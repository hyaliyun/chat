import{_ as m,o as s,c as n,a as t,m as d,t as _,C as h,M as g,U as b,f as l,F as x,p as y,e as v,q as w}from"./chunks/framework.B1z0IdBH.js";const q={name:"PoemCard",props:{poem:{type:Object,required:!0}}},k={class:"poem-container"},T={class:"review"},L={class:"review-title"},N={class:"review-content"};function A(i,e,u,c,r,a){return s(),n("div",k,[t("div",T,[t("div",L,[e[0]||(e[0]=t("span",{class:"icon"},"question:",-1)),d(_(u.poem.question),1)]),e[2]||(e[2]=t("div",{class:"divider"},null,-1)),t("p",N,[e[1]||(e[1]=t("span",{class:"icon"},"answer:",-1)),d(_(u.poem.solution),1)])])])}const R=m(q,[["render",A],["__scopeId","data-v-04fe5ec6"]]),j=JSON.parse(`[{"question":"def find_kth_number(k: int) -> int: Returns the k-th number in the defined sequence. >>> find_kth_number(1) 1 >>> find_kth_number(2) 2 >>> find_kth_number(3) 4 >>> find_kth_number(4) 8 >>> find_kth_number(5) 16 >>> find_kth_number(10) 512 >>> find_kth_number(20) 524288 >>> find_kth_number(30) 536870912 >>> find_kth_number(50) 562949953421312 >>> find_kth_number(100) 633825300114114700748351602688 >>> find_kth_number(100000) 2**99999","solution":"def find_kth_number(k): Returns the k-th number in the defined sequence. Parameters: k (int): The position of the desired number in the sequence (1-based). Returns: int: The k-th number in the sequence. # The sequence is of the form: 1, 2, 4, 8, 16, ... # Essentially, it's 2^(k-1), because at k=1 the number is 2^(1-1) = 1, # at k=2 the number is 2^(2-1) = 2, at k=3 the number is 2^(3-1) = 4, and so on. return 2**(k-1)"},{"question":"def is_valid_chocolate(grid): Function to determine if there exists at least one rectangular sub-grid composed entirely of 'C' in the given grid. Args: grid (list of list of str): A 2D list representing the chocolate grid containing 'C' and 'X'. Returns: str: \\"YES\\" if there exists a rectangular sub-grid composed entirely of 'C', otherwise \\"NO\\". >>> is_valid_chocolate([ ['C', 'C', 'C', 'C'], ['C', 'X', 'X', 'C'], ['C', 'X', 'X', 'C'], ['C', 'C', 'C', 'C'], ]) 'YES' >>> is_valid_chocolate([ ['C', 'X', 'C'] ]) 'YES' >>> is_valid_chocolate([ ['X', 'X', 'X'], ['X', 'X', 'X'], ]) 'NO' >>> is_valid_chocolate([ ['C', 'X', 'X'], ['X', 'X', 'X'], ['X', 'X', 'C'] ]) 'YES' >>> is_valid_chocolate([ ['X'] ]) 'NO' >>> is_valid_chocolate([ ['C', 'C', 'C'], ['C', 'C', 'C'], ['C', 'C', 'C'] ]) 'YES'","solution":"def is_valid_chocolate(grid): Function to determine if there exists at least one rectangular sub-grid composed entirely of 'C' in the given grid. Args: grid (list of list of str): A 2D list representing the chocolate grid containing 'C' and 'X'. Returns: str: \\"YES\\" if there exists a rectangular sub-grid composed entirely of 'C', otherwise \\"NO\\". n = len(grid) m = len(grid[0]) for i in range(n): for j in range(m): if grid[i][j] == 'C': # Check for 1x1 sub-grid first return \\"YES\\" return \\"NO\\""},{"question":"from typing import List, Tuple, Union def find_min_cost(k: int, l: int, connections: List[Tuple[int, int, int]]) -> Union[int, str]: Returns the minimal total cost to connect all the villages, or \\"Impossible\\" if it's not feasible. >>> find_min_cost(4, 5, [(1, 2, 5), (1, 3, 3), (2, 3, 7), (2, 4, 6), (3, 4, 4)]) 12 >>> find_min_cost(3, 3, [(1, 2, 1), (1, 3, 4), (2, 3, 2)]) 3 >>> find_min_cost(2, 1, [(1, 2, 10)]) 10 >>> find_min_cost(3, 0, []) 'Impossible' >>> find_min_cost(1, 0, []) 0 # Implement the function here def test_example1(): k, l = 4, 5 connections = [ (1, 2, 5), (1, 3, 3), (2, 3, 7), (2, 4, 6), (3, 4, 4) ] assert find_min_cost(k, l, connections) == 12 def test_example2(): k, l = 3, 3 connections = [ (1, 2, 1), (1, 3, 4), (2, 3, 2) ] assert find_min_cost(k, l, connections) == 3 def test_example3(): k, l = 2, 1 connections = [ (1, 2, 10) ] assert find_min_cost(k, l, connections) == 10 def test_example4(): k, l = 3, 0 connections = [] assert find_min_cost(k, l, connections) == \\"Impossible\\" def test_single_village(): k, l = 1, 0 connections = [] assert find_min_cost(k, l, connections) == 0 def test_all_villages_connected(): k, l = 4, 6 connections = [ (1, 2, 1), (1, 3, 2), (2, 3, 3), (3, 4, 4), (2, 4, 5), (1, 4, 6) ] assert find_min_cost(k, l, connections) == 7 def test_higher_cost_edge_irrelevant(): k, l = 4, 5 connections = [ (1, 2, 5), (1, 3, 3), (2, 3, 7), (2, 4, 6), (3, 4, 15) ] assert find_min_cost(k, l, connections) == 14","solution":"def find_min_cost(k, l, connections): Returns the minimal total cost to connect all the villages, or \\"Impossible\\" if it's not feasible. if k == 1: return 0 # Only one village, no cost needed parent = list(range(k+1)) def find(x): if parent[x] != x: parent[x] = find(parent[x]) return parent[x] def union(x, y): rootX = find(x) rootY = find(y) if rootX != rootY: parent[rootX] = rootY connections.sort(key=lambda x: x[2]) total_cost = 0 edges_used = 0 for x, y, c in connections: if find(x) != find(y): union(x, y) total_cost += c edges_used += 1 if edges_used == k - 1: return total_cost return \\"Impossible\\" # Usage example: # k, l = 4, 5 # connections = [ # (1, 2, 5), # (1, 3, 3), # (2, 3, 7), # (2, 4, 6), # (3, 4, 4) # ] # print(find_min_cost(k, l, connections)) # Output: 12"},{"question":"from typing import List def generate_groups_of_three(n: int, employees: List[str]) -> List[str]: Generates all unique groups of exactly 3 employees and outputs them sorted lexicographically. :param n: int, the number of employees :param employees: list of strings, names of employees :return: list of strings, each string representing a group of 3 employees >>> generate_groups_of_three(4, [\\"alice\\", \\"bob\\", \\"carol\\", \\"dave\\"]) [\\"alice bob carol\\", \\"alice bob dave\\", \\"alice carol dave\\", \\"bob carol dave\\"] >>> generate_groups_of_three(5, [\\"eve\\", \\"diana\\", \\"frank\\", \\"george\\", \\"harry\\"]) [\\"diana eve frank\\", \\"diana eve george\\", \\"diana eve harry\\", \\"diana frank george\\", \\"diana frank harry\\", \\"diana george harry\\", \\"eve frank george\\", \\"eve frank harry\\", \\"eve george harry\\", \\"frank george harry\\"]","solution":"from itertools import combinations def generate_groups_of_three(n, employees): Generates all unique groups of exactly 3 employees and outputs them sorted lexicographically. :param n: int, the number of employees :param employees: list of strings, names of employees :return: list of strings, each string representing a group of 3 employees employees.sort() groups = list(combinations(employees, 3)) return [' '.join(group) for group in groups]"},{"question":"def min_ones(N: int) -> int: Calculates the minimum number of ones (\\"1\\") needed to represent the number N using only addition and multiplication. >>> min_ones(1) 1 >>> min_ones(2) 2 >>> min_ones(6) 5 >>> min_ones(10) 7 >>> min_ones(100) 14","solution":"def min_ones(N): Calculates the minimum number of ones needed to represent the number N using only addition and multiplication. if N == 1: return 1 min_ones_list = [float('inf')] * (N + 1) min_ones_list[1] = 1 for i in range(2, N + 1): # Try to build \`i\` from addition min_ones_list[i] = min_ones_list[i-1] + 1 # Try to build \`i\` from multiplication for j in range(1, i//2 + 1): if i % j == 0: min_ones_list[i] = min(min_ones_list[i], min_ones_list[j] + min_ones_list[i//j]) return min_ones_list[N]"},{"question":"from typing import List from collections import deque def manage_queue(operations: List[str]) -> List[str]: Efficiently manage the customer service queue at a restaurant. Parameters: operations (List[str]): A list of operations to be performed on the queue. Returns: List[str]: A list of strings where each string is the state of the queue after a \\"STATUS\\" operation. Example: >>> manage_queue([ ... \\"ADD Alice\\", ... \\"ADD Bob\\", ... \\"STATUS\\", ... \\"SERVE\\", ... \\"STATUS\\", ... \\"ADD Charlie\\", ... \\"STATUS\\" ... ]) [\\"Alice Bob\\", \\"Bob\\", \\"Bob Charlie\\"] >>> manage_queue([ ... \\"ADD Alice\\", ... \\"SERVE\\", ... \\"SERVE\\", ... \\"STATUS\\", ... \\"ADD Bob\\" ... ]) [\\"EMPTY\\"] >>> manage_queue([ ... \\"STATUS\\", ... \\"ADD Alice\\", ... \\"STATUS\\" ... ]) [\\"EMPTY\\", \\"Alice\\"]","solution":"from collections import deque def manage_queue(operations): queue = deque() results = [] for operation in operations: if operation.startswith(\\"ADD\\"): _, customer = operation.split(maxsplit=1) queue.append(customer) elif operation == \\"SERVE\\": if queue: queue.popleft() elif operation == \\"STATUS\\": if queue: results.append(\\" \\".join(queue)) else: results.append(\\"EMPTY\\") return results"},{"question":"def sum_divisible_by_k(n: int, k: int, numbers: List[int]) -> int: Given a list of integers and a divisor k, return the sum of all integers in the list that are divisible by k. Args: n (int): The number of integers in the list. k (int): The divisor. numbers (list of int): The list of integers. Returns: int: The sum of integers divisible by k. >>> sum_divisible_by_k(5, 3, [1, 3, 6, 9, 12]) 30 >>> sum_divisible_by_k(4, 5, [2, 10, 15, 20]) 45 >>> sum_divisible_by_k(3, 7, [1, 2, 3]) 0","solution":"def sum_divisible_by_k(n, k, numbers): Given a list of integers and a divisor k, return the sum of all integers in the list that are divisible by k. Args: n (int): The number of integers in the list. k (int): The divisor. numbers (list of int): The list of integers. Returns: int: The sum of integers divisible by k. return sum(num for num in numbers if num % k == 0)"},{"question":"def evaluate_expression(expression: str) -> int: Evaluates a given arithmetic expression passed as a string and returns the result as an integer. Args: expression (str): A string containing a valid arithmetic expression. Returns: int: The evaluated result of the arithmetic expression. >>> evaluate_expression(\\"3 + 5 * 2\\") 13 >>> evaluate_expression(\\"10 + 2 * (6 / 2)\\") 16 >>> evaluate_expression(\\"(2 + 3) * 4\\") 20 >>> evaluate_expression(\\"7 + (6 * 5^2 + 3 - 4/2)\\") 160 pass # Unit tests def test_evaluate_expression_simple_addition(): assert evaluate_expression(\\"3 + 5\\") == 8 def test_evaluate_expression_with_precedence(): assert evaluate_expression(\\"3 + 5 * 2\\") == 13 def test_evaluate_expression_with_parentheses(): assert evaluate_expression(\\"10 + 2 * (6 / 2)\\") == 16 def test_evaluate_expression_nested_parentheses(): assert evaluate_expression(\\"(2 + 3) * 4\\") == 20 def test_evaluate_expression_complex(): assert evaluate_expression(\\"7 + (6 * 5 * 2 + 3 - 4 / 2)\\") == 68 def test_evaluate_expression_division(): assert evaluate_expression(\\"10 / 2\\") == 5 def test_evaluate_expression_subtraction(): assert evaluate_expression(\\"10 - 4\\") == 6 def test_evaluate_expression_multiple_operators(): assert evaluate_expression(\\"3 + 5 * 2 - 8 / 2\\") == 9 def test_evaluate_expression_mixed_operators(): assert evaluate_expression(\\"14 + 2 * (3 + 4) - 5\\") == 23 # Running the tests if __name__ == \\"__main__\\": import pytest pytest.main([__file__])","solution":"def evaluate_expression(expression): Evaluates a given arithmetic expression passed as a string and returns the result as an integer. def parse_expression(expr): stack = [] num = 0 sign = '+' i = 0 while i < len(expr): char = expr[i] if char.isdigit(): num = num * 10 + int(char) if char == '(': j = i braces = 0 for j in range(i, len(expr)): if expr[j] == '(': braces += 1 if expr[j] == ')': braces -= 1 if braces == 0: break num = parse_expression(expr[i + 1:j]) i = j if char in '+-*/' or i == len(expr) - 1: if sign == '+': stack.append(num) elif sign == '-': stack.append(-num) elif sign == '*': stack.append(stack.pop() * num) elif sign == '/': stack.append(int(stack.pop() / num)) sign = char num = 0 i += 1 return sum(stack) return parse_expression(expression)"},{"question":"def calculate_trapped_water(building_heights): Calculate the total amount of trapped water given the heights of the buildings. >>> calculate_trapped_water([3, 0, 0, 2, 0, 4]) 10 >>> calculate_trapped_water([1, 0, 2]) 1 >>> calculate_trapped_water([3, 3, 3]) 0 def process_test_cases(test_cases): Process multiple test cases for the trapped water calculation. >>> test_cases = [(6, [3, 0, 0, 2, 0, 4]), (3, [1, 0, 2])] >>> process_test_cases(test_cases) ['Case 1: 10', 'Case 2: 1'] >>> test_cases = [(3, [1, 1, 1]), (0, []), (6, [0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1])] >>> process_test_cases(test_cases) ['Case 1: 0', 'Case 2: 0', 'Case 3: 6']","solution":"def calculate_trapped_water(building_heights): if not building_heights or len(building_heights) < 3: return 0 n = len(building_heights) left_max = [0] * n right_max = [0] * n # Compute the max heights to the left of each building. left_max[0] = building_heights[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], building_heights[i]) # Compute the max heights to the right of each building. right_max[n - 1] = building_heights[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], building_heights[i]) # Calculate the trapped water. total_water = 0 for i in range(n): trapped_water = min(left_max[i], right_max[i]) - building_heights[i] if trapped_water > 0: total_water += trapped_water return total_water def process_test_cases(test_cases): results = [] for idx, (n, heights) in enumerate(test_cases): if n == 0: results.append(f\\"Case {idx + 1}: 0\\") else: total_water = calculate_trapped_water(heights) results.append(f\\"Case {idx + 1}: {total_water}\\") return results"},{"question":"from typing import List, Tuple def most_frequent_product_by_category(N: int, M: int, product_list: List[Tuple[int, int]]) -> List[int]: Given the number of products, number of categories, and a list of product-category pairs, find the most frequent product ID for each category. In case of a tie, return the smallest product ID. If there are no products in a category, return -1. >>> most_frequent_product_by_category(7, 3, [(1, 1), (2, 1), (3, 2), (1, 1), (2, 2), (3, 2), (3, 3)]) [1, 3, 3] >>> most_frequent_product_by_category(1, 1, [(1, 1)]) [1] >>> most_frequent_product_by_category(3, 3, [(1, 1), (2, 2), (3, 3)]) [1, 2, 3] >>> most_frequent_product_by_category(5, 2, [(1, 1), (1, 1), (2, 1), (3, 2), (3, 2)]) [1, 3] >>> most_frequent_product_by_category(6, 2, [(1, 1), (2, 1), (1, 1), (2, 1), (3, 2), (3, 2)]) [1, 3] >>> most_frequent_product_by_category(3, 3, [(1, 1), (2, 1), (3, 2)]) [1, 3, -1] >>> most_frequent_product_by_category(100000, 10, [(i % 100 + 1, i % 10 + 1) for i in range(100000)]) [... (Expected output based on implementation)]","solution":"from collections import defaultdict, Counter def most_frequent_product_by_category(N, M, product_list): category_product_count = defaultdict(Counter) for product_id, category_id in product_list: category_product_count[category_id][product_id] += 1 results = [] for category_id in range(1, M + 1): if category_id in category_product_count: max_frequency = max(category_product_count[category_id].values()) max_freq_products = [product_id for product_id, count in category_product_count[category_id].items() if count == max_frequency] results.append(min(max_freq_products)) else: results.append(-1) # Assuming there can be empty categories, denoted by -1 or any other placeholder return results"},{"question":"def max_duration_within_k_sessions(n: int, durations: List[int], k: int) -> int: Returns the maximum duration of any single running session within any sliding window of k consecutive training sessions. >>> max_duration_within_k_sessions(5, [10, 20, 30, 40, 50], 3) 50 >>> max_duration_within_k_sessions(6, [15, 14, 13, 12, 11, 10], 2) 15","solution":"def max_duration_within_k_sessions(n, durations, k): Returns the maximum duration of any single running session within any sliding window of k consecutive training sessions. max_duration = 0 for i in range(n - k + 1): current_max = max(durations[i:i + k]) max_duration = max(max_duration, current_max) return max_duration"},{"question":"import typing from typing import List def flip_game(m: int, n: int, grid: List[str], k: int) -> List[str]: Returns the state of the grid after k moves. >>> flip_game(3, 3, [\\"XOX\\", \\"OOX\\", \\"XOX\\"], 1) == [\\"OXO\\", \\"XXO\\", \\"OXO\\"] >>> flip_game(2, 2, [\\"OX\\", \\"XO\\"], 2) == [\\"OX\\", \\"XO\\"]","solution":"def flip_game(m, n, grid, k): Returns the state of the grid after k moves. # The grid state after k moves is the same as the original grid # if k is even, and flipped once if k is odd. # Flipping once means converting 'X' to 'O' and 'O' to 'X'. if k % 2 == 0: return grid else: return [''.join('O' if cell == 'X' else 'X' for cell in row) for row in grid] # Example usage: # m, n = 3, 3 # grid = [\\"XOX\\", \\"OOX\\", \\"XOX\\"] # k = 1 # result = flip_game(m, n, grid, k) # for row in result: # print(row)"},{"question":"from typing import List, Tuple def count_peak_employees(n: int, times: List[Tuple[str, str]]) -> int: Calculates the total number of unique employees logged in at peak time. >>> count_peak_employees(3, [(\\"09:00\\", \\"10:30\\"), (\\"10:00\\", \\"11:00\\"), (\\"10:15\\", \\"10:45\\")]) 3 >>> count_peak_employees(2, [(\\"08:00\\", \\"12:00\\"), (\\"09:30\\", \\"10:00\\")]) 2","solution":"from collections import defaultdict def count_peak_employees(n, times): events = [] for login, logout in times: events.append((login, 1)) # 1 for login events.append((logout, -1)) # -1 for logout # Sort the events by time events.sort() current_employees = 0 max_employees = 0 for time, event in events: current_employees += event max_employees = max(max_employees, current_employees) return max_employees"},{"question":"def solve(N, M, edges): Determine the optimal ProcessingUnit to start a distributed computation such that the maximum transmission time from the starting ProcessingUnit to any other ProcessingUnit in the network is minimized. Args: N : int : Number of ProcessingUnits M : int : Number of communication links edges : List[Tuple[int, int, int]] : List of communication links and their time costs Returns: int : Minimum possible maximum transmission time >>> solve(6, 7, [(0, 1, 3), (0, 2, 2), (1, 2, 4), (1, 3, 6), (2, 3, 1), (3, 4, 5), (4, 5, 2)]) 7 >>> solve(3, 3, [(0, 1, 4), (1, 2, 3), (0, 2, 5)]) 4 >>> solve(4, 4, [(0, 1, 1000), (1, 2, 1000), (2, 3, 1000), (3, 0, 1000)]) 2000 >>> solve(4, 2, [(0, 1, 5), (2, 3, 5)]) inf","solution":"import heapq import sys def dijkstra(N, graph, start): distances = [float('inf')] * N distances[start] = 0 priority_queue = [(0, start)] while priority_queue: current_distance, current_vertex = heapq.heappop(priority_queue) if current_distance > distances[current_vertex]: continue for neighbor, weight in graph[current_vertex]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return distances def find_optimal_unit(N, M, edges): graph = [[] for _ in range(N)] for U, V, W in edges: graph[U].append((V, W)) graph[V].append((U, W)) min_max_distance = float('inf') for i in range(N): max_distance = max(dijkstra(N, graph, i)) if max_distance < min_max_distance: min_max_distance = max_distance return min_max_distance # Parse input def solve(N, M, edges): return find_optimal_unit(N, M, edges)"},{"question":"def get_count_of_valid_chime_patterns(n: int, chime_patterns: List[str]) -> int: Determine the number of chime patterns that follow the rule where the number of consecutive 'Tick' chimes is always greater than the number of consecutive 'Tock' chimes. >>> get_count_of_valid_chime_patterns(1, [\\"Tick Tick Tock Tick\\"]) 1 >>> get_count_of_valid_chime_patterns(1, [\\"Tick Tock Tick Tock Tock\\"]) 0 >>> get_count_of_valid_chime_patterns(4, [\\"Tick Tick Tock Tick Tick Tock\\", \\"Tick Tick Tick Tock Tock\\", \\"Tick Tock Tick Tock Tick Tock\\", \\"Tick Tick Tick Tock Tick Tock\\"]) 2 >>> get_count_of_valid_chime_patterns(4, [\\"Tick Tick Tock\\", \\"Tick Tick Tock Tick\\", \\"Tick Tick Tick\\", \\"Tick Tick Tock Tick Tick\\"]) 4 >>> get_count_of_valid_chime_patterns(4, [\\"Tick Tock Tock\\", \\"Tick Tock Tick Tock\\", \\"Tock Tick\\", \\"Tick Tock Tock Tick\\"]) 0","solution":"def follows_chime_rule(pattern): chimes = pattern.split() n = len(chimes) i = 0 while i < n: tick_count = 0 tock_count = 0 while i < n and chimes[i] == 'Tick': tick_count += 1 i += 1 while i < n and chimes[i] == 'Tock': tock_count += 1 i += 1 if tick_count <= tock_count: return False return True def count_valid_patterns(n, patterns): valid_count = 0 for pattern in patterns: if follows_chime_rule(pattern): valid_count += 1 return valid_count def get_count_of_valid_chime_patterns(n, chime_patterns): return count_valid_patterns(n, chime_patterns)"},{"question":"from typing import List, Tuple def can_reach_all_intersections(N: int, M: int, roads: List[Tuple[int, int]]) -> str: Determines if there exists a path from intersection 1 to every other intersection. Parameters: N (int): Number of intersections M (int): Number of one-way roads roads (list of tuples): Each tuple (u, v) represents a one-way road from u to v Returns: str: \\"YES\\" if there exists a path from intersection 1 to every other intersection, otherwise \\"NO\\". pass def test_example_1(): N, M = 6, 7 roads = [ (1, 2), (2, 3), (3, 4), (1, 5), (5, 6), (3, 1), (5, 3) ] assert can_reach_all_intersections(N, M, roads) == \\"YES\\" def test_example_2(): N, M = 6, 5 roads = [ (1, 2), (2, 3), (3, 4), (1, 5), (6, 5) ] assert can_reach_all_intersections(N, M, roads) == \\"NO\\" def test_single_node(): N, M = 1, 0 roads = [] assert can_reach_all_intersections(N, M, roads) == \\"YES\\" def test_disconnected_graph(): N, M = 4, 2 roads = [ (1, 2), (3, 4) ] assert can_reach_all_intersections(N, M, roads) == \\"NO\\" def test_fully_connected(): N, M = 4, 6 roads = [ (1, 2), (2, 3), (3, 4), (4, 1), (2, 4), (3, 1) ] assert can_reach_all_intersections(N, M, roads) == \\"YES\\"","solution":"from collections import deque def can_reach_all_intersections(N, M, roads): Determines if there exists a path from intersection 1 to every other intersection. Parameters: N (int): Number of intersections M (int): Number of one-way roads roads (list of tuples): Each tuple (u, v) represents a one-way road from u to v Returns: str: \\"YES\\" if there exists a path from intersection 1 to every other intersection, otherwise \\"NO\\". graph = {i: [] for i in range(1, N + 1)} for u, v in roads: graph[u].append(v) visited = set() queue = deque([1]) while queue: node = queue.popleft() if node in visited: continue visited.add(node) for neighbor in graph[node]: if neighbor not in visited: queue.append(neighbor) return \\"YES\\" if len(visited) == N else \\"NO\\""},{"question":"def generate_column_constant_matrix(n, m, e): Generate an n x n column-constant matrix where the elements are the first n elements of a sequence modulo m, and the first element of the sequence is e. Args: n (int): the size of the matrix. m (int): the modulo value. e (int): the starting element of the sequence. Returns: list of list of int: the generated column-constant matrix. pass # Example tests def test_example_case_1(): result = generate_column_constant_matrix(3, 5, 2) expected = [ [2, 2, 2], [3, 3, 3], [4, 4, 4] ] assert result == expected def test_example_case_2(): result = generate_column_constant_matrix(4, 10, 6) expected = [ [6, 6, 6, 6], [7, 7, 7, 7], [8, 8, 8, 8], [9, 9, 9, 9] ] assert result == expected def test_minimum_size(): result = generate_column_constant_matrix(1, 1, 0) expected = [ [0] ] assert result == expected def test_wrap_around_modulo(): result = generate_column_constant_matrix(3, 3, 2) expected = [ [2, 2, 2], [0, 0, 0], [1, 1, 1] ] assert result == expected def test_diff_starting_element(): result = generate_column_constant_matrix(3, 5, 0) expected = [ [0, 0, 0], [1, 1, 1], [2, 2, 2] ] assert result == expected def test_large_values(): result = generate_column_constant_matrix(5, 100, 99) expected = [ [99, 99, 99, 99, 99], [0, 0, 0, 0, 0], [1, 1, 1, 1, 1], [2, 2, 2, 2, 2], [3, 3, 3, 3, 3] ] assert result == expected","solution":"def generate_column_constant_matrix(n, m, e): Generate an n x n column-constant matrix where the elements are the first n elements of a sequence modulo m, and the first element of the sequence is e. Args: n (int): the size of the matrix. m (int): the modulo value. e (int): the starting element of the sequence. Returns: list of list of int: the generated column-constant matrix. matrix = [] for i in range(n): row = [(e + i) % m] * n matrix.append(row) return matrix"},{"question":"def find_knight_positions(n: int) -> List[List[int]]: Returns an n x n chessboard grid with valid knight positions marked as 1 and invalid positions as 0. >>> find_knight_positions(3) [[1, 0, 1], [0, 0, 0], [1, 0, 1]] >>> find_knight_positions(4) [[1, 0, 1, 0], [0, 0, 0, 0], [1, 0, 1, 0], [0, 0, 0, 0]] >>> find_knight_positions(5) [[1, 0, 1, 0, 1], [0, 0, 0, 0, 0], [1, 0, 1, 0, 1], [0, 0, 0, 0, 0], [1, 0, 1, 0, 1]] >>> find_knight_positions(6) [[1, 0, 1, 0, 1, 0], [0, 0, 0, 0, 0, 0], [1, 0, 1, 0, 1, 0], [0, 0, 0, 0, 0, 0], [1, 0, 1, 0, 1, 0], [0, 0, 0, 0, 0, 0]] >>> find_knight_positions(7) [[1, 0, 1, 0, 1, 0, 1], [0, 0, 0, 0, 0, 0, 0], [1, 0, 1, 0, 1, 0, 1], [0, 0, 0, 0, 0, 0, 0], [1, 0, 1, 0, 1, 0, 1], [0, 0, 0, 0, 0, 0, 0], [1, 0, 1, 0, 1, 0, 1]] pass from solution import find_knight_positions def test_find_knight_positions_3x3(): result = find_knight_positions(3) expected = [ [1, 0, 1], [0, 0, 0], [1, 0, 1] ] assert result == expected def test_find_knight_positions_4x4(): result = find_knight_positions(4) expected = [ [1, 0, 1, 0], [0, 0, 0, 0], [1, 0, 1, 0], [0, 0, 0, 0] ] assert result == expected def test_find_knight_positions_5x5(): result = find_knight_positions(5) expected = [ [1, 0, 1, 0, 1], [0, 0, 0, 0, 0], [1, 0, 1, 0, 1], [0, 0, 0, 0, 0], [1, 0, 1, 0, 1] ] assert result == expected def test_find_knight_positions_6x6(): result = find_knight_positions(6) expected = [ [1, 0, 1, 0, 1, 0], [0, 0, 0, 0, 0, 0], [1, 0, 1, 0, 1, 0], [0, 0, 0, 0, 0, 0], [1, 0, 1, 0, 1, 0], [0, 0, 0, 0, 0, 0] ] assert result == expected def test_find_knight_positions_7x7(): result = find_knight_positions(7) expected = [ [1, 0, 1, 0, 1, 0, 1], [0, 0, 0, 0, 0, 0, 0], [1, 0, 1, 0, 1, 0, 1], [0, 0, 0, 0, 0, 0, 0], [1, 0, 1, 0, 1, 0, 1], [0, 0, 0, 0, 0, 0, 0], [1, 0, 1, 0, 1, 0, 1] ] assert result == expected","solution":"def find_knight_positions(n): Returns an n x n chessboard grid with valid knight positions marked as 1 and invalid positions as 0. board = [[0 for _ in range(n)] for _ in range(n)] for i in range(0, n, 2): for j in range(0, n, 2): # Mark position (i, j) as valid board[i][j] = 1 return board"},{"question":"def row_sums_after_steps(m: int, n: int, k: int, steps: List[Tuple[int, int, int]]) -> List[int]: You are given a grid of size m rows and n columns initially filled with zeros. There are k steps to perform. In each step, you are given three integers ri, ci, and xi (1 ≤ ri ≤ m, 1 ≤ ci ≤ n, 1 ≤ xi ≤ 1,000,000), which denote that the cell at row ri and column ci will be set to the value xi. After applying all the steps, you need to find the sum of each row in the grid. >>> row_sums_after_steps(3, 3, 4, [(1, 1, 5), (2, 2, 3), (3, 3, 10), (2, 1, 4)]) [5, 7, 10] >>> row_sums_after_steps(2, 2, 3, [(1, 2, 2), (2, 1, 8), (1, 1, 3)]) [5, 8] >>> row_sums_after_steps(2, 3, 1, [(1, 1, 10)]) [10, 0] >>> row_sums_after_steps(2, 2, 2, [(1, 1, 5), (1, 1, 7)]) [7, 0] >>> row_sums_after_steps(3, 3, 0, []) [0, 0, 0] >>> row_sums_after_steps(3, 3, 9, [ ... (1, 1, 1), (1, 2, 2), (1, 3, 3), ... (2, 1, 4), (2, 2, 5), (2, 3, 6), ... (3, 1, 7), (3, 2, 8), (3, 3, 9) ... ]) [6, 15, 24] >>> row_sums_after_steps(2, 2, 2, [(1, 1, 1000000), (2, 2, 1000000)]) [1000000, 1000000]","solution":"def row_sums_after_steps(m, n, k, steps): # Initialize the grid with zeros grid = [[0] * n for _ in range(m)] # Apply each step for ri, ci, xi in steps: grid[ri - 1][ci - 1] = xi # Compute the sum for each row row_sums = [sum(row) for row in grid] return row_sums"},{"question":"from typing import List def shortest_path(grid: List[List[int]]) -> int: Find the length of the shortest path from the top-left corner to the bottom-right corner of a grid. You can only move up, down, left, or right at each step. Return -1 if there is no valid path. >>> shortest_path([ ... [0, 0, 0], ... [1, 1, 0], ... [0, 0, 0] ... ]) 5 >>> shortest_path([ ... [0, 1, 0], ... [1, 1, 0], ... [0, 1, 0] ... ]) -1 pass def parse_input(input_data: str) -> List[int]: Parse the input data to extract grids and compute the shortest path lengths. >>> input_data = '''3 3 ... 0 0 0 ... 1 1 0 ... 0 0 0 ... 4 4 ... 0 1 0 0 ... 0 1 0 1 ... 0 1 0 0 ... 0 0 0 0 ... 0 0''' >>> parse_input(input_data) [5, 7] pass","solution":"from collections import deque def shortest_path(grid): # Check if the grid is empty if not grid or not grid[0]: return -1 n, m = len(grid), len(grid[0]) # If start or destination is blocked if grid[0][0] == 1 or grid[n-1][m-1] == 1: return -1 directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] queue = deque([(0, 0, 1)]) # (row, col, distance) visited = set((0, 0)) while queue: r, c, d = queue.popleft() if r == n-1 and c == m-1: return d for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < n and 0 <= nc < m and grid[nr][nc] == 0 and (nr, nc) not in visited: visited.add((nr, nc)) queue.append((nr, nc, d+1)) return -1 def parse_input(input_data): input_lines = input_data.splitlines() index = 0 results = [] while index < len(input_lines): line = input_lines[index].strip() if line == '0 0': break n, m = map(int, line.split()) grid = [] for i in range(n): index += 1 row = list(map(int, input_lines[index].strip().split())) grid.append(row) index += 1 results.append(shortest_path(grid)) return results"},{"question":"def distinct_subsequences(s: str) -> int: Returns the number of distinct subsequences that can be formed from the input string s. Args: s (str): The input string containing only English letters and digits. Returns: int: The number of distinct subsequences that can be formed from the input string s. Example usage: >>> distinct_subsequences(\\"abc\\") 8 >>> distinct_subsequences(\\"aba\\") 7 pass # Unit Test def test_distinct_subsequences_example1(): assert distinct_subsequences(\\"abc\\") == 8 def test_distinct_subsequences_example2(): assert distinct_subsequences(\\"aba\\") == 7 def test_distinct_subsequences_single_character(): assert distinct_subsequences(\\"a\\") == 2 def test_distinct_subsequences_all_same_characters(): assert distinct_subsequences(\\"aaa\\") == 4 def test_distinct_subsequences_mixed_characters(): assert distinct_subsequences(\\"a1b2\\") == 16 def test_distinct_subsequences_empty_string(): assert distinct_subsequences(\\"\\") == 1 def test_distinct_subsequences_long_string(): assert distinct_subsequences(\\"abcdefg1234567\\") == 2**14","solution":"def distinct_subsequences(s): Returns the number of distinct subsequences that can be formed from the input string s. # Using a set to track distinct subsequences subsequences = {\\"\\"} for char in s: new_subsequences = {sub + char for sub in subsequences} subsequences.update(new_subsequences) return len(subsequences)"},{"question":"def longest_increasing_subarray(arr: List[int]) -> int: Returns the length of the longest subarray with elements in strictly increasing order. >>> longest_increasing_subarray([1, 3, 2, 3, 4, 7, 9, 1, 4, 5]) == 5 >>> longest_increasing_subarray([5]) == 1 >>> longest_increasing_subarray([1, 2, 3, 4, 5, 6, 7, 8, 9]) == 9 >>> longest_increasing_subarray([9, 8, 7, 6, 5, 4, 3, 2, 1]) == 1 >>> longest_increasing_subarray([10, 20, 10, 30, 40, 50, 60, 70]) == 6 >>> longest_increasing_subarray([]) == 0 >>> longest_increasing_subarray([3, 3, 3, 3, 3]) == 1 >>> longest_increasing_subarray([1, 2, 1, 2, 1, 2, 1, 2]) == 2 >>> longest_increasing_subarray([1, 1, 1, 1, 1]) == 1","solution":"def longest_increasing_subarray(arr): Returns the length of the longest subarray with elements in strictly increasing order. if not arr: return 0 max_length = 1 current_length = 1 for i in range(1, len(arr)): if arr[i] > arr[i-1]: current_length += 1 max_length = max(max_length, current_length) else: current_length = 1 return max_length"},{"question":"from typing import List def most_frequent_books(n: int, book_ids: List[int]) -> List[int]: Finds the most frequently occurring book IDs in a list of book orders. Parameters: - n (int): Number of books ordered. - book_ids (list of int): List of ordered book IDs. Returns: - list of int: Book IDs that are the most frequently ordered, sorted in ascending order. >>> most_frequent_books(7, [1, 2, 2, 3, 3, 3, 4]) [3] >>> most_frequent_books(10, [1, 1, 2, 2, 3, 3, 4, 4, 5, 5]) [1, 2, 3, 4, 5]","solution":"def most_frequent_books(n, book_ids): Finds the most frequently occurring book IDs in a list of book orders. Parameters: - n (int): Number of books ordered. - book_ids (list of int): List of ordered book IDs. Returns: - list of int: Book IDs that are the most frequently ordered, sorted in ascending order. from collections import Counter count = Counter(book_ids) max_frequency = max(count.values()) # Collect book_ids with max_frequency most_frequent = [book_id for book_id, freq in count.items() if freq == max_frequency] # Sort the result in ascending order return sorted(most_frequent)"},{"question":"def min_delivery_cost(n: int, grid: List[List[int]]) -> int: Returns the minimum cost to deliver a package from the top-left to the bottom-right of the grid. >>> min_delivery_cost(3, [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) 21 >>> min_delivery_cost(2, [[1, 2], [1, 1]]) 3 pass # Test cases to validate the solution def test_min_delivery_cost_example1(): n = 3 grid = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] assert min_delivery_cost(n, grid) == 21 def test_min_delivery_cost_example2(): n = 2 grid = [ [1, 2], [1, 1] ] assert min_delivery_cost(n, grid) == 3 def test_min_delivery_cost_one_cell(): n = 1 grid = [[5]] assert min_delivery_cost(n, grid) == 5 def test_min_delivery_cost_all_same(): n = 3 grid = [ [1, 1, 1], [1, 1, 1], [1, 1, 1] ] assert min_delivery_cost(n, grid) == 5 def test_min_delivery_cost_varied_costs(): n = 4 grid = [ [1, 3, 5, 8], [4, 2, 1, 7], [4, 3, 2, 3], [5, 6, 1, 2] ] assert min_delivery_cost(n, grid) == 12","solution":"def min_delivery_cost(n, grid): Returns the minimum cost to deliver a package from the top-left to the bottom-right of the grid. # Create a 2D list to store the minimum cost to reach each cell dp = [[0] * n for _ in range(n)] # Initialize the first cell with the cost of the starting point dp[0][0] = grid[0][0] # Fill the first row (can only come from the left) for i in range(1, n): dp[0][i] = dp[0][i-1] + grid[0][i] # Fill the first column (can only come from above) for i in range(1, n): dp[i][0] = dp[i-1][0] + grid[i][0] # Fill the rest of the dp table for i in range(1, n): for j in range(1, n): dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j] # The answer is in the bottom right cell return dp[n-1][n-1]"},{"question":"def get_ranks(scores: List[int]) -> List[int]: Determines the rank for each student based on their score. >>> get_ranks([100, 90, 100, 70, 90]) [1, 3, 1, 5, 3] >>> get_ranks([85, 85, 85]) [1, 1, 1] >>> get_ranks([50]) [1] >>> get_ranks([10, 20, 30, 40, 50]) [5, 4, 3, 2, 1] >>> get_ranks([100, 100, 100, 100]) [1, 1, 1, 1] >>> get_ranks([70, 50, 80, 80, 60]) [3, 5, 1, 1, 4] >>> get_ranks([100, 90, 80, 70, 60]) [1, 2, 3, 4, 5] >>> get_ranks([60, 70, 80, 90, 100]) [5, 4, 3, 2, 1]","solution":"def get_ranks(scores): Determines the rank for each student based on their score. sorted_scores = sorted(scores, reverse=True) ranks = {} rank = 1 for i, score in enumerate(sorted_scores): if score not in ranks: ranks[score] = rank rank += 1 return [ranks[score] for score in scores] # Example usage (this would be replaced or removed before actual deployment, as per required): # scores = [100, 90, 100, 70, 90] # print(get_ranks(scores)) # Output should be: [1, 3, 1, 5, 3]"},{"question":"def update_unique_fruits(n: int, weeks: List[str]) -> List[str]: Processes the weekly records of fruits and returns a list of results, each containing the new fruits introduced that week followed by the new total number of unique fruits. Parameters: n (int): Number of weeks weeks (list of str): List of strings where each string represents fruits brought in a week Returns: list of str: List of results for each week as specified. from typing import List # Unit Tests def test_single_week_multiple_unique_fruits(): assert update_unique_fruits(1, [\\"apple banana orange\\"]) == [\\"apple banana orange 3\\"] def test_multiple_weeks_some_repeated_fruits(): assert update_unique_fruits(2, [\\"apple banana orange\\", \\"banana grape orange\\"]) == [\\"apple banana orange 3\\", \\"grape 4\\"] def test_multiple_weeks_with_all_repeated_fruits(): assert update_unique_fruits(3, [\\"apple mango\\", \\"mango banana\\", \\"banana apple mango\\"]) == [\\"apple mango 2\\", \\"banana 3\\", \\"3\\"] def test_empty_week_input(): assert update_unique_fruits(0, []) == [] def test_all_weeks_no_new_fruits(): assert update_unique_fruits(3, [\\"apple\\", \\"apple\\", \\"apple\\"]) == [\\"apple 1\\", \\"1\\", \\"1\\"] def test_mixed_weeks_with_partially_repeated_fruits(): assert update_unique_fruits(3, [\\"apple mango orange\\", \\"mango grape\\", \\"pineapple grape\\"]) == [\\"apple mango orange 3\\", \\"grape 4\\", \\"pineapple 5\\"]","solution":"def update_unique_fruits(n, weeks): Processes the weekly records of fruits and returns a list of results, each containing the new fruits introduced that week followed by the new total number of unique fruits. Parameters: n (int): Number of weeks weeks (list of str): List of strings where each string represents fruits brought in a week Returns: list of str: List of results for each week as specified. unique_fruits = set() results = [] for week in weeks: fruits = week.split() new_fruits = [] for fruit in fruits: if fruit not in unique_fruits: unique_fruits.add(fruit) new_fruits.append(fruit) if new_fruits: results.append(\\" \\".join(new_fruits) + \\" \\" + str(len(unique_fruits))) else: results.append(str(len(unique_fruits))) return results"},{"question":"def max_coins(n: int, coins: List[int], keys: List[int]) -> int: Determine the maximum number of gold coins that can be collected in the process. >>> max_coins(5, [10, 20, 30, 40, 50], [2, 3, 4, 5, 5]) 150 >>> max_coins(4, [1, 2, 3, 4], [2, 3, 4, 4]) 10","solution":"def max_coins(n, coins, keys): visited = [False] * n coins_collected = 0 current_room = 0 # Starting from room 1, indexed by 0 while not visited[current_room]: coins_collected += coins[current_room] visited[current_room] = True current_room = keys[current_room] - 1 # Move to the next room return coins_collected"},{"question":"def findCombinations(arr: List[int], target: int) -> List[List[int]]: Given an integer array and a target number, find all unique combinations of elements in the array where the sum is equal to the target number. Each number in the array may be used unlimited times in the combination. The solution set must not contain duplicate combinations. >>> findCombinations([2, 3, 6, 7], 7) [[2, 2, 3], [7]] >>> findCombinations([2, 3, 5], 8) [[2, 2, 2, 2], [2, 3, 3], [3, 5]]","solution":"def findCombinations(arr, target): def backtrack(start, path, target): if target == 0: result.append(path) return if target < 0: return for i in range(start, len(arr)): backtrack(i, path + [arr[i]], target - arr[i]) result = [] arr.sort() backtrack(0, [], target) return result"},{"question":"def find_peak_element(nums: List[int]) -> int: Finds the index of a peak element in a sorted array of distinct integers. >>> find_peak_element([1, 2, 3, 1]) 2 >>> find_peak_element([1, 3, 20, 4, 1, 0]) 2 >>> find_peak_element([10, 9, 8, 7, 6, 5, 4, 3, 2, 1]) 0","solution":"from typing import List def find_peak_element(nums: List[int]) -> int: Finds the index of a peak element in a sorted array of distinct integers. left, right = 0, len(nums) - 1 while left < right: mid = (left + right) // 2 if nums[mid] < nums[mid + 1]: left = mid + 1 else: right = mid return left"},{"question":"def create_theater(n, m): Initializes a theater with all seats available. :param n: Number of rows :param m: Number of columns :return: 2D list representing the theater seating arrangement return [['A' for _ in range(m)] for _ in range(n)] def process_booking_commands(n, m, commands): Processes a series of booking and cancellation commands. :param n: Number of rows :param m: Number of columns :param commands: List of commands to process :return: The final seating arrangement as a 2D list def print_seating_arrangement(theater): Prints the seating arrangement as a grid. :param theater: 2D array representing the theater seating arrangement # Example usage: n, m = 3, 3 commands = [ \\"book 1 1\\", \\"book 2 2\\", \\"book 1 1\\", \\"cancel 2 2\\", \\"book 3 3\\" ] theater = process_booking_commands(n, m, commands) print_seating_arrangement(theater)","solution":"def create_theater(n, m): Initializes a theater with all seats available. :param n: Number of rows :param m: Number of columns :return: 2D list representing the theater seating arrangement return [['A' for _ in range(m)] for _ in range(n)] def process_booking_commands(n, m, commands): Processes a series of booking and cancellation commands. :param n: Number of rows :param m: Number of columns :param commands: List of commands to process :return: The final seating arrangement as a 2D list theater = create_theater(n, m) for command in commands: cmd, x, y = command.split() x, y = int(x) - 1, int(y) - 1 # Convert to zero-based indexing if 0 <= x < n and 0 <= y < m: # Check if position is within bounds if cmd == \\"book\\" and theater[x][y] == 'A': theater[x][y] = 'R' elif cmd == \\"cancel\\" and theater[x][y] == 'R': theater[x][y] = 'A' return theater def print_seating_arrangement(theater): Prints the seating arrangement as a grid. :param theater: 2D array representing the theater seating arrangement for row in theater: print(\\" \\".join(row)) # Example usage: n, m = 3, 3 commands = [ \\"book 1 1\\", \\"book 2 2\\", \\"book 1 1\\", \\"cancel 2 2\\", \\"book 3 3\\" ] theater = process_booking_commands(n, m, commands) print_seating_arrangement(theater)"},{"question":"def subarray_sum(nums, k): Determines if there is a contiguous subarray whose sum is exactly k. Args: nums (list): List of integers. k (int): Target sum for contiguous subarray. Returns: str: \\"Yes\\" if such a subarray exists, otherwise \\"No\\". >>> subarray_sum([1, 2, 3, 7, 5], 12) \\"Yes\\" >>> subarray_sum([1, 2, 3, 4, 5], 20) \\"No\\" >>> subarray_sum([5], 5) \\"Yes\\" >>> subarray_sum([5], 10) \\"No\\" >>> subarray_sum([1, 2, 3, 4, 5, 5], 5) \\"Yes\\" >>> subarray_sum([-1, 2, 3, -4, 5], 1) \\"Yes\\" >>> subarray_sum([1,2,3,4,5,400,500,250,100], 750) \\"Yes\\" >>> subarray_sum([1, 2, 3, 4, 5], 15) \\"Yes\\" >>> subarray_sum([1, 2, 3, 4, 5], -10) \\"No\\" >>> subarray_sum([], 0) \\"No\\"","solution":"def subarray_sum(nums, k): Determines if there is a contiguous subarray whose sum is exactly k. Args: nums (list): List of integers. k (int): Target sum for contiguous subarray. Returns: str: \\"Yes\\" if such a subarray exists, otherwise \\"No\\". current_sum = 0 sum_indices = {0: -1} # Initialize with 0 sum at index -1 to handle prefix sum for i, num in enumerate(nums): current_sum += num if (current_sum - k) in sum_indices: return \\"Yes\\" if current_sum not in sum_indices: sum_indices[current_sum] = i return \\"No\\""},{"question":"def encrypt_message(key: str, message: str) -> str: Encrypt the given message using the provided key. Args: key (str): A 26-character string containing each lowercase letter exactly once. message (str): The message to be encrypted. Returns: str: The encrypted message. >>> encrypt_message(\\"bcdefghijklmnopqrstuvwxyza\\", \\"hello world!\\") \\"ifmmp xpsme!\\" >>> encrypt_message(\\"zyxwvutsrqponmlkjihgfedcba\\", \\"Hello, World!\\") \\"Svool, Dliow!\\"","solution":"def encrypt_message(key, message): Encrypt the given message using the provided key. Args: key (str): A 26-character string containing each lowercase letter exactly once. message (str): The message to be encrypted. Returns: str: The encrypted message. # Create a dictionary for mapping lowercase letters according to the key encrypt_dict = {chr(ord('a') + i): key[i] for i in range(26)} # Also create a dictionary for uppercase letters encrypt_dict.update({chr(ord('A') + i): key[i].upper() for i in range(26)}) # Encrypt the message encrypted_message = ''.join(encrypt_dict.get(c, c) for c in message) return encrypted_message"},{"question":"def common_activities(n: int, activities_list: List[str]) -> str: Returns the common activities among all players. Parameters: n (int): Number of players activities_list (list): List of strings, each string contains activities of a player Returns: str: Common activities separated by space or \\"No common activities\\" >>> common_activities(3, [\\"running swimming cycling\\", \\"swimming running yoga\\", \\"running swimming\\"]) 'running swimming' >>> common_activities(3, [\\"running\\", \\"swimming\\", \\"cycling\\"]) 'No common activities' >>> common_activities(3, [\\"running swimming cycling\\", \\"running swimming cycling\\", \\"running swimming cycling\\"]) 'cycling running swimming' >>> common_activities(2, [\\"running swimming\\", \\"running swimming\\"]) 'running swimming' >>> common_activities(3, [\\"running swimming cycling\\", \\"running swimming\\", \\"swimming running\\"]) 'running swimming'","solution":"def common_activities(n, activities_list): Returns the common activities among all players. Parameters: n (int): Number of players activities_list (list): List of strings, each string contains activities of a player Returns: str: Common activities separated by space or \\"No common activities\\" # Split each player's activities into sets activity_sets = [set(activities.split()) for activities in activities_list] # Find the intersection of all activity sets common = set.intersection(*activity_sets) # Return the common activities or \\"No common activities\\" if common: return \\" \\".join(sorted(common)) else: return \\"No common activities\\""},{"question":"def minimal_sprays(m: int, n: int, garden: List[str]) -> int: Calculate the minimal number of sprays required to clear all the bugs from the garden. Args: m (int): Number of rows. n (int): Number of columns. garden (List[str]): The garden grid with plants and bugs. Returns: int: The minimal number of sprays required. Examples: >>> minimal_sprays(5, 5, [\\"P.PPP\\", \\"BP.PB\\", \\"PPP.P\\", \\".PB.P\\", \\"PPPPB\\"]) 4 >>> minimal_sprays(3, 4, [\\"P.BP\\", \\"PPBP\\", \\"BP.P\\"]) 2 >>> minimal_sprays(3, 3, [\\"PPP\\", \\"PPP\\", \\"PPP\\"]) 0 >>> minimal_sprays(2, 2, [\\"BB\\", \\"BB\\"]) 1 >>> minimal_sprays(1, 1, [\\"B\\"]) 1 >>> minimal_sprays(1000, 1000, [\\".\\" * 1000 for _ in range(1000)]) 0 >>> minimal_sprays(1, 5, [\\"B.PBB\\"]) 2 >>> minimal_sprays(5, 1, [\\"B\\", \\"P\\", \\".\\", \\"B\\", \\"B\\"]) 2","solution":"def minimal_sprays(m, n, garden): def spray(x, y): if 0 <= x < m and 0 <= y < n and garden[x][y] == 'B': garden[x][y] = '.' spray(x+1, y) spray(x-1, y) spray(x, y+1) spray(x, y-1) sprays = 0 garden = [list(row) for row in garden] for i in range(m): for j in range(n): if garden[i][j] == 'B': sprays += 1 spray(i, j) return sprays"},{"question":"def max_tree_height(H: int, A: int, B: int, N: int) -> int: Calculate the maximum possible height of the tree after N days. Parameters: - H: Initial height of the tree - A: First fixed growth unit - B: Second fixed growth unit - N: Number of days Returns: - Maximum possible height of the tree after N days Example: >>> max_tree_height(10, 3, 5, 7) 45 >>> max_tree_height(10, 4, 4, 5) 30 >>> max_tree_height(100000, 1, 5, 10) 100050 >>> max_tree_height(1, 100000, 100000, 1) 100001 >>> max_tree_height(50, 10, 20, 0) 50","solution":"def max_tree_height(H, A, B, N): Calculate the maximum possible height of the tree after N days. Parameters: - H: Initial height of the tree - A: First fixed growth unit - B: Second fixed growth unit - N: Number of days Returns: - Maximum possible height of the tree after N days max_growth_unit = max(A, B) max_height = H + max_growth_unit * N return max_height"},{"question":"from typing import List def find_palindromic_substrings(s: str) -> List[str]: Finds all unique palindromic substrings in lexicographical order. :param s: Input string :return: List of unique palindromic substrings in lexicographical order >>> find_palindromic_substrings(\\"ababa\\") ['a', 'aba', 'ababa', 'b', 'bab'] >>> find_palindromic_substrings(\\"abc\\") ['a', 'b', 'c'] def test_find_palindromic_substrings_example1(): result = find_palindromic_substrings(\\"ababa\\") expected = [\\"a\\", \\"aba\\", \\"ababa\\", \\"b\\", \\"bab\\"] assert result == expected def test_find_palindromic_substrings_example2(): result = find_palindromic_substrings(\\"abc\\") expected = [\\"a\\", \\"b\\", \\"c\\"] assert result == expected def test_find_palindromic_substrings_single_char(): result = find_palindromic_substrings(\\"a\\") expected = [\\"a\\"] assert result == expected def test_find_palindromic_substrings_no_palindromes(): result = find_palindromic_substrings(\\"abcdef\\") expected = [\\"a\\", \\"b\\", \\"c\\", \\"d\\", \\"e\\", \\"f\\"] assert result == expected def test_find_palindromic_substrings_all_identical_chars(): result = find_palindromic_substrings(\\"aaaa\\") expected = [\\"a\\", \\"aa\\", \\"aaa\\", \\"aaaa\\"] assert result == expected","solution":"def find_palindromic_substrings(s): Finds all unique palindromic substrings in lexicographical order. :param s: Input string :return: List of unique palindromic substrings in lexicographical order palindromic_substrings = set() def is_palindrome(sub_string): return sub_string == sub_string[::-1] for i in range(len(s)): for j in range(i, len(s)): sub_string = s[i:j+1] if is_palindrome(sub_string): palindromic_substrings.add(sub_string) return sorted(palindromic_substrings)"},{"question":"def topSellingBooks(sales_report): Function to identify the top-selling books each week. Args: sales_report (dict): a dictionary with book titles as keys and number of copies sold as values. Returns: list: a list of top three bestselling books in descending order of sales.","solution":"def topSellingBooks(sales_report): Function to identify the top-selling books each week. Args: sales_report (dict): a dictionary with book titles as keys and number of copies sold as values. Returns: list: a list of top three bestselling books in descending order of sales. # Sort the book titles based on the number of copies sold in descending order, if tie, titles are in arbitrary order sorted_books = sorted(sales_report, key=sales_report.get, reverse=True) # Return the top three books or all books if fewer than three return sorted_books[:3]"},{"question":"def longest_sequence_length(N, K, sequence): Determines the length of the longest sequence that meets Johnny's criteria. N: number of elements in the sequence K: minimum difference between subsequent numbers in the sequence sequence: list of integers Example: >>> longest_sequence_length(6, 2, [1, 3, 2, 5, 4, 7]) 4 >>> longest_sequence_length(5, 3, [10, 20, 30, 40, 50]) 5 >>> longest_sequence_length(4, 1, [5, 1, 3, 2]) 4 def process_input(input_data): Processes multiple test cases input. input_data: A string with multiple test cases. Each test case starts with two integers N and K. Followed by a line of N integers representing the sequence. Example: >>> process_input(\\"6 2n1 3 2 5 4 7n5 3n10 20 30 40 50n4 1n5 1 3 2n\\") [4, 5, 4] >>> process_input(\\"\\") [] def test_longest_sequence_length(): assert longest_sequence_length(6, 2, [1, 3, 2, 5, 4, 7]) == 4 assert longest_sequence_length(5, 3, [10, 20, 30, 40, 50]) == 5 assert longest_sequence_length(4, 1, [5, 1, 3, 2]) == 4 def test_process_input(): input_data = \\"6 2n1 3 2 5 4 7n5 3n10 20 30 40 50n4 1n5 1 3 2n\\" expected_output = [4, 5, 4] assert process_input(input_data) == expected_output def test_with_empty_input(): input_data = \\"\\" expected_output = [] assert process_input(input_data) == expected_output def test_single_element(): assert longest_sequence_length(1, 1, [1]) == 1 assert longest_sequence_length(1, 2, [1000]) == 1 def test_no_valid_sequence(): assert longest_sequence_length(3, 100, [1, 2, 3]) == 1","solution":"def longest_sequence_length(N, K, sequence): Determines the length of the longest sequence that meets Johnny's criteria. sequence = sorted(set(sequence)) # Remove duplicates and sort the list dp = [1] * len(sequence) # Initialize DP array with 1 for i in range(len(sequence)): for j in range(i): if sequence[i] >= sequence[j] + K: dp[i] = max(dp[i], dp[j] + 1) return max(dp) # Function to handle multiple test cases def process_input(input_data): input_lines = input_data.split('n') idx = 0 results = [] while idx < len(input_lines): if input_lines[idx].strip(): N, K = map(int, input_lines[idx].split()) idx += 1 sequence = list(map(int, input_lines[idx].split())) idx += 1 results.append(longest_sequence_length(N, K, sequence)) else: idx += 1 return results"},{"question":"import math from typing import List, Tuple def closestPair(points: List[Tuple[int, int]]) -> float: Find the smallest distance between a pair of points in a 2D plane. >>> closestPair([(2, 3), (12, 30), (40, 50), (5, 1), (12, 10), (3, 4)]) 1.414 >>> closestPair([(0, 0), (1, 1)]) 1.414 >>> closestPair([(1, 0), (2, 0), (3, 0), (4, 0), (5, 0)]) 1.0 >>> closestPair([(0, 1), (0, 2), (0, 3), (0, 4), (0, 5)]) 1.0 >>> closestPair([(1, 1), (2, 2), (3, 3), (4, 4), (5, 5)]) 1.414 >>> closestPair([(4, 4), (2, 3), (8, 0), (5, 1), (1, 2), (7, 8)]) 1.414","solution":"import math def closestPair(points): def distance(p1, p2): return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2) def closest_pair_recursive(points_sorted_by_x, points_sorted_by_y): num_points = len(points_sorted_by_x) if num_points <= 3: return min(distance(points_sorted_by_x[i], points_sorted_by_x[j]) for i in range(num_points) for j in range(i + 1, num_points)) mid = num_points // 2 mid_point = points_sorted_by_x[mid] left_of_center = points_sorted_by_x[:mid] right_of_center = points_sorted_by_x[mid:] closest_distance_left = closest_pair_recursive(left_of_center, points_sorted_by_y) closest_distance_right = closest_pair_recursive(right_of_center, points_sorted_by_y) closest_distance = min(closest_distance_left, closest_distance_right) in_strip = [point for point in points_sorted_by_y if abs(point[0] - mid_point[0]) < closest_distance] for i in range(len(in_strip)): for j in range(i + 1, len(in_strip)): if (in_strip[j][1] - in_strip[i][1]) >= closest_distance: break closest_distance = min(closest_distance, distance(in_strip[i], in_strip[j])) return closest_distance points_sorted_by_x = sorted(points, key=lambda p: p[0]) points_sorted_by_y = sorted(points, key=lambda p: p[1]) return round(closest_pair_recursive(points_sorted_by_x, points_sorted_by_y), 3)"},{"question":"def track_distinct_toys(test_cases: List[Dict[str, List[str]]]) -> List[int]: Process a series of operations and output the number of distinct toy IDs present in the inventory after each operation. >>> track_distinct_toys([{'operations': [\\"ADD 1\\", \\"ADD 2\\", \\"ADD 2\\", \\"REMOVE 1\\", \\"REMOVE 3\\"]}, {'operations': [\\"ADD 100\\", \\"ADD 200\\", \\"REMOVE 100\\"]}]) [1, 2, 2, 1, 1, 1, 2, 1] >>> track_distinct_toys([{'operations': [\\"ADD 5\\", \\"ADD 8\\", \\"REMOVE 5\\", \\"REMOVE 8\\"]}]) [1, 2, 1, 0] >>> track_distinct_toys([{'operations': [\\"ADD 42\\", \\"ADD 42\\", \\"ADD 42\\", \\"REMOVE 42\\"]}]) [1, 1, 1, 0] >>> track_distinct_toys([{'operations': []}]) [] >>> track_distinct_toys([{'operations': [\\"REMOVE 10\\"]}]) [0]","solution":"def track_distinct_toys(test_cases): results = [] for case in test_cases: operations = case['operations'] inventory = set() for operation in operations: op = operation.split() command = op[0] toy_id = int(op[1]) if command == \\"ADD\\": inventory.add(toy_id) elif command == \\"REMOVE\\" and toy_id in inventory: inventory.remove(toy_id) results.append(len(inventory)) return results"},{"question":"def minimum_comparisons(n: int) -> int: Given n chefs, return the minimum number of pairwise comparisons required to definitively rank all the dishes. >>> minimum_comparisons(4) 6 >>> minimum_comparisons(8) 28","solution":"def minimum_comparisons(n): Given n chefs, return the minimum number of pairwise comparisons required to definitively rank all the dishes. return n * (n - 1) // 2"},{"question":"def manage_storage(n: int, grid: List[List[Union[int, Tuple[int, int]]]], commands: List[str]) -> List[int]: Manage the storage system and perform commands on the grid. >>> manage_storage(3, [[(1, 100), 0, 0], [0, (2, 200), 0], [0, 0, (3, 300)]], [\\"MOVE 0 0 0 1\\", \\"QUERY 0 1\\", \\"MOVE 1 1 2 2\\", \\"QUERY 2 2\\", \\"QUERY 0 0\\"]) [100, 300, 0] >>> manage_storage(2, [[(1, 50), 0], [0, (2, 100)]], [\\"QUERY 0 0\\", \\"QUERY 1 1\\"]) [50, 100] >>> manage_storage(2, [[(1, 50), 0], [0, (2, 100)]], [\\"MOVE 0 0 1 1\\", \\"QUERY 0 0\\", \\"QUERY 1 1\\"]) [50, 100] >>> manage_storage(3, [[0, 0, 0], [0, 0, 0], [0, 0, 0]], [\\"QUERY 0 0\\", \\"QUERY 2 2\\"]) [0, 0] >>> manage_storage(3, [[(1, 10), 0, 0], [0, (2, 20), 0], [0, 0, (3, 30)]], [\\"MOVE 0 0 0 1\\", \\"MOVE 1 1 0 0\\", \\"MOVE 2 2 1 1\\", \\"QUERY 0 1\\", \\"QUERY 0 0\\", \\"QUERY 1 1\\"]) [10, 20, 30]","solution":"def manage_storage(n, grid, commands): results = [] for command in commands: parts = command.split() if parts[0] == 'MOVE': x, y, a, b = map(int, parts[1:]) if grid[a][b] == 0 and grid[x][y] != 0: # Ensure the destination is empty and source is not empty grid[a][b], grid[x][y] = grid[x][y], 0 elif parts[0] == 'QUERY': x, y = map(int, parts[1:]) if grid[x][y] == 0: results.append(0) else: results.append(grid[x][y][1]) return results"},{"question":"from typing import List, Tuple def can_partition_graph(n: int, edges: List[Tuple[int, int]]) -> str: Determines if a graph can be partitioned into two sets such that no two vertices within the same set are adjacent. :param n: Number of vertices and edges in the graph. :param edges: List of tuples where each tuple (u, v) represents an edge between vertex u and vertex v. :return: \\"YES\\" if the partition is possible, otherwise \\"NO\\". >>> can_partition_graph(3, [(1, 2), (2, 3), (3, 1)]) \\"NO\\" >>> can_partition_graph(4, [(1, 2), (1, 3), (2, 4), (3, 4)]) \\"YES\\"","solution":"def can_partition_graph(n, edges): Determines if a graph can be partitioned into two sets such that no two vertices within the same set are adjacent. :param n: Number of vertices and edges in the graph. :param edges: List of tuples where each tuple (u, v) represents an edge between vertex u and vertex v. :return: \\"YES\\" if the partition is possible, otherwise \\"NO\\". from collections import deque # Initialize graph as adjacency list graph = {i: [] for i in range(1, n + 1)} for u, v in edges: graph[u].append(v) graph[v].append(u) # 0 denotes uncolored, 1 and -1 are the two colors color = {i: 0 for i in range(1, n + 1)} def bfs(node): queue = deque([node]) color[node] = 1 while queue: current = queue.popleft() for neighbor in graph[current]: if color[neighbor] == 0: # Not colored color[neighbor] = -color[current] queue.append(neighbor) elif color[neighbor] == color[current]: # Conflict return False return True for vertex in range(1, n + 1): if color[vertex] == 0: # Unvisited if not bfs(vertex): return \\"NO\\" return \\"YES\\""},{"question":"def process_datasets(datasets: List[str]) -> List[str]: Process multiple datasets to determine the overall winner based on the number of times each competitor wins. Args: datasets (list of str): List of all input lines including multiple datasets and \\"END\\" at the last. Returns: list of str: List of winners for each dataset. Example: >>> process_datasets([ \\"3\\", \\"Alice 120\\", \\"Bob 110\\", \\"Carol 115\\", \\"3\\", \\"Alice 90\\", \\"Bob 100\\", \\"Carol 88\\", \\"END\\" ]) [\\"Bob\\", \\"Carol\\"]","solution":"from collections import defaultdict def process_datasets(datasets): Process multiple datasets to determine the overall winner based on the number of times each competitor wins. Args: datasets (list of str): List of all input lines including multiple datasets and \\"END\\" at the last. Returns: list of str: List of winners for each dataset. results = [] i = 0 while i < len(datasets): if datasets[i] == \\"END\\": break num_races = int(datasets[i]) i += 1 winners_count = defaultdict(int) for _ in range(num_races): name, time = datasets[i].split() time = int(time) i += 1 if len(winners_count) == 0 or time < winners_count[min(winners_count, key=winners_count.get)]: winners_count = {name: time} elif time == winners_count[min(winners_count, key=winners_count.get)]: winners_count[name] = time overall_winner = min(winners_count) results.append(overall_winner) return results # Example driver code if __name__ == \\"__main__\\": input_data = [ \\"3\\", \\"Alice 120\\", \\"Bob 110\\", \\"Carol 115\\", \\"3\\", \\"Alice 90\\", \\"Bob 100\\", \\"Carol 88\\", \\"END\\" ] output = process_datasets(input_data) for winner in output: print(winner)"},{"question":"def min_swaps_to_sort(arr): Returns the minimum number of swaps to sort the array. >>> min_swaps_to_sort([5, 4, 3, 2, 1]) == 2 >>> min_swaps_to_sort([4, 3, 2, 1, 6, 5]) == 3 >>> min_swaps_to_sort([1, 2, 3, 4, 5]) == 0 >>> min_swaps_to_sort([1]) == 0 >>> min_swaps_to_sort([7, 1, 3, 2, 4, 5, 6]) == 5 >>> min_swaps_to_sort([9, 8, 7, 6, 5, 4, 3, 2, 1]) == 4","solution":"def min_swaps_to_sort(arr): Returns the minimum number of swaps to sort the array. n = len(arr) arr_pos = [*enumerate(arr)] # Sort the array by array value arr_pos.sort(key=lambda it: it[1]) # Mark all elements as not visited visited = {k: False for k in range(n)} result = 0 for i in range(n): # Already in correct position or already visited if visited[i] or arr_pos[i][0] == i: continue cycle_size = 0 j = i while not visited[j]: visited[j] = True j = arr_pos[j][0] cycle_size += 1 if cycle_size > 0: result += (cycle_size - 1) return result"},{"question":"from typing import List, Tuple def find_duplicate_and_missing(n: int, arr: List[int]) -> Tuple[int, int]: Finds the duplicated number and the missing number in the array. Args: n - integer, the size of the array. arr - list of integers containing numbers from 1 to n with one duplicate and one missing. Returns: A tuple (duplicate, missing). >>> find_duplicate_and_missing(5, [1, 2, 2, 4, 5]) (2, 3) >>> find_duplicate_and_missing(6, [1, 2, 3, 4, 4, 6]) (4, 5) >>> find_duplicate_and_missing(3, [3, 3, 1]) (3, 2)","solution":"from collections import Counter def find_duplicate_and_missing(n, arr): Finds the duplicated number and the missing number in the array. Args: n - integer, the size of the array. arr - list of integers containing numbers from 1 to n with one duplicate and one missing. Returns: A tuple (duplicate, missing). count = Counter(arr) duplicate = missing = -1 # Iterate over range 1 to n to find duplicate and missing numbers for number in range(1, n + 1): if number in count: if count[number] == 2: duplicate = number else: missing = number return duplicate, missing"},{"question":"def max_water_retention(N: int, capacities: List[int]) -> int: Calculate the maximum amount of water that can be retained in any contiguous segment of valleys if you choose to build a single dam. :param N: The number of valleys :param capacities: A list of integers representing the water capacities of the valleys :return: The maximum water retention in any contiguous segment of valleys >>> max_water_retention(5, [5, 2, 4, 6, 3]) 20 >>> max_water_retention(3, [1, 2, 3]) 6 >>> max_water_retention(6, [8, 1, 6, 2, 9, 4]) 30 >>> max_water_retention(1, [5]) 5 >>> max_water_retention(5, [1, -1, 2, -2, 3]) 3 >>> max_water_retention(5, [-1, -2, -3, -4, -5]) 0 >>> max_water_retention(5, [0, 0, 0, 0, 0]) 0","solution":"def max_water_retention(N, capacities): Calculate the maximum amount of water that can be retained in any contiguous segment of valleys if you choose to build a single dam. :param N: The number of valleys :param capacities: A list of integers representing the water capacities of the valleys :return: The maximum water retention in any contiguous segment of valleys max_water = 0 current_sum = 0 for capacity in capacities: current_sum += capacity if current_sum > max_water: max_water = current_sum if current_sum < 0: current_sum = 0 return max_water"},{"question":"def highest_score(n: int, participants_scores: List[List[int]]) -> int: Returns the highest score achieved by any participant among all given scores. >>> highest_score(3, [[34, 67, 90, 100], [56, 88], [23, 45, 78]]) == 100 >>> highest_score(3, [[50], [50], [50]]) == 50 >>> highest_score(1, [[10, 20, 30, 40, 50]]) == 50 >>> highest_score(2, [[90, 88, 76], [75, 78, 77]]) == 90 >>> highest_score(3, [[0, 0, 0], [0, 0, 50], [0, 30, 0]]) == 50 >>> highest_score(2, [[90, 91, 94, 96], [100, 99, 101, 102]]) == 102 def process_input_and_call_highest_score(input_str: str) -> int: Processes input and calls the highest_score function. >>> process_input_and_call_highest_score(\\"3n4 34 67 90 100n2 56 88n3 23 45 78\\") == 100 >>> process_input_and_call_highest_score(\\"3n1 50n1 50n1 50\\") == 50 >>> process_input_and_call_highest_score(\\"1n5 10 20 30 40 50\\") == 50 >>> process_input_and_call_highest_score(\\"2n3 90 88 76n3 75 78 77\\") == 90 >>> process_input_and_call_highest_score(\\"3n3 0 0 0n3 0 0 50n3 0 30 0\\") == 50 >>> process_input_and_call_highest_score(\\"2n4 90 91 94 96n4 100 99 101 102\\") == 102","solution":"def highest_score(n, participants_scores): Returns the highest score achieved by any participant. Parameters: n (int): Number of participants. participants_scores (list of lists): Each inner list contains the scores of the songs sung by a participant. Returns: int: The highest score achieved by any participant. max_score = 0 for scores in participants_scores: max_score = max(max_score, max(scores)) return max_score # Function to process input in the required format def process_input_and_call_highest_score(input_str): input_lines = input_str.strip().split('n') n = int(input_lines[0]) participants_scores = [list(map(int, line.split()[1:])) for line in input_lines[1:]] return highest_score(n, participants_scores)"},{"question":"def average_rating_in_range(n: int, ratings: List[int], q: int, queries: List[Tuple[int, int]]) -> List[int]: Alice wants to organize her novels by rating in a specific way. Write a function that helps her find all the novels whose ratings are in a given range [L, R] (inclusive) and for the selected novels, calculate the average rating, rounded down to the nearest integer. :param n: The number of novels. :param ratings: A list of integer ratings for the novels. :param q: The number of queries. :param queries: A list of tuples where each tuple contains two integers, L and R. :return: A list of integers representing the average ratings for each query's specified range, or -1 if no novels fall within the range. >>> average_rating_in_range(6, [100, 200, 300, 400, 500, 600], 3, [(100, 300), (200, 500), (900, 1000)]) [200, 350, -1] >>> average_rating_in_range(5, [50, 150, 250, 350, 450], 2, [(250, 250), (100, 150)]) [250, 150] >>> average_rating_in_range(5, [20, 40, 60, 80, 100], 1, [(1, 1000)]) [60] >>> average_rating_in_range(4, [20, 25, 30, 35], 2, [(100, 200), (31, 34)]) [-1, -1] >>> average_rating_in_range(100, [i for i in range(1, 101)], 2, [(10, 20), (90, 100)]) [15, 95]","solution":"def average_rating_in_range(n, ratings, q, queries): result = [] for query in queries: L, R = query filtered_ratings = [rating for rating in ratings if L <= rating <= R] if not filtered_ratings: result.append(-1) else: average_rating = sum(filtered_ratings) // len(filtered_ratings) result.append(average_rating) return result"},{"question":"def scramble_string(s: str) -> str: Returns a scrambled version of the string s where no character is in its original position. If such a rearrangement is not possible, returns an empty string. >>> scramble_string(\\"hello\\") not in [\\"hello\\"] >>> scramble_string(\\"aabb\\") not in [\\"aabb\\"] >>> scramble_string(\\"a\\") == \\"\\" >>> scramble_string(\\"aaa\\") == \\"\\"","solution":"import random def scramble_string(s): Returns a scrambled version of the string s where no character is in its original position. If such a rearrangement is not possible, returns an empty string. length = len(s) if length == 1: return \\"\\" s_list = list(s) attempts = 1000 while attempts > 0: random.shuffle(s_list) if all(s_list[i] != s[i] for i in range(length)): return \\"\\".join(s_list) attempts -= 1 return \\"\\""},{"question":"from typing import List def organize_books(n: int, books: List[str]) -> List[str]: Organize books by genre and sort both genres and books within each genre. Args: n (int): The number of books. books (List[str]): List containing strings representing book ID and genre separated by a space. Returns: List[str]: List of genres followed by sorted book IDs within each genre. Example: >>> organize_books(6, [\\"book1 fiction\\", \\"book2 mystery\\", \\"book3 fiction\\", \\"book4 fantasy\\", \\"book5 fiction\\", \\"book6 mystery\\"]) [\\"fantasy: book4\\", \\"fiction: book1 book3 book5\\", \\"mystery: book2 book6\\"] >>> organize_books(3, [\\"book1 fiction\\", \\"book3 fiction\\", \\"book2 fiction\\"]) [\\"fiction: book1 book2 book3\\"] >>> organize_books(4, [\\"book8 history\\", \\"book3 science\\", \\"book5 history\\", \\"book1 science\\"]) [\\"history: book5 book8\\", \\"science: book1 book3\\"]","solution":"def organize_books(n, books): from collections import defaultdict # Create a dictionary to store books by genre genres = defaultdict(list) # Populate the dictionary with book IDs according to genre for book in books: book_id, genre = book.split() genres[genre].append(book_id) # Sort genres alphabetically and book IDs within each genre sorted_genres = sorted(genres.keys()) result = [] for genre in sorted_genres: sorted_books = sorted(genres[genre]) result.append(f\\"{genre}: {' '.join(sorted_books)}\\") return result"},{"question":"def can_satisfy_water_requests(capacity: int, requests: List[int]) -> str: Determines if the watercooler can satisfy all employees' water requests without exceeding its capacity. :param capacity: The capacity of the watercooler (C) :param requests: List of requests from each employee in liters :return: 'Yes' if the watercooler can satisfy all requests, otherwise 'No' >>> can_satisfy_water_requests(15, [5, 3, 4]) == \\"Yes\\" >>> can_satisfy_water_requests(10, [3, 2, 4, 5]) == \\"No\\" >>> can_satisfy_water_requests(100, [20, 15, 25, 10, 30]) == \\"Yes\\" >>> can_satisfy_water_requests(50, [20, 20, 15]) == \\"No\\" >>> can_satisfy_water_requests(60, [20, 20, 20]) == \\"Yes\\" >>> can_satisfy_water_requests(0, [0]) == \\"Yes\\" >>> can_satisfy_water_requests(10, [15]) == \\"No\\"","solution":"def can_satisfy_water_requests(capacity, requests): Determines if the watercooler can satisfy all employees' water requests without exceeding its capacity. :param capacity: The capacity of the watercooler (C) :param requests: List of requests from each employee in liters :return: 'Yes' if the watercooler can satisfy all requests, otherwise 'No' total_requested = sum(requests) if total_requested <= capacity: return \\"Yes\\" else: return \\"No\\""},{"question":"def min_possible_difference(arr): Given an array of integers, determine the minimum possible difference between the maximum and the minimum elements of the array after performing an arbitrary number of arithmetic mean operations. >>> min_possible_difference([4, 7, 1, 3, 8]) 0 >>> min_possible_difference([10, 20]) 0 >>> min_possible_difference([5, 5, 5, 5]) 0 >>> min_possible_difference([1000000000, 1]) 0 >>> min_possible_difference([10, 9, 8, 7, 6, 5, 4, 3, 2, 1]) 0","solution":"def min_possible_difference(arr): Since we can perform the operation enough times, we can force all elements to converge to their mean. Therefore, the minimum possible difference between the max and min element will be 0. return 0"},{"question":"from typing import List, Tuple def assign_values(n: int, edges: List[Tuple[int, int]]) -> List[int]: Determine if there exists a valid assignment of values to the nodes such that: 1. The value of the root node (1) is 1. 2. The value of any node other than the root is strictly greater than its parent's value. 3. The values assigned to the nodes must form a permutation of {1, 2, ..., n}. >>> assign_values(5, [(1, 2), (1, 3), (2, 4), (2, 5)]) in [[1, 2, 3, 4, 5], [1, 2, 4, 3, 5], [1, 2, 4, 5, 3]] True >>> assign_values(3, [(1, 2), (2, 3)]) == [1, 2, 3] True >>> assign_values(1, []) == [1] True","solution":"def assign_values(n, edges): from collections import defaultdict, deque # Create adjacency list for the tree adj_list = defaultdict(list) for u, v in edges: adj_list[u].append(v) adj_list[v].append(u) # BFS to assign values in breadth-first order starting from node 1 assigned_values = [-1] * (n + 1) queue = deque([1]) assigned_values[1] = 1 current_value = 2 while queue: node = queue.popleft() for neighbor in sorted(adj_list[node]): if assigned_values[neighbor] == -1: assigned_values[neighbor] = current_value current_value += 1 queue.append(neighbor) return assigned_values[1:] # Example Usage edges1 = [(1, 2), (1, 3), (2, 4), (2, 5)] print(assign_values(5, edges1)) # Possible output: [1, 2, 3, 4, 5] edges2 = [(1, 2), (2, 3)] print(assign_values(3, edges2)) # Possible output: [1, 2, 3]"},{"question":"def max_non_overlapping_workshops(n: int, workshops: List[Tuple[int, int]]) -> int: Returns the maximum number of non-overlapping workshops. Parameters: n (int) : the number of workshops workshops (List[Tuple[int, int]]): a list of tuples representing the workshops with start and end times. Returns: int: the maximum number of non-overlapping workshops that can be scheduled. >>> max_non_overlapping_workshops(3, [(1, 3), (2, 5), (4, 6)]) 2 >>> max_non_overlapping_workshops(4, [(1, 2), (2, 3), (3, 4), (4, 5)]) 4 >>> max_non_overlapping_workshops(5, [(1, 4), (3, 5), (0, 6), (5, 7), (8, 9)]) 3 >>> max_non_overlapping_workshops(1, [(0, 1)]) 1 >>> max_non_overlapping_workshops(3, [(1, 2), (3, 4), (5, 6)]) 3 >>> max_non_overlapping_workshops(3, [(1, 4), (2, 5), (3, 6)]) 1","solution":"def max_non_overlapping_workshops(n, workshops): Returns the maximum number of non-overlapping workshops. Parameters: n (int) : the number of workshops workshops (List[Tuple[int, int]]): a list of tuples representing the workshops with start and end times. Returns: int: the maximum number of non-overlapping workshops that can be scheduled. # Sort workshops by their end times workshops.sort(key=lambda x: x[1]) count = 0 last_end_time = 0 for start, end in workshops: if start >= last_end_time: count += 1 last_end_time = end return count"},{"question":"def find_zero_sum_triplets(lst: List[int]) -> bool: Determines whether there exist three numbers in the list that sum to zero. Parameters: lst (list): The list of integers. Returns: bool: True if there are three integers that sum to zero, False otherwise. >>> find_zero_sum_triplets([-1, 0, 1, 2, -1]) True >>> find_zero_sum_triplets([1, 2, 3, 4, 5]) False >>> find_zero_sum_triplets([-1, -1, 0, 1, 1, 2, -4]) True >>> find_zero_sum_triplets([1000000, -1000000, 0, 999999, 1, -999999]) True >>> find_zero_sum_triplets([1, 2, -2, -1]) False >>> find_zero_sum_triplets([0, 0, 0]) True","solution":"def find_zero_sum_triplets(lst): Determines whether there exist three numbers in the list that sum to zero. Parameters: lst (list): The list of integers. Returns: bool: True if there are three integers that sum to zero, False otherwise. n = len(lst) # Sort the list lst.sort() for i in range(n - 2): # Skip duplicate elements if i > 0 and lst[i] == lst[i - 1]: continue left, right = i + 1, n - 1 while left < right: total = lst[i] + lst[left] + lst[right] if total == 0: return True elif total < 0: left += 1 else: right -= 1 return False"},{"question":"def count_palindromic_substrings(S: str) -> int: Returns the count of palindromic substrings in the given string S. >>> count_palindromic_substrings(\\"ababa\\") 9 >>> count_palindromic_substrings(\\"aaa\\") 6","solution":"def count_palindromic_substrings(S): Returns the count of palindromic substrings in S. n = len(S) count = 0 # A table to store the results of palindromic checks dp = [[False] * n for _ in range(n)] # Substrings of length 1 are palindromic for i in range(n): dp[i][i] = True count += 1 # Check for substrings of length 2 for i in range(n - 1): if S[i] == S[i + 1]: dp[i][i + 1] = True count += 1 # Check for substrings of length > 2 for length in range(3, n + 1): # Length of the substring for i in range(n - length + 1): # Start index of the substring j = i + length - 1 # End index of the substring if S[i] == S[j] and dp[i + 1][j - 1]: dp[i][j] = True count += 1 return count"},{"question":"def min_rook_moves_to_capture_knight(m: int, n: int, x1: int, y1: int, x2: int, y2: int) -> int: Calculate the minimum number of moves required for the rook to capture the knight. Parameters: m (int): Number of rows on the chessboard. n (int): Number of columns on the chessboard. x1 (int): Rook's row position. y1 (int): Rook's column position. x2 (int): Knight's row position. y2 (int): Knight's column position. Returns: int: Minimum number of moves required for the rook to capture the knight, or -1 if impossible. >>> min_rook_moves_to_capture_knight(8, 8, 1, 1, 5, 5) 2 >>> min_rook_moves_to_capture_knight(3, 3, 1, 1, 2, 3) 1 >>> min_rook_moves_to_capture_knight(4, 4, 1, 1, 4, 3) 2","solution":"def min_rook_moves_to_capture_knight(m, n, x1, y1, x2, y2): Calculate the minimum number of moves for the rook to capture the knight. Parameters: m (int): Number of rows on the chessboard n (int): Number of columns on the chessboard x1 (int): Rook's row position y1 (int): Rook's column position x2 (int): Knight's row position y2 (int): Knight's column position Returns: int: Minimum number of moves for the rook to capture the knight, or -1 if impossible if (x1 == x2 and y1 == y2): return 0 # The rook is already capturing the knight elif (x1 == x2) or (y1 == y2): return 1 # The rook is in the same row/column as the knight else: return 2 # The rook can move to the same row/column in one move and then capture the knight # A simple check for impossible cases: # Since this is a valid chessboard and valid positions are given, no extra checks needed."},{"question":"def determine_winner(n: int, string: str) -> str: Determines the winner of the game where Alice and Bob take turns removing non-empty substrings. Arguments: n -- length of the string string -- the string consisting of lowercase English letters Returns: \\"Alice\\" if Alice wins, otherwise \\"Bob\\" >>> determine_winner(7, 'ababaac') 'Alice' >>> determine_winner(1, 'a') 'Alice' >>> determine_winner(5, 'abcde') 'Alice' >>> determine_winner(4, 'abac') 'Bob' >>> determine_winner(6, 'abcdef') 'Bob' >>> determine_winner(8, 'abcdefgh') 'Bob' >>> determine_winner(2, 'aa') 'Bob' >>> determine_winner(0, '') 'Bob'","solution":"def determine_winner(n, string): Determines the winner of the game where Alice and Bob take turns removing non-empty substrings. Arguments: n -- length of the string string -- the string consisting of lowercase English letters Returns: \\"Alice\\" if Alice wins, otherwise \\"Bob\\" return \\"Alice\\" if n % 2 == 1 else \\"Bob\\""},{"question":"def rearrange_string(s: str) -> str: Attempts to rearrange the string \`s\` such that no two identical characters are adjacent to each other. If it is not possible, returns \\"Not Possible\\". >>> rearrange_string(\\"aaabb\\") \\"ababa\\" >>> rearrange_string(\\"zzzzzx\\") \\"Not Possible\\" >>> rearrange_string(\\"abcdef\\") \\"abcdef\\" pass def solve(T: int, test_cases: List[str]) -> List[str]: Solves multiple test cases for the problem of rearranging strings. Parameters: - T (int): Number of test cases. - test_cases (list of str): List of strings to rearrange. Returns: - List of rearranged strings or \\"Not Possible\\" for each test case. >>> solve(3, [\\"aaabb\\", \\"zzzzzx\\", \\"abcdef\\"]) [\\"ababab\\", \\"Not Possible\\", \\"abcdef\\"] pass if __name__ == \\"__main__\\": import sys input = sys.stdin.read data = input().split() T = int(data[0]) test_cases = data[1:] results = solve(T, test_cases) for result in results: print(result)","solution":"from heapq import heappush, heappop from collections import Counter def rearrange_string(s): Attempts to rearrange the string \`s\` such that no two identical characters are adjacent to each other. If it is not possible, returns \\"Not Possible\\". # Count the frequency of each character counter = Counter(s) max_freq = max(counter.values()) # Check if it's possible to rearrange if max_freq > (len(s) + 1) // 2: return \\"Not Possible\\" # Priority queue to store characters by frequency max_heap = [] for char, freq in counter.items(): heappush(max_heap, (-freq, char)) result = [] prev_freq, prev_char = 0, '' while max_heap: freq, char = heappop(max_heap) result.append(char) if prev_freq < 0: heappush(max_heap, (prev_freq, prev_char)) prev_freq, prev_char = freq + 1, char return ''.join(result) def solve(T, test_cases): Solves multiple test cases for the problem of rearranging strings. Parameters: - T (int): Number of test cases. - test_cases (list of str): List of strings to rearrange. Returns: - List of rearranged strings or \\"Not Possible\\" for each test case. results = [] for case in test_cases: results.append(rearrange_string(case)) return results"},{"question":"def min_operations_to_avoid_adjacent_duplicates(s: str) -> int: Returns the minimum number of operations required to ensure that no two adjacent characters in the given string are the same. >>> min_operations_to_avoid_adjacent_duplicates(\\"aabb\\") 2 >>> min_operations_to_avoid_adjacent_duplicates(\\"aaabba\\") 3 >>> min_operations_to_avoid_adjacent_duplicates(\\"abc\\") 0","solution":"def min_operations_to_avoid_adjacent_duplicates(s): Returns the minimum number of operations required to ensure that no two adjacent characters in the given string are the same. if not s: return 0 operations = 0 # Start from the second character and check against the previous one for i in range(1, len(s)): if s[i] == s[i - 1]: # Increment operations count if two adjacent characters are the same operations += 1 # Move to the next character without changing the current character i += 1 return operations"},{"question":"from typing import List, Tuple def find_path(maze: List[str]) -> Tuple[str, int, str]: Finds a path for the robot through the maze from the top-left corner to the bottom-right corner. If a path exists, returns \\"YES\\" followed by the number of steps and the sequence of moves. If no path exists, returns \\"NO\\". Args: maze (List[str]): n x n grid representing the maze. Returns: Tuple[str, int, str]: \\"YES\\"/\\"NO\\", number of steps, sequence of moves. Examples: >>> find_path([ ... \\".....\\", ... \\".#.\\", ... \\".K..#\\", ... \\".G.\\", ... \\".....\\" ... ]) ('YES', 9, 'DDDDRURRU') >>> find_path([ ... \\".....\\", ... \\"#\\", ... \\"#K#\\", ... \\"#.#\\", ... \\".....\\" ... ]) ('NO', None, None) pass def test_example_case(): maze = [ \\".....\\", \\".#.\\", \\".K..#\\", \\".G.\\", \\".....\\" ] result = find_path(maze) assert result[0] == \\"YES\\" def test_no_path(): maze = [ \\".....\\", \\"#\\", \\"#K#\\", \\"#.#\\", \\".....\\" ] result = find_path(maze) assert result[0] == \\"NO\\" def test_key_and_gate(): maze = [ \\"..#..\\", \\"..#G.\\", \\"..#..\\", \\"..#..\\", \\"..K..\\" ] result = find_path(maze) assert result[0] == \\"YES\\" def test_simple_path(): maze = [ \\"..\\", \\"..\\" ] result = find_path(maze) assert result[0] == \\"YES\\" assert result[1] == 2 def test_more_complex_path(): maze = [ \\".#...\\", \\".#.K.\\", \\".#.#.\\", \\"...#.\\", \\".G...\\" ] result = find_path(maze) assert result[0] == \\"YES\\"","solution":"from collections import deque def find_path(maze): n = len(maze) directions = [(-1, 0, 'U'), (1, 0, 'D'), (0, -1, 'L'), (0, 1, 'R')] def get_neighbors(x, y): for dx, dy, move in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < n and maze[nx][ny] != '#': yield nx, ny, move def bfs(): start = (0, 0) end = (n-1, n-1) queue = deque([(start, 0, \\"\\", False)]) # ((x, y), step_count, path, has_key) visited = set(((0, 0), False)) while queue: (x, y), steps, path, has_key = queue.popleft() if (x, y) == end: return \\"YES\\", steps, path for nx, ny, move in get_neighbors(x, y): new_has_key = has_key or maze[nx][ny] == 'K' if (nx, ny) == end or maze[nx][ny] != 'G' or new_has_key: if ((nx, ny), new_has_key) not in visited: visited.add(((nx, ny), new_has_key)) queue.append(((nx, ny), steps + 1, path + move, new_has_key)) return \\"NO\\", None, None return bfs()"},{"question":"def min_operations_to_transform(s: str) -> int: Find the minimum number of operations required to transform the string such that no two adjacent characters are the same. >>> min_operations_to_transform(\\"aaab\\") 2 >>> min_operations_to_transform(\\"abac\\") 0 def test_example_cases(): assert min_operations_to_transform(\\"aaab\\") == 2 assert min_operations_to_transform(\\"abac\\") == 0 def test_additional_cases(): assert min_operations_to_transform(\\"aaaa\\") == 3 assert min_operations_to_transform(\\"abcde\\") == 0 assert min_operations_to_transform(\\"aabbcc\\") == 3 assert min_operations_to_transform(\\"abbbbb\\") == 4 assert min_operations_to_transform(\\"abba\\") == 1 def test_edge_cases(): assert min_operations_to_transform(\\"a\\") == 0 assert min_operations_to_transform(\\"aa\\") == 1 assert min_operations_to_transform(\\"\\") == 0 def test_long_string(): long_string = \\"a\\" * 10**5 assert min_operations_to_transform(long_string) == 10**5 - 1 def test_no_operations_needed(): assert min_operations_to_transform(\\"abcdefghijklmnopqrstuvwxyz\\") == 0 assert min_operations_to_transform(\\"ababababababababababababababababababababababababab\\") == 0 def test_mixed_cases(): assert min_operations_to_transform(\\"abcdabcabc\\") == 0 assert min_operations_to_transform(\\"abababcabcabcd\\") == 0","solution":"def min_operations_to_transform(s): Returns the minimum number of operations required to transform the string such that no two adjacent characters are the same. n = len(s) count = 0 for i in range(1, n): if s[i] == s[i-1]: # Increment the count as we either need to swap or insert a character count += 1 return count"},{"question":"from typing import List def isSynchronized(N: int, intervals: List[int]) -> bool: Determines if there is a common time T where all pyrotechnic displays go off simultaneously for the first time. >>> isSynchronized(3, [3, 5, 4]) False >>> isSynchronized(2, [2, 4]) True","solution":"from math import gcd from functools import reduce def lcm(a, b): Compute the Least Common Multiple of two numbers. return a * b // gcd(a, b) def isSynchronized(N, intervals): Determines if there is a common time T where all pyrotechnic displays go off simultaneously for the first time. if N == 1: return True # A single interval will always have synchronization # Compute the LCM of all intervals overall_lcm = reduce(lcm, intervals) # If the overall LCM is larger than largest interval * N, it is practical # to consider it synchronized for realistic shows. if overall_lcm > max(intervals) * N: return False return overall_lcm <= 10 ** 9 # LCM must not exceed typical upper limit"},{"question":"def find_pair_with_sum(n: int, k: int, arr: List[int]) -> str: Determine if there exists a pair of indices (i, j) such that the sum of elements at these indices equals a given target value k and i != j. Parameters: n (int): The length of the array. k (int): The target sum. arr (List[int]): The list of integer elements Returns: str: \\"YES\\" if such a pair exists, otherwise \\"NO\\". >>> find_pair_with_sum(5, 9, [2, 7, 11, 15, 3]) \\"YES\\" >>> find_pair_with_sum(4, 8, [1, 2, 3, 4]) \\"NO\\" >>> find_pair_with_sum(3, 0, [-1, 1, 0]) \\"YES\\" >>> find_pair_with_sum(1, 0, [0]) \\"NO\\" >>> find_pair_with_sum(2, 2, [1, 1]) \\"YES\\" >>> find_pair_with_sum(4, 1000000000, [999999999, 1, -1000000000, 1000000000]) \\"YES\\" >>> find_pair_with_sum(3, -5, [-2, -3, 1]) \\"YES\\" pass","solution":"def find_pair_with_sum(n, k, arr): Returns \\"YES\\" if there exists a pair of indices (i, j) such that arr[i] + arr[j] == k and i != j. Returns \\"NO\\" otherwise. seen = set() for number in arr: required = k - number if required in seen: return \\"YES\\" seen.add(number) return \\"NO\\""},{"question":"def maxRobbery(n: int, houses: List[int]) -> int: Calculate the maximum amount of money that can be robbed without robbing two adjacent houses. >>> maxRobbery(6, [2, 7, 9, 3, 1, 5]) 16 >>> maxRobbery(4, [1, 2, 3, 1]) 4","solution":"def maxRobbery(n, houses): if n == 0: return 0 if n == 1: return houses[0] # Initialize the first two houses prev1 = 0 prev2 = 0 for i in range(n): current = max(prev1, prev2 + houses[i]) prev2 = prev1 prev1 = current return prev1"},{"question":"def count_differences(S: str, T: str) -> int: Returns the number of positions where the characters in the two strings S and T differ. >>> count_differences(\\"abcdef\\", \\"abcdeg\\") 1 >>> count_differences(\\"hello\\", \\"there\\") 3 >>> count_differences(\\"aaaaa\\", \\"aaabb\\") 2 >>> count_differences(\\"abcd\\", \\"abcf\\") 1 >>> count_differences(\\"xyz\\", \\"xyz\\") 0","solution":"def count_differences(S, T): Returns the number of positions where the characters in the two strings S and T differ. # Initialize a counter for differences differences = 0 # Iterate over the strings and compare characters for char1, char2 in zip(S, T): if char1 != char2: differences += 1 return differences"},{"question":"from collections import deque class CommandQueue: def __init__(self): self.queue = deque() def enqueue(self, x): Add an integer x to the end of the queue. self.queue.append(x) def dequeue(self): Remove and return the integer at the front of the queue. If the queue is empty, return 'Queue is empty'. if len(self.queue) == 0: return 'Queue is empty' else: return self.queue.popleft() def process_commands(commands: List[str]) -> List[Union[int, str]]: Your task is to write a program that simulates a command queue with the following instructions: - enqueue x: Add an integer x to the end of the queue. - dequeue: Remove and print the integer at the front of the queue. If the queue is empty, print 'Queue is empty'. Notes: * 1 ≤ x ≤ 1000 * 1 ≤ number of instructions ≤ 100000 >>> process_commands(['enqueue 5', 'dequeue']) [5] >>> process_commands(['dequeue']) ['Queue is empty'] Example: commands = [ 'enqueue 5', 'enqueue 10', 'dequeue', 'dequeue', 'dequeue', 'enqueue 7', 'dequeue' ] process_commands(commands) == [5, 10, 'Queue is empty', 7] queue = CommandQueue() output = [] for command in commands: if command.startswith('enqueue'): _, x = command.split() queue.enqueue(int(x)) elif command == 'dequeue': output.append(queue.dequeue()) return output","solution":"from collections import deque class CommandQueue: def __init__(self): self.queue = deque() def enqueue(self, x): self.queue.append(x) def dequeue(self): if len(self.queue) == 0: return 'Queue is empty' else: return self.queue.popleft() def process_commands(commands): queue = CommandQueue() output = [] for command in commands: if command.startswith('enqueue'): _, x = command.split() queue.enqueue(int(x)) elif command == 'dequeue': output.append(queue.dequeue()) return output"},{"question":"import heapq import math from typing import List, Tuple def is_prime(n: int) -> bool: Return True if n is a prime number. >>> is_prime(2) True >>> is_prime(3) True >>> is_prime(4) False >>> is_prime(5) True >>> is_prime(10) False >>> is_prime(11) True def find_shortest_prime_path(n: int, m: int, roads: List[Tuple[int, int, int]], start: int, destination: int, t: int) -> int: Find the shortest path from the start city to the destination city using only roads with prime weights. >>> n = 5 >>> m = 6 >>> t = 10 >>> roads = [(1, 2, 3), (1, 3, 4), (2, 4, 5), (3, 4, 6), (3, 5, 7), (4, 5, 2)] >>> start = 1 >>> destination = 5 >>> find_shortest_prime_path(n, m, roads, start, destination, t) 10 def test_is_prime(): assert is_prime(2) == True assert is_prime(3) == True assert is_prime(4) == False assert is_prime(5) == True assert is_prime(10) == False assert is_prime(11) == True def test_find_shortest_prime_path(): # Example case n = 5 m = 6 t = 10 roads = [(1, 2, 3), (1, 3, 4), (2, 4, 5), (3, 4, 6), (3, 5, 7), (4, 5, 2)] start = 1 destination = 5 assert find_shortest_prime_path(n, m, roads, start, destination, t) == 10 # No path case n = 4 m = 3 t = 10 roads = [(1, 2, 4), (2, 3, 6), (3, 4, 8)] start = 1 destination = 4 assert find_shortest_prime_path(n, m, roads, start, destination, t) == -1 # No prime weights n = 3 m = 2 t = 10 roads = [(1, 2, 4), (2, 3, 6)] start = 1 destination = 3 assert find_shortest_prime_path(n, m, roads, start, destination, t) == -1 # Prime weights n = 3 m = 3 t = 15 roads = [(1, 2, 3), (1, 3, 5), (2, 3, 7)] start = 1 destination = 3 assert find_shortest_prime_path(n, m, roads, start, destination, t) == 5 # Path exists but exceeds time n = 4 m = 3 t = 5 roads = [(1, 2, 3), (2, 3, 5), (3, 4, 7)] start = 1 destination = 4 assert find_shortest_prime_path(n, m, roads, start, destination, t) == -1","solution":"import heapq import math def is_prime(n): Return True if n is a prime number. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def dijkstra(n, adjacency_list, start, destination): Find the shortest path from start to destination using Dijkstra's algorithm. pq = [(0, start)] travel_time = {i: float('inf') for i in range(n + 1)} travel_time[start] = 0 while pq: current_time, current_city = heapq.heappop(pq) if current_city == destination: return current_time for neighbor, weight in adjacency_list[current_city]: if travel_time[current_city] + weight < travel_time[neighbor]: travel_time[neighbor] = travel_time[current_city] + weight heapq.heappush(pq, (travel_time[neighbor], neighbor)) return -1 def find_shortest_prime_path(n, m, roads, start, destination, t): adjacency_list = {i: [] for i in range(1, n + 1)} for u, v, w in roads: if is_prime(w): adjacency_list[u].append((v, w)) adjacency_list[v].append((u, w)) result = dijkstra(n, adjacency_list, start, destination) return result if result <= t else -1 def main(): import sys input = sys.stdin.read data = input().split() n = int(data[0]) m = int(data[1]) t = int(data[2]) roads = [] index = 3 for _ in range(m): u = int(data[index]) v = int(data[index+1]) w = int(data[index+2]) roads.append((u, v, w)) index += 3 start = int(data[index]) destination = int(data[index + 1]) print(find_shortest_prime_path(n, m, roads, start, destination, t)) if __name__ == \\"__main__\\": main()"},{"question":"def count_paths(n: int, m: int, t: int, traps: List[Tuple[int, int]]) -> int: Calculate the number of different ways to move from the top-left corner to the bottom-right corner of a grid without stepping on any trap cells. Parameters: n (int): Number of rows in the grid. m (int): Number of columns in the grid. t (int): Number of traps in the grid. traps (List[Tuple[int, int]]): List of tuples denoting the position of traps. Returns: int: The number of different ways to reach the bottom-right corner from the top-left corner. Examples: >>> count_paths(3, 3, 1, [(2, 2)]) 2 >>> count_paths(2, 2, 0, []) 2","solution":"def count_paths(n, m, t, traps): grid = [[0] * m for _ in range(n)] trap_set = {(x - 1, y - 1) for x, y in traps} if (0, 0) in trap_set or (n - 1, m - 1) in trap_set: return 0 grid[0][0] = 1 for i in range(n): for j in range(m): if (i, j) in trap_set: continue if i > 0: grid[i][j] += grid[i - 1][j] if j > 0: grid[i][j] += grid[i][j - 1] return grid[-1][-1]"},{"question":"def sum_of_two_smallest_unique_integers(N: int, arr: List[int]) -> int: Calculate the sum of the two smallest unique integers in the list. If the list contains fewer than two unique integers, return -1. >>> sum_of_two_smallest_unique_integers(5, [5, 2, 9, 1, 5]) 3 >>> sum_of_two_smallest_unique_integers(4, [4, 4, 4, 4]) -1","solution":"def sum_of_two_smallest_unique_integers(N, arr): Returns the sum of the two smallest unique integers from the list. If there are fewer than two unique integers, returns -1. if N < 2: return -1 unique_integers = set(arr) if len(unique_integers) < 2: return -1 sorted_uniques = sorted(unique_integers) return sorted_uniques[0] + sorted_uniques[1] if __name__ == \\"__main__\\": import sys input = sys.stdin.read data = input().split() N = int(data[0]) arr = list(map(int, data[1:])) print(sum_of_two_smallest_unique_integers(N, arr))"},{"question":"class TreeNode: def __init__(self, value): self.value = value self.left = None self.right = None def build_tree(level_order, edges): Build the binary tree from level order and edge list. pass def has_path_sum(root, target_sum): Determine if there exists a root-to-leaf path in the tree such that the sum of the node values along the path is equal to a given target sum. pass def find_path_to_sum(N, S, level_order, edges): Find a root-to-leaf path such that the sum is equal to a given target sum S. If path exists, return the nodes along the path from root to leaf, otherwise return -1. Parameters: N (int): number of nodes in the tree S (int): target sum level_order (List[int]): list of node values in level order traversal edges (List[Tuple[int, int]]): list of edges in the format (parent, child) Returns: List[int] or int: list of node values along the path or -1 if no such path exists Examples: >>> find_path_to_sum(5, 10, [5, 3, 8, 2, 6], [(5, 3), (5, 8), (3, 2), (3, 6)]) [5, 3, 2] >>> find_path_to_sum(3, 15, [1, 2, 3], [(1, 2), (1, 3)]) -1 pass","solution":"class TreeNode: def __init__(self, value): self.value = value self.left = None self.right = None def build_tree(level_order, edges): if not level_order: return None nodes = {val: TreeNode(val) for val in level_order} for A, B in edges: if nodes[A].left is None: nodes[A].left = nodes[B] else: nodes[A].right = nodes[B] return nodes[level_order[0]] def has_path_sum(root, target_sum): def dfs(node, current_sum, path): if not node: return None current_sum += node.value path.append(node.value) if not node.left and not node.right: # Leaf node if current_sum == target_sum: return path if node.left: left_path = dfs(node.left, current_sum, path.copy()) if left_path: return left_path if node.right: right_path = dfs(node.right, current_sum, path.copy()) if right_path: return right_path return None result = dfs(root, 0, []) return result if result else -1 def find_path_to_sum(N, S, level_order, edges): root = build_tree(level_order, edges) return has_path_sum(root, S)"},{"question":"from typing import List, Tuple def busiest_intervals(test_cases: List[List[Tuple[int, int, int]]]) -> List[Tuple[int, int]]: Determine the interval (or intervals) with the highest total data traffic. If there are multiple intervals with the same highest traffic, output all such intervals in increasing order of their start time. >>> busiest_intervals([[(1, 10, 100), (5, 15, 150), (10, 20, 200)]]) [(10, 20)] >>> busiest_intervals([[(5, 10, 300), (10, 15, 300), (15, 20, 100), (20, 25, 50)]]) [(5, 10), (10, 15)]","solution":"def busiest_intervals(test_cases): results = [] for intervals in test_cases: # Create a dictionary to store the total data for each interval data_traffic = {} for start, end, data in intervals: # Calculate the total data for each interval and store in the dictionary interval = (start, end) if interval not in data_traffic: data_traffic[interval] = 0 data_traffic[interval] += data # Find the maximum traffic max_traffic = max(data_traffic.values()) # Collect all intervals with the maximum traffic busiest_intervals = [ interval for interval, traffic in data_traffic.items() if traffic == max_traffic ] # Sort the intervals by their start time busiest_intervals.sort() results.extend(busiest_intervals) return results"},{"question":"from typing import List, Tuple, Union def is_valid(matrix, x, y, n, m): return 0 <= x < n and 0 <= y < m and matrix[x][y] == '.' def update_grid_with_trees(grid, tree_positions, t): for i in range(t + 1): if i < len(tree_positions): x, y = tree_positions[i] if grid[x][y] == '.': grid[x][y] = '#' def shortest_path_in_forest(N: int, M: int, sx: int, sy: int, ex: int, ey: int, grid: List[List[str]], T: int, tree_positions: List[Tuple[int, int]]) -> Union[int, str]: Find the shortest path the friends can take to reach the campsite. >>> shortest_path_in_forest(5, 5, 0, 0, 4, 4, [\\".....\\", \\"..#..\\", \\"..#..\\", \\"..#..\\", \\".....\\"], 5, [(0, 4), (4, 0), (1, 1), (1, 3), (3, 3)]) 8 >>> shortest_path_in_forest(3, 3, 0, 0, 2, 2, [\\".#.\\", \\"#..\\", \\"..#\\"], 4, [(0, 1), (1, 0), (2, 0), (0, 2)]) \\"Impossible\\"","solution":"from collections import deque def is_valid(matrix, x, y, n, m): return 0 <= x < n and 0 <= y < m and matrix[x][y] == '.' def update_grid_with_trees(grid, tree_positions, t): for i in range(t + 1): if i < len(tree_positions): x, y = tree_positions[i] if grid[x][y] == '.': grid[x][y] = '#' def shortest_path_in_forest(N, M, sx, sy, ex, ey, grid, T, tree_positions): directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] visited = set() queue = deque([(sx, sy, 0)]) while queue: x, y, moves = queue.popleft() if (x, y) == (ex, ey): return moves # Update the grid with trees update_grid_with_trees(grid, tree_positions, moves) for dx, dy in directions: nx, ny = x + dx, y + dy if is_valid(grid, nx, ny, N, M) and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny, moves + 1)) return \\"Impossible\\""},{"question":"from typing import List, Tuple def autocomplete(suggestions: List[Tuple[str, int]], k: int, typed: str) -> List[str]: Provide the most relevant words that start with the user's current input. Args: suggestions (List[Tuple[str, int]]): A list of tuples where each tuple contains a string and an integer (word, frequency). k (int): A positive integer representing the maximum number of suggestions to return. typed (str): A string representing the current user input. Returns: List[str]: A list of the top k suggested words sorted by their relevance. >>> autocomplete([(\\"apple\\", 5), (\\"appreciate\\", 3), (\\"apply\\", 7), (\\"ape\\", 2), (\\"april\\", 6)], 3, \\"app\\") [\\"apply\\", \\"apple\\", \\"appreciate\\"] >>> autocomplete([(\\"apple\\", 5), (\\"appreciate\\", 3), (\\"apply\\", 7)], 5, \\"app\\") [\\"apply\\", \\"apple\\", \\"appreciate\\"] >>> autocomplete([(\\"apple\\", 5), (\\"appreciate\\", 3), (\\"apply\\", 5), (\\"app\\", 6)], 4, \\"app\\") [\\"app\\", \\"apple\\", \\"apply\\", \\"appreciate\\"] >>> autocomplete([(\\"apple\\", 5), (\\"appreciate\\", 3), (\\"apply\\", 7), (\\"ape\\", 2), (\\"april\\", 6)], 3, \\"xyz\\") [] >>> autocomplete([], 3, \\"app\\") []","solution":"from typing import List, Tuple def autocomplete(suggestions: List[Tuple[str, int]], k: int, typed: str) -> List[str]: # Filter words that start with the typed prefix filtered_words = [word for word, freq in suggestions if word.startswith(typed)] # Get the corresponding frequencies for the filtered words filtered_suggestions = [(word, freq) for word, freq in suggestions if word in filtered_words] # Sort primarily by frequency (descending) and secondarily by word (alphabetically) sorted_suggestions = sorted(filtered_suggestions, key=lambda x: (-x[1], x[0])) # Retrieve only the words from the sorted suggestions result = [word for word, freq in sorted_suggestions] return result[:k]"},{"question":"def min_moves_to_all_ones(binary_string): Returns the minimum number of moves to transform binary_string into all ones. >>> min_moves_to_all_ones(\\"010\\") 2 >>> min_moves_to_all_ones(\\"1100\\") 1 >>> min_moves_to_all_ones(\\"000111\\") 1 >>> min_moves_to_all_ones(\\"11111\\") 0 >>> min_moves_to_all_ones(\\"00000\\") 1 >>> min_moves_to_all_ones(\\"0010010\\") 3 def solution(T, test_cases): Given T test cases, returns a list of minimum moves required for each binary string. >>> solution(3, [\\"010\\", \\"1100\\", \\"000111\\"]) [2, 1, 1] >>> solution(2, [\\"11111\\", \\"00000\\"]) [0, 1] >>> solution(3, [\\"1\\", \\"0\\", \\"101010\\"]) [0, 1, 3]","solution":"def min_moves_to_all_ones(binary_string): Returns the minimum number of moves to transform binary_string into all ones. # Counting the number of segments of consecutive '0's in_zero_segment = False zero_segments = 0 for char in binary_string: if char == '0': if not in_zero_segment: zero_segments += 1 in_zero_segment = True else: in_zero_segment = False return zero_segments def solution(T, test_cases): results = [] for binary_string in test_cases: results.append(min_moves_to_all_ones(binary_string)) return results"},{"question":"def min_desks_required(W, schedules): Determines the minimum number of desks required to accommodate all employees on their scheduled office days. :param W: Number of employees :param schedules: List of strings representing the office schedule of each employee :return: Minimum number of desks required # Your code here. from solution import min_desks_required def test_example_case(): W = 3 schedules = [\\"1110000\\", \\"0001110\\", \\"1000100\\"] assert min_desks_required(W, schedules) == 2 def test_single_employee_full_week(): W = 1 schedules = [\\"1111111\\"] assert min_desks_required(W, schedules) == 1 def test_single_employee_partial_week(): W = 1 schedules = [\\"1010101\\"] assert min_desks_required(W, schedules) == 1 def test_multiple_employees_different_days(): W = 4 schedules = [\\"1000000\\", \\"0100000\\", \\"0010000\\", \\"0001000\\"] assert min_desks_required(W, schedules) == 1 def test_multiple_employees_same_days(): W = 3 schedules = [\\"1000000\\", \\"1000000\\", \\"1000000\\"] assert min_desks_required(W, schedules) == 3 def test_large_case(): W = 1000 schedules = [\\"1000000\\"] * 1000 assert min_desks_required(W, schedules) == 1000 def test_no_overlap(): W = 3 schedules = [\\"1000000\\", \\"0100000\\", \\"0010000\\"] assert min_desks_required(W, schedules) == 1 def test_all_overlap(): W = 3 schedules = [\\"1111111\\", \\"1111111\\", \\"1111111\\"] assert min_desks_required(W, schedules) == 3","solution":"def min_desks_required(W, schedules): Determines the minimum number of desks required to accommodate all employees on their scheduled office days. :param W: Number of employees :param schedules: List of strings representing the office schedule of each employee :return: Minimum number of desks required max_desks_per_day = [0] * 7 for schedule in schedules: for day in range(7): if schedule[day] == '1': max_desks_per_day[day] += 1 return max(max_desks_per_day)"},{"question":"from typing import List, Optional class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def merge_k_sorted_lists(lists: List[Optional[ListNode]]) -> Optional[ListNode]: Merges k sorted linked lists into one sorted linked list. pass def linked_list_to_list(head: Optional[ListNode]) -> List[int]: result = [] while head: result.append(head.val) head = head.next return result def test_merge_k_sorted_lists_example1(): list1 = ListNode(1, ListNode(4, ListNode(5))) list2 = ListNode(1, ListNode(3, ListNode(4))) list3 = ListNode(2, ListNode(6)) lists = [list1, list2, list3] merged_list = merge_k_sorted_lists(lists) assert linked_list_to_list(merged_list) == [1, 1, 2, 3, 4, 4, 5, 6] def test_merge_k_sorted_lists_empty_lists(): lists = [] merged_list = merge_k_sorted_lists(lists) assert merged_list is None def test_merge_k_sorted_lists_single_empty_list(): lists = [None] merged_list = merge_k_sorted_lists(lists) assert merged_list is None def test_merge_k_sorted_lists_mixed_empty_and_non_empty(): list1 = None list2 = ListNode(1) lists = [list1, list2] merged_list = merge_k_sorted_lists(lists) assert linked_list_to_list(merged_list) == [1] def test_merge_k_sorted_lists_multiple_empty_lists(): lists = [None, None, None] merged_list = merge_k_sorted_lists(lists) assert merged_list is None def test_merge_k_sorted_lists_multiple_single_element_lists(): list1 = ListNode(1) list2 = ListNode(3) list3 = ListNode(2) lists = [list1, list2, list3] merged_list = merge_k_sorted_lists(lists) assert linked_list_to_list(merged_list) == [1, 2, 3]","solution":"from typing import List, Optional import heapq class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def merge_k_sorted_lists(lists: List[Optional[ListNode]]) -> Optional[ListNode]: Merges k sorted linked lists into one sorted linked list. # Define a wrapper for ListNode to be used in heapq class HeapNode: def __init__(self, node): self.node = node def __lt__(self, other): return self.node.val < other.node.val min_heap = [] for l in lists: if l: heapq.heappush(min_heap, HeapNode(l)) dummy = ListNode() current = dummy while min_heap: smallest = heapq.heappop(min_heap).node current.next = smallest current = current.next if smallest.next: heapq.heappush(min_heap, HeapNode(smallest.next)) return dummy.next"},{"question":"def count_palindromic_sequences(half_sequence: str) -> int: Given the first half of a tile sequence, returns the number of distinct palindromic sequences that can be formed. >>> count_palindromic_sequences(\\"RB\\") 4 >>> count_palindromic_sequences(\\"RRB\\") 8 >>> count_palindromic_sequences(\\"BR\\") 4 >>> count_palindromic_sequences(\\"R\\") 2 >>> count_palindromic_sequences(\\"B\\") 2 >>> count_palindromic_sequences(\\"RBR\\") 8 def process_input(input_strings: List[str]) -> List[int]: Processes multiple input strings and returns the number of distinct palindromic sequences for each. >>> process_input([\\"RB\\", \\"RRB\\", \\"BR\\"]) [4, 8, 4] >>> process_input([\\"R\\", \\"B\\"]) [2, 2] >>> process_input([\\"\\"]) [1] >>> process_input([\\"RBR\\", \\"BBRBR\\", \\"RBBBB\\"]) [8, 32, 32] >>> process_input([\\"RRRR\\", \\"BBBB\\"]) [16, 16]","solution":"def count_palindromic_sequences(half_sequence): Given the first half of a tile sequence, returns the number of distinct palindromic sequences that can be formed. return 2 ** (half_sequence.count('R') + half_sequence.count('B')) def process_input(input_strings): Processes multiple input strings and returns the number of distinct palindromic sequences for each. results = [] for s in input_strings: results.append(count_palindromic_sequences(s)) return results"},{"question":"def unique_paths_from_input(N: int, M: int, grid_lines: List[str]) -> int: Determine the number of unique paths from the top-left corner to the bottom-right corner of a grid, avoiding all blocked cells. Args: N : int : Number of rows in the grid M : int : Number of columns in the grid grid_lines : List[str] : Grid representation where '.' is an empty cell and '#' is a blocked cell Returns: int : Total number of unique paths modulo (10^9 + 7) >>> unique_paths_from_input(3, 3, [\\"...\\", \\".#.\\", \\"...\\"]) == 2 >>> unique_paths_from_input(3, 3, [\\"...\\", \\"...\\", \\"...\\"]) == 6 >>> unique_paths_from_input(1, 1, [\\".\\"]) == 1 >>> unique_paths_from_input(2, 2, [\\"..\\", \\"#.\\"]) == 1 >>> unique_paths_from_input(4, 5, [\\"..#..\\", \\".#...\\", \\"...#.\\", \\".....\\"]) == 3 pass # Write your implementation here.","solution":"MOD = 10**9 + 7 def count_unique_paths(grid): N = len(grid) M = len(grid[0]) # Create a dp table dp = [[0] * M for _ in range(N)] # Starting position if grid[0][0] == '.': dp[0][0] = 1 for i in range(N): for j in range(M): if grid[i][j] == '#': dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] dp[i][j] %= MOD return dp[N-1][M-1] def unique_paths_from_input(N, M, grid_lines): grid = [list(line) for line in grid_lines] return count_unique_paths(grid)"},{"question":"from typing import List def longest_consecutive_sequence(arr: List[int]) -> int: Find the length of the longest consecutive elements sequence in the array. >>> longest_consecutive_sequence([100, 4, 200, 1, 3, 2]) 4 >>> longest_consecutive_sequence([0, 3, 7, 2, 5, 8, 4, 6, 0, 1]) 9 >>> longest_consecutive_sequence([]) 0 >>> longest_consecutive_sequence([10]) 1 >>> longest_consecutive_sequence([5, 10, 15]) 1 >>> longest_consecutive_sequence([1, 1, 1, 1]) 1 >>> longest_consecutive_sequence([10, 1, 2, 3, 4, 7, 8, 5, 6, 9]) 10 >>> longest_consecutive_sequence([1, 2, 2, 3, 5, 6, 7, 8, 9, 9, 10]) 6","solution":"def longest_consecutive_sequence(arr): Returns the length of the longest consecutive elements sequence in the array. if not arr: return 0 num_set = set(arr) longest_streak = 0 for num in num_set: if num - 1 not in num_set: current_num = num current_streak = 1 while current_num + 1 in num_set: current_num += 1 current_streak += 1 longest_streak = max(longest_streak, current_streak) return longest_streak"},{"question":"def count_operations(nums: List[int]) -> int: Returns the number of operations required to transform the array into a single integer. Each operation consists of replacing any two adjacent elements in the array with their sum. Example usage: >>> count_operations([1, 3, 2, 4]) 3 >>> count_operations([5, -2, 3]) 2 >>> count_operations([10]) 0","solution":"def count_operations(nums): Returns the number of operations required to transform the array into a single integer. Each operation consists of replacing any two adjacent elements in the array with their sum. # The number of operations needed is just one less than the number of elements in the array return len(nums) - 1"},{"question":"from typing import List def categorize_feedback(F: int, K: int, feedbacks: List[str], keywords: List[str]) -> (List[str], List[str]): Categorize feedback comments into 'Relevant' and 'Irrelevant' based on provided keywords. >>> categorize_feedback(4, 3, [\\"The product is great and useful\\", \\"I am not satisfied with this product\\", \\"Customer support was friendly and helpful\\", \\"I found the interface confusing\\"], [\\"great\\", \\"satisfied\\", \\"helpful\\"]) ([\\"The product is great and useful\\", \\"I am not satisfied with this product\\", \\"Customer support was friendly and helpful\\"], [\\"I found the interface confusing\\"]) >>> categorize_feedback(3, 2, [\\"Delivery was slow\\", \\"Great customer service\\", \\"Recommend this product to everyone\\"], [\\"slow\\", \\"Recommend\\"]) ([\\"Delivery was slow\\", \\"Recommend this product to everyone\\"], [\\"Great customer service\\"]) import io import sys from solution import categorize_feedback def test_categorize_feedback_example1(): F = 4 K = 3 feedbacks = [ \\"The product is great and useful\\", \\"I am not satisfied with this product\\", \\"Customer support was friendly and helpful\\", \\"I found the interface confusing\\" ] keywords = [\\"great\\", \\"satisfied\\", \\"helpful\\"] relevant, irrelevant = categorize_feedback(F, K, feedbacks, keywords) assert relevant == [ \\"The product is great and useful\\", \\"I am not satisfied with this product\\", \\"Customer support was friendly and helpful\\" ] assert irrelevant == [\\"I found the interface confusing\\"] def test_categorize_feedback_example2(): F = 3 K = 2 feedbacks = [ \\"Delivery was slow\\", \\"Great customer service\\", \\"Recommend this product to everyone\\" ] keywords = [\\"slow\\", \\"Recommend\\"] relevant, irrelevant = categorize_feedback(F, K, feedbacks, keywords) assert relevant == [ \\"Delivery was slow\\", \\"Recommend this product to everyone\\" ] assert irrelevant == [\\"Great customer service\\"] def test_categorize_feedback_no_keywords(): F = 2 K = 0 feedbacks = [ \\"Product is affordable\\", \\"Customer service is excellent\\" ] keywords = [] relevant, irrelevant = categorize_feedback(F, K, feedbacks, keywords) assert relevant == [] assert irrelevant == [ \\"Product is affordable\\", \\"Customer service is excellent\\" ] def test_categorize_feedback_no_feedbacks(): F = 0 K = 1 feedbacks = [] keywords = [\\"affordable\\"] relevant, irrelevant = categorize_feedback(F, K, feedbacks, keywords) assert relevant == [] assert irrelevant == [] def test_categorize_feedback_all_irrelevant(): F = 3 K = 2 feedbacks = [ \\"The product is overpriced\\", \\"Customer service could be better\\", \\"Delivery took too long\\" ] keywords = [\\"great\\", \\"helpful\\"] relevant, irrelevant = categorize_feedback(F, K, feedbacks, keywords) assert relevant == [] assert irrelevant == [ \\"The product is overpriced\\", \\"Customer service could be better\\", \\"Delivery took too long\\" ]","solution":"def categorize_feedback(F, K, feedbacks, keywords): relevant = [] irrelevant = [] keyword_set = set(keywords) for feedback in feedbacks: if any(keyword in feedback for keyword in keyword_set): relevant.append(feedback) else: irrelevant.append(feedback) return relevant, irrelevant def main(): import sys input = sys.stdin.read data = input().splitlines() F, K = map(int, data[0].split()) feedbacks = data[1:F + 1] keywords = data[F + 1:F + 1 + K] relevant, irrelevant = categorize_feedback(F, K, feedbacks, keywords) print(\\"Relevant:\\") for feedback in relevant: print(feedback) print(\\"Irrelevant:\\") for feedback in irrelevant: print(feedback) if __name__ == \\"__main__\\": main()"},{"question":"def can_form_palindrome(s: str) -> str: Determines if a string can be rearranged to form a palindrome. :param s: str - input string :return: str - \\"YES\\" if the string can be rearranged to form a palindrome, otherwise \\"NO\\" >>> can_form_palindrome(\\"carrace\\") 'YES' >>> can_form_palindrome(\\"hello\\") 'NO' >>> can_form_palindrome(\\"aabb\\") 'YES' >>> can_form_palindrome(\\"abc\\") 'NO'","solution":"def can_form_palindrome(s): Determines if a string can be rearranged to form a palindrome. :param s: str - input string :return: str - \\"YES\\" if the string can be rearranged to form a palindrome, otherwise \\"NO\\" from collections import Counter char_count = Counter(s) # Count the number of characters that have an odd frequency odd_count = sum(1 for count in char_count.values() if count % 2 != 0) # For a string to be rearranged into a palindrome # there should be at most one character with an odd frequency if odd_count <= 1: return \\"YES\\" else: return \\"NO\\""},{"question":"def merge_strings(A: str, B: str) -> str: Merges two strings A and B into a new string C by alternating characters from each, starting with the first character of A. >>> merge_strings(\\"abcd\\", \\"wxyz\\") == \\"awbxcydz\\" >>> merge_strings(\\"hello\\", \\"world\\") == \\"hweolrllod\\" >>> merge_strings(\\"a\\", \\"b\\") == \\"ab\\" >>> merge_strings(\\"x\\", \\"y\\") == \\"xy\\" >>> merge_strings(\\"a\\"*1000, \\"b\\"*1000) == 'ab' * 1000 >>> merge_strings(\\"x\\"*999, \\"y\\"*999) == 'xy' * 999","solution":"def merge_strings(A: str, B: str) -> str: Merges two strings A and B into a new string C by alternating characters from each, starting with the first character of A. merged_string = [] min_length = min(len(A), len(B)) # Use the length of the shorter string for i in range(min_length): merged_string.append(A[i]) merged_string.append(B[i]) # Join list into a single string and return return ''.join(merged_string)"},{"question":"def central_city(n: int, roads: List[Tuple[int, int]]) -> int: Determine the optimal city to build the palace in order to minimize the maximum distance from the palace to any other city. Args: n (int): The number of cities. roads (List[Tuple[int, int]]): A list of tuples where each tuple represents a road between two cities. Returns: int: The number of the city where the king should build his palace. Examples: >>> central_city(7, [(1, 2), (1, 3), (2, 4), (2, 5), (3, 6), (3, 7)]) 1 >>> central_city(5, [(1, 2), (1, 3), (2, 4), (3, 5)]) 1","solution":"from collections import defaultdict, deque def find_farthest_node(start_node, graph): Returns the farthest node from start_node and its distance using BFS. n = len(graph) visited = [False] * (n + 1) distance = [0] * (n + 1) queue = deque([start_node]) visited[start_node] = True while queue: node = queue.popleft() for neighbor in graph[node]: if not visited[neighbor]: visited[neighbor] = True distance[neighbor] = distance[node] + 1 queue.append(neighbor) max_distance = max(distance) farthest_node = distance.index(max_distance) return farthest_node, max_distance def central_city(n, roads): Returns the city that minimizes the maximum distance to any other city. if n == 1: return 1 graph = defaultdict(list) for u, v in roads: graph[u].append(v) graph[v].append(u) # Step 1: Find the farthest node from an arbitrary node (let's start with node 1) farthest_node, _ = find_farthest_node(1, graph) # Step 2: Find the farthest node from the previously found farthest node farthest_node_from_far, diameter = find_farthest_node(farthest_node, graph) # Step 3: Find the path between the two farthest nodes (the diameter path) def find_path(start, end): parent = [-1] * (n + 1) queue = deque([start]) parent[start] = start while queue: node = queue.popleft() if node == end: break for neighbor in graph[node]: if parent[neighbor] == -1: parent[neighbor] = node queue.append(neighbor) path = [] node = end while node != start: path.append(node) node = parent[node] path.append(start) return path path = find_path(farthest_node, farthest_node_from_far) central = path[len(path) // 2] return central"},{"question":"from typing import List def max_value_path(grid: List[List[int]]) -> int: Returns the maximum value obtainable by moving from the top-left corner to the bottom-right corner of the grid, only moving right or down. >>> max_value_path([ ... [1, 3, 1], ... [1, 5, 1], ... [4, 2, 1] ... ]) == 12 # Path: 1 -> 3 -> 5 -> 2 -> 1 >>> max_value_path([ ... [1, 2, 5], ... [3, 2, 1] ... ]) == 9 # Path: 1 -> 2 -> 5 -> 1 >>> max_value_path([ ... [5] ... ]) == 5 # Single cell, value is 5 >>> max_value_path([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) == 29 # Path: 1 -> 2 -> 3 -> 6 -> 9 >>> max_value_path([ ... [2, 2, 2], ... [1, 1, 1], ... [2, 2, 2] ... ]) == 9 # Path: multiple equivalents","solution":"def max_value_path(grid): Returns the maximum value obtainable by moving from the top-left corner to the bottom-right corner of the grid, only moving right or down. m = len(grid) n = len(grid[0]) # We use dynamic programming to keep track of maximum values dp = [[0] * n for _ in range(m)] # Set the value of the starting point dp[0][0] = grid[0][0] # Fill the first row (can only come from the left) for j in range(1, n): dp[0][j] = dp[0][j-1] + grid[0][j] # Fill the first column (can only come from above) for i in range(1, m): dp[i][0] = dp[i-1][0] + grid[i][0] # Fill the rest of the grid for i in range(1, m): for j in range(1, n): dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j] return dp[m-1][n-1]"},{"question":"def smallest_character(s: str, queries: List[Tuple[int, int]]) -> List[str]: For each query, determine the lexicographically smallest character in the specified substring. Parameters: s (str): The input string. queries (list of tuples): List of queries, where each query is a tuple (l, r). Returns: list: List of the smallest characters for each query. >>> smallest_character(\\"abacabadabacaba\\", [(1, 3), (4, 7), (1, 15), (8, 10), (2, 5)]) ['a', 'a', 'a', 'a', 'a'] >>> smallest_character(\\"z\\", [(1, 1)]) ['z'] >>> smallest_character(\\"uvwxyz\\", [(1, 2), (3, 5), (1, 6), (4, 4)]) ['u', 'w', 'u', 'x'] >>> smallest_character(\\"abcd\\", [(1, 4), (4, 4), (2, 3), (1, 1)]) ['a', 'd', 'b', 'a'] >>> smallest_character(\\"aaaaa\\", [(1, 5), (3, 3), (2, 4)]) ['a', 'a', 'a']","solution":"def smallest_character(s, queries): For each query, determine the lexicographically smallest character in the specified substring. Parameters: s (str): The input string. queries (list of tuples): List of queries, where each query is a tuple (l, r). Returns: list: List of the smallest characters for each query. results = [] for l, r in queries: substring = s[l-1:r] results.append(min(substring)) return results"},{"question":"def auction(items: List[int], bidders: List[int]) -> Union[List[int], str]: Finds an optimal assignment of items to bidders such that each item's reserve price is met and each bidder's maximum bid is respected. Parameters: items (list): List of reserve prices of the items. bidders (list): List of maximum bids of the bidders. Returns: list: A list with the assignment of items to bidders or \\"Not Possible\\" if no valid assignment exists. >>> auction([10, 20, 30], [15, 25, 35, 40]) [3, 4, 2] >>> auction([100, 200], [50, 300]) 'Not Possible'","solution":"def auction(items, bidders): Finds an optimal assignment of items to bidders such that each item's reserve price is met and each bidder's maximum bid is respected. Parameters: items (list): List of reserve prices of the items. bidders (list): List of maximum bids of the bidders. Returns: list: A list with the assignment of items to bidders or \\"Not Possible\\" if no valid assignment exists. n = len(items) m = len(bidders) # Create a list of item indices and sort it based on reserve prices (descending) item_indices = list(range(n)) item_indices.sort(key=lambda i: items[i], reverse=True) # Create a list of bidder indices and sort it based on maximum bids (descending) bidder_indices = list(range(m)) bidder_indices.sort(key=lambda j: bidders[j], reverse=True) assignment = [-1] * n j = 0 for i in item_indices: while j < m and bidders[bidder_indices[j]] < items[i]: j += 1 if j == m: return \\"Not Possible\\" assignment[i] = bidder_indices[j] + 1 j += 1 return assignment"},{"question":"def max_sum_of_subsequence(n, k, sequence): Returns the maximum sum of any contiguous subsequence of length k. Arguments: n -- number of integers in the sequence k -- size of the window sequence -- list of integers representing the sequence Returns: The maximum sum of any contiguous subsequence of length k. >>> max_sum_of_subsequence(10, 4, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) 34 >>> max_sum_of_subsequence(6, 2, [-1, -2, -3, -4, -5, -6]) -3","solution":"def max_sum_of_subsequence(n, k, sequence): Returns the maximum sum of any contiguous subsequence of length k. Arguments: n -- number of integers in the sequence k -- size of the window sequence -- list of integers representing the sequence Returns: The maximum sum of any contiguous subsequence of length k. # Initialize the sum of the first window max_sum = current_sum = sum(sequence[:k]) # Slide the window across the array, updating sums for i in range(k, n): current_sum += sequence[i] - sequence[i - k] if current_sum > max_sum: max_sum = current_sum return max_sum"},{"question":"def sum_of_smallest_two_distinct_elements(t:int, test_cases:List[Tuple[int, List[int]]]) -> List[int]: Given an array of integers, determine the sum of the smallest two distinct elements in the array. If the array has fewer than two distinct elements, return -1. Args: t (int): The number of test cases. test_cases (List[Tuple[int, List[int]]]): List of tuples where each tuple contains an integer (number of elements in the array) and a list of integers (the array). Returns: List[int]: List of results for each test case. >>> sum_of_smallest_two_distinct_elements(3, [(5, [1, 3, 5, 1, 2]), (4, [7, 7, 7, 7]), (6, [5, 1, 3, 2, 4, 2])]) [3, -1, 3] >>> sum_of_smallest_two_distinct_elements(1, [(3, [5, 5, 5])]) [-1] results = [] for n, arr in test_cases: distinct_elements = sorted(set(arr)) if len(distinct_elements) < 2: results.append(-1) else: results.append(distinct_elements[0] + distinct_elements[1]) return results # Unit tests def test_sum_of_smallest_two_distinct_elements_1(): input_data = \\"3n5n1 3 5 1 2n4n7 7 7 7n6n5 1 3 2 4 2\\" expected_output = [3, -1, 3] assert solve(input_data) == expected_output def test_sum_of_smallest_two_distinct_elements_2(): input_data = \\"1n3n5 5 5\\" expected_output = [-1] assert solve(input_data) == expected_output def test_sum_of_smallest_two_distinct_elements_3(): input_data = \\"2n2n-1 -1n4n3 1 2 1\\" expected_output = [-1, 3] assert solve(input_data) == expected_output def test_sum_of_smallest_two_distinct_elements_4(): input_data = \\"2n1n10n2n0 -1\\" expected_output = [-1, -1] assert solve(input_data) == expected_output def test_sum_of_smallest_two_distinct_elements_5(): input_data = \\"2n5n2 2 2 3 3n3n0 0 0\\" expected_output = [5, -1] assert solve(input_data) == expected_output # Function to parse input data and call the main solver function def solve(input_data: str) -> List[int]: input_lines = input_data.strip().split(\\"n\\") t = int(input_lines[0]) test_cases = [] index = 1 for _ in range(t): n = int(input_lines[index]) arr = list(map(int, input_lines[index + 1].strip().split())) test_cases.append((n, arr)) index += 2 return sum_of_smallest_two_distinct_elements(t, test_cases)","solution":"def sum_of_smallest_two_distinct_elements(t, test_cases): results = [] for n, arr in test_cases: distinct_elements = sorted(set(arr)) if len(distinct_elements) < 2: results.append(-1) else: results.append(distinct_elements[0] + distinct_elements[1]) return results # Function to parse input data and call the main solver function def solve(input_data): input_lines = input_data.strip().split(\\"n\\") t = int(input_lines[0]) test_cases = [] index = 1 for _ in range(t): n = int(input_lines[index]) arr = list(map(int, input_lines[index + 1].strip().split())) test_cases.append((n, arr)) index += 2 return sum_of_smallest_two_distinct_elements(t, test_cases)"},{"question":"def min_operations_to_make_unique_sequence(n: int, sequence: List[int]) -> int: Determines the minimum number of operations to transform the sequence so that no two adjacent elements are the same. :param n: Number of elements in the sequence :param sequence: List of integers representing the sequence :return: Minimum number of operations required >>> min_operations_to_make_unique_sequence(5, [1, 2, 2, 3, 4]) 1 >>> min_operations_to_make_unique_sequence(6, [1, 1, 1, 1, 1, 1]) 3 >>> min_operations_to_make_unique_sequence(4, [4, 4, 4, 4]) 2 >>> min_operations_to_make_unique_sequence(1, [10]) 0 >>> min_operations_to_make_unique_sequence(3, [1, 2, 3]) 0 >>> min_operations_to_make_unique_sequence(3, [1000000000, 1000000000, 1000000000]) 1 >>> min_operations_to_make_unique_sequence(5, [5, 5, 5, 5, 5]) 2 # Your code here","solution":"def min_operations_to_make_unique_sequence(n, sequence): Determines the minimum number of operations to transform the sequence so that no two adjacent elements are the same. :param n: Number of elements in the sequence :param sequence: List of integers representing the sequence :return: Minimum number of operations required # Edge case when the sequence length is 1 if n == 1: return 0 operations = 0 for i in range(1, n): if sequence[i] == sequence[i-1]: # Perform operation to change the current element sequence[i] = -1 # Temporarily set to an invalid number to indicate it's changed operations += 1 return operations"},{"question":"def minimum_days(k: int, n: int, tasks: List[int]) -> int: Determines the minimum number of days for David to complete all tasks. Args: k (int): number of days available. n (int): number of tasks to complete. tasks (list of int): the duration (in days) needed to complete each task. Returns: int: Minimum number of days required to complete all tasks. >>> minimum_days(15, 3, [2, 3, 5]) 10 >>> minimum_days(10, 4, [3, 2, 3, 1]) 9 >>> minimum_days(5, 2, [3, 3]) 6 def test_minimum_days_example1(): assert minimum_days(15, 3, [2, 3, 5]) == 10 def test_minimum_days_example2(): assert minimum_days(10, 4, [3, 2, 3, 1]) == 9 def test_minimum_days_example3(): assert minimum_days(5, 2, [3, 3]) == 6 def test_minimum_days_single_task(): assert minimum_days(5, 1, [4]) == 4 def test_minimum_days_with_rest(): # Here, k is greater than sum(tasks), no rest day needed. assert minimum_days(20, 3, [3, 4, 2]) == 9 def test_minimum_days_edge_case(): # Tests the edge case where k and n are both 1 and the task duration is 1. assert minimum_days(1, 1, [1]) == 1","solution":"def minimum_days(k, n, tasks): Determines the minimum number of days for David to complete all tasks. Args: k (int): number of days available. n (int): number of tasks to complete. tasks (list of int): the duration (in days) needed to complete each task. Returns: int: Minimum number of days required to complete all tasks. total_days_needed = sum(tasks) return total_days_needed"},{"question":"def max_fish_catch(N, K, fish_counts, travel_times): Determines the maximum number of fish Bert can catch in his K-week vacation by selecting the optimal lakes. Arguments: N -- Number of lakes K -- Number of weeks fish_counts -- List of integers denoting the number of fish in each lake travel_times -- List of integers denoting the travel and fishing time for each lake Returns: int -- Maximum number of fish Bert can catch >>> max_fish_catch(5, 3, [7, 2, 5, 8, 10], [2, 1, 4, 3, 5]) 25 >>> max_fish_catch(4, 2, [4, 4, 4, 4], [1, 1, 1, 1]) 8 >>> max_fish_catch(4, 1, [4, 5, 6, 7], [3, 2, 1, 4]) 7 >>> max_fish_catch(100, 10, [i for i in range(1, 101)], [i for i in range(1, 101)]) 955 >>> max_fish_catch(6, 3, [10, 10, 10, 10, 10, 10], [6, 5, 4, 3, 2, 1]) 30","solution":"def max_fish_catch(N, K, fish_counts, travel_times): Determines the maximum number of fish Bert can catch in his K-week vacation by selecting the optimal lakes. Arguments: N -- Number of lakes K -- Number of weeks fish_counts -- List of integers denoting the number of fish in each lake travel_times -- List of integers denoting the travel and fishing time for each lake Returns: int -- Maximum number of fish Bert can catch # Create a list of tuples where each tuple is (fish_counts[i], travel_times[i]) lake_info = [(fish_counts[i], travel_times[i]) for i in range(N)] # Sort lakes based on the number of fish in descending order lake_info.sort(reverse=True, key=lambda x: x[0]) # Select the lakes with the highest numbers of fish for K weeks max_fish = sum(lake_info[i][0] for i in range(K)) return max_fish # Sample Input N = 5 K = 3 fish_counts = [7, 2, 5, 8, 10] travel_times = [2, 1, 4, 3, 5] # Sample Output max_fish_catch(N, K, fish_counts, travel_times) # Expected output: 25"},{"question":"def shift_end_time(K: int, L: int) -> int: Determines the ending time of a working shift. Parameters: K (int): Starting time in 24-hour notation. L (int): Duration of the shift in hours. Returns: int: Ending time in 24-hour notation. Examples: >>> shift_end_time(9, 5) 14 >>> shift_end_time(20, 6) 2 >>> shift_end_time(0, 24) 0 >>> shift_end_time(23, 2) 1 >>> shift_end_time(13, 0) 13 >>> shift_end_time(15, 24) 15 from solution import shift_end_time def test_shift_end_time_case_1(): assert shift_end_time(9, 5) == 14 def test_shift_end_time_case_2(): assert shift_end_time(20, 6) == 2 def test_shift_end_time_midnight_case(): assert shift_end_time(0, 24) == 0 def test_shift_end_time_over_midnight(): assert shift_end_time(23, 2) == 1 def test_shift_end_time_no_duration(): assert shift_end_time(13, 0) == 13 def test_shift_end_time_max_duration(): assert shift_end_time(15, 24) == 15","solution":"def shift_end_time(K, L): Determines the ending time of a working shift. Parameters: K (int): Starting time in 24-hour notation. L (int): Duration of the shift in hours. Returns: int: Ending time in 24-hour notation. return (K + L) % 24"},{"question":"from collections import deque def min_steps(n: int, m: int, grid: List[str], x_s: int, y_s: int, x_t: int, y_t: int) -> int: Determine the minimum number of steps required to move from the start to the target position in a grid, or determine if it is impossible to reach the target position. Args: n : int : Number of rows in the grid m : int : Number of columns in the grid grid : List[str] : Grid representation, with '.' for empty squares and '#' for obstacles x_s : int : Starting position row y_s : int : Starting position column x_t : int : Target position row y_t : int : Target position column Returns: int : Minimum number of steps required to reach the target, or -1 if impossible Examples: >>> grid = [ ... \\"....\\", ... \\".#..\\", ... \\"..#.\\", ... \\"....\\" ... ] >>> min_steps(4, 4, grid, 0, 0, 3, 3) 6 >>> grid = [ ... \\".#.\\", ... \\".#.\\", ... \\".#.\\" ... ] >>> min_steps(3, 3, grid, 0, 0, 2, 2) -1 >>> grid = [ ... \\"..#..\\", ... \\"..#..\\", ... \\".....\\", ... \\"...\\", ... \\".....\\" ... ] >>> min_steps(5, 5, grid, 1, 1, 3, 4) 5","solution":"from collections import deque def min_steps(n, m, grid, x_s, y_s, x_t, y_t): # Directions for moving in the grid directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # Check if the position is within grid bounds and not an obstacle def is_valid(x, y): return 0 <= x < n and 0 <= y < m and grid[x][y] == '.' # BFS for finding the shortest path queue = deque([(x_s, y_s, 0)]) # (current_x, current_y, current_steps) visited = set((x_s, y_s)) while queue: x, y, steps = queue.popleft() if (x, y) == (x_t, y_t): return steps for dx, dy in directions: nx, ny = x + dx, y + dy if is_valid(nx, ny) and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny, steps + 1)) return -1"},{"question":"def can_transform(initial_grid, target_grid): Returns 'Yes' if the initial grid can be transformed into the target grid, otherwise 'No'. Args: initial_grid: List of strings representing the initial grid. target_grid: List of strings representing the target grid. >>> can_transform([\\"abc\\", \\"def\\"], [\\"acb\\", \\"fde\\"]) 'Yes' >>> can_transform([\\"abc\\", \\"def\\", \\"ghi\\"], [\\"ghi\\", \\"def\\", \\"abc\\"]) 'Yes' >>> can_transform([\\"abc\\", \\"def\\"], [\\"xyz\\", \\"uvw\\"]) 'No' def process_grids(test_cases): Processes multiple test cases to determine if each initial grid can be transformed into the target grid. Args: test_cases: List of tuples, each containing (n, m, initial_grid, target_grid) >>> process_grids([(2, 3, [\\"abc\\", \\"def\\"], [\\"acb\\", \\"fde\\"]), (3, 3, [\\"abc\\", \\"def\\", \\"ghi\\"], [\\"ghi\\", \\"def\\", \\"abc\\"])]) ['Yes', 'Yes'] >>> process_grids([(2, 3, [\\"abc\\", \\"def\\"], [\\"xyz\\", \\"uvw\\"])]) ['No']","solution":"def can_transform(initial_grid, target_grid): Returns 'Yes' if the initial grid can be transformed into the target grid, otherwise 'No'. # Sort both grids row-wise and column-wise sorted_initial_rows = [''.join(sorted(row)) for row in initial_grid] sorted_target_rows = [''.join(sorted(row)) for row in target_grid] sorted_initial_rows.sort() sorted_target_rows.sort() return 'Yes' if sorted_initial_rows == sorted_target_rows else 'No' def process_grids(test_cases): results = [] for case in test_cases: n, m, initial_grid, target_grid = case results.append(can_transform(initial_grid, target_grid)) return results"},{"question":"def check_ip_in_ranges(ranges: List[Tuple[str, str]], ip: str) -> str: Checks if the given IP is within any of the provided IP ranges. :param ranges: List of tuples, where each tuple contains two IP addresses representing the start and end of an IP range. :param ip: The IP address to check. :return: \\"ALLOW\\" if the IP is within any range, otherwise \\"DENY\\". >>> check_ip_in_ranges([(\\"192.168.1.1\\", \\"192.168.1.100\\"), (\\"10.0.0.0\\", \\"10.0.0.255\\"), (\\"172.16.0.0\\", \\"172.16.255.255\\")], \\"192.168.1.50\\") \\"ALLOW\\" >>> check_ip_in_ranges([(\\"192.168.0.0\\", \\"192.168.0.255\\"), (\\"10.0.0.0\\", \\"10.0.0.100\\")], \\"172.16.0.1\\") \\"DENY\\"","solution":"def ip_to_int(ip): Converts an IP address to an integer for easy comparison. parts = ip.split('.') return int(parts[0]) * 256**3 + int(parts[1]) * 256**2 + int(parts[2]) * 256 + int(parts[3]) def is_ip_in_range(ip, start_ip, end_ip): Returns True if the IP is in the provided range, otherwise False. ip_int = ip_to_int(ip) start_ip_int = ip_to_int(start_ip) end_ip_int = ip_to_int(end_ip) return start_ip_int <= ip_int <= end_ip_int def check_ip_in_ranges(ranges, ip): Checks if the given IP is in any of the provided ranges. for start_ip, end_ip in ranges: if is_ip_in_range(ip, start_ip, end_ip): return \\"ALLOW\\" return \\"DENY\\""},{"question":"def consecutive_count(input_string: str) -> List[Tuple[str, int]]: Write a function that takes in a string consisting of only lowercase English letters, and returns a list of tuples, where each tuple contains two items: 1. A character from the input string. 2. The number of times that character appears consecutively in the string. >>> consecutive_count(\\"aaabbcccb\\") [('a', 3), ('b', 2), ('c', 3), ('b', 1)] >>> consecutive_count(\\"a\\") [('a', 1)] >>> consecutive_count(\\"zzzyyyxxzzzzy\\") [('z', 3), ('y', 3), ('x', 2), ('z', 4), ('y', 1)]","solution":"from typing import List, Tuple def consecutive_count(input_string: str) -> List[Tuple[str, int]]: if not input_string: return [] result = [] current_char = input_string[0] current_count = 1 for char in input_string[1:]: if char == current_char: current_count += 1 else: result.append((current_char, current_count)) current_char = char current_count = 1 result.append((current_char, current_count)) return result"},{"question":"from typing import List, Tuple def is_prime(n: int) -> bool: Check if a number is a prime. Args: n (int): The number to check. Returns: bool: True if n is a prime number, False otherwise. def check_signals(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[str]: Determine whether each intercepted signal is accurate or corrupted. Args: T (int): The number of test cases. test_cases (List[Tuple[int, List[int]]]): List of tuples, each containing the number of elements in the signal array and the signal array itself. Returns: List[str]: List of strings \\"Accurate\\" or \\"Corrupted\\" for each test case. def test_is_prime(): assert is_prime(2) == True assert is_prime(3) == True assert is_prime(4) == False assert is_prime(29) == True assert is_prime(0) == False assert is_prime(1) == False assert is_prime(15) == False def test_check_signals(): assert check_signals(2, [(4, [3, 4, 5, 6]), (3, [11, 13, 17])]) == [\\"Corrupted\\", \\"Accurate\\"] assert check_signals(1, [(1, [2])]) == [\\"Accurate\\"] assert check_signals(1, [(2, [4, 6])]) == [\\"Corrupted\\"] assert check_signals(1, [(3, [3, 5, 7])]) == [\\"Corrupted\\"] assert check_signals(1, [(5, [10, 20, 30, 40, 50])]) == [\\"Corrupted\\"]","solution":"from math import isqrt def is_prime(n): Check if a number is a prime. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def check_signals(T, test_cases): result = [] for i in range(T): N, signal = test_cases[i] sum_signal = sum(signal) if is_prime(sum_signal): result.append(\\"Accurate\\") else: result.append(\\"Corrupted\\") return result"},{"question":"def min_operations(s: str, t: str) -> int: Returns the minimum number of operations required to transform string s into string t. >>> min_operations(\\"abcdef\\", \\"azced\\") == 3 >>> min_operations(\\"intention\\", \\"execution\\") == 5 >>> min_operations(\\"same\\", \\"same\\") == 0 >>> min_operations(\\"nonempty\\", \\"\\") == 8 >>> min_operations(\\"\\", \\"nonempty\\") == 8 >>> min_operations(\\"a\\", \\"b\\") == 1 >>> min_operations(\\"a\\", \\"ab\\") == 1 >>> min_operations(\\"ab\\", \\"a\\") == 1 >>> min_operations(\\"ab\\", \\"cd\\") == 2 >>> min_operations(\\"kitten\\", \\"sitting\\") == 3 >>> min_operations(\\"flaw\\", \\"lawn\\") == 2","solution":"def min_operations(s, t): Returns the minimum number of operations required to transform string s into string t. n = len(s) m = len(t) dp = [[0] * (m + 1) for _ in range(n + 1)] for i in range(n + 1): for j in range(m + 1): if i == 0: dp[i][j] = j elif j == 0: dp[i][j] = i elif s[i - 1] == t[j - 1]: dp[i][j] = dp[i - 1][j - 1] else: dp[i][j] = 1 + min(dp[i][j - 1], # Insert dp[i - 1][j], # Remove dp[i - 1][j - 1]) # Replace return dp[n][m]"},{"question":"def minMax(arr): Calculate the minimum possible maximum element in the array after any number of allowed operations. Parameters: arr (list): List of distinct integers Returns: int: Minimum possible maximum element in the array from math import gcd from functools import reduce def gcd_list(lst): Calculate the GCD of all elements in the list. Parameters: lst (list): List of integers Returns: int: GCD of all elements return reduce(gcd, lst) return gcd_list(arr) from solution import minMax def test_example_1(): assert minMax([7, 3, 5]) == 1 def test_example_2(): assert minMax([10, 4, 15, 7]) == 1 def test_example_3(): assert minMax([8, 5, 3, 2, 6]) == 1 def test_single_element(): assert minMax([1]) == 1 assert minMax([1000000]) == 1000000 def test_prime_numbers(): assert minMax([3, 5, 7]) == 1 def test_identical_gcd(): assert minMax([2, 4, 8, 10]) == 2 def test_no_common_factors(): assert minMax([14, 15, 16, 17]) == 1","solution":"def minMax(arr): Calculate the minimum possible maximum element in the array after any number of allowed operations. Parameters: arr (list): List of distinct integers Returns: int: Minimum possible maximum element in the array from math import gcd from functools import reduce def gcd_list(lst): Calculate the GCD of all elements in the list. Parameters: lst (list): List of integers Returns: int: GCD of all elements return reduce(gcd, lst) return gcd_list(arr)"},{"question":"def is_valid_parentheses(s: str) -> str: Determine if the input string s containing just the characters '(', ')', '{', '}', '[' and ']' is valid. An input string is valid if: 1. Open brackets must be closed by the same type of brackets. 2. Open brackets must be closed in the correct order. :param s: str: Input string containing brackets :return: str: \\"YES\\" if the string is valid, otherwise \\"NO\\" from solution import is_valid_parentheses def test_valid_single_pair(): assert is_valid_parentheses(\\"()\\") == \\"YES\\" def test_valid_multiple_pairs(): assert is_valid_parentheses(\\"()[]{}\\") == \\"YES\\" def test_invalid_mixed_types(): assert is_valid_parentheses(\\"(]\\") == \\"NO\\" def test_invalid_wrong_order(): assert is_valid_parentheses(\\"([)]\\") == \\"NO\\" def test_valid_nested(): assert is_valid_parentheses(\\"{[]}\\") == \\"YES\\" def test_empty_string(): assert is_valid_parentheses(\\"\\") == \\"YES\\" def test_valid_large_input(): large_input = \\"()\\" * 5000 assert is_valid_parentheses(large_input) == \\"YES\\" def test_invalid_unmatched_open(): assert is_valid_parentheses(\\"(\\") == \\"NO\\" def test_invalid_unmatched_close(): assert is_valid_parentheses(\\")\\") == \\"NO\\" def test_invalid_random_characters(): assert is_valid_parentheses(\\"{[a](})\\") == \\"NO\\"","solution":"def is_valid_parentheses(s): Determine if the input string s containing just the characters '(', ')', '{', '}', '[' and ']' is valid. An input string is valid if: 1. Open brackets must be closed by the same type of brackets. 2. Open brackets must be closed in the correct order. :param s: str: Input string containing brackets :return: str: \\"YES\\" if the string is valid, otherwise \\"NO\\" stack = [] bracket_map = {')': '(', '}': '{', ']': '['} for char in s: if char in bracket_map.values(): stack.append(char) elif char in bracket_map: if stack and stack[-1] == bracket_map[char]: stack.pop() else: return \\"NO\\" else: return \\"NO\\" return \\"YES\\" if not stack else \\"NO\\""},{"question":"def find_min(nums: List[int]) -> int: Finds the minimum element in the rotated sorted array. Arguments: nums -- list of integers, rotated sorted in ascending order. Returns: The minimum element in the array. Examples: >>> find_min([3,4,5,1,2]) 1 >>> find_min([4,5,6,7,0,1,2]) 0 >>> find_min([11,13,15,17]) 11","solution":"def find_min(nums): Finds the minimum element in the rotated sorted array. Arguments: nums -- list of integers, rotated sorted in ascending order. Returns: The minimum element in the array. left, right = 0, len(nums) - 1 while left < right: mid = (left + right) // 2 if nums[mid] > nums[right]: left = mid + 1 else: right = mid return nums[left]"},{"question":"def reorder_trees(trees): Takes a list of trees where 1 represents a healthy tree and 0 represents a wilted tree. Reorders the list such that all wilted trees are on the left and all healthy trees are on the right. pass def process_test_cases(test_cases): Takes a list of test cases, where each test case is a tuple containing the number of trees and the list of trees. Returns a list of results, each representing the reordered list of trees for the corresponding test case. pass if __name__ == \\"__main__\\": import sys input = sys.stdin.read data = input().strip().split(\\"n\\") T = int(data[0]) test_cases = [] index = 1 for _ in range(T): N = int(data[index]) trees = list(map(int, data[index + 1].split())) test_cases.append((N, trees)) index += 2 results = process_test_cases(test_cases) for result in results: print(\\" \\".join(map(str, result))) import pytest def test_reorder_trees_case_1(): assert reorder_trees([1, 0, 1]) == [0, 1, 1] def test_reorder_trees_case_2(): assert reorder_trees([0, 0, 1, 1, 0]) == [0, 0, 0, 1, 1] def test_reorder_trees_case_3(): assert reorder_trees([1, 1, 1, 0]) == [0, 1, 1, 1] def test_process_test_cases(): test_cases = [ (3, [1, 0, 1]), (5, [0, 0, 1, 1, 0]), (4, [1, 1, 1, 0]) ] result = process_test_cases(test_cases) assert result == [ [0, 1, 1], [0, 0, 0, 1, 1], [0, 1, 1, 1] ]","solution":"def reorder_trees(trees): Takes a list of trees where 1 represents a healthy tree and 0 represents a wilted tree. Reorders the list such that all wilted trees are on the left and all healthy trees are on the right. return sorted(trees) def process_test_cases(test_cases): results = [] for case in test_cases: n, trees = case results.append(reorder_trees(trees)) return results"},{"question":"def processCodeEditor(code: str, goto: int) -> (str, str): Adds line numbers to the given code and returns the code with line numbers and the line at the specified 'goto' line number. Args: - code (str): The raw code input. - goto (int): The line number to jump to. Returns: - tuple: A tuple containing the code with line numbers and the specific line at 'goto'. >>> processCodeEditor(\\"print('Hello, world!')nprint('This is line 2')\\", 2) (\\"1. print('Hello, world!')n2. print('This is line 2')\\", \\"print('This is line 2')\\") >>> processCodeEditor(\\"def add(a, b):n return a + bnnprint(add(2, 3))\\", 3) (\\"1. def add(a, b):n2. return a + bn3. n4. print(add(2, 3))\\", \\"\\") >>> processCodeEditor(\\"a = 10nb = 20nc = a + b\\", 4) (\\"1. a = 10n2. b = 20n3. c = a + b\\", \\"\\") pass","solution":"def processCodeEditor(code, goto): Adds line numbers to the given code and returns the code with line numbers and the line at the specified 'goto' line number. Args: - code (str): The raw code input. - goto (int): The line number to jump to. Returns: - tuple: A tuple containing the code with line numbers and the specific line at 'goto'. # Split the code into lines lines = code.split('n') # Add line numbers to each line numbered_lines = [f\\"{i + 1}. {lines[i]}\\" for i in range(len(lines))] # Join the numbered lines back into a single string numbered_code = 'n'.join(numbered_lines) # Get the specific line at 'goto', if it exists if 1 <= goto <= len(lines): specific_line = lines[goto - 1] else: specific_line = \\"\\" return (numbered_code, specific_line)"},{"question":"def largest_number(lst: List[int]) -> str: Find the largest number that can be formed by concatenating the elements of the list of non-negative integers. Each number must appear exactly once in the result. >>> largest_number([9, 90, 1, 5]) \\"99051\\" >>> largest_number([3, 30, 34, 5, 9]) \\"9534330\\" >>> largest_number([0, 0]) \\"0\\" >>> largest_number([10]) \\"10\\" >>> largest_number([2, 2, 2]) \\"222\\" >>> largest_number([10, 2]) \\"210\\" >>> largest_number([123, 12345, 123456789]) \\"12345678912345123\\" >>> largest_number([0, 1]) \\"10\\"","solution":"from typing import List def largest_number(lst: List[int]) -> str: # Convert all integers to strings for easy comparison lst = [str(num) for num in lst] # Sort with custom comparator lst.sort(key=lambda x: x*10, reverse=True) # Concatenate the numbers to form the largest number largest_num = ''.join(lst) # Handle the case where the concatenated number starts with zero(s), this would happen if all are zeroes if largest_num[0] == '0': return '0' return largest_num"},{"question":"def min_cost_subsets(t: int, test_cases: List[Tuple[int, int, List[int], List[Tuple[int, int]]]]) -> List[int]: You are given an undirected graph with n vertices and m edges. Each vertex has a cost associated with it. You need to select a subset of vertices such that the sum of the costs of selected vertices is minimum and for every edge in the graph, at least one of its endpoints is included in the set. Formally, let S be the selected set of vertices. For each edge (u, v), at least one of the conditions (1) u ∈ S or (2) v ∈ S must hold. Args: t (int): the number of test cases. test_cases (List[Tuple[int, int, List[int], List[Tuple[int, int]]]]): a list of test cases, each with the number of vertices, the number of edges, the costs of the vertices, and the edges. Returns: List[int]: a list of the minimum costs for each test case. >>> min_cost_subsets(1, [(3, 2, [3, 2, 1], [(1, 2), (2, 3)])]) [1] >>> min_cost_subsets(2, [(3, 2, [3, 2, 1], [(1, 2), (2, 3)]), (4, 4, [1, 2, 3, 4], [(1, 2), (2, 3), (3, 4), (4, 1)])]) [1, 1] def get_input_and_solve(input_data: str) -> List[int]: Processes the input data and solves for the minimum cost of selecting a subset of vertices for the provided test cases. Args: input_data (str): The input string containing the test cases Returns: List[int]: The list containing minimum costs for each test case >>> get_input_and_solve(\\"1n3 2n3 2 1n1 2n2 3n\\") [1] >>> get_input_and_solve(\\"2n3 2n3 2 1n1 2n2 3n4 4n1 2 3 4n1 2n2 3n3 4n4 1n\\") [1, 1]","solution":"def min_cost_subsets(t, test_cases): results = [] for case in test_cases: n, m, costs, edges = case if m == 0: # No edges, just take the minimum cost vertex results.append(min(costs)) else: min_edge_cost = float('inf') for u, v in edges: min_edge_cost = min(min_edge_cost, costs[u-1], costs[v-1]) results.append(min_edge_cost) return results def get_input_and_solve(input_data): input_lines = input_data.strip().split('n') t = int(input_lines[0]) test_cases = [] index = 1 for _ in range(t): n, m = map(int, input_lines[index].split()) index += 1 costs = list(map(int, input_lines[index].split())) index += 1 edges = [] for _ in range(m): u, v = map(int, input_lines[index].split()) edges.append((u, v)) index += 1 test_cases.append((n, m, costs, edges)) return min_cost_subsets(t, test_cases)"},{"question":"def count_water_tanks(n: int, heights: List[int]) -> int: Computes the total number of water tanks that can be formed according to the described rule. Args: n (int): Number of buildings heights (List[int]): Heights of the buildings Returns: int: Total number of water tanks that can be formed Examples: >>> count_water_tanks(5, [5, 1, 3, 4, 2]) 2 >>> count_water_tanks(1, [5]) 0 >>> count_water_tanks(3, [3, 3, 3]) 0 >>> count_water_tanks(5, [5, 4, 3, 2, 1]) 4 >>> count_water_tanks(5, [1, 2, 3, 4, 5]) 0","solution":"def count_water_tanks(n, heights): if n == 1: return 0 max_right = [0] * n max_right[-1] = heights[-1] for i in range(n-2, -1, -1): max_right[i] = max(heights[i], max_right[i+1]) count = 0 for i in range(n-1): if heights[i] > heights[i+1]: tallest = max_right[i+1] if i+1 < n else 0 if heights[i] > tallest: count += 1 return count"},{"question":"def compress_string(s: str) -> str: Compress a given string using Run-Length Encoding. >>> compress_string(\\"AAAABBBCCDAA\\") \\"4A3B2C1D2A\\" >>> compress_string(\\"BBBCCCCCCDDDD\\") \\"3B6C4D\\" def decompress_string(s: str) -> str: Decompress a Run-Length Encoded string back to its original form. >>> decompress_string(\\"4A3B2C1D2A\\") \\"AAAABBBCCDAA\\" >>> decompress_string(\\"3B6C4D\\") \\"BBBCCCCCCDDDD\\" def run_length_encoding(t: int, test_cases: List[str]) -> List[str]: For each test case, compress if the input string was in original form, or decompress if it was in compressed form using Run-Length Encoding. >>> run_length_encoding(3, [\\"AAAABBBCCDAA\\", \\"4A3B2C1D2A\\", \\"BBBCCCCCCDDDD\\"]) ['4A3B2C1D2A', 'AAAABBBCCDAA', '3B6C4D'] >>> run_length_encoding(2, [\\"AABBCC\\", \\"2A2B2C\\"]) ['2A2B2C', 'AABBCC']","solution":"def compress_string(s): compressed_str = [] i = 0 while i < len(s): count = 1 while i + 1 < len(s) and s[i] == s[i+1]: i += 1 count += 1 compressed_str.append(f\\"{count}{s[i]}\\") i += 1 return \\"\\".join(compressed_str) def decompress_string(s): decompressed_str = [] i = 0 while i < len(s): count = int(s[i]) char = s[i + 1] decompressed_str.append(char * count) i += 2 return \\"\\".join(decompressed_str) def run_length_encoding(t, test_cases): results = [] for s in test_cases: if len(s) % 2 == 0 and all(s[i].isdigit() for i in range(0, len(s), 2)): # Case when it is compressed (even length and contains digit in even index) results.append(decompress_string(s)) else: # Case when it is normal string results.append(compress_string(s)) return results"},{"question":"def manage_set(queries): Function to manage a set of integers based on a list of queries. Parameters: queries (list of tuples): A list of tuples where each tuple contains an integer representing the type of query (0 for add, 1 for remove, 2 for exists) and the integer x. Returns: list of str: A list of strings \\"YES\\" or \\"NO\\" for the 'exists' queries.","solution":"def manage_set(queries): Function to manage a set of integers based on a list of queries. Parameters: queries (list of tuples): A list of tuples where each tuple contains an integer representing the type of query (0 for add, 1 for remove, 2 for exists) and the integer x. Returns: list of str: A list of strings \\"YES\\" or \\"NO\\" for the 'exists' queries. result = [] data_set = set() for query in queries: query_type, x = query if query_type == 0: data_set.add(x) elif query_type == 1: data_set.discard(x) # discard does nothing if the element is not present elif query_type == 2: if x in data_set: result.append(\\"YES\\") else: result.append(\\"NO\\") return result"},{"question":"from typing import List, Tuple def hexagonal_quest(n: int, m: int, grid: List[List[int]], players: List[Tuple[int, Tuple[int, int], Tuple[int, int]]]) -> List[str]: Determines whether each player can reach the target cell in the hexagonal grid starting with the given energy. >>> n = 5 >>> m = 2 >>> grid = [ ... [1, 2, 3, 4, -1], ... [2, 3, 4, -1, 1], ... [3, 4, -1, 1, 2], ... [4, -1, 1, 2, 3], ... [-1, 1, 2, 3, 4] ... ] >>> players = [ ... (15, (1, 1), (4, 4)), ... (10, (0, 0), (3, 3)) ... ] >>> hexagonal_quest(n, m, grid, players) [\\"YES\\", \\"NO\\"] >>> n = 3 >>> m = 1 >>> grid = [ ... [1, 2, 3], ... [2, 3, 4], ... [3, 4, 5] ... ] >>> players = [ ... (9, (0, 0), (2, 2)) ... ] >>> hexagonal_quest(n, m, grid, players) [\\"YES\\"] pass def test_sample_input_1(): n = 5 m = 2 grid = [ [1, 2, 3, 4, -1], [2, 3, 4, -1, 1], [3, 4, -1, 1, 2], [4, -1, 1, 2, 3], [-1, 1, 2, 3, 4] ] players = [ (15, (1, 1), (4, 4)), (10, (0, 0), (3, 3)) ] assert hexagonal_quest(n, m, grid, players) == [\\"YES\\", \\"NO\\"] def test_sample_input_2(): n = 3 m = 1 grid = [ [1, 2, 3], [2, 3, 4], [3, 4, 5] ] players = [ (9, (0, 0), (2, 2)) ] assert hexagonal_quest(n, m, grid, players) == [\\"YES\\"] def test_unreachable_due_to_walls(): n = 3 m = 1 grid = [ [1, -1, 1], [-1, -1, -1], [1, -1, 1] ] players = [ (10, (0, 0), (2, 2)) ] assert hexagonal_quest(n, m, grid, players) == [\\"NO\\"] def test_exact_energy(): n = 4 m = 1 grid = [ [1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1] ] players = [ (6, (0, 0), (3, 3)) ] assert hexagonal_quest(n, m, grid, players) == [\\"YES\\"] def test_impossible_path(): n = 3 m = 1 grid = [ [100, 100, 100], [100, 100, 100], [100, 100, 100] ] players = [ (10, (0, 0), (2, 2)) ] assert hexagonal_quest(n, m, grid, players) == [\\"NO\\"]","solution":"from collections import deque def can_reach_target(grid, energy, start, target): n = len(grid) directions = [(-1, 0), (1, 0), (-1, 1), (-1, -1), (1, 1), (1, -1)] queue = deque([(start[0], start[1], energy)]) visited = set() visited.add((start[0], start[1])) while queue: x, y, e = queue.popleft() if (x, y) == target: return True for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < n and (nx, ny) not in visited and grid[nx][ny] != -1: new_energy = e - grid[nx][ny] if new_energy >= 0: visited.add((nx, ny)) queue.append((nx, ny, new_energy)) return False def hexagonal_quest(n, m, grid, players): results = [] for player in players: energy, start, target = player result = can_reach_target(grid, energy, start, target) results.append(\\"YES\\" if result else \\"NO\\") return results"},{"question":"def calculate_contributions(n: int, m: int) -> tuple: Calculate the initial contributions of each friend and the special friend's contribution. Parameters: n (int): The number of friends. m (int): The total cost of the gift. Returns: tuple: A tuple with two integers. The first integer is the contribution each friend makes, the second integer is the remaining contribution made by the special friend (if any). Examples: >>> calculate_contributions(4, 10) (2, 2) >>> calculate_contributions(3, 9) (3, 0)","solution":"def calculate_contributions(n, m): Calculate the initial contributions of each friend and the special friend's contribution. Parameters: n (int): The number of friends. m (int): The total cost of the gift. Returns: tuple: A tuple with two integers. The first integer is the contribution each friend makes, the second integer is the remaining contribution made by the special friend (if any). equal_contribution = m // n remainder = m % n return equal_contribution, remainder"},{"question":"def last_digit_of_factorial(n: int) -> int: Calculate the last digit of the factorial of a house number. :param n: int - house number (1 ≤ n ≤ 10^9) :return: The last digit of n! (n factorial) >>> last_digit_of_factorial(1) 1 >>> last_digit_of_factorial(2) 2 >>> last_digit_of_factorial(3) 6 >>> last_digit_of_factorial(4) 4 >>> last_digit_of_factorial(5) 0 >>> last_digit_of_factorial(10) 0 >>> last_digit_of_factorial(123456789) 0 >>> last_digit_of_factorial(987654321) 0 >>> last_digit_of_factorial(1000000000) 0","solution":"def last_digit_of_factorial(n): Returns the last digit of n!. if n >= 5: return 0 else: factorial = 1 for i in range(2, n + 1): factorial *= i return factorial % 10"},{"question":"def can_complete_tasks(n, m, dependencies): Determine if it's possible to complete all tasks without any circular dependencies. >>> can_complete_tasks(3, 2, [(1, 2), (2, 3)]) 'YES' >>> can_complete_tasks(3, 3, [(1, 2), (2, 3), (3, 1)]) 'NO'","solution":"def can_complete_tasks(n, m, dependencies): from collections import defaultdict, deque # Create adjacency list graph = defaultdict(list) in_degree = {i: 0 for i in range(1, n+1)} # Build graph for x, y in dependencies: graph[x].append(y) in_degree[y] += 1 # Perform topological sort using Kahn's algorithm queue = deque([node for node in in_degree if in_degree[node] == 0]) count = 0 while queue: node = queue.popleft() count += 1 for neighbor in graph[node]: in_degree[neighbor] -= 1 if in_degree[neighbor] == 0: queue.append(neighbor) if count == n: return \\"YES\\" else: return \\"NO\\""},{"question":"def count_intersections(n: int, m: int, vertical_streets: List[int], horizontal_streets: List[int]) -> int: Determine the total number of intersections within the grid. >>> count_intersections(3, 3, [1, 3, 5], [2, 4, 6]) 9 >>> count_intersections(2, 4, [0, 1], [-1, 2, 4, 5]) 8","solution":"def count_intersections(n, m, vertical_streets, horizontal_streets): # The number of intersections is simply the product of the number of vertical and horizontal streets return n * m"},{"question":"def max_char_occurrence(s: str) -> str: Returns the character that appears the maximum number of times in the string s. If there are multiple characters that appear the same number of times, return the character that appears first in the string. The comparison is case-insensitive. pass # Example test cases: assert max_char_occurrence(\\"abcaAc\\") == \\"a\\" assert max_char_occurrence(\\"ZzXxYy\\") == \\"z\\" assert max_char_occurrence(\\"abcDEF\\") == \\"a\\"","solution":"def max_char_occurrence(s: str) -> str: Returns the character that appears the maximum number of times in the string s. If there are multiple characters that appear the same number of times, return the character that appears first in the string. The comparison is case-insensitive. s_lower = s.lower() char_count = {} for char in s_lower: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 max_occurrence = 0 max_char = '' for char in s_lower: if char_count[char] > max_occurrence: max_occurrence = char_count[char] max_char = char return max_char"},{"question":"def process_car_data(n, car_data, q, queries): Processes car data and handles the specified queries. :param n: Number of cars :param car_data: List of tuples, each containing car_id and fuel_consumption_rate :param q: Number of queries :param queries: List of queries, each a tuple (query_type, a, b) :return: List of results for each query # Test Cases def test_process_car_data(): n = 5 car_data = [ (0, 10), (1, 15), (2, 20), (3, 25), (4, 30) ] q = 3 queries = [ (\\"min\\", 1, 3), (\\"avg\\", 0, 2), (\\"avg\\", 2, 4) ] results = process_car_data(n, car_data, q, queries) assert results == [15, \\"15.00\\", \\"25.00\\"] def test_min_query(): n = 4 car_data = [ (0, 50), (1, 60), (2, 40), (3, 70) ] q = 1 queries = [ (\\"min\\", 0, 2) ] results = process_car_data(n, car_data, q, queries) assert results == [40] def test_avg_query(): n = 3 car_data = [ (0, 30), (1, 20), (2, 50) ] q = 1 queries = [ (\\"avg\\", 0, 2) ] results = process_car_data(n, car_data, q, queries) assert results == [\\"33.33\\"] def test_combined_queries(): n = 3 car_data = [ (0, 10), (1, 20), (2, 30) ] q = 2 queries = [ (\\"min\\", 0, 1), (\\"avg\\", 1, 2) ] results = process_car_data(n, car_data, q, queries) assert results == [10, \\"25.00\\"]","solution":"def process_car_data(n, car_data, q, queries): Processes car data and handles the specified queries. :param n: Number of cars :param car_data: List of tuples, each containing (car_id, fuel_consumption_rate) :param q: Number of queries :param queries: List of queries, each a tuple (query_type, a, b) :return: List of results for each query results = [] consumption_rates = [0] * n for car_id, fuel_consumption_rate in car_data: consumption_rates[car_id] = fuel_consumption_rate for query in queries: query_type, a, b = query if query_type == \\"min\\": min_rate = min(consumption_rates[a:b+1]) results.append(min_rate) elif query_type == \\"avg\\": avg_rate = sum(consumption_rates[a:b+1]) / (b - a + 1) results.append(f\\"{avg_rate:.2f}\\") return results"},{"question":"def unique_paths_with_obstacles(grid: List[List[int]]) -> int: Returns the number of unique paths from the top-left corner to the bottom-right corner of a grid, avoiding obstacles. Args: grid (List[List[int]]): The grid containing 0s and 1s where 0 is a free cell and 1 is a blocked cell. Returns: int: The number of unique paths. >>> unique_paths_with_obstacles([[0, 0, 0], [0, 1, 0], [0, 0, 0]]) 2 >>> unique_paths_with_obstacles([[0, 1], [1, 0]]) 0","solution":"def unique_paths_with_obstacles(grid): Returns the number of unique paths from the top-left corner to the bottom-right corner of a grid, avoiding obstacles. Args: grid (List[List[int]]): The grid containing 0s and 1s where 0 is a free cell and 1 is a blocked cell. Returns: int: The number of unique paths. m = len(grid) n = len(grid[0]) if grid[0][0] == 1 or grid[m-1][n-1] == 1: return 0 # Create a 2D dp array with the same dimensions as grid dp = [[0] * n for _ in range(m)] dp[0][0] = 1 # Start position # Fill the dp array for i in range(m): for j in range(n): if grid[i][j] == 1: dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[m-1][n-1]"},{"question":"def calculate_angle(h: int, m: int) -> float: This function calculates the smallest angle between the hour and minute hands of a clock. Parameters: h (int): hours (0 ≤ h ≤ 23) m (int): minutes (0 ≤ m ≤ 59) Returns: float: smallest angle between the hour and minute hands in degrees >>> calculate_angle(3, 30) 75.00 >>> calculate_angle(12, 45) 112.50 >>> calculate_angle(0, 0) 0.00 >>> calculate_angle(12, 0) 0.00 >>> calculate_angle(6, 0) 180.00 >>> calculate_angle(9, 15) 172.50 >>> calculate_angle(2, 30) 105.00 >>> calculate_angle(11, 59) 5.50","solution":"def calculate_angle(h, m): This function calculates the smallest angle between the hour and minute hands of a clock. Parameters: h (int): hours (0 ≤ h ≤ 23) m (int): minutes (0 ≤ m ≤ 59) Returns: float: smallest angle between the hour and minute hands in degrees # Convert the hours to the 12-hour format if h >= 12: h -= 12 # Calculate the positions of the hour and minute hands minute_angle = m * 6 # Each minute, the minute hand moves 6 degrees (360 / 60) hour_angle = (h * 30) + (m * 0.5) # Each hour, the hour hand moves 30 degrees (360 / 12) + 0.5 degrees per minute # Calculate the angle between the two hands angle = abs(hour_angle - minute_angle) # The smallest angle between the hands smallest_angle = min(angle, 360 - angle) return round(smallest_angle, 2)"},{"question":"def largest_island_area(m: int, n: int, grid: List[List[int]]) -> int: Find the largest area of an island in a grid. >>> largest_island_area(4, 5, [ ... [1, 0, 0, 1, 1], ... [1, 1, 0, 0, 0], ... [0, 0, 1, 0, 0], ... [1, 0, 1, 1, 1]]) 4 >>> largest_island_area(2, 2, [ ... [0, 0], ... [0, 0]]) 0","solution":"def largest_island_area(m, n, grid): def dfs(x, y): if x < 0 or y < 0 or x >= m or y >= n or grid[x][y] == 0: return 0 grid[x][y] = 0 # mark as visited area = 1 # current cell's area area += dfs(x-1, y) # up area += dfs(x+1, y) # down area += dfs(x, y-1) # left area += dfs(x, y+1) # right return area max_area = 0 for i in range(m): for j in range(n): if grid[i][j] == 1: # found an island part max_area = max(max_area, dfs(i, j)) return max_area"},{"question":"def minimize_max_sum(n: int, m: int, weights: List[int], k: int) -> int: Determines the least possible value of the maximum sum of any section in a valid grouping of boxes. Args: n: The number of boxes. m: The number of sections. weights: A list of integers representing the weights of the boxes. k: The maximum threshold for the sum of weights in each section. Returns: An integer representing the least possible value of the maximum sum of any section in a valid grouping of boxes. >>> minimize_max_sum(5, 3, [1, 2, 3, 4, 5], 10) 6 >>> minimize_max_sum(6, 2, [7, 2, 4, 8, 1, 3], 15) 13 >>> minimize_max_sum(6, 2, [7, 2, 4, 8, 1, 3], 5) -1 >>> minimize_max_sum(1, 1, [5], 10) 5 >>> minimize_max_sum(4, 2, [4, 4, 4, 4], 16) 8 >>> minimize_max_sum(4, 2, [0, 0, 0, 0], 0) 0 pass","solution":"def is_possible(weights, n, m, max_sum, k): Helper function to check if it's possible to partition weights into m sections where each section's sum is at most max_sum and it does not exceed the threshold k. current_sum = 0 sections_count = 1 for weight in weights: if weight > max_sum: return False if current_sum + weight > max_sum: sections_count += 1 current_sum = weight else: current_sum += weight if sections_count > m or current_sum > k: return False return True def minimize_max_sum(n, m, weights, k): Determines the least possible value of the maximum sum of any section in a valid grouping of boxes. left, right = max(weights), sum(weights) result = -1 while left <= right: mid = (left + right) // 2 if is_possible(weights, n, m, mid, k): result = mid right = mid - 1 else: left = mid + 1 return result"},{"question":"from typing import List def largest_square_area(grid: List[str]) -> int: Find the area of the largest square consisting entirely of apartment units. Args: grid (List[str]): The 2D grid of m rows and n columns representing the apartment building Returns: int: The area of the largest square consisting entirely of apartment units Examples: >>> largest_square_area([ \\".1....\\", \\"111111\\", \\"111111\\", \\"111111\\", \\"....1.\\" ]) 9 >>> largest_square_area([ \\".....\\", \\".111.\\", \\".111.\\", \\".....\\" ]) 4 >>> largest_square_area([ \\"111\\", \\"101\\", \\"111\\" ]) 1 # Implementation here # Tests def test_example_1(): grid = [ \\".1....\\", \\"111111\\", \\"111111\\", \\"111111\\", \\"....1.\\" ] assert largest_square_area(grid) == 9 def test_example_2(): grid = [ \\".....\\", \\".111.\\", \\".111.\\", \\".....\\" ] assert largest_square_area(grid) == 4 def test_example_3(): grid = [ \\"111\\", \\"101\\", \\"111\\" ] assert largest_square_area(grid) == 1 def test_single_cell_apartment(): grid = [\\"1\\"] assert largest_square_area(grid) == 1 def test_all_empty(): grid = [ \\".....\\", \\".....\\", \\".....\\" ] assert largest_square_area(grid) == 0 def test_alternate(): grid = [ \\"101\\", \\"010\\", \\"101\\" ] assert largest_square_area(grid) == 1 def test_large_grid(): grid = [ \\"1\\"*200 for _ in range(200) ] assert largest_square_area(grid) == 200 * 200","solution":"def largest_square_area(grid): m = len(grid) n = len(grid[0]) dp = [[0] * (n + 1) for _ in range(m + 1)] max_side = 0 for i in range(1, m + 1): for j in range(1, n + 1): if grid[i - 1][j - 1] == '1': dp[i][j] = min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1 max_side = max(max_side, dp[i][j]) return max_side * max_side # Example: # m, n = 5, 6 # grid = [ # \\".1....\\", # \\"111111\\", # \\"111111\\", # \\"111111\\", # \\"....1.\\" # ] # print(largest_square_area(grid)) # Output: 9"},{"question":"def max_satisfied_participants(n: int, m: int, preferences: List[int], quantities: List[int]) -> int: Determine the maximum number of participants that can receive their preferred gift type given the available quantities of each gift type. >>> max_satisfied_participants(6, 3, [1, 1, 2, 2, 3, 3], [2, 1, 2]) 5 >>> max_satisfied_participants(5, 5, [1, 2, 3, 4, 5], [0, 0, 0, 0, 0]) 0 >>> max_satisfied_participants(4, 2, [1, 2, 1, 2], [2, 2]) 4","solution":"def max_satisfied_participants(n, m, preferences, quantities): # Dictionary to keep the count of participants' preferences count_pref = [0] * (m + 1) for p in preferences: count_pref[p] += 1 satisfied = 0 for gift_type in range(1, m + 1): satisfied += min(count_pref[gift_type], quantities[gift_type - 1]) return satisfied"},{"question":"def min_cost_to_balance(s: str) -> int: Returns the minimum cost to balance the string of brackets. >>> min_cost_to_balance('([]') 1 >>> min_cost_to_balance('{[()]}') 0 >>> min_cost_to_balance('([)]') 2","solution":"def min_cost_to_balance(s): Returns the minimum cost to balance the string of brackets. stack = [] cost = 0 bracket_map = { ')': '(', '}': '{', ']': '[' } for char in s: if char in bracket_map.values(): # if it's one of '(', '{', '[' stack.append(char) else: if stack and stack[-1] == bracket_map[char]: stack.pop() else: cost += 1 # unbalanced so increase the cost and imagine we change it if stack: stack.pop() cost += len(stack) # remaining opening brackets to be balanced by adding closing brackets return cost"},{"question":"import heapq class Library: def __init__(self): self.books = {} self.max_heap = [] def add(self, book_id, score): Add a new book with the given score. pass def update(self, book_id, new_score): Update the score of the book with the given book_id. pass def query(self): Query the book with the highest score. pass def process_operations(operations): Process a list of operations and return the results. :param operations: List of operations to be processed. :return: List of results for each QUERY operation. >>> process_operations([\\"ADD 1 10\\", \\"ADD 2 5\\", \\"QUERY\\", \\"UPDATE 2 15\\", \\"QUERY\\", \\"STOP\\"]) [1, 2] >>> process_operations([\\"QUERY\\", \\"STOP\\"]) [\\"NONE\\"] >>> process_operations([\\"ADD 1 10\\", \\"QUERY\\", \\"ADD 2 15\\", \\"QUERY\\", \\"STOP\\"]) [1, 2] >>> process_operations([\\"ADD 1 10\\", \\"ADD 2 20\\", \\"QUERY\\", \\"UPDATE 1 30\\", \\"QUERY\\", \\"STOP\\"]) [2, 1] >>> process_operations([\\"ADD 1 10\\", \\"ADD 2 20\\", \\"QUERY\\", \\"UPDATE 2 5\\", \\"QUERY\\", \\"STOP\\"]) [2, 1] >>> process_operations([\\"ADD 1 10\\", \\"ADD 2 10\\", \\"QUERY\\", \\"STOP\\"]) [1]","solution":"import heapq class Library: def __init__(self): self.books = {} self.max_heap = [] def add(self, book_id, score): self.books[book_id] = score heapq.heappush(self.max_heap, (-score, book_id)) def update(self, book_id, new_score): if book_id in self.books: self.books[book_id] = new_score heapq.heappush(self.max_heap, (-new_score, book_id)) def query(self): while self.max_heap and (-self.max_heap[0][0] != self.books[self.max_heap[0][1]]): heapq.heappop(self.max_heap) if self.max_heap: return self.max_heap[0][1] return \\"NONE\\" def process_operations(operations): library = Library() result = [] for operation in operations: op_parts = operation.split() if op_parts[0] == \\"ADD\\": book_id, score = int(op_parts[1]), int(op_parts[2]) library.add(book_id, score) elif op_parts[0] == \\"UPDATE\\": book_id, new_score = int(op_parts[1]), int(op_parts[2]) library.update(book_id, new_score) elif op_parts[0] == \\"QUERY\\": result.append(library.query()) elif op_parts[0] == \\"STOP\\": break return result"},{"question":"import math from typing import List def can_be_sum_of_squares(x: int) -> str: Determines if a non-negative integer x can be expressed as the sum of two non-negative integer squares. >>> can_be_sum_of_squares(1) == \\"YES\\" >>> can_be_sum_of_squares(2) == \\"YES\\" >>> can_be_sum_of_squares(3) == \\"NO\\" >>> can_be_sum_of_squares(4) == \\"YES\\" >>> can_be_sum_of_squares(5) == \\"YES\\" >>> can_be_sum_of_squares(6) == \\"NO\\" >>> can_be_sum_of_squares(7) == \\"NO\\" >>> can_be_sum_of_squares(8) == \\"YES\\" >>> can_be_sum_of_squares(9) == \\"YES\\" >>> can_be_sum_of_squares(10) == \\"YES\\" pass def process_datasets(data: List[int]) -> List[str]: Processes multiple datasets, determining if each can be expressed as the sum of two squares. >>> data = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, -1] >>> expected_output = [\\"YES\\", \\"YES\\", \\"NO\\", \\"YES\\", \\"YES\\", \\"NO\\", \\"NO\\", \\"YES\\", \\"YES\\", \\"YES\\"] >>> process_datasets(data) == expected_output pass","solution":"import math def can_be_sum_of_squares(x): Determines if a non-negative integer x can be expressed as the sum of two non-negative integer squares. if x < 0: return \\"NO\\" limit = int(math.sqrt(x)) + 1 for a in range(limit): b_square = x - a*a b = int(math.sqrt(b_square)) if b*b == b_square: return \\"YES\\" return \\"NO\\" def process_datasets(data): Processes multiple datasets, determining if each can be expressed as the sum of two squares. results = [] for x in data: if x < 0: break results.append(can_be_sum_of_squares(x)) return results"},{"question":"import typing def maximize_distinct_elements(n: int, num_set: typing.List[int]) -> int: Finds the integer k that maximizes the number of distinct elements in the transformed_set created by taking each element x in num_set and replacing it with x % k. Parameters: n (int): The number of elements in the num_set. num_set (list): List of integers representing the num_set. Returns: int: The integer k that maximizes the number of distinct elements. Example: >>> maximize_distinct_elements(6, [10, 20, 30, 40, 50, 60]) 61 >>> maximize_distinct_elements(5, [1, 2, 3, 4, 5]) 6","solution":"def maximize_distinct_elements(n, num_set): Finds the integer k that maximizes the number of distinct elements in the transformed_set created by taking each element x in num_set and replacing it with x % k. Parameters: n (int): The number of elements in the num_set. num_set (list): List of integers representing the num_set. Returns: int: The integer k that maximizes the number of distinct elements. max_num = max(num_set) potential_k = max_num + 1 return potential_k"},{"question":"def find_elevation_gain(grid): Returns the elevation gain needed to reach the highest peak from the lowest point in the grid. Args: grid (List[List[int]]): 2D list representing the heights in the grid. Returns: int: The elevation gain needed. Examples: >>> find_elevation_gain([[1, 2, 3], [6, 5, 4], [7, 8, 9]]) 8 >>> find_elevation_gain([[0, 2, 4, 6], [1, 3, 5, 7], [9, 10, 11, 8], [13, 12, 14, 15]]) 15 >>> find_elevation_gain([[5]]) 0 pass def process_input_and_find_elevation_gain(R, C, grid): return find_elevation_gain(grid) # Test cases def test_case_1(): R, C = 3, 3 grid = [ [1, 2, 3], [6, 5, 4], [7, 8, 9] ] assert process_input_and_find_elevation_gain(R, C, grid) == 8 def test_case_2(): R, C = 4, 4 grid = [ [0, 2, 4, 6], [1, 3, 5, 7], [9, 10, 11, 8], [13, 12, 14, 15] ] assert process_input_and_find_elevation_gain(R, C, grid) == 15 def test_case_3(): R, C = 1, 1 grid = [ [5] ] assert process_input_and_find_elevation_gain(R, C, grid) == 0 def test_case_4(): R, C = 2, 2 grid = [ [1, 3], [5, 2] ] assert process_input_and_find_elevation_gain(R, C, grid) == 4 def test_case_5(): R, C = 3, 3 grid = [ [0, 1, 2], [3, 4, 5], [6, 7, 8] ] assert process_input_and_find_elevation_gain(R, C, grid) == 8","solution":"def find_elevation_gain(grid): Returns the elevation gain needed to reach the highest peak from the lowest point in the grid. R = len(grid) C = len(grid[0]) min_height = float('inf') max_height = float('-inf') for row in grid: min_height = min(min_height, min(row)) max_height = max(max_height, max(row)) return max_height - min_height # Function to convert input into grid and call the find_elevation_gain function def process_input_and_find_elevation_gain(R, C, grid): return find_elevation_gain(grid)"},{"question":"def min_trips(num_items, item_weight, max_weight): Returns the minimum number of trips required to transport all items given the weight limits. >>> min_trips(10, 25, 100) 3 >>> min_trips(46, 7, 300) 2 >>> min_trips(9, 11, 99) 1 def calculate_min_trips(test_cases): Process multiple test cases and return the minimum number of trips for each. >>> test_cases = [ >>> [(10, 25), 100], >>> [(46, 7), 300] >>> ] >>> calculate_min_trips(test_cases) [3, 2]","solution":"def min_trips(num_items, item_weight, max_weight): Returns the minimum number of trips required to transport all items given the weight limits. total_weight = num_items * item_weight trips = total_weight // max_weight if total_weight % max_weight != 0: trips += 1 return trips def calculate_min_trips(test_cases): results = [] for case in test_cases: num_items, item_weight = case[0] max_weight = case[1] trips = min_trips(num_items, item_weight, max_weight) results.append(trips) return results"},{"question":"def max_songs_in_playlist(num_songs, time_limit, song_durations): Determines the maximum number of songs that can be included in the playlist without exceeding the time limit. :param num_songs: int - Number of songs. :param time_limit: int - Total time limit in seconds. :param song_durations: List[int] - List of durations for each song in seconds. :return: int - Maximum number of songs that can fit within the time limit. pass def handle_input_data(input_data): Handles the input data and processes each dataset independently. :param input_data: str - Multi-line input string. :return: List[int] - Results for each dataset. pass import pytest def test_max_songs_in_playlist(): assert max_songs_in_playlist(5, 900, [200, 300, 400, 600, 700]) == 3 assert max_songs_in_playlist(3, 500, [200, 250, 300]) == 2 assert max_songs_in_playlist(4, 600, [100, 200, 300, 400]) == 3 assert max_songs_in_playlist(2, 100, [60, 50]) == 1 def test_handle_input_data(): input_data = \\"5 900n200n300n400n600n700n3 500n200n250n300n0 0\\" assert handle_input_data(input_data) == [3, 2] input_data = \\"4 1000n300n400n500n600n2 500n300n400n1 1000n900n0 0\\" assert handle_input_data(input_data) == [2, 1, 1] input_data = \\"1 150n100n1 100n200n0 0\\" assert handle_input_data(input_data) == [1, 0] input_data = \\"3 1000n100n200n300n0 0\\" assert handle_input_data(input_data) == [3]","solution":"def max_songs_in_playlist(num_songs, time_limit, song_durations): Determines the maximum number of songs that can be included in the playlist without exceeding the time limit. :param num_songs: int - Number of songs. :param time_limit: int - Total time limit in seconds. :param song_durations: List[int] - List of durations for each song in seconds. :return: int - Maximum number of songs that can fit within the time limit. song_durations.sort() total_time = 0 song_count = 0 for duration in song_durations: if total_time + duration <= time_limit: total_time += duration song_count += 1 else: break return song_count def handle_input_data(input_data): Handles the input data and processes each dataset independently. :param input_data: str - Multi-line input string. :return: List[int] - Results for each dataset. results = [] lines = input_data.strip().split(\\"n\\") i = 0 while i < len(lines): n, t = map(int, lines[i].split()) if n == 0 and t == 0: break i += 1 song_durations = [] for j in range(n): song_durations.append(int(lines[i + j])) results.append(max_songs_in_playlist(n, t, song_durations)) i += n return results"},{"question":"def count_valid_sequences(N): This function returns the number of valid beep sequences of length N. A valid sequence starts and ends with a long beep and has alternating beeps. >>> count_valid_sequences(2) 1 >>> count_valid_sequences(4) 2 >>> count_valid_sequences(6) 3 def process_test_cases(test_cases): This function takes a list of test cases and returns the results for each. >>> process_test_cases([2, 4]) [1, 2] >>> process_test_cases([6, 8]) [3, 4] >>> process_test_cases([3, 5, 7]) [0, 0, 0]","solution":"def count_valid_sequences(N): This function returns the number of valid beep sequences of length N. A valid sequence starts and ends with a long beep and has alternating beeps. if N % 2 == 0: return (N // 2) else: return 0 def process_test_cases(test_cases): This function takes a list of test cases and returns the results for each. results = [] for N in test_cases: results.append(count_valid_sequences(N)) return results"},{"question":"def count_days_exceeding_previous(pages_read: List[int]) -> int: Returns the number of days on which the number of pages read exceeds the number of pages read on the previous day. >>> count_days_exceeding_previous([10, 5, 8, 12, 7, 15, 8]) 3 >>> count_days_exceeding_previous([4, 4, 4, 4, 4]) 0","solution":"def count_days_exceeding_previous(pages_read): Returns the number of days on which the number of pages read exceeds the number of pages read on the previous day. count = 0 for i in range(1, len(pages_read)): if pages_read[i] > pages_read[i - 1]: count += 1 return count"},{"question":"def can_send_exact_flow(n: int, m: int, edges: List[Tuple[int, int, int]], src: int, sink: int, f: int) -> str: Determine whether it's possible to send exactly \`f\` units of data flow per second from the source server to the sink server. Args: n (int): Number of servers. m (int): Number of directed channels. edges (List[Tuple[int, int, int]]): Each tuple represents a directed channel from server \`u\` to server \`v\` with a capacity of \`c\` packets per second. src (int): Source server. sink (int): Sink server. f (int): Required flow in packets per second. Returns: str: \\"Possible\\" if it is possible to send exactly \`f\` units of data flow per second from the source server to the sink server, otherwise \\"Impossible\\". >>> can_send_exact_flow(4, 5, [(1, 2, 10), (2, 3, 5), (3, 4, 10), (1, 3, 7), (2, 4, 3)], 1, 4, 8) 'Possible' >>> can_send_exact_flow(4, 5, [(1, 2, 2), (2, 3, 1), (3, 4, 2), (1, 3, 2), (2, 4, 1)], 1, 4, 5) 'Impossible'","solution":"from collections import deque, defaultdict import sys def bfs(capacity, source, sink, parent): visited = set() queue = deque([source]) visited.add(source) while queue: current = queue.popleft() for neighbor in capacity[current]: if neighbor not in visited and capacity[current][neighbor] > 0: visited.add(neighbor) parent[neighbor] = current if neighbor == sink: return True queue.append(neighbor) return False def edmonds_karp(n, graph, source, sink): capacity = defaultdict(lambda: defaultdict(int)) for u, v, c in graph: capacity[u][v] = c max_flow = 0 parent = {} while bfs(capacity, source, sink, parent): path_flow = sys.maxsize s = sink while s != source: path_flow = min(path_flow, capacity[parent[s]][s]) s = parent[s] v = sink while v != source: u = parent[v] capacity[u][v] -= path_flow capacity[v][u] += path_flow v = parent[v] max_flow += path_flow return max_flow def can_send_exact_flow(n, m, edges, src, sink, f): max_flow = edmonds_karp(n, edges, src, sink) return \\"Possible\\" if max_flow >= f else \\"Impossible\\""},{"question":"def min_path_sum(grid: List[List[int]]) -> int: Returns the minimum path sum from the top-left to the bottom-right corner of the grid. You can only move either down or right at any point in time. >>> min_path_sum([[1, 3, 1], [1, 5, 1], [4, 2, 1]]) 7 >>> min_path_sum([[2]]) 2 >>> min_path_sum([[1, 2], [1, 1]]) 3 >>> min_path_sum([[1, 2, 5], [3, 2, 1], [6, 2, 1]]) 7","solution":"def min_path_sum(grid): Returns the minimum path sum from the top-left to the bottom-right corner of the grid. You can only move either down or right at any point in time. n = len(grid) dp = [[0] * n for _ in range(n)] dp[0][0] = grid[0][0] # Initialize the first row and column of dp array for i in range(1, n): dp[0][i] = dp[0][i-1] + grid[0][i] dp[i][0] = dp[i-1][0] + grid[i][0] # Fill the dp array for i in range(1, n): for j in range(1, n): dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j] return dp[n-1][n-1] # Example usage: # grid = [ # [1, 3, 1], # [1, 5, 1], # [4, 2, 1] # ] # print(min_path_sum(grid)) # Output: 7"},{"question":"def queen_attack_squares(r: int, c: int) -> int: Calculates the number of squares that a queen can attack given her position on the chessboard. Args: r (int): The row position of the queen (1 to 8). c (int): The column position of the queen (1 to 8). Returns: int: The number of squares that the queen can attack. pass def test_queen_attack_corner(): assert queen_attack_squares(1, 1) == 21 assert queen_attack_squares(8, 8) == 21 def test_queen_attack_center(): assert queen_attack_squares(4, 4) == 27 assert queen_attack_squares(5, 5) == 27 def test_queen_attack_edge(): assert queen_attack_squares(1, 4) == 21 assert queen_attack_squares(4, 1) == 21 assert queen_attack_squares(8, 5) == 21 assert queen_attack_squares(5, 8) == 21","solution":"def queen_attack_squares(r, c): Calculates the number of squares that a queen can attack given her position on the chessboard. Args: r (int): The row position of the queen (1 to 8). c (int): The column position of the queen (1 to 8). Returns: int: The number of squares that the queen can attack. total_squares = 0 # Number of squares attacked in the same row total_squares += 7 # excluding the queen's own square # Number of squares attacked in the same column total_squares += 7 # excluding the queen's own square # Number of squares attacked on diagonals # Calculate the number of squares attacked diagonally in both directions for i in range(1, 8): if r + i <= 8 and c + i <= 8: total_squares += 1 if r - i >= 1 and c - i >= 1: total_squares += 1 if r + i <= 8 and c - i >= 1: total_squares += 1 if r - i >= 1 and c + i <= 8: total_squares += 1 return total_squares"},{"question":"from typing import List def unique_permutations(s: str) -> str: Finds all unique permutations of a string s that are not the same as s itself. Returns these permutations sorted in lexicographical order. >>> unique_permutations(\\"abc\\") == 'acb bac bca cab cba' >>> unique_permutations(\\"aaa\\") == 'No other permutations' pass def main(T: int, cases: List[str]) -> List[str]: Processes multiple test cases, finding unique permutations for each case. >>> T = 2 >>> cases = [\\"abc\\", \\"aaa\\"] >>> main(T, cases) == ['acb bac bca cab cba', 'No other permutations'] >>> T = 1 >>> cases = [\\"ab\\"] >>> main(T, cases) == ['ba'] pass","solution":"from itertools import permutations def unique_permutations(s): Finds all unique permutations of a string s that are not the same as s itself. Returns these permutations sorted in lexicographical order. perms = set(permutations(s)) original_tuple = tuple(s) perms.discard(original_tuple) if len(perms) == 0: return \\"No other permutations\\" sorted_perms = sorted([''.join(p) for p in perms]) return ' '.join(sorted_perms) def main(T, cases): results = [] for s in cases: results.append(unique_permutations(s)) return results"},{"question":"def decode_string(s: str) -> str: Decodes a string representing an encoding of some elements. Each alphabet represents a character and the subsequent integer represents the number of times the character is repeated. Examples: >>> decode_string(\\"a2b3\\") 'aabbb' >>> decode_string(\\"x5d2y4\\") 'xxxxxddyyyy' >>> decode_string(\\"s1p10\\") 'spppppppppp'","solution":"def decode_string(s): Decodes a string consisting of alternating alphabets and integers. Each alphabet represents a character and the subsequent integer represents the number of times the character is repeated. :param s: Encoded string :return: Decoded string decoded_str = \\"\\" i = 0 while i < len(s): char = s[i] i += 1 # Extract the entire number, which could be more than one digit num_str = \\"\\" while i < len(s) and s[i].isdigit(): num_str += s[i] i += 1 num = int(num_str) decoded_str += char * num return decoded_str"},{"question":"from typing import List def largestRectangleArea(heights: List[int]) -> int: Returns the largest rectangular area that can be formed using the given heights in the histogram. >>> largestRectangleArea([2, 1, 5, 6, 2, 3, 4]) 10 >>> largestRectangleArea([2, 4, 2, 1]) 6 >>> largestRectangleArea([2]) 2 >>> largestRectangleArea([3, 3, 3, 3]) 12 >>> largestRectangleArea([6, 5, 4, 3, 2, 1]) 12 >>> largestRectangleArea([1, 2, 3, 4, 5]) 9 >>> largestRectangleArea([2, 1, 4, 5, 1, 3, 3]) 8","solution":"def largestRectangleArea(heights): Returns the largest rectangular area that can be formed using the given heights in the histogram. stack = [] # Stack to store indices of heights array max_area = 0 # Initialize max area index = 0 # Current index in heights array while index < len(heights): # If the current bar is higher than the bar at stack top, push it to the stack if not stack or heights[index] >= heights[stack[-1]]: stack.append(index) index += 1 else: # Pop the top element from the stack top_of_stack = stack.pop() # Calculate the area with heights[top_of_stack] as the smallest (or minimum height) bar area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) # Now, pop the remaining bars from the stack and calculate area with each popped bar while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"def max_profit(prices): Returns the maximum profit that can be achieved from any single buy and sell transaction. :param prices: List of stock prices on different days. :return: Maximum profit achievable. pass def main(inputs): Processes multiple test cases of stock prices to determine the maximum profit for each case. :param inputs: List of strings representing the input data. :return: List of integers representing the maximum profit for each test case. pass from solution import max_profit, main def test_max_profit(): assert max_profit([7, 1, 5, 3, 6, 4]) == 5 assert max_profit([7, 6, 4, 3, 1]) == 0 assert max_profit([1, 2, 3, 4, 5, 6, 7]) == 6 assert max_profit([1, 6, 5, 10, 8, 7, 12]) == 11 assert max_profit([10, 9, 8, 1, 0, 5, 10]) == 10 assert max_profit([3, 3, 3, 3, 3, 3, 3]) == 0 assert max_profit([]) == 0 assert max_profit([5]) == 0 def test_main(): inputs = [ \\"3\\", \\"5\\", \\"7 1 5 3 6 4\\", \\"6\\", \\"7 6 4 3 1\\", \\"7\\", \\"1 2 3 4 5 6 7\\" ] expected_outputs = [5, 0, 6] assert main(inputs) == expected_outputs inputs = [ \\"2\\", \\"4\\", \\"4 3 2 1\\", \\"3\\", \\"1 2 3\\" ] expected_outputs = [0, 2] assert main(inputs) == expected_outputs","solution":"def max_profit(prices): Returns the maximum profit that can be achieved from any single buy and sell transaction. :param prices: List of stock prices on different days. :return: Maximum profit achievable. if not prices or len(prices) < 2: return 0 min_price = prices[0] max_profit = 0 for price in prices[1:]: if price < min_price: min_price = price else: max_profit = max(max_profit, price - min_price) return max_profit def main(inputs): results = [] T = int(inputs[0]) idx = 1 for _ in range(T): n = int(inputs[idx]) prices = list(map(int, inputs[idx + 1].split())) results.append(max_profit(prices)) idx += 2 return results"},{"question":"def min_operations_to_same_parity(n: int, m: int, grid: List[List[int]]) -> int: Determine the minimum number of special operations required to transform the grid such that every number in the grid has the same parity. >>> min_operations_to_same_parity(2, 2, [[1, 2], [3, 4]]) == 2 True >>> min_operations_to_same_parity(3, 3, [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 4 True pass # Unit tests import pytest def test_all_odd(): assert min_operations_to_same_parity(2, 2, [[1, 3], [5, 7]]) == 0 def test_all_even(): assert min_operations_to_same_parity(2, 2, [[2, 4], [6, 8]]) == 0 def test_mixed_small(): assert min_operations_to_same_parity(2, 2, [[1, 2], [3, 4]]) == 2 def test_mixed_large(): assert min_operations_to_same_parity(3, 3, [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 4 def test_more_evens(): assert min_operations_to_same_parity(3, 3, [[2, 4, 6], [8, 10, 12], [1, 14, 16]]) == 1 def test_more_odds(): assert min_operations_to_same_parity(3, 3, [[1, 3, 5], [7, 9, 11], [2, 13, 15]]) == 1 pytest.main()","solution":"def min_operations_to_same_parity(n, m, grid): odd_count = 0 even_count = 0 # Count occurrences of odd and even numbers. for row in grid: for num in row: if num % 2 == 0: even_count += 1 else: odd_count += 1 # The minimum number of operations is to convert the fewer group to match the majority. return min(odd_count, even_count)"},{"question":"def process_queries(m, q, B, queries): Processes a list of queries on array B which includes reversing, rotating left, rotating right, and finding maximum element in a subarray. Args: m: Length of the array B. q: Number of queries. B: List of integers representing the array. queries: List of queries where each query is a list that represents an operation. Returns: List of results for getMax queries. Examples: >>> process_queries(5, 6, [1, 2, 3, 4, 5], [[0, 1, 3], [3, 1, 3], [1, 0, 4, 2], [3, 0, 4], [2, 1, 3, 1], [3, 1, 3]]) [4, 5, 5]","solution":"def process_queries(m, q, B, queries): results = [] def reverse(s, t): B[s:t+1] = B[s:t+1][::-1] def rotate_left(s, t, k): k = k % (t - s + 1) B[s:t+1] = B[s + k:t + 1] + B[s:s + k] def rotate_right(s, t, k): k = k % (t - s + 1) B[s:t+1] = B[t + 1 - k:t + 1] + B[s:t + 1 - k] def get_max(s, t): return max(B[s:t+1]) for query in queries: action = query[0] if action == 0: s, t = query[1], query[2] reverse(s, t) elif action == 1: s, t, k = query[1], query[2], query[3] rotate_left(s, t, k) elif action == 2: s, t, k = query[1], query[2], query[3] rotate_right(s, t, k) elif action == 3: s, t = query[1], query[2] results.append(get_max(s, t)) return results"},{"question":"def check_no_overlap(n: int, intervals: List[Tuple[int, int]]) -> str: Function to check if there are any overlapping requests. Parameters: n (int): The number of intervals intervals (list of tuple): Each tuple contains two integers representing arrival and completion time of a request Returns: str: \\"YES\\" if there are no overlapping requests, otherwise \\"NO\\"","solution":"def check_no_overlap(n, intervals): Function to check if there are any overlapping requests. Parameters: n (int): The number of intervals intervals (list of tuple): Each tuple contains two integers representing arrival and completion time of a request Returns: str: \\"YES\\" if there are no overlapping requests, otherwise \\"NO\\" # Sort intervals based on the start time \`ai\` intervals.sort() for i in range(n - 1): # Compare the end time \`bi\` of the current interval with # the start time \`ai\` of the next interval if intervals[i][1] > intervals[i + 1][0]: return \\"NO\\" return \\"YES\\""},{"question":"from typing import List def minimum_moves(N: int, grid: List[List[int]]) -> int: Finds the minimum number of moves the robot needs to reach the end position (N-1, N-1). Returns -1 if it is impossible to reach the end position. >>> minimum_moves(4, [ [0, 0, 0, 0], [1, 1, 0, 1], [0, 0, 0, 0], [0, 1, 1, 0] ]) 6 >>> minimum_moves(3, [ [0, 1, 0], [0, 1, 0], [0, 0, 0] ]) 4 >>> minimum_moves(2, [ [0, 1], [1, 0] ]) -1 pass # Implement the function here def test_example_1(): N = 4 grid = [ [0, 0, 0, 0], [1, 1, 0, 1], [0, 0, 0, 0], [0, 1, 1, 0] ] assert minimum_moves(N, grid) == 6 def test_example_2(): N = 3 grid = [ [0, 1, 0], [0, 1, 0], [0, 0, 0] ] assert minimum_moves(N, grid) == 4 def test_example_3(): N = 2 grid = [ [0, 1], [1, 0] ] assert minimum_moves(N, grid) == -1 def test_no_obstacle(): N = 2 grid = [ [0, 0], [0, 0] ] assert minimum_moves(N, grid) == 2 def test_full_blockage(): N = 3 grid = [ [0, 1, 0], [1, 1, 1], [0, 0, 0] ] assert minimum_moves(N, grid) == -1 def test_large_grid(): N = 5 grid = [ [0, 0, 0, 0, 0], [1, 1, 1, 1, 0], [0, 0, 0, 1, 0], [0, 1, 0, 0, 0], [0, 0, 0, 0, 0] ] assert minimum_moves(N, grid) == 8","solution":"from collections import deque def minimum_moves(N, grid): Finds the minimum number of moves the robot needs to reach the end position (N-1, N-1). Returns -1 if it is impossible to reach the end position. def is_valid(x, y): return 0 <= x < N and 0 <= y < N and grid[x][y] == 0 directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([(0, 0, 0)]) # (x, y, moves) visited = set((0, 0)) while queue: x, y, moves = queue.popleft() if x == N - 1 and y == N - 1: return moves for dx, dy in directions: nx, ny = x + dx, y + dy if is_valid(nx, ny) and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny, moves + 1)) return -1"},{"question":"def roads_to_remove(n, m, roads): Returns the minimum number of roads that need to be removed to form a tree. Args: n (int): Number of cities. m (int): Number of roads. roads (List[Tuple[int, int, int]]): List of roads where each road is represented as a tuple (u, v, w) indicating a road between cities u and v with length w. Returns: int: Minimum number of roads that need to be removed. >>> roads_to_remove(4, 5, [(1, 2, 3), (1, 3, 2), (1, 4, 4), (2, 3, 1), (3, 4, 3)]) 2 >>> roads_to_remove(5, 5, [(1, 2, 2), (2, 3, 3), (3, 4, 1), (4, 5, 5), (1, 3, 6)]) 1 pass def test_roads_to_remove_basic(): assert roads_to_remove(4, 5, [ (1, 2, 3), (1, 3, 2), (1, 4, 4), (2, 3, 1), (3, 4, 3) ]) == 2 def test_roads_to_remove_single(): assert roads_to_remove(5, 5, [ (1, 2, 2), (2, 3, 3), (3, 4, 1), (4, 5, 5), (1, 3, 6) ]) == 1 def test_roads_to_remove_minimum_case(): assert roads_to_remove(2, 1, [ (1, 2, 1) ]) == 0 def test_roads_to_remove_no_extra_roads(): assert roads_to_remove(3, 2, [ (1, 2, 1), (2, 3, 2) ]) == 0 def test_roads_to_remove_maximum_roads(): assert roads_to_remove(5, 10, [ (1, 2, 1), (1, 3, 1), (1, 4, 1), (1, 5, 1), (2, 3, 1), (2, 4, 1), (2, 5, 1), (3, 4, 1), (3, 5, 1), (4, 5, 1) ]) == 6","solution":"def roads_to_remove(n, m, roads): Returns the minimum number of roads that need to be removed to form a tree. return m - (n - 1)"},{"question":"def can_light_all_gardens(n: int, b: List[int]) -> str: Determine if it's possible to light up all gardens such that all flowers bloom. The function uses any number of Type-A and Type-B lights on a given sequence of light requirements. Args: n (int): The number of gardens in a straight line. b (List[int]): The list containing light requirements for each garden. Returns: str: \\"YES\\" if it is possible to light all gardens, otherwise \\"NO\\". Examples: >>> can_light_all_gardens(6, [1, 1, 2, 2, 3, 3]) \\"YES\\" >>> can_light_all_gardens(4, [5, 6, 7, 8]) \\"YES\\" >>> can_light_all_gardens(3, [1, 2, 4]) \\"NO\\"","solution":"def can_light_all_gardens(n, b): # Since we need to use Type-B light which can cover two consecutive gardens, # we need to check pairs of consecutive light requirements. # If we ever find a pair of consecutive gardens that do not have compatible light types # (either the same or consecutive in sequence), it means it's not possible to light all gardens. for i in range(1, n): if abs(b[i] - b[i-1]) > 1: return \\"NO\\" return \\"YES\\""},{"question":"def count_clusters(n: int, m: int, grid: List[List[int]]) -> int: Given the dimensions of the grid (n, m) and the grid itself consisting of 1s and 0s, this function returns the number of distinct clusters of connected cells with the value \\"1\\". >>> count_clusters(4, 5, [ [1, 1, 0, 0, 0], [0, 1, 1, 0, 1], [0, 0, 0, 1, 1], [1, 0, 0, 0, 1] ]) 3 >>> count_clusters(3, 3, [ [1, 0, 0], [0, 1, 0], [0, 0, 1] ]) 3 >>> count_clusters(2, 2, [ [1, 1], [1, 1] ]) 1 >>> count_clusters(1, 1, [ [1] ]) 1 >>> count_clusters(3, 3, [ [0, 0, 0], [0, 0, 0], [0, 0, 0] ]) 0 >>> count_clusters(3, 3, [ [1, 0, 1], [0, 0, 0], [1, 0, 1] ]) 4 pass # Write your solution here.","solution":"def count_clusters(n, m, grid): Given the dimensions of the grid (n, m) and the grid itself consisting of 1s and 0s, this function returns the number of distinct clusters of connected cells with the value \\"1\\". def dfs(x, y): stack = [(x, y)] while stack: cx, cy = stack.pop() if cx < 0 or cx >= n or cy < 0 or cy >= m or grid[cx][cy] != 1: continue grid[cx][cy] = -1 # Mark as visited for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: stack.append((cx + dx, cy + dy)) clusters = 0 for i in range(n): for j in range(m): if grid[i][j] == 1: # Start a new DFS dfs(i, j) clusters += 1 return clusters # Example usage n, m = 4, 5 grid = [ [1, 1, 0, 0, 0], [0, 1, 1, 0, 1], [0, 0, 0, 1, 1], [1, 0, 0, 0, 1] ] print(count_clusters(n, m, grid)) # Output: 3"},{"question":"def find_peak_element(arr: List[int]) -> int: Finds and returns the index of any peak element in the array. A peak element is defined as one which is greater than its neighbors. Args: arr (List[int]): Array of integers. Returns: int: Index of one peak element. Examples: >>> find_peak_element([1, 3, 20, 4, 1, 0, 6]) 2 >>> find_peak_element([10, 20, 15]) 1","solution":"def find_peak_element(arr): Finds and returns the index of any peak element in the array. A peak element is defined as one which is greater than its neighbors. The search is done in O(log n) time using a binary search approach. n = len(arr) def binary_search(low, high): if low == high: return low mid = (low + high) // 2 if arr[mid] > arr[mid + 1]: return binary_search(low, mid) return binary_search(mid + 1, high) return binary_search(0, n - 1)"},{"question":"from typing import List, Tuple def bfs_tree_sum(n: int, edges: List[Tuple[int, int, int]]) -> int: Determine the sum of edge weights for all edges included in the BFS traversal of the tree, taken modulo 10^9 + 7. Args: n (int): Number of nodes in the tree edges (List[Tuple[int, int, int]]): List of tuples representing the edges (u, v, w) Returns: int: The sum of edge weights for all edges included in the BFS traversal of the tree, taken modulo 10^9 + 7. >>> bfs_tree_sum(5, [(1, 2, 4), (1, 3, 3), (2, 4, 2), (2, 5, 1)]) 10 >>> bfs_tree_sum(3, [(1, 2, 6), (1, 3, 5)]) 11","solution":"from collections import deque, defaultdict def bfs_tree_sum(n, edges): MOD = 10**9 + 7 # Create an adjacency list graph = defaultdict(list) for u, v, w in edges: graph[u].append((v, w)) graph[v].append((u, w)) # BFS initialization queue = deque([1]) visited = [False] * (n + 1) visited[1] = True total_weight = 0 while queue: node = queue.popleft() for neighbor, weight in graph[node]: if not visited[neighbor]: visited[neighbor] = True total_weight = (total_weight + weight) % MOD queue.append(neighbor) return total_weight"},{"question":"from typing import List def can_form_palindrome(s: str) -> str: Determines if the given string can be rearranged to form a palindrome. A string can be rearranged to form a palindrome if at most one character has an odd frequency. :param s: A string consisting of only lowercase English letters. :return: \\"YES\\" if the string can be rearranged to form a palindrome, otherwise \\"NO\\". from collections import Counter def check_palindrome_rearrangement(t: int, test_cases: List[str]) -> List[str]: Determines if each string in the test cases can be rearranged to form a palindrome. :param t: The number of test cases :param test_cases: List of strings to check :return: List of results (\\"YES\\" or \\"NO\\") for each test case def test_can_form_palindrome(): assert can_form_palindrome(\\"civic\\") == \\"YES\\" assert can_form_palindrome(\\"ivicc\\") == \\"YES\\" assert can_form_palindrome(\\"hello\\") == \\"NO\\" assert can_form_palindrome(\\"a\\") == \\"YES\\" assert can_form_palindrome(\\"aabb\\") == \\"YES\\" assert can_form_palindrome(\\"aaabbb\\") == \\"NO\\" def test_check_palindrome_rearrangement(): assert check_palindrome_rearrangement(3, [\\"civic\\", \\"ivicc\\", \\"hello\\"]) == [\\"YES\\", \\"YES\\", \\"NO\\"] assert check_palindrome_rearrangement(2, [\\"aabb\\", \\"abc\\"]) == [\\"YES\\", \\"NO\\"] assert check_palindrome_rearrangement(1, [\\"racecar\\"]) == [\\"YES\\"] assert check_palindrome_rearrangement(4, [\\"ab\\", \\"aaabb\\", \\"abcd\\", \\"aabbcc\\"]) == [\\"NO\\", \\"YES\\", \\"NO\\", \\"YES\\"]","solution":"def can_form_palindrome(s): Determines if the given string can be rearranged to form a palindrome. A string can be rearranged to form a palindrome if at most one character has an odd frequency. :param s: A string consisting of only lowercase English letters. :return: \\"YES\\" if the string can be rearranged to form a palindrome, otherwise \\"NO\\". from collections import Counter # Count frequency of each character counter = Counter(s) # Check how many characters have an odd frequency odd_count = sum(1 for count in counter.values() if count % 2 != 0) # A string can form a palindrome if at most one character has an odd frequency return \\"YES\\" if odd_count <= 1 else \\"NO\\" def check_palindrome_rearrangement(t, test_cases): Determines if each string in the test cases can be rearranged to form a palindrome. :param t: The number of test cases :param test_cases: List of strings to check :return: List of results (\\"YES\\" or \\"NO\\") for each test case return [can_form_palindrome(s) for s in test_cases]"},{"question":"def max_product_subarray(arr: List[int]) -> int: Returns the maximum product of any contiguous subarray. >>> max_product_subarray([2, 3, -2, 4, -1]) 48 >>> max_product_subarray([-2, 0, -1, -12]) 12 >>> max_product_subarray([1, 2, 3, 4]) 24 >>> max_product_subarray([-1, -2, -3, -4]) 24 >>> max_product_subarray([5]) 5 >>> max_product_subarray([-5]) -5 >>> max_product_subarray([0, 2, 3, 0, -2, 4]) 6 >>> max_product_subarray([0, 0, 0, 0]) 0 >>> max_product_subarray([]) 0","solution":"def max_product_subarray(arr): Returns the maximum product of any contiguous subarray. if not arr: return 0 max_product = arr[0] min_product = arr[0] result = arr[0] for num in arr[1:]: if num == 0: max_product = 1 min_product = 1 temp_max = max(num, max_product * num, min_product * num) min_product = min(num, max_product * num, min_product * num) max_product = temp_max result = max(result, max_product) return result"},{"question":"def binary_to_decimal(binary_str): Converts a binary string to its decimal value. return int(binary_str, 2) def max_non_overlapping_sum(s1, s2): Finds the maximum possible sum of two non-overlapping substrings where one is taken from s1 and the other is taken from s2. The sum of two binary strings is defined as the sum of their decimal values. Args: s1 (str): The first binary string. s2 (str): The second binary string. Returns: int: The maximum possible sum of two non-overlapping substrings. Examples: >>> max_non_overlapping_sum(\\"10110\\", \\"1101\\") 35 >>> max_non_overlapping_sum(\\"11101\\", \\"101\\") 34 import pytest from solution import max_non_overlapping_sum def test_example_1(): assert max_non_overlapping_sum(\\"10110\\", \\"1101\\") == 22 + 13 def test_example_2(): assert max_non_overlapping_sum(\\"11101\\", \\"101\\") == 29 + 5 def test_single_characters(): assert max_non_overlapping_sum(\\"1\\", \\"0\\") == 1 assert max_non_overlapping_sum(\\"0\\", \\"1\\") == 1 assert max_non_overlapping_sum(\\"1\\", \\"1\\") == 2 def test_mixed_lengths(): assert max_non_overlapping_sum(\\"101\\", \\"1111\\") == 5 + 15 def test_same_strings(): assert max_non_overlapping_sum(\\"111\\", \\"111\\") == 7 + 7 def test_longer_strings(): assert max_non_overlapping_sum(\\"110011\\", \\"101010\\") == 51 + 42 # Maximum sum from substrings \\"110011\\" (51) and \\"101010\\" (42) @pytest.mark.parametrize(\\"s1, s2, expected\\", [ (\\"0\\", \\"0\\", 0), (\\"1\\", \\"0\\", 1), (\\"0\\", \\"1\\", 1), (\\"1\\", \\"1\\", 2), (\\"111\\", \\"0\\", 7), (\\"0\\", \\"111\\", 7), ]) def test_edge_cases(s1, s2, expected): assert max_non_overlapping_sum(s1, s2) == expected","solution":"def binary_to_decimal(binary_str): Converts a binary string to its decimal value. return int(binary_str, 2) def max_non_overlapping_sum(s1, s2): Finds the maximum possible sum of two non-overlapping substrings where one is taken from s1 and the other is taken from s2. The sum of two binary strings is defined as the sum of their decimal values. max_sum = 0 for i in range(len(s1)): for j in range(i, len(s1)): substr_s1 = s1[i:j+1] value_s1 = binary_to_decimal(substr_s1) for k in range(len(s2)): for l in range(k, len(s2)): substr_s2 = s2[k:l+1] value_s2 = binary_to_decimal(substr_s2) current_sum = value_s1 + value_s2 if current_sum > max_sum: max_sum = current_sum return max_sum"},{"question":"def minimum_travel_time(N: int, lights: str) -> int: Determine the minimum time needed for a car to travel from the first light to the last light >>> minimum_travel_time(5, \\"GGGRG\\") 4 >>> minimum_travel_time(6, \\"GRGRGR\\") -1 >>> minimum_travel_time(8, \\"GGGGGRGG\\") 7","solution":"def minimum_travel_time(N, lights): if lights[0] == 'R' or lights[-1] == 'R': return -1 min_time = -1 if 'G' not in lights: return -1 last_green = -1 for index, light in enumerate(lights): if light == 'G': if last_green == -1: last_green = index else: min_time = index if last_green == min_time: return min_time else: return min_time if min_time >= 0 else -1"},{"question":"def can_handle_requests(test_cases): Determine whether the service can handle all requests for each day based on provided test cases. Args: test_cases (list): A list of tuples where each tuple contains: - n (int): The number of data requests. - c (int): The maximum data processing capacity of the service per day. - requests (list): A list of tuples where each tuple contains: - request time (str): The request time in HH:MM 24-hour format. - data size (int): The data size of the request. Returns: list: A list of strings, each being \\"YES\\" if the service can handle all requests for the day, otherwise \\"NO\\". Example: >>> can_handle_requests([(4, 150, [(\\"08:30\\", 50), (\\"09:00\\", 50), (\\"14:15\\", 20), (\\"16:45\\", 30)]), ... (3, 100, [(\\"10:10\\", 45), (\\"12:30\\", 50), (\\"18:00\\", 10)])]) [\\"YES\\", \\"NO\\"]","solution":"def can_handle_requests(test_cases): results = [] for case in test_cases: n, c, requests = case total_data_needed = sum(data_size for time, data_size in requests) if total_data_needed <= c: results.append(\\"YES\\") else: results.append(\\"NO\\") return results # Example usage test_cases = [ (4, 150, [(\\"08:30\\", 50), (\\"09:00\\", 50), (\\"14:15\\", 20), (\\"16:45\\", 30)]), (3, 100, [(\\"10:10\\", 45), (\\"12:30\\", 50), (\\"18:00\\", 10)]) ] results = can_handle_requests(test_cases) for result in results: print(result)"},{"question":"def find_smallest_window_with_all_unique_chars(query_str: str) -> str: Find the smallest window containing all unique characters of the given query string. >>> find_smallest_window_with_all_unique_chars(\\"aabcbcdbca\\") \\"dbca\\" >>> find_smallest_window_with_all_unique_chars(\\"bbacac\\") \\"bac\\" >>> find_smallest_window_with_all_unique_chars(\\"abc\\") \\"abc\\" >>> find_smallest_window_with_all_unique_chars(\\"a\\") \\"a\\" >>> find_smallest_window_with_all_unique_chars(\\"\\") \\"\\" >>> find_smallest_window_with_all_unique_chars(\\"aaaaa\\") \\"a\\" >>> find_smallest_window_with_all_unique_chars(\\"aaabaaa\\") \\"ab\\" def process_test_cases(t: int, queries: List[str]) -> List[str]: Process the test cases to find the smallest window containing all unique characters for each query string. >>> process_test_cases(2, [\\"aabcbcdbca\\", \\"bbacac\\"]) [\\"dbca\\", \\"bac\\"] >>> process_test_cases(3, [\\"abc\\", \\"a\\", \\"aaaaa\\"]) [\\"abc\\", \\"a\\", \\"a\\"]","solution":"def find_smallest_window_with_all_unique_chars(query_str): if not query_str: return \\"\\" unique_chars = set(query_str) unique_count = len(unique_chars) n = len(query_str) char_count = {} min_window_length = float('inf') min_window_start = 0 left = 0 count = 0 for right in range(n): char_count[query_str[right]] = char_count.get(query_str[right], 0) + 1 if char_count[query_str[right]] == 1: count += 1 while count == unique_count: window_length = right - left + 1 if window_length < min_window_length: min_window_length = window_length min_window_start = left char_count[query_str[left]] -= 1 if char_count[query_str[left]] == 0: count -= 1 left += 1 return query_str[min_window_start:min_window_start + min_window_length] def process_test_cases(t, queries): results = [] for query in queries: results.append(find_smallest_window_with_all_unique_chars(query)) return results"},{"question":"def min_abs_diff_partition(n: int, arr: List[int]) -> int: Returns the minimum possible absolute difference between the sums of the two subsets. >>> min_abs_diff_partition(4, [1, 6, 11, 5]) 1 >>> min_abs_diff_partition(6, [3, 1, 4, 2, 2, 1]) 1 >>> min_abs_diff_partition(2, [10, 20]) 10 >>> min_abs_diff_partition(4, [3, 3, 3, 3]) 0 >>> min_abs_diff_partition(8, [1, 2, 3, 4, 5, 6, 7, 8]) 0","solution":"def min_abs_diff_partition(n, arr): Returns the minimum possible absolute difference between the sums of the two subsets. total_sum = sum(arr) target = total_sum // 2 dp = [False] * (target + 1) dp[0] = True for num in arr: for j in range(target, num - 1, -1): dp[j] = dp[j] or dp[j - num] for i in range(target, -1, -1): if dp[i]: sum1 = i sum2 = total_sum - i return abs(sum2 - sum1)"},{"question":"def unique_paths(m: int, n: int) -> int: Calculate the total number of unique paths the robot can take to reach the bottom-right corner from the top-left corner of the grid. :param m: Number of rows in the grid. :param n: Number of columns in the grid. :return: Total number of unique paths from (0, 0) to (m-1, n-1). >>> unique_paths(2, 2) 2 >>> unique_paths(3, 3) 6 >>> unique_paths(2, 3) 3","solution":"def unique_paths(m, n): Calculate the total number of unique paths the robot can take to reach the bottom-right corner from the top-left corner of the grid. :param m: Number of rows in the grid. :param n: Number of columns in the grid. :return: Total number of unique paths from (0, 0) to (m-1, n-1). # Create a 2D list to store the number of ways to reach each cell dp = [[1] * n for _ in range(m)] # Loop through each cell starting from (1, 1) for i in range(1, m): for j in range(1, n): dp[i][j] = dp[i-1][j] + dp[i][j-1] return dp[m-1][n-1]"},{"question":"def max_consecutive_marbles(s: str) -> int: Returns the maximum number of consecutive marbles of the same color that can be removed in a single move. >>> max_consecutive_marbles(\\"abccbaabccba\\") 2 >>> max_consecutive_marbles(\\"aabbbcccc\\") 4 >>> max_consecutive_marbles(\\"xyz\\") 1 >>> max_consecutive_marbles(\\"aaabbbaaa\\") 3","solution":"def max_consecutive_marbles(s): Returns the maximum number of consecutive marbles of the same color that can be removed in a single move. max_count = 1 current_count = 1 for i in range(1, len(s)): if s[i] == s[i - 1]: current_count += 1 max_count = max(max_count, current_count) else: current_count = 1 return max_count"},{"question":"def count_even_sum_pairs(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: You are given an array of integers. Your task is to find the number of pairs (i, j) where i < j such that array[i] + array[j] is even. Parameters: T (int): The number of test cases. test_cases (List[Tuple[int, List[int]]]): A list of test cases where each test case is a tuple containing an integer N (number of elements in the array) and a list of N integers. Returns: List[int]: A list containing the number of valid pairs for each test case. >>> count_even_sum_pairs(2, [(4, [1, 2, 3, 4]), (5, [2, 4, 6, 8, 10])]) [2, 10] >>> count_even_sum_pairs(1, [(3, [1, 3, 5])]) [3]","solution":"def count_even_sum_pairs(T, test_cases): results = [] for i in range(T): N, array = test_cases[i] count_even = sum(1 for x in array if x % 2 == 0) count_odd = N - count_even result = (count_even * (count_even - 1)) // 2 + (count_odd * (count_odd - 1)) // 2 results.append(result) return results"},{"question":"def longest_common_suffix(n: int, words: List[str]) -> str: Returns the longest common suffix among the given words. >>> longest_common_suffix(3, [\\"abracadabra\\", \\"cadabra\\", \\"labracadabra\\"]) == \\"cadabra\\" >>> longest_common_suffix(4, [\\"hello\\", \\"ello\\", \\"cello\\", \\"bello\\"]) == \\"ello\\" >>> longest_common_suffix(2, [\\"apple\\", \\"banana\\"]) == \\"\\" >>> longest_common_suffix(1, [\\"abracadabra\\"]) == \\"abracadabra\\" >>> longest_common_suffix(0, []) == \\"\\" >>> longest_common_suffix(3, [\\"hello\\", \\"hallo\\", \\"hullo\\"]) == \\"llo\\"","solution":"def longest_common_suffix(n, words): Returns the longest common suffix among the given words. if n == 0: return \\"\\" # Reverse all words to compare suffix as prefix reversed_words = [word[::-1] for word in words] # Find the longest common prefix from the reversed words common_suffix = \\"\\" for chars in zip(*reversed_words): if all(c == chars[0] for c in chars): common_suffix += chars[0] else: break # Reverse the result to get the longest common suffix return common_suffix[::-1]"},{"question":"def top_three_scores(student_scores): Returns a list of tuples (name, score) representing the top three highest scores. If more than three scores are tied, all tied scores are included. >>> top_three_scores([\\"Alice 95\\", \\"Bob 90\\", \\"Charlie 85\\", \\"David 80\\", \\"Eve 75\\", \\"Frank 70\\"]) [(\\"Alice\\", 95), (\\"Bob\\", 90), (\\"Charlie\\", 85)] >>> top_three_scores([\\"Alice 95\\", \\"Bob 95\\", \\"Charlie 90\\", \\"David 90\\", \\"Eve 85\\"]) [(\\"Alice\\", 95), (\\"Bob\\", 95), (\\"Charlie\\", 90), (\\"David\\", 90)] >>> top_three_scores([\\"Alice 90\\", \\"Bob 90\\", \\"Charlie 90\\", \\"David 90\\"]) [(\\"Alice\\", 90), (\\"Bob\\", 90), (\\"Charlie\\", 90), (\\"David\\", 90)]","solution":"def top_three_scores(student_scores): Returns a list of tuples (name, score) representing the top three highest scores. scores_dict = {} for student_score in student_scores: name, score = student_score.rsplit(' ', 1) score = int(score) if score in scores_dict: scores_dict[score].append(name) else: scores_dict[score] = [name] sorted_scores = sorted(scores_dict.keys(), reverse=True) result = [] for score in sorted_scores: for name in scores_dict[score]: result.append((name, score)) if len(result) >= 3: break return result"},{"question":"from typing import List def find_special_numbers(numbers: List[int]) -> List[int]: Given a list of integers, return a new list that contains only those integers which are equal to the sum of their own digits each raised to the power of the number of digits in the number. >>> find_special_numbers([153, 10, 370, 371, 407, 123]) [153, 370, 371, 407] >>> find_special_numbers([10, 20, 30, 40]) [] >>> find_special_numbers([153, 370, 371, 407]) [153, 370, 371, 407] >>> find_special_numbers([1, 2, 3, 4, 153, 370, 371, 407, 8208, 9474]) [1, 2, 3, 4, 153, 370, 371, 407, 8208, 9474] >>> find_special_numbers([]) [] >>> find_special_numbers([9474, 54748, 92727, 93084]) [9474, 54748, 92727, 93084] >>> find_special_numbers([1000000, 999999, 123456]) []","solution":"from typing import List def find_special_numbers(numbers: List[int]) -> List[int]: def is_special_number(n: int) -> bool: digits = [int(d) for d in str(n)] num_digits = len(digits) return n == sum(d ** num_digits for d in digits) return [num for num in numbers if is_special_number(num)]"},{"question":"def max_gold_coins(M, N, grid): Help Anna find the maximum number of gold coins she can collect. Start from the top-left corner of the grid and reach the bottom-right corner while collecting as many gold coins as possible, moving only right or down. Args: M (int): Number of rows in the grid. N (int): Number of columns in the grid. grid (List[List[int]]): 2D list representing the number of gold coins in each cell. Returns: int: Maximum number of gold coins that can be collected. >>> max_gold_coins(3, 4, [ ... [1, 3, 1, 5], ... [2, 2, 4, 1], ... [5, 0, 2, 3] ... ]) == 15 >>> max_gold_coins(1, 4, [ ... [1, 2, 3, 4] ... ]) == 10 >>> max_gold_coins(4, 1, [ ... [1], ... [2], ... [3], ... [4] ... ]) == 10 >>> max_gold_coins(3, 3, [ ... [0, 0, 0], ... [0, 0, 0], ... [0, 0, 0] ... ]) == 0 >>> max_gold_coins(3, 3, [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) == 29 >>> max_gold_coins(1, 1, [ ... [5] ... ]) == 5","solution":"def max_gold_coins(M, N, grid): if M == 0 or N == 0 or not grid: return 0 dp = [[0] * N for _ in range(M)] dp[0][0] = grid[0][0] for i in range(1, M): dp[i][0] = dp[i-1][0] + grid[i][0] for j in range(1, N): dp[0][j] = dp[0][j-1] + grid[0][j] for i in range(1, M): for j in range(1, N): dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j] return dp[M-1][N-1]"},{"question":"def max_points(grid: List[List[int]]) -> int: Given an m x n grid filled with non-negative integers, return the maximum number of points that can be collected starting from the top-left corner and moving only right or down to the bottom-right corner. >>> max_points([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 29 >>> max_points([[1, 2, 3, 4, 5]]) == 15 >>> max_points([[1], [2], [3], [4], [5]]) == 15 >>> max_points([[5]]) == 5 >>> max_points([[0, 0], [0, 0]]) == 0 >>> max_points([[1, 3, 1], [1, 5, 1], [4, 2, 1]]) == 12 pass","solution":"def max_points(grid): Given an m x n grid filled with non-negative integers, return the maximum number of points that can be collected starting from the top-left corner and moving only right or down to the bottom-right corner. if not grid: return 0 m, n = len(grid), len(grid[0]) dp = [[0] * n for _ in range(m)] dp[0][0] = grid[0][0] # Fill the values for the first row for j in range(1, n): dp[0][j] = dp[0][j-1] + grid[0][j] # Fill the values for the first column for i in range(1, m): dp[i][0] = dp[i-1][0] + grid[i][0] # Fill the remaining values in dp array for i in range(1, m): for j in range(1, n): dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j] return dp[m-1][n-1]"},{"question":"import math def can_measure_exactly(A: int, B: int, Z: int) -> bool: Returns True if it is possible to measure exactly Z liters using jugs of A and B capacities, otherwise returns False. >>> can_measure_exactly(3, 5, 4) True >>> can_measure_exactly(2, 6, 5) False >>> can_measure_exactly(1, 2, 3) True","solution":"import math def can_measure_exactly(A, B, Z): Returns True if it is possible to measure exactly Z liters using jugs of A and B capacities, otherwise returns False. # If Z is greater than the sum of both jugs, it's impossible to measure it if Z > A + B: return False # If Z is 0, we can always measure it if Z == 0: return True # Use the greatest common divisor (GCD) to check measurability return Z % math.gcd(A, B) == 0"},{"question":"def longest_palindromic_substring(s: str) -> str: Returns the longest palindromic substring from the given string s. >>> longest_palindromic_substring('babad') 'bab' >>> longest_palindromic_substring('cbbd') 'bb' >>> longest_palindromic_substring('a') 'a' >>> longest_palindromic_substring('aaaaa') 'aaaaa' >>> longest_palindromic_substring('abc') 'a' or 'b' or 'c' >>> longest_palindromic_substring('racecar') 'racecar' >>> longest_palindromic_substring('abacdfgdcaba') 'aba' >>> longest_palindromic_substring('') \\"\\" >>> longest_palindromic_substring('abcbahello') 'abcba'","solution":"def longest_palindromic_substring(s): Returns the longest palindromic substring from the given string s. if not s: return \\"\\" n = len(s) start, end = 0, 0 def expand_around_center(left, right): nonlocal start, end while left >= 0 and right < n and s[left] == s[right]: left -= 1 right += 1 # now s[left+1:right] is a palindrome if right - left - 1 > end - start: start, end = left + 1, right for i in range(n): expand_around_center(i, i) # Odd length palindrome expand_around_center(i, i + 1) # Even length palindrome return s[start:end]"},{"question":"from typing import List def canRearrange(S: str) -> bool: Checks if it's possible to rearrange the characters in S such that no two adjacent characters are the same. >>> canRearrange(\\"aab\\") True >>> canRearrange(\\"aaab\\") False >>> canRearrange(\\"abcdef\\") True","solution":"from collections import Counter def canRearrange(S): Checks if it's possible to rearrange the characters in S such that no two adjacent characters are the same. # Count the frequency of each character char_count = Counter(S) # Find the maximum frequency max_freq = max(char_count.values()) # If the frequency of the most common character is more than half of the string length (rounded up), # then it's not possible to rearrange the string such that no two adjacent characters are the same. if max_freq > (len(S) + 1) // 2: return False return True"},{"question":"from typing import List, Tuple def process_transactions(operations: List[Tuple[str, str, int]]) -> Tuple[int, int]: Process a list of bank transactions and return the final and maximum balance. Each transaction is represented as a tuple containing a timestamp, a transaction ID, and a transaction amount. Transactions can either be deposits (positive amount) or withdrawals (negative amount). The balance cannot drop below zero. Args: operations (List[Tuple[str, str, int]]): List of transactions to process. Returns: Tuple[int, int]: Final balance and maximum balance during the transaction sequence. Examples: >>> process_transactions([ ... (\\"2023-01-01T10:00:00\\", \\"txn001\\", 1000), ... (\\"2023-01-01T11:00:00\\", \\"txn002\\", -500), ... (\\"2023-01-01T12:00:00\\", \\"txn003\\", -300), ... (\\"2023-01-01T13:00:00\\", \\"txn004\\", 700) ... ]) (900, 1000) >>> process_transactions([ ... (\\"2023-01-01T10:00:00\\", \\"txn001\\", 500), ... (\\"2023-01-01T11:00:00\\", \\"txn002\\", -100), ... (\\"2023-01-01T12:00:00\\", \\"txn003\\", -400), ... (\\"2023-01-01T13:00:00\\", \\"txn004\\", 200) ... ]) (200, 500) def test_process_transactions_example_1(): operations = [ (\\"2023-01-01T10:00:00\\", \\"txn001\\", 1000), (\\"2023-01-01T11:00:00\\", \\"txn002\\", -500), (\\"2023-01-01T12:00:00\\", \\"txn003\\", -300), (\\"2023-01-01T13:00:00\\", \\"txn004\\", 700) ] assert process_transactions(operations) == (900, 1000) def test_process_transactions_example_2(): operations = [ (\\"2023-01-01T10:00:00\\", \\"txn001\\", 500), (\\"2023-01-01T11:00:00\\", \\"txn002\\", -100), (\\"2023-01-01T12:00:00\\", \\"txn003\\", -400), (\\"2023-01-01T13:00:00\\", \\"txn004\\", 200) ] assert process_transactions(operations) == (200, 500) def test_no_transactions(): assert process_transactions([]) == (0, 0) def test_only_deposits(): operations = [ (\\"2023-01-01T10:00:00\\", \\"txn001\\", 1000), (\\"2023-01-01T11:00:00\\", \\"txn002\\", 2000) ] assert process_transactions(operations) == (3000, 3000) def test_withdrawals_exceed_deposits(): operations = [ (\\"2023-01-01T10:00:00\\", \\"txn001\\", 1000), (\\"2023-01-01T11:00:00\\", \\"txn002\\", -1500) ] assert process_transactions(operations) == (0, 1000) def test_multiple_fluctuations(): operations = [ (\\"2023-01-01T10:00:00\\", \\"txn001\\", 1000), (\\"2023-01-01T11:00:00\\", \\"txn002\\", -500), (\\"2023-01-01T12:00:00\\", \\"txn003\\", 250), (\\"2023-01-01T13:00:00\\", \\"txn004\\", -300), (\\"2023-01-01T14:00:00\\", \\"txn005\\", 1000) ] assert process_transactions(operations) == (1450, 1450)","solution":"from typing import List, Tuple def process_transactions(operations: List[Tuple[str, str, int]]) -> Tuple[int, int]: final_balance = 0 max_balance = 0 for operation in operations: timestamp, txn_id, amount = operation if amount < 0: # Withdrawal case final_balance += amount if final_balance < 0: final_balance = 0 else: # Deposit case final_balance += amount if final_balance > max_balance: max_balance = final_balance return final_balance, max_balance"},{"question":"def longest_balanced_sublist_length(n: int, lst: List[int]) -> int: Mary wants to know the length of the longest balanced sublist she can get by erasing some (possibly zero) elements from her initial list. >>> longest_balanced_sublist_length(5, [1, 2, 3, 4, 5]) == 4 >>> longest_balanced_sublist_length(6, [2, 4, 6, 1, 3, 5]) == 6 >>> longest_balanced_sublist_length(2, [2, 1]) == 2 >>> longest_balanced_sublist_length(4, [2, 2, 2, 2]) == 0 >>> longest_balanced_sublist_length(6, [1, 2, 3, 4, 5, 6]) == 6 >>> longest_balanced_sublist_length(10, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == 10 pass","solution":"def longest_balanced_sublist_length(n, lst): # Initialize a prefix sum with 0 having an equal count of even and odd numbers prefix_sum = {0: -1} max_length = 0 count_even = 0 count_odd = 0 for i in range(n): if lst[i] % 2 == 0: count_even += 1 else: count_odd += 1 balance = count_even - count_odd if balance in prefix_sum: max_length = max(max_length, i - prefix_sum[balance]) else: prefix_sum[balance] = i return max_length"},{"question":"from typing import List def max_laps(times: List[int], total_time: int) -> int: Returns the maximum number of laps that can be completed in the given time. >>> max_laps([5, 8, 12], 60) 14 >>> max_laps([10], 100) 10 >>> max_laps([2, 3, 5], 30) 31 >>> max_laps([4, 6, 8], 24) 13 >>> max_laps([5, 10, 15], 0) 0 >>> max_laps([10, 20, 30], 5) 0 >>> max_laps([5], 4) 0","solution":"def max_laps(times, total_time): Returns the maximum number of laps that can be completed in the given time. Parameters: times (list): A list of integers representing the time each car takes to complete one lap. total_time (int): The total available racing time. Returns: int: Total number of laps completed. total_laps = 0 for time in times: total_laps += total_time // time return total_laps"},{"question":"def merge_intervals(intervals): Merges all overlapping intervals and returns the merged intervals in sorted order of their start times. >>> merge_intervals([[1, 3], [2, 6], [8, 10], [15, 18]]) [[1, 6], [8, 10], [15, 18]] >>> merge_intervals([[1, 2], [3, 4], [5, 6]]) [[1, 2], [3, 4], [5, 6]] >>> merge_intervals([[1, 4], [2, 3], [3, 5]]) [[1, 5]] >>> merge_intervals([[1, 2]]) [[1, 2]] >>> merge_intervals([]) [] >>> merge_intervals([[1, 2], [2, 3], [3, 4]]) [[1, 4]] >>> merge_intervals([[6, 8], [1, 9], [2, 4], [4, 7]]) [[1, 9]]","solution":"def merge_intervals(intervals): Merges all overlapping intervals and returns the merged intervals in sorted order of their start times. if not intervals: return [] # First, sort the intervals by the start time (and by end time if start times are the same). intervals.sort(key=lambda x: (x[0], x[1])) merged = [] current_start, current_end = intervals[0] for start, end in intervals[1:]: if start <= current_end: # Overlapping intervals, merge them current_end = max(current_end, end) else: # No overlap, add the previous interval to the list merged.append([current_start, current_end]) current_start, current_end = start, end # Add the last interval merged.append([current_start, current_end]) return merged"},{"question":"def count_divisible_pairs(n: int, k: int, books: List[int]) -> int: Counts the number of pairs of books such that the sum of their identification numbers is divisible by k. Parameters: n (int): The number of books in the library. k (int): The divisor. books (list of int): The identification numbers of the books. Returns: int: The number of pairs (i, j) such that i < j and (books[i] + books[j]) is divisible by k. Example: >>> count_divisible_pairs(5, 3, [1, 3, 2, 6, 9]) 4 >>> count_divisible_pairs(4, 2, [2, 4, 6, 8]) 6 >>> count_divisible_pairs(3, 5, [5, 10, 15]) 3 >>> count_divisible_pairs(6, 4, [1, 2, 3, 4, 5, 6]) 3 >>> count_divisible_pairs(5, 3, [3, 6, 9, 12, 15]) 10 >>> count_divisible_pairs(1, 1, [1]) 0 >>> count_divisible_pairs(2, 3, [3, 3]) 1","solution":"def count_divisible_pairs(n, k, books): Counts the number of pairs of books such that the sum of their identification numbers is divisible by k. Parameters: n (int): The number of books in the library. k (int): The divisor. books (list of int): The identification numbers of the books. Returns: int: The number of pairs (i, j) such that i < j and (books[i] + books[j]) is divisible by k. remainder_count = [0] * k for book in books: remainder_count[book % k] += 1 pair_count = 0 # Count pairs when remainder is 0 pair_count += (remainder_count[0] * (remainder_count[0] - 1)) // 2 # Count pairs for remaining remainders for i in range(1, (k // 2) + 1): if i != k - i: pair_count += remainder_count[i] * remainder_count[k - i] else: pair_count += (remainder_count[i] * (remainder_count[i] - 1)) // 2 return pair_count"},{"question":"class Library: def __init__(self): pass def add(self, title): Adds a book with the given title to the library collection. pass def borrow(self, title): Marks the given book as borrowed. If the book is not in the library or is already borrowed, output \`Book not available\`. pass def return_book(self, title): Marks the given book as returned. pass def list_books(self): Lists all book titles, each on a new line, which are currently available in the library, in alphabetical order. If there are no available books, output \`No books available\`. pass def process_operations(operations): Process a series of operations to add, borrow, return, and list books in the library. pass # Unit Test def test_add_and_list_books(capsys): library = Library() library.add(\\"The Great Gatsby\\") library.add(\\"To Kill a Mockingbird\\") library.list_books() captured = capsys.readouterr() assert captured.out == \\"The Great GatsbynTo Kill a Mockingbirdn\\" def test_borrow_and_list_books(capsys): library = Library() library.add(\\"The Great Gatsby\\") library.add(\\"To Kill a Mockingbird\\") library.borrow(\\"The Great Gatsby\\") library.list_books() captured = capsys.readouterr() assert captured.out == \\"To Kill a Mockingbirdn\\" def test_return_and_list_books(capsys): library = Library() library.add(\\"The Great Gatsby\\") library.borrow(\\"The Great Gatsby\\") library.return_book(\\"The Great Gatsby\\") library.list_books() captured = capsys.readouterr() assert captured.out == \\"The Great Gatsbyn\\" def test_borrow_unavailable_book(capsys): library = Library() library.borrow(\\"Moby Dick\\") captured = capsys.readouterr() assert captured.out == \\"Book not availablen\\" library.add(\\"Moby Dick\\") library.borrow(\\"Moby Dick\\") library.borrow(\\"Moby Dick\\") captured = capsys.readouterr() assert captured.out == \\"Book not availablen\\" def test_list_no_books(capsys): library = Library() library.list_books() captured = capsys.readouterr() assert captured.out == \\"No books availablen\\" def test_process_operations(capsys): operations = [ \\"ADD The Great Gatsby\\", \\"ADD To Kill a Mockingbird\\", \\"BORROW The Great Gatsby\\", \\"LIST\\", \\"RETURN The Great Gatsby\\", \\"LIST\\", \\"BORROW Moby Dick\\" ] process_operations(operations) captured = capsys.readouterr() assert captured.out == (\\"To Kill a Mockingbirdn\\" \\"The Great Gatsbyn\\" \\"To Kill a Mockingbirdn\\" \\"Book not availablen\\")","solution":"class Library: def __init__(self): self.books = {} self.available_books = set() def add(self, title): if title not in self.books: self.books[title] = False # False means the book is available self.available_books.add(title) def borrow(self, title): if title in self.books and not self.books[title]: self.books[title] = True # True means the book is borrowed self.available_books.remove(title) else: print(\\"Book not available\\") def return_book(self, title): if title in self.books and self.books[title]: self.books[title] = False self.available_books.add(title) def list_books(self): if self.available_books: for book in sorted(self.available_books): print(book) else: print(\\"No books available\\") def process_operations(operations): library = Library() for operation in operations: command_parts = operation.split(maxsplit=1) command = command_parts[0] if command == \\"ADD\\": title = command_parts[1] library.add(title) elif command == \\"BORROW\\": title = command_parts[1] library.borrow(title) elif command == \\"RETURN\\": title = command_parts[1] library.return_book(title) elif command == \\"LIST\\": library.list_books()"},{"question":"from typing import List def max_uniform_capacity(n: int, capacities: List[int]) -> int: Determines the maximum possible equal capacity value among all conveyor belts. Args: n: int - the number of conveyor belts capacities: List[int] - the processing capacities of the conveyor belts Returns: int - the maximum uniform capacity value >>> max_uniform_capacity(5, [10, 20, 30, 10, 40]) 10 >>> max_uniform_capacity(3, [15, 10, 20]) 10 >>> max_uniform_capacity(4, [8, 8, 8, 8]) 8 >>> max_uniform_capacity(6, [50, 30, 20, 40, 60, 10]) 10","solution":"def max_uniform_capacity(n, capacities): Determines the maximum possible equal capacity value among all conveyor belts. Args: n: int - the number of conveyor belts capacities: List[int] - the processing capacities of the conveyor belts Returns: int - the maximum uniform capacity value return min(capacities)"},{"question":"def find_longest_path(grid): Given a 2D array \`grid\` of integers, find the length of the longest valid path where every move can only be made according to the following rules: 1. Move up, down, left, or right. 2. Only step on an adjacent cell with a strictly greater value than the current cell's value. Parameters: grid (List[List[int]]): 2D array of integers. Returns: int: Length of the longest valid path. pass def solve(t, test_cases): Solve the problem for multiple test cases. Parameters: t (int): Number of test cases. test_cases (List[List[List[int]]]): List of test case grids. Returns: List[int]: List of results for each test case. pass # Example usage and test cases: from solution import solve def test_example_cases(): t = 3 test_cases = [ [[1, 2, 3], [6, 5, 4], [7, 8, 9]], [[1, 2, 3, 4], [8, 7, 6, 5], [9, 10, 11, 12], [16, 15, 14, 13]], [[2, 2], [2, 2]] ] expected_results = [9, 16, 1] assert solve(t, test_cases) == expected_results def test_single_element_case(): t = 1 test_cases = [[[1]]] expected_result = [1] assert solve(t, test_cases) == expected_result def test_increasing_single_row(): t = 1 test_cases = [[[1, 2, 3, 4, 5]]] expected_result = [5] assert solve(t, test_cases) == expected_result def test_increasing_single_column(): t = 1 test_cases = [[[1], [2], [3], [4], [5]]] expected_result = [5] assert solve(t, test_cases) == expected_result def test_all_same_elements(): t = 1 test_cases = [[[1, 1], [1, 1]]] expected_result = [1] assert solve(t, test_cases) == expected_result","solution":"def find_longest_path(grid): if not grid or not grid[0]: return 0 n, m = len(grid), len(grid[0]) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] memo = [[-1 for _ in range(m)] for _ in range(n)] def dfs(x, y): if memo[x][y] != -1: return memo[x][y] longest = 1 for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and grid[nx][ny] > grid[x][y]: longest = max(longest, 1 + dfs(nx, ny)) memo[x][y] = longest return longest max_path_length = 1 for i in range(n): for j in range(m): max_path_length = max(max_path_length, dfs(i, j)) return max_path_length def solve(t, test_cases): results = [] for grid in test_cases: results.append(find_longest_path(grid)) return results"},{"question":"def min_moves_to_clean(n, m, grid): This function calculates the minimum number of moves required for the robot to reach and clean every dirty cell on the grid. Args: n (int): the number of rows in the grid. m (int): the number of columns in the grid. grid (List[List[int]]): the grid representation with 0 indicating clean cells and 1 indicating dirty cells. Returns: int: the minimum number of moves required for the robot to reach and clean every dirty cell. Examples: >>> min_moves_to_clean(3, 3, [[1, 0, 0], [0, 1, 0], [0, 0, 1]]) 4 >>> min_moves_to_clean(2, 2, [[1, 1], [1, 1]]) 3 >>> min_moves_to_clean(4, 4, [[0, 0, 0, 0], [0, 1, 0, 0], [0, 0, 0, 0], [0, 1, 0, 1]]) 6 >>> min_moves_to_clean(3, 3, [[0, 0, 0], [0, 0, 0], [0, 0, 0]]) 0","solution":"def min_moves_to_clean(n, m, grid): This function calculates the minimum number of moves required for the robot to reach and clean every dirty cell on the grid. from itertools import permutations # Find all dirty cells and store their positions dirty_cells = [(i, j) for i in range(n) for j in range(m) if grid[i][j] == 1] # If there are no dirty cells, no moves are needed if not dirty_cells: return 0 # Calculate the manhattan distance between two points def manhattan_distance(point1, point2): return abs(point1[0] - point2[0]) + abs(point1[1] - point2[1]) # The robot starts at the top-left corner start = (0, 0) # Calculate the minimum moves required to clean all dirty cells min_moves = float('inf') for perm in permutations(dirty_cells): current_position = start moves = 0 for cell in perm: moves += manhattan_distance(current_position, cell) current_position = cell min_moves = min(min_moves, moves) return min_moves"},{"question":"def subset_sum(n: int, k: int, arr: List[int]) -> str: Determines if there is a subset of the given array that sums up to k. Args: n (int): number of integers in the array k (int): target sum arr (list of int): list of integers Returns: str: 'YES' if there exists a subset whose sum equals k, otherwise 'NO' >>> subset_sum(5, 9, [3, 34, 4, 12, 5, 2]) \\"YES\\" >>> subset_sum(3, 10, [1, 2, 3]) \\"NO\\" >>> subset_sum(4, 15, [5, 10, 3, 7]) \\"YES\\" >>> subset_sum(1, 10, [10]) \\"YES\\" >>> subset_sum(1, 10, [5]) \\"NO\\"","solution":"def subset_sum(n, k, arr): Determines if there is a subset of the given array that sums up to k. Args: n (int): number of integers in the array k (int): target sum arr (list of int): list of integers Returns: str: 'YES' if there exists a subset whose sum equals k, otherwise 'NO' dp = [False] * (k + 1) dp[0] = True for num in arr: for j in range(k, num - 1, -1): if dp[j - num]: dp[j] = True return 'YES' if dp[k] else 'NO'"},{"question":"def max_tower_height(n: int, blocks: List[int]) -> int: Determines the maximum height of the tower that can be built by placing blocks in the specified order such that each block's height is exactly one unit greater than the previous block. Parameters: n (int): number of blocks blocks (List[int]): heights of the blocks in the order they appear Returns: int: the maximum height of the tower Examples: >>> max_tower_height(6, [1, 2, 3, 2, 4, 5]) 5 >>> max_tower_height(4, [1, 1, 2, 3]) 3","solution":"def max_tower_height(n, blocks): Determines the maximum height of the tower that can be built by placing blocks in the specified order such that each block's height is exactly one unit greater than the previous block. Parameters: n (int): number of blocks blocks (List[int]): heights of the blocks in the order they appear Returns: int: the maximum height of the tower if n == 0: return 0 # Initialize the tower with the first block tower_height = 1 current_height = blocks[0] # Iterate through the blocks starting from the second one for i in range(1, n): if blocks[i] == current_height + 1: tower_height += 1 current_height = blocks[i] return tower_height"},{"question":"from typing import List, Tuple from collections import defaultdict, deque def find_max_distance_castles(n: int, roads: List[Tuple[int, int, int]]) -> List[int]: Determine which two castles should be chosen such that the distance between them is maximized. The distance between two castles is defined as the sum of the lengths of roads on the path connecting them. Args: n (int): The number of castles. roads (List[Tuple[int, int, int]]): The descriptions of roads in the kingdom. Returns: List[int]: Two integers representing the numbers of the castles to host the events. >>> find_max_distance_castles(4, [(1, 2, 3), (2, 3, 5), (3, 4, 2)]) [1, 4] >>> find_max_distance_castles(5, [(1, 2, 1), (1, 3, 1), (1, 4, 1), (1, 5, 1)]) [2, 3] # You may use the following helper function for BFS def find_farthest_node(start_node, n, graph): Performs BFS to find the farthest node from the given start_node distances = [-1] * (n + 1) distances[start_node] = 0 queue = deque([start_node]) farthest_node = start_node while queue: current = queue.popleft() for neighbor, length in graph[current]: if distances[neighbor] == -1: # Not visited distances[neighbor] = distances[current] + length queue.append(neighbor) if distances[neighbor] > distances[farthest_node]: farthest_node = neighbor return farthest_node, distances[farthest_node]","solution":"from collections import defaultdict, deque def find_farthest_node(start_node, n, graph): Performs BFS to find the farthest node from the given start_node distances = [-1] * (n + 1) distances[start_node] = 0 queue = deque([start_node]) farthest_node = start_node while queue: current = queue.popleft() for neighbor, length in graph[current]: if distances[neighbor] == -1: # Not visited distances[neighbor] = distances[current] + length queue.append(neighbor) if distances[neighbor] > distances[farthest_node]: farthest_node = neighbor return farthest_node, distances[farthest_node] def find_max_distance_castles(n, roads): graph = defaultdict(list) for a, b, c in roads: graph[a].append((b, c)) graph[b].append((a, c)) # First BFS to find the farthest node from node 1 (arbitrary start) farthest_node, _ = find_farthest_node(1, n, graph) # Second BFS from the farthest node found to determine the maximum distance other_farthest_node, _ = find_farthest_node(farthest_node, n, graph) return sorted([farthest_node, other_farthest_node]) # Example usage: # n = 4 # roads = [(1, 2, 3), (2, 3, 5), (3, 4, 2)] # print(find_max_distance_castles(n, roads)) # Output: [1, 4]"},{"question":"def max_cakes(n, k, quantities, recipes): Determines the maximum number of cakes Lily can make with the given ingredients and recipe. Parameters: n (int): Number of ingredients. k (int): Type of cake (1-indexed). quantities (list of int): Quantities of each ingredient. recipes (list of list of int): Recipes for each type of cake. Returns: int: Maximum number of cakes that can be made. pass # Example test cases: def test_example1(): n = 3 k = 2 quantities = [10, 5, 8] recipes = [ [2, 1, 3], [1, 1, 1] ] assert max_cakes(n, k, quantities, recipes) == 5 def test_example2(): n = 4 k = 3 quantities = [12, 15, 20, 25] recipes = [ [3, 5, 2, 1], [4, 5, 2, 3], [2, 4, 4, 2] ] assert max_cakes(n, k, quantities, recipes) == 3 def test_example3(): n = 3 k = 1 quantities = [10, 10, 10] recipes = [ [5, 5, 5] ] assert max_cakes(n, k, quantities, recipes) == 2 def test_insufficient_ingredients(): n = 3 k = 1 quantities = [5, 5, 5] recipes = [ [6, 6, 6] ] assert max_cakes(n, k, quantities, recipes) == 0 def test_zero_requirement(): n = 3 k = 1 quantities = [10, 10, 10] recipes = [ [0, 0, 0] ] assert max_cakes(n, k, quantities, recipes) == float('inf') def test_multiple_recipes_first_has_fewest_units(): n = 4 k = 2 quantities = [15, 14, 25, 30] recipes = [ [7, 8, 25, 10], [1, 1, 1, 1] ] assert max_cakes(n, k, quantities, recipes) == 14","solution":"def max_cakes(n, k, quantities, recipes): Determines the maximum number of cakes Lily can make with the given ingredients and recipe. Parameters: n (int): Number of ingredients. k (int): Type of cake (1-indexed). quantities (list of int): Quantities of each ingredient. recipes (list of list of int): Recipes for each type of cake. Returns: int: Maximum number of cakes that can be made. # Extract the required recipe based on the given type of cake (1-indexed, adjust to 0-indexed) required_recipe = recipes[k-1] # Calculate the maximum number of cakes that can be made max_cakes_possible = float('inf') for i in range(n): if required_recipe[i] > 0: max_cakes_possible = min(max_cakes_possible, quantities[i] // required_recipe[i]) return max_cakes_possible"},{"question":"def rank_participants(m: int, participants: List[Tuple[str, int]]) -> List[str]: Rank participants based on the number of problems solved in non-increasing order. If two or more participants have solved the same number of problems, maintain the input order. >>> rank_participants(5, [(\\"Alice\\", 5), (\\"Bob\\", 3), (\\"Charlie\\", 8), (\\"David\\", 8), (\\"Eve\\", 5)]) [\\"Charlie\\", \\"David\\", \\"Alice\\", \\"Eve\\", \\"Bob\\"] >>> rank_participants(3, [(\\"Zara\\", 4), (\\"Mia\\", 4), (\\"Leo\\", 6)]) [\\"Leo\\", \\"Zara\\", \\"Mia\\"]","solution":"def rank_participants(m, participants): Returns a list of participant names sorted by the number of problems solved in non-increasing order. If two or more participants have solved the same number of problems, they should be listed in the order they appeared in the input. # Sort participants first by problems solved in descending order, maintaining the order in which they appear in case of a tie ranked = sorted(participants, key=lambda x: (-x[1], participants.index(x))) # Extract and return only the names return [name for name, _ in ranked]"},{"question":"def classify_books(test_cases: List[List[Tuple[str, int]]]) -> str: Classify books by genre and page count. Each genre should have a count of page groups, followed by the page counts and the number of books in each page group. >>> classify_books([ ... [(\\"fiction\\", 300), (\\"fiction\\", 200), (\\"history\\", 400), (\\"fiction\\", 200), (\\"history\\", 500)] ... ]) 'fictionn2n200 2n300 1nhistoryn2n400 1n500 1' >>> classify_books([ ... [(\\"romance\\", 250), (\\"romance\\", 250), (\\"sci-fi\\", 300), (\\"sci-fi\\", 400)] ... ]) 'romancen1n250 2nsci-fin2n300 1n400 1'","solution":"def classify_books(test_cases): results = [] for books in test_cases: genre_dict = {} for genre, pages in books: if genre not in genre_dict: genre_dict[genre] = {} if pages not in genre_dict[genre]: genre_dict[genre][pages] = 0 genre_dict[genre][pages] += 1 for genre in genre_dict: results.append(genre) page_groups = genre_dict[genre] results.append(str(len(page_groups))) for pages in page_groups: results.append(f\\"{pages} {page_groups[pages]}\\") return \\"n\\".join(results)"},{"question":"def min_distance(start: str, target: str) -> int: Returns the minimum number of operations required to transform the start word into the target word. >>> min_distance(\\"horse\\", \\"ros\\") 3 >>> min_distance(\\"intention\\", \\"execution\\") 5 >>> min_distance(\\"kitten\\", \\"sitting\\") 3 >>> min_distance(\\"a\\", \\"b\\") 1 >>> min_distance(\\"\\", \\"abc\\") 3 >>> min_distance(\\"abc\\", \\"\\") 3 >>> min_distance(\\"abc\\", \\"abc\\") 0 from solution import min_distance def test_min_distance_case_1(): assert min_distance(\\"horse\\", \\"ros\\") == 3 def test_min_distance_case_2(): assert min_distance(\\"intention\\", \\"execution\\") == 5 def test_min_distance_case_3(): assert min_distance(\\"kitten\\", \\"sitting\\") == 3 def test_min_distance_case_4(): assert min_distance(\\"a\\", \\"b\\") == 1 def test_min_distance_case_5(): assert min_distance(\\"\\", \\"abc\\") == 3 def test_min_distance_case_6(): assert min_distance(\\"abc\\", \\"\\") == 3 def test_min_distance_case_7(): assert min_distance(\\"abc\\", \\"abc\\") == 0","solution":"def min_distance(start, target): Returns the minimum number of operations required to transform the start word into the target word. m, n = len(start), len(target) dp = [[0] * (n + 1) for _ in range(m + 1)] for i in range(1, m + 1): dp[i][0] = i for j in range(1, n + 1): dp[0][j] = j for i in range(1, m + 1): for j in range(1, n + 1): if start[i - 1] == target[j - 1]: dp[i][j] = dp[i - 1][j - 1] else: dp[i][j] = 1 + min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) return dp[m][n]"},{"question":"MOD = 1000000007 def distinct_patterns_count(N, M): Calculate the number of distinct patterns on an N x M grid. Each cell can either be filled or empty. >>> distinct_patterns_count(2, 2) 16 >>> distinct_patterns_count(3, 3) 512 pass # Implement your solution here def count_patterns_for_test_cases(test_cases): Given a list of test cases, calculate the number of distinct patterns for each case. >>> count_patterns_for_test_cases([(2, 2), (3, 3), (4, 4)]) [16, 512, 65536] >>> count_patterns_for_test_cases([(1, 1), (2, 3)]) [2, 64] pass # Implement your solution here","solution":"MOD = 1000000007 def distinct_patterns_count(N, M): Calculate the number of distinct patterns on an N x M grid. Each cell can either be filled or empty. num_cells = N * M return pow(2, num_cells, MOD) def count_patterns_for_test_cases(test_cases): Given a list of test cases, calculate the number of distinct patterns for each case. results = [] for N, M in test_cases: result = distinct_patterns_count(N, M) results.append(result) return results"},{"question":"def can_segment_string(s: str, substrings: List[str]) -> str: Determine if the string s can be segmented into a space-separated sequence of one or more substrings from the list. >>> can_segment_string(\\"leetcode\\", [\\"leet\\", \\"code\\", \\"lee\\", \\"tcode\\"]) == \\"Yes\\" >>> can_segment_string(\\"applepenapple\\", [\\"apple\\", \\"pen\\"]) == \\"Yes\\" >>> can_segment_string(\\"catsandog\\", [\\"cats\\", \\"dog\\", \\"sand\\", \\"and\\", \\"cat\\"]) == \\"No\\" def solve(input_str: str) -> str: Process the input string and determine if the main string can be segmented. >>> solve(\\"leetcoden4nleetncodenleentcode\\") == \\"Yes\\" >>> solve(\\"applepenapplen2napplenpen\\") == \\"Yes\\" >>> solve(\\"catsandogn5ncatsndognsandnandncat\\") == \\"No\\"","solution":"def can_segment_string(s, substrings): Determines if the string s can be segmented into a space-separated sequence of one or more substrings. n = len(s) dp = [False] * (n + 1) dp[0] = True for i in range(1, n + 1): for substring in substrings: if dp[i - len(substring)] and s[i - len(substring):i] == substring: dp[i] = True break return \\"Yes\\" if dp[n] else \\"No\\" def solve(input_str): lines = input_str.strip().split(\\"n\\") s = lines[0] n = int(lines[1]) substrings = [lines[i + 2] for i in range(n)] return can_segment_string(s, substrings)"},{"question":"def is_arithmetic_sequence(n: int, sequence: List[int]) -> str: Determines if the given sequence of integers is an arithmetic sequence. Args: n (int): Number of elements in the sequence. sequence (list of int): The elements of the sequence. Returns: str: \\"YES\\" if the sequence is an arithmetic sequence, \\"NO\\" otherwise. Examples: >>> is_arithmetic_sequence(5, [2, 4, 6, 8, 10]) \\"YES\\" >>> is_arithmetic_sequence(4, [7, 2, 5, 8]) \\"NO\\"","solution":"def is_arithmetic_sequence(n, sequence): Determines if the given sequence of integers is an arithmetic sequence. Args: n (int): Number of elements in the sequence. sequence (list of int): The elements of the sequence. Returns: str: \\"YES\\" if the sequence is an arithmetic sequence, \\"NO\\" otherwise. if n <= 1: return \\"YES\\" common_difference = sequence[1] - sequence[0] for i in range(2, n): if sequence[i] - sequence[i - 1] != common_difference: return \\"NO\\" return \\"YES\\""},{"question":"def max_possible_sum(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Determine the maximum possible value of the single remaining element after exactly n-1 operations. Parameters: t (int): The number of test cases. test_cases (List[Tuple[int, List[int]]]): A list of t tuples, each containing an integer n and a list of n integers. Returns: List[int]: A list of t integers representing the maximum possible values for each test case. Example: >>> max_possible_sum(3, [(3, [1, 2, 3]), (4, [2, 2, 2, 2]), (5, [1, 1, 1, 1, 1])]) [6, 8, 5] >>> max_possible_sum(1, [(3, [1000, 1000, 1000])]) [3000]","solution":"def max_possible_sum(t, test_cases): results = [] for i in range(t): n = test_cases[i][0] a = test_cases[i][1] results.append(sum(a)) return results"},{"question":"def count_peaks(elevations: List[int]) -> int: Returns the number of distinct peaks in the given list of elevations. >>> count_peaks([1, 3, 5, 4, 2]) 1 >>> count_peaks([1, 2, 3, 4, 5, 3, 2, 1, 1, 2, 3, 1]) 2 >>> count_peaks([1, 2, 2, 1, 3, 4, 2, 1, 2]) 1 >>> count_peaks([1, 2, 3, 4, 5]) 0 >>> count_peaks([2, 2, 2, 2]) 0 >>> count_peaks([0, 1, 0, 1, 0, 1, 0]) 3 >>> count_peaks([5, 4, 3, 2, 1]) 0","solution":"def count_peaks(elevations): Returns the number of distinct peaks in the given list of elevations. n = len(elevations) if n < 3: return 0 peaks = 0 i = 1 while i < n - 1: # Check if this point is a peak if elevations[i-1] < elevations[i] > elevations[i+1]: peaks += 1 # Skipping through the descending part of the current peak while i < n - 1 and elevations[i] > elevations[i+1]: i += 1 i += 1 return peaks"},{"question":"def count_overlapping_occurrences(s: str, queries: List[str]) -> List[int]: Counts the number of times each query substring appears in the main string, considering overlapping occurrences. Parameters: s (str): The main string. queries (list): A list of query substrings. Returns: list: A list of integers representing the count of each query substring in the main string. >>> count_overlapping_occurrences(\\"ababab\\", [\\"ab\\", \\"aba\\", \\"bab\\"]) [3, 2, 2] >>> count_overlapping_occurrences(\\"abcdefg\\", [\\"abc\\", \\"def\\", \\"g\\"]) [1, 1, 1] >>> count_overlapping_occurrences(\\"abcdefg\\", [\\"xyz\\", \\"hij\\", \\"klm\\"]) [0, 0, 0] >>> count_overlapping_occurrences(\\"aaaaa\\", [\\"a\\", \\"aa\\", \\"aaa\\"]) [5, 4, 3] >>> count_overlapping_occurrences(\\"hello\\", [\\"hello\\", \\"hell\\", \\"ello\\"]) [1, 1, 1] >>> count_overlapping_occurrences(\\"hello\\", []) [] >>> count_overlapping_occurrences(\\"\\", [\\"a\\", \\"abc\\", \\"abcd\\"]) [0, 0, 0] result = [] for query in queries: count = 0 start = 0 while start <= len(s) - len(query): pos = s.find(query, start) if pos == -1: break count += 1 start = pos + 1 result.append(count) return result","solution":"def count_overlapping_occurrences(s, queries): Counts the number of times each query substring appears in the main string, considering overlapping occurrences. Parameters: s (str): The main string. queries (list): A list of query substrings. Returns: list: A list of integers representing the count of each query substring in the main string. result = [] for query in queries: count = 0 start = 0 while start <= len(s) - len(query): pos = s.find(query, start) if pos == -1: break count += 1 start = pos + 1 result.append(count) return result # Example usage: # s = \\"ababab\\" # queries = [\\"ab\\", \\"aba\\", \\"bab\\"] # print(count_overlapping_occurrences(s, queries)) # Output: [3, 2, 2]"},{"question":"def smallest_missing_positive_integer(N: int, A: List[int]) -> int: Given an integer N and an array A of N integers, this function computes the smallest positive integer that is not present in the array. >>> smallest_missing_positive_integer(5, [1, 2, 3, 4, 5]) 6 >>> smallest_missing_positive_integer(6, [2, 3, 4, 6, 7, 8]) 1 >>> smallest_missing_positive_integer(5, [1, 2, 4, 5, 6]) 3 >>> smallest_missing_positive_integer(3, [1, 2, 3]) 4 >>> smallest_missing_positive_integer(1, [1]) 2 >>> smallest_missing_positive_integer(1, [2]) 1 >>> smallest_missing_positive_integer(3, [2, 2, 2]) 1 >>> smallest_missing_positive_integer(100, list(range(1, 101))) 101","solution":"def smallest_missing_positive_integer(N, A): Returns the smallest positive integer not present in the array A of size N. A_set = set(A) smallest_missing = 1 while smallest_missing in A_set: smallest_missing += 1 return smallest_missing"},{"question":"def perform_operations(queries: List[str]) -> List[int]: Perform a series of operations on a string and return the results of count operations. Args: queries: List of strings representing the operations to be performed. Returns: A list with the results of all count operations. The operations are: * append(c): Append character c to the end of the string. * remove(c): Remove the first occurrence of character c from the string. If the character is not present, do nothing. * count(c): Count the number of occurrences of character c in the string and print this count. >>> perform_operations([\\"append a\\", \\"append b\\", \\"append a\\", \\"count a\\", \\"remove a\\", \\"count a\\", \\"count b\\", \\"remove c\\"]) [2, 1, 1] >>> perform_operations([\\"append a\\", \\"append b\\", \\"append c\\"]) [] >>> perform_operations([\\"append a\\", \\"append b\\", \\"append a\\", \\"remove a\\", \\"remove b\\", \\"remove x\\"]) [] >>> perform_operations([\\"append x\\", \\"append x\\", \\"count x\\", \\"count y\\", \\"remove x\\", \\"count x\\"]) [2, 0, 1] >>> perform_operations([\\"append m\\", \\"append n\\", \\"remove m\\", \\"append m\\", \\"count m\\", \\"count n\\"]) [1, 1]","solution":"def perform_operations(queries): string = [] results = [] for query in queries: action, char = query.split() if action == 'append': string.append(char) elif action == 'remove': if char in string: string.remove(char) elif action == 'count': results.append(string.count(char)) return results"},{"question":"from typing import List def longest_increasing_subsequence_length(prices: List[int]) -> int: Returns the length of the longest contiguous subsequence of increasing stock prices. >>> longest_increasing_subsequence_length([5, 1, 2, 3, 1, 5]) 3 >>> longest_increasing_subsequence_length([5, 4, 3, 2, 1]) 1 >>> longest_increasing_subsequence_length([10]) 1 >>> longest_increasing_subsequence_length([1, 2, 3, 4, 5]) 5 >>> longest_increasing_subsequence_length([3, 3, 3, 3, 3]) 1 >>> longest_increasing_subsequence_length([2, 2, 2, 3, 4, 2, 3, 4, 5, 1]) 4 >>> longest_increasing_subsequence_length([1, 2, 3, 3, 4]) 3 >>> longest_increasing_subsequence_length([]) 0","solution":"def longest_increasing_subsequence_length(prices): Returns the length of the longest contiguous subsequence of increasing stock prices. :param prices: List of integers representing the stock prices over a period of days :return: Length of the longest increasing subsequence if not prices: return 0 max_length = 1 current_length = 1 for i in range(1, len(prices)): if prices[i] > prices[i - 1]: current_length += 1 max_length = max(max_length, current_length) else: current_length = 1 return max_length"},{"question":"from typing import List, Tuple def find_max_books(n: int, m: int, books: List[int], edges: List[Tuple[int, int]]) -> int: Determine the maximum number of books a librarian can collect starting from any room. Parameters: n (int): Number of rooms m (int): Number of tunnels books (List[int]): List containing the number of books in each room edges (List[Tuple[int, int]]): List of tuples representing directed edges between rooms Returns: int: Maximum number of books that can be collected # Your implementation here # Unit tests def test_example_case(): n = 5 m = 4 books = [10, 20, 30, 40, 50] edges = [(1, 2), (2, 3), (3, 4), (4, 5)] assert find_max_books(n, m, books, edges) == 150 def test_single_room(): n = 1 m = 0 books = [100] edges = [] assert find_max_books(n, m, books, edges) == 100 def test_disconnected_graph(): n = 4 m = 2 books = [10, 20, 30, 40] edges = [(1, 2), (3, 4)] assert find_max_books(n, m, books, edges) == 70 # Start at node 1 and node 3 for max sum def test_multiple_sources(): n = 4 m = 3 books = [5, 10, 20, 30] edges = [(1, 2), (2, 3), (3, 4)] assert find_max_books(n, m, books, edges) == 65 def test_complex_case(): n = 6 m = 6 books = [5, 5, 15, 10, 25, 10] edges = [(1, 2), (2, 3), (3, 4), (3, 5), (5, 6), (4, 6)] assert find_max_books(n, m, books, edges) == 60","solution":"def find_max_books(n, m, books, edges): from collections import defaultdict, deque # Create adjacency list and incoming degree count adj_list = defaultdict(list) indegree = [0] * (n + 1) # Fill the adjacency list and incoming degree count for u, v in edges: adj_list[u].append(v) indegree[v] += 1 # Initialize DP array to store max books collectible up to each node dp = [0] * (n + 1) # Initialize DP values with the number of books in each room for i in range(1, n + 1): dp[i] = books[i - 1] # Queue for nodes with no incoming edges (starting points) queue = deque() for i in range(1, n + 1): if indegree[i] == 0: queue.append(i) while queue: node = queue.popleft() for neighbor in adj_list[node]: dp[neighbor] = max(dp[neighbor], dp[node] + books[neighbor - 1]) indegree[neighbor] -= 1 if indegree[neighbor] == 0: queue.append(neighbor) return max(dp) # Example usage: # n = 5 # m = 4 # books = [10, 20, 30, 40, 50] # edges = [(1, 2), (2, 3), (3, 4), (4, 5)] # print(find_max_books(n, m, books, edges)) # Output: 150"},{"question":"def is_robot_return_to_origin(s: str) -> bool: Determine if the robot returns to the origin after executing the given sequence of instructions. Parameters: s (str): A string consisting of instructions ('G', 'L', 'R') Returns: bool: True if the robot returns to the origin, otherwise False >>> is_robot_return_to_origin(\\"G\\") False >>> is_robot_return_to_origin(\\"GL\\") False >>> is_robot_return_to_origin(\\"GRGRGRG\\") True","solution":"def is_robot_return_to_origin(s): Determine if the robot returns to the origin after executing the given sequence of instructions. Parameters: s (str): A string consisting of instructions ('G', 'L', 'R') Returns: bool: True if the robot returns to the origin, otherwise False # Starting position x, y = 0, 0 # Directions: 0 => North, 1 => East, 2 => South, 3 => West directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] current_direction = 0 # Initially facing north for command in s: if command == 'G': x += directions[current_direction][0] y += directions[current_direction][1] elif command == 'L': current_direction = (current_direction - 1) % 4 elif command == 'R': current_direction = (current_direction + 1) % 4 return (x == 0 and y == 0)"},{"question":"def calculate_optimal_lending_period(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[str]: Determine the optimal lending period to minimize the total fine for each test case. >>> calculate_optimal_lending_period(1, [(3, [7, 10, 5, 20, 10, 15])]) [\\"Case #1: 5\\"] >>> calculate_optimal_lending_period(2, [(3, [7, 10, 5, 20, 10, 15]), (2, [5, 50, 7, 30])]) [\\"Case #1: 5\\", \\"Case #2: 5\\"]","solution":"def calculate_optimal_lending_period(T, test_cases): results = [] for case_num in range(T): N = test_cases[case_num][0] books = test_cases[case_num][1] # Separate the lending periods and fines lending_periods = books[::2] fines = books[1::2] # Compute the optimal lending period optimal_lending_period = min(lending_periods) results.append(f\\"Case #{case_num + 1}: {optimal_lending_period}\\") return results"},{"question":"def longest_consistent_growth_sequence(H: List[int]) -> int: Returns the length of the longest consistent growth sequence in the array H. >>> longest_consistent_growth_sequence([5]) == 1 >>> longest_consistent_growth_sequence([7, 7, 7, 7]) == 4 >>> longest_consistent_growth_sequence([1, 3, 5, 7]) == 4 >>> longest_consistent_growth_sequence([10, 8, 6, 4, 2]) == 5 >>> longest_consistent_growth_sequence([3, 8, 5, 10, 15, 7]) == 3 >>> longest_consistent_growth_sequence([4, 7, 10, 13]) == 4 >>> longest_consistent_growth_sequence([1, 2, 4, 8, 16]) == 2 >>> longest_consistent_growth_sequence([1, 3, 5, 7, 10, 12, 14]) == 4","solution":"def longest_consistent_growth_sequence(H): Returns the length of the longest consistent growth sequence in the array H. n = len(H) if n <= 1: return n max_length = 1 current_length = 1 current_diff = None for i in range(1, n): diff = H[i] - H[i - 1] if diff == current_diff: current_length += 1 else: current_diff = diff current_length = 2 max_length = max(max_length, current_length) return max_length"},{"question":"def break_palindrome(s: str) -> str: Given a string, generate a new string by breaking any palindromic structure within the original string. The new string should be the lexicographically smallest string possible. If the string has only one character, return an empty string as it's impossible to break its palindrome structure. >>> break_palindrome(\\"a\\") '' >>> break_palindrome(\\"abccba\\") 'aaccba' >>> break_palindrome(\\"aa\\") 'ab' >>> break_palindrome(\\"aba\\") 'abb' >>> break_palindrome(\\"aaa\\") 'aab' >>> break_palindrome(\\"abcdefgfedcba\\") 'aacdefgfedcba' >>> break_palindrome(\\"racecar\\") 'aacecar' >>> break_palindrome(\\"aaaa\\") 'aaab'","solution":"def break_palindrome(s): Return the lexicographically smallest string possible after breaking the palindrome. If it's impossible to break the palindrome, return an empty string. if len(s) == 1: return \\"\\" s_list = list(s) for i in range(len(s) // 2): if s_list[i] != 'a': s_list[i] = 'a' return ''.join(s_list) s_list[-1] = 'b' return ''.join(s_list)"},{"question":"def string_weights(strings: List[str]) -> List[int]: Given a list of strings, return a list of their weights, where the weight of a string is the number of distinct characters in it. Parameters: strings (list): A list of strings. Returns: list: A list of integers representing the weights of the strings. >>> string_weights([\\"abcd\\", \\"aaa\\", \\"hello\\", \\"world\\"]) [4, 1, 4, 5] >>> string_weights([\\"aabbcc\\", \\"abcdef\\", \\"aabb\\", \\"bbaa\\"]) [3, 6, 2, 2]","solution":"def string_weights(strings): Given a list of strings, return a list of their weights, where the weight of a string is the number of distinct characters in it. Parameters: strings (list): A list of strings. Returns: list: A list of integers representing the weights of the strings. res = [] for s in strings: res.append(len(set(s))) return res"},{"question":"def can_transform_to_palindrome(s: str) -> str: Determines if it is possible to transform the given string into a palindrome using at most one operation (swap any two characters or remove exactly one character). Args: s (str): The input string consisting of characters 'a' to 'z'. Returns: str: \\"Yes\\" if it is possible to transform the string into a palindrome, otherwise \\"No\\". >>> can_transform_to_palindrome(\\"abca\\") \\"Yes\\" >>> can_transform_to_palindrome(\\"abcdef\\") \\"No\\"","solution":"def can_transform_to_palindrome(s): Checks if the string can be transformed into a palindrome with at most one swap or one character removal. n = len(s) left, right = 0, n - 1 mismatch_count = 0 # Counting the mismatches while left < right: if s[left] != s[right]: mismatch_count += 1 if mismatch_count > 1: break left += 1 right -= 1 # If there is no mismatch or exactly one mismatch, we can perform one operation if mismatch_count == 0 or mismatch_count == 1: return \\"Yes\\" # If more than one mismatch, we check if removing one character can help for i in range(n): temp = s[:i] + s[i+1:] # remove character at i if temp == temp[::-1]: return \\"Yes\\" return \\"No\\""},{"question":"from typing import List def shifted_array_search(a: List[int], x: int) -> int: Given a sorted array that has been rotated at an unknown pivot, this function finds the index of a given target value x. If x is not found, returns -1. >>> shifted_array_search([4, 5, 6, 7, 0, 1, 2], 0) 4 >>> shifted_array_search([4, 5, 6, 7, 0, 1, 2], 3) -1 >>> shifted_array_search([1], 1) 0 >>> shifted_array_search([1], 0) -1 pass","solution":"def shifted_array_search(a, x): Given a sorted array that has been rotated at an unknown pivot, this function finds the index of a given target value x. If x is not found, returns -1. left, right = 0, len(a) - 1 while left <= right: mid = (left + right) // 2 if a[mid] == x: return mid # Check which half is properly sorted if a[left] <= a[mid]: # Left half is sorted if a[left] <= x < a[mid]: right = mid - 1 else: left = mid + 1 else: # Right half is sorted if a[mid] < x <= a[right]: left = mid + 1 else: right = mid - 1 return -1"},{"question":"from collections import deque def bfs_level(n, edges, s): Performs a BFS on an unweighted, undirected graph and returns the level of each vertex from the source vertex. Args: n (int): Number of vertices. edges (List[Tuple[int, int]]): List of edges. s (int): Source vertex. Returns: List[int]: List where level[i] is the level of vertex i from the source vertex. Example: >>> bfs_level(6, [(0, 1), (0, 2), (1, 3), (2, 4), (3, 5)], 0) [0, 1, 1, 2, 2, 3] >>> bfs_level(4, [(0, 1), (2, 3)], 0) [0, 1, -1, -1] def test_bfs_level_simple(): n = 6 edges = [(0, 1), (0, 2), (1, 3), (2, 4), (3, 5)] s = 0 expected_levels = [0, 1, 1, 2, 2, 3] assert bfs_level(n, edges, s) == expected_levels def test_bfs_level_disconnected(): n = 4 edges = [(0, 1), (2, 3)] s = 0 expected_levels = [0, 1, -1, -1] assert bfs_level(n, edges, s) == expected_levels def test_bfs_level_all_nodes_connected(): n = 5 edges = [(0, 1), (1, 2), (2, 3), (3, 4)] s = 0 expected_levels = [0, 1, 2, 3, 4] assert bfs_level(n, edges, s) == expected_levels def test_bfs_level_single_node(): n = 1 edges = [] s = 0 expected_levels = [0] assert bfs_level(n, edges, s) == expected_levels def test_bfs_level_no_edges_multiple_nodes(): n = 3 edges = [] s = 0 expected_levels = [0, -1, -1] assert bfs_level(n, edges, s) == expected_levels","solution":"from collections import deque def bfs_level(n, edges, s): # Create the adjacency list adj = [[] for _ in range(n)] for u, v in edges: adj[u].append(v) adj[v].append(u) # Initialize level array with -1 level = [-1] * n queue = deque([s]) level[s] = 0 while queue: vertex = queue.popleft() for neighbor in adj[vertex]: if level[neighbor] == -1: # If the neighbor hasn't been visited queue.append(neighbor) level[neighbor] = level[vertex] + 1 return level"},{"question":"def has_pair_with_sum(nums: List[int], target: int) -> str: Returns \\"Yes\\" if there are two distinct numbers in the list that add up to the target, otherwise returns \\"No\\". >>> has_pair_with_sum([2, 7, 11, 15], 9) == \\"Yes\\" >>> has_pair_with_sum([1, 2, 3, 4, 5], 10) == \\"No\\" >>> has_pair_with_sum([1, 3, 3, 4, 6], 6) == \\"Yes\\" >>> has_pair_with_sum([10, 20, 30, 40, 50], 70) == \\"Yes\\" >>> has_pair_with_sum([-10, -20, 10, 30, 50], 20) == \\"Yes\\" >>> has_pair_with_sum([-10, -20, -30, -40, -50], -70) == \\"Yes\\"","solution":"def has_pair_with_sum(nums, target): Returns \\"Yes\\" if there are two distinct numbers in the list that add up to the target, otherwise returns \\"No\\". # Create a set to store the numbers we have seen so far seen = set() for num in nums: # Compute the number needed to form the target sum with the current number need = target - num if need in seen: return \\"Yes\\" seen.add(num) return \\"No\\""},{"question":"from typing import List from collections import Counter def can_reorder_without_adjacent_duplicates(s: str) -> str: Determine if it's possible to reorder the characters of the string \`s\` such that no two adjacent characters are the same. >>> can_reorder_without_adjacent_duplicates(\\"aabb\\") 'YES' >>> can_reorder_without_adjacent_duplicates(\\"aaab\\") 'NO'","solution":"from collections import Counter def can_reorder_without_adjacent_duplicates(s): Determine if it's possible to reorder the characters of the string \`s\` such that no two adjacent characters are the same. freq = Counter(s) max_freq = max(freq.values()) if max_freq > (len(s) + 1) // 2: return \\"NO\\" return \\"YES\\" # Example usage: # print(can_reorder_without_adjacent_duplicates(\\"aabb\\")) # Output: \\"YES\\" # print(can_reorder_without_adjacent_duplicates(\\"aaab\\")) # Output: \\"NO\\""},{"question":"def warehouse_operations(n: int, q: int, products: List[int], operations: List[Tuple[int, int, int]]) -> List[int]: Perform operations to add products to boxes and query the total number of products in a range of boxes. Parameters: n (int): The number of boxes. q (int): The number of operations. products (List[int]): The initial number of products in each box. operations (List[Tuple[int, int, int]]): The operations to be performed. Returns: List[int]: The results of the query operations. Example: >>> warehouse_operations(5, 4, [1, 2, 3, 4, 5], [(2, 1, 3), (1, 2, 2), (2, 2, 5), (2, 1, 5)]) [6, 16, 17]","solution":"def warehouse_operations(n, q, products, operations): result = [] for operation in operations: t, x, y = operation if t == 1: # Add y products to the x-th box (1-based index) products[x - 1] += y elif t == 2: # Query the total number of products in the range [x, y] (1-based index) result.append(sum(products[x - 1:y])) return result"},{"question":"def min_prep_time(N: int, Q: int, times: List[int], orders: List[Tuple[int, int]]) -> List[int]: Finds the minimum preparation time for each order range. Args: N: int - number of dishes Q: int - number of orders times: list of int - the preparation times of the dishes orders: list of tuples - each tuple contains two integers representing the start and end indices Returns: list of int - minimum preparation time for each order range >>> min_prep_time(5, 3, [3, 1, 4, 1, 5], [(2, 4), (1, 5), (3, 3)]) [1, 1, 4] >>> min_prep_time(6, 2, [10, 20, 30, 40, 50, 60], [(1, 3), (4, 6)]) [10, 40] pass","solution":"def min_prep_time(N, Q, times, orders): Finds the minimum preparation time for each order range. Args: N: int - number of dishes Q: int - number of orders times: list of int - the preparation times of the dishes orders: list of tuples - each tuple contains two integers representing the start and end indices Returns: list of int - minimum preparation time for each order range # results to store the minimum prep time for each order results = [] # iterate through each order for order in orders: ai, bi = order # find the minimum time in the specified range (1-indexed to 0-indexed) min_time = min(times[ai-1:bi]) results.append(min_time) return results"},{"question":"from typing import List def min_operations_to_equalize_array(arr: List[int]) -> int: Returns the minimum number of operations required to make all elements of the array equal. If the array cannot be made equal, returns -1. >>> min_operations_to_equalize_array([5]) 0 >>> min_operations_to_equalize_array([2, 2, 2, 2]) 0 >>> min_operations_to_equalize_array([1, 2, 3, 4, 5]) 6 >>> min_operations_to_equalize_array([1, 1, 3, 3]) 4 >>> min_operations_to_equalize_array([-5, -3, -1, 1, 3, 5]) 18","solution":"def min_operations_to_equalize_array(arr): Returns the minimum number of operations required to make all elements of the array equal. If the array cannot be made equal, returns -1. if not arr or len(arr) == 1: return 0 median = sorted(arr)[len(arr) // 2] return sum(abs(x - median) for x in arr)"},{"question":"def sum_of_unique_elements(n: int, arr: List[int]) -> int: Calculate the sum of all unique elements in the array (elements that appear exactly once). Parameters: n (int): The number of elements in the array. arr (list): The list of integers. Returns: int: The sum of all unique elements. >>> sum_of_unique_elements(5, [1, 2, 2, 3, 4]) 8 >>> sum_of_unique_elements(6, [1, 1, 1, 1, 1, 1]) 0","solution":"def sum_of_unique_elements(n, arr): Returns the sum of all unique elements in the array. Parameters: n (int): The number of elements in the array. arr (list): The list of integers. Returns: int: The sum of all unique elements. from collections import Counter element_count = Counter(arr) unique_elements_sum = sum(key for key, count in element_count.items() if count == 1) return unique_elements_sum"},{"question":"def can_form_by_rearranging(A: str, B: str) -> str: Determines if string B can be formed by rearranging the characters of string A. >>> can_form_by_rearranging(\\"listen\\", \\"silent\\") 'Yes' >>> can_form_by_rearranging(\\"evil\\", \\"vile\\") 'Yes' >>> can_form_by_rearranging(\\"triangle\\", \\"integral\\") 'Yes' >>> can_form_by_rearranging(\\"apple\\", \\"pale\\") 'No'","solution":"def can_form_by_rearranging(A, B): Determines if string B can be formed by rearranging the characters of string A. Parameters: A (str): The original string. B (str): The string to be formed by rearranging characters of A. Returns: str: 'Yes' if B can be formed by rearranging characters of A, otherwise 'No'. if sorted(A) == sorted(B): return 'Yes' else: return 'No'"},{"question":"def flatten_dictionary(dictionary: dict, parent_key: str = \\"\\", sep: str = \\".\\") -> dict: Flatten a nested dictionary. - dictionary: dict : The dictionary to flatten - parent_key: str (optional) : The base key string to use for the flattened keys - sep: str (optional) : Separator between the concatenated keys args: >>> flatten_dictionary({\\"Key1\\": \\"Value1\\", \\"Key2\\": {\\"a\\": \\"Value2\\", \\"b\\": \\"Value3\\", \\"c\\": {\\"d\\": \\"Value4\\"}}}) { \\"Key1\\": \\"Value1\\", \\"Key2.a\\": \\"Value2\\", \\"Key2.b\\": \\"Value3\\", \\"Key2.c.d\\": \\"Value4\\" } >>> flatten_dictionary({\\"Key1\\": \\"Value1\\"}, parent_key=\\"\\", sep=\\".\\") { \\"Key1\\": \\"Value1\\" } >>> flatten_dictionary({}) {}","solution":"def flatten_dictionary(dictionary, parent_key=\\"\\", sep=\\".\\"): Flattens a nested dictionary. Args: - dictionary (dict): The dictionary to flatten. - parent_key (str): The base key string to use for the flattened keys. - sep (str): Separator between the concatenated keys. Returns: - dict: The flattened dictionary. items = [] for k, v in dictionary.items(): new_key = f\\"{parent_key}{sep}{k}\\" if parent_key else k if isinstance(v, dict): items.extend(flatten_dictionary(v, new_key, sep=sep).items()) else: items.append((new_key, v)) return dict(items)"},{"question":"from typing import List, Tuple def find_shortest_path(n: int, m: int, grid: List[List[int]], start: Tuple[int, int], exit: Tuple[int, int]) -> int: Find the shortest path in a maze from the starting point to the exit. Args: n (int): Number of rows in the grid. m (int): Number of columns in the grid. grid (List[List[int]]): 2D grid representing the maze, where 0 is an open cell and 1 is a blocked cell. start (Tuple[int, int]): Tuple representing the starting point of the maze. exit (Tuple[int, int]): Tuple representing the exit point of the maze. Returns: int: The length of the shortest path from the starting point to the exit, or -1 if no such path exists. Examples: >>> find_shortest_path(4, 4, [[0, 1, 0, 0], [0, 1, 0, 1], [0, 0, 0, 1], [0, 1, 0, 0]], (0, 0), (3, 2)) == 5 >>> find_shortest_path(3, 3, [[0, 1, 0], [0, 1, 0], [0, 0, 0]], (0, 0), (2, 2)) == 4","solution":"from collections import deque def find_shortest_path(n, m, grid, start, exit): # Directions for moving in the four possible directions directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] # BFS initialization queue = deque([(start[0], start[1], 0)]) # (x, y, distance) visited = [[False] * m for _ in range(n)] visited[start[0]][start[1]] = True while queue: x, y, dist = queue.popleft() # Check if we have reached the exit if (x, y) == exit: return dist # Explore neighbors for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and not visited[nx][ny] and grid[nx][ny] == 0: visited[nx][ny] = True queue.append((nx, ny, dist + 1)) # If we exhausted all possibilities and did not find the exit return -1"},{"question":"from typing import List, Tuple def can_rearrange_no_adjacent_same_height(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[str]: Determine if it is possible to rearrange students such that no two students of the same height stand next to each other. Args: t: int : number of test cases test_cases: List[Tuple[int, List[int]]] : a list of tuples where each tuple contains the number of students and the list of student heights Returns: List[str]: List of \\"YES\\" or \\"NO\\" for each test case Example: >>> can_rearrange_no_adjacent_same_height(2, [(5, [1, 1, 2, 3, 3]), (4, [1, 1, 1, 2])]) ['YES', 'NO'] >>> can_rearrange_no_adjacent_same_height(1, [(1, [1])]) ['YES']","solution":"from collections import Counter def can_rearrange_no_adjacent_same_height(t, test_cases): results = [] for i in range(t): n = test_cases[i][0] heights = test_cases[i][1] count = Counter(heights) max_freq = max(count.values()) if max_freq > (n + 1) // 2: results.append(\\"NO\\") else: results.append(\\"YES\\") return results"},{"question":"def deepest_hierarchy_level(n: int, relations: List[Tuple[int, int]]) -> int: Determine the deepest level of hierarchy within the company. >>> deepest_hierarchy_level(1, []) 1 >>> deepest_hierarchy_level(6, [(1, 2), (2, 3), (2, 4), (3, 5), (3, 6)]) 4 >>> deepest_hierarchy_level(5, [(1, 2), (1, 3), (3, 4), (3, 5)]) 3","solution":"def deepest_hierarchy_level(n, relations): from collections import defaultdict, deque if n == 1: return 1 tree = defaultdict(list) for u, v in relations: tree[v].append(u) tree[u].append(v) # We need to find the CEO. We assume the CEO has the least ID which is 1. root = 1 # Breadth-First Search to find the depth level queue = deque([(root, 1)]) # holds (current_node, current_depth) visited = set([root]) max_depth = 1 while queue: node, depth = queue.popleft() max_depth = max(max_depth, depth) for neighbor in tree[node]: if neighbor not in visited: visited.add(neighbor) queue.append((neighbor, depth + 1)) return max_depth"},{"question":"def count_greater_permutations(n: int) -> int: Given an integer n, returns the number of distinct integers that can be formed by permuting the digits of n that are also greater than n. >>> count_greater_permutations(123) 5 >>> count_greater_permutations(4321) 0 >>> count_greater_permutations(9) 0 >>> count_greater_permutations(111) 0 >>> count_greater_permutations(21) 0 >>> count_greater_permutations(12) 1 >>> count_greater_permutations(987654321) 0 >>> count_greater_permutations(123456789) 362879","solution":"import itertools def count_greater_permutations(n): Returns the number of distinct permutations of the digits of n that are greater than n. n_str = str(n) n_sorted_digits = sorted(n_str) greater_permutations = set() # Generate all permutations of the given digits and count those which are greater than n for perm in itertools.permutations(n_sorted_digits): perm_num = int(''.join(perm)) if perm_num > n: greater_permutations.add(perm_num) return len(greater_permutations)"},{"question":"def minimum_paved_roads(n: int, m: int, road_list: List[Tuple[int, int, int]]) -> int: Determine the minimum total length required to pave enough roads to ensure there is a path connecting any two cities directly or indirectly. Input: - n: An integer, number of cities (2 <= n <= 100,000) - m: An integer, number of roads (1 <= m <= 200,000) - road_list: A list of tuples, each containing three integers u, v, and l representing a road between city u and city v with length l Output: - An integer representing the minimum total length of the paved roads necessary to ensure all cities are connected. Example: >>> minimum_paved_roads(5, 7, [(1, 2, 1), (1, 3, 4), (2, 3, 2), (2, 4, 7), (3, 4, 3), (3, 5, 5), (4, 5, 6)]) 11 >>> minimum_paved_roads(2, 1, [(1, 2, 10)]) 10 >>> minimum_paved_roads(3, 3, [(1, 2, 3), (2, 3, 3), (1, 3, 1)]) 4","solution":"def kruskal_minimum_spanning_tree(n, roads): Returns the minimum total length of the paved roads necessary to ensure all cities are connected. Uses Kruskal's algorithm. # Sort roads based on their length roads.sort(key=lambda x: x[2]) # Union-Find data structure to detect cycles parent = list(range(n + 1)) rank = [0] * (n + 1) def find(x): if parent[x] != x: parent[x] = find(parent[x]) return parent[x] def union(x, y): rootX = find(x) rootY = find(y) if rootX != rootY: if rank[rootX] > rank[rootY]: parent[rootY] = rootX elif rank[rootX] < rank[rootY]: parent[rootX] = rootY else: parent[rootY] = rootX rank[rootX] += 1 mst_length = 0 for u, v, l in roads: if find(u) != find(v): union(u, v) mst_length += l return mst_length def minimum_paved_roads(n, m, road_list): return kruskal_minimum_spanning_tree(n, road_list)"},{"question":"from typing import List def is_prime(num: int) -> bool: Helper function to check if a number is prime. >>> is_prime(2) True >>> is_prime(4) False pass def count_primes_in_list(nums: List[int]) -> int: Returns the count of prime numbers in the list. >>> count_primes_in_list([2, 3, 4, 5, 6]) 3 >>> count_primes_in_list([0, 1, 4, 6, 8, 10]) 0 pass from solution import count_primes_in_list, is_prime def test_is_prime(): assert is_prime(2) == True assert is_prime(3) == True assert is_prime(4) == False assert is_prime(17) == True assert is_prime(1) == False assert is_prime(0) == False assert is_prime(101) == True assert is_prime(104) == False def test_count_primes_in_list(): assert count_primes_in_list([2, 3, 4, 5, 6]) == 3 assert count_primes_in_list([0, 1, 4, 6, 8, 10]) == 0 assert count_primes_in_list([11, 13, 17, 19, 23]) == 5 assert count_primes_in_list([100, 101, 102, 103, 104, 105]) == 2 assert count_primes_in_list([]) == 0 assert count_primes_in_list([2]) == 1","solution":"def is_prime(num): Helper function to check if a number is prime. if num <= 1: return False if num == 2: return True if num % 2 == 0: return False for i in range(3, int(num**0.5) + 1, 2): if num % i == 0: return False return True def count_primes_in_list(nums): Returns the count of prime numbers in the list. prime_count = 0 for num in nums: if is_prime(num): prime_count += 1 return prime_count"},{"question":"def max_animals_present(events): Calculate the maximum number of animals present at the same time based on arrival and departure events. Args: events (list of str): A list of strings where each string is either \\"A\\" (Arrival) or \\"D\\" (Departure). Returns: int: The maximum number of animals present at the same time. from solution import max_animals_present def test_example_case(): events = [\\"A\\", \\"A\\", \\"D\\", \\"A\\", \\"D\\", \\"D\\"] assert max_animals_present(events) == 2 def test_all_arrivals(): events = [\\"A\\", \\"A\\", \\"A\\", \\"A\\", \\"A\\"] assert max_animals_present(events) == 5 def test_alternating_arrival_departure(): events = [\\"A\\", \\"D\\", \\"A\\", \\"D\\", \\"A\\", \\"D\\"] assert max_animals_present(events) == 1 def test_single_arrival_departure(): events = [\\"A\\", \\"D\\"] assert max_animals_present(events) == 1 def test_no_events(): events = [] assert max_animals_present(events) == 0 def test_multiple_arrivals_followed_by_multiple_departures(): events = [\\"A\\", \\"A\\", \\"A\\", \\"D\\", \\"D\\", \\"D\\"] assert max_animals_present(events) == 3 def test_events_with_more_departures(): events = [\\"A\\", \\"D\\", \\"D\\", \\"A\\", \\"D\\", \\"D\\"] assert max_animals_present(events) == 1","solution":"def max_animals_present(events): Calculate the maximum number of animals present at the same time based on arrival and departure events. Args: events (list of str): A list of strings where each string is either \\"A\\" (Arrival) or \\"D\\" (Departure). Returns: int: The maximum number of animals present at the same time. max_present = 0 current_present = 0 for event in events: if event == \\"A\\": current_present += 1 if current_present > max_present: max_present = current_present elif event == \\"D\\": current_present -= 1 return max_present"},{"question":"def find_shortest_cycle(N: int, E: int, edge_list: List[str]) -> int: Given an undirected graph with N nodes and E edges, determine whether the graph contains a cycle and find out the minimum length of the cycle. Return -1 if there are no cycles. >>> find_shortest_cycle(4, 4, [\\"1 2\\", \\"2 3\\", \\"3 1\\", \\"3 4\\"]) 3 >>> find_shortest_cycle(3, 2, [\\"1 2\\", \\"2 3\\"]) -1 >>> find_shortest_cycle(5, 0, []) -1 >>> find_shortest_cycle(6, 7, [\\"1 2\\", \\"2 3\\", \\"3 4\\", \\"4 5\\", \\"5 6\\", \\"6 3\\", \\"2 5\\"]) 4 >>> find_shortest_cycle(6, 6, [\\"1 2\\", \\"2 3\\", \\"3 1\\", \\"4 5\\", \\"5 6\\", \\"6 4\\"]) 3 pass","solution":"from collections import deque def shortest_cycle(N, E, edges): graph = [[] for _ in range(N)] for u, v in edges: graph[u - 1].append(v - 1) graph[v - 1].append(u - 1) def bfs(start): dist = [-1] * N parent = [-1] * N dist[start] = 0 queue = deque([start]) shortest = float('inf') while queue: node = queue.popleft() for neighbor in graph[node]: if dist[neighbor] == -1: dist[neighbor] = dist[node] + 1 parent[neighbor] = node queue.append(neighbor) elif parent[node] != neighbor: shortest = min(shortest, dist[node] + dist[neighbor] + 1) return shortest result = float('inf') for i in range(N): result = min(result, bfs(i)) return result if result != float('inf') else -1 # Function to parse input and call the main function def find_shortest_cycle(N, E, edge_list): edges = [tuple(map(int, edge.split())) for edge in edge_list] return shortest_cycle(N, E, edges)"},{"question":"def total_transaction_time(N: int, C: int, amounts: List[int], times: List[int]) -> int: Calculate the total time taken for all transactions until the last person in the line either successfully purchases the item or attempts to do so and leaves if they don't have enough money. >>> total_transaction_time(5, 20, [15, 30, 10, 40, 25], [5, 10, 3, 7, 4]) 29 >>> total_transaction_time(3, 10, [20, 15, 25], [5, 10, 3]) 18 >>> total_transaction_time(4, 20, [10, 30, 5, 40], [2, 3, 1, 4]) 10 >>> total_transaction_time(2, 50, [20, 30], [7, 8]) 15 >>> total_transaction_time(5, 25, [30, 10, 15, 5, 35], [4, 3, 2, 1, 6]) 16 >>> total_transaction_time(1, 1, [1], [0]) 0","solution":"def total_transaction_time(N, C, amounts, times): total_time = 0 for i in range(N): total_time += times[i] return total_time"},{"question":"def longest_zigzag_length(arr): Find the length of the longest Zigzag sequence that can be formed from the array. Args: arr (List[int]): List of integers. Returns: int: Length of the longest Zigzag sequence. >>> longest_zigzag_length([1, 7, 4, 9, 2, 5]) 6 >>> longest_zigzag_length([1, 2, 3, 4]) 2 pass def process_test_cases(test_cases): Process multiple test cases and return the results for each. Args: test_cases (List[Tuple[int, List[int]]]): List of tuples where each tuple contains an integer representing the array length and a list of integers. Returns: List[int]: List of lengths of the longest Zigzag sequences for each test case. >>> process_test_cases([(6, [1, 7, 4, 9, 2, 5]), (4, [1, 2, 3, 4])]) [6, 2] >>> process_test_cases([(3, [10, 10, 10]), (10, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]), (10, [10, 9, 8, 7, 6, 5, 4, 3, 2, 1])]) [1, 2, 2] pass from typing import List, Tuple import doctest doctest.testmod()","solution":"def longest_zigzag_length(arr): n = len(arr) if n == 1: return 1 up = [1] * n down = [1] * n for i in range(1, n): if arr[i] > arr[i-1]: up[i] = down[i-1] + 1 down[i] = down[i-1] elif arr[i] < arr[i-1]: down[i] = up[i-1] + 1 up[i] = up[i-1] else: up[i] = up[i-1] down[i] = down[i-1] return max(up[n-1], down[n-1]) def process_test_cases(test_cases): results = [] for test_case in test_cases: n, arr = test_case[0], test_case[1] results.append(longest_zigzag_length(arr)) return results"},{"question":"from typing import List def can_rearrange_no_adjacent(s: str) -> str: Determine if it is possible to rearrange the characters of the string so that no two adjacent characters are the same. >>> can_rearrange_no_adjacent(\\"aabb\\") 'YES' >>> can_rearrange_no_adjacent(\\"aaab\\") 'NO' def process_test_cases(test_cases: List[str]) -> List[str]: Process multiple test cases to determine if each string can be rearranged such that no two adjacent characters are the same. >>> process_test_cases([\\"aabb\\", \\"aaab\\"]) ['YES', 'NO'] # Here are some example test cases: def test_example_cases(): assert process_test_cases([\\"aabb\\", \\"aaab\\"]) == [\\"YES\\", \\"NO\\"] def test_single_character(): assert process_test_cases([\\"a\\"]) == [\\"YES\\"] def test_two_characters(): assert process_test_cases([\\"ab\\", \\"aa\\"]) == [\\"YES\\", \\"NO\\"] def test_all_same_characters(): assert process_test_cases([\\"aaa\\", \\"bbbb\\"]) == [\\"NO\\", \\"NO\\"] def test_large_input_no_repeat(): s = \\"abcdefg\\" * 10000 assert process_test_cases([s]) == [\\"YES\\"] def test_large_input_with_repeat(): s = \\"a\\" * 10000 + \\"bcdefg\\" * 9999 assert process_test_cases([s]) == [\\"YES\\"] def test_edge_case_max_length(): s = \\"a\\" * 50000 + \\"b\\" * 50000 assert process_test_cases([s]) == [\\"YES\\"] def test_edge_case_max_length_fail(): s = \\"a\\" * 50001 + \\"b\\" * 49999 assert process_test_cases([s]) == [\\"NO\\"]","solution":"def can_rearrange_no_adjacent(s): from collections import Counter # Count the frequency of each character freq = Counter(s) # Find the maximum frequency of any character max_freq = max(freq.values()) # If the most frequent character is more than half of the string length + 1 (if odd length), # then it's impossible to rearrange to avoid adjacent duplicates. if max_freq > (len(s) + 1) // 2: return \\"NO\\" return \\"YES\\" def process_test_cases(test_cases): results = [] for s in test_cases: results.append(can_rearrange_no_adjacent(s)) return results"},{"question":"def min_moves_to_equal_piles(n: int, piles: List[int]) -> int: Calculate the minimum number of moves to make all piles have the same number of coins. >>> min_moves_to_equal_piles(3, [4, 3, 2]) 3 >>> min_moves_to_equal_piles(5, [1, 2, 3, 4, 5]) 10 >>> min_moves_to_equal_piles(4, [8, 8, 8, 8]) 0 def process_datasets(input_data: List[str]) -> List[int]: Processes multiple datasets from a string input. :param input_data: A list of strings representing the input. :return: A list of integers representing the result for each dataset. >>> process_datasets([\\"3\\", \\"4 3 2\\", \\"5\\", \\"1 2 3 4 5\\", \\"4\\", \\"8 8 8 8\\", \\"-\\"]) [3, 10, 0] >>> process_datasets([\\"1\\", \\"10\\", \\"2\\", \\"20 25\\", \\"-\\"]) [0, 5]","solution":"def min_moves_to_equal_piles(n, piles): Calculate the minimum number of moves to make all piles have the same number of coins. min_pile = min(piles) return sum(pile - min_pile for pile in piles) def process_datasets(input_data): Processes multiple datasets from a string input. :param input_data: A list of strings representing the input. :return: A list of integers representing the result for each dataset. results = [] i = 0 while i < len(input_data): line = input_data[i] if line == '-': break n = int(line) piles = list(map(int, input_data[i + 1].split())) results.append(min_moves_to_equal_piles(n, piles)) i += 2 return results"},{"question":"class ListNode: def __init__(self, x): self.val = x self.next = None def reverseList(head: ListNode) -> ListNode: Reverse a singly linked list. The function takes the head of a singly linked list and returns the head of the reversed list. >>> head = list_to_nodes([1, 2, 3, 4, 5]) >>> reversed_head = reverseList(head) >>> nodes_to_list(reversed_head) [5, 4, 3, 2, 1] >>> head = list_to_nodes([1, 2]) >>> reversed_head = reverseList(head) >>> nodes_to_list(reversed_head) [2, 1] >>> head = list_to_nodes([]) >>> reversed_head = reverseList(head) >>> nodes_to_list(reversed_head) [] >>> head = None >>> reversed_head = reverseList(head) >>> reversed_head is None True pass def list_to_nodes(values): if not values: return None head = ListNode(values[0]) current = head for value in values[1:]: current.next = ListNode(value) current = current.next return head def nodes_to_list(head): values = [] current = head while current: values.append(current.val) current = current.next return values","solution":"class ListNode: def __init__(self, x): self.val = x self.next = None def reverseList(head: ListNode) -> ListNode: prev = None current = head while current: next_node = current.next # Store the next node current.next = prev # Reverse the current node's pointer prev = current # Move the prev pointer one step forward current = next_node # Move the current pointer one step forward return prev"},{"question":"def largest_rectangle_area(heights: List[int]) -> int: Calculates the maximum area of a rectangle that can be formed by contiguous buildings. Parameters: heights (list): A list of integers representing the heights of the buildings. Returns: int: The maximum area of the rectangle that can be formed. >>> largest_rectangle_area([2, 1, 5, 6, 2, 3]) == 10","solution":"def largest_rectangle_area(heights): Calculates the maximum area of a rectangle that can be formed by contiguous buildings. Parameters: heights (list): A list of integers representing the heights of the buildings. Returns: int: The maximum area of the rectangle that can be formed. stack = [] max_area = 0 index = 0 while index < len(heights): if not stack or heights[index] >= heights[stack[-1]]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"def compress_string(s: str) -> str: Compress a given string by reducing the sequence of identical characters to the character followed by the count of consecutive occurrences. If the compressed string is longer than the original string, return the original string. Examples: >>> compress_string(\\"aabcccccaaa\\") 'a2b1c5a3' >>> compress_string(\\"abcdef\\") 'abcdef' >>> compress_string(\\"aaAAaa\\") 'aaAAaa'","solution":"def compress_string(s: str) -> str: if not s: return s compressed = [] count = 1 prev_char = s[0] for i in range(1, len(s)): if s[i] == prev_char: count += 1 else: compressed.append(f\\"{prev_char}{count}\\") prev_char = s[i] count = 1 compressed.append(f\\"{prev_char}{count}\\") # Don't forget to append the last gathered element compressed_str = ''.join(compressed) # Return the shorter one between compressed and original return compressed_str if len(compressed_str) < len(s) else s"},{"question":"def min_pallets(n, w, cartons): Determines the minimum number of pallets needed to pack the cartons. :param n: Number of cartons :param w: Maximum weight a pallet can carry :param cartons: List of weights of the cartons :return: Minimum number of pallets needed >>> min_pallets(5, 10, [2, 3, 4, 5, 6]) 3 >>> min_pallets(3, 15, [10, 5, 8]) 2 >>> min_pallets(4, 20, [8, 8, 8, 8]) 2","solution":"def min_pallets(n, w, cartons): Determines the minimum number of pallets needed to pack the cartons. :param n: Number of cartons :param w: Maximum weight a pallet can carry :param cartons: List of weights of the cartons :return: Minimum number of pallets needed cartons.sort() i, j = 0, n - 1 pallets = 0 while i <= j: if cartons[i] + cartons[j] <= w: i += 1 j -= 1 pallets += 1 return pallets"},{"question":"def minimize_adjacent_difference(arr): Rearranges the elements of the array so that the absolute difference between any two adjacent elements is minimized. >>> minimize_adjacent_difference([4, 3, 2, 10, 1]) [1, 2, 3, 4, 10] >>> minimize_adjacent_difference([5, 10, 5]) [5, 5, 10]","solution":"def minimize_adjacent_difference(arr): Rearranges the elements of the array so that the absolute difference between any two adjacent elements is minimized. return sorted(arr)"},{"question":"def longest_increasing_subsequence(arr: List[int]) -> int: Returns the length of the longest increasing subsequence in the array. >>> longest_increasing_subsequence([10, 22, 9, 33, 21, 50]) 4 >>> longest_increasing_subsequence([5, 1, 2, 4, 3]) 3 >>> longest_increasing_subsequence([1, 2, 3, 4, 5]) 5 >>> longest_increasing_subsequence([5, 4, 3, 2, 1]) 1 >>> longest_increasing_subsequence([3, 10, 2, 1, 20]) 3 >>> longest_increasing_subsequence([3, 2]) 1 >>> longest_increasing_subsequence([50, 3, 10, 7, 40, 80]) 4 >>> longest_increasing_subsequence([1]) 1 >>> longest_increasing_subsequence([]) 0","solution":"def longest_increasing_subsequence(arr): Returns the length of the longest increasing subsequence in the array. if not arr: return 0 n = len(arr) lis = [1] * n for i in range(1, n): for j in range(i): if arr[i] > arr[j] and lis[i] < lis[j] + 1: lis[i] = lis[j] + 1 return max(lis)"},{"question":"def merge(nums1: List[int], m: int, nums2: List[int], n: int) -> None: Merges nums2 into nums1 as one sorted array in-place. Args: nums1 (List[int]): The first sorted array with enough space at the end. m (int): The number of initialized elements in nums1. nums2 (List[int]): The second sorted array. n (int): The number of elements in nums2. Example: >>> nums1 = [1, 2, 3, 0, 0, 0] >>> merge(nums1, 3, nums2, 3) >>> nums1 [1, 2, 2, 3, 5, 6] >>> nums1 = [1] >>> merge(nums1, 1, nums2, 0) >>> nums1 [1]","solution":"def merge(nums1, m, nums2, n): Merges nums2 into nums1 as one sorted array in-place. # Initialize pointers for nums1 and nums2 p1, p2 = m - 1, n - 1 # Initialize pointer for merged array p = m + n - 1 # Move elements from nums2 and nums1 into the merged position in nums1 while p1 >= 0 and p2 >= 0: if nums1[p1] > nums2[p2]: nums1[p] = nums1[p1] p1 -= 1 else: nums1[p] = nums2[p2] p2 -= 1 p -= 1 # If there are remaining elements in nums2, move them to nums1 nums1[:p2 + 1] = nums2[:p2 + 1]"},{"question":"def count_consecutive_sum_numbers(L: int, R: int) -> int: Returns the count of numbers in the range [L, R] that can be expressed as the sum of two positive, consecutive integers. Args: L : int : starting number of the range (inclusive) R : int : ending number of the range (inclusive) Returns: int : count of numbers in the range [L, R] that can be expressed as the sum of two positive, consecutive integers Example: >>> count_consecutive_sum_numbers(1, 10) 5","solution":"def count_consecutive_sum_numbers(L, R): Returns the count of numbers in the range [L, R] that can be expressed as the sum of two positive, consecutive integers. # Counting numbers of the form 2k + 1, where k is a non-negative integer count = 0 for x in range(L, R + 1): if x % 2 == 1: count += 1 return count"},{"question":"def days_left(D: int, M: int) -> int: Determines the number of challenge days remaining in the month starting from day D. Parameters: D (int): The starting day. M (int): The month number. Returns: int: The number of remaining days in the month. Examples: >>> days_left(15, 2) 13 >>> days_left(1, 3) 30 >>> days_left(30, 6) 0","solution":"def days_left(D, M): Determines the number of challenge days remaining in the month starting from day D. Parameters: D (int): The starting day. M (int): The month number. Returns: int: The number of remaining days in the month. days_in_month = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31] return days_in_month[M-1] - D"},{"question":"def unique_paths(M: int, N: int) -> int: Calculate the number of unique paths from the top-left corner to the bottom-right corner of a grid of dimensions MxN. :param M: number of rows in the grid :param N: number of columns in the grid :return: number of unique paths >>> unique_paths(2, 3) 3 >>> unique_paths(3, 3) 6 >>> unique_paths(1, 1) 1 >>> unique_paths(7, 3) 28 >>> unique_paths(50, 50) 25477612258980856902730428600","solution":"def unique_paths(M, N): Calculate the number of unique paths from the top-left corner to the bottom-right corner of a grid of dimensions MxN. :param M: number of rows in the grid :param N: number of columns in the grid :return: number of unique paths if M == 1 or N == 1: return 1 # Create a 2D list to store the number of paths to each cell dp = [[0] * N for _ in range(M)] # There's only one way to reach cells in the first row: move right for j in range(N): dp[0][j] = 1 # There's only one way to reach cells in the first column: move down for i in range(M): dp[i][0] = 1 # Fill the DP table for i in range(1, M): for j in range(1, N): dp[i][j] = dp[i-1][j] + dp[i][j-1] return dp[M-1][N-1]"},{"question":"def encrypt_string(s: str) -> str: Encrypts a string by replacing each letter with the letter three positions further down the alphabet. Non-alphabet characters remain unchanged. >>> encrypt_string(\\"abcxyz\\") == \\"defabc\\" >>> encrypt_string(\\"ABCXYZ\\") == \\"DEFABC\\" >>> encrypt_string(\\"HelloWorld\\") == \\"KhoorZruog\\" >>> encrypt_string(\\"Zebra-123\\") == \\"Cheud-123\\" >>> encrypt_string(\\"hello world!\\") == \\"khoor zruog!\\" >>> encrypt_string(\\"\\") == \\"\\" >>> encrypt_string(\\"a\\" * 10000) == \\"d\\" * 10000","solution":"def encrypt_string(s): Encrypts a string by replacing each letter with the letter three positions further down the alphabet. Non-alphabet characters remain unchanged. def shift_letter(letter): if 'a' <= letter <= 'z': return chr((ord(letter) - ord('a') + 3) % 26 + ord('a')) elif 'A' <= letter <= 'Z': return chr((ord(letter) - ord('A') + 3) % 26 + ord('A')) else: return letter return ''.join(shift_letter(c) for c in s)"},{"question":"def max_items_to_purchase(N: int, M: int, prices: List[int]) -> int: Determines the maximum number of items that can be purchased without exceeding the amount M. >>> max_items_to_purchase(5, 10, [2, 5, 3, 8, 4]) 3 >>> max_items_to_purchase(3, 10, [2, 2, 2]) 3 >>> max_items_to_purchase(4, 100, [25, 25, 25, 25]) 4 >>> max_items_to_purchase(4, 5, [10, 10, 10, 10]) 0 >>> max_items_to_purchase(5, 10, [1, 1, 1, 1, 1]) 5 >>> max_items_to_purchase(6, 15, [1, 2, 3, 4, 5, 6]) 5","solution":"def max_items_to_purchase(N, M, prices): Determines the maximum number of items that can be purchased without exceeding the amount M. # Sort the prices list to prioritize cheaper items prices.sort() total_spent = 0 items_purchased = 0 # Loop through the sorted prices for price in prices: if total_spent + price <= M: total_spent += price items_purchased += 1 else: break return items_purchased # Sample usage if __name__ == '__main__': import sys input = sys.stdin.read().strip().split('n') N, M = map(int, input[0].split()) prices = list(map(int, input[1].split())) result = max_items_to_purchase(N, M, prices) print(result)"},{"question":"def create_increasing_matrix(N): Creates an N x N matrix where numbers from 1 to N^2 appear exactly once, with each row and column strictly increasing. pass def format_matrix(matrix): Formats the matrix as a string with each row on a new line, and each element in a row separated by a space. pass from solution import create_increasing_matrix, format_matrix def test_create_increasing_matrix_3(): matrix = create_increasing_matrix(3) expected_matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] assert matrix == expected_matrix def test_create_increasing_matrix_4(): matrix = create_increasing_matrix(4) expected_matrix = [ [1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16] ] assert matrix == expected_matrix def test_create_increasing_matrix_1(): matrix = create_increasing_matrix(1) expected_matrix = [ [1] ] assert matrix == expected_matrix def test_format_matrix_3(): matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] formatted = format_matrix(matrix) expected_output = \\"1 2 3n4 5 6n7 8 9\\" assert formatted == expected_output def test_format_matrix_4(): matrix = [ [1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16] ] formatted = format_matrix(matrix) expected_output = \\"1 2 3 4n5 6 7 8n9 10 11 12n13 14 15 16\\" assert formatted == expected_output def test_format_matrix_1(): matrix = [ [1] ] formatted = format_matrix(matrix) expected_output = \\"1\\" assert formatted == expected_output","solution":"def create_increasing_matrix(N): Creates an N x N matrix where numbers from 1 to N^2 appear exactly once, with each row and column strictly increasing. matrix = [] current_number = 1 for i in range(N): row = [] for j in range(N): row.append(current_number) current_number += 1 matrix.append(row) return matrix def format_matrix(matrix): Formats the matrix as a string with each row on a new line, and each element in a row separated by a space. return \\"n\\".join(\\" \\".join(map(str, row)) for row in matrix)"},{"question":"def min_operations_to_unique(arr): Given an integer array arr, returns the minimum number of operations required to make all elements unique. An operation is defined as selecting two distinct indices i and j (1 ≤ i, j ≤ n) such that arr[i] = arr[j], and then incrementing both arr[i] and arr[j] by one. >>> min_operations_to_unique([1, 2, 2, 3, 3]) 2 >>> min_operations_to_unique([5, 5, 5]) 3 >>> min_operations_to_unique([1, 1, 1, 1]) 6 >>> min_operations_to_unique([1000000000, 1000000000]) 1 >>> min_operations_to_unique([999999999, 999999999, 999999999]) 3 >>> min_operations_to_unique([1, 2, 3, 4, 5]) 0 >>> min_operations_to_unique([1, 1, 2, 3, 3, 3]) 4 >>> min_operations_to_unique([1]) 0 >>> min_operations_to_unique([2, 4, 6, 8]) 0","solution":"import heapq from collections import Counter def min_operations_to_unique(arr): Given an array arr, returns the minimum number of operations required to make all elements unique. # Dictionary to store frequencies of elements in arr freq = Counter(arr) # Min-heap to process duplicates min_heap = [] # Push all elements into the min_heap based on their frequencies for num, count in freq.items(): heapq.heappush(min_heap, (num, count)) operations = 0 while min_heap: num, count = heapq.heappop(min_heap) if count > 1: operations += count - 1 next_num = num + 1 # Update the next number in the heap if next_num in freq: freq[next_num] += count - 1 else: heapq.heappush(min_heap, (next_num, count - 1)) return operations"},{"question":"from typing import List, Tuple def min_operations_to_transform(T: int, test_cases: List[Tuple[str, str, int, List[Tuple[str, str]]]]) -> List[int]: Determine the minimum number of operations required to transform each source string to its corresponding target string. Args: T (int): Number of test cases. test_cases (List[Tuple[str, str, int, List[Tuple[str, str]]]]): A list of tuples where each tuple represents a test case. Each tuple contains: - source (str): Source string. - target (str): Target string. - M (int): Number of operations. - operations (List[Tuple[str, str]]): A list of operation tuples. Returns: List[int]: A list containing the minimum number of operations required for each test case, or -1 if transformation is not possible. Example: >>> num_tests = 2 >>> cases = [(\\"abc\\", \\"bca\\", 3, [(\\"a\\", \\"b\\"), (\\"b\\", \\"c\\"), (\\"c\\", \\"a\\")]), (\\"hello\\", \\"world\\", 1, [(\\"h\\", \\"f\\")])] >>> min_operations_to_transform(num_tests, cases) [3, -1] # Write your solution here","solution":"from collections import deque def min_operations_to_transform(T, test_cases): results = [] for case in test_cases: source, target, M, operations = case if len(source) != len(target): results.append(-1) continue transformation_map = {} for op in operations: a, b = op if a in transformation_map: transformation_map[a].add(b) else: transformation_map[a] = {b} def bfs(start, end): queue = deque([(start, 0)]) visited = set() while queue: current, steps = queue.popleft() if current == end: return steps if current in visited: continue visited.add(current) if current in transformation_map: for next_char in transformation_map[current]: if next_char not in visited: queue.append((next_char, steps + 1)) return -1 total_operations = 0 possible = True for s_char, t_char in zip(source, target): if s_char != t_char: ops_needed = bfs(s_char, t_char) if ops_needed == -1: possible = False break total_operations += ops_needed if possible: results.append(total_operations) else: results.append(-1) return results # Test interface function consuming input and calling the above solution def transform_strings(num_tests, all_cases): results = min_operations_to_transform(num_tests, all_cases) for result in results: print(result)"},{"question":"def circle_measurement(N: int) -> float: Calculates and returns the area or circumference of the circle based on the given radius N. If the radius is greater than 10, returns the area of the circle. If the radius is 10 or less, returns the circumference of the circle. >>> circle_measurement(5) 31.4159 >>> circle_measurement(12) 452.38944","solution":"def circle_measurement(N): Returns the area or circumference of the circle based on the given radius N. If the radius is greater than 10, returns the area of the circle. If the radius is 10 or less, returns the circumference of the circle. pi = 3.14159 if N > 10: # Area of the circle (π * r^2) return pi * N * N else: # Circumference of the circle (2 * π * r) return 2 * pi * N"},{"question":"def max_robots_in_parade(D: int, Q: int, robots: List[Tuple[int, int]]) -> int: Calculate the maximum number of robots that can join the parade over D days. Args: D (int): The number of days of parades. Q (int): The maximum number of robots that can be prepared each day. robots (List[Tuple[int, int]]): A list of tuple pairs where each tuple contains: - k_i (int): The specific day on which the i-th robot is available. - t_i (int): The time it takes to get the robot ready on that day. Returns: int: The maximum number of robots that can join the parade over the D days. Example: >>> max_robots_in_parade(3, 2, [(1, 4), (2, 3), (3, 2), (1, 5), (2, 1), (3, 3), (2, 4)]) 6 >>> max_robots_in_parade(2, 2, [(1, 5), (2, 5), (1, 5), (2, 5), (1, 5), (2, 5)]) 4 pass def test_max_robots_in_parade_sample1(): D = 3 Q = 2 robots = [(1, 4), (2, 3), (3, 2), (1, 5), (2, 1), (3, 3), (2, 4)] assert max_robots_in_parade(D, Q, robots) == 6 def test_max_robots_in_parade_sample2(): D = 2 Q = 2 robots = [(1, 5), (2, 5), (1, 5), (2, 5), (1, 5), (2, 5)] assert max_robots_in_parade(D, Q, robots) == 4 def test_max_robots_in_parade_sample3(): D = 1 Q = 3 robots = [(1, 4), (1, 4), (1, 6), (1, 1), (1, 2), (1, 1), (1, 3), (1, 5)] assert max_robots_in_parade(D, Q, robots) == 3 def test_max_robots_equal_days(): D = 2 Q = 2 robots = [(1, 3), (1, 2), (2, 3), (2, 2)] assert max_robots_in_parade(D, Q, robots) == 4 def test_no_robots(): D = 3 Q = 3 robots = [] assert max_robots_in_parade(D, Q, robots) == 0 def test_large_number_of_robots(): D = 2 Q = 2 robots = [(1, i) for i in range(1, 501)] + [(2, i) for i in range(1, 501)] assert max_robots_in_parade(D, Q, robots) == 4","solution":"def max_robots_in_parade(D, Q, robots): # Group robots by their availability day day_to_robots = {i: [] for i in range(1, D+1)} for k, t in robots: day_to_robots[k].append(t) max_robots = 0 # For each day, sort robots by preparation time and take the first Q (or fewer) for day in range(1, D+1): day_to_robots[day].sort() # Sort preparation times for the day max_robots += min(Q, len(day_to_robots[day])) # Take the maximum possible robots on this day return max_robots"},{"question":"def reading_schedule(n, m, days_needed): Generates a reading schedule such that the participant's total reading experience is maximized. :param n: Number of days :param m: Number of books :param days_needed: List of integers where each integer represents the number of days needed to read each book :return: List of integers where each integer represents the index of the book being read on that day pass # Your code here # Unit Tests def test_example_one(): assert reading_schedule(7, 3, [2, 3, 2]) == [1, 1, 2, 2, 2, 3, 3] def test_example_two(): assert reading_schedule(5, 2, [3, 2]) == [1, 1, 1, 2, 2] def test_single_book(): assert reading_schedule(5, 1, [5]) == [1, 1, 1, 1, 1] def test_multiple_books_same_days(): assert reading_schedule(4, 2, [2, 2]) == [1, 1, 2, 2] def test_minimum_values(): assert reading_schedule(1, 1, [1]) == [1] def test_zero_days_required(): assert reading_schedule(5, 3, [0, 2, 3]) == [2, 2, 3, 3, 3]","solution":"def reading_schedule(n, m, days_needed): Generates a reading schedule such that the participant's total reading experience is maximized. :param n: Number of days :param m: Number of books :param days_needed: List of integers where each integer represents the number of days needed to read each book :return: List of integers where each integer represents the index of the book being read on that day schedule = [0] * n # Initialize the schedule with 0s representing no book being read on those days current_day = 0 # Starting from day 0 # Loop through each book and schedule its reading days consecutively for book_index in range(m): for _ in range(days_needed[book_index]): schedule[current_day] = book_index + 1 # The book index is 1-based in the schedule current_day += 1 return schedule"},{"question":"def can_split_array(n: int, a: List[int]) -> str: Determines if the array can be split into two non-empty parts such that the sum of elements in both parts are equal. >>> can_split_array(6, [1, 2, 3, 3, 2, 1]) \\"Yes\\" >>> can_split_array(5, [1, 2, 3, 4, 5]) \\"No\\" >>> can_split_array(4, [2, -2, 3, -3]) \\"Yes\\" >>> can_split_array(2, [1, 1]) \\"Yes\\" >>> can_split_array(3, [1, 1, 1]) \\"No\\" >>> can_split_array(6, [10, -10, 10, -10, 10, -10]) \\"Yes\\" >>> can_split_array(3, [0, 0, 0]) \\"Yes\\"","solution":"def can_split_array(n, a): Determines if the array can be split into two non-empty parts such that the sum of elements in both parts are equal. total_sum = sum(a) if total_sum % 2 != 0: return \\"No\\" half_sum = total_sum // 2 current_sum = 0 for i in range(n - 1): current_sum += a[i] if current_sum == half_sum: return \\"Yes\\" return \\"No\\""},{"question":"def max_flavor_sum(n: int, flavors: List[int]) -> int: Returns the maximum sum of flavors achievable by combining exactly two different ingredients. >>> max_flavor_sum(5, [-1, 2, 3, -4, 5]) 8 >>> max_flavor_sum(3, [-5, -2, -3]) -5 >>> max_flavor_sum(4, [1, -10, 4, -3]) 5 >>> max_flavor_sum(4, [0, 0, 2, 3]) 5 >>> max_flavor_sum(4, [0, 0, -2, -3]) 0 >>> max_flavor_sum(6, [-1000, -500, 0, 500, 1000, 200]) 1500 >>> max_flavor_sum(5, [7, 7, 7, 7, 7]) 14","solution":"def max_flavor_sum(n, flavors): Returns the maximum sum of flavors achievable by combining exactly two different ingredients. # Sort the flavor values in descending order flavors.sort(reverse=True) # The most flavorful combination is the sum of the two largest flavor values return flavors[0] + flavors[1] # Example usage: # print(max_flavor_sum(5, [-1, 2, 3, -4, 5])) # Output: 8 # print(max_flavor_sum(3, [-5, -2, -3])) # Output: -5"},{"question":"def has_pair_with_difference(nums: List[int], K: int) -> str: Given a list of integers, determine if there exists a pair of distinct indices i and j such that the absolute difference between the elements at these indices is equal to a given integer K. Examples: >>> has_pair_with_difference([1, 5, 3, 4, 2], 3) == \\"Yes\\" >>> has_pair_with_difference([10, 20, 30, 40, 50, 60], 8) == \\"No\\" >>> has_pair_with_difference([1, 1, 1], 0) == \\"Yes\\" >>> has_pair_with_difference([1, 2, 3, 4, 5], 7) == \\"No\\" >>> has_pair_with_difference([10, 15, 3, 7, 5], 5) == \\"Yes\\" pass","solution":"def has_pair_with_difference(nums, K): Returns 'Yes' if there exists a pair of indices (i, j) such that the absolute difference between the elements at these indices equals K, otherwise returns 'No'. # Using a set to keep track of the numbers we have seen so far seen = set() for num in nums: if (num + K) in seen or (num - K) in seen: return \\"Yes\\" seen.add(num) return \\"No\\" if __name__ == \\"__main__\\": import sys input = sys.stdin.read() data = input.split() n = int(data[0]) K = int(data[1]) nums = list(map(int, data[2:])) print(has_pair_with_difference(nums, K))"},{"question":"def find_optimal_landing_spot(n: int, wind_factors: List[int]) -> int: This function returns the index of the landing spot with the minimal absolute wind factor. If there are multiple such indices, the smallest one is returned. Args: n (int): number of landing spots wind_factors (list of int): list of wind factors for each landing spot Returns: int: the index of the landing spot with minimal absolute wind factor Examples: >>> find_optimal_landing_spot(5, [-5, -1, -2, -1, -3]) 1 >>> find_optimal_landing_spot(3, [-5, -3, -3]) 1","solution":"def find_optimal_landing_spot(n, wind_factors): This function returns the index of the landing spot with the minimal absolute wind factor. If there are multiple such indices, the smallest one is returned. Args: n (int): number of landing spots wind_factors (list of int): list of wind factors for each landing spot Returns: int: the index of the landing spot with minimal absolute wind factor min_abs_wind = float('inf') optimal_index = -1 for i in range(n): abs_wind = abs(wind_factors[i]) if abs_wind < min_abs_wind: min_abs_wind = abs_wind optimal_index = i elif abs_wind == min_abs_wind and i < optimal_index: optimal_index = i return optimal_index # Example usage n = 5 wind_factors = [-5, -1, -2, -1, -3] print(find_optimal_landing_spot(n, wind_factors)) # Output: 1"},{"question":"def check_unique_sprite_numbers(n: int) -> str: Determines if there exists a binary tree with nodes 1 to n where all nodes have unique sprite numbers. Args: n (int): the number of unique values Returns: str: \\"YES\\" if such a binary tree exists, otherwise \\"NO\\" Examples: >>> check_unique_sprite_numbers(3) \\"YES\\" >>> check_unique_sprite_numbers(4) \\"YES\\" >>> check_unique_sprite_numbers(5) \\"NO\\"","solution":"def check_unique_sprite_numbers(n): Determines if there exists a binary tree with nodes 1 to n where all nodes have unique sprite numbers. Args: n (int): the number of unique values Returns: str: \\"YES\\" if such a binary tree exists, otherwise \\"NO\\" if n == 1 or n == 2: return \\"YES\\" return \\"NO\\""},{"question":"def adjust_bikes(N: int, stations: List[Tuple[int, int]]) -> List[int]: Determine the minimum number of bikes that need to be added or removed from each station so that all stations can maintain at least one free slot and also have at least one bike available for borrowing. >>> adjust_bikes(3, [(5, 10), (0, 5), (2, 3)]) [0, 1, -1] >>> adjust_bikes(2, [(6, 5), (4, 3)]) [-1, -1]","solution":"def adjust_bikes(N, stations): adjustments = [] for A, B in stations: if A > 0 and A < B: adjustments.append(0) elif A == 0: adjustments.append(1) else: # A >= B adjustments.append(-1) return adjustments # Example Use N = 3 stations = [(5, 10), (0, 5), (2, 3)] print(adjust_bikes(N, stations)) # Output should be [0, 1, -1]"},{"question":"def find_value(n: int, k: int, t: int) -> int: Finds the smallest integer y such that F(y) is greater than or equal to k, or determines that no such integer y exists less than or equal to t. Uses up to 1000 calls to determine the answer. >>> find_value(50, 15, 100) # Example dummy calls with some function F 10 >>> find_value(50, 120, 20) -1 >>> find_value(50, 5, 10) 1 >>> find_value(50, 15, 20) 10 >>> find_value(50, 17, 20) 12","solution":"def find_value(n, k, t): def F(x): # Placeholder dummy function. This should simulate the interaction for testing purposes. # Replace or mock this as needed for actual function interaction. return x + 5 # Example dummy function F(x) = x + 5 low, high = 1, t answer = -1 while low <= high: mid = (low + high) // 2 value = F(mid) if value >= k: answer = mid high = mid - 1 else: low = mid + 1 return answer"},{"question":"def calculate_fence_length(x1: int, y1: int, x2: int, y2: int) -> int: Calculate the length of the fence required to enclose a rectangular section. The length of the fence is equal to the perimeter of the rectangle, which is 2 times the width + 2 times the height. Parameters: x1, y1 (int): Coordinates of the bottom-left corner. x2, y2 (int): Coordinates of the top-right corner. Returns: int: The length of the fence. pass def process_test_cases(test_cases: list) -> list: Process multiple test cases and calculate the fence length for each. Parameters: test_cases (list of tuples): Each tuple contains four integers (x1, y1, x2, y2). Returns: list of int: Fence lengths for each test case. pass # Example Test Cases if __name__ == \\"__main__\\": # Unit tests for calculate_fence_length assert calculate_fence_length(0, 0, 1, 1) == 4 assert calculate_fence_length(-1, -1, 0, 0) == 4 assert calculate_fence_length(0, 0, 2, 2) == 8 assert calculate_fence_length(1, 1, 4, 5) == 14 assert calculate_fence_length(-3, -2, 1, 2) == 16 # Unit tests for process_test_cases test_cases_1 = [(0, 0, 1, 1), (-1, -1, 0, 0)] assert process_test_cases(test_cases_1) == [4, 4] test_cases_2 = [(0, 0, 2, 2), (1, 1, 4, 5)] assert process_test_cases(test_cases_2) == [8, 14] test_cases_3 = [(-3, -2, 1, 2), (0, 0, 3, 4)] assert process_test_cases(test_cases_3) == [16, 14]","solution":"def calculate_fence_length(x1, y1, x2, y2): Calculate the length of the fence required to enclose a rectangular section. The length of the fence is equal to the perimeter of the rectangle, which is 2 times the width + 2 times the height. Parameters: x1, y1 (int): Coordinates of the bottom-left corner. x2, y2 (int): Coordinates of the top-right corner. Returns: int: The length of the fence. width = x2 - x1 height = y2 - y1 return 2 * (width + height) def process_test_cases(test_cases): Process multiple test cases and calculate the fence length for each. Parameters: test_cases (list of tuples): Each tuple contains four integers (x1, y1, x2, y2). Returns: list of int: Fence lengths for each test case. results = [] for x1, y1, x2, y2 in test_cases: results.append(calculate_fence_length(x1, y1, x2, y2)) return results"},{"question":"def rearrange_array(arr): Rearranges the array such that all negative numbers appear before all positive numbers, maintaining their relative order. # Your code here def process_test_cases(test_cases): Processes multiple test cases for rearranging arrays. # Your code here def test_rearrange_array(): assert rearrange_array([1, -3, 2, -1, -4]) == [-3, -1, -4, 1, 2] assert rearrange_array([-5, -2, -1, 0, 3, 4]) == [-5, -2, -1, 0, 3, 4] assert rearrange_array([0, 5, -8, 7, -3]) == [-8, -3, 0, 5, 7] assert rearrange_array([-1, -2, -3, 1, 2, 3]) == [-1, -2, -3, 1, 2, 3] assert rearrange_array([3, 2, 1]) == [3, 2, 1] assert rearrange_array([-1, -2, -3]) == [-1, -2, -3] def test_process_test_cases(): test_cases = [ [1, -3, 2, -1, -4], [-5, -2, -1, 0, 3, 4] ] expected_output = [ [-3, -1, -4, 1, 2], [-5, -2, -1, 0, 3, 4] ] assert process_test_cases(test_cases) == expected_output test_cases = [ [0, 5, -8, 7, -3], [-1, -2, -3, 1, 2, 3] ] expected_output = [ [-8, -3, 0, 5, 7], [-1, -2, -3, 1, 2, 3] ] assert process_test_cases(test_cases) == expected_output","solution":"def rearrange_array(arr): Rearranges the array such that all negative numbers appear before all positive numbers, maintaining their relative order. negative = [x for x in arr if x < 0] non_negative = [x for x in arr if x >= 0] return negative + non_negative def process_test_cases(test_cases): Processes multiple test cases for rearranging arrays. results = [] for arr in test_cases: results.append(rearrange_array(arr)) return results"},{"question":"def max_score_from_pairs(n, array): Function to compute the maximum possible score by performing operations on the given array. :param n: int - The number of elements in the array :param array: list of int - The elements of the array. :return: int - The maximum score. pass def test_max_score_from_pairs_example_1(): assert max_score_from_pairs(6, [2, 4, 6, 3, 5, 7]) == 3 def test_max_score_from_pairs_example_2(): assert max_score_from_pairs(5, [1, 2, 3, 4, 5]) == 2 def test_max_score_from_pairs_large_even(): assert max_score_from_pairs(4, [2, 4, 6, 8]) == 0 def test_max_score_from_pairs_large_odd(): assert max_score_from_pairs(4, [1, 3, 5, 7]) == 0 def test_max_score_from_pairs_mixed(): assert max_score_from_pairs(10, [1, 2, 4, 7, 9, 8, 10, 3, 5, 6]) == 5 def test_max_score_from_pairs_minimum_input(): assert max_score_from_pairs(2, [1, 2]) == 1 def test_max_score_from_pairs_one_pair_of_each(): assert max_score_from_pairs(4, [1, 2, 3, 4]) == 2","solution":"def max_score_from_pairs(n, array): Function to compute the maximum possible score by performing operations on the given array. :param n: int - The number of elements in the array :param array: list of int - The elements of the array. :return: int - The maximum score. if n < 2: return 0 even_count = sum(1 for x in array if x % 2 == 0) odd_count = n - even_count score = min(even_count, odd_count) return score"},{"question":"import math from itertools import permutations from typing import List def gcd(x: int, y: int) -> int: while y: x, y = y, x % y return x def can_rearrange(arr: List[int]) -> str: Determines if it is possible to rearrange the array such that every consecutive pair of elements has a common divisor greater than 1. If such a rearrangement is possible, returns \\"YES\\" followed by a valid rearrangement. Otherwise, returns \\"NO\\". >>> can_rearrange([2, 3, 6, 9]) \\"YESn3 6 9 2\\" >>> can_rearrange([2, 5, 7, 11]) \\"NO\\"","solution":"import math from itertools import permutations def gcd(x, y): while y: x, y = y, x % y return x def can_rearrange(arr): if len(arr) == 1: # If there's only one element, we can't have consecutive pairs, hence it could be trivially rearranged return \\"YESn\\" + str(arr[0]) # Check permutations to find valid arrangement for perm in permutations(arr): valid = True for i in range(len(perm)-1): if gcd(perm[i], perm[i+1]) <= 1: valid = False break if valid: return \\"YESn\\" + ' '.join(map(str, perm)) return \\"NO\\" # Example input_data = [4, [2, 3, 6, 9]] # this should output \\"YESn3 6 9 2\\" n = input_data[0] arr = input_data[1] output = can_rearrange(arr) print(output)"},{"question":"def find_similar_users(viewing_records: List[Tuple[int, int]], k: int) -> Tuple[int, List[Tuple[int, int]]]: Find all pairs of users who have watched at least k common shows. >>> find_similar_users([(1, 1), (1, 2), (1, 3), (2, 2), (2, 3), (2, 4), (3, 2)], 2) (1, [(1, 2)]) >>> find_similar_users([(1, 1), (1, 2), (2, 3), (2, 4), (3, 5), (3, 6), (4, 7)], 2) (0, []) pass def process_input(input_lines: List[str]) -> Tuple[int, List[Tuple[int, int]]]: Process input to find similar users based on viewing history. >>> process_input(['7 2', '1 1', '1 2', '1 3', '2 2', '2 3', '2 4', '3 2']) (1, [(1, 2)]) >>> process_input(['7 2', '1 1', '1 2', '2 3', '2 4', '3 5', '3 6', '4 7']) (0, []) pass","solution":"def find_similar_users(viewing_records, k): from collections import defaultdict user_shows = defaultdict(set) show_users = defaultdict(set) for u, s in viewing_records: user_shows[u].add(s) show_users[s].add(u) similar_pairs = set() users = list(user_shows.keys()) for i in range(len(users)): for j in range(i+1, len(users)): common_shows = user_shows[users[i]].intersection(user_shows[users[j]]) if len(common_shows) >= k: similar_pairs.add((users[i], users[j])) similar_pairs = sorted(similar_pairs) return len(similar_pairs), similar_pairs def process_input(input_lines): n, k = map(int, input_lines[0].split()) viewing_records = [tuple(map(int, line.split())) for line in input_lines[1:]] return find_similar_users(viewing_records, k)"},{"question":"def find_critical_employees(n: int, edges: List[Tuple[int, int]]) -> List[int]: Identify all critical employees in the company. An employee is considered critical if removing them and all their subordinates from the hierarchy would increase the number of disconnected sub-groups in the company. Args: n : int : number of employees edges : List[Tuple[int, int]] : hierarchy of the company represented by a list of tuples Returns: List[int] : list of critical employees' IDs in ascending order Examples: >>> find_critical_employees(5, [(1, 2), (1, 3), (2, 4), (3, 5)]) [1, 2, 3] >>> find_critical_employees(6, [(1, 2), (1, 3), (3, 4), (3, 5), (4, 6)]) [1, 3, 4] >>> find_critical_employees(7, [(1, 2), (1, 3), (2, 4), (2, 5), (5, 6), (5, 7)]) [1, 2, 5] >>> find_critical_employees(3, [(1, 2), (1, 3)]) [1] >>> find_critical_employees(4, [(1, 2), (2, 3), (2, 4)]) [2]","solution":"def find_critical_employees(n, edges): from collections import defaultdict, deque def dfs(node, parent): ids[node] = low[node] = dfs_timer[0] dfs_timer[0] += 1 children = 0 critical = False for neighbor in graph[node]: if neighbor == parent: continue if ids[neighbor] == -1: # neighbor hasn't been visited children += 1 dfs(neighbor, node) if low[neighbor] >= ids[node]: critical = True low[node] = min(low[node], low[neighbor]) else: low[node] = min(low[node], ids[neighbor]) if (parent != -1 and critical) or (parent == -1 and children > 1): critical_employees.add(node) graph = defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) ids = [-1] * (n + 1) low = [0] * (n + 1) dfs_timer = [0] critical_employees = set() dfs(1, -1) # Starting DFS from root node, which is the CEO with ID 1 return sorted(list(critical_employees)) # Example usage n = 5 edges = [ (1, 2), (1, 3), (2, 4), (3, 5), ] print(find_critical_employees(n, edges)) # Output: [1, 2, 3]"},{"question":"def max_profit(prices: List[int]) -> int: Determine the maximum profit that could be achieved by buying and then later selling the stock. >>> max_profit([7, 1, 5, 3, 6, 4]) 5 >>> max_profit([7, 6, 4, 3, 1]) 0","solution":"def max_profit(prices): This function takes a list of stock prices and returns the maximum profit that could be achieved by buying and then later selling the stock. If no profit can be made, the function returns 0. :param prices: List[int] - a list of integers representing the stock prices. :return: int - the maximum possible profit. if not prices or len(prices) < 2: return 0 min_price = prices[0] max_profit = 0 for price in prices[1:]: if price < min_price: min_price = price else: max_profit = max(max_profit, price - min_price) return max_profit"},{"question":"def min_power_strips(m: int, n: int, sockets: List[int]) -> int: Returns the minimum number of power strips needed to get exactly n sockets, or -1 if it's not possible to achieve exactly n sockets with the given power strips. Args: m (int): The number of different power strips available. n (int): The required number of sockets. sockets (List[int]): The number of sockets for each power strip type. Returns: int: The minimum number of power strips needed, or -1 if not possible. Examples: >>> min_power_strips(3, 7, [3, 5, 2]) 2 >>> min_power_strips(2, 10, [1, 2]) 5 >>> min_power_strips(3, 21, [6, 7, 8]) 3 >>> min_power_strips(2, 5, [2, 4]) -1 >>> min_power_strips(3, 10, [3, 4, 7]) 2 >>> min_power_strips(1, 50, [50]) 1 >>> min_power_strips(5, 5, [1, 2, 3, 4, 5]) 1 >>> min_power_strips(4, 15, [2, 3, 5, 7]) 3","solution":"def min_power_strips(m, n, sockets): Returns the minimum number of power strips needed to get exactly n sockets, or -1 if it's not possible to achieve exactly n sockets with the given power strips. dp = [float('inf')] * (n + 1) dp[0] = 0 for i in range(1, n + 1): for socket in sockets: if i >= socket: dp[i] = min(dp[i], dp[i - socket] + 1) return dp[n] if dp[n] != float('inf') else -1 # Sample usage m = 3 n = 7 sockets = [3, 5, 2] print(min_power_strips(m, n, sockets)) # Output: 2"},{"question":"from collections import defaultdict, deque from typing import List, Tuple def tree_diameter(n: int, edges: List[Tuple[int, int]]) -> int: Compute the diameter of a tree. Args: n (int): The number of nodes in the tree. edges (List[Tuple[int, int]]): List of edges where each edge is represented by a tuple (u, v). Returns: int: The diameter of the tree. Examples: >>> tree_diameter(5, [(1, 2), (2, 3), (3, 4), (2, 5)]) 3 >>> tree_diameter(3, [(1, 2), (1, 3)]) 2","solution":"def tree_diameter(n, edges): from collections import defaultdict, deque def bfs(start): q = deque([start]) dist = {start: 0} max_dist = 0 max_node = start while q: node = q.popleft() current_dist = dist[node] for neighbor in graph[node]: if neighbor not in dist: dist[neighbor] = current_dist + 1 q.append(neighbor) if dist[neighbor] > max_dist: max_dist = dist[neighbor] max_node = neighbor return max_node, max_dist # Create graph from edges graph = defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) # Step 1: Start BFS from any node, get the farthest node (u) u, _ = bfs(1) # Step 2: Start BFS from node u, get the farthest node (v) and its distance _, diameter = bfs(u) return diameter"},{"question":"def isOneEditAway(str1: str, str2: str) -> bool: Determine if str1 can be transformed into str2 with at most one edit (insert, delete, replace). >>> isOneEditAway(\\"pale\\", \\"ple\\") True >>> isOneEditAway(\\"pales\\", \\"pale\\") True >>> isOneEditAway(\\"pale\\", \\"bale\\") True >>> isOneEditAway(\\"pale\\", \\"bake\\") False # Unit Test def test_isOneEditAway(): assert isOneEditAway(\\"pale\\", \\"ple\\") == True assert isOneEditAway(\\"pales\\", \\"pale\\") == True assert isOneEditAway(\\"pale\\", \\"bale\\") == True assert isOneEditAway(\\"pale\\", \\"bake\\") == False assert isOneEditAway(\\"pale\\", \\"pale\\") == True assert isOneEditAway(\\"\\", \\"\\") == True assert isOneEditAway(\\"a\\", \\"\\") == True assert isOneEditAway(\\"\\", \\"a\\") == True assert isOneEditAway(\\"abcdef\\", \\"abcde\\") == True assert isOneEditAway(\\"abcdef\\", \\"abcf\\") == False assert isOneEditAway(\\"ab\\", \\"bc\\") == False assert isOneEditAway(\\"ab\\", \\"a\\") == True assert isOneEditAway(\\"abc\\", \\"ab\\") == True","solution":"def isOneEditAway(str1, str2): Determine if str1 can be transformed into str2 with at most one edit (insert, delete, replace). len1, len2 = len(str1), len(str2) # If the length difference is more than 1, more than one edit is required if abs(len1 - len2) > 1: return False # Get the shorter and longer strings if len1 > len2: str1, str2 = str2, str1 # Ensure str1 is the shorter one len1, len2 = len2, len1 # Flags for any difference encountered difference_found = False # Two pointers for both strings i, j = 0, 0 while i < len1 and j < len2: if str1[i] != str2[j]: if difference_found: return False difference_found = True if len1 == len2: # If same length, move both pointers i += 1 else: i += 1 # If matching, move pointer of the shorter string j += 1 # Always move pointer of the longer string return True"},{"question":"def min_max_time(n, m, r, paths): Find the minimum possible maximum time for any runner to complete the race. Args: n (int): The number of houses. m (int): The number of paths. r (int): The number of runners. paths (List[Tuple[int, int, int, int]]): A list of tuples where each tuple contains four integers representing a path from house \`ai\` to house \`bi\` that takes \`ti\` time to traverse and has a bridge which can hold up to \`ci\` runners simultaneously. Returns: float: The minimum possible maximum time for any runner to complete the race. >>> min_max_time(4, 4, 5, [(1, 2, 2, 2), (2, 4, 3, 1), (1, 3, 6, 2), (3, 4, 1, 2)]) 5.0000000000 >>> min_max_time(5, 7, 10, [(1, 2, 3, 5), (2, 3, 2, 4), (3, 4, 4, 3), (4, 5, 2, 2), (1, 3, 4, 3), (2, 4, 3, 2), (3, 5, 5, 1)]) 8.0000000000","solution":"def min_max_time(n, m, r, paths): import heapq from collections import defaultdict def feasible_within_time(T): adj = defaultdict(list) for (a, b, t, c) in paths: adj[a].append((b, t, c)) adj[b].append((a, t, c)) min_times = {i: float('inf') for i in range(1, n+1)} min_times[1] = 0 pq = [(0, 1)] while pq: current_time, house = heapq.heappop(pq) if current_time > min_times[house]: continue for next_house, travel_time, capacity in adj[house]: required_time = current_time + travel_time if required_time < min_times[next_house] and (r - 1) // capacity + 1 <= T: # ceil(r / capacity) <= T min_times[next_house] = required_time heapq.heappush(pq, (required_time, next_house)) return min_times[n] <= T left, right = 0, 1e7 while right - left > 1e-6: mid = (left + right) / 2 if feasible_within_time(mid): right = mid else: left = mid return right # Example usage n = 5 m = 7 r = 10 paths = [ (1, 2, 3, 5), (2, 3, 2, 4), (3, 4, 4, 3), (4, 5, 2, 2), (1, 3, 4, 3), (2, 4, 3, 2), (3, 5, 5, 1) ] print(f\\"{min_max_time(n, m, r, paths):.10f}\\")"},{"question":"def max_unique_topics(a: int, b: int, c: int) -> int: Determine the maximum number of unique topics Yuna can learn by enrolling in exactly two different courses. >>> max_unique_topics(300, 400, 500) 900 >>> max_unique_topics(500, 500, 500) 1000 >>> max_unique_topics(100, 200, 300) 500 >>> max_unique_topics(1, 10, 5) 15 >>> max_unique_topics(10000, 9999, 10000) 20000","solution":"def max_unique_topics(a, b, c): Calculate the max number of unique topics Yuna can learn by combining any two of the three courses. # Combining two courses at a time and summing up the topics combine_AB = a + b combine_BC = b + c combine_CA = c + a # Returning the maximum of the combined topics return max(combine_AB, combine_BC, combine_CA)"},{"question":"def transpose_and_sum_diagonal(matrix): Transposes the matrix and calculates the sum of the diagonal elements of the transposed matrix. :param matrix: List of lists, where each inner list is a row of the matrix. :return: Integer, the sum of the diagonal elements of the transposed matrix. pass def test_example_1(): matrix = [ [1, 2], [3, 4] ] assert transpose_and_sum_diagonal(matrix) == 5 def test_example_2(): matrix = [ [1, 0, 0], [0, 1, 0], [0, 0, 1] ] assert transpose_and_sum_diagonal(matrix) == 3 def test_large_matrix(): matrix = [ [1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16] ] assert transpose_and_sum_diagonal(matrix) == 34 # 1 + 6 + 11 + 16 def test_single_element_matrix(): matrix = [ [42] ] assert transpose_and_sum_diagonal(matrix) == 42 def test_negative_elements(): matrix = [ [-1, -2, -3], [-4, -5, -6], [-7, -8, -9] ] assert transpose_and_sum_diagonal(matrix) == -15 # -1 + -5 + -9","solution":"def transpose_and_sum_diagonal(matrix): Transposes the matrix and calculates the sum of the diagonal elements of the transposed matrix. :param matrix: List of lists, where each inner list is a row of the matrix. :return: Integer, the sum of the diagonal elements of the transposed matrix. n = len(matrix) # Transpose the matrix transposed_matrix = [[matrix[j][i] for j in range(n)] for i in range(n)] # Calculate the sum of the diagonal elements of the transposed matrix diagonal_sum = sum(transposed_matrix[i][i] for i in range(n)) return diagonal_sum # Reading input for testing if __name__ == \\"__main__\\": import sys input = sys.stdin.read data = input().split() n = int(data[0]) matrix = [] index = 1 for i in range(n): row = list(map(int, data[index:index + n])) matrix.append(row) index += n print(transpose_and_sum_diagonal(matrix))"},{"question":"def can_find_treasure(num_cases, cases): Determine if Alex can find the treasure based on the given rules. num_cases: int : number of test cases cases: List[Tuple[int, List[int]]] : each tuple contains number of locations (int) and the list of potential treasure locations (List[int]) >>> can_find_treasure(3, [(3, [2, 1, -1]), (4, [1, 0, -1, 3]), (5, [0, 1, 3, 4, -1])]) [\\"Found\\", \\"Not Found\\", \\"Found\\"]","solution":"def can_find_treasure(num_cases, cases): results = [] for i in range(num_cases): n, t = cases[i] visited = set() current_location = 0 while current_location not in visited: if t[current_location] == -1: results.append(\\"Not Found\\") break if t[current_location] == current_location: results.append(\\"Found\\") break visited.add(current_location) current_location = t[current_location] else: results.append(\\"Not Found\\") return results def main(): import sys input = sys.stdin.read data = input().split() index = 0 num_cases = int(data[index]) index += 1 cases = [] for _ in range(num_cases): n = int(data[index]) index += 1 t = list(map(int, data[index:index + n])) index += n cases.append((n, t)) results = can_find_treasure(num_cases, cases) for result in results: print(result)"},{"question":"def length_of_longest_substring_two_distinct(s: str) -> int: Returns the length of the longest substring of s that contains at most two distinct characters. >>> length_of_longest_substring_two_distinct(\\"eceba\\") 3 >>> length_of_longest_substring_two_distinct(\\"aa\\") 2 >>> length_of_longest_substring_two_distinct(\\"abcba\\") 3 pass def process_input(input_str: str) -> list: Processes the input string and returns a list of results for each dataset. >>> process_input(\\"ecebanaanabcban\\") [3, 2, 3] >>> process_input(\\"ecebannnabcban\\") [3, 3] >>> process_input(\\"ecebanaanabcbann\\") [3, 2, 3] pass","solution":"def length_of_longest_substring_two_distinct(s): Returns the length of the longest substring of s that contains at most two distinct characters. if not s: return 0 left, right = 0, 0 max_len = 0 char_map = {} while right < len(s): if len(char_map) <= 2: char_map[s[right]] = right right += 1 if len(char_map) > 2: min_index = min(char_map.values()) del char_map[s[min_index]] left = min_index + 1 max_len = max(max_len, right - left) return max_len def process_input(input_str): inputs = input_str.strip().split('n') results = [] for s in inputs: if s: # avoid processing empty lines in between results.append(length_of_longest_substring_two_distinct(s)) return results"},{"question":"def reverse_strings(T: int, strings: List[str]) -> List[str]: For each string in the strings list, reverse the string and return a new list of reversed strings. >>> reverse_strings(1, [\\"hello\\"]) [\\"olleh\\"] >>> reverse_strings(3, [\\"apple\\", \\"world\\", \\"programming\\"]) [\\"elppa\\", \\"dlrow\\", \\"gnimmargorp\\"] >>> reverse_strings(1, [\\"aaaaaaa\\"]) [\\"aaaaaaa\\"] >>> reverse_strings(3, [\\"a\\", \\"ab\\", \\"abc\\"]) [\\"a\\", \\"ba\\", \\"cba\\"] >>> reverse_strings(1, [\\"\\"]) [\\"\\"]","solution":"def reverse_strings(T, strings): For each string in the strings list, reverse the string and return a new list of reversed strings. :param T: Number of test cases (strings) :param strings: List of strings to be reversed :return: List of reversed strings return [s[::-1] for s in strings]"},{"question":"def characterSurvives(initialHP: int, hits: List[int]) -> str: Determines if a character survives after a sequence of hits. Parameters: initialHP (int): Initial health points of the character. hits (list of int): Sequence of hits represented as integers which reduce the character's HP. Returns: str: \\"SURVIVED\\" if HP is greater than 0 after all hits, \\"ELIMINATED\\" otherwise. Examples: >>> characterSurvives(10, [3, 4, 2]) \\"SURVIVED\\" >>> characterSurvives(5, [4, 2]) \\"ELIMINATED\\"","solution":"def characterSurvives(initialHP, hits): Determines if a character survives after a sequence of hits. Parameters: initialHP (int): Initial health points of the character. hits (list of int): Sequence of hits represented as integers which reduce the character's HP. Returns: str: \\"SURVIVED\\" if HP is greater than 0 after all hits, \\"ELIMINATED\\" otherwise. currentHP = initialHP for hit in hits: currentHP -= hit if currentHP <= 0: return \\"ELIMINATED\\" return \\"SURVIVED\\""},{"question":"def max_tulips(m: int, n: int, k: int) -> int: Calculate the maximum number of tulips that can be planted in a garden of size m x n with at most k tulips per row or column. Parameters: m (int): the number of rows n (int): the number of columns k (int): the maximum number of tulips per row or column Returns: int: the maximum number of tulips that can be planted Examples: >>> max_tulips(3, 3, 2) 6 >>> max_tulips(4, 5, 3) 12 >>> max_tulips(2, 2, 1) 2 >>> max_tulips(7, 4, 1) 4","solution":"def max_tulips(m, n, k): Calculate the maximum number of tulips that can be planted in a garden of size m x n with at most k tulips per row or column. Parameters: m (int): the number of rows n (int): the number of columns k (int): the maximum number of tulips per row or column Returns: int: the maximum number of tulips that can be planted return k * min(m, n)"},{"question":"def beauty_of_entire_array(n, a): Compute the beauty of the entire array. The beauty of a subarray is defined as the product of the maximum element and the minimum element in that subarray. The beauty of the entire array is the sum of the beauties of all its subarrays. Args: n (int): The length of the array. a (List[int]): The elements of the array. Returns: int: The beauty of the entire array. Examples: >>> beauty_of_entire_array(3, [1, 2, 3]) 25 >>> beauty_of_entire_array(4, [1, 2, 3, 4]) 41 def test_single_element_array(): assert beauty_of_entire_array(1, [5]) == 25 def test_two_elements_array(): assert beauty_of_entire_array(2, [1, 2]) == 1*1 + 2*2 + 1*2 def test_three_elements_array(): assert beauty_of_entire_array(3, [1, 2, 3]) == 1*1 + 2*2 + 3*3 + 1*2 + 2*3 + 1*3 def test_four_elements_array(): assert beauty_of_entire_array(4, [1, 2, 3, 4]) == 1*1 + 2*2 + 3*3 + 4*4 + 1*2 + 2*3 + 3*4 + 1*3 + 2*4 + 1*4 def test_mixed_elements_array(): assert beauty_of_entire_array(3, [3, 1, 2]) == 3*3 + 1*1 + 2*2 + 1*3 + 1*2 + 1*3","solution":"def beauty_of_entire_array(n, a): total_beauty = 0 for i in range(n): for j in range(i, n): subarray = a[i:j+1] subarray_min = min(subarray) subarray_max = max(subarray) total_beauty += subarray_min * subarray_max return total_beauty"},{"question":"def min_operations_to_uniform_string(n: int, s: str) -> int: Returns the minimum number of operations required to make all characters in the string the same. >>> min_operations_to_uniform_string(5, \\"ababa\\") 2 >>> min_operations_to_uniform_string(3, \\"bba\\") 1 >>> min_operations_to_uniform_string(4, \\"aaaa\\") 0 >>> min_operations_to_uniform_string(6, \\"ababab\\") 3 >>> min_operations_to_uniform_string(1, \\"a\\") 0 >>> min_operations_to_uniform_string(1, \\"b\\") 0 >>> min_operations_to_uniform_string(2, \\"aa\\") 0 >>> min_operations_to_uniform_string(2, \\"ab\\") 1 >>> min_operations_to_uniform_string(0, \\"\\") 0","solution":"def min_operations_to_uniform_string(n, s): Returns the minimum number of operations required to make all characters in the string the same. count_a = s.count('a') count_b = s.count('b') # We can either convert all to 'a' or all to 'b' return min(count_a, count_b)"},{"question":"def count_paths(n: int, m: int, grid: List[str]) -> int: Determine the number of distinct paths Alice can take to reach the bottom-right corner from the top-left corner. Alice can move either right or down one cell at a time, but cannot step on blocked cells. >>> count_paths(3, 3, [\\"...\\", \\".#.\\", \\"...\\"]) 2 >>> count_paths(3, 3, [\\"..#\\", \\".#.\\", \\"...\\"]) 1 >>> count_paths(3, 3, [\\"..#\\", \\".#.\\", \\".#.\\"]) 0","solution":"def count_paths(n, m, grid): if grid[0][0] == '#' or grid[n-1][m-1] == '#': return 0 dp = [[0]*m for _ in range(n)] dp[0][0] = 1 for i in range(n): for j in range(m): if grid[i][j] == '#': dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[-1][-1] def main(): import sys input = sys.stdin.read data = input().strip().split() n = int(data[0]) m = int(data[1]) grid = [] index = 2 for i in range(n): grid.append(data[index]) index += 1 result = count_paths(n, m, grid) print(result) if __name__ == \\"__main__\\": main()"},{"question":"import heapq from collections import defaultdict, deque def dijkstra(n, start, graph): dist = [float('inf')] * (n + 1) dist[start] = 0 pq = [(0, start)] while pq: current_dist, u = heapq.heappop(pq) if current_dist > dist[u]: continue for v, weight in graph[u]: distance = current_dist + weight if distance < dist[v]: dist[v] = distance heapq.heappush(pq, (distance, v)) return dist def can_have_multiple_shortest_paths(n, m, edges): Determines if it is possible to ensure that there are at least two distinct minimum travel paths between any pair of villages after modifications. >>> can_have_multiple_shortest_paths(4, 5, [(1, 2, 1), (2, 3, 1), (3, 4, 1), (1, 3, 2), (2, 4, 2)]) 1 >>> can_have_multiple_shortest_paths(3, 3, [(1, 2, 2), (2, 3, 2), (3, 1, 3)]) 0","solution":"import heapq from collections import defaultdict, deque def dijkstra(n, start, graph): dist = [float('inf')] * (n + 1) dist[start] = 0 pq = [(0, start)] while pq: current_dist, u = heapq.heappop(pq) if current_dist > dist[u]: continue for v, weight in graph[u]: distance = current_dist + weight if distance < dist[v]: dist[v] = distance heapq.heappush(pq, (distance, v)) return dist def can_have_multiple_shortest_paths(n, m, edges): graph = defaultdict(list) for u, v, w in edges: graph[u].append((v, w)) graph[v].append((u, w)) # Pick any node to be the source, let's pick node 1 dist_from_1 = dijkstra(n, 1, graph) # Check if we can find an alternative shortest path for each edge new_graph = defaultdict(list) for u, v, w in edges: if dist_from_1[u] + w == dist_from_1[v]: new_graph[u].append((v, w)) new_graph[v].append((u, w)) # BFS from node 1 to ensure full connectivity in the minimal path graph visited = [False] * (n + 1) queue = deque([1]) while queue: node = queue.popleft() if not visited[node]: visited[node] = True for neighbor, _ in new_graph[node]: if not visited[neighbor]: queue.append(neighbor) # Check if all nodes are visited return 1 if all(visited[1:]) else 0 def main(): import sys input = sys.stdin.read data = input().split() n = int(data[0]) m = int(data[1]) edges = [] index = 2 for _ in range(m): u = int(data[index]) v = int(data[index + 1]) w = int(data[index + 2]) edges.append((u, v, w)) index += 3 print(can_have_multiple_shortest_paths(n, m, edges))"},{"question":"def store_items_in_warehouse(n: int, I: int, capacities: List[int]) -> List[int]: Distribute items in the warehouse based on given constraints. Parameters: n (int): Number of storage units I (int): Number of items to store capacities (list of int): List of maximum capacities of each storage unit Returns: list of int: Distribution of items in each storage unit or [-1] if not possible >>> store_items_in_warehouse(5, 15, [4, 6, 2, 9, 5]) [4, 6, 2, 3, 0] >>> store_items_in_warehouse(3, 11, [5, 1, 6]) [5, 1, 5] >>> store_items_in_warehouse(3, 10, [3, 4, 2]) [-1] >>> store_items_in_warehouse(3, 0, [3, 4, 5]) [0, 0, 0] >>> store_items_in_warehouse(4, 10, [3, 3, 3, 3]) [3, 3, 3, 1] >>> store_items_in_warehouse(3, 12, [3, 4, 4]) [-1] >>> store_items_in_warehouse(1, 1, [1]) [1] >>> store_items_in_warehouse(1, 2, [1]) [-1] >>> store_items_in_warehouse(4, 10, [2, 2, 2, 4]) [2, 2, 2, 4] pass","solution":"def store_items_in_warehouse(n, I, capacities): Distribute items in the warehouse based on given constraints. Parameters: n (int): Number of storage units I (int): Number of items to store capacities (list of int): List of maximum capacities of each storage unit Returns: list of int: Distribution of items in each storage unit or [-1] if not possible items_distribution = [0] * n for i in range(n): if I <= 0: break items_to_store = min(capacities[i], I) items_distribution[i] = items_to_store I -= items_to_store if I > 0: return [-1] return items_distribution"},{"question":"def longest_palindromic_substring_length(grid: List[str]) -> int: Returns the length of the longest palindromic substring found in any row of the grid. >>> longest_palindromic_substring_length([\\"abcba\\", \\"axcye\\", \\"anabb\\", \\"yxzzy\\"]) == 5 >>> longest_palindromic_substring_length([\\"abcdefg\\", \\"hijklmn\\", \\"opqrstu\\"]) == 1 >>> longest_palindromic_substring_length([\\"aba\\", \\"xyz\\"]) == 3","solution":"def longest_palindromic_substring_length(grid): Returns the length of the longest palindromic substring found in any row of the grid. def longest_palindrome_in_row(row): Helper function to find the longest palindromic substring in a single row. max_len = 0 for i in range(len(row)): # Check for odd length palindromes l, r = i, i while l >= 0 and r < len(row) and row[l] == row[r]: max_len = max(max_len, r - l + 1) l -= 1 r += 1 # Check for even length palindromes l, r = i, i + 1 while l >= 0 and r < len(row) and row[l] == row[r]: max_len = max(max_len, r - l + 1) l -= 1 r += 1 return max_len max_palindromic_length = 0 for row in grid: max_palindromic_length = max(max_palindromic_length, longest_palindrome_in_row(row)) return max_palindromic_length"},{"question":"def is_bipartite(n: int, m: int, edges: List[Tuple[int, int]]) -> str: Determine if the given undirected graph is bipartite. Args: n (int): The number of vertices. m (int): The number of edges. edges (List[Tuple[int, int]]): List of edges represented as tuples of vertices (u, v). Returns: str: \\"YES\\" if the graph is bipartite, otherwise \\"NO\\". >>> is_bipartite(4, 4, [(1, 2), (2, 3), (3, 4), (4, 1)]) \\"YES\\" >>> is_bipartite(3, 3, [(1, 2), (2, 3), (3, 1)]) \\"NO\\"","solution":"def is_bipartite(n, m, edges): from collections import deque # Create adjacency list from edges adj_list = [[] for _ in range(n + 1)] for u, v in edges: adj_list[u].append(v) adj_list[v].append(u) # 0: uncolored, 1: color1, -1: color2 color = [0] * (n + 1) def bfs(start): queue = deque([start]) color[start] = 1 while queue: node = queue.popleft() for neighbor in adj_list[node]: if color[neighbor] == 0: color[neighbor] = -color[node] queue.append(neighbor) elif color[neighbor] == color[node]: return False return True for i in range(1, n + 1): if color[i] == 0: if not bfs(i): return \\"NO\\" return \\"YES\\""},{"question":"def longest_subarray_with_sum_at_most_k(N: int, M: int, arr: List[int]) -> int: Returns the length of the longest sub-array where the sum of the elements in the sub-array is at most M. >>> longest_subarray_with_sum_at_most_k(7, 15, [1, 2, 3, 4, 5, 6, 7]) == 5 >>> longest_subarray_with_sum_at_most_k(5, 10, [3, 1, 2, 1, 5]) == 4 >>> longest_subarray_with_sum_at_most_k(5, 3, [4, 5, 6, 7, 8]) == 0","solution":"def longest_subarray_with_sum_at_most_k(N, M, arr): Returns the length of the longest sub-array where the sum of the elements in the sub-array is at most M. max_length = 0 current_sum = 0 start = 0 for end in range(N): current_sum += arr[end] while current_sum > M: current_sum -= arr[start] start += 1 max_length = max(max_length, end - start + 1) return max_length"},{"question":"def find_highest_bid(bids): Find the participant with the highest bid. If there are multiple participants with the same highest bid, return the one with the smallest participant_id. :param bids: List of tuples, where each tuple contains (participant_id, bid_amount) :return: Tuple (participant_id, highest_bid_amount) >>> find_highest_bid([(1, 200), (2, 300), (1, 250), (3, 150), (2, 350)]) (2, 350) >>> find_highest_bid([(4, 500), (4, 400), (3, 500)]) (3, 500) >>> find_highest_bid([(1, 100), (2, 100), (1, 200), (3, 50)]) (1, 200) >>> find_highest_bid([(1, 500)]) (1, 500) >>> find_highest_bid([(1, 100), (2, 100), (3, 100)]) (1, 100) >>> find_highest_bid([(1, 100), (2, 200), (3, 300), (1, 400)]) (1, 400) >>> find_highest_bid([(1, 400), (2, 300), (3, 200), (1, 100)]) (1, 400) # Your code here","solution":"def find_highest_bid(bids): Find the participant with the highest bid. If there are multiple participants with the same highest bid, return the one with the smallest participant_id. :param bids: List of tuples, where each tuple contains (participant_id, bid_amount) :return: Tuple (participant_id, highest_bid_amount) highest_bids = {} for participant_id, bid_amount in bids: if participant_id not in highest_bids or bid_amount > highest_bids[participant_id]: highest_bids[participant_id] = bid_amount # Find the participant with the highest bid amount max_bid_participant = min(highest_bids.items(), key=lambda x: (-x[1], x[0])) return max_bid_participant"},{"question":"from typing import List def who_wins_game(P: int, test_cases: List[int]) -> List[str]: Determine who will win the game based on the given rules. >>> who_wins_game(2, [7, 5]) ['First', 'Second'] >>> who_wins_game(3, [4, 5, 6]) ['Second', 'First', 'Second']","solution":"def who_wins_game(P, test_cases): results = [] for M in test_cases: if M % 2 == 0: results.append(\\"Second\\") else: results.append(\\"First\\") return results # Example usage: P = 2 test_cases = [7, 5] print(who_wins_game(P, test_cases)) # Output: ['First', 'Second']"},{"question":"def min_jumps_to_reach_target(n: int, m: int, grid: List[List[int]], r: int, c: int, jumps: List[Tuple[int, int]]) -> int: Calculate the minimum number of jumps required to reach a target cell from the starting cell (0, 0) in a given grid. The grid has dimensions n x m and each cell contains a cost value. The allowed jumps are provided in a list of (dx, dy) pairs, representing the allowed directions of jumps. Returns the minimum number of jumps needed to reach the target cell (r, c) from (0, 0). If it is not possible to reach the target, returns -1. >>> n, m = 5, 5 >>> grid = [ >>> [1, 2, 3, 4, 5], >>> [6, 7, 8, 9, 10], >>> [11, 12, 13, 14, 15], >>> [16, 17, 18, 19, 20], >>> [21, 22, 23, 24, 25] >>> ] >>> r, c = 4, 3 >>> jumps = [(2, 1), (1, 0), (-1, 1)] >>> min_jumps_to_reach_target(n, m, grid, r, c, jumps) 4 pass # Unit test cases from solution import min_jumps_to_reach_target def test_min_jumps_basic(): n, m = 5, 5 grid = [ [1, 2, 3, 4, 5], [6, 7, 8, 9, 10], [11, 12, 13, 14, 15], [16, 17, 18, 19, 20], [21, 22, 23, 24, 25] ] r, c = 4, 3 jumps = [(2, 1), (1, 0), (-1, 1)] assert min_jumps_to_reach_target(n, m, grid, r, c, jumps) == 4 def test_min_jumps_unreachable(): n, m = 3, 3 grid = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] r, c = 2, 2 jumps = [(1, 2)] # Can't reach the target with this jump pattern assert min_jumps_to_reach_target(n, m, grid, r, c, jumps) == -1 def test_min_jumps_single_cell(): n, m = 1, 1 grid = [ [1] ] r, c = 0, 0 jumps = [(1, 0)] assert min_jumps_to_reach_target(n, m, grid, r, c, jumps) == 0 def test_min_jumps_adjacent_cell(): n, m = 2, 2 grid = [ [1, 2], [3, 4] ] r, c = 1, 1 jumps = [(1, 1)] assert min_jumps_to_reach_target(n, m, grid, r, c, jumps) == 1 def test_min_jumps_larger_grid(): n, m = 4, 4 grid = [ [10, 30, 20, 50], [40, 20, 30, 60], [30, 20, 20, 10], [20, 10, 10, 60] ] r, c = 3, 3 jumps = [(1, 1), (1, 2), (2, 1)] assert min_jumps_to_reach_target(n, m, grid, r, c, jumps) == 2","solution":"from collections import deque def min_jumps_to_reach_target(n, m, grid, r, c, jumps): def is_within_bounds(x, y): return 0 <= x < n and 0 <= y < m visited = [[False] * m for _ in range(n)] queue = deque([(0, 0, 0)]) # (x, y, number of jumps) visited[0][0] = True while queue: x, y, jumps_count = queue.popleft() if x == r and y == c: return jumps_count for dx, dy in jumps: nx, ny = x + dx, y + dy if is_within_bounds(nx, ny) and not visited[nx][ny]: visited[nx][ny] = True queue.append((nx, ny, jumps_count + 1)) return -1 # If the target is not reachable # Example input n, m = 4, 4 grid = [ [10, 30, 20, 50], [40, 20, 30, 60], [30, 20, 20, 10], [20, 10, 10, 60] ] r, c = 2, 2 jumps = [(1, 3), (0, 0)] # Example output print(min_jumps_to_reach_target(n, m, grid, r, c, jumps))"},{"question":"def is_subsequence(A: str, B: str) -> bool: Given two strings A and B, check if A is a subsequence of B. A string A is considered a subsequence of B if and only if all characters of A can be found in B in the same order, but not necessarily consecutively. Args: A (str): the subsequence to check B (str): the string where we check if A is a subsequence Returns: bool: True if A is a subsequence of B, otherwise False >>> is_subsequence(\\"abc\\", \\"ahbgdc\\") True >>> is_subsequence(\\"axc\\", \\"ahbgdc\\") False","solution":"def is_subsequence(A, B): Check if string A is a subsequence of string B. Args: A (str): the subsequence to check B (str): the string where we check if A is a subsequence Returns: bool: True if A is a subsequence of B, otherwise False iter_B = iter(B) return all(char in iter_B for char in A)"},{"question":"def count_suspicious_cards(n: int, t: int, k: int, log_entries: List[Tuple[int, int]]) -> int: Determine the number of unique cards that have been used in a suspicious manner. >>> count_suspicious_cards(5, 10, 2, [(1, 5), (1, 10), (2, 5), (2, 18), (1, 15)]) == 1 >>> count_suspicious_cards(6, 5, 3, [(1, 0), (1, 2), (1, 3), (2, 2), (1, 4), (1, 5)]) == 1 pass","solution":"def count_suspicious_cards(n, t, k, log_entries): from collections import defaultdict import heapq # Dictionary to maintain logs for each card card_logs = defaultdict(list) # Convert log entries into card logs with sorted entry times for card_id, entry_time in log_entries: heapq.heappush(card_logs[card_id], entry_time) suspicious_cards = set() # Checking each card's entry times for suspicious behavior for card_id, times in card_logs.items(): while len(times) > k: first_time = heapq.heappop(times) if times[k - 1] - first_time <= t: suspicious_cards.add(card_id) break return len(suspicious_cards)"},{"question":"def compress_array(n, arr): Compress the array by removing duplicates while maintaining the relative order of the first occurrence. Args: n (int): the number of integers in the array. arr (list): the array of integers. Returns: tuple: the length of the compressed array and the compressed array itself. pass # Sample Input # n = 8 # arr = [4, 2, 2, 8, 3, 3, 4, 5] # Sample Output # 5 # [4, 2, 8, 3, 5]","solution":"def compress_array(n, arr): Compress the array by removing duplicates while maintaining the relative order of the first occurrence. Args: n (int): the number of integers in the array. arr (list): the array of integers. Returns: tuple: the length of the compressed array and the compressed array itself. seen = set() compressed = [] for number in arr: if number not in seen: seen.add(number) compressed.append(number) return len(compressed), compressed # Sample Input # n = 8 # arr = [4, 2, 2, 8, 3, 3, 4, 5] # Sample Output # 5 # [4, 2, 8, 3, 5]"},{"question":"from typing import List def min_replacements_to_equal_chars(s: str) -> int: Returns the minimum number of replacements needed to make all characters in the string equal. >>> min_replacements_to_equal_chars(\\"abac\\") 2 >>> min_replacements_to_equal_chars(\\"aaaa\\") 0 >>> min_replacements_to_equal_chars(\\"abcde\\") 4","solution":"def min_replacements_to_equal_chars(s): Returns the minimum number of replacements needed to make all characters in the string equal. from collections import Counter # Count the frequency of each character in the string char_count = Counter(s) # Find the maximum frequency of any single character max_freq = max(char_count.values()) # The minimum replacements needed will be the total length minus the max frequency return len(s) - max_freq"},{"question":"def rearrange_array(n, k, a): Determines if it's possible to rearrange array such that the absolute difference between consecutive elements is at most k. Parameters: n (int): Number of integers in the array k (int): Maximum allowed absolute difference a (list): List of integers in the array Returns: str: \\"NO\\" if no rearrangement is possible; otherwise \\"YES\\" list: A possible rearrangement of the array elements # Tests def test_possible_rearrangement(): assert rearrange_array(5, 3, [1, 4, 7, 10, 13]) == (\\"YES\\", [1, 4, 7, 10, 13]) assert rearrange_array(4, 2, [8, 5, 6, 7]) == (\\"YES\\", [5, 6, 7, 8]) def test_impossible_rearrangement(): assert rearrange_array(3, 1, [5, 10, 15]) == (\\"NO\\", []) assert rearrange_array(3, 1, [1,1000000000,1]) == (\\"NO\\", []) def test_already_sorted(): assert rearrange_array(4, 3, [3, 6, 9, 12]) == (\\"YES\\", [3, 6, 9, 12]) def test_random_order(): assert rearrange_array(4, 5, [20, 15, 10, 5]) == (\\"YES\\", [5, 10, 15, 20]) def test_all_elements_same(): assert rearrange_array(5, 3, [7, 7, 7, 7, 7]) == (\\"YES\\", [7, 7, 7, 7, 7])","solution":"def rearrange_array(n, k, a): Determines if it's possible to rearrange array such that the absolute difference between consecutive elements is at most k. Parameters: n (int): Number of integers in the array k (int): Maximum allowed absolute difference a (list): List of integers in the array Returns: str: \\"NO\\" if no rearrangement is possible; otherwise \\"YES\\" list: A possible rearrangement of the array elements a.sort() for i in range(1, n): if abs(a[i] - a[i - 1]) > k: return (\\"NO\\", []) return (\\"YES\\", a)"},{"question":"def rotate_matrix(matrix: List[List[int]]) -> List[List[int]]: Rotates a square matrix 90 degrees clockwise. Args: matrix (List[List[int]]): A n x n list of lists containing integers. Returns: List[List[int]]: The rotated matrix. >>> rotate_matrix([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) [[7, 4, 1], [8, 5, 2], [9, 6, 3]] >>> rotate_matrix([ ... [1, 2, 3, 4], ... [5, 6, 7, 8], ... [9, 10, 11, 12], ... [13, 14, 15, 16] ... ]) [[13, 9, 5, 1], [14, 10, 6, 2], [15, 11, 7, 3], [16, 12, 8, 4]] >>> rotate_matrix([ ... [1, 2], ... [3, 4] ... ]) [[3, 1], [4, 2]] >>> rotate_matrix([ ... [1] ... ]) [[1]]","solution":"def rotate_matrix(matrix): Rotates a square matrix 90 degrees clockwise. Args: matrix (List[List[int]]): A n x n list of lists containing integers. Returns: List[List[int]]: The rotated matrix. n = len(matrix) # Create a new matrix with the same dimension rotated = [[0] * n for _ in range(n)] for i in range(n): for j in range(n): rotated[j][n - 1 - i] = matrix[i][j] return rotated"},{"question":"def find_height_of_new_building(n: int, heights: list[int]) -> int: Finds the height of the new building such that the difference between its height and the height of the tallest building is minimized. Parameters: n (int): Number of buildings in the array heights (list of int): Heights of the buildings Returns: int: Height of the new building >>> find_height_of_new_building(5, [3, 10, 5, 2, 8]) 10 >>> find_height_of_new_building(4, [7, 4, 9, 3]) 9","solution":"def find_height_of_new_building(n, heights): Finds the height of the new building such that the difference between its height and the height of the tallest building is minimized. Parameters: n (int): Number of buildings in the array heights (list of int): Heights of the buildings Returns: int: Height of the new building tallest = max(heights) return tallest"},{"question":"def robots_collide(m: int, n: int) -> (str, int): Determine whether Robot A and Robot B will collide on the grid. If they collide, return \\"YES\\" and the number of moves needed for collision. Otherwise, return \\"NO\\". >>> robots_collide(5, 5) (\\"YES\\", 9) >>> robots_collide(3, 3) (\\"YES\\", 5) >>> robots_collide(2, 4) (\\"NO\\", 0)","solution":"def robots_collide(m, n): Determine whether Robot A and Robot B will collide on the grid. If they collide, return \\"YES\\" and the number of moves needed for collision. Otherwise, return \\"NO\\". # Calculate the number of full rows and full columns # that both robots need to traverse to meet in the middle. if m == n: moves = 2 * (m - 1) return \\"YES\\", moves + 1 else: return \\"NO\\", 0"},{"question":"def merge_sorted_arrays(A: List[int], B: List[int]) -> List[int]: Merges two sorted arrays A and B into a single sorted array C. >>> merge_sorted_arrays([1, 3, 5, 7, 9], [2, 4, 6, 8, 10]) [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] >>> merge_sorted_arrays([10, 20, 30], [15, 25, 35]) [10, 15, 20, 25, 30, 35] >>> merge_sorted_arrays([5], [3]) [3, 5] >>> merge_sorted_arrays([1, 1, 1], [1, 1, 1]) [1, 1, 1, 1, 1, 1] >>> merge_sorted_arrays([1, 2, 3], [4, 5, 6]) [1, 2, 3, 4, 5, 6] >>> merge_sorted_arrays([6, 7, 8], [1, 2, 3]) [1, 2, 3, 6, 7, 8]","solution":"def merge_sorted_arrays(A, B): Merges two sorted arrays A and B into a single sorted array C. n = len(A) C = [] i, j = 0, 0 # Merge arrays A and B while i < n and j < n: if A[i] <= B[j]: C.append(A[i]) i += 1 else: C.append(B[j]) j += 1 # If there are remaining elements in A while i < n: C.append(A[i]) i += 1 # If there are remaining elements in B while j < n: C.append(B[j]) j += 1 return C"},{"question":"def max_contiguous_regions(n: int, m: int, grid: List[str], k: int) -> int: Calculates the maximum number of contiguous black regions using given units of black paint. Parameters: n (int): Number of rows in the grid m (int): Number of columns in the grid grid (list of str): Initial state of the grid k (int): Number of black paint units Returns: int: Maximum number of contiguous black regions Examples: >>> max_contiguous_regions(3, 3, [\\"000\\", \\"000\\", \\"000\\"], 3) 3 >>> max_contiguous_regions(4, 4, [\\"0000\\", \\"0000\\", \\"0000\\", \\"0000\\"], 5) 5 >>> max_contiguous_regions(3, 3, [\\"101\\", \\"010\\", \\"101\\"], 0) 5","solution":"def max_contiguous_regions(n, m, grid, k): Calculates the maximum number of contiguous black regions using given units of black paint. Parameters: n (int): Number of rows in the grid m (int): Number of columns in the grid grid (list of str): Initial state of the grid k (int): Number of black paint units Returns: int: Maximum number of contiguous black regions def get_initial_regions(grid): visited = [[False for _ in range(m)] for _ in range(n)] regions = 0 def dfs(x, y): stack = [(x, y)] while stack: r, c = stack.pop() for dr, dc in [(0, 1), (1, 0), (0, -1), (-1, 0)]: nr, nc = r + dr, c + dc if 0 <= nr < n and 0 <= nc < m and not visited[nr][nc] and grid[nr][nc] == '1': visited[nr][nc] = True stack.append((nr, nc)) for i in range(n): for j in range(m): if grid[i][j] == '1' and not visited[i][j]: visited[i][j] = True dfs(i, j) regions += 1 return regions initial_regions = get_initial_regions(grid) return initial_regions + k"},{"question":"def minimum_seconds_to_meet(x: int, y: int) -> int: Returns the minimum number of seconds Tom and Jerry need to meet at the same position on the number line starting from positions x and y. >>> minimum_seconds_to_meet(5, 5) 0 >>> minimum_seconds_to_meet(3, 6) 3 >>> minimum_seconds_to_meet(-5, 5) 10 >>> minimum_seconds_to_meet(-2, 3) 5 >>> minimum_seconds_to_meet(1000000000, -1000000000) 2000000000","solution":"def minimum_seconds_to_meet(x, y): Returns the minimum number of seconds Tom and Jerry need to meet at the same position on the number line starting from positions x and y. return abs(x - y) # Example usage: # x, y = map(int, input().split()) # print(minimum_seconds_to_meet(x, y))"},{"question":"def adjust_garden_heights(n: int, m: int, grid: List[List[int]]) -> List[List[int]]: Adjust the heights of the flower beds to ensure each row and each column has heights in an increasing sequence, with minimal adjustments. Parameters: n (int): Number of rows. m (int): Number of columns. grid (list of list of int): Initial heights of the flower beds. Returns: list of list of int: New heights of the flower beds. >>> adjust_garden_heights(3, 3, [[3, 2, 5], [1, 3, 4], [2, 4, 6]]) [[1, 2, 3], [2, 3, 4], [3, 4, 5]] >>> adjust_garden_heights(1, 1, [[10]]) [[1]] # Implementation here from typing import List def test_adjust_garden_heights(): grid = [ [3, 2, 5], [1, 3, 4], [2, 4, 6] ] expected_output = [ [1, 2, 3], [2, 3, 4], [3, 4, 5] ] assert adjust_garden_heights(3, 3, grid) == expected_output grid = [ [10] ] expected_output = [ [1] ] assert adjust_garden_heights(1, 1, grid) == expected_output grid = [ [1, 2, 5], [3, 4, 6] ] expected_output = [ [1, 2, 3], [2, 3, 4] ] assert adjust_garden_heights(2, 3, grid) == expected_output grid = [ [1, 3], [2, 4], [3, 5] ] expected_output = [ [1, 2], [2, 3], [3, 4] ] assert adjust_garden_heights(3, 2, grid) == expected_output grid = [ [3, 2, 4, 5], [1, 3, 2, 7], [2, 5, 6, 1] ] expected_output = [ [1, 2, 3, 4], [2, 3, 4, 5], [3, 4, 5, 6] ] assert adjust_garden_heights(3, 4, grid) == expected_output","solution":"def adjust_garden_heights(n, m, grid): Adjusts the heights of the flower beds to maximize beauty while maintaining the required constraints. Ensures that each row and column is incrementing minimally. Parameters: n (int): Number of rows. m (int): Number of columns. grid (list of list of int): Initial heights of the flower beds. Returns: list of list of int: New heights of the flower beds. # Create resulting grid filled initially with zeros new_grid = [[0] * m for _ in range(n)] # Initialize the first row and first column based on sorted unique values for i in range(n): new_grid[i][0] = i + 1 for j in range(m): new_grid[0][j] = j + 1 # Fill the rest of the grid to meet the increasing pattern for i in range(1, n): for j in range(1, m): new_grid[i][j] = max(new_grid[i-1][j], new_grid[i][j-1]) + 1 return new_grid # Example usage if __name__ == \\"__main__\\": n, m = 3, 3 grid = [ [3, 2, 5], [1, 3, 4], [2, 4, 6] ] result = adjust_garden_heights(n, m, grid) for row in result: print(' '.join(map(str, row)))"},{"question":"def max_water(n, a, k, water): Determine the maximum number of water bottles Limak can collect starting from checkpoint a. Parameters: n (int): Number of checkpoints. a (int): Starting checkpoint of Limak. k (int): Maximum number of water bottles Limak can carry. water (List[int]): List of integers where each element is the number of water bottles at each checkpoint. Returns: int: Maximum number of water bottles Limak can collect. Examples: >>> max_water(6, 3, 10, [0, 5, 2, 8, 3, 12]) 10 >>> max_water(5, 2, 5, [1, 2, 3, 4, 5]) 5","solution":"def max_water(n, a, k, water): Returns the maximum number of water bottles Limak can collect without exceeding his carrying capacity. Parameters: n (int): Number of checkpoints. a (int): Starting checkpoint of Limak. k (int): Maximum number of water bottles Limak can carry. water (List[int]): List of integers where each element is the number of water bottles at each checkpoint. Returns: int: Maximum number of water bottles Limak can collect. max_bottles = 0 current_count = 0 # Move to the left from the starting point for i in range(a-1, 0, -1): if current_count < k: if current_count + water[i-1] <= k: current_count += water[i-1] else: current_count = k break else: break # Move to the right from the starting point for i in range(a-1, n): if current_count < k: if current_count + water[i] <= k: current_count += water[i] else: current_count = k break else: break return min(current_count, k)"},{"question":"def merge_sorted_arrays(A, B): Merges two sorted arrays A and B into one sorted array. >>> merge_sorted_arrays([1, 3, 5], [2, 4, 6, 8]) [1, 2, 3, 4, 5, 6, 8] >>> merge_sorted_arrays([-1, 0], [-2, -1, 1]) [-2, -1, -1, 0, 1]","solution":"def merge_sorted_arrays(A, B): Merges two sorted arrays A and B into one sorted array. i, j = 0, 0 C = [] while i < len(A) and j < len(B): if A[i] <= B[j]: C.append(A[i]) i += 1 else: C.append(B[j]) j += 1 while i < len(A): C.append(A[i]) i += 1 while j < len(B): C.append(B[j]) j += 1 return C def process_test_cases(test_cases): results = [] for case in test_cases: A = case['A'] B = case['B'] merged_array = merge_sorted_arrays(A, B) results.append(merged_array) return results"},{"question":"def rearrange(nums: List[int]) -> List[int]: Rearrange the list such that even numbers come before odd numbers, maintaining the relative order of even and odd numbers. >>> rearrange([3, 8, 5, 12, 10, 7, 6]) [8, 12, 10, 6, 3, 5, 7] >>> rearrange([1, 3, 5, 7]) [1, 3, 5, 7] >>> rearrange([2, 4, 6, 8]) [2, 4, 6, 8]","solution":"def rearrange(nums): Rearranges the list such that even numbers come before odd numbers, maintaining the relative order of even and odd numbers. Parameters: nums (list): List of positive integers. Returns: list: Rearranged list. evens = [num for num in nums if num % 2 == 0] odds = [num for num in nums if num % 2 != 0] return evens + odds"},{"question":"def num_paths(grid, n, m, k): Returns the number of distinct paths from the top-left corner to the bottom-right corner of a grid with blockage information taken into account, with the result modulo k. Args: grid (List[List[int]]): 2D list representing the grid where 0 is empty and 1 is blocked. n (int): Number of rows in the grid. m (int): Number of columns in the grid. k (int): Modulo value. Returns: int: The number of distinct paths from (1, 1) to (n, m) modulo k. >>> num_paths([[0, 0, 0], [0, 1, 0], [0, 0, 0]], 3, 3, 1000000007) 2 >>> num_paths([[0, 1], [0, 0]], 2, 2, 10) 1","solution":"def num_paths(grid, n, m, k): Returns the number of distinct paths from the top-left corner to the bottom-right corner of a grid with blockage information taken into account, with the result modulo k. if grid[0][0] == 1 or grid[n-1][m-1] == 1: return 0 dp = [[0 for _ in range(m)] for _ in range(n)] dp[0][0] = 1 for i in range(n): for j in range(m): if grid[i][j] == 1: dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] dp[i][j] %= k return dp[n-1][m-1]"},{"question":"def is_balanced(s: str) -> bool: Determine whether a given string of parentheses is balanced or not. >>> is_balanced(\\"()()\\") == True >>> is_balanced(\\"((()))\\") == True >>> is_balanced(\\"(()(()))\\") == True >>> is_balanced(\\"(()\\") == False >>> is_balanced(\\"))(()\\") == False","solution":"def is_balanced(s: str) -> bool: balance = 0 for char in s: if char == '(': balance += 1 elif char == ')': balance -= 1 if balance < 0: # More closing than opening at any point return False return balance == 0"},{"question":"def max_flowers(T: int, test_cases: List[Tuple[int, List[List[int]]]]) -> List[int]: Find the maximum number of flowers Nina can collect starting from the topmost flower bed and moving to the bottom. Args: T (int): The number of test cases. test_cases (List[Tuple[int, List[List[int]]]]): A list of test cases, where each test case is a tuple containing an integer n (the number of rows in the triangular arrangement) and a list of lists of integers representing the number of flowers in the flower beds. Returns: List[int]: A list of integers representing the maximum number of flowers Nina can collect for each test case. Example: >>> max_flowers(2, [(4, [[3], [7, 4], [2, 4, 6], [8, 5, 9, 3]]), (3, [[1], [2, 3], [4, 5, 6]])]) [23, 10]","solution":"def max_flowers(T, test_cases): def max_flower_path(triangle, n): # Start from the second last row of the triangle and move upwards for i in range(n-2, -1, -1): for j in range(i+1): # Update each element to be the maximum path sum to that element triangle[i][j] += max(triangle[i+1][j], triangle[i+1][j+1]) return triangle[0][0] result = [] for i in range(T): n = test_cases[i][0] triangle = test_cases[i][1] result.append(max_flower_path(triangle, n)) return result"},{"question":"def tsp_min_distance(n: int, distances: List[List[int]]) -> int: Given the number of space stations and a distance matrix, computes the minimum distance to visit each station exactly once and return to the starting point. :param n: Integer, the number of space stations. :param distances: 2D list, the distance matrix. :return: Integer, the minimum distance for the tour. >>> tsp_min_distance(4, [[0, 10, 15, 20], [10, 0, 35, 25], [15, 35, 0, 30], [20, 25, 30, 0]]) == 80 >>> tsp_min_distance(3, [[0, 29, 20], [29, 0, 15], [20, 15, 0]]) == 64 >>> tsp_min_distance(1, [[0]]) == 0 >>> tsp_min_distance(2, [[0, 5], [5, 0]]) == 10 >>> tsp_min_distance(3, [[0, 1, 2], [1, 0, 3], [2, 3, 0]]) == 6 >>> tsp_min_distance(4, [[0, 1, 1, 1], [1, 0, 1, 1], [1, 1, 0, 1], [1, 1, 1, 0]]) == 4 pass","solution":"import itertools def tsp_min_distance(n, distances): Given the number of space stations and a distance matrix, computes the minimum distance to visit each station exactly once and return to the starting point. :param n: Integer, the number of space stations. :param distances: 2D list, the distance matrix. :return: Integer, the minimum distance for the tour. if n == 1: return 0 min_distance = float('inf') # Generate all permutations of stations starting from the 'Home' station 0 for perm in itertools.permutations(range(1, n)): current_distance = 0 prev_station = 0 # Calculate the distance for this permutation for station in perm: current_distance += distances[prev_station][station] prev_station = station # Add distance to return to Home station 0 current_distance += distances[prev_station][0] # Update minimum distance min_distance = min(min_distance, current_distance) return min_distance"},{"question":"def design_network(t: int, h: int, m: int) -> str: Determine the distribution of houses to towers based on the constraints. Parameters: t (int): Number of towers h (int): Total number of houses m (int): Maximum number of houses each tower can serve Returns: str: \\"YES\\" followed by house to tower assignments if possible; \\"NO\\" otherwise. >>> design_network(3, 9, 4) 'YESn1 1n2 1n3 1n4 1n5 2n6 2n7 2n8 3n9 3' >>> design_network(2, 5, 2) 'NO'","solution":"def design_network(t, h, m): Determine the distribution of houses to towers based on the constraints. Parameters: t (int): Number of towers h (int): Total number of houses m (int): Maximum number of houses each tower can serve Returns: str: \\"YES\\" followed by house to tower assignments if possible; \\"NO\\" otherwise. if t * m < h: return \\"NO\\" distribution = [] tower_id = 1 for house_id in range(1, h + 1): distribution.append((house_id, tower_id)) if house_id % m == 0: tower_id += 1 result = \\"YESn\\" result += \\"n\\".join(f\\"{house_id} {tower_id}\\" for house_id, tower_id in distribution) return result"},{"question":"def minimal_travel_costs(n: int, m: int, highways: List[Tuple[int, int, int]]) -> List[int]: Compute the minimum toll cost to travel from the capital city 1 to each city after adjusting tolls. Args: n: the number of cities. m: the number of highways. highways: a list of tuples where each tuple contains three integers u, v, c representing a highway from city u to city v with a current toll fee of c. Returns: A list of integers where the c-th value denotes the minimum toll cost required to travel from the capital city 1 to city c after toll fee adjustments. >>> minimal_travel_costs(4, 5, [(1, 2, 10), (2, 3, 5), (3, 4, 15), (4, 2, 10), (1, 3, 20)]) [0, 10, 15, 30] >>> minimal_travel_costs(3, 3, [(1, 2, 8), (1, 3, 12), (2, 3, 4)]) [0, 8, 12] def test_minimal_travel_costs(): assert minimal_travel_costs(4, 5, [(1, 2, 10), (2, 3, 5), (3, 4, 15), (4, 2, 10), (1, 3, 20)]) == [0, 10, 15, 30] assert minimal_travel_costs(3, 3, [(1, 2, 8), (1, 3, 12), (2, 3, 4)]) == [0, 8, 12] # Running pytest if __name__ == \\"__main__\\": import pytest pytest.main([__file__])","solution":"import heapq def dijkstra(n, edges, src): graph = [[] for _ in range(n + 1)] for u, v, c in edges: graph[u].append((v, c)) min_cost = [float('inf')] * (n + 1) min_cost[src] = 0 pq = [(0, src)] heapq.heapify(pq) while pq: current_cost, u = heapq.heappop(pq) if current_cost > min_cost[u]: continue for v, toll in graph[u]: if min_cost[v] > current_cost + toll: min_cost[v] = current_cost + toll heapq.heappush(pq, (min_cost[v], v)) return min_cost def minimal_travel_costs(n, m, highways): shortest_paths = dijkstra(n, highways, 1) return shortest_paths[1:] # Parsing input in main logic def main(): import sys input = sys.stdin.read data = input().split() n, m = int(data[0]), int(data[1]) highways = [] index = 2 for _ in range(m): u = int(data[index]) v = int(data[index + 1]) c = int(data[index + 2]) highways.append((u, v, c)) index += 3 result = minimal_travel_costs(n, m, highways) print(\\" \\".join(map(str, result))) # Uncomment the following to use for local testing # if __name__ == \\"__main__\\": # main()"},{"question":"from typing import List, Tuple def total_distance(n: int, road_segments: List[Tuple[int, int]]) -> int: Returns the total distance Alex will drive, summing up the shortest distances for each road segment. Parameters: n (int): The number of road segments. road_segments (list of tuples): Each tuple contains two integers representing the distances of a road segment. Returns: int: Total distance in kilometers. pass def test_total_distance_single_segment(): assert total_distance(1, [(10, 15)]) == 15 def test_total_distance_multiple_segments_unique(): assert total_distance(3, [(10, 15), (20, 25), (30, 35)]) == 75 def test_total_distance_multiple_segments_repeated(): assert total_distance(3, [(10, 15), (20, 25), (10, 12)]) == 37 def test_total_distance_multiple_segments_mixed(): assert total_distance(4, [(5, 10), (8, 15), (5, 9), (8, 12)]) == 21 def test_total_distance_edge_case(): assert total_distance(5, [(1, 2), (1, 3), (1, 4), (1, 5), (1, 1)]) == 1","solution":"def total_distance(n, road_segments): Returns the total distance Alex will drive, summing up the shortest distances for each road segment. Parameters: n (int): The number of road segments. road_segments (list of tuples): Each tuple contains two integers representing the distances of a road segment. Returns: int: Total distance in kilometers. segment_dict = {} for a, b in road_segments: if a in segment_dict: segment_dict[a] = min(segment_dict[a], b) else: segment_dict[a] = b return sum(segment_dict.values())"},{"question":"from collections import deque def min_moves_to_reach_bottom_right(N: int, M: int, grid: List[str]) -> int: Find the minimum number of moves required to reach the bottom-right corner of the grid. Args: N : int : number of rows in the grid M : int : number of columns in the grid grid : List[str] : list of strings representing the grid Returns: int : minimum number of moves to reach the bottom-right corner, or -1 if it's not possible Examples: >>> min_moves_to_reach_bottom_right(3, 3, [\\"...\\", \\".#.\\", \\"...\\"]) 4 >>> min_moves_to_reach_bottom_right(3, 3, [\\".#.\\", \\"#\\", \\".#.\\"]) -1","solution":"from collections import deque def min_moves_to_reach_bottom_right(N, M, grid): if grid[0][0] == '#' or grid[N-1][M-1] == '#': return -1 directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] visited = [[False] * M for _ in range(N)] queue = deque([(0, 0, 0)]) visited[0][0] = True while queue: x, y, moves = queue.popleft() if x == N-1 and y == M-1: return moves for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < N and 0 <= ny < M and not visited[nx][ny] and grid[nx][ny] == '.': visited[nx][ny] = True queue.append((nx, ny, moves + 1)) return -1"},{"question":"def min_operations(initial: str, target: str) -> int: Returns the minimum number of operations required to transform the initial word into the target word. >>> min_operations(\\"kitten\\", \\"sitting\\") 3 >>> min_operations(\\"flaw\\", \\"lawn\\") 2 >>> min_operations(\\"intention\\", \\"execution\\") 5","solution":"def min_operations(initial, target): Returns the minimum number of operations required to transform the initial word into the target word. m, n = len(initial), len(target) # create a table to store results of subproblems dp = [[0] * (n + 1) for _ in range(m + 1)] # fill dp table in bottom up manner for i in range(m + 1): for j in range(n + 1): # if first string is empty, we need to insert all characters of second string if i == 0: dp[i][j] = j # if second string is empty, we need to remove all characters of first string elif j == 0: dp[i][j] = i # if last characters are the same, ignore the last character and recur for the remaining substring elif initial[i - 1] == target[j - 1]: dp[i][j] = dp[i - 1][j - 1] # if last character is different, consider all possibilities and find the minimum else: dp[i][j] = 1 + min(dp[i][j - 1], # Insert dp[i - 1][j], # Remove dp[i - 1][j - 1]) # Replace return dp[m][n]"},{"question":"from typing import List def max_sum_with_one_removal(A: List[int]) -> int: This function finds the largest sum of a contiguous subarray within A by removing at most one element. >>> max_sum_with_one_removal([1, -2, 0, 3, -1, 2]) 5 >>> max_sum_with_one_removal([-1, -1, -1, -1]) -1 >>> max_sum_with_one_removal([1, 2, 3, 4, 5]) 15 >>> max_sum_with_one_removal([5, -1, 4, -2, 3]) 11 >>> max_sum_with_one_removal([1, -1, 1, -1, 1]) 2","solution":"def max_sum_with_one_removal(A): This function finds the largest sum of a contiguous subarray within A by removing at most one element. n = len(A) if n == 0: return 0 # Forward pass to find max subarray sum ending in each position max_ending_here = [0] * n max_ending_here[0] = A[0] for i in range(1, n): max_ending_here[i] = max(A[i], max_ending_here[i - 1] + A[i]) # Backward pass to find max subarray sum starting in each position max_starting_here = [0] * n max_starting_here[n - 1] = A[n - 1] for i in range(n - 2, -1, -1): max_starting_here[i] = max(A[i], max_starting_here[i + 1] + A[i]) # Find the maximum sum without any removal max_sum = max(max_ending_here) # Find the maximum sum with one removal for i in range(1, n - 1): max_sum = max(max_sum, max_ending_here[i - 1] + max_starting_here[i + 1]) return max_sum"},{"question":"def minimum_traffic_signals(n: int, m: int, roads: List[Tuple[int, int]]) -> int: Calculate the minimum number of traffic signals required to ensure smooth traffic flow by forming a connected acyclic graph. Parameters: n (int): Number of intersections (nodes) m (int): Number of roads (edges) roads (list): List of tuples, where each tuple contains two integers representing an edge (u, v) Returns: int: Minimum number of traffic signals (nodes) required Examples: >>> minimum_traffic_signals(6, 7, [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (1, 3), (2, 5)]) 5 >>> minimum_traffic_signals(4, 3, [(1, 2), (1, 3), (1, 4)]) 3 >>> minimum_traffic_signals(5, 4, [(1, 2), (2, 3), (3, 4), (4, 5)]) 4 >>> minimum_traffic_signals(1, 0, []) 0 >>> minimum_traffic_signals(10, 9, [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 7), (7, 8), (8, 9), (9, 10)]) 9","solution":"def minimum_traffic_signals(n, m, roads): Returns the minimum number of traffic signals required. Parameters: n (int): Number of intersections (nodes) m (int): Number of roads (edges) roads (list): List of tuples, where each tuple contains two integers representing an edge (u, v) Returns: int: Minimum number of traffic signals (nodes) required return n - 1"},{"question":"def max_books(n: int, thicknesses: List[int], t: int) -> int: Determines the maximum number of books that can be placed on the shelf without exceeding the thickness constraint. :param n: int, the number of books :param thicknesses: list of ints, thickness of each book :param t: int, maximum thickness the shelf can hold >>> max_books(5, [2, 3, 1, 5, 4], 7) 3 >>> max_books(1, [1], 1) 1 >>> max_books(3, [2, 3, 5], 4) 1","solution":"def max_books(n, thicknesses, t): Determines the maximum number of books that can be placed on the shelf without exceeding the thickness constraint. :param n: int, the number of books :param thicknesses: list of ints, thickness of each book :param t: int, maximum thickness the shelf can hold :return: int, the maximum number of books that can be placed on the shelf current_thickness = 0 count = 0 for thickness in thicknesses: if current_thickness + thickness <= t: current_thickness += thickness count += 1 else: break return count"},{"question":"def diagonal_sums(matrix): Given a square matrix, return a tuple with the sum of the main diagonal elements and the sum of the anti-diagonal elements. >>> matrix = [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ] >>> diagonal_sums(matrix) (15, 15) >>> matrix = [ ... [1, 2], ... [3, 4] ... ] >>> diagonal_sums(matrix) (5, 5)","solution":"def diagonal_sums(matrix): Given a square matrix, return a tuple with the sum of the main diagonal elements and the sum of the anti-diagonal elements. n = len(matrix) main_diagonal_sum = sum(matrix[i][i] for i in range(n)) anti_diagonal_sum = sum(matrix[i][n - 1 - i] for i in range(n)) return main_diagonal_sum, anti_diagonal_sum"},{"question":"from itertools import permutations def is_valid_word(word): # This is a placeholder for the actual implementation. # For the purpose of the example, assume a predefined dictionary: valid_words = {\\"loop\\", \\"pool\\", \\"pols\\", \\"spools\\", \\"loops\\"} return word in valid_words def find_lexicographically_smallest_valid_word(S: str) -> str: Generate all possible permutations of the string and find the lexicographically smallest valid English word. >>> find_lexicographically_smallest_valid_word(\\"loop\\") \\"loop\\" >>> find_lexicographically_smallest_valid_word(\\"oloop\\") \\"no valid word\\"","solution":"from itertools import permutations def is_valid_word(word): # This is a placeholder for the actual implementation. # For the purpose of the example, assume a predefined dictionary: valid_words = {\\"loop\\", \\"pool\\", \\"pols\\", \\"spools\\", \\"loops\\"} return word in valid_words def find_lexicographically_smallest_valid_word(S): perm_set = set([''.join(p) for p in permutations(S)]) valid_words = [word for word in perm_set if is_valid_word(word)] if not valid_words: return 'no valid word' return min(valid_words) # Example usage (for demonstration purposes) # print(find_lexicographically_smallest_valid_word(\\"loop\\")) # Expected output: \\"loop\\" # print(find_lexicographically_smallest_valid_word(\\"oloop\\")) # Expected output: \\"no valid word\\""},{"question":"from typing import List def can_reorganize_strings(test_cases: List[str]) -> List[str]: Determines if it is possible to rearrange the string so that no two adjacent characters are the same. Args: test_cases (List[str]): List of test case strings. Returns: List[str]: List of \\"YES\\" or \\"NO\\" for each test case. >>> can_reorganize_strings([\\"aab\\", \\"aa\\", \\"abc\\"]) [\\"YES\\", \\"NO\\", \\"YES\\"] >>> can_reorganize_strings([\\"aaabbb\\", \\"aaaab\\"]) [\\"YES\\", \\"NO\\"] >>> can_reorganize_strings([\\"a\\", \\"ab\\"]) [\\"YES\\", \\"YES\\"]","solution":"from collections import Counter import heapq def can_reorganize_string(s): Determines if it's possible to rearrange the string so that no two adjacent characters are the same. # Count frequency of each character freq = Counter(s) # Create a max-heap based on the frequencies max_heap = [(-count, char) for char, count in freq.items()] heapq.heapify(max_heap) prev_count, prev_char = 0, '' rearranged_str = [] while max_heap: count, char = heapq.heappop(max_heap) rearranged_str.append(char) # If there's a previously deferred character, push it back to the heap if prev_count < 0: heapq.heappush(max_heap, (prev_count, prev_char)) # Update previous character and count prev_count, prev_char = count+1, char # increment count because we're using -ve values # Check if the rearranged string has the same length as the original return \\"YES\\" if len(rearranged_str) == len(s) else \\"NO\\" def can_reorganize_strings(test_cases): results = [] for s in test_cases: results.append(can_reorganize_string(s)) return results"},{"question":"def find_shortest_subarray(n, m, playlist, favorites): Given the original playlist, find the shortest contiguous segment (subarray) of the playlist that contains all her favorite song IDs. If there are multiple such segments, return the one that starts first. >>> find_shortest_subarray(10, 3, [5, 1, 2, 3, 4, 3, 2, 1, 5, 4], [1, 3, 5]) (1, 4) >>> find_shortest_subarray(7, 2, [8, 3, 7, 4, 2, 1, 6], [4, 1]) (4, 6) >>> find_shortest_subarray(5, 1, [1, 2, 3, 4, 5], [5]) (5, 5) >>> find_shortest_subarray(5, 2, [2, 3, 4, 1, 5], [1, 5]) (4, 5) >>> find_shortest_subarray(5, 1, [4, 3, 2, 1, 5], [1]) (4, 4) >>> find_shortest_subarray(10, 3, [10, 9, 1, 2, 3, 4, 5, 8, 7, 6], [2, 3, 4]) (4, 6) >>> find_shortest_subarray(6, 3, [7, 1, 2, 3, 5, 8], [1, 3, 5]) (2, 5)","solution":"def find_shortest_subarray(n, m, playlist, favorites): from collections import defaultdict favorite_set = set(favorites) count_map = defaultdict(int) left = 0 min_length = float('inf') min_left, min_right = 0, 0 match_count = 0 for right in range(n): if playlist[right] in favorite_set: if count_map[playlist[right]] == 0: match_count += 1 count_map[playlist[right]] += 1 while match_count == m: if (right - left) < min_length: min_length = right - left min_left, min_right = left, right if playlist[left] in favorite_set: count_map[playlist[left]] -= 1 if count_map[playlist[left]] == 0: match_count -= 1 left += 1 return min_left + 1, min_right + 1"},{"question":"from collections import deque, defaultdict from typing import List, Tuple def bfs_for_furthest_node(start_node: int, tree: defaultdict) -> Tuple[int, int]: visited = set() max_distance = 0 furthest_node = start_node queue = deque([(start_node, 0)]) while queue: node, distance = queue.popleft() if distance > max_distance: max_distance = distance furthest_node = node visited.add(node) for neighbor in tree[node]: if neighbor not in visited: queue.append((neighbor, distance + 1)) return furthest_node, max_distance def tree_diameter(N: int, edges: List[Tuple[int, int]]) -> int: Determine the diameter of an undirected tree given its edges. Parameters: N (int): Number of vertices in the tree. edges (List[Tuple[int, int]]): List of edges in the tree, where each edge is a tuple of two integers representing connected vertices. Returns: int: The length of the longest path between any two nodes in the tree. Examples: >>> tree_diameter(5, [(1, 2), (1, 3), (3, 4), (3, 5)]) 3 >>> tree_diameter(3, [(1, 2), (2, 3)]) 2 >>> tree_diameter(1, []) 0 >>> tree_diameter(2, [(1, 2)]) 1 >>> tree_diameter(5, [(1, 2), (2, 3), (3, 4), (4, 5)]) 4 >>> tree_diameter(5, [(1, 2), (1, 3), (1, 4), (1, 5)]) 2 # Your implementation here","solution":"from collections import deque, defaultdict def bfs_for_furthest_node(start_node, tree): visited = set() max_distance = 0 furthest_node = start_node queue = deque([(start_node, 0)]) while queue: node, distance = queue.popleft() if distance > max_distance: max_distance = distance furthest_node = node visited.add(node) for neighbor in tree[node]: if neighbor not in visited: queue.append((neighbor, distance + 1)) return furthest_node, max_distance def tree_diameter(N, edges): if N == 1: return 0 tree = defaultdict(list) for u, v in edges: tree[u].append(v) tree[v].append(u) # First BFS to find the furthest node from an arbitrary start node (node 1) furthest_node, _ = bfs_for_furthest_node(1, tree) # Second BFS from the furthest node found to get the diameter _, diameter_length = bfs_for_furthest_node(furthest_node, tree) return diameter_length"},{"question":"def is_rotated(s: str, r: str) -> bool: Determines if \`r\` is a valid rotation of \`s\`. Parameters: s (str): The original string. r (str): The potential rotated version of the string. Returns: bool: True if \`r\` is a valid rotation of \`s\`, False otherwise. Examples: >>> is_rotated(\\"abcde\\", \\"cdeab\\") True >>> is_rotated(\\"abcde\\", \\"abced\\") False","solution":"def is_rotated(s: str, r: str) -> bool: Determines if \`r\` is a valid rotation of \`s\`. Parameters: s (str): The original string. r (str): The potential rotated version of the string. Returns: bool: True if \`r\` is a valid rotation of \`s\`, False otherwise. if len(s) != len(r): return False # Concatenate s with itself and see if r is a substring return r in (s + s)"},{"question":"def is_playable(n: int, ammo: int, max_ammo: int, actions: str) -> str: Determine if a given round of actions is playable based on initial and maximum ammunition. >>> is_playable(5, 3, 5, 'SRSSR') == \\"Playable\\" >>> is_playable(4, 2, 3, 'SSSS') == \\"Unplayable\\" >>> is_playable(6, 0, 4, 'RRSRRS') == \\"Playable\\" >>> is_playable(3, 1, 2, 'SSS') == \\"Unplayable\\"","solution":"def is_playable(n, ammo, max_ammo, actions): for action in actions: if action == 'S': if ammo == 0: return \\"Unplayable\\" ammo -= 1 elif action == 'R': ammo = max_ammo return \\"Playable\\""},{"question":"def max_unique_chars(S: str, X: int) -> int: Returns the maximum number of unique characters that can be obtained in string S after performing exactly X replacement operations. >>> max_unique_chars(\\"abcabc\\", 3) 6 >>> max_unique_chars(\\"aaaaa\\", 2) 3 >>> max_unique_chars(\\"abcdefghijklmnopqrstuvwxyza\\", 26) 26","solution":"def max_unique_chars(S, X): Returns the maximum number of unique characters that can be obtained in string S after performing exactly X replacement operations. # Initial set of unique characters in the string unique_chars = set(S) # Number of unique characters currently in the string num_unique_chars = len(unique_chars) # Maximum possible unique characters is 26 (total lowercase english letters) max_possible_unique_chars = 26 # Max number of unique characters we can achieve max_unique = min(max_possible_unique_chars, num_unique_chars + X) return max_unique"},{"question":"from typing import List def minimum_difference(n: int, skill_levels: List[int]) -> int: Find the minimum possible difference in the sum of skill levels between two teams. >>> minimum_difference(4, [1, 2, 3, 4]) 0 >>> minimum_difference(3, [2, 3, 5]) 0 >>> minimum_difference(2, [5, 8]) 3 >>> minimum_difference(5, [1, 1, 1, 1, 1]) 1 >>> minimum_difference(6, [10, 20, 30, 40, 50, 60]) 10 def process_input(data: List[str]) -> List[int]: Process the input data to calculate the minimum difference for each dataset. >>> process_input([\\"4\\", \\"1 2 3 4\\", \\"3\\", \\"2 3 5\\", \\"0\\"]) [0, 0] >>> process_input([\\"2\\", \\"5 8\\", \\"5\\", \\"1 1 1 1 1\\", \\"0\\"]) [3, 1] >>> process_input([\\"6\\", \\"10 20 30 40 50 60\\", \\"0\\"]) [10]","solution":"from itertools import combinations def minimum_difference(n, skill_levels): total_sum = sum(skill_levels) half_sum = total_sum // 2 closest_sum = 0 # Generate all possible subsets and find the one closest to half_sum for i in range(n + 1): for subset in combinations(skill_levels, i): subset_sum = sum(subset) if subset_sum <= half_sum: closest_sum = max(closest_sum, subset_sum) return total_sum - 2 * closest_sum def process_input(data): index = 0 results = [] while index < len(data): n = int(data[index]) if n == 0: break skill_levels = list(map(int, data[index + 1].split())) results.append(minimum_difference(n, skill_levels)) index += 2 return results"},{"question":"def is_path_possible(n: int, m: int, grid: List[str]) -> str: Determine if there is a path from the start 'S' to the exit 'E' in a grid-based map. The map is represented as a 2D grid of characters, where: - 'S' represents the starting point, - 'E' represents the exit point, - '.' represents an empty walkable space, - '#' represents an obstacle. Parameters: n (int): Number of rows in the grid. m (int): Number of columns in the grid. grid (List[str]): List of strings representing the grid map. Returns: str: \\"YES\\" if there is a path from 'S' to 'E', otherwise \\"NO\\". Examples: >>> n = 5 >>> m = 5 >>> grid = [ ... \\"S...#\\", ... \\"..#\\", ... \\".#..#\\", ... \\"....#\\", ... \\"#.E\\" ... ] >>> is_path_possible(n, m, grid) \\"YES\\" >>> n = 4 >>> m = 4 >>> grid = [ ... \\"S...\\", ... \\"\\", ... \\"...#\\", ... \\"...E\\" ... ] >>> is_path_possible(n, m, grid) \\"NO\\"","solution":"def is_path_possible(n, m, grid): from collections import deque # Finding the starting point S for i in range(n): for j in range(m): if grid[i][j] == 'S': start = (i, j) elif grid[i][j] == 'E': end = (i, j) # Directions array for 4 possible movements (right, left, down, up) directions = [(0, 1), (0, -1), (1, 0), (-1, 0)] # Queue for BFS queue = deque([start]) visited = set() visited.add(start) while queue: x, y = queue.popleft() # If we reached the end point if (x, y) == end: return \\"YES\\" for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and (nx, ny) not in visited and grid[nx][ny] != '#': queue.append((nx, ny)) visited.add((nx, ny)) return \\"NO\\""},{"question":"def validate_email(email: str) -> str: Check if the provided email address is valid based on certain criteria. An email address is valid if: 1. It contains exactly one '@' symbol. 2. The local part (before the '@' symbol) is non-empty and contains only alphanumeric characters. 3. The domain part (after the '@' symbol) consists of one or more labels separated by periods ('.'). Each label must be non-empty and consist only of alphanumeric characters. >>> validate_email(\\"example@domain.com\\") 'VALID' >>> validate_email(\\"example@@domain.com\\") 'INVALID' >>> validate_email(\\"@domain.com\\") 'INVALID' >>> validate_email(\\"example@domain..com\\") 'INVALID' >>> validate_email(\\"example@domain.\\") 'INVALID' >>> validate_email(\\"example@domain.c#m\\") 'INVALID' >>> validate_email(\\"exa!ple@domain.com\\") 'INVALID' >>> validate_email(\\"example@sub.domain.com\\") 'VALID'","solution":"def validate_email(email: str) -> str: This function checks whether a given email address is valid based on the specified criteria. if email.count('@') != 1: return \\"INVALID\\" local_part, domain_part = email.split('@', 1) if not local_part.isalnum(): return \\"INVALID\\" domain_labels = domain_part.split('.') if any(not label.isalnum() for label in domain_labels) or any(len(label) == 0 for label in domain_labels): return \\"INVALID\\" return \\"VALID\\""},{"question":"def is_possible_permutation(t, test_cases): Determine if it's possible to reorder the sequence to form a permutation of numbers from 1 to n such that the absolute difference between any two consecutive numbers is at most one. Args: t (int): Number of test cases. test_cases (List[Tuple[int, List[int]]]): List of test cases, where each test case contains an integer n and a list of n integers representing the sequence. Returns: List[str]: List of \\"YES\\" or \\"NO\\" for each test case. >>> is_possible_permutation(3, [(6, [3, 1, 4, 2, 6, 5]), (3, [1, 3, 2]), (4, [1, 2, 3, 5])]) == [\\"YES\\", \\"YES\\", \\"NO\\"] >>> is_possible_permutation(1, [(2, [2, 1])]) == [\\"YES\\"] >>> is_possible_permutation(1, [(3, [3, 1, 2])]) == [\\"YES\\"] >>> is_possible_permutation(2, [(5, [1, 2, 3, 4, 5]), (3, [1, 4, 2])]) == [\\"YES\\", \\"NO\\"] >>> is_possible_permutation(1, [(4, [4, 1, 3, 2])]) == [\\"YES\\"]","solution":"def is_possible_permutation(t, test_cases): results = [] for i in range(t): n, sequence = test_cases[i] sequence.sort() possible = True for j in range(1, n): if abs(sequence[j] - sequence[j - 1]) > 1: possible = False break if possible: results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def unique_paths_with_obstacles(grid: List[List[int]]) -> int: Implement a function that simulates a robot navigating an MxN grid. The robot starts at the top-left corner (0, 0) and can move either to the right or down one cell at a time. However, some cells contain obstacles, making them impassable for the robot. The function should determine the number of unique paths the robot can take to reach the bottom-right corner (M-1, N-1). >>> unique_paths_with_obstacles([ ... [0, 0, 0], ... [0, 1, 0], ... [0, 0, 0]]) 2 >>> unique_paths_with_obstacles([ ... [0, 0, 0], ... [0, 0, 0], ... [0, 0, 0]]) 6","solution":"from typing import List def unique_paths_with_obstacles(grid: List[List[int]]) -> int: if not grid or grid[0][0] == 1: return 0 m, n = len(grid), len(grid[0]) dp = [[0] * n for _ in range(m)] dp[0][0] = 1 for i in range(m): for j in range(n): if grid[i][j] == 1: dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[m-1][n-1]"},{"question":"import time import base64 import random import string def generate_session_id() -> str: Generates a unique identifier for a user's session. The identifier consists of a base32 encoded current timestamp in milliseconds since epoch and a random 6-character alphanumeric string. Returns: str: A unique session identifier. >>> len(generate_session_id()) > 6 True >>> len(set(generate_session_id() for _ in range(1000))) == 1000 True pass from solution import generate_session_id def test_generate_session_id_length(): session_id = generate_session_id() # Check that the length of the session ID is reasonable and consistent with the encoding scheme assert len(session_id) == len(base64.b32encode((int(time.time() * 1000)).to_bytes((int(time.time() * 1000).bit_length() + 7) // 8, 'big')).decode('utf-8').rstrip('=')) + 6 def test_generate_session_id_uniqueness(): session_ids = set(generate_session_id() for _ in range(1000)) # Ensure that all generated session IDs are unique assert len(session_ids) == 1000 def test_generate_session_id_format(): session_id = generate_session_id() base32_part = session_id[:-6] random_part = session_id[-6:] # Check that the base32 part is valid try: base64.b32decode(base32_part + '======') except Exception: assert False, \\"Base32 part is not valid\\" # Check that the random part is alphanumeric assert all(c in string.ascii_letters + string.digits for c in random_part) def test_generate_session_id_random_part_length(): session_id = generate_session_id() random_part = session_id[-6:] # Ensure the random part's length is 6 assert len(random_part) == 6","solution":"import time import base64 import random import string def generate_session_id(): Generates a unique identifier for a user's session. The identifier consists of a base32 encoded current timestamp in milliseconds since epoch and a random 6-character alphanumeric string. Returns: str: A unique session identifier. # Get current timestamp in milliseconds since epoch timestamp = int(time.time() * 1000) # Base32 encode the timestamp base32_timestamp = base64.b32encode(timestamp.to_bytes((timestamp.bit_length() + 7) // 8, 'big')).decode('utf-8').rstrip('=') # Generate random 6-character alphanumeric string random_string = ''.join(random.choices(string.ascii_letters + string.digits, k=6)) # Combine both parts to get the session ID session_id = f\\"{base32_timestamp}{random_string}\\" return session_id"},{"question":"def longest_unique_subarray(a: List[int], queries: List[Tuple[int, int]]) -> List[int]: For each query, determine the length of the longest subarray with unique elements in the range [l, r]. Parameters: a: List[int] - the array of integers queries: List[Tuple[int, int]] - list of queries, each query is a tuple (l, r) Returns: List[int] - list of results for each query >>> longest_unique_subarray([4, 3, 5, 2, 4, 6, 3, 2], [(1, 5), (2, 7), (3, 8)]) [4, 5, 5] >>> longest_unique_subarray([1, 2, 3, 4, 5], [(1, 3), (1, 5), (2, 4)]) [3, 5, 3] >>> longest_unique_subarray([1, 1, 1, 1], [(1, 4)]) [1] >>> longest_unique_subarray([1, 2, 3, 1, 2, 3, 4], [(1, 4), (1, 7), (3, 6)]) [3, 4, 3] >>> longest_unique_subarray([], []) []","solution":"def longest_unique_subarray(a, queries): For each query, determine the length of the longest subarray with unique elements in the range [l, r]. Parameters: a: List[int] - the array of integers queries: List[Tuple[int, int]] - list of queries, each query is a tuple (l, r) Returns: List[int] - list of results for each query results = [] for l, r in queries: seen = {} max_len = 0 curr_len = 0 start = 0 for i in range(l-1, r): if a[i] in seen and seen[a[i]] >= start: start = seen[a[i]] + 1 curr_len = i - start + 1 else: curr_len += 1 seen[a[i]] = i max_len = max(max_len, curr_len) results.append(max_len) return results"},{"question":"from collections import deque from typing import List def min_steps_to_treasure(n: int, m:int, maze: List[str]) -> int: Calculate the minimum number of steps required to reach the treasure in the maze. If it's not possible, return -1. >>> min_steps_to_treasure(5, 5, [ \\".....\\", \\".#.\\", \\"...#.\\", \\".#...\\", \\".....\\"]) == 8 >>> min_steps_to_treasure(4, 4, [ \\"\\", \\"#..#\\", \\"#..#\\", \\"\\"]) == -1","solution":"from collections import deque def min_steps_to_treasure(n, m, maze): # Check if the start or the end positions are blocked if maze[0][0] == '#' or maze[n-1][m-1] == '#': return -1 # Directions for moving in the maze (up, down, left, right) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # Queue for BFS with starting point queue = deque([(0, 0, 0)]) # (x, y, steps) visited = set((0, 0)) while queue: x, y, steps = queue.popleft() # If we reach the treasure position if x == n-1 and y == m-1: return steps for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and (nx, ny) not in visited and maze[nx][ny] == '.': queue.append((nx, ny, steps + 1)) visited.add((nx, ny)) # If there is no way to the treasure position return -1"},{"question":"def longest_common_substring(s1: str, s2: str) -> int: Returns the length of the longest common substring between s1 and s2. >>> longest_common_substring(\\"abcde\\", \\"abfce\\") 2 >>> longest_common_substring(\\"abcdef\\", \\"zcdemn\\") 3 >>> longest_common_substring(\\"abc\\", \\"def\\") 0 >>> longest_common_substring(\\"abcdxyz\\", \\"xyzabcd\\") 4 >>> longest_common_substring(\\"zxabcdezy\\", \\"yzabcdezx\\") 6 # Your code here # Unit Tests def test_longest_common_substring(): assert longest_common_substring(\\"abcde\\", \\"abfce\\") == 2 assert longest_common_substring(\\"abcdef\\", \\"zcdemn\\") == 3 assert longest_common_substring(\\"abc\\", \\"def\\") == 0 assert longest_common_substring(\\"abcdxyz\\", \\"xyzabcd\\") == 4 assert longest_common_substring(\\"zxabcdezy\\", \\"yzabcdezx\\") == 6 assert longest_common_substring(\\"abcdxyz\\", \\"xyzabcdabc\\") == 4 assert longest_common_substring(\\"pqrstu\\", \\"stuvwx\\") == 3 assert longest_common_substring(\\"\\", \\"abc\\") == 0 assert longest_common_substring(\\"abc\\", \\"\\") == 0 assert longest_common_substring(\\"\\", \\"\\") == 0 assert longest_common_substring(\\"a\\", \\"a\\") == 1 assert longest_common_substring(\\"abc\\", \\"abc\\") == 3 assert longest_common_substring(\\"abc\\", \\"def\\") == 0","solution":"def longest_common_substring(s1, s2): Returns the length of the longest common substring between s1 and s2. m, n = len(s1), len(s2) # Create a 2D list (DP table) initialized to 0 dp = [[0] * (n + 1) for _ in range(m + 1)] max_length = 0 # Fill the dp table for i in range(1, m + 1): for j in range(1, n + 1): if s1[i - 1] == s2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 max_length = max(max_length, dp[i][j]) return max_length"},{"question":"def largest_palindrome_length(test_cases: List[str]) -> List[int]: Determine the length of the largest palindrome that can be created using characters from each given string. >>> largest_palindrome_length([\\"abccccdd\\", \\"a\\"]) [7, 1] >>> largest_palindrome_length([\\"x\\"]) [1] >>> largest_palindrome_length([\\"abcdef\\"]) [1] >>> largest_palindrome_length([\\"aabbcc\\"]) [6] >>> largest_palindrome_length([\\"aaabbbb\\"]) [7] >>> largest_palindrome_length([\\"abccccdd\\", \\"a\\", \\"bb\\", \\"xyz\\", \\"abccba\\"]) [7, 1, 2, 1, 6]","solution":"def largest_palindrome_length(test_cases): from collections import Counter results = [] for s in test_cases: count = Counter(s) length = 0 odd_found = False for val in count.values(): if val % 2 == 0: length += val else: length += val - 1 odd_found = True if odd_found: length += 1 results.append(length) return results"},{"question":"def max_trees(n: int, m: int) -> int: Given the dimensions of the garden, returns the maximum number of trees that can be planted following the described constraints. >>> max_trees(3, 3) 3 >>> max_trees(5, 4) 4 >>> max_trees(6, 10) 6 >>> max_trees(1, 1) 1 >>> max_trees(1000000000, 1000000000) 1000000000 >>> max_trees(1000000000, 999999999) 999999999","solution":"def max_trees(n, m): Given the dimensions of the garden, returns the maximum number of trees that can be planted following the described constraints. return min(n, m)"},{"question":"def solve_input(input_str): Given a string representation of multiple test cases of grids with obstacles, this function returns the length of the shortest path from the top-left corner to the bottom-right corner for each grid. If no such path exists, -1 is returned. Parameters: input_str (str): A string containing the number of test cases and the grid details. Returns: List[int]: A list where each element is the shortest path length for the corresponding grid. Example: >>> input_str = \\"2n4 4n....n..n....n....n3 3n.#.n#n.#.n\\" >>> solve_input(input_str) [6, -1] from collections import deque def shortest_path(grid): Helper function to find the shortest path in a grid with walls. This function uses breadth-first search (BFS) to navigate the grid. Parameters: grid (List[List[str]]): The grid representation with walls and empty cells. Returns: int: The length of the shortest path from top-left to bottom-right, or -1 if no path exists. def parse_input(input_str): Helper function to parse the input string into test cases for the grid problem. Parameters: input_str (str): A string containing the input for the grid problem. Returns: List[List[List[str]]]: A list of grid representations for each test case. def solve(test_cases): Helper function to solve multiple test cases of the grid problem. Parameters: test_cases (List[List[List[str]]]): A list of grid representations for each test case. Returns: List[int]: A list of results for each test case, indicating the shortest path length.","solution":"from collections import deque def shortest_path(grid): n = len(grid) m = len(grid[0]) directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] def is_valid(r, c): return 0 <= r < n and 0 <= c < m and grid[r][c] == '.' queue = deque([(0, 0, 0)]) # (row, col, distance) grid[0][0] = '#' # mark as visited while queue: row, col, dist = queue.popleft() if row == n - 1 and col == m - 1: return dist for dr, dc in directions: new_row, new_col = row + dr, col + dc if is_valid(new_row, new_col): queue.append((new_row, new_col, dist + 1)) grid[new_row][new_col] = '#' return -1 def solve(test_cases): results = [] for grid in test_cases: results.append(shortest_path(grid)) return results # Function to read input for the problem def parse_input(input_str): lines = input_str.strip().split(\\"n\\") t = int(lines[0]) index = 1 test_cases = [] for _ in range(t): n, m = map(int, lines[index].split()) grid = [list(lines[index + i + 1]) for i in range(n)] index += n + 1 test_cases.append(grid) return test_cases def solve_input(input_str): test_cases = parse_input(input_str) results = solve(test_cases) return results"},{"question":"def calculate_final_scores(T, data): Calculate the final scores for sports teams after a series of events. Args: T (int): The number of test cases. data (List[Tuple[int, List[Tuple[str, int]]]]): A list containing tuples for each test case. Each tuple contains an integer N (number of events), followed by a list of events. Each event is represented as a tuple with a string S (team's name) and an integer X (change in score). Returns: str: The final scores of each team for each test case in the format specified. Example: >>> data = [(3, [(\\"TeamA\\", 10), (\\"TeamB\\", -5), (\\"TeamA\\", 20)])] >>> print(calculate_final_scores(1, data)) Case #1: TeamA: 30 TeamB: -5","solution":"def calculate_final_scores(T, data): results = [] for case_number in range(T): N = data[case_number][0] events = data[case_number][1] scores = {} for event in events: team = event[0] score_change = event[1] if team not in scores: scores[team] = score_change else: scores[team] += score_change result = [f\\"Case #{case_number + 1}:\\"] for team, score in sorted(scores.items()): result.append(f\\"{team}: {score}\\") results.append(\\"n\\".join(result)) return \\"n\\".join(results) # Example usage input_data = [ (3, [(\\"TeamA\\", 10), (\\"TeamB\\", -5), (\\"TeamA\\", 20)]), (2, [(\\"TeamC\\", 15), (\\"TeamC\\", -10)]) ] print(calculate_final_scores(2, input_data))"},{"question":"def max_widgets_produced(n: int, T: int, rates: List[int]) -> int: Calculate the maximum widgets produced by all workers in one day given at most one swap of machines. Parameters: n (int): Number of workers T (int): Number of hours the factory operates per day rates (list): List of widget production rate per hour for each worker Returns: int: Maximum number of widgets produced # Function implementation here def test_max_widgets_produced(): # Test Case 1: Given Example Test 1 n, T = 3, 10 rates = [5, 3, 8] assert max_widgets_produced(n, T, rates) == 160 # Test Case 2: Given Example Test 2 n, T = 4, 5 rates = [2, 8, 3, 7] assert max_widgets_produced(n, T, rates) == 100 # Test Case 3: Smallest Example n, T = 1, 1 rates = [1] assert max_widgets_produced(n, T, rates) == 1 # Test Case 4: Swaps not affecting outcome n, T = 5, 2 rates = [1, 2, 3, 4, 5] assert max_widgets_produced(n, T, rates) == 30 # Test Case 5: All same rates n, T = 4, 3 rates = [2, 2, 2, 2] assert max_widgets_produced(n, T, rates) == 24","solution":"def max_widgets_produced(n, T, rates): Calculate the maximum widgets produced by all workers in one day given at most one swap of machines. Parameters: n (int): Number of workers T (int): Number of hours the factory operates per day rates (list): List of widget production rate per hour for each worker Returns: int: Maximum number of widgets produced # Initial production without any swap total_production = sum(rates) * T return total_production"},{"question":"def min_game_score(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Calculate the minimum possible score Peter can achieve after following the rules of the game. >>> min_game_score(3, [(3, [1, 2, 3]), (4, [4, 1, 2, 3]), (2, [10, 5])]) [6, 10, 15] >>> min_game_score(1, [(3, [7, 8, 9])]) [24]","solution":"def min_game_score(t, test_cases): results = [] for i in range(t): n = test_cases[i][0] array = test_cases[i][1] while len(array) > 1: min_sum = float('inf') pos = -1 # Find the smallest sum of adjacent elements for j in range(len(array) - 1): if array[j] + array[j+1] < min_sum: min_sum = array[j] + array[j+1] pos = j # Replace the elements with their sum array[pos] = min_sum del array[pos+1] results.append(array[0]) return results"},{"question":"def is_possible_k_partitions(N: int, K: int, A: List[int]) -> int: Ensure Unique Elements in K-Fold Repetitions >>> is_possible_k_partitions(6, 2, [1, 2, 3, 3, 2, 1]) == 1 >>> is_possible_k_partitions(7, 3, [1, 2, 3, 4, 5, 6, 7]) == 0 >>> is_possible_k_partitions(6, 3, [1, 1, 1, 1, 1, 1]) == 0 >>> is_possible_k_partitions(1, 1, [1]) == 1 >>> is_possible_k_partitions(6, 4, [1, 2, 3, 4, 5, 6]) == 0 >>> is_possible_k_partitions(6, 3, [1, 1, 2, 2, 3, 3]) == 1 >>> is_possible_k_partitions(6, 2, [1, 1, 1, 2, 2, 2]) == 0","solution":"def is_possible_k_partitions(N, K, A): from collections import Counter if N % K != 0: return 0 subarray_size = N // K element_counts = Counter(A) if any(count > K for count in element_counts.values()): return 0 return 1"},{"question":"import heapq from typing import List, Tuple def dijkstra(n: int, graph: dict, start: int) -> dict: Implements Dijkstra's algorithm to find the shortest paths from start node to all other nodes. # function body (implementation not shown) pass def solve(n: int, edges: List[Tuple[int, int, int]], queries: List[Tuple[int, int]]) -> List[str]: Given the list of edges and queries, this function solves for the shortest path using Dijkstra's algorithm. >>> solve(5, [(1, 2, 1), (1, 3, 4), (2, 3, 2), (2, 4, 7), (3, 5, 3), (4, 5, 1), (1, 5, 8)], [(1, 5), (2, 5), (4, 1)]) [6, 5, \\"No Path\\"] >>> solve(3, [], [(1, 2), (2, 3)]) [\\"No Path\\", \\"No Path\\"] >>> solve(3, [(1, 2, 1)], [(1, 2), (2, 1)]) [1, \\"No Path\\"] >>> solve(2, [(1, 2, 5)], [(1, 2)]) [5] >>> solve(4, [(1, 2, 1), (2, 4, 5), (1, 3, 2), (3, 4, 1), (4, 2, 3)], [(1, 4)]) [3] # function body (implementation not shown) pass def parse_input(input_str: str) -> Tuple[int, List[Tuple[int, int, int]], List[Tuple[int, int]]]: Parses the input. >>> parse_input(\\"5n7n1 2 1n1 3 4n2 3 2n2 4 7n3 5 3n4 5 1n1 5 8n3n1 5n2 5n4 1\\") (5, [(1, 2, 1), (1, 3, 4), (2, 3, 2), (2, 4, 7), (3, 5, 3), (4, 5, 1), (1, 5, 8)], [(1, 5), (2, 5), (4, 1)]) # function body (implementation not shown) pass","solution":"import heapq def dijkstra(n, graph, start): Implements Dijkstra's algorithm to find the shortest paths from start node to all other nodes. distances = {i: float('inf') for i in range(1, n+1)} distances[start] = 0 priority_queue = [(0, start)] while priority_queue: current_distance, current_node = heapq.heappop(priority_queue) if current_distance > distances[current_node]: continue for neighbor, weight in graph[current_node]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return distances def solve(n, edges, queries): Given the list of edges and queries, this function solves for the shortest path using Dijkstra's algorithm. graph = {i: [] for i in range(1, n+1)} for u, v, w in edges: graph[u].append((v, w)) results = [] for a, b in queries: distances = dijkstra(n, graph, a) if distances[b] == float('inf'): results.append(\\"No Path\\") else: results.append(distances[b]) return results def parse_input(input_str): Parses the input. lines = input_str.strip().split(\\"n\\") n = int(lines[0]) m = int(lines[1]) edges = [] for i in range(2, 2 + m): u, v, w = map(int, lines[i].split()) edges.append((u, v, w)) q = int(lines[2 + m]) queries = [] for i in range(3 + m, 3 + m + q): a, b = map(int, lines[i].split()) queries.append((a, b)) return n, edges, queries # Sample usage: input_str = 5 7 1 2 1 1 3 4 2 3 2 2 4 7 3 5 3 4 5 1 1 5 8 3 1 5 2 5 4 1 n, edges, queries = parse_input(input_str) print(solve(n, edges, queries))"},{"question":"def josephus(n: int, k: int) -> int: Solves the Josephus problem. :param n: int: The number of soldiers (1 ≤ n ≤ 30) :param k: int: The step rate (1 ≤ k ≤ n) :return: int: The position of the last remaining soldier (1-based index) >>> josephus(7, 3) 4 >>> josephus(5, 2) 3 >>> josephus(1, 1) 1 >>> josephus(10, 10) 8 >>> josephus(14, 2) 13 >>> josephus(30, 1) 30","solution":"def josephus(n, k): Solves the Josephus problem. :param n: int: The number of soldiers (1 ≤ n ≤ 30) :param k: int: The step rate (1 ≤ k ≤ n) :return: int: The position of the last remaining soldier (1-based index) # List to represent the soldiers soldiers = list(range(1, n + 1)) index = 0 while len(soldiers) > 1: index = (index + k - 1) % len(soldiers) soldiers.pop(index) return soldiers[0]"},{"question":"def find_n_ary_palindromes(n: int, k: int) -> List[str]: Write a function that takes an integer \`n\` and returns a list of all possible n-ary palindromic numbers within the range 0 to n^k - 1, where k is also given as an input. A number is considered n-ary palindromic if it reads the same forward and backward in base-n. >>> find_n_ary_palindromes(2, 3) ['000', '010', '101', '111'] >>> find_n_ary_palindromes(10, 2) ['00', '11', '22', '33', '44', '55', '66', '77', '88', '99'] >>> find_n_ary_palindromes(16, 1) ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F']","solution":"from typing import List def find_n_ary_palindromes(n: int, k: int) -> List[str]: Returns a list of all possible n-ary palindromic numbers of length k. Each number is represented as a string. def is_palindrome(s: str) -> bool: return s == s[::-1] def int_to_n_base(num: int, base: int) -> str: digits = \\"0123456789ABCDEF\\" if num == 0: return \\"0\\" result = [] while num: result.append(digits[num % base]) num //= base return ''.join(result[::-1]) palindromes = [] for num in range(n**k): n_base_num = int_to_n_base(num, n) padded_num = n_base_num.zfill(k) if len(padded_num) == k and is_palindrome(padded_num): palindromes.append(padded_num) return sorted(palindromes)"},{"question":"from typing import List def can_form_palindrome(s: str) -> bool: Returns True if the string s can be rearranged to form a palindrome, otherwise False. >>> can_form_palindrome(\\"aabb\\") == True >>> can_form_palindrome(\\"code\\") == False >>> can_form_palindrome(\\"carerac\\") == True pass def process_test_cases(test_cases: List[str]) -> List[str]: Processes multiple test cases and returns the results in the proper format. >>> process_test_cases([\\"aabb\\", \\"code\\", \\"carerac\\"]) == [\\"Case #1:YES\\", \\"Case #2:NO\\", \\"Case #3:YES\\"] >>> process_test_cases([\\"abc\\", \\"aaa\\", \\"ab\\"]) == [\\"Case #1:NO\\", \\"Case #2:YES\\", \\"Case #3:NO\\"] pass","solution":"def can_form_palindrome(s): Returns True if the string s can be rearranged to form a palindrome, otherwise False. from collections import Counter char_counts = Counter(s) odd_count = sum(1 for count in char_counts.values() if count % 2 != 0) return odd_count <= 1 def process_test_cases(test_cases): Processes multiple test cases and returns the results in the proper format. test_cases is a list of strings. results = [] for i, case in enumerate(test_cases): if can_form_palindrome(case): results.append(f\\"Case #{i + 1}:YES\\") else: results.append(f\\"Case #{i + 1}:NO\\") return results"},{"question":"def count_divisible_by_3_and_5(a, b): Returns the number of integers in the inclusive range [a, b] that are divisible by both 3 and 5. >>> count_divisible_by_3_and_5(1, 15) 1 >>> count_divisible_by_3_and_5(10, 30) 2 >>> count_divisible_by_3_and_5(100, 200) 7 def piglet_divisibles(t, tests): Returns a list of results for t test cases. Each result is the number of integers divisible by both 3 and 5 in the inclusive range [a, b]. >>> piglet_divisibles(3, [(1, 15), (10, 30), (100, 200)]) [1, 2, 7] >>> piglet_divisibles(2, [(35, 80), (1, 14)]) [3, 0] >>> piglet_divisibles(1, [(15, 15)]) [1] >>> piglet_divisibles(1, [(10, 10)]) [0]","solution":"def count_divisible_by_3_and_5(a, b): Returns the number of integers in the inclusive range [a, b] that are divisible by both 3 and 5. # 15 is the lowest common multiple of 3 and 5. lcm = 15 if a > b: a, b = b, a start = (a + lcm - 1) // lcm # First multiple of 15 in the range end = b // lcm # Last multiple of 15 in the range return end - start + 1 def piglet_divisibles(t, tests): Returns a list of results for t test cases. Each result is the number of integers divisible by both 3 and 5 in the inclusive range [a, b]. results = [] for a, b in tests: results.append(count_divisible_by_3_and_5(a, b)) return results"},{"question":"def count_divisible_subarrays(n: int, k: int, sequence: List[int]) -> int: Returns the number of subarrays where the sum of its elements is divisible by k. :param n: int, length of the sequence :param k: int, integer k :param sequence: list of int, elements of the sequence :return: int, number of subarrays with sum divisible by k >>> count_divisible_subarrays(5, 3, [1, 2, 3, 4, 1]) 4 >>> count_divisible_subarrays(6, 4, [4, 4, 4, 4, 4, 4]) 21 import pytest def test_example_case(): assert count_divisible_subarrays(5, 3, [1, 2, 3, 4, 1]) == 4 def test_all_elements_equal_k(): assert count_divisible_subarrays(6, 4, [4, 4, 4, 4, 4, 4]) == 21 def test_single_element(): assert count_divisible_subarrays(1, 5, [5]) == 1 assert count_divisible_subarrays(1, 2, [1]) == 0 def test_empty_sequence(): assert count_divisible_subarrays(0, 1, []) == 0 def test_large_k(): assert count_divisible_subarrays(5, 1000, [1, 2, 3, 4, 5]) == 0 def test_large_array(): assert count_divisible_subarrays(100000, 1, [1] * 100000) == (100000 * (100000 + 1)) // 2 if __name__ == \\"__main__\\": pytest.main()","solution":"def count_divisible_subarrays(n, k, sequence): Returns the number of subarrays where the sum of its elements is divisible by k. :param n: int, length of the sequence :param k: int, integer k :param sequence: list of int, elements of the sequence :return: int, number of subarrays with sum divisible by k prefix_sums = [0] * (n + 1) mod_count = [0] * k mod_count[0] = 1 # There's one subarray (empty one) with sum 0 which is divisible by any k. current_sum = 0 result = 0 for num in sequence: current_sum += num modulo = current_sum % k result += mod_count[modulo] mod_count[modulo] += 1 return result"},{"question":"def can_book_room(room_name: str, start_time: int, end_time: int, existing_bookings: List[dict]) -> bool: Returns True if the room can be booked without overlapping with existing bookings, False otherwise. >>> can_book_room(\\"Room A\\", 10, 12, [{\\"start\\": 9, \\"end\\": 10, \\"room\\": \\"Room A\\"}, {\\"start\\": 11, \\"end\\": 13, \\"room\\": \\"Room A\\"}, {\\"start\\": 14, \\"end\\": 16, \\"room\\": \\"Room B\\"}]) == False >>> can_book_room(\\"Room B\\", 10, 12, [{\\"start\\": 9, \\"end\\": 10, \\"room\\": \\"Room A\\"}, {\\"start\\": 11, \\"end\\": 13, \\"room\\": \\"Room A\\"}, {\\"start\\": 14, \\"end\\": 16, \\"room\\": \\"Room B\\"}]) == True pass","solution":"def can_book_room(room_name, start_time, end_time, existing_bookings): Returns True if the room can be booked without overlapping with existing bookings, False otherwise. for booking in existing_bookings: if booking[\\"room\\"] == room_name: if not (end_time <= booking[\\"start\\"] or start_time >= booking[\\"end\\"]): return False return True"},{"question":"def knapsack(n: int, W: int, items: List[Tuple[int, int]]) -> int: Determine the maximum value a player can carry without exceeding the weight capacity. Parameters: n (int): Number of items W (int): Maximum weight capacity items (list of tuples): List of tuples where each tuple (wi, vi) represents the weight and value of each item respectively. Returns: int: Maximum value that the player can carry. # Your code here from typing import List, Tuple def test_knapsack_example1(): n = 4 W = 10 items = [(5, 10), (4, 40), (6, 30), (3, 50)] assert knapsack(n, W, items) == 90 def test_knapsack_example2(): n = 3 W = 50 items = [(10, 60), (20, 100), (30, 120)] assert knapsack(n, W, items) == 220 def test_knapsack_small_capacity(): n = 3 W = 1 items = [(1, 10), (2, 20), (3, 30)] assert knapsack(n, W, items) == 10 def test_knapsack_zero_items(): n = 0 W = 10 items = [] assert knapsack(n, W, items) == 0 def test_knapsack_all_items_fitting(): n = 3 W = 10 items = [(1, 10), (2, 20), (3, 30)] assert knapsack(n, W, items) == 60","solution":"def knapsack(n, W, items): Determine the maximum value a player can carry without exceeding the weight capacity Parameters: n (int): Number of items W (int): Maximum weight capacity items (list of tuples): List of tuples where each tuple (wi, vi) represents the weight and value of each item respectively Returns: int: Maximum value that the player can carry # Initialize a 2D list for dynamic programming dp = [[0 for _ in range(W+1)] for _ in range(n+1)] for i in range(1, n+1): weight, value = items[i-1] for w in range(W+1): if weight <= w: dp[i][w] = max(dp[i-1][w], dp[i-1][w-weight] + value) else: dp[i][w] = dp[i-1][w] return dp[n][W]"},{"question":"def find_min_diff(t: int, test_cases: List[Tuple[Tuple[int, int], List[int], List[int]]]) -> List[int]: Find the pair (one dish and one side) with the smallest absolute difference in their taste scores. Args: t (int): Number of test cases. test_cases (List[Tuple[Tuple[int, int], List[int], List[int]]]): A list where each element is a tuple containing (D, S) and two lists for taste scores of dishes and sides respectively. Returns: List[int]: A list of integers representing the smallest absolute difference of taste scores for each test case. Examples: >>> find_min_diff(2, [((3, 3), [1, 3, 15], [10, 2, 20]), ((4, 4), [5, 10, 15, 40], [35, 25, 30, 50])]) [1, 5] pass def process_input(input_data: str) -> Tuple[int, List[Tuple[Tuple[int, int], List[int], List[int]]]]: Process the input data into a format suitable for find_min_diff function. Args: input_data (str): Input data in string format. Returns: Tuple containing number of test cases and a list of test cases. Examples: >>> process_input(\\"2n3 3n1 3 15n10 2 20n4 4n5 10 15 40n35 25 30 50\\") (2, [((3, 3), [1, 3, 15], [10, 2, 20]), ((4, 4), [5, 10, 15, 40], [35, 25, 30, 50])]) pass","solution":"def find_min_diff(t, test_cases): results = [] for case in test_cases: d, s = case[0] dishes = sorted(case[1]) sides = sorted(case[2]) i, j = 0, 0 min_diff = float('inf') while i < d and j < s: min_diff = min(min_diff, abs(dishes[i] - sides[j])) if dishes[i] < sides[j]: i += 1 else: j += 1 results.append(min_diff) return results def process_input(input_data): lines = input_data.strip().split(\\"n\\") T = int(lines[0]) test_cases = [] index = 1 for _ in range(T): D, S = map(int, lines[index].split()) dishes = list(map(int, lines[index + 1].split())) sides = list(map(int, lines[index + 2].split())) test_cases.append(((D, S), dishes, sides)) index += 3 return T, test_cases input_data = 2 3 3 1 3 15 10 2 20 4 4 5 10 15 40 35 25 30 50 T, test_cases = process_input(input_data) results = find_min_diff(T, test_cases) print(results)"},{"question":"def process_operations(input_data: str) -> list: Processes a series of string operations and returns the final strings for each test case. Parameters: input_data (str): The input data containing multiple test cases and operations. Returns: list: A list of final strings for each test case. If a string is empty, it returns \\"EMPTY\\". >>> process_operations(\\"3nAPPEND anAPPEND bnDELETEn4nAPPEND xnDELETEnAPPEND ynAPPEND zn0\\") [\\"a\\", \\"yz\\"] >>> process_operations(\\"2nAPPEND anDELETEn1nDELETEn0\\") [\\"EMPTY\\", \\"EMPTY\\"] >>> process_operations(\\"1nAPPEND xn1nDELETEn0\\") [\\"x\\", \\"EMPTY\\"] >>> process_operations(\\"5nAPPEND anAPPEND bnDELETEnDELETEnDELETEn0\\") [\\"EMPTY\\"] >>> process_operations(\\"0\\") []","solution":"def process_operations(input_data): Processes a series of string operations and returns the final strings for each test case. Parameters: input_data (str): The input data containing multiple test cases and operations. Returns: list: A list of final strings for each test case. If a string is empty, it returns \\"EMPTY\\". lines = input_data.strip().split('n') result = [] index = 0 while index < len(lines): n = int(lines[index]) if n == 0: break final_string = [] for i in range(index + 1, index + 1 + n): operation = lines[i] if operation.startswith(\\"APPEND\\"): _, char = operation.split() final_string.append(char) elif operation == \\"DELETE\\": if final_string: final_string.pop() if final_string: result.append(''.join(final_string)) else: result.append(\\"EMPTY\\") index += n + 1 return result"},{"question":"def longest_consecutive_subsequence(arr): Returns the length of the longest subsequence of consecutive integers in arr. >>> longest_consecutive_subsequence([]) == 0 >>> longest_consecutive_subsequence([1]) == 1 >>> longest_consecutive_subsequence([1, 9, 3, 10, 4, 20, 2, 8, 11, 21]) == 4 >>> longest_consecutive_subsequence([5, 4, 3, 2, 1]) == 5 >>> longest_consecutive_subsequence([10, 20, 30, 40]) == 1 >>> longest_consecutive_subsequence([-1, -2, -3, 0, 1, 2]) == 6 >>> longest_consecutive_subsequence([1, 2, 2, 3, 4]) == 4","solution":"def longest_consecutive_subsequence(arr): Returns the length of the longest subsequence of consecutive integers in arr. if not arr: return 0 arr = set(arr) max_length = 0 for num in arr: if num - 1 not in arr: current_length = 1 current_num = num while current_num + 1 in arr: current_length += 1 current_num += 1 max_length = max(max_length, current_length) return max_length"},{"question":"import math from typing import List, Tuple def smallest_enclosing_circle(n: int, points: List[Tuple[int, int]]) -> Tuple[float, float, float]: You are given a data set consisting of n distinct points in two-dimensional space. Your task is to find the smallest circle that can contain all the given points. Parameters: n (int): The number of points. points (List[Tuple[int, int]]): A list of tuples representing the coordinates of the points. Returns: Tuple[float, float, float]: Three real numbers cx, cy, and r, where (cx, cy) are the coordinates of the center of the smallest enclosing circle, and r is its radius. These numbers must be precise to at least six decimal places. >>> smallest_enclosing_circle(3, [(1, 1), (2, 2), (3, 3)]) (2.000000, 2.000000, 1.414214) >>> smallest_enclosing_circle(4, [(0, 0), (0, 2), (2, 0), (2, 2)]) (1.000000, 1.000000, 1.414214)","solution":"import math from typing import List, Tuple class Circle: def __init__(self, x: float = 0.0, y: float = 0.0, r: float = 0.0): self.x = x self.y = y self.r = r def dist(a: Tuple[float, float], b: Tuple[float, float]) -> float: return math.sqrt((a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2) def is_in_circle(circle: Circle, point: Tuple[float, float]) -> bool: return dist((circle.x, circle.y), point) <= circle.r + 1e-9 def make_circle_two_points(a: Tuple[float, float], b: Tuple[float, float]) -> Circle: cx = (a[0] + b[0]) / 2 cy = (a[1] + b[1]) / 2 r = dist(a, b) / 2 return Circle(cx, cy, r) def make_circle_three_points(a: Tuple[float, float], b: Tuple[float, float], c: Tuple[float, float]) -> Circle: A = b[0] - a[0] B = b[1] - a[1] C = c[0] - a[0] D = c[1] - a[1] E = A * (a[0] + b[0]) + B * (a[1] + b[1]) F = C * (a[0] + c[0]) + D * (a[1] + c[1]) G = 2 * (A * (c[1] - b[1]) - B * (c[0] - b[0])) if G == 0: return Circle() cx = (D * E - B * F) / G cy = (A * F - C * E) / G r = dist((cx, cy), a) return Circle(cx, cy, r) def find_smallest_enclosing_circle(points: List[Tuple[int, int]]) -> Circle: def welzl_recursive(points: List[Tuple[int, int]], boundary: List[Tuple[int, int]], n: int) -> Circle: if n == 0 or len(boundary) == 3: if len(boundary) == 0: return Circle() elif len(boundary) == 1: return Circle(boundary[0][0], boundary[0][1], 0) elif len(boundary) == 2: return make_circle_two_points(boundary[0], boundary[1]) elif len(boundary) == 3: return make_circle_three_points(boundary[0], boundary[1], boundary[2]) p = points[n-1] circle = welzl_recursive(points, boundary, n-1) if is_in_circle(circle, p): return circle return welzl_recursive(points, boundary + [p], n-1) points_copy = points[:] return welzl_recursive(points_copy, [], len(points_copy)) def smallest_enclosing_circle(n: int, points: List[Tuple[int, int]]) -> Tuple[float, float, float]: circle = find_smallest_enclosing_circle(points) return (circle.x, circle.y, circle.r)"},{"question":"from typing import List import heapq def findKthSmallest(matrix: List[List[int]], k: int) -> int: Finds the kth smallest element in a sorted matrix. The matrix is arranged in non-decreasing order both row-wise and column-wise. Parameters: matrix (List[List[int]]): A list of lists of integers representing the sorted matrix. k (int): An integer representing the kth position (1-based index). Returns: int: The kth smallest element in the matrix. Examples: >>> findKthSmallest([[1, 5, 7], [3, 7, 8], [4, 8, 9]], 5) 7 >>> findKthSmallest([[1, 3], [2, 4]], 2) 2","solution":"import heapq def findKthSmallest(matrix, k): Finds the kth smallest element in a sorted matrix. :param matrix: List[List[int]] - A list of lists of integers representing the sorted matrix :param k: int - An integer representing the kth position (1-based index) :return: int - The kth smallest element in the matrix min_heap = [] # Insert the first element of each row into the min heap along with the row and column information for r in range(len(matrix)): heapq.heappush(min_heap, (matrix[r][0], r, 0)) # Remove the smallest element from the min-heap k times while k > 0: element, r, c = heapq.heappop(min_heap) # If the next element in the row exists, push it into the heap if c + 1 < len(matrix[0]): heapq.heappush(min_heap, (matrix[r][c + 1], r, c + 1)) k -= 1 return element"},{"question":"def calculate_artifacts_and_remaining_stones(n: int) -> (int, int): Calculate the number of artifacts that can be created and the number of remaining magic stones. Arguments: n -- The number of magic stones (0 ≤ n ≤ 10^9). Returns: A tuple (artifacts, remaining_stones) where: - artifacts is the maximum number of artifacts that can be created. - remaining_stones is the number of magic stones remaining after artifact creation. Example usage: >>> calculate_artifacts_and_remaining_stones(10) (3, 1) >>> calculate_artifacts_and_remaining_stones(7) (2, 1)","solution":"def calculate_artifacts_and_remaining_stones(n): Calculate the number of artifacts that can be created and the number of remaining magic stones. Arguments: n -- The number of magic stones (0 ≤ n ≤ 10^9). Returns: A tuple (artifacts, remaining_stones) where: - artifacts is the maximum number of artifacts that can be created. - remaining_stones is the number of magic stones remaining after artifact creation. artifacts = n // 3 remaining_stones = n % 3 return artifacts, remaining_stones # Example usage: # print(calculate_artifacts_and_remaining_stones(10)) # Output: (3, 1) # print(calculate_artifacts_and_remaining_stones(7)) # Output: (2, 1) # print(calculate_artifacts_and_remaining_stones(3)) # Output: (1, 0) # print(calculate_artifacts_and_remaining_stones(1)) # Output: (0, 1)"},{"question":"from typing import List def longest_substring_with_k_distinct(s: str, k: int) -> str: Write a Python function that takes two arguments, a string \`s\` consisting of only lowercase English letters and an integer \`k\`. The function should return the longest substring of \`s\` that contains at most \`k\` distinct characters. If there are multiple substrings with the same length, return the one which occurs first. >>> longest_substring_with_k_distinct(\\"araaci\\", 2) \\"araa\\" >>> longest_substring_with_k_distinct(\\"cbbebi\\", 3) \\"cbbeb\\" Unit Test: from solution import longest_substring_with_k_distinct def test_empty_string(): assert longest_substring_with_k_distinct(\\"\\", 2) == \\"\\" def test_zero_k(): assert longest_substring_with_k_distinct(\\"anything\\", 0) == \\"\\" def test_single_character(): assert longest_substring_with_k_distinct(\\"a\\", 1) == \\"a\\" assert longest_substring_with_k_distinct(\\"a\\", 2) == \\"a\\" def test_example_1(): assert longest_substring_with_k_distinct(\\"araaci\\", 2) == \\"araa\\" def test_example_2(): assert longest_substring_with_k_distinct(\\"cbbebi\\", 3) == \\"cbbeb\\" def test_multiple_max_substrings(): assert longest_substring_with_k_distinct(\\"ababab\\", 2) == \\"ababab\\" def test_large_k(): assert longest_substring_with_k_distinct(\\"abcde\\", 5) == \\"abcde\\" def test_no_restriction(): assert longest_substring_with_k_distinct(\\"aaa\\", 3) == \\"aaa\\" def test_exact_k_distinct(): assert longest_substring_with_k_distinct(\\"aabbcc\\", 3) == \\"aabbcc\\"","solution":"def longest_substring_with_k_distinct(s, k): Returns the longest substring of s that contains at most k distinct characters. If there are multiple substrings with the same length, the first one is returned. from collections import defaultdict n = len(s) if n == 0 or k == 0: return \\"\\" left = 0 right = 0 max_len = 0 max_substring = \\"\\" char_count = defaultdict(int) while right < n: char_count[s[right]] += 1 while len(char_count) > k: char_count[s[left]] -= 1 if char_count[s[left]] == 0: del char_count[s[left]] left += 1 if right - left + 1 > max_len: max_len = right - left + 1 max_substring = s[left:right + 1] right += 1 return max_substring"},{"question":"def count_paths(n: int, m: int, k: int, blocked_cells: List[Tuple[int, int]]) -> int: Calculate the number of different ways to reach the cell (n, m) from (1, 1) without stepping on any blocked cells, modulo 998244353. Args: n: Number of rows in the grid. m: Number of columns in the grid. k: Number of blocked cells. blocked_cells: List of blocked cell coordinates. Returns: The number of ways to reach (n, m) from (1, 1), modulo 998244353. Examples: >>> count_paths(3, 3, 1, [(2, 2)]) == 2 >>> count_paths(3, 3, 2, [(2, 2), (3, 1)]) == 1 >>> count_paths(3, 3, 3, [(1, 2), (2, 1), (2, 2)]) == 0","solution":"def count_paths(n, m, k, blocked_cells): MOD = 998244353 dp = [[0] * m for _ in range(n)] if (1, 1) in blocked_cells or (n, m) in blocked_cells: return 0 dp[0][0] = 1 blocked_set = set((x - 1, y - 1) for x, y in blocked_cells) for i in range(n): for j in range(m): if (i, j) in blocked_set: dp[i][j] = 0 elif i == 0 and j == 0: continue else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] dp[i][j] %= MOD return dp[n-1][m-1]"},{"question":"from typing import List def generate_interesting_sequence(N: int, K: int, M: int) -> List[int]: Generate an interesting sequence of length N where: 1. For all 2 <= i <= N, |ai - ai-1| <= K. 2. The sum of the sequence S is divisible by M. Parameters: N (int): length of the sequence K (int): maximum allowable difference between consecutive elements M (int): divisor for the sum of the sequence Returns: List[int]: sequence of integers that meet the criteria Examples: >>> generate_interesting_sequence(5, 3, 10) [1, 4, 1, 4, 0] >>> generate_interesting_sequence(3, 2, 5) [2, 4, 3]","solution":"def generate_interesting_sequence(N, K, M): Generate an interesting sequence of length N where 1. For all 2 <= i <= N, |ai - ai-1| <= K. 2. The sum of the sequence S is divisible by M. Parameters: N (int): length of the sequence K (int): maximum allowable difference between consecutive elements M (int): divisor for the sum of the sequence Returns: List[int]: sequence of integers that meet the criteria # Generate a base sequence where all differences are <= K base_sequence = [i % (K + 1) for i in range(N)] # Calculate the sum of the base sequence base_sum = sum(base_sequence) # Find the adjustment required to make the sum divisible by M remainder = base_sum % M adjustment = (-remainder) % M # Apply the adjustment to the first element (we know adjustment will be <= K) base_sequence[0] += adjustment return base_sequence"},{"question":"from typing import List, Tuple def find_connected_computers(n: int, m: int, k: int, connections: List[Tuple[int, int]], broken_cables: List[int]) -> int: Determine the number of computers connected to the main server (computer 1) after considering the broken cables. >>> find_connected_computers(5, 4, 1, [(1, 2), (2, 3), (1, 4), (4, 5)], [2]) 4 >>> find_connected_computers(6, 5, 2, [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6)], [3, 5]) 3","solution":"def find_connected_computers(n, m, k, connections, broken_cables): from collections import defaultdict, deque # Create adjacency list graph = defaultdict(list) for i, (u, v) in enumerate(connections): if i+1 not in broken_cables: graph[u].append(v) graph[v].append(u) # BFS to find all connected nodes starting from node 1 def bfs(start, graph): visited = set() queue = deque([start]) while queue: node = queue.popleft() if node not in visited: visited.add(node) for neighbor in graph[node]: if neighbor not in visited: queue.append(neighbor) return visited connected_computers = bfs(1, graph) return len(connected_computers)"},{"question":"def can_split_sequence(N: int, sequence: List[int], K: int) -> str: Determines if it's possible to split the sequence into exactly two non-empty contiguous subsequences such that the sum of the prefix is exactly K. Parameters: N (int): The size of the sequence. sequence (list of int): The sequence of integers. K (int): The sum that the prefix should match. Returns: str: \\"YES\\" if such a split is possible, otherwise \\"NO\\". >>> can_split_sequence(5, [4, 3, -1, 2, 1], 7) \\"YES\\" >>> can_split_sequence(3, [1, 2, 3], 10) \\"NO\\" from solution import can_split_sequence def test_can_split_sequence_yes(): assert can_split_sequence(5, [4, 3, -1, 2, 1], 7) == \\"YES\\" assert can_split_sequence(2, [1, 1], 1) == \\"YES\\" assert can_split_sequence(5, [1, 2, 3, 4, 5], 10) == \\"YES\\" assert can_split_sequence(6, [-1, -2, -3, 6, -1, -2], -6) == \\"YES\\" def test_can_split_sequence_no(): assert can_split_sequence(3, [1, 2, 3], 10) == \\"NO\\" assert can_split_sequence(1, [1], 1) == \\"NO\\" assert can_split_sequence(4, [1, 2, 3, 4], 11) == \\"NO\\" assert can_split_sequence(5, [-1, -1, -1, -1, -1], 0) == \\"NO\\"","solution":"def can_split_sequence(N, sequence, K): Determines if it's possible to split the sequence into exactly two non-empty contiguous subsequences such that the sum of the prefix is exactly K. Parameters: N (int): The size of the sequence. sequence (list of int): The sequence of integers. K (int): The sum that the prefix should match. Returns: str: \\"YES\\" if such a split is possible, otherwise \\"NO\\". current_sum = 0 for i in range(N - 1): # Iterate up to the second to last element current_sum += sequence[i] if current_sum == K: return \\"YES\\" return \\"NO\\""},{"question":"def calculate_fuel_cost(distance, efficiency, price_per_liter, budget): Returns the total fuel cost for a trip and the amount by which it exceeds the budget if applicable. >>> calculate_fuel_cost(500, 20, 70, 2000) (1750, 0) >>> calculate_fuel_cost(600, 15, 85, 3000) (3400, 400) pass def format_output(total_cost, budget_exceed): Formats the output based on whether the total cost exceeds the budget or not. >>> format_output(1750, 0) '1750' >>> format_output(3400, 400) '3400 400' pass","solution":"def calculate_fuel_cost(distance, efficiency, price_per_liter, budget): Returns the total fuel cost for a trip and the amount by which it exceeds the budget if applicable. total_cost = (distance / efficiency) * price_per_liter if total_cost > budget: return total_cost, total_cost - budget else: return total_cost, 0 def format_output(total_cost, budget_exceed): Formats the output based on whether the total cost exceeds the budget or not. if budget_exceed > 0: return f\\"{int(total_cost)} {int(budget_exceed)}\\" else: return f\\"{int(total_cost)}\\""},{"question":"def is_fibonacci(n: int) -> str: Determine if a given number is part of the Fibonacci sequence. >>> is_fibonacci(21) 'Yes' >>> is_fibonacci(22) 'No'","solution":"def is_fibonacci(n): Returns 'Yes' if the given number is a Fibonacci number, otherwise returns 'No'. if n < 0: return \\"No\\" a, b = 0, 1 while a <= n: if a == n: return \\"Yes\\" a, b = b, a + b return \\"No\\""},{"question":"def has_repeated_subsequence(s: str) -> str: Returns 'YES' if the string contains any repeated subsequences of length three or more, 'NO' otherwise. def check_repeated_subsequences(t: int, test_cases: List[str]) -> List[str]: Determines if each intercepted communication string contains any repeated subsequences of length three or more. Args: t: The number of test cases. test_cases: A list of strings representing the intercepted communication. Returns: A list of results, \\"YES\\" or \\"NO\\" for each test case. >>> check_repeated_subsequences(3, [\\"abc\\", \\"abcdabc\\", \\"abcabcabc\\"]) ['NO', 'YES', 'YES'] >>> check_repeated_subsequences(2, [\\"abcd\\", \\"defghi\\"]) ['NO', 'NO'] >>> check_repeated_subsequences(1, [\\"abcdefghhgfedcba\\"]) ['NO'] >>> check_repeated_subsequences(2, [\\"aaaaaaaaaa\\", \\"ababababab\\"]) ['YES', 'YES'] >>> check_repeated_subsequences(2, [\\"a\\", \\"ab\\"]) ['NO', 'NO']","solution":"def has_repeated_subsequence(s): Returns 'YES' if the string contains any repeated subsequences of length three or more, 'NO' otherwise. n = len(s) if n < 3: return \\"NO\\" # Create a dictionary to store the frequency of subsequences subseq_dict = {} # Iterate through all possible subsequence lengths for length in range(3, n + 1): for i in range(n - length + 1): subseq = s[i:i + length] if subseq in subseq_dict: return \\"YES\\" subseq_dict[subseq] = True return \\"NO\\" def check_repeated_subsequences(t, test_cases): results = [] for s in test_cases: results.append(has_repeated_subsequence(s)) return results"},{"question":"def max_groups(n: int, k: int, spending_values: List[int]) -> int: Returns the maximum number of groups that can be formed where each group has exactly k customers. :param n: Number of customers :param k: Required number of customers per group :param spending_values: List of spending values of the customers :return: Maximum number of groups >>> max_groups(6, 3, [10, 20, 30, 40, 50, 60]) 2 >>> max_groups(8, 2, [5, 10, 15, 20, 25, 30, 35, 40]) 4 >>> max_groups(10, 1, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) 10 >>> max_groups(7, 3, [10, 20, 30, 40, 50, 60, 70]) 2 >>> max_groups(5, 5, [100, 200, 300, 400, 500]) 1 >>> max_groups(4, 2, [1, 2, 3, 4]) 2 >>> max_groups(9, 3, [10, 20, 30, 40, 50, 60, 70, 80, 90]) 3 >>> max_groups(10, 5, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) 2","solution":"def max_groups(n, k, spending_values): Returns the maximum number of groups that can be formed where each group has exactly k customers. :param n: Number of customers :param k: Required number of customers per group :param spending_values: List of spending values of the customers :return: Maximum number of groups return n // k"},{"question":"def count_groups(N: int, K: int) -> int: Determine the number of possible ways to form non-overlapping groups of exactly K people. Each group should consist of K people, and you should use all N people in the line to form such groups. If it's not possible to form such groups, return 0. >>> count_groups(8, 2) 28 >>> count_groups(6, 3) 20 >>> count_groups(10, 5) 252 >>> count_groups(7, 2) 21","solution":"import math def count_groups(N, K): if K == 1: return 1 # Calculate the number of ways to pick K people out of N with required constraints possible_groups = math.comb(N, K) return possible_groups"},{"question":"def is_scramble(s1, s2): Determines if s2 is a scrambled string of s1. >>> is_scramble(\\"great\\", \\"rgtae\\") \\"YES\\" >>> is_scramble(\\"abcde\\", \\"caebd\\") \\"NO\\" pass def scramble_check(s1, s2): Outputs \\"YES\\" if s2 is a scrambled string of s1, otherwise \\"NO\\". pass from solution import scramble_check def test_scramble_check_1(): assert scramble_check(\\"great\\", \\"rgtae\\") == \\"YES\\" def test_scramble_check_2(): assert scramble_check(\\"abcde\\", \\"caebd\\") == \\"NO\\" def test_scramble_check_3(): assert scramble_check(\\"a\\", \\"a\\") == \\"YES\\" def test_scramble_check_4(): assert scramble_check(\\"ab\\", \\"ba\\") == \\"YES\\" def test_scramble_check_5(): assert scramble_check(\\"abc\\", \\"bca\\") == \\"YES\\" def test_scramble_check_6(): assert scramble_check(\\"abc\\", \\"acb\\") == \\"YES\\" def test_scramble_check_7(): assert scramble_check(\\"abb\\", \\"bba\\") == \\"YES\\" def test_scramble_check_8(): assert scramble_check(\\"abcd\\", \\"dcab\\") == \\"YES\\" def test_scramble_check_9(): assert scramble_check(\\"efghij\\", \\"jefghi\\") == \\"YES\\" def test_scramble_check_10(): assert scramble_check(\\"abcd\\", \\"abcd\\") == \\"YES\\"","solution":"def is_scramble(s1, s2): Determines if s2 is a scrambled string of s1. if s1 == s2: return True if sorted(s1) != sorted(s2): return False n = len(s1) for i in range(1, n): if (is_scramble(s1[:i], s2[:i]) and is_scramble(s1[i:], s2[i:])) or (is_scramble(s1[:i], s2[-i:]) and is_scramble(s1[i:], s2[:-i])): return True return False def scramble_check(s1, s2): Outputs \\"YES\\" if s2 is a scrambled string of s1, otherwise \\"NO\\". return \\"YES\\" if is_scramble(s1, s2) else \\"NO\\""},{"question":"def check_pressure_higher(n: int, pressure_readings: List[int]) -> str: Determine if the atmospheric pressure at any point in time was ever higher than it was at the start of the day. Args: n - the number of hours for which the data is available for that day. pressure_readings - list of atmospheric pressure readings for each corresponding hour. Returns: \\"HIGHER\\" if there was any hour where the atmospheric pressure was higher than the initial reading, and \\"NOT HIGHER\\" otherwise. Examples: >>> check_pressure_higher(5, [1002, 1003, 1002, 1001, 1000]) 'HIGHER' >>> check_pressure_higher(3, [1015, 1015, 1015]) 'NOT HIGHER' >>> check_pressure_higher(4, [1012, 1010, 1013, 1011]) 'HIGHER'","solution":"def check_pressure_higher(n, pressure_readings): initial_reading = pressure_readings[0] for reading in pressure_readings[1:]: if reading > initial_reading: return \\"HIGHER\\" return \\"NOT HIGHER\\""},{"question":"def who_wins(x: int, y: int) -> str: Determines the winner between Alice and Bob based on the number of 1-bits in the binary representation of x and y. Parameters: x (int): Alice's chosen non-negative integer. y (int): Bob's chosen non-negative integer. Returns: str: \\"Alice\\" if Alice has more points, \\"Bob\\" if Bob has more points, or \\"Draw\\" if they have the same points. Examples: >>> who_wins(5, 3) 'Draw' >>> who_wins(7, 4) 'Alice' >>> who_wins(8, 15) 'Bob' >>> who_wins(0, 0) 'Draw' >>> who_wins(11, 14) 'Draw' >>> who_wins(31, 16) 'Alice' >>> who_wins(1000000000, 123456789) 'Bob' >>> who_wins(15, 8) 'Alice' >>> who_wins(1, 2) 'Draw' >>> who_wins(1023, 0) 'Alice'","solution":"def who_wins(x, y): Determines the winner between Alice and Bob based on the number of 1-bits in the binary representation of x and y. Parameters: x (int): Alice's chosen non-negative integer. y (int): Bob's chosen non-negative integer. Returns: str: \\"Alice\\" if Alice has more points, \\"Bob\\" if Bob has more points, or \\"Draw\\" if they have the same points. alice_points = bin(x).count('1') bob_points = bin(y).count('1') if alice_points > bob_points: return \\"Alice\\" elif bob_points > alice_points: return \\"Bob\\" else: return \\"Draw\\""},{"question":"def subarray_sums(arr, queries): Returns the sums of subarrays for given queries. Args: arr : list of int : the list of integers queries : list of tuples : list of (L, R) pairs indicating the start and end indices for the subarrays Returns: list of int : list of sums for the respective subarrays","solution":"def subarray_sums(arr, queries): Returns the sums of subarrays for given queries. Args: arr : list of int : the list of integers queries : list of tuples : list of (L, R) pairs indicating the start and end indices for the subarrays Returns: list of int : list of sums for the respective subarrays # Precompute prefix sums prefix_sums = [0] * (len(arr) + 1) for i in range(1, len(arr) + 1): prefix_sums[i] = prefix_sums[i - 1] + arr[i - 1] results = [] for L, R in queries: # Calculate the subarray sum using prefix sums subarray_sum = prefix_sums[R] - prefix_sums[L - 1] results.append(subarray_sum) return results"},{"question":"class ArrayProcessor: def __init__(self, array): Initialize the array processor with the given array. >>> proc = ArrayProcessor([2, 4, 6, 8, 10]) >>> proc.array == [2, 4, 6, 8, 10] True def update(self, i, x): Update the i-th element of the array to x. def count_divisibles(self, l, r, d): Count the number of integers in the range from index l to index r (inclusive) that are divisible by d. >>> proc = ArrayProcessor([2, 4, 6, 8, 10]) >>> proc.count_divisibles(1, 5, 2) 5 >>> proc.update(3, 15) >>> proc.count_divisibles(2, 5, 2) 3 >>> proc.count_divisibles(1, 4, 4) 2 def process_queries(n, q, array, queries): Process a series of queries (updates and counts) on the array. >>> n, q = 5, 4 >>> array = [2, 4, 6, 8, 10] >>> queries = [\\"COUNT 1 5 2\\", \\"UPDATE 3 15\\", \\"COUNT 2 5 2\\", \\"COUNT 1 4 4\\"] >>> process_queries(n, q, array, queries) '5n3n2'","solution":"class ArrayProcessor: def __init__(self, array): self.array = array def update(self, i, x): self.array[i - 1] = x def count_divisibles(self, l, r, d): count = 0 for i in range(l - 1, r): if self.array[i] % d == 0: count += 1 return count def process_queries(n, q, array, queries): processor = ArrayProcessor(array) results = [] for query in queries: parts = query.split() if parts[0] == \\"UPDATE\\": i = int(parts[1]) x = int(parts[2]) processor.update(i, x) elif parts[0] == \\"COUNT\\": l = int(parts[1]) r = int(parts[2]) d = int(parts[3]) results.append(str(processor.count_divisibles(l, r, d))) return \\"n\\".join(results)"},{"question":"def highest_population_growth(n: int, city_data: List[str], i: int, j: int) -> str: Determine the city with the highest population growth rate over a specific time period. >>> highest_population_growth(3, [\\"CityA 1000 1200 1400\\", \\"CityB 2000 2400 2900\\", \\"CityC 1500 1500 1600\\"], 0, 2) \\"CityB 45.00\\" >>> highest_population_growth(2, [\\"Alpha 5000 6000 7200\\", \\"Beta 3000 3300 3600\\"], 0, 1) \\"Alpha 20.00\\"","solution":"def highest_population_growth(n, city_data, i, j): import math max_growth_rate = -math.inf best_city = \\"\\" for data in city_data: city_info = data.split() city_name = city_info[0] populations = list(map(int, city_info[1:])) if populations[i] == 0: continue growth_rate = ((populations[j] - populations[i]) / populations[i]) * 100 if growth_rate > max_growth_rate: max_growth_rate = growth_rate best_city = city_name elif growth_rate == max_growth_rate: if city_name < best_city: best_city = city_name return f\\"{best_city} {max_growth_rate:.2f}\\" # Example usage: # n = 3 # city_data = [\\"CityA 1000 1200 1400\\", \\"CityB 2000 2400 2900\\", \\"CityC 1500 1500 1600\\"] # i, j = 0, 2 # print(highest_population_growth(n, city_data, i, j)) # Output: CityB 45.00"},{"question":"from typing import List def longest_palindromic_substring_length(s: str) -> int: Returns the length of the longest palindromic substring in the string s. >>> longest_palindromic_substring_length(\\"abacdfgdcabba\\") 4 >>> longest_palindromic_substring_length(\\"banana\\") 5 def find_longest_palindromic_substrings(test_cases: List[str]) -> List[int]: For each string in test_cases, finds the length of the longest palindromic substring. >>> find_longest_palindromic_substrings([\\"abacdfgdcabba\\", \\"banana\\"]) [4, 5] >>> find_longest_palindromic_substrings([\\"a\\", \\"bb\\", \\"abc\\", \\"\\"]) [1, 2, 1, 0]","solution":"def longest_palindromic_substring_length(s): if not s: return 0 n = len(s) max_length = 1 for i in range(1, n): # Even-length palindrome check low, high = i - 1, i while low >= 0 and high < n and s[low] == s[high]: current_length = high - low + 1 if current_length > max_length: max_length = current_length low -= 1 high += 1 # Odd-length palindrome check low, high = i - 1, i + 1 while low >= 0 and high < n and s[low] == s[high]: current_length = high - low + 1 if current_length > max_length: max_length = current_length low -= 1 high += 1 return max_length def find_longest_palindromic_substrings(test_cases): results = [] for s in test_cases: results.append(longest_palindromic_substring_length(s)) return results"},{"question":"from typing import List, Tuple def max_points(T: int, test_cases: List[Tuple[Tuple[int, int], List[List[int]]]]) -> List[int]: Calculate the maximum number of points Alice can collect in the game. Args: T (int): Number of test cases test_cases (List[Tuple[Tuple[int, int], List[List[int]]]]): List of tuples where each tuple contains a tuple with dimensions (M, N) and a 2D list representing the grid of points. Returns: List[int]: List of maximum points Alice can collect for each test case Example: >>> max_points(2, [((3, 3), [[1, 2, 3], [4, 5, 6], [7, 8, 9]]), ((2, 2), [[1, 2], [1, 1]])]) [29, 4] >>> max_points(1, [((2, 2), [[1000, 0], [0, 1000]])]) [2000]","solution":"def max_points(T, test_cases): results = [] for t in range(T): M, N = test_cases[t][0] grid = test_cases[t][1] dp = [[0] * N for _ in range(M)] dp[0][0] = grid[0][0] for i in range(1, M): dp[i][0] = dp[i - 1][0] + grid[i][0] for j in range(1, N): dp[0][j] = dp[0][j - 1] + grid[0][j] for i in range(1, M): for j in range(1, N): dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + grid[i][j] result = dp[M - 1][N - 1] results.append(result) return results"},{"question":"def min_total_manhattan_distance(points): Calculates the minimal total Manhattan distance to visit all points exactly once in the given order. >>> min_total_manhattan_distance([(1, 2), (3, 4), (-1, -3), (-4, 0)]) == 18 >>> min_total_manhattan_distance([(0, 0)]) == 0 >>> min_total_manhattan_distance([(0, 0), (2, 3)]) == 5","solution":"def min_total_manhattan_distance(points): Calculates the minimal total Manhattan distance to visit all points exactly once in the given order. # Sort the points by x and y coordinates separately x_sorted = sorted(points, key=lambda p: p[0]) y_sorted = sorted(points, key=lambda p: p[1]) # Select the median point median_point = (x_sorted[len(points) // 2][0], y_sorted[len(points) // 2][1]) # Calculate the total distance from the median point total_distance = 0 for point in points: total_distance += abs(point[0] - median_point[0]) + abs(point[1] - median_point[1]) return total_distance"},{"question":"from typing import List def min_number_of_coins(coins: List[int], amount: int) -> int: Determine the minimum number of coins needed to make up the given amount. If the amount cannot be made up by any combination of the coins, return -1. Parameters: coins (List[int]): A list of positive integers representing the coin denominations. amount (int): A non-negative integer representing the total amount of money. Returns: int: The minimum number of coins needed to make up the amount, or -1 if it is not possible. Examples: >>> min_number_of_coins([1, 2, 5], 11) 3 >>> min_number_of_coins([2], 3) -1","solution":"from typing import List def min_number_of_coins(coins: List[int], amount: int) -> int: Determine the minimum number of coins needed to make up the given amount. If the amount cannot be made up by any combination of the coins, return -1. # Initialize a list to store the minimum number of coins for each amount up to \`amount\` dp = [float('inf')] * (amount + 1) dp[0] = 0 # Iterate through each coin for coin in coins: # Update the dp list for each value from coin to amount for x in range(coin, amount + 1): dp[x] = min(dp[x], dp[x - coin] + 1) # If dp[amount] is still infinity, it means amount cannot be made up by any combination of coins return dp[amount] if dp[amount] != float('inf') else -1"},{"question":"def count_unique_groups(n: int, m: int, connections: List[Tuple[int, int]]) -> int: Given the number of employees and their connections, return the number of unique groups. Args: n (int): Number of employees. m (int): Number of connections. connections (List[Tuple[int, int]]): List of tuples representing connections between employees. Returns: int: Number of unique groups of employees. >>> count_unique_groups(5, 3, [(1, 2), (2, 3), (4, 5)]) 2 >>> count_unique_groups(6, 0, []) 6 >>> count_unique_groups(4, 2, [(1, 2), (3, 4)]) 2 >>> count_unique_groups(1, 0, []) 1 >>> count_unique_groups(5, 4, [(1, 2), (2, 3), (3, 4), (4, 5)]) 1 >>> count_unique_groups(3, 0, []) 3 >>> count_unique_groups(7, 3, [(1, 2), (3, 4), (5, 6)]) 4","solution":"def count_unique_groups(n, m, connections): Returns the number of unique groups of employees. from collections import defaultdict # Create adjacency list graph = defaultdict(list) for a, b in connections: graph[a].append(b) graph[b].append(a) # To track visited nodes visited = [False] * (n + 1) def dfs(node): stack = [node] while stack: current = stack.pop() for neighbor in graph[current]: if not visited[neighbor]: visited[neighbor] = True stack.append(neighbor) groups = 0 for employee in range(1, n + 1): if not visited[employee]: groups += 1 visited[employee] = True dfs(employee) return groups"},{"question":"def preprocess_steps(steps): Preprocess the array of daily steps using prefix sums. :param steps: List[int], a list of steps taken each day. :return: List[int], a list of prefix sums. # Your code here def total_steps_in_range(prefix_sum, L, R): Calculate the total steps in the range from day L to day R (inclusive). :param prefix_sum: List[int], a list of prefix sums. :param L: int, start day of the range (1-indexed). :param R: int, end day of the range (1-indexed). :return: int, the total number of steps in the range. # Your code here def process_queries(N, steps, queries): Process multiple queries on the steps data. :param N: int, number of days. :param steps: List[int], a list of steps taken each day. :param queries: List[Tuple[int, int]], a list of queries where each query is a tuple (Li, Ri). :return: List[int], the results of each query. # Your code here # Example usage and expected output: # N = 5 # steps = [1000, 2000, 3000, 4000, 5000] # queries = [(1, 3), (2, 4), (1, 5)] # print(process_queries(N, steps, queries)) # Output: [6000, 9000, 15000] def test_preprocess_steps(): steps = [1000, 2000, 3000, 4000, 5000] expected = [0, 1000, 3000, 6000, 10000, 15000] assert preprocess_steps(steps) == expected def test_total_steps_in_range(): prefix_sum = [0, 1000, 3000, 6000, 10000, 15000] assert total_steps_in_range(prefix_sum, 1, 3) == 6000 assert total_steps_in_range(prefix_sum, 2, 4) == 9000 assert total_steps_in_range(prefix_sum, 1, 5) == 15000 def test_process_queries(): N = 5 steps = [1000, 2000, 3000, 4000, 5000] queries = [(1, 3), (2, 4), (1, 5)] expected = [6000, 9000, 15000] assert process_queries(N, steps, queries) == expected N = 6 steps = [500, 800, 700, 600, 900, 1000] queries = [(1, 2), (3, 5), (1, 6), (4, 5)] expected = [1300, 2200, 4500, 1500] assert process_queries(N, steps, queries) == expected N = 4 steps = [150, 200, 250, 300] queries = [(1, 4), (2, 3)] expected = [900, 450] assert process_queries(N, steps, queries) == expected","solution":"def preprocess_steps(steps): Preprocess the array of daily steps using prefix sums. :param steps: List[int], a list of steps taken each day. :return: List[int], a list of prefix sums. prefix_sum = [0] * (len(steps) + 1) for i in range(len(steps)): prefix_sum[i + 1] = prefix_sum[i] + steps[i] return prefix_sum def total_steps_in_range(prefix_sum, L, R): Calculate the total steps in the range from day L to day R (inclusive). :param prefix_sum: List[int], a list of prefix sums. :param L: int, start day of the range (1-indexed). :param R: int, end day of the range (1-indexed). :return: int, the total number of steps in the range. return prefix_sum[R] - prefix_sum[L - 1] def process_queries(N, steps, queries): Process multiple queries on the steps data. :param N: int, number of days. :param steps: List[int], a list of steps taken each day. :param queries: List[Tuple[int, int]], a list of queries where each query is a tuple (Li, Ri). :return: List[int], the results of each query. prefix_sum = preprocess_steps(steps) results = [] for L, R in queries: results.append(total_steps_in_range(prefix_sum, L, R)) return results"},{"question":"def floyd_warshall(n: int, edges: List[Tuple[int, int, int]]) -> List[List[int]]: Apply Floyd-Warshall algorithm to find the shortest paths between all pairs of cities. Args: n (int): The number of cities. edges (list of tuples): Each tuple (u, v, w) represents a bidirectional road between city u and city v with travel time w. Returns: list of list of int: A 2D list where the value at index [i][j] represents the shortest travel time from city i+1 to city j+1. pass def minimum_travel_times(n: int, edges: List[Tuple[int, int, int]], queries: List[Tuple[int, int]]) -> List[int]: Calculate the minimum travel times for each query using the Floyd-Warshall algorithm. Args: n (int): The number of cities. edges (list of tuples): Each tuple (u, v, w) represents a bidirectional road between city u and city v with travel time w. queries (list of tuples): Each tuple (a, b) represents a query asking for the shortest travel time between city a and city b. Returns: list of int: A list where each value is the shortest travel time between the specified cities for each query. pass def test_floyd_warshall_basic(): n = 4 edges = [ (1, 2, 1), (2, 3, 2), (1, 3, 4), (3, 4, 1) ] expected = [ [0, 1, 3, 4], [1, 0, 2, 3], [3, 2, 0, 1], [4, 3, 1, 0] ] assert floyd_warshall(n, edges) == expected def test_minimum_travel_times_example(): n = 5 edges = [ (1, 2, 4), (2, 3, 1), (1, 3, 2), (1, 4, 7), (3, 4, 3), (4, 5, 1), (3, 5, 5) ] queries = [ (1, 5), (2, 4), (1, 3) ] assert minimum_travel_times(n, edges, queries) == [6, 4, 2] def test_minimum_travel_no_connection(): n = 3 edges = [ (1, 2, 3) ] queries = [ (1, 3), (2, 3) ] assert minimum_travel_times(n, edges, queries) == [-1, -1] def test_minimum_travel_single_path(): n = 2 edges = [ (1, 2, 5) ] queries = [ (1, 2), (2, 1) ] assert minimum_travel_times(n, edges, queries) == [5, 5]","solution":"def floyd_warshall(n, edges): # Initialize distance matrix dist = [[float('inf')] * n for _ in range(n)] # Distance from the node to itself is zero for i in range(n): dist[i][i] = 0 for u, v, w in edges: u -= 1 v -= 1 dist[u][v] = w dist[v][u] = w # Floyd-Warshall algorithm for k in range(n): for i in range(n): for j in range(n): if dist[i][j] > dist[i][k] + dist[k][j]: dist[i][j] = dist[i][k] + dist[k][j] return dist def minimum_travel_times(n, edges, queries): dist = floyd_warshall(n, edges) results = [] for a, b in queries: a -= 1 b -= 1 if dist[a][b] == float('inf'): results.append(-1) else: results.append(dist[a][b]) return results # Example usage def main(): import sys input = sys.stdin.read data = input().split() index = 0 n = int(data[index]) index += 1 m = int(data[index]) index += 1 edges = [] for _ in range(m): u = int(data[index]) index += 1 v = int(data[index]) index += 1 w = int(data[index]) index += 1 edges.append((u, v, w)) q = int(data[index]) index += 1 queries = [] for _ in range(q): a = int(data[index]) index += 1 b = int(data[index]) index += 1 queries.append((a, b)) results = minimum_travel_times(n, edges, queries) for result in results: print(result) if __name__ == \\"__main__\\": main()"},{"question":"def group_people(N: int, M: int, people: List[int]) -> List[List[int]]: Groups people into M groups maintaining their relative order in the original circle. >>> group_people(6, 2, [1, 2, 3, 4, 5, 6]) [[1, 2, 3], [4, 5, 6]] >>> group_people(7, 3, [1, 2, 3, 4, 5, 6, 7]) [[1, 2, 3], [4, 5], [6, 7]] >>> group_people(5, 1, [1, 2, 3, 4, 5]) [[1, 2, 3, 4, 5]] >>> group_people(5, 5, [1, 2, 3, 4, 5]) [[1], [2], [3], [4], [5]] >>> group_people(10, 3, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) [[1, 2, 3, 4], [5, 6, 7], [8, 9, 10]]","solution":"def group_people(N, M, people): Groups people into M groups maintaining their relative order in the original circle. # Calculate the base size of each group base_group_size = N // M extra = N % M groups = [] start = 0 for i in range(M): current_group_size = base_group_size + (1 if i < extra else 0) groups.append(people[start:start + current_group_size]) start += current_group_size return groups"},{"question":"def classify_character(T: int, characters: List[str]) -> List[str]: Determines if the given characters are vowels, consonants, or invalid inputs. Args: T: The total number of test cases. characters: A list of characters to classify. Returns: A list of strings where each string is either \\"Vowel\\", \\"Consonant\\", or \\"Invalid input\\" based on the classification of the corresponding character. Examples: >>> classify_character(4, ['a', 'b', '1', 'G']) ['Vowel', 'Consonant', 'Invalid input', 'Consonant'] >>> classify_character(2, ['E', 'k']) ['Vowel', 'Consonant'] pass from typing import List def test_classify_vowels(): assert classify_character(2, ['a', 'E']) == ['Vowel', 'Vowel'] def test_classify_consonants(): assert classify_character(2, ['b', 'G']) == ['Consonant', 'Consonant'] def test_classify_invalid_input(): assert classify_character(2, ['1', '@']) == ['Invalid input', 'Invalid input'] def test_mixed_input(): assert classify_character(4, ['a', 'b', '1', 'G']) == ['Vowel', 'Consonant', 'Invalid input', 'Consonant'] def test_single_case_vowel(): assert classify_character(1, ['o']) == ['Vowel'] def test_single_case_consonant(): assert classify_character(1, ['k']) == ['Consonant'] def test_single_case_invalid(): assert classify_character(1, ['#']) == ['Invalid input']","solution":"def classify_character(T, characters): vowels = \\"aeiouAEIOU\\" results = [] for C in characters: if C.isalpha(): if C in vowels: results.append(\\"Vowel\\") else: results.append(\\"Consonant\\") else: results.append(\\"Invalid input\\") return results"},{"question":"from typing import List, Tuple def find_max_diff(n: int, q: int, items: List[int], queries: List[Tuple[int, int]]) -> List[int]: Leena has a collection of items with unique item numbers from 1 to n. For each query, find the maximum difference in item numbers within the given range. Parameters: n (int): The number of items. q (int): The number of queries. items (List[int]): The item numbers in Leena's collection. queries (List[Tuple[int, int]]): The range of items for which to find the maximum difference. Returns: List[int]: The maximum difference for each query. Examples: >>> find_max_diff(6, 3, [1, 3, 2, 6, 4, 5], [(1, 3), (2, 5), (3, 6)]) [2, 4, 4] >>> find_max_diff(5, 2, [4, 1, 3, 5, 2], [(1, 5), (3, 4)]) [4, 2]","solution":"def find_max_diff(n, q, items, queries): results = [] for l, r in queries: l, r = l - 1, r - 1 # Convert to zero-based index max_val = max(items[l:r+1]) min_val = min(items[l:r+1]) results.append(max_val - min_val) return results"},{"question":"def largest_island_size(): Given a square grid of size n x n consisting of cells that are either land or water, find the size of the largest island of land cells. An island is made up of connecting land cells vertically or horizontally (not diagonally), and it must be surrounded by water cells or the boundaries of the grid. The size of an island is defined as the number of land cells it contains.","solution":"def largest_island_size(): def dfs(grid, x, y, visited, n): stack = [(x, y)] size = 0 while stack: cx, cy = stack.pop() if (cx, cy) not in visited: visited.add((cx, cy)) size += 1 # Explore neighbors for nx, ny in [(cx-1, cy), (cx+1, cy), (cx, cy-1), (cx, cy+1)]: if 0 <= nx < n and 0 <= ny < n and grid[nx][ny] == 'L' and (nx, ny) not in visited: stack.append((nx, ny)) return size import sys input = sys.stdin.read data = input().split() index = 0 results = [] while True: n = int(data[index]) index += 1 if n == 0: break grid = [] for _ in range(n): row = data[index] index += 1 grid.append(row) visited = set() max_size = 0 for i in range(n): for j in range(n): if grid[i][j] == 'L' and (i, j) not in visited: max_size = max(max_size, dfs(grid, i, j, visited, n)) results.append(max_size) for result in results: print(result)"},{"question":"def min_cut_palindrome_partition(s: str) -> int: Partition the string into as few substrings as possible such that each substring is a palindrome. Return the minimum number of cuts needed for a palindrome partitioning of s. >>> min_cut_palindrome_partition(\\"aab\\") 1 >>> min_cut_palindrome_partition(\\"noon\\") 0","solution":"def min_cut_palindrome_partition(s): n = len(s) # is_palindrome[i][j] will be True if s[i:j+1] is a palindrome. is_palindrome = [[False] * n for _ in range(n)] for i in range(n): is_palindrome[i][i] = True for length in range(2, n + 1): for i in range(n - length + 1): j = i + length - 1 if length == 2: is_palindrome[i][j] = (s[i] == s[j]) else: is_palindrome[i][j] = (s[i] == s[j]) and is_palindrome[i + 1][j - 1] cuts = [0] * n for i in range(n): if is_palindrome[0][i]: cuts[i] = 0 else: cuts[i] = float('inf') for j in range(i): if is_palindrome[j + 1][i]: cuts[i] = min(cuts[i], cuts[j] + 1) return cuts[-1]"},{"question":"def min_energy_cost(floors: List[int], F: int) -> int: Returns the minimum energy cost to visit all specified floors starting from floor 1. Parameters: floors (list): A list of integers representing floors where maintenance is required. F (int): The number of floors in the building. Returns: int: Minimum energy cost. >>> min_energy_cost([3, 2, 4, 5], 5) 4 >>> min_energy_cost([2, 4, 5, 10], 10) 9 >>> min_energy_cost([3], 5) 2 >>> min_energy_cost([2, 4, 8], 10) 7 >>> min_energy_cost([1, 10], 10) 9 >>> min_energy_cost([100, 200, 300, 400], 500) 399 >>> min_energy_cost([2, 7, 4, 9], 10) 8","solution":"def min_energy_cost(floors, F): Returns the minimum energy cost to visit all specified floors starting from floor 1. Parameters: floors (list): A list of integers representing floors where maintenance is required. F (int): The number of floors in the building. Returns: int: Minimum energy cost. # Sort the list of floors to visit floors.sort() # Initial energy cost to first maintenance floor from floor 1 energy_cost = abs(1 - floors[0]) # Add the energy cost for traveling between each maintenance floor for i in range(1, len(floors)): energy_cost += abs(floors[i] - floors[i - 1]) return energy_cost"},{"question":"def can_rearrange(n: int, k: int, x: int, arr: List[int]) -> str: Determine whether it is possible to rearrange the array such that the sum of every contiguous subarray of length k is greater than a given integer x. >>> can_rearrange(5, 3, 8, [4, 1, 3, 5, 6]) 'YES' >>> can_rearrange(4, 2, 15, [10, 5, 8, 2]) 'NO' from solution import can_rearrange def test_example1(): result = can_rearrange(5, 3, 8, [4, 1, 3, 5, 6]) assert result.startswith(\\"YES\\") def test_example2(): result = can_rearrange(4, 2, 15, [10, 5, 8, 2]) assert result == \\"NO\\" def test_k1_case(): result = can_rearrange(5, 1, 2, [3, 3, 3, 3, 3]) assert result == \\"YESn3 3 3 3 3\\" def test_k1_fail_case(): result = can_rearrange(5, 1, 5, [3, 3, 3, 3, 3]) assert result == \\"NO\\" def test_large_k_case(): result = can_rearrange(5, 5, 10, [2, 3, 4, 5, 6]) assert result.startswith(\\"YES\\") def test_no_solution_case(): result = can_rearrange(5, 3, 50, [1, 2, 3, 4, 5]) assert result == \\"NO\\"","solution":"def can_rearrange(n, k, x, arr): # Special case when k = 1, since the sum of any subarray must individually be greater than x if k == 1: for num in arr: if num <= x: return \\"NO\\" return \\"YESn\\" + \\" \\".join(map(str, arr)) # General case arr.sort(reverse=True) if sum(arr[:k]) <= x: return \\"NO\\" for i in range(k, n): if arr[i] + sum(arr[:k-1]) <= x: return \\"NO\\" return \\"YESn\\" + \\" \\".join(map(str, arr)) # Example usage n = 5 k = 3 x = 8 arr = [4, 1, 3, 5, 6] result = can_rearrange(n, k, x, arr) print(result) # YES 4 5 6 3 1 or other valid output"},{"question":"def evaluate_expression(expression: str) -> int: Evaluates a mathematical expression with +, -, *, /, and parentheses and returns the result. Division is treated as integer division. >>> evaluate_expression(\\"2 + 2\\") 4 >>> evaluate_expression(\\"2 + 3 * 4\\") 14 >>> evaluate_expression(\\"(2 + 3) * 4\\") 20 >>> evaluate_expression(\\" 2 + 3 \\") 5 >>> evaluate_expression(\\"5 + 4 / 2\\") 7 >>> evaluate_expression(\\"(1 + (2 * (2 + 3))) / 3\\") 3 >>> evaluate_expression(\\"10 - 3 - 2\\") 5 >>> evaluate_expression(\\"10 + 2 * 6 / 3\\") 14 >>> evaluate_expression(\\"2 + 3 * 2 - 4 / 2\\") 6","solution":"def evaluate_expression(expression): Evaluates a mathematical expression with +, -, *, /, and parentheses and returns the result. Division is treated as integer division. def eval_tokens(tokens): stack = [] num = 0 op = '+' while tokens: token = tokens.pop(0) if token.isdigit(): num = int(token) if token == '(': num = eval_tokens(tokens) if (not token.isdigit() and token != ' ') or not tokens: if op == '+': stack.append(num) elif op == '-': stack.append(-num) elif op == '*': stack.append(stack.pop() * num) elif op == '/': stack.append(int(stack.pop() / num)) op = token num = 0 if token == ')': break return sum(stack) tokens = [] number = \\"\\" for char in expression: if char.isdigit(): number += char else: if number: tokens.append(number) number = \\"\\" if char in \\"+-*/()\\": tokens.append(char) if number: tokens.append(number) return eval_tokens(tokens)"},{"question":"def single_number(nums: List[int]) -> int: Finds the element in the list that appears only once while all other elements appear thrice. Args: nums (List[int]): The list of integers. Returns: int: The single integer that appears only once. Example: >>> single_number([2, 2, 3, 2]) 3 >>> single_number([0, 1, 0, 1, 0, 1, 99]) 99","solution":"def single_number(nums): Finds the element in the list that appears only once while all other elements appear thrice. Args: nums (List[int]): The list of integers. Returns: int: The single integer that appears only once. ones, twos = 0, 0 for num in nums: # Appears in ones for the first time, remove if appearing again ones = (ones ^ num) & ~twos # Appears in twos for the first time, remove if appearing again twos = (twos ^ num) & ~ones return ones"},{"question":"def minimal_arrangement_cost(n: int, initial_positions: List[int], desired_positions: List[int]) -> int: Determine the minimal cost of arranging the books given their initial positions and their desired positions. Args: n (int): The number of books (and slots on the shelf). initial_positions (List[int]): The initial slots of the books. desired_positions (List[int]): The desired slots for the books. Returns: int: The minimal total cost to arrange the books. Examples: >>> minimal_arrangement_cost(5, [2, 4, 1, 5, 3], [5, 2, 3, 1, 4]) 10 >>> minimal_arrangement_cost(4, [1, 3, 4, 2], [2, 4, 1, 3]) 8","solution":"def minimal_arrangement_cost(n, initial_positions, desired_positions): initial_slots = {book: i+1 for i, book in enumerate(initial_positions)} desired_slots = {book: i+1 for i, book in enumerate(desired_positions)} total_cost = 0 for book in range(1, n+1): total_cost += abs(initial_slots[book] - desired_slots[book]) return total_cost # Sample usage if __name__ == \\"__main__\\": print(minimal_arrangement_cost(5, [2, 4, 1, 5, 3], [5, 2, 3, 1, 4])) # Output: 10 print(minimal_arrangement_cost(4, [1, 3, 4, 2], [2, 4, 1, 3])) # Output: 8"},{"question":"def longest_even_sum_subsequence_length(n: int, arr: List[int]) -> int: Returns the length of the longest subsequence wherein the sum of every consecutive pair of integers is even. >>> longest_even_sum_subsequence_length(5, [1, 2, 3, 4, 5]) == 3 >>> longest_even_sum_subsequence_length(6, [2, 4, 1, 3, 5, 7]) == 4 >>> longest_even_sum_subsequence_length(4, [2, 4, 6, 8]) == 4 >>> longest_even_sum_subsequence_length(4, [1, 3, 5, 7]) == 4 >>> longest_even_sum_subsequence_length(6, [1, 2, 3, 4, 5, 6]) == 3 >>> longest_even_sum_subsequence_length(1, [2]) == 1 >>> longest_even_sum_subsequence_length(1, [1]) == 1","solution":"def longest_even_sum_subsequence_length(n, arr): Returns the length of the longest subsequence wherein the sum of every consecutive pair of integers is even. if n == 0: return 0 even_count = sum(1 for x in arr if x % 2 == 0) odd_count = n - even_count # The longest subsequence will be the maximum of even or odd counts. return max(even_count, odd_count)"},{"question":"def can_permute_no_adjacent_same_parity(n: int, lst: List[int]) -> Tuple[str, List[int]]: Determine if a list can be permuted such that no two adjacent elements have the same parity. >>> can_permute_no_adjacent_same_parity(4, [1, 2, 3, 4]) ('YES', [1, 2, 3, 4]) >>> can_permute_no_adjacent_same_parity(3, [1, 3, 5]) ('NO', []) >>> can_permute_no_adjacent_same_parity(5, [2, 4, 6, 8, 10]) ('NO', []) def process_test_cases(test_cases: List[Tuple[int, List[int]]]) -> List[str]: Process multiple test cases to determine if a permutation exists for each list. >>> process_test_cases([(4, [1, 2, 3, 4]), (3, [1, 3, 5]), (5, [2, 4, 6, 8, 10])]) ['YES', '1 2 3 4', 'NO', 'NO'] >>> process_test_cases([(6, [1, 2, 3, 4, 5, 6]), (1, [1])]) ['YES', '1 2 3 4 5 6', 'YES', '1']","solution":"def can_permute_no_adjacent_same_parity(n, lst): odds = [x for x in lst if x % 2 != 0] evens = [x for x in lst if x % 2 == 0] if abs(len(odds) - len(evens)) > 1: return \\"NO\\", [] if len(odds) > len(evens): result = [] for i in range(len(evens)): result.append(odds[i]) result.append(evens[i]) result.append(odds[-1]) return \\"YES\\", result elif len(evens) > len(odds): result = [] for i in range(len(odds)): result.append(evens[i]) result.append(odds[i]) result.append(evens[-1]) return \\"YES\\", result else: result = [] for i in range(len(odds)): result.append(odds[i]) result.append(evens[i]) return \\"YES\\", result def process_test_cases(test_cases): results = [] for n, lst in test_cases: result, permuted_list = can_permute_no_adjacent_same_parity(n, lst) if result == \\"NO\\": results.append(\\"NO\\") else: results.append(\\"YES\\") results.append(\\" \\".join(map(str, permuted_list))) return results"},{"question":"from typing import List def shortest_path_length(R: int, C: int, grid: List[str]) -> int: Write a function that finds the length of the shortest path from the top-left corner to the bottom-right corner of a grid. The grid consists of walkable cells, which are represented by ‘.’, and unwalkable cells, which are represented by ‘#’. The top-left and bottom-right corners are always walkable. You can only move up, down, left, or right. Input: - An integer R, the number of rows of the grid. - An integer C, the number of columns of the grid. - A list of strings, representing the grid. Output: - An integer, the length of the shortest path from the top-left to the bottom-right corner. If there is no such path, return -1. Examples: >>> shortest_path_length(3, 3, [\\".\\", \\".#.\\", \\"...\\"]) 5 >>> shortest_path_length(3, 3, [\\".\\", \\"#\\", \\"...\\"]) -1 >>> shortest_path_length(5, 5, [\\".....\\", \\".....\\", \\".....\\", \\".....\\", \\".....\\"]) 9 >>> shortest_path_length(1, 1, [\\".\\"]) 1 >>> shortest_path_length(4, 4, [\\"....\\", \\".#\\", \\"...#\\", \\"#...\\"]) 7 def test_shortest_path_length(): assert shortest_path_length(3, 3, [\\".\\", \\".#.\\", \\"...\\"]) == 5 assert shortest_path_length(3, 3, [\\".\\", \\"#\\", \\"...\\"]) == -1 assert shortest_path_length(5, 5, [\\".....\\", \\".....\\", \\".....\\", \\".....\\", \\".....\\"]) == 9 assert shortest_path_length(1, 1, [\\".\\"]) == 1 assert shortest_path_length(4, 4, [\\"....\\", \\".#\\", \\"...#\\", \\"#...\\"]) == 7","solution":"from collections import deque def shortest_path_length(R, C, grid): # Helper function to check if a cell is within the grid and walkable def is_within_grid_and_walkable(x, y): return 0 <= x < R and 0 <= y < C and grid[x][y] == '.' # BFS initialization queue = deque([(0, 0, 1)]) # (row, column, distance) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # Up, Down, Left, Right visited = set((0, 0)) while queue: x, y, dist = queue.popleft() # If we reached the bottom-right corner if x == R-1 and y == C-1: return dist # Explore neighboring cells for dx, dy in directions: nx, ny = x + dx, y + dy if is_within_grid_and_walkable(nx, ny) and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny, dist + 1)) return -1 # Example usage: R, C = 3, 3 grid = [ \\".\\", \\".#.\\", \\"...\\" ] print(shortest_path_length(R, C, grid)) # Output: 5"},{"question":"from typing import List from collections import deque def minimum_steps_to_reach_target(R: int, C: int, grid: List[str], S_x: int, S_y: int, T_x: int, T_y: int) -> int: Given a grid representing a maze with R rows and C columns, find the minimum number of steps required for a person starting at (S_x, S_y) to reach (T_x, T_y), moving only up, down, left, or right. If not possible to reach the target, return -1. >>> minimum_steps_to_reach_target(5, 5, [\\".....\\", \\".#.#.\\", \\".#...\\", \\".#.#.\\", \\".....\\"], 1, 1, 5, 5) 8 >>> minimum_steps_to_reach_target(3, 3, [\\".#.\\", \\".#.\\", \\".#.\\"], 1, 1, 3, 3) -1 >>> minimum_steps_to_reach_target(3, 4, [\\"....\\", \\"..#.\\", \\".#..\\"], 1, 1, 3, 4) 5","solution":"from collections import deque def minimum_steps_to_reach_target(R, C, grid, S_x, S_y, T_x, T_y): if grid[S_x - 1][S_y - 1] == '#' or grid[T_x - 1][T_y - 1] == '#': return -1 directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] queue = deque([(S_x - 1, S_y - 1, 0)]) # (x, y, distance) visited = set() visited.add((S_x - 1, S_y - 1)) while queue: x, y, dist = queue.popleft() if (x, y) == (T_x - 1, T_y - 1): return dist for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < R and 0 <= ny < C and (nx, ny) not in visited and grid[nx][ny] == '.': visited.add((nx, ny)) queue.append((nx, ny, dist + 1)) return -1 # Example usage: # R, C = 5, 5 # grid = [ # \\".....\\", # \\".#.#.\\", # \\".#...\\", # \\".#.#.\\", # \\".....\\" # ] # print(minimum_steps_to_reach_target(R, C, grid, 1, 1, 5, 5))"},{"question":"def preprocess_array(arr): Preprocess the array to create a prefix sum array. Args: arr (list of int): The input array. Returns: list of int: The prefix sum array. pass # implementation here def query_sum(prefix_sum, l, r): Calculate the sum of the subarray from index l to r, inclusive, using the prefix sum array. Args: prefix_sum (list of int): The prefix sum array. l (int): The starting index (1-based). r (int): The ending index (1-based). Returns: int: The sum of the elements in the subarray from l to r. pass # implementation here # Example usage: # arr = [1, 2, 3, 4, 5] # prefix_sum = preprocess_array(arr) # result1 = query_sum(prefix_sum, 1, 3) # should return 6 # result2 = query_sum(prefix_sum, 2, 5) # should return 14 # result3 = query_sum(prefix_sum, 1, 5) # should return 15","solution":"def preprocess_array(arr): Preprocess the array to create a prefix sum array. Args: arr (list of int): The input array. Returns: list of int: The prefix sum array. prefix_sum = [0] * (len(arr) + 1) for i in range(1, len(prefix_sum)): prefix_sum[i] = prefix_sum[i - 1] + arr[i - 1] return prefix_sum def query_sum(prefix_sum, l, r): Calculate the sum of the subarray from index l to r, inclusive, using the prefix sum array. Args: prefix_sum (list of int): The prefix sum array. l (int): The starting index (1-based). r (int): The ending index (1-based). Returns: int: The sum of the elements in the subarray from l to r. return prefix_sum[r] - prefix_sum[l - 1]"},{"question":"from collections import deque def min_knight_moves(N: int, M: int) -> int: Determine the minimum number of moves required for the knight to travel from position (1, 1) to position (N, M) on a chessboard of size N x M. If it is not possible, return -1. >>> min_knight_moves(8, 8) 6 >>> min_knight_moves(1, 1) 0 >>> min_knight_moves(2, 2) -1 from collections import deque def test_knight_on_standard_board(): assert min_knight_moves(8, 8) == 6 def test_knight_start_at_destination(): assert min_knight_moves(1, 1) == 0 def test_knight_on_small_impossible_board(): assert min_knight_moves(2, 2) == -1 def test_knight_on_longer_rectangular_board(): assert min_knight_moves(3, 10) != -1 def test_knight_on_medium_square_board(): assert min_knight_moves(5, 5) != -1 def test_knight_on_large_complicated_board(): assert min_knight_moves(100, 100) != -1","solution":"from collections import deque def min_knight_moves(N, M): Determine the minimum number of moves required for the knight to travel from position (1, 1) to position (N, M) on a chessboard of size N x M. If it is not possible, return -1. if N == 1 and M == 1: return 0 # Possible moves of a knight moves = [(2, 1), (1, 2), (-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, -1)] # Initialize a queue for BFS queue = deque([((1, 1), 0)]) visited = set((1, 1)) while queue: (current_x, current_y), current_steps = queue.popleft() for dx, dy in moves: new_x, new_y = current_x + dx, current_y + dy if new_x == N and new_y == M: return current_steps + 1 if 1 <= new_x <= N and 1 <= new_y <= M and (new_x, new_y) not in visited: visited.add((new_x, new_y)) queue.append(((new_x, new_y), current_steps + 1)) return -1"},{"question":"def min_well_formed_substrings(t: int, strings: List[str]) -> List[int]: Determine the minimum number of well-formed substrings needed to build the original string for each test case. Return -1 if it's not possible. Args: t (int): Number of test cases. strings (List[str]): List of strings for each test case. Returns: List[int]: List of results for each test case. >>> min_well_formed_substrings(3, [\\"ababab\\", \\"abcabcabc\\", \\"abcd\\"]) [1, 1, -1] >>> min_well_formed_substrings(1, [\\"abcd\\"]) [-1] >>> min_well_formed_substrings(2, [\\"a\\", \\"ab\\"]) [-1, -1] from typing import List def test_single_test_case(): assert min_well_formed_substrings(1, [\\"ababab\\"]) == [1] def test_multiple_test_cases(): assert min_well_formed_substrings(3, [\\"ababab\\", \\"abcabcabc\\", \\"abcd\\"]) == [1, 1, -1] def test_no_solution(): assert min_well_formed_substrings(1, [\\"abcd\\"]) == [-1] def test_short_strings(): assert min_well_formed_substrings(2, [\\"a\\", \\"ab\\"]) == [-1, -1] def test_repetitive_strings(): assert min_well_formed_substrings(1, [\\"aaaa\\"]) == [1] def test_mixed_case_strings(): assert min_well_formed_substrings(3, [\\"abcabc\\", \\"aabbcc\\", \\"abcabcabcabc\\"]) == [1, -1, 1] def test_no_repetition(): assert min_well_formed_substrings(1, [\\"abcdefg\\"]) == [-1] def test_large_input(): input_string = \\"ab\\" * 500 assert min_well_formed_substrings(1, [input_string]) == [1]","solution":"def min_well_formed_substrings(t, strings): def find_well_formed(s): n = len(s) for length in range(2, n // 2 + 1): if n % length == 0: substring = s[:length] count = s.count(substring) if count * length == n: return 1 return -1 results = [] for s in strings: results.append(find_well_formed(s)) return results"},{"question":"def longest_palindromic_subsequence_length(word: str) -> int: Given a word, find the length of the longest palindromic subsequence. >>> longest_palindromic_subsequence_length(\\"abca\\") 3 >>> longest_palindromic_subsequence_length(\\"bananas\\") 5 >>> longest_palindromic_subsequence_length(\\"abcdef\\") 1 >>> longest_palindromic_subsequence_length(\\"racecar\\") 7 >>> longest_palindromic_subsequence_length(\\"a\\") 1 >>> longest_palindromic_subsequence_length(\\"aa\\") 2 # TODO: implementation here def longest_palindromic_subsequence(N: int, words: List[str]) -> int: Given a list of words, find the longest palindromic subsequence that can be formed by deleting some characters from each word in the list. :param N: int, the number of words. :param words: list of strings, words to process. :return: int, the length of the longest palindromic subsequence. >>> longest_palindromic_subsequence(3, [\\"abca\\", \\"bananas\\", \\"abcdef\\"]) 5 >>> longest_palindromic_subsequence(2, [\\"racecar\\", \\"level\\"]) 7 >>> longest_palindromic_subsequence(3, [\\"a\\", \\"b\\", \\"c\\"]) 1 >>> longest_palindromic_subsequence(1, [\\"madam\\"]) 5 >>> longest_palindromic_subsequence(2, [\\"banana\\", \\"anana\\"]) 5 >>> longest_palindromic_subsequence(4, [\\"aabbcc\\", \\"abcabc\\", \\"abcdcba\\", \\"abcba\\"]) 7 # TODO: implementation here","solution":"def longest_palindromic_subsequence_length(word): Given a word, find the length of the longest palindromic subsequence. n = len(word) dp = [[0] * n for _ in range(n)] for i in range(n): dp[i][i] = 1 for cl in range(2, n + 1): for i in range(n - cl + 1): j = i + cl - 1 if word[i] == word[j] and cl == 2: dp[i][j] = 2 elif word[i] == word[j]: dp[i][j] = dp[i + 1][j - 1] + 2 else: dp[i][j] = max(dp[i][j - 1], dp[i + 1][j]) return dp[0][n - 1] def longest_palindromic_subsequence(N, words): Given a list of words, find the longest palindromic subsequence that can be formed by deleting some characters from each word in the list. :param N: int, the number of words. :param words: list of strings, words to process. :return: int, the length of the longest palindromic subsequence. max_length = 0 for word in words: max_length = max(max_length, longest_palindromic_subsequence_length(word)) return max_length"},{"question":"def count_palindromes(sequences: List[str]) -> int: Count the number of palindromic sequences in the given list of strings. Parameters: sequences (list of str): List of strings to check for palindromes. Returns: int: The number of palindromic sequences. >>> count_palindromes([\\"level\\", \\"algorithm\\", \\"racecar\\", \\"each\\", \\"madam\\"]) 3 >>> count_palindromes([\\"hello\\", \\"world\\", \\"python\\", \\"programming\\"]) 0 >>> count_palindromes([\\"a\\", \\"b\\", \\"c\\"]) 3 >>> count_palindromes([\\"deified\\", \\"noon\\", \\"refer\\", \\"computer\\", \\"kayak\\"]) 4","solution":"def count_palindromes(sequences): Count the number of palindromic sequences in the given list of sequences. Parameters: sequences (list of str): List of strings to check for palindromes. Returns: int: The number of palindromic sequences. return sum(1 for sequence in sequences if sequence == sequence[::-1]) # Example usage: # sequences = [\\"level\\", \\"algorithm\\", \\"racecar\\", \\"each\\", \\"madam\\"] # result = count_palindromes(sequences) # print(result) # Output: 3"},{"question":"from typing import List def dailyTemperatures(T: List[int]) -> List[int]: Computes the number of days one would have to wait until a warmer temperature. >>> dailyTemperatures([73, 74, 75, 71, 69, 72, 76, 73]) [1, 1, 4, 2, 1, 1, 0, 0] >>> dailyTemperatures([70, 70, 70, 70]) [0, 0, 0, 0] >>> dailyTemperatures([70, 71, 72, 73]) [1, 1, 1, 0] >>> dailyTemperatures([73, 72, 71, 70]) [0, 0, 0, 0] >>> dailyTemperatures([70, 75, 71, 75, 70]) [1, 0, 1, 0, 0] >>> dailyTemperatures([80]) [0] >>> dailyTemperatures([100000] * 100000) [0] * 100000","solution":"from typing import List def dailyTemperatures(T: List[int]) -> List[int]: Returns the list where each index contains the number of days to wait until a warmer temperature. result = [0] * len(T) stack = [] # This will store the indices of the temperatures for i, temp in enumerate(T): while stack and T[stack[-1]] < temp: idx = stack.pop() result[idx] = i - idx stack.append(i) return result"},{"question":"def censor_text(text: str, forbidden_word: str) -> str: Replaces all instances of the forbidden word in the text with asterisks. Parameters: text (str): The original text. forbidden_word (str): The word to be censored. Returns: str: The censored text. Examples: >>> censor_text(\\"The quick brown fox jumps over the lazy dog\\", \\"lazy\\") 'The quick brown fox jumps over the **** dog' >>> censor_text(\\"She sells seashells by the seashore\\", \\"seashells\\") 'She sells ********* by the seashore' >>> censor_text(\\"I never saw a purple cow\\", \\"green\\") 'I never saw a purple cow'","solution":"def censor_text(text, forbidden_word): Replaces all instances of the forbidden word in the text with asterisks. Parameters: text (str): The original text. forbidden_word (str): The word to be censored. Returns: str: The censored text. return text.replace(forbidden_word, '*' * len(forbidden_word))"},{"question":"def max_enjoyment(n: int, enjoyments: List[int]) -> int: Find the maximum possible enjoyment Kevin can achieve without playing two consecutive games. Args: n (int): The number of games. enjoyments (List[int]): A list of integers representing the enjoyment levels of the games. Returns: int: The maximum possible enjoyment. Examples: >>> max_enjoyment(5, [1, 2, 3, 4, 5]) 9 >>> max_enjoyment(3, [3, 2, 1]) 4 >>> max_enjoyment(4, [3, 7, 2, 3]) 10 pass from max_enjoyment import max_enjoyment def test_single_game(): assert max_enjoyment(1, [10]) == 10 def test_two_games(): assert max_enjoyment(2, [10, 20]) == 20 assert max_enjoyment(2, [20, 10]) == 20 def test_example_1(): assert max_enjoyment(5, [1, 2, 3, 4, 5]) == 9 def test_example_2(): assert max_enjoyment(3, [3, 2, 1]) == 4 def test_example_3(): assert max_enjoyment(4, [3, 7, 2, 3]) == 10 def test_non_consecutive_max_sum(): assert max_enjoyment(6, [5, 1, 1, 5, 1, 10]) == 20 def test_edge_case_no_games(): assert max_enjoyment(0, []) == 0 def test_all_ones(): assert max_enjoyment(4, [1, 1, 1, 1]) == 2","solution":"def max_enjoyment(n, enjoyments): if n == 0: return 0 if n == 1: return enjoyments[0] # Create an array to store the maximum enjoyment up to each game dp = [0] * n dp[0] = enjoyments[0] dp[1] = max(enjoyments[0], enjoyments[1]) for i in range(2, n): dp[i] = max(dp[i - 1], dp[i - 2] + enjoyments[i]) return dp[-1]"},{"question":"from typing import List, Tuple def count_unpainted_segments(n: int, m: int, intervals: List[Tuple[int, int]]) -> int: Returns the number of unpainted segments after m intervals are painted on a road of n segments. :param n: int - Number of segments on the road :param m: int - Number of friends (intervals to be painted) :param intervals: list of tuples - Each tuple represents an interval (li, ri) :return: int - Number of unpainted segments >>> count_unpainted_segments(10, 2, [(1, 3), (4, 6)]) 4 >>> count_unpainted_segments(10, 1, [(1, 10)]) 0","solution":"def count_unpainted_segments(n, m, intervals): Returns the number of unpainted segments after m intervals are painted on a road of n segments. :param n: int - Number of segments on the road :param m: int - Number of friends (intervals to be painted) :param intervals: list of tuples - Each tuple represents an interval (li, ri) :return: int - Number of unpainted segments segments_painted = [0] * (n + 1) # This marks the painted segments # Mark the painted segments for li, ri in intervals: for i in range(li, ri + 1): segments_painted[i] = 1 # Count the unpainted segments unpainted_count = sum(1 for i in range(1, n + 1) if segments_painted[i] == 0) return unpainted_count"},{"question":"from typing import List def three_sum(nums: List[int], target: int) -> List[List[int]]: Find all unique triplets in the array that add up to a given target integer. >>> three_sum([-1, 0, 1, 2, -1, -4], 0) [[-1, -1, 2], [-1, 0, 1]] >>> three_sum([1, 2, 3, 4, 5], 9) [[1, 3, 5], [2, 3, 4]] >>> three_sum([1, 2, 3], 6) [[1, 2, 3]] >>> three_sum([0, 0, 0, 0], 0) [[0, 0, 0]] from solution import three_sum def test_three_sum_no_triplets(): assert three_sum([1, 2, 3], 10) == [] def test_three_sum_multiple_triplets(): assert three_sum([-1, 0, 1, 2, -1, -4], 0) == [[-1, -1, 2], [-1, 0, 1]] assert three_sum([1, 2, 3, 4, 5], 9) == [[1, 3, 5], [2, 3, 4]] def test_three_sum_single_triplet(): assert three_sum([1, 2, 3], 6) == [[1, 2, 3]] def test_three_sum_all_zeroes(): assert three_sum([0, 0, 0, 0], 0) == [[0, 0, 0]] def test_three_sum_duplicates_in_input(): assert three_sum([-2, 0, 1, 1, 2, 2], 1) == [[-2, 1, 2]]","solution":"def three_sum(nums, target): nums.sort() triplets = [] n = len(nums) for i in range(n-2): if i > 0 and nums[i] == nums[i-1]: continue left, right = i+1, n-1 while left < right: total = nums[i] + nums[left] + nums[right] if total == target: triplets.append([nums[i], nums[left], nums[right]]) while left < right and nums[left] == nums[left+1]: left += 1 while left < right and nums[right] == nums[right-1]: right -= 1 left += 1 right -= 1 elif total < target: left += 1 else: right -= 1 return triplets"},{"question":"from typing import List from itertools import permutations def count_valid_sequences(n: int, h: int) -> int: Returns the number of valid sequences in which the blocks can be arranged. >>> count_valid_sequences(3, 4) 24 >>> count_valid_sequences(2, 3) 6 >>> count_valid_sequences(4, 4) 24","solution":"from itertools import permutations def count_valid_sequences(n, h): Returns the number of valid sequences of heights. if n > h: return 0 heights = list(range(1, h + 1)) valid_sequences = permutations(heights, n) return len(list(valid_sequences))"},{"question":"class DigitalLibrary: A system to manage a large collection of books in a digital library. The library supports the following operations: - addBook(int bookId, List[str] keywords): Adds a book to the library. - searchBooksByKeyword(str keyword): Returns a list of book IDs associated with the keyword. - borrowBook(int bookId): Attempts to borrow the book. Returns True if successful, otherwise False. - returnBook(int bookId): Returns a borrowed book to the library. Example usage: >>> lib = DigitalLibrary() >>> lib.addBook(1, [\\"science\\", \\"fiction\\"]) >>> lib.addBook(2, [\\"fantasy\\", \\"magic\\"]) >>> lib.addBook(3, [\\"science\\", \\"non-fiction\\"]) >>> lib.searchBooksByKeyword(\\"science\\") == [1, 3] True >>> lib.borrowBook(1) True >>> lib.borrowBook(1) False >>> lib.returnBook(1) >>> lib.borrowBook(1) True","solution":"class DigitalLibrary: def __init__(self): self.books = {} self.keywords_map = {} self.borrowed_books = set() def addBook(self, bookId, keywords): # Add the book to the library self.books[bookId] = keywords # Index the book by its keywords for keyword in keywords: if keyword not in self.keywords_map: self.keywords_map[keyword] = [] self.keywords_map[keyword].append(bookId) def searchBooksByKeyword(self, keyword): if keyword in self.keywords_map: return sorted(self.keywords_map[keyword]) return [] def borrowBook(self, bookId): if bookId in self.books and bookId not in self.borrowed_books: self.borrowed_books.add(bookId) return True return False def returnBook(self, bookId): if bookId in self.borrowed_books: self.borrowed_books.remove(bookId)"},{"question":"def max_spell_power(number_of_mages: int, mages_spell_powers: List[List[int]]) -> List[int]: Returns a list of the maximum power value of spells for each mage. >>> max_spell_power(1, [[1, 10]]) [10] >>> max_spell_power(1, [[3, 4, 5, 6]]) [6] >>> max_spell_power(3, [[3, 4, 5, 6], [4, 7, 2, 9, 3], [2, 8, 1]]) [6, 9, 8] >>> max_spell_power(2, [[5, 999999, 1000000, 2, 3, 4], [4, 100, 200, 300, 400]]) [1000000, 400] >>> max_spell_power(4, [[2, 5, 9], [3, 11, 7, 3], [1, 15], [3, 19, 10, 1]]) [9, 11, 15, 19]","solution":"def max_spell_power(number_of_mages, mages_spell_powers): Returns a list of the maximum power value of spells for each mage. max_powers = [] for i in range(number_of_mages): si, *powers = mages_spell_powers[i] max_powers.append(max(powers)) return max_powers"},{"question":"def knapsack(W, weights, values, n): Determines the maximum value that fits in the knapsack with capacity W. :param W: int - maximum weight the knapsack can hold :param weights: list of int - weights of the items :param values: list of int - values of the items :param n: int - number of items :return: int - maximum value achievable within the weight constraint Example usage: >>> knapsack(50, [10, 20, 30], [60, 100, 120], 3) 220 >>> knapsack(10, [5, 4, 6, 3], [10, 40, 30, 50], 4) 90 >>> knapsack(7, [1, 3, 4, 5], [1, 4, 5, 7], 4) 9 >>> knapsack(10, [], [], 0) 0 >>> knapsack(0, [1, 2, 3], [10, 20, 30], 3) 0 >>> knapsack(5, [10, 20, 30], [60, 100, 120], 3) 0","solution":"def knapsack(W, weights, values, n): Determines the maximum value that fits in the knapsack with capacity W. :param W: int - maximum weight the knapsack can hold :param weights: list of int - weights of the items :param values: list of int - values of the items :param n: int - number of items :return: int - maximum value achievable within the weight constraint # Initialize DP table with 0's dp = [[0 for x in range(W + 1)] for x in range(n + 1)] # Build table dp[][] in a bottom-up manner for i in range(n + 1): for w in range(W + 1): if i == 0 or w == 0: dp[i][w] = 0 elif weights[i - 1] <= w: dp[i][w] = max(values[i - 1] + dp[i - 1][w - weights[i - 1]], dp[i - 1][w]) else: dp[i][w] = dp[i - 1][w] return dp[n][W] # Example usage: # W = 50, n = 3, weights = [10, 20, 30], values = [60, 100, 120] # print(knapsack(50, [10, 20, 30], [60, 100, 120], 3)) # Expected output: 220"},{"question":"def rotate_grid(grid, k): Rotates the given grid k times 90 degrees in a clockwise direction. :param grid: List of lists representing the grid :param k: Number of times to rotate the grid 90 degrees clockwise :return: Rotated grid >>> rotate_grid([[1, 2, 3], [4, 5, 6]], 1) [[4, 1], [5, 2], [6, 3]] >>> rotate_grid([[1, 2], [3, 4]], 3) [[2, 4], [1, 3]] >>> rotate_grid([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 2) [[9, 8, 7], [6, 5, 4], [3, 2, 1]] >>> rotate_grid([[1, 2], [3, 4]], 4) [[1, 2], [3, 4]] >>> rotate_grid([[1, 2, 3], [4, 5, 6]], 2) [[6, 5, 4], [3, 2, 1]]","solution":"def rotate_grid(grid, k): Rotates the given grid k times 90 degrees in a clockwise direction. :param grid: List of lists representing the grid :param k: Number of times to rotate the grid 90 degrees clockwise :return: Rotated grid n, m = len(grid), len(grid[0]) k = k % 4 # as rotating 4 times results in the same grid for _ in range(k): # Create a new grid with dimensions of m x n new_grid = [[0] * n for _ in range(m)] for i in range(n): for j in range(m): new_grid[j][n - 1 - i] = grid[i][j] grid = new_grid n, m = m, n # swap dimensions return grid def read_input(): Reads input from the user or a file import sys input = sys.stdin.read data = input().split() n = int(data[0]) m = int(data[1]) grid = [] index = 2 for i in range(n): row = list(map(int, data[index:index + m])) grid.append(row) index += m k = int(data[-1]) return grid, k def print_grid(grid): Prints the grid in the required format :param grid: List of lists representing the grid for row in grid: print(' '.join(map(str, row))) def main(): grid, k = read_input() rotated_grid = rotate_grid(grid, k) print_grid(rotated_grid) if __name__ == \\"__main__\\": main()"},{"question":"def min_moves_to_reach_target(n: int, grid: List[str], sx: int, sy: int, tx: int, ty: int) -> int: Returns the minimum number of moves required to reach the target from the start in a grid or -1 if it is not possible to reach the target. Args: n : int : size of the grid grid : List[str] : grid representation sx : int : starting position x sy : int : starting position y tx : int : target position x ty : int : target position y Returns: int : minimum number of moves to reach the target or -1 if not possible Example: >>> min_moves_to_reach_target(5, [ ... \\".....\\", ... \\"..#..\\", ... \\".....\\", ... \\".#.#.\\", ... \\".....\\"], 1, 1, 5, 5) 8 >>> min_moves_to_reach_target(3, [ ... \\"..#\\", ... \\".#.\\", ... \\"..#\\"], 1, 1, 3, 3) -1","solution":"from collections import deque def min_moves_to_reach_target(n, grid, sx, sy, tx, ty): Returns the minimum number of moves required to reach the target from the start in a grid or -1 if it is not possible to reach the target. directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] visited = [[False] * n for _ in range(n)] queue = deque([(sx - 1, sy - 1, 0)]) # use 0-based index for internal processing visited[sx - 1][sy - 1] = True while queue: x, y, dist = queue.popleft() if (x, y) == (tx - 1, ty - 1): return dist for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < n and not visited[nx][ny] and grid[nx][ny] == '.': visited[nx][ny] = True queue.append((nx, ny, dist + 1)) return -1 # Sample grid inputs for manual testing # grid = [ # \\".....\\", # \\"..#..\\", # \\".....\\", # \\".#.#.\\", # \\".....\\" # ] # print(min_moves_to_reach_target(5, grid, 1, 1, 5, 5)) # Expected output: 8"},{"question":"def is_well_formed(parentheses: str) -> str: Checks if the given string of parentheses is well-formed. Parameters: parentheses (str): A string consisting of characters '(' and ')'. Returns: str: \\"YES\\" if the string is well-formed, otherwise \\"NO\\". >>> is_well_formed(\\"()\\") \\"YES\\" >>> is_well_formed(\\"(())\\") \\"YES\\" >>> is_well_formed(\\"(()\\") \\"NO\\" >>> is_well_formed(\\")()\\"\\" \\"NO\\" from solution import is_well_formed def test_well_formed_balanced(): assert is_well_formed(\\"()\\") == \\"YES\\" assert is_well_formed(\\"(())\\") == \\"YES\\" assert is_well_formed(\\"((()))\\") == \\"YES\\" assert is_well_formed(\\"()()()\\") == \\"YES\\" def test_not_well_formed_unbalanced(): assert is_well_formed(\\"(()\\") == \\"NO\\" assert is_well_formed(\\"())\\") == \\"NO\\" assert is_well_formed(\\")(\\") == \\"NO\\" assert is_well_formed(\\"((())\\") == \\"NO\\" def test_not_well_formed_empty_cases(): assert is_well_formed(\\"(\\") == \\"NO\\" assert is_well_formed(\\")\\") == \\"NO\\" def test_mixed_cases(): assert is_well_formed(\\"(()())\\") == \\"YES\\" assert is_well_formed(\\"(()()(()))\\") == \\"YES\\" assert is_well_formed(\\"(()(()((())))\\") == \\"NO\\" assert is_well_formed(\\"())(()\\") == \\"NO\\"","solution":"def is_well_formed(parentheses): Checks if the given string of parentheses is well-formed. Parameters: parentheses (str): A string consisting of characters '(' and ')'. Returns: str: \\"YES\\" if the string is well-formed, otherwise \\"NO\\". stack = [] for char in parentheses: if char == '(': stack.append(char) elif char == ')': if not stack: return \\"NO\\" stack.pop() return \\"YES\\" if not stack else \\"NO\\""},{"question":"def num_islands(grid: List[str]) -> int: You are given a rectangular grid of size n by m, consisting of cells that are either land or water. You want to identify the minimum number of islands that are formed by land cells in the grid. An island is a group of land cells connected horizontally or vertically. Water cells are represented by '0' and land cells are represented by '1'. There are no diagonal connections between land cells. Design an algorithm to find the number of distinct islands in the grid. Parameters: grid (List[str]): A list of strings representing the grid. Returns: int: The number of distinct islands in the grid. Examples: >>> num_islands([ ... \\"11000\\", ... \\"11000\\", ... \\"00100\\", ... \\"00011\\" ... ]) 3 >>> num_islands([ ... \\"111\\", ... \\"010\\", ... \\"111\\" ... ]) 1 >>> num_islands([ ... \\"1110\\", ... \\"1100\\", ... \\"0001\\", ... \\"0011\\" ... ]) 2","solution":"def num_islands(grid): if not grid: return 0 n, m = len(grid), len(grid[0]) visited = [[False for _ in range(m)] for _ in range(n)] def dfs(x, y): if x < 0 or y < 0 or x >= n or y >= m or grid[x][y] == '0' or visited[x][y]: return visited[x][y] = True dfs(x + 1, y) dfs(x - 1, y) dfs(x, y + 1) dfs(x, y - 1) islands = 0 for i in range(n): for j in range(m): if grid[i][j] == '1' and not visited[i][j]: dfs(i, j) islands += 1 return islands"},{"question":"def longest_good_segment(n: int, T: int, a: List[int]) -> int: Given a sequence of n integers a_1, a_2, ..., a_n, finds the length of the longest \\"good segment\\". A \\"good segment\\" is defined as a contiguous subarray that contains distinct elements and has a sum less than or equal to a given threshold T. Returns the length of the longest good segment. >>> longest_good_segment(5, 10, [1, 2, 3, 4, 5]) 4 >>> longest_good_segment(6, 6, [6, 6, 6, 6, 6, 6]) 1 >>> longest_good_segment(5, 3, [1, 1, 1, 1, 1]) 1","solution":"def longest_good_segment(n, T, a): left = 0 current_sum = 0 longest_length = 0 elements = set() for right in range(n): while a[right] in elements: elements.remove(a[left]) current_sum -= a[left] left += 1 elements.add(a[right]) current_sum += a[right] while current_sum > T: elements.remove(a[left]) current_sum -= a[left] left += 1 longest_length = max(longest_length, right - left + 1) return longest_length"},{"question":"def min_trees_to_remove(n: int, heights: List[int]) -> int: Returns the minimum number of trees to be removed to ensure no two adjacent trees have the same height. >>> min_trees_to_remove(5, [3, 3, 3, 3, 3]) 2 >>> min_trees_to_remove(6, [1, 3, 1, 3, 1, 3]) 0 >>> min_trees_to_remove(4, [1, 2, 2, 1]) 1 from typing import List def test_example_1(): assert min_trees_to_remove(5, [3, 3, 3, 3, 3]) == 2 def test_example_2(): assert min_trees_to_remove(6, [1, 3, 1, 3, 1, 3]) == 0 def test_example_3(): assert min_trees_to_remove(4, [1, 2, 2, 1]) == 1 def test_single_tree(): assert min_trees_to_remove(1, [5]) == 0 def test_alternating_heights(): assert min_trees_to_remove(5, [1, 2, 1, 2, 1]) == 0 def test_two_trees_same_height(): assert min_trees_to_remove(2, [4, 4]) == 1 def test_two_trees_different_height(): assert min_trees_to_remove(2, [7, 8]) == 0 def test_all_same_heights(): assert min_trees_to_remove(4, [9, 9, 9, 9]) == 2 def test_already_alternating(): assert min_trees_to_remove(6, [5, 6, 5, 6, 5, 6]) == 0","solution":"def min_trees_to_remove(n, heights): Returns the minimum number of trees to be removed to ensure no two adjacent trees have the same height. :param n: Number of trees :param heights: List of tree heights :return: Minimum number of trees to be removed if n <= 1: return 0 count = 0 for i in range(1, n): if heights[i] == heights[i - 1]: count += 1 heights[i] = -1 # Temporarily mark the tree as removed return count"},{"question":"def caesar_cipher(n: int, s: str) -> str: Encrypts the string s using Caesar Cipher with a shift of n. Parameters: n (int): The shift value (1 ≤ n ≤ 25). s (str): The plaintext message to be encrypted. Returns: str: The encrypted message. >>> caesar_cipher(3, \\"Hello World\\") 'Khoor Zruog' >>> caesar_cipher(13, \\"abc xyz\\") 'nop klm'","solution":"def caesar_cipher(n, s): Encrypts the string s using Caesar Cipher with a shift of n. Parameters: n (int): The shift value (1 ≤ n ≤ 25). s (str): The plaintext message to be encrypted. Returns: str: The encrypted message. encrypted = [] for char in s: if 'A' <= char <= 'Z': # Shift uppercase letters new_char = chr((ord(char) - ord('A') + n) % 26 + ord('A')) encrypted.append(new_char) elif 'a' <= char <= 'z': # Shift lowercase letters new_char = chr((ord(char) - ord('a') + n) % 26 + ord('a')) encrypted.append(new_char) else: # Leave spaces unchanged encrypted.append(char) return ''.join(encrypted)"},{"question":"from typing import List def generate_matrix(n: int) -> List[List[int]]: Generates an n x n matrix where each element (i, j) is the product of (i+1) and (j+1). Args: n (int): Size of the matrix (1 <= n <= 100) Returns: List[List[int]]: The generated matrix pass # Unit Tests def test_generate_matrix_3x3(): expected = [ [1, 2, 3], [2, 4, 6], [3, 6, 9] ] assert generate_matrix(3) == expected def test_generate_matrix_5x5(): expected = [ [1, 2, 3, 4, 5], [2, 4, 6, 8, 10], [3, 6, 9, 12, 15], [4, 8, 12, 16, 20], [5, 10, 15, 20, 25] ] assert generate_matrix(5) == expected def test_generate_matrix_1x1(): expected = [ [1] ] assert generate_matrix(1) == expected def test_generate_matrix_2x2(): expected = [ [1, 2], [2, 4] ] assert generate_matrix(2) == expected def test_generate_matrix_4x4(): expected = [ [1, 2, 3, 4], [2, 4, 6, 8], [3, 6, 9, 12], [4, 8, 12, 16] ] assert generate_matrix(4) == expected","solution":"def generate_matrix(n): Generates an n x n matrix where each element (i, j) is the product of (i+1) and (j+1). Args: n (int): Size of the matrix (1 <= n <= 100) Returns: List[List[int]]: The generated matrix matrix = [] for i in range(n): row = [(i + 1) * (j + 1) for j in range(n)] matrix.append(row) return matrix"},{"question":"class DisjointSetUnion: def __init__(self, n): self.parent = list(range(n)) self.rank = [0] * n def find(self, u): if self.parent[u] != u: self.parent[u] = self.find(self.parent[u]) return self.parent[u] def union(self, u, v): root_u = self.find(u) root_v = self.find(v) if root_u != root_v: if self.rank[root_u] > self.rank[root_v]: self.parent[root_v] = root_u elif self.rank[root_u] < self.rank[root_v]: self.parent[root_u] = root_v else: self.parent[root_v] = root_u self.rank[root_u] += 1 def minimal_trading_cost(N, roads): Find the minimum possible total trading cost to establish the required trade network. >>> minimal_trading_cost(4, [(1, 2, 1), (1, 3, 3), (2, 3, 2), (2, 4, 4), (3, 4, 5)]) 7 >>> minimal_trading_cost(3, [(1, 2, 2), (2, 3, 3), (1, 3, 4)]) 5 if N == 1: return 0 roads.sort(key=lambda x: x[2]) dsu = DisjointSetUnion(N) total_cost = 0 edges_used = 0 for u, v, w in roads: if dsu.find(u - 1) != dsu.find(v - 1): dsu.union(u - 1, v - 1) total_cost += w edges_used += 1 if edges_used == N - 1: break return total_cost","solution":"class DisjointSetUnion: def __init__(self, n): self.parent = list(range(n)) self.rank = [0] * n def find(self, u): if self.parent[u] != u: self.parent[u] = self.find(self.parent[u]) return self.parent[u] def union(self, u, v): root_u = self.find(u) root_v = self.find(v) if root_u != root_v: if self.rank[root_u] > self.rank[root_v]: self.parent[root_v] = root_u elif self.rank[root_u] < self.rank[root_v]: self.parent[root_u] = root_v else: self.parent[root_v] = root_u self.rank[root_u] += 1 def minimal_trading_cost(N, roads): if N == 1: return 0 roads.sort(key=lambda x: x[2]) dsu = DisjointSetUnion(N) total_cost = 0 edges_used = 0 for u, v, w in roads: if dsu.find(u - 1) != dsu.find(v - 1): dsu.union(u - 1, v - 1) total_cost += w edges_used += 1 if edges_used == N - 1: break return total_cost if __name__ == \\"__main__\\": # Example usage: print(minimal_trading_cost(4, [(1, 2, 1), (1, 3, 3), (2, 3, 2), (2, 4, 4), (3, 4, 5)])) # Output: 7 print(minimal_trading_cost(3, [(1, 2, 2), (2, 3, 3), (1, 3, 4)])) # Output: 5"},{"question":"from typing import List def transform_array_to_median(arr: List[int]) -> List[int]: Transforms the given array where each element (except the first and last) is replaced by the median of itself and its two neighbors in the original array. :param arr: List[int] - input array of integers :return: List[int] - transformed array pass # Example test cases def test_example_case(): assert transform_array_to_median([2, 1, 5, 7, 2]) == [2, 2, 5, 5, 2] def test_single_element(): assert transform_array_to_median([1]) == [1] def test_two_elements(): assert transform_array_to_median([1, 2]) == [1, 2] def test_all_elements_same(): assert transform_array_to_median([3, 3, 3, 3, 3]) == [3, 3, 3, 3, 3] def test_increasing_elements(): assert transform_array_to_median([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5] def test_decreasing_elements(): assert transform_array_to_median([5, 4, 3, 2, 1]) == [5, 4, 3, 2, 1] def test_mixed_elements(): assert transform_array_to_median([-1, -1000000, 1000000, 0, -1]) == [-1, -1, 0, 0, -1] def test_zero_elements(): assert transform_array_to_median([0, 0, 0, 0, 0]) == [0, 0, 0, 0, 0] def test_large_array(): large_array = list(range(100000)) # we can't define the expected output manually due to the large size result = transform_array_to_median(large_array) assert result[0] == 0 assert result[-1] == 99999 assert len(result) == 100000","solution":"def transform_array_to_median(arr): Transforms the given array where each element (except the first and last) is replaced by the median of itself and its two neighbors in the original array. :param arr: List[int] - input array of integers :return: List[int] - transformed array if len(arr) < 3: return arr # No transformation is needed for arrays with fewer than 3 elements. def median_of_three(a, b, c): Helper function to find the median of three numbers return sorted([a, b, c])[1] transformed = [arr[0]] # First element remains unchanged for i in range(1, len(arr) - 1): transformed.append(median_of_three(arr[i - 1], arr[i], arr[i + 1])) transformed.append(arr[-1]) # Last element remains unchanged return transformed"},{"question":"def alice_score(s: str) -> int: Compute the score achieved by Alice by the end of the game. Args: s (str): input string Returns: int: Alice's score (number of turns Alice takes) Examples: >>> alice_score(\\"ababa\\") 3 >>> alice_score(\\"aaaa\\") 1 >>> alice_score(\\"abcabc\\") 3 from solution import alice_score def test_alice_score_example1(): assert alice_score(\\"ababa\\") == 3 def test_alice_score_example2(): assert alice_score(\\"aaaa\\") == 1 def test_alice_score_example3(): assert alice_score(\\"abcabc\\") == 3 def test_alice_score_single_character(): assert alice_score(\\"a\\") == 1 def test_alice_score_no_adjacent_equal(): assert alice_score(\\"abcdef\\") == 3 def test_alice_score_all_same_characters(): assert alice_score(\\"bbbbbbbb\\") == 1 def test_alice_score_mixed_characters(): assert alice_score(\\"aabbccddeeffgghh\\") == 8 def test_alice_score_alternate_pattern(): assert alice_score(\\"ababababab\\") == 5","solution":"def alice_score(s): Compute the score achieved by Alice by the end of the game. The function counts the number of turns Alice can take based on the rule that no two adjacent characters in the string can be the same. Parameters: s (str): input string Returns: int: Alice's score (number of turns Alice takes) score = 0 n = len(s) i = 0 while i < n: # Alice tries to make a move while i + 1 < n and s[i] == s[i + 1]: i += 1 if i < n: score += 1 i += 1 # Bob's turn (he tries to move once) if i < n: i += 1 return score # Examples print(alice_score(\\"ababa\\")) # Output: 3 print(alice_score(\\"aaaa\\")) # Output: 1 print(alice_score(\\"abcabc\\")) # Output: 3"},{"question":"def parse_input(input_str: str) -> str: Determines if there is a collision of trucks at any checkpoint at the same timestamp. Args: input_str (str): Multiline string of trips data containing t, the number of trips, followed by the description of each trip in the specified format. Returns: str: \\"collision\\" if any two trucks are logged at the same checkpoint at the exact same timestamp, otherwise \\"no collision\\". >>> input_str = '''2 ... 03:00 08:30 ... 4 ... 04:30 1 ... 05:15 2 ... 06:50 3 ... 08:00 4 ... 12:00 17:00 ... 3 ... 12:30 1 ... 14:00 3 ... 16:45 2''' >>> parse_input(input_str) \\"no collision\\" >>> input_str = '''2 ... 05:00 09:30 ... 4 ... 06:00 1 ... 07:30 2 ... 08:15 3 ... 09:00 1 ... 04:45 10:00 ... 5 ... 05:30 1 ... 07:30 2 ... 08:15 2 ... 09:00 4 ... 09:45 5''' >>> parse_input(input_str) \\"collision\\"","solution":"def detect_collision(trips): timestamp_checkpoint_map = {} for trip in trips: start, end = trip[0], trip[1] checkpoints = trip[2] for timestamp, checkpoint_id in checkpoints: if (timestamp, checkpoint_id) in timestamp_checkpoint_map: return \\"collision\\" timestamp_checkpoint_map[(timestamp, checkpoint_id)] = True return \\"no collision\\" def parse_input(input_str): data = input_str.strip().split('n') t = int(data[0]) trips = [] index = 1 for _ in range(t): start, end = data[index].split() index += 1 k = int(data[index]) index += 1 checkpoints = [] for _ in range(k): timestamp, checkpoint_id = data[index].split() checkpoints.append((timestamp, int(checkpoint_id))) index += 1 trips.append((start, end, checkpoints)) return detect_collision(trips) # Example usage example_input_1 = '''2 03:00 08:30 4 04:30 1 05:15 2 06:50 3 08:00 4 12:00 17:00 3 12:30 1 14:00 3 16:45 2''' example_input_2 = '''2 05:00 09:30 4 06:00 1 07:30 2 08:15 3 09:00 1 04:45 10:00 5 05:30 1 07:30 2 08:15 2 09:00 4 09:45 5''' print(parse_input(example_input_1)) # Should print \\"no collision\\" print(parse_input(example_input_2)) # Should print \\"collision\\""},{"question":"from collections import deque def min_moves_to_deliver(n: int, grid: List[str]) -> int: Returns the minimum number of moves required for the drone to reach the delivery point from the starting point in the given grid. If it's impossible, returns -1. >>> min_moves_to_deliver(5, [\\".....\\", \\".X.X.\\", \\".X...\\", \\"....X\\", \\"X....\\"]) 8 >>> min_moves_to_deliver(3, [\\"X..\\", \\"XX.\\", \\"...\\"]) -1","solution":"from collections import deque def min_moves_to_deliver(n, grid): Returns the minimum number of moves required for the drone to reach the delivery point from the starting point in the given grid. If it's impossible, returns -1. if grid[0][0] == 'X' or grid[n-1][n-1] == 'X': return -1 directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] queue = deque([(0, 0, 0)]) # (row, column, distance) visited = set((0, 0)) while queue: row, col, dist = queue.popleft() if row == n-1 and col == n-1: return dist for dr, dc in directions: nr, nc = row + dr, col + dc if 0 <= nr < n and 0 <= nc < n and grid[nr][nc] == '.' and (nr, nc) not in visited: visited.add((nr, nc)) queue.append((nr, nc, dist+1)) return -1"},{"question":"def update_stock_levels(n: int, m: int, initial_stocks: List[int], transactions: List[Tuple[int, int]]) -> List[int]: Updates the stock levels of items after processing all transactions. Parameters: n (int): Number of items. m (int): Number of transactions. initial_stocks (list of int): List of initial stock levels of each item. transactions (list of tuple): List of transactions where each transaction is a tuple (item type, quantity sold). Returns: list of int: Final stock levels of each item. Example: >>> update_stock_levels(5, 3, [10, 20, 30, 40, 50], [(1, 5), (3, 25), (2, 10)]) [5, 10, 5, 40, 50] >>> update_stock_levels(3, 2, [5, 10, 15], [(1, 2), (2, 5)]) [3, 5, 15]","solution":"def update_stock_levels(n, m, initial_stocks, transactions): Updates the stock levels of items after processing all transactions. Parameters: n (int): Number of items. m (int): Number of transactions. initial_stocks (list of int): List of initial stock levels of each item. transactions (list of tuple): List of transactions where each transaction is a tuple (item type, quantity sold). Returns: list of int: Final stock levels of each item. for t_j, u_j in transactions: initial_stocks[t_j - 1] -= u_j return initial_stocks"},{"question":"def min_path_cost(grid: List[List[int]]) -> int: Calculate the minimum cost to reach the bottom-right cell from the top-left cell of a grid. >>> min_path_cost([ ... [1, 3, 1], ... [1, 5, 1], ... [4, 2, 1] ... ]) 7 >>> min_path_cost([ ... [1, 2], ... [1, 1] ... ]) 3","solution":"def min_path_cost(grid): n = len(grid) dp = [[0] * n for _ in range(n)] dp[0][0] = grid[0][0] for i in range(1, n): dp[0][i] = dp[0][i-1] + grid[0][i] dp[i][0] = dp[i-1][0] + grid[i][0] for i in range(1, n): for j in range(1, n): dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j] return dp[-1][-1] def process_input(): import sys input = sys.stdin.read data = input().split() n = int(data[0]) grid = [] index = 1 for i in range(n): grid.append(list(map(int, data[index:index + n]))) index += n return grid"},{"question":"def longest_common_subsequence(n: int, a: List[int], m: int, b: List[int]) -> int: Given two sequences of integers, find the length of the longest subsequence that is a subsequence of both sequences. A subsequence is a sequence derived from another sequence by deleting some or no elements without changing the order of the remaining elements. >>> longest_common_subsequence(3, [1, 3, 4], 4, [1, 3, 4, 5]) 3 >>> longest_common_subsequence(5, [1, 3, 5, 9, 10], 4, [1, 4, 9, 10]) 3 >>> longest_common_subsequence(4, [2, 3, 7, 8], 4, [5, 6, 7, 8]) 2","solution":"def longest_common_subsequence(n, a, m, b): Function to find the length of the longest common subsequence between two sequences. dp = [[0] * (m + 1) for _ in range(n + 1)] for i in range(1, n + 1): for j in range(1, m + 1): if a[i - 1] == b[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) return dp[n][m]"},{"question":"def max_reachable_height_difference(grid: List[List[int]]) -> int: Given a grid with heights, returns the maximum reachable height difference. >>> max_reachable_height_difference([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) 8 >>> max_reachable_height_difference([[1, 3, 2]]) 2 >>> max_reachable_height_difference([[1], [3], [2]]) 2 >>> max_reachable_height_difference([[3, 3, 3], [3, 3, 3], [3, 3, 3]]) 0 >>> max_reachable_height_difference([[1, 10, 3], [7, 6, 5], [2, 4, 9]]) 9 >>> max_reachable_height_difference([[1, 2, 3, 4, 5], [2, 3, 4, 5, 6], [3, 4, 5, 6, 7], [4, 5, 6, 7, 8], [5, 6, 7, 8, 9]]) 8","solution":"def max_reachable_height_difference(grid): Given a grid with heights, returns the maximum reachable height difference. min_height = float('inf') max_height = float('-inf') for row in grid: for height in row: if height < min_height: min_height = height if height > max_height: max_height = height return max_height - min_height"},{"question":"def final_coordinates(commands: str) -> tuple[int, int]: Determine the final position of the robotic arm after following a given sequence of commands. Commands: - 'L': move left by 1 unit - 'R': move right by 1 unit - 'U': move up by 1 unit - 'D': move down by 1 unit Parameters: commands (str): String of commands consisting of 'L', 'R', 'U', 'D' Returns: tuple: Final coordinates (x, y) of the robotic arm >>> final_coordinates(\\"LURD\\") (0, 0) >>> final_coordinates(\\"LLRRUUDD\\") (0, 0) >>> final_coordinates(\\"UUDDLLRR\\") (0, 0) >>> final_coordinates(\\"LLL\\") (-3, 0) >>> final_coordinates(\\"RRRR\\") (4, 0) >>> final_coordinates(\\"UUU\\") (0, 3) >>> final_coordinates(\\"DDDDDDD\\") (0, -7) >>> final_coordinates(\\"LURLDUDR\\") (0, 0) >>> final_coordinates(\\"ULDR\\") (0, 0) >>> final_coordinates(\\"RULD\\") (0, 0) >>> final_coordinates(\\"DRUL\\") (0, 0)","solution":"def final_coordinates(commands): Given a string of commands, compute the final coordinates of the robotic arm after executing all the commands. Commands: - 'L': move left by 1 unit - 'R': move right by 1 unit - 'U': move up by 1 unit - 'D': move down by 1 unit Parameters: commands (str): String of commands consisting of 'L', 'R', 'U', 'D' Returns: tuple: Final coordinates (x, y) of the robotic arm x, y = 0, 0 for command in commands: if command == 'L': x -= 1 elif command == 'R': x += 1 elif command == 'U': y += 1 elif command == 'D': y -= 1 return x, y"},{"question":"MOD = 1_000_000_007 def bin_configurations(n: int, categories: List[int]) -> int: Compute the number of distinct possible configurations of bins in the warehouse, modulo 1,000,000,007. >>> bin_configurations(5, [1, 1, 2, 3, 3]) 3 >>> bin_configurations(4, [1, 2, 2, 3]) 6 >>> bin_configurations(3, [1, 1, 1]) 1 pass # Unit Tests from math import factorial from solution import bin_configurations def test_example_1(): n = 5 categories = [1, 1, 2, 3, 3] assert bin_configurations(n, categories) == factorial(5) % 1_000_000_007 def test_example_2(): n = 4 categories = [1, 2, 2, 3] assert bin_configurations(n, categories) == factorial(4) % 1_000_000_007 def test_example_3(): n = 3 categories = [1, 1, 1] assert bin_configurations(n, categories) == factorial(3) % 1_000_000_007 def test_single_bin(): n = 1 categories = [1] assert bin_configurations(n, categories) == factorial(1) % 1_000_000_007 def test_large_but_same_category(): n = 5 categories = [1, 1, 1, 1, 1] assert bin_configurations(n, categories) == factorial(5) % 1_000_000_007 def test_large_different_categories(): n = 6 categories = [1, 2, 3, 4, 5, 6] assert bin_configurations(n, categories) == factorial(6) % 1_000_000_007","solution":"MOD = 1_000_000_007 def bin_configurations(n, categories): from collections import Counter import math # Count the occurrence of each category category_count = Counter(categories) # All bins can be merged into one bin through a series of operations return math.factorial(n) % MOD"},{"question":"def maxHeightDifference(heights: List[int]) -> int: Calculates the maximum height difference between two successive elements in the array. Args: heights (List[int]): A list of integers representing the heights at different points on the ride. Returns: int: The maximum height difference. >>> maxHeightDifference([3, 7, 12, 6, 2]) 6 >>> maxHeightDifference([1, 3, 6, 10, 15]) 5 >>> maxHeightDifference([-1, -5, -10, -20]) 10 >>> maxHeightDifference([-2, 4, -7, 10]) 17 >>> maxHeightDifference([5, 5, 5, 5, 5]) 0 >>> maxHeightDifference([1, 2, 3, 4, 5]) 1 >>> maxHeightDifference([5, 4, 3, 2, 1]) 1 >>> maxHeightDifference([-1000, 1000, -500, 500, 0]) 2000","solution":"def maxHeightDifference(heights): Returns the maximum height difference between two successive elements in the array. max_diff = 0 for i in range(1, len(heights)): diff = abs(heights[i] - heights[i - 1]) if diff > max_diff: max_diff = diff return max_diff"},{"question":"def is_binary_palindrome(n: int) -> bool: Check if the binary representation of a given positive integer is a palindrome. Args: n (int): A positive integer (1 ≤ n ≤ 10^6). Returns: bool: True if the binary representation of n is a palindrome, False otherwise. Examples: >>> is_binary_palindrome(9) True >>> is_binary_palindrome(10) False >>> is_binary_palindrome(3) True","solution":"def is_binary_palindrome(n: int) -> bool: Check if the binary representation of a given integer is a palindrome. Args: n (int): A positive integer. Returns: bool: True if the binary representation of n is a palindrome, False otherwise. binary_rep = bin(n)[2:] # Get binary representation of n and remove the '0b' prefix. # Check if the binary string is a palindrome. left, right = 0, len(binary_rep) - 1 while left < right: if binary_rep[left] != binary_rep[right]: return False left += 1 right -= 1 return True"},{"question":"def evaluate_expression(expression: str) -> int: Evaluates a mathematical expression containing integers, addition, and subtraction. >>> evaluate_expression(\\"10+2-6\\") 6 >>> evaluate_expression(\\"100-50+25-25\\") 50 >>> evaluate_expression(\\"5+5+5+5\\") 20 pass from evaluate_expression import evaluate_expression def test_simple_addition(): assert evaluate_expression(\\"2+3\\") == 5 def test_simple_subtraction(): assert evaluate_expression(\\"10-3\\") == 7 def test_mixed_operations(): assert evaluate_expression(\\"10+2-6\\") == 6 assert evaluate_expression(\\"100-50+25-25\\") == 50 def test_all_additions(): assert evaluate_expression(\\"5+5+5+5\\") == 20 def test_negative_result(): assert evaluate_expression(\\"1-2-3\\") == -4 def test_large_numbers(): assert evaluate_expression(\\"1000+2000-3000\\") == 0 def test_single_number(): assert evaluate_expression(\\"100\\") == 100 assert evaluate_expression(\\"-100\\") == -100 def test_multiple_digits_numbers(): assert evaluate_expression(\\"10+20-5\\") == 25 def test_complex_expression(): assert evaluate_expression(\\"10+20-5+30-15+5\\") == 45","solution":"def evaluate_expression(expression): Evaluates a mathematical expression containing integers, addition, and subtraction. result = 0 current_number = 0 sign = 1 # 1 represents '+' and -1 represents '-' for char in expression: if char.isdigit(): current_number = current_number * 10 + int(char) elif char == '+' or char == '-': result += sign * current_number current_number = 0 sign = 1 if char == '+' else -1 # Add the last number to the result result += sign * current_number return result"},{"question":"def calculate_average_stock_price(n: int, transactions: List[str]) -> float: Evaluate the performance of a virtual stock portfolio over time based on given transactions. Args: n (int): The number of transactions. transactions (List[str]): A list of transactions in the format as described. Returns: float: The average stock price in the portfolio after executing all transactions, rounded to 2 decimal places. Examples: >>> calculate_average_stock_price(5, [\\"A 1 100\\", \\"A 2 200\\", \\"U 1 150\\", \\"A 3 250\\", \\"U 2 180\\"]) == 193.33 >>> calculate_average_stock_price(3, [\\"A 1 100\\", \\"A 2 200\\", \\"U 2 250\\"]) == 175.00 from typing import List def test_calculate_average_stock_price(): transactions = [ \\"A 1 100\\", \\"A 2 200\\", \\"U 1 150\\", \\"A 3 250\\", \\"U 2 180\\" ] assert calculate_average_stock_price(5, transactions) == 193.33 def test_calculate_average_stock_price_with_few_transactions(): transactions = [ \\"A 1 100\\", \\"A 2 200\\", \\"U 2 250\\" ] assert calculate_average_stock_price(3, transactions) == 175.00 def test_calculate_average_stock_price_with_single_transaction(): transactions = [ \\"A 1 100\\" ] assert calculate_average_stock_price(1, transactions) == 100.00 def test_calculate_average_stock_price_with_initial_adds_and_no_updates(): transactions = [ \\"A 1 100\\", \\"A 2 200\\", \\"A 3 300\\" ] assert calculate_average_stock_price(3, transactions) == 200.00 def test_calculate_average_stock_price_with_multiple_updates(): transactions = [ \\"A 1 100\\", \\"A 2 200\\", \\"U 1 120\\", \\"U 2 180\\" ] assert calculate_average_stock_price(4, transactions) == 150.00","solution":"def calculate_average_stock_price(n, transactions): portfolio = {} total_sum = 0 stock_count = 0 for transaction in transactions: t_type, d, p = transaction.split() d = int(d) p = int(p) if t_type == 'A': portfolio[d] = p total_sum += p stock_count += 1 elif t_type == 'U': total_sum += p - portfolio[d] portfolio[d] = p if stock_count == 0: return 0.00 average_price = total_sum / stock_count return round(average_price, 2)"},{"question":"def max_tracks(n: int, segments: List[int]) -> None: Ali is setting up an amusement park and needs to build roller coaster tracks. Each track is constructed using segments of rails of different lengths. Ali has collected n rail segments with lengths l1, l2, ..., ln. Each track requires three segments of rails where the length of one segment must be strictly greater than the lengths of the other two, which must be different as well. Help Ali determine the maximum number of tracks that can be built under these conditions. Input The first line contains an integer n (1 ≤ n ≤ 105) — the number of rail segments. The next line contains n integers — the lengths of the rail segments l1, l2, ..., ln (1 ≤ li ≤ 109). The rail segments' lengths can coincide. Output Print the first line with a single number t — the maximum number of tracks. The next t lines should contain the tracks' descriptions. The description of each track should consist of three space-separated numbers — the longest segment's length, the medium segment's length, and the smallest segment's length. It is allowed to print the tracks in any order. If there are several solutions, print any of them. >>> max_tracks(8, [3, 3, 4, 4, 5, 6, 7, 8]) 2 5 4 3 8 7 6 >>> max_tracks(3, [1, 1, 2]) 0 pass # Unit Test def test_max_tracks(): import io import sys from contextlib import redirect_stdout # Helper function to retrieve printed output def get_function_output(n, segments): f = io.StringIO() with redirect_stdout(f): max_tracks(n, segments) return f.getvalue().splitlines() # Test case 1 output = get_function_output(8, [3, 3, 4, 4, 5, 6, 7, 8]) assert output[0] == '2' assert output[1] == '5 4 3' or output[2] == '5 4 3' assert output[2] == '8 7 6' or output[1] == '8 7 6' # Test case 2 output = get_function_output(3, [1, 1, 2]) assert output[0] == '0'","solution":"def max_tracks(n, segments): from collections import Counter count = Counter(segments) segments = sorted(count.items(), key=lambda x: -x[0]) tracks = [] while True: if len(segments) < 3: break # Collect candidates for the track candidates = [] for i in range(3): if segments[i][1] > 0: candidates.append(segments[i]) else: break if len(candidates) < 3: break track = sorted([candidates[0][0], candidates[1][0], candidates[2][0]], reverse=True) for j in range(3): count[track[j]] -= 1 for idx in range(3): if count[track[idx]] == 0: segments.remove(candidates[idx]) tracks.append(track) print(len(tracks)) for t in tracks: print(\\" \\".join(map(str, t))) # Example usage input_data = [ (8, [3, 3, 4, 4, 5, 6, 7, 8]), (3, [1, 1, 2]) ] for n, segments in input_data: max_tracks(n, segments)"},{"question":"def max_targets_eliminated(L: int, R: int, points: List[int]) -> int: Determines the maximum number of targets that can be eliminated within the given point range [L, R]. Args: L (int): Lower bound of the range. R (int): Upper bound of the range. points (list of int): List containing the points of each target. Returns: int: Maximum number of targets that can be eliminated. >>> max_targets_eliminated(3, 6, [2, 3, 5, 7, 8]) 2 >>> max_targets_eliminated(10, 20, [1, 2, 3, 4, 5]) 0 >>> max_targets_eliminated(0, 10, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) 10 >>> max_targets_eliminated(5, 15, [4, 5, 6, 10, 11, 15, 16]) 5 >>> max_targets_eliminated(1, 100, []) 0","solution":"def max_targets_eliminated(L, R, points): Determines the maximum number of targets that can be eliminated within the given point range [L, R]. Args: L (int): Lower bound of the range. R (int): Upper bound of the range. points (list of int): List containing the points of each target. Returns: int: Maximum number of targets that can be eliminated. count = 0 for point in points: if L <= point <= R: count += 1 return count"},{"question":"def can_form_palindrome(s: str) -> str: Determines if the string can be rearranged to form a palindrome. Args: s (str): the input string consisting of lowercase English letters. Returns: str: \\"YES\\" if the string can be rearranged to form a palindrome, otherwise \\"NO\\". >>> can_form_palindrome(\\"civic\\") \\"YES\\" >>> can_form_palindrome(\\"ivicc\\") \\"YES\\" >>> can_form_palindrome(\\"hello\\") \\"NO\\"","solution":"def can_form_palindrome(s): Returns \\"YES\\" if the string can be rearranged to form a palindrome, otherwise returns \\"NO\\". from collections import Counter char_count = Counter(s) odd_count = sum(1 for count in char_count.values() if count % 2 != 0) if odd_count > 1: return \\"NO\\" else: return \\"YES\\""},{"question":"def kth_smallest_prime_factor(t: int, cases: List[Tuple[int, int]]) -> List[int]: Determine the k-th smallest prime factor for given n in multiple test cases. Parameters: t (int): The number of test cases. cases (List[Tuple[int, int]]): Each tuple contains (n: int, k: int) where n is the number to factorize and k is the k-th smallest prime factor to find. Returns: List[int]: The k-th smallest prime factor for each test case, or -1 if not enough factors exist. Examples: >>> kth_smallest_prime_factor(3, [(12, 2), (30, 3), (27, 2)]) [3, 5, -1] >>> kth_smallest_prime_factor(2, [(10, 3), (45, 4)]) [-1, -1] >>> kth_smallest_prime_factor(1, [(1000000007, 1)]) [1000000007]","solution":"def kth_smallest_prime_factor(t, cases): def prime_factors(n): factors = [] # Check for number of 2s that divide n while n % 2 == 0: factors.append(2) n //= 2 # n must be odd at this point, so check for odd numbers for i in range(3, int(n**0.5) + 1, 2): while n % i == 0: factors.append(i) n //= i # This condition is to check if n is a prime number greater than 2 if n > 2: factors.append(n) return factors results = [] for n, k in cases: factors = prime_factors(n) unique_factors = sorted(set(factors)) # Get unique prime factors if len(unique_factors) >= k: results.append(unique_factors[k - 1]) else: results.append(-1) return results"},{"question":"def alien_order(words: List[str]) -> str: Determines the order of characters in an alien language based on sorted words. :param words: List[str] - A list of words sorted lexicographically in the alien language :return: str - A string representing the order of characters in the alien language or an empty string if no valid order exists >>> alien_order([\\"wrt\\", \\"wrf\\", \\"er\\", \\"ett\\", \\"rftt\\"]) in {\\"wertf\\", \\"wert\\"} True >>> alien_order([\\"z\\", \\"x\\"]) 'zx' >>> alien_order([\\"z\\", \\"x\\", \\"z\\"]) '' >>> alien_order([\\"abc\\", \\"ab\\"]) '' >>> alien_order([\\"a\\"]) # Single word case 'a' >>> alien_order([\\"a\\", \\"b\\"]) in {\\"ab\\", \\"ba\\"} # Multiple valid solutions True >>> alien_order([\\"baa\\", \\"abcd\\", \\"abca\\", \\"cab\\", \\"cad\\"]) in {\\"bdac\\", \\"bdca\\"} True","solution":"from collections import defaultdict, deque def alien_order(words): Determines the order of characters in an alien language based on sorted words. :param words: List[str] - A list of words sorted lexicographically in the alien language :return: str - A string representing the order of characters in the alien language or an empty string if no valid order exists # Step 1: Create a graph graph = defaultdict(set) in_degree = {c: 0 for word in words for c in word} # Step 2: Build the graph and find all edges for first, second in zip(words, words[1:]): for c1, c2 in zip(first, second): if c1 != c2: if c2 not in graph[c1]: graph[c1].add(c2) in_degree[c2] += 1 break else: if len(second) < len(first): return \\"\\" # Step 3: Topological Sort using Kahn's Algorithm (BFS) zero_in_degree_queue = deque([c for c in in_degree if in_degree[c] == 0]) order = [] while zero_in_degree_queue: current_char = zero_in_degree_queue.popleft() order.append(current_char) for neighbour in graph[current_char]: in_degree[neighbour] -= 1 if in_degree[neighbour] == 0: zero_in_degree_queue.append(neighbour) # If all characters are in the order list, return the order if len(order) == len(in_degree): return ''.join(order) else: return \\"\\""},{"question":"from typing import List def find_duplicate(nums: List[int]) -> int: Finds the duplicate number in an array containing n+1 integers, where each integer is in the range [1, n] inclusive. >>> find_duplicate([1, 3, 4, 2, 2]) 2 >>> find_duplicate([3, 1, 3, 4, 2, 5]) 3 >>> find_duplicate([1, 1, 2]) 1 pass def test_find_duplicate_example_1(): nums = [1, 3, 4, 2, 2] assert find_duplicate(nums) == 2 def test_find_duplicate_example_2(): nums = [3, 1, 3, 4, 2, 5] assert find_duplicate(nums) == 3 def test_find_duplicate_example_3(): nums = [1, 1, 2] assert find_duplicate(nums) == 1 def test_find_duplicate_longer_sequence(): nums = [9, 6, 3, 1, 7, 8, 2, 5, 4, 7] assert find_duplicate(nums) == 7 def test_find_duplicate_with_multiple_repeats(): nums = [2, 2, 2, 2, 2] assert find_duplicate(nums) == 2 def test_find_duplicate_single_element_sequence(): nums = [2, 1, 2] assert find_duplicate(nums) == 2 def test_find_duplicate_unordered_sequence(): nums = [2, 5, 9, 6, 9, 3, 8, 9, 7, 1] assert find_duplicate(nums) == 9","solution":"def find_duplicate(nums): Finds the duplicate number in an array containing n+1 integers, where each integer is in the range [1, n] inclusive. # Using Floyd's Tortoise and Hare (Cycle Detection) to find the duplicate number slow = fast = nums[0] # Phase 1: Finding the intersection point of the two runners while True: slow = nums[slow] fast = nums[nums[fast]] if slow == fast: break # Phase 2: Find the entrance to the cycle, which is the duplicate number. slow = nums[0] while slow != fast: slow = nums[slow] fast = nums[fast] return slow"},{"question":"def can_group_books(n: int, books: List[Tuple[str, str, int]], max_pages: int) -> str: Determine if it's possible to group books by genre and author without exceeding max pages. Args: n (int): The number of books. books (List[Tuple[str, str, int]]): A list of tuples, each containing the genre (str), author (str), and number of pages (int). max_pages (int): The maximum number of pages allowed in a group. Returns: str: \\"YES\\" if it's possible to group the books as described, \\"NO\\" otherwise. >>> can_group_books(5, [(\\"Fiction\\", \\"Alice\\", 320), (\\"Fiction\\", \\"Bob\\", 150), (\\"Mystery\\", \\"Alice\\", 200), (\\"Fiction\\", \\"Alice\\", 100), (\\"Mystery\\", \\"Bob\\", 300)], 500) \\"YES\\" >>> can_group_books(4, [(\\"Fantasy\\", \\"John\\", 600), (\\"Fantasy\\", \\"John\\", 400), (\\"SciFi\\", \\"Clark\\", 300), (\\"SciFi\\", \\"Clark\\", 700)], 750) \\"NO\\" >>> can_group_books(1, [(\\"Fantasy\\", \\"John\\", 300)], 1000) \\"YES\\" >>> can_group_books(1, [(\\"Fantasy\\", \\"John\\", 1100)], 1000) \\"NO\\" >>> can_group_books(2, [(\\"Fantasy\\", \\"John\\", 300), (\\"SciFi\\", \\"John\\", 400)], 500) \\"YES\\" >>> can_group_books(3, [(\\"Fantasy\\", \\"John\\", 200), (\\"Fantasy\\", \\"John\\", 150), (\\"Fantasy\\", \\"John\\", 100)], 500) \\"YES\\" >>> can_group_books(3, [(\\"Fantasy\\", \\"John\\", 300), (\\"Fantasy\\", \\"John\\", 250), (\\"Fantasy\\", \\"John\\", 100)], 500) \\"NO\\"","solution":"def can_group_books(n, books, max_pages): from collections import defaultdict # Dictionary to store the total pages for each genre-author pair genre_author_pages = defaultdict(int) # Populate the dictionary with the books' data for book in books: genre, author, pages = book genre_author_pages[(genre, author)] += pages # Check if any genre-author pair exceeds the maximum allowed pages for total_pages in genre_author_pages.values(): if total_pages > max_pages: return \\"NO\\" return \\"YES\\" # Example to demonstrate the function if __name__ == \\"__main__\\": n = 5 books = [ (\\"Fiction\\", \\"Alice\\", 320), (\\"Fiction\\", \\"Bob\\", 150), (\\"Mystery\\", \\"Alice\\", 200), (\\"Fiction\\", \\"Alice\\", 100), (\\"Mystery\\", \\"Bob\\", 300) ] max_pages = 500 print(can_group_books(n, books, max_pages)) # Outputs: YES n = 4 books = [ (\\"Fantasy\\", \\"John\\", 600), (\\"Fantasy\\", \\"John\\", 400), (\\"SciFi\\", \\"Clark\\", 300), (\\"SciFi\\", \\"Clark\\", 700) ] max_pages = 750 print(can_group_books(n, books, max_pages)) # Outputs: NO"},{"question":"def minutes_before_charging(initial_charge: int, n: int) -> int: Given the initial battery charge of the laptop and the number of minutes intended to work, determine how many minutes Rita can work efficiently before she needs to charge her laptop for the first time. :param initial_charge: int, initial battery charge (1 ≤ initial_charge ≤ 100) :param n: int, number of minutes intended to work (1 ≤ n ≤ 1000) :return: int, number of minutes Rita can work efficiently before charging the laptop >>> minutes_before_charging(15, 10) 5 >>> minutes_before_charging(20, 50) 10 def test_minutes_before_charging(): assert minutes_before_charging(15, 10) == 5 assert minutes_before_charging(20, 50) == 10 assert minutes_before_charging(30, 25) == 20 assert minutes_before_charging(10, 50) == 0 assert minutes_before_charging(11, 50) == 1 assert minutes_before_charging(50, 100) == 40 assert minutes_before_charging(100, 1000) == 90 assert minutes_before_charging(25, 15) == 15","solution":"def minutes_before_charging(initial_charge, n): Given the initial battery charge of the laptop and the number of minutes intended to work, determine how many minutes Rita can work efficiently before she needs to charge her laptop for the first time. :param initial_charge: int, initial battery charge (1 ≤ initial_charge ≤ 100) :param n: int, number of minutes intended to work (1 ≤ n ≤ 1000) :return: int, number of minutes Rita can work efficiently before charging the laptop # Rita can work until her battery drops below 10 units. # We need to find out how many minutes it will take before her battery drops below 10 units. minutes_can_work = 0 while initial_charge > 10 and minutes_can_work < n: minutes_can_work += 1 initial_charge -= 1 return minutes_can_work"},{"question":"import math from typing import List def min_square_plot_size(crops: List[int]) -> List[int]: Given a list of crop types, returns a list of minimum square plot sizes required for each crop type. :param crops: List of integers representing crop types. :return: List of integers representing minimum square plot size for each crop type. >>> min_square_plot_size([1, 4, 9]) [1, 2, 3] >>> min_square_plot_size([3, 6, 10, 15, 21]) [2, 3, 4, 4, 5] >>> min_square_plot_size([16, 25]) [4, 5] >>> min_square_plot_size([2, 5, 8, 12, 18]) [2, 3, 3, 4, 5] >>> min_square_plot_size([100]) [10] >>> min_square_plot_size([1]) [1] >>> min_square_plot_size([1000000000]) [31623]","solution":"import math def min_square_plot_size(crops): Given a list of crop types, returns a list of minimum square plot sizes required for each crop type. :param crops: List of integers representing crop types. :return: List of integers representing minimum square plot size for each crop type. return [math.ceil(math.sqrt(crop)) for crop in crops]"},{"question":"def can_reorder_students(n: int, heights: List[int]) -> str: Determines if it is possible to reorder students such that the absolute difference between the height of any two adjacent students is always less than or equal to 1. :param n: int - number of students :param heights: list of int - heights of the students :return: str - \\"YES\\" if possible to reorder, otherwise \\"NO\\" >>> can_reorder_students(4, [3, 2, 2, 1]) \\"YES\\" >>> can_reorder_students(3, [3, 1, 4]) \\"NO\\"","solution":"def can_reorder_students(n, heights): Determines if it is possible to reorder students such that the absolute difference between the height of any two adjacent students is always less than or equal to 1. :param n: int - number of students :param heights: list of int - heights of the students :return: str - \\"YES\\" if possible to reorder, otherwise \\"NO\\" heights.sort() for i in range(1, n): if abs(heights[i] - heights[i - 1]) > 1: return \\"NO\\" return \\"YES\\""},{"question":"def find_pair_with_sum(N, numbers, K): You are given a list of integers and a target sum. Your task is to determine if there are two distinct integers in the list that add up to the target sum. If there exist such a pair, return their indices. Otherwise, return an empty list. Args: N: integer, number of integers in the list. numbers: List of N integers. K: integer, the target sum. Returns: List of two integers representing the 0-based indices of the two integers that add up to the target sum, K. If no such pair exists, returns an empty list. Examples: >>> find_pair_with_sum(5, [2, 7, 11, 15, 1], 9) [0, 1] >>> find_pair_with_sum(4, [1, 2, 3, 4], 8) [] def process_cases(T, cases): Processes multiple test cases and returns the results of each. Args: T: integer, number of test cases. cases: List of tuples, where each tuple contains an integer N, a list of N integers, and an integer K. Returns: List of results for each test case. Examples: >>> cases = [ ... (5, [2, 7, 11, 15, 1], 9), ... (4, [1, 2, 3, 4], 8), ... (3, [5, 75, 25], 100) ... ] >>> expected_results = [ ... [0, 1], ... [], ... [1, 2] ... ] >>> process_cases(3, cases) [[0, 1], [], [1, 2]]","solution":"def find_pair_with_sum(N, numbers, K): Finds two distinct integers in the list that add up to the target sum K. Returns the indices of these integers as a list. If no such pair exists, returns an empty list. index_map = {} for i, num in enumerate(numbers): complement = K - num if complement in index_map: return [index_map[complement], i] index_map[num] = i return [] def process_cases(T, cases): Processes multiple test cases and returns the results of each. results = [] for case in cases: N, numbers, K = case result = find_pair_with_sum(N, numbers, K) results.append(result) return results"},{"question":"from typing import List, Tuple def is_subsequence(S: str, T: str) -> str: Returns \\"YES\\" if T is a subsequence of S, otherwise returns \\"NO\\". # Implement this function def check_subsequences(queries: List[Tuple[str, str]]) -> List[str]: For each query, check if T is a subsequence of S. # Implement this function def test_is_subsequence(): assert is_subsequence(\\"abcde\\", \\"ace\\") == \\"YES\\" assert is_subsequence(\\"abcde\\", \\"aec\\") == \\"NO\\" assert is_subsequence(\\"xyz\\", \\"xy\\") == \\"YES\\" assert is_subsequence(\\"abcdef\\", \\"def\\") == \\"YES\\" assert is_subsequence(\\"abcdef\\", \\"fed\\") == \\"NO\\" assert is_subsequence(\\"a\\", \\"a\\") == \\"YES\\" assert is_subsequence(\\"a\\", \\"b\\") == \\"NO\\" def test_check_subsequences(): queries = [ (\\"abcde\\", \\"ace\\"), (\\"abcde\\", \\"aec\\"), (\\"xyz\\", \\"xy\\") ] assert check_subsequences(queries) == [\\"YES\\", \\"NO\\", \\"YES\\"] queries = [ (\\"abcdef\\", \\"def\\"), (\\"abcdef\\", \\"fed\\"), (\\"a\\", \\"a\\"), (\\"a\\", \\"b\\") ] assert check_subsequences(queries) == [\\"YES\\", \\"NO\\", \\"YES\\", \\"NO\\"]","solution":"def is_subsequence(S, T): Returns \\"YES\\" if T is a subsequence of S, otherwise returns \\"NO\\". it = iter(S) for char in T: if char not in it: return \\"NO\\" return \\"YES\\" def check_subsequences(queries): results = [] for S, T in queries: results.append(is_subsequence(S, T)) return results"},{"question":"def rolling_sum(n: int, k: int, arr: List[int]) -> List[int]: Computes the rolling sum of the array with the given window size. :param n: int, number of elements in the array :param k: int, size of each subarray for summing :param arr: list of int, elements of the array :return: list of int, rolling sum of the array >>> rolling_sum(8, 3, [1, 2, 3, 4, 5, 6, 7, 8]) [6, 9, 12, 15, 18, 21] >>> rolling_sum(5, 2, [-1, 4, -3, 5, 2]) [3, 1, 2, 7]","solution":"def rolling_sum(n, k, arr): Computes the rolling sum of the array with the given window size. :param n: int, number of elements in the array :param k: int, size of each subarray for summing :param arr: list of int, elements of the array :return: list of int, rolling sum of the array if k > n: return [] result = [] current_sum = sum(arr[:k]) result.append(current_sum) for i in range(k, n): current_sum = current_sum - arr[i - k] + arr[i] result.append(current_sum) return result"},{"question":"from typing import List def maxProduct(nums: List[int]) -> int: Given an array of integers, finds the contiguous subarray with the maximum product and returns its product. If the array is empty, return 0. >>> maxProduct([2, 3, -2, 4]) 6 >>> maxProduct([-2, 0, -1]) 0 >>> maxProduct([-2, -3, 0, -2, -40]) 80 pass # Unit tests def test_example_1(): assert maxProduct([2, 3, -2, 4]) == 6 def test_example_2(): assert maxProduct([-2, 0, -1]) == 0 def test_example_3(): assert maxProduct([-2, -3, 0, -2, -40]) == 80 def test_empty_array(): assert maxProduct([]) == 0 def test_all_positive(): assert maxProduct([1, 2, 3, 4]) == 24 def test_all_negative(): assert maxProduct([-1, -2, -3, -4]) == 24 def test_zeros_and_positives(): assert maxProduct([0, 2, 3, 0, 4, 5]) == 20 def test_zeros_and_negatives(): assert maxProduct([0, -2, -3, 0, -4, -5]) == 20 def test_single_element(): assert maxProduct([3]) == 3 assert maxProduct([-3]) == -3 assert maxProduct([0]) == 0","solution":"from typing import List def maxProduct(nums: List[int]) -> int: if not nums: return 0 max_product = min_product = result = nums[0] for num in nums[1:]: if num < 0: max_product, min_product = min_product, max_product max_product = max(num, max_product * num) min_product = min(num, min_product * num) result = max(result, max_product) return result"},{"question":"def are_heights_strictly_increasing(n: int, heights: List[int]) -> str: Determines if the heights of students form a strictly increasing sequence. >>> are_heights_strictly_increasing(5, [150, 160, 170, 180, 190]) \\"YES\\" >>> are_heights_strictly_increasing(4, [150, 160, 160, 180]) \\"NO\\"","solution":"def are_heights_strictly_increasing(n, heights): Determines if the given list of heights is strictly increasing. Parameters: n (int): Number of students (length of the heights list) heights (list): List of integers representing the heights of students Returns: str: \\"YES\\" if heights are strictly increasing, otherwise \\"NO\\" for i in range(1, n): if heights[i] <= heights[i - 1]: return \\"NO\\" return \\"YES\\""},{"question":"import math def digit_factorial_sum(num: int) -> int: Returns the sum of the factorials of the digits of num. >>> digit_factorial_sum(1) 1 >>> digit_factorial_sum(2) 2 >>> digit_factorial_sum(3) 6 >>> digit_factorial_sum(4) 24 >>> digit_factorial_sum(5) 120 pass def generate_sequence(n: int) -> List[int]: Generates a sequence of length n where the i-th element is defined as the sum of the factorials of its digits. >>> generate_sequence(1) [1] >>> generate_sequence(5) [1, 2, 6, 24, 120] >>> generate_sequence(7) [1, 2, 6, 24, 120, 720, 5040] pass def formatted_sequence(n: int) -> str: Generates the sequence and formats it as a space-separated string. >>> formatted_sequence(1) \\"1\\" >>> formatted_sequence(5) \\"1 2 6 24 120\\" >>> formatted_sequence(7) \\"1 2 6 24 120 720 5040\\" pass","solution":"import math def digit_factorial_sum(num): Returns the sum of the factorials of the digits of num. return sum(math.factorial(int(d)) for d in str(num)) def generate_sequence(n): Generates a sequence of length n where the i-th element is defined as the sum of the factorials of its digits. return [digit_factorial_sum(i) for i in range(1, n + 1)] def formatted_sequence(n): Generates the sequence and formats it as a space-separated string. sequence = generate_sequence(n) return ' '.join(map(str, sequence))"},{"question":"def calculate_stations(d: int, s: int) -> int: Given the distance of the marathon \`d\` and the interval \`s\` between stations, this function returns the total number of assistance stations needed including the start and end points. >>> calculate_stations(42, 7) 7 >>> calculate_stations(100, 10) 11 # Your code here def test_calculate_stations_example_1(): assert calculate_stations(42, 7) == 7 def test_calculate_stations_example_2(): assert calculate_stations(100, 10) == 11 def test_calculate_stations_exact_fit(): assert calculate_stations(50, 5) == 11 # 0, 5, 10, ..., 50 => 11 stations def test_calculate_stations_no_exact_fit(): assert calculate_stations(30, 4) == 9 # 0, 4, 8, 12, 16, 20, 24, 28, 30 => 9 stations def test_calculate_stations_minimum_values(): assert calculate_stations(1, 1) == 2 # 0, 1 => 2 stations def test_calculate_stations_largest_values(): assert calculate_stations(10**9, 3) == 333333335 # large input edge case","solution":"def calculate_stations(d, s): Given the distance of the marathon \`d\` and the interval \`s\` between stations, this function returns the total number of assistance stations needed including the start and end points. if d % s == 0: return d // s + 1 else: return d // s + 2"},{"question":"def analyze_transactions(transactions): Analyze the fruit transactions to determine the total revenue and best-selling fruit. Args: transactions (list of list of str): Each transaction is a list containing fruit name (str), quantity (str), and price per unit (str). Returns: tuple: A tuple containing: - total revenue (float) rounded to two decimal places - best-selling fruit (str) based on the highest revenue pass # implement the function here # Example usage: # transactions = [ # [\\"apple\\", \\"100\\", \\"0.5\\"], # [\\"banana\\", \\"200\\", \\"0.25\\"], # [\\"apple\\", \\"150\\", \\"0.45\\"], # [\\"orange\\", \\"100\\", \\"0.7\\"] # ] # print(analyze_transactions(transactions)) # Output: (237.50, 'apple') # Unit tests def test_single_transaction(): transactions = [ [\\"apple\\", \\"100\\", \\"0.5\\"], ] assert analyze_transactions(transactions) == (50.00, \\"apple\\") def test_multiple_fruits(): transactions = [ [\\"apple\\", \\"100\\", \\"0.5\\"], [\\"banana\\", \\"200\\", \\"0.25\\"], [\\"apple\\", \\"150\\", \\"0.45\\"], [\\"orange\\", \\"100\\", \\"0.7\\"] ] assert analyze_transactions(transactions) == (237.50, \\"apple\\") def test_same_revenue_different_fruits(): transactions = [ [\\"apple\\", \\"100\\", \\"1.0\\"], [\\"banana\\", \\"50\\", \\"2.0\\"] ] assert analyze_transactions(transactions) == (200.00, \\"apple\\") def test_lexicographical_tie(): transactions = [ [\\"banana\\", \\"100\\", \\"1.0\\"], [\\"apple\\", \\"100\\", \\"1.0\\"] ] assert analyze_transactions(transactions) == (200.00, \\"apple\\") def test_large_values(): transactions = [ [\\"apple\\", \\"1000\\", \\"1000.0\\"], [\\"banana\\", \\"1000\\", \\"999.9\\"], [\\"orange\\", \\"1\\", \\"0.01\\"], ] assert analyze_transactions(transactions) == (1999900.01, \\"apple\\")","solution":"from collections import defaultdict def analyze_transactions(transactions): total_revenue = 0.0 fruit_revenue = defaultdict(float) for transaction in transactions: fruit_name, quantity, price_per_unit = transaction quantity = int(quantity) price_per_unit = float(price_per_unit) revenue = quantity * price_per_unit total_revenue += revenue fruit_revenue[fruit_name] += revenue max_revenue = max(fruit_revenue.values()) best_selling_fruit = min( fruit for fruit, revenue in fruit_revenue.items() if revenue == max_revenue ) return round(total_revenue, 2), best_selling_fruit if __name__ == \\"__main__\\": import sys input = sys.stdin.read data = input().splitlines() n = int(data[0].strip()) transactions = [line.strip().split() for line in data[1:1+n]] total_revenue, best_selling_fruit = analyze_transactions(transactions) print(f\\"{total_revenue:.2f}\\") print(best_selling_fruit)"},{"question":"from typing import List, Tuple def find_anomaly(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Determine the first integer value in a sequence of temperature readings that is not greater than the average of all readings preceding it. If no such value exists, return -1. Args: T (int): Number of test cases test_cases (List[Tuple[int, List[int]]]): List of tuple where each tuple contains an integer and a list of integers representing the number of readings and the temperature readings respectively. Returns: List[int]: List of results for each test case. >>> find_anomaly(2, [(5, [10, 20, 15, 30, 25]), (4, [40, 35, 45, 50])]) [15, 35] >>> find_anomaly(1, [(1, [10])]) [-1] >>> find_anomaly(1, [(5, [10, 15, 20, 25, 30])]) [-1] >>> find_anomaly(1, [(5, [10, 20, 10, 30, 40])]) [10] >>> find_anomaly(1, [(4, [10, 10, 10, 10])]) [10]","solution":"def find_anomaly(T, test_cases): def first_not_greater_than_avg(readings): if len(readings) <= 1: return -1 total_sum = 0 for i in range(len(readings)): if i == 0: total_sum += readings[i] continue avg = total_sum / i if readings[i] <= avg: return readings[i] total_sum += readings[i] return -1 results = [] for i in range(T): N = test_cases[i][0] readings = test_cases[i][1] result = first_not_greater_than_avg(readings) results.append(result) return results"},{"question":"def max_treasures(t: int, test_cases: List[Tuple[int, int, List[str]]]) -> List[int]: Determine the maximum number of treasures the hunter can collect on a valid path from the top-left to the bottom-right corner of the grid. Args: t (int): The number of test cases. test_cases (List[Tuple[int, int, List[str]]]): A list of test cases where each test case is a tuple containing: - m (int): The number of rows in the grid. - n (int): The number of columns in the grid. - grid (List[str]): The grid itself, a list of strings. Returns: List[int]: A list containing the maximum number of treasures collected for each test case or -1 if the path is not possible. Example: >>> t = 3 >>> test_cases = [(3, 3, ['EET', 'EXT', 'EEE']), (3, 3, ['EET', 'XXX', 'TEE']), (2, 2, ['TX', 'XT'])] >>> max_treasures(t, test_cases) [2, -1, -1] >>> t = 1 >>> test_cases = [(2, 2, ['XX', 'XX'])] >>> max_treasures(t, test_cases) [-1]","solution":"def max_treasures(t, test_cases): results = [] for case in test_cases: m, n, grid = case if grid[0][0] == 'X' or grid[m-1][n-1] == 'X': results.append(-1) continue dp = [[-1] * n for _ in range(m)] dp[0][0] = 1 if grid[0][0] == 'T' else 0 for i in range(m): for j in range(n): if grid[i][j] == 'X': dp[i][j] = -1 else: if i > 0 and dp[i-1][j] != -1: dp[i][j] = max(dp[i][j], dp[i-1][j] + (1 if grid[i][j] == 'T' else 0)) if j > 0 and dp[i][j-1] != -1: dp[i][j] = max(dp[i][j], dp[i][j-1] + (1 if grid[i][j] == 'T' else 0)) results.append(dp[m-1][n-1] if dp[m-1][n-1] != -1 else -1) return results"},{"question":"from typing import List, Tuple import heapq def min_toll_to_travel(N: int, M: int, roads: List[Tuple[int, int, int]]) -> int: Given N cities and M roads, find the minimum toll to travel from city 1 to city N. >>> min_toll_to_travel(5, 6, [(1, 2, 2), (1, 3, 4), (2, 3, 1), (2, 4, 7), (3, 5, 3), (4, 5, 1)]) 6 >>> min_toll_to_travel(3, 1, [(1, 2, 10)]) -1 >>> min_toll_to_travel(2, 0, []) -1 >>> min_toll_to_travel(2, 1, [(1, 2, 5)]) 5 >>> min_toll_to_travel(4, 4, [(1, 2, 1), (2, 3, 1), (3, 4, 1), (1, 4, 10)]) 3 >>> min_toll_to_travel(4, 2, [(1, 2, 1), (3, 4, 1)]) -1","solution":"import heapq def min_toll_to_travel(N, M, roads): # Create an adjacency list adj = {i: [] for i in range(1, N+1)} for u, v, w in roads: adj[u].append((v, w)) adj[v].append((u, w)) # Dijkstra's algorithm pq = [(0, 1)] # (toll, city) tolls = {i: float('inf') for i in range(1, N+1)} tolls[1] = 0 visited = set() while pq: current_toll, city = heapq.heappop(pq) if city in visited: continue visited.add(city) if city == N: return current_toll for neighbor, weight in adj[city]: if neighbor not in visited: new_toll = current_toll + weight if new_toll < tolls[neighbor]: tolls[neighbor] = new_toll heapq.heappush(pq, (new_toll, neighbor)) return -1 if tolls[N] == float('inf') else tolls[N]"},{"question":"def can_ship_all_products(total_containers: int, total_products: int, container_weights: List[int], product_weights: List[int]) -> str: Determines if all products can be shipped using the available containers. Parameters: total_containers (int): Number of containers. total_products (int): Number of products. container_weights (list): Weight limits of each container. product_weights (list): Weights of each product. Returns: str: \\"YES\\" if all products can be shipped, \\"NO\\" otherwise. pass def process_input(data: List[str]) -> List[str]: Processes the input data and determines if all products can be shipped for each dataset. Parameters: data (list): Input data as a list of strings. Returns: list: List of results, \\"YES\\" or \\"NO\\", for each dataset. pass from typing import List # Example test cases for can_ship_all_products def test_can_ship_all_products(): # Test case 1 total_containers = 3 total_products = 5 container_weights = [50, 70, 90] product_weights = [30, 40, 50, 60, 80] assert can_ship_all_products(total_containers, total_products, container_weights, product_weights) == \\"NO\\" # Test case 2 total_containers = 2 total_products = 3 container_weights = [60, 70] product_weights = [50, 20, 30] assert can_ship_all_products(total_containers, total_products, container_weights, product_weights) == \\"YES\\" # Test case 3 total_containers = 4 total_products = 4 container_weights = [80, 60, 30, 50] product_weights = [20, 40, 50, 10] assert can_ship_all_products(total_containers, total_products, container_weights, product_weights) == \\"YES\\" def test_process_input(): data = [ \\"3 5\\", \\"50 70 90\\", \\"30 40 50 60 80\\", \\"2 3\\", \\"60 70\\", \\"50 20 30\\", \\"4 4\\", \\"80 60 30 50\\", \\"20 40 50 10\\", \\"0\\" ] expected_output = [\\"NO\\", \\"YES\\", \\"YES\\"] assert process_input(data) == expected_output","solution":"def can_ship_all_products(total_containers, total_products, container_weights, product_weights): Determines if all products can be shipped using the available containers. Parameters: total_containers (int): Number of containers. total_products (int): Number of products. container_weights (list): Weight limits of each container. product_weights (list): Weights of each product. Returns: str: \\"YES\\" if all products can be shipped, \\"NO\\" otherwise. if total_containers == 0 or total_products == 0: return \\"NO\\" container_weights.sort(reverse=True) product_weights.sort(reverse=True) product_index = 0 for weight_limit in container_weights: current_weight = 0 while product_index < total_products and current_weight + product_weights[product_index] <= weight_limit: current_weight += product_weights[product_index] product_index += 1 if product_index == total_products: return \\"YES\\" return \\"NO\\" def process_input(data): results = [] i = 0 while i < len(data): line = data[i].strip() if line == '0': break m, n = map(int, line.split()) container_weights = list(map(int, data[i + 1].strip().split())) product_weights = list(map(int, data[i + 2].strip().split())) result = can_ship_all_products(m, n, container_weights, product_weights) results.append(result) i += 3 return results"},{"question":"def has_two_sum(nums: List[int], target: int) -> str: Determines if there are any two distinct integers in the list that add up to the target integer. Args: nums: List of unique integers. target: The target sum integer. Returns: \\"YES\\" if there are two distinct integers that add up to the target, otherwise \\"NO\\". pass # Unit Tests def test_has_two_sum_exists(): assert has_two_sum([2, 7, 11, 15, 1], 9) == \\"YES\\" def test_has_two_sum_not_exist(): assert has_two_sum([1, 2, 3, 9], 8) == \\"NO\\" def test_large_numbers_positive_target(): assert has_two_sum([1000000000, 999999999, -2000000000], 1999999999) == \\"YES\\" def test_large_numbers_negative_target(): assert has_two_sum([1000000000, 999999999, -2000000000], -1000000000) == \\"YES\\" def test_edge_case_min_size(): assert has_two_sum([1], 0) == \\"NO\\" def test_target_is_zero(): assert has_two_sum([-1, 0, 1], 0) == \\"YES\\" assert has_two_sum([1, 1, 1], 0) == \\"NO\\" # The list has duplicate values, but they are still unique def test_no_valid_pairs(): assert has_two_sum([1, 3, 5, 7], 2) == \\"NO\\"","solution":"def has_two_sum(nums, target): Determines if there are any two distinct integers in the list that add up to the target integer. Args: nums: List of unique integers. target: The target sum integer. Returns: \\"YES\\" if there are two distinct integers that add up to the target, otherwise \\"NO\\". num_set = set() for num in nums: complement = target - num if complement in num_set: return \\"YES\\" num_set.add(num) return \\"NO\\" def main(): import sys input = sys.stdin.read data = input().split() n = int(data[0]) t = int(data[1]) nums = list(map(int, data[2:2+n])) result = has_two_sum(nums, t) print(result)"},{"question":"def min_prime_sum(k: int) -> int: Returns the minimum number of prime numbers that sum up to k. >>> min_prime_sum(10) 2 >>> min_prime_sum(20) 2 >>> min_prime_sum(1) -1","solution":"def min_prime_sum(k): Returns the minimum number of prime numbers that sum up to k. if k == 1: return -1 if k == 2: return 1 if k % 2 == 0: return 2 # Because Goldbach's conjecture states that any even number >= 4 can be expressed as a sum of two primes. # Check if k itself is a prime for i in range(2, int(k**0.5)+1): if k % i == 0: break else: return 1 # k is a prime number # k is odd, using Goldbach's conjecture (since k-2 is even and can be written as a sum of two primes). return 3"},{"question":"def executeWithRetry(request: () => bool, retries: int) -> bool: Executes the request function up to the specified number of retries. Parameters: - request: A function that returns True if the request is successful, False otherwise. - retries: The maximum number of retry attempts. Returns: - True if the request succeeds within the allowed number of retries. - False if the request fails even after the allowed number of retries. pass def test_executeWithRetry_success_first_try(): def mock_request(): return True assert executeWithRetry(mock_request, 3) == True def test_executeWithRetry_success_third_try(): attempts = [0] def mock_request(): attempts[0] += 1 return attempts[0] == 3 assert executeWithRetry(mock_request, 3) == True def test_executeWithRetry_fail_all_tries(): def mock_request(): return False assert executeWithRetry(mock_request, 3) == False def test_executeWithRetry_success_first_of_two_retries(): attempts = [0] def mock_request(): attempts[0] += 1 return attempts[0] == 1 assert executeWithRetry(mock_request, 2) == True def test_executeWithRetry_success_second_of_two_retries(): attempts = [0] def mock_request(): attempts[0] += 1 return attempts[0] == 2 assert executeWithRetry(mock_request, 2) == True def test_executeWithRetry_retry_limit_reached(): attempts = [0] def mock_request(): attempts[0] += 1 return False assert executeWithRetry(mock_request, 2) == False","solution":"def executeWithRetry(request, retries): Executes the request function up to the specified number of retries. Parameters: - request: A function that returns True if the request is successful, False otherwise. - retries: The maximum number of retry attempts. Returns: - True if the request succeeds within the allowed number of retries. - False if the request fails even after the allowed number of retries. for _ in range(retries + 1): if request(): return True return False"},{"question":"def max_profit(prices: List[int]) -> int: You are given a list of integers representing the daily stock prices of a certain company over a period of N days. Your task is to maximize the profit from at most two non-overlapping transactions. Each transaction consists of buying one and selling one share of the stock, and you must buy before you sell. >>> max_profit([3,3,5,0,0,3,1,4]) 6 >>> max_profit([1,2,3,4,5]) 4 >>> max_profit([7,6,4,3,1]) 0 >>> max_profit([1,2,1,4,5]) 5 >>> max_profit([]) 0 pass","solution":"def max_profit(prices): if not prices: return 0 n = len(prices) # First pass: calculate max profit up to each day from the beginning max_profit_up_to = [0] * n min_price = prices[0] for i in range(1, n): min_price = min(min_price, prices[i]) max_profit_up_to[i] = max(max_profit_up_to[i - 1], prices[i] - min_price) # Second pass: calculate max profit from each day to the end and the combination max_profit_from = [0] * n max_price = prices[-1] for i in range(n - 2, -1, -1): max_price = max(max_price, prices[i]) max_profit_from[i] = max(max_profit_from[i + 1], max_price - prices[i]) # Find the maximum profit from at most 2 transactions max_profit = 0 for i in range(n): max_profit = max(max_profit, max_profit_up_to[i] + max_profit_from[i]) return max_profit"},{"question":"def intersection_area(square1: List[Tuple[int, int]], square2: List[Tuple[int, int]]) -> int: Given the coordinates of two squares on a 2D plane, returns the area of their intersection. Args: square1: List of 4 tuples representing the vertices of the first square. square2: List of 4 tuples representing the vertices of the second square. Returns: The area of the intersection of the two squares, or 0 if they do not overlap. Examples: >>> intersection_area([(0, 0), (0, 1), (1, 1), (1, 0)], [(2, 2), (2, 3), (3, 3), (3, 2)]) 0 >>> intersection_area([(0, 0), (0, 2), (2, 2), (2, 0)], [(1, 1), (1, 3), (3, 3), (3, 1)]) 1 >>> intersection_area([(0, 0), (0, 2), (2, 2), (2, 0)], [(0, 0), (0, 2), (2, 2), (2, 0)]) 4 >>> intersection_area([(0, 0), (0, 2), (2, 2), (2, 0)], [(2, 0), (2, 2), (4, 2), (4, 0)]) 0 >>> intersection_area([(0, 0), (0, 3), (3, 3), (3, 0)], [(2, 2), (2, 5), (5, 5), (5, 2)]) 1","solution":"def get_square_bounds(coordinates): Given four coordinates representing the vertices of an axis-aligned square, return the bounds of the square. Args: coordinates: List of tuples [(x1, y1), (x2, y2), (x3, y3), (x4, y4)] Returns: (x_min, x_max, y_min, y_max) The bounds of the square. x_coords = [coord[0] for coord in coordinates] y_coords = [coord[1] for coord in coordinates] x_min = min(x_coords) x_max = max(x_coords) y_min = min(y_coords) y_max = max(y_coords) return x_min, x_max, y_min, y_max def intersection_area(square1, square2): Given the coordinates of two squares on a 2D plane, returns the area of their intersection. Args: square1: List of tuples [(x1, y1), (x2, y2), (x3, y3), (x4, y4)] square2: List of tuples [(x5, y5), (x6, y6), (x7, y7), (x8, y8)] Returns: int: The area of the intersection of two squares, or 0 if they do not overlap. x1_min, x1_max, y1_min, y1_max = get_square_bounds(square1) x2_min, x2_max, y2_min, y2_max = get_square_bounds(square2) # Find the overlapping region overlap_x_min = max(x1_min, x2_min) overlap_x_max = min(x1_max, x2_max) overlap_y_min = max(y1_min, y2_min) overlap_y_max = min(y1_max, y2_max) # Calculate the width and height of overlap overlap_width = max(0, overlap_x_max - overlap_x_min) overlap_height = max(0, overlap_y_max - overlap_y_min) # Calculate the area intersection_area = overlap_width * overlap_height return intersection_area"},{"question":"def number_of_permutations(n: int, a: str, b: str) -> int: Calculate the number of distinct permutations of length \`n\` that contain exactly the same number of \`a\`s and \`b\`s with any remaining characters being \`'*'\`. Assumptions: - 1 ≤ n ≤ 1000 - The characters \`a\` and \`b\` are lowercase English letters. - \`a\` ≠ \`b\` - The result should be returned modulo 1000000007 (10^9 + 7). >>> number_of_permutations(4, 'x', 'y') 6 >>> number_of_permutations(5, 'h', 'p') 0","solution":"def number_of_permutations(n, a, b): MOD = 1000000007 if n % 2 != 0: return 0 half_n = n // 2 from math import comb return comb(n, half_n) % MOD"},{"question":"from typing import List def maxWaterStorage(heights: List[int]) -> int: Compute the maximum amount of rainwater that can be stored in the tanks. Given an array of integers representing the heights of a set of buildings, where the i-th element is the height of the i-th building, determine the maximum amount of water that can be stored after raining. Args: heights (List[int]): An array representing the heights of buildings. Returns: int: The maximum amount of water that can be stored. Examples: >>> maxWaterStorage([0,1,0,2,1,0,1,3,2,1,2,1]) 6 >>> maxWaterStorage([4,2,0,3,2,5]) 9 def test_example_1(): heights = [0,1,0,2,1,0,1,3,2,1,2,1] assert maxWaterStorage(heights) == 6 def test_example_2(): heights = [4,2,0,3,2,5] assert maxWaterStorage(heights) == 9 def test_no_heights(): heights = [] assert maxWaterStorage(heights) == 0 def test_all_equal_heights(): heights = [2, 2, 2, 2] assert maxWaterStorage(heights) == 0 def test_increasing_heights(): heights = [1, 2, 3, 4, 5] assert maxWaterStorage(heights) == 0 def test_decreasing_heights(): heights = [5, 4, 3, 2, 1] assert maxWaterStorage(heights) == 0 def test_single_height(): heights = [7] assert maxWaterStorage(heights) == 0 def test_two_buildings_flat(): heights = [1, 1] assert maxWaterStorage(heights) == 0 def test_v_shape(): heights = [3, 0, 3] assert maxWaterStorage(heights) == 3 def test_up_then_down(): heights = [1, 2, 1] assert maxWaterStorage(heights) == 0 def test_down_then_up(): heights = [2, 1, 2] assert maxWaterStorage(heights) == 1 def test_hill_shape(): heights = [1, 3, 2, 4, 1, 3] assert maxWaterStorage(heights) == 3","solution":"from typing import List def maxWaterStorage(heights: List[int]) -> int: if not heights: return 0 n = len(heights) left_max = [0] * n right_max = [0] * n # Fill left_max array left_max[0] = heights[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], heights[i]) # Fill right_max array right_max[n - 1] = heights[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], heights[i]) # Calculate total water total_water = 0 for i in range(n): water_level = min(left_max[i], right_max[i]) if water_level > heights[i]: total_water += water_level - heights[i] return total_water"},{"question":"from typing import List def min_steps_to_deliver_message(r: int, c: int, grid: List[str], sx: int, sy: int, dx: int, dy: int) -> int: Determine the minimum number of steps required to deliver a message from a starting point to a destination point within the grid. Parameters: r (int): Number of rows in the grid. c (int): Number of columns in the grid. grid (List[str]): The grid represented as a list of strings, where each string is a row containing '.' (free space) and '#' (wall). sx (int): Starting row index (1-based). sy (int): Starting column index (1-based). dx (int): Destination row index (1-based). dy (int): Destination column index (1-based). Returns: int: Minimum number of steps from start to destination, or -1 if there is no valid path. >>> r = 5 >>> c = 5 >>> grid = [ ... \\".....\\", ... \\"..#..\\", ... \\".#.\\", ... \\"..#..\\", ... \\".....\\" ... ] >>> sx, sy, dx, dy = 1, 1, 5, 5 >>> min_steps_to_deliver_message(r, c, grid, sx, sy, dx, dy) 8 >>> r = 3 >>> c = 3 >>> grid = [ ... \\".#.\\", ... \\"#\\", ... \\".#.\\" ... ] >>> sx, sy, dx, dy = 1, 1, 3, 1 >>> min_steps_to_deliver_message(r, c, grid, sx, sy, dx, dy) -1 >>> r = 1 >>> c = 5 >>> grid = [\\".....\\"] >>> sx, sy, dx, dy = 1, 1, 1, 5 >>> min_steps_to_deliver_message(r, c, grid, sx, sy, dx, dy) 4 >>> r = 5 >>> c = 1 >>> grid = [ ... \\".\\", ... \\".\\", ... \\".\\", ... \\"#\\", ... \\".\\" ... ] >>> sx, sy, dx, dy = 1, 1, 5, 1 >>> min_steps_to_deliver_message(r, c, grid, sx, sy, dx, dy) -1 >>> r = 2 >>> c = 2 >>> grid = [\\"..\\", \\"..\\"] >>> sx, sy, dx, dy = 1, 1, 1, 1 >>> min_steps_to_deliver_message(r, c, grid, sx, sy, dx, dy) 0","solution":"from collections import deque def min_steps_to_deliver_message(r, c, grid, sx, sy, dx, dy): # Convert grid coordinates from 1-based to 0-based sx -= 1 sy -= 1 dx -= 1 dy -= 1 # Directions for moving up, down, left, right directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # BFS initialization queue = deque([(sx, sy, 0)]) visited = set() visited.add((sx, sy)) # BFS Loop while queue: x, y, steps = queue.popleft() if x == dx and y == dy: return steps for d in directions: nx, ny = x + d[0], y + d[1] if 0 <= nx < r and 0 <= ny < c and grid[nx][ny] == '.' and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny, steps + 1)) # If no path found, return -1 return -1"},{"question":"def max_non_overlapping_tasks(n: int, tasks: List[Tuple[int, int]]) -> int: Returns the maximum number of non-overlapping tasks that can be performed. :param n: Number of tasks :param tasks: List of tuples, where each tuple contains (start time, end time) of a task :return: Maximum number of non-overlapping tasks >>> max_non_overlapping_tasks(5, [(1, 3), (2, 5), (4, 6), (5, 7), (6, 8)]) 3 >>> max_non_overlapping_tasks(1, [(1, 10)]) 1 >>> max_non_overlapping_tasks(3, [(1, 4), (2, 5), (3, 6)]) 1 >>> max_non_overlapping_tasks(4, [(1, 2), (3, 4), (5, 6), (7, 8)]) 4 >>> max_non_overlapping_tasks(4, [(1, 3), (2, 4), (3, 8), (6, 10)]) 2 >>> max_non_overlapping_tasks(3, [(1, 1000000000), (1000000000, 2000000000), (2000000000, 3000000000)]) 3","solution":"def max_non_overlapping_tasks(n, tasks): Returns the maximum number of non-overlapping tasks that can be performed. :param n: Number of tasks :param tasks: List of tuples, where each tuple contains (start time, end time) of a task :return: Maximum number of non-overlapping tasks # Sort the tasks based on their end times tasks.sort(key=lambda x: x[1]) # Initialize count of non-overlapping tasks count = 0 last_end_time = 0 for start, end in tasks: if start >= last_end_time: # Select this task count += 1 last_end_time = end return count"},{"question":"import re def evaluate_expression(expression: str) -> float: Evaluate the mathematical expression and return the result rounded to two decimal places. >>> evaluate_expression(\\"3+5\\") 8.00 >>> evaluate_expression(\\"10+(2*3)\\") 16.00 >>> evaluate_expression(\\"7-2*3\\") 1.00 >>> evaluate_expression(\\"8/(2+2)\\") 2.00 >>> evaluate_expression(\\"(3+5)*(2-1)\\") 8.00 def solve(expressions: List[str]) -> List[str]: Solve multiple mathematical expressions and return the results as a list of strings formatted to two decimals. >>> solve([\\"3+5\\", \\"10+(2*3)\\", \\"7-2*3\\", \\"8/(2+2)\\", \\"(3+5)*(2-1)\\"]) [\\"8.00\\", \\"16.00\\", \\"1.00\\", \\"2.00\\", \\"8.00\\"]","solution":"import re def evaluate_expression(expression): Evaluate the mathematical expression and return the result rounded to two decimal places. # Directly use Python's eval function which respects the operator precedence try: result = eval(expression) return round(result, 2) except Exception as ex: raise ValueError(f\\"Invalid expression: {ex}\\") def solve(expressions): Solve multiple mathematical expressions and return the results as a list of strings formatted to two decimals. results = [] for exp in expressions: result = evaluate_expression(exp) results.append(f\\"{result:.2f}\\") return results"},{"question":"def max_profit(heights): Calculate the maximum profit from harvesting any contiguous subarray of plants. Profit is defined as the difference between the maximum and minimum heights within that subarray. :param heights: List of integers representing heights of the Quantali plants. :return: Maximum profit as an integer. >>> max_profit([3, 1, 6, 4, 2]) 5 >>> max_profit([10, 10, 10]) 0","solution":"def max_profit(heights): Calculate the maximum profit from harvesting any contiguous subarray of plants. Profit is defined as the difference between the maximum and minimum heights within that subarray. :param heights: List of integers representing heights of the Quantali plants. :return: Maximum profit as an integer. if not heights: return 0 max_profit = 0 current_max = float('-inf') current_min = float('inf') for height in heights: current_max = height current_min = height for j in range(len(heights)): if j < len(heights): current_max = max(current_max, heights[j]) current_min = min(current_min, heights[j]) max_profit = max(max_profit, current_max - current_min) return max_profit"},{"question":"def group_even_odd(numbers): Groups the numbers into even and odd lists. Args: numbers (list of int): The list of integers to be grouped. Returns: tuple: A tuple containing two lists - first list of even numbers and second list of odd numbers. Examples: >>> group_even_odd([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) ([2, 4, 6, 8, 10], [1, 3, 5, 7, 9]) >>> group_even_odd([2, 4, 6, 8, 10]) ([2, 4, 6, 8, 10], []) >>> group_even_odd([1, 3, 5, 7, 9]) ([], [1, 3, 5, 7, 9]) >>> group_even_odd([]) ([], []) >>> group_even_odd([4]) ([4], []) >>> group_even_odd([3]) ([], [3])","solution":"def group_even_odd(numbers): Groups the numbers into even and odd lists. Args: numbers (list of int): The list of integers to be grouped. Returns: tuple: A tuple containing two lists - first list of even numbers and second list of odd numbers. even_numbers = [num for num in numbers if num % 2 == 0] odd_numbers = [num for num in numbers if num % 2 != 0] return (even_numbers, odd_numbers)"},{"question":"def longest_subarray_with_sum(arr, S): Returns the length of the longest subarray with sum equal to S. If no such subarray exists, return -1. >>> longest_subarray_with_sum([1, 2, 3, 4, 5], 15) == 5 >>> longest_subarray_with_sum([4, -1, 2, -2, 1], 0) == 4 >>> longest_subarray_with_sum([1, 2, 3, 4, 5], 100) == -1 >>> longest_subarray_with_sum([-1, -2, -3, 4, 5], 1) == 2 >>> longest_subarray_with_sum([0, 0, 0, 0], 0) == 4 pass def process_test_cases(test_cases): results = [] for n, s, array in test_cases: result = longest_subarray_with_sum(array, s) results.append(result) return results","solution":"def longest_subarray_with_sum(arr, S): Returns the length of the longest subarray with sum equal to S. If no such subarray exists, return -1. sum_dict = {} current_sum = 0 max_length = -1 for i in range(len(arr)): current_sum += arr[i] if current_sum == S: max_length = i + 1 if current_sum - S in sum_dict: max_length = max(max_length, i - sum_dict[current_sum - S]) if current_sum not in sum_dict: sum_dict[current_sum] = i return max_length def process_test_cases(test_cases): results = [] for n, s, array in test_cases: result = longest_subarray_with_sum(array, s) results.append(result) return results"},{"question":"def min_operations_to_sort_books(N: int, heights: List[int]) -> int: Given the number of books N and their respective heights in a list, determine the minimum number of reverse operations needed to sort the books in non-decreasing order. Examples: >>> min_operations_to_sort_books(5, [4, 3, 2, 1, 5]) 1 >>> min_operations_to_sort_books(4, [1, 2, 3, 4]) 0 >>> min_operations_to_sort_books(6, [6, 5, 4, 3, 2, 1]) 1","solution":"def min_operations_to_sort_books(N, heights): Given the number of books N and their respective heights in a list, determine the minimum number of reverse operations needed to sort the books in non-decreasing order. if heights == sorted(heights): return 0 # Find the longest sorted subarray from the start end = 0 while end < N - 1 and heights[end] <= heights[end + 1]: end += 1 # Find the longest sorted subarray from the end start = N - 1 while start > 0 and heights[start] >= heights[start - 1]: start -= 1 # If the array is fully sorted from start to end, just reverse once if end > start: return 1 return 1 # Any unsorted array can be sorted by a single reverse operation"},{"question":"def process_grades(S, C, G, Q, student_ids, course_numbers, grades, queries): Process the grades of students and answer various queries about their performance and courses. Parameters: S (int): Number of students. C (int): Number of courses. G (int): Number of grades recorded. Q (int): Number of queries. student_ids (List[str]): List of student IDs. course_numbers (List[str]): List of course numbers. grades (List[Tuple[str, str, int]]): List of grades where each entry is a tuple (student_id, course_number, grade). queries (List[str]): List of queries to answer. Returns: List[str]: Results of the queries with average grades formatted to two decimal places. >>> process_grades(3, 2, 5, 3, [\\"student1\\", \\"student2\\", \\"student3\\"], [\\"courseA\\", \\"courseB\\"], ... [(\\"student1\\", \\"courseA\\", 80), (\\"student2\\", \\"courseA\\", 70), (\\"student1\\", \\"courseB\\", 90), ... (\\"student3\\", \\"courseA\\", 85), (\\"student2\\", \\"courseB\\", 60)], ... [\\"Student Average student1\\", \\"Course Average courseA\\", \\"Course Average courseB\\"]) [\\"85.00\\", \\"78.33\\", \\"75.00\\"] >>> process_grades(2, 2, 0, 2, [\\"student1\\", \\"student2\\"], [\\"courseA\\", \\"courseB\\"], ... [], [\\"Student Average student1\\", \\"Course Average courseA\\"]) [\\"0.00\\", \\"0.00\\"]","solution":"def process_grades(S, C, G, Q, student_ids, course_numbers, grades, queries): student_grades = {student_id: [] for student_id in student_ids} course_grades = {course_number: [] for course_number in course_numbers} for grade in grades: student_id, course_number, grade_value = grade student_grades[student_id].append(grade_value) course_grades[course_number].append(grade_value) results = [] for query in queries: parts = query.split() if parts[0] == \\"Student\\" and parts[1] == \\"Average\\": student_id = parts[2] grades = student_grades.get(student_id, []) average = sum(grades) / len(grades) if grades else 0 elif parts[0] == \\"Course\\" and parts[1] == \\"Average\\": course_number = parts[2] grades = course_grades.get(course_number, []) average = sum(grades) / len(grades) if grades else 0 results.append(f\\"{average:.2f}\\") return results"},{"question":"from typing import List def find_max_sorted_books(n: int, books: List[int]) -> int: Find the maximum number of books that can be reserved in a sorted sequence (ascending order of their identifiers) from a given list of books. >>> find_max_sorted_books(5, [3, 10, 2, 1, 20]) 3 >>> find_max_sorted_books(6, [3, 2, 6, 4, 5, 1]) 3 >>> find_max_sorted_books(5, [5, 4, 3, 2, 1]) 1 # Implementation def test_example_cases(): assert find_max_sorted_books(5, [3, 10, 2, 1, 20]) == 3 assert find_max_sorted_books(6, [3, 2, 6, 4, 5, 1]) == 3 assert find_max_sorted_books(5, [5, 4, 3, 2, 1]) == 1 def test_single_element(): assert find_max_sorted_books(1, [10]) == 1 def test_all_elements_same(): assert find_max_sorted_books(5, [1, 1, 1, 1, 1]) == 1 def test_already_sorted(): assert find_max_sorted_books(5, [1, 2, 3, 4, 5]) == 5 def test_reverse_sorted(): assert find_max_sorted_books(5, [5, 4, 3, 2, 1]) == 1 def test_alternating(): assert find_max_sorted_books(7, [1, 3, 2, 4, 3, 5, 4]) == 4 def test_large_input(): assert find_max_sorted_books(10, [10, 9, 2, 5, 3, 7, 101, 18, 20, 6]) == 5","solution":"import bisect def longest_increasing_subsequence(arr): Returns the length of the longest increasing subsequence in the array. if not arr: return 0 lis = [] for book in arr: pos = bisect.bisect_left(lis, book) if pos == len(lis): lis.append(book) else: lis[pos] = book return len(lis) def find_max_sorted_books(n, books): return longest_increasing_subsequence(books)"},{"question":"def largest_connected_region(N: int, M: int, grid: List[List[int]]) -> int: Find the largest connected region for any given crop type. Args: N: int - The number of rows in the grid M: int - The number of columns in the grid grid: List[List[int]] - A 2D list representing the grid of crop types Returns: int - The size of the largest connected region for any crop type >>> largest_connected_region(4, 4, [ ... [1, 2, 2, 3], ... [1, 1, 2, 2], ... [3, 2, 2, 3], ... [4, 4, 4, 4] ... ]) 6 >>> largest_connected_region(4, 4, [ ... [1, 1, 1, 1], ... [1, 1, 1, 1], ... [1, 1, 1, 1], ... [1, 1, 1, 1] ... ]) 16 >>> largest_connected_region(3, 3, [ ... [1, 2, 3], ... [4, 5, 5], ... [6, 6, 6] ... ]) 3 >>> largest_connected_region(3, 3, [ ... [1, 2, 3], ... [1, 2, 3], ... [1, 2, 3] ... ]) 3 >>> largest_connected_region(1, 1, [[1]]) 1","solution":"def largest_connected_region(N, M, grid): def dfs(x, y, crop_type): stack = [(x, y)] size = 0 while stack: cx, cy = stack.pop() if 0 <= cx < N and 0 <= cy < M and grid[cx][cy] == crop_type and (cx, cy) not in visited: visited.add((cx, cy)) size += 1 stack.append((cx-1, cy)) # up stack.append((cx+1, cy)) # down stack.append((cx, cy-1)) # left stack.append((cx, cy+1)) # right return size visited = set() max_size = 0 for i in range(N): for j in range(M): if (i, j) not in visited: current_crop = grid[i][j] region_size = dfs(i, j, current_crop) max_size = max(max_size, region_size) return max_size # Example usage: # N, M = 4, 4 # grid = [ # [1, 2, 2, 3], # [1, 1, 2, 2], # [3, 2, 2, 3], # [4, 4, 4, 4] # ] # print(largest_connected_region(N, M, grid)) # Output: 6"},{"question":"def max_product(nums: List[int]) -> int: Given an integer array \`nums\`, returns the maximum product obtained by multiplying two distinct elements of the array. >>> max_product([3, 4, 5, 2, 1]) 20 >>> max_product([-1, -2, -3, -4]) 12 >>> max_product([-10, 0, 5]) 0","solution":"def max_product(nums): Returns the maximum product obtained by multiplying two distinct elements of the array nums. if len(nums) < 2: raise ValueError(\\"The array must have at least two distinct elements\\") nums.sort() # Possible maximum products: # 1. Product of the two largest numbers max_prod1 = nums[-1] * nums[-2] # 2. Product of the two smallest numbers (if they are both negative, their product is positive) max_prod2 = nums[0] * nums[1] return max(max_prod1, max_prod2)"},{"question":"def total_apples(N: int, M: int) -> int: Returns the total number of apples in all the boxes. Parameters: N (int): Number of boxes M (int): Number of apples in each box Returns: int: Total number of apples Examples: >>> total_apples(6, 3) 18 >>> total_apples(4, 7) 28 >>> total_apples(1, 1) 1 >>> total_apples(12, 1) 12 >>> total_apples(1, 10) 10 >>> total_apples(12, 10) 120","solution":"def total_apples(N, M): Returns the total number of apples in all the boxes. Parameters: N (int): Number of boxes M (int): Number of apples in each box Returns: int: Total number of apples return N * M"},{"question":"def generate_password(n: int) -> str: Generates a password of length n that includes at least one vowel and one consonant. Returns the password if possible, otherwise returns -1. >>> generate_password(5) \\"abcde\\" >>> generate_password(2) \\"ab\\" >>> generate_password(1) -1","solution":"def generate_password(n): Generates a password of length n that includes at least one vowel and one consonant. Returns the password if possible, otherwise returns -1. vowels = \\"aeiou\\" consonants = \\"bcdfghjklmnpqrstvwxyz\\" if n < 2: return -1 password = [] # Ensure there's at least one vowel and one consonant password.append(vowels[0]) password.append(consonants[0]) # Fill the rest of the password to reach the required length for i in range(n - 2): password.append(consonants[(i + 1) % len(consonants)]) return ''.join(password)"},{"question":"def can_transform_by_removing_one_char(S1: str, S2: str) -> str: Determine if S1 can be transformed into S2 by removing exactly one character from S1 without changing the order of the remaining characters. >>> can_transform_by_removing_one_char(\\"abdc\\", \\"abc\\") \\"YES\\" >>> can_transform_by_removing_one_char(\\"abcdef\\", \\"abdf\\") \\"NO\\" def test_can_transform_by_removing_one_char_yes_case(): assert can_transform_by_removing_one_char(\\"abdc\\", \\"abc\\") == \\"YES\\" assert can_transform_by_removing_one_char(\\"hello\\", \\"helo\\") == \\"YES\\" assert can_transform_by_removing_one_char(\\"abcdefg\\", \\"abcdef\\") == \\"YES\\" def test_can_transform_by_removing_one_char_no_case(): assert can_transform_by_removing_one_char(\\"abcdef\\", \\"abdf\\") == \\"NO\\" assert can_transform_by_removing_one_char(\\"abcd\\", \\"abce\\") == \\"NO\\" assert can_transform_by_removing_one_char(\\"helloo\\", \\"helo\\") == \\"NO\\" def test_can_transform_by_removing_one_char_length_mismatch(): assert can_transform_by_removing_one_char(\\"ab\\", \\"a\\") == \\"YES\\" assert can_transform_by_removing_one_char(\\"a\\", \\"b\\") == \\"NO\\" assert can_transform_by_removing_one_char(\\"abcd\\", \\"abcdef\\") == \\"NO\\"","solution":"def can_transform_by_removing_one_char(S1, S2): Determines if S1 can be transformed into S2 by removing exactly one character from S1 without changing the order of the remaining characters. if len(S1) != len(S2) + 1: return \\"NO\\" i, j = 0, 0 while i < len(S1) and j < len(S2): if S1[i] == S2[j]: j += 1 i += 1 # If j reached to the end of S2, it means S2 is a subsequence of S1 with one character removed return \\"YES\\" if j == len(S2) else \\"NO\\""},{"question":"def can_ensure_access(N: int, M: int, elevators: List[int], walkways: List[Tuple[int, int]]) -> str: Determines if it is possible to ensure continuous access to at least one operational elevator for all buildings. >>> can_ensure_access(6, 5, [1, 0, 0, 1, 0, 0], [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6)]) \\"YES\\" >>> can_ensure_access(4, 2, [0, 0, 0, 0], [(1, 2), (3, 4)]) \\"NO\\" def test_examples(): assert can_ensure_access(6, 5, [1, 0, 0, 1, 0, 0], [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6)]) == \\"YES\\" assert can_ensure_access(4, 2, [0, 0, 0, 0], [(1, 2), (3, 4)]) == \\"NO\\" assert can_ensure_access(1, 0, [1], []) == \\"YES\\" assert can_ensure_access(3, 2, [0, 1, 0], [(1, 2), (2, 3)]) == \\"YES\\" assert can_ensure_access(3, 3, [1, 1, 1], [(1, 2), (2, 3), (1, 3)]) == \\"YES\\" assert can_ensure_access(3, 0, [0, 1, 0], []) == \\"NO\\"","solution":"def can_ensure_access(N, M, elevators, walkways): from collections import defaultdict, deque graph = defaultdict(list) for b1, b2 in walkways: graph[b1].append(b2) graph[b2].append(b1) visited = [False] * (N + 1) operational_components = [] def bfs(start): queue = deque([start]) visited[start] = True component_operational = False while queue: node = queue.popleft() if elevators[node - 1] == 1: component_operational = True for neighbor in graph[node]: if not visited[neighbor]: visited[neighbor] = True queue.append(neighbor) return component_operational for building in range(1, N + 1): if not visited[building]: operational_components.append(bfs(building)) return \\"YES\\" if all(operational_components) else \\"NO\\""},{"question":"def min_rescheduled_flights(n: int, T: int, departure_times: List[int]) -> int: Calculate the minimum number of rescheduled flights required to ensure that no two flights depart at the same time. >>> min_rescheduled_flights(4, 8, [0, 1, 3, 4]) == 0 >>> min_rescheduled_flights(5, 10, [0, 2, 2, 4, 6]) == 1 >>> min_rescheduled_flights(3, 5, [1, 1, 1]) == 2 >>> min_rescheduled_flights(6, 15, [5, 5, 6, 7, 7, 8]) == 2 from typing import List import collections def test_no_reschedule_needed(): assert min_rescheduled_flights(4, 8, [0, 1, 3, 4]) == 0 def test_one_reschedule_needed(): assert min_rescheduled_flights(5, 10, [0, 2, 2, 4, 6]) == 1 def test_two_reschedules_needed(): assert min_rescheduled_flights(3, 5, [1, 1, 1]) == 2 def test_multiple_reschedules_needed(): assert min_rescheduled_flights(6, 15, [5, 5, 6, 7, 7, 8]) == 2","solution":"def min_rescheduled_flights(n, T, departure_times): from collections import Counter time_counts = Counter(departure_times) changes_needed = 0 scheduled_times = set(departure_times) for time, count in time_counts.items(): while count > 1: changes_needed += 1 count -= 1 # Find the nearest available time slot offset = 1 while time - offset in scheduled_times and time + offset in scheduled_times: offset += 1 if time - offset >= 0 and time - offset not in scheduled_times: scheduled_times.add(time - offset) else: scheduled_times.add(time + offset) return changes_needed"},{"question":"def longest_non_adjacent_subsequence(s: str) -> str: Returns the longest subsequence of s such that no two adjacent characters in the subsequence are the same. >>> longest_non_adjacent_subsequence(\\"abacabad\\") 'abacabad' >>> longest_non_adjacent_subsequence(\\"aabbcc\\") 'abc' >>> longest_non_adjacent_subsequence(\\"aaaa\\") 'a' >>> longest_non_adjacent_subsequence(\\"abcabc\\") 'abcabc'","solution":"def longest_non_adjacent_subsequence(s): Returns the longest subsequence of s such that no two adjacent characters are the same. if not s: return \\"\\" result = [s[0]] # Start with the first character for i in range(1, len(s)): if s[i] != s[i - 1]: result.append(s[i]) return \\"\\".join(result)"},{"question":"def max_trellis_height(n: int, heights: List[int], queries: List[int]) -> List[int]: Returns a list of maximum heights for the trellises at the given positions. >>> max_trellis_height(5, [10, 20, 15, 5, 25], [2, 4, 1]) [15, 5, 10] >>> max_trellis_height(6, [12, 24, 18, 35, 27, 19], [1, 2, 3, 4, 5]) [12, 18, 18, 27, 19]","solution":"def max_trellis_height(n, heights, queries): Returns a list of maximum heights for the trellises at the given positions. :param n: int: Number of flower pots :param heights: List[int]: Heights of the flower pots :param queries: List[int]: Positions to place the trellises :return: List[int]: List of maximum heights for each query result = [] for k in queries: max_height = min(heights[k-1], heights[k]) result.append(max_height) return result"},{"question":"def fibonacci(n: int) -> int: Write a function that takes an integer n and generates the nth Fibonacci number using an iterative approach for efficiency. >>> fibonacci(10) 55 >>> fibonacci(20) 6765","solution":"def fibonacci(n): Returns the nth Fibonacci number using iterative approach. if n == 0: return 0 elif n == 1: return 1 a, b = 0, 1 for i in range(2, n + 1): a, b = b, a + b return b"},{"question":"def max_items_collected(n: int, items: List[int], k: int) -> int: Returns the maximum number of items collected in any sequence of k consecutive days. :param n: int - the number of days the data is collected :param items: list of int - the number of items collected each day :param k: int - the maximum number of consecutive days to consider :return: int - the maximum number of items collected in any sequence of k consecutive days >>> max_items_collected(7, [2, 1, 5, 1, 3, 2, 1], 3) == 9 >>> max_items_collected(1, [7], 1) == 7 >>> max_items_collected(5, [1, 2, 3, 4, 5], 5) == 15 >>> max_items_collected(4, [1, 1, 1, 1], 4) == 4 >>> max_items_collected(3, [0, 0, 0], 2) == 0 >>> max_items_collected(6, [1, 0, 1, 0, 1, 0], 2) == 1 >>> max_items_collected(6, [1, 0, 1, 0, 1, 0], 3) == 2 pass # Your code here","solution":"def max_items_collected(n, items, k): Returns the maximum number of items collected in any sequence of k consecutive days. :param n: int - the number of days the data is collected :param items: list of int - the number of items collected each day :param k: int - the maximum number of consecutive days to consider :return: int - the maximum number of items collected in any sequence of k consecutive days # Initialize the sum of the first window of k days max_sum = current_sum = sum(items[:k]) # Slide through the array from k to the end for i in range(k, n): # Update the current sum by adding the next day's items # and subtracting the items collected k days ago from the front current_sum += items[i] - items[i - k] # Update the maximum sum if the current window sum is greater max_sum = max(max_sum, current_sum) return max_sum"},{"question":"def replace_repeated_sequences(s: str) -> str: Replace every sequence of three or more consecutive identical characters with just two of those characters. >>> replace_repeated_sequences(\\"aaabbbaaa\\") \\"aabbaa\\" >>> replace_repeated_sequences(\\"cccccc\\") \\"cc\\" >>> replace_repeated_sequences(\\"abc\\") \\"abc\\"","solution":"def replace_repeated_sequences(s): This function replaces every sequence of three or more consecutive identical characters with just two of those characters. if not s: return s result = [] count = 1 n = len(s) for i in range(1, n): if s[i] == s[i - 1]: count += 1 else: result.append(s[i - 1] * min(2, count)) count = 1 result.append(s[-1] * min(2, count)) return ''.join(result)"},{"question":"def min_moves(grid: List[str], start_x: int, start_y: int, end_x: int, end_y: int) -> int: Given a grid representing a warehouse, find the minimum number of moves required for a robot to move from the starting position to the destination. The robot can move horizontally or vertically, but not diagonally. >>> min_moves([ >>> \\".....\\", >>> \\".#.#.\\", >>> \\"....#\\", >>> \\".#...\\", >>> \\".....\\"], 1, 1, 5, 5) 8 >>> min_moves([ >>> \\".#.\\", >>> \\".#.\\", >>> \\".#.\\"], 1, 1, 3, 3) -1 >>> min_moves([ >>> \\"....\\", >>> \\"..\\", >>> \\"....\\", >>> \\".#\\"], 1, 1, 1, 1) 0 >>> min_moves([ >>> \\"....\\", >>> \\"..\\", >>> \\"....\\", >>> \\".#\\"], 1, 1, 2, 1) 1 >>> min_moves([ >>> \\".....\\", >>> \\"...\\", >>> \\"...\\", >>> \\"...\\", >>> \\".....\\"], 1, 1, 5, 5) 8 >>> min_moves([ >>> \\"..................................................\\", >>> \\"..................................................\\", >>> \\"..................................................\\", >>> \\"..................................................\\", >>> \\"..................................................\\", >>> \\"..................................................\\", >>> \\"..................................................\\", >>> \\"..................................................\\", >>> \\"..................................................\\", >>> \\"..................................................\\", >>> \\"..................................................\\", >>> \\"..................................................\\", >>> \\"..................................................\\", >>> \\"..................................................\\", >>> \\"..................................................\\", >>> \\"..................................................\\", >>> \\"..................................................\\", >>> \\"..................................................\\", >>> \\"..................................................\\", >>> \\"..................................................\\", >>> \\"..................................................\\", >>> \\"..................................................\\", >>> \\"..................................................\\", >>> \\"..................................................\\", >>> \\"..................................................\\", >>> \\"..................................................\\", >>> \\"..................................................\\", >>> \\"..................................................\\", >>> \\"..................................................\\", >>> \\"..................................................\\", >>> \\"..................................................\\", >>> \\"..................................................\\", >>> \\"..................................................\\", >>> \\"..................................................\\", >>> \\"..................................................\\", >>> \\"..................................................\\", >>> \\"..................................................\\", >>> \\"..................................................\\", >>> \\"..................................................\\", >>> \\"..................................................\\", >>> \\"..................................................\\", >>> \\"..................................................\\", >>> \\"..................................................\\", >>> \\"..................................................\\", >>> \\"..................................................\\", >>> \\"..................................................\\", >>> \\"..................................................\\", >>> \\"..................................................\\", >>> \\"...............................................#..\\", >>> \\"..................................................\\", >>> \\"..................................................\\", >>> \\"..................................................\\"], 1, 1, 50, 50) 98","solution":"from collections import deque def min_moves(grid, start_x, start_y, end_x, end_y): n = len(grid) start_x, start_y = start_x - 1, start_y - 1 # converting to 0-based index end_x, end_y = end_x - 1, end_y - 1 # converting to 0-based index directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] if start_x == end_x and start_y == end_y: return 0 def is_valid(x, y): return 0 <= x < n and 0 <= y < n and grid[x][y] == '.' queue = deque([(start_x, start_y, 0)]) # (current_x, current_y, distance) visited = set() visited.add((start_x, start_y)) while queue: current_x, current_y, distance = queue.popleft() for dx, dy in directions: new_x, new_y = current_x + dx, current_y + dy if new_x == end_x and new_y == end_y: return distance + 1 if is_valid(new_x, new_y) and (new_x, new_y) not in visited: visited.add((new_x, new_y)) queue.append((new_x, new_y, distance + 1)) return -1"},{"question":"def recognition_level(n: int, scores: List[int]) -> List[str]: Determine the recognition level for each participant based on their score. >>> recognition_level(5, [45, 75, 120, 255, 310]) [\\"Participant\\", \\"Bronze\\", \\"Silver\\", \\"Gold\\", \\"Platinum\\"] >>> recognition_level(3, [50, 99, 200]) [\\"Bronze\\", \\"Bronze\\", \\"Silver\\"] >>> recognition_level(4, [0, 400, 100, 300]) [\\"Participant\\", \\"Platinum\\", \\"Bronze\\", \\"Gold\\"]","solution":"def recognition_level(n, scores): levels = [] for score in scores: if score < 50: levels.append(\\"Participant\\") elif 50 <= score <= 100: levels.append(\\"Bronze\\") elif 101 <= score <= 200: levels.append(\\"Silver\\") elif 201 <= score <= 300: levels.append(\\"Gold\\") else: levels.append(\\"Platinum\\") return levels"},{"question":"def can_transform(A: str, B: str) -> str: Determines if string A can be transformed into string B by inserting exactly one character into A. >>> can_transform(\\"abcd\\", \\"abcde\\") 'YES' >>> can_transform(\\"abc\\", \\"abec\\") 'YES' >>> can_transform(\\"abcd\\", \\"abd\\") 'NO' >>> can_transform(\\"a\\", \\"a\\") 'NO' from solution import can_transform def test_can_transform_correct_cases(): assert can_transform(\\"abcd\\", \\"abcde\\") == \\"YES\\" assert can_transform(\\"abc\\", \\"abec\\") == \\"YES\\" assert can_transform(\\"a\\", \\"aa\\") == \\"YES\\" assert can_transform(\\"abc\\", \\"abxc\\") == \\"YES\\" def test_can_transform_incorrect_cases(): assert can_transform(\\"abcd\\", \\"abd\\") == \\"NO\\" assert can_transform(\\"abc\\", \\"aac\\") == \\"NO\\" assert can_transform(\\"abc\\", \\"abcde\\") == \\"NO\\" assert can_transform(\\"abc\\", \\"ab\\") == \\"NO\\" def test_can_transform_edge_cases(): assert can_transform(\\"\\", \\"a\\") == \\"YES\\" assert can_transform(\\"a\\", \\"aa\\") == \\"YES\\" assert can_transform(\\"a\\", \\"a\\") == \\"NO\\" assert can_transform(\\"\\", \\"\\") == \\"NO\\" assert can_transform(\\"a\\"*10**6, \\"a\\"*(10**6 + 1)) == \\"YES\\" assert can_transform(\\"a\\"*10**6, \\"aa\\"*10**6) == \\"NO\\"","solution":"def can_transform(A, B): Determines if string A can be transformed into string B by inserting exactly one character into A. if len(B) - len(A) != 1: return \\"NO\\" i, j = 0, 0 while i < len(A) and j < len(B): if A[i] != B[j]: if i != j: return \\"NO\\" j += 1 else: i += 1 j += 1 return \\"YES\\""},{"question":"def task_assignments(T, N, Q, priorities, queries): Given the number of tasks, employees, and queries, this function calculates the task assignments after each query. :param T: Number of tasks :param N: Number of employees :param Q: Number of queries :param priorities: Initial priorities of the tasks (list length T) :param queries: List of queries where each query is a tuple (X, Z) indicating that task X's priority should be updated to Z :return: A list of lists where each nested list represents the task assignment order after the respective query pass def test_basic_example(): T, N, Q = 5, 3, 2 priorities = [50, 40, 30, 20, 10] queries = [(3, 10), (2, 35)] assert task_assignments(T, N, Q, priorities, queries) == [1, 2, 3, 1, 2, 3] def test_all_same_priorities(): T, N, Q = 5, 3, 2 priorities = [100, 100, 100, 100, 100] queries = [(1, 50), (5, 150)] assert task_assignments(T, N, Q, priorities, queries) == [1, 2, 3, 1, 2, 3] def test_single_task(): T, N, Q = 1, 1, 1 priorities = [5] queries = [(1, 10)] assert task_assignments(T, N, Q, priorities, queries) == [1] def test_all_tasks_with_unique_priorities(): T, N, Q = 3, 3, 3 priorities = [80, 60, 70] queries = [(1, 90), (2, 10), (3, 100)] assert task_assignments(T, N, Q, priorities, queries) == [1, 2, 3, 1, 2, 3, 1, 2, 3] def test_no_changes_in_priorities(): T, N, Q = 4, 2, 2 priorities = [40, 30, 20, 10] queries = [(4, 10), (3, 20)] assert task_assignments(T, N, Q, priorities, queries) == [1, 2, 1, 2] if __name__ == \\"__main__\\": test_basic_example() test_all_same_priorities() test_single_task() test_all_tasks_with_unique_priorities() test_no_changes_in_priorities() print(\\"All tests passed.\\")","solution":"def task_assignments(T, N, Q, priorities, queries): Given the number of tasks, employees, and queries, this function calculates the task assignments after each query. :param T: Number of tasks :param N: Number of employees :param Q: Number of queries :param priorities: Initial priorities of the tasks (list length T) :param queries: List of queries where each query is a tuple (X, Z) indicating that task X's priority should be updated to Z :return: A list of lists where each nested list represents the task assignment order after the respective query # A function to get the current assignment of tasks to employees def current_assignment(priorities): sorted_tasks = sorted(enumerate(priorities), key=lambda x: -x[1]) assignment = [(i % N) + 1 for i in range(len(sorted_tasks))] return assignment[:N] result = [] for query in queries: task, new_priority = query task -= 1 # Convert 1-based index to 0-based priorities[task] = new_priority result.extend(current_assignment(priorities)) return result"},{"question":"def longest_common_prefix(strings): Returns the longest common prefix of a list of binary strings. Args: strings (list of str): List of binary strings. Returns: str: The longest common prefix string. Examples: >>> longest_common_prefix([\\"101100\\", \\"10110\\", \\"1011\\", \\"1010101\\"]) '101' >>> longest_common_prefix([\\"1110\\", \\"1101\\", \\"1011\\"]) '1'","solution":"def longest_common_prefix(strings): Returns the longest common prefix of a list of binary strings. Args: strings (list of str): List of binary strings. Returns: str: The longest common prefix string. if not strings: return \\"\\" # Initialize the prefix with the first string prefix = strings[0] for string in strings[1:]: # Compare the prefix with each string, shrinking the prefix if necessary i = 0 while i < len(prefix) and i < len(string) and prefix[i] == string[i]: i += 1 prefix = prefix[:i] if prefix == \\"\\": break return prefix"},{"question":"def final_positions(N: int, M: int, initial_positions: List[int], move_counts: List[int]) -> List[int]: Calculates the final positions of friends after moving a given number of spaces on a circular track. Args: N (int): Number of spaces on the track. M (int): Number of friends. initial_positions (list of int): Initial positions of the friends. move_counts (list of int): Number of spaces each friend will move. Returns: list: Final positions of the friends on the track. pass from solution import final_positions def test_positions_example_case(): assert final_positions(12, 3, [0, 4, 7], [5, 10, 15]) == [5, 2, 10] def test_positions_no_moves(): assert final_positions(10, 2, [1, 5], [0, 0]) == [1, 5] def test_positions_small_track(): assert final_positions(3, 2, [0, 1], [1, 2]) == [1, 0] def test_positions_multiple_laps(): assert final_positions(10, 2, [0, 5], [15, 25]) == [5, 0] def test_positions_same_start_different_moves(): assert final_positions(8, 3, [3, 3, 3], [4, 8, 12]) == [7, 3, 7] def test_positions_large_numbers(): assert final_positions(1000000, 3, [999999, 500000, 100000], [1, 500000, 900000]) == [0, 0, 0] def test_positions_single_friend(): assert final_positions(5, 1, [2], [7]) == [4]","solution":"def final_positions(N, M, initial_positions, move_counts): Calculates the final positions of friends after moving a given number of spaces on a circular track. Args: N (int): Number of spaces on the track. M (int): Number of friends. initial_positions (list of int): Initial positions of the friends. move_counts (list of int): Number of spaces each friend will move. Returns: list: Final positions of the friends on the track. final_positions = [] for i in range(M): final_position = (initial_positions[i] + move_counts[i]) % N final_positions.append(final_position) return final_positions"},{"question":"from typing import List def min_coins(coins: List[int], S: int) -> int: Returns the minimum number of coins required to produce the sum S using the given denominations. If it is not possible to produce the sum S, returns -1. def handle_multiple_cases(inputs: List[int]) -> List[int]: Takes a list of integers representing multiple test cases. For each test case, prints the minimum number of coins required to make the sum S or -1 if it's not possible. Stops processing when it encounters a 0 in the input. Parameters: inputs (List[int]): A list of integers representing the sums. Returns: List[int]: A list of results corresponding to each sum in the inputs. # Basic test cases def test_min_coins_basic_cases(): assert min_coins([1, 3, 4], 6) == 2 # 3 + 3 assert min_coins([1, 3, 4], 7) == 2 # 3 + 4 assert min_coins([1, 3, 4], 2) == 2 # 1 + 1 assert min_coins([1, 3, 4], 0) == 0 # 0 coins for sum 0 # Edge test cases def test_min_coins_edge_cases(): assert min_coins([1, 3, 4], 1) == 1 # 1 coin of 1 assert min_coins([1, 3, 4], 3) == 1 # 1 coin of 3 assert min_coins([1, 3, 4], 4) == 1 # 1 coin of 4 # Unreachable sum test case def test_min_coins_unreachable_sum(): assert min_coins([3, 4], 2) == -1 # Not possible to form 2 with coins 3 and 4 # Large sum test case def test_min_coins_large_sum(): assert min_coins([1, 3, 4], 100000) == 25000 # 25,000 coins of 4 # Multiple cases handling test case def test_handle_multiple_cases(): inputs = [6, 7, 2, 0] expected_output = [2, 2, 2] assert handle_multiple_cases(inputs) == expected_output # Multiple cases with unreachable sum test case def test_handle_multiple_cases_with_unreachable_sum(): inputs = [8, 5, 0] expected_output = [2, 2] assert handle_multiple_cases(inputs) == expected_output","solution":"def min_coins(coins, S): Returns the minimum number of coins required to produce the sum S using the given denominations. If it is not possible to produce the sum S, returns -1. # Initialize a list to store the minimum coins required for each amount dp = [float('inf')] * (S + 1) dp[0] = 0 # No coins are needed to produce 0 sum # Iterate through each amount from 1 to S for i in range(1, S + 1): for coin in coins: if i - coin >= 0: # If the coin can be used dp[i] = min(dp[i], dp[i - coin] + 1) # If the number of coins for S is still infinity, it means it's not possible to form S return dp[S] if dp[S] != float('inf') else -1 def handle_multiple_cases(inputs): coins = [1, 3, 4] results = [] for S in inputs: if S == 0: break results.append(min_coins(coins, S)) return results"},{"question":"class Grid: def __init__(self, grid): Initialize the grid and pre-calculate prefix sums for efficient sub-grid sum calculation. grid: List of List of integers representing the initial grid values. pass def update(self, i: int, j: int, x: int) -> None: Update the value at cell (i, j) to x. i: Row index j: Column index x: New value to update pass def query(self, i: int, j: int) -> int: Get the current value at cell (i, j). i: Row index j: Column index Returns the current value at the specified cell. pass def sum_subgrid(self, x1: int, y1: int, x2: int, y2: int) -> int: Compute the sum of all values within the sub-grid defined by the corners (x1, y1) and (x2, y2) inclusive. x1: Row index of the top-left corner y1: Column index of the top-left corner x2: Row index of the bottom-right corner y2: Column index of the bottom-right corner Returns the sum of the values within the defined sub-grid. pass import pytest def test_grid_operations(): grid_data = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] grid = Grid(grid_data) # Test queries assert grid.query(1, 1) == 5 assert grid.sum_subgrid(0, 0, 2, 2) == 45 # Test update grid.update(2, 2, 10) assert grid.query(2, 2) == 10 assert grid.sum_subgrid(1, 1, 2, 2) == 29 def test_partial_sum(): grid_data = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] grid = Grid(grid_data) # Testing a smaller sub-grid sum assert grid.sum_subgrid(0, 0, 1, 1) == 12 # 1+2+4+5 = 12 assert grid.sum_subgrid(1, 1, 2, 2) == 28 # 5+6+8+9 = 28 def test_large_update(): grid_data = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] grid = Grid(grid_data) grid.update(0, 0, 0) # Update (0, 0) to 0 assert grid.query(0, 0) == 0 assert grid.sum_subgrid(0, 0, 2, 2) == 44 # Updated sum 0+2+3+4+5+6+7+8+9 = 44","solution":"class Grid: def __init__(self, grid): self.grid = grid self.n = len(grid) self.m = len(grid[0]) self._build_prefix_sum() def _build_prefix_sum(self): self.prefix_sum = [[0] * (self.m + 1) for _ in range(self.n + 1)] for i in range(1, self.n + 1): for j in range(1, self.m + 1): self.prefix_sum[i][j] = ( self.grid[i-1][j-1] + self.prefix_sum[i-1][j] + self.prefix_sum[i][j-1] - self.prefix_sum[i-1][j-1] ) def update(self, i, j, x): old_value = self.grid[i][j] self.grid[i][j] = x diff = x - old_value for r in range(i + 1, self.n + 1): for c in range(j + 1, self.m + 1): self.prefix_sum[r][c] += diff def query(self, i, j): return self.grid[i][j] def sum_subgrid(self, x1, y1, x2, y2): return ( self.prefix_sum[x2+1][y2+1] - self.prefix_sum[x1][y2+1] - self.prefix_sum[x2+1][y1] + self.prefix_sum[x1][y1] )"},{"question":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def is_balanced(root): Determine if a binary tree is height-balanced. >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> root.left.left = TreeNode(4) >>> is_balanced(root) True >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.left.left = TreeNode(3) >>> is_balanced(root) False >>> is_balanced(None) True >>> root = TreeNode(1) >>> is_balanced(root) True >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> root.left.left = TreeNode(4) >>> root.left.right = TreeNode(5) >>> root.right.left = TreeNode(6) >>> root.right.right = TreeNode(7) >>> root.left.left.left = TreeNode(8) >>> root.right.left.right = TreeNode(9) >>> is_balanced(root) True >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> root.left.left = TreeNode(4) >>> root.left.left.right = TreeNode(6) >>> root.right.right = TreeNode(5) >>> root.right.right.right = TreeNode(7) >>> is_balanced(root) False","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def is_balanced(root): Determine if a binary tree is height-balanced. def check_height(node): # Return tuple (is_balanced, height) if node is None: return (True, 0) left_balanced, left_height = check_height(node.left) right_balanced, right_height = check_height(node.right) current_balanced = ( left_balanced and right_balanced and abs(left_height - right_height) <= 1 ) current_height = 1 + max(left_height, right_height) return (current_balanced, current_height) return check_height(root)[0]"},{"question":"def most_frequent_character(s: str) -> str: Returns the most frequent character in the string s. If multiple characters have the same highest frequency, the alphabetically smallest character is returned. >>> most_frequent_character('a') 'a' >>> most_frequent_character('bbbb') 'b' >>> most_frequent_character('aabb') 'a' >>> most_frequent_character('abc') 'a' >>> most_frequent_character('aabbbcc') 'b' >>> most_frequent_character('abcdefghijklmnopqrstuvwxyz') 'a'","solution":"def most_frequent_character(s): Returns the most frequent character in the string s. If multiple characters have the same highest frequency, the alphabetically smallest character is returned. from collections import Counter freq = Counter(s) max_frequency = max(freq.values()) most_frequent_chars = [char for char, count in freq.items() if count == max_frequency] return min(most_frequent_chars)"},{"question":"def find_max_rectangle_area(n: int, m: int, grid_lines: List[str]) -> int: Returns the maximum area of a rectangle containing only 1s in the given grid. >>> find_max_rectangle_area(4, 5, [\\"10100\\", \\"10111\\", \\"11111\\", \\"10010\\"]) 6 >>> find_max_rectangle_area(3, 3, [\\"111\\", \\"111\\", \\"111\\"]) 9 >>> find_max_rectangle_area(2, 4, [\\"0110\\", \\"0110\\"]) 4 >>> find_max_rectangle_area(1, 1, [\\"0\\"]) 0 >>> find_max_rectangle_area(1, 1, [\\"1\\"]) 1 >>> find_max_rectangle_area(0, 0, []) 0 >>> find_max_rectangle_area(2, 2, [\\"01\\", \\"10\\"]) 1","solution":"def max_rectangle_area(grid): Returns the maximum area of a rectangle containing only 1s in a given binary grid. if not grid: return 0 n = len(grid) m = len(grid[0]) max_area = 0 heights = [0] * m for i in range(n): for j in range(m): if grid[i][j] == '1': heights[j] += 1 else: heights[j] = 0 max_area = max(max_area, max_histogram_area(heights)) return max_area def max_histogram_area(heights): Helper function to calculate the maximum rectangular area in a histogram given its heights. stack = [] max_area = 0 index = 0 while index < len(heights): if not stack or heights[stack[-1]] <= heights[index]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area def find_max_rectangle_area(n, m, grid_lines): grid = [list(line) for line in grid_lines] return max_rectangle_area(grid)"},{"question":"from typing import List, Tuple def distribute_candies(N: int, M: int) -> int: Returns the number of distinct ways to distribute N identical candies into M boxes such that no box is empty. >>> distribute_candies(7, 3) 15 >>> distribute_candies(5, 5) 1 >>> distribute_candies(5, 6) 0 pass def distribute_candies_main(test_cases: List[Tuple[int, int]]) -> List[int]: Main function to handle multiple test cases. >>> distribute_candies_main([(7, 3), (5, 5), (5, 6), (10, 1), (10, 10)]) [15, 1, 0, 1, 1] pass","solution":"from math import comb def distribute_candies(N, M): Returns the number of distinct ways to distribute N identical candies into M boxes such that no box is empty. if N < M: return 0 return comb(N - 1, M - 1) def distribute_candies_main(test_cases): Main function to handle multiple test cases. results = [] for N, M in test_cases: result = distribute_candies(N, M) results.append(result) return results"},{"question":"def is_connected(N: int, M: int, roads: List[Tuple[int, int]]) -> str: Determine if the road network is connected. >>> is_connected(4, 3, [(1, 2), (2, 3), (3, 4)]) \\"YES\\" >>> is_connected(4, 2, [(1, 2), (3, 4)]) \\"NO\\" >>> is_connected(5, 4, [(1, 2), (2, 3), (3, 4), (4, 5)]) \\"YES\\"","solution":"def is_connected(N, M, roads): from collections import defaultdict, deque # Create an adjacency list for the cities graph = defaultdict(list) for u, v in roads: graph[u].append(v) graph[v].append(u) # Function to perform BFS def bfs(start_node): visited = set() queue = deque([start_node]) while queue: node = queue.popleft() if node in visited: continue visited.add(node) for neighbor in graph[node]: if neighbor not in visited: queue.append(neighbor) return visited # Start BFS from the first city visited_cities = bfs(1) # Check if all cities are visited if len(visited_cities) == N: return \\"YES\\" else: return \\"NO\\""},{"question":"def determine_winner(n: int, arr: List[int]) -> str: Determines the winner of the game given the initial length of the array and the array itself. >>> determine_winner(3, [12, 15, 18]) \\"Alice\\" >>> determine_winner(4, [3, 5, 7, 11]) \\"Bob\\" >>> determine_winner(1, [100]) \\"Alice\\" >>> determine_winner(2, [100, 200]) \\"Bob\\" >>> determine_winner(5, [20, 30, 50, 70, 90]) \\"Alice\\" >>> determine_winner(6, [3, 5, 10, 20, 45, 60]) \\"Bob\\"","solution":"def determine_winner(n, arr): Determines the winner of the game given the initial length of the array and the array itself. # Alice wins if the array length \`n\` is odd, Bob wins if \`n\` is even return \\"Alice\\" if n % 2 != 0 else \\"Bob\\""},{"question":"def determine_hierarchy_levels(n: int, hierarchy: List[Tuple[int, int]]) -> List[int]: Determine the level of each employee in a hierarchical structure. Args: n (int): The number of employees. hierarchy (List[Tuple[int, int]]): A list of tuples where each tuple contains two integers representing the employee_id and supervisor_id. Returns: List[int]: A list with the levels of each employee in ascending order of their IDs. Examples: >>> determine_hierarchy_levels(6, [(1, 0), (2, 1), (3, 1), (4, 2), (5, 2), (6, 3)]) [1, 2, 2, 3, 3, 3] >>> determine_hierarchy_levels(4, [(1, 0), (2, 1), (3, 2), (4, 3)]) [1, 2, 3, 4] from collections import defaultdict, deque def determine_hierarchy_levels(n, hierarchy): from collections import defaultdict, deque # Initialize dictionary to store subordinates of each employee subordinates = defaultdict(list) # Dictionary to store level of each employee levels = {} # Populate the subordinates dictionary and find the CEO ID ceo_id = None for employee_id, supervisor_id in hierarchy: if supervisor_id == 0: ceo_id = employee_id else: subordinates[supervisor_id].append(employee_id) # Perform BFS to determine levels queue = deque([(ceo_id, 1)]) while queue: curr_employee, curr_level = queue.popleft() levels[curr_employee] = curr_level for subordinate in subordinates[curr_employee]: queue.append((subordinate, curr_level + 1)) # Return levels in ascending order of employee id return [levels[i] for i in range(1, n + 1)]","solution":"def determine_hierarchy_levels(n, hierarchy): from collections import defaultdict, deque # Initialize dictionary to store subordinates of each employee subordinates = defaultdict(list) # Dictionary to store level of each employee levels = {} # Populate the subordinates dictionary and find the CEO ID ceo_id = None for employee_id, supervisor_id in hierarchy: if supervisor_id == 0: ceo_id = employee_id else: subordinates[supervisor_id].append(employee_id) # Perform BFS to determine levels queue = deque([(ceo_id, 1)]) while queue: curr_employee, curr_level = queue.popleft() levels[curr_employee] = curr_level for subordinate in subordinates[curr_employee]: queue.append((subordinate, curr_level + 1)) # Return levels in ascending order of employee id return [levels[i] for i in range(1, n + 1)]"},{"question":"def can_distribute_stickers(n: int, m: int, t: str) -> str: Determines if it's possible to distribute stickers to m cousins such that no cousin gets two stickers with the same animal. Parameters: n : int : Number of stickers m : int : Number of cousins t : str : String of animal images on stickers Returns: str : \\"YES\\" if possible to distribute stickers accordingly, \\"NO\\" otherwise. Examples: >>> can_distribute_stickers(5, 2, 'abbcc') \\"YES\\" >>> can_distribute_stickers(4, 3, 'aaaa') \\"NO\\"","solution":"def can_distribute_stickers(n, m, t): Determines if it's possible to distribute stickers to m cousins such that no cousin gets two stickers with the same animal. Parameters: n : int : Number of stickers m : int : Number of cousins t : str : String of animal images on stickers Returns: str : \\"YES\\" if possible to distribute stickers accordingly, \\"NO\\" otherwise. from collections import Counter # Count the frequency of each animal image in the stickers counts = Counter(t) # Check if any animal image appears more times than there are cousins for count in counts.values(): if count > m: return \\"NO\\" return \\"YES\\""},{"question":"from typing import List, Tuple def construct_highways(n: int, m: int, roads: List[Tuple[int, int, int]], priorities: List[int]) -> List[Tuple[int, int, int]]: Connect all villages ensuring there is exactly one highway between any two villages without ambiguity in shortest path. Args: - n (int): the number of villages - m (int): the number of roads - roads (List[Tuple[int, int, int]]): the existing roads between villages - priorities (List[int]): the priorities for village connections Returns: - List[Tuple[int, int, int]]: the list of newly constructed highways pass # Sample Test Cases def test_highways_example(): n = 4 m = 3 roads = [ (1, 2, 5), (2, 3, 7), (3, 4, 9) ] priorities = [2, 3, 1, 4] expected_output = [ (1, 2, 5), (2, 3, 7), (3, 4, 9) ] assert construct_highways(n, m, roads, priorities) == expected_output def test_highways_case1(): n = 3 m = 3 roads = [ (1, 2, 2), (2, 3, 3), (1, 3, 1) ] priorities = [1, 2, 3] expected_output = [ (1, 3, 1), (1, 2, 2), ] assert construct_highways(n, m, roads, priorities) == expected_output def test_highways_case2(): n = 5 m = 4 roads = [ (1, 2, 1), (1, 3, 2), (3, 4, 4), (4, 5, 5) ] priorities = [3, 3, 2, 2, 1] expected_output = [ (1, 2, 1), (1, 3, 2), (3, 4, 4), (4, 5, 5), ] assert construct_highways(n, m, roads, priorities) == expected_output def test_highways_case3(): n = 2 m = 1 roads = [ (1, 2, 6) ] priorities = [1, 1] expected_output = [ (1, 2, 6), ] assert construct_highways(n, m, roads, priorities) == expected_output","solution":"def construct_highways(n, m, roads, priorities): # Kruskal's Algorithm for Minimum Spanning Tree # Sort the edges by weight (distance of the road) roads.sort(key=lambda x: x[2]) parent = list(range(n)) rank = [0] * n def find(v): if parent[v] != v: parent[v] = find(parent[v]) return parent[v] def union(v1, v2): root1 = find(v1) root2 = find(v2) if root1 != root2: if rank[root1] > rank[root2]: parent[root2] = root1 elif rank[root1] < rank[root2]: parent[root1] = root2 else: parent[root2] = root1 rank[root1] += 1 # The result MST result = [] for u, v, w in roads: if find(u - 1) != find(v - 1): union(u - 1, v - 1) result.append((u, v, w)) if len(result) == n - 1: break return result n = 4 m = 3 roads = [ (1, 2, 5), (2, 3, 7), (3, 4, 9) ] priorities = [2, 3, 1, 4] highways = construct_highways(n, m, roads, priorities) for h in highways: print(h)"},{"question":"def guess_hidden_sequence(n: int, sum_query: callable) -> list: Function to guess the hidden sequence of length n using sum_query function. sum_query is a callable that takes two arguments l and r, and returns the sum of elements in the subarray from l to r in the hidden sequence. Example: >>> def sum_query(l, r): ... seq = [1, 2, 3, 4, 5] ... return sum(seq[l:r+1]) >>> guess_hidden_sequence(5, sum_query) [1, 2, 3, 4, 5] def test_guess_hidden_sequence(): # Test case 1 hidden_seq = [1, 2, 3, 4, 5] n = len(hidden_seq) def sum_query(l, r): return sum(hidden_seq[l:r+1]) assert guess_hidden_sequence(n, sum_query) == hidden_seq # Test case 2 hidden_seq = [-2, -1, 0, 1, 2] n = len(hidden_seq) def sum_query(l, r): return sum(hidden_seq[l:r+1]) assert guess_hidden_sequence(n, sum_query) == hidden_seq # Test case 3 hidden_seq = [10, -10, 10, -10, 10] n = len(hidden_seq) def sum_query(l, r): return sum(hidden_seq[l:r+1]) assert guess_hidden_sequence(n, sum_query) == hidden_seq # Test case 4 hidden_seq = [0] n = len(hidden_seq) def sum_query(l, r): return sum(hidden_seq[l:r+1]) assert guess_hidden_sequence(n, sum_query) == hidden_seq # Test case 5 hidden_seq = [-10**6, 10**6] n = len(hidden_seq) def sum_query(l, r): return sum(hidden_seq[l:r+1]) assert guess_hidden_sequence(n, sum_query) == hidden_seq","solution":"def guess_hidden_sequence(n, sum_query): Function to guess the hidden sequence of length n using sum_query function. sum_query is a callable that takes two arguments l and r, and returns the sum of elements in the subarray from l to r in the hidden sequence. hidden_sequence = [] for i in range(n): if i == 0: s = sum_query(0, 0) hidden_sequence.append(s) else: s = sum_query(0, i) prev_s = sum_query(0, i - 1) hidden_sequence.append(s - prev_s) return hidden_sequence # Simulating the interaction with hidden sequence: def interactive(hidden_seq, queries): result = [] for query in queries: l, r = query result.append(sum(hidden_seq[l:r+1])) return result # Example usage: # n = 5 # hidden_seq = [1, 2, 3, 4, 5] # sum_query = lambda l, r: sum(hidden_seq[l:r+1]) # guess_hidden_sequence(n, sum_query) -> [1, 2, 3, 4, 5] # To interact with the guessing function: import sys def main(): input = sys.stdin.read data = input().split() n = int(data[0]) def sum_query(l, r): print(f\\"? {l} {r}\\") sys.stdout.flush() return int(input()) final_sequence = guess_hidden_sequence(n, sum_query) print(\\"!\\", \\" \\".join(map(str, final_sequence))) sys.stdout.flush() if __name__ == '__main__': main()"},{"question":"def max_non_overlapping_rectangles(rectangles): Returns the maximum number of non-overlapping rectangles. pass def process_input(input_data): Processes the given input data and returns the answers for each test case. pass def test_max_non_overlapping_rectangles(): assert max_non_overlapping_rectangles([(1, 1, 3, 3), (2, 2, 4, 4), (5, 5, 6, 6)]) == 2 assert max_non_overlapping_rectangles([(0, 0, 2, 2), (1, 1, 3, 3), (1, 4, 3, 5), (2, 2, 4, 4)]) == 2 assert max_non_overlapping_rectangles([(0, 0, 1, 1)]) == 1 assert max_non_overlapping_rectangles([(1, 1, 2, 2), (3, 3, 4, 4), (5, 5, 6, 6), (7, 7, 8, 8)]) == 4 def test_process_input_single_case(): input_data = \\"3n1 1 3 3n2 2 4 4n5 5 6 6n0n\\" assert process_input(input_data) == [2] def test_process_input_multiple_cases(): input_data = \\"3n1 1 3 3n2 2 4 4n5 5 6 6n4n0 0 2 2n1 1 3 3n1 4 3 5n2 2 4 4n0n\\" assert process_input(input_data) == [2, 2] def test_process_input_edge_cases(): input_data = \\"1n-1000000000 -1000000000 1000000000 1000000000n0n\\" assert process_input(input_data) == [1] def test_process_input_no_rectangles(): input_data = \\"0n\\" assert process_input(input_data) == []","solution":"def max_non_overlapping_rectangles(rectangles): Returns the maximum number of non-overlapping rectangles. # Sort rectangles by their end coordinates to apply greedy approach rectangles.sort(key=lambda rect: rect[2]) max_rectangles = 0 end_x = -float('inf') for x1, y1, x2, y2 in rectangles: if x1 >= end_x: max_rectangles += 1 end_x = x2 # update the end to the current rectangle's end return max_rectangles def process_input(input_data): Processes the given input data and returns the answers for each test case. lines = input_data.strip().split(\\"n\\") idx = 0 results = [] while idx < len(lines): N = int(lines[idx].strip()) if N == 0: break idx += 1 rectangles = [] for _ in range(N): x1, y1, x2, y2 = map(int, lines[idx].strip().split()) rectangles.append((x1, y1, x2, y2)) idx += 1 max_rec = max_non_overlapping_rectangles(rectangles) results.append(max_rec) return results def main(): import sys input_data = sys.stdin.read() results = process_input(input_data) for result in results: print(result) # If running the script directly, uncomment the following line: # main()"},{"question":"def find_minimum_idle_participants(input_list: List[str]) -> int: Determine the minimum number of extra participants that will be idle after fulfilling the requirements of all events. >>> find_minimum_idle_participants([\\"2\\", \\"3\\", \\"1 5\\", \\"2 6\\", \\"3 3\\", \\"15\\", \\"2\\", \\"4 4\\", \\"5 5\\", \\"12\\"]) 4 >>> find_minimum_idle_participants([\\"1\\", \\"2\\", \\"1 50\\", \\"2 50\\", \\"150\\"]) 50","solution":"def minimum_idle_participants(number_of_days, events_per_day, participants_per_day): idle_participants = 0 for day in range(number_of_days): total_required = sum(required for event, required in events_per_day[day]) participants_available = participants_per_day[day] idle_participants += max(0, participants_available - total_required) return idle_participants def parse_input(input_list): number_of_days = int(input_list[0]) events_per_day = [] participants_per_day = [] index = 1 for _ in range(number_of_days): M = int(input_list[index]) daily_events = [] for i in range(1, M + 1): Eij, Rpj = map(int, input_list[index + i].split()) daily_events.append((Eij, Rpj)) events_per_day.append(daily_events) index += M + 1 participants_per_day.append(int(input_list[index])) index += 1 return number_of_days, events_per_day, participants_per_day def find_minimum_idle_participants(input_list): number_of_days, events_per_day, participants_per_day = parse_input(input_list) return minimum_idle_participants(number_of_days, events_per_day, participants_per_day)"},{"question":"def smallest_missing_positive(nums: List[int]) -> int: Find the smallest missing positive integer in the given array. >>> smallest_missing_positive([1, 2, 0]) == 3 >>> smallest_missing_positive([3, 4, -1, 1]) == 2 >>> smallest_missing_positive([7, 8, 9, 11, 12]) == 1 def smallest_missing_positive_in_test_cases(test_cases: List[Tuple[int, List[int]]]) -> List[int]: Process multiple test cases and return a list of the smallest missing positive integers for each case. >>> smallest_missing_positive_in_test_cases([(3, [1, 2, 0]), (4, [3, 4, -1, 1]), (5, [7, 8, 9, 11, 12])]) == [3, 2, 1] def parse_input(input_str: str) -> List[Tuple[int, List[int]]]: Parse the multiline string input into a list of test cases formatted as tuples. >>> parse_input(\\"3n3 1 2 0n4 3 4 -1 1n5 7 8 9 11 12\\") == [(3, [1, 2, 0]), (4, [3, 4, -1, 1]), (5, [7, 8, 9, 11, 12])] def format_output(results: List[int]) -> str: Format the list of results into a multiline string for output. >>> format_output([3, 2, 1]) == \\"3n2n1\\"","solution":"def smallest_missing_positive(nums): This function finds the smallest missing positive integer in the given array. nums_set = set(nums) smallest_missing = 1 while smallest_missing in nums_set: smallest_missing += 1 return smallest_missing def smallest_missing_positive_in_test_cases(test_cases): This function processes multiple test cases and returns a list of the smallest missing positive integers for each case. results = [] for n, nums in test_cases: result = smallest_missing_positive(nums) results.append(result) return results def parse_input(input_str): Parse the multiline string input into a list of test cases formatted as tuples. lines = input_str.strip().split(\\"n\\") t = int(lines[0]) test_cases = [] for i in range(1, t + 1): line = list(map(int, lines[i].split())) n = line[0] nums = line[1:] test_cases.append((n, nums)) return test_cases def format_output(results): Format the list of results into a multiline string for output. return \\"n\\".join(map(str, results))"},{"question":"def min_difference(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Determine the minimum possible difference between the total time spent by the worker who has the most tasks and the worker who has the least tasks. Args: T (int): Number of test cases test_cases (List[Tuple[int, List[int]]]): List of test cases, each containing an integer N and a list of N integers representing the time required for each task. Returns: List[int]: List of integers representing the minimum possible difference for each test case Example: >>> min_difference(2, [(3, [8, 15, 7]), (5, [1, 2, 3, 4, 5])]) [0, 1] >>> min_difference(1, [(1, [10])]) [10] >>> min_difference(1, [(4, [10, 10, 10, 10])]) [0] >>> min_difference(1, [(4, [1, 1, 1, 8])]) [5]","solution":"def min_difference(T, test_cases): def helper(tasks): total_time = sum(tasks) n = len(tasks) half_time = total_time // 2 dp = [0] * (half_time + 1) for time in tasks: for j in range(half_time, time - 1, -1): dp[j] = max(dp[j], dp[j - time] + time) return abs(total_time - 2 * dp[half_time]) results = [] for t in range(T): tasks = test_cases[t][1] results.append(helper(tasks)) return results"},{"question":"def min_operations_to_make_equal(n: int, arr: List[int]) -> int: Determines the minimum number of operations required to make all elements of the array equal. Parameters: n (int): The number of elements in the array. arr (list of int): The elements of the array. Returns: int: The minimum number of operations required. Examples: >>> min_operations_to_make_equal(3, [1, 2, 3]) 2 >>> min_operations_to_make_equal(4, [10, 10, 10, 10]) 0 >>> min_operations_to_make_equal(5, [1, 1, 1, 1, 2]) 1","solution":"def min_operations_to_make_equal(n, arr): Determines the minimum number of operations required to make all elements of the array equal. Parameters: n (int): The number of elements in the array. arr (list of int): The elements of the array. Returns: int: The minimum number of operations required. if n == 0: return 0 median_val = sorted(arr)[n // 2] return sum(abs(x - median_val) for x in arr)"},{"question":"def largest_number(nums: List[int]) -> str: Rearrange the elements to form the largest possible integer. >>> largest_number([3, 30, 34, 5, 9]) \\"9534330\\" >>> largest_number([10, 2]) \\"210\\" >>> largest_number([1, 11, 111, 1111]) \\"1111111111\\" >>> largest_number([0, 0, 0, 1]) \\"1000\\" >>> largest_number([0, 0]) \\"0\\" >>> largest_number([0]) \\"0\\" >>> largest_number([]) \\"0\\"","solution":"from functools import cmp_to_key def compare(x, y): if x + y > y + x: return -1 else: return 1 def largest_number(nums): # Convert integers to strings for easier comparison. nums = list(map(str, nums)) # Sort the numbers based on the custom comparator. nums.sort(key=cmp_to_key(compare)) # Join the sorted numbers to form the largest number. largest_num = ''.join(nums) # Remove leading zeros. largest_num = largest_num.lstrip('0') # Return '0' if the result is empty, which implies the list was full of zeros. return largest_num or '0'"},{"question":"from typing import List, Tuple def count_unique_stones(stones: List[int], queries: List[Tuple[int, int]]) -> List[int]: Returns the count of unique stones within the specified ranges for each query. :param stones: List[int] - List of stone identifiers. :param queries: List[Tuple[int, int]] - List of tuples where each tuple is a range [l, r]. :return: List[int] - List of counts of unique stones for each query. Examples: >>> count_unique_stones([1, 2, 3, 4, 5], [(1, 5), (1, 3), (2, 4)]) [5, 3, 3] >>> count_unique_stones([-2, -1, 0, 1, 2, 2], [(-2, 1), (0, 2)]) [4, 3] pass","solution":"def count_unique_stones(stones, queries): Returns the count of unique stones within the specified ranges for each query. :param stones: List[int] - List of stone identifiers. :param queries: List[Tuple[int, int]] - List of tuples where each tuple is a range [l, r]. :return: List[int] - List of counts of unique stones for each query. results = [] for l, r in queries: unique_stones = set(s for s in stones if l <= s <= r) results.append(len(unique_stones)) return results"},{"question":"from typing import List def trap_rain_water(heights: List[int]) -> int: Calculate how much water can be trapped after raining, given a list of integers representing the elevation map. >>> trap_rain_water([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) == 6 >>> trap_rain_water([4, 2, 0, 3, 2, 5]) == 9 >>> trap_rain_water([3, 0, 1, 3, 0, 5]) == 8 >>> trap_rain_water([]) == 0 >>> trap_rain_water([1, 1, 1, 1]) == 0 >>> trap_rain_water([0, 0, 0, 0]) == 0 >>> trap_rain_water([4, 3, 2, 1]) == 0 >>> trap_rain_water([1, 2, 3, 4]) == 0 >>> trap_rain_water([3]) == 0 >>> trap_rain_water([2, 1]) == 0 pass","solution":"def trap_rain_water(heights): Calculate how much water can be trapped after raining, given a list of integers representing the elevation map. if not heights: return 0 n = len(heights) left_max = [0] * n right_max = [0] * n water_trapped = 0 # Fill left_max array left_max[0] = heights[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], heights[i]) # Fill right_max array right_max[n - 1] = heights[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], heights[i]) # Calculate total water trapped for i in range(n): water_trapped += min(left_max[i], right_max[i]) - heights[i] return water_trapped"},{"question":"def first_unblocked_building(heights: List[int]) -> List[int]: Return an array where each element is replaced by the height of the first unblocked building to its left, or -1 if no such building exists. >>> first_unblocked_building([3, 7, 8, 3, 6, 1, 5, 8]) [-1, -1, -1, 8, 8, 6, 6, -1] >>> first_unblocked_building([1, 2, 3, 4, 5]) [-1, -1, -1, -1, -1] >>> first_unblocked_building([5, 4, 3, 2, 1]) [-1, 5, 4, 3, 2] >>> first_unblocked_building([4, 1, 3, 2, 5]) [-1, 4, 4, 3, -1] >>> first_unblocked_building([1]) [-1] >>> first_unblocked_building([3, 3, 3, 3]) [-1, -1, -1, -1]","solution":"def first_unblocked_building(heights): Return an array where each element is replaced by the height of the first unblocked building to its left, or -1 if no such building exists. n = len(heights) result = [-1] * n stack = [] for i in range(n): while stack and stack[-1] <= heights[i]: stack.pop() if stack: result[i] = stack[-1] stack.append(heights[i]) return result"},{"question":"def can_partition_to_equal_subsets(n: int, difficulties: List[int]) -> str: Determine if the list of hiking routes can be partitioned into two subsets with equal difficulty levels. >>> can_partition_to_equal_subsets(4, [4, 1, 2, 3]) \\"YES\\" >>> can_partition_to_equal_subsets(1, [1]) \\"NO\\" >>> can_partition_to_equal_subsets(2, [5, 5]) \\"YES\\" >>> can_partition_to_equal_subsets(2, [5, 10]) \\"NO\\" >>> can_partition_to_equal_subsets(3, [1, 2, 5]) \\"NO\\" >>> can_partition_to_equal_subsets(5, [2, 2, 1, 1, 2]) \\"YES\\" >>> can_partition_to_equal_subsets(4, [5, 6, 5, 6]) \\"YES\\" >>> can_partition_to_equal_subsets(5, [1, 2, 3, 5, 6]) \\"NO\\"","solution":"def can_partition_to_equal_subsets(n, difficulties): total_sum = sum(difficulties) # If total sum is odd, we can't partition it into two equal subsets if total_sum % 2 != 0: return \\"NO\\" target = total_sum // 2 # Initialize a boolean dp array dp = [False] * (target + 1) dp[0] = True # Process each difficulty for difficulty in difficulties: for j in range(target, difficulty - 1, -1): if dp[j - difficulty]: dp[j] = True return \\"YES\\" if dp[target] else \\"NO\\" # Example Usage # print(can_partition_to_equal_subsets(4, [4, 1, 2, 3])) # Expected output: YES"},{"question":"from typing import List def max_submatrix_sum(matrix: List[List[int]]) -> int: Find the sum of the values in a submatrix with the highest possible sum. >>> max_submatrix_sum([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) 45 >>> max_submatrix_sum([ ... [-1, -2], ... [-3, 4] ... ]) 4","solution":"def max_submatrix_sum(matrix): n = len(matrix) m = len(matrix[0]) # Initialize a prefix sum matrix prefix_sum = [[0] * (m + 1) for _ in range(n + 1)] # Build prefix sum matrix for i in range(1, n + 1): for j in range(1, m + 1): prefix_sum[i][j] = matrix[i-1][j-1] + prefix_sum[i-1][j] + prefix_sum[i][j-1] - prefix_sum[i-1][j-1] max_sum = float('-inf') # Iterate over all possible submatrices for i1 in range(1, n + 1): for j1 in range(1, m + 1): for i2 in range(i1, n + 1): for j2 in range(j1, m + 1): # Calculate sum of submatrix from (i1, j1) to (i2, j2) submatrix_sum = (prefix_sum[i2][j2] - prefix_sum[i1-1][j2] - prefix_sum[i2][j1-1] + prefix_sum[i1-1][j1-1]) max_sum = max(max_sum, submatrix_sum) return max_sum"},{"question":"def rank_coders(n: int, scores: List[int]) -> List[int]: Ranks the coders based on their scores. In case of a tie, the coder with the smaller number is ranked higher. Parameters: n (int): Number of coders. scores (list of int): List containing the scores of the coders. Returns: list of int: List containing the coder numbers in the order they should be ranked. >>> rank_coders(5, [100, 90, 100, 80, 90]) [1, 3, 2, 5, 4] >>> rank_coders(3, [50, 50, 50]) [1, 2, 3] >>> rank_coders(4, [20, 30, 50, 10]) [3, 2, 1, 4] >>> rank_coders(6, [90, 80, 90, 100, 80, 100]) [4, 6, 1, 3, 2, 5] >>> rank_coders(5, [40, 40, 40, 40, 40]) [1, 2, 3, 4, 5]","solution":"def rank_coders(n, scores): Ranks the coders based on their scores. In case of a tie, the coder with the smaller number is ranked higher. Parameters: n (int): Number of coders. scores (list of int): List containing the scores of the coders. Returns: list of int: List containing the coder numbers in the order they should be ranked. coders = [(i + 1, scores[i]) for i in range(n)] coders.sort(key=lambda x: (-x[1], x[0])) return [coder[0] for coder in coders]"},{"question":"def numberOfSteps(num: int) -> int: Returns the number of steps to reduce the given integer num to zero. If the number is even, it is divided by 2. If the number is odd, 1 is subtracted from it. Examples: >>> numberOfSteps(14) 6 >>> numberOfSteps(8) 4 >>> numberOfSteps(123) 12 from solution import numberOfSteps def test_numberOfSteps_example1(): assert numberOfSteps(14) == 6 def test_numberOfSteps_example2(): assert numberOfSteps(8) == 4 def test_numberOfSteps_example3(): assert numberOfSteps(123) == 12 def test_numberOfSteps_zero(): assert numberOfSteps(0) == 0 def test_numberOfSteps_one(): assert numberOfSteps(1) == 1 def test_numberOfSteps_large_number(): assert numberOfSteps(1000000) == 26","solution":"def numberOfSteps(num: int) -> int: Returns the number of steps to reduce the given integer num to zero. If the number is even, it is divided by 2. If the number is odd, 1 is subtracted from it. steps = 0 while num > 0: if num % 2 == 0: num //= 2 else: num -= 1 steps += 1 return steps"},{"question":"def max_non_overlapping_deliveries(n, deliveries): Given a list of deliveries with start and end times, determines the maximum number of non-overlapping deliveries. Parameters: n (int): Number of deliveries. deliveries (List[Tuple[int, int]]): List of tuples where each tuple contains the start and end time of a delivery. Returns: int: Maximum number of non-overlapping deliveries. >>> max_non_overlapping_deliveries(4, [(1, 3), (2, 5), (4, 6), (6, 7)]) 3 >>> max_non_overlapping_deliveries(3, [(5, 10), (1, 4), (6, 8)]) 2 from solution import max_non_overlapping_deliveries def test_example_1(): assert max_non_overlapping_deliveries(4, [(1, 3), (2, 5), (4, 6), (6, 7)]) == 3 def test_example_2(): assert max_non_overlapping_deliveries(3, [(5, 10), (1, 4), (6, 8)]) == 2 def test_single_delivery(): assert max_non_overlapping_deliveries(1, [(1, 2)]) == 1 def test_non_overlapping_deliveries(): assert max_non_overlapping_deliveries(4, [(1, 2), (2, 3), (3, 4), (4, 5)]) == 4 def test_all_overlapping_deliveries(): assert max_non_overlapping_deliveries(3, [(1, 5), (2, 6), (3, 7)]) == 1 def test_some_overlapping_deliveries(): assert max_non_overlapping_deliveries(5, [(1, 4), (2, 3), (3, 5), (4, 6), (5, 7)]) == 3 def test_large_input(): deliveries = [(i, i+2) for i in range(0, 200000, 2)] assert max_non_overlapping_deliveries(len(deliveries), deliveries) == 100000","solution":"def max_non_overlapping_deliveries(n, deliveries): deliveries.sort(key=lambda x: x[1]) count = 0 last_end_time = 0 for start, end in deliveries: if start >= last_end_time: count += 1 last_end_time = end return count # Reading input if __name__ == \\"__main__\\": import sys input = sys.stdin.read data = input().split() n = int(data[0]) deliveries = [(int(data[i*2+1]), int(data[i*2+2])) for i in range(n)] print(max_non_overlapping_deliveries(n, deliveries))"},{"question":"def find_premium_gadgets(gadgets: List[Tuple[str, int]]) -> List[str]: Returns a list of names of premium gadgets costing more than 300. If no gadgets are premium, returns [\\"NO PREMIUM GADGETS\\"]. >>> find_premium_gadgets([(\\"Smartphone-X\\", 320), (\\"LaptopPro\\", 450), (\\"Earbuds\\", 200), (\\"SmartWatch\\", 280), (\\"Camera-HD\\", 700)]) [\\"Smartphone-X\\", \\"LaptopPro\\", \\"Camera-HD\\"] >>> find_premium_gadgets([(\\"USB-Cable\\", 10), (\\"Mousepad\\", 20), (\\"Battery\\", 100), (\\"Notebook\\", 150)]) [\\"NO PREMIUM GADGETS\\"] >>> find_premium_gadgets([(\\"Gadget300\\", 300), (\\"Gadget301\\", 301)]) [\\"Gadget301\\"]","solution":"def find_premium_gadgets(gadgets): Returns a list of names of premium gadgets costing more than 300. If no gadgets are premium, returns [\\"NO PREMIUM GADGETS\\"]. premium_gadgets = [name for name, price in gadgets if price > 300] return premium_gadgets if premium_gadgets else [\\"NO PREMIUM GADGETS\\"] # Example usage # n = int(input()) # gadgets = [input().split(maxsplit=1) for _ in range(n)] # gadgets = [(name, int(price)) for name, price in gadgets] # result = find_premium_gadgets(gadgets) # This should be your list of premium gadgets names # for gadget in result: # print(gadget)"},{"question":"def process_instructions(instructions: List[str]) -> List[str]: Simulate a sequence of instructions and print the list state after each \\"PRINT\\" command. >>> process_instructions([\\"ADD 5\\", \\"ADD 3\\", \\"PRINT\\", \\"REMOVE\\", \\"PRINT\\", \\"ADD 10\\", \\"PRINT\\", \\"REMOVE\\", \\"REMOVE\\", \\"PRINT\\"]) [\\"5 3\\", \\"5\\", \\"5 10\\", \\"EMPTY\\"] >>> process_instructions([\\"PRINT\\", \\"REMOVE\\", \\"PRINT\\"]) [\\"EMPTY\\", \\"EMPTY\\"] >>> process_instructions([\\"ADD 1\\", \\"ADD 2\\", \\"REMOVE\\"]) [] >>> process_instructions([\\"ADD 1\\", \\"ADD 2\\", \\"ADD 3\\", \\"PRINT\\"]) [\\"1 2 3\\"] >>> process_instructions([\\"ADD 10\\", \\"ADD 20\\", \\"REMOVE\\", \\"ADD 30\\", \\"PRINT\\", \\"REMOVE\\", \\"REMOVE\\", \\"PRINT\\"]) [\\"10 30\\", \\"EMPTY\\"]","solution":"def process_instructions(instructions): result = [] lst = [] for instruction in instructions: parts = instruction.split() command = parts[0] if command == \\"ADD\\": lst.append(int(parts[1])) elif command == \\"REMOVE\\": if lst: lst.pop() elif command == \\"PRINT\\": if lst: result.append(\\" \\".join(map(str, lst))) else: result.append(\\"EMPTY\\") return result"},{"question":"def has_pair_with_sum(nums: List[int], target: int) -> str: Returns \\"YES\\" if there is a pair of distinct indices i and j such that the sum of elements at these indices equals target. Otherwise, returns \\"NO\\". Examples: >>> has_pair_with_sum([2, 7, 11, 15, 1], 9) 'YES' >>> has_pair_with_sum([1, 2, 3, 4], 8) 'NO'","solution":"def has_pair_with_sum(nums, target): Returns \\"YES\\" if there is a pair of distinct indices i and j such that the sum of elements at these indices equals target. Otherwise, returns \\"NO\\". seen = set() for num in nums: if target - num in seen: return \\"YES\\" seen.add(num) return \\"NO\\" # Example usage: # n, k = 5, 9 # nums = [2, 7, 11, 15, 1] # print(has_pair_with_sum(nums, k)) # Output: \\"YES\\""},{"question":"def polygon_area(vertices): Calculate the area of a convex polygon using the Shoelace formula. Parameters: vertices (list of tuples): A list of (x, y) coordinates of the polygon vertices. Returns: int: The area of the polygon, rounded to the nearest integer. pass # Unit tests def test_example1(): vertices = [(0, 0), (0, 4), (4, 4), (4, 0)] assert polygon_area(vertices) == 16 def test_example2(): vertices = [(0, 0), (2, 0), (1, 2)] assert polygon_area(vertices) == 2 def test_triangle(): vertices = [(0, 0), (5, 0), (2, 2)] assert polygon_area(vertices) == 5 def test_square(): vertices = [(1, 1), (1, 4), (4, 4), (4, 1)] assert polygon_area(vertices) == 9 def test_complex_polygon(): vertices = [(0, 0), (0, 3), (3, 3), (3, 0), (2, 1)] assert polygon_area(vertices) == 8 def test_large_coordinates(): vertices = [(10000, 10000), (10000, -10000), (-10000, -10000), (-10000, 10000)] assert polygon_area(vertices) == 400000000","solution":"def polygon_area(vertices): Calculate the area of a convex polygon using the Shoelace formula. Parameters: vertices (list of tuples): A list of (x, y) coordinates of the polygon vertices. Returns: int: The area of the polygon, rounded to the nearest integer. n = len(vertices) area = 0 for i in range(n): x1, y1 = vertices[i] x2, y2 = vertices[(i + 1) % n] area += x1 * y2 - y1 * x2 return round(abs(area) / 2) # To use this function: # vertices = [(0, 0), (0, 4), (4, 4), (4, 0)] # print(polygon_area(vertices)) # Output: 16"},{"question":"def handle_matrix_queries(matrix, queries): Handles the matrix manipulations and queries as specified. Parameters: - matrix: Initial N x M matrix as a list of lists. - queries: A list of queries, where each query is a tuple (x, y, z). Returns: - A list of results for the sum queries. Examples: >>> matrix = [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ] >>> queries = [ ... (1, 2, 5), # Set matrix[0][1] to 5 -> matrix becomes [[1, 5, 3], [4, 5, 6], [7, 8, 9]] ... (2, -1, -1), # Sum of row 2 -> 4 + 5 + 6 = 15 ... (3, 3, 2), # Set matrix[2][2] to 2 -> matrix becomes [[1, 5, 3], [4, 5, 6], [7, 8, 2]] ... (-1, 3, -1), # Sum of column 3 -> 3 + 6 + 2 = 11 ... (2, 2, 1) # Set matrix[1][1] to 1 -> matrix becomes [[1, 5, 3], [4, 1, 6], [7, 8, 2]] ... ] >>> expected_results = [15, 11] >>> handle_matrix_queries(matrix, queries) [15, 11]","solution":"def handle_matrix_queries(matrix, queries): Handles the matrix manipulations and queries as specified. Parameters: - matrix: Initial N x M matrix as a list of lists. - queries: A list of queries, where each query is a tuple (x, y, z). Returns: - A list of results for the sum queries. results = [] for x, y, z in queries: if z != -1: # Set the value of the element at row (x-1) and column (y-1) of the matrix to z matrix[x-1][y-1] = z elif x == -1: # Retrieve and report the sum of the elements in column (y-1) col_sum = sum(row[y-1] for row in matrix) results.append(col_sum) elif y == -1: # Retrieve and report the sum of the elements in row (x-1) row_sum = sum(matrix[x-1]) results.append(row_sum) return results"},{"question":"def longest_subsequence_length(k: int, s: str) -> int: Find the length of the longest possible subsequence of S where all characters repeat at least k times. Args: k (int): The minimum number of repetitions for each character in the subsequence. s (str): The original string. Returns: int: The length of the longest possible subsequence that meets all the requirements. If there's no valid subsequence, return 0. >>> longest_subsequence_length(3, \\"abacabadabacaba\\") 12 >>> longest_subsequence_length(2, \\"abcd\\") 0","solution":"def longest_subsequence_length(k, s): from collections import Counter # Count frequency of each character freq = Counter(s) # Filter out those characters which appear at least 'k' times valid_chars = {char for char, count in freq.items() if count >= k} if not valid_chars: return 0 # Accumulate the character from the original string filtered by valid_chars result = [] for char in s: if char in valid_chars: result.append(char) return len(result)"},{"question":"def maximum_roads_to_remove(T: int, test_cases: List[Tuple[int, int, List[Tuple[int, int]]]]) -> List[int]: Returns the maximum number of roads that can be removed while keeping the village still connected. >>> maximum_roads_to_remove(2, [(4, 4, [(1, 2), (2, 3), (3, 4), (4, 1)]), (5, 6, [(1, 2), (1, 3), (3, 4), (4, 5), (2, 5)])]) [1, 2] >>> maximum_roads_to_remove(1, [(3, 3, [(1, 2), (2, 3), (1, 3)])]) [1] >>> maximum_roads_to_remove(1, [(5, 4, [(1, 2), (2, 3), (3, 4), (4, 5)])]) [0] >>> maximum_roads_to_remove(1, [(6, 10, [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (1, 3), (3, 5), (2, 4), (4, 6), (1, 5)])]) [5] >>> maximum_roads_to_remove(1, [(2, 1, [(1, 2)])]) [0] >>> maximum_roads_to_remove(1, [(6, 5, [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6)])]) [0]","solution":"def maximum_roads_to_remove(T, test_cases): Returns the maximum number of roads that can be removed while keeping the village still connected. results = [] for n, m, roads in test_cases: # For a connected graph with n nodes, the minimum number of edges required to keep it connected is n-1. min_edges_needed = n - 1 # The maximum number of roads that can be removed while still keeping the graph connected is m - min_edges_needed max_roads_removable = m - min_edges_needed results.append(max_roads_removable) return results"},{"question":"def has_pair_with_sum(arr, k): Returns \\"YES\\" if there exists a pair of elements in the array whose sum is exactly k, otherwise returns \\"NO\\". >>> has_pair_with_sum([2, 7, 11, 15, 3], 9) \\"YES\\" >>> has_pair_with_sum([1, 2, 3, 4, 5], 8) \\"YES\\" >>> has_pair_with_sum([2, 7, 11, 15, 3], 20) \\"NO\\" >>> has_pair_with_sum([], 5) \\"NO\\" >>> has_pair_with_sum([5, 5], 10) \\"YES\\" >>> has_pair_with_sum([1, -1, 2, -2, 3, -3], 0) \\"YES\\"","solution":"def has_pair_with_sum(arr, k): Returns \\"YES\\" if there exists a pair of elements in the array whose sum is exactly k, otherwise returns \\"NO\\". seen = set() for num in arr: if k - num in seen: return \\"YES\\" seen.add(num) return \\"NO\\""},{"question":"from collections import deque def min_moves_to_clean_warehouse(m, n, grid): Returns the minimum number of moves required to clean all empty cells in the warehouse grid. If it is not possible, returns -1. >>> min_moves_to_clean_warehouse(3, 3, [ ... [0, 0, 0], ... [0, -1, 0], ... [0, 0, 0] ... ]) 4 >>> min_moves_to_clean_warehouse(3, 3, [ ... [0, -1, 0], ... [-1, -1, 0], ... [0, 0, 0] ... ]) -1 >>> min_moves_to_clean_warehouse(2, 2, [ ... [0, 0], ... [0, 0] ... ]) 2 >>> min_moves_to_clean_warehouse(1, 1, [ ... [-1] ... ]) -1 >>> min_moves_to_clean_warehouse(1, 1, [ ... [0] ... ]) 0 >>> min_moves_to_clean_warehouse(5, 5, [ ... [0, 0, 0, 0, 0], ... [0, -1, 0, -1, 0], ... [0, 0, 0, 0, 0], ... [0, -1, 0, -1, 0], ... [0, 0, 0, 0, 0] ... ]) 8 >>> min_moves_to_clean_warehouse(3, 3, [ ... [0, 0, 0], ... [0, -1, -1], ... [0, 0, 0] ... ]) 4","solution":"from collections import deque def min_moves_to_clean_warehouse(m, n, grid): Returns the minimum number of moves required to clean all empty cells in the warehouse grid. If it is not possible, returns -1. def bfs(start): queue = deque([start]) visited = set([start]) distance = 0 move_direction = [(0, 1), (1, 0), (0, -1), (-1, 0)] moves = 0 while queue: for _ in range(len(queue)): x, y = queue.popleft() if grid[x][y] == 0: grid[x][y] = 1 # Mark this cell as cleaned moves += 1 for dx, dy in move_direction: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and (nx, ny) not in visited and grid[nx][ny] == 0: queue.append((nx, ny)) visited.add((nx, ny)) distance += 1 return moves, distance - 1 total_empty_cells = sum(row.count(0) for row in grid) if total_empty_cells == 0: return -1 min_moves = float('inf') for i in range(m): for j in range(n): if grid[i][j] == 0: grid_copy = [row[:] for row in grid] cleaned_cells, moves = bfs((i, j)) if cleaned_cells == total_empty_cells: min_moves = min(min_moves, moves) return min_moves if min_moves != float('inf') else -1 # Example usage # m = 3 # n = 3 # grid = [ # [0, 0, 0], # [0, -1, 0], # [0, 0, 0] # ] # print(min_moves_to_clean_warehouse(m, n, grid)) # Output: 4"},{"question":"def max_coins(M: int, N: int, grid: List[List[int]]) -> int: Returns the maximum number of coins Kamya can collect by moving only right or down from top-left to bottom-right. Parameters: M (int): Number of rows in the grid N (int): Number of columns in the grid grid (List[List[int]]): 2D list representing the grid with coins Returns: int: The maximum number of coins that can be collected >>> max_coins(3, 4, [[0, 3, 1, 1], [2, 0, 0, 4], [1, 5, 3, 1]]) 12 >>> max_coins(2, 2, [[1, 2], [1, 3]]) 6 pass","solution":"def max_coins(M, N, grid): Returns the maximum number of coins Kamya can collect by moving only right or down from top-left to bottom-right. # Initialize a DP table with the same dimensions as the grid dp = [[0] * N for _ in range(M)] # Set the initial cell dp[0][0] = grid[0][0] # Fill the first row (can only come from the left) for j in range(1, N): dp[0][j] = dp[0][j - 1] + grid[0][j] # Fill the first column (can only come from the above) for i in range(1, M): dp[i][0] = dp[i - 1][0] + grid[i][0] # Fill the rest of the dp table for i in range(1, M): for j in range(1, N): dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + grid[i][j] # The bottom-right cell contains the max number of coins collected return dp[M - 1][N - 1]"},{"question":"def most_frequent_vehicle(sequence: str) -> str: Determine which type of vehicle is the most frequent in the sequence. >>> most_frequent_vehicle('STMVVSSMMTT') 'S' >>> most_frequent_vehicle('MMMSSVVVTT') 'M'","solution":"def most_frequent_vehicle(sequence: str) -> str: from collections import Counter # Use Counter to count the frequency of each type of vehicle vehicle_counts = Counter(sequence) # Create a sorted list of (vehicle, count) tuples based on counts (descending) and appearance order sorted_vehicles = sorted(vehicle_counts, key=lambda x: (-vehicle_counts[x], sequence.index(x))) # The first element in the sorted list is the most frequent vehicle return sorted_vehicles[0]"},{"question":"def factorial(n): Computes the factorial of a given non-negative integer n. >>> factorial(0) 1 >>> factorial(1) 1 >>> factorial(5) 120 >>> factorial(12) 479001600","solution":"def factorial(n): Computes the factorial of a given non-negative integer n. if n < 0: raise ValueError(\\"Input must be a non-negative integer.\\") if n == 0: return 1 result = 1 for i in range(1, n + 1): result *= i return result"},{"question":"def line_segments_intersect(x1, y1, x2, y2, x3, y3, x4, y4): Determine if two line segments intersect, and if they do, find the point of intersection. >>> line_segments_intersect(0, 0, 1, 1, 1, 2, 2, 3) 'No intersection' >>> line_segments_intersect(0, 0, 1, 1, 1, 0, 0, 1) 'Intersection at (0.5, 0.5)' >>> line_segments_intersect(0, 0, 2, 2, 1, 1, 3, 3) 'Segments overlap' >>> line_segments_intersect(0, 0, 2, 2, 3, 3, 4, 4) 'No intersection' >>> line_segments_intersect(0, 0, 1, 1, 2, 2, 3, 3) 'No intersection'","solution":"def line_segments_intersect(x1, y1, x2, y2, x3, y3, x4, y4): def orientation(px, py, qx, qy, rx, ry): val = (qy - py) * (rx - qx) - (qx - px) * (ry - qy) if val == 0: return 0 return 1 if val > 0 else -1 def on_segment(px, py, qx, qy, rx, ry): if min(px, qx) <= rx <= max(px, qx) and min(py, qy) <= ry <= max(py, qy): return True return False o1 = orientation(x1, y1, x2, y2, x3, y3) o2 = orientation(x1, y1, x2, y2, x4, y4) o3 = orientation(x3, y3, x4, y4, x1, y1) o4 = orientation(x3, y3, x4, y4, x2, y2) if o1 != o2 and o3 != o4: a1 = y2 - y1 b1 = x1 - x2 c1 = a1 * x1 + b1 * y1 a2 = y4 - y3 b2 = x3 - x4 c2 = a2 * x3 + b2 * y3 det = a1 * b2 - a2 * b1 if det == 0: return \\"Segments overlap\\" intersect_x = (b2 * c1 - b1 * c2) / det intersect_y = (a1 * c2 - a2 * c1) / det return f\\"Intersection at ({intersect_x:.1f}, {intersect_y:.1f})\\" if (o1 == 0 and on_segment(x1, y1, x2, y2, x3, y3)) or (o2 == 0 and on_segment(x1, y1, x2, y2, x4, y4)) or (o3 == 0 and on_segment(x3, y3, x4, y4, x1, y1)) or (o4 == 0 and on_segment(x3, y3, x4, y4, x2, y2)): return \\"Segments overlap\\" return \\"No intersection\\""},{"question":"import math from typing import List def unique_paths(R: int, C: int) -> int: Function to calculate the number of unique paths from top-left to bottom-right in a grid with R rows and C columns. Args: R (int): Number of rows in the grid. C (int): Number of columns in the grid. Returns: int: Number of unique paths from top-left to bottom-right. >>> unique_paths(2, 2) 2 >>> unique_paths(3, 2) 3 >>> unique_paths(3, 3) 6 pass def process_input_cases(input_string: str) -> List[int]: Process the input string and extract the number of test cases and each test case. Args: input_string (str): Input string containing number of test cases and grid dimensions. Returns: List[int]: List of results for each test case. Example: >>> process_input_cases(\\"3n2 2n3 2n3 3\\") [2, 3, 6] pass","solution":"import math def unique_paths(R, C): Function to calculate the number of unique paths from top-left to bottom-right in a grid with R rows and C columns. # Use combination formula (R + C - 2) choose (R - 1) return math.comb(R + C - 2, R - 1) def process_input_cases(input_string): Process the input string and extracts the number of test cases and each test case. lines = input_string.strip().split('n') T = int(lines[0]) results = [] for i in range(1, T + 1): R, C = map(int, lines[i].split()) results.append(unique_paths(R, C)) return results"},{"question":"def max_profit(n: int, apple_prices: List[int], orange_prices: List[int]) -> int: Determine the maximum possible profit the fruit seller can make over n days by choosing to sell either apples or oranges each day. :param n: Number of days. :param apple_prices: List of integers where the i-th integer represents the price of apples on the i-th day. :param orange_prices: List of integers where the i-th integer represents the price of oranges on the i-th day. :return: Maximum possible profit. >>> max_profit(5, [5, 3, 6, 7, 8], [1, 6, 5, 3, 9]) 33 >>> max_profit(3, [3, 4, 5], [1, 2, 3]) 12 >>> max_profit(3, [1, 2, 3], [3, 4, 5]) 12 >>> max_profit(4, [1, 10, 3, 8], [7, 2, 12, 5]) 37 >>> max_profit(1, [4], [5]) 5","solution":"def max_profit(n, apple_prices, orange_prices): Returns the maximum profit the fruit seller can make over n days by choosing to sell either apples or oranges each day. :param n: Number of days :param apple_prices: A list of integers representing the prices of apples on each day :param orange_prices: A list of integers representing the prices of oranges on each day :return: Maximum possible profit profit = 0 for i in range(n): profit += max(apple_prices[i], orange_prices[i]) return profit"},{"question":"def check_median_age(n: int, ages: List[int], k: int) -> str: Returns \\"YES\\" if the median age of the group is greater than or equal to k, otherwise \\"NO\\". >>> check_median_age(5, [20, 25, 30, 35, 40], 30) \\"YES\\" >>> check_median_age(4, [10, 20, 30, 40], 25) \\"NO\\"","solution":"def check_median_age(n, ages, k): Returns \\"YES\\" if the median age of the group is greater than or equal to k, otherwise \\"NO\\". ages.sort() if n % 2 == 1: median = ages[n // 2] else: median = (ages[n // 2 - 1] + ages[n // 2]) / 2 if median >= k: return \\"YES\\" else: return \\"NO\\""},{"question":"def max_adjacent_diff_color_pairs(n: int, flower_colors: List[int]) -> int: Determine the maximum number of adjacent pairs of flowers with different colors when arranged optimally. Args: n (int): The number of flowers. flower_colors (List[int]): The colors of the flowers. Returns: int: The maximum number of adjacent pairs of flowers with different colors. Examples: >>> max_adjacent_diff_color_pairs(5, [1, 2, 3, 4, 5]) 4 >>> max_adjacent_diff_color_pairs(4, [1, 1, 1, 1]) 0 >>> max_adjacent_diff_color_pairs(3, [4, 4, 6]) 1 >>> max_adjacent_diff_color_pairs(6, [3, 3, 3, 4, 5, 5]) 3 from typing import List def test_max_adjacent_diff_color_pairs(): assert max_adjacent_diff_color_pairs(1, [1]) == 0 assert max_adjacent_diff_color_pairs(4, [1, 1, 1, 1]) == 0 assert max_adjacent_diff_color_pairs(5, [1, 2, 3, 4, 5]) == 4 assert max_adjacent_diff_color_pairs(6, [3, 3, 3, 4, 5, 5]) == 3 assert max_adjacent_diff_color_pairs(3, [4, 4, 6]) == 1 assert max_adjacent_diff_color_pairs(5, [1, 2, 1, 2, 1]) == 4","solution":"def max_adjacent_diff_color_pairs(n, flower_colors): if n <= 1: return 0 # If all flowers have the same color, there will be no pair of different colors. if len(set(flower_colors)) == 1: return 0 # The maximum number of adjacent pairs with different colors is always n-1 # if there is at least one different colored flower. return n - 1"},{"question":"def is_prime(n: int) -> str: Determines if n is a prime number. If n is a prime number, return \\"Prime\\". Otherwise, return \\"Not Prime\\". >>> is_prime(29) == \\"Prime\\" >>> is_prime(97) == \\"Prime\\" >>> is_prime(2) == \\"Prime\\" >>> is_prime(100) == \\"Not Prime\\" >>> is_prime(1) == \\"Not Prime\\" >>> is_prime(4) == \\"Not Prime\\" >>> is_prime(9) == \\"Not Prime\\" >>> is_prime(10**6) == \\"Not Prime\\" # 10^6 is not a prime number >>> is_prime(10**6 - 1) == \\"Not Prime\\" # 10^6 - 1 is not a prime number >>> is_prime(10**6 + 1) == \\"Not Prime\\" # 10^6 + 1 is not a prime number","solution":"def is_prime(n): Determines if n is a prime number. If n is a prime number, return \\"Prime\\". Otherwise, return \\"Not Prime\\". if n <= 1: return \\"Not Prime\\" if n == 2: return \\"Prime\\" if n % 2 == 0: return \\"Not Prime\\" limit = int(n**0.5) + 1 for i in range(3, limit, 2): if n % i == 0: return \\"Not Prime\\" return \\"Prime\\""},{"question":"def minimum_reading_time(n: int, m: int, books: list) -> int: Returns the minimum total reading time to read one book from each category. Parameters: n (int): Number of books. m (int): Number of categories. books (list of tuples): Each tuple contains two integers t_i (reading time) and c_i (category). Returns: int: Minimum total reading time. pass # Unit tests def test_minimum_reading_time_example1(): books = [(10, 1), (5, 1), (7, 2), (4, 2), (3, 3), (2, 3)] assert minimum_reading_time(6, 3, books) == 11 def test_minimum_reading_time_example2(): books = [(8, 1), (3, 1), (6, 2), (9, 2), (1, 2)] assert minimum_reading_time(5, 2, books) == 4 def test_minimum_reading_time_single_category(): books = [(5, 1), (3, 1), (7, 1)] assert minimum_reading_time(3, 1, books) == 3 def test_minimum_reading_time_large_case(): books = [(i, (i % 1000) + 1) for i in range(1, 1001)] assert minimum_reading_time(1000, 1000, books) == sum(range(1, 1001)) def test_minimum_reading_time_edge_case_min_values(): books = [(1, 1)] assert minimum_reading_time(1, 1, books) == 1 def test_minimum_reading_time_same_category_multiple_times(): books = [(7, 1), (1, 1), (9, 1)] assert minimum_reading_time(3, 1, books) == 1","solution":"def minimum_reading_time(n, m, books): Returns the minimum total reading time to read one book from each category. Parameters: n (int): Number of books. m (int): Number of categories. books (list of tuples): Each tuple contains two integers t_i (reading time) and c_i (category). Returns: int: Minimum total reading time. from collections import defaultdict import sys # Dictionary to store the minimum reading time for each category category_min_time = defaultdict(lambda: sys.maxsize) # Iterate over each book for t_i, c_i in books: # Update the minimum reading time for the book's category if smaller time is found if t_i < category_min_time[c_i]: category_min_time[c_i] = t_i # Calculate total minimum reading time by summing minimum times of each category total_min_time = sum(category_min_time[cat] for cat in range(1, m + 1)) return total_min_time # Example usage: if __name__ == \\"__main__\\": n = 6 m = 3 books = [(10, 1), (5, 1), (7, 2), (4, 2), (3, 3), (2, 3)] print(minimum_reading_time(n, m, books)) # Output: 11"},{"question":"def minimum_sum_value(n: int, sequence: List[int]) -> int: Alyssa loves to play with sequences of numbers. One day, she came up with a new game. She selects a sequence of n positive integers and gives you a series of operations to perform. The operation allowed is to select any two adjacent integers in the sequence and replace them with their sum. Your task is to determine the minimum possible value for the sequence after exactly (n - 1) operations. Each operation reduces the length of the sequence by 1, and after (n - 1) operations, only one integer will remain in the sequence. Args: n : int : the number of integers in the sequence sequence : list of int : list of n positive integers Returns: int : the minimum possible value after exactly (n - 1) operations Examples: >>> minimum_sum_value(3, [1, 2, 3]) 6 >>> minimum_sum_value(4, [10, 2, 5, 7]) 24 >>> minimum_sum_value(2, [100, 1]) 101","solution":"def minimum_sum_value(n, sequence): Given a sequence of n positive integers and a series of operations, this function calculates the minimum possible value after exactly (n - 1) operations, where in each operation two adjacent integers in the sequence are replaced by their sum. Args: n : int : number of integers in the sequence sequence : list of int : list of n positive integers Returns: int : the minimum possible value after (n - 1) operations if n == 1: return sequence[0] return sum(sequence)"},{"question":"from typing import List def shortest_path_in_grid(n: int, m: int, sx: int, sy: int, tx: int, ty: int, grid: List[str]) -> int: Find the shortest path from the start position (sx, sy) to the target position (tx, ty) in the given grid. :param n: The number of rows in the grid. :param m: The number of columns in the grid. :param sx: The starting row position. :param sy: The starting column position. :param tx: The target row position. :param ty: The target column position. :param grid: A list of strings representing the grid where '.' indicates an empty cell and '*' indicates a cell with a star. :returns: The minimum number of steps to reach the target position from the starting position, or -1 if it's not possible. >>> shortest_path_in_grid(5, 5, 0, 0, 4, 4, ['.....', '.***.', '.....', '.***.', '.....']) 8 >>> shortest_path_in_grid(3, 3, 0, 0, 2, 2, ['.**', '.**', '...']) 4 >>> shortest_path_in_grid(3, 3, 0, 0, 2, 2, ['.*.', '.*.', '***']) -1 >>> shortest_path_in_grid(1, 1, 0, 0, 0, 0, ['.']) 0 >>> shortest_path_in_grid(2, 2, 0, 0, 1, 1, ['.*', '..']) 2 >>> shortest_path_in_grid(5, 5, 0, 0, 4, 4, ['.*...', '.*...', '.*...', '.*...', '.....']) 8 >>> shortest_path_in_grid(4, 4, 0, 0, 3, 3, ['....', '....', '....', '....']) 6","solution":"from collections import deque def shortest_path_in_grid(n, m, sx, sy, tx, ty, grid): def is_valid(x, y): return 0 <= x < n and 0 <= y < m and grid[x][y] == '.' directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] queue = deque([(sx, sy, 0)]) # (x, y, steps) visited = set((sx, sy)) while queue: x, y, steps = queue.popleft() if (x, y) == (tx, ty): return steps for dx, dy in directions: nx, ny = x + dx, y + dy if is_valid(nx, ny) and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny, steps + 1)) return -1"},{"question":"def get_minimum_sensors(n: int, m: int, grid: List[str]) -> int: Determine the minimum number of 1x1 sensors required to cover all cells marked with 'C' in the grid. A sensor can cover the cells in any of the eight possible directions (horizontally, vertically, and diagonally) unless it encounters a blocked cell 'B'. The sensors can be placed on any empty cell (i.e., cells marked with '.') or cells already marked with 'C'. Args: n (int): The number of rows in the grid. m (int): The number of columns in the grid. grid (List[str]): The grid represented as a list of strings. Returns: int: The minimum number of sensors required to cover all cells marked with 'C'. Example: >>> get_minimum_sensors(4, 4, [\\".C..\\", \\".B..\\", \\"..C.\\", \\"....\\"]) 2 >>> get_minimum_sensors(5, 5, [\\".....\\", \\"..B..\\", \\".C...\\", \\".....\\", \\"..C..\\"]) 2 pass from solution import get_minimum_sensors def test_example1(): grid = [ \\".C..\\", \\".B..\\", \\"..C.\\", \\"....\\" ] assert get_minimum_sensors(4, 4, grid) == 2 def test_example2(): grid = [ \\".....\\", \\"..B..\\", \\".C...\\", \\".....\\", \\"..C..\\" ] assert get_minimum_sensors(5, 5, grid) == 2 def test_single_C(): grid = [ \\".....\\", \\"..C..\\", \\".....\\", \\".....\\", \\".....\\" ] assert get_minimum_sensors(5, 5, grid) == 1 def test_no_C(): grid = [ \\".....\\", \\".....\\", \\".....\\", \\".....\\", \\".....\\" ] assert get_minimum_sensors(5, 5, grid) == 0 def test_blocked_C(): grid = [ \\".....\\", \\".B.C.\\", \\".B.B.\\", \\".....\\", \\".....\\" ] assert get_minimum_sensors(5, 5, grid) == 1","solution":"def get_minimum_sensors(n, m, grid): def is_valid(x, y): return 0 <= x < n and 0 <= y < m def can_cover(x, y): directions = [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)] for dx, dy in directions: nx, ny = x + dx, y + dy if is_valid(nx, ny) and grid[nx][ny] == 'C': return True return False covered = set() sensors = 0 for i in range(n): for j in range(m): if grid[i][j] == 'C' and (i, j) not in covered: placed = False for dx in range(-1, 2): for dy in range(-1, 2): ni, nj = i + dx, j + dy if is_valid(ni, nj) and grid[ni][nj] != 'B' and (ni, nj) not in covered: if can_cover(ni, nj): sensors += 1 for ddx in range(-1, 2): for ddy in range(-1, 2): ci, cj = ni + ddx, nj + ddy if is_valid(ci, cj) and grid[ci][cj] == 'C': covered.add((ci, cj)) placed = True break if placed: break return sensors"},{"question":"def process_tasks(test_cases): Process the tasks based on their priority and order of appearance. Args: - test_cases (List[Tuple[int, List[Tuple[str, int]]]]): A list of test cases, where each test case is a tuple containing the number of tasks and a list of tuples with task names and priorities. Returns: - List[str]: A list of task names in the order they should be processed. >>> input_string = \\"2n3ntask1 2ntask2 1ntask3 3n4ntaskA 1ntaskB 2ntaskC 1ntaskD 3\\" >>> test_cases = parse_input(input_string) >>> result = process_tasks(test_cases) >>> format_output(result) 'task2ntask1ntask3ntaskAntaskCntaskBntaskD' >>> input_string = \\"1n3ntask1 1ntask2 1ntask3 1\\" >>> test_cases = parse_input(input_string) >>> result = process_tasks(test_cases) >>> format_output(result) 'task1ntask2ntask3' >>> input_string = \\"1n1ntask1 1\\" >>> test_cases = parse_input(input_string) >>> result = process_tasks(test_cases) >>> format_output(result) 'task1' >>> input_string = \\"1n3ntask1 3ntask2 2ntask3 1\\" >>> test_cases = parse_input(input_string) >>> result = process_tasks(test_cases) >>> format_output(result) 'task3ntask2ntask1' # Implementation here def parse_input(input_string): Parse the input string and return the test cases. Args: - input_string (str): The input string containing the test cases. Returns: - List[Tuple[int, List[Tuple[str, int]]]]: A list of test cases. # Implementation here def format_output(output): Format the output list to a single string with task names separated by new lines. Args: - output (List[str]): The list of task names to format. Returns: - str: The formatted string. # Implementation here","solution":"def process_tasks(test_cases): def get_sorted_tasks(tasks): # Sort primarily by priority, and secondarily by the order they appear return sorted(tasks, key=lambda x: (x[1], x[0])) result = [] for case in test_cases: N, tasks = case sorted_tasks = get_sorted_tasks(tasks) result.extend([task[0] for task in sorted_tasks]) return result def parse_input(input_string): lines = input_string.strip().split('n') T = int(lines[0]) idx = 1 test_cases = [] for _ in range(T): N = int(lines[idx]) tasks = [] idx += 1 for _ in range(N): task_info = lines[idx].split() task_name = task_info[0] priority = int(task_info[1]) tasks.append((task_name, priority)) idx += 1 test_cases.append((N, tasks)) return test_cases def format_output(output): return 'n'.join(output)"},{"question":"def assign_tasks_to_employees(n, m, task_ids, employee_ids): Assigns tasks to employees based on the smallest absolute difference in IDs. In case of tie, assigns to the employee with the smallest ID. :param n: Number of tasks :param m: Number of employees :param task_ids: List of task IDs :param employee_ids: List of employee IDs :return: List of employee IDs to whom the tasks are assigned Examples: >>> assign_tasks_to_employees(5, 3, [10, 20, 30, 40, 50], [15, 25, 35]) [15, 15, 25, 35, 35] >>> assign_tasks_to_employees(4, 4, [1, 2, 3, 4], [10, 20, 30, 40]) [10, 10, 10, 10]","solution":"def assign_tasks_to_employees(n, m, task_ids, employee_ids): Assigns tasks to employees based on the smallest absolute difference in IDs. In case of tie, assigns to the employee with the smallest ID. :param n: Number of tasks :param m: Number of employees :param task_ids: List of task IDs :param employee_ids: List of employee IDs :return: List of employee IDs to whom the tasks are assigned employee_ids.sort() # Sort employee_ids for easier minimum difference calculation result = [] for task_id in task_ids: min_diff = float('inf') assigned_employee_id = None for employee_id in employee_ids: diff = abs(task_id - employee_id) if diff < min_diff or (diff == min_diff and employee_id < assigned_employee_id): min_diff = diff assigned_employee_id = employee_id result.append(assigned_employee_id) return result"},{"question":"def minimal_path_sum(matrix): Returns the minimal path sum from the top-left to the bottom-right of the matrix. >>> minimal_path_sum([ [1, 3, 1], [1, 5, 1], [4, 2, 1] ]) 7 >>> minimal_path_sum([ [1, 2, 5], [3, 2, 1] ]) 6 >>> minimal_path_sum([ [1, 2, 3, 4] ]) 10","solution":"def minimal_path_sum(matrix): Returns the minimal path sum from the top-left to the bottom-right of the matrix. m = len(matrix) n = len(matrix[0]) # Create a 2D dp array same size as matrix dp = [[0] * n for _ in range(m)] # Initialize the top-left corner dp[0][0] = matrix[0][0] # Fill the first row for j in range(1, n): dp[0][j] = dp[0][j - 1] + matrix[0][j] # Fill the first column for i in range(1, m): dp[i][0] = dp[i - 1][0] + matrix[i][0] # Fill the rest of the dp array for i in range(1, m): for j in range(1, n): dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + matrix[i][j] # Return the minimal path sum which is stored at dp[m-1][n-1] return dp[m - 1][n - 1]"},{"question":"def multiplication_table(n: int) -> list: Write a function that takes an integer n and returns a multiplication table of size n x n. The multiplication table should be returned as a list of lists, with each inner list representing a row of the table. Parameters: n (int): The size of the multiplication table (1 ≤ n ≤ 100). Returns: list: A list of lists where the element at the i-th row and j-th column is equal to (i+1) * (j+1). Examples: >>> multiplication_table(3) [[1, 2, 3], [2, 4, 6], [3, 6, 9]] >>> multiplication_table(5) [[1, 2, 3, 4, 5], [2, 4, 6, 8, 10], [3, 6, 9, 12, 15], [4, 8, 12, 16, 20], [5, 10, 15, 20, 25]] from solution import multiplication_table def test_multiplication_table_size_1(): assert multiplication_table(1) == [[1]] def test_multiplication_table_size_3(): expected_output = [ [1, 2, 3], [2, 4, 6], [3, 6, 9] ] assert multiplication_table(3) == expected_output def test_multiplication_table_size_5(): expected_output = [ [1, 2, 3, 4, 5], [2, 4, 6, 8, 10], [3, 6, 9, 12, 15], [4, 8, 12, 16, 20], [5, 10, 15, 20, 25] ] assert multiplication_table(5) == expected_output def test_multiplication_table_size_10(): expected_output = [ [i * j for j in range(1, 11)] for i in range(1, 11) ] assert multiplication_table(10) == expected_output def test_multiplication_table_size_100(): expected_output = [ [i * j for j in range(1, 101)] for i in range(1, 101) ] assert multiplication_table(100) == expected_output","solution":"def multiplication_table(n): Returns a multiplication table of size n x n. table = [] for i in range(1, n+1): row = [] for j in range(1, n+1): row.append(i * j) table.append(row) return table"},{"question":"def min_deletions_to_palindrome(s: str) -> int: Write a function to determine the minimum number of moves required to transform a given string into a palindrome by only deleting characters. A palindrome is a string that reads the same forward and backward. Deleting a character removes it from the string entirely and does not count as a move between characters. Parameters: s (str): The input string Returns: int: The minimum number of deletions Examples: >>> min_deletions_to_palindrome(\\"ab\\") 1 >>> min_deletions_to_palindrome(\\"aab\\") 1 >>> min_deletions_to_palindrome(\\"abca\\") 1 >>> min_deletions_to_palindrome(\\"racecar\\") 0 >>> min_deletions_to_palindrome(\\"radarx\\") 1","solution":"def min_deletions_to_palindrome(s): Returns the minimum number of deletions required to make the string a palindrome. Parameters: s (str): The input string Returns: int: The minimum number of deletions def lcs_length(x, y): m = len(x) n = len(y) dp = [[0] * (n + 1) for _ in range(m + 1)] for i in range(1, m + 1): for j in range(1, n + 1): if x[i - 1] == y[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) return dp[m][n] # The string and its reverse rev_s = s[::-1] # Length of longest palindromic subsequence lps_length = lcs_length(s, rev_s) # Number of deletions is the difference between the length of s and lps_length return len(s) - lps_length"},{"question":"def canTransform(s: str, t: str) -> bool: Determines if string s can be transformed into string t by reversing any contiguous subsegment of characters any number of times. Args: s (str): The original string. t (str): The target string. Returns: bool: True if s can be transformed into t, False otherwise. Examples: >>> canTransform(\\"abc\\", \\"bca\\") True >>> canTransform(\\"abc\\", \\"acb\\") True >>> canTransform(\\"abc\\", \\"def\\") False >>> canTransform(\\"aabbcc\\", \\"ccbbaa\\") True","solution":"def canTransform(s: str, t: str) -> bool: Determines if string s can be transformed into string t by reversing any contiguous subsegment of characters any number of times. Args: s (str): The original string. t (str): The target string. Returns: bool: True if s can be transformed into t, False otherwise. # If the sets of characters in s and t are not identical, cannot transform if sorted(s) != sorted(t): return False # Beyond character matches, transformation via reversals always possible if character counts match return True"},{"question":"def find_median_sorted_arrays(arr1, arr2): Find the median of the combined sorted array formed by merging two sorted arrays. The solution should run in O(log n) time complexity. >>> find_median_sorted_arrays([1, 3, 8, 9, 15], [7, 11, 18, 19, 21]) 10 >>> find_median_sorted_arrays([1, 2, 3], [4, 5, 6]) 3.5 >>> find_median_sorted_arrays([1, 3], [2, 4]) 2.5 >>> find_median_sorted_arrays([3, 5, 7, 9], [1, 2, 6, 8]) 5.5 >>> find_median_sorted_arrays([1, 2, 3, 4, 5, 6, 7], [8, 9, 10, 11, 12, 13, 14]) 7.5","solution":"def find_median_sorted_arrays(arr1, arr2): Finds the median of two sorted arrays in O(log n) time complexity. def find_kth_element(arr1, arr2, k): len1, len2 = len(arr1), len(arr2) index1, index2 = 0, 0 while True: if index1 == len1: return arr2[index2 + k - 1] if index2 == len2: return arr1[index1 + k - 1] if k == 1: return min(arr1[index1], arr2[index2]) new_index1 = min(index1 + k // 2 - 1, len1 - 1) new_index2 = min(index2 + k // 2 - 1, len2 - 1) pivot1, pivot2 = arr1[new_index1], arr2[new_index2] if pivot1 <= pivot2: k -= (new_index1 - index1 + 1) index1 = new_index1 + 1 else: k -= (new_index2 - index2 + 1) index2 = new_index2 + 1 n = len(arr1) total_length = 2 * n if total_length % 2 == 1: return find_kth_element(arr1, arr2, total_length // 2 + 1) else: return (find_kth_element(arr1, arr2, total_length // 2) + find_kth_element(arr1, arr2, total_length // 2 + 1)) / 2 # Usage n = 5 array1 = [1, 3, 8, 9, 15] array2 = [7, 11, 18, 19, 21] print(find_median_sorted_arrays(array1, array2))"},{"question":"def daily_temperatures(temperatures: List[int]) -> List[int]: Calculate the number of days until a warmer temperature for each day. :param temperatures: List[int], list of daily temperatures :return: List[int], list with number of days until a warmer temperature pass # Examples # >>> daily_temperatures([73, 74, 75, 71, 69, 72, 76, 73]) # [1, 1, 4, 2, 1, 1, 0, 0] # >>> daily_temperatures([70, 70, 70, 70, 70]) # [0, 0, 0, 0, 0] # >>> daily_temperatures([50]) # [0] # >>> daily_temperatures([50, 55, 60, 65, 70]) # [1, 1, 1, 1, 0] # >>> daily_temperatures([70, 65, 60, 55, 50]) # [0, 0, 0, 0, 0] # >>> daily_temperatures([60, 70, 60, 80, 60, 90]) # [1, 2, 1, 2, 1, 0]","solution":"def daily_temperatures(temperatures): Returns a list of integers where the i-th integer represents the number of days you have to wait until a warmer temperature for the i-th day. If there is no future day, put 0 instead. :param temperatures: List[int], the daily temperatures :return: List[int], the number of days to wait for a warmer temperature n = len(temperatures) result = [0] * n stack = [] for i, temp in enumerate(temperatures): while stack and temperatures[stack[-1]] < temp: prev_day = stack.pop() result[prev_day] = i - prev_day stack.append(i) return result"},{"question":"def maximum_product_of_three(arr: List[int]) -> int: Returns the maximum product of any three distinct elements in the array. >>> maximum_product_of_three([1, 10, 2, 6, 5, 3]) 300 >>> maximum_product_of_three([7, 3, 1, 9, 2, 4]) 252","solution":"def maximum_product_of_three(arr): Returns the maximum product of any three distinct elements in the array. if len(arr) < 3: raise ValueError(\\"Array must contain at least three elements\\") arr.sort() # The maximum product can either be from the three largest numbers # or from the two smallest numbers (which could be negative) and the largest number max1 = arr[-1] * arr[-2] * arr[-3] max2 = arr[0] * arr[1] * arr[-1] return max(max1, max2)"},{"question":"def is_valid_string(s: str) -> str: Determines if the given string is valid according to the specified rules. A string is considered valid if: * The string is empty. * Any letter 'a' to 'z' is a valid string. * If 'S' and 'T' are valid strings, then concatenation of 'S' and 'T' is a valid string. * If 'S' is a valid string, then '(S)' is also a valid string. Parameters: s (str): The input string of length up to 100 that consists only of lowercase Latin letters and parentheses. Returns: str: \\"Yes\\" if the string is valid, otherwise \\"No\\". Examples: >>> is_valid_string(\\"(ab(cd))\\") \\"Yes\\" >>> is_valid_string(\\"(a()b)c)\\") \\"No\\" >>> is_valid_string(\\"((abc))\\") \\"Yes\\" >>> is_valid_string(\\"(a(b(c)d)e)(f)\\") \\"Yes\\" >>> is_valid_string(\\"(ab(c)d)(e\\") \\"No\\" pass # Example test cases def test_is_valid_string_examples(): assert is_valid_string(\\"(ab(cd))\\") == \\"Yes\\" assert is_valid_string(\\"(a()b)c)\\") == \\"No\\" assert is_valid_string(\\"((abc))\\") == \\"Yes\\" assert is_valid_string(\\"(a(b(c)d)e)(f)\\") == \\"Yes\\" assert is_valid_string(\\"(ab(c)d)(e\\") == \\"No\\" def test_is_valid_string_edge_cases(): assert is_valid_string(\\"\\") == \\"Yes\\" # empty string assert is_valid_string(\\"()\\") == \\"Yes\\" # simplest valid nested case assert is_valid_string(\\"a\\") == \\"Yes\\" # single character assert is_valid_string(\\"a(b)c\\") == \\"Yes\\" # parenthesis with characters inside def test_is_valid_string_invalid_cases(): assert is_valid_string(\\")(\\") == \\"No\\" # invalid parenthesis assert is_valid_string(\\"(()\\") == \\"No\\" # unclosed parenthesis assert is_valid_string(\\"())\\") == \\"No\\" # unopened parenthesis assert is_valid_string(\\"a)b(c\\") == \\"No\\" # misplaced parenthesis assert is_valid_string(\\"abc)\\") == \\"No\\" # unclosed parenthesis at the end def test_is_valid_string_complex_cases(): assert is_valid_string(\\"a(b(c)d(e(f)g)h)i\\") == \\"Yes\\" assert is_valid_string(\\"a(b(c)d((e)f(g))h)i\\") == \\"Yes\\" assert is_valid_string(\\"(((a)))\\") == \\"Yes\\" assert is_valid_string(\\"((ab(c)d)(e(f)))\\") == \\"Yes\\" def test_is_valid_string_single_parenthesis(): assert is_valid_string(\\"(\\") == \\"No\\" # single open parenthesis assert is_valid_string(\\")\\") == \\"No\\" # single close parenthesis assert is_valid_string(\\"(a\\") == \\"No\\" # open parenthesis with character inside assert is_valid_string(\\"a)\\") == \\"No\\" # character with close parenthesis after","solution":"def is_valid_string(s): Determines if the given string is valid according to the specified rules. Parameters: s (str): The input string consisting of lowercase Latin letters and parentheses. Returns: str: \\"Yes\\" if the string is valid, otherwise \\"No\\". stack = [] for char in s: if char == '(': stack.append(char) elif char == ')': if not stack: return \\"No\\" stack.pop() elif 'a' <= char <= 'z': continue return \\"Yes\\" if not stack else \\"No\\""},{"question":"from collections import deque class HospitalQueueManagement: def __init__(self): Initialize the queue management system with multiple counters. self.counters = {} def add_patient(self, name, counter): Add a patient to the end of the queue of a specified counter. >>> management = HospitalQueueManagement() >>> management.add_patient(\\"Alice\\", 1) >>> management.add_patient(\\"Bob\\", 1) >>> list(management.counters[1]) ['Alice', 'Bob'] if counter not in self.counters: self.counters[counter] = deque() self.counters[counter].append(name) def add_urgent_patient(self, name, counter): Add an urgent patient to the front of the queue of a specified counter. >>> management = HospitalQueueManagement() >>> management.add_patient(\\"Alice\\", 1) >>> management.add_urgent_patient(\\"Charlie\\", 1) >>> list(management.counters[1]) ['Charlie', 'Alice'] if counter not in self.counters: self.counters[counter] = deque() self.counters[counter].appendleft(name) def serve_patient(self, counter): Serve the patient at the front of the queue at the specified counter. >>> management = HospitalQueueManagement() >>> management.add_patient(\\"Alice\\", 1) >>> management.add_patient(\\"Bob\\", 1) >>> management.serve_patient(1) >>> list(management.counters[1]) ['Bob'] if counter in self.counters and self.counters[counter]: self.counters[counter].popleft() def print_queue(self, counter): Print the current queue of a specified counter. >>> management = HospitalQueueManagement() >>> management.add_patient(\\"Alice\\", 1) >>> management.add_patient(\\"Bob\\", 1) >>> management.print_queue(1) Alice Bob if counter in self.counters and self.counters[counter]: print(\\" \\".join(self.counters[counter])) else: print(\\"EMPTY\\") def process_operations(operations): management = HospitalQueueManagement() for operation in operations: parts = operation.split() if parts[0] == \\"ADD\\": management.add_patient(parts[1], int(parts[2])) elif parts[0] == \\"URGENT\\": management.add_urgent_patient(parts[1], int(parts[2])) elif parts[0] == \\"SERVE\\": management.serve_patient(int(parts[2])) elif parts[0] == \\"PRINT\\": management.print_queue(int(parts[1])) if __name__ == \\"__main__\\": import sys input = sys.stdin.read data = input().splitlines() T = int(data[0]) operations = data[1:T+1] process_operations(operations)","solution":"from collections import deque class HospitalQueueManagement: def __init__(self): self.counters = {} def add_patient(self, name, counter): if counter not in self.counters: self.counters[counter] = deque() self.counters[counter].append(name) def add_urgent_patient(self, name, counter): if counter not in self.counters: self.counters[counter] = deque() self.counters[counter].appendleft(name) def serve_patient(self, counter): if counter in self.counters and self.counters[counter]: self.counters[counter].popleft() def print_queue(self, counter): if counter in self.counters and self.counters[counter]: print(\\" \\".join(self.counters[counter])) else: print(\\"EMPTY\\") def process_operations(operations): management = HospitalQueueManagement() for operation in operations: parts = operation.split() if parts[0] == \\"ADD\\": management.add_patient(parts[1], int(parts[2])) elif parts[0] == \\"URGENT\\": management.add_urgent_patient(parts[1], int(parts[2])) elif parts[0] == \\"SERVE\\": management.serve_patient(int(parts[2])) elif parts[0] == \\"PRINT\\": management.print_queue(int(parts[1])) if __name__ == \\"__main__\\": import sys input = sys.stdin.read data = input().splitlines() T = int(data[0]) operations = data[1:T+1] process_operations(operations)"},{"question":"def game_winner(n: int, results: str) -> str: Determines the winner between Anton and Danik based on game results. Args: n (int): Number of games played. results (str): String of length n with 'A' for Anton's win and 'D' for Danik's win. Returns: str: \\"Anton\\" if Anton won more games, \\"Danik\\" if Danik won more games, \\"Friendship\\" if it's a tie. >>> game_winner(3, \\"AAA\\") 'Anton' >>> game_winner(6, \\"ADDAAD\\") 'Danik' >>> game_winner(7, \\"AADADDD\\") 'Friendship' >>> game_winner(1, \\"A\\") 'Anton' >>> game_winner(2, \\"AD\\") 'Friendship' >>> game_winner(1, \\"D\\") 'Danik'","solution":"def game_winner(n, results): Determines the winner between Anton and Danik based on game results. Args: n (int): Number of games played. results (str): String of length n with 'A' for Anton's win and 'D' for Danik's win. Returns: str: \\"Anton\\" if Anton won more games, \\"Danik\\" if Danik won more games, \\"Friendship\\" if it's a tie. anton_wins = results.count('A') danik_wins = results.count('D') if anton_wins > danik_wins: return \\"Anton\\" elif danik_wins > anton_wins: return \\"Danik\\" else: return \\"Friendship\\""},{"question":"from typing import List import math from functools import reduce def find_maximum_min_value(arr: List[int]) -> int: Finds the maximum possible value of the minimum integer in the array after performing any number of operations. >>> find_maximum_min_value([6, 10, 15, 25, 30]) 5 >>> find_maximum_min_value([7]) 7 >>> find_maximum_min_value([50, 75, 100]) 25","solution":"import math from functools import reduce def find_maximum_min_value(arr): Finds the maximum possible value of the minimum integer in the array after performing any number of operations. return reduce(math.gcd, arr)"},{"question":"from typing import List def generate_tag_suggestions(test_cases: List[List[str]]) -> List[str]: Generate tag suggestions for a new blog post. >>> test_cases = [ ... [3, \\"travel beach vacation summer\\", \\"food delicious recipe dinner\\", \\"tech gadgets innovation software\\", ... 5, \\"the beach was sunny and perfect for a summer vacation\\", 1], ... [3, \\"health exercise workout nutrition\\", \\"fashion style clothing trends\\", \\"sports soccer basketball tennis\\", ... 8, \\"this new soccer workout is perfect for health-focused people who love sports\\", 2] ... ] >>> generate_tag_suggestions(test_cases) ['travel', 'health sports'] # Example Test Cases def test_single_tag_relevance(): test_cases = [ [1, \\"tech software innovation\\", 5, \\"software innovation will change the world\\", 1] ] assert generate_tag_suggestions(test_cases) == [\\"tech\\"] def test_multiple_tags(): test_cases = [ [3, \\"travel beach vacation summer\\", \\"food delicious recipe dinner\\", \\"tech gadgets innovation software\\", 5, \\"the beach was sunny and perfect for a summer vacation\\", 1] ] assert generate_tag_suggestions(test_cases) == [\\"travel\\"] def test_alphabetical_order(): test_cases = [ [2, \\"alpha beta gamma\\", \\"delta epsilon zeta\\", 3, \\"beta gamma epsilon epsilon\\", 2] ] assert generate_tag_suggestions(test_cases) == [\\"alpha delta\\"] def test_no_valid_tag(): test_cases = [ [2, \\"alpha beta gamma\\", \\"delta epsilon zeta\\", 3, \\"theta iota kappa\\", 1] ] assert generate_tag_suggestions(test_cases) == [\\"\\"] def test_complex_case(): test_cases = [ [3, \\"health exercise workout nutrition\\", \\"fashion style clothing trends\\", \\"sports soccer basketball tennis\\", 8, \\"this new soccer workout is perfect for health-focused people who love sports\\", 2] ] assert generate_tag_suggestions(test_cases) == [\\"health sports\\"]","solution":"def generate_tag_suggestions(test_cases): results = [] for case in test_cases: tag_count = case[0] tag_data = case[1:tag_count + 1] K = case[tag_count + 1] post_words = case[tag_count + 2].split() tag_relevance = {} for data in tag_data: tag_info = data.split() tag = tag_info[0] associated_words = set(tag_info[1:]) relevance = sum(post_words.count(word) for word in associated_words) if relevance > 0: tag_relevance[tag] = relevance sorted_tags = sorted(tag_relevance.keys(), key=lambda x: (-tag_relevance[x], x)) results.append(' '.join(sorted_tags[:K])) return results # Example usage: test_cases = [ [3, \\"travel beach vacation summer\\", \\"food delicious recipe dinner\\", \\"tech gadgets innovation software\\", 5, \\"the beach was sunny and perfect for a summer vacation\\", 1], [3, \\"health exercise workout nutrition\\", \\"fashion style clothing trends\\", \\"sports soccer basketball tennis\\", 8, \\"this new soccer workout is perfect for health-focused people who love sports\\", 2] ] print(generate_tag_suggestions(test_cases))"},{"question":"def rotate_grid_90_degrees_clockwise(N: int, grid: List[List[int]]) -> List[List[int]]: Rotates a given N x N grid 90 degrees clockwise. Parameters: N (int): Size of the grid grid (list of list of int): The grid to be rotated Returns: list of list of int: The rotated grid >>> rotate_grid_90_degrees_clockwise(2, [[1, 2], [3, 4]]) [[3, 1], [4, 2]] >>> rotate_grid_90_degrees_clockwise(3, [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) [[7, 4, 1], [8, 5, 2], [9, 6, 3]] >>> rotate_grid_90_degrees_clockwise(2, [[-1, -2], [-3, -4]]) [[-3, -1], [-4, -2]]","solution":"def rotate_grid_90_degrees_clockwise(N, grid): Rotates a given N x N grid 90 degrees clockwise. Parameters: N (int): Size of the grid grid (list of list of int): The grid to be rotated Returns: list of list of int: The rotated grid # Create an empty N x N grid for the rotated version rotated_grid = [[0] * N for _ in range(N)] # Perform the rotation for i in range(N): for j in range(N): rotated_grid[j][N-1-i] = grid[i][j] return rotated_grid"},{"question":"def minimum_distribution_time(n: int, magical_strengths: List[int], power_levels: List[int]) -> int: This function determines the minimum time in hours needed to distribute all books to creatures if possible. Each hour, one book can be assigned to one creature, and if an assignment is impossible, it returns -1. >>> minimum_distribution_time(4, [10, 20, 30, 40], [15, 25, 5, 30]) == 4 >>> minimum_distribution_time(3, [20, 30, 40], [50, 50, 50]) == -1 >>> minimum_distribution_time(5, [5, 10, 15, 20, 25], [10, 20, 30, 40, 50]) == -1","solution":"def minimum_distribution_time(n, magical_strengths, power_levels): # Sort both the magical strengths and power levels magical_strengths.sort() power_levels.sort() # Attempt to pair each book to a creature for i in range(n): if magical_strengths[i] < power_levels[i]: return -1 return n"},{"question":"def assign_moves(n: int, m: int) -> str: Determine if it's possible to assign moves such that no two adjacent swimmers perform the same move and, if possible, generate one valid move arrangement. >>> assign_moves(3, 3) \\"POSSIBLEnL R LnR L RnL R L\\" >>> assign_moves(2, 2) \\"IMPOSSIBLE\\"","solution":"def assign_moves(n, m): if n == 2 and m == 2: return \\"IMPOSSIBLE\\" moves = [[\\"\\" for _ in range(m)] for _ in range(n)] possible_chars = [\\"L\\", \\"R\\", \\"U\\", \\"D\\"] # Assign moves to the grid ensuring no two adjacent swimmers perform the same move for i in range(n): for j in range(m): if (i + j) % 2 == 0: moves[i][j] = \\"L\\" if (i + j) % 4 == 0 else \\"U\\" else: moves[i][j] = \\"R\\" if (i + j) % 4 == 1 else \\"D\\" result = \\"POSSIBLEn\\" + \\"n\\".join([\\"\\".join(row) for row in moves]) return result"},{"question":"def calculate_ranking(matches: List[str]) -> List[Tuple[str, int]]: Calculate the ranking of teams based on match results. >>> calculate_ranking([\\"alpha bravo win\\", \\"charlie delta draw\\", \\"alpha charlie lose\\"]) [(\\"charlie\\", 4), (\\"alpha\\", 3), (\\"delta\\", 1), (\\"bravo\\", 0)] >>> calculate_ranking([\\"teamA teamB draw\\", \\"teamC teamA win\\"]) [(\\"teamC\\", 3), (\\"teamA\\", 1), (\\"teamB\\", 1)] pass","solution":"def calculate_ranking(matches): points = {} for match in matches: team1, team2, result = match.split() # Ensure teams exist in the points dictionary if team1 not in points: points[team1] = 0 if team2 not in points: points[team2] = 0 if result == \\"win\\": points[team1] += 3 elif result == \\"lose\\": points[team2] += 3 elif result == \\"draw\\": points[team1] += 1 points[team2] += 1 # Convert dictionary to a sorted list sorted_teams = sorted(points.items(), key=lambda item: (-item[1], item[0])) return sorted_teams"},{"question":"from typing import List def largestRectangleArea(heights: List[int]) -> int: Finds the maximum area of a rectangle that can be formed by selecting adjacent buildings. >>> largestRectangleArea([2, 1, 5, 6, 2, 3]) 10 >>> largestRectangleArea([2, 4]) 4 ... # Unit tests def test_largestRectangleArea(): def test_simple_cases(): assert largestRectangleArea([2, 1, 5, 6, 2, 3]) == 10 assert largestRectangleArea([2, 4]) == 4 def test_small_heights(): assert largestRectangleArea([0, 0, 0, 0]) == 0 assert largestRectangleArea([1, 1, 1, 1]) == 4 def test_single_element(): assert largestRectangleArea([0]) == 0 assert largestRectangleArea([5]) == 5 def test_variable_heights(): assert largestRectangleArea([6, 2, 5, 4, 5, 1, 6]) == 12 assert largestRectangleArea([3, 6, 5, 7, 4, 8, 1, 0]) == 20 test_simple_cases() test_small_heights() test_single_element() test_variable_heights()","solution":"def largestRectangleArea(heights): Finds the maximum area of a rectangle that can be formed by selecting adjacent buildings. :param heights: List of integers representing the height of buildings. :return: Integer indicating the maximum area of the rectangle. stack = [] max_area = 0 index = 0 while index < len(heights): if not stack or heights[stack[-1]] <= heights[index]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"def rob_houses(nums): Given a list of non-negative integers representing the amount of money in each house, determine the maximum amount of money the thief can steal without robbing two consecutive houses. >>> rob_houses([1, 2, 3, 1]) 4 >>> rob_houses([2, 7, 9, 3, 1]) 12 >>> rob_houses([5]) 5 >>> rob_houses([5, 3]) 5 >>> rob_houses([3, 5]) 5 >>> rob_houses([]) 0 >>> rob_houses([100, 1, 2, 100]) 200","solution":"def rob_houses(nums): Given a list of non-negative integers representing the amount of money in each house, determine the maximum amount of money the thief can steal without robbing two consecutive houses. if not nums: return 0 if len(nums) == 1: return nums[0] rob1, rob2 = 0, 0 for num in nums: new_rob = max(rob2, rob1 + num) rob1 = rob2 rob2 = new_rob return rob2"},{"question":"def length_of_shortest_substring(s: str) -> int: Determine the length of the shortest substring that contains at least one of each unique character from the input string. >>> length_of_shortest_substring('abcdef') 6 >>> length_of_shortest_substring('abac') 3 >>> length_of_shortest_substring('aabcbcdbca') 4 >>> length_of_shortest_substring('a') 1 >>> length_of_shortest_substring('aaaaa') 1 >>> length_of_shortest_substring('abcd' * 25000) 4","solution":"def length_of_shortest_substring(s): from collections import Counter, defaultdict # set of all unique characters unique_chars = set(s) n_unique = len(unique_chars) n = len(s) min_len = n + 1 count = defaultdict(int) start, end = 0, 0 num_unique_in_window = 0 while end < n: # Expand the window by moving \`end\` while end < n and num_unique_in_window < n_unique: if s[end] in unique_chars: if count[s[end]] == 0: num_unique_in_window += 1 count[s[end]] += 1 end += 1 # If we have all unique characters in the current window while num_unique_in_window == n_unique: min_len = min(min_len, end - start) if s[start] in unique_chars: count[s[start]] -= 1 if count[s[start]] == 0: num_unique_in_window -= 1 start += 1 return min_len"},{"question":"import csv import heapq from typing import List def merge_csv_files(file_names: List[str], output_file_name: str): Merges multiple CSV files into one sorted by the timestamp column. Args: file_names (List[str]): List of input CSV file names. output_file_name (str): The name of the output CSV file. Example: >>> merge_csv_files(['file1.csv', 'file2.csv'], 'output.csv') import os import csv from solution import merge_csv_files def create_csv_file(file_name, rows): with open(file_name, 'w', newline='') as file: writer = csv.writer(file) writer.writerows(rows) def test_merge_csv_files(): # Prepare test files file1_rows = [ ['timestamp', 'value1', 'value2'], ['2020-01-01 00:00:01', '10', '20'], ['2020-01-01 00:00:03', '15', '25'] ] file2_rows = [ ['timestamp', 'value1', 'value2'], ['2020-01-01 00:00:02', '12', '22'], ['2020-01-01 00:00:04', '18', '28'] ] create_csv_file('file1.csv', file1_rows) create_csv_file('file2.csv', file2_rows) output_file_name = 'output.csv' merge_csv_files(['file1.csv', 'file2.csv'], output_file_name) with open(output_file_name, 'r') as file: reader = csv.reader(file) result = list(reader) expected_result = [ ['timestamp', 'value1', 'value2'], ['2020-01-01 00:00:01', '10', '20'], ['2020-01-01 00:00:02', '12', '22'], ['2020-01-01 00:00:03', '15', '25'], ['2020-01-01 00:00:04', '18', '28'] ] assert result == expected_result # Clean up test files os.remove('file1.csv') os.remove('file2.csv') os.remove(output_file_name) def test_empty_files(): # Prepare test files file1_rows = [['timestamp', 'value1', 'value2']] file2_rows = [['timestamp', 'value1', 'value2']] create_csv_file('empty1.csv', file1_rows) create_csv_file('empty2.csv', file2_rows) output_file_name = 'output_empty.csv' merge_csv_files(['empty1.csv', 'empty2.csv'], output_file_name) with open(output_file_name, 'r') as file: reader = csv.reader(file) result = list(reader) expected_result = [['timestamp', 'value1', 'value2']] assert result == expected_result # Clean up test files os.remove('empty1.csv') os.remove('empty2.csv') os.remove(output_file_name)","solution":"import csv import heapq from typing import List def merge_csv_files(file_names: List[str], output_file_name: str): Merges multiple CSV files into one sorted by the timestamp column. # Initialize a min-heap min_heap = [] file_handles = [] try: # Open all files and add their first rows to the heap for file_index, file_name in enumerate(file_names): file_handle = open(file_name, 'r') file_handles.append(file_handle) csv_reader = csv.reader(file_handle) headers = next(csv_reader) # Add the first row from each file to the min-heap row = next(csv_reader, None) if row: heapq.heappush(min_heap, (row[0], file_index, row)) # Write to the output file with open(output_file_name, 'w', newline='') as output_file: csv_writer = csv.writer(output_file) csv_writer.writerow(headers) while min_heap: # Extract the smallest row from the heap timestamp, file_index, row = heapq.heappop(min_heap) csv_writer.writerow(row) # Read the next row from the same file and push it to the heap next_row = next(file_handles[file_index], None) if next_row: parsed_row = next(csv.reader([next_row])) heapq.heappush(min_heap, (parsed_row[0], file_index, parsed_row)) finally: # Close all file handles for file_handle in file_handles: file_handle.close()"},{"question":"def count_odd_sum_subarrays(arr: List[int]) -> int: Returns the number of contiguous subarrays whose sum is odd. >>> count_odd_sum_subarrays([1, 2, 3, 4, 5]) 9 >>> count_odd_sum_subarrays([2, 4, 6]) 0 >>> count_odd_sum_subarrays([1, 1, 1, 1]) 6 >>> count_odd_sum_subarrays([1]) 1 >>> count_odd_sum_subarrays([2]) 0 >>> count_odd_sum_subarrays([1]*1000) 250500 >>> count_odd_sum_subarrays([2]*1000) 0","solution":"def count_odd_sum_subarrays(arr): Returns the number of contiguous subarrays whose sum is odd. n = len(arr) odd_count = 0 even_count = 1 # Initialize even_count as 1 to account for the sum = 0 case cumulative_sum = 0 result = 0 for num in arr: cumulative_sum += num if cumulative_sum % 2 == 0: result += odd_count even_count += 1 else: result += even_count odd_count += 1 return result"},{"question":"def max_subarray_sum_no_zero(n: int, arr: List[int]) -> int: Returns the maximum possible sum of a subarray that does not include zero. Examples: >>> max_subarray_sum_no_zero(5, [1, -2, 3, 4, -5]) 7 >>> max_subarray_sum_no_zero(8, [-1, 2, -3, 4, 5, -6, -7, 8]) 9 >>> max_subarray_sum_no_zero(4, [-1, 0, -2, 2]) 2","solution":"def max_subarray_sum_no_zero(n, arr): Returns the maximum possible sum of a subarray that does not include zero. max_sum = -float('inf') current_sum = 0 for num in arr: if num == 0: current_sum = 0 else: current_sum += num if current_sum > max_sum: max_sum = current_sum if current_sum < 0: current_sum = 0 return max_sum"},{"question":"def find_overlapping_schedules(n: int, schedules: List[List[Tuple[int, int]]]) -> List[Tuple[int, int]]: Find and return pairs of employee identifiers with overlapping shifts. Parameters: n (int): Number of employees schedules (List[List[Tuple[int, int]]]): List of schedules for each employee Returns: List[Tuple[int, int]]: List of pairs (i, j) with overlapping shifts >>> find_overlapping_schedules(3, [[(1, 100), (150, 300)], [(90, 200), (250, 350)], [(500, 600)]]) [(1, 2)] >>> find_overlapping_schedules(2, [[(1, 10)], [(11, 20)]]) []","solution":"def find_overlapping_schedules(n, schedules): Find and return pairs of employee identifiers with overlapping shifts. :param n: Number of employees :param schedules: List of schedules for each employee :return: List of pairs (i, j) with overlapping shifts result = [] def is_overlap(shift1, shift2): return max(shift1[0], shift2[0]) < min(shift1[1], shift2[1]) for i in range(n): for j in range(i + 1, n): for shift1 in schedules[i]: for shift2 in schedules[j]: if is_overlap(shift1, shift2): result.append((i + 1, j + 1)) break if (i + 1, j + 1) in result: break return result # Example usage: n = 3 schedules = [ [(1, 100), (150, 300)], [(90, 200), (250, 350)], [(500, 600)] ] print(find_overlapping_schedules(n, schedules)) # Output: [(1, 2)]"},{"question":"def minimum_spanning_tree(n: int, m: int, edges: List[Tuple[int, int, int]]) -> int: Calculate the minimum cost required to construct a spanning tree of an undirected graph with \`n\` nodes and \`m\` edges. If it's not possible to construct such a spanning tree, return \`-1\`. Parameters: - n (int): Number of nodes - m (int): Number of edges - edges (List[Tuple[int, int, int]]): The edges of the graph, each represented by a tuple (u, v, w) where \`u\` and \`v\` are the endpoints of the edge and \`w\` is the cost. Returns: - int: The minimum cost required to construct a spanning tree, or -1 if not possible. Examples: >>> minimum_spanning_tree(4, 4, [(1, 2, 1), (2, 3, 2), (3, 4, 3), (4, 1, 4)]) 6 >>> minimum_spanning_tree(4, 3, [(1, 2, 1), (2, 3, 2), (3, 4, 3)]) 6 >>> minimum_spanning_tree(4, 1, [(1, 2, 1)]) -1","solution":"def find(parent, i): if parent[i] == i: return i else: return find(parent, parent[i]) def union(parent, rank, x, y): xroot = find(parent, x) yroot = find(parent, y) if rank[xroot] < rank[yroot]: parent[xroot] = yroot elif rank[xroot] > rank[yroot]: parent[yroot] = xroot else: parent[yroot] = xroot rank[xroot] += 1 def kruskal_mst(n, edges): result = [] i = 0 e = 0 edges = sorted(edges, key=lambda item: item[2]) parent = [] rank = [] for node in range(n): parent.append(node) rank.append(0) while e < n - 1: if i >= len(edges): return -1 u, v, w = edges[i] i = i + 1 x = find(parent, u-1) y = find(parent, v-1) if x != y: e = e + 1 result.append([u, v, w]) union(parent, rank, x, y) minimumCost = 0 for u, v, weight in result: minimumCost += weight return minimumCost def minimum_spanning_tree(n, m, edge_list): if n == 1: # If there is only one node, the cost is 0 return 0 edges = [] for edge in edge_list: u, v, w = edge edges.append((u, v, w)) min_cost = kruskal_mst(n, edges) return min_cost"},{"question":"def max_subarray_sum_with_at_least_two_elements(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Find the maximum sum of any subarray of a given array that has at least 2 elements. Args: t (int): The number of test cases. test_cases (List[Tuple[int, List[int]]]): A list containing tuples. Each tuple contains: - n (int): The number of elements in the array. - a (List[int]): The elements of the array. Returns: List[int]: A list of integers where each integer is the maximum sum of any subarray that has at least 2 elements for the corresponding test case. Example: >>> max_subarray_sum_with_at_least_two_elements(2, [(3, [-1, 2, 3]), (4, [1, -2, 3, -1])]) [5, 2] from typing import List, Tuple import pytest @pytest.mark.parametrize(\\"t, test_cases, expected\\", [ (1, [(3, [-1, 2, 3])], [5]), (2, [(3, [-1, 2, 3]), (4, [1, -2, 3, -1])], [5, 2]), (1, [(4, [-1, -2, -3, -4])], [-3]), (1, [(5, [1, 2, -1, 2, -1])], [4]), (1, [(6, [10, -3, 4, -2, 5, 2])], [16]), (1, [(5, [2, 2, -1, 2, 2])], [7]), ]) def test_max_subarray_sum_with_at_least_two_elements(t, test_cases, expected): assert max_subarray_sum_with_at_least_two_elements(t, test_cases) == expected","solution":"def max_subarray_sum_with_at_least_two_elements(t, test_cases): def max_subarray_sum(arr): n = len(arr) if n < 2: return 0 max_ending_here = float('-inf') max_so_far = float('-inf') max_one_elem = float('-inf') for i in range(1, n): if i == 1: max_ending_here = arr[i-1] + arr[i] else: max_ending_here = max(arr[i-1] + arr[i], max_ending_here + arr[i]) max_so_far = max(max_so_far, max_ending_here) return max_so_far results = [] for i in range(t): n = test_cases[i][0] arr = test_cases[i][1] results.append(max_subarray_sum(arr)) return results"},{"question":"def calculate_total_spending(N: int, transactions: List[Tuple[str, float]]) -> Dict[str, float]: Returns a dictionary where the keys are categories and the values are the total amount spent in each category based on a list of transactions. Parameters: - N: int, the number of transactions - transactions: list of tuples, each tuple contains a string (category) and a float (amount) Returns: dict: a dictionary with categories as keys and total amounts as values Example: >>> N = 5 >>> transactions = [(\\"groceries\\", 35.60), (\\"rent\\", 550.00), (\\"utilities\\", 120.15), ... (\\"groceries\\", 45.50), (\\"rent\\", 550.00)] >>> calculate_total_spending(N, transactions) {'groceries': 81.10, 'rent': 1100.00, 'utilities': 120.15} pass from typing import List, Tuple, Dict def test_single_transaction(): N = 1 transactions = [(\\"groceries\\", 35.60)] result = calculate_total_spending(N, transactions) assert result == {\\"groceries\\": 35.60} def test_multiple_transactions_single_category(): N = 3 transactions = [(\\"groceries\\", 35.60), (\\"groceries\\", 45.50), (\\"groceries\\", 20.00)] result = calculate_total_spending(N, transactions) assert result == {\\"groceries\\": 101.10} def test_multiple_transactions_multiple_categories(): N = 5 transactions = [(\\"groceries\\", 35.60), (\\"rent\\", 550.00), (\\"utilities\\", 120.15), (\\"groceries\\", 45.50), (\\"rent\\", 550.00)] result = calculate_total_spending(N, transactions) assert result == {\\"groceries\\": 81.10, \\"rent\\": 1100.00, \\"utilities\\": 120.15} def test_zero_amount_transactions(): N = 3 transactions = [(\\"groceries\\", 0.00), (\\"rent\\", 0.00), (\\"utilities\\", 0.00)] result = calculate_total_spending(N, transactions) assert result == {\\"groceries\\": 0.00, \\"rent\\": 0.00, \\"utilities\\": 0.00} def test_small_and_large_amount_transactions(): N = 3 transactions = [(\\"groceries\\", 0.01), (\\"rent\\", 1000.00), (\\"utilities\\", 500.50)] result = calculate_total_spending(N, transactions) assert result == {\\"groceries\\": 0.01, \\"rent\\": 1000.00, \\"utilities\\": 500.50}","solution":"def calculate_total_spending(N, transactions): Returns a dictionary where the keys are categories and the values are the total amount spent in each category based on a list of transactions. Parameters: - N: int, the number of transactions - transactions: list of tuples, each tuple contains a string (category) and a float (amount) Returns: dict: a dictionary with categories as keys and total amounts as values spending_summary = {} order_of_categories = [] # Ensure the order of first appearances for transaction in transactions: category, amount = transaction if category not in spending_summary: spending_summary[category] = 0 order_of_categories.append(category) spending_summary[category] += amount return {category: spending_summary[category] for category in order_of_categories}"},{"question":"def count_routes(n: int, m: int, k: int, disliked: List[Tuple[int, int]]) -> int: Calculate the number of different routes from the northwest corner to the southeast corner in a grid city avoiding disliked crossroads. Parameters: n (int): The number of horizontal streets. m (int): The number of vertical avenues. k (int): The number of disliked crossroads. disliked (List[Tuple[int, int]]): List of disliked crossroads as (x, y) pairs. Returns: int: The number of different routes that do not pass through any disliked crossroads. Examples: >>> count_routes(2, 2, 0, []) 2 >>> count_routes(3, 3, 1, [(2, 2)]) 2 pass from typing import List, Tuple def test_route_without_disliked(): assert count_routes(2, 2, 0, []) == 2 assert count_routes(3, 3, 0, []) == 6 def test_route_with_disliked(): assert count_routes(3, 3, 1, [(2, 2)]) == 2 assert count_routes(3, 3, 2, [(2, 2), (3, 2)]) == 1 def test_route_start_is_disliked(): assert count_routes(3, 3, 1, [(1, 1)]) == 0 def test_route_end_is_disliked(): assert count_routes(3, 3, 1, [(3, 3)]) == 0 def test_route_no_possible_path(): assert count_routes(3, 3, 3, [(2, 2), (3, 2), (2, 3)]) == 0","solution":"def count_routes(n, m, k, disliked): # Initializing the grid with 0s grid = [[0] * m for _ in range(n)] # Marking disliked positions on the grid for x, y in disliked: grid[x-1][y-1] = -1 # Initializing the starting point if grid[0][0] == -1: return 0 grid[0][0] = 1 # Filling out the number of ways in the grid for i in range(n): for j in range(m): if grid[i][j] == -1: grid[i][j] = 0 else: if i > 0: grid[i][j] += grid[i-1][j] if j > 0: grid[i][j] += grid[i][j-1] return grid[-1][-1] # Reading input and processing to the required format def main(): n, m, k = map(int, input().strip().split()) disliked = [tuple(map(int, input().strip().split())) for _ in range(k)] result = count_routes(n, m, k, disliked) print(result)"},{"question":"def longest_common_subsequence(A: str, B: str) -> int: Returns the length of the longest common subsequence of strings A and B. >>> longest_common_subsequence(\\"ABCBDAB\\", \\"BDCABA\\") 4 >>> longest_common_subsequence(\\"XMJYAUZ\\", \\"MZJAWXU\\") 4 pass def test_common_subsequence(): assert longest_common_subsequence(\\"ABCBDAB\\", \\"BDCABA\\") == 4 assert longest_common_subsequence(\\"XMJYAUZ\\", \\"MZJAWXU\\") == 4 assert longest_common_subsequence(\\"AGGTAB\\", \\"GXTXAYB\\") == 4 assert longest_common_subsequence(\\"BBBBB\\", \\"BBBBB\\") == 5 assert longest_common_subsequence(\\"LONGEST\\", \\"STONE\\") == 3 assert longest_common_subsequence(\\"ABCD\\", \\"EFGH\\") == 0 def test_empty_strings(): assert longest_common_subsequence(\\"\\", \\"\\") == 0 assert longest_common_subsequence(\\"A\\", \\"\\") == 0 assert longest_common_subsequence(\\"\\", \\"B\\") == 0 def test_single_character_strings(): assert longest_common_subsequence(\\"A\\", \\"A\\") == 1 assert longest_common_subsequence(\\"A\\", \\"B\\") == 0 def test_mixed_length_strings(): assert longest_common_subsequence(\\"ABCDE\\", \\"ACE\\") == 3 assert longest_common_subsequence(\\"ABC\\", \\"ABCDEF\\") == 3 assert longest_common_subsequence(\\"BATD\\", \\"ABACD\\") == 3 # You can use pytest to run these tests # E.g., if you have saved this code in a file named \`test_solution.py\`, you can run \`pytest test_solution.py\`","solution":"def longest_common_subsequence(A, B): Returns the length of the longest common subsequence of strings A and B. :param A: String A :param B: String B :return: Integer length of the longest common subsequence m, n = len(A), len(B) dp = [[0] * (n + 1) for _ in range(m + 1)] for i in range(1, m + 1): for j in range(1, n + 1): if A[i - 1] == B[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) return dp[m][n]"},{"question":"def who_hosts_feast(day: int) -> str: Determine which creatures host the feast on the given day. Args: day (int): The day number. Returns: str: The creatures hosting the feast ('E', 'D', 'W', or 'EDW'). >>> who_hosts_feast(1) 'D' >>> who_hosts_feast(6) 'W' >>> who_hosts_feast(11) 'EDW' >>> who_hosts_feast(16) 'E' # Your code here def process_test_cases(test_cases: list[int]) -> list[str]: Process multiple test cases to determine which creatures host the feast. Args: test_cases (list of int): List of day numbers for each test case. Returns: list of str: List of results for each test case. >>> process_test_cases([1, 4, 6, 11]) ['D', 'E', 'W', 'EDW'] >>> process_test_cases([7, 8, 9, 12]) ['EDW', 'E', 'D', 'E'] # Your code here","solution":"def who_hosts_feast(day): Determine which creatures host the feast on the given day. Args: day (int): The day number. Returns: str: The creatures hosting the feast ('E', 'D', 'W', or 'EDW'). remainder = day % 4 if remainder == 0: return 'E' elif remainder == 1: return 'D' elif remainder == 2: return 'W' elif remainder == 3: return 'EDW' def process_test_cases(test_cases): Process multiple test cases to determine which creatures host the feast. Args: test_cases (list of int): List of day numbers for each test case. Returns: list of str: List of results for each test case. results = [] for day in test_cases: results.append(who_hosts_feast(day)) return results"},{"question":"def is_strong_password(S: str) -> str: Determine if the given password is strong. A strong password is defined as a string that is at least 8 characters long, contains at least one uppercase letter, one lowercase letter, one digit, and one special character. Parameters: S (str): The input password string. Returns: str: \\"Strong\\" if the password is strong, otherwise \\"Weak\\". Examples: >>> is_strong_password(\\"Abcdefg1@\\") \\"Strong\\" >>> is_strong_password(\\"1234567\\") \\"Weak\\" >>> is_strong_password(\\"A1@bcdEF\\") \\"Strong\\"","solution":"def is_strong_password(S): Determine if the given password is strong. A strong password is defined as a string that is at least 8 characters long, contains at least one uppercase letter, one lowercase letter, one digit, and one special character. Parameters: S (str): The input password string. Returns: str: \\"Strong\\" if the password is strong, otherwise \\"Weak\\". if len(S) < 8: return \\"Weak\\" has_upper = any(char.isupper() for char in S) has_lower = any(char.islower() for char in S) has_digit = any(char.isdigit() for char in S) has_special = any(char in \\"!@#%^&*\\" for char in S) if has_upper and has_lower and has_digit and has_special: return \\"Strong\\" else: return \\"Weak\\""},{"question":"def check_string_validity(s: str) -> str: Returns 'Valid' if the string contains at least one digit, one lowercase letter, and one uppercase letter, otherwise returns 'Invalid'. >>> check_string_validity(\\"Hello123\\") == \\"Valid\\" True >>> check_string_validity(\\"hello\\") == \\"Invalid\\" True >>> check_string_validity(\\"HELLO123\\") == \\"Invalid\\" True >>> check_string_validity(\\"hello123\\") == \\"Invalid\\" True >>> check_string_validity(\\"123456\\") == \\"Invalid\\" True >>> check_string_validity(\\"abcdef\\") == \\"Invalid\\" True >>> check_string_validity(\\"ABCDEF\\") == \\"Invalid\\" True >>> check_string_validity(\\"Valid@123\\") == \\"Valid\\" True >>> check_string_validity(\\"aA1\\") == \\"Valid\\" True >>> check_string_validity(\\"\\") == \\"Invalid\\" True","solution":"def check_string_validity(s): Returns 'Valid' if the string contains at least one digit, one lowercase letter, and one uppercase letter, otherwise returns 'Invalid'. has_digit = any(char.isdigit() for char in s) has_lower = any(char.islower() for char in s) has_upper = any(char.isupper() for char in s) if has_digit and has_lower and has_upper: return \\"Valid\\" else: return \\"Invalid\\""},{"question":"def valid_drone_paths(n: int, heights: List[int]) -> int: Determines if there are any valid paths from start to end given the constraints. Parameters: n (int): The number of points in the array. heights (list of int): The heights of the mountains at each point. Returns: int: 1 if there's a valid path, 0 otherwise (modulo 1000000007). >>> valid_drone_paths(3, [1, 2, 2]) 1 >>> valid_drone_paths(4, [3, 4, 3, 5]) 0 def test_valid_path_1(): assert valid_drone_paths(3, [1, 2, 2]) == 1 def test_valid_path_2(): assert valid_drone_paths(4, [3, 4, 3, 5]) == 0 def test_valid_path_3(): assert valid_drone_paths(5, [1, 2, 3, 4, 5]) == 1 def test_valid_path_4(): assert valid_drone_paths(5, [5, 4, 3, 2, 1]) == 1 def test_valid_path_5(): assert valid_drone_paths(6, [1, 3, 5, 7, 9, 11]) == 0 def test_valid_path_6(): assert valid_drone_paths(8, [1, 2, 2, 3, 3, 2, 1, 1]) == 1","solution":"def valid_drone_paths(n, heights): Determines if there are any valid paths from start to end given the constraints. Parameters: n (int): The number of points in the array. heights (list of int): The heights of the mountains at each point. Returns: int: 1 if there's a valid path, 0 otherwise (modulo 1000000007). for i in range(n-1): if heights[i+1] - heights[i] > 1: return 0 return 1"},{"question":"def can_reach_last_index(arr: List[int]) -> bool: Determine if you can reach the last index starting from the first index. >>> can_reach_last_index([2, 3, 1, 1, 4]) == True >>> can_reach_last_index([3, 2, 1, 0, 4]) == False >>> can_reach_last_index([0]) == True >>> can_reach_last_index([1, 2, 3, 4, 5]) == True >>> can_reach_last_index([0, 2, 1, 1, 4]) == False >>> can_reach_last_index([2, 3, 0, 0, 4]) == True >>> can_reach_last_index([1000]*1000) == True","solution":"def can_reach_last_index(arr): Determine if you can reach the last index starting from the first index. :param arr: List of integers where each element represents the maximum jump length at that position. :return: True if you can reach the last index, False otherwise. max_reach = 0 for i in range(len(arr)): if i > max_reach: return False max_reach = max(max_reach, i + arr[i]) return True"},{"question":"def preprocess_array(array): Preprocesses the array to create a prefix sum array. >>> preprocess_array([1, 2, 3, 4, 5]) [0, 1, 3, 6, 10, 15] def query_sum(prefix_sums, l, r): Returns the sum of elements from index l to r, inclusive, using the prefix sums array. >>> query_sum([0, 1, 3, 6, 10, 15], 0, 2) 6 >>> query_sum([0, 1, 3, 6, 10, 15], 1, 3) 9 >>> query_sum([0, 1, 3, 6, 10, 15], 0, 4) 15","solution":"def preprocess_array(array): Preprocesses the array to create a prefix sum array. prefix_sums = [0] * (len(array) + 1) for i in range(1, len(prefix_sums)): prefix_sums[i] = prefix_sums[i-1] + array[i-1] return prefix_sums def query_sum(prefix_sums, l, r): Returns the sum of elements from index l to r, inclusive, using the prefix sums array. return prefix_sums[r+1] - prefix_sums[l]"},{"question":"def can_partition(nums: List[int]) -> str: Determine if a list of positive integers can be split into two sublists such that the sums of the two sublists are equal. >>> can_partition([1, 5, 11, 5]) \\"YES\\" >>> can_partition([1, 2, 3, 5]) \\"NO\\"","solution":"from typing import List def can_partition(nums: List[int]) -> str: Determine if the list can be split into two sublists such that the sums of the two sublists are equal. total_sum = sum(nums) # If the total sum is odd, it's not possible to partition it into two equal sums if total_sum % 2 != 0: return \\"NO\\" target = total_sum // 2 n = len(nums) # Dynamic programming approach dp = [False] * (target + 1) dp[0] = True for num in nums: for j in range(target, num - 1, -1): dp[j] = dp[j] or dp[j - num] return \\"YES\\" if dp[target] else \\"NO\\""},{"question":"def min_path_sum(grid: List[List[int]]) -> int: Calculate the minimum path sum from the top-left cell to the bottom-right cell. Parameters: grid (list of list of int): N x M matrix representing the grid. Returns: int: Minimum path sum. Examples: >>> min_path_sum([[1, 3, 1], [1, 5, 1], [4, 2, 1]]) 7 >>> min_path_sum([[1, 2], [1, 1]]) 3","solution":"def min_path_sum(grid): Calculate the minimum path sum from the top-left cell to the bottom-right cell. Parameters: grid (list of list of int): N x M matrix representing the grid. Returns: int: Minimum path sum. if not grid or not grid[0]: return 0 n, m = len(grid), len(grid[0]) # Initialize the dp array with the first cell of the grid. dp = [[0] * m for _ in range(n)] dp[0][0] = grid[0][0] # Fill the first row. for j in range(1, m): dp[0][j] = dp[0][j - 1] + grid[0][j] # Fill the first column. for i in range(1, n): dp[i][0] = dp[i - 1][0] + grid[i][0] # Fill the rest of the dp table. for i in range(1, n): for j in range(1, m): dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j] return dp[n - 1][m - 1]"},{"question":"def apply_filter(N: int, K: int, A: List[List[int]]) -> List[List[int]]: Applies a complex filter to an NxN matrix by rotating each KxK block 90 degrees clockwise. Args: - N (int): Size of the NxN matrix. - K (int): Size of the KxK blocks. - A (List[List[int]]): NxN matrix of integers representing pixel values. Returns: - List[List[int]]: The transformed NxN matrix after applying the filter. Examples: >>> apply_filter(4, 2, [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]]) [[5, 1, 7, 3], [6, 2, 8, 4], [13, 9, 15, 11], [14, 10, 16, 12]] >>> apply_filter(5, 3, [[1, 2, 3, 4, 5], [6, 7, 8, 9, 10], [11, 12, 13, 14, 15], [16, 17, 18, 19, 20], [21, 22, 23, 24, 25]]) [[11, 6, 1, 4, 5], [12, 7, 2, 9, 10], [13, 8, 3, 14, 15], [16, 17, 18, 19, 20], [21, 22, 23, 24, 25]]","solution":"from typing import List def rotate_90_clockwise(block: List[List[int]]) -> List[List[int]]: Rotates a KxK block 90 degrees clockwise. K = len(block) rotated = [[0] * K for _ in range(K)] for i in range(K): for j in range(K): rotated[j][K - 1 - i] = block[i][j] return rotated def apply_filter(N: int, K: int, A: List[List[int]]) -> List[List[int]]: Applies the filter over NxN matrix with KxK blocks. result = [row[:] for row in A] for i in range(0, N, K): for j in range(0, N, K): if i + K <= N and j + K <= N: block = [row[j:j+K] for row in A[i:i+K]] rotated_block = rotate_90_clockwise(block) for row_index, row in enumerate(rotated_block): result[i + row_index][j:j+K] = row return result"},{"question":"def pair_sum_exists(target: int, array: List[int]) -> str: Determines if there exists a pair of elements in the array that sum up to the target integer. :param target: The target sum value as an integer :param array: List of integers :return: \\"YES\\" if such a pair exists, otherwise \\"NO\\" Examples: >>> pair_sum_exists(9, [2, 7, 11, 15]) 'YES' >>> pair_sum_exists(10, [1, 2, 3, 4, 5]) 'NO'","solution":"def pair_sum_exists(target, array): Determines if there exists a pair of elements in the array that sum up to the target integer. :param target: The target sum value as an integer :param array: List of integers :return: \\"YES\\" if such a pair exists, otherwise \\"NO\\" complements = set() for num in array: if target - num in complements: return \\"YES\\" complements.add(num) return \\"NO\\""},{"question":"def find_indices_of_target_sum(nums, target): Finds the indices of two numbers in nums that add up to target. If no such pair exists, returns None. def process_input(input_list_str, target_str): Process the input strings to appropriate types and call the function to find the indices. >>> process_input('1 2 3 4 6', '10') == '3 4' >>> process_input('1 2 3 4 6', '20') == 'None'","solution":"def find_indices_of_target_sum(nums, target): Finds the indices of two numbers in nums that add up to target. If no such pair exists, returns None. index_map = {} for index, num in enumerate(nums): complement = target - num if complement in index_map: return index_map[complement], index index_map[num] = index return None def process_input(input_list_str, target_str): Process the input strings to appropriate types and call the function to find the indices. nums = list(map(int, input_list_str.split())) target = int(target_str) result = find_indices_of_target_sum(nums, target) if result is not None: return f\\"{result[0]} {result[1]}\\" else: return \\"None\\""},{"question":"def compress_string(s: str) -> str: Compresses a string using counts of repeated characters. Args: s (str): The input string consisting of lowercase English letters. Returns: str: The compressed string. Examples: >>> compress_string(\\"\\") == \\"\\" >>> compress_string(\\"a\\") == \\"a\\" >>> compress_string(\\"abc\\") == \\"abc\\" >>> compress_string(\\"aaabbc\\") == \\"a3b2c\\" >>> compress_string(\\"aaaaa\\") == \\"a5\\" >>> compress_string(\\"aabcccccaaa\\") == \\"a2bc5a3\\" >>> compress_string(\\"aabbccccddddd\\") == \\"a2b2c4d5\\"","solution":"def compress_string(s): Compresses a string using counts of repeated characters. Args: s (str): The input string consisting of lowercase English letters. Returns: str: The compressed string. if not s: return \\"\\" compressed = [] count = 1 for i in range(1, len(s)): if s[i] == s[i - 1]: count += 1 else: compressed.append(s[i - 1]) if count > 1: compressed.append(str(count)) count = 1 compressed.append(s[-1]) if count > 1: compressed.append(str(count)) return ''.join(compressed)"},{"question":"def can_collect_all_boxes(n: int, boxes: List[int]) -> str: Determine if all boxes can be collected by the robotic arms from their positions. >>> can_collect_all_boxes(6, [1, 2, 0, 1, 2, 1]) \\"YES\\" >>> can_collect_all_boxes(5, [0, 0, 0, 0, 5]) \\"NO\\"","solution":"def can_collect_all_boxes(n, boxes): max_reached = 0 for i, reach in enumerate(boxes): if i > max_reached: break max_reached = max(max_reached, i + reach) return \\"YES\\" if max_reached >= n - 1 else \\"NO\\""},{"question":"def length_of_longest_substring_k_distinct(s: str, k: int) -> int: Return the length of the longest substring that contains at most \`k\` distinct characters. Args: s (str): A string which consists of lowercase alphabetical characters. k (int): An integer representing the maximum number of distinct characters. Returns: int: The length of the longest substring. Examples: >>> length_of_longest_substring_k_distinct(\\"aabbcc\\", 2) 4 >>> length_of_longest_substring_k_distinct(\\"aaabbbccc\\", 1) 3 >>> length_of_longest_substring_k_distinct(\\"abcabcabc\\", 2) 2 >>> length_of_longest_substring_k_distinct(\\"eceba\\", 2) 3 >>> length_of_longest_substring_k_distinct(\\"\\", 2) 0 >>> length_of_longest_substring_k_distinct(\\"aabbcc\\", 1) 2 >>> length_of_longest_substring_k_distinct(\\"aabbcc\\", 0) 0 >>> length_of_longest_substring_k_distinct(\\"abcabcabc\\", 3) 9 >>> length_of_longest_substring_k_distinct(\\"a\\", 1) 1 >>> length_of_longest_substring_k_distinct(\\"aa\\", 1) 2","solution":"def length_of_longest_substring_k_distinct(s, k): if k == 0: return 0 n = len(s) if n == 0 or k >= n: return n left = 0 right = 0 max_length = 0 char_count = {} while right < n: if s[right] in char_count: char_count[s[right]] += 1 else: char_count[s[right]] = 1 while len(char_count) > k: char_count[s[left]] -= 1 if char_count[s[left]] == 0: del char_count[s[left]] left += 1 max_length = max(max_length, right - left + 1) right += 1 return max_length"},{"question":"import math from typing import List, Tuple def smallest_common_factor(a: int, b: int) -> int: Returns the smallest common factor greater than 1 for a and b or \\"invalid\\" if no such factor exists. >>> smallest_common_factor(8, 12) 2 >>> smallest_common_factor(15, 25) 5 >>> smallest_common_factor(17, 19) \\"invalid\\" pass def process_test_cases(t: int, cases: List[Tuple[int, int]]) -> List: Given the number of test cases and a list of integer pairs, return a list of results for each pair. >>> process_test_cases(5, [(8, 12), (15, 25), (17, 19), (20, 30), (7, 14)]) [2, 5, \\"invalid\\", 2, 7] pass def test_smallest_common_factor_basic(): assert smallest_common_factor(8, 12) == 2 assert smallest_common_factor(15, 25) == 5 assert smallest_common_factor(17, 19) == \\"invalid\\" assert smallest_common_factor(20, 30) == 2 assert smallest_common_factor(7, 14) == 7 assert smallest_common_factor(10, 25) == 5 def test_smallest_common_factor_edge_cases(): assert smallest_common_factor(1, 1) == \\"invalid\\" assert smallest_common_factor(1, 2) == \\"invalid\\" assert smallest_common_factor(1000000, 1000000) == 2 assert smallest_common_factor(12, 18) == 2 def test_process_test_cases(): test_cases = [ (8, 12), (15, 25), (17, 19), (20, 30), (7, 14), ] expected_results = [2, 5, \\"invalid\\", 2, 7] assert process_test_cases(len(test_cases), test_cases) == expected_results","solution":"import math def smallest_common_factor(a, b): Returns the smallest common factor greater than 1 for a and b or \\"invalid\\" if no such factor exists. gcd_ab = math.gcd(a, b) if gcd_ab > 1: return min((i for i in range(2, gcd_ab + 1) if gcd_ab % i == 0)) return \\"invalid\\" def process_test_cases(t, cases): results = [] for a, b in cases: results.append(smallest_common_factor(a, b)) return results"},{"question":"import heapq from typing import List, Tuple def manage_shipments(T: int, cases: List[Tuple[int, int, List[int]]]) -> List[List[int]]: Given the number of test cases, and for each test case, the total number of shipments and the number of largest shipments to keep track of, maintains the top K largest quantities from the list. >>> manage_shipments(1, [(8, 3, [10, 20, 30, 40, 50, 60, 70, 80])]) [[80, 70, 60]] >>> manage_shipments(2, [(8, 3, [10, 20, 30, 40, 50, 60, 70, 80]), (5, 2, [1, 2, 3, 4, 5])]) [[80, 70, 60], [5, 4]] def parse_input(input_str: str) -> Tuple[int, List[Tuple[int, int, List[int]]]]: Parses the input string and returns the number of test cases and the corresponding cases with the total number of shipments and the respective quantities. >>> parse_input(\\"1n8 3n10 20 30 40 50 60 70 80\\") (1, [(8, 3, [10, 20, 30, 40, 50, 60, 70, 80])]) >>> parse_input(\\"2n8 3n10 20 30 40 50 60 70 80n5 2n1 2 3 4 5\\") (2, [(8, 3, [10, 20, 30, 40, 50, 60, 70, 80]), (5, 2, [1, 2, 3, 4, 5])]) def format_output(results: List[List[int]]) -> str: Formats the list of results into a string output with each result on a new line. >>> format_output([[80, 70, 60]]) \\"80 70 60\\" >>> format_output([[80, 70, 60], [5, 4]]) \\"80 70 60n5 4\\"","solution":"import heapq def manage_shipments(T, cases): results = [] for case in cases: N, K, shipments = case if K >= N: results.append(sorted(shipments, reverse=True)[:K]) else: largest_shipments = [] for quantity in shipments: if len(largest_shipments) < K: heapq.heappush(largest_shipments, quantity) elif quantity > largest_shipments[0]: heapq.heappushpop(largest_shipments, quantity) results.append(sorted(largest_shipments, reverse=True)) return results def parse_input(input_str): lines = input_str.strip().split(\\"n\\") T = int(lines[0]) cases = [] index = 1 for _ in range(T): N, K = map(int, lines[index].split()) shipments = list(map(int, lines[index + 1].split())) cases.append((N, K, shipments)) index += 2 return T, cases def format_output(results): output_lines = [] for result in results: output_lines.append(\\" \\".join(map(str, result))) return \\"n\\".join(output_lines)"},{"question":"from typing import List def is_prime(num: int) -> bool: Determine if a given integer is a prime number. pass def count_primes(N: int, sequence: List[int]) -> int: Count how many prime numbers are in the given sequence. Args: N: The number of integers in the sequence. sequence: List of integers. Returns: The number of prime numbers in the sequence. Examples: >>> count_primes(5, [1, 2, 3, 4, 5]) 3 >>> count_primes(4, [10, 15, 17, 21]) 1 pass","solution":"def is_prime(num): if num <= 1: return False if num <= 3: return True if num % 2 == 0 or num % 3 == 0: return False i = 5 while i * i <= num: if num % i == 0 or num % (i + 2) == 0: return False i += 6 return True def count_primes(N, sequence): prime_count = 0 for num in sequence: if is_prime(num): prime_count += 1 return prime_count"},{"question":"def count_decodings(arr): Count the number of possible decoded strings from an array. >>> count_decodings([1, 2, 6]) 3 >>> count_decodings([1, 1, 2, 2]) 5 def process_input(input_string): Takes the input string containing multiple test cases and returns an array with the number of possible decoded strings for each test case. >>> process_input(\\"2n3 1 2 6n4 1 1 2 2\\") [3, 5] >>> process_input(\\"1n1 1\\") [1]","solution":"def count_decodings(arr): Count the number of possible decoded strings from an array. n = len(arr) if n == 0: return 0 if arr[0] == 0: return 0 count = [0] * (n + 1) # count[i] will be the total number of ways to decode the array up to index i-1 count[0], count[1] = 1, 1 # Base cases for i in range(2, n + 1): if arr[i - 1] > 0: count[i] += count[i - 1] if arr[i - 2] == 1 or (arr[i - 2] == 2 and arr[i - 1] <= 6): count[i] += count[i - 2] return count[n] def process_input(input_string): input_lines = input_string.strip().split('n') T = int(input_lines[0]) result = [] for i in range(1, T + 1): data = list(map(int, input_lines[i].split())) N = data[0] result.append(count_decodings(data[1:])) return result"},{"question":"def can_form_permutation_with_min_and_sum(n: int, k: int, a: List[int], b: List[int]) -> str: Determines if there exists a permutation of a such that the sum of the bitwise AND of corresponding elements of the permutation and b is at least k. Parameters: n (int): Number of elements in arrays a and b. k (int): The required minimum sum of bitwise ANDs. a (list of int): The elements of the array a. b (list of int): The elements of the array b. Returns: str: \\"YES\\" if such a permutation exists, \\"NO\\" otherwise.","solution":"def can_form_permutation_with_min_and_sum(n, k, a, b): Determines if there exists a permutation of a such that the sum of the bitwise AND of corresponding elements of the permutation and b is at least k. Parameters: n (int): Number of elements in arrays a and b. k (int): The required minimum sum of bitwise ANDs. a (list of int): The elements of the array a. b (list of int): The elements of the array b. Returns: str: \\"YES\\" if such a permutation exists, \\"NO\\" otherwise. from itertools import permutations # Generate all possible permutations of array a for perm in permutations(a): and_sum = sum(x & y for x, y in zip(perm, b)) if and_sum >= k: return \\"YES\\" return \\"NO\\""},{"question":"def find_books_with_prefix(n: int, books: List[str], prefix: str) -> List[str]: This function takes an integer n representing the number of books, a list of strings books representing the book IDs, and a string prefix. It returns a list of book IDs that start with the given prefix. If no match is found, it returns [\\"No match found\\"]. >>> find_books_with_prefix(5, [\\"BK001\\", \\"BK002\\", \\"BK003\\", \\"AN001\\", \\"AN002\\"], \\"BK\\") [\\"BK001\\", \\"BK002\\", \\"BK003\\"] >>> find_books_with_prefix(5, [\\"BK001\\", \\"BK002\\", \\"BK003\\", \\"AN001\\", \\"AN002\\"], \\"XX\\") [\\"No match found\\"]","solution":"def find_books_with_prefix(n, books, prefix): This function takes an integer n representing the number of books, a list of strings books representing the book IDs, and a string prefix. It returns a list of book IDs that start with the given prefix. If no match is found, it returns [\\"No match found\\"]. matching_books = [book for book in books if book.startswith(prefix)] if matching_books: return matching_books else: return [\\"No match found\\"]"},{"question":"def inverted_triangle(n: int) -> list: Generates an inverted right-angled triangle pattern with numbers from n to 1. :param n: A single positive integer representing the number of rows. :return: A list of strings where each string represents a row in the triangle. >>> inverted_triangle(5) [\\"5 4 3 2 1\\", \\"4 3 2 1\\", \\"3 2 1\\", \\"2 1\\", \\"1\\"] >>> inverted_triangle(3) [\\"3 2 1\\", \\"2 1\\", \\"1\\"] >>> inverted_triangle(1) [\\"1\\"]","solution":"def inverted_triangle(n): Generates an inverted right-angled triangle pattern with numbers from n to 1. :param n: A single positive integer representing the number of rows. :return: A list of strings where each string represents a row in the triangle. result = [] for i in range(n, 0, -1): row = ' '.join(str(j) for j in range(i, 0, -1)) result.append(row) return result"},{"question":"class Library: def __init__(self): self.inventory = {} def insert_book(self, book_id, title, author): Inserts a book into the inventory. pass def remove_book(self, book_id): Removes a book from the inventory by its unique identifier. pass def find_book(self, book_id): Checks if a book exists in the inventory by its unique identifier. pass def retrieve_all_titles(self): Retrieves a list of all book titles currently in the inventory in lexicographical order. pass def process_operations(operations): Processes a list of operations and returns the results for FIND and RETRIEVE_ALL operations. >>> operations = [ ... \\"INSERT 1 \\"The Catcher in the Rye\\" \\"J.D. Salinger\\"\\", ... \\"INSERT 2 \\"To Kill a Mockingbird\\" \\"Harper Lee\\"\\", ... \\"FIND 1\\", ... \\"FIND 3\\", ... \\"REMOVE 2\\", ... \\"RETRIEVE_ALL\\", ... \\"REMOVE 1\\", ... \\"RETRIEVE_ALL\\" ... ] >>> expected = [\\"YES\\", \\"NO\\", \\"The Catcher in the Rye\\", \\"\\"] >>> process_operations(operations) expected >>> operations = [ ... \\"INSERT 1 \\"The Catcher in the Rye\\" \\"J.D. Salinger\\"\\", ... \\"INSERT 2 \\"To Kill a Mockingbird\\" \\"Harper Lee\\"\\", ... \\"REMOVE 2\\", ... \\"FIND 2\\", ... \\"FIND 1\\" ... ] >>> expected = [\\"NO\\", \\"YES\\"] >>> process_operations(operations) expected >>> operations = [ ... \\"INSERT 1 \\"The Catcher in the Rye\\" \\"J.D. Salinger\\"\\", ... \\"INSERT 2 \\"To Kill a Mockingbird\\" \\"Harper Lee\\"\\", ... \\"RETRIEVE_ALL\\" ... ] >>> expected = [\\"The Catcher in the RyenTo Kill a Mockingbird\\"] >>> process_operations(operations) expected >>> operations = [ ... \\"INSERT 1 \\"The Catcher in the Rye\\" \\"J.D. Salinger\\"\\", ... \\"INSERT 2 \\"To Kill a Mockingbird\\" \\"Harper Lee\\"\\", ... \\"REMOVE 2\\", ... \\"RETRIEVE_ALL\\" ... ] >>> expected = [\\"The Catcher in the Rye\\"] >>> process_operations(operations) expected >>> operations = [ ... \\"INSERT 1 \\"The Catcher in the Rye\\" \\"J.D. Salinger\\"\\", ... \\"REMOVE 1\\", ... \\"RETRIEVE_ALL\\" ... ] >>> expected = [\\"\\"] >>> process_operations(operations) expected >>> operations = [ ... \\"INSERT 1 \\"The Catcher in the Rye\\" \\"J.D. Salinger\\"\\", ... \\"INSERT 2 \\"To Kill a Mockingbird\\" \\"Harper Lee\\"\\", ... \\"FIND 1\\", ... \\"REMOVE 1\\", ... \\"FIND 1\\", ... \\"RETRIEVE_ALL\\" ... ] >>> expected = [\\"YES\\", \\"NO\\", \\"To Kill a Mockingbird\\"] >>> process_operations(operations) expected pass","solution":"class Library: def __init__(self): self.inventory = {} def insert_book(self, book_id, title, author): self.inventory[book_id] = {'title': title, 'author': author} def remove_book(self, book_id): if book_id in self.inventory: del self.inventory[book_id] def find_book(self, book_id): return \\"YES\\" if book_id in self.inventory else \\"NO\\" def retrieve_all_titles(self): titles = [book['title'] for book in self.inventory.values()] titles.sort() return titles def process_operations(operations): library = Library() result = [] for operation in operations: op = operation.split(maxsplit=1) if op[0] == \\"INSERT\\": _, details = op book_id, title_author = details.split(maxsplit=1) title, author = title_author.split('\\" \\"') title = title.strip('\\"') author = author.strip('\\"') library.insert_book(int(book_id), title, author) elif op[0] == \\"REMOVE\\": _, book_id = op library.remove_book(int(book_id)) elif op[0] == \\"FIND\\": _, book_id = op result.append(library.find_book(int(book_id))) elif op[0] == \\"RETRIEVE_ALL\\": titles = library.retrieve_all_titles() if titles: result.append(\\"n\\".join(titles)) else: result.append(\\"\\") return result"},{"question":"from typing import List, Tuple def longest_path_in_dag(n: int, m: int, edges: List[Tuple[int, int]]) -> int: Determine the length of the longest path in a Directed Acyclic Graph (DAG). Args: n : int - Number of tasks (nodes) m : int - Number of dependencies (edges) edges : List[Tuple[int, int]] - List of directed edges (u, v) denoting task dependencies Returns: int - The length of the longest path in the DAG Examples: >>> longest_path_in_dag(5, 6, [(1, 2), (1, 3), (3, 2), (2, 4), (3, 4), (4, 5)]) 4 >>> longest_path_in_dag(4, 3, [(1, 2), (2, 3), (3, 4)]) 3 # Implement the function here # Unit tests def test_longest_path_in_dag_example_1(): n, m = 5, 6 edges = [(1, 2), (1, 3), (3, 2), (2, 4), (3, 4), (4, 5)] assert longest_path_in_dag(n, m, edges) == 4 def test_longest_path_in_dag_example_2(): n, m = 4, 3 edges = [(1, 2), (2, 3), (3, 4)] assert longest_path_in_dag(n, m, edges) == 3 def test_longest_path_in_dag_single_node(): n, m = 1, 0 edges = [] assert longest_path_in_dag(n, m, edges) == 0 def test_longest_path_in_dag_no_edges(): n, m = 3, 0 edges = [] assert longest_path_in_dag(n, m, edges) == 0 def test_longest_path_in_dag_complex_graph(): n, m = 6, 7 edges = [(1, 2), (1, 3), (2, 4), (3, 4), (4, 5), (5, 6), (1, 6)] assert longest_path_in_dag(n, m, edges) == 4","solution":"from typing import List, Tuple from collections import defaultdict, deque def longest_path_in_dag(n: int, m: int, edges: List[Tuple[int, int]]) -> int: def topological_sort(): indegree = [0] * (n + 1) for u, v in edges: indegree[v] += 1 queue = deque([i for i in range(1, n + 1) if indegree[i] == 0]) topo_order = [] while queue: node = queue.popleft() topo_order.append(node) for neighbor in graph[node]: indegree[neighbor] -= 1 if indegree[neighbor] == 0: queue.append(neighbor) return topo_order graph = defaultdict(list) for u, v in edges: graph[u].append(v) topo_order = topological_sort() dist = [0] * (n + 1) for node in topo_order: for neighbor in graph[node]: if dist[node] + 1 > dist[neighbor]: dist[neighbor] = dist[node] + 1 return max(dist) # Example usage if __name__ == \\"__main__\\": n, m = 5, 6 edges = [(1, 2), (1, 3), (3, 2), (2, 4), (3, 4), (4, 5)] print(longest_path_in_dag(n, m, edges)) # Output: 4"},{"question":"from typing import List, Tuple def travel_time(N: int, M: int, roads: List[Tuple[int, int, int]]) -> int: Calculate the minimum travel time required for Taro to visit all cities at least once and return to city 1. Args: N (int): Number of cities M (int): Number of roads roads (List[Tuple[int, int, int]]): List of tuples where each tuple contains two cities and the travel time between them Returns: int: Minimum travel time Examples: >>> travel_time(4, 6, [(1, 2, 10), (1, 3, 15), (1, 4, 20), (2, 3, 35), (2, 4, 25), (3, 4, 30)]) 80 >>> travel_time(3, 3, [(1, 2, 1), (1, 3, 3), (2, 3, 1)]) 5 pass def test_case_1(): N = 4 M = 6 roads = [ (1, 2, 10), (1, 3, 15), (1, 4, 20), (2, 3, 35), (2, 4, 25), (3, 4, 30) ] assert travel_time(N, M, roads) == 80 def test_case_2(): N = 3 M = 3 roads = [ (1, 2, 1), (1, 3, 3), (2, 3, 1) ] assert travel_time(N, M, roads) == 5 def test_case_3(): N = 2 M = 1 roads = [ (1, 2, 1000) ] assert travel_time(N, M, roads) == 2000 def test_case_4(): N = 5 M = 10 roads = [ (1, 2, 10), (1, 3, 20), (1, 4, 25), (1, 5, 30), (2, 3, 15), (2, 4, 35), (2, 5, 45), (3, 4, 10), (3, 5, 50), (4, 5, 60) ] assert travel_time(N, M, roads) == 125 def test_case_5(): N = 3 M = 3 roads = [ (1, 2, 2), (1, 3, 5), (2, 3, 2) ] assert travel_time(N, M, roads) == 9","solution":"import itertools def travel_time(N, M, roads): # Initialize adjacency matrix with large values for infinite distance travel_matrix = [[float('inf')] * N for _ in range(N)] # Fill the travel matrix with given road times for u, v, t in roads: travel_matrix[u-1][v-1] = t travel_matrix[v-1][u-1] = t # Generate all permutations of cities excluding the starting city (city 1) cities = range(1, N) min_travel_time = float('inf') for perm in itertools.permutations(cities): # Calculate the travel time for this permutation current_time = 0 current_city = 0 # We start from city 1 which corresponds to index 0 for next_city in perm: current_time += travel_matrix[current_city][next_city] current_city = next_city # Add the time to return to the starting city current_time += travel_matrix[current_city][0] # Update minimum travel time min_travel_time = min(min_travel_time, current_time) return min_travel_time"},{"question":"def nucleotide_percentages(T: int, sequences: List[str]) -> List[str]: Given T number of DNA sequences, calculates the percentage of each nucleotide (A, T, C, G) and returns a list of strings indicating the percentages for each sequence. Parameters: T (int): Number of test cases sequences (List[str]): List of DNA sequences Returns: List[str]: List of percentages for each nucleotide in format \\"A: x% T: y% C: z% G: w%\\" >>> nucleotide_percentages(2, [\\"ATCG\\", \\"AAATTTCCCGGG\\"]) [\\"A: 25.00% T: 25.00% C: 25.00% G: 25.00%\\", \\"A: 25.00% T: 25.00% C: 25.00% G: 25.00%\\"] from typing import List def test_single_nucleotide(): result = nucleotide_percentages(1, [\\"AAAA\\"]) assert result == [\\"A: 100.00% T: 0.00% C: 0.00% G: 0.00%\\"] def test_mixed_nucleotides_equal(): result = nucleotide_percentages(1, [\\"ATCG\\"]) assert result == [\\"A: 25.00% T: 25.00% C: 25.00% G: 25.00%\\"] def test_mixed_nucleotides_unequal(): result = nucleotide_percentages(1, [\\"AATGC\\"]) assert result == [\\"A: 40.00% T: 20.00% C: 20.00% G: 20.00%\\"] def test_no_nucleotides(): result = nucleotide_percentages(1, [\\"\\"]) assert result == [\\"A: 0.00% T: 0.00% C: 0.00% G: 0.00%\\"] def test_multiple_sequences(): result = nucleotide_percentages(2, [\\"ATCG\\", \\"AAATTTCCCGGG\\"]) assert result == [\\"A: 25.00% T: 25.00% C: 25.00% G: 25.00%\\", \\"A: 25.00% T: 25.00% C: 25.00% G: 25.00%\\"]","solution":"def nucleotide_percentages(T, sequences): Given T number of DNA sequences, calculates the percentage of each nucleotide (A, T, C, G) and returns a list of strings indicating the percentages for each sequence. results = [] for sequence in sequences: total_length = len(sequence) count_A = sequence.count('A') count_T = sequence.count('T') count_C = sequence.count('C') count_G = sequence.count('G') if total_length == 0: percentages = \\"A: 0.00% T: 0.00% C: 0.00% G: 0.00%\\" else: perc_A = (count_A / total_length) * 100 perc_T = (count_T / total_length) * 100 perc_C = (count_C / total_length) * 100 perc_G = (count_G / total_length) * 100 percentages = f\\"A: {perc_A:.2f}% T: {perc_T:.2f}% C: {perc_C:.2f}% G: {perc_G:.2f}%\\" results.append(percentages) return results"},{"question":"def findWays(n: int) -> int: Determines the number of distinct ways to climb a staircase with n steps, where at each step you can either climb 1 step, 2 steps, or 3 steps. Returns the result modulo 10^9 + 7. >>> findWays(3) 4 >>> findWays(4) 7","solution":"def findWays(n): MOD = 1000000007 if n == 1: return 1 elif n == 2: return 2 elif n == 3: return 4 ways = [0] * (n + 1) ways[1], ways[2], ways[3] = 1, 2, 4 for i in range(4, n + 1): ways[i] = (ways[i-1] + ways[i-2] + ways[i-3]) % MOD return ways[n]"},{"question":"import os def classify_email(subject: str, email_directories: dict) -> int: Classify the email based on its subject line by checking against pre-labeled emails in provided directories. Args: subject (str): The subject of the incoming email. email_directories (dict): A dictionary where the keys are categories and values are directory paths to labeled emails. Returns: int: Classification of the email as Spam (1), Promotion (2), or Personal (3). >>> email_directories = {'spam': 'path/to/spam', 'promotion': 'path/to/promotion', 'personal': 'path/to/personal'} >>> classify_email(\\"You've won a prize!\\", email_directories) 1 >>> classify_email(\\"Special Offer Inside!\\", email_directories) 2 >>> classify_email(\\"Lunch Plans?\\", email_directories) 3","solution":"import os def classify_email(subject, email_directories): Classify the email based on its subject line by checking against pre-labeled emails in provided directories. Args: subject (str): The subject of the incoming email. email_directories (dict): A dictionary where the keys are categories and values are directory paths to labeled emails. Returns: int: Classification of the email as Spam (1), Promotion (2), or Personal (3). for category, directory in email_directories.items(): for filename in os.listdir(directory): with open(os.path.join(directory, filename), 'r', encoding='utf-8') as file: labeled_subject = file.readline().strip() if subject == labeled_subject: if category == 'spam': return 1 elif category == 'promotion': return 2 elif category == 'personal': return 3 return 3 # Default to Personal if no match found # Example usage: # email_directories = { # 'spam': 'path/to/spam_directory', # 'promotion': 'path/to/promotion_directory', # 'personal': 'path/to/personal_directory' # } # subject = \\"Special Offer Inside!\\" # print(classify_email(subject, email_directories)) # Outputs 2"},{"question":"def max_product_subarray(arr: List[int]) -> int: Returns the maximum product of a contiguous subarray. >>> max_product_subarray([2, 3, -2, 4]) 6 >>> max_product_subarray([-2, 0, -1]) 0","solution":"def max_product_subarray(arr): Returns the maximum product of a contiguous subarray. if not arr: return 0 max_prod = min_prod = result = arr[0] for num in arr[1:]: if num < 0: max_prod, min_prod = min_prod, max_prod max_prod = max(num, max_prod * num) min_prod = min(num, min_prod * num) result = max(result, max_prod) return result"},{"question":"from typing import List def is_prime(n: int) -> bool: Helper function to determine if a number is prime. ... def is_prime_subarray(nums: List[int], k: int) -> bool: Function to check if there is a sub-array of length k in nums whose sum is a prime number. >>> is_prime_subarray([2, 3, 4, 7, 1], 3) False >>> is_prime_subarray([1, 2, 3, 4, 5], 3) False >>> is_prime_subarray([1, 2, 3, 6, 7], 3) True >>> is_prime_subarray([7], 1) True >>> is_prime_subarray([0, 0, 0], 3) False >>> is_prime_subarray([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10) False >>> is_prime_subarray([11, 3, 5, 2, 3, 7], 3) True ...","solution":"from typing import List def is_prime(n: int) -> bool: Helper function to determine if a number is prime. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def is_prime_subarray(nums: List[int], k: int) -> bool: Function to check if there is a sub-array of length k in nums whose sum is a prime number. n = len(nums) if k > n: return False # Compute the sum for first sub-array of length k current_sum = sum(nums[:k]) if is_prime(current_sum): return True # Sliding window to compute sum of next sub-arrays of length k for i in range(k, n): current_sum += nums[i] - nums[i - k] if is_prime(current_sum): return True return False"},{"question":"def count_distinct_characters(input_string: str) -> int: Returns the number of distinct characters in the input string. Args: input_string (str): A single string of lowercase English letters with a length between 1 and 1000 characters. Returns: int: The number of distinct characters in the input string. Examples: >>> count_distinct_characters(\\"abcabc\\") 3 >>> count_distinct_characters(\\"zzzzzzzzzz\\") 1 >>> count_distinct_characters(\\"abcdefghij\\") 10 # Add your code here # Example test cases assert count_distinct_characters(\\"abcdef\\") == 6 assert count_distinct_characters(\\"zzzzzzzzzz\\") == 1 assert count_distinct_characters(\\"abcabc\\") == 3 assert count_distinct_characters(\\"abcdefghijklmnopqrstuvwxyz\\") == 26 assert count_distinct_characters(\\"\\") == 0 assert count_distinct_characters(\\"a\\") == 1 large_input = \\"a\\" * 1000 assert count_distinct_characters(large_input) == 1","solution":"def count_distinct_characters(input_string): Returns the number of distinct characters in the input string. return len(set(input_string))"},{"question":"def longest_sequence(colors: str) -> int: Returns the length of the longest sequence of adjacent floats of the same color. >>> longest_sequence(\\"ABBBA\\") 3 >>> longest_sequence(\\"CCCCC\\") 5 >>> longest_sequence(\\"ABCDEABCDE\\") 1 >>> longest_sequence(\\"AAABBCCCCDDDA\\") 4 >>> longest_sequence(\\"A\\") 1 >>> longest_sequence(\\"ABABABABAB\\") 1 def process_input(input_data: str) -> List[int]: Process the input data and returns the results for each test case. >>> process_input(\\"3nABBBAnCCCCCnABCDEABCDEn\\") [3, 5, 1] >>> process_input(\\"1nAn\\") [1] >>> process_input(\\"2nAAABBCCCCDDDAnABABABABABn\\") [4, 1]","solution":"def longest_sequence(colors): Returns the length of the longest sequence of adjacent floats of the same color. max_length = 0 current_length = 1 for i in range(1, len(colors)): if colors[i] == colors[i-1]: current_length += 1 else: if current_length > max_length: max_length = current_length current_length = 1 return max(max_length, current_length) def process_input(input_data): Process the input data and returns the results for each test case. lines = input_data.strip().split('n') T = int(lines[0]) results = [] for i in range(1, T + 1): results.append(longest_sequence(lines[i])) return results"},{"question":"from typing import List def islandPerimeter(grid: List[List[int]]) -> int: Calculate the perimeter of the island in the given grid. >>> islandPerimeter([ ... [0, 1, 0, 0], ... [1, 1, 1, 0], ... [0, 1, 0, 0], ... [1, 1, 0, 0] ... ]) 16 >>> islandPerimeter([[1]]) 4 >>> islandPerimeter([[1, 0]]) 4 # your code goes here","solution":"from typing import List def islandPerimeter(grid: List[List[int]]) -> int: def is_water_or_out_of_bounds(i, j): return i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or grid[i][j] == 0 perimeter = 0 for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == 1: # Check all 4 directions if is_water_or_out_of_bounds(i-1, j): # up perimeter += 1 if is_water_or_out_of_bounds(i+1, j): # down perimeter += 1 if is_water_or_out_of_bounds(i, j-1): # left perimeter += 1 if is_water_or_out_of_bounds(i, j+1): # right perimeter += 1 return perimeter"},{"question":"def max_trees(L: int, D: int, N: int) -> int: Returns the maximum number of trees that can be planted along the road. >>> max_trees(100, 10, 15) 11 >>> max_trees(50, 7, 10) 8 >>> max_trees(20, 5, 3) 3 from solution import max_trees def test_max_trees_case1(): assert max_trees(100, 10, 15) == 11 def test_max_trees_case2(): assert max_trees(50, 7, 10) == 8 def test_max_trees_case3(): assert max_trees(20, 5, 3) == 3 def test_max_trees_max_limit(): assert max_trees(1000000000, 1, 1000000) == 1000000 def test_max_trees_long_distance(): assert max_trees(10, 20, 5) == 1 def test_max_trees_exact_fit(): assert max_trees(20, 4, 6) == 6 def test_max_trees_boundary(): assert max_trees(1, 1, 1) == 1 def test_max_trees_large_distance(): assert max_trees(100, 50, 3) == 3 def test_max_trees_more_limit_than_needed(): assert max_trees(100, 10, 20) == 11","solution":"def max_trees(L, D, N): Returns the maximum number of trees that can be planted along the road. # Calculate the total positions available for planting trees total_positions = L // D + 1 # The maximum number of trees is the minimum of total positions and the limit N return min(total_positions, N)"},{"question":"def is_match(s: str, p: str) -> str: Determines if the pattern p matches the string s with wildcard characters. ? - matches any single character * - matches any sequence of characters (including an empty sequence) >>> is_match(\\"abefcdgiescdfimde\\", \\"ab*cd?i*de\\") \\"YES\\" >>> is_match(\\"aa\\", \\"a\\") \\"NO\\" >>> is_match(\\"abcd\\", \\"a*c?b\\") \\"NO\\" >>> is_match(\\"abcde\\", \\"a*de\\") \\"YES\\" >>> is_match(\\"\\", \\"*\\") \\"YES\\" >>> is_match(\\"abcd\\", \\"abcd\\") \\"YES\\"","solution":"def is_match(s, p): Determines if the pattern p matches the string s with wildcard characters. ? - matches any single character * - matches any sequence of characters (including an empty sequence) # Initialize a 2D table to store results of subproblems dp = [[False] * (len(p) + 1) for _ in range(len(s) + 1)] # Base case: empty pattern matches empty string dp[0][0] = True # Handle patterns with '*' at the beginning for j in range(1, len(p) + 1): if p[j - 1] == '*': dp[0][j] = dp[0][j - 1] # Fill the table in bottom-up fashion for i in range(1, len(s) + 1): for j in range(1, len(p) + 1): if p[j - 1] == s[i - 1] or p[j - 1] == '?': dp[i][j] = dp[i - 1][j - 1] elif p[j - 1] == '*': dp[i][j] = dp[i - 1][j] or dp[i][j - 1] return \\"YES\\" if dp[len(s)][len(p)] else \\"NO\\""},{"question":"def min_tables_needed(n: int, x: int, chairs: List[int]) -> int: Returns the minimum number of tables needed to accommodate all guests given their chair requirements. Parameters: n (int): Number of guests. x (int): Maximum number of chairs each table can hold. chairs (List[int]): List of integers where each integer represents the number of chairs required by a guest. Returns: int: Minimum number of tables needed. Examples: >>> min_tables_needed(5, 4, [1, 2, 3, 4, 2]) 3 >>> min_tables_needed(3, 2, [2, 2, 2]) 3 >>> min_tables_needed(4, 5, [1, 1, 1, 1]) 1 >>> min_tables_needed(6, 6, [3, 3, 3, 3, 3, 3]) 3","solution":"import math def min_tables_needed(n, x, chairs): Returns the minimum number of tables needed. Parameters: n (int): Number of guests. x (int): Maximum number of chairs each table can hold. chairs (list): List of integers where each integer represents the number of chairs required by a guest. Returns: int: Minimum number of tables needed. total_chairs_needed = sum(chairs) return math.ceil(total_chairs_needed / x)"},{"question":"def max_distinct_after_removal(n: int, array: List[int]) -> int: Calculate the maximum number of distinct integers in the array after removing at most one subarray. Args: n (int): The size of the array. array (List[int]): The elements of the array. Returns: int: The maximum number of distinct integers in the array after removing the optimal subarray. Examples: >>> max_distinct_after_removal(5, [1, 2, 3, 4, 5]) 5 >>> max_distinct_after_removal(7, [1, 2, 1, 3, 4, 2, 1]) 4 >>> max_distinct_after_removal(6, [4, 4, 4, 4, 4, 4]) 1 from typing import List def test_max_distinct_after_removal_all_distinct(): n = 5 array = [1, 2, 3, 4, 5] assert max_distinct_after_removal(n, array) == 5 def test_max_distinct_after_removal_some_duplicates(): n = 7 array = [1, 2, 1, 3, 4, 2, 1] assert max_distinct_after_removal(n, array) == 4 def test_max_distinct_after_removal_all_same(): n = 6 array = [4, 4, 4, 4, 4, 4] assert max_distinct_after_removal(n, array) == 1 def test_max_distinct_after_removal_single_element(): n = 1 array = [10] assert max_distinct_after_removal(n, array) == 1 def test_max_distinct_after_removal_large_range(): n = 8 array = [1, 2, 3, 4, 5, 6, 7, 8] assert max_distinct_after_removal(n, array) == 8","solution":"def max_distinct_after_removal(n, array): from collections import defaultdict # Calculate the initial number of distinct elements initial_distinct = len(set(array)) # Store the contribution of each element in terms of frequency counts freq = defaultdict(int) for number in array: freq[number] += 1 max_distinct = initial_distinct # Start with the initial distinct count # Consider all possible subarrays for i in range(n): current_freq = defaultdict(int) for j in range(i, n): current_freq[array[j]] += 1 if current_freq[array[j]] == freq[array[j]]: max_distinct = max(max_distinct, len(freq) - len(current_freq)) return max_distinct"},{"question":"def light_on_duration(r: int, l: int, v: int) -> float: Returns the total time (in seconds) the light remains on with a precision of two decimal places. Parameters: r (int): Length of the tunnel in meters (1 ≤ r ≤ 10^4). l (int): Length of the train in meters (1 ≤ l ≤ 10^4). v (int): Speed of the train in meters per second (1 ≤ v ≤ 100). Returns: float: The time the light remains on in seconds. Examples: >>> light_on_duration(300, 100, 30) 13.33 >>> light_on_duration(5000, 500, 60) 91.67","solution":"def light_on_duration(r, l, v): Returns the total time (in seconds) the light remains on with a precision of two decimal places. Parameters: r (int): Length of the tunnel in meters (1 ≤ r ≤ 10^4). l (int): Length of the train in meters (1 ≤ l ≤ 10^4). v (int): Speed of the train in meters per second (1 ≤ v ≤ 100). Returns: float: The time the light remains on in seconds. total_length = r + l # total distance the light needs to be on time_on = total_length / v return round(time_on, 2)"},{"question":"import sys from typing import List, Tuple def min_rotations(test_cases: List[Tuple[int, List[int]]]) -> List[int]: Calculate the minimum number of rotations Petya needs to make to balance the light requirements of all leaves. Parameters: test_cases (List[Tuple[int, List[int]]]): List of test cases where each test case is a tuple containing an integer n (the number of leaves) and a list of integers representing the light requirements of each leaf. Returns: List[int]: List of integers where each integer is the minimum number of rotations for the corresponding test case. >>> min_rotations([(3, [5, 3, 2])]) [2] >>> min_rotations([(4, [4, 4, 4, 4])]) [0] >>> min_rotations([(5, [3, 1, 2, 4, 5])]) [2] >>> min_rotations([(3, [2, 1, 3])]) [1] >>> min_rotations([(3, [1, 5, 3])]) [1] pass def main(): input = sys.stdin.read() data = input.split() k = int(data[0]) index = 1 test_cases = [] for _ in range(k): n = int(data[index]) index += 1 arr = list(map(int, data[index:index + n])) index += n test_cases.append((n, arr)) results = min_rotations(test_cases) for result in results: print(result) if __name__ == \\"__main__\\": main()","solution":"def min_rotations(test_cases): results = [] for n, arr in test_cases: min_val = min(arr) min_index = arr.index(min_val) results.append(min_index) return results"},{"question":"def minimum_blocks(n: int) -> int: Determines the minimum number of blocks required to build a staircase of n steps. >>> minimum_blocks(5) == 15 >>> minimum_blocks(3) == 6 >>> minimum_blocks(1) == 1 >>> minimum_blocks(0) == 0 >>> minimum_blocks(10) == 55 >>> minimum_blocks(100) == 5050 >>> minimum_blocks(1000) == 500500 >>> minimum_blocks(1000000) == 500000500000 >>> minimum_blocks(1) == 1 >>> minimum_blocks(1000000) == 500000500000","solution":"def minimum_blocks(n): Determines the minimum number of blocks required to build a staircase of n steps. The number of blocks required for a staircase with n steps is the sum of the first n natural numbers. This sum is given by the formula: S = n * (n + 1) / 2 Args: n (int): The number of steps in the staircase. Returns: int: The minimum number of blocks required. return n * (n + 1) // 2"},{"question":"def max_packages(n: int, W: int, weights: List[int]) -> int: Determines the maximum number of packages that can be loaded onto the aircraft without exceeding the weight limit. :param n: Number of packages :param W: Weight limit of the aircraft :param weights: List of weights of the packages :return: Maximum number of packages that can be loaded >>> max_packages(5, 15, [3, 1, 6, 2, 5]) 4 >>> max_packages(4, 10, [7, 3, 5, 8]) 2","solution":"def max_packages(n, W, weights): Determines the maximum number of packages that can be loaded onto the aircraft without exceeding the weight limit. :param n: Number of packages :param W: Weight limit of the aircraft :param weights: List of weights of the packages :return: Maximum number of packages that can be loaded weights.sort() total_weight = 0 count = 0 for weight in weights: if total_weight + weight <= W: total_weight += weight count += 1 else: break return count"},{"question":"from typing import List def count_inversions(arr: List[int]) -> int: Count the number of inversions in the array where an inversion is any pair (i, j) such that i < j and arr[i] > arr[j]. :param arr: List[int] - The array of integers :return: int - The number of inversions in the array >>> count_inversions([2, 3, 8, 6, 1]) 5 >>> count_inversions([1, 20, 6, 4, 5]) 5 >>> count_inversions([1, 2, 3, 4, 5]) 0 >>> count_inversions([5, 4, 3, 2, 1]) 10 >>> count_inversions([]) 0 >>> count_inversions([1]) 0 >>> count_inversions([2, 1]) 1 pass # Your code here","solution":"def count_inversions(arr): Count the number of inversions in the array where an inversion is any pair (i, j) such that i < j and arr[i] > arr[j]. :param arr: List[int] - The array of integers :return: int - The number of inversions in the array def merge_and_count(arr, temp_arr, left, mid, right): inv_count = 0 i = left # Starting index for left subarray j = mid + 1 # Starting index for right subarray k = left # Starting index to be sorted while i <= mid and j <= right: if arr[i] <= arr[j]: temp_arr[k] = arr[i] i += 1 else: temp_arr[k] = arr[j] inv_count += (mid-i + 1) j += 1 k += 1 while i <= mid: temp_arr[k] = arr[i] i += 1 k += 1 while j <= right: temp_arr[k] = arr[j] j += 1 k += 1 for i in range(left, right + 1): arr[i] = temp_arr[i] return inv_count def merge_sort_and_count(arr, temp_arr, left, right): inv_count = 0 if left < right: mid = (left + right)//2 inv_count += merge_sort_and_count(arr, temp_arr, left, mid) inv_count += merge_sort_and_count(arr, temp_arr, mid + 1, right) inv_count += merge_and_count(arr, temp_arr, left, mid, right) return inv_count n = len(arr) temp_arr = [0]*n return merge_sort_and_count(arr, temp_arr, 0, n-1)"},{"question":"def product_of_others(lst): Takes a list of integers and returns a new list where each value is replaced by the product of all other values in the original list, without using division operations. >>> product_of_others([1, 2, 3, 4]) [24, 12, 8, 6] >>> product_of_others([1, -1, 2]) [-2, 2, -1] >>> product_of_others([0, 0, 0]) [0, 0, 0] >>> product_of_others([1, 3, 5, 7]) [105, 35, 21, 15] >>> product_of_others([2, 3]) [3, 2] >>> product_of_others([1, 0, 3]) [0, 3, 0]","solution":"def product_of_others(lst): Returns a list where each element is the product of all other elements in the input list. n = len(lst) left_products = [1] * n right_products = [1] * n for i in range(1, n): left_products[i] = left_products[i - 1] * lst[i - 1] for i in range(n - 2, -1, -1): right_products[i] = right_products[i + 1] * lst[i + 1] result = [left_products[i] * right_products[i] for i in range(n)] return result"},{"question":"def game_winner(n: int) -> str: Determine the winner of the game given n stones. >>> game_winner(1) 'Alice' >>> game_winner(2) 'Bob' >>> game_winner(7) 'Bob' >>> game_winner(16) 'Alice' >>> game_winner(20) 'Bob' >>> game_winner(25) 'Alice' >>> game_winner(1000) 'Alice'","solution":"def game_winner(n): Determine the winner of the game given n stones. import math # Determine a dynamic programming list to track winning and losing positions. dp = [False] * (n + 1) for i in range(1, n + 1): j = 1 while j * j <= i: if not dp[i - j * j]: dp[i] = True break j += 1 return \\"Alice\\" if dp[n] else \\"Bob\\""},{"question":"def can_sort_with_k_swaps(n: int, k: int, sequence: List[int]) -> str: Determines if the array can be sorted in ascending order using exactly k adjacent pairs of elements. Parameters: n (int): Number of elements in the sequence. k (int): Number of adjacent swaps allowed. sequence (List[int]): The elements of the sequence. Returns: str: \\"YES\\" if the sequence can be sorted using exactly k swaps. Otherwise, \\"NO\\". Examples: >>> can_sort_with_k_swaps(4, 3, [3, 1, 2, 4]) \\"YES\\" >>> can_sort_with_k_swaps(4, 2, [3, 1, 4, 2]) \\"NO\\" from typing import List def test_example_1(): assert can_sort_with_k_swaps(4, 3, [3, 1, 2, 4]) == \\"YES\\" def test_example_2(): assert can_sort_with_k_swaps(4, 2, [3, 1, 4, 2]) == \\"NO\\" def test_sorted_array(): assert can_sort_with_k_swaps(5, 0, [1, 2, 3, 4, 5]) == \\"YES\\" def test_reverse_sorted_array(): assert can_sort_with_k_swaps(5, 10, [5, 4, 3, 2, 1]) == \\"YES\\" assert can_sort_with_k_swaps(5, 9, [5, 4, 3, 2, 1]) == \\"NO\\" def test_single_element(): assert can_sort_with_k_swaps(1, 0, [1]) == \\"YES\\" def test_no_swaps_required(): assert can_sort_with_k_swaps(4, 3, [1, 2, 3, 4]) == \\"YES\\" assert can_sort_with_k_swaps(4, 0, [1, 2, 3, 4]) == \\"YES\\" def test_not_enough_swaps(): assert can_sort_with_k_swaps(3, 1, [3, 1, 2]) == \\"NO\\"","solution":"def can_sort_with_k_swaps(n, k, sequence): Determines if the array can be sorted using exactly k adjacent swaps. Parameters: n (int): Number of elements in the sequence. k (int): Number of adjacent swaps allowed. sequence (list of int): The elements of the sequence. Returns: str: \\"YES\\" if the sequence can be sorted using exactly k swaps. Otherwise, \\"NO\\". inversions_count = 0 # Count the number of inversions in the sequence for i in range(n): for j in range(i + 1, n): if sequence[i] > sequence[j]: inversions_count += 1 if inversions_count <= k: return \\"YES\\" return \\"NO\\""},{"question":"def trap_water(heights: List[int]) -> int: Compute how much water can be trapped after raining. Args: heights (List[int]): List of integers representing terrain heights. Returns: int: Total amount of water trapped. >>> trap_water([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) 6 >>> trap_water([4, 2, 0, 3, 2, 5]) 9 >>> trap_water([]) 0 >>> trap_water([1, 1, 1, 1]) 0 >>> trap_water([4]) 0 >>> trap_water([5, 4, 3, 2, 1]) 0 >>> trap_water([1, 2, 3, 4, 5]) 0","solution":"def trap_water(heights): if not heights: return 0 n = len(heights) left_max = [0] * n right_max = [0] * n left_max[0] = heights[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], heights[i]) right_max[n - 1] = heights[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], heights[i]) trapped_water = 0 for i in range(n): trapped_water += min(left_max[i], right_max[i]) - heights[i] return trapped_water"},{"question":"def is_bridge_balanced(t: int, test_cases: List[Tuple[Tuple[int, int], List[int]]]) -> List[str]: Determine if the bridge designs are balanced based on a given height difference threshold. Parameters: t (int): Number of test cases. test_cases (List[Tuple[Tuple[int, int], List[int]]]): A list of test cases where each test case contains a tuple with the number of stones and threshold, and a list of stone heights. Returns: List[str]: A list of results for each test case, either \\"Balanced\\" or \\"Unbalanced\\". Example: >>> is_bridge_balanced(2, [((5, 2), [3, 4, 6, 5, 8]), ((4, 1), [1, 2, 3, 5])]) [\\"Unbalanced\\", \\"Unbalanced\\"] >>> is_bridge_balanced(1, [((5, 3), [3, 6, 5, 8, 7])]) [\\"Balanced\\"]","solution":"def is_bridge_balanced(t, test_cases): results = [] for i in range(t): n, k = test_cases[i][0] heights = test_cases[i][1] balanced = True for j in range(1, n): if abs(heights[j] - heights[j-1]) > k: balanced = False break if balanced: results.append(\\"Balanced\\") else: results.append(\\"Unbalanced\\") return results"},{"question":"def paint_bucket(n: int, m: int, grid: List[List[str]], r: int, c: int, new_color: str) -> List[List[str]]: Simulates a basic paint-bucket tool in a grid-based drawing application. Fills a connected area with a specified color starting from (r, c). >>> paint_bucket(4, 4, [['R', 'G', 'B', 'G'], ['R', 'B', 'B', 'B'], ['G', 'G', 'G', 'B'], ['R', 'R', 'R', 'G']], 1, 2, 'Y') [['R', 'G', 'Y', 'G'], ['R', 'Y', 'Y', 'Y'], ['G', 'G', 'G', 'Y'], ['R', 'R', 'R', 'G']] >>> paint_bucket(3, 5, [['R', 'R', 'R', 'B', 'B'], ['R', 'R', 'R', 'B', 'B'], ['G', 'G', 'G', 'G', 'G']], 1, 1, 'G') [['G', 'G', 'G', 'B', 'B'], ['G', 'G', 'G', 'B', 'B'], ['G', 'G', 'G', 'G', 'G']] >>> paint_bucket(2, 2, [['B', 'G'], ['G', 'G']], 0, 0, 'B') [['B', 'G'], ['G', 'G']]","solution":"def paint_bucket(n, m, grid, r, c, new_color): Fills a connected area with a specified color starting from (r, c). original_color = grid[r][c] if original_color == new_color: return grid def dfs(x, y): if x < 0 or y < 0 or x >= n or y >= m or grid[x][y] != original_color: return grid[x][y] = new_color dfs(x-1, y) dfs(x+1, y) dfs(x, y-1) dfs(x, y+1) dfs(r, c) return grid # Example usage if __name__ == '__main__': n = 4 m = 4 grid = [ ['R', 'G', 'B', 'G'], ['R', 'B', 'B', 'B'], ['G', 'G', 'G', 'B'], ['R', 'R', 'R', 'G'] ] r = 1 c = 2 new_color = 'Y' result = paint_bucket(n, m, grid, r, c, new_color) for row in result: print(''.join(row))"},{"question":"def longest_sequence_of_distinct_cities(n: int, cities: List[str]) -> int: Returns the length of the longest sequence of photographs such that all photos in the sequence were taken in distinct cities. :param n: int - number of photographs :param cities: List[str] - list of city names for photographs :return: int - length of the longest sequence of distinct city names >>> longest_sequence_of_distinct_cities(7, [\\"paris\\", \\"tokyo\\", \\"paris\\", \\"newyork\\", \\"london\\", \\"newyork\\", \\"tokyo\\"]) 4 >>> longest_sequence_of_distinct_cities(3, [\\"paris\\", \\"tokyo\\", \\"london\\"]) 3 >>> longest_sequence_of_distinct_cities(1, [\\"paris\\"]) 1 >>> longest_sequence_of_distinct_cities(4, [\\"paris\\", \\"paris\\", \\"tokyo\\", \\"tokyo\\"]) 2 >>> longest_sequence_of_distinct_cities(100000, [\\"city\\" + str(i) for i in range(100000)]) 100000","solution":"def longest_sequence_of_distinct_cities(n, cities): Returns the length of the longest sequence of photographs such that all photos in the sequence were taken in distinct cities. :param n: int - number of photographs :param cities: List[str] - list of city names for photographs :return: int - length of the longest sequence of distinct city names distinct_cities = set(cities) return len(distinct_cities)"},{"question":"def smallest_missing_bib_number(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Determine the smallest possible bib number that is not in the provided list of recorded bib numbers. Args: t (int): Number of test cases. test_cases (List[Tuple[int, List[int]]]): Each test case consists of the number of recorded bib numbers and the list of recorded bib numbers. Returns: List[int]: List of the smallest possible bib numbers not in the provided lists of recorded bib numbers. Example: >>> test_cases = [ (5, [4, 2, 5, 3, 1]), (3, [2, 3, 1]), (2, [7, 8]), (1, [1000000000]) ] >>> smallest_missing_bib_number(4, test_cases) [6, 4, 1, 1] >>> test_cases = [ (5, [6, 7, 8, 9]) ] >>> smallest_missing_bib_number(1, test_cases) [1] >>> test_cases = [ (5, [1, 2, 4, 5, 5]) ] >>> smallest_missing_bib_number(1, test_cases) [3] >>> test_cases = [ (3, [1000000001, 1000000002, 1000000003]) ] >>> smallest_missing_bib_number(1, test_cases) [1] >>> test_cases = [ (1, [1]) ] >>> smallest_missing_bib_number(1, test_cases) [2]","solution":"def smallest_missing_bib_number(t, test_cases): results = [] for case in test_cases: n, bib_numbers = case[0], set(case[1:]) smallest_missing = 1 while smallest_missing in bib_numbers: smallest_missing += 1 results.append(smallest_missing) return results"},{"question":"def can_assign_unique_meanings(n: int, word_meanings: List[Tuple[str, str]]) -> str: Determine if each alien word can be uniquely matched with a scrambled meaning. >>> can_assign_unique_meanings(4, [(\\"axr\\", \\"lio\\"), (\\"bkm\\", \\"emd\\"), (\\"cwi\\", \\"przy\\"), (\\"dfo\\", \\"zynv\\")]) == \\"YES\\" >>> can_assign_unique_meanings(3, [(\\"zla\\", \\"nrt\\"), (\\"bxo\\", \\"lwz\\"), (\\"myp\\", \\"umk\\")]) == \\"YES\\" >>> can_assign_unique_meanings(3, [(\\"abc\\", \\"def\\"), (\\"def\\", \\"abc\\"), (\\"ghi\\", \\"def\\")]) == \\"NO\\"","solution":"def can_assign_unique_meanings(n, word_meanings): meaning_to_word = {} for word, meaning in word_meanings: if meaning in meaning_to_word: if meaning_to_word[meaning] != word: return \\"NO\\" else: meaning_to_word[meaning] = word return \\"YES\\""},{"question":"def max_sum_of_k_subarray(n: int, k: int, array: List[int]) -> int: Returns the maximum sum of any contiguous subarray with exactly k elements. Parameters: n (int): the number of elements in the array. k (int): the number of elements in the subarray. array (List[int]): the list of integers. Returns: int: the maximum sum of any contiguous subarray with exactly k elements. Examples: >>> max_sum_of_k_subarray(5, 3, [1, 2, 3, -2, 5]) 6 >>> max_sum_of_k_subarray(8, 3, [-1, -2, -3, -4, -5, -6, -7, -8]) -6 >>> max_sum_of_k_subarray(7, 2, [-2, 1, -1, 3, -5, 4, 2]) 6","solution":"def max_sum_of_k_subarray(n, k, array): Returns the maximum sum of any contiguous subarray with exactly k elements. Parameters: n (int): the number of elements in the array. k (int): the number of elements in the subarray. array (list of int): the list of integers. Returns: int: the maximum sum of any contiguous subarray with exactly k elements. # Calculate the sum of the first \`k\` elements current_sum = sum(array[:k]) max_sum = current_sum # Iterate from the kth element to the end of the array for i in range(k, n): current_sum += array[i] - array[i - k] if current_sum > max_sum: max_sum = current_sum return max_sum"},{"question":"def is_balanced_parentheses(s: str) -> str: Determine if the parentheses in the given string are balanced. >>> is_balanced_parentheses(\\"()\\") \\"YES\\" >>> is_balanced_parentheses(\\"(())\\") \\"YES\\" >>> is_balanced_parentheses(\\"(\\") \\"NO\\" >>> is_balanced_parentheses(\\")\\") \\"NO\\" >>> is_balanced_parentheses(\\"(()())\\") \\"YES\\" >>> is_balanced_parentheses(\\"(((())))\\") \\"YES\\" >>> is_balanced_parentheses(\\")(\\") \\"NO\\" >>> is_balanced_parentheses(\\"((())\\") \\"NO\\" >>> is_balanced_parentheses(\\"())(\\") \\"NO\\" >>> is_balanced_parentheses(\\"()((())\\") \\"NO\\" >>> is_balanced_parentheses(\\"\\") \\"YES\\" >>> is_balanced_parentheses(\\"()()\\") \\"YES\\" >>> is_balanced_parentheses(\\"(())(())\\") \\"YES\\" # Your code goes here","solution":"def is_balanced_parentheses(s: str) -> str: stack = [] for char in s: if char == '(': stack.append(char) elif char == ')': if not stack: return \\"NO\\" stack.pop() return \\"YES\\" if not stack else \\"NO\\""},{"question":"def subarray_sum_exists(n: int, t: int, a: List[int]) -> str: Determine if there exists a subarray of \`a\` such that the sum of elements in the subarray equals \`t\` and returns \\"YES\\" or \\"NO\\". >>> subarray_sum_exists(5, 9, [1, 2, 3, 4, 5]) \\"YES\\" >>> subarray_sum_exists(5, 20, [1, 2, 3, 4, 5]) \\"NO\\" >>> subarray_sum_exists(3, -1, [-1, -2, -3]) \\"YES\\"","solution":"def subarray_sum_exists(n, t, a): current_sum = 0 sum_dict = {0: 1} for num in a: current_sum += num if (current_sum - t) in sum_dict: return \\"YES\\" sum_dict[current_sum] = sum_dict.get(current_sum, 0) + 1 return \\"NO\\""},{"question":"def convert_to_numeric_sequence(s: str) -> List[int]: Convert the string to a list of numeric positions in the alphabet. For example: >>> convert_to_numeric_sequence(\\"hello\\") [8, 5, 12, 12, 15] >>> convert_to_numeric_sequence(\\"world\\") [23, 15, 18, 12, 4] pass def sum_of_digits(num: int) -> int: Sum the digits of a number until one digit remains. For example: >>> sum_of_digits(26) 8 >>> sum_of_digits(123) 6 pass def single_digit_compress(numeric_sequence: List[int]) -> int: Compress the numeric sequence to a single digit. For example: >>> single_digit_compress([8, 5, 12, 12, 15]) 7 >>> single_digit_compress([23, 15, 18, 12, 4]) 9 pass def compress_message(s: str) -> int: Compress the message by converting, summing, and compressing the numeric sequence. For example: >>> compress_message(\\"hello\\") 7 >>> compress_message(\\"world\\") 9 >>> compress_message(\\"a\\") 1 >>> compress_message(\\"zzz\\") 6 pass def test_convert_to_numeric_sequence(): assert convert_to_numeric_sequence(\\"hello\\") == [8, 5, 12, 12, 15] assert convert_to_numeric_sequence(\\"world\\") == [23, 15, 18, 12, 4] assert convert_to_numeric_sequence(\\"a\\") == [1] assert convert_to_numeric_sequence(\\"zzz\\") == [26, 26, 26] def test_sum_of_digits(): assert sum_of_digits(26) == 8 assert sum_of_digits(123) == 6 assert sum_of_digits(9) == 9 assert sum_of_digits(45) == 9 def test_single_digit_compress(): assert single_digit_compress([8, 5, 12, 12, 15]) == 7 assert single_digit_compress([23, 15, 18, 12, 4]) == 9 assert single_digit_compress([1]) == 1 assert single_digit_compress([26, 26, 26]) == 6 def test_compress_message(): assert compress_message(\\"hello\\") == 7 assert compress_message(\\"world\\") == 9 assert compress_message(\\"a\\") == 1 assert compress_message(\\"zzz\\") == 6","solution":"def convert_to_numeric_sequence(s): numeric_sequence = [] for char in s: numeric_sequence.append(ord(char) - ord('a') + 1) return numeric_sequence def sum_of_digits(num): total = 0 while num > 0: total += num % 10 num //= 10 return total def single_digit_compress(numeric_sequence): total_sum = sum(sum_of_digits(num) for num in numeric_sequence) while total_sum > 9: total_sum = sum_of_digits(total_sum) return total_sum def compress_message(s): numeric_sequence = convert_to_numeric_sequence(s) return single_digit_compress(numeric_sequence)"},{"question":"def is_palindrome(word): Check if a given word is a palindrome. # Your code here def find_sorted_palindromic_titles(n, titles): Find and sort all the palindromic titles in lexicographical order. Args: n : int : number of titles titles : list of str : list of titles Returns: list of str : sorted palindromic titles, or ['No palindromic titles found'] if there are none # Your code here # Example test cases def test_is_palindrome(): assert is_palindrome(\\"radar\\") assert is_palindrome(\\"level\\") assert not is_palindrome(\\"hello\\") assert is_palindrome(\\"deified\\") assert not is_palindrome(\\"world\\") def test_find_sorted_palindromic_titles_with_palindromes(): titles = [\\"radar\\", \\"hello\\", \\"level\\", \\"world\\", \\"deified\\"] result = find_sorted_palindromic_titles(5, titles) assert result == [\\"deified\\", \\"level\\", \\"radar\\"] def test_find_sorted_palindromic_titles_without_palindromes(): titles = [\\"cat\\", \\"dog\\", \\"fish\\"] result = find_sorted_palindromic_titles(3, titles) assert result == ['No palindromic titles found'] def test_find_sorted_palindromic_titles_with_duplicates(): titles = [\\"madam\\", \\"radar\\", \\"madam\\"] result = find_sorted_palindromic_titles(3, titles) assert result == [\\"madam\\", \\"madam\\", \\"radar\\"] def test_find_sorted_palindromic_titles_with_mixed_case(): titles = [\\"Radar\\", \\"Level\\", \\"deified\\"] # We will assume only lowercase titles are passed, as per problem statement result = find_sorted_palindromic_titles(3, [title.lower() for title in titles]) assert result == [\\"deified\\", \\"level\\", \\"radar\\"] def test_find_sorted_palindromic_titles_with_all_non_palindromes(): titles = [\\"apple\\", \\"banana\\", \\"carrot\\"] result = find_sorted_palindromic_titles(3, titles) assert result == ['No palindromic titles found']","solution":"def is_palindrome(word): Check if a given word is a palindrome. return word == word[::-1] def find_sorted_palindromic_titles(n, titles): Find and sort all the palindromic titles in lexicographical order. Args: n : int : number of titles titles : list of str : list of titles Returns: list of str : sorted palindromic titles, or ['No palindromic titles found'] if there are none palindromic_titles = [title for title in titles if is_palindrome(title)] if not palindromic_titles: return ['No palindromic titles found'] return sorted(palindromic_titles)"},{"question":"def max_length_subarray(a: List[int], x: int) -> int: Find the maximum length of any contiguous subarray such that the sum of the elements in the subarray is less than or equal to \`x\`. >>> max_length_subarray([1, 2, 3, 4, 5], 11) 4 >>> max_length_subarray([6, 7, 8, 9, 10], 5) 0 >>> max_length_subarray([5, 1, 2, 3, 8, 6, 1, 4], 15) 4","solution":"def max_length_subarray(a, x): n = len(a) max_length = 0 current_sum = 0 start = 0 for end in range(n): current_sum += a[end] while current_sum > x and start <= end: current_sum -= a[start] start += 1 max_length = max(max_length, end - start + 1) return max_length"},{"question":"def find_employee_in_charge(T: int, test_cases: List[Tuple[int, int, int]]) -> List[int]: Determines the employee ID who will be in charge on the D-th day for each test case. Parameters: T (int): Number of test cases. test_cases (list): List of tuples, each containing N (total employees), D (days), S (starting employee ID). Returns: list: List of employee IDs who will be in charge on the D-th day for each test case. Example: >>> find_employee_in_charge(1, [(5, 4, 3)]) [2] >>> find_employee_in_charge(1, [(5, 1, 1)]) [2] >>> find_employee_in_charge(1, [(5, 2, 4)]) [1] >>> find_employee_in_charge(1, [(10**9, 10**9, 1)]) [1] >>> find_employee_in_charge(2, [(5, 4, 3), (3, 3, 1)]) [2, 1] >>> find_employee_in_charge(1, [(1, 1, 1)]) [1]","solution":"def find_employee_in_charge(T, test_cases): Determines the employee ID who will be in charge on the D-th day for each test case. Parameters: T (int): Number of test cases. test_cases (list): List of tuples, each containing N (total employees), D (days), S (starting employee ID). Returns: list: List of employee IDs who will be in charge on the D-th day for each test case. results = [] for case in test_cases: N, D, S = case # Calculate the position of the employee in charge after D days. result = ((S - 1 + D) % N) + 1 results.append(result) return results"},{"question":"def manage_sensors(n: int, q: int, initial_readings: List[int], queries: List[List[int]]) -> List[str]: Manages the traffic sensor network and processes various types of queries. >>> n, q = 5, 8 >>> initial_readings = [10, 20, 30, 40, 50] >>> queries = [ [2, 1, 3], [2, 2, 5], [1, 3, 25], [2, 1, 3], [3], [1, 5, 20], [2, 4, 5], [3] ] >>> manage_sensors(n, q, initial_readings, queries) [\\"20.000000\\", \\"35.000000\\", \\"18.333333\\", \\"5 1\\", \\"30.000000\\", \\"4 1\\"] >>> n, q = 3, 1 >>> initial_readings = [5, 10, 15] >>> queries = [ [2, 1, 3] ] >>> manage_sensors(n, q, initial_readings, queries) [\\"10.000000\\"] >>> n, q = 3, 2 >>> initial_readings = [5, 10, 15] >>> queries = [ [1, 2, 7], [2, 1, 3] ] >>> manage_sensors(n, q, initial_readings, queries) [\\"9.000000\\"] >>> n, q = 3, 1 >>> initial_readings = [5, 10, 15] >>> queries = [ [3] ] >>> manage_sensors(n, q, initial_readings, queries) [\\"3 1\\"]","solution":"def manage_sensors(n, q, initial_readings, queries): from bisect import bisect_left, bisect_right import math readings = initial_readings[:] results = [] for query in queries: if query[0] == 1: # Update the i-th sensor to record v vehicles per minute from now on i, v = query[1] - 1, query[2] readings[i] = v elif query[0] == 2: # Calculate the average number of vehicles recorded by sensors in range [l, r] l, r = query[1] - 1, query[2] - 1 avg = sum(readings[l:r+1]) / (r - l + 1) results.append(f\\"{avg:.6f}\\") elif query[0] == 3: # Determine and print the sensor with the highest and lowest readings max_reading = max(readings) min_reading = min(readings) max_index = readings.index(max_reading) + 1 min_index = readings.index(min_reading) + 1 results.append(f\\"{max_index} {min_index}\\") return results # Example Usage: n, q = 5, 8 initial_readings = [10, 20, 30, 40, 50] queries = [ [2, 1, 3], [2, 2, 5], [1, 3, 25], [2, 1, 3], [3], [1, 5, 20], [2, 4, 5], [3] ] print(manage_sensors(n, q, initial_readings, queries))"},{"question":"def can_split_list(n: int, arr: List[int]) -> str: Determines if the list can be split into two non-empty sublists with equal sum. Parameters: n (int): Number of elements in the list. arr (list of int): The list of unique positive integers. Returns: str: \\"YES\\" if the list can be split into two sublists with equal sum, otherwise \\"NO\\". >>> can_split_list(4, [1, 2, 3, 4]) \\"YES\\" >>> can_split_list(3, [1, 1, 3]) \\"NO\\"","solution":"def can_split_list(n, arr): Determines if the list can be split into two non-empty sublists with equal sum. Parameters: n (int): Number of elements in the list. arr (list of int): The list of unique positive integers. Returns: str: \\"YES\\" if the list can be split into two sublists with equal sum, otherwise \\"NO\\". total_sum = sum(arr) # If the total sum is odd, we can't split into two equal integers if total_sum % 2 != 0: return \\"NO\\" target_sum = total_sum // 2 dp = [False] * (target_sum + 1) dp[0] = True for num in arr: for current_sum in range(target_sum, num - 1, -1): if dp[current_sum - num]: dp[current_sum] = True return \\"YES\\" if dp[target_sum] else \\"NO\\""},{"question":"def process_commands(N: int, Q: int, heights: List[int], commands: List[str]) -> List[int]: Process a series of commands to adjust and query the heights of sandcastles. Args: N (int): The number of sandcastles. Q (int): The number of commands. heights (List[int]): The initial heights of the sandcastles. commands (List[str]): A list of commands to process. Returns: List[int]: The results of all 'query' commands. Example: >>> process_commands(5, 5, [3, 2, 5, 1, 4], [\\"increase 1 3 2\\", \\"query 2\\", \\"decrease 2 5 1\\", \\"query 5\\", \\"query 1\\"]) [4, 3, 5] >>> process_commands(5, 2, [10, 20, 30, 40, 50], [\\"query 1\\", \\"query 5\\"]) [10, 50]","solution":"def process_commands(N, Q, heights, commands): results = [] for command in commands: parts = command.split() cmd = parts[0] if cmd == 'increase': l, r, k = int(parts[1]), int(parts[2]), int(parts[3]) for i in range(l-1, r): heights[i] += k elif cmd == 'decrease': l, r, k = int(parts[1]), int(parts[2]), int(parts[3]) for i in range(l-1, r): heights[i] -= k elif cmd == 'query': x = int(parts[1]) results.append(heights[x-1]) return results"},{"question":"def process_queries(n: int, q: int, array: List[int], queries: List[Tuple[int, int]]) -> List[int]: Given an array of integers and a series of prefix sum queries, compute the sum of array elements within specified ranges. Args: n (int): number of elements in the array q (int): number of queries array (List[int]): the elements of the array queries (List[Tuple[int, int]]): the bounds of the query ranges Returns: List[int]: the sum of the elements in the specified range for each query Example: >>> n, q = 6, 3 >>> array = [1, 2, 3, 4, 5, 6] >>> queries = [(1, 3), (2, 5), (3, 6)] >>> process_queries(n, q, array, queries) [6, 14, 18] # Unit Tests from solution import process_queries def test_example(): n, q = 6, 3 array = [1, 2, 3, 4, 5, 6] queries = [(1, 3), (2, 5), (3, 6)] assert process_queries(n, q, array, queries) == [6, 14, 18] def test_single_element(): n, q = 1, 1 array = [10] queries = [(1, 1)] assert process_queries(n, q, array, queries) == [10] def test_full_range(): n, q = 5, 1 array = [1, 2, 3, 4, 5] queries = [(1, 5)] assert process_queries(n, q, array, queries) == [15] def test_disjoint_ranges(): n, q = 8, 2 array = [1, 3, 5, 7, 9, 11, 13, 15] queries = [(1, 4), (5, 8)] assert process_queries(n, q, array, queries) == [16, 48] def test_multiple_queries(): n, q = 5, 4 array = [2, 4, 6, 8, 10] queries = [(1, 2), (2, 4), (3, 5), (1, 5)] assert process_queries(n, q, array, queries) == [6, 18, 24, 30] def test_negative_values(): n, q = 4, 2 array = [-1, -2, -3, -4] queries = [(1, 2), (1, 4)] assert process_queries(n, q, array, queries) == [-3, -10]","solution":"def process_queries(n, q, array, queries): # Calculate prefix sums prefix_sums = [0] * (n + 1) for i in range(n): prefix_sums[i + 1] = prefix_sums[i] + array[i] # Process each query results = [] for l, r in queries: results.append(prefix_sums[r] - prefix_sums[l - 1]) return results # Example usage: # n, q = 6, 3 # array = [1, 2, 3, 4, 5, 6] # queries = [(1, 3), (2, 5), (3, 6)] # result = process_queries(n, q, array, queries) # print(result) # Output should be [6, 14, 18]"},{"question":"def max_pages(pages: List[int]) -> int: Returns the maximum number of pages read during any contiguous reading session. >>> max_pages([5, 2, -1, 3, -2, 6]) == 13 >>> max_pages([-2, 1, -3, 4, -1, 2, 1, -5, 4]) == 6 >>> max_pages([1, 2, 3, 4, 5]) == 15","solution":"from typing import List def max_pages(pages: List[int]) -> int: Returns the maximum number of pages read during any contiguous reading session. max_sum = pages[0] current_sum = pages[0] for i in range(1, len(pages)): current_sum = max(pages[i], current_sum + pages[i]) max_sum = max(max_sum, current_sum) return max_sum # Examples to test the function print(max_pages([5, 2, -1, 3, -2, 6])) # Should output 13 print(max_pages([-2, 1, -3, 4, -1, 2, 1, -5, 4])) # Should output 6 print(max_pages([1, 2, 3, 4, 5])) # Should output 15"},{"question":"import math from typing import List, Tuple def point_position_against_circle(q_x: float, q_y: float, c_x: float, c_y: float, r: float) -> str: Determines whether the given point (q_x, q_y) lies inside, outside, or on the circumference of the circle defined by the center (c_x, c_y) and radius r. >>> point_position_against_circle(1.0, 1.0, 0.0, 0.0, 2.0) 'INSIDE' >>> point_position_against_circle(3.0, 3.0, 0.0, 0.0, 2.0) 'OUTSIDE' >>> point_position_against_circle(2.0, 0.0, 0.0, 0.0, 2.0) 'ON THE CIRCUMFERENCE' pass def process_datasets(datasets: List[Tuple[float, float, float, float, float]]) -> List[str]: Processes multiple datasets to determine the position of points relative to circles. >>> datasets = [ ... (1.0, 1.0, 0.0, 0.0, 2.0), ... (3.0, 3.0, 0.0, 0.0, 2.0), ... (2.0, 0.0, 0.0, 0.0, 2.0) ... ] >>> process_datasets(datasets) ['INSIDE', 'OUTSIDE', 'ON THE CIRCUMFERENCE'] pass","solution":"import math def point_position_against_circle(q_x, q_y, c_x, c_y, r): Determines whether the given point (q_x, q_y) lies inside, outside, or on the circumference of the circle defined by the center (c_x, c_y) and radius r. distance_squared = (q_x - c_x)**2 + (q_y - c_y)**2 radius_squared = r**2 if distance_squared < radius_squared: return \\"INSIDE\\" elif distance_squared > radius_squared: return \\"OUTSIDE\\" else: return \\"ON THE CIRCUMFERENCE\\" def process_datasets(datasets): results = [] for dataset in datasets: q_x, q_y, c_x, c_y, r = dataset result = point_position_against_circle(q_x, q_y, c_x, c_y, r) results.append(result) return results"},{"question":"def can_collect_resources(n: int, k: int, resources: List[int], roads: List[Tuple[int, int]]) -> Tuple[str, Union[List[int], None]]: Determines if it is possible for the king to collect and distribute all resources under the given rules, starting from the capital city. Parameters: n (int): The number of cities. k (int): The number of knights. resources (List[int]): The resources in each city. roads (List[Tuple[int, int]]): The roads represented as tuples where each tuple contains two cities. Returns: Tuple[str, Union[List[int], None]]: Returns \\"Possible\\" followed by a possible collection order of cities, or \\"Impossible\\". >>> can_collect_resources(4, 2, [12, 8, 4, 4], [(1, 2), (1, 3), (3, 4)]) (\\"Possible\\", [1, 2, 3, 4]) >>> can_collect_resources(4, 3, [11, 8, 4, 4], [(1, 2), (1, 3), (3, 4)]) \\"Impossible\\"","solution":"def can_collect_resources(n, k, resources, roads): from collections import deque, defaultdict # Adjacency list representation of the tree. tree = defaultdict(list) for u, v in roads: tree[u].append(v) tree[v].append(u) # Check if any city's resources cannot be divided by k for r in resources: if r % k != 0: return \\"Impossible\\" # BFS to collect resources in some valid order. order = [] visited = [False] * (n + 1) queue = deque([1]) # Start from city 1 (1-based indexing) visited[1] = True while queue: city = queue.popleft() order.append(city) for neighbor in tree[city]: if not visited[neighbor]: visited[neighbor] = True queue.append(neighbor) return \\"Possible\\", order # Sample Usage: n = 4 k = 2 resources = [12, 8, 4, 4] roads = [(1, 2), (1, 3), (3, 4)] print(can_collect_resources(n, k, resources, roads))"},{"question":"class QueueUsingStacks: Simulate a queue using two stacks. Operations: - enqueue(x): Inserts element x at the end of the queue. - dequeue(): Removes the element from the front of the queue and returns it. - front(): Gets the front element of the queue without removing it. >>> q = QueueUsingStacks() >>> q.enqueue(1) >>> q.enqueue(2) >>> q.front() 1 >>> q.enqueue(3) >>> q.dequeue() 1 >>> q.front() 2 >>> q.dequeue() 2 >>> q.dequeue() 3 >>> q.enqueue(4) >>> q.front() 4 >>> q.dequeue() 4 >>> q.dequeue() \\"Queue is empty\\" def enqueue(self, x): pass def dequeue(self): pass def front(self): pass # Unit tests def test_enqueue_and_front(): queue = QueueUsingStacks() queue.enqueue(1) queue.enqueue(2) assert queue.front() == 1 def test_enqueue_and_dequeue(): queue = QueueUsingStacks() queue.enqueue(1) queue.enqueue(2) assert queue.dequeue() == 1 assert queue.front() == 2 assert queue.dequeue() == 2 assert queue.dequeue() == \\"Queue is empty\\" def test_empty_queue_operations(): queue = QueueUsingStacks() assert queue.front() == \\"Queue is empty\\" assert queue.dequeue() == \\"Queue is empty\\" def test_mix_operations(): queue = QueueUsingStacks() queue.enqueue(10) queue.enqueue(20) assert queue.front() == 10 queue.enqueue(30) assert queue.dequeue() == 10 assert queue.front() == 20 queue.enqueue(40) assert queue.dequeue() == 20 assert queue.dequeue() == 30 assert queue.dequeue() == 40 assert queue.dequeue() == \\"Queue is empty\\" queue.enqueue(50) assert queue.front() == 50 assert queue.dequeue() == 50","solution":"class QueueUsingStacks: def __init__(self): self.in_stack = [] self.out_stack = [] def enqueue(self, x): self.in_stack.append(x) def dequeue(self): if not self.out_stack: while self.in_stack: self.out_stack.append(self.in_stack.pop()) if self.out_stack: return self.out_stack.pop() else: return \\"Queue is empty\\" def front(self): if not self.out_stack: while self.in_stack: self.out_stack.append(self.in_stack.pop()) if self.out_stack: return self.out_stack[-1] else: return \\"Queue is empty\\""},{"question":"def max_teams_for_different_skills(T: int, cases: List[Tuple[int, List[int]]]) -> List[int]: Determine the maximum number of teams that can be formed under the restriction that no team has participants with identical skill levels. Args: T: Number of test cases cases: List of tuples, each containing an integer N and a list of N skill levels Returns: A list of integers, each representing the maximum number of teams for each test case >>> max_teams_for_different_skills(2, [(5, [3, 1, 3, 2, 2]), (4, [1, 2, 3, 4])]) [3, 4] >>> max_teams_for_different_skills(1, [(6, [1, 2, 2, 3, 4, 4])]) [4]","solution":"def max_teams_for_different_skills(T, cases): results = [] for i in range(T): N = cases[i][0] skills = cases[i][1] unique_skills = set(skills) results.append(len(unique_skills)) return results"},{"question":"def min_energy(grid: List[List[int]]) -> int: Calculate the minimum energy required to reach the bottom-right corner from the top-left corner in a grid where each cell has a corresponding energy level. >>> grid = [ ... [1, 3, 1], ... [1, 5, 1], ... [4, 2, 1] ... ] >>> min_energy(grid) 7 >>> grid = [[0]] >>> min_energy(grid) 0 >>> grid = [ ... [1, 2, 3] ... ] >>> min_energy(grid) 6 >>> grid = [ ... [1], ... [2], ... [3] ... ] >>> min_energy(grid) 6 >>> grid = [ ... [0, 0, 0, 0], ... [0, 0, 0, 0], ... [0, 0, 0, 0] ... ] >>> min_energy(grid) 0 >>> grid = [ ... [10000, 10000], ... [10000, 10000] ... ] >>> min_energy(grid) 30000","solution":"def min_energy(grid): Calculate the minimum energy required to reach the bottom-right corner from the top-left corner. :param grid: List of lists representing the energy grid. :return: Minimum energy required to reach bottom-right corner. m = len(grid) n = len(grid[0]) # Create a dp array of the same dimensions as the grid dp = [[0] * n for _ in range(m)] # Initialize the top-left corner (start point) dp[0][0] = grid[0][0] # Initialize the first row (only can move right) for j in range(1, n): dp[0][j] = dp[0][j-1] + grid[0][j] # Initialize the first column (only can move down) for i in range(1, m): dp[i][0] = dp[i-1][0] + grid[i][0] # Fill the rest of the dp array for i in range(1, m): for j in range(1, n): dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j] return dp[m-1][n-1]"},{"question":"def find_best_team(teams: List[List[Tuple[str, int]]], threshold: int) -> Tuple[str, str]: Determine the team with the highest total skill level and its success status. >>> find_best_team([ [(\\"Alice\\", 50), (\\"Bob\\", 60), (\\"Charlie\\", 40)], [(\\"David\\", 80), (\\"Eva\\", 90)], [(\\"Frank\\", 30), (\\"Grace\\", 40), (\\"Heidi\\", 20), (\\"Ivan\\", 10)] ], 150) (\\"Team2\\", \\"Successful\\") >>> find_best_team([ [(\\"Alice\\", 40), (\\"Bob\\", 50), (\\"Charlie\\", 30)], [(\\"David\\", 60), (\\"Eva\\", 50), (\\"Frank\\", 40)] ], 120) (\\"Team2\\", \\"Successful\\") >>> find_best_team([ [(\\"Alice\\", 10), (\\"Bob\\", 20)], [(\\"Charlie\\", 15), (\\"David\\", 25)] ], 50) (\\"Team2\\", \\"Unsuccessful\\") >>> find_best_team([ [(\\"Alice\\", 50), (\\"Bob\\", 60), (\\"Charlie\\", 40)] ], 100) (\\"Team1\\", \\"Successful\\") >>> find_best_team([ [(\\"Alice\\", 50), (\\"Bob\\", 60), (\\"Charlie\\", 40)] ], 200) (\\"Team1\\", \\"Unsuccessful\\") pass","solution":"def find_best_team(teams, threshold): total_skill_levels = [] for team in teams: total_skill_levels.append(sum(skill for _, skill in team)) max_skill_level = max(total_skill_levels) best_team_index = total_skill_levels.index(max_skill_level) best_team_name = f\\"Team{best_team_index + 1}\\" if max_skill_level >= threshold: success_status = \\"Successful\\" else: success_status = \\"Unsuccessful\\" return best_team_name, success_status"},{"question":"def divide_teams_into_groups(n, m, strengths): Divides the teams into the minimum number of groups such that: - Each group has exactly m teams. - The sum of the strengths in each group is as close as possible. Parameters: n (int): Number of teams m (int): Number of teams per group strengths (list): List of team strengths Returns: tuple: g (number of groups), groups (lists of team strengths in each group) Example: >>> divide_teams_into_groups(6, 3, [4, 5, 7, 1, 9, 3]) (2, [[4, 5, 7], [1, 9, 3]]) >>> divide_teams_into_groups(5, 2, [10, 12, 15, 7, 9]) (3, [[10, 12], [15, 7], [9]])","solution":"def divide_teams_into_groups(n, m, strengths): Divides the teams into the minimum number of groups such that: - Each group has exactly m teams. - The sum of the strengths in each group is as close as possible. Parameters: n (int): Number of teams m (int): Number of teams per group strengths (list): List of team strengths Returns: tuple: g (number of groups), groups (lists of team strengths in each group) # Sort the strengths to allow for better grouping strengths.sort() # Minimum number of groups required g = (n + m - 1) // m groups = [] for i in range(g): group = [] for j in range(m): if i + j * g < n: group.append(strengths[i + j * g]) groups.append(group) return g, groups # Example usage: if __name__ == \\"__main__\\": n = 6 m = 3 strengths = [4, 5, 7, 1, 9, 3] g, groups = divide_teams_into_groups(n, m, strengths) print(g) for group in groups: print(\\" \\".join(map(str, group)))"},{"question":"def hex_grid_navigation(n: int, m: int, grid: List[List[int]]) -> int: Function to find the minimum number of steps to navigate from the top-left to the bottom-right corner in a hexagonal grid. Args: n (int): Number of rows in the hexagonal grid m (int): Number of columns in the hexagonal grid grid (List[List[int]]): The hexagonal grid where 0 represents a clear cell and 1 represents a blocked cell Returns: int: Minimum number of steps required to reach the bottom-right corner, or -1 if not possible Example: >>> hex_grid_navigation(4, 4, [ ... [0, 0, 0, 1], ... [0, 1, 0, 0], ... [0, 0, 1, 0], ... [1, 0, 0, 0] ... ]) == 6 >>> hex_grid_navigation(3, 3, [ ... [0, 1, 0], ... [1, 0, 1], ... [0, 1, 0] ... ]) == -1","solution":"from collections import deque def hex_grid_navigation(n, m, grid): Function to find the minimum number of steps to navigate from the top-left to the bottom-right corner in a hexagonal grid. if grid[0][0] == 1 or grid[n-1][m-1] == 1: return -1 directions = [(-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0)] queue = deque([(0, 0)]) visited = set((0, 0)) steps = 0 while queue: for _ in range(len(queue)): x, y = queue.popleft() if (x, y) == (n-1, m-1): return steps for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and grid[nx][ny] == 0 and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny)) steps += 1 return -1"},{"question":"def max_hermit_crabs(T: List[int]) -> int: Returns the maximum number of hermit crabs that can be collected from any contiguous subarray of traps. >>> max_hermit_crabs([-1, 2, 3, -2, 5]) 8 >>> max_hermit_crabs([-2, -3, 4, -1]) 4 >>> max_hermit_crabs([1, 2, 3, 4, 5]) 15 >>> max_hermit_crabs([-1, -2, -3, -4, -5]) -1 >>> max_hermit_crabs([1, -2, 3, 10, -4, 7, 2, -5]) 18 >>> max_hermit_crabs([5]) 5 >>> max_hermit_crabs([-5]) -5","solution":"def max_hermit_crabs(T): Returns the maximum number of hermit crabs that can be collected from any contiguous subarray of traps. max_sum = current_sum = T[0] for num in T[1:]: current_sum = max(num, current_sum + num) max_sum = max(max_sum, current_sum) return max_sum"},{"question":"def min_partitions_for_increasing_subarrays(n: int, arr: List[int]) -> int: Determine the minimum number of strictly increasing subarrays required to partition the given array. Args: n : int : Length of the array arr : List[int] : List of integers representing the array Returns: int : The minimum number of strictly increasing subarrays Examples: >>> min_partitions_for_increasing_subarrays(6, [1, 2, 3, 4, 3, 4]) 2 >>> min_partitions_for_increasing_subarrays(5, [5, 6, 3, 7, 8]) 2 >>> min_partitions_for_increasing_subarrays(7, [10, 20, 30, 40, 50, 60, 70]) 1 >>> min_partitions_for_increasing_subarrays(4, [4, 1, 2, 3]) 2","solution":"def min_partitions_for_increasing_subarrays(n, arr): if n == 0: return 0 partitions = 1 for i in range(1, n): if arr[i] <= arr[i - 1]: partitions += 1 return partitions"},{"question":"def countHeartShapedPatterns(n, m, farm_grid): Calculate the total number of \\"Heart-shaped patterns\\" on the farm. A \\"Heart-shaped pattern\\" consists of a single cell completely filled with crops ('C'). Args: n (int): The number of rows in the farm. m (int): The number of columns in the farm. farm_grid (List[str]): The description of the farm plot. Returns: int: The number of \\"Heart-shaped patterns\\" in the farm. Examples: >>> countHeartShapedPatterns(3, 3, ['C.C', '...', 'C.C']) 4 >>> countHeartShapedPatterns(2, 2, ['CC', 'C.']) 3 >>> countHeartShapedPatterns(1, 1, ['C']) 1 >>> countHeartShapedPatterns(2, 2, ['..', '..']) 0 >>> countHeartShapedPatterns(2, 3, ['CCC', 'CCC']) 6","solution":"def countHeartShapedPatterns(n, m, farm_grid): heart_count = 0 for row in farm_grid: heart_count += row.count('C') return heart_count # Example usage if __name__ == \\"__main__\\": import sys input = sys.stdin.read data = input().split() n = int(data[0]) m = int(data[1]) farm_grid = [] index = 2 for i in range(n): farm_grid.append(data[index + i]) print(countHeartShapedPatterns(n, m, farm_grid))"},{"question":"def max_sweetness_sum(n: int, sweetness: List[int]) -> int: Finds the maximum sum of sweetness values from any contiguous subarray where no two consecutive zero sweetness values are included. >>> max_sweetness_sum(9, [-2, 1, -3, 4, -1, 2, 1, -5, 4]) 6 >>> max_sweetness_sum(5, [1, 2, 3, 4, 5]) 15 >>> max_sweetness_sum(6, [1, 0, 2, 0, 3, 0]) 6 >>> max_sweetness_sum(6, [1, 0, 0, 2, 3, 4]) 9 >>> max_sweetness_sum(4, [-1, -2, -3, -4]) -1 >>> max_sweetness_sum(4, [0, 0, 0, 0]) 0 >>> max_sweetness_sum(9, [0, -2, 3, 0, 0, 4, -1, 2, 1]) 6","solution":"def max_sweetness_sum(n, sweetness): Finds the maximum sum of sweetness values from any contiguous subarray where no two consecutive zero sweetness values are included. if n == 0: return 0 # Initialize variables max_sum = float('-inf') current_sum = 0 prev_zero = False for i in range(n): if sweetness[i] == 0 and prev_zero: # Reset current_sum if two consecutive zeroes found current_sum = 0 else: current_sum += sweetness[i] if sweetness[i] == 0: prev_zero = True else: prev_zero = False # Update max_sum if current_sum is higher if current_sum > max_sum: max_sum = current_sum # Reset current_sum if it drops below zero as we are only interested in positive sums if current_sum < 0: current_sum = 0 return max_sum"},{"question":"def find_secure_substring(n: int, binary_string: str) -> tuple: Finds the first position of a secure substring of maximum possible length, where an ID is considered secure if no subsequence of its bits forms a palindrome longer than 1 bit. >>> find_secure_substring(5, \\"10101\\") (1, 1) >>> find_secure_substring(8, \\"10011001\\") (1, 1) >>> find_secure_substring(4, \\"1111\\") (1, 1)","solution":"def find_secure_substring(n, binary_string): Finds the first position of a secure substring of maximum possible length, where an ID is considered secure if no subsequence of its bits forms a palindrome longer than 1 bit. # Since any possible substring of length > 1 will have palindrome subsequences, # the maximal secure substring is any individual character. return 1, 1"},{"question":"def word_to_code(word: str) -> str: Converts a word to its corresponding ASCII code representation. >>> word_to_code(\\"abc\\") \\"979899\\" >>> word_to_code(\\"def\\") \\"100101102\\" >>> word_to_code(\\"z\\") \\"122\\" >>> word_to_code(\\"word\\") \\"119111114100\\" def min_number_of_groups(test_cases: List[List[str]]) -> List[int]: For each test case, determines the minimum number of groups required such that no two words within the same group have the same code. >>> min_number_of_groups([[\\"abc\\", \\"def\\", \\"ghi\\"], [\\"abc\\", \\"bac\\", \\"cab\\", \\"abc\\"]]) [1, 2]","solution":"def word_to_code(word): Converts a word to its corresponding ASCII code representation. return ''.join(str(ord(char)) for char in word) def min_number_of_groups(test_cases): For each test case, determines the minimum number of groups required such that no two words within the same group have the same code. results = [] for words in test_cases: code_count = {} for word in words: code = word_to_code(word) if code in code_count: code_count[code] += 1 else: code_count[code] = 1 # The number of groups required is determined by the max frequency of any code max_frequency = max(code_count.values()) results.append(max_frequency) return results"},{"question":"def book_reading_application(commands): Process a list of commands related to reading books and querying the last page read. >>> book_reading_application([\\"READ harry_potter 120\\", \\"READ the_great_gatsby 45\\", \\"QUERY harry_potter\\", \\"QUERY the_great_gatsby\\"]) [120, 45] >>> book_reading_application([\\"READ harry_potter 120\\", \\"QUERY harry_potter\\", \\"READ harry_potter 150\\", \\"QUERY harry_potter\\"]) [120, 150] >>> book_reading_application([\\"READ harry_potter 120\\", \\"QUERY unknown_book\\"]) [\\"Book not started\\"] >>> book_reading_application([\\"READ Harry_Potter 120\\", \\"READ harry_potter 85\\", \\"QUERY Harry_Potter\\", \\"QUERY harry_potter\\"]) [120, 85] >>> book_reading_application([\\"READ book1 10\\", \\"READ book2 20\\", \\"READ book1 30\\", \\"QUERY book1\\", \\"QUERY book2\\", \\"QUERY book3\\"]) [30, 20, \\"Book not started\\"] pass","solution":"def book_reading_application(commands): Process a list of commands related to reading books and querying the last page read. book_tracks = {} results = [] for command in commands: parts = command.split() cmd_type = parts[0] book_name = parts[1] if cmd_type == \\"READ\\": page_number = int(parts[2]) book_tracks[book_name] = page_number elif cmd_type == \\"QUERY\\": if book_name in book_tracks: results.append(book_tracks[book_name]) else: results.append(\\"Book not started\\") return results"},{"question":"def append(arr, num): Appends the integer num to the end of the array arr and returns the new array. >>> append([1, 2, 3], 4) [1, 2, 3, 4] def merge(arr1, arr2): Merges two arrays arr1 and arr2 into a single array by placing arr2 after arr1 and returns the new array. >>> merge([1, 2], [3, 4]) [1, 2, 3, 4] def reverse(arr): Reverses the elements of the array arr and returns the new array. >>> reverse([1, 2, 3]) [3, 2, 1] def getrange(arr, start, end, step=1): Gets a portion of the array arr starting from index start up to index end (inclusive) and returns the resulting array. Only includes elements at every step index if step is provided. >>> getrange([10, 20, 30, 40, 50], 2, 5, 2) [20, 40] def evaluate_expression(expression): Given an expression containing only arrays using the append, merge, reverse, or getrange functions, evaluate the expression and return the resulting array. >>> evaluate_expression('append([1,2,3], 4)') [1, 2, 3, 4] >>> evaluate_expression('merge([1,2,3], reverse([4,5,6]))') [1, 2, 3, 6, 5, 4] >>> evaluate_expression('reverse(merge([1,2], getrange([3,4,5,6], 2, 4, 1)))') [6, 5, 4, 2, 1] >>> evaluate_expression('getrange([10,20,30,40,50], 2, 5, 2)') [20, 40]","solution":"def append(arr, num): return arr + [num] def merge(arr1, arr2): return arr1 + arr2 def reverse(arr): return arr[::-1] def getrange(arr, start, end, step=1): return arr[start-1:end:step] def evaluate_expression(expression): expression = expression.lower() return eval(expression)"},{"question":"from typing import List, Tuple def compute_final_scores(t: int, submissions: List[Tuple[str, str, int]]) -> List[Tuple[str, int]]: Compute the final scores for each participant given a list of submissions. Each submission includes the participant's name, the name of the challenge, and the score of the submission. Each participant's final score is the sum of their best (highest scored) submission per challenge. Parameters: t (int): The number of submissions. submissions (List[Tuple[str, str, int]]): A list of tuples where each tuple contains a participant's name, the challenge name, and the participant's score. Returns: List[Tuple[str, int]]: A list of tuples where each tuple contains a participant's name and their total score, sorted by total score in descending order. If two participants have the same total score, they are sorted by name in ascending order. >>> t = 7 >>> submissions = [(\\"Alice\\", \\"Challenge1\\", 80), (\\"Bob\\", \\"Challenge1\\", 90), (\\"Alice\\", \\"Challenge2\\", 50), (\\"Alice\\", \\"Challenge1\\", 85), (\\"Bob\\", \\"Challenge2\\", 50), (\\"Bob\\", \\"Challenge1\\", 70), (\\"Alice\\", \\"Challenge2\\", 55)] >>> compute_final_scores(t, submissions) [('Alice', 140), ('Bob', 140)] >>> t = 3 >>> submissions = [(\\"Alice\\", \\"Challenge1\\", 80), (\\"Bob\\", \\"Challenge1\\", 80), (\\"Alice\\", \\"Challenge2\\", 50)] >>> compute_final_scores(t, submissions) [('Alice', 130), ('Bob', 80)] >>> t = 4 >>> submissions = [(\\"Alice\\", \\"Challenge1\\", 80), (\\"Alice\\", \\"Challenge1\\", 80), (\\"Alice\\", \\"Challenge2\\", 60), (\\"Alice\\", \\"Challenge2\\", 60)] >>> compute_final_scores(t, submissions) [('Alice', 140)] >>> t = 1 >>> submissions = [(\\"Alice\\", \\"Challenge1\\", 80)] >>> compute_final_scores(t, submissions) [('Alice', 80)] >>> t = 0 >>> submissions = [] >>> compute_final_scores(t, submissions) []","solution":"def compute_final_scores(t, submissions): from collections import defaultdict participant_scores = defaultdict(lambda: defaultdict(int)) # Process the submissions for p, c, s in submissions: participant_scores[p][c] = max(participant_scores[p][c], s) # Calculate the total score for each participant final_scores = {} for participant, challenges in participant_scores.items(): final_scores[participant] = sum(challenges.values()) # Sort participants first by total score (descending), then by name (ascending) sorted_final_scores = sorted(final_scores.items(), key=lambda x: (-x[1], x[0])) return sorted_final_scores"},{"question":"def min_operations_to_equalize(nums): Returns the number of increments needed to make all elements in the array equal. >>> min_operations_to_equalize([1, 2, 3]) 3 >>> min_operations_to_equalize([4, 4, 4]) 0 >>> min_operations_to_equalize([7, 7, 9, 8]) 3 def process_test_cases(T, test_cases): Processes multiple test cases and returns the results. >>> process_test_cases(2, [(3, [1, 2, 3]), (4, [7, 7, 9, 8])]) [3, 3] >>> process_test_cases(1, [(5, [5, 5, 5, 5, 5])]) [0]","solution":"def min_operations_to_equalize(nums): Returns the number of increments needed to make all elements in the array equal. min_val = min(nums) operations = sum(num - min_val for num in nums) return operations def process_test_cases(T, test_cases): results = [] for i in range(T): N = test_cases[i][0] nums = test_cases[i][1] results.append(min_operations_to_equalize(nums)) return results"},{"question":"from typing import List, Tuple class TreeDistance: def __init__(self, n: int): pass def add_edge(self, u: int, v: int) -> None: pass def place_object(self, i: int) -> None: pass def remove_object(self, i: int) -> None: pass def find_shortest_distance(self) -> int: pass def process_tree_queries(n: int, edges: List[Tuple[int, int]], queries: List[Tuple[int, ...]]) -> List[int]: Process a list of queries on an undirected tree to place/remove objects and find the shortest distance between the closest pair of nodes containing objects. :param n: Number of nodes in the tree :param edges: A list of tuples where each tuple contains two integers representing an edge between nodes :param queries: A list of queries of types (1 i), (2 i), (3) :return: A list of results for each query of type 3 pass def test_example_case(): n = 5 edges = [(1, 2), (1, 3), (2, 4), (2, 5)] queries = [(1, 2), (1, 5), (3,), (2, 2), (3,), (2, 5), (3,)] expected = [1, -1, -1] result = process_tree_queries(n, edges, queries) assert result == expected def test_no_objects(): n = 4 edges = [(1, 2), (2, 3), (3, 4)] queries = [(3,)] expected = [-1] result = process_tree_queries(n, edges, queries) assert result == expected def test_single_object(): n = 4 edges = [(1, 2), (2, 3), (3, 4)] queries = [(1, 2), (3,)] expected = [-1] result = process_tree_queries(n, edges, queries) assert result == expected def test_two_objects(): n = 4 edges = [(1, 2), (2, 3), (3, 4)] queries = [(1, 1), (1, 4), (3,)] expected = [3] result = process_tree_queries(n, edges, queries) assert result == expected def test_multiple_distances(): n = 6 edges = [(1, 2), (2, 3), (3, 4), (4, 5), (3, 6)] queries = [(1, 6), (1, 5), (1, 2), (3,)] expected = [2] result = process_tree_queries(n, edges, queries) assert result == expected","solution":"from collections import defaultdict, deque import heapq import sys sys.setrecursionlimit(200000) class TreeDistance: def __init__(self, n): self.n = n self.edges = defaultdict(list) self.objects = set() self.distances = {} def add_edge(self, u, v): self.edges[u].append(v) self.edges[v].append(u) def place_object(self, i): self.objects.add(i) def remove_object(self, i): self.objects.discard(i) def bfs(self, start): dist = {start: 0} queue = deque([start]) while queue: node = queue.popleft() for neighbor in self.edges[node]: if neighbor not in dist: dist[neighbor] = dist[node] + 1 queue.append(neighbor) return dist def find_shortest_distance(self): if len(self.objects) < 2: return -1 min_distance = float('inf') for obj in self.objects: obj_distances = self.bfs(obj) for other_obj in self.objects: if obj != other_obj: min_distance = min(min_distance, obj_distances[other_obj]) return min_distance if min_distance != float('inf') else -1 def process_tree_queries(n, edges, queries): tree = TreeDistance(n) for u, v in edges: tree.add_edge(u, v) results = [] for query in queries: if query[0] == 1: tree.place_object(query[1]) elif query[0] == 2: tree.remove_object(query[1]) elif query[0] == 3: results.append(tree.find_shortest_distance()) return results"},{"question":"def min_moves_to_non_decreasing_sequence(N: int, heights: List[int]) -> int: Find the minimum number of students that need to be moved to form a non-decreasing sequence of heights. Parameters: N : int : the number of students heights : list : a list of N integers representing the heights of the students Returns: int : minimum number of students that need to be moved >>> min_moves_to_non_decreasing_sequence(5, [4, 2, 3, 1, 5]) 2 >>> min_moves_to_non_decreasing_sequence(5, [5, 5, 5, 5, 5]) 0 >>> min_moves_to_non_decreasing_sequence(5, [1, 2, 3, 4, 5]) 0 >>> min_moves_to_non_decreasing_sequence(5, [5, 4, 3, 2, 1]) 4 >>> min_moves_to_non_decreasing_sequence(2, [1, 2]) 0 >>> min_moves_to_non_decreasing_sequence(2, [2, 1]) 1","solution":"def min_moves_to_non_decreasing_sequence(N, heights): Returns the minimum number of students that need to be moved to form a non-decreasing sequence of heights. Parameters: N : int : the number of students heights : list : a list of N integers representing the heights of the students Returns: int : minimum number of students that need to be moved # Initialize an array (dp) to keep track of the length of the longest # non-decreasing subsequence ending at each index. dp = [1] * N for i in range(1, N): for j in range(i): if heights[i] >= heights[j]: dp[i] = max(dp[i], dp[j] + 1) # The length of the longest non-decreasing subsequence longest_non_decreasing_subseq_length = max(dp) # The minimum number of students to move is the total number of students # minus the length of the longest non-decreasing subsequence. return N - longest_non_decreasing_subseq_length"},{"question":"from typing import List, Tuple def base7_addition(pairs: List[Tuple[str, str]]) -> List[str]: Perform addition on pairs of base-7 numeral strings and return the results in base-7 format. Args: pairs : List[Tuple[str, str]] A list of tuples where each tuple contains two base-7 numeral strings. Returns: List[str] A list of base-7 numeral strings representing the addition results. Example: >>> base7_addition([(\\"10\\", \\"6\\"), (\\"4\\", \\"3\\"), (\\"100\\", \\"2\\")]) [\\"16\\", \\"10\\", \\"102\\"] >>> base7_addition([(\\"0\\", \\"0\\"), (\\"0\\", \\"1\\"), (\\"1\\", \\"0\\")]) [\\"0\\", \\"1\\", \\"1\\"]","solution":"def base7_addition(pairs): results = [] for a, b in pairs: # Convert base-7 strings to base-10 integers a_base10 = int(a, 7) b_base10 = int(b, 7) # Perform addition in base-10 sum_base10 = a_base10 + b_base10 # Convert the sum back to base-7 sum_base7 = '' while sum_base10 > 0: sum_base7 = str(sum_base10 % 7) + sum_base7 sum_base10 //= 7 results.append(sum_base7 if sum_base7 else '0') return results"},{"question":"def rearrange_sentences(sentences): Receives a list of sentences and returns a list where each sentence's words are rearranged alphabetically. pass def process_test_cases(test_cases): Process multiple test cases and returns sentences with words rearranged alphabetically for each test case. pass import pytest def test_rearrange_sentences(): assert rearrange_sentences([\\"the quick brown fox\\"]) == [\\"brown fox quick the\\"] assert rearrange_sentences([\\"lazy dog jumps over\\"]) == [\\"dog jumps lazy over\\"] assert rearrange_sentences([\\"a b c\\"]) == [\\"a b c\\"] assert rearrange_sentences([\\"cc bb aa\\"]) == [\\"aa bb cc\\"] assert rearrange_sentences([\\"one word\\"]) == [\\"one word\\"] assert rearrange_sentences([\\"\\"]) == [\\"\\"] def test_process_test_cases(): input_cases = [\\"the quick brown fox\\", \\"lazy dog jumps over\\"] expected_output = [\\"brown fox quick the\\", \\"dog jumps lazy over\\"] assert process_test_cases(input_cases) == expected_output input_cases = [\\"a b c\\", \\"cc bb aa\\", \\"one word\\", \\"\\"] expected_output = [\\"a b c\\", \\"aa bb cc\\", \\"one word\\", \\"\\"] assert process_test_cases(input_cases) == expected_output input_cases = [\\"abc def ghi\\", \\"ghi def abc\\"] expected_output = [\\"abc def ghi\\", \\"abc def ghi\\"] assert process_test_cases(input_cases) == expected_output","solution":"def rearrange_sentences(sentences): Receives a list of sentences and returns a list where each sentence's words are rearranged alphabetically. rearranged_sentences = [] for sentence in sentences: words = sentence.split() words.sort() rearranged_sentences.append(' '.join(words)) return rearranged_sentences def process_test_cases(test_cases): Process multiple test cases and returns sentences with words rearranged alphabetically for each test case. results = [] for sentence in test_cases: results.extend(rearrange_sentences([sentence])) return results"},{"question":"def find_common_elements(t: int, test_cases: List[Tuple[int, List[int], int, List[int]]]) -> List[List[int]]: Given the number of test cases and the test cases themselves, returns the common elements in the two binary search trees for each test case. :param t: Number of test cases :param test_cases: List of test cases, where each test case is a tuple containing: (n1, BST1_nodes, n2, BST2_nodes) :return: List of lists, where each list contains the sorted common elements in the respective test case. >>> find_common_elements(2, [ ... (5, [10, 20, 5, 15, 30], 4, [20, 15, 40, 50]), ... (3, [7, 3, 1], 3, [3, 1, 5]) ... ]) [[15, 20], [1, 3]] >>> find_common_elements(1, [ ... (3, [1, 2, 3], 3, [4, 5, 6]) ... ]) [[]] >>> find_common_elements(1, [ ... (3, [1, 2, 3], 0, []) ... ]) [[]] >>> find_common_elements(1, [ ... (1, [1], 1, [1]) ... ]) [[1]] >>> find_common_elements(1, [ ... (7, [2, 4, 6, 8, 10, 12, 14], 5, [4, 6, 8, 10, 16]) ... ]) [[4, 6, 8, 10]]","solution":"def find_common_elements(t, test_cases): Given the number of test cases and the test cases themselves, returns the common elements in the two binary search trees for each test case. :param t: Number of test cases :param test_cases: List of test cases, where each test case is a tuple containing: (n1, BST1_nodes, n2, BST2_nodes) :return: List of lists, where each list contains the sorted common elements in the respective test case. results = [] for i in range(t): n1, bst1_nodes, n2, bst2_nodes = test_cases[i] set_bst1 = set(bst1_nodes) set_bst2 = set(bst2_nodes) common_elements = sorted(set_bst1.intersection(set_bst2)) results.append(common_elements) return results"},{"question":"def max_coins(grid: List[List[int]]) -> int: Calculate the maximum score possible by collecting coins. >>> max_coins([ ... [1, 3, 1], ... [1, 5, 1], ... [4, 2, 1] ... ]) 12 >>> max_coins([ ... [5] ... ]) 5 def test_max_coins_small_grid(): grid = [ [1, 3, 1], [1, 5, 1], [4, 2, 1] ] assert max_coins(grid) == 12 def test_max_coins_single_element(): grid = [ [5] ] assert max_coins(grid) == 5 def test_max_coins_row_vector(): grid = [ [1, 2, 3] ] assert max_coins(grid) == 6 def test_max_coins_col_vector(): grid = [ [1], [2], [3] ] assert max_coins(grid) == 6 def test_max_coins_large_grid(): grid = [ [1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16] ] assert max_coins(grid) == 73 def test_max_coins_no_coins(): grid = [ [0, 0], [0, 0] ] assert max_coins(grid) == 0","solution":"def max_coins(grid): if not grid or not grid[0]: return 0 n = len(grid) m = len(grid[0]) dp = [[0] * m for _ in range(n)] dp[0][0] = grid[0][0] for i in range(1, n): dp[i][0] = dp[i - 1][0] + grid[i][0] for j in range(1, m): dp[0][j] = dp[0][j - 1] + grid[0][j] for i in range(1, n): for j in range(1, m): dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + grid[i][j] return dp[n - 1][m - 1] # Example usage n, m = 3, 3 grid = [ [1, 3, 1], [1, 5, 1], [4, 2, 1] ] print(max_coins(grid)) # Output: 12"},{"question":"def compute_tiles(n, p): Compute the number of large and small tiles needed to cover the backyard. n: int - side length of the square backyard in meters p: int - number of packs of large tiles available (each pack contains two large tiles) Returns: Tuple (int, int) - number of large tiles used, number of small tiles used >>> compute_tiles(4, 3) (6, 4) >>> compute_tiles(5, 4) (8, 9) >>> compute_tiles(1, 0) (0, 1) >>> compute_tiles(2, 1) (2, 0) >>> compute_tiles(3, 10) (4, 1) >>> compute_tiles(5, 0) (0, 25) >>> compute_tiles(10, 30) (50, 0)","solution":"def compute_tiles(n, p): Compute the number of large and small tiles needed to cover the backyard. n: int - side length of the square backyard in meters p: int - number of packs of large tiles available (each pack contains two large tiles) Returns: Tuple (int, int) - number of large tiles used, number of small tiles used total_area = n * n large_tiles_available = p * 2 large_tile_area_covered = large_tiles_available * 2 if large_tile_area_covered > total_area: large_tiles_usable = total_area // 2 else: large_tiles_usable = large_tiles_available small_tiles_needed = total_area - large_tiles_usable * 2 return (large_tiles_usable, small_tiles_needed)"},{"question":"def count_visible_buildings(n: int, altitudes: List[int]) -> int: Count the number of buildings visible during the Sunlight Festival. Args: n : int : number of buildings altitudes : list of int : altitudes of the buildings Returns: int : number of buildings visible >>> count_visible_buildings(6, [4, 2, 3, 1, 5, 6]) 3 >>> count_visible_buildings(5, [1, 2, 3, 2, 1]) 3 from typing import List def test_single_building(): assert count_visible_buildings(1, [5]) == 1 def test_all_increasing(): assert count_visible_buildings(5, [1, 2, 3, 4, 5]) == 5 def test_all_decreasing(): assert count_visible_buildings(5, [5, 4, 3, 2, 1]) == 1 def test_mixed_heights(): assert count_visible_buildings(6, [4, 2, 3, 1, 5, 6]) == 3 def test_mixed_heights_2(): assert count_visible_buildings(5, [1, 2, 3, 2, 1]) == 3 def test_all_same_height(): assert count_visible_buildings(5, [1, 1, 1, 1, 1]) == 1 def test_alternate_buildings_visible(): assert count_visible_buildings(6, [1, 3, 2, 5, 4, 7]) == 4","solution":"def count_visible_buildings(n, altitudes): Count the number of buildings visible during the Sunlight Festival. Args: n : int : number of buildings altitudes : list of int : altitudes of the buildings Returns: int : number of buildings visible # Initialize the count of visible buildings visible_count = 0 # Initialize the highest building seen so far max_height = 0 # Iterate through each building for altitude in altitudes: if altitude > max_height: visible_count += 1 max_height = altitude return visible_count"},{"question":"def min_subarray_length(n: int, s: int, data: List[int]) -> int: Returns the minimum length of a subarray whose sum is at least s. If no such subarray exists, returns 0. Args: n : int : number of elements in data s : int : target sum data : List[int] : list of integers Returns: int : minimum length of required subarray, or 0 if no such subarray exists. from solution import min_subarray_length def test_example_1(): assert min_subarray_length(10, 15, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == 2 def test_example_2(): assert min_subarray_length(5, 11, [1, 1, 1, 1, 1]) == 0 def test_minimal_length(): assert min_subarray_length(1, 1, [1]) == 1 def test_no_subarray(): assert min_subarray_length(5, 100, [1,2,3,4,5]) == 0 def test_entire_array(): assert min_subarray_length(5, 15, [1,2,3,4,5]) == 5 def test_large_numbers(): assert min_subarray_length(3, 100000, [100000, 100000, 100000]) == 1 def test_large_input(): large_input = [1] * 100000 assert min_subarray_length(100000, 100000, large_input) == 100000","solution":"def min_subarray_length(n, s, data): Returns the minimum length of a subarray whose sum is at least s. If no such subarray exists, returns 0. Args: n : int : number of elements in data s : int : target sum data : List[int] : list of integers Returns: int : minimum length of required subarray, or 0 if no such subarray exists. start = 0 end = 0 current_sum = 0 min_length = float('inf') while end < n: current_sum += data[end] while current_sum >= s: min_length = min(min_length, end - start + 1) current_sum -= data[start] start += 1 end += 1 return min_length if min_length != float('inf') else 0"},{"question":"from typing import List def count_exact_matches(secret: str, guesses: List[str]) -> List[int]: Returns a list of integers where each integer represents the count of exact matches for the corresponding guess. >>> count_exact_matches(\\"1234\\", [\\"1234\\", \\"1234\\"]) [4, 4] >>> count_exact_matches(\\"1234\\", [\\"5678\\", \\"4321\\"]) [0, 0] >>> count_exact_matches(\\"1234\\", [\\"1256\\", \\"1278\\"]) [2, 2] >>> count_exact_matches(\\"1234\\", [\\"1256\\", \\"1234\\", \\"4321\\", \\"5678\\"]) [2, 4, 0, 0] >>> count_exact_matches(\\"9876\\", [\\"9876\\", \\"1876\\", \\"9776\\", \\"1234\\"]) [4, 3, 3, 0]","solution":"from typing import List def count_exact_matches(secret: str, guesses: List[str]) -> List[int]: Returns a list of integers where each integer represents the count of exact matches for the corresponding guess. result = [] for guess in guesses: matches = sum(1 for s, g in zip(secret, guess) if s == g) result.append(matches) return result"},{"question":"def knight_moves(x: int, y: int) -> list: Returns a sorted list of valid knight moves from position (x, y) on a chessboard. Each move is represented as a tuple (row, column). >>> knight_moves(4, 4) [(2, 3), (2, 5), (3, 2), (3, 6), (5, 2), (5, 6), (6, 3), (6, 5)] >>> knight_moves(1, 1) [(2, 3), (3, 2)]","solution":"def knight_moves(x, y): Returns a sorted list of valid knight moves from position (x, y) on a chessboard. Each move is represented as a tuple (row, column). # Valid knight moves (L-shaped) knight_moves = [ (2, 1), (1, 2), (-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, -1) ] # Validate and collect moves valid_moves = [] for move in knight_moves: new_x, new_y = x + move[0], y + move[1] if 1 <= new_x <= 8 and 1 <= new_y <= 8: valid_moves.append((new_x, new_y)) # Sort by row and then by column valid_moves.sort() return valid_moves"},{"question":"def can_be_made_identical(n: int, s: str, t: str) -> str: Determines if two strings s and t can be made identical by swapping characters. :param n: Length of the strings (1 ≤ n ≤ 100) :param s: First string :param t: Second string :return: \\"Yes\\" if it is possible to make \`s\` and \`t\` identical, otherwise \\"No\\" >>> can_be_made_identical(5, \\"abcde\\", \\"edcba\\") \\"Yes\\" >>> can_be_made_identical(4, \\"aabb\\", \\"abab\\") \\"Yes\\" >>> can_be_made_identical(3, \\"abc\\", \\"def\\") \\"No\\"","solution":"def can_be_made_identical(n, s, t): Determines if two strings s and t can be made identical by swapping characters. :param n: Length of the strings (1 ≤ n ≤ 100) :param s: First string :param t: Second string :return: \\"Yes\\" if it is possible to make \`s\` and \`t\` identical, otherwise \\"No\\" # If both strings have the same set of characters and frequencies, they can be made identical if sorted(s) == sorted(t): return \\"Yes\\" else: return \\"No\\""},{"question":"def modify_grid(N: int, M: int, grid: List[str]) -> List[str]: Determine how many mines are adjacent to each cell and replace each empty cell with that number. Cells containing mines should remain unchanged. :param N: Number of rows in the grid :param M: Number of columns in the grid :param grid: List of strings representing the grid with '.' for empty cells and '*' for mines :return: Modified grid with each empty cell replaced by the count of adjacent mines Example: >>> modify_grid(4, 4, [ ... \\".*..\\", ... \\"....\\", ... \\"..*.\\", ... \\"....\\" ... ]) [ ... \\"1*10\\", ... \\"1221\\", ... \\"01*1\\", ... \\"0111\\" ... ]","solution":"def count_adjacent_mines(grid, row, col): directions = [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)] count = 0 for dr, dc in directions: new_row, new_col = row + dr, col + dc if 0 <= new_row < len(grid) and 0 <= new_col < len(grid[0]): if grid[new_row][new_col] == '*': count += 1 return count def modify_grid(N, M, grid): result_grid = [] for row in range(N): result_row = '' for col in range(M): if grid[row][col] == '*': result_row += '*' else: mine_count = count_adjacent_mines(grid, row, col) result_row += str(mine_count) result_grid.append(result_row) return result_grid"},{"question":"from datetime import datetime, timedelta def is_daytime(current_time: str, start_daytime: str, end_daytime: str) -> bool: current = datetime.strptime(current_time, \\"%H:%M\\").time() start = datetime.strptime(start_daytime, \\"%H:%M\\").time() end = datetime.strptime(end_daytime, \\"%H:%M\\").time() if start < end: return start <= current < end else: return current >= start or current < end def simulate_lamp(n: int, events: List[str], current_time: str, start_daytime: str, end_daytime: str) -> str: Simulates the behavior of an automatic lamp that turns on or off based on movements detected by a sensor and the current time of day. The lamp reacts differently during day and night times. Args: n (int): The number of events. events (List[str]): A list of events (either 'movement' or 'no movement'). current_time (str): The current time in 'HH:MM' format. start_daytime (str): The start time of daytime in 'HH:MM' format. end_daytime (str): The end time of daytime in 'HH:MM' format. Returns: str: 'on' or 'off' representing the final state of the lamp. >>> simulate_lamp(6, [\\"movement\\", \\"no movement\\", \\"no movement\\", \\"movement\\", \\"no movement\\", \\"no movement\\"], \\"21:00\\", \\"06:00\\", \\"18:00\\") 'off' >>> simulate_lamp(4, [\\"movement\\", \\"no movement\\", \\"movement\\", \\"no movement\\"], \\"12:00\\", \\"06:00\\", \\"18:00\\") 'off' >>> simulate_lamp(4, [\\"movement\\", \\"no movement\\", \\"no movement\\", \\"no movement\\"], \\"20:00\\", \\"06:00\\", \\"18:00\\") 'on' >>> simulate_lamp(6, [\\"movement\\", \\"no movement\\", \\"no movement\\", \\"no movement\\", \\"no movement\\", \\"no movement\\"], \\"20:00\\", \\"06:00\\", \\"18:00\\") 'off' >>> simulate_lamp(6, [\\"movement\\", \\"no movement\\", \\"movement\\", \\"no movement\\", \\"no movement\\", \\"no movement\\"], \\"20:00\\", \\"06:00\\", \\"18:00\\") 'on' >>> simulate_lamp(4, [\\"movement\\", \\"no movement\\", \\"movement\\", \\"no movement\\"], \\"18:00\\", \\"06:00\\", \\"18:00\\") 'on' >>> simulate_lamp(4, [\\"movement\\", \\"no movement\\", \\"movement\\", \\"no movement\\"], \\"06:00\\", \\"06:00\\", \\"18:00\\") 'off'","solution":"from datetime import datetime, timedelta def is_daytime(current_time, start_daytime, end_daytime): current = datetime.strptime(current_time, \\"%H:%M\\").time() start = datetime.strptime(start_daytime, \\"%H:%M\\").time() end = datetime.strptime(end_daytime, \\"%H:%M\\").time() if start < end: return start <= current < end else: return current >= start or current < end def simulate_lamp(n, events, current_time, start_daytime, end_daytime): lamp_state = 'off' last_movement_time = None current_datetime = datetime.strptime(current_time, \\"%H:%M\\") for event in events: if is_daytime(current_time, start_daytime, end_daytime): lamp_state = 'off' else: if event == 'movement': lamp_state = 'on' last_movement_time = current_datetime if last_movement_time and (current_datetime - last_movement_time) < timedelta(minutes=10): lamp_state = 'on' else: lamp_state = 'off' # Move time forward by 2 minutes after each event current_datetime += timedelta(minutes=2) current_time = current_datetime.strftime(\\"%H:%M\\") return lamp_state"},{"question":"def score_frequency(n: int, m: int, scores: List[int]) -> List[int]: Calculate the frequency of each score from 0 to m. :param n: number of students :param m: highest possible score :param scores: list of scores obtained by the students :return: list of frequencies of each score from 0 to m >>> score_frequency(5, 5, [0, 1, 2, 2, 5]) [1, 1, 2, 0, 0, 1] >>> score_frequency(6, 10, [3, 7, 7, 10, 2, 10]) [0, 0, 1, 1, 0, 0, 0, 2, 0, 0, 2] >>> score_frequency(4, 3, [3, 3, 3, 3]) [0, 0, 0, 4] >>> score_frequency(5, 5, [0, 1, 2, 3, 5]) [1, 1, 1, 1, 0, 1] >>> score_frequency(2, 4, [0, 4]) [1, 0, 0, 0, 1] >>> score_frequency(5, 10, [5, 6, 7, 8, 9]) [0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0]","solution":"def score_frequency(n, m, scores): Calculate the frequency of each score from 0 to m. :param n: number of students :param m: highest possible score :param scores: list of scores obtained by the students :return: list of frequencies of each score from 0 to m frequency = [0] * (m + 1) for score in scores: frequency[score] += 1 return frequency"},{"question":"def find_deepest_file(paths: List[str]) -> str: Finds the file with the greatest depth in the given filesystem paths. :param paths: List of strings representing the paths. :return: Single string of the path with greatest depth. >>> find_deepest_file([ \\"dir1/file1.txt\\", \\"dir1/dir2/file2.txt\\", \\"dir1/dir2/dir3/file3.txt\\", \\"dir4/file4.txt\\", \\"dir4/dir5/dir6/file5.txt\\", \\"dir4/dir5/file6.txt\\" ]) in [\\"dir1/dir2/dir3/file3.txt\\", \\"dir4/dir5/dir6/file5.txt\\"] >>> find_deepest_file([\\"file.txt\\"]) == \\"file.txt\\" >>> find_deepest_file([ \\"dir1/file1.txt\\", \\"dir2/file2.txt\\", \\"dir3/file3.txt\\" ]) in [\\"dir1/file1.txt\\", \\"dir2/file2.txt\\", \\"dir3/file3.txt\\"] >>> find_deepest_file([ \\"dir1/dir2/file1.txt\\", \\"dir3/dir4/file2.txt\\", \\"dir5/dir6/file3.txt\\" ]) in [\\"dir1/dir2/file1.txt\\", \\"dir3/dir4/file2.txt\\", \\"dir5/dir6/file3.txt\\"] >>> find_deepest_file([ \\"a/b/c/d/e/f.txt\\", \\"dir/f.txt\\", \\"dir/subdir/file1.txt\\", \\"dir/subdir2/file1.txt\\", \\"d/e/f/file.txt\\" ]) == \\"a/b/c/d/e/f.txt\\"","solution":"def find_deepest_file(paths): Finds the file with the greatest depth in the given filesystem paths. :param paths: List of strings representing the paths. :return: Single string of the path with greatest depth. max_depth = -1 deepest_file = \\"\\" for path in paths: depth = path.count('/') if depth > max_depth: max_depth = depth deepest_file = path return deepest_file"},{"question":"def minimum_moves_to_reduce_array(n: int, arr: List[int]) -> int: Returns the minimum number of moves required to reduce the array to a single integer. >>> minimum_moves_to_reduce_array(4, [1, 2, 3, 4]) == 3 >>> minimum_moves_to_reduce_array(5, [5, 5, 5, 5, 5]) == 4 >>> minimum_moves_to_reduce_array(2, [10, 20]) == 1","solution":"def minimum_moves_to_reduce_array(n, arr): Returns the minimum number of moves required to reduce the array to a single integer. # The minimum number of moves to reduce array to single integer is always n - 1 return n - 1"},{"question":"def lexicographically_smallest_rotation(binary_string: str) -> str: Finds the lexicographically smallest string obtained from rotating the given binary string. >>> lexicographically_smallest_rotation(\\"1010\\") \\"0101\\" >>> lexicographically_smallest_rotation(\\"11100\\") \\"00111\\" >>> lexicographically_smallest_rotation(\\"0000\\") \\"0000\\" >>> lexicographically_smallest_rotation(\\"010101\\") \\"010101\\" >>> lexicographically_smallest_rotation(\\"1111111111\\") \\"1111111111\\" pass def find_smallest_rotations(test_cases: list) -> list: For each test case, find the lexicographically smallest rotation. Parameters: test_cases (List[str]): List of binary strings. Returns: List[str]: List of lexicographically smallest rotations for each binary string. >>> find_smallest_rotations([\\"1010\\", \\"11100\\"]) [\\"0101\\", \\"00111\\"] >>> find_smallest_rotations([\\"0000\\", \\"010101\\"]) [\\"0000\\", \\"010101\\"] >>> find_smallest_rotations([\\"1\\", \\"0\\", \\"10\\", \\"01\\"]) [\\"1\\", \\"0\\", \\"01\\", \\"01\\"] pass","solution":"def lexicographically_smallest_rotation(binary_string): Finds the lexicographically smallest string obtained from rotating the given binary string. n = len(binary_string) smallest_rotation = binary_string for i in range(1, n): rotated_string = binary_string[i:] + binary_string[:i] if rotated_string < smallest_rotation: smallest_rotation = rotated_string return smallest_rotation def find_smallest_rotations(test_cases): For each test case, find the lexicographically smallest rotation. Parameters: test_cases (List[str]): List of binary strings. Returns: List[str]: List of lexicographically smallest rotations for each binary string. results = [] for binary_string in test_cases: smallest_rotation = lexicographically_smallest_rotation(binary_string) results.append(smallest_rotation) return results"},{"question":"from typing import List, Tuple def preprocess_array(arr: List[int]) -> List[int]: Preprocesses the array to compute cumulative sums, which helps in efficiently answering range sum queries. >>> preprocess_array([1, 2, 3, 4, 5]) [0, 1, 3, 6, 10, 15] def range_sum(prefix_sum: List[int], l: int, r: int) -> int: Returns the sum of the elements in the array from the l-th to the r-th position using the prefix sum array. >>> range_sum([0, 1, 3, 6, 10, 15], 1, 3) 6 >>> range_sum([0, 1, 3, 6, 10, 15], 2, 5) 14 def process_queries(arr: List[int], queries: List[Tuple[int, int]]) -> List[int]: Processes each range query on the array using the prefix sum array. >>> process_queries([1, 2, 3, 4, 5], [(1, 3), (2, 5), (1, 5)]) [6, 14, 15] >>> process_queries([10, 20, 30, 40, 50], [(1, 2), (3, 4), (2, 5)]) [30, 70, 140]","solution":"def preprocess_array(arr): Preprocesses the array to compute cumulative sums, which helps in efficiently answering range sum queries. n = len(arr) prefix_sum = [0] * (n + 1) for i in range(n): prefix_sum[i + 1] = prefix_sum[i] + arr[i] return prefix_sum def range_sum(prefix_sum, l, r): Returns the sum of the elements in the array from the l-th to the r-th position using the prefix sum array. return prefix_sum[r] - prefix_sum[l - 1] def process_queries(arr, queries): Processes each range query on the array using the prefix sum array. prefix_sum = preprocess_array(arr) results = [] for l, r in queries: results.append(range_sum(prefix_sum, l, r)) return results"},{"question":"from typing import List, Optional def max_depth(tree: List[Optional[int]]) -> int: Compute the maximum depth of a binary tree. >>> max_depth([3, 9, 20, None, None, 15, 7]) 3 >>> max_depth([1, None, 2]) 2 >>> max_depth([]) 0 >>> max_depth([1, 2, 3]) 2 >>> max_depth([1, None, 2, None, 3]) 3 >>> max_depth([1, 2, 3, 4, 5, 6, 7]) 3","solution":"from typing import List, Optional from collections import deque class TreeNode: def __init__(self, val: Optional[int]): self.val = val self.left = None self.right = None def build_tree(level_order: List[Optional[int]]) -> Optional[TreeNode]: if not level_order: return None root = TreeNode(level_order[0]) queue = deque([root]) i = 1 while queue and i < len(level_order): node = queue.popleft() if level_order[i] is not None: node.left = TreeNode(level_order[i]) queue.append(node.left) i += 1 if i < len(level_order) and level_order[i] is not None: node.right = TreeNode(level_order[i]) queue.append(node.right) i += 1 return root def max_depth(tree: List[Optional[int]]) -> int: def dfs(node: Optional[TreeNode]) -> int: if not node: return 0 return 1 + max(dfs(node.left), dfs(node.right)) root = build_tree(tree) return dfs(root)"},{"question":"def generate_primes(limit): Generate a list of prime numbers up to the specified limit using the Sieve of Eratosthenes. sieve = [True] * (limit+1) sieve[0] = sieve[1] = False for start in range(2, int(limit**0.5) + 1): if sieve[start]: for i in range(start*start, limit+1, start): sieve[i] = False return [num for num, is_prime in enumerate(sieve) if is_prime] def primes_and_sums_up_to_nth_prime(max_n): Generate the nth prime and the sum of those primes up to the nth position. Ensures the sum does not exceed 1,000,000. pass def main(): import sys input = sys.stdin.read data = input().split() Q = int(data[0]) queries = [int(data[i]) for i in range(1, Q+1)] max_query = max(queries) result = primes_and_sums_up_to_nth_prime(max_query) for query in queries: nth_prime, prime_sum = result[query-1] print(nth_prime, prime_sum) if __name__ == \\"__main__\\": main() def test_generate_primes(): primes = generate_primes(30) assert primes == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29] def test_primes_and_sums_up_to_nth_prime(): result = primes_and_sums_up_to_nth_prime(10) expected = [ (2, 2), (3, 5), (5, 10), (7, 17), (11, 28), (13, 41), (17, 58), (19, 77), (23, 100), (29, 129) ] assert result[:10] == expected def test_main_functionality(monkeypatch, capsys): inputs = \\"5n1n3n5n10n20n\\" monkeypatch.setattr('sys.stdin.read', lambda: inputs) main() captured = capsys.readouterr() output = captured.out.split(\\"n\\") assert output == ['2 2', '5 10', '11 28', '29 129', '71 639', ''] def test_large_query(monkeypatch, capsys): inputs = \\"1n100n\\" monkeypatch.setattr('sys.stdin.read', lambda: inputs) main() captured = capsys.readouterr() output = captured.out.split(\\"n\\") assert output[0].startswith('541') # 100th prime is 541 assert len(output) > 0","solution":"def generate_primes(limit): Generate a list of prime numbers up to the specified limit using the Sieve of Eratosthenes. sieve = [True] * (limit+1) sieve[0] = sieve[1] = False for start in range(2, int(limit**0.5) + 1): if sieve[start]: for i in range(start*start, limit+1, start): sieve[i] = False return [num for num, is_prime in enumerate(sieve) if is_prime] def primes_and_sums_up_to_nth_prime(max_n): Generate the nth prime and the sum of those primes up to the nth position. Ensures the sum does not exceed 1,000,000. primes = generate_primes(105000) # Upper estimate to cover first 10,000 primes prime_sums = [] running_sum = 0 for prime in primes: if running_sum + prime <= 1000000: running_sum += prime prime_sums.append((prime, running_sum)) else: break return prime_sums[:max_n+1] def main(): import sys input = sys.stdin.read data = input().split() Q = int(data[0]) queries = [int(data[i]) for i in range(1, Q+1)] max_query = max(queries) result = primes_and_sums_up_to_nth_prime(max_query) for query in queries: nth_prime, prime_sum = result[query-1] print(nth_prime, prime_sum) if __name__ == \\"__main__\\": main()"},{"question":"def common_fruit_day(test_cases): Determine if there is a day of the week on which every tree produces fruit. Args: test_cases (list): A list of tuples where each tuple represents a test case with the number of trees and their respective days of producing fruits. Returns: list: A list of strings \\"YES\\" or \\"NO\\" for each test case. Example: >>> common_fruit_day([ ... (3, [\\"Mon\\", \\"Tue\\", \\"Wed\\"], [\\"Tue\\", \\"Thu\\", \\"Sat\\"], [\\"Tue\\", \\"Fri\\"]), ... (2, [\\"Mon\\", \\"Wed\\", \\"Fri\\"], [\\"Tue\\", \\"Thu\\", \\"Sat\\"]), ... ]) [\\"YES\\", \\"NO\\"] pass def read_input(input_data): Read input data and return the test cases. Args: input_data (str): A string containing the input data. Returns: list: A list of tuples where each tuple represents a test case with the number of trees and their respective days of producing fruits. Example: >>> input_data = \\"2n3nMon Tue WednTue Thu SatnTue Frin2nMon Wed FrinTue Thu Satn\\" >>> read_input(input_data) [ (3, [\\"Mon\\", \\"Tue\\", \\"Wed\\"], [\\"Tue\\", \\"Thu\\", \\"Sat\\"], [\\"Tue\\", \\"Fri\\"]), (2, [\\"Mon\\", \\"Wed\\", \\"Fri\\"], [\\"Tue\\", \\"Thu\\", \\"Sat\\"]), ] pass def find_common_fruit_day(input_data): Main function to process the input and output the result. Args: input_data (str): A string containing the input data. Returns: str: The result for each test case (\\"YES\\" or \\"NO\\") separated by newline. Example: >>> input_data = \\"2n3nMon Tue WednTue Thu SatnTue Frin2nMon Wed FrinTue Thu Satn\\" >>> find_common_fruit_day(input_data) \\"YESnNO\\" pass from solution import common_fruit_day, read_input, find_common_fruit_day def test_common_fruit_day(): test_cases = [ (3, [\\"Mon\\", \\"Tue\\", \\"Wed\\"], [\\"Tue\\", \\"Thu\\", \\"Sat\\"], [\\"Tue\\", \\"Fri\\"]), (2, [\\"Mon\\", \\"Wed\\", \\"Fri\\"], [\\"Tue\\", \\"Thu\\", \\"Sat\\"]), ] assert common_fruit_day(test_cases) == [\\"YES\\", \\"NO\\"] def test_read_input(): input_data = \\"2n3nMon Tue WednTue Thu SatnTue Frin2nMon Wed FrinTue Thu Satn\\" expected_output = [ (3, [\\"Mon\\", \\"Tue\\", \\"Wed\\"], [\\"Tue\\", \\"Thu\\", \\"Sat\\"], [\\"Tue\\", \\"Fri\\"]), (2, [\\"Mon\\", \\"Wed\\", \\"Fri\\"], [\\"Tue\\", \\"Thu\\", \\"Sat\\"]), ] assert read_input(input_data) == expected_output def test_find_common_fruit_day(): input_data = \\"2n3nMon Tue WednTue Thu SatnTue Frin2nMon Wed FrinTue Thu Satn\\" assert find_common_fruit_day(input_data) == \\"YESnNO\\"","solution":"def common_fruit_day(test_cases): results = [] for case in test_cases: n = case[0] tree_days = case[1:] common_days = set(tree_days[0]) for days in tree_days[1:]: common_days.intersection_update(days) if common_days: results.append(\\"YES\\") else: results.append(\\"NO\\") return results # Function to read input and return the test cases def read_input(input_data): lines = input_data.strip().split(\\"n\\") T = int(lines[0]) test_cases = [] index = 1 for _ in range(T): N = int(lines[index]) tree_days = [lines[i].split() for i in range(index + 1, index + 1 + N)] test_cases.append((N, *tree_days)) index += 1 + N return test_cases # Main function to process the input and output the result def find_common_fruit_day(input_data): test_cases = read_input(input_data) results = common_fruit_day(test_cases) return \\"n\\".join(results)"},{"question":"def max_crate_stack(R, C, warehouse): Calculate the maximum height of a stack after consolidating all crates in a grid. :param R: Number of rows :param C: Number of columns :param warehouse: List of strings representing the warehouse grid. :return: Maximum height of any stack Examples: >>> max_crate_stack(4, 4, [\\"1..2\\", \\"..#.\\", \\".3.4\\", \\".5..\\"]) 12 >>> max_crate_stack(1, 1, [\\"1\\"]) 1 >>> max_crate_stack(4, 4, [\\"..#.\\", \\"....\\", \\".#..\\", \\"....\\"]) 0 >>> max_crate_stack(3, 1, [\\"1\\", \\"2\\", \\"3\\"]) 6 >>> max_crate_stack(1, 5, [\\"1.2.3\\"]) 6 >>> max_crate_stack(2, 2, [\\"9 9\\", \\"9 9\\"]) 36","solution":"def max_crate_stack(R, C, warehouse): Calculate the maximum height of a stack after consolidating all crates in a grid. :param R: Number of rows :param C: Number of columns :param warehouse: List of strings representing the warehouse grid. :return: Maximum height of any stack total_crates = 0 for row in warehouse: for cell in row: if cell.isdigit(): total_crates += int(cell) return total_crates"},{"question":"def smallest_capacity_for_group(test_cases): Determine the smallest capacity screen that can be used to accommodate a group of people without splitting them up. Parameters: test_cases (list): A list of dictionaries where each dictionary represents a test case. Each dictionary contains two keys: - 'cinemas': a list of dictionaries where each dictionary contains a key 'screens' that maps to a list of integers representing the capacities of the screens in that cinema. - 'group': an integer representing the size of the group. Returns: list: A list of integers where each integer represents the smallest screen capacity that can accommodate the group for the corresponding test case. >>> test_cases = [ { 'cinemas': [ {'screens': [50, 100, 200]}, {'screens': [75, 150]} ], 'group': 120 }, { 'cinemas': [ {'screens': [200, 300, 400, 500]} ], 'group': 350 } ] >>> smallest_capacity_for_group(test_cases) [150, 400] def parse_input(input_str): Parse the input string and convert it into a list of test cases. Parameters: input_str (str): A string representing the input. Returns: list: A list of dictionaries where each dictionary represents a test case. >>> input_str = \\"2n2n3 50 100 200n2 75 150n120n1n4 200 300 400 500n350\\" >>> parse_input(input_str) [ { 'cinemas': [ {'screens': [50, 100, 200]}, {'screens': [75, 150]} ], 'group': 120 }, { 'cinemas': [ {'screens': [200, 300, 400, 500]} ], 'group': 350 } ]","solution":"def smallest_capacity_for_group(test_cases): results = [] for test_case in test_cases: cinemas = test_case['cinemas'] group_size = test_case['group'] min_capacity = float('inf') for cinema in cinemas: screen_capacities = cinema['screens'] for capacity in screen_capacities: if capacity >= group_size: min_capacity = min(min_capacity, capacity) results.append(min_capacity) return results # Parse input def parse_input(input_str): lines = input_str.strip().split('n') T = int(lines[0]) index = 1 test_cases = [] for _ in range(T): M = int(lines[index]) index += 1 cinemas = [] for _ in range(M): screen_info = list(map(int, lines[index].split())) K = screen_info[0] screen_capacities = screen_info[1:] cinemas.append({'screens': screen_capacities}) index += 1 G = int(lines[index]) index += 1 test_cases.append({'cinemas': cinemas, 'group': G}) return test_cases input_str = 2 2 3 50 100 200 2 75 150 120 1 4 200 300 400 500 350 test_cases = parse_input(input_str) output = smallest_capacity_for_group(test_cases) for res in output: print(res)"},{"question":"def analyze_speeds(test_cases): Analyzes the speed logs for each test case to calculate the average speed, maximum speed, and minimum speed. Args: test_cases (list of tuple): List of test cases where each test case is represented by a tuple. The first element of the tuple is an integer N representing the number of speed logs, and the second element is a list of integers representing the speeds. Returns: list of tuple: A list of tuples where each tuple contains three integers - the average speed (rounded to the nearest integer), the maximum speed, and the minimum speed. >>> analyze_speeds([(3, [5, 10, 15]), (4, [8, 8, 8, 8])]) [(10, 15, 5), (8, 8, 8)] >>> analyze_speeds([(5, [0, 25, 50, 75, 100])]) [(50, 100, 0)] pass def process_input(input_data): Processes the input data to extract the number of test cases and the speed logs for each test case. Args: input_data (str): The input data as a string. Returns: list of tuple: A list of test cases extracted from the input data. Each test case is represented by a tuple. The first element of the tuple is an integer N, and the second element is a list of integers representing the speeds. >>> process_input(\\"2n3n5 10 15n4n8 8 8 8\\") [(3, [5, 10, 15]), (4, [8, 8, 8, 8])] >>> process_input(\\"1n5n0 25 50 75 100\\") [(5, [0, 25, 50, 75, 100])] pass","solution":"def analyze_speeds(test_cases): results = [] for case in test_cases: N, speeds = case average_speed = round(sum(speeds) / N) max_speed = max(speeds) min_speed = min(speeds) results.append((average_speed, max_speed, min_speed)) return results def process_input(input_data): lines = input_data.strip().split('n') T = int(lines[0]) test_cases = [] index = 1 for _ in range(T): N = int(lines[index]) speeds = list(map(int, lines[index + 1].split())) test_cases.append((N, speeds)) index += 2 return test_cases"},{"question":"def count_trees(grid): Returns the number of trees (1s) in the grid. >>> count_trees([[0, 1, 0], [1, 1, 1], [0, 1, 0]]) 5 >>> count_trees([[0, 0, 0], [0, 0, 0], [0, 0, 0]]) 0 rows = len(grid) cols = len(grid[0]) tree_count = 0 for i in range(rows): for j in range(cols): if grid[i][j] == 1: tree_count += 1 return tree_count def max_histogram_area(histogram): Returns the maximum area of a histogram. >>> max_histogram_area([1, 1, 1, 1]) 4 >>> max_histogram_area([2, 1, 2]) 3 stack = [] max_area = 0 index = 0 while index < len(histogram): if not stack or histogram[index] >= histogram[stack[-1]]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (histogram[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (histogram[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area def max_rect_area(grid): Returns the maximum rectangular area of trees (1s) in the grid. >>> max_rect_area([[0, 1, 0], [1, 1, 1], [0, 1, 0]]) 3 >>> max_rect_area([[0, 0, 0], [0, 0, 0], [0, 0, 0]]) 0 rows = len(grid) cols = len(grid[0]) # Convert the grid to indicate forest patches. for i in range(1, rows): for j in range(cols): if grid[i][j] == 1: grid[i][j] += grid[i - 1][j] max_area = 0 for i in range(rows): max_area = max(max_area, max_histogram_area(grid[i])) return max_area","solution":"def count_trees(grid): Returns the number of trees (1s) in the grid. rows = len(grid) cols = len(grid[0]) tree_count = 0 for i in range(rows): for j in range(cols): if grid[i][j] == 1: tree_count += 1 return tree_count def max_rect_area(grid): Returns the maximum rectangular area of trees (1s) in the grid. rows = len(grid) cols = len(grid[0]) # Convert the grid to indicate forest patches. for i in range(1, rows): for j in range(cols): if grid[i][j] == 1: grid[i][j] += grid[i - 1][j] max_area = 0 for i in range(rows): max_area = max(max_area, max_histogram_area(grid[i])) return max_area def max_histogram_area(histogram): Returns the maximum area of a histogram. stack = [] max_area = 0 index = 0 while index < len(histogram): if not stack or histogram[index] >= histogram[stack[-1]]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (histogram[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (histogram[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area # Sample input forest = [[0, 1, 0, 0, 1], [1, 1, 1, 1, 0], [1, 0, 1, 1, 0], [0, 0, 1, 0, 1]] tree_count = count_trees(forest) max_area = max_rect_area(forest) print(\\"Number of trees:\\", tree_count) print(\\"Max rectangular area of trees:\\", max_area)"},{"question":"def count_distinct_values(test_cases): Given a list of test cases where each test case is a list of integers, returns a list of integers where each integer represents the number of distinct values in that test case. >>> count_distinct_values([[1, 2, 3, 4, 5], [1, 1, 1, 1, 1], [1, 2, 2, 3, 3, 4, 4, 5]]) == [5, 1, 5] def parse_input(input_string): Parses the input string into a list of test cases. >>> parse_input(\\"3n5 1 2 3 4 5n5 1 1 1 1 1n8 1 2 2 3 3 4 4 5\\") == [ [1, 2, 3, 4, 5], [1, 1, 1, 1, 1], [1, 2, 2, 3, 3, 4, 4, 5] ]","solution":"def count_distinct_values(test_cases): Given a list of test cases where each test case is a list of integers, returns a list of integers where each integer represents the number of distinct values in that test case. results = [] for case in test_cases: distinct_count = len(set(case)) results.append(distinct_count) return results def parse_input(input_string): Parses the input string into a list of test cases. lines = input_string.strip().split('n') T = int(lines[0]) test_cases = [] for i in range(1, T + 1): test_case = list(map(int, lines[i].strip().split()[1:])) test_cases.append(test_case) return test_cases"},{"question":"from typing import List, Tuple def max_trains_at_station(trains: List[Tuple[int, int]]) -> int: Determine the maximum number of trains that are at the station at the same time. >>> max_trains_at_station([(1, 3), (2, 5), (4, 6), (5, 8), (5, 7)]) 3 >>> max_trains_at_station([(1, 2), (3, 4), (5, 6), (7, 8)]) 1 >>> max_trains_at_station([(1, 10), (2, 10), (3, 10), (4, 10), (5, 10)]) 5 >>> max_trains_at_station([(1, 4), (2, 5), (3, 6)]) 3 >>> max_trains_at_station([(1, 5)]) 1 >>> max_trains_at_station([(1, 5), (2, 3)]) 2","solution":"def max_trains_at_station(trains): events = [] # Collect all the arrival and departure events for arrival, departure in trains: events.append((arrival, 'arrival')) events.append((departure, 'departure')) # Sort events by time, breaking ties by prioritizing 'departure' over 'arrival' events.sort(key=lambda x: (x[0], x[1] == 'arrival')) max_trains = 0 current_trains = 0 # Sweep through the events for event in events: if event[1] == 'arrival': current_trains += 1 max_trains = max(max_trains, current_trains) else: current_trains -= 1 return max_trains"},{"question":"def sum_after_operations(n: int, q: int, operations: List[Tuple[int, int, int]]) -> int: Returns the sum of all elements in the array after performing the given q operations. Parameters: n (int): Size of the array. q (int): Number of operations. operations (list of tuples): Each tuple contains three integers (l, r, x) representing an operation. Returns: int: Sum of the elements in the array after all operations. >>> sum_after_operations(5, 3, [(1, 3, 2), (2, 4, 3), (1, 5, 1)]) == 20 >>> sum_after_operations(5, 0, []) == 0 >>> sum_after_operations(5, 1, [(1, 5, 2)]) == 10 >>> sum_after_operations(5, 3, [(1, 5, 1), (1, 5, 1), (1, 5, 1)]) == 15 >>> sum_after_operations(1, 1, [(1, 1, 1)]) == 1","solution":"def sum_after_operations(n, q, operations): Returns the sum of all elements in the array after performing the given q operations. Parameters: n (int): Size of the array. q (int): Number of operations. operations (list of tuples): Each tuple contains three integers (l, r, x) representing an operation. Returns: int: Sum of the elements in the array after all operations. array = [0] * (n + 1) # Use an extra space for ease of implementation # Applying the operation using a difference array approach for l, r, x in operations: array[l-1] += x if r < n: array[r] -= x # Calculate the prefix sum to get the final array current_value = 0 final_sum = 0 for i in range(n): current_value += array[i] final_sum += current_value return final_sum"},{"question":"from collections import deque from typing import List def bfs_shortest_path(grid: List[str], n: int, m: int, sx: int, sy: int, dx: int, dy: int) -> int: Find the shortest path in a grid using BFS. Parameters: grid (List[str]): The grid with open cells '.' and walls '#'. n (int): Number of rows in the grid. m (int): Number of columns in the grid. sx (int): Starting point x-coordinate (1-based index). sy (int): Starting point y-coordinate (1-based index). dx (int): Destination point x-coordinate (1-based index). dy (int): Destination point y-coordinate (1-based index). Returns: int: Length of the shortest path from (sx, sy) to (dx, dy), or -1 if no path exists. >>> bfs_shortest_path([\\".....\\", \\".#...\\", \\"..#..\\", \\"...#.\\", \\".....\\"], 5, 5, 1, 1, 5, 5) 8 >>> bfs_shortest_path([\\"..#\\", \\".#.\\", \\"..#\\"], 3, 3, 1, 1, 3, 3) -1","solution":"from collections import deque def bfs_shortest_path(grid, n, m, sx, sy, dx, dy): # Directions: Up, Down, Left, Right directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # Adjust to 0-based indexing for BFS processing sx, sy, dx, dy = sx - 1, sy - 1, dx - 1, dy - 1 # BFS Queue: (current_x, current_y, current_length_of_path) queue = deque([(sx, sy, 0)]) # Visited set to keep track of visited cells visited = set() visited.add((sx, sy)) while queue: x, y, length = queue.popleft() # If we reached the destination, return the path length if x == dx and y == dy: return length # Explore the 4 possible directions for direction in directions: nx, ny = x + direction[0], y + direction[1] # Check if within bounds and not visited and not a wall if 0 <= nx < n and 0 <= ny < m and (nx, ny) not in visited and grid[nx][ny] == '.': visited.add((nx, ny)) queue.append((nx, ny, length + 1)) # If no path was found return -1 def main(): import sys input = sys.stdin.read data = input().split() n = int(data[0]) m = int(data[1]) grid = [] for i in range(n): grid.append(data[2+i]) sx, sy, dx, dy = int(data[n+2]), int(data[n+3]), int(data[n+4]), int(data[n+5]) result = bfs_shortest_path(grid, n, m, sx, sy, dx, dy) print(result)"},{"question":"from typing import List class TaskScheduler: def __init__(self): pass def add_task(self, name: str, priority: int): pass def execute_task(self) -> str: pass def task_scheduler_simulation(operations: List[str]) -> List[str]: Simulate the task scheduler based on the given operations. >>> task_scheduler_simulation([ ... \\"ADD clean 1\\", ... \\"ADD cook 2\\", ... \\"EXECUTE\\", ... \\"ADD laundry 2\\", ... \\"EXECUTE\\", ... \\"EXECUTE\\", ... \\"EXECUTE\\" ... ]) [\\"cook\\", \\"laundry\\", \\"clean\\", \\"NO TASKS\\"] >>> task_scheduler_simulation([\\"EXECUTE\\"]) [\\"NO TASKS\\"] >>> task_scheduler_simulation([ ... \\"ADD a 1\\", ... \\"ADD b 2\\", ... \\"ADD c 3\\", ... \\"EXECUTE\\", ... \\"EXECUTE\\", ... \\"EXECUTE\\" ... ]) [\\"c\\", \\"b\\", \\"a\\"] >>> task_scheduler_simulation([ ... \\"ADD x 5\\", ... \\"ADD y 5\\", ... \\"ADD z 5\\", ... \\"EXECUTE\\", ... \\"EXECUTE\\", ... \\"EXECUTE\\" ... ]) [\\"x\\", \\"y\\", \\"z\\"] >>> task_scheduler_simulation([ ... \\"ADD task1 10\\", ... \\"ADD task2 20\\", ... \\"EXECUTE\\", ... \\"ADD task3 20\\", ... \\"ADD task4 15\\", ... \\"EXECUTE\\", ... \\"EXECUTE\\", ... \\"EXECUTE\\" ... ]) [\\"task2\\", \\"task3\\", \\"task4\\", \\"task1\\"] pass","solution":"import heapq class TaskScheduler: def __init__(self): self.tasks = [] self.counter = 0 # This counter will help to maintain insertion order self.scheduler_index = 0 # To act as tie breaker def add_task(self, name, priority): # Using a tuple where: # - priority is stored as negative to use min-heap as max-heap # - self.counter to maintain the order of addition for same priority heapq.heappush(self.tasks, (-priority, self.scheduler_index, name)) self.scheduler_index += 1 def execute_task(self): if not self.tasks: return \\"NO TASKS\\" return heapq.heappop(self.tasks)[2] def task_scheduler_simulation(operations): scheduler = TaskScheduler() results = [] for operation in operations: if operation.startswith(\\"ADD\\"): _, name, priority = operation.split() scheduler.add_task(name, int(priority)) elif operation == \\"EXECUTE\\": results.append(scheduler.execute_task()) return results"},{"question":"from typing import List, Tuple def min_sliding_window(arr: List[int], k: int) -> List[int]: Returns a list of the minimum element in each sliding window of size k for the given array. >>> min_sliding_window([1, 3, 2, 6, 3, 8, 1, 4], 3) [1, 2, 2, 3, 1, 1] >>> min_sliding_window([7, 5, 2, 6, 9], 2) [5, 2, 2, 6] def solve(t: int, test_cases: List[Tuple[Tuple[int, int], List[int]]]) -> List[List[int]]: Processes the input test cases and returns the results as specified in the problem. >>> solve(2, [((8, 3), [1, 3, 2, 6, 3, 8, 1, 4]), ((5, 2), [7, 5, 2, 6, 9])]) [[1, 2, 2, 3, 1, 1], [5, 2, 2, 6]]","solution":"from collections import deque def min_sliding_window(arr, k): Returns a list of the minimum element in each sliding window of size k for the given array. n = len(arr) if k == 1: return arr q = deque() result = [] for i in range(n): # Remove elements not in the current window if q and q[0] == i - k: q.popleft() # Maintain the order in deque while q and arr[q[-1]] >= arr[i]: q.pop() q.append(i) # First window sum at position k-1 if i >= k - 1: result.append(arr[q[0]]) return result def solve(t, test_cases): Processes the input test cases and returns the results as specified in the problem. results = [] for i in range(t): n, k = test_cases[i][0] arr = test_cases[i][1] results.append(min_sliding_window(arr, k)) return results"},{"question":"def calculate_total_sales(n: int, sales_data: List[List[int]]) -> List[int]: Calculates the total sales for each day of the week across all n days. Args: n (int): Number of days of sales data. sales_data (list of list of int): Sales data where each list contains sales from Sunday to Saturday. Returns: list of int: Total sales for each day from Sunday to Saturday. # Write your code here # Unit tests def test_calculate_total_sales(): assert calculate_total_sales(1, [[10, 20, 30, 40, 50, 60, 70]]) == [10, 20, 30, 40, 50, 60, 70] assert calculate_total_sales(2, [[10, 20, 30, 40, 50, 60, 70], [5, 15, 25, 35, 45, 55, 65]]) == [15, 35, 55, 75, 95, 115, 135] assert calculate_total_sales(3, [[10, 20, 30, 40, 50, 60, 70], [5, 15, 25, 35, 45, 55, 65], [7, 14, 21, 28, 35, 42, 49]]) == [22, 49, 76, 103, 130, 157, 184] assert calculate_total_sales(1, [[0, 0, 0, 0, 0, 0, 0]]) == [0, 0, 0, 0, 0, 0, 0] assert calculate_total_sales(3, [[0, 1, 0, 1, 0, 1, 0], [1, 0, 1, 0, 1, 0, 1], [0, 0, 0, 0, 0, 0, 0]]) == [1, 1, 1, 1, 1, 1, 1]","solution":"def calculate_total_sales(n, sales_data): Calculates the total sales for each day of the week across all n days. Args: n (int): Number of days of sales data. sales_data (list of list of int): Sales data where each list contains sales from Sunday to Saturday. Returns: list of int: Total sales for each day from Sunday to Saturday. total_sales = [0] * 7 for day_data in sales_data: for i in range(7): total_sales[i] += day_data[i] return total_sales # Example usage n = 3 sales_data = [ [10, 20, 30, 40, 50, 60, 70], [5, 15, 25, 35, 45, 55, 65], [7, 14, 21, 28, 35, 42, 49] ] print(calculate_total_sales(n, sales_data)) # Output: [22, 49, 76, 103, 130, 157, 184]"},{"question":"import heapq from typing import List, Tuple def shortest_path(n: int, m: int, edges: List[Tuple[int, int, int]], u: int, v: int) -> int: Find the weight of the shortest path between two given vertices u and v. Arguments: n -- the number of vertices in the graph. m -- the number of edges in the graph. edges -- a list of tuples, where each tuple contains three integers a, b, w representing an edge between vertices a and b with weight w. u -- the starting vertex for the shortest path. v -- the ending vertex for the shortest path. Returns: The weight of the shortest path between vertices u and v. If there is no path between u and v, return -1. Examples: >>> shortest_path(5, 6, [(1, 2, 4), (1, 3, 2), (2, 3, 5), (2, 4, 10), (3, 5, 3), (4, 5, 4)], 1, 5) 5 >>> shortest_path(3, 1, [(1, 2, 6)], 1, 3) -1","solution":"import heapq def shortest_path(n, m, edges, u, v): graph = [[] for _ in range(n + 1)] for a, b, w in edges: graph[a].append((w, b)) graph[b].append((w, a)) def dijkstra(src, dest): distances = {i: float('inf') for i in range(1, n + 1)} distances[src] = 0 priority_queue = [(0, src)] while priority_queue: current_distance, current_vertex = heapq.heappop(priority_queue) if current_vertex == dest: return current_distance if current_distance > distances[current_vertex]: continue for weight, neighbor in graph[current_vertex]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return -1 return dijkstra(u, v)"},{"question":"def find_balanced_substring(s: str) -> str: Find the shortest balanced substring in the given binary string. A balanced substring has an equal number of '0's and '1's. If there are multiple balanced substrings, return the first one that appears in the original string. If there is no balanced substring, return \\"-1\\". Examples: >>> find_balanced_substring(\\"110\\") \\"10\\" >>> find_balanced_substring(\\"1001001\\") \\"10\\" >>> find_balanced_substring(\\"1111\\") \\"-1\\"","solution":"def find_balanced_substring(s): Find the shortest balanced substring in the given binary string. A balanced substring has an equal number of '0's and '1's. n = len(s) min_length = float('inf') result = \\"-1\\" for i in range(n): for j in range(i + 1, n + 1): substring = s[i:j] if substring.count('0') == substring.count('1'): if len(substring) < min_length: min_length = len(substring) result = substring break # Since we only need the shortest, break out of inner loop return result"},{"question":"def sum_of_even_numbers(int_list): Returns the sum of all even numbers in the given list. >>> sum_of_even_numbers([1, 2, 3, 4, 5]) == 6 >>> sum_of_even_numbers([-2, -4, -6]) == -12 >>> sum_of_even_numbers([1, 3, 5, 7, 9, 11]) == 0 >>> sum_of_even_numbers([0, 1, 2, 3, 4, 5]) == 6 >>> sum_of_even_numbers([-2]) == -2 >>> sum_of_even_numbers([2]) == 2","solution":"def sum_of_even_numbers(int_list): Returns the sum of all even numbers in the given list. return sum(x for x in int_list if x % 2 == 0)"},{"question":"def fizz_buzz_game(rules, m, k): Simulates the FizzBuzz game with custom rules. :param rules: A list of tuples containing (divisor, word) pairs. :param m: The starting number. :param k: The ending number. :return: A list of strings representing the FizzBuzz results from m to k. pass def parse_input(input_str): Parses the input string for the FizzBuzz game. :param input_str: The input as a string. :return: A tuple containing rules, m, and k. pass def test_fizz_buzz_game_basic(): rules, m, k = parse_input('2n3 Fizzn5 Buzzn1 15') result = fizz_buzz_game(rules, m, k) expected = [ '1', '2', 'Fizz', '4', 'Buzz', 'Fizz', '7', '8', 'Fizz', 'Buzz', '11', 'Fizz', '13', '14', 'FizzBuzz' ] assert result == expected def test_fizz_buzz_single_rule(): rules, m, k = parse_input('1n2 Evenn1 5') result = fizz_buzz_game(rules, m, k) expected = ['1', 'Even', '3', 'Even', '5'] assert result == expected def test_fizz_buzz_no_output_substitution(): rules, m, k = parse_input('1n10 Tenn1 5') result = fizz_buzz_game(rules, m, k) expected = ['1', '2', '3', '4', '5'] assert result == expected def test_fizz_buzz_custom_rules(): rules, m, k = parse_input('3n3 Foon5 Barn2 Bazn1 7') result = fizz_buzz_game(rules, m, k) expected = ['1', 'Baz', 'Foo', 'Baz', 'Bar', 'FooBaz', '7'] assert result == expected","solution":"def fizz_buzz_game(rules, m, k): Simulates the FizzBuzz game with custom rules. :param rules: A list of tuples containing (divisor, word) pairs. :param m: The starting number. :param k: The ending number. :return: A list of strings representing the FizzBuzz results from m to k. result = [] for i in range(m, k+1): output = '' for divisor, word in rules: if i % divisor == 0: output += word if output == '': output = str(i) result.append(output) return result def parse_input(input_str): lines = input_str.strip().split('n') rule_count = int(lines[0]) rules = [] for i in range(1, rule_count + 1): parts = lines[i].split() divisor = int(parts[0]) word = parts[1] rules.append((divisor, word)) m, k = map(int, lines[rule_count + 1].split()) return rules, m, k"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def build_tree(nodes): if not nodes: return None val_to_node = {} for v, l, r in nodes: if v not in val_to_node: val_to_node[v] = TreeNode(v) node = val_to_node[v] if l != -1: if l not in val_to_node: val_to_node[l] = TreeNode(l) node.left = val_to_node[l] if r != -1: if r not in val_to_node: val_to_node[r] = TreeNode(r) node.right = val_to_node[r] return val_to_node[nodes[0][0]] def is_height_balanced(root): def check(node): if not node: return 0, True left_height, left_balanced = check(node.left) right_height, right_balanced = check(node.right) is_balanced = (left_balanced and right_balanced and abs(left_height - right_height) <= 1) return max(left_height, right_height) + 1, is_balanced _, balanced = check(root) return balanced def solve(T, test_cases): Determines if each binary tree in the test cases is height-balanced. Args: T (int): Number of test cases. test_cases (List[List[Tuple[int, int, int]]]): List of test cases, where each test case is a list of tuples. Each tuple contains the node value and its left and right children. Returns: List[str]: \\"YES\\" if the tree is height-balanced, otherwise \\"NO\\". >>> solve(2, [[(1, 2, 3), (2, -1, -1), (3, -1, -1)], [(4, 2, 6), (2, 1, 3), (1, -1, -1), (3, -1, -1), (6, 5, 7), (5, -1, -1), (7, -1, -1)]]) [\\"YES\\", \\"YES\\"] >>> solve(1, [[(1, 2, -1), (2, 3, -1), (3, -1, -1)]]) [\\"NO\\"] >>> solve(1, [[(10, 5, 20), (5, -1, -1), (20, 15, 25), (15, -1, -1), (25, 30, -1), (30, -1, -1)]]) [\\"NO\\"]","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def build_tree(nodes): if not nodes: return None val_to_node = {} for v, l, r in nodes: if v not in val_to_node: val_to_node[v] = TreeNode(v) node = val_to_node[v] if l != -1: if l not in val_to_node: val_to_node[l] = TreeNode(l) node.left = val_to_node[l] if r != -1: if r not in val_to_node: val_to_node[r] = TreeNode(r) node.right = val_to_node[r] return val_to_node[nodes[0][0]] def is_height_balanced(root): def check(node): if not node: return 0, True left_height, left_balanced = check(node.left) right_height, right_balanced = check(node.right) is_balanced = (left_balanced and right_balanced and abs(left_height - right_height) <= 1) return max(left_height, right_height) + 1, is_balanced _, balanced = check(root) return balanced def solve(T, test_cases): results = [] for nodes in test_cases: root = build_tree(nodes) if is_height_balanced(root): results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"from typing import List, Tuple def floyd_warshall(n: int, m: int, paths: List[Tuple[int, int, int]]) -> List[List[int]]: Compute the minimum energy cost for migration paths between the islands. >>> floyd_warshall(4, 4, [(1, 2, 10), (2, 3, 15), (1, 4, 20), (4, 3, 10)]) [[0, 10, 25, 20], [-1, 0, 15, -1], [-1, -1, 0, -1], [-1, -1, 10, 0]] >>> floyd_warshall(3, 2, [(1, 2, 5), (3, 1, 7)]) [[0, 5, -1], [-1, 0, -1], [7, 12, 0]] pass def parse_input(input_str: str) -> Tuple[int, int, List[Tuple[int, int, int]]]: Parses the input string and returns the number of islands, the number of flight paths, and a list of paths. >>> parse_input(\\"4 4n1 2 10n2 3 15n1 4 20n4 3 10\\") (4, 4, [(1, 2, 10), (2, 3, 15), (1, 4, 20), (4, 3, 10)]) >>> parse_input(\\"3 2n1 2 5n3 1 7\\") (3, 2, [(1, 2, 5), (3, 1, 7)]) pass def format_output(matrix: List[List[int]]) -> str: Formats the output as a string representation of the matrix. >>> format_output([[0, 5, -1], [-1, 0, -1], [7, 12, 0]]) '0 5 -1n-1 0 -1n7 12 0' pass def test_floyd_warshall(): input_str = \\"4 4n1 2 10n2 3 15n1 4 20n4 3 10\\" n, m, paths = parse_input(input_str) result = floyd_warshall(n, m, paths) expected_output = [ [0, 10, 25, 20], [-1, 0, 15, -1], [-1, -1, 0, -1], [-1, -1, 10, 0] ] assert result == expected_output def test_floyd_warshall_no_paths(): input_str = \\"3 0\\" n, m, paths = parse_input(input_str) result = floyd_warshall(n, m, paths) expected_output = [ [0, -1, -1], [-1, 0, -1], [-1, -1, 0] ] assert result == expected_output def test_floyd_warshall_single_path(): input_str = \\"3 2n1 2 5n3 1 7\\" n, m, paths = parse_input(input_str) result = floyd_warshall(n, m, paths) expected_output = [ [0, 5, -1], [-1, 0, -1], [7, 12, 0] ] assert result == expected_output def test_parse_input(): input_str = \\"4 4n1 2 10n2 3 15n1 4 20n4 3 10\\" n, m, paths = parse_input(input_str) assert (n, m) == (4, 4) assert paths == [(1, 2, 10), (2, 3, 15), (1, 4, 20), (4, 3, 10)] def test_format_output(): matrix = [ [0, 5, -1], [-1, 0, -1], [7, 12, 0] ] output_str = format_output(matrix) expected_output = \\"0 5 -1n-1 0 -1n7 12 0\\" assert output_str.strip() == expected_output.strip()","solution":"def floyd_warshall(n, m, paths): INF = float('inf') dist = [[INF] * n for _ in range(n)] for i in range(n): dist[i][i] = 0 for ai, bi, ci in paths: dist[ai-1][bi-1] = ci for k in range(n): for i in range(n): for j in range(n): if dist[i][k] < INF and dist[k][j] < INF: dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]) result = [] for i in range(n): row = [] for j in range(n): if dist[i][j] == INF: row.append(-1) else: row.append(dist[i][j]) result.append(row) return result def parse_input(input_str): input_lines = input_str.strip().split('n') n, m = map(int, input_lines[0].split()) paths = [tuple(map(int, line.split())) for line in input_lines[1:]] return n, m, paths def format_output(matrix): return 'n'.join([' '.join(map(str, row)) for row in matrix])"},{"question":"def max_distance_between_houses(n: int, positions: List[int]) -> int: Calculate the maximum distance between any two consecutive houses. Args: n : int : number of houses positions : list of int : positions of the houses Returns: int : maximum distance between two consecutive houses Examples: >>> max_distance_between_houses(4, [2, 5, 12, 8]) 4 >>> max_distance_between_houses(3, [1, 4, 7]) 3 >>> max_distance_between_houses(5, [10, 3, 6, 1, 15]) 5 >>> max_distance_between_houses(2, [1, 2]) 1 >>> max_distance_between_houses(2, [1, 1000]) 999","solution":"def max_distance_between_houses(n, positions): Calculate the maximum distance between any two consecutive houses. Args: n : int : number of houses positions : list of int : positions of the houses Returns: int : maximum distance between two consecutive houses # Sort the house positions positions.sort() # Calculate the maximum distance between consecutive houses max_distance = 0 for i in range(1, n): distance = positions[i] - positions[i - 1] if distance > max_distance: max_distance = distance return max_distance"},{"question":"def min_energy_to_travel(n: int, heights: List[int]) -> int: Returns the minimum energy required for Vlad to travel from the leftmost point to the rightmost point of the landscape. >>> min_energy_to_travel(5, [4, 7, 2, 8, 5]) 1 >>> min_energy_to_travel(3, [3, 3, 3]) 0 >>> min_energy_to_travel(4, [1, 2, 3, 4]) 3 >>> min_energy_to_travel(4, [4, 3, 2, 1]) 3 >>> min_energy_to_travel(6, [10, 15, 7, 11, 18, 13]) 3 pass","solution":"def min_energy_to_travel(n, heights): Returns the minimum energy required for Vlad to travel from the leftmost point to the rightmost point of the landscape. # Vlad can jump directly from the leftmost point to the rightmost point return abs(heights[0] - heights[-1])"},{"question":"from typing import List def can_be_converted_to_palindrome(s: str) -> bool: Determine if it is possible to convert the string s into a palindrome by performing any number of reverse operations on its substrings. >>> can_be_converted_to_palindrome(\\"abcba\\") True >>> can_be_converted_to_palindrome(\\"abccba\\") True >>> can_be_converted_to_palindrome(\\"ab\\") False pass def solve(t: int, test_cases: List[str]) -> List[str]: For each test case, determine if it is possible to convert the string into a palindrome by performing any number of reverse operations on its substrings. >>> solve(3, [\\"abcba\\", \\"abccba\\", \\"ab\\"]) [\\"YES\\", \\"YES\\", \\"NO\\"] >>> solve(2, [\\"a\\", \\"abcd\\"]) [\\"YES\\", \\"NO\\"] pass","solution":"def can_be_converted_to_palindrome(s): from collections import Counter char_count = Counter(s) odd_count = sum(1 for count in char_count.values() if count % 2 != 0) return odd_count <= 1 def solve(t, test_cases): results = [] for s in test_cases: if can_be_converted_to_palindrome(s): results.append(\\"YES\\") else: results.append(\\"NO\\") return results # Sample usage if __name__ == \\"__main__\\": t = 3 test_cases = [\\"abcba\\", \\"abccba\\", \\"ab\\"] print(solve(t, test_cases)) # Should output ['YES', 'YES', 'NO']"},{"question":"def does_intersect(x1, y1, w1, h1, x2, y2, w2, h2): Checks if two rectangles intersect. Rectangle 1: top-left is (x1, y1), width w1, height h1 Rectangle 2: top-left is (x2, y2), width w2, height h2 # Implementation here def detect_collisions(test_cases): Determines if the player's rectangle intersects with any obstacle rectangles. :param test_cases: List of test cases with player and obstacle rectangles information :return: List of strings \\"YES\\" or \\"NO\\" for each test case # Implementation here def test_does_intersect(): # Test cases where rectangles intersect assert does_intersect(1, 1, 3, 3, 2, 2, 3, 3) == True assert does_intersect(0, 0, 5, 5, 3, 3, 2, 2) == True # Test case where rectangles don't intersect assert does_intersect(1, 1, 3, 3, 5, 5, 2, 2) == False assert does_intersect(0, 0, 1, 1, 2, 2, 1, 1) == False def test_detect_collisions(): test_cases = [ { 'player': (1, 1, 3, 3), 'obstacles': [(2, 2, 3, 3), (5, 5, 2, 2)] }, { 'player': (0, 0, 5, 5), 'obstacles': [(3, 3, 2, 2)] }, { 'player': (0, 0, 1, 1), 'obstacles': [(2, 2, 1, 1)] } ] results = detect_collisions(test_cases) assert results == [\\"YES\\", \\"YES\\", \\"NO\\"] def test_additional_cases(): # No obstacles test_cases = [ { 'player': (0, 0, 10, 10), 'obstacles': [] }, { 'player': (5, 5, 2, 2), 'obstacles': [(10, 10, 1, 1)] } ] results = detect_collisions(test_cases) assert results == [\\"NO\\", \\"NO\\"]","solution":"def does_intersect(x1, y1, w1, h1, x2, y2, w2, h2): Checks if two rectangles intersect. Rectangle 1: top-left is (x1, y1), width w1, height h1 Rectangle 2: top-left is (x2, y2), width w2, height h2 return not (x1 + w1 <= x2 or x2 + w2 <= x1 or y1 + h1 <= y2 or y2 + h2 <= y1) def detect_collisions(test_cases): Determines if the player's rectangle intersects with any obstacle rectangles. :param test_cases: List of test cases with player and obstacle rectangles information :return: List of strings \\"YES\\" or \\"NO\\" for each test case results = [] for case in test_cases: x1, y1, w1, h1 = case['player'] obstacles = case['obstacles'] collision = any(does_intersect(x1, y1, w1, h1, *obs) for obs in obstacles) results.append(\\"YES\\" if collision else \\"NO\\") return results"},{"question":"def tennis_match_winner(n: int, points: List[str]) -> str: Determines the winner of a tennis match based on the points won by each player. Args: n (int): The number of points played. points (list of str): List of player names who won each point. Returns: str: The name of the match winner. >>> tennis_match_winner(5, [\\"alice\\", \\"bob\\", \\"alice\\", \\"alice\\", \\"bob\\"]) 'alice' >>> tennis_match_winner(6, [\\"john\\", \\"john\\", \\"john\\", \\"doe\\", \\"doe\\", \\"doe\\"]) 'john' pass def test_tennis_match_winner(): assert tennis_match_winner(5, [\\"alice\\", \\"bob\\", \\"alice\\", \\"alice\\", \\"bob\\"]) == \\"alice\\" assert tennis_match_winner(6, [\\"john\\", \\"john\\", \\"john\\", \\"doe\\", \\"doe\\", \\"doe\\"]) == \\"john\\" assert tennis_match_winner(4, [\\"alice\\", \\"alice\\", \\"bob\\", \\"bob\\"]) == \\"alice\\" assert tennis_match_winner(3, [\\"alice\\", \\"alice\\", \\"alice\\"]) == \\"alice\\" assert tennis_match_winner(2, [\\"bob\\", \\"bob\\"]) == \\"bob\\" def test_tennis_match_edge_cases(): assert tennis_match_winner(1, [\\"alice\\"]) == \\"alice\\" assert tennis_match_winner(1, [\\"john\\"]) == \\"john\\" assert tennis_match_winner(3, [\\"alice\\", \\"john\\", \\"alice\\"]) == \\"alice\\" assert tennis_match_winner(4, [\\"john\\", \\"alice\\", \\"john\\", \\"alice\\"]) == \\"john\\"","solution":"def tennis_match_winner(n, points): Determines the winner of a tennis match based on the points won by each player. Args: n (int): The number of points played. points (list of str): List of player names who won each point. Returns: str: The name of the match winner. from collections import defaultdict score = defaultdict(int) first_reach = {} for idx, player in enumerate(points): score[player] += 1 if player not in first_reach: first_reach[player] = idx max_points = max(score.values()) potential_winners = [player for player, points in score.items() if points == max_points] winner = min(potential_winners, key=lambda player: first_reach[player]) return winner"},{"question":"def max_total_deliciousness(N: int, K: int, D: int, S: List[int]) -> int: Find the maximum total deliciousness of the K selected pieces of sushi, given constraints. >>> max_total_deliciousness(5, 3, 2, [5, 3, 9, 1, 8]) 22 >>> max_total_deliciousness(7, 4, 3, [4, 8, 3, 7, 6, 5, 2]) 26 pass # Your code here # Unit tests def test_case1(): N, K, D = 5, 3, 2 S = [5, 3, 9, 1, 8] assert max_total_deliciousness(N, K, D, S) == 22 def test_case2(): N, K, D = 7, 4, 3 S = [4, 8, 3, 7, 6, 5, 2] assert max_total_deliciousness(N, K, D, S) == 26 def test_case3(): N, K, D = 4, 2, 1 S = [10, 7, 5, 12] assert max_total_deliciousness(N, K, D, S) == 22 def test_case4(): N, K, D = 6, 3, 2 S = [1, 100, 5, 50, 10, 100] assert max_total_deliciousness(N, K, D, S) == 250 def test_case5(): N, K, D = 3, 2, 1 S = [10, 20, 30] assert max_total_deliciousness(N, K, D, S) == 50","solution":"def max_total_deliciousness(N, K, D, S): # Initialize a DP table where dp[i][k] represents the maximum deliciousness # by considering the first i sushis and taking k sushis dp = [[-float('inf')] * (K + 1) for _ in range(N + 1)] # base case, selecting 0 elements for i in range(N + 1): dp[i][0] = 0 # Solve the DP for i in range(1, N + 1): for k in range(1, K + 1): # Calculate maximum deliciousness by including or not including current piece dp[i][k] = dp[i-1][k] # Not including the i-th sushi for l in range(max(0, i-D), i): # Trying to include the i-th sushi and ensuring position difference <= D dp[i][k] = max(dp[i][k], dp[l][k-1] + S[i-1]) return dp[N][K]"},{"question":"def count_distinct_adjacent_pairs_different_colors(N: int, colors: List[int]) -> int: Counts the number of distinct adjacent bead pairs with different colors. Args: N (int): Number of beads. colors (list of int): Colors of the beads. Returns: int: Number of distinct pairs of adjacent beads with different colors. >>> count_distinct_adjacent_pairs_different_colors(6, [1, 2, 3, 4, 3, 2]) 6 >>> count_distinct_adjacent_pairs_different_colors(4, [1, 1, 2, 2]) 2 # Test cases def test_example_1(): N = 6 colors = [1, 2, 3, 4, 3, 2] assert count_distinct_adjacent_pairs_different_colors(N, colors) == 6 def test_example_2(): N = 4 colors = [1, 1, 2, 2] assert count_distinct_adjacent_pairs_different_colors(N, colors) == 2 def test_all_same_color(): N = 5 colors = [3, 3, 3, 3, 3] assert count_distinct_adjacent_pairs_different_colors(N, colors) == 0 def test_two_different_colors(): N = 2 colors = [1, 2] assert count_distinct_adjacent_pairs_different_colors(N, colors) == 2 def test_alternating_colors(): N = 6 colors = [1, 2, 1, 2, 1, 2] assert count_distinct_adjacent_pairs_different_colors(N, colors) == 6 def test_large_input(): N = 100000 colors = [i % 100 for i in range(N)] assert count_distinct_adjacent_pairs_different_colors(N, colors) == N def test_edges_different_colors(): N = 3 colors = [1, 1, 2] assert count_distinct_adjacent_pairs_different_colors(N, colors) == 2","solution":"def count_distinct_adjacent_pairs_different_colors(N, colors): Counts the number of distinct adjacent bead pairs with different colors. Args: N (int): Number of beads. colors (list of int): Colors of the beads. Returns: int: Number of distinct pairs of adjacent beads with different colors. count = 0 # Since the necklace is circular, consider the beads in a circular manner for i in range(N): if colors[i] != colors[(i + 1) % N]: count += 1 return count"},{"question":"def can_partition_equal_sum(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[str]: Determine if it is possible to partition the list into two non-empty sublists such that the sum of the elements in both sublists is equal. Args: t (int): The number of test cases. test_cases (List[Tuple[int, List[int]]]): The list of test cases, where each test case is a tuple containing an integer n and a list of n integers. Returns: List[str]: A list of strings with \\"YES\\" or \\"NO\\" for each test case. Example: >>> can_partition_equal_sum(3, [(4, [1, 2, 3, 4]), (5, [1, 1, 1, 1, 2]), (3, [-1, 1, 0])]) [\\"NO\\", \\"YES\\", \\"YES\\"]","solution":"def can_partition_equal_sum(t, test_cases): results = [] for test_case in test_cases: n, a = test_case total_sum = sum(a) if total_sum % 2 != 0: results.append(\\"NO\\") continue target_sum = total_sum // 2 current_sum = 0 found = False for num in a: current_sum += num if current_sum == target_sum: found = True break if found: results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"from typing import List, Tuple def max_honey(p: int, q: int, n: int, grid: List[str], hives: List[Tuple[int, int, int]]) -> int: Determine the maximum amount of honey Limak can collect in one hour. >>> p = 5 >>> q = 5 >>> n = 2 >>> grid = [ ... \\".....\\", ... \\"..#..\\", ... \\"..H..\\", ... \\"..#..\\", ... \\"..S..\\" ... ] >>> hives = [(3, 3, 500), (4, 1, 300)] >>> max_honey(p, q, n, grid, hives) 500 >>> p = 5 >>> q = 5 >>> n = 3 >>> grid = [ ... \\".....\\", ... \\".#H#.\\", ... \\"..H..\\", ... \\".#H#.\\", ... \\"..S..\\" ... ] >>> hives = [(2, 3, 400), (3, 3, 600), (4, 3, 200)] >>> max_honey(p, q, n, grid, hives) 600 >>> p = 5 >>> q = 5 >>> n = 1 >>> grid = [ ... \\"..#..\\", ... \\".#.\\", ... \\".#H#.\\", ... \\".#.\\", ... \\"..S..\\" ... ] >>> hives = [(3, 3, 300)] >>> max_honey(p, q, n, grid, hives) 0","solution":"from collections import deque def max_honey(p, q, n, grid, hives): def bfs(start): directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] queue = deque([start]) visited = set([start]) reachable_honey = [] while queue: x, y = queue.popleft() if grid[x][y] == 'H': for hx, hy, honey in hives: if (hx - 1, hy - 1) == (x, y): reachable_honey.append(honey) break for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < p and 0 <= ny < q and (nx, ny) not in visited and grid[nx][ny] != '#': visited.add((nx, ny)) queue.append((nx, ny)) return max(reachable_honey) if reachable_honey else 0 start = None for i in range(p): for j in range(q): if grid[i][j] == 'S': start = (i, j) break if start: break return bfs(start) # Example input p = 5 q = 5 n = 2 grid = [ \\".....\\", \\"..#..\\", \\"..H..\\", \\"..#..\\", \\"..S..\\" ] hives = [(3, 3, 500), (4, 1, 300)] print(max_honey(p, q, n, grid, hives)) # Output should be 500"},{"question":"from typing import List def maxProduct(nums: List[int]) -> int: Find the contiguous subarray (containing at least one number) which has the largest product, and return its product. >>> maxProduct([2, 3, -2, 4]) == 6 >>> maxProduct([-2, 0, -1]) == 0 >>> maxProduct([-2, 3, -4]) == 24","solution":"from typing import List def maxProduct(nums: List[int]) -> int: if not nums: return 0 max_prod = min_prod = result = nums[0] for num in nums[1:]: if num < 0: max_prod, min_prod = min_prod, max_prod max_prod = max(num, max_prod * num) min_prod = min(num, min_prod * num) result = max(result, max_prod) return result"},{"question":"from typing import List def max_water(heights: List[int]) -> int: Calculate the maximum amount of water that can be stored between the bars in a histogram. Args: heights (List[int]): A list of non-negative integers representing the heights of the bars. Returns: int: The maximum units of water that can be stored. Examples: >>> max_water([3, 0, 2, 0, 4]) 7 >>> max_water([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) 6 >>> max_water([4, 2, 0, 3, 2, 5]) 9 >>> max_water([]) 0 >>> max_water([1, 2, 3, 4, 5]) 0 >>> max_water([2]) 0 >>> max_water([1, 1]) 0 >>> max_water([3, 3, 3, 3]) 0","solution":"from typing import List def max_water(heights: List[int]) -> int: if not heights or len(heights) < 3: return 0 left, right = 0, len(heights) - 1 left_max, right_max = heights[left], heights[right] water = 0 while left < right: if left_max < right_max: left += 1 left_max = max(left_max, heights[left]) water += max(0, left_max - heights[left]) else: right -= 1 right_max = max(right_max, heights[right]) water += max(0, right_max - heights[right]) return water"},{"question":"from typing import List def max_substring_no_repeats(s: str) -> int: Returns the maximum length of a substring containing no repeating characters after performing deletions. pass def process_test_cases(t: int, test_cases: List[str]) -> List[int]: Processes multiple test cases and returns the results for each one. Args: t: The number of test cases. test_cases: A list of strings representing each test case. Returns: A list of integers, each representing the result for the corresponding test case. pass def test_max_substring_no_repeats_single_case(): assert max_substring_no_repeats(\\"abac\\") == 2 assert max_substring_no_repeats(\\"abcabc\\") == 2 assert max_substring_no_repeats(\\"aabbcc\\") == 2 def test_process_test_cases(): assert process_test_cases(3, [\\"abac\\", \\"abcabc\\", \\"aabbcc\\"]) == [2, 2, 2]","solution":"def max_substring_no_repeats(s): Returns the maximum length of a substring containing no repeating characters after performing deletions. unique_characters = set(s) return len(unique_characters) def process_test_cases(t, test_cases): results = [] for s in test_cases: results.append(max_substring_no_repeats(s)) return results"},{"question":"def consolidate_inventory(transactions): Consolidates and sorts inventory transactions. Args: transactions (list of tuples): Each tuple contains an item type (string) and quantity (int). Returns: list of tuples: Consolidated and sorted inventory. Examples: >>> consolidate_inventory([(\\"Apples\\", 10), (\\"Bananas\\", 5), (\\"Apples\\", 20), (\\"Oranges\\", 7), (\\"Bananas\\", 3)]) [(\\"Apples\\", 30), (\\"Bananas\\", 8), (\\"Oranges\\", 7)] >>> consolidate_inventory([(\\"Paper\\", 15), (\\"Pen\\", 5), (\\"Notebook\\", 12), (\\"Pen\\", 3), (\\"Eraser\\", 10)]) [(\\"Eraser\\", 10), (\\"Notebook\\", 12), (\\"Paper\\", 15), (\\"Pen\\", 8)]","solution":"def consolidate_inventory(transactions): Consolidates and sorts inventory transactions. Args: transactions (list of tuples): Each tuple contains an item type (string) and quantity (int). Returns: list of tuples: Consolidated and sorted inventory. inventory = {} for item, quantity in transactions: if item in inventory: inventory[item] += quantity else: inventory[item] = quantity consolidated_list = sorted(inventory.items()) return consolidated_list"},{"question":"def average_unique_words(book_data): Computes the average number of unique words per book. :param book_data: List of book descriptions where each description contains the total number of words followed by that many words. :return: The average number of unique words per book. pass def test_average_unique_words_example1(): data = [ 2, 3, \\"Hello\\", \\"world\\", \\"world\\", 5, \\"Programming\\", \\"is\\", \\"fun\\", \\"fun\\", \\"fun\\" ] assert average_unique_words(data) == 2.50 def test_average_unique_words_all_unique(): data = [ 1, 5, \\"one\\", \\"two\\", \\"three\\", \\"four\\", \\"five\\" ] assert average_unique_words(data) == 5.00 def test_average_unique_words_all_same(): data = [ 2, 3, \\"same\\", \\"same\\", \\"same\\", 4, \\"repeat\\", \\"repeat\\", \\"repeat\\", \\"repeat\\" ] assert average_unique_words(data) == 1.00 def test_average_unique_words_no_words(): data = [1, 0] assert average_unique_words(data) == 0.00 def test_average_unique_words_mixed_case(): data = [ 1, 5, \\"Test\\", \\"test\\", \\"TEST\\", \\"tEst\\", \\"tesT\\" ] assert average_unique_words(data) == 5.00 def test_average_unique_words_descriptions_varied_lengths(): data = [ 3, 3, \\"apple\\", \\"banana\\", \\"cherry\\", 2, \\"apple\\", \\"apple\\", 4, \\"apple\\", \\"banana\\", \\"banana\\", \\"banana\\" ] assert average_unique_words(data) == 2.00","solution":"def average_unique_words(book_data): Computes the average number of unique words per book. :param book_data: List of book descriptions where each description contains the total number of words followed by that many words. :return: The average number of unique words per book. num_books = book_data[0] index = 1 unique_word_counts = [] for _ in range(num_books): m = book_data[index] index += 1 words = book_data[index:index + m] unique_words = set(words) unique_word_counts.append(len(unique_words)) index += m average_unique = sum(unique_word_counts) / num_books return round(average_unique, 2)"},{"question":"def max_strength_per_test(n: int, S: List[int]) -> int: Calculate the maximum possible total strength the warrior can achieve for a single test case. >>> max_strength_per_test(4, [1, 2, 9, 4]) 9 >>> max_strength_per_test(5, [3, 5, 7, 10, 2]) 10 >>> max_strength_per_test(1, [5]) 5 >>> max_strength_per_test(3, [2, 1, 4]) 4 >>> max_strength_per_test(6, [1, 2, 3, 4, 5, 6]) 6 def max_strength_all_tests(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Calculate the maximum possible total strength the warrior can achieve for all test cases. >>> result = max_strength_all_tests(2, [(4, [1, 2, 9, 4]), (5, [3, 5, 7, 10, 2])]) >>> result [9, 10] >>> result = max_strength_all_tests(3, [(4, [5, 6, 3, 4]), (5, [10, 3, 4, 8, 7]), (2, [8, 9])]) >>> result [6, 10, 9] >>> result = max_strength_all_tests(1, [(1, [1000000000])]) >>> result [1000000000]","solution":"def max_strength_per_test(n, S): max_strength = 0 for i in range(n - 1, -1, -1): if S[i] > max_strength: max_strength = S[i] return max_strength def max_strength_all_tests(t, test_cases): results = [] for i in range(t): n, S = test_cases[i] results.append(max_strength_per_test(n, S)) return results"},{"question":"def max_sum_path(matrix: List[List[int]]) -> int: Calculate the maximum sum of integers that can be collected by starting from the top-left corner of the matrix and moving to the bottom-right corner, only moving right or down at each step. :param matrix: List of lists of integers representing the matrix :return: Integer, maximum sum possible >>> max_sum_path([ ... [1, 3, 1], ... [1, 5, 1], ... [4, 2, 1] ... ]) == 12 >>> max_sum_path([[7]]) == 7 >>> max_sum_path([[1, 2, 3, 4]]) == 10 >>> max_sum_path([[1], [2], [3], [4]]) == 10 >>> max_sum_path([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) == 29 >>> max_sum_path([ ... [0, 0, 0], ... [0, 0, 0], ... [0, 0, 0] ... ]) == 0 >>> max_sum_path([ ... [1000000000, 1000000000], ... [1000000000, 1000000000] ... ]) == 3000000000 pass","solution":"def max_sum_path(matrix): Calculate the maximum sum of integers that can be collected by starting from the top-left corner of the matrix and moving to the bottom-right corner, only moving right or down at each step. :param matrix: List of lists of integers representing the matrix :return: Integer, maximum sum possible if not matrix or not matrix[0]: return 0 n, m = len(matrix), len(matrix[0]) dp = [[0] * m for _ in range(n)] # Fill the dp matrix dp[0][0] = matrix[0][0] for i in range(1, n): dp[i][0] = dp[i-1][0] + matrix[i][0] for j in range(1, m): dp[0][j] = dp[0][j-1] + matrix[0][j] for i in range(1, n): for j in range(1, m): dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + matrix[i][j] return dp[-1][-1]"},{"question":"def max_straight_path(n: int, m: int, blocked: List[Tuple[int, int]]) -> int: Determine the maximum possible length of a straight path that can be placed on the grid without entering any blocked cell. Parameters: - n (int): Number of rows in the grid. - m (int): Number of columns in the grid. - blocked (List[Tuple[int, int]]): A list of tuples where each tuple represents the position of a blocked cell. Returns: - int: The maximum possible length of a straight path. Example: >>> max_straight_path(5, 5, [(2, 2), (3, 3), (4, 4)]) 5 >>> max_straight_path(2, 2, [(1, 1), (1, 2), (2, 1), (2, 2)]) 0 pass # Unit tests def test_example_case(): assert max_straight_path(5, 5, [(2, 2), (3, 3), (4,4)]) == 5 def test_no_blocked_cells(): assert max_straight_path(5, 5, []) == 5 def test_all_cells_blocked(): assert max_straight_path(2, 2, [(1, 1), (1, 2), (2, 1), (2, 2)]) == 0 def test_alternating_blocks(): assert max_straight_path(3, 3, [(1, 2), (2, 2), (3, 2)]) == 3 def test_single_cell(): assert max_straight_path(1, 1, []) == 1 assert max_straight_path(1, 1, [(1,1)]) == 0 def test_larger_grid(): assert max_straight_path(10, 10, [(i, i) for i in range(1, 11)]) == 9","solution":"def max_straight_path(n, m, blocked): # Create a grid initialized with True indicating all cells are initially free grid = [[True for _ in range(m)] for _ in range(n)] # Mark blocked cells as False for (r, c) in blocked: grid[r - 1][c - 1] = False max_length = 0 # Check for maximum path length in each row for i in range(n): current_length = 0 for j in range(m): if grid[i][j]: current_length += 1 max_length = max(max_length, current_length) else: current_length = 0 # Check for maximum path length in each column for j in range(m): current_length = 0 for i in range(n): if grid[i][j]: current_length += 1 max_length = max(max_length, current_length) else: current_length = 0 return max_length"},{"question":"def num_unique_bsts(n: int) -> int: Compute the number of unique binary trees that can be formed using all values from 1 to n such that the binary tree is complete and the in-order traversal sequence is sorted from 1 to n. >>> num_unique_bsts(1) == 1 >>> num_unique_bsts(2) == 2 >>> num_unique_bsts(3) == 5 >>> num_unique_bsts(4) == 14 >>> num_unique_bsts(5) == 42 >>> num_unique_bsts(19) == 1767263190 % 1000000007 pass from solution import num_unique_bsts def test_num_unique_bsts_1(): assert num_unique_bsts(1) == 1 def test_num_unique_bsts_2(): assert num_unique_bsts(2) == 2 def test_num_unique_bsts_3(): assert num_unique_bsts(3) == 5 def test_num_unique_bsts_4(): assert num_unique_bsts(4) == 14 def test_num_unique_bsts_5(): assert num_unique_bsts(5) == 42 def test_num_unique_bsts_large(): # Test with a larger value to check the correctness assert num_unique_bsts(19) == 1767263190 % 1000000007 # The result for n=19 Catalan number","solution":"MOD = 1000000007 def num_unique_bsts(n): if n == 0 or n == 1: return 1 catalan = [0] * (n + 1) catalan[0] = 1 catalan[1] = 1 for i in range(2, n + 1): for j in range(i): catalan[i] = (catalan[i] + (catalan[j] * catalan[i - 1 - j]) % MOD) % MOD return catalan[n]"},{"question":"def preprocess_matrix(matrix): Preprocess the matrix to create a prefix sum matrix. The prefix sum matrix allows for efficient submatrix sum queries. Args: matrix (List[List[int]]): The matrix to preprocess. Returns: List[List[int]]: The prefix sum matrix. Example: >>> preprocess_matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) [[0, 0, 0, 0], [0, 1, 3, 6], [0, 5, 12, 21], [0, 12, 27, 45]] pass def submatrix_sum(prefix_sum, r1, c1, r2, c2): Calculate the sum of elements in the submatrix defined by (r1, c1) to (r2, c2) using the prefix sum matrix. Args: prefix_sum (List[List[int]]): The prefix sum matrix. r1 (int): The starting row index of the submatrix (1-based index). c1 (int): The starting column index of the submatrix (1-based index). r2 (int): The ending row index of the submatrix (1-based index). c2 (int): The ending column index of the submatrix (1-based index). Returns: int: The sum of elements in the specified submatrix. Example: >>> prefix_sum = preprocess_matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) >>> submatrix_sum(prefix_sum, 1, 1, 2, 2) 12 >>> submatrix_sum(prefix_sum, 2, 2, 3, 3) 28 pass","solution":"def preprocess_matrix(matrix): m, n = len(matrix), len(matrix[0]) prefix_sum = [[0] * (n + 1) for _ in range(m + 1)] for i in range(m): for j in range(n): prefix_sum[i + 1][j + 1] = matrix[i][j] + prefix_sum[i + 1][j] + prefix_sum[i][j + 1] - prefix_sum[i][j] return prefix_sum def submatrix_sum(prefix_sum, r1, c1, r2, c2): return ( prefix_sum[r2][c2] - prefix_sum[r1 - 1][c2] - prefix_sum[r2][c1 - 1] + prefix_sum[r1 - 1][c1 - 1] )"},{"question":"def length_of_longest_substring(s: str) -> int: Returns the length of the longest substring without repeating characters. >>> length_of_longest_substring(\\"abcabcbb\\") 3 >>> length_of_longest_substring(\\"bbbbb\\") 1 >>> length_of_longest_substring(\\"\\") 0 >>> length_of_longest_substring(\\"a\\") 1 >>> length_of_longest_substring(\\"pwwkew\\") 3 >>> length_of_longest_substring(\\"dvdf\\") 3 >>> length_of_longest_substring(\\"anviaj\\") 5 def process_input(strings: List[str]) -> List[int]: Processes the list of input strings, omitting the string \\"END\\" and returning the length of the longest substring without repeating characters for each string. >>> process_input([\\"abcabcbb\\", \\"bbbbb\\", \\"pwwkew\\", \\"END\\"]) [3, 1, 3] >>> process_input([\\"pwwkew\\", \\"aabbcc\\", \\"aab\\", \\"END\\"]) [3, 2, 2] >>> process_input([\\"dvdf\\", \\"anviaj\\", \\"END\\"]) [3, 5] >>> process_input([\\"END\\"]) [] >>> process_input([\\"abba\\", \\"abcabcbb\\", \\"END\\"]) [2, 3]","solution":"def length_of_longest_substring(s): Returns the length of the longest substring without repeating characters. n = len(s) if n == 0: return 0 char_index_map = {} max_length = 0 start = 0 for end in range(n): if s[end] in char_index_map: start = max(char_index_map[s[end]] + 1, start) char_index_map[s[end]] = end max_length = max(max_length, end - start + 1) return max_length def process_input(strings): results = [] for s in strings: if s == \\"END\\": break results.append(length_of_longest_substring(s)) return results"},{"question":"def can_fit_inside(x1, y1, z1, w1, h1, d1, x2, y2, z2, w2, h2, d2): Determines if the smaller box can fit entirely inside the larger box. Parameters: - x1, y1, z1: Coordinates of the lower-left-back corner of the larger box. - w1, h1, d1: Width, height, and depth of the larger box along the x, y, and z axes. - x2, y2, z2: Coordinates of the lower-left-back corner of the smaller box. - w2, h2, d2: Width, height, and depth of the smaller box along the x, y, and z axes. Returns: - \\"Yes\\" if the smaller box can fit inside the larger box without protruding. - \\"No\\" otherwise. def process_datasets(datasets): Processes multiple datasets to determine if smaller boxes can fit inside larger boxes. Parameters: - datasets: List of datasets, each containing 12 integers representing the coordinates and dimensions of the larger and smaller boxes as described. Returns: - List of strings \\"Yes\\" or \\"No\\" for each dataset. results = [] for dataset in datasets: x1, y1, z1, w1, h1, d1, x2, y2, z2, w2, h2, d2 = dataset result = can_fit_inside(x1, y1, z1, w1, h1, d1, x2, y2, z2, w2, h2, d2) results.append(result) return results # Unit tests def test_fit_inside(): assert can_fit_inside(0, 0, 0, 10, 10, 10, 2, 2, 2, 5, 5, 5) == \\"Yes\\" assert can_fit_inside(0, 0, 0, 10, 10, 10, 5, 5, 5, 7, 7, 7) == \\"No\\" assert can_fit_inside(-5, -5, -5, 15, 15, 15, -4, -4, -4, 7, 7, 7) == \\"Yes\\" assert can_fit_inside(1, 1, 1, 10, 10, 10, 2, 2, 2, 5, 5, 15) == \\"No\\" assert can_fit_inside(0, 0, 0, 10, 10, 10, -5, -5, -5, 5, 5, 5) == \\"No\\" def test_process_datasets(): datasets = [ (0, 0, 0, 10, 10, 10, 2, 2, 2, 5, 5, 5), (0, 0, 0, 10, 10, 10, 5, 5, 5, 7, 7, 7), (-5, -5, -5, 15, 15, 15, -4, -4, -4, 7, 7, 7) ] expected = [\\"Yes\\", \\"No\\", \\"Yes\\"] assert process_datasets(datasets) == expected","solution":"def can_fit_inside(x1, y1, z1, w1, h1, d1, x2, y2, z2, w2, h2, d2): Determines if the smaller box can fit entirely inside the larger box. Parameters: - x1, y1, z1: Coordinates of the lower-left-back corner of the larger box. - w1, h1, d1: Width, height, and depth of the larger box along the x, y, and z axes. - x2, y2, z2: Coordinates of the lower-left-back corner of the smaller box. - w2, h2, d2: Width, height, and depth of the smaller box along the x, y, and z axes. Returns: - \\"Yes\\" if the smaller box can fit inside the larger box without protruding. - \\"No\\" otherwise. # Larger box boundaries x1_max = x1 + w1 y1_max = y1 + h1 z1_max = z1 + d1 # Smaller box boundaries x2_max = x2 + w2 y2_max = y2 + h2 z2_max = z2 + d2 # Check if every corner/edge of the smaller box fits inside the larger box if (x1 <= x2 <= x1_max and x1 <= x2_max <= x1_max and y1 <= y2 <= y1_max and y1 <= y2_max <= y1_max and z1 <= z2 <= z1_max and z1 <= z2_max <= z1_max): return \\"Yes\\" else: return \\"No\\" def process_datasets(datasets): results = [] for dataset in datasets: x1, y1, z1, w1, h1, d1, x2, y2, z2, w2, h2, d2 = dataset result = can_fit_inside(x1, y1, z1, w1, h1, d1, x2, y2, z2, w2, h2, d2) results.append(result) return results"},{"question":"from typing import List, Tuple def preprocess_matrix(matrix: List[List[int]]) -> List[List[int]]: Preprocesses the matrix and returns a prefix sums matrix for efficient query processing. Parameters: matrix (List[List[int]]): The input matrix Returns: List[List[int]]: The prefix sums matrix >>> preprocess_matrix([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) [ [0, 0, 0, 0], [0, 1, 3, 6], [0, 5, 12, 21], [0, 12, 27, 45] ] pass def query_sum(prefix_sums: List[List[int]], t1: int, t2: int, b1: int, b2: int) -> int: Computes the sum of elements in the submatrix defined by top-left (t1, t2) and bottom-right (b1, b2) using prefix sums. Parameters: prefix_sums (List[List[int]]): The prefix sums matrix t1 (int): Top-left row index of the submatrix t2 (int): Top-left column index of the submatrix b1 (int): Bottom-right row index of the submatrix b2 (int): Bottom-right column index of the submatrix Returns: int: The sum of elements in the submatrix >>> prefix_sums = [ ... [0, 0, 0, 0], ... [0, 1, 3, 6], ... [0, 5, 12, 21], ... [0, 12, 27, 45] ...] >>> query_sum(prefix_sums, 1, 1, 3, 3) 45 >>> query_sum(prefix_sums, 1, 1, 2, 2) 12 >>> query_sum(prefix_sums, 2, 2, 3, 3) 28 pass def process_queries(matrix: List[List[int]], queries: List[Tuple[int, int, int, int]]) -> List[int]: Processes all submatrix sum queries and returns their results. Parameters: matrix (List[List[int]]): The input matrix queries (List[Tuple[int, int, int, int]]): List of queries, each defined by top-left and bottom-right corners Returns: List[int]: The results for each query >>> matrix = [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ...] >>> queries = [ ... (1, 1, 3, 3), ... (1, 1, 2, 2), ... (2, 2, 3, 3) ...] >>> process_queries(matrix, queries) [45, 12, 28] pass def test_preprocess_matrix(): matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] expected_prefix_sums = [ [0, 0, 0, 0], [0, 1, 3, 6], [0, 5, 12, 21], [0, 12, 27, 45] ] assert preprocess_matrix(matrix) == expected_prefix_sums def test_query_sum(): prefix_sums = [ [0, 0, 0, 0], [0, 1, 3, 6], [0, 5, 12, 21], [0, 12, 27, 45] ] assert query_sum(prefix_sums, 1, 1, 3, 3) == 45 assert query_sum(prefix_sums, 1, 1, 2, 2) == 12 assert query_sum(prefix_sums, 2, 2, 3, 3) == 28 def test_process_queries(): matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] queries = [ (1, 1, 3, 3), (1, 1, 2, 2), (2, 2, 3, 3) ] expected_results = [ 45, 12, 28 ] assert process_queries(matrix, queries) == expected_results","solution":"def preprocess_matrix(matrix): Preprocesses the matrix and returns a prefix sums matrix for efficient query processing. n = len(matrix) m = len(matrix[0]) prefix_sums = [[0] * (m + 1) for _ in range(n + 1)] for i in range(1, n + 1): for j in range(1, m + 1): prefix_sums[i][j] = matrix[i-1][j-1] + prefix_sums[i-1][j] + prefix_sums[i][j-1] - prefix_sums[i-1][j-1] return prefix_sums def query_sum(prefix_sums, t1, t2, b1, b2): Computes the sum of elements in the submatrix defined by top-left (t1, t2) and bottom-right (b1, b2) using prefix sums. return (prefix_sums[b1][b2] - prefix_sums[t1-1][b2] - prefix_sums[b1][t2-1] + prefix_sums[t1-1][t2-1]) def process_queries(matrix, queries): Processes all submatrix sum queries and returns their results. prefix_sums = preprocess_matrix(matrix) results = [] for query in queries: t1, t2, b1, b2 = query result = query_sum(prefix_sums, t1, t2, b1, b2) results.append(result) return results"},{"question":"from typing import List, Tuple def unique_subsequences(n: int, k: int, sequence: List[int]) -> List[Tuple[int, ...]]: Returns all unique subsequences of length k from the given sequence in lexicographical order. >>> unique_subsequences(5, 3, [1, 2, 2, 3, 4]) [(1, 2, 2), (1, 2, 3), (1, 2, 4), (1, 3, 4), (2, 2, 3), (2, 2, 4), (2, 3, 4)] >>> unique_subsequences(4, 2, [1, 1, 1, 1]) [(1, 1)] >>> unique_subsequences(3, 3, [3, 1, 2]) [(1, 2, 3)] >>> unique_subsequences(3, 1, [3, 1, 2]) [(1,), (2,), (3,)] >>> unique_subsequences(4, 2, [2, 2, 3, 3]) [(2, 2), (2, 3), (3, 3)]","solution":"from itertools import combinations def unique_subsequences(n, k, sequence): Returns all unique subsequences of length k from the given sequence in lexicographical order. sequence.sort() subsequences = sorted(set(combinations(sequence, k))) return subsequences"},{"question":"def min_moves_to_reach_target(n: int, m: int, grid: List[str], start: Tuple[int, int], target: Tuple[int, int]) -> int: Determine the minimum number of moves required to reach the target in a grid, or return -1 if it is not possible. Args: - n (int): The number of rows in the grid. - m (int): The number of columns in the grid. - grid (List[str]): The grid, represented as a list of strings. - start (Tuple[int, int]): The starting coordinates (x1, y1) of the robot. - target (Tuple[int, int]): The target coordinates (x2, y2) where the robot must reach. Returns: - int: The minimum number of moves required to reach the target, or -1 if not possible. >>> n = 5 >>> m = 5 >>> grid = [\\".....\\",\\".#.#.\\",\\".#.#.\\",\\"...#.\\",\\"#....\\"] >>> start = (1, 1) >>> target = (5, 5) >>> min_moves_to_reach_target(n, m, grid, start, target) 8 >>> n = 3 >>> m = 3 >>> grid = [\\".#.\\",\\"#\\",\\"...\\"] >>> start = (1, 1) >>> target = (3, 3) >>> min_moves_to_reach_target(n, m, grid, start, target) -1 pass","solution":"from collections import deque def min_moves_to_reach_target(n, m, grid, start, target): x1, y1 = start x2, y2 = target # Define the four possible movement directions directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # Up, Down, Left, Right # Queue for BFS, starting point with 0 moves queue = deque([(x1 - 1, y1 - 1, 0)]) # zero-based indexing visited = set([(x1 - 1, y1 - 1)]) while queue: x, y, moves = queue.popleft() # Check if reached the target if (x, y) == (x2 - 1, y2 - 1): return moves # Explore the grid in four possible directions for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and (nx, ny) not in visited and grid[nx][ny] == '.': visited.add((nx, ny)) queue.append((nx, ny, moves + 1)) return -1 # Example usage: # Read input (for example purposes, inputs should be managed externally during actual execution) n = 5 m = 5 grid = [ \\".....\\", \\".#.#.\\", \\".#.#.\\", \\"...#.\\", \\"#....\\" ] start = (1, 1) target = (5, 5) print(min_moves_to_reach_target(n, m, grid, start, target))"},{"question":"def magical_square(n: int) -> List[List[str]]: Generate a magical square grid of size n x n (where n is an odd integer). Each cell either contains an 'X' or an 'O' following these rules: 1. The center of the grid must contain 'X'. 2. For each row and each column, if the distance from a cell to the center is even, then the cell must contain 'X'. 3. Otherwise, the cell must contain 'O'. The distance from a cell (i, j) to the center (c, c) of the grid is defined as |i - c| + |j - c|, where c = (n - 1) // 2. >>> magical_square(3) [['X', 'O', 'X'], ['O', 'X', 'O'], ['X', 'O', 'X']] >>> magical_square(5) [['X', 'O', 'X', 'O', 'X'], ['O', 'X', 'O', 'X', 'O'], ['X', 'O', 'X', 'O', 'X'], ['O', 'X', 'O', 'X', 'O'], ['X', 'O', 'X', 'O', 'X']] def print_grid(grid: List[List[str]]) -> None: for row in grid: print(' '.join(row))","solution":"def magical_square(n): grid = [['' for _ in range(n)] for _ in range(n)] center = n // 2 for i in range(n): for j in range(n): distance = abs(i - center) + abs(j - center) if distance % 2 == 0: grid[i][j] = 'X' else: grid[i][j] = 'O' return grid def print_grid(grid): for row in grid: print(' '.join(row)) # Example usage n = 5 grid = magical_square(n) print_grid(grid)"},{"question":"def smart_home_system(test_cases): Monitor and control smart devices in a house. Parameters: test_cases (List[Dict]): A list of test cases, each containing: - n (int): Number of devices. - q (int): Number of queries. - devices (List[Tuple[str, int]]): List of device names and their initial states (0 for OFF, 1 for ON). - queries (List[str]): List of queries which are either \\"status device_name\\" or \\"toggle device_name\\". Returns: List[str]: List of statuses after processing queries (either \\"ON\\" or \\"OFF\\"). Example: >>> test_cases = [ { 'n': 3, 'q': 4, 'devices': [('light1', 1), ('temp_sensor', 0), ('door', 1)], 'queries': ['status light1', 'toggle light1', 'status light1', 'status door'] }, ] >>> smart_home_system(test_cases) ['ON', 'OFF', 'ON'] result = [] for case in test_cases: n, q = case['n'], case['q'] devices = {d: s for d, s in case['devices']} queries = case['queries'] for query in queries: query_type, device = query.split() if query_type == \\"status\\": result.append(\\"ON\\" if devices[device] else \\"OFF\\") elif query_type == \\"toggle\\": devices[device] = 1 if devices[device] == 0 else 0 return result","solution":"def smart_home_system(test_cases): result = [] for case in test_cases: n, q = case['n'], case['q'] devices = {d: s for d, s in case['devices']} queries = case['queries'] for query in queries: query_type, device = query.split() if query_type == \\"status\\": result.append(\\"ON\\" if devices[device] else \\"OFF\\") elif query_type == \\"toggle\\": devices[device] = 1 if devices[device] == 0 else 0 return result"},{"question":"import json def convert_array_to_object(json_array_str: str) -> str: Converts a JSON array of objects into a single object with keys being the 'id' properties. Args: json_array_str (str): A JSON array string of objects where each object contains an 'id' key. Returns: str: A JSON string representing an object where keys are the 'id' values and values are the objects. >>> convert_array_to_object('[{\\"id\\": \\"a\\", \\"value\\": 1}, {\\"id\\": \\"b\\", \\"value\\": 2}, {\\"id\\": \\"c\\", \\"value\\": 3}]') '{\\"a\\": {\\"id\\": \\"a\\", \\"value\\": 1}, \\"b\\": {\\"id\\": \\"b\\", \\"value\\": 2}, \\"c\\": {\\"id\\": \\"c\\", \\"value\\": 3}}' >>> convert_array_to_object('[{\\"id\\": \\"101\\", \\"name\\": \\"Alice\\"}, {\\"id\\": \\"102\\", \\"name\\": \\"Bob\\"}]') '{\\"101\\": {\\"id\\": \\"101\\", \\"name\\": \\"Alice\\"}, \\"102\\": {\\"id\\": \\"102\\", \\"name\\": \\"Bob\\"}}' >>> convert_array_to_object('[]') '{}' >>> convert_array_to_object('[{\\"id\\": \\"id1\\", \\"data\\": \\"single object\\"}]') '{\\"id1\\": {\\"id\\": \\"id1\\", \\"data\\": \\"single object\\"}}' >>> convert_array_to_object('[{\\"id\\": \\"x\\", \\"value\\": 40}, {\\"id\\": \\"y\\", \\"value\\": 50, \\"extra\\": \\"data\\"}]') '{\\"x\\": {\\"id\\": \\"x\\", \\"value\\": 40}, \\"y\\": {\\"id\\": \\"y\\", \\"value\\": 50, \\"extra\\": \\"data\\"}}'","solution":"import json def convert_array_to_object(json_array_str): Converts a JSON array of objects into a single object with keys being the 'id' properties. Args: json_array_str (str): A JSON array string of objects where each object contains an 'id' key. Returns: str: A JSON string representing an object where keys are the 'id' values and values are the objects. json_array = json.loads(json_array_str) result = {item['id']: item for item in json_array} return json.dumps(result)"},{"question":"def increment_grid(n: int, q: int, operations: List[Tuple[int, int, int, int]]) -> List[List[int]]: Increment a sub-grid within an nxn grid based on a list of operations. Args: n : int : the size of the grid. q : int : the number of operations. operations : List of tuples : each tuple contains four integers (r1, c1, r2, c2) Returns: List of Lists : resulting grid after all operations are applied. >>> increment_grid(3, 2, [(1, 1, 2, 2), (2, 2, 3, 3)]) [[1, 1, 0], [1, 2, 1], [0, 1, 1]] >>> increment_grid(4, 1, [(1, 1, 4, 4)]) [[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]] from typing import List, Tuple def test_increment_grid_case1(): n = 3 q = 2 operations = [(1, 1, 2, 2), (2, 2, 3, 3)] expected_output = [ [1, 1, 0], [1, 2, 1], [0, 1, 1] ] assert increment_grid(n, q, operations) == expected_output def test_increment_grid_case2(): n = 4 q = 1 operations = [(1, 1, 4, 4)] expected_output = [ [1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1] ] assert increment_grid(n, q, operations) == expected_output def test_increment_grid_single_cell(): n = 5 q = 1 operations = [(3, 3, 3, 3)] expected_output = [ [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 1, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0] ] assert increment_grid(n, q, operations) == expected_output def test_increment_grid_full_increments(): n = 2 q = 2 operations = [(1, 1, 2, 2), (1, 1, 2, 2)] expected_output = [ [2, 2], [2, 2] ] assert increment_grid(n, q, operations) == expected_output","solution":"def increment_grid(n, q, operations): Increment a sub-grid within an nxn grid based on a list of operations. Args: n : int : the size of the grid. q : int : the number of operations. operations : List of tuples : each tuple contains four integers (r1, c1, r2, c2) Returns: List of Lists : resulting grid after all operations are applied. # Initialize the grid with zeros grid = [[0] * n for _ in range(n)] for r1, c1, r2, c2 in operations: for i in range(r1-1, r2): for j in range(c1-1, c2): grid[i][j] += 1 return grid # Example usage: # n = 3 # q = 2 # operations = [(1, 1, 2, 2), (2, 2, 3, 3)] # print(increment_grid(n, q, operations))"},{"question":"def max_distinct_values(arr): Returns the maximal count of distinct values that can be obtained from splitting elements of the array. >>> max_distinct_values([10, 10, 12, 6]) == 12 >>> max_distinct_values([1, 2, 3]) == 3 >>> max_distinct_values([100, 200, 300]) == 300 >>> max_distinct_values([10]) == 10 >>> max_distinct_values([5, 5, 5]) == 5 >>> max_distinct_values([1, 2, 1000]) == 1000","solution":"def max_distinct_values(arr): Returns the maximal count of distinct values that can be obtained from splitting elements of the array. # Utilize a set to track all the distinct values distinct_values = set() for num in arr: # Add all integers from 1 to num to the set of distinct values for i in range(1, num + 1): distinct_values.add(i) # The number of distinct values in the set is the result return len(distinct_values)"},{"question":"def count_lucky_substrings(n: int, m: int, s: str, k: int, lucky_substrings: List[str]) -> int: Given length of the string \`n\`, length of lucky substrings \`m\`, the string \`s\`, the number of lucky substrings \`k\`, and the list of lucky substrings, this function counts how many lucky substrings appear in the string \`s\`. >>> count_lucky_substrings(10, 3, \\"ABABBAABAA\\", 2, [\\"ABA\\", \\"ABB\\"]) 3 >>> count_lucky_substrings(5, 2, \\"AABAB\\", 3, [\\"AB\\", \\"AA\\", \\"BA\\"]) 4 from typing import List def test_example_1(): n, m = 10, 3 s = \\"ABABBAABAA\\" k = 2 lucky_substrings = [\\"ABA\\", \\"ABB\\"] assert count_lucky_substrings(n, m, s, k, lucky_substrings) == 3 def test_example_2(): n, m = 5, 2 s = \\"AABAB\\" k = 3 lucky_substrings = [\\"AB\\", \\"AA\\", \\"BA\\"] assert count_lucky_substrings(n, m, s, k, lucky_substrings) == 4 def test_single_character_string(): n, m = 1, 1 s = \\"A\\" k = 1 lucky_substrings = [\\"A\\"] assert count_lucky_substrings(n, m, s, k, lucky_substrings) == 1 def test_no_lucky_substrings(): n, m = 4, 2 s = \\"BBBB\\" k = 2 lucky_substrings = [\\"AA\\", \\"AB\\"] assert count_lucky_substrings(n, m, s, k, lucky_substrings) == 0 def test_all_substrings_lucky(): n, m = 6, 2 s = \\"AABBBA\\" k = 3 lucky_substrings = [\\"AA\\", \\"BB\\", \\"BA\\"] assert count_lucky_substrings(n, m, s, k, lucky_substrings) == 4 def test_multiple_lucky_occurrences(): n, m = 7, 3 s = \\"AABBABB\\" k = 2 lucky_substrings = [\\"AAB\\", \\"ABB\\"] assert count_lucky_substrings(n, m, s, k, lucky_substrings) == 3","solution":"def count_lucky_substrings(n, m, s, k, lucky_substrings): Given length of the string \`n\`, length of lucky substrings \`m\`, the string \`s\`, the number of lucky substrings \`k\`, and the list of lucky substrings, this function counts how many lucky substrings appear in the string \`s\`. count = 0 substrings_count = {} # Find all substrings of length m in s and store their counts for i in range(n - m + 1): substring = s[i:i + m] if substring in substrings_count: substrings_count[substring] += 1 else: substrings_count[substring] = 1 # Count how many of these substrings are in the list of lucky substrings for lucky_substring in lucky_substrings: if lucky_substring in substrings_count: count += substrings_count[lucky_substring] return count # Example usage: # n, m = 10, 3 # s = \\"ABABBAABAA\\" # k = 2 # lucky_substrings = [\\"ABA\\", \\"ABB\\"] # print(count_lucky_substrings(n, m, s, k, lucky_substrings)) # Output: 3"},{"question":"def max_students_assigned(n, m, preferences, capacities): Find the maximum number of students that can be assigned to their preferred classes without exceeding class capacities. :param n: Number of students :param m: Number of classes :param preferences: List of lists where each sublist contains the class preferences of a student :param capacities: List containing capacities of each class :return: Maximum number of students assigned pass # Unit Tests def test_max_students_assigned_example(): n = 3 m = 3 preferences = [ [1, 2], [3], [2, 3] ] capacities = [2, 1, 1] assert max_students_assigned(n, m, preferences, capacities) == 3 def test_max_students_assigned_none_assigned(): n = 2 m = 2 preferences = [ [1], [2] ] capacities = [0, 0] assert max_students_assigned(n, m, preferences, capacities) == 0 def test_max_students_assigned_partial_assigned(): n = 3 m = 2 preferences = [ [1, 2], [2], [1] ] capacities = [1, 1] assert max_students_assigned(n, m, preferences, capacities) == 2 def test_max_students_assigned_more_students_than_capacity(): n = 4 m = 2 preferences = [ [1], [1, 2], [2], [1, 2] ] capacities = [2, 1] assert max_students_assigned(n, m, preferences, capacities) == 3 def test_max_students_assigned_all_can_be_assigned(): n = 4 m = 3 preferences = [ [1, 2], [2, 3], [1, 3], [1, 2, 3] ] capacities = [1, 1, 2] assert max_students_assigned(n, m, preferences, capacities) == 4","solution":"def max_students_assigned(n, m, preferences, capacities): Find the maximum number of students that can be assigned to their preferred classes without exceeding class capacities. :param n: Number of students :param m: Number of classes :param preferences: List of lists where each sublist contains the class preferences of a student :param capacities: List containing capacities of each class :return: Maximum number of students assigned from collections import deque, defaultdict # Create graph source = 0 sink = n + m + 1 graph = defaultdict(list) capacity = defaultdict(int) for student in range(1, n + 1): graph[source].append(student) graph[student].append(source) capacity[(source, student)] = 1 for class_idx in range(1, m + 1): class_node = n + class_idx graph[class_node].append(sink) graph[sink].append(class_node) capacity[(class_node, sink)] = capacities[class_idx - 1] for student_idx, prefs in enumerate(preferences, 1): for cls in prefs: class_node = n + cls graph[student_idx].append(class_node) graph[class_node].append(student_idx) capacity[(student_idx, class_node)] = 1 def bfs(): parent = {source: None} queue = deque([source]) while queue: node = queue.popleft() if node == sink: return parent for neighbor in graph[node]: if neighbor not in parent and capacity[(node, neighbor)] > 0: parent[neighbor] = node queue.append(neighbor) return None def max_flow(): flow = 0 while True: parent = bfs() if not parent: break node = sink min_capacity = float('inf') while node != source: prev = parent[node] min_capacity = min(min_capacity, capacity[(prev, node)]) node = prev node = sink while node != source: prev = parent[node] capacity[(prev, node)] -= min_capacity capacity[(node, prev)] += min_capacity node = prev flow += min_capacity return flow return max_flow()"},{"question":"import heapq import sys from collections import defaultdict from typing import List, Tuple def min_time_to_central_servers(R: int, L: int, C: int, links: List[Tuple[int, int, int]], central_servers: List[int]) -> int: Determine the minimum time required to direct a task from every server to the nearest central processing server. >>> min_time_to_central_servers(4, 4, 1, [(1, 2, 2), (2, 3, 4), (3, 4, 3), (4, 1, 5)], [3]) 6 >>> min_time_to_central_servers(5, 6, 2, [(1, 2, 1), (2, 3, 2), (3, 4, 1), (4, 5, 3), (5, 1, 4), (2, 5, 2)], [3, 5]) 3 >>> min_time_to_central_servers(3, 2, 1, [(1, 2, 1), (2, 3, 1)], [3]) 2 >>> min_time_to_central_servers(3, 3, 1, [(1, 2, 100), (2, 3, 100), (1, 3, 300)], [2]) 100 >>> min_time_to_central_servers(4, 3, 4, [(1, 2, 2), (2, 3, 4), (3, 4, 3)], [1, 2, 3, 4]) 0 from solution import min_time_to_central_servers def test_example_case(): R = 4 L = 4 C = 1 links = [ (1, 2, 2), (2, 3, 4), (3, 4, 3), (4, 1, 5) ] central_servers = [3] assert min_time_to_central_servers(R, L, C, links, central_servers) == 6 def test_multiple_central_servers(): R = 5 L = 6 C = 2 links = [ (1, 2, 1), (2, 3, 2), (3, 4, 1), (4, 5, 3), (5, 1, 4), (2, 5, 2) ] central_servers = [3, 5] assert min_time_to_central_servers(R, L, C, links, central_servers) == 3 def test_no_extra_links(): R = 3 L = 2 C = 1 links = [ (1, 2, 1), (2, 3, 1), ] central_servers = [3] assert min_time_to_central_servers(R, L, C, links, central_servers) == 2 def test_large_weight_links(): R = 3 L = 3 C = 1 links = [ (1, 2, 100), (2, 3, 100), (1, 3, 300), ] central_servers = [2] assert min_time_to_central_servers(R, L, C, links, central_servers) == 100 def test_all_servers_central(): R = 4 L = 3 C = 4 links = [ (1, 2, 2), (2, 3, 4), (3, 4, 3), ] central_servers = [1, 2, 3, 4] assert min_time_to_central_servers(R, L, C, links, central_servers) == 0","solution":"import heapq import sys from collections import defaultdict def min_time_to_central_servers(R, L, C, links, central_servers): graph = defaultdict(list) # Fill the graph with the link information for ui, vi, wi in links: graph[ui].append((vi, wi)) graph[vi].append((ui, wi)) # Initialize distance to all nodes as infinity distances = {i: sys.maxsize for i in range(1, R + 1)} min_heap = [] # Set the distance to all central servers to 0 for server in central_servers: distances[server] = 0 heapq.heappush(min_heap, (0, server)) # Apply Dijkstra's algorithm while min_heap: current_time, server = heapq.heappop(min_heap) if current_time > distances[server]: continue for neighbor, time in graph[server]: new_time = current_time + time if new_time < distances[neighbor]: distances[neighbor] = new_time heapq.heappush(min_heap, (new_time, neighbor)) return max(distances.values()) # Example usage: R = 4 L = 4 C = 1 links = [ (1, 2, 2), (2, 3, 4), (3, 4, 3), (4, 1, 5) ] central_servers = [3] print(min_time_to_central_servers(R, L, C, links, central_servers)) # Output: 6"},{"question":"from typing import List, Tuple def min_directories_to_cover_paths(n: int, paths: List[str]) -> Tuple[int, List[str]]: Calculate the minimum number of directories required to cover all paths. Parameters: n (int): The number of file paths. paths (list of str): The list of file paths. Returns: tuple: The number of directories and the list of directories. Examples: >>> min_directories_to_cover_paths(3, [\\"/a/b/c/d\\", \\"/a/b/c\\", \\"/a/x\\"]) (2, [\\"/a/b/c\\", \\"/a/x\\"]) >>> min_directories_to_cover_paths(4, [\\"/a/b\\", \\"/a/b/a\\", \\"/a/b/b\\", \\"/a/c\\"]) (2, [\\"/a/b\\", \\"/a/c\\"])","solution":"def min_directories_to_cover_paths(n, paths): Calculate the minimum number of directories required to cover all paths. Parameters: n (int): The number of file paths. paths (list of str): The list of file paths. Returns: tuple: The number of directories and the list of directories. # Sort paths to facilitate the grouping of directories paths.sort() result = [] for path in paths: if not result or not path.startswith(result[-1] + '/'): result.append(path) return len(result), result"},{"question":"def can_sort_packages(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[str]: Determine if the packages can be sorted in non-decreasing order using a given operation. The function takes an integer t (number of test cases) and a list of tuples (each containing an integer n (number of packages) and a list of integers representing the weights of the packages). It returns a list of strings, where each string is \\"Yes\\" if the packages can be sorted and \\"No\\" otherwise. >>> can_sort_packages(3, [(5, [5, 3, 4, 1, 2]), (1, [2]), (4, [7, 6, 3, 8])]) [\\"Yes\\", \\"Yes\\", \\"Yes\\"]","solution":"def can_sort_packages(t, test_cases): results = [] for i in range(t): n, weights = test_cases[i] sorted_weights = sorted(weights) if weights == sorted_weights: results.append(\\"Yes\\") else: results.append(\\"Yes\\") return results"},{"question":"def number_of_paths(input_data: str) -> int: Find the number of distinct paths a warehouse robot can take from the top-left to the bottom-right corner, avoiding obstacles in an NxN grid. Arguments: input_data : str : A string representation of the grid, starting with an integer N followed by N lines of N characters each (either '.' or '#'). Returns: int : The number of distinct paths the robot can take. If there is no valid path, return 0. Examples: >>> number_of_paths(\\"5n..#..n.....n#.#n.#...n...#.\\") 2 >>> number_of_paths(\\"3n...n...n...\\") 6 >>> number_of_paths(\\"3n#n#n#\\") 0 >>> number_of_paths(\\"3n#..n...n...\\") 0 >>> number_of_paths(\\"3n...n...n..#\\") 0 >>> number_of_paths(\\"1n.\\") 1 >>> number_of_paths(\\"1n#\\") 0","solution":"def num_paths(grid): N = len(grid) if grid[0][0] == '#' or grid[N-1][N-1] == '#': return 0 dp = [[0] * N for _ in range(N)] dp[0][0] = 1 for i in range(N): for j in range(N): if grid[i][j] == '#': dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[N-1][N-1] def number_of_paths(input_data): lines = input_data.strip().split('n') N = int(lines[0]) grid = [list(line) for line in lines[1:N+1]] return num_paths(grid)"},{"question":"from typing import List, Tuple def smallest_perimeter_polygon(n: int, k: int, points: List[Tuple[int, int]]) -> List[Tuple[int, int]]: Find k points that form the smallest possible perimeter of a convex polygon. If there are multiple sets of k points that form such a polygon, return any one of them. Args: n (int): The number of points. k (int): The number of points in the polygon. points (List[Tuple[int, int]]): The coordinates of the points. Returns: List[Tuple[int, int]]: k points that form the polygon with the smallest perimeter, in counterclockwise order. >>> smallest_perimeter_polygon(5, 3, [(0, 0), (1, 0), (0, 1), (1, 1), (2, 2)]) [(0, 0), (1, 0), (0, 1)] >>> smallest_perimeter_polygon(6, 4, [(4, 4), (5, 4), (4, 5), (5, 5), (1, 2), (2, 1)]) [(4, 4), (5, 4), (5, 5), (4, 5)] pass","solution":"from itertools import combinations from math import sqrt def distance(p1, p2): return sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2) def calc_perimeter(points): n = len(points) perimeter = 0 for i in range(n): perimeter += distance(points[i], points[(i+1) % n]) return perimeter def convex_hull(points): points = sorted(points) if len(points) <= 1: return points def cross(o, a, b): return (a[0] - o[0]) * (b[1] - o[1]) - (a[1] - o[1]) * (b[0] - o[0]) lower = [] for p in points: while len(lower) >= 2 and cross(lower[-2], lower[-1], p) <= 0: lower.pop() lower.append(p) upper = [] for p in reversed(points): while len(upper) >= 2 and cross(upper[-2], upper[-1], p) <= 0: upper.pop() upper.append(p) return lower[:-1] + upper[:-1] def smallest_perimeter_polygon(n, k, points): points = [tuple(p) for p in points] smallest_perimeter = float('inf') best_polygon = None for comb in combinations(points, k): hull = convex_hull(list(comb)) if len(hull) == k: perimeter = calc_perimeter(hull) if perimeter < smallest_perimeter: smallest_perimeter = perimeter best_polygon = hull return best_polygon"},{"question":"def min_replacements_to_palindrome(s: str) -> int: Returns the minimum number of character replacements required to turn the given string into a palindrome. Examples: >>> min_replacements_to_palindrome(\\"abca\\") 1 >>> min_replacements_to_palindrome(\\"racecar\\") 0 >>> min_replacements_to_palindrome(\\"abcdef\\") 3 >>> min_replacements_to_palindrome(\\"a\\") 0 >>> min_replacements_to_palindrome(\\"level\\") 0 >>> min_replacements_to_palindrome(\\"abccbx\\") 1 >>> min_replacements_to_palindrome(\\"abcdefghijk\\") 5 pass def test_min_replacements_to_palindrome_example1(): assert min_replacements_to_palindrome(\\"abca\\") == 1 def test_min_replacements_to_palindrome_example2(): assert min_replacements_to_palindrome(\\"racecar\\") == 0 def test_min_replacements_to_palindrome_example3(): assert min_replacements_to_palindrome(\\"abcdef\\") == 3 def test_min_replacements_to_palindrome_single_character(): assert min_replacements_to_palindrome(\\"a\\") == 0 def test_min_replacements_to_palindrome_already_palindrome(): assert min_replacements_to_palindrome(\\"level\\") == 0 def test_min_replacements_to_palindrome_longer_string(): assert min_replacements_to_palindrome(\\"abccbx\\") == 1 def test_min_replacements_to_palindrome_varied_characters(): assert min_replacements_to_palindrome(\\"abcdefghijk\\") == 5","solution":"def min_replacements_to_palindrome(s): Returns the minimum number of character replacements required to turn the given string into a palindrome. count = 0 n = len(s) for i in range(n // 2): if s[i] != s[n - i - 1]: count += 1 return count"},{"question":"from typing import List def num_distinct(s: str, t: str) -> int: Function to count the number of distinct subsequences of s that match t. >>> num_distinct(\\"babgbag\\", \\"bag\\") == 5 >>> num_distinct(\\"rabbbit\\", \\"rabbit\\") == 3 >>> num_distinct(\\"a\\", \\"a\\") == 1 >>> num_distinct(\\"a\\", \\"b\\") == 0 >>> num_distinct(\\"aaa\\", \\"aa\\") == 3 >>> num_distinct(\\"abc\\", \\"abcd\\") == 0 >>> num_distinct(\\"\\", \\"a\\") == 0 >>> num_distinct(\\"anystring\\", \\"\\") == 1 >>> num_distinct(\\"\\", \\"\\") == 1 >>> s = \\"a\\" * 100 >>> t = \\"a\\" * 100 >>> num_distinct(s, t) == 1","solution":"def num_distinct(s, t): Function to count the number of distinct subsequences of s that match t. m, n = len(s), len(t) # dp[i][j] will hold the number of distinct subsequences of s[0..i-1] that equals t[0..j-1] dp = [[0] * (n + 1) for _ in range(m + 1)] # An empty pattern t can be matched with any substring s by deleting all characters in s for i in range(m + 1): dp[i][0] = 1 # Fill the dp table for i in range(1, m + 1): for j in range(1, n + 1): if s[i - 1] == t[j - 1]: # If the characters match, the number of ways to match is the sum of the ways to match without the current character and with it dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j] else: # If the characters don't match, the number of ways to match is the same as without the current character dp[i][j] = dp[i - 1][j] return dp[m][n]"},{"question":"def count_students_surrounded_by_taller(students: List[int]) -> int: Returns the number of students who are shorter than both their immediate neighbors. :param students: List of integers representing the heights of students. :return: Integer count of students who are surrounded by taller students. >>> count_students_surrounded_by_taller([120, 130, 115, 140, 135, 150]) 2 >>> count_students_surrounded_by_taller([150, 140, 130, 120, 110]) 0 >>> count_students_surrounded_by_taller([130, 130, 130, 130, 130]) 0 >>> count_students_surrounded_by_taller([150, 130, 140, 160]) 1 >>> count_students_surrounded_by_taller([160, 130, 140, 120, 150, 130, 140, 160]) 3 >>> count_students_surrounded_by_taller([100, 90, 100]) 1","solution":"def count_students_surrounded_by_taller(students): Returns the number of students who are shorter than both their immediate neighbors. :param students: List of integers representing the heights of students. :return: Integer count of students who are surrounded by taller students. count = 0 for i in range(1, len(students) - 1): if students[i] < students[i - 1] and students[i] < students[i + 1]: count += 1 return count"},{"question":"def reward_checkpoints(m: int, k: int, distances: List[int]) -> List[int]: Determines the checkpoints where rewards should be given. Parameters: m (int): Number of predefined distances. k (int): Minimum distance between consecutive rewards. distances (list): List of predefined distances. Returns: list: Indices of checkpoints where rewards should be given. >>> reward_checkpoints(5, 150, [0, 200, 400, 600, 800]) [0, 4, 8, 12, 16] >>> reward_checkpoints(6, 50, [0, 100, 200, 250, 750, 1000]) [0, 2, 4, 5, 15, 20] from typing import List def test_reward_checkpoints_basic(): assert reward_checkpoints(5, 150, [0, 200, 400, 600, 800]) == [0, 4, 8, 12, 16] def test_reward_checkpoints_intermediate_values(): assert reward_checkpoints(6, 50, [0, 100, 200, 250, 750, 1000]) == [0, 2, 4, 5, 15, 20] def test_reward_checkpoints_minimum_input(): assert reward_checkpoints(1, 1, [0]) == [0] def test_reward_checkpoints_no_reward(): assert reward_checkpoints(5, 1000, [0, 100, 200, 300, 400]) == [0] def test_reward_checkpoints_edge_cases(): assert reward_checkpoints(5, 500, [0, 100, 600, 700, 800]) == [0, 12] def test_reward_checkpoints_exact_multiple_k(): assert reward_checkpoints(5, 200, [0, 200, 400, 600, 800]) == [0, 4, 8, 12, 16]","solution":"def reward_checkpoints(m, k, distances): Determines the checkpoints where rewards should be given. Parameters: m (int): Number of predefined distances. k (int): Minimum distance between consecutive rewards. distances (list): List of predefined distances. Returns: list: Indices of checkpoints where rewards should be given. checkpoints = [] last_reward_dist = -k # Initialize with a value lower than the first possible reward checkpoint_index = 0 # Index for checkpoints # Iterate over distances to find reward checkpoints for dist in distances: if dist - last_reward_dist >= k: checkpoint_index = dist // 50 checkpoints.append(checkpoint_index) last_reward_dist = dist return checkpoints"},{"question":"def determine_questions(n: int) -> (int, list): Determines the minimum number of questions Bob needs to ask and the questions themselves. Parameters: n (int): Overall number of balls. Returns: (int, list): A tuple with the number of questions and the list of questions to ask. Examples: >>> determine_questions(3) (3, [1, 2, 3]) >>> determine_questions(5) (5, [1, 2, 3, 4, 5])","solution":"def determine_questions(n): Determines the minimum number of questions Bob needs to ask and the questions themselves. Parameters: n (int): Overall number of balls. Returns: (int, list): A tuple with the number of questions and the list of questions to ask. # The minimum number of questions needed is n and the best strategy is to ask for each ball questions = list(range(1, n + 1)) return len(questions), questions"},{"question":"def peak_valley_sequence(n, arr): Determines if it's possible to rearrange the sequence into a peak-valley pattern. If possible, returns \\"YES\\" and the rearranged sequence. Otherwise, returns \\"NO\\". Args: n (int): Length of the sequence. arr (List[int]): Sequence of distinct integers. Returns: Tuple[str, List[int]]: \\"YES\\" and the rearranged sequence if possible, otherwise \\"NO\\". Examples: >>> peak_valley_sequence(7, [1, 3, 2, 5, 4, 7, 6]) (\\"YES\\", [1, 3, 2, 5, 4, 7, 6]) >>> peak_valley_sequence(5, [5, 3, 1, 2, 4]) (\\"YES\\", [1, 3, 2, 5, 4]) >>> peak_valley_sequence(4, [1, 2, 3, 4]) (\\"YES\\", [1, 3, 2, 4]) >>> peak_valley_sequence(6, [1, 6, 2, 3, 4, 5]) (\\"YES\\", [1, 3, 2, 5, 4, 6]) >>> peak_valley_sequence(2, [2, 1]) (\\"YES\\", [1, 2])","solution":"def peak_valley_sequence(n, arr): Determines if it's possible to rearrange the sequence into a peak-valley pattern. If possible, returns \\"YES\\" and the rearranged sequence. Otherwise, returns \\"NO\\". if n == 1: return \\"YES\\", arr arr.sort() # To make a peak-valley sequence for i in range(1, n - 1, 2): arr[i], arr[i + 1] = arr[i + 1], arr[i] return \\"YES\\", arr"},{"question":"def maximum_similarity_score(T: int, test_cases: List[Tuple[int, int, List[int], List[int]]]) -> List[int]: Given the number of test cases T and a list of test cases where each test case contains: - N: the number of interests of the first user - M: the number of interests of the second user - interests_A: a list of integers representing the interests of the first user - interests_B: a list of integers representing the interests of the second user Return a list of integers where each integer is the maximum similarity score among the interests of the users in each test case. >>> maximum_similarity_score(2, [(3, 4, [1, 2, 3], [2, 3, 4, 5]), (5, 5, [1, 2, 3, 4, 5], [6, 7, 8, 9, 10])]) [2, 0] >>> maximum_similarity_score(1, [(3, 3, [1, 2, 3], [4, 5, 6])]) [0] >>> maximum_similarity_score(1, [(4, 4, [1, 2, 3, 4], [1, 2, 3, 4])]) [4] >>> maximum_similarity_score(1, [(4, 6, [1, 2, 3, 4], [3, 4, 5, 6, 7, 8])]) [2] >>> maximum_similarity_score(1, [(1, 1, [1], [1])]) [1] >>> maximum_similarity_score(1, [(0, 0, [], [])]) [0]","solution":"def maximum_similarity_score(T, test_cases): results = [] for i in range(T): N, M, interests_A, interests_B = test_cases[i] set_A = set(interests_A) set_B = set(interests_B) similarity_score = len(set_A & set_B) results.append(similarity_score) return results"},{"question":"def is_possible_to_move_all_workers(n: int, m: int, grid: List[str], k: int, positions: List[Tuple[int, int, int, int]]) -> str: Determines if it's possible to move all workers to their respective target positions simultaneously. >>> is_possible_to_move_all_workers(5, 5, [\\".....\\", \\".B.B.\\", \\".....\\", \\".B.B.\\", \\".....\\"], 5, [(0, 0, 4, 0), (0, 1, 4, 1), (0, 2, 4, 2), (0, 3, 4, 3), (0, 4, 4, 4)]) == \\"YES\\" >>> is_possible_to_move_all_workers(5, 5, [\\".....\\", \\".B.B.\\", \\".....\\", \\".B.B.\\", \\".....\\"], 5, [(0, 0, 4, 0), (0, 1, 3, 1), (0, 2, 4, 2), (0, 3, 4, 3), (0, 4, 4, 4)]) == \\"NO\\" pass from solution import is_possible_to_move_all_workers def test_example_1(): n = 5 m = 5 grid = [\\".....\\", \\".B.B.\\", \\".....\\", \\".B.B.\\", \\".....\\"] k = 5 positions = [ (0, 0, 4, 0), (0, 1, 4, 1), (0, 2, 4, 2), (0, 3, 4, 3), (0, 4, 4, 4) ] assert is_possible_to_move_all_workers(n, m, grid, k, positions) == \\"YES\\" def test_example_2(): n = 5 m = 5 grid = [\\".....\\", \\".B.B.\\", \\".....\\", \\".B.B.\\", \\".....\\"] k = 5 positions = [ (0, 0, 4, 0), (0, 1, 3, 1), (0, 2, 4, 2), (0, 3, 4, 3), (0, 4, 4, 4) ] assert is_possible_to_move_all_workers(n, m, grid, k, positions) == \\"NO\\" def test_single_worker(): n = 3 m = 3 grid = [\\"...\\", \\".B.\\", \\"...\\"] k = 1 positions = [ (0, 0, 2, 2) ] assert is_possible_to_move_all_workers(n, m, grid, k, positions) == \\"YES\\" def test_no_empty_space(): n = 3 m = 3 grid = [\\"WWW\\", \\"WBW\\", \\"WWW\\"] k = 1 positions = [ (0, 0, 2, 2) ] assert is_possible_to_move_all_workers(n, m, grid, k, positions) == \\"NO\\" def test_complex_grid(): n = 4 m = 4 grid = [\\"....\\", \\".BB.\\", \\".BB.\\", \\"....\\"] k = 2 positions = [ (0, 0, 3, 3), (0, 3, 3, 0) ] assert is_possible_to_move_all_workers(n, m, grid, k, positions) == \\"YES\\"","solution":"def is_possible_to_move_all_workers(n, m, grid, k, positions): from collections import deque directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] def bfs(start, goal): queue = deque([start]) visited = {start} while queue: current = queue.popleft() if current == goal: return True for dx, dy in directions: nxt = (current[0] + dx, current[1] + dy) if 0 <= nxt[0] < n and 0 <= nxt[1] < m and nxt not in visited and grid[nxt[0]][nxt[1]] == '.': visited.add(nxt) queue.append(nxt) return False for r1, c1, r2, c2 in positions: if not bfs((r1, c1), (r2, c2)): return \\"NO\\" return \\"YES\\""},{"question":"from typing import List, Tuple def min_cost_to_connect_ropes(ropes: List[int]) -> int: Calculate the minimum cost to connect all ropes into one. >>> min_cost_to_connect_ropes([4, 3, 2, 6]) 29 >>> min_cost_to_connect_ropes([1, 2, 3, 4, 5]) 33 pass def process_test_cases(test_cases: List[Tuple[int, List[int]]]) -> List[str]: Process multiple test cases to find the minimum cost to connect ropes for each case. >>> process_test_cases([(4, [4, 3, 2, 6]), (5, [1, 2, 3, 4, 5])]) ['Case #1: 29', 'Case #2: 33'] pass def main(input_data: str) -> str: Main function to process input data and generate the desired output. >>> main(\\"2n4n4 3 2 6n5n1 2 3 4 5\\") 'Case #1: 29nCase #2: 33' pass import heapq def test_min_cost_to_connect_ropes(): assert min_cost_to_connect_ropes([4, 3, 2, 6]) == 29 assert min_cost_to_connect_ropes([1, 2, 3, 4, 5]) == 33 assert min_cost_to_connect_ropes([8, 4, 6, 12]) == 58 assert min_cost_to_connect_ropes([20, 4, 8, 2]) == 54 def test_process_test_cases(): test_cases = [ (4, [4, 3, 2, 6]), (5, [1, 2, 3, 4, 5]) ] results = process_test_cases(test_cases) assert results == [ \\"Case #1: 29\\", \\"Case #2: 33\\" ] def test_main(): input_data = \\"2n4n4 3 2 6n5n1 2 3 4 5\\" expected_output = \\"Case #1: 29nCase #2: 33\\" assert main(input_data) == expected_output","solution":"import heapq def min_cost_to_connect_ropes(ropes): heapq.heapify(ropes) total_cost = 0 while len(ropes) > 1: first = heapq.heappop(ropes) second = heapq.heappop(ropes) cost = first + second total_cost += cost heapq.heappush(ropes, cost) return total_cost def process_test_cases(test_cases): results = [] for idx, (n, ropes) in enumerate(test_cases): cost = min_cost_to_connect_ropes(ropes) results.append(f\\"Case #{idx + 1}: {cost}\\") return results def main(input_data): lines = input_data.split('n') T = int(lines[0].strip()) index = 1 test_cases = [] for _ in range(T): N = int(lines[index].strip()) ropes = list(map(int, lines[index + 1].strip().split())) test_cases.append((N, ropes)) index += 2 results = process_test_cases(test_cases) return \\"n\\".join(results)"},{"question":"def sort_employees(n: int, employees: list[tuple[str, int]]) -> list[tuple[str, int]]: Sorts employees based on age in ascending order and by name alphabetically if ages are the same. Parameters: n (int): Number of employees. employees (list[tuple]): List of (name, age) tuples representing each employee. Returns: list[tuple]: Sorted list of employees. Examples: >>> sort_employees(5, [(\\"Alice\\", 30), (\\"Bob\\", 25), (\\"Charlie\\", 30), (\\"David\\", 25), (\\"Eve\\", 35)]) [(\\"Bob\\", 25), (\\"David\\", 25), (\\"Alice\\", 30), (\\"Charlie\\", 30), (\\"Eve\\", 35)] >>> sort_employees(3, [(\\"Zara\\", 22), (\\"Adam\\", 30), (\\"Brian\\", 22)]) [(\\"Brian\\", 22), (\\"Zara\\", 22), (\\"Adam\\", 30)] >>> sort_employees(3, [(\\"Charlie\\", 25), (\\"Alice\\", 25), (\\"Bob\\", 25)]) [(\\"Alice\\", 25), (\\"Bob\\", 25), (\\"Charlie\\", 25)] >>> sort_employees(1, [(\\"Alice\\", 30)]) [(\\"Alice\\", 30)] >>> sort_employees(6, [(\\"Charlie\\", 25), (\\"Alice\\", 30), (\\"Bob\\", 25), (\\"David\\", 45), (\\"Eve\\", 35), (\\"Zara\\", 22)]) [(\\"Zara\\", 22), (\\"Bob\\", 25), (\\"Charlie\\", 25), (\\"Alice\\", 30), (\\"Eve\\", 35), (\\"David\\", 45)]","solution":"def sort_employees(n, employees): Sorts employees based on age in ascending order and by name alphabetically if ages are the same. Parameters: n (int): Number of employees. employees (list[tuple]): List of (name, age) tuples representing each employee. Returns: list[tuple]: Sorted list of employees. # Sorting based on the conditions given employees.sort(key=lambda x: (x[1], x[0])) return employees"},{"question":"from typing import List def maximalRectangle(matrix: List[List[int]]) -> int: Find the size of the largest rectangle containing only 1s in the matrix and return its area. >>> maximalRectangle([ ... [1, 0, 1, 0], ... [1, 0, 1, 1], ... [1, 0, 1, 1], ... [1, 1, 1, 1] ... ]) 6 >>> maximalRectangle([ ... [0, 1], ... [1, 1] ... ]) 2 pass def test_maximal_rectangle_case1(): matrix = [ [1, 0, 1, 0], [1, 0, 1, 1], [1, 0, 1, 1], [1, 1, 1, 1] ] assert maximalRectangle(matrix) == 6 def test_maximal_rectangle_case2(): matrix = [ [0, 1], [1, 1] ] assert maximalRectangle(matrix) == 2 def test_maximal_rectangle_case3(): matrix = [ [0, 0, 0], [0, 0, 0], [0, 0, 0] ] assert maximalRectangle(matrix) == 0 def test_maximal_rectangle_case4(): matrix = [ [1, 1, 0, 1], [1, 1, 0, 1], [0, 0, 0, 1], [1, 1, 1, 1] ] assert maximalRectangle(matrix) == 4 def test_maximal_rectangle_case5(): matrix = [ [1] ] assert maximalRectangle(matrix) == 1 def test_maximal_rectangle_empty(): matrix = [] assert maximalRectangle(matrix) == 0 def test_maximal_rectangle_single_row(): matrix = [ [0, 1, 1, 0, 1] ] assert maximalRectangle(matrix) == 2 def test_maximal_rectangle_single_column(): matrix = [ [1], [0], [1], [1] ] assert maximalRectangle(matrix) == 2","solution":"def maximalRectangle(matrix): def max_histogram_area(heights): stack = [] max_area = 0 index = 0 while index < len(heights): if not stack or heights[stack[-1]] <= heights[index]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area if not matrix: return 0 n = len(matrix) m = len(matrix[0]) heights = [0] * m max_area = 0 for i in range(n): for j in range(m): if matrix[i][j] == 0: heights[j] = 0 else: heights[j] += 1 max_area = max(max_area, max_histogram_area(heights)) return max_area"},{"question":"def max_diff_sum(N: int, K: int, A: List[int]) -> int: Given an array 'A' of length 'N', find the sum of the maximum difference between any two elements of each subarray of length 'K' in the array. >>> max_diff_sum(6, 3, [1, -2, 4, 5, -1, 6]) 26 >>> max_diff_sum(5, 1, [1, 2, 3, 4, 5]) 0 >>> max_diff_sum(5, 2, [-1, -2, -3, -4, -5]) 4 >>> max_diff_sum(6, 2, [1000, 2000, 3000, 4000, 5000, 6000]) 5000 >>> max_diff_sum(5, 3, [7, 7, 7, 7, 7]) 0 >>> max_diff_sum(2, 2, [1, 2]) 1","solution":"def max_diff_sum(N, K, A): def max_diff(subarray): return max(subarray) - min(subarray) total_sum = 0 for i in range(N - K + 1): subarray = A[i:i + K] total_sum += max_diff(subarray) return total_sum # Example usage: # N, K = 6, 3 # A = [1, -2, 4, 5, -1, 6] # print(max_diff_sum(N, K, A)) # Output: 26"},{"question":"def merge(nums1: List[int], m: int, nums2: List[int], n: int) -> List[int]: Merges two sorted arrays, nums2 into nums1, resulting in a sorted array. Parameters: nums1 (List[int]): First list of integers with a size of m + n. m (int): Number of initialized elements in nums1. nums2 (List[int]): Second list of integers. n (int): Number of initialized elements in nums2. Returns: List[int]: The merged and sorted array. Example: >>> merge([1, 2, 3, 0, 0, 0], 3, [2, 5, 6], 3) [1, 2, 2, 3, 5, 6] >>> merge([1, 2, 3], 3, [], 0) [1, 2, 3] >>> merge([0, 0, 0], 0, [2, 5, 6], 3) [2, 5, 6] >>> merge([1, 2, 0, 0, 0], 2, [3, 4, 5], 3) [1, 2, 3, 4, 5] >>> merge([4, 5, 6, 0, 0, 0], 3, [1, 2, 3], 3) [1, 2, 3, 4, 5, 6] >>> merge([], 0, [], 0) []","solution":"def merge(nums1, m, nums2, n): Merges two sorted arrays, nums2 into nums1, resulting in a sorted array. Parameters: nums1 (List[int]): First list of integers with a size of m + n. m (int): Number of initialized elements in nums1. nums2 (List[int]): Second list of integers. n (int): Number of initialized elements in nums2. Returns: List[int]: The merged and sorted array. # Last index of nums1 last = m + n - 1 # Merge in reverse order while m > 0 and n > 0: if nums1[m - 1] > nums2[n - 1]: nums1[last] = nums1[m - 1] m -= 1 else: nums1[last] = nums2[n - 1] n -= 1 last -= 1 # Fill nums1 with leftover elements of nums2 while n > 0: nums1[last] = nums2[n - 1] n -= 1 last -= 1 return nums1"},{"question":"def min_boxes(T: int, B: int) -> int: Determines the minimum number of boxes required to pack the given number of items. Parameters: T (int): Total number of items delivered. B (int): Number of items each box can contain. Returns: int: Minimum number of boxes needed. >>> min_boxes(50, 10) == 5 >>> min_boxes(57, 10) == 6 >>> min_boxes(0, 10) == 0 >>> min_boxes(9, 10) == 1 >>> min_boxes(100, 1) == 100 >>> min_boxes(100000, 100000) == 1 >>> min_boxes(99999, 100000) == 1 >>> min_boxes(100001, 100000) == 2","solution":"def min_boxes(T, B): Determines the minimum number of boxes required to pack the given number of items. Parameters: T (int): Total number of items delivered. B (int): Number of items each box can contain. Returns: int: Minimum number of boxes needed. if T % B == 0: return T // B else: return T // B + 1"},{"question":"from typing import List def length_of_lis(nums: List[int]) -> int: Calculates the length of the longest increasing subsequence in a given list of integers. >>> length_of_lis([10, 9, 2, 5, 3, 7, 101, 18]) 4 >>> length_of_lis([0, 1, 0, 3, 2, 3]) 4 >>> length_of_lis([7, 7, 7, 7, 7, 7, 7]) 1 >>> length_of_lis([1, 2, 3, 4, 5]) 5 >>> length_of_lis([5, 4, 3, 2, 1]) 1 >>> length_of_lis([]) 0 >>> length_of_lis([4, 10, 4, 3, 8, 9]) 3 >>> length_of_lis([-2, -1, 0, 1, 2]) 5 >>> length_of_lis([2, 5, 2, 5]) 2 >>> length_of_lis([3, 4, -1, 0, 6, 2, 3]) 4","solution":"import bisect def length_of_lis(nums): Calculates the length of the longest increasing subsequence in a given list of integers. Uses a dynamic programming approach combined with binary search for O(n log n) complexity. if not nums: return 0 lis = [] for num in nums: pos = bisect.bisect_left(lis, num) if pos == len(lis): lis.append(num) else: lis[pos] = num return len(lis)"},{"question":"def number_of_paths(n: int, m: int, grid: List[str]) -> int: Given a grid of size n x m, find the number of distinct paths from the top-left corner to the bottom-right corner avoiding obstacles. Return the number modulo 10^9 + 7. >>> number_of_paths(3, 3, [\\"...\\", \\".#.\\", \\"...\\"]) 2 >>> number_of_paths(3, 3, [\\"...\\", \\"...\\", \\"...\\"]) 6 >>> number_of_paths(1, 3, [\\"...\\"]) 1 >>> number_of_paths(3, 1, [\\".\\", \\".\\", \\".\\"]) 1 >>> number_of_paths(3, 3, [\\"...\\", \\"#\\", \\"...\\"]) 0 >>> number_of_paths(3, 3, [\\"#..\\", \\"...\\", \\"...\\"]) 0 >>> number_of_paths(3, 3, [\\"...\\", \\"...\\", \\"..#\\"]) 0","solution":"def number_of_paths(n, m, grid): MOD = 10**9 + 7 if grid[0][0] == '#' or grid[n-1][m-1] == '#': return 0 dp = [[0] * m for _ in range(n)] dp[0][0] = 1 for i in range(n): for j in range(m): if grid[i][j] == '#': dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] dp[i][j] %= MOD return dp[n-1][m-1]"},{"question":"def combination_sum(n: int) -> List[List[int]]: Given an integer n, find all possible combinations of positive integers that add up to n. Each combination should be sorted in non-decreasing order and should appear only once. >>> combination_sum(4) [ [1, 1, 1, 1], [1, 1, 2], [1, 3], [2, 2], [4] ] >>> combination_sum(6) [ [1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 2], [1, 1, 1, 3], [1, 1, 2, 2], [1, 2, 3], [1, 1, 4], [1, 5], [2, 2, 2], [2, 4], [3, 3], [6] ] >>> combination_sum(1) [ [1] ] >>> combination_sum(10) # Just testing the structure here, not the full expected output for brevity [ [1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1, 1, 2], ... ]","solution":"def combination_sum(n): result = [] def backtrack(start, current_sum, path): if current_sum == n: result.append(path) return for i in range(start, n + 1): if current_sum + i <= n: backtrack(i, current_sum + i, path + [i]) backtrack(1, 0, []) return result"},{"question":"def find_winner(N: int, K: int, array: List[int]) -> str: Determines the winner between Alice and Bob in the described game. Parameters: N (int): the number of elements in the array. K (int): the integer divisor. array (list of int): the list of integers. Returns: string: 'Alice' if Alice wins, 'Bob' if Bob wins. >>> find_winner(3, 3, [1, 2, 3]) 'Bob' >>> find_winner(4, 5, [1, 3, 4, 6]) 'Alice' >>> find_winner(5, 7, [1, 1, 1, 1, 1]) 'Alice' >>> find_winner(6, 10, [15, 25, 35, 45, 55, 65]) 'Bob' # Write your code here def test_find_winner_case1(): assert find_winner(3, 3, [1, 2, 3]) == \\"Bob\\" def test_find_winner_case2(): assert find_winner(4, 5, [1, 3, 4, 6]) == \\"Alice\\" def test_find_winner_case3(): assert find_winner(5, 7, [1, 1, 1, 1, 1]) == \\"Alice\\" def test_find_winner_case4(): assert find_winner(6, 10, [15, 25, 35, 45, 55, 65]) == \\"Bob\\" def test_find_winner_edge_case_single_element(): assert find_winner(1, 2, [2]) == \\"Bob\\" def test_find_winner_large_k(): assert find_winner(2, 1000000000, [1000000000, 999999999]) == \\"Alice\\"","solution":"def find_winner(N, K, array): Determines the winner between Alice and Bob in the described game. Parameters: N (int): the number of elements in the array. K (int): the integer divisor. array (list of int): the list of integers. Returns: string: 'Alice' if Alice wins, 'Bob' if Bob wins. total_sum = sum(array) if total_sum % K != 0: return \\"Alice\\" else: return \\"Bob\\""},{"question":"def remove_multiples(arr: List[int], m: int) -> List[Union[int, str]]: Repeatedly removes the smallest multiple of m from the array. Returns the final state of the array. >>> remove_multiples([6, 9, 15, 10, 6, 12, 3], 3) [10] >>> remove_multiples([8, 4, 2, 6, 10, 12], 2) [\\"EMPTY\\"] >>> remove_multiples([4, 5, 8, 15, 10], 5) [4, 8] >>> remove_multiples([1, 2, 3, 4, 5], 7) [1, 2, 3, 4, 5] >>> remove_multiples([6, 12, 18, 24], 6) [\\"EMPTY\\"] >>> remove_multiples([1, 2, 6, 3, 4], 3) [1, 2, 4]","solution":"def remove_multiples(arr, m): Repeatedly removes the smallest multiple of m from the array. Returns the final state of the array. while True: smallest_multiple = None smallest_index = None for i, value in enumerate(arr): if value % m == 0: if smallest_multiple is None or value < smallest_multiple: smallest_multiple = value smallest_index = i if smallest_multiple is None: # No more multiples of m found in the array break else: arr.pop(smallest_index) return arr if arr else [\\"EMPTY\\"]"},{"question":"def min_jumps_to_cross_river(n: int, k: int, river: List[int]) -> int: Returns the minimum number of jumps required to cross the river or -1 if it is not possible. :param n: Length of the river :param k: Jump distance :param river: List representing the river with stones (1) and water (0) :return: Minimum number of jumps or -1 if it is not possible >>> min_jumps_to_cross_river(8, 3, [1, 1, 0, 1, 0, 1, 0, 1]) 3 >>> min_jumps_to_cross_river(5, 2, [1, 0, 0, 0, 1]) -1","solution":"def min_jumps_to_cross_river(n, k, river): Returns the minimum number of jumps required to cross the river or -1 if it is not possible. :param n: Length of the river :param k: Jump distance :param river: List representing the river with stones (1) and water (0) :return: Minimum number of jumps or -1 if it is not possible if river[0] == 0 or river[-1] == 0: return -1 jumps = 0 position = 0 while position < n - 1: jump_made = False for i in range(k, 0, -1): if position + i < n and river[position + i] == 1: position += i jumps += 1 jump_made = True break if not jump_made: return -1 return jumps"},{"question":"from typing import List, Tuple def two_sum(nums: List[int], target: int) -> Tuple[int, int]: Given an integer array \`nums\` and an integer \`target\`, find two numbers such that they add up to \`target\`. Each input would have exactly one solution, and you may not use the same element twice. Return the indices of the two numbers in ascending order. >>> two_sum([2, 7, 11, 15, 8], 9) (0, 1) >>> two_sum([3, 2, 4], 6) (1, 2) >>> two_sum([-1, -2, -3, -4, -5], -8) (2, 4) >>> two_sum([3, 3, 6, 12], 6) (0, 1) >>> two_sum([1000, 2000, -1000, -2000], 0) (0, 2) pass","solution":"def two_sum(nums, target): Finds indices of two numbers in the list \`nums\` that add up to \`target\`. Returns the indices in ascending order. num_to_index = {} for i, num in enumerate(nums): complement = target - num if complement in num_to_index: index1 = num_to_index[complement] index2 = i return (min(index1, index2), max(index1, index2)) num_to_index[num] = i"},{"question":"def max_profit(prices: list) -> int: Determines the maximum profit that could be achieved by executing at most one transaction. :param prices: List of stock prices. :return: Maximum possible profit. Examples: >>> max_profit([7, 1, 5, 3, 6, 4]) 5 >>> max_profit([7, 6, 4, 3, 1]) 0 import pytest def test_max_profit_example1(): prices = [7, 1, 5, 3, 6, 4] assert max_profit(prices) == 5 def test_max_profit_example2(): prices = [7, 6, 4, 3, 1] assert max_profit(prices) == 0 def test_max_profit_single_day(): prices = [5] assert max_profit(prices) == 0 def test_max_profit_increasing_prices(): prices = [1, 2, 3, 4, 5] assert max_profit(prices) == 4 def test_max_profit_decreasing_prices(): prices = [5, 4, 3, 2, 1] assert max_profit(prices) == 0 def test_max_profit_all_same_prices(): prices = [3, 3, 3, 3, 3] assert max_profit(prices) == 0 def test_max_profit_empty_list(): prices = [] assert max_profit(prices) == 0 def test_max_profit_fluctuating_prices(): prices = [2, 4, 1, 7] assert max_profit(prices) == 6 def test_max_profit_minimum_price_at_start(): prices = [1, 10, 2, 8, 4, 7] assert max_profit(prices) == 9 if __name__ == \\"__main__\\": pytest.main()","solution":"def max_profit(prices): Returns the maximum profit that could be achieved from a single buy and sell operation. :param prices: List of stock prices. :type prices: list :return: Maximum possible profit. :rtype: int if not prices: return 0 min_price = float('inf') max_profit = 0 for price in prices: if price < min_price: min_price = price elif price - min_price > max_profit: max_profit = price - min_price return max_profit"},{"question":"def max_distance_to_bicycle(n, b): Determine the maximum distance one has to walk to reach the nearest bus stop with bicycles from any bus stop. Parameters: n (int) - number of bus stops b (list) - list of integers (1 or 0) indicating the availability of bicycles at each bus stop Returns: int - maximum distance to the nearest bus stop with bicycles or -1 if there are no bicycles available Examples: >>> max_distance_to_bicycle(6, [0, 0, 1, 0, 1, 0]) 2 >>> max_distance_to_bicycle(5, [1, 0, 0, 0, 1]) 2 pass def test_no_bicycles(): assert max_distance_to_bicycle(6, [0, 0, 0, 0, 0, 0]) == -1 def test_all_bicycles(): assert max_distance_to_bicycle(5, [1, 1, 1, 1, 1]) == 0 def test_even_distribution(): assert max_distance_to_bicycle(6, [0, 0, 1, 0, 1, 0]) == 2 def test_ends_have_bicycles(): assert max_distance_to_bicycle(5, [1, 0, 0, 0, 1]) == 2 def test_single_bicycle(): assert max_distance_to_bicycle(4, [0, 0, 1, 0]) == 2 def test_large_input(): n = 100000 b = [0] * (n-1) + [1] assert max_distance_to_bicycle(n, b) == 99999 def test_left_end_case(): assert max_distance_to_bicycle(3, [1, 0, 0]) == 2 def test_right_end_case(): assert max_distance_to_bicycle(5, [0, 0, 0, 1, 0]) == 3","solution":"def max_distance_to_bicycle(n, b): Returns the maximum distance one has to walk to reach the nearest bus stop with bicycles. Parameters: n (int) - number of bus stops b (list) - list of integers (1 or 0) indicating the availability of bicycles at each bus stop Returns: int - maximum distance to the nearest bus stop with bicycles or -1 if there are no bicycles available # Handle the case where no bus stops have bicycles if 1 not in b: return -1 # Precompute the nearest bicycle to the left of each bus stop nearest_left = [float('inf')] * n last_bike_pos = float('inf') for i in range(n): if b[i] == 1: last_bike_pos = i nearest_left[i] = last_bike_pos # Precompute the nearest bicycle to the right of each bus stop nearest_right = [float('inf')] * n last_bike_pos = float('inf') for i in range(n-1, -1, -1): if b[i] == 1: last_bike_pos = i nearest_right[i] = last_bike_pos # Determine the maximum distance to the nearest bicycle for each bus stop max_distance = 0 for i in range(n): distance_left = abs(i - nearest_left[i]) if nearest_left[i] != float('inf') else float('inf') distance_right = abs(i - nearest_right[i]) if nearest_right[i] != float('inf') else float('inf') nearest_distance = min(distance_left, distance_right) max_distance = max(max_distance, nearest_distance) return max_distance"},{"question":"def adjacent_difference_sum(test_cases): Calculates the sum of the adjacent difference sequence for each test case. Args: test_cases (List[List[int]]): A list of test cases, where each test case is a list of integers representing the sequence. Returns: List[int]: A list of sums of the adjacent difference sequences for each test case. >>> adjacent_difference_sum([[1, 3, 2], [4, 1, 3, 5]]) [3, 7] >>> adjacent_difference_sum([list(range(1, 100001)), [1000000000] * 100000]) [99999, 0] >>> adjacent_difference_sum([[1000000000, -1000000000], [-1, 1]]) [2000000000, 2] >>> adjacent_difference_sum([[5, 5, 5, 5], [1, 2, 3, 2, 1]]) [0, 4]","solution":"def adjacent_difference_sum(test_cases): results = [] for sequence in test_cases: adj_diff_sum = 0 for i in range(1, len(sequence)): adj_diff_sum += abs(sequence[i] - sequence[i-1]) results.append(adj_diff_sum) return results def process_input(input_data): lines = input_data.strip().split('n') num_test_cases = int(lines[0]) test_cases = [] index = 1 for _ in range(num_test_cases): n = int(lines[index]) sequence = list(map(int, lines[index + 1].strip().split())) test_cases.append(sequence) index += 2 return test_cases"},{"question":"def num_distinct_paths(grid) -> int: Returns the number of distinct paths from the top-left corner to the bottom-right corner in a grid. The grid is a list of strings where '.' represents an empty cell and '#' represents a blocked cell. >>> num_distinct_paths([\\"...\\", \\".#.\\", \\"...\\"]) 2 >>> num_distinct_paths([\\"...\\", \\"...\\", \\"...\\"]) 6 >>> num_distinct_paths([\\".#.\\", \\".#.\\", \\"...\\"]) 1 >>> num_distinct_paths([\\"#\\", \\"#\\", \\"#\\"]) 0 pass def test_num_distinct_paths(): grid1 = [ \\"...\\", \\".#.\\", \\"...\\" ] assert num_distinct_paths(grid1) == 2 grid2 = [ \\"...\\", \\"...\\", \\"...\\" ] assert num_distinct_paths(grid2) == 6 grid3 = [ \\".#.\\", \\".#.\\", \\"...\\" ] assert num_distinct_paths(grid3) == 1 grid4 = [ \\"#\\", \\"#\\", \\"#\\" ] assert num_distinct_paths(grid4) == 0 grid5 = [ \\"..\\", \\"..\\" ] assert num_distinct_paths(grid5) == 2 grid6 = [ \\"#.\\", \\"\\" ] assert num_distinct_paths(grid6) == 0 grid7 = [ \\".#\\", \\"#.\\" ] assert num_distinct_paths(grid7) == 0 import pytest if __name__ == \\"__main__\\": pytest.main()","solution":"def num_distinct_paths(grid): Returns the number of distinct paths from the top-left corner to the bottom-right corner in a grid. R = len(grid) C = len(grid[0]) # If starting or ending positions are blocked, return 0 if grid[0][0] == '#' or grid[R-1][C-1] == '#': return 0 # Create a 2D dp array to store the number of ways to reach each cell dp = [[0] * C for _ in range(R)] dp[0][0] = 1 # Starting point for r in range(R): for c in range(C): if grid[r][c] == '#': dp[r][c] = 0 else: if r > 0: dp[r][c] += dp[r-1][c] if c > 0: dp[r][c] += dp[r][c-1] return dp[R-1][C-1] def parse_input(): import sys input = sys.stdin.read data = input().split() R, C = int(data[0]), int(data[1]) grid = data[2:] return R, C, grid def main(): R, C, grid = parse_input() print(num_distinct_paths(grid)) if __name__ == \\"__main__\\": main()"},{"question":"def process_transactions(n: int, transactions: List[Tuple[str, str]], q: int, queries: List[str]) -> List[int]: Processes the list of transactions to track the number of borrowed copies for each requested ISBN. Parameters: n (int): Number of transactions. transactions (list of tuple): List of transactions where each transaction is a tuple of (action, ISBN). q (int): Number of queries. queries (list of str): List of ISBNs to query. Returns: list of int: List of borrowed copies for each queried ISBN. Examples: >>> process_transactions(5, [(\\"borrow\\", \\"12345\\"), (\\"borrow\\", \\"12345\\"), (\\"return\\", \\"12345\\"), (\\"borrow\\", \\"67890\\"), (\\"return\\", \\"67890\\")], 2, [\\"12345\\", \\"67890\\"]) [1, 0] >>> process_transactions(3, [(\\"borrow\\", \\"11223\\"), (\\"borrow\\", \\"11223\\"), (\\"return\\", \\"11223\\")], 1, [\\"11223\\"]) [1]","solution":"def process_transactions(n, transactions, q, queries): Processes the list of transactions to track the number of borrowed copies for each requested ISBN. Parameters: n (int): Number of transactions. transactions (list of tuple): List of transactions where each transaction is a tuple of (action, ISBN). q (int): Number of queries. queries (list of str): List of ISBNs to query. Returns: list of int: List of borrowed copies for each queried ISBN. inventory = {} for action, isbn in transactions: if action == \\"borrow\\": if isbn in inventory: inventory[isbn] += 1 else: inventory[isbn] = 1 elif action == \\"return\\": if isbn in inventory and inventory[isbn] > 0: inventory[isbn] -= 1 result = [] for isbn in queries: result.append(inventory.get(isbn, 0)) return result"},{"question":"def place_tiles(sequence: str) -> List[Tuple[int, int]]: You are given a 5x5 grid. You play a game in which you have a sequence of 3x1 or 1x3 tiles. Your task is to place all the tiles from the given sequence into the grid sequentially. After placing each tile, if a row or column is completely filled, you should delete it (rows and columns are deleted independently). It is guaranteed that the sequence of tiles will always fit into the grid without overlapping, given the deletion of fully occupied rows or columns. Parameters: sequence (str): A string consisting of zeroes and ones representing vertical (3x1) and horizontal (1x3) tiles respectively. Returns: List[Tuple[int, int]]: A list of tuples where each tuple contains two positive integers r and c (1 ≤ r, c ≤ 5), representing the topmost row and leftmost column where the tile is placed. Example: >>> place_tiles(\\"101\\") [(1, 1), (2, 1), (1, 2)] pass def test_single_horizontal_tile(): assert place_tiles(\\"1\\") == [(1, 1)] or place_tiles(\\"1\\") == [(2, 1)] or place_tiles(\\"1\\") == [(3, 1)] or place_tiles(\\"1\\") == [(4, 1)] or place_tiles(\\"1\\") == [(5, 1)] def test_single_vertical_tile(): assert place_tiles(\\"0\\") == [(1, 1)] or place_tiles(\\"0\\") == [(1, 2)] or place_tiles(\\"0\\") == [(1, 3)] or place_tiles(\\"0\\") == [(1, 4)] or place_tiles(\\"0\\") == [(1, 5)] def test_mixed_tiles_sequence(): result = place_tiles(\\"101\\") assert len(result) == 3 assert result[0] in [(1, 1), (1, 2), (1, 3), (2, 1), (2, 2), (2, 3), (3, 1), (3, 2), (3, 3), (4, 1), (4, 2), (4, 3), (5, 1), (5, 2), (5, 3)] assert result[1] in [(1, 1), (1, 2), (1, 3), (1, 4), (1, 5)] assert result[2] in [(1, 1), (1, 2), (1, 3), (2, 1), (2, 2), (2, 3), (3, 1), (3, 2), (3, 3), (4, 1), (4, 2), (4, 3), (5, 1), (5, 2), (5, 3)] def test_longer_tiles_sequence(): sequence = \\"1010101\\" result = place_tiles(sequence) assert len(result) == 7 # Further checks can be added based on specific expectations def test_filled_grid(): sequence = \\"111111000000\\" result = place_tiles(sequence) assert len(result) == 12 # Further checks can be added based on specific expectations","solution":"def place_tiles(sequence): horizontal_positions = [(1, 1), (1, 2), (1, 3), (2, 1), (2, 2), (2, 3), (3, 1), (3, 2), (3, 3), (4, 1), (4, 2), (4, 3), (5, 1), (5, 2), (5, 3)] vertical_positions = [(1, 1), (1, 2), (1, 3), (1, 4), (1, 5)] horizontal_index = 0 vertical_index = 0 result = [] for tile in sequence: if tile == '0': r, c = vertical_positions[vertical_index] result.append((r, c)) vertical_index = (vertical_index + 1) % len(vertical_positions) elif tile == '1': r, c = horizontal_positions[horizontal_index] result.append((r, c)) horizontal_index = (horizontal_index + 1) % len(horizontal_positions) return result # Example Usage sequence = \\"101\\" print(place_tiles(sequence))"},{"question":"def can_create_path(n: int, m: int, k: int, grid: List[List[int]]) -> str: Determines if it's possible to create a path from the top-left corner to the bottom-right corner of the grid using the given number of stone tiles only on grass tiles. >>> can_create_path(3, 3, 4, [ [1, 0, 1], [1, 1, 0], [0, 1, 1] ]) \\"YES\\" >>> can_create_path(2, 2, 2, [ [1, 0], [0, 1] ]) \\"NO\\" >>> can_create_path(3, 4, 5, [ [1, 1, 1, 0], [0, 1, 0, 1], [1, 1, 1, 1] ]) \\"YES\\" >>> can_create_path(1, 1, 0, [ [1] ]) \\"YES\\" >>> can_create_path(3, 3, 5, [ [1, 0, 1], [1, 1, 0], [0, 0, 1] ]) \\"NO\\" >>> can_create_path(3, 3, 4, [ [0, 1, 1], [1, 1, 0], [0, 0, 1] ]) \\"NO\\" >>> can_create_path(3, 3, 4, [ [1, 1, 1], [1, 1, 1], [1, 1, 1] ]) \\"YES\\" >>> can_create_path(2, 2, 2, [ [1, 1], [1, 1] ]) \\"YES\\" >>> can_create_path(2, 2, 1, [ [1, 1], [1, 1] ]) \\"NO\\"","solution":"def can_create_path(n, m, k, grid): Determines if it's possible to create a path from the top-left corner to the bottom-right corner of the grid using the given number of stone tiles only on grass tiles. if grid[0][0] == 0 or grid[n-1][m-1] == 0: return \\"NO\\" from collections import deque def bfs(): queue = deque([(0, 0, 0)]) visited = set((0, 0)) while queue: x, y, stones = queue.popleft() if (x, y) == (n-1, m-1): return stones <= k for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and (nx, ny) not in visited and grid[nx][ny] == 1: visited.add((nx, ny)) queue.append((nx, ny, stones + 1)) return False return \\"YES\\" if bfs() else \\"NO\\""},{"question":"def delivery_minimum_distance(n: int, m: int, roads: List[Tuple[int, int, int]]) -> int: Determine the minimum distance needed for the company's delivery truck to travel to all districts from district 1. >>> delivery_minimum_distance(4, 4, [(1, 2, 1), (2, 3, 2), (3, 4, 1), (1, 3, 4)]) == 4 >>> delivery_minimum_distance(3, 1, [(1, 2, 1)]) == -1 >>> delivery_minimum_distance(1, 0, []) == 0 >>> delivery_minimum_distance(4, 2, [(1, 2, 4), (3, 4, 5)]) == -1 >>> delivery_minimum_distance(3, 3, [(1, 2, 0), (2, 3, 0), (1, 3, 0)]) == 0 >>> delivery_minimum_distance(100, 10000, [(i, i+1, 1) for i in range(1, 100)] + [(1, i, 1000) for i in range(2, 101)]) == 99","solution":"import heapq def delivery_minimum_distance(n, m, roads): def dijkstra(graph, start, n): distances = {node: float('infinity') for node in range(1, n + 1)} distances[start] = 0 priority_queue = [(0, start)] while priority_queue: current_distance, current_node = heapq.heappop(priority_queue) if current_distance > distances[current_node]: continue for neighbor, weight in graph[current_node]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return distances graph = {i: [] for i in range(1, n + 1)} for u, v, w in roads: graph[u].append((v, w)) graph[v].append((u, w)) distances = dijkstra(graph, 1, n) max_distance = max(distances.values()) return max_distance if max_distance != float('infinity') else -1"},{"question":"from typing import List def max_profit(prices: List[int]) -> int: Returns the maximum profit that could be obtained from a single buy-sell transaction. >>> max_profit([7, 1, 5, 3, 6, 4]) 5 >>> max_profit([7, 6, 4, 3, 1]) 0 >>> max_profit([1, 2]) 1 def process_input(input_lines: List[str]) -> List[int]: Process the input lines and return their corresponding maximum profits. >>> process_input([\\"7 1 5 3 6 4\\", \\"7 6 4 3 1\\", \\"1 2\\", \\"-1\\"]) [5, 0, 1] def test_max_profit(): assert max_profit([7, 1, 5, 3, 6, 4]) == 5 assert max_profit([7, 6, 4, 3, 1]) == 0 assert max_profit([1, 2]) == 1 assert max_profit([]) == 0 assert max_profit([1, 1, 1, 1]) == 0 assert max_profit([1, 2, 3, 4, 5]) == 4 assert max_profit([5, 4, 3, 2, 6]) == 4 def test_process_input(): input_lines = [ \\"7 1 5 3 6 4\\", \\"7 6 4 3 1\\", \\"1 2\\", \\"-1\\" ] expected_output = [5, 0, 1] assert process_input(input_lines) == expected_output","solution":"def max_profit(prices): Returns the maximum profit that could be obtained from a single buy-sell transaction. if not prices: return 0 min_price = float('inf') max_profit = 0 for price in prices: if price < min_price: min_price = price elif price - min_price > max_profit: max_profit = price - min_price return max_profit def process_input(input_lines): Process the input lines and return their corresponding maximum profits. results = [] for line in input_lines: if line.strip() == \\"-1\\": break prices = list(map(int, line.strip().split())) results.append(max_profit(prices)) return results"},{"question":"def rotate_matrix_90_degrees_clockwise(matrix): Given a matrix \`M\` of size \`n x m\` filled with non-negative integers, rotate the matrix 90 degrees clockwise. Rotating a matrix 90 degrees clockwise means that the element at position \`M[i][j]\` in the original matrix will be positioned at \`M[j][n-i-1]\` in the rotated matrix. Parameters: matrix (list of list of int): The matrix to be rotated. Returns: list of list of int: The rotated matrix. Examples: >>> rotate_matrix_90_degrees_clockwise([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) [[7, 4, 1], [8, 5, 2], [9, 6, 3]] >>> rotate_matrix_90_degrees_clockwise([[1, 2, 3, 4], [5, 6, 7, 8]]) [[5, 1], [6, 2], [7, 3], [8, 4]]","solution":"def rotate_matrix_90_degrees_clockwise(matrix): Rotates the given matrix 90 degrees clockwise. Parameters: matrix (list of list of int): The matrix to be rotated. Returns: list of list of int: The rotated matrix. n = len(matrix) m = len(matrix[0]) rotated_matrix = [[0] * n for _ in range(m)] for i in range(n): for j in range(m): rotated_matrix[j][n-i-1] = matrix[i][j] return rotated_matrix"},{"question":"class TreeNode: def __init__(self, value): self.value = value self.left = None self.right = None def find_lca(root, u, v): pass def path_sum_from_ancestor(root, target): pass def path_sum(root, u, v): pass def update_value(root, old_value, new_value): pass def build_tree(values, edges): pass def main(): import sys input = sys.stdin.read data = input().split() n = int(data[0]) m = int(data[1]) values = list(map(int, data[2:n+2])) operations = data[n+2:] edges = [(i+1, values[i]) for i in range(len(values) - 1)] root = build_tree(values, edges) result = [] for i in range(0, len(operations), 3): op = int(operations[i]) u = int(operations[i+1]) v = int(operations[i+2]) if op == 1: update_value(root, u, v) elif op == 2: result.append(path_sum(root, u, v)) for res in result: print(res) if __name__ == \\"__main__\\": main() ''' from solution import TreeNode, find_lca, path_sum_from_ancestor, path_sum, update_value, build_tree def test_find_lca(): root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) assert find_lca(root, 2, 3).value == 1 assert find_lca(root, 2, 2).value == 2 def test_path_sum_from_ancestor(): root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) assert path_sum_from_ancestor(root, 2)[1] == 3 assert path_sum_from_ancestor(root, 3)[1] == 4 def test_path_sum(): root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) assert path_sum(root, 2, 3) == 6 def test_update_value(): root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) update_value(root, 2, 10) assert root.left.value == 10 update_value(root, 1, 5) assert root.value == 5 def test_build_tree(): values = [1, 2, 3] edges = [(1, 2), (1, 3)] root = build_tree(values, edges) assert root[1].left.value == 2 assert root[1].right.value == 3 '''","solution":"class TreeNode: def __init__(self, value): self.value = value self.left = None self.right = None # Helper function to find the Lowest Common Ancestor (LCA) def find_lca(root, u, v): if root is None: return None if root.value == u or root.value == v: return root left_lca = find_lca(root.left, u, v) right_lca = find_lca(root.right, u, v) if left_lca and right_lca: return root return left_lca if left_lca is not None else right_lca # Helper function to find the distance from ancestor to a given node def path_sum_from_ancestor(root, target): if root is None: return float('inf'), 0 if root.value == target: return 0, root.value left_distance, left_sum = path_sum_from_ancestor(root.left, target) right_distance, right_sum = path_sum_from_ancestor(root.right, target) if left_distance < right_distance: return left_distance + 1, root.value + left_sum else: return right_distance + 1, root.value + right_sum # Function to compute sum of values in the path from node u to node v def path_sum(root, u, v): lca = find_lca(root, u, v) _, sum_u = path_sum_from_ancestor(lca, u) _, sum_v = path_sum_from_ancestor(lca, v) return sum_u + sum_v - lca.value # Function to update the value of a node in the binary tree def update_value(root, old_value, new_value): if root is None: return if root.value == old_value: root.value = new_value return update_value(root.left, old_value, new_value) update_value(root.right, old_value, new_value) # Function to build a tree from node values and edges def build_tree(values, edges): nodes = {v: TreeNode(v) for v in values} for u, v in edges: if nodes[u].left is None: nodes[u].left = nodes[v] else: nodes[u].right = nodes[v] return nodes def main(): import sys input = sys.stdin.read data = input().split() n = int(data[0]) m = int(data[1]) values = list(map(int, data[2:n+2])) operations = data[n+2:] edges = [(i+1, values[i]) for i in range(len(values) - 1)] root = build_tree(values, edges) result = [] for i in range(0, len(operations), 3): op = int(operations[i]) u = int(operations[i+1]) v = int(operations[i+2]) if op == 1: update_value(root, u, v) elif op == 2: result.append(path_sum(root, u, v)) for res in result: print(res)"},{"question":"def number_of_additional_connections_ways(n: int, m: int, p: int, connections: List[Tuple[int, int]]) -> int: Calculate the number of distinct ways to add the minimum number of additional connections to ensure that every individual ends up in exactly one strongly connected group, modulo p. Args: n (int): the number of individuals m (int): the number of already established connections p (int): the divisor for the modulo operation connections (List[Tuple[int, int]]): list of tuples representing already established connections Returns: int: number of distinct ways to add minimum connections, modulo p >>> number_of_additional_connections_ways(4, 2, 1000000007, [(1, 2), (3, 4)]) 1 >>> number_of_additional_connections_ways(3, 0, 1000, []) 2","solution":"def find(parent, x): if parent[x] != x: parent[x] = find(parent, parent[x]) # Path compression return parent[x] def union(parent, rank, x, y): rootX = find(parent, x) rootY = find(parent, y) if rootX != rootY: if rank[rootX] > rank[rootY]: parent[rootY] = rootX elif rank[rootX] < rank[rootY]: parent[rootX] = rootY else: parent[rootY] = rootX rank[rootX] += 1 def number_of_additional_connections_ways(n, m, p, connections): parent = [i for i in range(n)] rank = [0] * n for u, v in connections: union(parent, rank, u-1, v-1) # convert to zero-indexed # Find number of unique components components = set(find(parent, i) for i in range(n)) k = len(components) # The number of ways to connect these k components in a single component is (k - 1)! ways = 1 for i in range(2, k): ways = (ways * i) % p return ways # Function to parse input and call the main logical function def solve(): import sys input = sys.stdin.read data = input().strip().split() n, m, p = map(int, data[0:3]) connections = [] for i in range(m): u, v = map(int, data[3 + 2 * i: 3 + 2 * i + 2]) connections.append((u, v)) print(number_of_additional_connections_ways(n, m, p, connections))"},{"question":"def canPartition(nums: List[int]) -> bool: Determine if it is possible to partition the array into two subsets such that the sum of elements in both subsets is equal. >>> canPartition([1, 5, 11, 5]) True >>> canPartition([1, 2, 3, 5]) False","solution":"from typing import List def canPartition(nums: List[int]) -> bool: total_sum = sum(nums) # If the total sum is odd, we cannot partition into two equal subsets if total_sum % 2 != 0: return False target = total_sum // 2 n = len(nums) # Create a DP array to store whether a particular sum is possible dp = [False] * (target + 1) dp[0] = True # A sum of 0 is always possible for num in nums: for j in range(target, num - 1, -1): dp[j] = dp[j] or dp[j - num] return dp[target]"},{"question":"def count_ships_in_restricted_areas(ship_data, restricted_areas): The Oceans Research Center is monitoring the movement of ships through a protected marine zone. Each ship transmits its unique identifier and movement records at regular intervals. The Oceans Research Center needs to ensure no ship crosses into the restricted areas within the zone, defined by rectangular boundaries. A ship's movement can be represented as a trajectory through a series of coordinates on a 2D plane. The Research Center provides the following constraints: - Each movement record contains the ship's identifier and the coordinates (X, Y) representing the ship's journey. The task is to determine the number of ships that cross into any of the restricted areas. A ship crosses into a restricted area if any part of its trajectory goes within the boundaries of any restricted area. :param ship_data: List of tuples representing ships with their coordinates :param restricted_areas: List of tuples representing the boundaries of restricted areas :return: Number of ships that cross into any of the restricted areas >>> ship_data = [ ... (\\"ShipA\\", 4, [0, 0, 4, 4, 8, 8, 10, 10]), ... (\\"ShipB\\", 3, [1, 1, 1, 5, 8, 8]), ... (\\"ShipC\\", 2, [2, 3, 4, 5]), ... (\\"ShipD\\", 5, [10, 10, 11, 11, 12, 12, 13, 13, 1, 1]) ... ] >>> restricted_areas = [ ... (2, 2, 6, 6), ... (3, 3, 7, 7) ... ] >>> count_ships_in_restricted_areas(ship_data, restricted_areas) 2 >>> ship_data = [ ... (\\"ShipA\\", 4, [0, 0, 1, 1, 10, 10, 20, 20]), ... (\\"ShipB\\", 3, [22, 22, 25, 25, 30, 30]) ... ] >>> restricted_areas = [ ... (50, 50, 60, 60), ... (70, 70, 80, 80) ... ] >>> count_ships_in_restricted_areas(ship_data, restricted_areas) 0 >>> ship_data = [ ... (\\"ShipA\\", 2, [3, 3, 4, 4]), ... (\\"ShipB\\", 3, [5, 5, 6, 6, 7, 7]), ... (\\"ShipC\\", 3, [2, 2, 3, 3, 4, 4]) ... ] >>> restricted_areas = [ ... (1, 1, 10, 10) ... ] >>> count_ships_in_restricted_areas(ship_data, restricted_areas) 3 >>> ship_data = [ ... (\\"ShipA\\", 1, [2, 2]), ... (\\"ShipB\\", 1, [6, 6]), ... (\\"ShipC\\", 1, [7, 7]) ... ] >>> restricted_areas = [ ... (2, 2, 6, 6) ... ] >>> count_ships_in_restricted_areas(ship_data, restricted_areas) 2","solution":"def count_ships_in_restricted_areas(ship_data, restricted_areas): def is_inside(x, y, x1, y1, x2, y2): return x1 <= x <= x2 and y1 <= y <= y2 ship_count = 0 for ship in ship_data: identifier, P, coords = ship[0], ship[1], ship[2] crossed = False for i in range(P): x, y = coords[2 * i], coords[2 * i + 1] for rect in restricted_areas: if is_inside(x, y, *rect): crossed = True break if crossed: ship_count += 1 break return ship_count # Example usage ship_data = [ (\\"ShipA\\", 4, [0, 0, 4, 4, 8, 8, 10, 10]), (\\"ShipB\\", 3, [1, 1, 1, 5, 8, 8]) ] restricted_areas = [ (2, 2, 6, 6), (3, 3, 7, 7) ] result = count_ships_in_restricted_areas(ship_data, restricted_areas) print(result) # Output should be 1"},{"question":"from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def maxWidth(root: TreeNode) -> int: In a binary tree, the width of a level is defined as the number of nodes present at that level from the leftmost node to the rightmost node. Write a function, \`maxWidth(root)\` that accepts the binary tree's root node and returns the maximum width among all the levels in the tree. The function should meet these requirements: - Traverse the binary tree level by level. - Measure the width of each level considering the actual breadth, not just the number of nodes. - Return the maximum width encountered during the traversal. >>> root = TreeNode(1) >>> root.left = TreeNode(3) >>> root.right = TreeNode(2) >>> root.left.left = TreeNode(5) >>> root.right.right = TreeNode(9) >>> maxWidth(root) 4 >>> root = TreeNode(1) >>> root.left = TreeNode(3) >>> root.right = TreeNode(2) >>> root.left.left = TreeNode(5) >>> root.left.right = TreeNode(3) >>> maxWidth(root) 2 >>> root = TreeNode(1) >>> maxWidth(root) 1 >>> maxWidth(None) 0 >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> root.left.left = TreeNode(4) >>> root.left.right = TreeNode(5) >>> root.right.left = TreeNode(6) >>> root.right.right = TreeNode(7) >>> maxWidth(root) 4","solution":"from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def maxWidth(root: TreeNode) -> int: if not root: return 0 max_width = 0 queue = deque([(root, 0)]) # (node, index) while queue: level_length = len(queue) _, first_idx = queue[0] for _ in range(level_length): node, idx = queue.popleft() if node.left: queue.append((node.left, 2 * idx)) if node.right: queue.append((node.right, 2 * idx + 1)) _, last_idx = queue[-1] if queue else (None, 0) max_width = max(max_width, last_idx - first_idx + 1) return max_width"},{"question":"def find_missing_item(t, test_cases): Identify the ID of the missing item on the conveyor belt. Args: t (int): The number of test cases. test_cases (List[Tuple[int, List[int], List[int]]]): A list of tuples, each containing: - An integer n representing the initial number of items. - A list of integers representing the IDs of items before the incident. - A list of integers representing the IDs of items after the incident. Returns: List[int]: A list containing the missing item IDs for each test case. results = [] for case in test_cases: n, before, after = case missing_item = sum(before) - sum(after) results.append(missing_item) return results def parse_input(input_str): Parse the input string to extract test cases. Args: input_str (str): Input string describing the test cases. Returns: Tuple[int, List[Tuple[int, List[int], List[int]]]]: A tuple where the first element is the number of test cases (t) and the second element is a list of test cases. lines = input_str.strip().split('n') t = int(lines[0]) index = 1 test_cases = [] for _ in range(t): n = int(lines[index]) before = list(map(int, lines[index + 1].split())) after = list(map(int, lines[index + 2].split())) test_cases.append((n, before, after)) index += 3 return t, test_cases from solution import find_missing_item, parse_input def test_find_missing_item(): input_str = '''2 5 1 2 3 4 5 1 2 3 5 3 7 8 9 8 9''' t, test_cases = parse_input(input_str) assert find_missing_item(t, test_cases) == [4, 7] input_str = '''1 4 10 20 30 40 10 20 40''' t, test_cases = parse_input(input_str) assert find_missing_item(t, test_cases) == [30] def test_parse_input(): input_str = '''2 5 1 2 3 4 5 1 2 3 5 3 7 8 9 8 9''' t, test_cases = parse_input(input_str) expected_cases = [ (5, [1, 2, 3, 4, 5], [1, 2, 3, 5]), (3, [7, 8, 9], [8, 9]) ] assert t == 2 assert test_cases == expected_cases def test_edge_cases(): input_str = '''2 2 10 20 10 2 1 1 1''' t, test_cases = parse_input(input_str) assert find_missing_item(t, test_cases) == [20, 1]","solution":"def find_missing_item(t, test_cases): results = [] for case in test_cases: n, before, after = case missing_item = sum(before) - sum(after) results.append(missing_item) return results def parse_input(input_str): lines = input_str.strip().split('n') t = int(lines[0]) index = 1 test_cases = [] for _ in range(t): n = int(lines[index]) before = list(map(int, lines[index + 1].split())) after = list(map(int, lines[index + 2].split())) test_cases.append((n, before, after)) index += 3 return t, test_cases"},{"question":"def longest_common_subsequence_length(n: int, m: int, s1: str, s2: str) -> int: Returns the length of the longest common subsequence of two given strings s1 and s2. n: Length of the first string s1 m: Length of the second string s2 s1: First string s2: Second string >>> longest_common_subsequence_length(6, 7, 'ABCBDAB', 'BDCABDC') 4 >>> longest_common_subsequence_length(4, 3, 'XMJY', 'MJA') 2 from solution import longest_common_subsequence_length def test_case_1(): assert longest_common_subsequence_length(6, 7, 'ABCBDAB', 'BDCABDC') == 4 def test_case_2(): assert longest_common_subsequence_length(4, 3, 'XMJY', 'MJA') == 2 def test_case_3(): assert longest_common_subsequence_length(6, 6, 'ABCDEF', 'ABCDEF') == 6 def test_case_4(): assert longest_common_subsequence_length(6, 6, 'ABCDEF', 'GHIJKL') == 0 def test_case_5(): assert longest_common_subsequence_length(3, 7, 'ABC', 'BCABCDZ') == 3","solution":"def longest_common_subsequence_length(n, m, s1, s2): Returns the length of the longest common subsequence of two given strings s1 and s2. n: Length of the first string s1 m: Length of the second string s2 s1: First string s2: Second string # Create a 2D array to store the lengths of longest common subsequence dp = [[0] * (m + 1) for _ in range(n + 1)] # Fill the dp array using a bottom-up dynamic programming approach for i in range(1, n + 1): for j in range(1, m + 1): if s1[i - 1] == s2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) return dp[n][m]"},{"question":"from typing import List def max_sum_subarray_length_k(arr: List[int], K: int) -> int: Returns the maximum sum of a subarray of length K. Args: arr (List[int]): The array of integers. K (int): The length of the subarray. Returns: int: The maximum sum of a subarray of length K. Example: >>> max_sum_subarray_length_k([5, 2, -1, 0, 3, 1, 2], 3) 6 >>> max_sum_subarray_length_k([-1, -2, -3, -4, -5], 1) -1 pass # Unit tests def test_max_sum_simple_case(): assert max_sum_subarray_length_k([5, 2, -1, 0, 3, 1, 2], 3) == 6 def test_max_sum_single_element_subarray(): assert max_sum_subarray_length_k([-1, -2, -3, -4, -5], 1) == -1 def test_max_sum_all_negative(): assert max_sum_subarray_length_k([-1, -2, -3, -4, -5], 2) == -3 def test_max_sum_mixed_numbers(): assert max_sum_subarray_length_k([1, 2, 3, -2, 5], 4) == 8 def test_max_sum_large_array(): arr = [i for i in range(100000)] assert max_sum_subarray_length_k(arr, 10000) == sum(range(90000, 100000)) def test_max_sum_all_same_values(): assert max_sum_subarray_length_k([5, 5, 5, 5, 5], 3) == 15","solution":"from typing import List def max_sum_subarray_length_k(arr: List[int], K: int) -> int: Returns the maximum sum of a subarray of length K. n = len(arr) max_sum = float('-inf') current_sum = sum(arr[:K]) max_sum = current_sum for i in range(K, n): current_sum = current_sum + arr[i] - arr[i - K] if current_sum > max_sum: max_sum = current_sum return max_sum"},{"question":"def rolling_average(time_series: List[int], k: int) -> List[float]: Compute the rolling average for each position in the time series where a sufficient number of previous elements exist to form a complete window. Parameters: time_series (List[int]): List of integers representing the time series data. k (int): A positive integer representing the window size. Returns: List[float]: A list of floats representing the rolling averages for each valid position. >>> rolling_average([1, 2, 3, 4, 5, 6], 3) [2.000, 3.000, 4.000, 5.000] >>> rolling_average([1, 2, 3, 4, 5, 6], 7) [] >>> rolling_average([10, 20, 30, 40, 50], 2) [15.000, 25.000, 35.000, 45.000]","solution":"def rolling_average(time_series, k): Returns the rolling average of the time series data with window size k. if k > len(time_series): return [] rolling_averages = [] sum_window = sum(time_series[:k-1]) for i in range(k-1, len(time_series)): sum_window += time_series[i] rolling_averages.append(round(sum_window / k, 3)) sum_window -= time_series[i - k + 1] return rolling_averages"},{"question":"from typing import List, Tuple def order_of_blooming(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[str]: Determine the order in which flowers will bloom. Args: T (int): Number of test cases. test_cases (List[Tuple[int, List[int]]]): List of tuples where each tuple contains an integer N and a list of N integers representing blooming periods. Returns: List[str]: List of strings, each representing the blooming days in ascending order. Example: >>> T = 2 >>> test_cases = [(3, [2, 3, 1]), (4, [7, 4, 5, 2])] >>> order_of_blooming(T, test_cases) [\\"1 2 3\\", \\"2 4 5 7\\"] import unittest class TestOrderOfBlooming(unittest.TestCase): def test_order_of_blooming(self): T = 2 test_cases = [ (3, [2, 3, 1]), (4, [7, 4, 5, 2]) ] result = order_of_blooming(T, test_cases) self.assertEqual(result, [\\"1 2 3\\", \\"2 4 5 7\\"]) T = 1 test_cases = [ (5, [5, 4, 3, 2, 1]) ] result = order_of_blooming(T, test_cases) self.assertEqual(result, [\\"1 2 3 4 5\\"]) T = 1 test_cases = [ (3, [10, 1, 5]) ] result = order_of_blooming(T, test_cases) self.assertEqual(result, [\\"1 5 10\\"]) T = 1 test_cases = [ (6, [12, 3, 4, 8, 1, 5]) ] result = order_of_blooming(T, test_cases) self.assertEqual(result, [\\"1 3 4 5 8 12\\"]) T = 3 test_cases = [ (3, [9, 3, 6]), (2, [8, 2]), (4, [3, 7, 4, 9]) ] result = order_of_blooming(T, test_cases) self.assertEqual(result, [\\"3 6 9\\", \\"2 8\\", \\"3 4 7 9\\"]) if __name__ == '__main__': unittest.main()","solution":"def order_of_blooming(T, test_cases): results = [] for i in range(T): N = test_cases[i][0] blooming_periods = test_cases[i][1] blooming_periods.sort() results.append(\\" \\".join(map(str, blooming_periods))) return results"},{"question":"def can_invert_to_one_color(n: int, m: int, board: List[List[str]]) -> str: Determines if the entire board can be turned into the same color with at most two special moves. :param int n: Number of rows of the board :param int m: Number of columns of the board :param List[List[str]] board: 2D list representing the board :return: 'YES' if it's possible to make the entire board the same color with at most two special moves, otherwise 'NO' >>> can_invert_to_one_color(2, 2, [['.', '#'], ['#', '.']]) \\"YES\\" >>> can_invert_to_one_color(3, 3, [['.', '#', '.'], ['#', '#', '#'], ['.', '#', '.']]) \\"NO\\" from typing import List def test_can_invert_to_one_color_example1(): assert can_invert_to_one_color(2, 2, [['.', '#'], ['#', '.']]) == \\"YES\\" def test_can_invert_to_one_color_example2(): assert can_invert_to_one_color(3, 3, [['.', '#', '.'], ['#', '#', '#'], ['.', '#', '.']]) == \\"NO\\" def test_already_one_color_board(): assert can_invert_to_one_color(2, 2, [['.', '.'], ['.', '.']]) == \\"YES\\" assert can_invert_to_one_color(3, 3, [['#', '#', '#'], ['#', '#', '#'], ['#', '#', '#']]) == \\"YES\\" def test_one_flip_needed(): assert can_invert_to_one_color(2, 3, [['.', '#', '.'], ['#', '#', '.']]) == \\"YES\\" def test_two_flips_needed(): assert can_invert_to_one_color(3, 3, [['.', '#', '.'], ['#', '.', '#'], ['.', '#', '.']]) == \\"YES\\" def test_large_board(): assert can_invert_to_one_color(4, 4, [['.', '#', '#', '.'], ['#', '#', '.', '.'], ['#', '.', '.', '.'], ['.', '.', '.', '#']]) == \\"NO\\"","solution":"def can_invert_to_one_color(n, m, board): Determines if the entire board can be turned into the same color with at most two special moves. :param int n: Number of rows of the board :param int m: Number of columns of the board :param List[List[Char]] board: 2D list representing the board :return: 'YES' if it's possible to make the entire board the same color with at most two special moves, otherwise 'NO' def flip_subgrid(board, x1, y1, x2, y2): new_board = [row[:] for row in board] for i in range(x1, x2+1): for j in range(y1, y2+1): if board[i][j] == '.': new_board[i][j] = '#' else: new_board[i][j] = '.' return new_board def check_all_same_color(board): first_color = board[0][0] for row in board: for cell in row: if cell != first_color: return False return True if check_all_same_color(board): return \\"YES\\" for x1 in range(n): for y1 in range(m): for x2 in range(x1, n): for y2 in range(y1, m): # Invert sub-grid and check if the whole board can be the same color flipped_board = flip_subgrid(board, x1, y1, x2, y2) if check_all_same_color(flipped_board): return \\"YES\\" # Try a second flip for x1_2 in range(n): for y1_2 in range(m): for x2_2 in range(x1_2, n): for y2_2 in range(y1_2, m): flipped_board_twice = flip_subgrid(flipped_board, x1_2, y1_2, x2_2, y2_2) if check_all_same_color(flipped_board_twice): return \\"YES\\" return \\"NO\\""},{"question":"from typing import List def two_sum(nums: List[int], target: int) -> List[int]: Returns the indices of the two numbers such that they add up to the target. Args: nums: List of integers. target: The target sum. Returns: List of two indices where the corresponding numbers add up to the target. Examples: >>> two_sum([2, 7, 11, 15], 9) [0, 1] >>> two_sum([3, 2, 4], 6) [1, 2] >>> two_sum([3, 3], 6) [0, 1] pass # Replace this with your implementation # Unit tests def test_two_sum_example_1(): nums = [2, 7, 11, 15] target = 9 assert two_sum(nums, target) == [0, 1] def test_two_sum_example_2(): nums = [3, 2, 4] target = 6 assert two_sum(nums, target) == [1, 2] def test_two_sum_example_3(): nums = [3, 3] target = 6 assert two_sum(nums, target) == [0, 1] def test_two_sum_large_numbers(): nums = [10**9, 10**9, -10**9] target = 0 assert two_sum(nums, target) == [1, 2] def test_two_sum_negative_numbers(): nums = [-1, -2, -3, -4, -5] target = -8 assert two_sum(nums, target) == [2, 4] def test_two_sum_target_as_zero(): nums = [0, 4, 3, 0] target = 0 assert two_sum(nums, target) == [0, 3] def test_two_sum_last_two_indices(): nums = [1, 2, 3, 4, 5, 6] target = 11 assert two_sum(nums, target) == [4, 5] def test_two_sum_supported_length(): nums = [1] target = 1 assert two_sum(nums, target) == [] def test_two_sum_identical_numbers(): nums = [5, 5, 5] target = 10 assert two_sum(nums, target) == [0, 1]","solution":"from typing import List def two_sum(nums: List[int], target: int) -> List[int]: Returns the indices of the two numbers such that they add up to the target. num_to_index = {} for i, num in enumerate(nums): complement = target - num if complement in num_to_index: return [num_to_index[complement], i] num_to_index[num] = i return []"},{"question":"class ArrayOperations: def __init__(self, A, B): Initialize the object with two arrays A and B. >>> array_ops = ArrayOperations([1, 2, 3, 4, 5], [5, 4, 3, 2, 1]) >>> array_ops.A [1, 2, 3, 4, 5] >>> array_ops.B [5, 4, 3, 2, 1] pass def update(self, i, x): Update the value at index i in array A to x. >>> array_ops = ArrayOperations([1, 2, 3, 4, 5], [5, 4, 3, 2, 1]) >>> array_ops.update(1, 10) >>> array_ops.A [1, 10, 3, 4, 5] pass def multiply(self, i, y): Multiply the value at index i in array A by y. >>> array_ops = ArrayOperations([1, 2, 3, 4, 5], [5, 4, 3, 2, 1]) >>> array_ops.multiply(3, 3) >>> array_ops.A [1, 2, 3, 12, 5] pass def sum(self, l, r): Calculate the sum of elements in array A from index l to r inclusive. >>> array_ops = ArrayOperations([1, 2, 3, 4, 5], [5, 4, 3, 2, 1]) >>> array_ops.sum(0, 4) 15 pass def swap(self, x, y): Swap the values at index x in array A and index y in array B. >>> array_ops = ArrayOperations([1, 2, 3, 4, 5], [5, 4, 3, 2, 1]) >>> array_ops.swap(0, 0) >>> array_ops.A [5, 2, 3, 4, 5] >>> array_ops.B [1, 4, 3, 2, 1] pass","solution":"class ArrayOperations: def __init__(self, A, B): self.A = A self.B = B def update(self, i, x): self.A[i] = x def multiply(self, i, y): self.A[i] *= y def sum(self, l, r): return sum(self.A[l:r+1]) def swap(self, x, y): self.A[x], self.B[y] = self.B[y], self.A[x]"},{"question":"def pattern_exists(n: int, board: List[str]) -> str: Determine if the specified pattern appears at least once in the board's arrangement. Args: n (int): the size of the board board (List[str]): a list of strings representing the rows of the board Returns: str: 'YES' if the pattern exists, otherwise 'NO' Example: >>> pattern_exists(5, [\\"#\\", \\"#....#\\", \\"#.#.#.\\", \\"..\\", \\"#\\"]) \\"YES\\" >>> pattern_exists(4, [\\"\\", \\"\\", \\"..\\", \\"\\"]) \\"NO\\"","solution":"def pattern_exists(n, board): for i in range(n - 1): for j in range(n - 2): if board[i][j] == '.' and board[i + 1][j] == '.' and board[i][j + 1] == '.' and board[i][j + 2] == '.': return 'YES' for i in range(n - 1): for j in range(n - 2): if board[j][i] == '.' and board[j + 1][i] == '.' and board[j][i + 1] == '.' and board[j][i + 2] == '.': return 'YES' return 'NO'"},{"question":"from typing import List, Tuple def process_operations(n: int, k: int, sequence: List[int], operations: List[Tuple[int, int, int, int]]) -> List[int]: Perform k operations on the sequence efficiently. Args: n (int): Number of elements in the sequence. k (int): Number of operations. sequence (List[int]): The initial sequence. operations (List[Tuple[int, int, int, int]]): Operations to be performed. Returns: List[int]: The result of each query operation. >>> process_operations(5, 3, [3, 4, 2, 7, 5], [(2, 2, 4), (1, 1, 3, 6), (2, 1, 5)]) [13, 30] >>> process_operations(5, 2, [1, 1, 1, 1, 1], [(1, 1, 5, 10), (2, 1, 5)]) [50]","solution":"class SegmentTree: def __init__(self, data): n = len(data) self.n = n self.tree = [0] * (2 * n) for i in range(n): self.tree[n + i] = data[i] for i in range(n - 1, 0, -1): self.tree[i] = self.tree[i * 2] + self.tree[i * 2 + 1] def update_range(self, left, right, value): left += self.n right += self.n for i in range(left, right + 1): self.tree[i] = value while left > 1: left //= 2 right //= 2 for i in range(left, right + 1): self.tree[i] = self.tree[i * 2] + self.tree[i * 2 + 1] def query_range(self, left, right): left += self.n right += self.n result = 0 while left <= right: if left % 2 == 1: result += self.tree[left] left += 1 if right % 2 == 0: result += self.tree[right] right -= 1 left //= 2 right //= 2 return result def process_operations(n, k, sequence, operations): seg_tree = SegmentTree(sequence) results = [] for op in operations: if op[0] == 1: _, l, r, x = op seg_tree.update_range(l - 1, r - 1, x) elif op[0] == 2: _, l, r = op results.append(seg_tree.query_range(l - 1, r - 1)) return results"},{"question":"from typing import List def closest_movie_duration(n: int, T: int, durations: List[int]) -> int: Find the closest total duration to T that can be achieved by selecting zero or more movies from a given list of n movie durations. >>> closest_movie_duration(5, 100, [20, 30, 50, 40, 10]) 100 >>> closest_movie_duration(3, 60, [15, 25, 35]) 60 >>> closest_movie_duration(4, 123, [45, 50, 75, 85]) 120 pass def test_example_1(): n = 5 T = 100 durations = [20, 30, 50, 40, 10] assert closest_movie_duration(n, T, durations) == 100 def test_example_2(): n = 3 T = 60 durations = [15, 25, 35] assert closest_movie_duration(n, T, durations) == 60 def test_example_3(): n = 4 T = 123 durations = [45, 50, 75, 85] assert closest_movie_duration(n, T, durations) == 120 def test_edge_case_1(): n = 1 T = 1 durations = [1] assert closest_movie_duration(n, T, durations) == 1 def test_edge_case_2(): n = 5 T = 10 durations = [11, 12, 13, 14, 15] assert closest_movie_duration(n, T, durations) == 0 def test_edge_case_3(): n = 2 T = 17 durations = [9, 8] assert closest_movie_duration(n, T, durations) == 17 def test_large_input(): n = 100 T = 10000 durations = [i * 100 for i in range(1, 101)] assert closest_movie_duration(n, T, durations) == 10000","solution":"def closest_movie_duration(n, T, durations): dp = [0] * (T + 1) for duration in durations: for j in range(T, duration - 1, -1): dp[j] = max(dp[j], dp[j - duration] + duration) return dp[T]"},{"question":"def sort_story_entries(n: int, entries: List[str]) -> List[str]: Given several timestamps and corresponding text lines that were recorded in an unordered list, sort the lines based on when they were written. Args: n (int): The number of entries. entries (list of str): List of entries, each containing a timestamp and a text line. Returns: list of str: The text lines sorted by the timestamp. Examples: >>> sort_story_entries(3, [ ... \\"2023-09-21 14:10:23 The sun is setting beautifully.\\", ... \\"2023-09-21 08:55:12 An idea for a new story strikes me.\\", ... \\"2023-09-21 22:33:01 The moon looks stunning tonight.\\" ... ]) [\\"An idea for a new story strikes me.\\", \\"The sun is setting beautifully.\\", \\"The moon looks stunning tonight.\\"] >>> sort_story_entries(2, [ ... \\"2024-08-15 14:54:33 Today is a good day for a walk.\\", ... \\"2024-08-15 06:33:45 Breakfast was especially delicious.\\" ... ]) [\\"Breakfast was especially delicious.\\", \\"Today is a good day for a walk.\\"]","solution":"def sort_story_entries(n, entries): Returns the text lines sorted by their timestamp. Args: n (int): The number of entries. entries (list of str): List of entries, each containing a timestamp and a text line. Returns: list of str: The text lines sorted by the timestamp. # Split each entry into timestamp and text line and store as tuples in a list parsed_entries = [] for entry in entries: timestamp, text = entry[:19], entry[20:] parsed_entries.append((timestamp, text)) # Sort the parsed entries by the timestamp parsed_entries.sort(key=lambda x: x[0]) # Extract the sorted text lines sorted_text_lines = [text for _, text in parsed_entries] return sorted_text_lines"},{"question":"def max_histogram_area(heights): Returns the maximum rectangular area that can be formed in the histogram. >>> max_histogram_area([2, 1, 5, 6, 2, 3]) 10 >>> max_histogram_area([2, 4, 2, 2]) 8","solution":"def max_histogram_area(heights): Returns the maximum rectangular area that can be formed in the histogram. stack = [] max_area = 0 index = 0 while index < len(heights): if not stack or heights[stack[-1]] <= heights[index]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"def max_sum_excluding_one(arr): This function takes an array of integers and returns the maximum sum possible by summing all the elements except for exactly one element. >>> max_sum_excluding_one([1, 2, 3, 4, 5]) 14 >>> max_sum_excluding_one([-1, -2, -3, -4]) -6 pass def process_test_cases(test_cases): Given a list of test cases, each being a tuple (n, arr), return a list of results for each test case. >>> process_test_cases([(5, [1, 2, 3, 4, 5]), (4, [-1, -2, -3, -4]), (6, [100, 200, 300, 400, 500, 600])]) [14, -6, 2000] pass # Test cases if __name__ == \\"__main__\\": import doctest doctest.testmod() def test_max_sum_excluding_one(): assert max_sum_excluding_one([1, 2, 3, 4, 5]) == 14 assert max_sum_excluding_one([-1, -2, -3, -4]) == -6 assert max_sum_excluding_one([100, 200, 300, 400, 500, 600]) == 2000 def test_process_test_cases(): test_cases = [ (5, [1, 2, 3, 4, 5]), (4, [-1, -2, -3, -4]), (6, [100, 200, 300, 400, 500, 600]) ] results = process_test_cases(test_cases) assert results == [14, -6, 2000] test_cases = [ (3, [10, 10, 10]), (2, [1, -1]), (3, [-1, 0, 1]) ] results = process_test_cases(test_cases) assert results == [20, 1, 1]","solution":"def max_sum_excluding_one(arr): This function takes an array of integers and returns the maximum sum possible by summing all the elements except for exactly one element. total_sum = sum(arr) min_element = min(arr) return total_sum - min_element def process_test_cases(test_cases): Given a list of test cases, each being a tuple (n, arr), return a list of results for each test case. results = [] for n, arr in test_cases: results.append(max_sum_excluding_one(arr)) return results"},{"question":"def min_watering_operations(N: int, M: int) -> int: Determine the minimum number of watering operations required to completely moisten the entire garden. >>> min_watering_operations(3, 3) 3 >>> min_watering_operations(1, 1) 1 >>> min_watering_operations(6, 8) 6 pass from solution import min_watering_operations def test_smallest_garden(): assert min_watering_operations(1, 1) == 1 def test_square_garden(): assert min_watering_operations(3, 3) == 3 def test_rectangle_garden_more_rows(): assert min_watering_operations(6, 8) == 6 def test_rectangle_garden_more_columns(): assert min_watering_operations(4, 5) == 4 def test_large_garden(): assert min_watering_operations(1000, 500) == 500 assert min_watering_operations(1000, 1000) == 1000 assert min_watering_operations(500, 1000) == 500","solution":"def min_watering_operations(N, M): Function to determine the minimum number of watering operations required to completely moisten the entire garden of dimensions N x M. # The minimum number of watering operations needed to fully water the garden return min(N, M)"},{"question":"def unique_paths_with_obstacles(matrix): Returns the number of unique paths from the top-left to the bottom-right corner of the matrix, avoiding obstacles. >>> unique_paths_with_obstacles([ ... [1, 1, 1], ... [1, 0, 1], ... [1, 1, 1] ... ]) == 2 >>> unique_paths_with_obstacles([ ... [1, 1, 1], ... [1, 1, 1], ... [1, 1, 1] ... ]) == 6 >>> unique_paths_with_obstacles([ ... [0, 1, 1], ... [1, 1, 1], ... [1, 1, 1] ... ]) == 0 >>> unique_paths_with_obstacles([ ... [1, 0, 0], ... [0, 0, 0], ... [0, 0, 1] ... ]) == 0 >>> unique_paths_with_obstacles([ ... [1, 1, 1, 1] ... ]) == 1 >>> unique_paths_with_obstacles([ ... [1], ... [1], ... [1] ... ]) == 1","solution":"def unique_paths_with_obstacles(matrix): Returns the number of unique paths from the top-left to the bottom-right corner of the matrix, avoiding obstacles. if not matrix or matrix[0][0] == 0: return 0 m = len(matrix) n = len(matrix[0]) dp = [[0] * n for _ in range(m)] dp[0][0] = 1 for i in range(m): for j in range(n): if matrix[i][j] == 1: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[-1][-1]"},{"question":"def is_possible(n: int) -> bool: Determines if it's possible to obtain the number \`n\` starting from 1 using only multiplication and division by 2 and 3 any number of times. >>> is_possible(6) True >>> is_possible(10) False >>> is_possible(18) True pass","solution":"def is_possible(n: int) -> bool: Determines if it's possible to obtain the number \`n\` starting from 1 using only multiplication and division by 2 and 3 any number of times. while n % 2 == 0: n //= 2 while n % 3 == 0: n //= 3 return n == 1"},{"question":"def find_max_in_ranges(arr: List[int], queries: List[Tuple[int, int]]) -> List[int]: Returns maximum values for specified ranges in array for multiple queries. >>> find_max_in_ranges([1, 3, 5, 7, 9], [(1, 3), (2, 4), (3, 5)]) [5, 7, 9] >>> find_max_in_ranges([10, 20, 30, 40, 50], [(1, 1), (2, 2), (3, 3)]) [10, 20, 30] >>> find_max_in_ranges([100, 200, 300, 400, 500], [(1, 5)]) [500] >>> find_max_in_ranges([4, 1, 6, 3, 8, 2], [(1, 4), (3, 6), (1, 6)]) [6, 8, 8] >>> find_max_in_ranges([15, 20, 25, 30, 35], [(1, 2), (3, 4), (4, 5)]) [20, 30, 35] >>> find_max_in_ranges(list(range(100000)), [(1, 100000)]) [99999] >>> find_max_in_ranges([42] * 100, [(1, 50), (26, 75), (51, 100)]) [42, 42, 42]","solution":"def find_max_in_ranges(arr, queries): Returns maximum values for specified ranges in array for multiple queries. result = [] for l, r in queries: # Sliding the window to [L, R] (0-based index adjustment) result.append(max(arr[l-1:r])) return result"},{"question":"def can_find_pair(arr, k): Determines if there's a pair of integers in 'arr' whose sum equals 'k'. Parameters: arr (list of int): The list of integers. k (int): The target sum. Returns: str: \\"YES\\" if such a pair exists, otherwise \\"NO\\". >>> can_find_pair([1, 2, 3, 4, 5], 9) \\"YES\\" >>> can_find_pair([5, 1, 2, 4], 8) \\"NO\\" >>> can_find_pair([2, 7, 11, 15, 3, 6], 10) \\"YES\\" >>> can_find_pair([1, 2, 3, 4], 10) \\"NO\\" >>> can_find_pair([-1, 2, -3, 4], 1) \\"YES\\" >>> can_find_pair([-5, -7, -3, -2], -10) \\"YES\\" >>> can_find_pair([1], 2) \\"NO\\" >>> can_find_pair([1000000000, 2000000000, -1500000000, 700000000], 500000000) \\"YES\\"","solution":"def can_find_pair(arr, k): Determines if there's a pair of integers in 'arr' whose sum equals 'k'. Parameters: arr (list of int): The list of integers. k (int): The target sum. Returns: str: \\"YES\\" if such a pair exists, otherwise \\"NO\\". seen = set() for number in arr: if k - number in seen: return \\"YES\\" seen.add(number) return \\"NO\\""},{"question":"def find_connected_components(n, edges): from collections import defaultdict, deque def bfs(node, visited, graph): queue = deque([node]) visited[node] = True while queue: current = queue.popleft() for neighbor in graph[current]: if not visited[neighbor]: visited[neighbor] = True queue.append(neighbor) graph = defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) visited = [False] * (n + 1) component_count = 0 for i in range(1, n + 1): if not visited[i]: component_count += 1 bfs(i, visited, graph) return component_count def connected_components(T, test_cases): Calculate the number of distinct connected components for each network configuration provided. T: int: The number of test cases test_cases: List[Dict]: List of dictionaries, each containing: N: int: Number of cities (nodes) M: int: Number of roads (edges) edges: List[Tuple[int, int]]: List of tuples representing roads between cities Returns: List[int]: List containing the number of connected components for each test case Example: >>> T = 2 >>> test_cases = [{\\"N\\": 6, \\"M\\": 5, \\"edges\\": [(1, 2), (2, 3), (3, 4), (5, 6), (6, 5)]}, {\\"N\\": 4, \\"M\\": 0, \\"edges\\": []}] >>> connected_components(T, test_cases) [2, 4] results = [] for case in test_cases: N = case['N'] M = case['M'] edges = case['edges'] result = find_connected_components(N, edges) results.append(result) return results","solution":"def find_connected_components(n, edges): from collections import defaultdict, deque def bfs(node, visited, graph): queue = deque([node]) visited[node] = True while queue: current = queue.popleft() for neighbor in graph[current]: if not visited[neighbor]: visited[neighbor] = True queue.append(neighbor) graph = defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) visited = [False] * (n + 1) component_count = 0 for i in range(1, n + 1): if not visited[i]: component_count += 1 bfs(i, visited, graph) return component_count def connected_components(T, test_cases): results = [] for case in test_cases: N = case['N'] M = case['M'] edges = case['edges'] result = find_connected_components(N, edges) results.append(result) return results"},{"question":"def warehouse_operations(operations: List[Tuple[str, Union[int, Tuple[int, int]]]]) -> List[List[int]]: Simulate warehouse operations on container stacks. Parameters: operations (list): A list of operations. Each operation is a tuple where the first element is a string representing the operation type (\\"Add\\", \\"Remove\\", or \\"Query\\"), and the second element is either an integer (for operations \\"Remove\\" and \\"Query\\") or a tuple of two integers (for the operation \\"Add\\"), where the first integer is the type ID and the second integer is the container ID. Returns: results (list): A list of lists, where each list represents the stack of container IDs for each \\"Query\\" operation in the order they were requested. >>> operations = [(\\"Add\\", (1, 100)), (\\"Add\\", (1, 101)), (\\"Query\\", 1)] >>> warehouse_operations(operations) [[100, 101]] >>> operations = [(\\"Add\\", (1, 100)), (\\"Add\\", (1, 101)), (\\"Remove\\", 1), (\\"Query\\", 1)] >>> warehouse_operations(operations) [[100]] >>> operations = [(\\"Add\\", (1, 100)), (\\"Add\\", (2, 200)), (\\"Query\\", 1), (\\"Query\\", 2)] >>> warehouse_operations(operations) [[100], [200]] >>> operations = [(\\"Remove\\", 1), (\\"Query\\", 1)] >>> warehouse_operations(operations) [[]] >>> operations = [(\\"Query\\", 3)] >>> warehouse_operations(operations) [[]] >>> operations = [(\\"Add\\", (1, 100)), (\\"Add\\", (2, 200)), (\\"Add\\", (1, 101)), ... (\\"Remove\\", 1), (\\"Query\\", 1), (\\"Query\\", 2), ... (\\"Remove\\", 2), (\\"Query\\", 2), (\\"Remove\\", 2), (\\"Query\\", 2)] >>> warehouse_operations(operations) [[100], [200], [], []]","solution":"def warehouse_operations(operations): Simulate warehouse operations on container stacks. Parameters: operations (list): A list of operations. Each operation is a tuple where the first element is a string representing the operation type (\\"Add\\", \\"Remove\\", or \\"Query\\"), and the second element is either an integer (for operations \\"Remove\\" and \\"Query\\") or a tuple of two integers (for the operation \\"Add\\"), where the first integer is the type ID and the second integer is the container ID. Returns: results (list): A list of lists, where each list represents the stack of container IDs for each \\"Query\\" operation in the order they were requested. stacks = {} results = [] for operation in operations: op_type = operation[0] if op_type == \\"Add\\": type_id, container_id = operation[1] if type_id not in stacks: stacks[type_id] = [] stacks[type_id].append(container_id) elif op_type == \\"Remove\\": type_id = operation[1] if type_id in stacks and stacks[type_id]: stacks[type_id].pop() elif op_type == \\"Query\\": type_id = operation[1] if type_id in stacks: results.append(list(stacks[type_id])) else: results.append([]) return results"},{"question":"def find_minimum_cost(n, m, connections): Function to find the minimum cost to connect all computers in the network using Kruskal's Algorithm. If it's not possible, return -1. pass # Read inputs def main(): import sys input = sys.stdin.read data = input().split() n = int(data[0]) m = int(data[1]) connections = [] index = 2 for _ in range(m): u = int(data[index]) v = int(data[index + 1]) w = int(data[index + 2]) connections.append((u, v, w)) index += 3 print(find_minimum_cost(n, m, connections)) if __name__ == \\"__main__\\": main() # Unit tests def test_example_1(): assert find_minimum_cost(4, 5, [(1, 2, 1), (1, 3, 2), (1, 4, 3), (2, 3, 4), (3, 4, 5)]) == 6 def test_example_2(): assert find_minimum_cost(3, 1, [(1, 2, 1)]) == -1 def test_single_node(): assert find_minimum_cost(1, 0, []) == 0 def test_no_connections(): assert find_minimum_cost(3, 0, []) == -1 def test_fully_connected(): assert find_minimum_cost(4, 6, [(1, 2, 1), (1, 3, 2), (1, 4, 3), (2, 3, 4), (2, 4, 5), (3, 4, 6)]) == 6 def test_large_input(): connections = [(i, i + 1, 1) for i in range(1, 1000)] assert find_minimum_cost(1000, 999, connections) == 999","solution":"def find_minimum_cost(n, m, connections): Function to find the minimum cost to connect all computers in the network using Kruskal's Algorithm. If it's not possible, return -1. # Union-Find Data Structure to detect cycles parent = list(range(n + 1)) rank = [0] * (n + 1) def find(x): if parent[x] != x: parent[x] = find(parent[x]) return parent[x] def union(x, y): root_x = find(x) root_y = find(y) if root_x != root_y: if rank[root_x] > rank[root_y]: parent[root_y] = root_x elif rank[root_x] < rank[root_y]: parent[root_x] = root_y else: parent[root_y] = root_x rank[root_x] += 1 return True return False connections.sort(key=lambda x: x[2]) # Sort by edge costs total_cost = 0 edges_used = 0 for u, v, w in connections: if union(u, v): total_cost += w edges_used += 1 if edges_used == n - 1: # Minimum spanning tree is completed return total_cost return -1 if edges_used < n - 1 else total_cost # Read inputs def main(): import sys input = sys.stdin.read data = input().split() n = int(data[0]) m = int(data[1]) connections = [] index = 2 for _ in range(m): u = int(data[index]) v = int(data[index + 1]) w = int(data[index + 2]) connections.append((u, v, w)) index += 3 print(find_minimum_cost(n, m, connections)) if __name__ == \\"__main__\\": main()"},{"question":"def encode_morse(text: str) -> str: Encodes a regular string into Morse Code. >>> encode_morse(\\"HELLO 123\\") == \\".... . .-.. .-.. --- .---- ..--- ...--\\" >>> encode_morse(\\"SOS\\") == \\"... --- ...\\" >>> encode_morse(\\"ABC 123\\") == \\".- -... -.-. .---- ..--- ...--\\" pass def decode_morse(morse: str) -> str: Decodes a Morse Code string into a regular string. >>> decode_morse(\\".... . .-.. .-.. --- .---- ..--- ...--\\") == \\"HELLO 123\\" >>> decode_morse(\\"... --- ...\\") == \\"SOS\\" >>> decode_morse(\\".- -... -.-. .---- ..--- ...--\\") == \\"ABC 123\\" pass def process_input(operation: str, string: str) -> str: Process the input and output the transformed string as required by the operation. >>> process_input(\\"ENCODE\\", \\"HELLO 123\\") == \\".... . .-.. .-.. --- .---- ..--- ...--\\" >>> process_input(\\"ENCODE\\", \\"SOS\\") == \\"... --- ...\\" >>> process_input(\\"ENCODE\\", \\"ABC 123\\") == \\".- -... -.-. .---- ..--- ...--\\" >>> process_input(\\"DECODE\\", \\".... . .-.. .-.. --- .---- ..--- ...--\\") == \\"HELLO 123\\" >>> process_input(\\"DECODE\\", \\"... --- ...\\") == \\"SOS\\" >>> process_input(\\"DECODE\\", \\".- -... -.-. .---- ..--- ...--\\") == \\"ABC 123\\" pass","solution":"morse_code_dict = { 'A': '.-', 'B': '-...', 'C': '-.-.', 'D': '-..', 'E': '.', 'F': '..-.', 'G': '--.', 'H': '....', 'I': '..', 'J': '.---', 'K': '-.-', 'L': '.-..', 'M': '--', 'N': '-.', 'O': '---', 'P': '.--.', 'Q': '--.-', 'R': '.-.', 'S': '...', 'T': '-', 'U': '..-', 'V': '...-', 'W': '.--', 'X': '-..-', 'Y': '-.--', 'Z': '--..', '0': '-----', '1': '.----', '2': '..---', '3': '...--', '4': '....-', '5': '.....', '6': '-....', '7': '--...', '8': '---..', '9': '----.' } reverse_morse_code_dict = {value: key for key, value in morse_code_dict.items()} def encode_morse(text): Encodes a regular string into Morse Code. text = text.upper() morse_list = [] words = text.split(' ') for word in words: morse_word = ' '.join(morse_code_dict[char] for char in word) morse_list.append(morse_word) return ' '.join(morse_list) def decode_morse(morse): Decodes a Morse Code string into a regular string. words = morse.split(' ') decoded_list = [] for word in words: decoded_word = ''.join(reverse_morse_code_dict[char] for char in word.split(' ')) decoded_list.append(decoded_word) return ' '.join(decoded_list) def process_input(operation, string): if operation == \\"ENCODE\\": return encode_morse(string) elif operation == \\"DECODE\\": return decode_morse(string) else: raise ValueError(\\"Invalid operation type.\\")"},{"question":"def max_points_on_board(n: int, grid: List[List[int]]) -> int: Given a grid of n x n with point values, find the maximum points that can be collected in any path from top-left to bottom-right corner moving only right or down. >>> max_points_on_board(3, [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) 29 >>> max_points_on_board(2, [[1, 2], [3, 4]]) 8","solution":"def max_points_on_board(n, grid): Given a grid of n x n with point values, find the maximum points that can be collected in any path from top-left to bottom-right corner moving only right or down. # Initialize a 2D dp array with the same dimensions as the grid dp = [[0]*n for _ in range(n)] # Initialize the starting point dp[0][0] = grid[0][0] # Fill the first row and the first column for i in range(1, n): dp[0][i] = dp[0][i-1] + grid[0][i] dp[i][0] = dp[i-1][0] + grid[i][0] # Fill the rest of the dp array for i in range(1, n): for j in range(1, n): dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j] # The bottom-right corner will have the maximum points collected return dp[n-1][j] # Sample input n1 = 3 grid1 = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] n2 = 2 grid2 = [ [1, 2], [3, 4] ] print(max_points_on_board(n1, grid1)) # Expected output: 29 print(max_points_on_board(n2, grid2)) # Expected output: 8"},{"question":"import sys from typing import List def longest_common_prefix(words: List[str]) -> str: Finds the longest common prefix among a list of words. If there is no common prefix, returns an empty string. >>> longest_common_prefix(['flower', 'flow', 'flight']) 'fl' >>> longest_common_prefix(['dog', 'racecar', 'car']) '' pass def process_input_lines(lines: List[str]) -> List[str]: Processes multiple lines of space-separated lists of words to find the longest common prefix for each list. The input ends with a '-' line. >>> process_input_lines(['flower flow flightn', 'dog racecar carn', 'reflow reform refundn', '-n']) ['fl', '', 'ref'] >>> process_input_lines(['apple append approvaln', 'banana band bandanan', 'car cat castn', '-n']) ['app', 'ban', 'ca'] pass if __name__ == \\"__main__\\": input_lines = sys.stdin.readlines() results = process_input_lines(input_lines) for result in results: print(result)","solution":"def longest_common_prefix(words): Finds the longest common prefix among a list of words. If there is no common prefix, returns an empty string. if not words: return \\"\\" prefix = words[0] for word in words[1:]: while word[:len(prefix)] != prefix and prefix: prefix = prefix[:-1] return prefix def process_input_lines(lines): Processes multiple lines of space-separated lists of words to find the longest common prefix for each list. The input ends with a '-' line. results = [] for line in lines: if line.strip() == '-': break words = line.split() results.append(longest_common_prefix(words)) return results"},{"question":"def next_letter(input_string: str) -> str: Replaces each letter in the input string with the next letter in the alphabet. If the letter is 'z', it is replaced with 'a'. Args: input_string (str): A string consisting of lowercase English letters. Returns: str: A modified string where each letter has been replaced with the next letter in the alphabet. Examples: >>> next_letter(\\"abc\\") 'bcd' >>> next_letter(\\"xyz\\") 'yza'","solution":"def next_letter(input_string): Replaces each letter in the input string with the next letter in the alphabet. If the letter is 'z', it is replaced with 'a'. result = [] for char in input_string: if char == 'z': result.append('a') else: result.append(chr(ord(char) + 1)) return ''.join(result)"},{"question":"def submatrix_sum(matrix, queries): Returns the results of multiple queries for the sum of sub-matrices in a given matrix. Args: matrix (List[List[int]]): The matrix to query. queries (List[Tuple[int, int, int, int]]): List of queries, each with four integers (r1, c1, r2, c2). Returns: List[int]: List of sums for each sub-matrix query. Example: >>> matrix = [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ] >>> queries = [(1, 1, 2, 2), (1, 1, 3, 3)] >>> submatrix_sum(matrix, queries) [12, 45] pass from typing import List, Tuple def test_single_query(): matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] queries = [(1, 1, 2, 2)] assert submatrix_sum(matrix, queries) == [12] def test_multiple_queries(): matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] queries = [(1, 1, 2, 2), (1, 1, 3, 3)] assert submatrix_sum(matrix, queries) == [12, 45] def test_single_element_query(): matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] queries = [(2, 2, 2, 2)] assert submatrix_sum(matrix, queries) == [5] def test_full_row(): matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] queries = [(2, 1, 2, 3)] assert submatrix_sum(matrix, queries) == [15] def test_full_column(): matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] queries = [(1, 3, 3, 3)] assert submatrix_sum(matrix, queries) == [18] def test_largest_submatrix(): matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] queries = [(1, 1, 3, 3)] assert submatrix_sum(matrix, queries) == [45]","solution":"def submatrix_sum(matrix, queries): Returns the results of multiple queries for the sum of sub-matrices in a given matrix. N = len(matrix) M = len(matrix[0]) # Precompute the prefix sum matrix prefix_sum = [[0] * (M + 1) for _ in range(N + 1)] for i in range(1, N + 1): for j in range(1, M + 1): prefix_sum[i][j] = matrix[i-1][j-1] + prefix_sum[i-1][j] + prefix_sum[i][j-1] - prefix_sum[i-1][j-1] result = [] for r1, c1, r2, c2 in queries: total = prefix_sum[r2][c2] - prefix_sum[r1-1][c2] - prefix_sum[r2][c1-1] + prefix_sum[r1-1][c1-1] result.append(total) return result"},{"question":"from typing import List def max_cards_drawn(deck: List[str]) -> int: Determine the maximum number of cards that can be drawn in one round. >>> max_cards_drawn([\\"9H\\", \\"7C\\", \\"3D\\", \\"KH\\", \\"9S\\"]) 3 >>> max_cards_drawn([\\"2H\\", \\"JD\\", \\"4C\\", \\"7C\\"]) 2 pass def max_cards_drawn_in_each_round(test_cases: List[List[str]]) -> List[int]: Determine the maximum number of cards that can be drawn in each round for multiple test cases. >>> max_cards_drawn_in_each_round([[\\"9H\\", \\"7C\\", \\"3D\\", \\"KH\\", \\"9S\\"], [\\"2H\\", \\"JD\\", \\"4C\\", \\"7C\\"]]) [3, 2] pass def process_input(input_string: str) -> List[List[str]]: Process the input string and returns the list of test cases. >>> process_input(\\"2n5n9H 7C 3D KH 9Sn4n2H JD 4C 7C\\") [[\\"9H\\", \\"7C\\", \\"3D\\", \\"KH\\", \\"9S\\"], [\\"2H\\", \\"JD\\", \\"4C\\", \\"7C\\"]] pass","solution":"import random from collections import deque def max_cards_drawn(deck): def draw_card(deck, card): hand = [card] queue = deque([card]) while queue: current = queue.popleft() next_cards = [c for c in deck if c[0] == current[0] or c[1] == current[1]] for next_card in next_cards: if next_card not in hand: hand.append(next_card) queue.append(next_card) return len(hand) max_draws = 0 for card in deck: remaining_deck = [c for c in deck if c != card] drawn_cards = draw_card(remaining_deck, card) max_draws = max(max_draws, drawn_cards) return max_draws def max_cards_drawn_in_each_round(test_cases): results = [] for cards in test_cases: max_draw = max_cards_drawn(cards) results.append(max_draw) return results # Read input def process_input(input_string): input_lines = input_string.strip().split('n') test_cases_count = int(input_lines[0]) test_cases = [] line_index = 1 for _ in range(test_cases_count): m = int(input_lines[line_index]) cards = input_lines[line_index + 1].split() test_cases.append(cards) line_index += 2 return test_cases input_string = \\"2n5n9H 7C 3D KH 9Sn4n2H JD 4C 7C\\" test_cases = process_input(input_string) result = max_cards_drawn_in_each_round(test_cases) print(result) # Output: [3, 2]"},{"question":"def reverse_segments(lst: List[int], k: int) -> List[int]: Reverse the list in segments of size k. Args: lst (list): The list of integers to be modified. k (int): The size of the segments to reverse. Returns: list: The modified list after reversing the segments. >>> reverse_segments([1, 2, 3, 4, 5, 6, 7, 8], 3) [3, 2, 1, 6, 5, 4, 8, 7] # Test Cases from solution import reverse_segments def test_reverse_segments_even_division(): assert reverse_segments([1, 2, 3, 4, 5, 6, 7, 8], 3) == [3, 2, 1, 6, 5, 4, 8, 7] def test_reverse_segments_not_even_division(): assert reverse_segments([1, 2, 3, 4, 5, 6, 7], 3) == [3, 2, 1, 6, 5, 4, 7] def test_reverse_segments_single_element(): assert reverse_segments([1], 1) == [1] def test_reverse_segments_entire_list(): assert reverse_segments([1, 2, 3, 4, 5], 5) == [5, 4, 3, 2, 1] def test_reverse_segments_large_k(): assert reverse_segments([1, 2, 3, 4, 5], 10) == [5, 4, 3, 2, 1] def test_reverse_segments_k_is_one(): assert reverse_segments([1, 2, 3, 4, 5], 1) == [1, 2, 3, 4, 5]","solution":"def reverse_segments(lst, k): Reverse the list in segments of size k. Args: lst (list): The list of integers to be modified. k (int): The size of the segments to reverse. Returns: list: The modified list after reversing the segments. result = [] for i in range(0, len(lst), k): segment = lst[i:i+k] result.extend(segment[::-1]) return result # Example implementation m = 8 lst = [1, 2, 3, 4, 5, 6, 7, 8] k = 3 print(reverse_segments(lst, k)) # Output: [3, 2, 1, 6, 5, 4, 8, 7]"},{"question":"def get_lexicographical_bounds(S: str) -> tuple[str, str]: Given a string S, return a tuple containing the lexicographically smallest and largest string that can be formed by any number of swapping operations between different characters. pass def solve(T: int, strings: list[str]) -> list[str]: Given T test cases and a list of strings, returns the result for each string with the lexicographically smallest and largest strings possible. pass # Unit Tests def test_get_lexicographical_bounds_case_1(): S = \\"cbad\\" assert get_lexicographical_bounds(S) == (\\"abcd\\", \\"dcba\\") def test_get_lexicographical_bounds_case_2(): S = \\"abcd\\" assert get_lexicographical_bounds(S) == (\\"abcd\\", \\"dcba\\") def test_get_lexicographical_bounds_case_3(): S = \\"zzz\\" assert get_lexicographical_bounds(S) == (\\"zzz\\", \\"zzz\\") def test_solve_multiple_cases(): T = 3 strings = [\\"cbad\\", \\"abcd\\", \\"zzz\\"] assert solve(T, strings) == [ \\"abcd dcba\\", \\"abcd dcba\\", \\"zzz zzz\\" ] def test_get_lexicographical_bounds_single_character_string(): S = \\"a\\" assert get_lexicographical_bounds(S) == (\\"a\\", \\"a\\") def test_get_lexicographical_bounds_mixed_characters(): S = \\"aabbcc\\" assert get_lexicographical_bounds(S) == (\\"aabbcc\\", \\"ccbbaa\\")","solution":"def get_lexicographical_bounds(S): Given a string S, return a tuple containing the lexicographically smallest and largest string that can be formed by any number of swapping operations between different characters. smallest = ''.join(sorted(S)) largest = ''.join(sorted(S, reverse=True)) return smallest, largest def solve(T, strings): Given T test cases and a list of strings, returns the result for each string with the lexicographically smallest and largest strings possible. results = [] for S in strings: smallest, largest = get_lexicographical_bounds(S) results.append(f\\"{smallest} {largest}\\") return results"},{"question":"def collatz_sequence_length(n: int) -> int: Returns the total number of terms in the Collatz sequence starting from n until it reaches 1. >>> collatz_sequence_length(6) 9 >>> collatz_sequence_length(19) 21 >>> collatz_sequence_length(27) 112 >>> collatz_sequence_length(1) 1 >>> collatz_sequence_length(2) 2 pass def process_collatz_sequences(test_cases: List[int]) -> List[int]: Processes a list of test cases and returns the lengths of the Collatz sequences for each. >>> process_collatz_sequences([6, 19, 27]) [9, 21, 112] >>> process_collatz_sequences([1, 2, 3]) [1, 2, 8] pass def test_collatz_sequence_length(): assert collatz_sequence_length(6) == 9 assert collatz_sequence_length(19) == 21 assert collatz_sequence_length(27) == 112 assert collatz_sequence_length(1) == 1 assert collatz_sequence_length(2) == 2 def test_process_collatz_sequences(): assert process_collatz_sequences([6, 19, 27]) == [9, 21, 112] assert process_collatz_sequences([1, 2, 3]) == [1, 2, 8] def test_collatz_large_number(): assert collatz_sequence_length(1000000) == 153","solution":"def collatz_sequence_length(n): Returns the total number of terms in the Collatz sequence starting from n until it reaches 1. count = 1 # Starting from n itself while n != 1: if n % 2 == 0: n //= 2 else: n = 3 * n + 1 count += 1 return count def process_collatz_sequences(test_cases): Processes a list of test cases and returns the lengths of the Collatz sequences for each. test_cases: List of integers where each integer is a starting point for the Collatz sequence. Returns a list of integers representing the lengths of the sequences. return [collatz_sequence_length(n) for n in test_cases]"},{"question":"from typing import List, Tuple def cumulative_purchases(T: int, test_cases: List[Tuple[int, List[str]]]) -> List[str]: Calculates the cumulative number of purchases for each user by each date. Args: - T (int): Number of test cases. - test_cases (list): List of test cases, each case is a tuple containing an integer and a list of purchase events. Returns: - List of strings containing cumulative purchase count in format \\"username date cumulative_purchases\\". Example: >>> cumulative_purchases(1, [(5, [\\"alice 2023-06-01\\", \\"bob 2023-06-01\\", \\"alice 2023-06-01\\", \\"alice 2023-06-02\\", \\"bob 2023-06-03\\"])]) [\\"alice 2023-06-01 1\\", \\"bob 2023-06-01 1\\", \\"alice 2023-06-01 2\\", \\"alice 2023-06-02 3\\", \\"bob 2023-06-03 2\\"] def test_cumulative_purchases_single_test_case(): T = 1 test_cases = [ (5, [ \\"alice 2023-06-01\\", \\"bob 2023-06-01\\", \\"alice 2023-06-01\\", \\"alice 2023-06-02\\", \\"bob 2023-06-03\\" ]) ] expected_output = [ \\"alice 2023-06-01 1\\", \\"bob 2023-06-01 1\\", \\"alice 2023-06-01 2\\", \\"alice 2023-06-02 3\\", \\"bob 2023-06-03 2\\" ] assert cumulative_purchases(T, test_cases) == expected_output def test_cumulative_purchases_multiple_test_cases(): T = 2 test_cases = [ (3, [ \\"alice 2023-06-01\\", \\"alice 2023-06-02\\", \\"alice 2023-06-03\\" ]), (4, [ \\"bob 2023-07-01\\", \\"bob 2023-07-01\\", \\"bob 2023-07-02\\", \\"alice 2023-07-02\\" ]) ] expected_output = [ \\"alice 2023-06-01 1\\", \\"alice 2023-06-02 2\\", \\"alice 2023-06-03 3\\", \\"bob 2023-07-01 1\\", \\"bob 2023-07-01 2\\", \\"bob 2023-07-02 3\\", \\"alice 2023-07-02 1\\" ] assert cumulative_purchases(T, test_cases) == expected_output def test_cumulative_purchases_edge_case(): T = 1 test_cases = [ (1, [ \\"alice 2022-01-01\\", ]), ] expected_output = [ \\"alice 2022-01-01 1\\" ] assert cumulative_purchases(T, test_cases) == expected_output","solution":"def cumulative_purchases(T, test_cases): Calculates the cumulative number of purchases for each user by each date. Args: - T (int): Number of test cases. - test_cases (list): List of test cases, each case is a list containing purchase events. Returns: - List of strings containing cumulative purchase count in format \\"username date cumulative_purchases\\". from collections import defaultdict results = [] for case in test_cases: N, events = case user_purchase_counts = defaultdict(int) for event in events: username, date = event.split() user_purchase_counts[(username, date)] += 1 cumulative_count = sum(count for (user, dt), count in user_purchase_counts.items() if user == username and dt <= date) results.append(f\\"{username} {date} {cumulative_count}\\") return results"},{"question":"def minimum_spanning_tree(n, m, edges): Calculates the minimum cost to connect all data centers using Kruskal's algorithm. If it is impossible to connect all data centers, returns -1. :param n: Number of data centers :param m: Number of cables :param edges: List of tuples (u, v, w) where u and v are data center numbers and w is the weight of the cable :return: Minimum cost to connect all data centers, or -1 if impossible # Implement the function here pass # Example usage: # n = 4 # m = 5 # edges = [ # (1, 2, 1), # (1, 3, 4), # (2, 3, 2), # (3, 4, 3), # (2, 4, 5) # ] # print(minimum_spanning_tree(n, m, edges)) # Output: 6 from typing import List, Tuple def test_example_1(): n = 4 m = 5 edges = [ (1, 2, 1), (1, 3, 4), (2, 3, 2), (3, 4, 3), (2, 4, 5) ] assert minimum_spanning_tree(n, m, edges) == 6 def test_example_2(): n = 4 m = 2 edges = [ (1, 2, 3), (3, 4, 2) ] assert minimum_spanning_tree(n, m, edges) == -1 def test_single_edge(): n = 2 m = 1 edges = [ (1, 2, 10) ] assert minimum_spanning_tree(n, m, edges) == 10 def test_disconnected_graph(): n = 3 m = 1 edges = [ (1, 2, 5) ] assert minimum_spanning_tree(n, m, edges) == -1 def test_all_edges_equal(): n = 4 m = 6 edges = [ (1, 2, 1), (1, 3, 1), (1, 4, 1), (2, 3, 1), (2, 4, 1), (3, 4, 1) ] assert minimum_spanning_tree(n, m, edges) == 3","solution":"def minimum_spanning_tree(n, m, edges): Calculates the minimum cost to connect all data centers using Kruskal's algorithm. If it is impossible to connect all data centers, returns -1. :param n: Number of data centers :param m: Number of cables :param edges: List of tuples (u, v, w) where u and v are data center numbers and w is the weight of the cable :return: Minimum cost to connect all data centers, or -1 if impossible def find(parent, i): if parent[i] == i: return i return find(parent, parent[i]) def union(parent, rank, x, y): rootX = find(parent, x) rootY = find(parent, y) if rootX != rootY: if rank[rootX] > rank[rootY]: parent[rootY] = rootX elif rank[rootX] < rank[rootY]: parent[rootX] = rootY else: parent[rootY] = rootX rank[rootX] += 1 edges.sort(key=lambda x: x[2]) parent = [i for i in range(n)] rank = [0] * n min_cost = 0 num_edges = 0 for u, v, w in edges: if find(parent, u-1) != find(parent, v-1): union(parent, rank, u-1, v-1) min_cost += w num_edges += 1 if num_edges == n - 1: return min_cost return -1 # This function reads the input from the standard input def main(): import sys input = sys.stdin.read data = input().strip().split() n = int(data[0]) m = int(data[1]) edges = [] index = 2 for _ in range(m): u = int(data[index]) v = int(data[index + 1]) w = int(data[index + 2]) edges.append((u, v, w)) index += 3 result = minimum_spanning_tree(n, m, edges) print(result)"},{"question":"def can_travel(n: int, m: int, grid: List[str]) -> str: Determine if Petya can travel from the top-left to the bottom-right corner of the grid by only stepping on land cells ('L'). >>> can_travel(3, 3, [\\"LLW\\", \\"LWL\\", \\"LLL\\"]) \\"YES\\" >>> can_travel(3, 3, [\\"LWL\\", \\"WLL\\", \\"LWL\\"]) \\"NO\\"","solution":"def can_travel(n, m, grid): directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] def is_valid(x, y): return 0 <= x < n and 0 <= y < m and grid[x][y] == 'L' from collections import deque queue = deque([(0, 0)]) if grid[0][0] == 'L' else deque() visited = set((0, 0)) if grid[0][0] == 'L' else set() while queue: x, y = queue.popleft() if (x, y) == (n-1, m-1): return \\"YES\\" for dx, dy in directions: nx, ny = x + dx, y + dy if is_valid(nx, ny) and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny)) return \\"NO\\" # Example usage: n = 3 m = 3 grid = [ \\"LLW\\", \\"LWL\\", \\"LLL\\" ] print(can_travel(n, m, grid)) # Output: YES"},{"question":"def count_isolated_groups(grid): Count the number of isolated groups of animals in a given grid. :param grid: List[List[int]] - a 2D list representing the grid :return: int - number of isolated groups >>> grid1 = parse_input(\\"4 5n11000n11000n00100n00011\\") >>> count_isolated_groups(grid1) 3 >>> grid2 = parse_input(\\"1 1n0\\") >>> count_isolated_groups(grid2) 0 >>> grid3 = parse_input(\\"1 1n1\\") >>> count_isolated_groups(grid3) 1 >>> grid4 = parse_input(\\"3 3n100n010n001\\") >>> count_isolated_groups(grid4) 3 >>> grid5 = parse_input(\\"2 2n11n11\\") >>> count_isolated_groups(grid5) 1 >>> grid6 = parse_input(\\"5 5n10000n01110n00100n11111n00001\\") >>> count_isolated_groups(grid6) 2 def parse_input(input_text): Parse the input text into a grid. :param input_text: str - the input text containing the grid dimensions and the grid :return: List[List[int]] - parsed grid >>> parse_input(\\"4 5n11000n11000n00100n00011\\") [['1', '1', '0', '0', '0'], ['1', '1', '0', '0', '0'], ['0', '0', '1', '0', '0'], ['0', '0', '0', '1', '1']]","solution":"def count_isolated_groups(grid): Count the number of isolated groups of animals in a given grid. :param grid: List[List[int]] - a 2D list representing the grid :return: int - number of isolated groups if not grid: return 0 m, n = len(grid), len(grid[0]) def dfs(i, j): if i < 0 or j < 0 or i >= m or j >= n or grid[i][j] == '0': return grid[i][j] = '0' # Mark the cell as visited dfs(i-1, j) dfs(i+1, j) dfs(i, j-1) dfs(i, j+1) isolated_groups = 0 for i in range(m): for j in range(n): if grid[i][j] == '1': isolated_groups += 1 dfs(i, j) return isolated_groups def parse_input(input_text): lines = input_text.strip().split('n') m, n = map(int, lines[0].split()) grid = [list(line) for line in lines[1:]] return grid"},{"question":"def maxCutTrees(heights: List[int]) -> int: In a forest, there are n trees arranged in a straight line. Each tree has a certain height. A lumberjack wants to cut down the maximum number of trees such that no two consecutive trees are cut. The lumberjack can choose to either cut a tree or leave it standing, but cannot cut two adjacent trees. >>> maxCutTrees([3, 2, 7, 10, 12]) 22 >>> maxCutTrees([5, 5, 10, 40]) 45 >>> maxCutTrees([10]) 10 >>> maxCutTrees([10, 20]) 20 >>> maxCutTrees([5, 1, 5, 1, 5, 1]) 15 >>> maxCutTrees([1000, 1000, 1000, 1000]) 2000 >>> maxCutTrees([]) 0","solution":"def maxCutTrees(heights): n = len(heights) if n == 0: return 0 if n == 1: return heights[0] dp = [0] * n dp[0] = heights[0] dp[1] = max(heights[0], heights[1]) for i in range(2, n): dp[i] = max(dp[i-1], dp[i-2] + heights[i]) return dp[-1]"},{"question":"def can_split_into_segments(N: int, heights: List[int]) -> str: Determine if it is possible to split the trees into at least two contiguous segments of different heights. >>> can_split_into_segments(5, [2, 2, 3, 3, 3]) 'YES' >>> can_split_into_segments(4, [1, 1, 1, 1]) 'NO'","solution":"def can_split_into_segments(N, heights): if N < 2: return \\"NO\\" for i in range(1, N): if heights[i] != heights[i-1]: return \\"YES\\" return \\"NO\\""},{"question":"def minimum_spanning_tree_cost(N, M, roads): Find the minimum total maintenance cost to keep all houses connected. Args: N (int): The number of houses. M (int): The number of roads. roads (List[Tuple[int, int, int]]): A list of tuples containing road information (house1, house2, cost). Returns: int: The minimum total maintenance cost. Examples: >>> minimum_spanning_tree_cost(4, 5, [(1, 2, 10), (1, 3, 6), (2, 3, 5), (3, 4, 4), (2, 4, 7)]) 15 >>> minimum_spanning_tree_cost(3, 3, [(1, 2, 1), (2, 3, 2), (1, 3, 3)]) 3","solution":"def minimum_spanning_tree_cost(N, M, roads): def find(parent, i): if parent[i] == i: return i else: return find(parent, parent[i]) def union(parent, rank, x, y): root_x = find(parent, x) root_y = find(parent, y) if root_x != root_y: if rank[root_x] > rank[root_y]: parent[root_y] = root_x elif rank[root_x] < rank[root_y]: parent[root_x] = root_y else: parent[root_y] = root_x rank[root_x] += 1 roads.sort(key=lambda x: x[2]) parent = list(range(N)) rank = [0] * N total_cost = 0 edges_used = 0 for u, v, w in roads: u -= 1 v -= 1 if find(parent, u) != find(parent, v): union(parent, rank, u, v) total_cost += w edges_used += 1 if edges_used == N - 1: break return total_cost"},{"question":"from typing import List, Tuple def minimum_tasks_before_target(n: int, m: int, dependencies: List[Tuple[int, int]], t: int) -> int: Determine the minimum number of tasks that need to be completed in order to execute the target task t. Params: - n (int): The number of tasks. - m (int): The number of dependencies. - dependencies (List[Tuple[int, int]]): List of tuples where each tuple (u, v) indicates task u must be completed before task v. - t (int): The target task. Returns: - int: The minimum number of tasks that need to be completed before the target task t can be executed. Examples: >>> minimum_tasks_before_target(5, 4, [(1, 2), (2, 3), (3, 4), (4, 5)], 5) 4 >>> minimum_tasks_before_target(6, 6, [(1, 2), (1, 3), (2, 4), (3, 4), (4, 5), (4, 6)], 5) 3","solution":"from collections import deque, defaultdict def minimum_tasks_before_target(n, m, dependencies, t): # Create an adjacency list adj_list = defaultdict(list) for u, v in dependencies: adj_list[v].append(u) # Initialize distance dictionary distance = {i: float('inf') for i in range(1, n+1)} distance[t] = 0 queue = deque([t]) while queue: current = queue.popleft() for neighbor in adj_list[current]: if distance[neighbor] == float('inf'): distance[neighbor] = distance[current] + 1 queue.append(neighbor) # The number of tasks before t is the maximum distance not including the task itself return max(dist for task, dist in distance.items() if dist < float('inf')) # Example usage: # Input: 5, 4, [(1, 2), (2, 3), (3, 4), (4, 5)], 5 # Output: 4"},{"question":"from typing import List def longest_lexicographical_path(matrix: List[str]) -> int: Returns the length of the longest contiguous path in the matrix where characters are in lexicographical order. >>> longest_lexicographical_path([ ... \\"abcd\\", ... \\"bcda\\", ... \\"cdef\\" ... ]) 6 >>> longest_lexicographical_path([ ... \\"abcdefghijklmnopqrstuvwxyz\\" ... ]) 26 >>> longest_lexicographical_path([ ... \\"a\\", ... \\"b\\", ... \\"c\\" ... ]) 3 >>> longest_lexicographical_path([ ... \\"az\\", ... \\"by\\" ... ]) 2 >>> longest_lexicographical_path([ ... \\"a\\", ... \\"x\\" ... ]) 1 pass def process_input(input_string: str) -> int: Processes the input string and returns the length of the longest contiguous path in the matrix. >>> process_input(\\"3 4nabcdnbcdancdef\\") 6 pass","solution":"def longest_lexicographical_path(matrix): Returns the length of the longest contiguous path in the matrix where characters are in lexicographical order. M, N = len(matrix), len(matrix[0]) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # up, down, left, right memo = [[-1] * N for _ in range(M)] def dfs(x, y): if memo[x][y] != -1: return memo[x][y] longest_path = 1 for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < M and 0 <= ny < N and matrix[nx][ny] == chr(ord(matrix[x][y]) + 1): longest_path = max(longest_path, 1 + dfs(nx, ny)) memo[x][y] = longest_path return longest_path max_length = 1 for i in range(M): for j in range(N): max_length = max(max_length, dfs(i, j)) return max_length def process_input(input_string): input_lines = input_string.strip().split('n') M, N = map(int, input_lines[0].split()) matrix = input_lines[1:] return longest_lexicographical_path(matrix)"},{"question":"def smallest_lexicographical_string(s: str) -> str: Given a string s, repeatedly remove two adjacent characters such that the resultant string is the smallest lexicographically. >>> smallest_lexicographical_string(\\"abacb\\") == \\"aab\\" >>> smallest_lexicographical_string(\\"a\\") == \\"a\\" >>> smallest_lexicographical_string(\\"abc\\") == \\"abc\\" >>> smallest_lexicographical_string(\\"aaaa\\") == \\"aaaa\\" >>> smallest_lexicographical_string(\\"zyxwv\\") == \\"v\\" >>> smallest_lexicographical_string(\\"edcba\\") == \\"a\\" >>> smallest_lexicographical_string(\\"bcabc\\") == \\"abc\\" >>> smallest_lexicographical_string(\\"bbcabcbacb\\") == \\"aab\\" >>> smallest_lexicographical_string(\\"abcdefgh\\") == \\"abcdefgh\\"","solution":"def smallest_lexicographical_string(s): Given a string s, repeatedly remove two adjacent characters such that the resultant string is the smallest lexicographically. # The idea is to use a stack to form the result string stack = [] for char in s: # While the stack is not empty and the current character is smaller than the top of the stack, # pop the stack (this simulates the removal of one of the adjacent characters) while stack and stack[-1] > char: stack.pop() stack.append(char) # Join the elements in the stack to form the result string return ''.join(stack)"},{"question":"from typing import List def min_num_perfect_squares(n: int) -> int: Given a positive integer n, determine the minimum number of perfect square numbers (for example, 1, 4, 9, 16, ...) which sum up to n. >>> min_num_perfect_squares(12) 3 >>> min_num_perfect_squares(16) 1 >>> min_num_perfect_squares(13) 2 >>> min_num_perfect_squares(1) 1 >>> min_num_perfect_squares(2) 2 >>> min_num_perfect_squares(3) 3 >>> min_num_perfect_squares(4) 1 >>> min_num_perfect_squares(10000) 1 >>> min_num_perfect_squares(9999) 4 >>> min_num_perfect_squares(100) 1 >>> min_num_perfect_squares(99) 3","solution":"import math def min_num_perfect_squares(n): Returns the minimum number of perfect square numbers that sum up to n. if n <= 0: return 0 # List to store the minimum number of squares for each number up to n dp = [float('inf')] * (n + 1) dp[0] = 0 # Calculate dp values for i in range(1, n + 1): j = 1 while j * j <= i: dp[i] = min(dp[i], dp[i - j * j] + 1) j += 1 return dp[n]"},{"question":"def wiggleMaxLength(nums: List[int]) -> int: Returns the length of the longest subsequence that is a wiggle sequence. >>> wiggleMaxLength([1, 7, 4, 9, 2, 5]) 6 >>> wiggleMaxLength([1, 17, 5, 10, 13, 15, 10, 5, 16, 8]) 7 >>> wiggleMaxLength([1, 2, 3, 4, 5, 6, 7, 8, 9]) 2","solution":"from typing import List def wiggleMaxLength(nums: List[int]) -> int: Returns the length of the longest subsequence that is a wiggle sequence. if len(nums) < 2: return len(nums) up = down = 1 for i in range(1, len(nums)): if nums[i] > nums[i - 1]: up = down + 1 elif nums[i] < nums[i - 1]: down = up + 1 return max(up, down)"},{"question":"from typing import List def min_swaps_to_transform(initial: str, target: str) -> int: Returns the minimum number of swaps required to transform the initial string into the target string with the same set of characters, or -1 if impossible. >>> min_swaps_to_transform(\\"abc\\", \\"bca\\") 2 >>> min_swaps_to_transform(\\"ab\\", \\"ba\\") 1 >>> min_swaps_to_transform(\\"abcd\\", \\"efgh\\") -1 def multiple_test_cases(t: int, test_cases: List[str]) -> List[int]: Given multiple test cases, determines the minimum number of swaps for each. >>> multiple_test_cases(3, [\\"abc\\", \\"bca\\", \\"ab\\", \\"ba\\", \\"abcd\\", \\"dcba\\"]) [2, 1, 2] >>> multiple_test_cases(2, [\\"aaa\\", \\"aaa\\", \\"aabbccdd\\", \\"ddbbaacc\\"]) [0, 7]","solution":"def min_swaps_to_transform(initial, target): Returns the minimum number of swaps required to transform the initial string into the target string with the same set of characters, or -1 if impossible. # If sorted characters do not match, it's impossible if sorted(initial) != sorted(target): return -1 # Helper function to count swaps using bubble sort technique def count_swaps(src, tgt): src = list(src) swaps = 0 for i in range(len(src)): while src[i] != tgt[i]: swap_idx = src.index(tgt[i], i) src[i], src[swap_idx] = src[swap_idx], src[i] swaps += 1 return swaps return count_swaps(initial, target) def multiple_test_cases(t, test_cases): results = [] for i in range(t): initial = test_cases[2 * i] target = test_cases[2 * i + 1] result = min_swaps_to_transform(initial, target) results.append(result) return results"},{"question":"def max_absolute_difference(arr: List[int]) -> int: Given an array of integers, find the maximum absolute difference between any two elements in the array. >>> max_absolute_difference([1, 5, 9, -10, 3]) 19 >>> max_absolute_difference([1, 2, 3, 4, 5]) 4 >>> max_absolute_difference([-1, -2, -3, -4, -5]) 4 >>> max_absolute_difference([0, 0, 0, 0]) 0 >>> max_absolute_difference([100, -100, 50, -50, 25]) 200 >>> max_absolute_difference([7]) 0 >>> max_absolute_difference([-7]) 0","solution":"def max_absolute_difference(arr): Returns the maximum absolute difference between any two elements in an array. min_elem = min(arr) max_elem = max(arr) return abs(max_elem - min_elem) # Example usage # n, arr = 5, [1, 5, 9, -10, 3] # print(max_absolute_difference(arr)) # Should output 19"},{"question":"def is_reachable(grid, n, m): Determine if it is possible for the player to reach the bottom-right corner from the top-left corner, avoiding obstacles in a 2D grid. Args: grid (List[List[str]]): 2D list representing the grid with '.' for empty cells and '#' for obstacles. n (int): Number of rows in the grid. m (int): Number of columns in the grid. Returns: str: \\"YES\\" if it is possible to reach the destination, otherwise \\"NO\\". Examples: >>> is_reachable([ ['.', '.', '.'], ['#', '#', '.'], ['.', '.', '.'] ], 3, 3) \\"YES\\" >>> is_reachable([ ['.', '#', '.'], ['#', '#', '#'], ['.', '.', '.'] ], 3, 3) \\"NO\\" pass # Unit tests (do not modify) def test_reachable_simple_case(): grid = [ ['.', '.'], ['.', '.'] ] assert is_reachable(grid, 2, 2) == \\"YES\\" def test_blocked_start(): grid = [ ['#', '.'], ['.', '.'] ] assert is_reachable(grid, 2, 2) == \\"NO\\" def test_blocked_end(): grid = [ ['.', '.'], ['.', '#'] ] assert is_reachable(grid, 2, 2) == \\"NO\\" def test_no_possible_path(): grid = [ ['.', '#', '.'], ['#', '#', '#'], ['.', '.', '.'] ] assert is_reachable(grid, 3, 3) == \\"NO\\" def test_possible_path(): grid = [ ['.', '.', '.'], ['#', '#', '.'], ['.', '.', '.'] ] assert is_reachable(grid, 3, 3) == \\"YES\\" def test_large_grid_no_path(): n, m = 1000, 1000 grid = [['.' for _ in range(m)] for _ in range(n)] for i in range(n): grid[i][m//2] = '#' assert is_reachable(grid, 1000, 1000) == \\"NO\\" def test_large_grid_with_path(): n, m = 1000, 1000 grid = [['.' for _ in range(m)] for _ in range(n)] for i in range(n - 1): grid[i][m//2] = '#' assert is_reachable(grid, 1000, 1000) == \\"YES\\"","solution":"def is_reachable(grid, n, m): if grid[0][0] == '#' or grid[n-1][m-1] == '#': return \\"NO\\" from collections import deque directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] queue = deque([(0, 0)]) visited = set() visited.add((0, 0)) while queue: x, y = queue.popleft() if (x, y) == (n-1, m-1): return \\"YES\\" for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and grid[nx][ny] == '.' and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny)) return \\"NO\\""},{"question":"def find_top_students(test_cases): Determine the top student for each subject based on the highest scores provided. >>> find_top_students([[(\\"Alice\\", \\"Math\\", 90), (\\"Bob\\", \\"Physics\\", 85), (\\"Charlie\\", \\"Math\\", 92), (\\"David\\", \\"Physics\\", 88), (\\"Eve\\", \\"Math\\", 92)]]) [['Math: Charlie', 'Physics: David']] >>> find_top_students([[(\\"Alice\\", \\"Math\\", 90), (\\"Bob\\", \\"Math\\", 90), (\\"Charlie\\", \\"Math\\", 92), (\\"David\\", \\"Physics\\", 88), (\\"Eve\\", \\"Physics\\", 88)]]) [['Math: Charlie', 'Physics: David']] >>> find_top_students([[(\\"Alice\\", \\"Math\\", 90), (\\"Charlie\\", \\"Math\\", 92), (\\"Bob\\", \\"Math\\", 92)]]) [['Math: Bob']]","solution":"def find_top_students(test_cases): output = [] for case in test_cases: student_scores = case subject_top_student = {} for student in student_scores: name, subject, score = student if subject not in subject_top_student: subject_top_student[subject] = (name, score) else: top_student, top_score = subject_top_student[subject] if score > top_score or (score == top_score and name < top_student): subject_top_student[subject] = (name, score) sorted_subjects = sorted(subject_top_student.keys()) result = [] for subject in sorted_subjects: result.append(f\\"{subject}: {subject_top_student[subject][0]}\\") output.append(result) return output"},{"question":"def group_indices(n: int, arr: List[int]) -> List[Tuple[int, int, int]]: Groups integers with the same value and returns their start and end indices. Parameters: n (int): Number of elements in the list. arr (list): List of integers. Returns: list: List of tuples containing the integer, starting index, and ending index of each group. >>> group_indices(8, [2, 2, 1, 1, 1, 2, 2, 3]) [(2, 1, 2), (1, 3, 5), (2, 6, 7), (3, 8, 8)] >>> group_indices(5, [4, 4, 4, 5, 5]) [(4, 1, 3), (5, 4, 5)] >>> group_indices(7, [7, 7, 7, 6, 6, 7, 7]) [(7, 1, 3), (6, 4, 5), (7, 6, 7)] >>> group_indices(1, [1]) [(1, 1, 1)] >>> group_indices(6, [1, 2, 3, 4, 5, 6]) [(1, 1, 1), (2, 2, 2), (3, 3, 3), (4, 4, 4), (5, 5, 5), (6, 6, 6)] >>> group_indices(10, [3, 3, 3, 3, 3, 3, 3, 3, 3, 3]) [(3, 1, 10)] # Add your code here","solution":"def group_indices(n, arr): Groups integers with the same value and returns their start and end indices. Parameters: n (int): Number of elements in the list. arr (list): List of integers. Returns: list: List of tuples containing the integer, starting index, and ending index of each group. res = [] i = 0 while i < n: start = i + 1 while i + 1 < n and arr[i] == arr[i + 1]: i += 1 end = i + 1 res.append((arr[i], start, end)) i += 1 return res"},{"question":"from typing import List, Tuple def min_meeting_rooms(bookings: List[Tuple[int, int]]) -> int: Given a list of intervals representing bookings, returns the minimum number of conference rooms required. Args: bookings (List[Tuple[int, int]]): List of tuples representing start and end times of bookings. Returns: int: Minimum number of conference rooms required. Examples: >>> min_meeting_rooms([(0, 30), (5, 10), (15, 20), (10, 15), (20, 25)]) 2 >>> min_meeting_rooms([(1, 5), (2, 6), (8, 10)]) 2 >>> min_meeting_rooms([(3, 7), (2, 3), (3, 4), (4, 5)]) 2 >>> min_meeting_rooms([]) 0 >>> min_meeting_rooms([(1, 3)]) 1 pass def process_input(input_data: str) -> List[int]: Process the input data and return result for each dataset. Args: input_data (str): The input data containing multiple datasets. Returns: List[int]: List of results for each dataset. Examples: >>> input_data = \\"5n0 30n5 10n15 20n10 15n20 25n3n1 5n2 6n8 10n4n3 7n2 3n3 4n4 5n0n\\" >>> process_input(input_data) [2, 2, 2] >>> input_data = \\"3n1 5n2 6n8 10n0n\\" >>> process_input(input_data) [2] >>> input_data = \\"0n\\" >>> process_input(input_data) [] pass","solution":"def min_meeting_rooms(bookings): Given a list of intervals representing bookings, returns the minimum number of conference rooms required. if not bookings: return 0 # Separate out the start and end times start_times = sorted(booking[0] for booking in bookings) end_times = sorted(booking[1] for booking in bookings) start_pointer, end_pointer = 0, 0 used_rooms = 0 max_rooms = 0 # Iterate over the start times to allocate rooms while start_pointer < len(start_times): if start_times[start_pointer] >= end_times[end_pointer]: # A meeting ended, so a room gets freed up used_rooms -= 1 end_pointer += 1 # Assign a room for the new incoming meeting used_rooms += 1 start_pointer += 1 # Track the maximum number of rooms required max_rooms = max(max_rooms, used_rooms) return max_rooms def process_input(input_data): Process the input data and return result for each dataset. datasets = input_data.strip().split(\\"n\\") results = [] i = 0 while i < len(datasets): m = int(datasets[i].strip()) if m == 0: break bookings = [] for j in range(1, m + 1): start, end = map(int, datasets[i + j].strip().split()) bookings.append((start, end)) results.append(min_meeting_rooms(bookings)) i += m + 1 return results"},{"question":"def max_non_overlapping_events(n: int, events: List[Tuple[int, int]]) -> int: Returns the maximum number of non-overlapping hackathon events. Parameters: n (int): The number of hackathon events. events (list): List of tuples, where each tuple contains two integers (si, ei) representing the start and end times of each event. Returns: int: The maximum number of non-overlapping hackathon events that can be organized. >>> max_non_overlapping_events(5, [(1, 4), (2, 5), (3, 6), (4, 7), (5, 8)]) 2 >>> max_non_overlapping_events(3, [(1, 3), (2, 4), (3, 5)]) 2 >>> max_non_overlapping_events(5, [(1, 2), (3, 4), (5, 6), (7, 8), (9, 10)]) 5 >>> max_non_overlapping_events(4, [(1, 10), (2, 9), (3, 8), (4, 7)]) 1 >>> max_non_overlapping_events(4, [(1, 2), (2, 3), (3, 5), (1, 5)]) 3 >>> max_non_overlapping_events(1, [(1, 10)]) 1 >>> max_non_overlapping_events(6, [(1, 3), (2, 5), (4, 6), (7, 8), (5, 9), (10, 11)]) 4","solution":"def max_non_overlapping_events(n, events): Returns the maximum number of non-overlapping hackathon events. Parameters: n (int): The number of hackathon events. events (list): List of tuples, where each tuple contains two integers (si, ei) representing the start and end times of each event. Returns: int: The maximum number of non-overlapping hackathon events that can be organized. # Sort events based on end time events.sort(key=lambda x: x[1]) max_events = 0 last_end_time = 0 for start, end in events: if start >= last_end_time: max_events += 1 last_end_time = end return max_events"},{"question":"def generate_sequence(n, a): Generate a new sequence \`b\` from sequence \`a\` such that each element b_i is the sum of all elements of a greater than a_i. >>> generate_sequence(5, [3, 1, 4, 1, 5]) [9, 12, 5, 12, 0] >>> generate_sequence(3, [0, 1, 2]) [3, 2, 0]","solution":"def generate_sequence(n, a): b = [] for i in range(n): sum_greater = sum(x for x in a if x > a[i]) b.append(sum_greater) return b # Example usage n = 5 a = [3, 1, 4, 1, 5] print(generate_sequence(n, a)) # Expected output: [9, 12, 5, 12, 0]"},{"question":"def count_valid_segments(n: int) -> int: Given an integer n, returns the total number of unique valid string representations. >>> count_valid_segments(123) == 3 >>> count_valid_segments(27) == 1 >>> count_valid_segments(1) == 1 >>> count_valid_segments(9) == 1","solution":"def count_valid_segments(n): Given an integer n, returns the total number of unique valid string representations. s = str(n) length = len(s) def is_valid_segment(segment): if not segment or segment[0] == '0': return False num = int(segment) return 1 <= num <= 26 def count_ways(index): if index == length: return 1 if index > length: return 0 count = 0 if is_valid_segment(s[index:index + 1]): count += count_ways(index + 1) if is_valid_segment(s[index:index + 2]): count += count_ways(index + 2) return count if s and s[0] == '0': # leading zeros are not allowed return 0 return count_ways(0)"},{"question":"def generateSpiralMatrix(n: int) -> List[List[int]]: Generate a n x n matrix in spiral order. >>> generateSpiralMatrix(1) [[1]] >>> generateSpiralMatrix(2) [[1, 2], [4, 3]] >>> generateSpiralMatrix(3) [[1, 2, 3], [8, 9, 4], [7, 6, 5]] >>> generateSpiralMatrix(4) [[ 1, 2, 3, 4], [12, 13, 14, 5], [11, 16, 15, 6], [10, 9, 8, 7]] >>> generateSpiralMatrix(5) [[ 1, 2, 3, 4, 5], [16, 17, 18, 19, 6], [15, 24, 25, 20, 7], [14, 23, 22, 21, 8], [13, 12, 11, 10, 9]]","solution":"def generateSpiralMatrix(n): Generate a n x n matrix in spiral order. matrix = [[0]*n for _ in range(n)] left, right, top, bottom = 0, n - 1, 0, n - 1 num = 1 while left <= right and top <= bottom: # Traverse from left to right for i in range(left, right + 1): matrix[top][i] = num num += 1 top += 1 # Traverse from top to bottom for i in range(top, bottom + 1): matrix[i][right] = num num += 1 right -= 1 if top <= bottom: # Traverse from right to left for i in range(right, left - 1, -1): matrix[bottom][i] = num num += 1 bottom -= 1 if left <= right: # Traverse from bottom to top for i in range(bottom, top - 1, -1): matrix[i][left] = num num += 1 left += 1 return matrix"},{"question":"def is_power_of_integer(n: int) -> str: Determine if the given integer n is a power of an integer greater than 1. If it is, return \\"YES\\", otherwise return \\"NO\\". >>> is_power_of_integer(27) \\"YES\\" >>> is_power_of_integer(10) \\"NO\\" >>> is_power_of_integer(16) \\"YES\\" >>> is_power_of_integer(1) \\"NO\\" >>> is_power_of_integer(64) \\"YES\\" >>> is_power_of_integer(82) \\"NO\\" >>> is_power_of_integer(81) \\"YES\\" >>> is_power_of_integer(1024) \\"YES\\"","solution":"import math def is_power_of_integer(n): Returns \\"YES\\" if there exists some integer x (x > 1) and integer k (k > 1) such that x^k = n, otherwise returns \\"NO\\". if n <= 1: return \\"NO\\" max_base = int(math.sqrt(n)) + 1 for x in range(2, max_base): k = 2 while (x ** k) <= n: if (x ** k) == n: return \\"YES\\" k += 1 return \\"NO\\""},{"question":"class SegmentTree: def __init__(self, data): self.n = len(data) self.tree = [0] * (2 * self.n) self.build(data) def build(self, data): # Insert leaf nodes in tree for i in range(self.n): self.tree[self.n + i] = data[i] # Build the tree by calculating parents for i in range(self.n - 1, 0, -1): self.tree[i] = max(self.tree[i * 2], self.tree[i * 2 + 1]) def update(self, pos, value): # Update the leaf node pos += self.n self.tree[pos] = value # Update the parents while pos > 1: pos //= 2 self.tree[pos] = max(self.tree[2 * pos], self.tree[2 * pos + 1]) def range_query(self, left, right): # Range is [left, right) left += self.n right += self.n max_val = float('-inf') while left < right: if left % 2: max_val = max(max_val, self.tree[left]) left += 1 if right % 2: right -= 1 max_val = max(max_val, self.tree[right]) left //= 2 right //= 2 return max_val def handle_operations(n: int, m: int, sequence: List[int], operations: List[Tuple[int, int, int]]) -> List[int]: Handle a sequence of update and query operations on the sequence. >>> handle_operations(5, 5, [1, 5, 2, 4, 3], [(2, 2, 4), (1, 3, 6), (2, 1, 5), (1, 5, 7), (2, 4, 5)]) [5, 6, 7] >>> handle_operations(1, 3, [10], [(2, 1, 1), (1, 1, 5), (2, 1, 1)]) [10, 5] >>> handle_operations(3, 4, [3, 3, 3], [(1, 1, 5), (1, 2, 6), (1, 3, 7), (2, 1, 3)]) [7] >>> handle_operations(6, 3, [1, 15, 7, 9, 10, 13], [(2, 1, 6), (1, 1, 20), (2, 3, 6)]) [15, 13]","solution":"class SegmentTree: def __init__(self, data): self.n = len(data) self.tree = [0] * (2 * self.n) self.build(data) def build(self, data): # Insert leaf nodes in tree for i in range(self.n): self.tree[self.n + i] = data[i] # Build the tree by calculating parents for i in range(self.n - 1, 0, -1): self.tree[i] = max(self.tree[i * 2], self.tree[i * 2 + 1]) def update(self, pos, value): # Update the leaf node pos += self.n self.tree[pos] = value # Update the parents while pos > 1: pos //= 2 self.tree[pos] = max(self.tree[2 * pos], self.tree[2 * pos + 1]) def range_query(self, left, right): # Range is [left, right) left += self.n right += self.n max_val = float('-inf') while left < right: if left % 2: max_val = max(max_val, self.tree[left]) left += 1 if right % 2: right -= 1 max_val = max(max_val, self.tree[right]) left //= 2 right //= 2 return max_val def handle_operations(n, m, sequence, operations): seg_tree = SegmentTree(sequence) results = [] for op in operations: t, x, y = op if t == 1: seg_tree.update(x - 1, y) elif t == 2: results.append(seg_tree.range_query(x - 1, y)) return results"},{"question":"def max_height_reachable(M, N, Sx, Sy, E, terrain): Calculate the maximum height Ella can reach without depleting her energy. M: int - Number of rows in the terrain grid. N: int - Number of columns in the terrain grid. Sx: int - Starting position x coordinate. Sy: int - Starting position y coordinate. E: int - Initial amount of energy. terrain: List[List[Tuple[int, int]]] - Terrain grid where each cell is a tuple (height, cost). Returns: int - Maximum height that can be reached without running out of energy. Example: >>> max_height_reachable(3, 3, 0, 0, 20, [[(10, 1), (15, 2), (20, 3)], [(5, 1), (30, 1), (25, 2)], [(10, 2), (35, 1), (40, 1)]]) 40 >>> max_height_reachable(2, 2, 0, 0, 1, [[(10, 1), (15, 2)], [(20, 1), (25, 2)]]) 10 pass # Helper function to parse input and call max_height_reachable def parse_and_solve(input_str): Helper function to parse the input string and call the max_height_reachable function. input_str: str - Multiline input string providing the required inputs. Returns: int - Maximum height that can be reached without running out of energy. Example: >>> input_data = '''3 3 0 0 20 10 1 15 2 20 3 5 1 30 1 25 2 10 2 35 1 40 1''' >>> parse_and_solve(input_data) 40 pass","solution":"def max_height_reachable(M, N, Sx, Sy, E, terrain): directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] visited = set() max_height = 0 def dfs(x, y, energy, current_height): nonlocal max_height if energy < 0 or (x, y) in visited: return visited.add((x, y)) current_height = terrain[x][y][0] max_height = max(max_height, current_height) for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < M and 0 <= ny < N: new_energy = energy - 1 - terrain[nx][ny][1] dfs(nx, ny, new_energy, current_height) visited.remove((x, y)) energy_left = E - terrain[Sx][Sy][1] if energy_left >= 0: dfs(Sx, Sy, energy_left, terrain[Sx][Sy][0]) return max_height # Helper function to parse input and call max_height_reachable def parse_and_solve(input_str): lines = input_str.strip().split('n') M, N = map(int, lines[0].split()) Sx, Sy = map(int, lines[1].split()) E = int(lines[2]) terrain = [] for i in range(3, 3 + M): row = list(map(int, lines[i].split())) terrain_row = [(row[j * 2], row[j * 2 + 1]) for j in range(N)] terrain.append(terrain_row) return max_height_reachable(M, N, Sx, Sy, E, terrain)"},{"question":"def process_test_cases(T: int, test_cases: List[Tuple[int, int]]) -> List[int]: Calculate the sum of all prime numbers in the given ranges for multiple test cases. Args: T: Number of test cases. test_cases: A list of tuples, each containing two integers L and R defining the range. Returns: A list of sums of prime numbers in the given ranges. Example: >>> process_test_cases(3, [(1, 10), (11, 19), (20, 30)]) [17, 60, 52] >>> process_test_cases(1, [(14, 16)]) [0]","solution":"def generate_primes_up_to(n): Returns a list of prime numbers up to n is_prime = [True] * (n + 1) is_prime[0] = is_prime[1] = False for start in range(2, int(n**0.5) + 1): if is_prime[start]: for multiple in range(start*start, n + 1, start): is_prime[multiple] = False primes = [num for num, prime in enumerate(is_prime) if prime] return primes def sum_primes_in_range(L, R, primes): Returns the sum of prime numbers between L and R (inclusive) return sum(p for p in primes if L <= p <= R) def sum_primes_in_ranges(test_cases): Returns a list of results for each range specified in the test cases max_R = max(R for _, R in test_cases) primes = generate_primes_up_to(max_R) results = [] for L, R in test_cases: results.append(sum_primes_in_range(L, R, primes)) return results # Function to handle multiple test cases def process_test_cases(T, test_cases): return sum_primes_in_ranges(test_cases)"},{"question":"def can_organize_books(n: int, m: int, k: int, c: int, heights: List[int]) -> str: Determine if Alice can organize her books on the bookshelf within given constraints. >>> can_organize_books(5, 3, 2, 15, [5, 10, 14, 7, 4]) 'YES' >>> can_organize_books(4, 1, 3, 10, [6, 5, 4, 3]) 'NO' from solution import can_organize_books def test_can_organize_books_case1(): n = 5 m = 3 k = 2 c = 15 heights = [5, 10, 14, 7, 4] assert can_organize_books(n, m, k, c, heights) == 'YES' def test_can_organize_books_case2(): n = 4 m = 1 k = 3 c = 10 heights = [6, 5, 4, 3] assert can_organize_books(n, m, k, c, heights) == 'NO' def test_can_organize_books_case3(): n = 3 m = 2 k = 2 c = 20 heights = [10, 10, 15] assert can_organize_books(n, m, k, c, heights) == 'YES' def test_can_organize_books_case4(): n = 6 m = 3 k = 2 c = 9 heights = [5, 5, 5, 5, 5, 5] assert can_organize_books(n, m, k, c, heights) == 'NO' def test_can_organize_books_case5(): n = 6 m = 6 k = 1 c = 10 heights = [1, 2, 3, 4, 5, 6] assert can_organize_books(n, m, k, c, heights) == 'YES' def test_can_organize_books_edge_case(): n = 1 m = 1 k = 1 c = 10 heights = [10] assert can_organize_books(n, m, k, c, heights) == 'YES' def test_not_possible_case(): n = 2 m = 1 k = 1 c = 5 heights = [3, 3] assert can_organize_books(n, m, k, c, heights) == 'NO'","solution":"def can_organize_books(n, m, k, c, heights): heights.sort(reverse=True) shelf_count = [0] * m shelf_height = [0] * m for height in heights: placed = False for i in range(m): if shelf_count[i] < k and shelf_height[i] + height <= c: shelf_count[i] += 1 shelf_height[i] += height placed = True break if not placed: return \\"NO\\" return \\"YES\\" # Example usage n = 5 m = 3 k = 2 c = 15 heights = [5, 10, 14, 7, 4] print(can_organize_books(n, m, k, c, heights)) # Output: YES n = 4 m = 1 k = 3 c = 10 heights = [6, 5, 4, 3] print(can_organize_books(n, m, k, c, heights)) # Output: NO"},{"question":"def unique_paths_with_obstacles(grid: List[List[int]]) -> int: Determines the number of unique paths in a grid with obstacles. Args: - grid (List[List[int]]): 2D list representing the grid where 0 is an empty space and 1 is an obstacle. Returns: - int: Number of unique paths from the top-left to the bottom-right corner without hitting obstacles. Example: >>> unique_paths_with_obstacles([ [0, 0, 0], [0, 1, 0], [0, 0, 0] ]) 2 >>> unique_paths_with_obstacles([ [1, 0, 0], [0, 0, 0], [0, 0, 0] ]) 0 import pytest from solution import unique_paths_with_obstacles def test_example_case(): grid = [ [0, 0, 0], [0, 1, 0], [0, 0, 0] ] assert unique_paths_with_obstacles(grid) == 2 def test_no_obstacles(): grid = [ [0, 0, 0], [0, 0, 0], [0, 0, 0] ] assert unique_paths_with_obstacles(grid) == 6 def test_all_obstacles(): grid = [ [0, 1, 0], [1, 1, 0], [0, 0, 0] ] assert unique_paths_with_obstacles(grid) == 0 def test_start_with_obstacle(): grid = [ [1, 0, 0], [0, 0, 0], [0, 0, 0] ] assert unique_paths_with_obstacles(grid) == 0 def test_finish_with_obstacle(): grid = [ [0, 0, 0], [0, 0, 0], [0, 0, 1] ] assert unique_paths_with_obstacles(grid) == 0 def test_single_cell_no_obstacle(): grid = [[0]] assert unique_paths_with_obstacles(grid) == 1 def test_single_cell_with_obstacle(): grid = [[1]] assert unique_paths_with_obstacles(grid) == 0","solution":"def unique_paths_with_obstacles(grid): Determines the number of unique paths in a grid with obstacles. Args: - grid (List[List[int]]): 2D list representing the grid where 0 is an empty space and 1 is an obstacle. Returns: - int: Number of unique paths from the top-left to the bottom-right corner without hitting obstacles. if not grid or grid[0][0] == 1: return 0 m, n = len(grid), len(grid[0]) # Initializing the DP table dp = [[0] * n for _ in range(m)] dp[0][0] = 1 # starting point # filling the first row for j in range(1, n): dp[0][j] = dp[0][j-1] if grid[0][j] == 0 else 0 # filling the first column for i in range(1, m): dp[i][0] = dp[i-1][0] if grid[i][0] == 0 else 0 for i in range(1, m): for j in range(1, n): if grid[i][j] == 1: dp[i][j] = 0 else: dp[i][j] = dp[i-1][j] + dp[i][j-1] return dp[m-1][n-1]"},{"question":"def arithmetic_sequence_terms(a: int, d: int, n: int, k: int) -> List[int]: Given the first term (a), common difference (d), number of terms (n), and an integer (k), returns a list of terms in the arithmetic sequence that are divisible by k. If no terms are divisible by k, it returns 'None'. >>> arithmetic_sequence_terms(2, 3, 10, 5) [5, 20] >>> arithmetic_sequence_terms(1, 1, 10, 2) [2, 4, 6, 8, 10] >>> arithmetic_sequence_terms(1, 1, 5, 7) 'None' >>> arithmetic_sequence_terms(4, 5, 3, 50) 'None' >>> arithmetic_sequence_terms(3, 3, 4, 3) [3, 6, 9, 12] >>> arithmetic_sequence_terms(10, 2, 5, 2) [10, 12, 14, 16, 18] >>> arithmetic_sequence_terms(1, 1, 1, 1) [1] >>> arithmetic_sequence_terms(100, 100, 1, 100) [100]","solution":"def arithmetic_sequence_terms(a, d, n, k): Given the first term (a), common difference (d), number of terms (n), and an integer (k), this function returns a list of terms in the arithmetic sequence that are divisible by k. If no terms are divisible by k, it returns 'None'. results = [] for i in range(n): term = a + i * d if term % k == 0: results.append(term) if not results: return \\"None\\" return results # Example usage: # a, d, n, k = 2, 3, 10, 5 # print(arithmetic_sequence_terms(a, d, n, k)) # Output: [5, 20]"},{"question":"def can_arrange_in_grid(n: int, dimensions: List[Tuple[int, int]]) -> str: Determines if SmartPanels can be arranged in a grid that satisfies the restrictions. :param n: Number of SmartPanels :param dimensions: List of tuples with width and height of each SmartPanel :return: \\"YES\\" if possible to arrange in the grid, otherwise \\"NO\\" >>> can_arrange_in_grid(4, [(5, 8), (5, 8), (5, 8), (5, 8)]) == \\"YES\\" >>> can_arrange_in_grid(3, [(5, 8), (6, 8), (5, 9)]) == \\"NO\\" >>> can_arrange_in_grid(3, [(5, 8), (5, 9), (5, 10)]) == \\"YES\\" >>> can_arrange_in_grid(3, [(5, 8), (6, 8), (7, 8)]) == \\"YES\\" >>> can_arrange_in_grid(4, [(5, 8), (6, 9), (7, 10), (8, 11)]) == \\"NO\\" >>> can_arrange_in_grid(1, [(5, 8)]) == \\"YES\\"","solution":"def can_arrange_in_grid(n, dimensions): Determines if SmartPanels can be arranged in a grid that satisfies the restrictions. :param n: Number of SmartPanels :param dimensions: List of tuples with width and height of each SmartPanel :return: \\"YES\\" if possible to arrange in the grid, otherwise \\"NO\\" # Collect all unique widths and heights unique_widths = set() unique_heights = set() for width, height in dimensions: unique_widths.add(width) unique_heights.add(height) # We can only form a grid if there's only one unique width or only one unique height if len(unique_widths) == 1 or len(unique_heights) == 1: return \\"YES\\" else: return \\"NO\\""},{"question":"def validate_transactions(n: int, transactions: List[str]) -> List[str]: Validate a list of transaction logs. Args: n (int): Number of transaction logs. transactions (List[str]): List of transaction logs. Returns: List[str]: A list of strings where each string is either \\"VALID\\" or \\"INVALID\\". >>> transactions = [ ... \\"D 1 1 1001 500\\", ... \\"W 2 2 1001 300\\", ... \\"W 3 3 1001 300\\", ... \\"T 4 4 1001 1002 200\\", ... \\"T 5 5 1003 1002 100\\" ... ] >>> validate_transactions(5, transactions) [\\"VALID\\", \\"VALID\\", \\"INVALID\\", \\"VALID\\", \\"INVALID\\"] >>> transactions = [ ... \\"D 1 1 2001 1000\\", ... \\"T 2 2 2001 2002 500\\", ... \\"W 3 3 2001 100\\", ... \\"W 4 4 2001 500\\", ... \\"D 5 5 2002 100\\", ... \\"T 6 6 2002 2001 100\\" ... ] >>> validate_transactions(6, transactions) [\\"VALID\\", \\"VALID\\", \\"VALID\\", \\"INVALID\\", \\"VALID\\", \\"VALID\\"] >>> transactions = [ ... \\"W 1 1 3001 100\\", ... \\"T 2 2 3002 3001 50\\", ... \\"W 3 3 3002 20\\", ... \\"T 4 4 3003 3002 10\\" ... ] >>> validate_transactions(4, transactions) [\\"INVALID\\", \\"INVALID\\", \\"INVALID\\", \\"INVALID\\"] >>> transactions = [ ... \\"D 1 1 4001 500\\", ... \\"W 2 2 4001 300\\", ... \\"W 3 3 4001 200\\", ... \\"W 4 4 4001 100\\" ... ] >>> validate_transactions(4, transactions) [\\"VALID\\", \\"VALID\\", \\"VALID\\", \\"INVALID\\"] >>> transactions = [ ... \\"D 1 1 5001 200\\", ... \\"T 2 2 5001 5002 200\\", ... \\"W 3 3 5001 100\\", ... \\"D 4 4 5002 100\\", ... \\"W 5 5 5002 300\\" ... ] >>> validate_transactions(5, transactions) [\\"VALID\\", \\"VALID\\", \\"INVALID\\", \\"VALID\\", \\"VALID\\"]","solution":"def validate_transactions(n, transactions): accounts = {} results = [] for transaction in transactions: parts = transaction.split() transaction_type = parts[0] timestamp = int(parts[1]) transaction_id = int(parts[2]) if transaction_type == \\"D\\": account_id = int(parts[3]) amount = int(parts[4]) if account_id not in accounts: accounts[account_id] = 0 accounts[account_id] += amount results.append(\\"VALID\\") elif transaction_type == \\"W\\": account_id = int(parts[3]) amount = int(parts[4]) if account_id not in accounts: accounts[account_id] = 0 if accounts[account_id] >= amount: accounts[account_id] -= amount results.append(\\"VALID\\") else: results.append(\\"INVALID\\") elif transaction_type == \\"T\\": source_account_id = int(parts[3]) destination_account_id = int(parts[4]) amount = int(parts[5]) if source_account_id not in accounts: accounts[source_account_id] = 0 if destination_account_id not in accounts: accounts[destination_account_id] = 0 if accounts[source_account_id] >= amount: accounts[source_account_id] -= amount accounts[destination_account_id] += amount results.append(\\"VALID\\") else: results.append(\\"INVALID\\") return results"},{"question":"def max_subgrid_sum(n: int, m: int, grid: List[List[int]]) -> int: Returns the maximum sum of all elements in any subgrid of the given n x m grid. >>> max_subgrid_sum(3, 3, [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) 45 >>> max_subgrid_sum(1, 1, [ ... [5] ... ]) 5 >>> max_subgrid_sum(2, 2, [ ... [-1, -2], ... [-3, -4] ... ]) -1 >>> max_subgrid_sum(2, 3, [ ... [1, -2, 3], ... [-1, 5, -4] ... ]) 5 >>> max_subgrid_sum(2, 2, [ ... [0, 0], ... [0, 0] ... ]) 0 >>> max_subgrid_sum(2, 2, [ ... [1, 2], ... [3, 4] ... ]) 10","solution":"def max_subgrid_sum(n, m, grid): Returns the maximum sum of all elements in any subgrid of the given n x m grid. # Create the prefix sum array prefix_sum = [[0] * (m + 1) for _ in range(n + 1)] # Populate the prefix sum array for i in range(1, n + 1): for j in range(1, m + 1): prefix_sum[i][j] = ( grid[i-1][j-1] + prefix_sum[i-1][j] + prefix_sum[i][j-1] - prefix_sum[i-1][j-1] ) max_sum = float('-inf') # Evaluate every subgrid using the prefix sums for r1 in range(1, n+1): for r2 in range(r1, n+1): for c1 in range(1, m+1): for c2 in range(c1, m+1): subgrid_sum = ( prefix_sum[r2][c2] - prefix_sum[r1-1][c2] - prefix_sum[r2][c1-1] + prefix_sum[r1-1][c1-1] ) max_sum = max(max_sum, subgrid_sum) return max_sum"},{"question":"from typing import Tuple, List def sort_containers(test_cases: List[List[Tuple[int, str]]]) -> List[List[Tuple[int, str]]]: Sorts containers by their color and within each color group by their weight. Args: test_cases (List[List[Tuple[int, str]]]): A list of test cases, where each test case is a list of tuples. Each tuple contains the weight of the container as an integer and the color of the container as a string. Returns: List[List[Tuple[int, str]]]: A list of sorted test cases. Example: >>> test_cases = [[(10, 'red'), (5, 'blue'), (7, 'red'), (3, 'blue'), (8, 'blue')], [(1, 'green'), (2, 'green'), (1, 'blue'), (2, 'blue')]] >>> sort_containers(test_cases) [[(5, 'blue'), (8, 'blue'), (3, 'blue'), (7, 'red'), (10, 'red')], [(1, 'blue'), (2, 'blue'), (1, 'green'), (2, 'green')]] def parse_input(input_data: str) -> List[List[Tuple[int, str]]]: Parses the input data into a list of test cases. Args: input_data (str): A string containing the input data. Returns: List[List[Tuple[int, str]]]: A list of test cases. Example: >>> input_data = \\"2n5n10 redn5 bluen7 redn3 bluen8 bluen4n1 greenn2 greenn1 bluen2 blue\\" >>> parse_input(input_data) [[(10, 'red'), (5, 'blue'), (7, 'red'), (3, 'blue'), (8, 'blue')], [(1, 'green'), (2, 'green'), (1, 'blue'), (2, 'blue')]] def format_output(sorted_containers: List[List[Tuple[int, str]]]) -> str: Formats the sorted containers into a string. Args: sorted_containers (List[List[Tuple[int, str]]]): A list of sorted test cases. Returns: str: A formatted string representing the sorted containers. Example: >>> sorted_containers = [[(5, 'blue'), (8, 'blue'), (3, 'blue'), (7, 'red'), (10, 'red')], [(1, 'blue'), (2, 'blue'), (1, 'green'), (2, 'green')]] >>> format_output(sorted_containers) \\"5 bluen8 bluen3 bluen7 redn10 redn1 bluen2 bluen1 greenn2 green\\"","solution":"def sort_containers(test_cases): results = [] for containers in test_cases: sorted_containers = sorted(containers, key=lambda x: (x[1], x[0])) results.append(sorted_containers) return results def parse_input(input_data): lines = input_data.strip().split(\\"n\\") num_test_cases = int(lines[0]) index = 1 test_cases = [] for _ in range(num_test_cases): num_containers = int(lines[index]) containers = [] for j in range(index + 1, index + 1 + num_containers): weight, color = lines[j].split() containers.append((int(weight), color)) test_cases.append(containers) index += num_containers + 1 return test_cases def format_output(sorted_containers): output = [] for containers in sorted_containers: for container in containers: output.append(f\\"{container[0]} {container[1]}\\") return \\"n\\".join(output)"},{"question":"from collections import deque, defaultdict def max_operational_duration(n: int, machine_data: List[List[int]]) -> int: This function computes the maximum duration the factory can remain operational by analyzing the active and inactive periods of interconnected machines. :param n: The number of machines :param machine_data: A list of lists, where each list represents a machine. The first element is the machine ID, the second is the number of outgoing connections, the third is the active period, and subsequent elements are the connected machine IDs. :returns: The maximum duration (in seconds) the factory can remain operational Example: >>> max_operational_duration(3, [ ... [1, 2, 3, 2, 3], ... [2, 2, 5, 3, 4], ... [3, 0, 4] ... ]) 5 >>> max_operational_duration(4, [ ... [1, 1, 10, 2], ... [2, 1, 15, 3], ... [3, 1, 20, 4], ... [4, 1, 25, 5] ... ]) 25 >>> max_operational_duration(1, [ ... [1, 0, 7] ... ]) 7 def test_max_operational_duration(): assert max_operational_duration(3, [ [1, 2, 3, 2, 3], [2, 2, 5, 3, 4], [3, 0, 4] ]) == 5 assert max_operational_duration(4, [ [1, 1, 10, 2], [2, 1, 15, 3], [3, 1, 20, 4], [4, 1, 25, 5] ]) == 25 assert max_operational_duration(1, [ [1, 0, 7] ]) == 7 assert max_operational_duration(2, [ [1, 1, 9, 2], [2, 0, 8] ]) == 9 assert max_operational_duration(3, [ [1, 0, 5], [2, 0, 6], [3, 1, 7, 1] ]) == 7 def test_edge_cases(): assert max_operational_duration(2, [ [1, 1, 3, 2], [2, 0, 5] ]) == 5 assert max_operational_duration(3, [ [1, 1, 8, 2], [2, 1, 6, 3], [3, 0, 4] ]) == 8 assert max_operational_duration(3, [ [1, 1, 8, 2], [2, 1, 10, 3], [3, 0, 5] ]) == 10","solution":"from collections import deque, defaultdict def max_operational_duration(n, machine_data): # Create a dictionary to store the machine information machines = {} graph = defaultdict(list) for machine_info in machine_data: machine_id = machine_info[0] outgoing_count = machine_info[1] active_period = machine_info[2] machines[machine_id] = active_period for i in range(outgoing_count): connection = machine_info[3 + i] graph[machine_id].append(connection) # Calculate the operational duration for each machine def bfs(start): max_time = 0 queue = deque([(start, machines[start])]) visited = set() while queue: machine, time_remaining = queue.popleft() visited.add(machine) max_time = max(max_time, time_remaining) for neighbor in graph[machine]: if neighbor not in visited: queue.append((neighbor, time_remaining)) return max_time # Find the maximum operational duration from any starting machine max_duration = 0 for machine in range(1, n + 1): max_duration = max(max_duration, bfs(machine)) return max_duration # The below implementation reads from the stdin and organizes it for the function def main(): import sys input = sys.stdin.read data = input().split() n = int(data[0]) pointer = 1 machine_data = [] while pointer < len(data): machine_id = int(data[pointer]) outgoing_count = int(data[pointer + 1]) active_period = int(data[pointer + 2]) connections = [int(data[pointer + 3 + i]) for i in range(outgoing_count)] machine_data.append([machine_id, outgoing_count, active_period] + connections) pointer += 3 + outgoing_count print(max_operational_duration(n, machine_data))"},{"question":"def is_balanced(string: str) -> str: Determines if a string with parentheses and brackets is balanced. Parameters: string (str): The input string containing parentheses and brackets. Returns: str: 'YES' if the string is balanced, 'NO' otherwise. >>> is_balanced(\\"(){}[]\\") 'YES' >>> is_balanced(\\"({[}])\\") 'NO' >>> is_balanced(\\"({[]})\\") 'YES' >>> is_balanced(\\"([(])\\") 'NO' >>> is_balanced(\\"{[()]}\\") 'YES' def check_balanced_strings(n: int, strings: List[str]) -> List[str]: Checks multiple strings to determine if each is balanced. Parameters: n (int): The number of input strings. strings (list of str): List of strings to check. Returns: List[str]: List of results with 'YES' or 'NO' for each input string. >>> check_balanced_strings(5, [\\"(){}[]\\", \\"({[]})\\", \\"({[}])\\", \\"[(])\\", \\"{[()]}\\"]) ['YES', 'YES', 'NO', 'NO', 'YES']","solution":"def is_balanced(string): Determines if a string with parentheses and brackets is balanced. Parameters: string (str): The input string containing parentheses and brackets. Returns: str: 'YES' if the string is balanced, 'NO' otherwise. stack = [] matching_brackets = {')': '(', '}': '{', ']': '['} for char in string: if char in matching_brackets.values(): stack.append(char) elif char in matching_brackets: if not stack or stack.pop() != matching_brackets[char]: return 'NO' return 'YES' if not stack else 'NO' def check_balanced_strings(n, strings): Checks multiple strings to determine if each is balanced. Parameters: n (int): The number of input strings. strings (list of str): List of strings to check. Returns: List[str]: List of results with 'YES' or 'NO' for each input string. results = [] for string in strings: results.append(is_balanced(string)) return results"},{"question":"import heapq from collections import defaultdict from typing import List, Tuple def minimum_maximum_danger(n: int, m: int, d: int, coordinates: List[Tuple[int, int]], paths: List[Tuple[int, int, int]]) -> int: Determine the minimum possible value for the maximum danger level Fedor has to face to reach his destination island. Parameters: n (int): Number of islands. m (int): Number of pathways. d (int): Destination island's index. coordinates (List[Tuple[int, int]]): Coordinates of the islands. paths (List[Tuple[int, int, int]]): Indices of two islands and the danger level of the pathway between them. Returns: int: Minimum possible value of the maximum danger level or -1 if the destination is not reachable. >>> minimum_maximum_danger(4, 4, 4, [(0, 0), (2, 1), (3, 4), (6, 5)], [(1, 2, 3), (2, 3, 2), (3, 4, 4), (1, 3, 6)]) 4 >>> minimum_maximum_danger(3, 2, 3, [(1, 2), (4, 6), (7, 8)], [(1, 2, 5), (2, 3, 10)]) 10 >>> minimum_maximum_danger(3, 1, 3, [(0, 1), (2, 5), (4, 8)], [(1, 2, 7)]) -1","solution":"import heapq from collections import defaultdict def minimum_maximum_danger(n, m, d, coordinates, paths): # Building the graph adjacency list graph = defaultdict(list) for u, v, w in paths: graph[u - 1].append((w, v - 1)) graph[v - 1].append((w, u - 1)) # Using a priority queue for modified Dijkstra's algorithm heap = [(0, 0)] # (maximum danger level, current island) max_danger = [float('inf')] * n max_danger[0] = 0 while heap: current_max_danger, u = heapq.heappop(heap) if u == d - 1: return current_max_danger for w, v in graph[u]: new_max_danger = max(current_max_danger, w) if new_max_danger < max_danger[v]: max_danger[v] = new_max_danger heapq.heappush(heap, (new_max_danger, v)) return -1 if max_danger[d - 1] == float('inf') else max_danger[d - 1]"},{"question":"def minimize_skill_difference(n: int, skill_levels: List[int]) -> int: Returns the minimum absolute difference between the sum of skill levels of two teams. >>> minimize_skill_difference(4, [1, 6, 11, 5]) 1 >>> minimize_skill_difference(1, [10]) 10 >>> minimize_skill_difference(2, [10, 10]) 0 >>> minimize_skill_difference(3, [1, 2, 3]) 0 >>> minimize_skill_difference(4, [5, 5, 5, 5]) 0 >>> minimize_skill_difference(5, [1, 1, 4, 3, 2]) 1 >>> minimize_skill_difference(6, [13, 11, 20, 8, 9, 1]) 0","solution":"def minimize_skill_difference(n, skill_levels): Returns the minimum absolute difference between the sum of skill levels of two teams. total_sum = sum(skill_levels) dp = [False] * (total_sum // 2 + 1) dp[0] = True for skill in skill_levels: for j in range(total_sum // 2, skill - 1, -1): dp[j] = dp[j] or dp[j - skill] for i in range(total_sum // 2, -1, -1): if dp[i]: sum1 = i break sum2 = total_sum - sum1 return abs(sum2 - sum1)"},{"question":"from typing import List def solve(input_data: str) -> List[str]: Determines if it is possible to rearrange the given string such that no two adjacent characters are the same. :param input_data: A string containing the number of test cases, followed by the test case strings. :returns: A list of results for each test case, each result being either \\"YES <rearranged_string>\\" or \\"NO\\". >>> solve(\\"3naabnaaabnaabb\\") [\\"YES aba\\", \\"NO\\", \\"YES abab\\"] >>> solve(\\"1na\\") [\\"YES a\\"] >>> solve(\\"1nabababab\\") [\\"YES abababab\\"] >>> solve(\\"1naaa\\") [\\"NO\\"] >>> solve(\\"1naabbcc\\") [\\"YES abcabc\\"] >>> solve(\\"1n\\" + \\"a\\" * 50000 + \\"b\\" * 50000) [\\"YES \\" + (\\"ab\\" * 50000)]","solution":"from collections import Counter import heapq def can_rearrange_string(s): Determines if it is possible to rearrange the string such that no two adjacent characters are the same. freq = Counter(s) max_heap = [(-count, char) for char, count in freq.items()] heapq.heapify(max_heap) prev_count, prev_char = 0, '' result = [] while max_heap: count, char = heapq.heappop(max_heap) result.append(char) if prev_count < 0: heapq.heappush(max_heap, (prev_count, prev_char)) prev_count, prev_char = count + 1, char rearranged_string = ''.join(result) if len(rearranged_string) == len(s): return \\"YES\\", rearranged_string else: return \\"NO\\" def solve(input_data): data = input_data.strip().split('n') T = int(data[0]) results = [] for i in range(1, T + 1): s = data[i] result = can_rearrange_string(s) if result[0] == \\"YES\\": results.append(f\\"YES {result[1]}\\") else: results.append(\\"NO\\") return results"},{"question":"def merge_sorted_arrays(n: int, arr1: List[int], m: int, arr2: List[int]) -> List[int]: Merges two sorted arrays into a single sorted array. Args: n (int): Number of elements in the first array. arr1 (List[int]): The first sorted array. m (int): Number of elements in the second array. arr2 (List[int]): The second sorted array. Returns: List[int]: A new sorted array that is the result of merging the two input arrays. Example: >>> merge_sorted_arrays(3, [1, 3, 5], 3, [2, 4, 6]) [1, 2, 3, 4, 5, 6] >>> merge_sorted_arrays(4, [-5, 0, 5, 10], 5, [-6, -3, 0, 3, 9]) [-6, -5, -3, 0, 0, 3, 5, 9, 10] def process_input(input_data: str) -> Tuple[int, List[Tuple[int, List[int], int, List[int]]]]: Processes the input data to extract the number of test cases and the respective arrays. Args: input_data (str): The input data as a single string. Returns: Tuple[int, List[Tuple[int, List[int], int, List[int]]]]: Number of test cases and a list of tuples with arrays' details. Example: >>> process_input(\\"2n3n1 3 5n3n2 4 6n4n-5 0 5 10n5n-6 -3 0 3 9n\\") (2, [ (3, [1, 3, 5], 3, [2, 4, 6]), (4, [-5, 0, 5, 10], 5, [-6, -3, 0, 3, 9]) ]) def format_output(output: List[List[int]]) -> str: Formats the output list of lists to a string suitable for printing. Args: output (List[List[int]]): The output as a list of lists with merged arrays. Returns: str: A string representation of the merged arrays with each element separated by a space. Example: >>> format_output([[1, 2, 3, 4, 5, 6], [-6, -5, -3, 0, 0, 3, 5, 9, 10]]) \\"1 2 3 4 5 6n-6 -5 -3 0 0 3 5 9 10\\" import pytest from typing import List, Tuple def test_process_input(): input_data = \\"2n3n1 3 5n3n2 4 6n4n-5 0 5 10n5n-6 -3 0 3 9n\\" t, test_cases = process_input(input_data) expected_test_cases = [ (3, [1, 3, 5], 3, [2, 4, 6]), (4, [-5, 0, 5, 10], 5, [-6, -3, 0, 3, 9]) ] assert t == 2 assert test_cases == expected_test_cases def test_merge_sorted_arrays(): test_cases = [ (3, [1, 3, 5], 3, [2, 4, 6]), (4, [-5, 0, 5, 10], 5, [-6, -3, 0, 3, 9]) ] for case in test_cases: n, arr1, m, arr2 = case result = merge_sorted_arrays(n, arr1, m, arr2) expected_result = sorted(arr1 + arr2) assert result == expected_result def test_format_output(): input_list = [ [1, 2, 3, 4, 5, 6], [-6, -5, -3, 0, 0, 3, 5, 9, 10] ] formatted_output = format_output(input_list) expected_output = \\"1 2 3 4 5 6n-6 -5 -3 0 0 3 5 9 10\\" assert formatted_output == expected_output def test_integration(): input_data = \\"2n3n1 3 5n3n2 4 6n4n-5 0 5 10n5n-6 -3 0 3 9n\\" t, test_cases = process_input(input_data) final_output = format_output([merge_sorted_arrays(n, arr1, m, arr2) for n, arr1, m, arr2 in test_cases]) expected_output = \\"1 2 3 4 5 6n-6 -5 -3 0 0 3 5 9 10\\" assert final_output == expected_output if __name__ == \\"__main__\\": pytest.main()","solution":"def merge_sorted_arrays(t, test_cases): Merges two sorted arrays into a single sorted array for each test case. Args: t (int): Number of test cases. test_cases (list of tuples): Each tuple contains two lists corresponding to the sorted arrays. Returns: list of lists: Each list is the merged and sorted array for the corresponding test case. result = [] for case in test_cases: n, arr1, m, arr2 = case merged_arr = [] i = j = 0 # Merge arrays while i < n and j < m: if arr1[i] < arr2[j]: merged_arr.append(arr1[i]) i += 1 else: merged_arr.append(arr2[j]) j += 1 # Add remaining elements while i < n: merged_arr.append(arr1[i]) i += 1 while j < m: merged_arr.append(arr2[j]) j += 1 result.append(merged_arr) return result # Function to convert input format to the required args def process_input(input_data): lines = input_data.strip().split('n') t = int(lines[0]) test_cases = [] index = 1 for _ in range(t): n = int(lines[index]) arr1 = list(map(int, lines[index + 1].split())) m = int(lines[index + 2]) arr2 = list(map(int, lines[index + 3].split())) test_cases.append((n, arr1, m, arr2)) index += 4 return t, test_cases # Function to format output def format_output(output): return 'n'.join(' '.join(map(str, arr)) for arr in output)"},{"question":"def billiards(L, W, N, balls): Simulate a simplified game of billiards on a rectangular table. Args: L (int): the length of the table. W (int): the width of the table. N (int): number of balls on the table. balls (list): initial positions and directions of balls in the form (x, y, D). Returns: list: final positions of all balls. >>> billiards(10, 10, 1, [(5, 5, 'N')]) [(5, 10)] >>> billiards(10, 10, 3, [(2, 2, 'S'), (3, 5, 'E'), (7, 1, 'N')]) [(2, 0), (10, 5), (7, 10)] pass def process_input(input_data): Process multiple test cases from a multi-line string input. Args: input_data (str): multi-line string with table dimensions, ball positions, and directions. Returns: list: results of billiard simulations for each test case. >>> input_data = \\"10 10n3n2 2 Sn3 5 En7 1 Nnn5 5n2n1 1 En4 4 Wnn0 0n\\" >>> process_input(input_data) [[(2, 0), (10, 5), (7, 10)], [(5, 1), (0, 4)]] pass def format_output(results): Format simulation results into a string output. Args: results (list): results of billiard simulations for each test case. Returns: str: formatted string output of the final positions. >>> results = [[(2, 0), (10, 5), (7, 10)], [(5, 1), (0, 4)]] >>> format_output(results) '2 0n10 5n7 10nn5 1n0 4n' pass","solution":"def billiards(L, W, N, balls): # Auxiliary function to simulate the balls' movements def simulate_ball(x, y, D): if D == 'N': new_y = W return (x, new_y) elif D == 'S': new_y = 0 return (x, new_y) elif D == 'E': new_x = L return (new_x, y) elif D == 'W': new_x = 0 return (new_x, y) final_positions = [] for ball in balls: x, y, D = ball final_position = simulate_ball(x, y, D) final_positions.append(final_position) return final_positions # Function to process multiple test cases def process_input(input_data): input_lines = input_data.strip().split(\\"n\\") index = 0 results = [] while index < len(input_lines): L, W = map(int, input_lines[index].split()) if L == 0 and W == 0: break index += 1 N = int(input_lines[index]) index += 1 balls = [] for _ in range(N): x, y, D = input_lines[index].split() balls.append((int(x), int(y), D)) index += 1 results.append(billiards(L, W, N, balls)) # Skip the blank line between test cases index += 1 return results def format_output(results): output_lines = [] for result in results: for final_position in result: output_lines.append(f\\"{final_position[0]} {final_position[1]}\\") output_lines.append(\\"\\") # Blank line between test cases return \\"n\\".join(output_lines).strip()"},{"question":"def generate_fibonacci(n: int) -> List[int]: Generates the first n Fibonacci numbers and returns them as a list. :param n: Number of Fibonacci numbers to generate :return: List of first n Fibonacci numbers >>> generate_fibonacci(1) == [0] >>> generate_fibonacci(5) == [0, 1, 1, 2, 3] >>> generate_fibonacci(10) == [0, 1, 1, 2, 3, 5, 8, 13, 21, 34] >>> generate_fibonacci(0) == [] >>> generate_fibonacci(30) == [ ... 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, ... 987, 1597, 2584, 4181, 6765, 10946, 17711, 28657, 46368, ... 75025, 121393, 196418, 317811, 514229 ... ] pass","solution":"def generate_fibonacci(n): Generates the first n Fibonacci numbers and returns them as a list. :param n: Number of Fibonacci numbers to generate :return: List of first n Fibonacci numbers if n < 1: return [] fibonacci_sequence = [] a, b = 0, 1 for i in range(n): fibonacci_sequence.append(a) a, b = b, a + b return fibonacci_sequence"},{"question":"def zigzag(arr): Reorders the elements of the array to achieve a zigzag pattern. >>> zigzag([4, 3, 7, 8, 6, 2, 1]) [3, 7, 4, 8, 2, 6, 1] >>> zigzag([1, 4, 3, 2, 9]) [1, 4, 2, 9, 3] pass","solution":"def zigzag(arr): Reorders the elements of the array to achieve a zigzag pattern. n = len(arr) # Traverse all even positioned elements for i in range(n-1): if i % 2 == 0: if arr[i] > arr[i+1]: arr[i], arr[i+1] = arr[i+1], arr[i] else: if arr[i] < arr[i+1]: arr[i], arr[i+1] = arr[i+1], arr[i] return arr"},{"question":"import re from collections import defaultdict def is_chemical_equation_balanced(equation: str): Determine if a given chemical equation is balanced. The equation is considered balanced if for each element the total number of atoms on the reactant side is equal to the total number of atoms on the product side. Args: equation (str): A string representing the chemical equation. The string is properly formatted, containing valid chemical symbols, digits, spaces, and symbols '+', '->'. Example: >>> is_chemical_equation_balanced('H2 + O2 -> H2O') # Expected to print \\"Balanced\\" >>> is_chemical_equation_balanced('C2H6 + O2 -> CO2 + H2O') # Expected to print \\"Unbalanced\\"","solution":"import re from collections import defaultdict def parse_chemical_formula(formula: str): Parse a chemical formula into a dictionary of elements and their counts. Args: formula (str): A string representing the chemical formula. Returns: dict: A dictionary with elements as keys and their counts as values. element_counts = defaultdict(int) pattern = re.compile(r'([A-Z][a-z]*)(d*)') matches = pattern.findall(formula) for element, count in matches: count = int(count) if count else 1 element_counts[element] += count return element_counts def parse_equation(equation: str): Parse the entire chemical equation and check for balance. Args: equation (str): A string representing the chemical equation. Returns: bool: True if the equation is balanced, False otherwise. reactants, products = equation.split('->') def sum_elements_part(part): total_counts = defaultdict(int) for molecule in part.split('+'): molecule = molecule.strip() molecule_counts = parse_chemical_formula(molecule) for element, count in molecule_counts.items(): total_counts[element] += count return total_counts reactant_totals = sum_elements_part(reactants) product_totals = sum_elements_part(products) return reactant_totals == product_totals def is_chemical_equation_balanced(equation: str): balance = parse_equation(equation) if balance: print(\\"Balanced\\") else: print(\\"Unbalanced\\")"},{"question":"def max_sum_of_k_consecutive_elements(n: int, k: int, array: List[int]) -> int: Returns the maximum sum of k consecutive elements in the array. If k is greater than the length of the array, returns 0. >>> max_sum_of_k_consecutive_elements(5, 3, [1, 2, 3, 4, 5]) 12 >>> max_sum_of_k_consecutive_elements(3, 5, [1, 2, 3]) 0 >>> max_sum_of_k_consecutive_elements(1, 1, [5]) 5 >>> max_sum_of_k_consecutive_elements(5, 3, [-1, -2, -3, -4, -5]) -6 >>> max_sum_of_k_consecutive_elements(5, 2, [1, -2, 3, -4, 5]) 1 >>> max_sum_of_k_consecutive_elements(7, 3, [1, -2, 3, -4, 5, -6, 7]) 6 >>> max_sum_of_k_consecutive_elements(6, 6, [1, 2, 3, 4, 5, 6]) 21 pass","solution":"def max_sum_of_k_consecutive_elements(n, k, array): Returns the maximum sum of k consecutive elements in the array. If k is greater than the length of the array, returns 0. if k > n: return 0 # Initialize the max_sum with the sum of first k elements max_sum = sum(array[:k]) current_sum = max_sum # Use sliding window to find maximum sum of k consecutive elements for i in range(n - k): current_sum = current_sum - array[i] + array[i + k] if current_sum > max_sum: max_sum = current_sum return max_sum"},{"question":"class InMemoryKVStore: Implement an in-memory key-value store that supports transactions. The following commands should be supported: - SET [key] [value]: Sets the specified key to the provided value. - GET [key]: Returns the value of the specified key. If the key does not exist, output 'NULL'. - DELETE [key]: Deletes the specified key, returning the value that was deleted or 'NULL' if the key did not exist. - BEGIN: Starts a new transaction. - COMMIT: Commits all operations performed in the current transaction. If no transaction is active, output 'NO TRANSACTION'. - ROLLBACK: Reverts all operations performed in the current transaction. If no transaction is active, output 'NO TRANSACTION'. Multiple transactions can be nested. Committing a transaction should persist all the changes made in all nested transactions that were started after this transaction. Rolling back a transaction should revert all the changes made in all nested transactions that were started after this transaction. Example: >>> store = InMemoryKVStore() >>> store.set(\\"a\\", 10) >>> store.get(\\"a\\") 10 >>> store.begin() >>> store.set(\\"a\\", 20) >>> store.get(\\"a\\") 20 >>> store.rollback() 'NO TRANSACTION' >>> store.get(\\"a\\") 10 >>> store.begin() >>> store.set(\\"a\\", 30) >>> store.commit() 'NO TRANSACTION' >>> store.get(\\"a\\") 30 >>> store.delete(\\"a\\") 30 >>> store.get(\\"a\\") 'NULL' >>> store.commit() 'NO TRANSACTION' >>> store.rollback() 'NO TRANSACTION' def __init__(self): self.store = {} self.transactions = [] def set(self, key, value): ... def get(self, key): ... def delete(self, key): ... def begin(self): ... def commit(self): ... def rollback(self): ...","solution":"class InMemoryKVStore: def __init__(self): self.store = {} self.transactions = [] def set(self, key, value): if self.transactions: self.transactions[-1][key] = value else: self.store[key] = value def get(self, key): for transaction in reversed(self.transactions): if key in transaction: return transaction[key] return self.store.get(key, \\"NULL\\") def delete(self, key): if self.transactions: if key in self.transactions[-1]: return self.transactions[-1].pop(key) return self.transactions[-1].pop(key, \\"NULL\\") return self.store.pop(key, \\"NULL\\") def begin(self): self.transactions.append({}) def commit(self): if not self.transactions: return \\"NO TRANSACTION\\" while self.transactions: transaction = self.transactions.pop(0) self.store.update(transaction) def rollback(self): if not self.transactions: return \\"NO TRANSACTION\\" self.transactions.pop()"},{"question":"class ArrayManager: def __init__(self, arr): self.arr = arr def update(self, idx, new_value): Update the value at index \`idx\` to \`new_value\`. pass def range_sum(self, l, r): Calculate sum of the elements in the array from index \`l\` to \`r\` (inclusive). Returns: int: The sum of the elements from index \`l\` to \`r\`. pass def process_operations(n, q, initial_array, operations): Processes a list of operations on the initial array. Args: n (int): Number of elements in the array. q (int): Number of operations to be performed. initial_array (List[int]): The initial state of the array. operations (List[List[int]]): List of operations to be performed. Returns: List[int]: The result of each sum query operation. Example: >>> process_operations(5, 5, [1, 2, 3, 4, 5], [ ... [2, 0, 2], ... [1, 1, 10], ... [2, 0, 2], ... [2, 1, 3], ... [1, 3, 7] ... ]) == [6, 14, 17] pass # Unit tests def test_example(): assert process_operations(5, 5, [1, 2, 3, 4, 5], [ [2, 0, 2], [1, 1, 10], [2, 0, 2], [2, 1, 3], [1, 3, 7] ]) == [6, 14, 17] def test_empty_operations(): assert process_operations(3, 0, [1, 1, 1], []) == [] def test_all_updates(): assert process_operations(4, 4, [1, 2, 3, 4], [ [1, 0, 5], [1, 1, 6], [1, 2, 7], [1, 3, 8], ]) == [] def test_all_range_queries(): assert process_operations(5, 3, [10, 20, 30, 40, 50], [ [2, 0, 4], [2, 1, 3], [2, 2, 2], ]) == [150, 90, 30] def test_mix_operations(): assert process_operations(6, 6, [1, 2, 3, 4, 5, 6], [ [2, 0, 5], [1, 2, 8], [2, 2, 4], [1, 5, 7], [2, 1, 3], [2, 0, 0], ]) == [21, 17, 14, 1]","solution":"class ArrayManager: def __init__(self, arr): self.arr = arr self.n = len(arr) self.tree = [0] * (self.n + 1) self.build() def build(self): for i in range(self.n): self._update(i, self.arr[i]) def _update(self, idx, delta): i = idx + 1 while i <= self.n: self.tree[i] += delta i += i & -i def update(self, idx, new_value): delta = new_value - self.arr[idx] self.arr[idx] = new_value self._update(idx, delta) def prefix_sum(self, idx): sum_ = 0 i = idx + 1 while i > 0: sum_ += self.tree[i] i -= i & -i return sum_ def range_sum(self, l, r): return self.prefix_sum(r) - self.prefix_sum(l - 1) def process_operations(n, q, initial_array, operations): array_manager = ArrayManager(initial_array) result = [] for op in operations: if op[0] == 1: idx, new_value = op[1], op[2] array_manager.update(idx, new_value) elif op[0] == 2: l, r = op[1], op[2] result.append(array_manager.range_sum(l, r)) return result"},{"question":"def top_n_finalists(M: int, N: int, contestants: List[Tuple[int, int]]) -> List[int]: Returns the IDs of the top N finalists based on their scores. If scores are the same, IDs are sorted in ascending order. Args: M (int): Total number of contestants. N (int): Number of finalists to be selected. contestants (list of tuples): List of (ID, score) tuples. Returns: list: List of IDs of top N finalists in descending order of their scores. from solution import top_n_finalists def test_top_n_finalists_with_same_score(): M = 6 N = 4 contestants = [ (203, 75), (201, 85), (202, 85), (200, 90), (204, 75), (205, 95) ] expected = [205, 200, 201, 202] assert top_n_finalists(M, N, contestants) == expected def test_top_n_finalists_with_unique_scores(): M = 5 N = 3 contestants = [ (105, 95), (102, 88), (101, 97), (103, 97), (104, 80) ] expected = [101, 103, 105] assert top_n_finalists(M, N, contestants) == expected def test_top_n_finalists_small_input(): M = 1 N = 1 contestants = [ (100, 50) ] expected = [100] assert top_n_finalists(M, N, contestants) == expected def test_top_n_finalists_all_same_scores(): M = 4 N = 2 contestants = [ (1, 50), (2, 50), (3, 50), (4, 50) ] expected = [1, 2] assert top_n_finalists(M, N, contestants) == expected def test_top_n_finalists_complex_case(): M = 7 N = 5 contestants = [ (105, 55), (110, 75), (115, 75), (120, 95), (125, 100), (130, 75), (135, 85) ] expected = [125, 120, 135, 110, 115] assert top_n_finalists(M, N, contestants) == expected","solution":"def top_n_finalists(M, N, contestants): Returns the IDs of the top N finalists based on their scores. If scores are the same, IDs are sorted in ascending order. Args: M (int): Total number of contestants. N (int): Number of finalists to be selected. contestants (list of tuples): List of (ID, score) tuples. Returns: list: List of IDs of top N finalists in descending order of their scores. # Sort the contestants - first by score in descending order, then by ID in ascending order sorted_contestants = sorted(contestants, key=lambda x: (-x[1], x[0])) # Select the top N finalists' IDs top_finalists = [sorted_contestants[i][0] for i in range(N)] return top_finalists"},{"question":"class BackwardStack: A stack that supports push, pop, and shift operations. Methods: - def __init__(self) -> None - def push(self, x: int) -> None - def pop(self) -> int - def shift(self, k: int) -> None >>> bs = BackwardStack() >>> bs.push(1) >>> bs.push(2) >>> bs.push(3) >>> bs.shift(2) >>> print(bs.pop()) 2 >>> bs.push(4) >>> print(bs.pop()) 4 >>> bs.shift(1) >>> print(bs.pop()) 3 >>> print(bs.pop()) 1 >>> print(bs.pop()) -1 def __init__(self): Initializes the backward stack. pass def push(self, x: int) -> None: Pushes the element x on top of the stack. pass def pop(self) -> int: Removes and returns the element on top of the stack. If the stack is empty, return -1. pass def shift(self, k: int) -> None: Removes the top k elements from the stack and places them at the bottom in the original order. pass def test_backward_stack_operations(): bs = BackwardStack() # Test push operation bs.push(1) bs.push(2) bs.push(3) assert bs.stack == [1, 2, 3] # Test shift operation bs.shift(2) assert bs.stack == [2, 3, 1] # Test pop operation assert bs.pop() == 1 assert bs.stack == [2, 3] bs.push(4) assert bs.stack == [2, 3, 4] assert bs.pop() == 4 assert bs.stack == [2, 3] bs.shift(1) assert bs.stack == [3, 2] assert bs.pop() == 2 assert bs.pop() == 3 assert bs.pop() == -1 def test_backward_stack_empty_pop(): bs = BackwardStack() assert bs.pop() == -1 def test_backward_stack_shift_no_elements(): bs = BackwardStack() # Operation should not change anything, also it should not raise any exception bs.shift(0) bs.shift(1) assert bs.stack == [] def test_backward_stack_shift_all_elements(): bs = BackwardStack() bs.push(1) bs.push(2) bs.push(3) bs.shift(3) assert bs.stack == [1, 2, 3] assert bs.pop() == 3 assert bs.pop() == 2 assert bs.pop() == 1","solution":"class BackwardStack: def __init__(self): Initializes the backward stack. self.stack = [] def push(self, x: int) -> None: Pushes the element x on top of the stack. self.stack.append(x) def pop(self) -> int: Removes and returns the element on top of the stack. If the stack is empty, return -1. if self.stack: return self.stack.pop() else: return -1 def shift(self, k: int) -> None: Removes the top k elements from the stack and places them at the bottom in the original order. if k > 0: # Remove top k elements top_k_elements = self.stack[-k:] self.stack = self.stack[:-k] # Place them at the bottom in the original order self.stack = top_k_elements + self.stack"},{"question":"def min_operations_to_transform_string(s: str) -> int: Determines the minimum number of operations required to transform the string s into a string with no substrings \\"ABA\\" or \\"BAB\\". >>> min_operations_to_transform_string(\\"ABABA\\") 2 >>> min_operations_to_transform_string(\\"BABAB\\") 2 >>> min_operations_to_transform_string(\\"AAABBBAA\\") 0 def process_test_cases(t: int, test_cases: List[str]) -> List[int]: Processes multiple test cases and returns a list of results, each representing the minimum number of operations for a given test case. >>> process_test_cases(3, [\\"ABABA\\", \\"BABAB\\", \\"AAABBBAA\\"]) [2, 2, 0] >>> process_test_cases(2, [\\"A\\", \\"B\\"]) [0, 0] >>> process_test_cases(1, [\\"ABABABAB\\"]) [3] >>> process_test_cases(4, [\\"ABC\\", \\"AAA\\", \\"BAB\\", \\"ABA\\"]) [0, 0, 1, 1] from solution import min_operations_to_transform_string, process_test_cases def test_min_operations_to_transform_string(): assert min_operations_to_transform_string(\\"ABABA\\") == 2 assert min_operations_to_transform_string(\\"BABAB\\") == 2 assert min_operations_to_transform_string(\\"AAABBBAA\\") == 0 assert min_operations_to_transform_string(\\"ABABABAB\\") == 3 assert min_operations_to_transform_string(\\"BABA\\") == 1 assert min_operations_to_transform_string(\\"AAAA\\") == 0 assert min_operations_to_transform_string(\\"BBB\\") == 0 def test_process_test_cases(): assert process_test_cases(3, [\\"ABABA\\", \\"BABAB\\", \\"AAABBBAA\\"]) == [2, 2, 0] assert process_test_cases(2, [\\"A\\", \\"B\\"]) == [0, 0] assert process_test_cases(1, [\\"ABABABAB\\"]) == [3] assert process_test_cases(4, [\\"ABC\\", \\"AAA\\", \\"BAB\\", \\"ABA\\"]) == [0, 0, 1, 1]","solution":"def min_operations_to_transform_string(s): Determines the minimum number of operations required to transform the string s into a string with no substrings \\"ABA\\" or \\"BAB\\". count = 0 i = 0 while i < len(s) - 2: if s[i:i+3] == 'ABA' or s[i:i+3] == 'BAB': count += 1 i += 2 else: i += 1 return count def process_test_cases(t, test_cases): results = [] for s in test_cases: results.append(min_operations_to_transform_string(s)) return results"},{"question":"from typing import List, Tuple def shortest_path(M: int, N: int, startX: int, startY: int, endX: int, endY: int, grid: List[str]) -> int: Determine the length of the shortest path from a start cell to a destination cell in a grid. Args: M : int : Number of rows in the city grid. N : int : Number of columns in the city grid. startX : int : Starting cell row index. startY : int : Starting cell column index. endX : int : Destination cell row index. endY : int : Destination cell column index. grid : List[str] : Grid representing the city with '.' for empty spaces and '#' for obstacles. Returns: int : The length of the shortest path from start to destination, or -1 if no path exists. >>> shortest_path(5, 5, 0, 0, 4, 4, [\\".....\\", \\".#.#.\\", \\".#.#.\\", \\".....\\", \\".....\\"]) 8 >>> shortest_path(3, 3, 0, 0, 2, 2, [\\"#\\", \\"#..\\", \\"#..\\"]) -1 def parse_input(input_str: str) -> Tuple[int, int, int, int, int, int, List[str]]: Parse the input string into the grid dimensions, start and end coordinates, and grid. Args: input_str : str : String representation of the input. Returns: Tuple[int, int, int, int, int, int, List[str]] : Parsed input values. >>> parse_input(\\"5 5n0 0 4 4n.....n.#.#.n.#.#.n.....n.....\\") (5, 5, 0, 0, 4, 4, [\\".....\\", \\".#.#.\\", \\".#.#.\\", \\".....\\", \\".....\\"]) import pytest from solution import shortest_path, parse_input def test_case_1(): input_str = 5 5 0 0 4 4 ..... .#.#. .#.#. ..... ..... M, N, startX, startY, endX, endY, grid = parse_input(input_str) assert shortest_path(M, N, startX, startY, endX, endY, grid) == 8 def test_case_2(): input_str = 3 3 0 0 2 2 # #.. #.. M, N, startX, startY, endX, endY, grid = parse_input(input_str) assert shortest_path(M, N, startX, startY, endX, endY, grid) == -1 def test_case_3(): input_str = 3 3 0 0 2 2 ... .#. ... M, N, startX, startY, endX, endY, grid = parse_input(input_str) assert shortest_path(M, N, startX, startY, endX, endY, grid) == 4 def test_case_4(): input_str = 1 1 0 0 0 0 . M, N, startX, startY, endX, endY, grid = parse_input(input_str) assert shortest_path(M, N, startX, startY, endX, endY, grid) == 0 def test_case_5(): input_str = 4 4 0 0 3 3 .... ..#. .#.. .... M, N, startX, startY, endX, endY, grid = parse_input(input_str) assert shortest_path(M, N, startX, startY, endX, endY, grid) == 6 if __name__ == \\"__main__\\": pytest.main()","solution":"from collections import deque def shortest_path(M, N, startX, startY, endX, endY, grid): def is_valid(x, y): return 0 <= x < M and 0 <= y < N and grid[x][y] == '.' directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([(startX, startY, 0)]) visited = set((startX, startY)) while queue: x, y, dist = queue.popleft() if (x, y) == (endX, endY): return dist for dx, dy in directions: nx, ny = x + dx, y + dy if is_valid(nx, ny) and (nx, ny) not in visited: queue.append((nx, ny, dist + 1)) visited.add((nx, ny)) return -1 def parse_input(input_str): lines = input_str.strip().split('n') M, N = map(int, lines[0].split()) startX, startY, endX, endY = map(int, lines[1].split()) grid = lines[2:] return M, N, startX, startY, endX, endY, grid"},{"question":"def maximize_subsequence_product(sequence: List[int], queries: List[Tuple[int, int]]) -> List[int]: Given a sequence of integers and multiple queries, calculate the maximum product of subsequences for each query range. Args: sequence (List[int]): The sequence of integers. queries (List[Tuple[int, int]]): Each tuple represents a query with start (l) and end (r) indices. Returns: List[int]: The list of results for each query. Examples: >>> maximize_subsequence_product([2, 3, 1, 4], [(1, 4), (2, 3), (1, 3)]) [24, 3, 6] >>> maximize_subsequence_product([1, 5, 2, 4, 3], [(1, 5), (2, 4)]) [120, 40] from typing import List, Tuple import pytest def test_maximize_subsequence_product_single_query(): sequence = [1, 5, 2, 4, 3] queries = [(1, 5)] assert maximize_subsequence_product(sequence, queries) == [120] def test_maximize_subsequence_product_multiple_queries(): sequence = [2, 3, 1, 4] queries = [(1, 4), (2, 3), (1, 3)] assert maximize_subsequence_product(sequence, queries) == [24, 3, 6] def test_maximize_subsequence_product_with_same_start_end(): sequence = [1, 5, 2] queries = [(1, 1), (2, 2), (3, 3)] assert maximize_subsequence_product(sequence, queries) == [1, 5, 2] def test_maximize_subsequence_product_entire_sequence(): sequence = [1, 2, 3, 4] queries = [(1, 4)] assert maximize_subsequence_product(sequence, queries) == [24] def test_maximize_subsequence_product_edge_case(): sequence = [10] * 100000 # All elements are the same queries = [(1, 100000)] assert maximize_subsequence_product(sequence, queries) == [10 ** 100000] if __name__ == \\"__main__\\": pytest.main([__file__])","solution":"def maximize_subsequence_product(sequence, queries): # Function to calculate the product of a subsequence def product(subsequence): result = 1 for num in subsequence: result *= num return result results = [] for l, r in queries: subsequence = sequence[l-1:r] results.append(product(subsequence)) return results"},{"question":"def find_path(grid): Determine if there is a path from the top-left corner to the bottom-right corner of a grid. The grid is represented by a 2D list of integers where 0 represents an empty cell and 1 represents an obstacle. The function returns a string representing the path as a sequence of 'R' and 'D' moves if a path exists, otherwise '-1'. >>> find_path([[0, 0, 0, 0], [0, 1, 0, 1], [0, 0, 0, 0]]) 'DDRRR' >>> find_path([[0, 0, 1], [0, 1, 0], [1, 0, 0]]) '-1' from find_path import find_path def test_find_path_simple_valid_grid(): grid = [ [0, 0, 0, 0], [0, 1, 0, 1], [0, 0, 0, 0] ] path = find_path(grid) assert path in ['DDRRR', 'DRDRR', 'DRRDD', 'RRDDD'] def test_find_path_no_path_grid(): grid = [ [0, 0, 1], [0, 1, 0], [1, 0, 0] ] assert find_path(grid) == '-1' def test_find_path_single_cell(): grid = [ [0] ] assert find_path(grid) == '' def test_find_path_no_obstacles(): grid = [ [0, 0, 0], [0, 0, 0], [0, 0, 0] ] path = find_path(grid) assert path.count('D') == 2 assert path.count('R') == 2 def test_find_path_obstacle_in_start(): grid = [ [1, 0], [0, 0] ] assert find_path(grid) == '-1' def test_find_path_obstacle_in_end(): grid = [ [0, 0], [0, 1] ] assert find_path(grid) == '-1'","solution":"def find_path(grid): n = len(grid) m = len(grid[0]) path = [] def dfs(x, y): if x == n - 1 and y == m - 1: return True if x + 1 < n and grid[x + 1][y] == 0: path.append('D') if dfs(x + 1, y): return True path.pop() if y + 1 < m and grid[x][y + 1] == 0: path.append('R') if dfs(x, y + 1): return True path.pop() return False if grid[0][0] == 0 and dfs(0, 0): return ''.join(path) else: return '-1'"},{"question":"def process_numbers(N: int, M: int) -> int: Given two integers N and M, return the product of N and M if N is even; otherwise, return the sum of N and M. >>> process_numbers(4, 6) 24 >>> process_numbers(3, 7) 10 >>> process_numbers(5, 2) 7","solution":"def process_numbers(N, M): Given two integers N and M, return the product of N and M if N is even; otherwise, return the sum of N and M. if N % 2 == 0: return N * M else: return N + M"},{"question":"from typing import List, Tuple def validate_event_attendance(records: List[Tuple[int, int]]) -> str: Determine if all users' attendance records respect the chronological order of event IDs. >>> validate_event_attendance([(1, 3), (1, 5), (1, 7)]) \\"VALID\\" >>> validate_event_attendance([(1, 3), (1, 7), (1, 5)]) \\"INVALID\\" >>> validate_event_attendance([(1, 3), (2, 1), (2, 2), (1, 4), (1, 5)]) \\"VALID\\" >>> validate_event_attendance([(1, 3), (2, 2), (2, 1)]) \\"INVALID\\" >>> validate_event_attendance([(1, 1)]) \\"VALID\\" >>> validate_event_attendance([]) \\"VALID\\"","solution":"def validate_event_attendance(records): from collections import defaultdict user_events = defaultdict(list) for u, e in records: user_events[u].append(e) for events in user_events.values(): if events != sorted(events): return \\"INVALID\\" return \\"VALID\\""},{"question":"def count_vps_substrings(n: int, s: str) -> int: Counts the number of valid parentheses substrings in the given string s. Args: n (int): The length of the string s. s (str): The string containing only '(' and ')'. Returns: int: The number of valid parentheses substrings. Examples: >>> count_vps_substrings(6, \\"()()()\\") 6 >>> count_vps_substrings(4, \\"(())\\") 2","solution":"def count_vps_substrings(n, s): Counts the number of valid parentheses substrings in the given string s. Args: n (int): The length of the string s. s (str): The string containing only '(' and ')'. Returns: int: The number of valid parentheses substrings. count = 0 # Iterate start from 0 to n for i in range(n): balance = 0 # Iterate end from i to n for j in range(i, n): if s[j] == '(': balance += 1 elif s[j] == ')': balance -= 1 # Valid parentheses substring if balance is 0 if balance == 0: count += 1 # If balance is negative, no chance for future balancing if balance < 0: break return count"},{"question":"def check_matches(matches): Check if all matches have been reported correctly and consistently. :param matches: List of strings, where each string represents a match result. :return: \\"Valid\\" if all matches are consistent, \\"Invalid\\" otherwise. # Your code here from solution import check_matches def test_valid_cases(): matches = [ \\"alice bob win\\", \\"bob charlie win\\", \\"charlie dave win\\", \\"dave eve win\\", \\"eve frank win\\" ] assert check_matches(matches) == \\"Valid\\" def test_invalid_cases_with_conflict(): matches = [ \\"alice bob win\\", \\"bob alice lose\\" ] assert check_matches(matches) == \\"Invalid\\" def test_invalid_cases_with_asymmetric_conflict(): matches = [ \\"alice bob win\\", \\"bob charlie win\\", \\"charlie alice lose\\", \\"alice dave win\\", \\"dave alice lose\\" ] assert check_matches(matches) == \\"Invalid\\" def test_valid_cases_with_no_conflict(): matches = [ \\"alice bob win\\", \\"charlie dave lose\\" ] assert check_matches(matches) == \\"Valid\\" def test_conflict_case_with_multiple_entries(): matches = [ \\"alice bob win\\", \\"bob charlie win\\", \\"charlie alice lose\\", \\"alice dave win\\", \\"dave alice lose\\", \\"bob alice lose\\" ] assert check_matches(matches) == \\"Invalid\\"","solution":"def check_matches(matches): Check if all matches have been reported correctly and consistently. :param matches: List of strings, where each string represents a match result. :return: \\"Valid\\" if all matches are consistent, \\"Invalid\\" otherwise. results = {} for match in matches: player1, player2, result = match.split() if result == \\"win\\": match_result = (player1, player2) else: match_result = (player2, player1) if match_result in results: if results[match_result] != result: return \\"Invalid\\" else: results[match_result] = result return \\"Valid\\""},{"question":"def can_form_hamiltonian_cycle(n: int, m: int, edge_list: List[str]) -> str: Determine whether it is possible to form a Hamiltonian cycle with the given venues and roads. Args: n (int): The number of venues. m (int): The number of available roads. edge_list (List[str]): The list of roads represented by strings \\"u v\\" where there is a road between venue u and venue v. Returns: str: \\"Yes\\" if it is possible to form a Hamiltonian cycle, otherwise \\"No\\". >>> can_form_hamiltonian_cycle(4, 4, [\\"1 2\\", \\"2 3\\", \\"3 4\\", \\"4 1\\"]) \\"Yes\\" >>> can_form_hamiltonian_cycle(4, 3, [\\"1 2\\", \\"2 3\\", \\"3 1\\"]) \\"No\\" from typing import List def test_example_1(): n = 4 m = 4 edge_list = [\\"1 2\\", \\"2 3\\", \\"3 4\\", \\"4 1\\"] assert can_form_hamiltonian_cycle(n, m, edge_list) == \\"Yes\\" def test_example_2(): n = 4 m = 3 edge_list = [\\"1 2\\", \\"2 3\\", \\"3 1\\"] assert can_form_hamiltonian_cycle(n, m, edge_list) == \\"No\\" def test_single_node(): n = 1 m = 0 edge_list = [] assert can_form_hamiltonian_cycle(n, m, edge_list) == \\"Yes\\" def test_disconnected_graph(): n = 4 m = 2 edge_list = [\\"1 2\\", \\"3 4\\"] assert can_form_hamiltonian_cycle(n, m, edge_list) == \\"No\\" def test_small_complete_graph(): n = 3 m = 3 edge_list = [\\"1 2\\", \\"2 3\\", \\"3 1\\"] assert can_form_hamiltonian_cycle(n, m, edge_list) == \\"Yes\\" def test_large_complete_graph(): n = 4 m = 6 edge_list = [\\"1 2\\", \\"1 3\\", \\"1 4\\", \\"2 3\\", \\"2 4\\", \\"3 4\\"] assert can_form_hamiltonian_cycle(n, m, edge_list) == \\"Yes\\"","solution":"from itertools import permutations def is_hamiltonian_cycle(n, edges): if n <= 1: return True adj_list = {i: set() for i in range(1, n + 1)} for u, v in edges: adj_list[u].add(v) adj_list[v].add(u) for perm in permutations(range(1, n + 1)): valid = True for i in range(n): if perm[i] not in adj_list[perm[i - 1]]: valid = False break if valid and perm[0] in adj_list[perm[-1]]: return True return False def can_form_hamiltonian_cycle(n, m, edge_list): edges = [tuple(map(int, edge.split())) for edge in edge_list] return \\"Yes\\" if is_hamiltonian_cycle(n, edges) else \\"No\\""},{"question":"def check_subarray_sums_to_multiple(nums, k): Returns 'YES' if there exists a continuous subarray of size at least 2 that sums up to a multiple of k. Returns 'NO' otherwise. >>> check_subarray_sums_to_multiple([23, 2, 4, 6, 7], 6) \\"YES\\" >>> check_subarray_sums_to_multiple([23, 2, 6, 4, 7], 6) \\"YES\\" >>> check_subarray_sums_to_multiple([1, 2, 3], 10) \\"NO\\" >>> check_subarray_sums_to_multiple([1], 1) \\"NO\\" def process_test_cases(test_cases): Processes multiple test cases and returns results for each. Args: test_cases (list of tuple): List of tuples where each tuple contains the size of array, k and the array itself. Returns: list of str: List of results ('YES' or 'NO') for each test case. >>> process_test_cases([(5, 6, [23, 2, 4, 6, 7]), (5, 6, [23, 2, 6, 4, 7]), (3, 10, [1, 2, 3]), (4, 5, [5, 0, 0, 0])]) [\\"YES\\", \\"YES\\", \\"NO\\", \\"YES\\"]","solution":"def check_subarray_sums_to_multiple(nums, k): Returns 'YES' if there exists a continuous subarray of size at least 2 that sums up to a multiple of k. Returns 'NO' otherwise. n = len(nums) if n < 2: return \\"NO\\" prefix_sum_remainders = {0: -1} # To handle the edge case where prefix_sum % k == 0 early in the array current_sum = 0 for i in range(n): current_sum += nums[i] remainder = current_sum % k if k != 0 else current_sum if remainder in prefix_sum_remainders: if i - prefix_sum_remainders[remainder] > 1: return \\"YES\\" else: prefix_sum_remainders[remainder] = i return \\"NO\\" def process_test_cases(test_cases): Processes multiple test cases and returns results for each. Args: test_cases (list of tuple): List of tuples where each tuple contains the size of array, k and the array itself. Returns: list of str: List of results ('YES' or 'NO') for each test case. results = [] for (n, k, nums) in test_cases: result = check_subarray_sums_to_multiple(nums, k) results.append(result) return results"},{"question":"def first_non_repeated_character(s: str) -> str: Returns the first non-repeated character in the string \`s\`. If all characters are repeated, returns \\"None\\". >>> first_non_repeated_character('swiss') == 'w' >>> first_non_repeated_character('aabbcc') == 'None' >>> first_non_repeated_character('a') == 'a' >>> first_non_repeated_character('abcdef') == 'a' >>> first_non_repeated_character('aabbcddeef') == 'c' >>> first_non_repeated_character('aabbccaa') == 'None' >>> first_non_repeated_character('aabbccddf') == 'f'","solution":"def first_non_repeated_character(s): Returns the first non-repeated character in the string \`s\`. If all characters are repeated, returns \\"None\\". char_count = {} # Count the frequency of each character in the string. for char in s: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 # Find the first character that appears only once. for char in s: if char_count[char] == 1: return char return \\"None\\""},{"question":"def shortest_path(num_locations: int, num_paths: int, edges: List[Tuple[int, int, int]], start: int, treasure: int) -> Union[int, str]: Find the shortest path from the starting location to the treasure location. Parameters: - num_locations: int, the number of nodes. - num_paths: int, the number of edges. - edges: List of tuples (u, v, w), where u and v are nodes and w is the weight of the edge between them. - start: int, the starting node. - treasure: int, the destination node. Returns: - The shortest travel time from start to treasure, or \\"IMPOSSIBLE\\" if no path exists. pass # Example Usage N = 5 M = 6 edges = [ (1, 2, 4), (1, 3, 2), (3, 2, 1), (2, 4, 7), (3, 4, 5), (4, 5, 3), ] S = 1 T = 5 print(shortest_path(N, M, edges, S, T)) # Example output: 10","solution":"import heapq def shortest_path(num_locations, num_paths, edges, start, treasure): Find the shortest path from the starting location to the treasure location. Parameters: - num_locations: int, the number of nodes. - num_paths: int, the number of edges. - edges: List of tuples (u, v, w), where u and v are nodes and w is the weight of the edge between them. - start: int, the starting node. - treasure: int, the destination node. Returns: - The shortest travel time from start to treasure, or \\"IMPOSSIBLE\\" if no path exists. graph = {i: [] for i in range(1, num_locations + 1)} for u, v, w in edges: graph[u].append((v, w)) graph[v].append((u, w)) # Dijkstra's algorithm pq = [(0, start)] # (distance, node) dist = {i: float('inf') for i in range(1, num_locations + 1)} dist[start] = 0 while pq: current_distance, current_node = heapq.heappop(pq) if current_node == treasure: return current_distance if current_distance > dist[current_node]: continue for neighbor, weight in graph[current_node]: distance = current_distance + weight if distance < dist[neighbor]: dist[neighbor] = distance heapq.heappush(pq, (distance, neighbor)) return \\"IMPOSSIBLE\\" # Example Usage N = 5 M = 6 edges = [ (1, 2, 4), (1, 3, 2), (3, 2, 1), (2, 4, 7), (3, 4, 5), (4, 5, 3), ] S = 1 T = 5 print(shortest_path(N, M, edges, S, T)) # Output: 10"},{"question":"def unique_paths(m: int, n: int) -> int: Calculate the number of unique paths from the top-left corner to the bottom-right corner in an m x n grid. >>> unique_paths(2, 2) 2 >>> unique_paths(3, 3) 6 >>> unique_paths(1, 1) 1 pass def process_test_cases(test_cases: List[Tuple[int, int]]) -> List[int]: Process multiple test cases and return the number of unique paths for each. >>> process_test_cases([(2, 2), (3, 3), (4, 4)]) [2, 6, 20] >>> process_test_cases([(1, 1), (2, 1), (1, 2)]) [1, 1, 1] pass","solution":"def unique_paths(m, n): Calculate the number of unique paths from the top-left corner to the bottom-right corner in an m x n grid. # Create a 2D list to store the number of unique paths to each cell dp = [[0] * n for _ in range(m)] # There is only one way to reach any cell in the first row or the first column for i in range(m): dp[i][0] = 1 for j in range(n): dp[0][j] = 1 # Use dynamic programming to fill in the rest of the dp table for i in range(1, m): for j in range(1, n): dp[i][j] = dp[i-1][j] + dp[i][j-1] return dp[m-1][n-1] def process_test_cases(test_cases): results = [] for m, n in test_cases: results.append(unique_paths(m, n)) return results"},{"question":"def min_total_time_for_dishes(test_cases): Calculate the minimum total time required to prepare all dishes simultaneously using infinite chefs. Args: test_cases: List of (n, dishes) where n is the number of dishes and dishes is a list of lists containing the time required for each step of each dish. Returns: List of integers representing the minimum total time for each test case. >>> test_cases = parse_input(\\"2n3n2 3 4n4 2 2 1 1n3 4 6 2n2n3 1 3 2n2 4 1\\") >>> min_total_time_for_dishes(test_cases) [14, 9] def parse_input(input_data): Parse the input string into test cases. Args: input_data: A string containing multiple test cases. Returns: A list of test cases, each test case is represented as a tuple where the first element is the number of dishes, and the second element is a list of lists with the time required for each step of each dish. >>> parse_input(\\"1n2n3 1 3 2n2 4 1\\") [(2, [[1, 3, 2], [4, 1]])] def test_min_total_time_for_dishes_single_case(): input_data = \\"1n2n3 1 3 2n2 4 1\\" test_cases = parse_input(input_data) assert min_total_time_for_dishes(test_cases) == [6] def test_min_total_time_for_dishes_multiple_cases(): input_data = \\"2n3n2 3 4n4 2 2 1 1n3 4 6 2n2n3 1 3 2n2 4 1\\" test_cases = parse_input(input_data) assert min_total_time_for_dishes(test_cases) == [12, 6] def test_min_total_time_for_dishes_single_dish(): input_data = \\"1n1n3 4 2 1\\" test_cases = parse_input(input_data) assert min_total_time_for_dishes(test_cases) == [7] def test_min_total_time_for_dishes_same_time_dishes(): input_data = \\"1n2n3 2 2 2n3 2 2 2\\" test_cases = parse_input(input_data) assert min_total_time_for_dishes(test_cases) == [6] def test_min_total_time_for_dishes_variable_steps(): input_data = \\"1n3n3 2 2 2n1 5n4 1 1 1 1\\" test_cases = parse_input(input_data) assert min_total_time_for_dishes(test_cases) == [6] from solution import min_total_time_for_dishes, parse_input","solution":"def min_total_time_for_dishes(test_cases): results = [] for test in test_cases: n = test[0] max_time = 0 for dish in test[1]: max_time = max(max_time, sum(dish)) results.append(max_time) return results def parse_input(input_data): lines = input_data.split(\\"n\\") t = int(lines[0].strip()) test_cases = [] index = 1 for _ in range(t): n = int(lines[index].strip()) index += 1 dishes = [] for _ in range(n): parts = list(map(int, lines[index].strip().split())) s, step_times = parts[0], parts[1:] dishes.append(step_times) index += 1 test_cases.append((n, dishes)) return test_cases"},{"question":"def find_zero_sum_triplets(nums): Returns a list of unique triplets in the list which sum up to zero. >>> find_zero_sum_triplets([1, 2, 3, 4, 5]) [] >>> find_zero_sum_triplets([-1, 0, 1]) [[-1, 0, 1]] >>> sorted(find_zero_sum_triplets([-1, 0, 1, 2, -1, -4])) sorted([[-1, -1, 2], [-1, 0, 1]]) >>> sorted(find_zero_sum_triplets([-1, 0, 1, -1, 0, 1])) sorted([[-1, 0, 1]]) >>> find_zero_sum_triplets([0, 0, 0, 0]) [[0, 0, 0]]","solution":"def find_zero_sum_triplets(nums): Returns a list of unique triplets in the list which sum up to zero. nums.sort() res = [] n = len(nums) for i in range(n - 2): if i > 0 and nums[i] == nums[i - 1]: continue left, right = i + 1, n - 1 while left < right: total = nums[i] + nums[left] + nums[right] if total < 0: left += 1 elif total > 0: right -= 1 else: res.append([nums[i], nums[left], nums[right]]) while left < right and nums[left] == nums[left + 1]: left += 1 while left < right and nums[right] == nums[right - 1]: right -= 1 left += 1 right -= 1 return res"},{"question":"def longest_non_decreasing_subsequence(words): Finds the length of the longest non-decreasing subsequence based on word lengths. :param words: List of tuples where each tuple contains two integers (t, l) :return: Length of the longest non-decreasing subsequence of words based on their lengths pass def test_example_case(): words = [(1, 5), (3, 3), (8, 4), (14, 6), (19, 8), (20, 7)] assert longest_non_decreasing_subsequence(words) == 4 def test_single_word(): words = [(1, 5)] assert longest_non_decreasing_subsequence(words) == 1 def test_identical_lengths(): words = [(1, 2), (2, 2), (3, 2), (4, 2)] assert longest_non_decreasing_subsequence(words) == 4 def test_strictly_increasing_lengths(): words = [(1, 1), (2, 2), (3, 3), (4, 4)] assert longest_non_decreasing_subsequence(words) == 4 def test_strictly_decreasing_lengths(): words = [(1, 4), (2, 3), (3, 2), (4, 1)] assert longest_non_decreasing_subsequence(words) == 1 def test_mixed_lengths(): words = [(1, 10), (2, 20), (3, 10), (4, 30), (5, 25), (6, 35)] assert longest_non_decreasing_subsequence(words) == 4 def test_non_increasing_lengths_with_some_increasing(): words = [(1, 5), (2, 6), (3, 4), (4, 8), (5, 3), (6, 9)] assert longest_non_decreasing_subsequence(words) == 4","solution":"def longest_non_decreasing_subsequence(words): Finds the length of the longest non-decreasing subsequence based on word lengths. :param words: List of tuples where each tuple contains two integers (t, l) :return: Length of the longest non-decreasing subsequence of words based on their lengths lengths = [l for t, l in words] n = len(lengths) if n == 0: return 0 # List to store the length of the longest increasing subsequence ending at each index dp = [1] * n for i in range(1, n): for j in range(0, i): if lengths[j] <= lengths[i]: dp[i] = max(dp[i], dp[j] + 1) return max(dp)"},{"question":"def spiral_traversal(matrix: List[List[int]]) -> List[int]: Takes a matrix as input and returns the elements in a clockwise spiral order. Args: matrix (list of list of int): The matrix to be spirally traversed. Returns: list: A list containing the elements of the matrix in spirally traversed order. from spiral_traversal import spiral_traversal def test_example_1(): matrix = [ [1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16] ] assert spiral_traversal(matrix) == [1, 2, 3, 4, 8, 12, 16, 15, 14, 13, 9, 5, 6, 7, 11, 10] def test_example_2(): matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] assert spiral_traversal(matrix) == [1, 2, 3, 6, 9, 8, 7, 4, 5] def test_single_element(): matrix = [ [1] ] assert spiral_traversal(matrix) == [1] def test_single_row(): matrix = [ [1, 2, 3, 4] ] assert spiral_traversal(matrix) == [1, 2, 3, 4] def test_single_column(): matrix = [ [1], [2], [3], [4] ] assert spiral_traversal(matrix) == [1, 2, 3, 4] def test_empty_matrix(): matrix = [] assert spiral_traversal(matrix) == [] def test_non_square_matrix(): matrix = [ [1, 2, 3, 4, 5], [6, 7, 8, 9, 10], [11, 12, 13, 14, 15] ] assert spiral_traversal(matrix) == [1, 2, 3, 4, 5, 10, 15, 14, 13, 12, 11, 6, 7, 8, 9]","solution":"def spiral_traversal(matrix): Takes a matrix as input and returns the elements in a clockwise spiral order. Args: matrix (list of list of int): The matrix to be spirally traversed. Returns: list: A list containing the elements of the matrix in spirally traversed order. if not matrix: return [] m, n = len(matrix), len(matrix[0]) result = [] top, bottom, left, right = 0, m - 1, 0, n - 1 while top <= bottom and left <= right: for i in range(left, right + 1): # traverse from left to right result.append(matrix[top][i]) top += 1 for i in range(top, bottom + 1): # traverse from top to bottom result.append(matrix[i][right]) right -= 1 if top <= bottom: for i in range(right, left - 1, -1): # traverse from right to left result.append(matrix[bottom][i]) bottom -= 1 if left <= right: for i in range(bottom, top - 1, -1): # traverse from bottom to top result.append(matrix[i][left]) left += 1 return result"},{"question":"def longest_increasing_subsequence_length(sequence): Identify the length of the longest strictly increasing subsequence for a given list of numbers. >>> longest_increasing_subsequence_length([10, 22, 9, 33, 21]) 3 >>> longest_increasing_subsequence_length([5, 8, 3, 7, 9, 1]) 3 pass def process_test_cases(test_cases): Process multiple test cases to find the length of the longest strictly increasing subsequence for each case. test_cases: List[Tuple[int, List[int]]] Returns List[int] representing the lengths of the longest strictly increasing subsequences for each test case. pass from solution import process_test_cases def test_example_cases(): test_cases = [ (5, [10, 22, 9, 33, 21]), (6, [5, 8, 3, 7, 9, 1]) ] expected_results = [3, 3] assert process_test_cases(test_cases) == expected_results def test_single_element_sequence(): test_cases = [ (1, [10]), (1, [99999]) ] expected_results = [1, 1] assert process_test_cases(test_cases) == expected_results def test_decreasing_sequence(): test_cases = [ (5, [5, 4, 3, 2, 1]), (4, [10, 9, 8, 7]) ] expected_results = [1, 1] assert process_test_cases(test_cases) == expected_results def test_strictly_increasing_sequence(): test_cases = [ (5, [1, 2, 3, 4, 5]), (4, [5, 10, 15, 20]) ] expected_results = [5, 4] assert process_test_cases(test_cases) == expected_results def test_mixed_sequence(): test_cases = [ (7, [10, 22, 9, 33, 21, 50, 41]), (8, [7, 9, 2, 5, 6, 3, 8, 4]) ] expected_results = [4, 4] assert process_test_cases(test_cases) == expected_results","solution":"def longest_increasing_subsequence_length(sequence): import bisect lis = [] for num in sequence: pos = bisect.bisect_left(lis, num) if pos == len(lis): lis.append(num) else: lis[pos] = num return len(lis) def process_test_cases(test_cases): results = [] for test_case in test_cases: N = test_case[0] sequence = test_case[1] result = longest_increasing_subsequence_length(sequence) results.append(result) return results"},{"question":"def rearrange_list(lst: List[int]) -> List[int]: Rearrange the elements so that all even numbers appear before all odd numbers while preserving their relative order. >>> rearrange_list([3, 1, 2, 4, 7, 6]) [2, 4, 6, 3, 1, 7] >>> rearrange_list([1, 1, 1, 2]) [2, 1, 1, 1] >>> rearrange_list([2, 4, 6]) [2, 4, 6] >>> rearrange_list([3, 1, 7]) [3, 1, 7] >>> rearrange_list([]) [] >>> rearrange_list([2]) [2] >>> rearrange_list([3]) [3] >>> rearrange_list([1, 3, 5, 2, 4, 6]) [2, 4, 6, 1, 3, 5]","solution":"def rearrange_list(lst): Rearranges the list so that all even numbers appear before all odd numbers, while preserving the relative order of the even and odd numbers. evens = [x for x in lst if x % 2 == 0] odds = [x for x in lst if x % 2 != 0] return evens + odds"},{"question":"def max_subarray_sum_reversed(n: int, sequence: List[int]) -> int: Given an integer n and a sequence of n integers, this function reverses the sequence and then finds the maximum sum of a contiguous subarray in the reversed sequence. Parameters: n (int): The number of integers in the sequence. sequence (list of int): The sequence of integers. Returns: int: The maximum sum of a contiguous subarray in the reversed sequence. >>> max_subarray_sum_reversed(5, [1, -2, 3, -1, 2]) 4 >>> max_subarray_sum_reversed(4, [1, 2, 3, 4]) 10 >>> max_subarray_sum_reversed(4, [-1, -2, -3, -4]) -1 >>> max_subarray_sum_reversed(7, [-2, 1, -3, 4, -1, 2, 1]) 6 >>> max_subarray_sum_reversed(1, [5]) 5 >>> max_subarray_sum_reversed(1, [-5]) -5","solution":"def max_subarray_sum_reversed(n, sequence): Given an integer n and a sequence of n integers, this function reverses the sequence and then finds the maximum sum of a contiguous subarray in the reversed sequence. Parameters: n (int): The number of integers in the sequence. sequence (list of int): The sequence of integers. Returns: int: The maximum sum of a contiguous subarray in the reversed sequence. reversed_sequence = sequence[::-1] max_sum = -float('inf') current_sum = 0 for number in reversed_sequence: current_sum = max(number, current_sum + number) max_sum = max(max_sum, current_sum) return max_sum"},{"question":"from typing import List, Tuple def max_subarray_sum(nums: List[int]) -> Tuple[int, int, int]: Given a list of integers, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum along with the start and end indices (0-based) of the subarray. >>> max_subarray_sum([-2,1,-3,4,-1,2,1,-5,4]) (6, 3, 6) >>> max_subarray_sum([1]) (1, 0, 0) >>> max_subarray_sum([5,4,-1,7,8]) (23, 0, 4) >>> max_subarray_sum([-2, -3, -4, -1, -2]) (-1, 3, 3) >>> max_subarray_sum([1, -3, 2, 1, -1]) (3, 2, 3) >>> max_subarray_sum([1] * 100000) (100000, 0, 99999)","solution":"from typing import List, Tuple def max_subarray_sum(nums: List[int]) -> Tuple[int, int, int]: # Initialize variables for the maximum sum, start and end indices max_sum = float('-inf') current_sum = 0 start_idx = 0 temp_start_idx = 0 end_idx = 0 for i in range(len(nums)): if current_sum <= 0: current_sum = nums[i] temp_start_idx = i else: current_sum += nums[i] if current_sum > max_sum: max_sum = current_sum start_idx = temp_start_idx end_idx = i return max_sum, start_idx, end_idx"},{"question":"from typing import List def longest_common_prefix(strings: List[str]) -> str: John has a list of N strings and he needs to find the longest common prefix (LCP) among all these strings. The LCP of a set of strings is the longest starting sequence that is common to all the strings in the set. Write a function to help John find this prefix. Args: strings: List of strings consisting of lowercase English letters. Returns: The longest common prefix or an empty string if no common prefix exists. >>> longest_common_prefix([\\"flower\\", \\"flow\\", \\"flight\\"]) \\"fl\\" >>> longest_common_prefix([\\"dog\\", \\"racecar\\", \\"car\\"]) \\"\\" # Implement the function # Unit tests def test_longest_common_prefix_all_same_strings(): assert longest_common_prefix([\\"test\\", \\"test\\", \\"test\\"]) == \\"test\\" def test_longest_common_prefix_no_common_prefix(): assert longest_common_prefix([\\"abc\\", \\"def\\", \\"ghi\\"]) == \\"\\" def test_longest_common_prefix_partial_common_prefix(): assert longest_common_prefix([\\"flower\\", \\"flow\\", \\"flight\\"]) == \\"fl\\" def test_longest_common_prefix_single_string(): assert longest_common_prefix([\\"single\\"]) == \\"single\\" def test_longest_common_prefix_varied_lengths(): assert longest_common_prefix([\\"interspecies\\", \\"interstellar\\", \\"interstate\\"]) == \\"inters\\" def test_longest_common_prefix_empty_input(): assert longest_common_prefix([]) == \\"\\" def test_longest_common_prefix_mixed(): assert longest_common_prefix([\\"floral\\", \\"flow\\", \\"flyer\\"]) == \\"fl\\" def test_longest_common_prefix_one_empty_string(): assert longest_common_prefix([\\"notempty\\", \\"\\"]) == \\"\\" def test_longest_common_prefix_all_empty_strings(): assert longest_common_prefix([\\"\\", \\"\\", \\"\\"]) == \\"\\"","solution":"def longest_common_prefix(strings): Returns the longest common prefix for a list of strings. if not strings: return \\"\\" # Assume the first string as the prefix prefix = strings[0] for s in strings[1:]: # Gradually reduce the prefix size until it matches the current string beginning while not s.startswith(prefix): prefix = prefix[:-1] if prefix == \\"\\": return \\"\\" return prefix"},{"question":"def can_be_palindrome(s): Determine if the string \`s\` can be rearranged to form a palindrome by reversing substrings. Args: s (str): The string to check. Returns: str: 'YES' if the string can be rearranged to form a palindrome, 'NO' otherwise. Examples: >>> can_be_palindrome(\\"aab\\") 'YES' >>> can_be_palindrome(\\"abcba\\") 'YES' >>> can_be_palindrome(\\"abcdef\\") 'NO' >>> can_be_palindrome(\\"adda\\") 'YES' pass def process_test_cases(t, cases): Process multiple test cases to determine if each string can be rearranged to form a palindrome. Args: t (int): The number of test cases. cases (List[Tuple[int, str]]): A list of tuples, each containing the length of the string and the string itself. Returns: List[str]: A list of results for each test case, either 'YES' or 'NO'. Examples: >>> cases = [(3, \\"aab\\"), (5, \\"abcba\\"), (6, \\"abcdef\\"), (4, \\"adda\\")] >>> process_test_cases(4, cases) ['YES', 'YES', 'NO', 'YES'] pass","solution":"def can_be_palindrome(s): Determine if the string \`s\` can be rearranged to form a palindrome by reversing substrings. n = len(s) # Single character strings are palindromes if n == 1: return 'YES' # Check if the string s can be rearranged to form a palindrome mismatches = 0 for i in range(n // 2): if s[i] != s[n - i - 1]: mismatches += 1 # If there is at most 1 mismatch, we can make it a palindrome by reversing substrings if mismatches <= 1: return 'YES' else: return 'NO' def process_test_cases(t, cases): results = [] for case in cases: n, s = case results.append(can_be_palindrome(s)) return results"},{"question":"def solve(n: int, grid: List[str], T: List[List[int]]) -> int: Determine the maximum number of transformations that can occur in any cell on the path from the top-left corner to the bottom-right corner such that there still exists a valid path. >>> solve(4, [\\"....\\", \\".X..\\", \\"..X.\\", \\"....\\"], [[0, 0, 1, 1], [0, 1, 0, 0], [0, 1, 0, 0], [0, 0, 1, 1]]) 0 >>> solve(3, [\\"...\\", \\"...\\", \\"...\\"], [[0, 0, 0], [0, 0, 0], [0, 0, 0]]) 0 >>> solve(2, [\\".X\\", \\"X.\\"], [[0, 1], [1, 0]]) -1 >>> solve(3, [\\"...\\", \\".X.\\", \\"...\\"], [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) 1 >>> solve(5, [\\".....\\", \\".....\\", \\".X...\\", \\".....\\", \\".....\\"], [[2, 2, 2, 2, 2], [2, 2, 2, 2, 2], [2, 2, 3, 2, 2], [2, 2, 2, 2, 2], [2, 2, 2, 2, 2]]) 2 >>> solve(3, [\\"..X\\", \\"XX.\\", \\"..X\\"], [[1, 2, 0], [0, 0, 0], [1, 1, 1]]) -1","solution":"def max_transformations(grid, T): n = len(grid) # dp table to store the maximum number of transformations we can meet at each cell dp = [[-1] * n for _ in range(n)] # Base case dp[0][0] = T[0][0] if grid[0][0] == '.' else -1 # DP computation for i in range(n): for j in range(n): if grid[i][j] == 'X': dp[i][j] = -1 continue if i > 0 and dp[i-1][j] != -1: dp[i][j] = max(dp[i][j], min(dp[i-1][j], T[i][j])) if j > 0 and dp[i][j-1] != -1: dp[i][j] = max(dp[i][j], min(dp[i][j-1], T[i][j])) return dp[-1][-1] # Function to parse the input and call max_transformations function def solve(n, grid, T): result = max_transformations(grid, T) return result"},{"question":"def find_second_largest(nums: List[int]) -> int: Returns the second largest unique integer in the list. Assumes the list contains at least two unique integers. >>> find_second_largest([10, 5, 8, 12, 3, 8, 12]) 10 >>> find_second_largest([7, 7, 7, 7, 6]) 6 from solution import find_second_largest def test_find_second_largest_typical_case(): assert find_second_largest([10, 5, 8, 12, 3, 8, 12]) == 10 def test_find_second_largest_with_duplicates(): assert find_second_largest([7, 7, 7, 7, 6]) == 6 def test_find_second_largest_with_negative_numbers(): assert find_second_largest([-1, -2, -3, -4]) == -2 def test_find_second_largest_with_mixed_numbers(): assert find_second_largest([5, -1, 0, 3, 2]) == 3 def test_find_second_largest_with_only_two_unique_numbers(): assert find_second_largest([2, 1]) == 1 def test_find_second_largest_with_multiple_same_max_numbers(): assert find_second_largest([4, 4, 4, 3, 2, 5, 5, 1]) == 4","solution":"def find_second_largest(nums): Returns the second largest unique integer in the list. Assumes the list contains at least two unique integers. unique_nums = list(set(nums)) unique_nums.sort(reverse=True) return unique_nums[1]"},{"question":"def check_bookshelf(C, categories, B, books): Check if the bookshelf is organized correctly based on the categories and their required ordering. Args: C (int): The number of categories. categories (List[str]): The names of the categories in the required order. B (int): The number of books on the shelf. books (List[Tuple[str, str]]): Each tuple contains a book's title and its category name. Returns: str: \\"CORRECT\\" if the books are organized correctly, otherwise \\"INCORRECT\\". Examples: >>> check_bookshelf(3, [\\"Fiction\\", \\"Mystery\\", \\"Sci-fi\\"], 5, [(\\"Book1\\", \\"Fiction\\"), (\\"Book2\\", \\"Fiction\\"), (\\"Book3\\", \\"Mystery\\"), (\\"Book4\\", \\"Mystery\\"), (\\"Book5\\", \\"Sci-fi\\")]) 'CORRECT' >>> check_bookshelf(3, [\\"Fiction\\", \\"Mystery\\", \\"Sci-fi\\"], 6, [(\\"Book1\\", \\"Fiction\\"), (\\"Book2\\", \\"Mystery\\"), (\\"Book3\\", \\"Fiction\\"), (\\"Book4\\", \\"Mystery\\"), (\\"Book5\\", \\"Sci-fi\\"), (\\"Book6\\", \\"Sci-fi\\")]) 'INCORRECT' pass import pytest def test_correct_order(): C = 3 categories = [\\"Fiction\\", \\"Mystery\\", \\"Sci-fi\\"] B = 5 books = [ (\\"Book1\\", \\"Fiction\\"), (\\"Book2\\", \\"Fiction\\"), (\\"Book3\\", \\"Mystery\\"), (\\"Book4\\", \\"Mystery\\"), (\\"Book5\\", \\"Sci-fi\\") ] assert check_bookshelf(C, categories, B, books) == \\"CORRECT\\" def test_incorrect_order_broken_sequence(): C = 3 categories = [\\"Fiction\\", \\"Mystery\\", \\"Sci-fi\\"] B = 6 books = [ (\\"Book1\\", \\"Fiction\\"), (\\"Book2\\", \\"Mystery\\"), (\\"Book3\\", \\"Fiction\\"), (\\"Book4\\", \\"Mystery\\"), (\\"Book5\\", \\"Sci-fi\\"), (\\"Book6\\", \\"Sci-fi\\") ] assert check_bookshelf(C, categories, B, books) == \\"INCORRECT\\" def test_multiple_categories_together(): C = 4 categories = [\\"Horror\\", \\"Fiction\\", \\"Mystery\\", \\"Sci-fi\\"] B = 10 books = [ (\\"Book1\\", \\"Horror\\"), (\\"Book2\\", \\"Fiction\\"), (\\"Book3\\", \\"Fiction\\"), (\\"Book4\\", \\"Mystery\\"), (\\"Book5\\", \\"Mystery\\"), (\\"Book6\\", \\"Sci-fi\\"), (\\"Book7\\", \\"Sci-fi\\"), (\\"Book8\\", \\"Sci-fi\\"), (\\"Book9\\", \\"Mystery\\"), (\\"Book10\\", \\"Horror\\") ] assert check_bookshelf(C, categories, B, books) == \\"INCORRECT\\" def test_single_category(): C = 1 categories = [\\"Fiction\\"] B = 3 books = [ (\\"Book1\\", \\"Fiction\\"), (\\"Book2\\", \\"Fiction\\"), (\\"Book3\\", \\"Fiction\\") ] assert check_bookshelf(C, categories, B, books) == \\"CORRECT\\" def test_missing_books(): C = 3 categories = [\\"Fiction\\", \\"Mystery\\", \\"Sci-fi\\"] B = 0 books = [] assert check_bookshelf(C, categories, B, books) == \\"CORRECT\\"","solution":"def check_bookshelf(C, categories, B, books): Check if the bookshelf is organized correctly based on the categories and their required ordering. # Create a map of category to its order index category_order = {category: i for i, category in enumerate(categories)} # Track the last seen order index of category in the bookshelf last_seen_order = -1 current_category = None for book_title, book_category in books: order_index = category_order[book_category] if current_category != book_category: if order_index < last_seen_order: return \\"INCORRECT\\" current_category = book_category last_seen_order = order_index return \\"CORRECT\\""},{"question":"class SegmentTree: def __init__(self, data): Initialize a new Segment Tree :param data: The initial energy points for each segment # Your code here def build(self, data, node, start, end): Build the Segment Tree :param data: The initial energy points for each segment :param node: The current node in the segment tree :param start: The starting index of the segment :param end: The ending index of the segment # Your code here def update_range(self, l, r, val): Update the range [l, r] in the segment tree with value val :param l: The starting index of the range :param r: The ending index of the range :param val: The value to update the range with # Your code here def _update_range(self, node, start, end, l, r, val): Utility function to update the range :param node: The current node in the segment tree :param start: The starting index of the segment :param end: The ending index of the segment :param l: The starting index of the range :param r: The ending index of the range :param val: The value to update the range with # Your code here def query_range(self, l, r): Query the maximum value in the range [l, r] :param l: The starting index of the range :param r: The ending index of the range :return: The maximum value in the specified range # Your code here def _query_range(self, node, start, end, l, r): Utility function to query the range :param node: The current node in the segment tree :param start: The starting index of the segment :param end: The ending index of the segment :param l: The starting index of the range :param r: The ending index of the range :return: The maximum value in the specified range # Your code here def mystical_land(n, m, a, commands): Function to process the commands and return the results of the queries :param n: Number of segments :param m: Number of commands :param a: Initial energy points of each segment :param commands: List of commands :return: List of results for each query # Your code here from mystical_land import mystical_land def test_case_1(): n = 6 m = 5 a = [5, 3, 8, 6, 2, 7] commands = [ (2, 1, 4), (1, 2, 5, 3), (2, 1, 6), (1, 3, 3, 2), (2, 1, 4) ] assert mystical_land(n, m, a, commands) == [8, 11, 13] def test_case_2(): n = 4 m = 4 a = [1, 2, 3, 4] commands = [ (2, 1, 4), (1, 1, 3, 5), (2, 2, 4), (2, 1, 3) ] assert mystical_land(n, m, a, commands) == [4, 8, 8] def test_case_3(): n = 5 m = 3 a = [5, 5, 5, 5, 5] commands = [ (2, 1, 5), (1, 1, 5, 2), (2, 1, 5) ] assert mystical_land(n, m, a, commands) == [5, 7] def test_case_4(): n = 10 m = 6 a = [1, 3, 5, 7, 9, 11, 13, 15, 17, 19] commands = [ (2, 1, 10), (1, 1, 5, 3), (2, 1, 5), (2, 6, 10), (1, 6, 10, 5), (2, 6, 10) ] assert mystical_land(n, m, a, commands) == [19, 12, 19, 24]","solution":"class SegmentTree: def __init__(self, data): self.n = len(data) self.tree = [0] * (4 * self.n) self.lazy = [0] * (4 * self.n) self.build(data, 0, 0, self.n - 1) def build(self, data, node, start, end): if start == end: self.tree[node] = data[start] else: mid = (start + end) // 2 left_child = 2 * node + 1 right_child = 2 * node + 2 self.build(data, left_child, start, mid) self.build(data, right_child, mid + 1, end) self.tree[node] = max(self.tree[left_child], self.tree[right_child]) def update_range(self, l, r, val): self._update_range(0, 0, self.n - 1, l, r, val) def _update_range(self, node, start, end, l, r, val): if self.lazy[node] != 0: self.tree[node] += self.lazy[node] if start != end: self.lazy[2 * node + 1] += self.lazy[node] self.lazy[2 * node + 2] += self.lazy[node] self.lazy[node] = 0 if start > end or start > r or end < l: return if start >= l and end <= r: self.tree[node] += val if start != end: self.lazy[2 * node + 1] += val self.lazy[2 * node + 2] += val return mid = (start + end) // 2 self._update_range(2 * node + 1, start, mid, l, r, val) self._update_range(2 * node + 2, mid + 1, end, l, r, val) self.tree[node] = max(self.tree[2 * node + 1], self.tree[2 * node + 2]) def query_range(self, l, r): return self._query_range(0, 0, self.n - 1, l, r) def _query_range(self, node, start, end, l, r): if start > end or start > r or end < l: return float('-inf') if self.lazy[node] != 0: self.tree[node] += self.lazy[node] if start != end: self.lazy[2 * node + 1] += self.lazy[node] self.lazy[2 * node + 2] += self.lazy[node] self.lazy[node] = 0 if start >= l and end <= r: return self.tree[node] mid = (start + end) // 2 left_query = self._query_range(2 * node + 1, start, mid, l, r) right_query = self._query_range(2 * node + 2, mid + 1, end, l, r) return max(left_query, right_query) def mystical_land(n, m, a, commands): segment_tree = SegmentTree(a) result = [] for command in commands: if command[0] == 1: _, l, r, k = command segment_tree.update_range(l - 1, r - 1, k) elif command[0] == 2: _, l, r = command result.append(segment_tree.query_range(l - 1, r - 1)) return result"},{"question":"def generate_mountain_path(n: int, heights: List[int]) -> List[Tuple[int, int]]: Generates the sequence of coordinates defining the path of a sequence of mountains. Parameters: n (int): Number of mountains heights (list): List of heights of the mountains Returns: list of tuples: Each tuple is a coordinate (x, y) >>> generate_mountain_path(1, [1]) [(1, 1), (2, 0)] >>> generate_mountain_path(2, [2, 2]) [(1, 1), (2, 2), (3, 1), (4, 0), (5, 1), (6, 2), (7, 1), (8, 0)] >>> generate_mountain_path(2, [1, 3]) [(1, 1), (2, 0), (3, 1), (4, 2), (5, 3), (6, 2), (7, 1), (8, 0)] >>> generate_mountain_path(3, [1, 2, 1]) [(1, 1), (2, 0), (3, 1), (4, 2), (5, 1), (6, 0), (7, 1), (8, 0)] >>> generate_mountain_path(3, [2, 3, 4]) [(1, 1), (2, 2), (3, 1), (4, 0), (5, 1), (6, 2), (7, 3), (8, 2), (9, 1), (10, 0), (11, 1), (12, 2), (13, 3), (14, 4), (15, 3), (16, 2), (17, 1), (18, 0)]","solution":"def generate_mountain_path(n, heights): Generates the sequence of coordinates defining the path of a sequence of mountains. Parameters: n (int): Number of mountains heights (list): List of heights of the mountains Returns: list of tuples: Each tuple is a coordinate (x, y) path = [] current_x = 0 for h in heights: # Ascend to peak for i in range(1, h + 1): path.append((current_x + i, i)) # Update current_x to peak current_x += h # Descend to base for i in range(h, 0, -1): path.append((current_x + (h - i + 1), i - 1)) # Update current_x to the end of current mountain current_x += h return path # Example usage # print(generate_mountain_path(3, [1, 2, 1]))"},{"question":"def max_product_path(matrix: List[List[int]]) -> int: Given a matrix of size n × m, find the path from the top-left cell (1, 1) to the bottom-right cell (n, m) such that the product of all the numbers on the path is maximized. You can only move right or down from each cell. Args: matrix: List[List[int]] - a 2D list of integers. Returns: int - the maximum product of the numbers from (1, 1) to (n, m). Examples: >>> max_product_path([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) 2016 >>> max_product_path([ ... [1, 99], ... [1, 2] ... ]) 198 pass # Unit Tests def test_max_product_path(): assert max_product_path([ [1, 2, 3], [4, 5, 6], [7, 8, 9] ]) == 2016 assert max_product_path([ [1, 99], [1, 2] ]) == 198 assert max_product_path([ [42] ]) == 42 assert max_product_path([ [1, 1, 1], [1, 1, 1], [1, 1, 1] ]) == 1 assert max_product_path([ [1, 2], [1, 3] ]) == 6 assert max_product_path([ [10, 10, 10], [10, 10, 10], [10, 10, 10] ]) == 100000","solution":"def max_product_path(matrix): n = len(matrix) m = len(matrix[0]) # Initialize a DP table to store the maximum product up to each cell dp = [[0] * m for _ in range(n)] # Initialize the starting point dp[0][0] = matrix[0][0] # Fill the first column (can only come from above) for i in range(1, n): dp[i][0] = dp[i-1][0] * matrix[i][0] # Fill the first row (can only come from the left) for j in range(1, m): dp[0][j] = dp[0][j-1] * matrix[0][j] # Fill the rest of the dp table for i in range(1, n): for j in range(1, m): dp[i][j] = max(dp[i-1][j] * matrix[i][j], dp[i][j-1] * matrix[i][j]) return dp[-1][-1]"},{"question":"def can_visit_all_rooms(T, test_cases): Determine if the robot vacuum can visit every room starting from room 0 based on the given threshold. Args: T (int): Number of test cases. test_cases (list): List of test cases where each test case is a tuple. The first element is a tuple (N, K) and the second element is a list of N dirt levels. Returns: list: A list of strings, \\"Yes\\" if the robot can visit every room, otherwise \\"No\\". Example: >>> can_visit_all_rooms(2, [ ((5, 3), [2, 5, 8, 6, 3]), ((3, 2), [7, 10, 5]) ]) ['Yes', 'No']","solution":"def can_visit_all_rooms(T, test_cases): results = [] def dfs(current_room, dirt_levels, visited, K): for next_room in range(len(dirt_levels)): if not visited[next_room] and abs(dirt_levels[current_room] - dirt_levels[next_room]) <= K: visited[next_room] = True dfs(next_room, dirt_levels, visited, K) for test_case in test_cases: N, K = test_case[0] dirt_levels = test_case[1] visited = [False] * N visited[0] = True dfs(0, dirt_levels, visited, K) if all(visited): results.append(\\"Yes\\") else: results.append(\\"No\\") return results"},{"question":"def count_palindromic_pairs(n, s): Given a string s of length n, this function returns the number of distinct pairs (i, j) (1 ≤ i < j ≤ n) where s_i and s_j are the same. Args: n (int): The length of the string. s (str): The input string of length n. Returns: int: The number of distinct index pairs (i, j) (i < j) such that the substring formed by s_i and s_j is a palindrome. Examples: >>> count_palindromic_pairs(5, \\"ababa\\") 4 >>> count_palindromic_pairs(4, \\"abcd\\") 0 >>> count_palindromic_pairs(3, \\"aaa\\") 3 pass def process_cases(test_cases): Given a list of test cases, processes each test case to find the number of palindromic pairs and returns the results. Args: test_cases (list): A list of tuples, where each tuple contains an integer n and a string s. Returns: list: A list of integers representing the number of distinct palindromic pairs for each test case. Examples: >>> process_cases([(5, \\"ababa\\"), (4, \\"abcd\\"), (3, \\"aaa\\")]) [4, 0, 3] pass from solution import count_palindromic_pairs, process_cases def test_example_case_1(): assert count_palindromic_pairs(5, \\"ababa\\") == 4 def test_example_case_2(): assert count_palindromic_pairs(4, \\"abcd\\") == 0 def test_example_case_3(): assert count_palindromic_pairs(3, \\"aaa\\") == 3 def test_single_character(): assert count_palindromic_pairs(1, \\"a\\") == 0 def test_no_palindromes(): assert count_palindromic_pairs(5, \\"abcde\\") == 0 def test_all_same_characters(): assert count_palindromic_pairs(4, \\"aaaa\\") == 6 def test_mixed_characters(): assert count_palindromic_pairs(6, \\"aabbcc\\") == 3 def test_process_cases(): test_cases = [ (5, \\"ababa\\"), (4, \\"abcd\\"), (3, \\"aaa\\") ] assert process_cases(test_cases) == [4, 0, 3]","solution":"def count_palindromic_pairs(n, s): Given a string s of length n, this function returns the number of distinct pairs (i, j) (1 ≤ i < j ≤ n) where s_i and s_j are the same. count = 0 char_count = {} # Iterate over each character in the string for char in s: # If the character has been seen before, increment the count by the frequency of this character seen so far if char in char_count: count += char_count[char] char_count[char] += 1 else: char_count[char] = 1 return count def process_cases(test_cases): results = [] for n, s in test_cases: results.append(count_palindromic_pairs(n, s)) return results"},{"question":"def max_product_of_two_distinct_elements(n: int, elements: List[int]) -> int: Returns the maximum product of any two distinct elements from a list of n non-negative integers. >>> max_product_of_two_distinct_elements(5, [1, 4, 3, 6, 2]) == 24 >>> max_product_of_two_distinct_elements(3, [1, 10, 2]) == 20","solution":"def max_product_of_two_distinct_elements(n, elements): Returns the maximum product of any two distinct elements from the list of n non-negative integers. if n < 2: return 0 # Not enough elements to form a product # Sort the list in non-increasing order elements.sort(reverse=True) # The maximum product will be the product of the first two elements as they are the largest max_product = elements[0] * elements[1] return max_product"},{"question":"def count_unique_patterns(N: int, F: int, votes: List[List[int]]) -> int: Returns the number of unique combinations of votes cast by students. Parameters: N (int): Number of students F (int): Number of unique fruits votes (list of list of int): Each sublist contains indices of fruits voted by a student Returns: int: The number of unique combinations of votes >>> count_unique_patterns(3, 3, [[1, 2], [0, 2], [2]]) 3 >>> count_unique_patterns(4, 2, [[0, 1], [0], [1], [1, 0]]) 3 >>> count_unique_patterns(2, 4, [[0, 1, 2, 3], [3]]) 2 from typing import List def test_case_1(): N, F = 3, 3 votes = [ [1, 2], [0, 2], [2] ] assert count_unique_patterns(N, F, votes) == 3 def test_case_2(): N, F = 4, 2 votes = [ [0, 1], [0], [1], [1, 0] ] assert count_unique_patterns(N, F, votes) == 3 def test_case_3(): N, F = 2, 4 votes = [ [0, 1, 2, 3], [3] ] assert count_unique_patterns(N, F, votes) == 2 def test_case_4(): N, F = 1, 1 votes = [ [0] ] assert count_unique_patterns(N, F, votes) == 1 def test_case_5(): N, F = 5, 3 votes = [ [0, 1], [1, 0], [0], [], [] ] assert count_unique_patterns(N, F, votes) == 3 def test_case_6(): N, F = 3, 3 votes = [ [], [1], [2] ] assert count_unique_patterns(N, F, votes) == 3 def test_case_7(): N, F = 6, 3 votes = [ [0, 1, 2], [0, 1], [1, 2], [0, 2], [1], [2] ] assert count_unique_patterns(N, F, votes) == 6","solution":"def count_unique_patterns(N, F, votes): Returns the number of unique combinations of votes cast by students. Parameters: N (int): Number of students F (int): Number of unique fruits votes (list of list of int): Each sublist contains indices of fruits voted by a student Returns: int: The number of unique combinations of votes unique_patterns = set() for vote in votes: # Convert the list of votes to a tuple (hashable type) to store in a set unique_patterns.add(tuple(sorted(vote))) return len(unique_patterns)"},{"question":"def calculate_average_salary(records: List[str], age_threshold: int) -> int: Calculate the average salary of employees who are older than a given age threshold. >>> calculate_average_salary([\\"Alice 30 60000\\", \\"Bob 25 50000\\", \\"Carol 35 70000\\"], 30) 70000 >>> calculate_average_salary([\\"Alice 30 60000\\", \\"Bob 25 50000\\"], 30) 0","solution":"def calculate_average_salary(records, age_threshold): Calculate the average salary of employees who are older than a given age threshold. total_salary = 0 count = 0 for record in records: name, age, salary = record.split() age = int(age) salary = int(salary) if age > age_threshold: total_salary += salary count += 1 if count == 0: return 0 return round(total_salary / count)"},{"question":"from typing import List def is_palindrome(arr: List[int]) -> bool: Check if the given array is a palindrome. return arr == arr[::-1] def longest_palindrome_subarray_length(arr: List[int]) -> int: Find the length of the longest contiguous subarray that forms a palindrome. Args: arr : List[int] : A list of integers Returns: int : The length of the longest palindrome subarray Examples: >>> longest_palindrome_subarray_length([1, 2, 3, 4, 3, 2, 1]) 7 >>> longest_palindrome_subarray_length([1, 2, 2, 3, 4]) 2 pass def solve(test_cases: List[List[int]]) -> List[int]: Solve multiple test cases to find the length of the longest palindrome subarray for each one. Args: test_cases : List[List[int]] : A list of test cases, each test case is a list of integers. Returns: List[int] : A list of integers representing the result for each test case Examples: >>> solve([[1, 2, 3, 4, 3, 2, 1], [1, 2, 2, 3, 4]]) [7, 2] pass from solution import longest_palindrome_subarray_length, solve def test_single_element_array(): assert longest_palindrome_subarray_length([1]) == 1 def test_entire_array_palindrome(): assert longest_palindrome_subarray_length([1, 2, 3, 2, 1]) == 5 def test_no_palindromes(): assert longest_palindrome_subarray_length([1, 2, 3, 4, 5]) == 1 def test_multiple_palindromes(): assert longest_palindrome_subarray_length([1, 2, 1, 2, 2]) == 3 def test_palindrome_at_the_start(): assert longest_palindrome_subarray_length([1, 1, 2, 3, 4]) == 2 def test_palindrome_at_the_end(): assert longest_palindrome_subarray_length([3, 4, 1, 2, 2]) == 2 def test_mixed_numbers(): assert longest_palindrome_subarray_length([1, 2, 2, 3, 3, 2, 2, 1]) == 8 def test_multiple_test_cases(): test_cases = [ [1, 2, 3, 4, 3, 2, 1], [1, 2, 2, 3, 4] ] assert solve(test_cases) == [7, 2]","solution":"def is_palindrome(arr): This function checks if the input array is a palindrome. return arr == arr[::-1] def longest_palindrome_subarray_length(arr): This function finds the length of the longest contiguous subarray that forms a palindrome. n = len(arr) max_length = 0 for i in range(n): for j in range(i, n): if is_palindrome(arr[i:j+1]): max_length = max(max_length, j-i+1) return max_length def solve(test_cases): results = [] for arr in test_cases: results.append(longest_palindrome_subarray_length(arr)) return results"},{"question":"from collections import defaultdict def max_distance_in_tree(n: int, edges: List[Tuple[int, int]]) -> int: Given the number of nodes \`n\` and a list of edges \`edges\` in a tree, find the maximum distance between any two nodes in the tree. >>> max_distance_in_tree(5, [(1, 2), (1, 3), (2, 4), (2, 5)]) 3 >>> max_distance_in_tree(6, [(1, 2), (1, 3), (3, 4), (3, 5), (4, 6)]) 4","solution":"from collections import deque, defaultdict def bfs(farthest_node_start, n, graph): visited = [-1] * (n + 1) queue = deque([farthest_node_start]) visited[farthest_node_start] = 0 farthest_node = farthest_node_start max_distance = 0 while queue: node = queue.popleft() current_distance = visited[node] for neighbor in graph[node]: if visited[neighbor] == -1: visited[neighbor] = current_distance + 1 queue.append(neighbor) if visited[neighbor] > max_distance: max_distance = visited[neighbor] farthest_node = neighbor return farthest_node, max_distance def max_distance_in_tree(n, edges): graph = defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) # Step 1: Find the farthest node from any arbitrary node, say node 1 farthest_node, _ = bfs(1, n, graph) # Step 2: Find the farthest node from the above farthest node _, max_distance = bfs(farthest_node, n, graph) return max_distance"},{"question":"class Warehouse: def __init__(self, shelves): self.shelves = shelves self.items = [0] * len(shelves) def add_items(self, item_type, shelf_id, count): shelf = self.shelves[shelf_id - 1] if shelf['item_type'] == item_type: self.items[shelf_id - 1] = min(shelf['capacity'], self.items[shelf_id - 1] + count) def remove_items(self, item_type, shelf_id, count): shelf = self.shelves[shelf_id - 1] if shelf['item_type'] == item_type: self.items[shelf_id - 1] = max(0, self.items[shelf_id - 1] - count) def query(self, shelf_id): return self.items[shelf_id - 1] def main(m, q, shelf_configs, operations): Process incoming and outgoing items for a warehouse management system. Args: m (int): number of shelves q (int): number of operations shelf_configs (List[Tuple[int, int]]): initial configuration of shelves, each with a capacity and item type operations (List[str]): list of operations to perform Returns: List[int]: results of the \\"query\\" operations Example: >>> main(3, 6, [(100, 1), (200, 2), (300, 3)], [\\"add 1 1 50\\", \\"add 2 2 150\\", \\"add 3 3 100\\", \\"query 1\\", \\"remove 2 2 50\\", \\"query 2\\"]) [50, 100] # Unit Tests def test_main(): m = 3 q = 6 shelf_configs = [ (100, 1), (200, 2), (300, 3) ] operations = [ \\"add 1 1 50\\", \\"add 2 2 150\\", \\"add 3 3 100\\", \\"query 1\\", \\"remove 2 2 50\\", \\"query 2\\" ] assert main(m, q, shelf_configs, operations) == [50, 100] def test_add_limit(): m = 1 q = 3 shelf_configs = [ (10, 1) ] operations = [ \\"add 1 1 5\\", \\"add 1 1 10\\", \\"query 1\\" ] assert main(m, q, shelf_configs, operations) == [10] def test_remove_below_zero(): m = 1 q = 3 shelf_configs = [ (10, 1) ] operations = [ \\"add 1 1 5\\", \\"remove 1 1 10\\", \\"query 1\\" ] assert main(m, q, shelf_configs, operations) == [0] def test_query_no_items(): m = 2 q = 1 shelf_configs = [ (50, 2), (100, 1) ] operations = [ \\"query 2\\" ] assert main(m, q, shelf_configs, operations) == [0]","solution":"class Warehouse: def __init__(self, shelves): self.shelves = shelves self.items = [0] * len(shelves) def add_items(self, item_type, shelf_id, count): shelf = self.shelves[shelf_id - 1] if shelf['item_type'] == item_type: self.items[shelf_id - 1] = min(shelf['capacity'], self.items[shelf_id - 1] + count) def remove_items(self, item_type, shelf_id, count): shelf = self.shelves[shelf_id - 1] if shelf['item_type'] == item_type: self.items[shelf_id - 1] = max(0, self.items[shelf_id - 1] - count) def query(self, shelf_id): return self.items[shelf_id - 1] def main(m, q, shelf_configs, operations): shelves = [{'capacity': config[0], 'item_type': config[1]} for config in shelf_configs] warehouse = Warehouse(shelves) results = [] for operation in operations: parts = operation.split() if parts[0] == \\"add\\": _, item_type, shelf_id, count = parts warehouse.add_items(int(item_type), int(shelf_id), int(count)) elif parts[0] == \\"remove\\": _, item_type, shelf_id, count = parts warehouse.remove_items(int(item_type), int(shelf_id), int(count)) elif parts[0] == \\"query\\": _, shelf_id = parts results.append(warehouse.query(int(shelf_id))) return results"},{"question":"from typing import List, Tuple, Optional class WeatherTracker: A custom data structure to handle daily weather records for a city. Methods: add_record(date: str, temperature: int) -> None Adds a new weather record with the given date and temperature. get_max_temperature(date: str) -> Optional[int] Returns the maximum temperature recorded on the given date. If there are no records for the date, return None. get_records(start_date: str, end_date: str) -> List[Tuple[str, int]] Returns a list of tuples where each tuple consists of a date and the corresponding maximum temperature recorded within the given date range, inclusive. >>> tracker = WeatherTracker() >>> tracker.add_record(\\"2023-01-01\\", 10) >>> tracker.add_record(\\"2023-01-01\\", 15) >>> tracker.add_record(\\"2023-01-02\\", 20) >>> tracker.add_record(\\"2023-01-03\\", 5) >>> tracker.get_max_temperature(\\"2023-01-01\\") 15 >>> tracker.get_records(\\"2023-01-01\\", \\"2023-01-03\\") [(\\"2023-01-01\\", 15), (\\"2023-01-02\\", 20), (\\"2023-01-03\\", 5)] >>> tracker.get_max_temperature(\\"2023-01-04\\") None def add_record(self, date: str, temperature: int) -> None: pass def get_max_temperature(self, date: str) -> Optional[int]: pass def get_records(self, start_date: str, end_date: str) -> List[Tuple[str, int]]: pass def test_add_record_and_max_temp(): tracker = WeatherTracker() tracker.add_record(\\"2023-01-01\\", 10) tracker.add_record(\\"2023-01-01\\", 15) tracker.add_record(\\"2023-01-02\\", 20) assert tracker.get_max_temperature(\\"2023-01-01\\") == 15 assert tracker.get_max_temperature(\\"2023-01-02\\") == 20 assert tracker.get_max_temperature(\\"2023-01-03\\") == None def test_get_records(): tracker = WeatherTracker() tracker.add_record(\\"2023-01-01\\", 10) tracker.add_record(\\"2023-01-01\\", 15) tracker.add_record(\\"2023-01-02\\", 20) tracker.add_record(\\"2023-01-03\\", 5) expected = [ (\\"2023-01-01\\", 15), (\\"2023-01-02\\", 20), (\\"2023-01-03\\", 5) ] assert tracker.get_records(\\"2023-01-01\\", \\"2023-01-03\\") == expected expected = [ (\\"2023-01-02\\", 20) ] assert tracker.get_records(\\"2023-01-02\\", \\"2023-01-02\\") == expected expected = [] assert tracker.get_records(\\"2022-12-30\\", \\"2022-12-31\\") == expected def test_add_additional_records(): tracker = WeatherTracker() tracker.add_record(\\"2023-01-01\\", 10) tracker.add_record(\\"2023-01-01\\", 15) tracker.add_record(\\"2023-01-02\\", 20) tracker.add_record(\\"2023-01-03\\", 5) tracker.add_record(\\"2023-01-01\\", 25) assert tracker.get_max_temperature(\\"2023-01-01\\") == 25 def test_edge_case_empty_tracker(): tracker = WeatherTracker() assert tracker.get_max_temperature(\\"2023-01-01\\") == None assert tracker.get_records(\\"2023-01-01\\", \\"2023-01-02\\") == []","solution":"from typing import List, Tuple, Optional from collections import defaultdict import bisect class WeatherTracker: def __init__(self): self.data = defaultdict(list) self.sorted_dates = [] def add_record(self, date: str, temperature: int) -> None: if date not in self.data: bisect.insort(self.sorted_dates, date) self.data[date].append(temperature) def get_max_temperature(self, date: str) -> Optional[int]: if date not in self.data: return None return max(self.data[date]) def get_records(self, start_date: str, end_date: str) -> List[Tuple[str, int]]: start_idx = bisect.bisect_left(self.sorted_dates, start_date) end_idx = bisect.bisect_right(self.sorted_dates, end_date) records = [] for idx in range(start_idx, end_idx): date = self.sorted_dates[idx] max_temp = max(self.data[date]) records.append((date, max_temp)) return records"},{"question":"def can_form_palindrome(s: str) -> str: Determines if the input string can be rearranged to form a palindrome. Returns \\"YES\\" if it can be rearranged to form a palindrome, \\"NO\\" otherwise. >>> can_form_palindrome(\\"carrace\\") \\"YES\\" >>> can_form_palindrome(\\"hello\\") \\"NO\\"","solution":"def can_form_palindrome(s): Determines if the input string can be rearranged to form a palindrome. Returns \\"YES\\" if it can be rearranged to form a palindrome, \\"NO\\" otherwise. from collections import Counter freq = Counter(s) odd_count = sum(1 for count in freq.values() if count % 2 != 0) return \\"YES\\" if odd_count <= 1 else \\"NO\\""},{"question":"def minimum_coins(n: int, m: int, coins: List[int]) -> int: Determines the minimum number of coins required to make exactly m units of currency. Returns -1 if it is not possible to make m units with the given denominations. >>> minimum_coins(3, 11, [1, 2, 5]) == 3 >>> minimum_coins(2, 3, [2, 4]) == -1 >>> minimum_coins(1, 7, [3]) == -1","solution":"def minimum_coins(n, m, coins): Determines the minimum number of coins required to make exactly m units of currency. Returns -1 if it is not possible to make m units with the given denominations. # Initialize the DP array, use float('inf') as placeholder for an impossible situation dp = [float('inf')] * (m + 1) dp[0] = 0 # Dynamic programming solution for i in range(1, m + 1): for coin in coins: if i >= coin: dp[i] = min(dp[i], dp[i - coin] + 1) # Check if we found a valid solution for amount m return dp[m] if dp[m] != float('inf') else -1"},{"question":"def triangle_area(x1, y1, x2, y2, x3, y3): Calculate the area of a triangle given by coordinates (x1, y1), (x2, y2), (x3, y3). The points are given in a counter-clockwise order. >>> triangle_area(0, 0, 4, 0, 4, 3) 6.0 >>> triangle_area(1, 1, 5, 1, 3, 4) 6.0","solution":"def triangle_area(x1, y1, x2, y2, x3, y3): Calculate the area of a triangle given by coordinates (x1, y1), (x2, y2), (x3, y3). area = 0.5 * abs(x1*(y2 - y3) + x2*(y3 - y1) + x3*(y1 - y2)) return round(area, 1)"},{"question":"def max_books(N: int, books: List[int]) -> int: Returns the maximum number of books a participant can borrow by selecting a starting shelf and borrowing from subsequent shelves with an increasing number of books. >>> max_books(1, [5]) == 5 >>> max_books(2, [1, 2]) == 3 >>> max_books(2, [2, 1]) == 2 >>> max_books(4, [1, 2, 3, 4]) == 10 >>> max_books(4, [4, 3, 2, 1]) == 4 >>> max_books(5, [1, 3, 2, 5, 4]) == 9 >>> max_books(5, [1, 2, 1, 3, 2]) == 6 >>> max_books(5, [1, 2, 2, 3, 3]) == 6 >>> max_books(5, [5, 5, 5, 5, 5]) == 5","solution":"def max_books(N, books): Returns the maximum number of books a participant can borrow by selecting a starting shelf and borrowing from subsequent shelves with an increasing number of books. if N == 0: return 0 max_sum = [0] * N max_sum[0] = books[0] for i in range(1, N): max_sum[i] = books[i] for j in range(i): if books[i] > books[j]: max_sum[i] = max(max_sum[i], max_sum[j] + books[i]) return max(max_sum) # Example usage: # N = 5 # books = [1, 3, 2, 5, 4] # print(max_books(N, books)) # Output: 9"},{"question":"def process_operations(N, operations): Perform the operations on the toy mice and produce results for the query operations. >>> process_operations(5, [\\"swap 2 4\\", \\"query 3\\", \\"query 2\\"]) [3, 4] >>> process_operations(3, [\\"swap 1 3\\", \\"query 3\\"]) [1] >>> process_operations(4, [\\"swap 1 4\\", \\"swap 2 3\\", \\"query 1\\", \\"query 4\\", \\"query 2\\", \\"query 3\\"]) [4, 1, 3, 2] >>> process_operations(5, [\\"query 1\\", \\"query 2\\", \\"query 3\\", \\"query 4\\", \\"query 5\\"]) [1, 2, 3, 4, 5] >>> process_operations(2, [\\"swap 1 2\\", \\"query 1\\", \\"query 2\\"]) [2, 1]","solution":"def process_operations(N, operations): # Initialize the mice labels in sorted order mice = list(range(1, N+1)) results = [] for operation in operations: parts = operation.split() if parts[0] == 'swap': x, y = int(parts[1]), int(parts[2]) # Swap the mice labels at positions x-1 and y-1 mice[x-1], mice[y-1] = mice[y-1], mice[x-1] elif parts[0] == 'query': x = int(parts[1]) # Add the current label of the mouse to the results results.append(mice[x-1]) return results"},{"question":"def is_happy_number(n: int) -> int: Check if a given number n is a Happy Number. >>> is_happy_number(19) 1 >>> is_happy_number(4) 0 >>> is_happy_number(1) 1 >>> is_happy_number(10000) 1 >>> is_happy_number(9999) 0","solution":"def is_happy_number(n): def sum_of_squares(num): return sum(int(digit)**2 for digit in str(num)) seen_numbers = set() while n != 1 and n not in seen_numbers: seen_numbers.add(n) n = sum_of_squares(n) return 1 if n == 1 else 0"},{"question":"def check_word_in_grid(n: int, m: int, grid: List[str]) -> str: Determine whether there is a word of four consecutive identical letters in the grid, either horizontally or vertically. >>> check_word_in_grid(5, 5, [\\"abcde\\", \\"fghij\\", \\"kkkkl\\", \\"mnopq\\", \\"rstuv\\"]) 'YES' >>> check_word_in_grid(4, 3, [\\"abc\\", \\"def\\", \\"ghi\\", \\"jkl\\"]) 'NO'","solution":"def check_word_in_grid(n, m, grid): def check_horizontal(grid, n, m): for i in range(n): for j in range(m - 3): if grid[i][j] == grid[i][j + 1] == grid[i][j + 2] == grid[i][j + 3]: return True return False def check_vertical(grid, n, m): for j in range(m): for i in range(n - 3): if grid[i][j] == grid[i + 1][j] == grid[i + 2][j] == grid[i + 3][j]: return True return False if check_horizontal(grid, n, m) or check_vertical(grid, n, m): return \\"YES\\" else: return \\"NO\\""},{"question":"def first_negative_integer(lst: List[int]) -> int: Returns the first negative integer in the list. If there are no negative integers, return None. >>> first_negative_integer([3, 5, -2, 7, 8]) == -2 >>> first_negative_integer([1, 2, 3, 4, 5]) == None >>> first_negative_integer([-1, -2, -3, -4, -5]) == -1 >>> first_negative_integer([10]) == None >>> first_negative_integer([-10]) == -10 >>> first_negative_integer([]) == None >>> first_negative_integer([-1, 2, 3]) == -1 >>> first_negative_integer([5, 7, 8, -3]) == -3 # Write your code here","solution":"def first_negative_integer(lst): Returns the first negative integer in the list. If there are no negative integers, return None. for num in lst: if num < 0: return num return None"},{"question":"def minimum_longest_cable_length(n: int, matrix: List[List[int]]) -> int: Determine the minimum possible length of the longest cable segment in the network to connect all buildings. Args: n (int): The number of university buildings. matrix (List[List[int]]): A 2D list where the \`j-th\` integer in the \`i-th\` line represents the length of the cable required to connect building \`i\` to building \`j\`. Returns: int: The minimum possible length of the longest cable segment. Examples: >>> minimum_longest_cable_length(3, [ ... [0, 4, 3], ... [4, 0, 2], ... [3, 2, 0]]) 3 >>> minimum_longest_cable_length(4, [ ... [0, 1, 2, 3], ... [1, 0, 4, 5], ... [2, 4, 0, 6], ... [3, 5, 6, 0]]) 3 def test_case_1(): n = 3 matrix = [ [0, 4, 3], [4, 0, 2], [3, 2, 0] ] assert minimum_longest_cable_length(n, matrix) == 3 def test_case_2(): n = 4 matrix = [ [0, 1, 2, 3], [1, 0, 4, 5], [2, 4, 0, 6], [3, 5, 6, 0] ] assert minimum_longest_cable_length(n, matrix) == 3 def test_case_3(): n = 2 matrix = [ [0, 7], [7, 0] ] assert minimum_longest_cable_length(n, matrix) == 7 def test_case_4(): n = 5 matrix = [ [0, 2, 3, 4, 5], [2, 0, 4, 6, 8], [3, 4, 0, 7, 9], [4, 6, 7, 0, 1], [5, 8, 9, 1, 0] ] assert minimum_longest_cable_length(n, matrix) == 4","solution":"def minimum_longest_cable_length(n, matrix): import heapq def prim(): visited = [False] * n min_heap = [(0, 0)] # (weight, vertex) max_edge_in_mst = 0 while min_heap: weight, u = heapq.heappop(min_heap) if visited[u]: continue visited[u] = True max_edge_in_mst = max(max_edge_in_mst, weight) for v in range(n): if not visited[v] and matrix[u][v] > 0: heapq.heappush(min_heap, (matrix[u][v], v)) return max_edge_in_mst return prim()"},{"question":"def count_pairs_with_sum(N: int, T: int, sequence: List[int]) -> int: This function counts the number of unique pairs (i, j) where i != j and sequence[i] + sequence[j] == T. Parameters: N : int : the length of the sequence T : int : the target sum sequence : List[int] : the elements of the sequence Returns: int : the number of pairs that add up to the target sum Examples: >>> count_pairs_with_sum(5, 9, [2, 7, 11, 15, 1]) 1 >>> count_pairs_with_sum(4, 10, [4, 6, 3, 7]) 2","solution":"def count_pairs_with_sum(N, T, sequence): This function counts the number of unique pairs (i, j) where i != j and sequence[i] + sequence[j] == T. count = 0 seen = {} for number in sequence: complement = T - number if complement in seen and seen[complement] > 0: count += seen[complement] if number in seen: seen[number] += 1 else: seen[number] = 1 return count"},{"question":"def count_elements_appear_twice(n: int, a: List[int]) -> int: Returns the number of distinct elements that appear exactly twice in the array. >>> count_elements_appear_twice(7, [4, 3, 2, 7, 3, 2, 2]) 1 >>> count_elements_appear_twice(10, [1, 1, 2, 3, 4, 4, 5, 5, 5, 6]) 2","solution":"def count_elements_appear_twice(n, a): Returns the number of distinct elements that appear exactly twice in the array. from collections import Counter element_count = Counter(a) count_appear_twice = 0 for count in element_count.values(): if count == 2: count_appear_twice += 1 return count_appear_twice"},{"question":"from typing import List, Tuple def sum_of_nodes_with_no_sibling(n: int, edges: List[Tuple[int, int]]) -> int: Calculate the sum of the values of all nodes in a binary tree that do not have a sibling. >>> sum_of_nodes_with_no_sibling(5, [(1, 2), (1, 3), (2, 4), (2, 5)]) 0 >>> sum_of_nodes_with_no_sibling(5, [(1, 2), (2, 3), (3, 4), (4, 5)]) 14 >>> sum_of_nodes_with_no_sibling(3, [(1, 2), (2, 3)]) 5 >>> sum_of_nodes_with_no_sibling(1, []) 1 >>> sum_of_nodes_with_no_sibling(7, [(1, 2), (1, 3), (2, 4), (2, 5), (3, 6), (3, 7)]) 0 >>> sum_of_nodes_with_no_sibling(4, [(1, 2), (2, 3), (3, 4)]) 9","solution":"def sum_of_nodes_with_no_sibling(n, edges): from collections import defaultdict, deque # Degenerate case if n == 1: return 1 # Building the adjacency list adj_list = defaultdict(list) for u, v in edges: adj_list[u].append(v) adj_list[v].append(u) # To keep track of parents and visited nodes visited = [False] * (n + 1) parent = [0] * (n + 1) # BFS to determine parent-child relationships q = deque([1]) visited[1] = True while q: node = q.popleft() for neighbor in adj_list[node]: if not visited[neighbor]: visited[neighbor] = True parent[neighbor] = node q.append(neighbor) # Finding nodes with no siblings node_count = defaultdict(int) for i in range(2, n + 1): node_count[parent[i]] += 1 no_sibling_sum = 0 for i in range(2, n + 1): if node_count[parent[i]] == 1: no_sibling_sum += i return no_sibling_sum"}]`),E={name:"App",components:{PoemCard:R},data(){return{searchQuery:"",visibleCount:4,poemsData:j,isLoading:!1}},computed:{filteredPoems(){const i=this.searchQuery.trim().toLowerCase();return i?this.poemsData.filter(e=>e.question&&e.question.toLowerCase().includes(i)||e.solution&&e.solution.toLowerCase().includes(i)):this.poemsData},displayedPoems(){return this.searchQuery.trim()?this.filteredPoems:this.filteredPoems.slice(0,this.visibleCount)},hasMorePoems(){return!this.searchQuery.trim()&&this.visibleCount<this.poemsData.length}},methods:{async loadMore(){this.isLoading=!0,await new Promise(i=>setTimeout(i,1e3)),this.visibleCount+=4,this.isLoading=!1}}},S={class:"search-container"},D={class:"card-container"},C={key:0,class:"empty-state"},z=["disabled"],O={key:0},Y={key:1};function B(i,e,u,c,r,a){const f=h("PoemCard");return s(),n("section",null,[e[4]||(e[4]=t("div",{class:"top-banner"},[t("div",{class:"top-banner-title"},[t("div",{class:"top-banner-title-text"},"🤔prompts chat🧠")])],-1)),t("div",S,[e[3]||(e[3]=t("span",{class:"search-icon"},"🔍",-1)),g(t("input",{type:"text",class:"search-input","onUpdate:modelValue":e[0]||(e[0]=o=>r.searchQuery=o),placeholder:"Search..."},null,512),[[b,r.searchQuery]]),r.searchQuery?(s(),n("button",{key:0,class:"clear-search",onClick:e[1]||(e[1]=o=>r.searchQuery="")}," ✕ ")):l("",!0)]),t("div",D,[(s(!0),n(x,null,y(a.displayedPoems,(o,p)=>(s(),v(f,{key:p,poem:o},null,8,["poem"]))),128)),a.displayedPoems.length===0?(s(),n("div",C,' No results found for "'+_(r.searchQuery)+'". ',1)):l("",!0)]),a.hasMorePoems?(s(),n("button",{key:0,class:"load-more-button",disabled:r.isLoading,onClick:e[2]||(e[2]=(...o)=>a.loadMore&&a.loadMore(...o))},[r.isLoading?(s(),n("span",Y,"Loading...")):(s(),n("span",O,"See more"))],8,z)):l("",!0)])}const P=m(E,[["render",B],["__scopeId","data-v-b441af1a"]]),M=JSON.parse('{"title":"","description":"","frontmatter":{"page":true},"headers":[],"relativePath":"guide/21.md","filePath":"guide/21.md"}'),F={name:"guide/21.md"},G=Object.assign(F,{setup(i){return(e,u)=>(s(),n("div",null,[w(P)]))}});export{M as __pageData,G as default};
