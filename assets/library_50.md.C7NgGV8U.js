import{_ as c,o as n,c as i,a as t,m as h,t as d,C as g,M as _,U as y,f as u,F as b,p as v,e as w,q as x}from"./chunks/framework.B1z0IdBH.js";const k={name:"PoemCard",props:{poem:{type:Object,required:!0}}},T={class:"poem-container"},q={class:"review"},I={class:"review-title"},N={class:"review-content"};function E(r,e,l,p,s,a){return n(),i("div",T,[t("div",q,[t("div",I,[e[0]||(e[0]=t("span",{class:"icon"},"question:",-1)),h(d(l.poem.question),1)]),e[2]||(e[2]=t("div",{class:"divider"},null,-1)),t("p",N,[e[1]||(e[1]=t("span",{class:"icon"},"answer:",-1)),h(d(l.poem.solution),1)])])])}const A=c(k,[["render",E],["__scopeId","data-v-49de9d95"]]),O=JSON.parse('[{"question":"# Coding Exercise: Implement Enhanced Radix Sort Context You have been tasked with sorting a large list of non-negative integers efficiently. The existing sorting algorithms are either too slow for large inputs or not well-suited for integers with a variable number of digits. Radix sort, with its digit-centric approach, presents an optimal solution for this problem. Task Implement an enhanced version of the Radix Sort that sorts a list of non-negative integers. Your implementation should handle edge cases efficiently and minimize memory usage where possible. Constraints - Input will always be a list of non-negative integers. - The list can be of length up to (10^5). - Each integer in the list will have at most (6) digits. Function Signature ```python def enhanced_radix_sort(arr: List[int]) -> List[int]: ``` Input - `arr`: A list of non-negative integers to be sorted. Output - A list of integers sorted in ascending order. Requirements - Achieve time complexity of O(nk), where (n) is the number of integers and (k) is the maximum number of digits in any integer. - Minimize space complexity where possible. Example ```python # Example 1 input_list = [170, 45, 75, 90, 802, 24, 2, 66] print(enhanced_radix_sort(input_list)) # Output: [2, 24, 45, 66, 75, 90, 170, 802] # Example 2 input_list = [333, 3, 5555, 55, 5] print(enhanced_radix_sort(input_list)) # Output: [3, 5, 55, 333, 5555] # Example 3 input_list = [0, 10, 200, 3000] print(enhanced_radix_sort(input_list)) # Output: [0, 10, 200, 3000] ``` Additional Constraints - Do not use built-in sorting functions. - Handle optimizations to reduce unnecessary memory usage. - Include error handling for unusual cases cleanly.","solution":"def enhanced_radix_sort(arr): Sorts a list of non-negative integers using Radix Sort. :param arr: List of non-negative integers :return: List of integers sorted in ascending order if len(arr) == 0: return arr max_num = max(arr) exp = 1 while max_num // exp > 0: counting_sort(arr, exp) exp *= 10 return arr def counting_sort(arr, exp): A utility function to perform counting sort on arr[] using digit at place exp :param arr: List of non-negative integers :param exp: Current digit\'s place (1, 10, 100, ...) n = len(arr) output = [0] * n count = [0] * 10 # Since the digits are 0 to 9 # Store count of occurrences in count[] for i in range(n): index = (arr[i] // exp) % 10 count[index] += 1 # Change count[i] so that count[i] now contains actual position of this digit in output[] for i in range(1, 10): count[i] += count[i - 1] # Build the output array i = n - 1 while i >= 0: index = (arr[i] // exp) % 10 output[count[index] - 1] = arr[i] count[index] -= 1 i -= 1 # Copying the output array to arr[], so that arr now contains sorted numbers according to current digit for i in range(n): arr[i] = output[i]"},{"question":"# Problem: Optimal Value Packing Context You are designing a utility for a shipping company that helps optimize the packing of high-value items into fixed-capacity crates to maximize the total value while not exceeding the given weight capacity of the crate. The problem is a variation of the well-known 0/1 Knapsack Problem. Task Given: - A list of items, each defined by its value and weight. - A fixed capacity of the crate. Write a Python function `optimal_value_packing` that determines and returns the maximum possible value that can be obtained by selecting items without exceeding the crate\'s weight capacity. Input - A list of tuples, `items`, where each tuple `(value, weight)` represents the value and weight of an item. - An integer `capacity` representing the maximum weight capacity of the crate. Output - An integer representing the maximum total value achievable. Constraints - `1 <= len(items) <= 100` (number of items) - `0 <= capacity <= 1000` (crate\'s capacity) - `1 <= value, weight <= 1000` (values and weights of items) Example ```python # Example 1 items = [(60, 10), (100, 20), (120, 30)] capacity = 50 print(optimal_value_packing(items, capacity)) # Output: 220 # Example 2 items = [(60, 5), (50, 3), (70, 4), (30, 2)] capacity = 5 print(optimal_value_packing(items, capacity)) # Output: 80 ``` Notes Implement the function efficiently keeping in mind the provided constraints. Edge cases mentioned in the analysis are relevant, such as items with zero value or weight, and scenarios with zero capacity.","solution":"def optimal_value_packing(items, capacity): Determine the maximum value achievable without exceeding the weight capacity of the crate. Args: items (list of tuples): Each tuple (value, weight) represents the value and weight of an item. capacity (int): The maximum weight capacity of the crate. Returns: int: The maximum total value achievable. # Define DP array where dp[w] will store the maximum value for capacity w dp = [0] * (capacity + 1) # Iterate through the items for value, weight in items: # Update the dp array in a reversed order to prevent overwriting values for w in range(capacity, weight - 1, -1): dp[w] = max(dp[w], dp[w - weight] + value) return dp[capacity]"},{"question":"# Problem: Detecting and Removing Loop in a Linked List You are given a singly linked list, which might contain a loop. Your task is to detect the presence of a loop and remove it if it exists. Write a function `detect_and_remove_loop(head)` that accomplishes this. # Function Signature ```python def detect_and_remove_loop(head: Node) -> None: ``` # Input * `head`: The head node of the singly linked list. - Each node has a `.val` attribute storing an integer value. - Each node has a `.next` attribute pointing to the next node or `None`. # Output * Modify the linked list, so any existing loop is removed. * If there is no loop in the list, the list remains unmodified. # Constraints * Do not use any extra space (O(1) space complexity). * Solve the problem in linear time (O(N) time complexity). # Example 1. Given the following linked list (Note: 2 -> 3 -> 4 creates a loop back to 2): ``` 1 -> 2 -> 3 -> 4 -> 2 ``` After calling `detect_and_remove_loop(head)`, the linked list should be: ``` 1 -> 2 -> 3 -> 4 -> None ``` # Guidelines * Detecting a loop can be done using Floyd’s Cycle-Finding Algorithm (also known as hare and tortoise algorithm). * After detecting the loop, you need to find the starting point of the loop and set the `.next` of the loop\'s last node to `None`.","solution":"class Node: def __init__(self, val=0, next=None): self.val = val self.next = next def detect_and_remove_loop(head: Node) -> None: if not head or not head.next: return slow = head fast = head # Step 1: Detect loop using Floyd’s Cycle-Finding Algorithm while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: break # If no loop detected, return if slow != fast: return # Step 2: Find the start of the loop slow = head while slow != fast: slow = slow.next fast = fast.next # Step 3: Remove the loop # To remove the loop, we need to find the node just before the start of the loop loop_start = slow while fast.next != loop_start: fast = fast.next fast.next = None"},{"question":"You are tasked with implementing an enhanced version of an anagram checker. This version should be versatile, handling various edge cases and supporting characters beyond lowercase English letters. Problem Scenario: Your friend, a book store manager, needs a tool that can verify if two given book titles are anagrams, regardless of capitalization and including punctuation. Write a function that checks if two strings (titles) are anagrams of each other considering any kind of characters. The function should ignore spaces and capitalization. Function Signature: ```python def are_anagrams(title1: str, title2: str) -> bool: ``` Input: * `title1` (str): The first book title to compare. * `title2` (str): The second book title to compare. Output: * `bool`: Returns `True` if `title1` and `title2` are anagrams of each other, `False` otherwise. Constraints: * The function should handle special characters, spaces, and capitalization correctly. * The function should run efficiently even for longer titles (up to 1000 characters). Example: ```python assert are_anagrams(\\"The Eyes\\", \\"They See\\") == True assert are_anagrams(\\"Hello, World!\\", \\"dlroW ,olleH\\") == True assert are_anagrams(\\"Astronomers\\", \\"No more stars\\") == True assert are_anagrams(\\"Hello\\", \\"Hi\\") == False ``` Note: To design an efficient solution, consider using dictionaries or collections to manage character counts for any character, and pay attention to case insensitivity and ignoring spaces/punctuation.","solution":"import string def are_anagrams(title1: str, title2: str) -> bool: Check if two book titles are anagrams of each other, ignoring spaces, punctuation, and case. def clean_string(s: str) -> str: return \'\'.join(c.lower() for c in s if c in string.ascii_letters) cleaned_title1 = clean_string(title1) cleaned_title2 = clean_string(title2) return sorted(cleaned_title1) == sorted(cleaned_title2)"},{"question":"# Question: Implementation of a Simplified Diffie-Hellman Key Exchange You have been provided with the basis of the Diffie-Hellman key exchange algorithm principles. Your task is to implement a simplified version of the Diffie-Hellman key exchange process by following the guidelines provided. # Instructions: 1. Implement the function `simplified_diffie_hellman_key_exchange(a: int, p: int) -> bool`. 2. This function will simulate a Diffie-Hellman key exchange between two users: * **a**: a base number (must be a primitive root of `p`). * **p**: a prime number. The validation of the prime number `p` and the base `a` being a primitive root will be checked within your code. # Requirements: 1. **Input Constraints**: * (2 leq p leq 10^6) * (2 leq a < p) 2. **Output**: * The function should return `True` if the shared secret keys computed by both sides (Alice and Bob) are equal. Otherwise, return `False`. 3. **Implementation Steps**: * Verify if `p` is a prime number. * Verify if `a` is a primitive root of `p`. * Generate random private keys for both Alice and Bob. * Compute respective public keys. * Perform the key exchange and compute the shared secret keys. * Compare the shared keys and return the result. 4. **Function Signature**: ```python def simplified_diffie_hellman_key_exchange(a: int, p: int) -> bool: pass ``` # Example: ```python # Example test case print(simplified_diffie_hellman_key_exchange(3, 17)) # Output: True (if the shared keys calculated by Alice and Bob match) ``` # Notes: - Consider appropriate validation and error handling for the inputs. - You can use helper functions to manage specific parts of the task (like prime checking, primitive root finding, etc.) - Ensure that the algorithm is efficient and can handle the upper limits of the constraints.","solution":"from sympy import isprime from random import randint def gcd(a, b): while b: a, b = b, a % b return a def is_primitive_root(a, p): if not isprime(p): return False required_set = set(num for num in range(1, p) if gcd(num, p) == 1) actual_set = set(pow(a, powers, p) for powers in range(1, p)) return required_set == actual_set def simplified_diffie_hellman_key_exchange(a: int, p: int) -> bool: if not (2 <= p <= 10**6) or not (2 <= a < p): raise ValueError(\\"Input values are out of constraint bounds.\\") if not isprime(p): raise ValueError(\\"p is not a prime number.\\") if not is_primitive_root(a, p): raise ValueError(\\"a is not a primitive root of p.\\") # Generate private keys for Alice and Bob private_key_alice = randint(2, p-2) private_key_bob = randint(2, p-2) # Compute public keys public_key_alice = pow(a, private_key_alice, p) public_key_bob = pow(a, private_key_bob, p) # Compute shared secret keys shared_key_alice = pow(public_key_bob, private_key_alice, p) shared_key_bob = pow(public_key_alice, private_key_bob, p) return shared_key_alice == shared_key_bob"},{"question":"# Advanced Coding Challenge: Enhanced Histogram Calculation with Constraints **Scenario**: You are tasked with extending and optimizing the histogram function for a large-scale data processing application. The input list can be extremely large, and performance is critical. Additionally, only the top `k` most frequent elements should be included in the final histogram result to minimize memory usage. # Problem Statement Implement a function `get_top_k_histogram(input_list: list, k: int) -> dict` that calculates a histogram of the input list but only includes the top `k` most frequent elements. # Function Signature ```python def get_top_k_histogram(input_list: list, k: int) -> dict: ... ``` # Input - `input_list` (list): A list of integers that can contain millions of elements. - `k` (int): The number of top frequent elements to include in the histogram. `1 <= k <= len(input_list)` # Output - (dict): A dictionary where the keys are the `k` most frequent elements in `input_list`, and the values are their respective counts. # Constraints 1. The input list can be of any length, including zero. 2. The function should handle large input lists efficiently. 3. The implementation should not use more memory than necessary. # Example ```python input_list = [2, 3, 5, 5, 5, 6, 4, 3, 7] k = 2 # Expected output: {5: 3, 3: 2} input_list = [1, 1, 1, 1, 2, 2, 3] k = 1 # Expected output: {1: 4} ``` # Performance Requirements - The function should aim for a linear time complexity, O(n). - It should efficiently handle memory usage, especially for large lists with many unique elements. # Notes - Ties should be handled by selecting any of the tied elements to be in the top `k`. - Consider using appropriate data structures to achieve the required performance. Implement the `get_top_k_histogram` function following these guidelines.","solution":"from collections import Counter def get_top_k_histogram(input_list, k): Calculates the histogram of the input list but includes only the top k most frequent elements. :param input_list: List of integers. :param k: The number of top frequent elements to include in the histogram. :return: A dictionary where keys are the top k most frequent elements and values are their counts. if not input_list or k <= 0: return {} # Use Counter to get frequency of each element freq_counter = Counter(input_list) # Extract the k most common elements top_k = freq_counter.most_common(k) return dict(top_k)"},{"question":"# Question: Transitive Closure of a Directed Graph Given a directed graph, implement an algorithm to find its transitive closure. The transitive closure of a graph is a matrix where element (i, j) is true if there is a path from vertex i to vertex j in the graph. # Inputs: 1. An integer `n` representing the number of vertices in the graph. 2. A list of tuples of integers representing the directed edges, where each tuple (u, v) represents a directed edge from vertex `u` to vertex `v`. # Outputs: * Return a 2D list (matrix) representing the transitive closure of the given graph, where element (i, j) is 1 if there is a path from vertex i to vertex j, otherwise it is 0. # Constraints: * 1 ≤ n ≤ 1000 * The number of edges can be up to n * (n - 1). # Performance: * Expected time complexity is O(n^3) in the average and worst case scenarios. # Example: Input: ```python n = 4 edges = [(0, 1), (1, 2), (2, 3)] ``` Output: ```python [ [1, 1, 1, 1], [0, 1, 1, 1], [0, 0, 1, 1], [0, 0, 0, 1] ] ``` In the above example, vertex 0 can reach all other vertices directly or indirectly, and similarly illustrated for other vertices. # Implementation Instructions: * Implement a class `Graph` that: - Initializes with number of vertices. - Has a method `add_edge` to add a directed edge. - Has a method `transitive_closure` that returns the closure matrix. * Implement helper methods as needed. # Note: Write clean, efficient, and well-documented code. Make sure to handle edge cases as discussed and provide appropriate test cases.","solution":"class Graph: def __init__(self, n): self.n = n self.adj_matrix = [[0] * n for _ in range(n)] def add_edge(self, u, v): self.adj_matrix[u][v] = 1 def transitive_closure(self): # Initialize the closure matrix same as the adjacency matrix initially. closure = [[self.adj_matrix[i][j] for j in range(self.n)] for i in range(self.n)] # Each vertex should reach itself for i in range(self.n): closure[i][i] = 1 # Floyd-Warshall algorithm to find transitive closure for k in range(self.n): for i in range(self.n): for j in range(self.n): closure[i][j] = closure[i][j] or (closure[i][k] and closure[k][j]) return closure"},{"question":"Scenario You are working on a project that involves maintaining a dynamically changing collection of sorted records. You need to frequently add, search, and delete records based on certain keys. The records are organized in a Binary Search Tree (BST) for efficient operations. Task Write a function `delete_node` that deletes a node with a given key from a BST and returns the new root of the BST. Your function should maintain the properties of the BST after deletion. Input and Output Formats - **Input**: * `root`: A reference to the root node of the BST. Nodes are defined as `TreeNode` with properties `val`, `left`, and `right`. * `key`: An integer key representing the value of the node to be deleted. - **Output**: A reference to the new root of the BST. Constraints - The number of nodes in the tree is in the range `[0, 10^4]`. - Each node\'s value is unique. - `root` is a reference to the root node of the BST, which can be `None` if the tree is empty. - `key` is an integer found in the tree. Example ```python # Example 1: root = [5,3,6,2,4,null,7] key = 3 # Expected Output: [5,4,6,2,null,null,7] # Example 2: root = [5,3,6,2,4,null,7] key = 5 # Expected Output: [6,3,7,2,4] ``` Detailed Requirements 1. Implement the function `delete_node(root: TreeNode, key: int) -> TreeNode`. 2. Ensure the BST properties remain valid after the deletion. 3. Handle edge cases such as deleting the root, a node with one child, or a node with two children. Function Signature ```python class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None class Solution: def delete_node(self, root: TreeNode, key: int) -> TreeNode: # Write your solution here pass ```","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None class Solution: def delete_node(self, root: TreeNode, key: int) -> TreeNode: if not root: return root # Search for the node to delete if key < root.val: root.left = self.delete_node(root.left, key) elif key > root.val: root.right = self.delete_node(root.right, key) else: # Node with only one child or no child if not root.left: return root.right elif not root.right: return root.left # Node with two children: Get the inorder successor (smallest in the right subtree) min_larger_node = self._find_min(root.right) root.val = min_larger_node.val # Delete the inorder successor root.right = self.delete_node(root.right, min_larger_node.val) return root def _find_min(self, node): current = node while current.left is not None: current = current.left return current"},{"question":"Custom FizzBuzz You are required to implement a function that simulates the FizzBuzz game with a customizable set of rules. Your function should take three parameters: an upper limit `n`, and two dictionaries `rules` and `replacements`. 1. **The parameter `n`** is the upper limit integer (greater than or equal to 1). 2. **The dictionary `rules`** will contain integers as keys and their modulus value as the values. For example, {3: \\"Fizz\\", 5: \\"Buzz\\"} implies any number divisible by 3 should be replaced with \\"Fizz\\", and any number divisible by 5 should be replaced with \\"Buzz\\". 3. **The dictionary `replacements`** will contain tuples of integers as keys (representing multiples) and their respective replacement strings as the values. For example, {(3, 5): \\"FizzBuzz\\"} implies any number divisible by both 3 and 5 should be replaced with \\"FizzBuzz\\". Your task is to generate a list of length `n` where numbers have been replaced according to the provided rules. # Function Signature: ```python def custom_fizzbuzz(n: int, rules: dict, replacements: dict) -> list: pass ``` # Example: ```python custom_fizzbuzz(15, {3: \\"Fizz\\", 5: \\"Buzz\\"}, {(3, 5): \\"FizzBuzz\\"}) ``` Should return: ```python [1, 2, \'Fizz\', 4, \'Buzz\', \'Fizz\', 7, 8, \'Fizz\', \'Buzz\', 11, \'Fizz\', 13, 14, \'FizzBuzz\'] ``` # Constraints: * `1 <= n <= 10^6` * `rules` and `replacements` dictionaries will only contain positive integers and strings. * If multiple replacements apply to a single number, replacements in `replacements` dictionary have higher priority compared to `rules`. # Requirements: * The solution should be efficient and handle large values of `n` up to 10^6. * The code should do appropriate error handling for invalid inputs. * Aim for clean, readable, and maintainable code. # Additional Notes: * Consider edge cases like no replacement rules or modulus values that do not divide any numbers in the range. * Make sure to test the function thoroughly with various inputs to ensure the accuracy.","solution":"def custom_fizzbuzz(n: int, rules: dict, replacements: dict) -> list: Generates a list of length n where numbers are replaced according to given rules and replacements. :param n: Upper limit integer (inclusive). :param rules: Dictionary with integers as keys and their replacement strings as values. :param replacements: Dictionary with tuples of integers as keys and their replacement strings as values. :return: List with numbers replaced as per the defined rules and replacements. result = [] for i in range(1, n + 1): replaced = False for key, value in replacements.items(): if all(i % k == 0 for k in key): result.append(value) replaced = True break if not replaced: for key, value in rules.items(): if i % key == 0: result.append(value) replaced = True break if not replaced: result.append(i) return result"},{"question":"Context You are tasked with developing software to manage a system of processes and resources, and to ensure that process dependencies do not lead to deadlocks. A deadlock occurs if there is a cycle in the resource allocation graph. Your task is to write a function that detects cycles in such graphs. Problem Statement Write a function `detect_cycle(graph)` that checks whether a given directed graph contains a cycle. The graph is represented as a dictionary where keys are nodes and values are lists of nodes to which there are directed edges. Function Signature ```python def detect_cycle(graph: Dict[str, List[str]]) -> bool: pass ``` Input - `graph`: A dictionary mapping vertices (strings) to lists of adjacent vertices (strings). Output - Returns `True` if there is at least one cycle in the graph. - Returns `False` otherwise. Constraints - The graph is directed. - There are no parallel edges or self-loops. - The graph can potentially be disconnected. - The graph may contain up to 1000 nodes and 2000 edges. Example ```python graph = { \'A\': [\'B\', \'C\'], \'B\': [\'D\'], \'C\': [\'F\'], \'D\': [\'E\', \'F\'], \'E\': [\'B\'], \'F\': [] } assert detect_cycle(graph) == True graph2 = { \'A\': [], \'B\': [], \'C\': [] } assert detect_cycle(graph2) == False ``` Notes - Ensure that your implementation can handle large inputs efficiently. - Make sure to consider all edge cases as described in the analysis. - Pay attention to the correct initialization and updating of traversal states.","solution":"def detect_cycle(graph): Returns True if there is a cycle in the graph, False otherwise. WHITE, GRAY, BLACK = 0, 1, 2 color = {node: WHITE for node in graph} def dfs(node): if color[node] == GRAY: return True if color[node] == BLACK: return False color[node] = GRAY for neighbor in graph[node]: if dfs(neighbor): return True color[node] = BLACK return False for node in graph: if color[node] == WHITE: if dfs(node): return True return False"},{"question":"You are tasked with creating conversion utilities to transform integers to their byte representation and vice versa using both big-endian and little-endian formats. Implement these functions with the following detailed requirements: Function 1: `int_to_bytes(num: int, endian: str) -> bytes` Converts an integer to its byte representation. * **Input**: - `num` (int): The integer to be converted. Assume `num >= 0`. - `endian` (str): The byte order format. It will be either `\\"big\\"` for big-endian or `\\"little\\"` for little-endian. * **Output**: - A byte sequence (`bytes`). * **Constraints**: - The output should be minimal (no leading zero bytes). - Handle the case when `num` is `0`, and return `b\'\'` (empty bytes). Function 2: `bytes_to_int(bytestr: bytes, endian: str) -> int` Converts a byte sequence back to its integer representation. * **Input**: - `bytestr` (bytes): The byte sequence to be converted. - `endian` (str): The byte order format used in `bytestr`. It will be either `\\"big\\"` or `\\"little\\"`. * **Output**: - An integer (`int`). * **Constraints**: - Handle empty byte sequences appropriately and return `0`. # Example ```python # Example 1 print(int_to_bytes(305419896, \\"big\\")) # Output: b\'x12x34x56x78\' print(int_to_bytes(305419896, \\"little\\")) # Output: b\'x78x56x34x12\' # Example 2 print(bytes_to_int(b\'x12x34x56x78\', \\"big\\")) # Output: 305419896 print(bytes_to_int(b\'x78x56x34x12\', \\"little\\")) # Output: 305419896 ``` # Explanation In the first example `int_to_bytes(305419896, \\"big\\")` converts `305419896` to its big-endian byte representation resulting in `b\'x12x34x56x78\'`. The little-endian representation flips the order of the bytes yielding `b\'x78x56x34x12\'`. In the second example, the byte sequences `b\'x12x34x56x78\'` and `b\'x78x56x34x12\'` are converted back to their integer representation using big-endian and little-endian formats respectively resulting in the same integer `305419896`. # Requirements * You must implement the solution within a time complexity of O(N), where N is the length of the byte sequence or the number of bytes required to represent the integer. * You should not use any built-in Python functions for direct conversion (e.g., `int.to_bytes()`, `int.from_bytes()`) to demonstrate full understanding and control of bitwise operations.","solution":"def int_to_bytes(num: int, endian: str) -> bytes: Converts an integer to its byte representation based on the specified endian format. :param num: The integer to be converted. Assume num >= 0. :param endian: The byte order format. It will be either \\"big\\" for big-endian or \\"little\\" for little-endian. :return: A byte sequence (bytes). if num == 0: return b\'\' result = bytearray() while num > 0: result.append(num & 0xff) num >>= 8 if endian == \'big\': result.reverse() return bytes(result) def bytes_to_int(bytestr: bytes, endian: str) -> int: Converts a byte sequence back to its integer representation based on the specified endian format. :param bytestr: The byte sequence to be converted. :param endian: The byte order format used in bytestr. It will be either \\"big\\" or \\"little\\". :return: An integer. result = 0 if endian == \'big\': bytestr = bytestr[::-1] for i, byte in enumerate(bytestr): result |= byte << (i * 8) return result"},{"question":"# Problem Description: You are tasked to detect if a given string can be constructed by repeating a smaller substring multiple times. Write a function to perform this check efficiently. # Detailed Requirements: Function Definition: `def repeat_substring(s):` * **Input**: A single string `s` (1 <= len(s) <= 10^5). * **Output**: A boolean value indicating whether `s` can be constructed by repeating a substring. # Examples: 1. **Input**: `\\"abab\\"` * **Output**: `True` * **Explanation**: The string \\"abab\\" can be constructed by repeating the substring \\"ab\\" twice. 2. **Input**: `\\"aba\\"` * **Output**: `False` * **Explanation**: The string \\"aba\\" cannot be constructed by repeating any smaller substring. 3. **Input**: `\\"abcabcabcabc\\"` * **Output**: `True` * **Explanation**: The string \\"abcabcabcabc\\" can be constructed by repeating the substring \\"abc\\" four times. # Constraints & Performance: * The function should operate efficiently within the provided input constraints. * Aim for O(n) time complexity, where n is the length of the string. * Handle edge cases and non-obvious inputs gracefully. # Evaluation Criteria: * Correctness: Ensure the function returns the correct boolean value for various inputs. * Efficiency: Ensure the solution adheres to the expected time and space complexity.","solution":"def repeat_substring(s): Determine if the string can be constructed by repeating a smaller substring multiple times. if not s: return False doubled_s = s + s # We remove the first and last characters from doubled_s. # If there is any repetition pattern, the original string s should be found within this modified string. return s in doubled_s[1:-1]"},{"question":"Problem Statement You are given the capacity matrix of a directed graph, along with a source and sink node. The objective is to find the maximum flow from the source to the sink using Dinic\'s Algorithm. Your task is to implement the Dinic\'s algorithm as described below to find the maximum flow. # Dinic\'s Algorithm 1. Construct a layered graph using BFS where all edges in the same layer are at most one level deeper than their parent. 2. Use DFS to send as much flow as possible through the layered graph. 3. Repeat the process until no more augmenting paths can be found. # Input Format - `capacity`: A two-dimensional list where `capacity[i][j]` represents the capacity of the edge from node `i` to node `j` (0 if no edge exists). - `source`: An integer representing the source node. - `sink`: An integer representing the sink node. # Output Format - An integer representing the maximum flow from the source to the sink. # Constraints - All nodes will have at least one outgoing or incoming edge. - `0 <= capacity[i][j] <= 1e5` - The number of vertices (V) in the graph will be such that (2 leq V leq 1000). # Performance Requirements - The implementation should run efficiently within the provided constraints. # Example ```python capacity = [ [0, 10, 10, 0, 0, 0], [0, 0, 2, 4, 8, 0], [0, 0, 0, 0, 9, 0], [0, 0, 0, 0, 0, 10], [0, 0, 0, 6, 0, 10], [0, 0, 0, 0, 0, 0] ] source = 0 sink = 5 ``` # Expected Output ``` 19 ``` **Implement the `dinic` function in Python to solve the problem.** ```python def dinic(capacity, source, sink): # Implement Dinic\'s algorithm here pass # Test the implementation capacity = [ [0, 10, 10, 0, 0, 0], [0, 0, 2, 4, 8, 0], [0, 0, 0, 0, 9, 0], [0, 0, 0, 0, 0, 10], [0, 0, 0, 6, 0, 10], [0, 0, 0, 0, 0, 0] ] source = 0 sink = 5 print(dinic(capacity, source, sink)) # Expected output: 19 ```","solution":"from collections import deque def bfs_capacity_level(capacity, source, sink, level): Build a level graph using BFS. V = len(capacity) level[:] = [-1] * V level[source] = 0 queue = deque([source]) while queue: u = queue.popleft() for v in range(V): if level[v] < 0 and capacity[u][v] > 0: level[v] = level[u] + 1 queue.append(v) if v == sink: return True return False def dfs_capacity_flow(capacity, u, sink, flow, start, level): Use DFS to find an augmenting path and send flow. if u == sink: return flow V = len(capacity) while start[u] < V: v = start[u] if level[v] == level[u] + 1 and capacity[u][v] > 0: min_cap = min(flow, capacity[u][v]) aug_flow = dfs_capacity_flow(capacity, v, sink, min_cap, start, level) if aug_flow > 0: capacity[u][v] -= aug_flow capacity[v][u] += aug_flow return aug_flow start[u] += 1 return 0 def dinic(capacity, source, sink): Implements Dinic\'s Algorithm to find the maximum flow from source to sink. V = len(capacity) level = [-1] * V max_flow = 0 while bfs_capacity_level(capacity, source, sink, level): start = [0] * V while True: flow = dfs_capacity_flow(capacity, source, sink, float(\'Inf\'), start, level) if flow == 0: break max_flow += flow return max_flow"},{"question":"# Problem Description In this task, you are required to implement an extended stack data structure with additional functionalities to assess your understanding of fundamental and advanced concepts of the Stack ADT. You will implement a class `ExtendedStack` that inherits from the `ArrayStack` class and adds two new methods: `min()` which returns the minimum element in the stack, and `sort()` which sorts the elements of the stack in ascending order. # Requirements 1. **ExtendedStack Class**: - Inherits the `ArrayStack` class provided in the code snippet. - Adds the `min()` and `sort()` methods. 2. **Methods**: * **min()**: - **Input**: No parameters - **Output**: Returns the minimum element in the stack (`int` type). - **Constraints**: Raise an `IndexError` with message \\"Stack is empty\\" if the stack is empty. * **sort()**: - **Input**: No parameters - **Output**: Modifies the stack such that its elements are sorted in ascending order. - **Constraints**: Should preserve the LIFO order after sorting. # Function Signatures ```python class ExtendedStack(ArrayStack): def min(self) -> int: # Your implementation here pass def sort(self): # Your implementation here pass ``` # Example ```python # Example usage stack = ExtendedStack(size=5) stack.push(3) stack.push(5) stack.push(1) stack.push(2) print(stack.min()) # Output: 1 stack.sort() print(stack) # Output: Top-> 1 2 3 5 ``` # Notes - Make sure to handle edge cases such as operations on an empty stack. - Optimize for both time and space complexities where possible. - The sorting should be efficient but can use any algorithm suitable for stack operations.","solution":"class ArrayStack: def __init__(self, size=10): self._data = [] self._size = size def is_empty(self) -> bool: return len(self._data) == 0 def push(self, item): if len(self._data) < self._size: self._data.append(item) else: raise OverflowError(\\"Stack overflow\\") def pop(self): if self.is_empty(): raise IndexError(\\"Stack underflow\\") return self._data.pop() def peek(self): if self.is_empty(): raise IndexError(\\"Stack is empty\\") return self._data[-1] def __repr__(self): return f\\"Top->{self._data[::-1]}\\" def __len__(self): return len(self._data) class ExtendedStack(ArrayStack): def min(self) -> int: if self.is_empty(): raise IndexError(\\"Stack is empty\\") return min(self._data) def sort(self): if self.is_empty(): raise IndexError(\\"Stack is empty\\") self._data.sort()"},{"question":"# Problem Scenario You are tasked with helping a combinatorics professor in implementing an efficient method to calculate binomial coefficients, commonly used in combinatorial mathematics, probability theory, and statistics. # Problem Statement Write a function `efficient_combination(n, r)` that computes the binomial coefficient, denoted as `C(n, r)` or `nCr`, which represents the number of ways to choose `r` items from `n` items. The function should be implemented using dynamic programming to ensure efficiency. # Function Signature ```python def efficient_combination(n: int, r: int) -> int: pass ``` # Input * `n` (int): the total number of items (0 <= n <= 1000) * `r` (int): the number of items to choose (0 <= r <= n) # Output * `int`: the computed binomial coefficient `C(n, r)` # Constraints * The function must handle edge cases without errors. * Ensure the solution leverages dynamic programming to be efficient. * Consider both time and space complexity in your implementation. # Example ```python assert efficient_combination(5, 2) == 10 # There are 10 ways to choose 2 items from 5 items assert efficient_combination(10, 0) == 1 # There is 1 way to choose 0 items from 10 items (do nothing) assert efficient_combination(5, 5) == 1 # There is 1 way to choose all items from the set. assert efficient_combination(8, 3) == 56 # As derived from the combinations. ```","solution":"def efficient_combination(n, r): Computes the binomial coefficient C(n, r) using dynamic programming approach. if r > n: return 0 if r == 0 or r == n: return 1 # Dynamic programming table initialized with zeros dp = [[0 for _ in range(r + 1)] for _ in range(n + 1)] # Build the table bottom-up for i in range(n + 1): for k in range(min(i, r) + 1): if k == 0 or k == i: dp[i][k] = 1 else: dp[i][k] = dp[i - 1][k - 1] + dp[i - 1][k] return dp[n][r]"},{"question":"# Power of Two Verification Objective Implement an extended version of the `is_power_of_two` function that not only checks if a given integer is a power of two but also handles various types of inputs gracefully, including strings and floating-point numbers. Problem Statement Write a function `extended_is_power_of_two` that takes one parameter, `num`: * The function should return `True` if `num` is a power of two. * It should return `False` if `num` is not a power of two or if `num` is not an integer. * Handle different types of inputs, including strings, floating-point numbers, etc. Convert those that can be converted to integers and return `False` for those that cannot. Expected Input and Output Formats ```python def extended_is_power_of_two(num): :type num: any :rtype: bool pass ``` # Constraints * The input can be any type (string, integer, float, etc.). * Ensure that the function checks for the valid input type and appropriately converts when possible. * Do not use Python\'s built-in power functions like `math.pow` or similar. Example Scenarios: ```python print(extended_is_power_of_two(1)) # True (2^0) print(extended_is_power_of_two(16)) # True (2^4) print(extended_is_power_of_two(18)) # False print(extended_is_power_of_two(\'32\')) # True (2^5) print(extended_is_power_of_two(\'hello\')) # False print(extended_is_power_of_two(2.0)) # True (2^1) print(extended_is_power_of_two(2.5)) # False print(extended_is_power_of_two(-8)) # False print(extended_is_power_of_two(0)) # False ``` Performance Requirements: * The function should maintain O(1) time and space complexity for the power of two check. * Handle input conversion efficiently without unnecessary computations.","solution":"def extended_is_power_of_two(num): Check if the input is a power of two. :param num: any type :return: bool if isinstance(num, str) and num.isdigit(): num = int(num) elif isinstance(num, float) and num.is_integer(): num = int(num) elif not isinstance(num, int): return False if num <= 0: return False return (num & (num - 1)) == 0"},{"question":"**Objective**: Implement a function to determine if a given binary tree is symmetric. **Scenario**: You\'re developing an application for visual processing. One of your tasks is to verify if the input image tree structure is symmetric. Symmetry here implies that the tree is a mirror image of itself along its center. # Task Define two functions: 1. `is_symmetric(root: TreeNode) -> bool`: A recursive solution to determine if the tree is symmetric. 2. `is_symmetric_iterative(root: TreeNode) -> bool`: An iterative solution using a stack based approach. # Input Format * `root`: The root node of the binary tree, with the structure: ```python class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None ``` # Output Format * Return `True` if the tree is symmetric, otherwise return `False`. # Constraints * The number of nodes in the tree will be in the range `[0, 10000]`. * Node values are integers and can be negative as well as positive. # Performance Requirements * Both solutions should have a time complexity of O(n). * The space complexity should be O(h) for the recursive solution and O(n) for the iterative solution where n is the number of nodes and h is the height of the tree. # Example ```python root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(2) root.left.left = TreeNode(3) root.left.right = TreeNode(4) root.right.left = TreeNode(4) root.right.right = TreeNode(3) print(is_symmetric(root)) # Output: True print(is_symmetric_iterative(root)) # Output: True ``` # Additional Notes * Ensure your solution handles edge cases such as an empty tree or a tree with only one or two nodes properly. * The iterative solution uses a stack data structure to manage and compare the respective nodes iteratively.","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def is_symmetric(root: TreeNode) -> bool: def is_mirror(t1: TreeNode, t2: TreeNode) -> bool: if not t1 and not t2: return True if not t1 or not t2: return False return (t1.val == t2.val and is_mirror(t1.right, t2.left) and is_mirror(t1.left, t2.right)) return is_mirror(root, root) def is_symmetric_iterative(root: TreeNode) -> bool: if not root: return True stack = [(root.left, root.right)] while stack: t1, t2 = stack.pop() if not t1 and not t2: continue if not t1 or not t2: return False if t1.val != t2.val: return False stack.append((t1.left, t2.right)) stack.append((t1.right, t2.left)) return True"},{"question":"Context You are working for a company that sets up network coverage for events using the fewest and least expensive radars, each covering a specific area. Given multiple radars with different coverage areas and costs, you need to determine the optimal subset of radars that covers the entire event area with minimal cost. Objective Implement a function `min_cost_radar_setup(universe, subsets, costs)` that, given a universal set of areas to cover, a dictionary of radar coverage sets, and a dictionary of radar setup costs, returns a list of the radar identifiers that together cover the entire area at the minimum possible cost using a greedy approach. Function Signature ```python def min_cost_radar_setup(universe: set, subsets: dict, costs: dict) -> list: ``` Input - `universe`: A set of unique identifiers representing the event areas. - `subsets`: A dictionary where keys are radar identifiers (strings) and values are sets of area identifiers each radar covers. - `costs`: A dictionary where keys are radar identifiers and values are their respective setup costs. Output - A list of radar identifiers (strings) that cover the entire event area with the least cost according to a greedy algorithm. Constraints - Each radar covers a non-empty subset of the universal set. - It is guaranteed that the combined subsets can cover the entire universal set. Example ```python universe = {1, 2, 3, 4, 5} subsets = {\'R1\': {4, 1, 3}, \'R2\': {2, 5}, \'R3\': {1, 4, 3, 2}} costs = {\'R1\': 5, \'R2\': 10, \'R3\': 3} result = min_cost_radar_setup(universe, subsets, costs) print(result) # Output might be [\'R2\', \'R3\'] ``` Notes * Make sure to handle all edge cases, including those where a radar might not contribute new coverage due to already covered areas. * Assume that input is valid and that there will always be a solution.","solution":"def min_cost_radar_setup(universe, subsets, costs): Given a universal set of areas to cover, a dictionary of radar coverage sets and a dictionary of radar setup costs, returns a list of the radar identifiers that together cover the entire area at the minimum possible cost using a greedy approach. remaining_areas = set(universe) # Areas that still need to be covered selected_radars = [] while remaining_areas: best_radar = None best_cost_efficiency = None for radar, covered_areas in subsets.items(): coverage = covered_areas & remaining_areas # Newly covered areas if coverage: cost_efficiency = costs[radar] / len(coverage) if best_cost_efficiency is None or cost_efficiency < best_cost_efficiency: best_radar = radar best_cost_efficiency = cost_efficiency if best_radar: selected_radars.append(best_radar) remaining_areas -= subsets[best_radar] return selected_radars"},{"question":"Design and implement a class, `EnhancedRandomizedSet`, that extends the functionalities of the `RandomizedSet` data structure with the following additional operations: 1. `get_elements() -> List[int]`: Returns a list of all elements in the set in the order they were inserted. 2. `is_present(val: int) -> bool`: Returns `True` if the element `val` is present in the set, `False` otherwise. 3. `clear() -> None`: Removes all elements from the set. Implement the `EnhancedRandomizedSet` class ensuring that all operations (`insert`, `remove`, `random_element`, `get_elements`, `is_present`, and `clear`) maintain efficient time complexities and correctness. # Expected Functions ```python class EnhancedRandomizedSet: def __init__(self): # Initialization method pass def insert(self, val: int) -> None: # Insert element pass def remove(self, val: int) -> None: # Remove element pass def random_element(self) -> int: # Return a random element pass def get_elements(self) -> List[int]: # Return all elements as a list pass def is_present(self, val: int) -> bool: # Check if element is present pass def clear(self) -> None: # Clear all elements pass ``` # Input and Output Formats * `insert(val: int) -> None`: Inserts an integer `val` into the set if not already present. No output. * `remove(val: int) -> None`: Removes an integer `val` from the set if present. No output. * `random_element() -> int`: Returns a random element from the set. Raises an error if the set is empty. * `get_elements() -> List[int]`: Returns a list of all elements in the set. * `is_present(val: int) -> bool`: Returns `True` if `val` is in the set and `False` otherwise. * `clear() -> None`: Clears all elements from the set. No output. # Constraints * The set will contain at most `10^5` elements. * All input elements will be integers within the range `[-10^9, 10^9]`. * Ensure that the operations are optimized for performance as much as possible. # Example ```python ers = EnhancedRandomizedSet() ers.insert(1) ers.insert(2) ers.insert(3) print(ers.get_elements()) # [1, 2, 3] print(ers.is_present(2)) # True ers.remove(2) print(ers.is_present(2)) # False print(ers.get_elements()) # [1, 3] val = ers.random_element() # Randomly returns 1 or 3 ers.clear() print(ers.get_elements()) # [] ```","solution":"import random class EnhancedRandomizedSet: def __init__(self): self.dict = {} self.list = [] def insert(self, val: int) -> bool: if val in self.dict: return False self.dict[val] = len(self.list) self.list.append(val) return True def remove(self, val: int) -> bool: if val not in self.dict: return False last_element, idx = self.list[-1], self.dict[val] self.list[idx], self.dict[last_element] = last_element, idx self.list.pop() del self.dict[val] return True def random_element(self) -> int: if not self.list: raise IndexError(\\"Attempting to get a random element from an empty set\\") return random.choice(self.list) def get_elements(self) -> list[int]: return self.list.copy() def is_present(self, val: int) -> bool: return val in self.dict def clear(self) -> None: self.dict.clear() self.list.clear()"},{"question":"# Scenario You are a software engineer working on a system that analyzes binary sequences to identify certain patterns. Your task is to determine the number of non-overlapping substrings within a binary string that have equal numbers of consecutive 0\'s and 1\'s. # Task Implement a function `count_binary_substring(s) -> int` that takes a binary string `s` and returns the number of non-empty contiguous substrings with equal numbers of consecutive 0’s and 1’s. # Examples ```python print(count_binary_substring(\\"00110011\\")) # Output: 6 print(count_binary_substring(\\"10101\\")) # Output: 4 ``` # Input * `s` (str): A binary string composed solely of characters \'0\' and \'1\'. The length of `s` is between 1 and 10^5. # Output * (int): The number of valid substrings. # Constraints 1. The input string must only contain \'0\' and \'1\'. 2. The solution must have time complexity O(n). # Performance Requirements Your solution should efficiently handle the upper constraint of the string length within the given time complexity. # Additional Notes Students should carefully handle edge cases such as strings with no valid substrings or strings with all characters the same. Ensure the implementation takes into account the length of contiguous 0\'s and 1\'s groups accurately.","solution":"def count_binary_substring(s): Returns the number of non-empty contiguous substrings within a binary string that have equal numbers of consecutive 0\'s and 1\'s. # Initialize variables prev_run_length, curr_run_length, count = 0, 1, 0 # Iterate over the string to calculate lengths of contiguous segments for i in range(1, len(s)): if s[i] == s[i - 1]: curr_run_length += 1 else: prev_run_length = curr_run_length curr_run_length = 1 if prev_run_length >= curr_run_length: count += 1 return count"},{"question":"# Scenario: You are developing a financial application that records daily transactions of a company and needs to handle the following efficiently: 1. **Query**: Calculate the total transactions in a given range of days. 2. **Update**: Adjust the transactions recorded for a particular day. To accomplish these tasks, you decide to implement a Fenwick Tree (also known as a Binary Indexed Tree). # Task: Using the provided class template, implement the following methods to manage the company\'s transactions efficiently: 1. `range_sum(bit_tree: list[int], left: int, right: int) -> int`: * Given the binary indexed tree and two indices, return the sum of transactions between the left and right indices (inclusive). 2. `update_transactions(bit_tree: list[int], index: int, value: int) -> None`: * Adjust the transaction value at a certain index. This involves updating the binary indexed tree to reflect this change. # Function Specifications: `range_sum(bit_tree: list[int], left: int, right: int) -> int`: * **Input**: * `bit_tree` - Binary indexed tree represented as a list of integers. * `left` - Start index of the range (inclusive). * `right` - End index of the range (inclusive). * **Output**: An integer representing the sum of transactions between indices `left` and `right`. `update_transactions(bit_tree: list[int], index: int, value: int) -> None`: * **Input**: * `bit_tree` - Binary indexed tree represented as a list of integers. * `index` - The day index to be updated. * `value` - The new transaction value to set. # Constraints: * 0 <= left <= right < n * 0 <= index < n * The number of days (n) can be up to 10^5. # Performance Requirements: * The sum and update operations should be performed in O(log n) time. # Example ```python # Example initialization and usage transactions = [100, 200, 300, 400, 500] fenwick_tree = Fenwick_Tree(transactions) bit_tree = fenwick_tree.construct() # Perform range sum query total = fenwick_tree.range_sum(bit_tree, 1, 3) # Output should be 900 (200+300+400) # Update transaction and perform range sum query again fenwick_tree.update_transactions(bit_tree, 2, -100) # Decrease the transaction of day 3 by 100 total = fenwick_tree.range_sum(bit_tree, 1, 3) # Output should now be 800 (200+200+400) ``` # Notes: * Ensure that you deeply understand how the Fenwick Tree functions work to implement the required methods accurately. * Handle edge cases and invalid inputs gracefully, ensuring the algorithm\'s correctness.","solution":"class Fenwick_Tree: def __init__(self, transactions): self.transactions = transactions self.n = len(transactions) self.bit_tree = [0] * (self.n + 1) self.construct() def construct(self): for i in range(self.n): self.update_transactions(i, self.transactions[i]) def update_transactions(self, index, value): Update the Fenwick Tree with an increment value at the given index. i = index + 1 while i <= self.n: self.bit_tree[i] += value i += i & -i def prefix_sum(self, index): Get the sum of transactions from the start to the given index. i = index + 1 total = 0 while i > 0: total += self.bit_tree[i] i -= i & -i return total def range_sum(self, left, right): Get the sum of transactions between two indices. if left == 0: return self.prefix_sum(right) return self.prefix_sum(right) - self.prefix_sum(left - 1) def adjust_transaction(self, index, new_value): Adjust the transaction value at a certain index. original_value = self.transactions[index] change_in_value = new_value - original_value self.transactions[index] = new_value self.update_transactions(index, change_in_value)"},{"question":"# Linked List Palindrome Checker **Objective**: Implement a function to determine if a singly linked list is a palindrome. You are given a `ListNode` class and a `head` node representing the linked list. **Function Signature**: ```python def is_linked_list_palindrome(head: ListNode) -> bool: ``` **Input**: - `head`: The head of the singly linked list composed of `ListNode` objects with integer values. **Output**: - Return `True` if the linked list is a palindrome. - Return `False` otherwise. **Constraints**: - The number of nodes in the list will be in the range [0, 10^5]. - -10^5 <= Node.value <= 10^5. **Performance Requirements**: - Aim for time complexity of O(n) and space complexity of O(1) if possible. - Ensure the function handles edge cases (e.g., empty list, single element). **Examples**: ```python # Example 1: # Input: 1 -> 2 -> 3 -> 2 -> 1 # Output: True # Example 2: # Input: 1 -> 2 -> 3 # Output: False # Example 3: # Input: 2 -> 7 -> 9 -> 7 -> 2 # Output: True ``` **Scenario**: You are tasked with optimizing a critical operation in a data-processing application that determines whether sequences of integer values form symmetric (palindromic) structures. This function will be integrated into larger analytical frameworks; thus, it needs to be both time and space efficient. **Note**: - Ensure detailed inline comments explaining your thought process and steps taken in the code. - Describe any alternate approaches considered.","solution":"class ListNode: def __init__(self, value=0, next=None): self.value = value self.next = next def is_linked_list_palindrome(head: ListNode) -> bool: Checks if the linked list is a palindrome. :param head: ListNode, the head of the singly linked list. :return: bool, True if the list is a palindrome, False otherwise. if not head or not head.next: # An empty list or a list with a single element is a palindrome return True # Finding the middle of the linked list using the slow and fast pointers method slow, fast = head, head while fast and fast.next: slow = slow.next fast = fast.next.next # Reversing the second half of the linked list prev, curr = None, slow while curr: next_node = curr.next curr.next = prev prev = curr curr = next_node # Compare the first half and the reversed second half first, second = head, prev while second: if first.value != second.value: return False first = first.next second = second.next return True"},{"question":"# Unique Element in a Triplicate Array **Context**: You are given an array of integers where every integer appears exactly three times except for one integer which appears exactly once. Your task is to find that single unique integer. **Problem Statement**: Write a function `find_unique_number(nums)` that takes a list of integers `nums` and returns the integer that appears exactly once. **Function Signature**: ```python def find_unique_number(nums: List[int]) -> int: ``` **Input**: - `nums`: A list of integers where every integer except one appears exactly three times. The length of the list `nums` is at least 1 and at most 10^5. **Output**: - An integer that is the only number appearing exactly once in the list. **Constraints**: - The function should execute in linear time, O(n). - No additional space (O(1) extra space complexity) should be used apart from variables to store the result. - You can assume that every integer except one appears exactly three times. **Example**: 1. Input: `nums = [2, 2, 3, 2]` Output: `3` 2. Input: `nums = [0, 1, 0, 1, 0, 1, 99]` Output: `99` **Notes**: - Utilize bitwise operations to keep track of the number of times a particular bit has been set. - Carefully manage the transitions between the masks for bits set once (`ones`) and twice (`twos`). **Hint**: Think about how you can leverage bitwise operations to differentiate between bits appearing exactly once and bits appearing multiple times.","solution":"from typing import List def find_unique_number(nums: List[int]) -> int: ones, twos = 0, 0 for num in nums: # Update \'twos\' with the bits that are set in both \'ones\' and the current number twos = twos | (ones & num) # Update \'ones\' with the new bits encountered ones = ones ^ num # Common_bits are the bits that are set in both \'ones\' and \'twos\' common_bits = ~(ones & twos) # Remove common bits from \'ones\' and \'twos\' ones &= common_bits twos &= common_bits return ones"},{"question":"Problem Context Company XYZ is facing a major challenge in ensuring optimal distribution of water through their water supply network. As a solution architect, you are tasked with finding the maximum flow of water from the source to the destination in their supply network. Given a network represented by an n × n adjacency matrix, write a Python function to determine the maximum flow from the source node (node 0) to the sink node (node n-1). Function Signature ```python def maximum_water_flow(adjacency_matrix: List[List[int]]) -> int: # Your code here ``` Input - `adjacency_matrix`: A 2D list of integers representing the capacities between nodes in the network. `adjacency_matrix[i][j]` denotes the capacity of the edge from node `i` to node `j`. Output - An integer representing the maximum flow from node 0 (source) to node n-1 (sink). Constraints - (2 leq n leq 50) - All capacities are non-negative integers. - There is no self-loop in the network. Example ```python adjacency_matrix = [ [0, 16, 13, 0, 0, 0], [0, 0, 10, 12, 0, 0], [0, 4, 0, 0, 14, 0], [0, 0, 9, 0, 0, 20], [0, 0, 0, 7, 0, 4], [0, 0, 0, 0, 0, 0] ] assert maximum_water_flow(adjacency_matrix) == 23 ``` Additional Requirements 1. Handle all edge cases where no path exists between source and the sink. 2. Ensure your solution is optimized for both time and space complexity where possible. Provide sufficient comments explaining the main parts of your algorithm for better understanding.","solution":"from typing import List from collections import deque def bfs(rGraph, s, t, parent): visited = [False] * len(rGraph) queue = deque([s]) visited[s] = True while queue: u = queue.popleft() for ind, val in enumerate(rGraph[u]): if visited[ind] == False and val > 0: queue.append(ind) visited[ind] = True parent[ind] = u if ind == t: return True return False def maximum_water_flow(adjacency_matrix: List[List[int]]) -> int: n = len(adjacency_matrix) source = 0 sink = n - 1 rGraph = [row[:] for row in adjacency_matrix] parent = [-1] * n max_flow = 0 while bfs(rGraph, source, sink, parent): path_flow = float(\\"Inf\\") s = sink while s != source: path_flow = min(path_flow, rGraph[parent[s]][s]) s = parent[s] v = sink while v != source: u = parent[v] rGraph[u][v] -= path_flow rGraph[v][u] += path_flow v = parent[v] max_flow += path_flow return max_flow"},{"question":"You are given a square Hermitian positive-definite matrix `A`. Your task is to write a function `cholesky_decomposition(A)` that performs Cholesky decomposition on matrix `A` and returns the lower triangular matrix `V` such that (V cdot V^* = A). # Function Signature ```python def cholesky_decomposition(A: List[List[float]]) -> Union[List[List[float]], None]: pass ``` # Input - `A`: A 2D list of floats representing a Hermitian positive-definite matrix of size `n x n`. # Output - Returns a 2D list of floats representing the lower triangular matrix `V` if the decomposition is possible. - Returns `None` if the decomposition is not possible (e.g., if `A` is not a Hermitian positive-definite matrix). # Constraints - Elements of `A` are floating-point numbers. - ( 1 leq n leq 100 ) # Provided Code ```python import math from typing import List, Union def cholesky_decomposition(A: List[List[float]]) -> Union[List[List[float]], None]: n = len(A) for ai in A: if len(ai) != n: return None V = [[0.0] * n for _ in range(n)] for j in range(n): sum_diagonal_element = 0 for k in range(j): sum_diagonal_element = sum_diagonal_element + math.pow(V[j][k], 2) sum_diagonal_element = A[j][j] - sum_diagonal_element if sum_diagonal_element <= 0: return None V[j][j] = math.pow(sum_diagonal_element, 0.5) for i in range(j+1, n): sum_other_element = 0 for k in range(j): sum_other_element += V[i][k]*V[j][k] V[i][j] = (A[i][j] - sum_other_element)/V[j][j] return V ``` # Example ```python A = [ [4, 12, -16], [12, 37, -43], [-16, -43, 98] ] result = cholesky_decomposition(A) # Expected result: # [ # [2.0, 0.0, 0.0], # [6.0, 1.0, 0.0], # [-8.0, 5.0, 3.0] # ] ``` # Notes - Ensure matrix `A` is a Hermitian positive-definite matrix before proceeding. - Handle numerical stability carefully especially when dealing with floating points.","solution":"import math from typing import List, Union def cholesky_decomposition(A: List[List[float]]) -> Union[List[List[float]], None]: Performs the Cholesky decomposition of a Hermitian positive-definite matrix. Args: A (List[List[float]]): The matrix to be decomposed. Returns: Union[List[List[float]], None]: The lower-triangular matrix `V` such that `V * V^T = A`, or None if the decomposition is not possible. n = len(A) for ai in A: if len(ai) != n: return None V = [[0.0] * n for _ in range(n)] for j in range(n): sum_diagonal_element = 0 for k in range(j): sum_diagonal_element += V[j][k] ** 2 sum_diagonal_element = A[j][j] - sum_diagonal_element if sum_diagonal_element <= 0: return None V[j][j] = math.sqrt(sum_diagonal_element) for i in range(j+1, n): sum_other_element = 0 for k in range(j): sum_other_element += V[i][k] * V[j][k] V[i][j] = (A[i][j] - sum_other_element) / V[j][j] return V"},{"question":"# Path Normalization Utility Function You are tasked with enhancing a utility function that converts a given file path into its absolute form. This function must handle both relative paths and user-referenced paths correctly. Function Signature ```python def normalize_path(file_path: str) -> str: pass ``` Input - `file_path` (str): A file path which might be relative, absolute, or include user references (e.g., `~/Documents`). Output - Returns a string representing the absolute path of the given input. Constraints - Assume the file path is a valid string. - If the input path is empty, return an empty string. - Handle cases with redundant slashes appropriately. Examples ```python assert normalize_path(\\"~/Documents\\") == \\"/home/username/Documents\\" # Assuming home is /home/username assert normalize_path(\\".\\") == \\"/current/directory\\" # Assuming current directory is /current/directory assert normalize_path(\\"\\") == \\"\\" assert normalize_path(\\"nested/dir/../file.txt\\") == \\"/current/directory/nested/file.txt\\" # Assuming current directory ``` Your task is to implement the `normalize_path` function ensuring it meets the specified criteria.","solution":"import os def normalize_path(file_path: str) -> str: Converts a given file path into its absolute form, handling relative paths and user-referenced paths correctly. if not file_path: return \\"\\" # Expand user (~) and clean the path expanded_path = os.path.expanduser(file_path) # Convert to absolute path absolute_path = os.path.abspath(expanded_path) return absolute_path"},{"question":"# Question: Separate Chaining Hash Table with Resizing **Objective:** Implement the Separate Chaining Hash Table data structure with dynamic resizing capabilities. **Context:** You are tasked with extending the `SeparateChainingHashTable` to support dynamic resizing (rehashing) when the load factor exceeds a certain threshold. This will ensure that the performance remains optimal by reducing the number of collisions. **Specifications and Constraints:** 1. **Function to Implement:** - `resize(self, new_size: int) -> None`: Resizes the hash table to a new size and rehashes all existing keys. 2. **Load Factor Threshold:** - When the load factor (number of elements/size of table) exceeds `0.7`, the table should resize to twice its current size. 3. **Modifications Required:** - Integrate the `resize` function such that it is called automatically after any insertion (i.e., in `put` method) if the load factor threshold is surpassed. - Ensure that all dictionary-like operations (`put`, `get`, `delete`, `__getitem__`, `__setitem__`, `__delitem__`) work seamlessly after resizing. **Function Signature:** ```python def resize(self, new_size: int) -> None: pass ``` **Examples:** ```python # Initial hash table creation and insertions table = SeparateChainingHashTable() table.put(\'a\', 1) table.put(\'b\', 2) # Assuming initial size is small to force resizing assert len(table) == 2 # Continue inserting until resizing is triggered for i in range(3, 10): table.put(str(i), i) assert len(table) == i # Check if keys are maintained correctly after resizing assert table.get(\'a\') == 1 assert table.get(\'b\') == 2 assert table.get(\'3\') == 3 assert table.get(\'9\') == 9 ``` **Performance Requirement:** - Ensure that the resizing operation maintains the average-case time complexity of O(1) for insertion, retrieval, and deletion, assuming a reasonably good hash function and load factor management. **Hints:** - Iterate through the old table\'s linked lists to rehash the elements. - Remember to update both the table\'s size and the _table attribute slices after resizing. **Testing:** - Utilize the unittest framework to write tests that verify the correctness of your `resize` implementation.","solution":"class SeparateChainingHashTable: def __init__(self, capacity=4): self.capacity = capacity self.size = 0 self.table = [[] for _ in range(capacity)] def _hash(self, key): return hash(key) % self.capacity def put(self, key, value): bucket_index = self._hash(key) bucket = self.table[bucket_index] # Check if key already exists and update for index, (k, v) in enumerate(bucket): if k == key: bucket[index] = (key, value) return # If key does not exist, add new entry bucket.append((key, value)) self.size += 1 # Resize the table if load factor > 0.7 if self.size / self.capacity > 0.7: self.resize(self.capacity * 2) def get(self, key): bucket_index = self._hash(key) bucket = self.table[bucket_index] for k, v in bucket: if k == key: return v return None def delete(self, key): bucket_index = self._hash(key) bucket = self.table[bucket_index] for index, (k, v) in enumerate(bucket): if k == key: del bucket[index] self.size -= 1 return def resize(self, new_size): old_table = self.table self.table = [[] for _ in range(new_size)] self.capacity = new_size self.size = 0 for bucket in old_table: for key, value in bucket: self.put(key, value) def __getitem__(self, key): result = self.get(key) if result is None: raise KeyError(f\'Key {key} not found\') return result def __setitem__(self, key, value): self.put(key, value) def __delitem__(self, key): self.delete(key)"},{"question":"**Binary Tree Inversion Challenge** You are provided with a binary tree node class and a function to invert a binary tree. Your task is to implement the binary tree inversion function using an iterative approach to avoid potential recursion stack overflow issues. # Binary Tree Node Class ```python class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right ``` # Task Implement the function `invert_tree` that inverts a binary tree iteratively. # Function Signature ```python def invert_tree(root: TreeNode) -> TreeNode: pass ``` # Input * `root`: TreeNode - The root node of the binary tree. It could be `None`, indicating an empty tree. # Output * `TreeNode` - The root of the inverted binary tree. # Example ```python # Tree: # 4 # / # 2 7 # / / # 1 3 6 9 root = TreeNode(4) root.left = TreeNode(2, TreeNode(1), TreeNode(3)) root.right = TreeNode(7, TreeNode(6), TreeNode(9)) inverted_root = invert_tree(root) # Inverted Tree: # 4 # / # 7 2 # / / # 9 6 3 1 ``` # Constraints * `The number of nodes in the tree is in the range [0, 1000]`. * `-100 <= Node.val <= 100` # Notes * Ensure your solution can handle trees of significant depth without hitting recursion limits. * An iterative solution is preferable for this problem.","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def invert_tree(root: TreeNode) -> TreeNode: if not root: return None queue = [root] while queue: current = queue.pop(0) current.left, current.right = current.right, current.left if current.left: queue.append(current.left) if current.right: queue.append(current.right) return root"},{"question":"# Problem Context Imagine you are working as a software engineer tasked with analyzing network connectivity. You need to determine the number of isolated networks (connected components) in a given undirected graph representing the connectivity of various nodes. # Task Description Write a function `get_connected_components_count(adj_list: List[List[int]], n: int) -> int` that computes the number of connected components in a given undirected graph. # Input * `adj_list`: A list of lists where `adj_list[i]` contains the neighbors of node `i`. This represents the adjacency list of the undirected graph. * `n`: An integer denoting the number of nodes in the graph (indexed from 0 to n-1). # Output * Returns an integer representing the number of connected components in the graph. # Constraints * 0 <= n <= 10^5 * 0 <= len(adj_list) <= n * 0 <= len(adj_list[i]) <= n for each i # Example ```python adj_list = [[1], [0, 2], [1], [4], [3]] n = 5 assert get_connected_components_count(adj_list, n) == 2 ``` # Explanation In the example above, there are 5 nodes and 2 connected components: {0,1,2} and {3,4}. The function should return 2.","solution":"from typing import List def get_connected_components_count(adj_list: List[List[int]], n: int) -> int: Returns the number of connected components in the undirected graph. def dfs(node, visited): stack = [node] while stack: current = stack.pop() for neighbor in adj_list[current]: if neighbor not in visited: visited.add(neighbor) stack.append(neighbor) visited = set() connected_components = 0 for node in range(n): if node not in visited: visited.add(node) dfs(node, visited) connected_components += 1 return connected_components"},{"question":"Problem Statement You are given an integer that represents a sequence of flags, where each bit indicates the state of a specific feature (1 means \\"enabled\\" and 0 means \\"disabled\\"). Your task is to implement four functions to manipulate these flags: 1. `get_flag(flags, index)`: Check if the feature at position `index` is enabled. 2. `enable_flag(flags, index)`: Enable the feature at position `index`. 3. `disable_flag(flags, index)`: Disable the feature at position `index`. 4. `update_flag(flags, index, state)`: Update the feature at position `index` to the specified `state` (either 1 for \\"enabled\\" or 0 for \\"disabled\\"). Input and Output Format 1. **Function `get_flag(flags, index)`**: - **Input**: - `flags`: An integer representing the sequence of flags. - `index`: An integer indicating the position of the flag. - **Output**: - A boolean indicating whether the feature at the specified position is enabled (`True`) or disabled (`False`). 2. **Function `enable_flag(flags, index)`**: - **Input**: - `flags`: An integer representing the sequence of flags. - `index`: An integer indicating the position of the flag. - **Output**: - An integer with the feature at the specified position enabled. 3. **Function `disable_flag(flags, index)`**: - **Input**: - `flags`: An integer representing the sequence of flags. - `index`: An integer indicating the position of the flag. - **Output**: - An integer with the feature at the specified position disabled. 4. **Function `update_flag(flags, index, state)`**: - **Input**: - `flags`: An integer representing the sequence of flags. - `index`: An integer indicating the position of the flag. - `state`: An integer (either 0 or 1) indicating the new state of the flag. - **Output**: - An integer with the feature at the specified position updated to the new state. Constraints * `flags` will be a non-negative integer. * `index` will be a non-negative integer less than 32 (considering a 32-bit integer). * `state` will be either 0 or 1. Performance Requirements These operations should all execute in constant time, O(1). Example Usage ```python # flag sequence: 0000 (binary form) -> 0 flags = 0 # Enable the feature at position 1 flags = enable_flag(flags, 1) # flag sequence: 0010 -> 2 # Enable the feature at position 3 flags = enable_flag(flags, 3) # flag sequence: 1010 -> 10 # Disable the feature at position 1 flags = disable_flag(flags, 1) # flag sequence: 1000 -> 8 # Update the feature at position 2 to enabled flags = update_flag(flags, 2, 1) # flag sequence: 1100 -> 12 # Check if the feature at position 3 is enabled is_feature_3_enabled = get_flag(flags, 3) # Output: True ```","solution":"def get_flag(flags, index): return (flags & (1 << index)) != 0 def enable_flag(flags, index): return flags | (1 << index) def disable_flag(flags, index): return flags & ~(1 << index) def update_flag(flags, index, state): if state: return enable_flag(flags, index) else: return disable_flag(flags, index)"},{"question":"Context You are tasked with implementing an efficient ordered insertion mechanism into a sorted array. To achieve this, you will use the provided `search_insert` function to find the correct position and then insert the element in that position while maintaining the array order. Problem Statement Write a function `ordered_insert(array, val)` that takes a sorted array `array` and a target value `val`. The function should insert `val` into the array in such a way that the array remains sorted. # Function Signature ```python def ordered_insert(array, val): # Your implementation here ``` # Input * `array`: A list of integers, sorted in non-decreasing order. * `val`: An integer that needs to be inserted into `array`. # Output * Returns a new list with `val` inserted in the correct position. # Constraints * The input list can have up to 10^4 elements. * The values in the list and the target value can be any integer within the range [-10^6, 10^6]. # Example ```python print(ordered_insert([1, 3, 5, 6], 5)) # Output: [1, 3, 5, 5, 6] print(ordered_insert([1, 3, 5, 6], 2)) # Output: [1, 2, 3, 5, 6] print(ordered_insert([1, 3, 5, 6], 7)) # Output: [1, 3, 5, 6, 7] print(ordered_insert([1, 3, 5, 6], 0)) # Output: [0, 1, 3, 5, 6] ``` # Performance Requirements * The implementation should leverage the `search_insert` function to maintain efficient time complexity. Remember, your function should correctly handle edge cases such as empty arrays and duplicates.","solution":"def search_insert(array, val): Binary search function to find the appropriate insert position. low, high = 0, len(array) - 1 while low <= high: mid = (low + high) // 2 if array[mid] == val: return mid elif array[mid] < val: low = mid + 1 else: high = mid - 1 return low def ordered_insert(array, val): Inserts val into array such that the resultant array remains sorted. pos = search_insert(array, val) return array[:pos] + [val] + array[pos:]"},{"question":"# Scenario Imagine you are managing a collection of books arranged in a stack, where pairs of books need to be switched for categorization purposes. The challenge is to switch successive pairs of books starting from the bottom of the stack while maintaining the top-most book in place if the stack has an odd count. # Problem Statement Write a function `switch_book_pairs` that takes a stack of book IDs (numbers) and switches successive pairs of IDs, starting from the bottom, using either one auxiliary stack or one auxiliary queue for intermediate storage. # Input * A list of integers representing book IDs stored in a stack, where the last element is the top of the stack. # Output * A list of integers where successive pairs of book IDs are swapped starting from the bottom of the stack. # Functions Signature ```python def switch_book_pairs(stack): # Your implementation here ``` # Constraints 1. The stack can have up to `10^5` elements. 2. The book IDs are positive integers. # Example Given the stack `[3, 8, 17, 9, 1, 10]`, the expected result is `[8, 3, 9, 17, 10, 1]`. Given the stack `[3, 8, 17, 9, 1]`, the expected result is `[8, 3, 9, 17, 1]`. This task ensures that you demonstrate understanding of stack manipulations and use of auxiliary data structures to accomplish the given transformations effectively. # Requirements * Ensure your function runs within the provided constraints efficiently. * Consider and handle edge cases like empty stacks and stacks with an odd number of elements properly.","solution":"def switch_book_pairs(stack): Switch pairs of book IDs in the stack. Args: stack (list): The list of book IDs. Returns: list: A list with successive pairs of book IDs swapped. aux_stack = [] n = len(stack) # Process pairs for i in range(0, n - 1, 2): aux_stack.append(stack[i + 1]) aux_stack.append(stack[i]) # If n is odd, add the last element as is if n % 2 != 0: aux_stack.append(stack[-1]) return aux_stack"},{"question":"You are given the task of implementing a pair of functions to encode and decode a list of strings. The encoded strings need to preserve the data so that they can be accurately decoded back to the original list of strings. # Problem Statement 1. Implement the `encode` function, which takes a list of strings and encodes it into a single string. 2. Implement the `decode` function, which takes this encoded string and decodes it back into the original list of strings. # Requirements * **Function Signatures**: ```python def encode(strs: List[str]) -> str: # your code here def decode(s: str) -> List[str]: # your code here ``` * **Input/Output**: * The `encode` function takes as input a list of strings `strs` (List[str]) and returns a single encoded string (str). * The `decode` function takes as input an encoded string `s` (str) and returns a list of strings (List[str]). * **Constraints**: * Strings can contain any characters including letters, numbers, and special characters. * The length for the strings in the list is at most 100,000 in total. * Ensure that your functions handle edge cases such as an empty list or strings with special characters like colons. # Example ```python # Example Input strs = [\\"hello\\", \\"world\\"] # Example Usage encoded_str = encode(strs) print(encoded_str) # Output may look like: \\"5:hello5:world\\" decoded_list = decode(encoded_str) print(decoded_list) # Output: [\\"hello\\", \\"world\\"] ``` # Scenario Imagine you are developing a messaging system where you need to transmit multiple messages as a single payload. The recipients need to decode this payload to retrieve the original messages. Your encoding and decoding functions will ensure reliable and efficient transfer of messages. # Performance Requirements Your implementation should be efficient in terms of time and space, aiming to use O(n) time and space complexity where n is the total length of all strings combined.","solution":"def encode(strs): Encodes a list of strings to a single string. Args: strs (list of str): The list of strings to encode. Returns: str: The encoded string. encoded_str = \\"\\" for s in strs: encoded_str += f\\"{len(s)}:{s}\\" return encoded_str def decode(s): Decodes a single string to a list of strings. Args: s (str): The encoded string. Returns: list of str: The decoded list of strings. decoded_strs = [] i = 0 while i < len(s): j = i # Read the length prefix to get the actual string while s[j] != \':\': j += 1 length = int(s[i:j]) i = j + 1 + length decoded_strs.append(s[j+1:i]) return decoded_strs"},{"question":"# Nearest Neighbor Algorithm Implementation Background You are working on a basic nearest neighbor classifier to predict the class of a given point based on the closest data points in a training set. Problem Statement Write a function `nearest_neighbor_classifier(x, train_set)` that takes a point `x` (a tuple of integers/floats) and a `train_set` (a dictionary where keys are tuples representing points and values are their corresponding classes). The function should return the class of the closest point to `x` in the training set. # Requirements 1. **Input**: - `x`: a tuple of length n representing a new point. - `train_set`: a dictionary with keys as tuples of length n and values as strings representing their classes. 2. **Output**: - Return the class of the nearest point in the training set. # Constraints 1. The lengths of `x` and tuples in `train_set` are guaranteed to be the same. 2. The training set is non-empty. 3. No missing values in the input. # Example ```python # Input x = (1, 2) train_set = { (3, 4): \\"A\\", (1, 1): \\"B\\", (2, 2): \\"C\\" } # Expected Output \\"B\\" ``` # Notes 1. Implement the Euclidean distance to measure the distance between two points. 2. Ensure your solution handles ties gracefully by returning the class of the first closest point found. # Function Signature ```python def nearest_neighbor_classifier(x: tuple, train_set: dict) -> str: pass ``` # Evaluation Your solution will be evaluated based on: 1. Correctness: Producing the correct output for all test cases. 2. Efficiency: Running within acceptable time and space limits. 3. Code Quality: Readability, proper use of data structures, and adherence to coding conventions.","solution":"import math def euclidean_distance(point1, point2): Computes the Euclidean distance between two points. return math.sqrt(sum((p1 - p2) ** 2 for p1, p2 in zip(point1, point2))) def nearest_neighbor_classifier(x, train_set): Returns the class of the nearest point in the train_set to the point x. :param x: tuple of length n representing a new point. :param train_set: dictionary with keys as tuples of length n and values as strings representing their classes. :return: the class of the nearest point in the training set. if not train_set: raise ValueError(\\"Training set cannot be empty\\") min_distance = float(\'inf\') nearest_class = None for point, class_label in train_set.items(): distance = euclidean_distance(x, point) if distance < min_distance: min_distance = distance nearest_class = class_label return nearest_class"},{"question":"**Context & Scenario**: You are tasked with creating a new model for a linguistics research project that involves studying language patterns and transformations. Part of this project requires checking if one string can be transformed into another by a unique character mapping preserving the order. Given two strings, you need to implement a function that determines whether they are isomorphic. **Objective**: Write a function `is_isomorphic(s, t)` that takes in two strings `s` and `t`, and returns `True` if they are isomorphic, otherwise returns `False`. **Function Signature**: ```python def is_isomorphic(s: str, t: str) -> bool: ``` **Input Format**: - `s`: A string of length n (1 ≤ n ≤ 10^5) - `t`: A string of length n (matching the length of `s`) **Output Format**: - A boolean value: `True` if `s` and `t` are isomorphic, otherwise `False`. **Constraints**: - The function should handle up to 100,000 characters efficiently. - Only lowercase letters are used in the strings. **Example**: ```python # Example 1 s = \\"egg\\" t = \\"add\\" Output: True # Example 2 s = \\"foo\\" t = \\"bar\\" Output: False # Example 3 s = \\"paper\\" t = \\"title\\" Output: True ``` # Performance Requirements - The solution should execute in linear time O(n) with respect to the length of `s` and `t`. The function should be robust, handle edge cases such as strings with repeated characters and very short or empty strings, and maintain correct character mappings throughout its operation.","solution":"def is_isomorphic(s: str, t: str) -> bool: if len(s) != len(t): return False # Two dictionaries to store the mapping of characters from s to t and t to s s_to_t = {} t_to_s = {} for char_s, char_t in zip(s, t): if char_s in s_to_t: if s_to_t[char_s] != char_t: return False else: s_to_t[char_s] = char_t if char_t in t_to_s: if t_to_s[char_t] != char_s: return False else: t_to_s[char_t] = char_s return True"},{"question":"# Context: You are working for a delivery routing company. You have been given a map of the city\'s road network represented as an undirected graph. Each node represents a location, and each edge represents a road between two locations. Your task is to write a set of functions that will help in finding different paths between two locations in the city. # Task: Implement the following functions based on the provided graph traversal algorithms: 1. **find_path(graph, start, end)**: - **Input**: - `graph`: A dictionary representation of an undirected graph where keys are node identifiers, and values are lists of adjacent nodes. - `start`: The starting node. - `end`: The target node. - **Output**: - A list representing a path from the `start` node to the `end` node if any path exists, otherwise `None`. 2. **find_all_paths(graph, start, end)**: - **Input**: - `graph`: A dictionary representation of an undirected graph. - `start`: The starting node. - `end`: The target node. - **Output**: - A list of lists, where each inner list represents a unique path from the `start` node to the `end` node. 3. **find_shortest_path(graph, start, end)**: - **Input**: - `graph`: A dictionary representation of an undirected graph. - `start`: The starting node. - `end`: The target node. - **Output**: - A list representing the shortest path from the `start` node to the `end` node if any path exists, otherwise `None`. # Constraints: - The graph is undirected and unweighted. - There are no negative cycles in the graph. - Graph nodes are labeled with unique identifiers. - Assume there are no duplicate edges in the graph. # Examples: ```python graph = { \'A\': [\'B\', \'C\'], \'B\': [\'A\', \'D\', \'E\'], \'C\': [\'A\', \'F\'], \'D\': [\'B\'], \'E\': [\'B\', \'F\'], \'F\': [\'C\', \'E\'] } # Example Calls print(find_path(graph, \'A\', \'F\')) # Output: [\'A\', \'C\', \'F\'] or [\'A\', \'B\', \'E\', \'F\'] print(find_all_paths(graph, \'A\', \'F\')) # Output: [[\'A\', \'B\', \'E\', \'F\'], [\'A\', \'C\', \'F\'], ...] print(find_shortest_path(graph, \'A\', \'F\')) # Output: [\'A\', \'C\', \'F\'] or [\'A\', \'B\', \'E\', \'F\'] ``` # Performance Requirements: - Ensure that your implementation is efficient for graphs up to 1000 nodes and 5000 edges.","solution":"def find_path(graph, start, end, path=[]): Finds any path between start and end nodes. path = path + [start] if start == end: return path if start not in graph: return None for node in graph[start]: if node not in path: newpath = find_path(graph, node, end, path) if newpath: return newpath return None def find_all_paths(graph, start, end, path=[]): Finds all paths between start and end nodes. path = path + [start] if start == end: return [path] if start not in graph: return [] paths = [] for node in graph[start]: if node not in path: newpaths = find_all_paths(graph, node, end, path) for newpath in newpaths: paths.append(newpath) return paths def find_shortest_path(graph, start, end): Finds the shortest path between start and end nodes. from collections import deque queue = deque([(start, [start])]) visited = set() while queue: (node, path) = queue.popleft() if node not in visited: if node == end: return path visited.add(node) for neighbor in graph.get(node, []): queue.append((neighbor, path + [neighbor])) return None"},{"question":"# Scenario You are implementing a Binary Search Tree (BST) to manage an ordered collection of integers for a scheduling application. One of the required features is to quickly find the next available slot given a current time (node) in this BST. # Task Implement the function `successor_in_bst(root, node)` which finds the in-order successor of `node` in the BST rooted at `root`. # Function Signature ```python def successor_in_bst(root: TreeNode, node: TreeNode) -> TreeNode: # Your code here ``` # Input - `root`: The root of the BST, a `TreeNode` object. - `node`: A `TreeNode` object for which the successor is to be found. # Output - Return a `TreeNode` object representing the in-order successor of the given `node`. - If no successor exists, return `None`. # Constraints - Assume the tree nodes have distinct integer values. - Tree nodes are defined by a typical class as follows: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` # Example Consider the following BST: ``` 20 / 10 30 / 5 15 40 ``` 1. If `node` has value `10`, your function should return the node with value `15`. 2. If `node` has value `15`, your function should return the node with value `20`. 3. If `node` has value `30`, your function should return the node with value `40`. 4. If `node` has value `40`, your function should return `None`. # Notes - Ensure to handle edge cases such as nodes without successors and nodes with right subtrees. - Focus on an efficient solution that optimally leverages BST properties.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def successor_in_bst(root: TreeNode, node: TreeNode) -> TreeNode: def find_min(node): while node.left: node = node.left return node successor = None while root: if node.val < root.val: successor = root root = root.left elif node.val > root.val: root = root.right else: if node.right: successor = find_min(node.right) break return successor"},{"question":"Context: As part of a number processing system, you need to accurately determine the number of digits in various integers. Your task is to implement a function that computes the number of digits in an integer with efficient time and space complexity. Problem Statement: Implement a function `count_digits(n)` that returns the number of digits in the given integer `n`. # Requirements: 1. The function should handle positive, negative, and zero values correctly. 2. The function must run in constant time (O(1)). 3. Your implementation should not exceed constant space (O(1)). Input Format: * A single integer `n` where `|n|` ≤ 10^18 Output Format: * An integer representing the count of digits in `n`. # Constraints: * The given integer `n` can be positive, negative, or zero. * Do not use loops or recursion in your implementation. Examples: Example 1: Input: `n = 12345` Output: `5` Reason: The number `12345` has 5 digits. Example 2: Input: `n = -67890` Output: `5` Reason: The number `-67890` has 5 digits. Example 3: Input: `n = 0` Output: `1` Reason: The number `0` has 1 digit. Function Signature: ```python def count_digits(n: int) -> int: pass # Example usage print(count_digits(12345)) # Output: 5 print(count_digits(-67890)) # Output: 5 print(count_digits(0)) # Output: 1 ```","solution":"def count_digits(n): Returns the number of digits in the given integer n. if n < 0: n = -n return len(str(n))"},{"question":"# Scenario You have been hired by a company that specializes in sorting large datasets of numerical information. The company is transitioning from traditional comparison-based sorts to more efficient linear time sorting algorithms and has asked you to implement and optimize Radix Sort for their internal use. They require a robust implementation that handles specific constraints and edge cases efficiently. # Task Implement a function `custom_radix_sort(arr)` that sorts a list of non-negative integers using the Radix Sort algorithm. Your implementation must: 1. Handle edge cases such as empty lists and lists with a single element. 2. Ensure stability during sorting. 3. Optimize memory usage where possible. # Function Signature ```python def custom_radix_sort(arr: List[int]) -> List[int]: ``` # Input * `arr` (List[int]): A list of non-negative integers where 0 ≤ arr[i] ≤ 10^6. # Output * Returns a sorted list of non-negative integers. # Constraints 1. No use of Python\'s built-in sort functions or libraries. 2. Must complete within a reasonable time under the given constraints. 3. Handling lists of varying lengths and a broad range of values. # Performance Requirements * The implementation should aim for O(nk) time complexity, where n is the number of elements, and k is the maximum number of digits in the largest number. # Examples ```python print(custom_radix_sort([170, 45, 75, 90, 802, 24, 2, 66])) # Output: [2, 24, 45, 66, 75, 90, 170, 802] print(custom_radix_sort([3, 3, 3, 3, 3])) # Output: [3, 3, 3, 3, 3] print(custom_radix_sort([100, 10, 1000, 1, 10, 100, 1000])) # Output: [1, 10, 10, 100, 100, 1000, 1000] print(custom_radix_sort([])) # Output: [] ``` Note: You may assume that the input does not contain negative numbers and that it fits within the given constraints.","solution":"from typing import List def counting_sort(arr: List[int], exp: int) -> List[int]: n = len(arr) output = [0] * n count = [0] * 10 for i in range(n): index = arr[i] // exp count[index % 10] += 1 for i in range(1, 10): count[i] += count[i - 1] i = n - 1 while i >= 0: index = arr[i] // exp output[count[index % 10] - 1] = arr[i] count[index % 10] -= 1 i -= 1 for i in range(n): arr[i] = output[i] return arr def custom_radix_sort(arr: List[int]) -> List[int]: if len(arr) == 0 or len(arr) == 1: return arr max_val = max(arr) exp = 1 while max_val // exp > 0: arr = counting_sort(arr, exp) exp *= 10 return arr"},{"question":"# Question: Merge K Sorted Linked Lists You are given an array of `k` sorted singly linked-lists `lists`, each linked list containing `n` nodes on average. Your goal is to merge all these linked lists into one sorted singly linked-list and return it. Function Signature ```python def merge_k_lists(lists: List[Node]) -> Node: ``` Input * `lists`: A list of `k` singly linked lists, where each linked list is sorted in non-decreasing order. Each linked list is represented by its head `Node`. Output * The head of the merged singly linked list, which should also be sorted in non-decreasing order. Constraints 1. `0 <= k <= 10^4` 2. `0 <= n <= 500` 3. The total number of nodes will not exceed `10^5`. Performance Requirement * Your algorithm should run in O(N log k) time complexity, where `N` is the total number of nodes across all linked lists. Example ```python Input: lists = [1->4->5, 1->3->4, 2->6] Output: 1->1->2->3->4->4->5->6 ``` Additional Notes * Handle the edge case when `lists` is empty. * Optimize for performance and handle memory effectively. * You may use additional data structures if necessary to achieve the required time complexity.","solution":"from typing import List, Optional import heapq class Node: def __init__(self, val=0, next=None): self.val = val self.next = next def merge_k_lists(lists: List[Optional[Node]]) -> Optional[Node]: Merges k sorted linked lists and returns the head of the merged sorted linked list. min_heap = [] for idx, node in enumerate(lists): if node: heapq.heappush(min_heap, (node.val, idx, node)) dummy = Node(0) current = dummy while min_heap: val, idx, node = heapq.heappop(min_heap) current.next = node current = current.next if current.next: heapq.heappush(min_heap, (current.next.val, idx, current.next)) return dummy.next"},{"question":"# Question: Implementing a Binary Search Tree (BST) Context: You have been given a task to implement a Binary Search Tree (BST) for a library management system. The BST will store the book IDs and allow efficient searching, insertion, and deletion of book IDs. Tasks: You are required to: 1. Implement search, insertion, and deletion operations in the BST. 2. Ensure the BST maintains its properties after each operation. Function Signatures: Implement the following functions: ```python class TreeNode: def __init__(self, val=0): self.val = val self.left = None self.right = None class BST: def __init__(self): self.root = None def insert(self, val: int) -> None: Insert a value into the BST. :param val: The value to be inserted. def search(self, val: int) -> bool: Search for a value in the BST. :param val: The value to search for. :return: True if the value is found, False otherwise. def delete(self, val: int) -> None: Delete a value from the BST. :param val: The value to be deleted. ``` Requirements: 1. **Insert**: Insert a value into the BST ensuring the tree properties. 2. **Search**: Check if a value is present in the BST. 3. **Delete**: Remove a value from the BST ensuring the tree properties are maintained. Constraints: - All book IDs are unique positive integers. - Implementations should perform efficiently, ensuring optimal average-case time complexity. Example: ```python # Example usage: bst = BST() bst.insert(5) bst.insert(3) bst.insert(7) print(bst.search(3)) # Output: True print(bst.search(4)) # Output: False bst.delete(3) print(bst.search(3)) # Output: False ```","solution":"class TreeNode: def __init__(self, val=0): self.val = val self.left = None self.right = None class BST: def __init__(self): self.root = None def insert(self, val: int) -> None: if not self.root: self.root = TreeNode(val) else: self._insert_recursive(self.root, val) def _insert_recursive(self, node, val): if val < node.val: if node.left is None: node.left = TreeNode(val) else: self._insert_recursive(node.left, val) else: if node.right is None: node.right = TreeNode(val) else: self._insert_recursive(node.right, val) def search(self, val: int) -> bool: return self._search_recursive(self.root, val) def _search_recursive(self, node, val): if not node: return False if val == node.val: return True elif val < node.val: return self._search_recursive(node.left, val) else: return self._search_recursive(node.right, val) def delete(self, val: int) -> None: self.root = self._delete_recursive(self.root, val) def _delete_recursive(self, node, val): if not node: return node if val < node.val: node.left = self._delete_recursive(node.left, val) elif val > node.val: node.right = self._delete_recursive(node.right, val) else: if not node.left: return node.right elif not node.right: return node.left min_larger_node = self._get_min(node.right) node.val = min_larger_node.val node.right = self._delete_recursive(node.right, min_larger_node.val) return node def _get_min(self, node): current = node while current.left: current = current.left return current"},{"question":"You are tasked with implementing an optimized function to compute the binomial coefficient, commonly known as combinations, `nCr`. Your function must handle large inputs efficiently by implementing and combining both dynamic programming principles and space optimization techniques. # Requirements - Write a function `optimized_combination(n: int, r: int) -> int` that computes the value of `nCr`. - The input `n` and `r` are integers where `0 <= r <= n`. - Your function should be efficient enough to handle `n` up to 10,000. # Function Signature ```python def optimized_combination(n: int, r: int) -> int: pass ``` # Input - An integer `n` (0 ≤ n ≤ 10000) - An integer `r` (0 ≤ r ≤ n) # Output - The function should return an integer which is the binomial coefficient calculated as `nCr`. # Constraints - You must optimize both time and space complexity. - Use an iterative dynamic programming approach to ensure feasibility for large inputs. # Example ```python # Example 1 print(optimized_combination(5, 2)) # Output: 10 # Example 2 print(optimized_combination(10, 3)) # Output: 120 ``` # Performance - Expected time complexity: ( O(n times r) ) - Expected space complexity: ( O(r) ) # Hints - Employ a dynamic programming table, focusing on reusing minimal space. - Consider the symmetry property `nCr = nC(n-r)` to minimize computations further.","solution":"def optimized_combination(n: int, r: int) -> int: Computes the binomial coefficient (nCr) using an optimized approach combining dynamic programming principles with space optimization techniques. # If r is greater than n-r, use the property nCr = nC(n-r) if r > n - r: r = n - r # Create an array to hold the intermediate results # C holds the values of binomial coefficients # We\'ll use only a single row updating it iteratively to achieve space optimization C = [0] * (r + 1) C[0] = 1 # Base case nC0 is always 1 # Populate the C array iteratively to compute nCr for i in range(1, n + 1): # Update the array from right to left to ensure we are using previous row\'s values for j in range(min(i, r), 0, -1): C[j] = C[j] + C[j - 1] return C[r]"},{"question":"You are given a dataset of points in a multidimensional space represented as (x, y, z, ...). You need to implement the Nearest Neighbor algorithm to classify a new data point based on this dataset. # Task Write a function `classify_point(new_point, training_set)` that takes the following inputs: 1. `new_point`: A tuple representing the coordinates of the new point to classify. 2. `training_set`: A dictionary where keys are tuples representing coordinates of known points, and values are the class labels (as strings) for the corresponding points. The function should return the class label of the nearest neighbor to the `new_point`. # Input Format - `new_point`: A tuple of floats/integers representing the new point to classify. - `training_set`: A dictionary with keys as tuples of floats/integers and values as string labels. # Constraints - Each tuple in `new_point` and keys in `training_set` have the same length. - The training set is non-empty. - Labels in the training set are non-empty strings. # Output Format - A string representing the class label of the nearest neighbor. # Examples 1. `classify_point((1.0, 2.0), {(0.0, 1.0): \'A\', (2.0, 3.0): \'B\', (1.0, 3.0): \'A\'})` should return `\'A\'`. 2. `classify_point((1.5, 2.5), {(1.0, 2.0): \'C\', (2.0, 3.0): \'D\'})` should return `\'C\'`. # Notes 1. Use Euclidean distance as the distance metric. 2. Assume there is always a definitive closest point. Implement your function below. ```python import math def distance(x, y): Calculates the Euclidean distance between vector x and y. assert len(x) == len(y), \\"The vectors must have the same length\\" return math.sqrt(sum((xi - yi) ** 2 for xi, yi in zip(x, y))) def classify_point(new_point, training_set): Classifies a new point based on the nearest neighbor in the training set. Arguments: new_point -- tuple: The new data point to classify. training_set -- dict: Known points and their class labels. Returns: str: The class label of the nearest neighbor. assert isinstance(new_point, tuple) and isinstance(training_set, dict) current_key = None min_d = float(\'inf\') for key in training_set: d = distance(new_point, key) if d < min_d: min_d = d current_key = key return training_set[current_key] # Example usage: # print(classify_point((1.5, 2.5), {(1.0, 2.0): \'C\', (2.0, 3.0): \'D\'})) ```","solution":"import math def distance(x, y): Calculates the Euclidean distance between vector x and y. assert len(x) == len(y), \\"The vectors must have the same length\\" return math.sqrt(sum((xi - yi) ** 2 for xi, yi in zip(x, y))) def classify_point(new_point, training_set): Classifies a new point based on the nearest neighbor in the training set. Arguments: new_point -- tuple: The new data point to classify. training_set -- dict: Known points and their class labels. Returns: str: The class label of the nearest neighbor. assert isinstance(new_point, tuple) and isinstance(training_set, dict) current_key = None min_d = float(\'inf\') for key in training_set: d = distance(new_point, key) if d < min_d: min_d = d current_key = key return training_set[current_key] # Example usage: # print(classify_point((1.5, 2.5), {(1.0, 2.0): \'C\', (2.0, 3.0): \'D\'}))"},{"question":"# Secure Communication System with Diffie-Hellman In this task, you will implement a secure communication using the Diffie-Hellman key exchange algorithm. The algorithm will enable two parties, Alice and Bob, to generate a shared secret key that can be used for encrypting their messages. The parties do not share their private keys, but only exchange public keys over an insecure channel. **Task**: Implement the function `secure_diffie_hellman(a: int, p: int) -> Tuple[int, int]` which performs the complete Diffie-Hellman key exchange. It should return a tuple containing the shared secret key calculated by Alice and Bob. **Input**: * `a` (int): A primitive root of prime number `p`. * `p` (int): A large prime number. **Output**: * A tuple (int, int): Shared secret key calculated by Alice and Bob. **Constraints**: 1. (2 leq p leq 10^9) 2. The value of `a` will be a known primitive root of `p`. **Performance Requirements**: * The solution should handle large `p` efficiently. * Ensure the correctness of prime-checking and primitive root assertion. **Example**: ```python a = 2 p = 23 Alice\'s private key: 6 Alice\'s public key: 8 Bob\'s private key: 15 Bob\'s public key: 19 Shared key calculated by Alice: 2 Shared key calculated by Bob: 2 ``` Your implementation should utilize the provided helper functions to ensure the security and efficiency of the key exchange process. # Function Signature ```python from typing import Tuple def secure_diffie_hellman(a: int, p: int) -> Tuple[int, int]: pass ```","solution":"import random from typing import Tuple def modular_exponentiation(base: int, ex: int, mod: int) -> int: Perform modular exponentiation. base^ex % mod result = 1 base = base % mod while ex > 0: if (ex % 2) == 1: # If ex is odd, multiply base with the result result = (result * base) % mod ex = ex >> 1 # exponent = exponent//2 base = (base * base) % mod # base = base^2 % mod return result def secure_diffie_hellman(a: int, p: int) -> Tuple[int, int]: Perform Diffie-Hellman key exchange algorithm to generate a shared secret key. # Private key generation for Alice and Bob alice_private_key = random.randint(2, p-2) bob_private_key = random.randint(2, p-2) # Public key generation using the private key and primitive root alice_public_key = modular_exponentiation(a, alice_private_key, p) bob_public_key = modular_exponentiation(a, bob_private_key, p) # Shared secret key generation shared_key_alice = modular_exponentiation(bob_public_key, alice_private_key, p) shared_key_bob = modular_exponentiation(alice_public_key, bob_private_key, p) return shared_key_alice, shared_key_bob"},{"question":"# Problem: Shortest Distance to Gates Using BFS Objective Given an m x n grid initialized with three types of values: - `-1`: representing a wall or an obstacle. - `0`: representing a gate. - `INF` (2^31 - 1): representing infinitely large empty rooms. Write a function `walls_and_gates(rooms: List[List[int]]) -> None:` that fills each empty room with the distance to its nearest gate. If it’s impossible to reach a gate, the value should remain `INF`. **Your task is to implement this using Breadth-First Search (BFS) for optimal performance.** Example ```python rooms = [ [2147483647, -1, 0, 2147483647], [2147483647, 2147483647, 2147483647, -1], [2147483647, -1, 2147483647, -1], [0, -1, 2147483647, 2147483647] ] walls_and_gates(rooms) # The output grid should be: # [ # [3, -1, 0, 1], # [2, 2, 1, -1], # [1, -1, 2, -1], # [0, -1, 3, 4] # ] ``` Constraints - Walls and gates cannot be replaced, i.e., their values should remain as `-1` and `0` respectively. - The distance calculation should consider only 4 possible moves (up, down, left, and right). - The grid dimensions are: `1 <= m, n <= 500`. Function Signature ```python from typing import List def walls_and_gates(rooms: List[List[int]]) -> None: # Implementation here ``` **Note**: Modify the input grid `rooms` in-place.","solution":"from typing import List from collections import deque def walls_and_gates(rooms: List[List[int]]) -> None: if not rooms: return m, n = len(rooms), len(rooms[0]) queue = deque() # Collect all gates\' positions. for i in range(m): for j in range(n): if rooms[i][j] == 0: queue.append((i, j)) directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] while queue: x, y = queue.popleft() for direction in directions: new_x, new_y = x + direction[0], y + direction[1] if 0 <= new_x < m and 0 <= new_y < n and rooms[new_x][new_y] == 2147483647: rooms[new_x][new_y] = rooms[x][y] + 1 queue.append((new_x, new_y))"},{"question":"# Question: Context: You are required to implement an optimized version of the Hosoya Triangle, a triangular number arrangement where every element is the sum of the two elements directly above it (if they exist). The first two rows are explicitly defined. - 1 - 1 1 The Hosoya number H(i, j) is defined as: - If width == 0 and height in {0, 1}, H(i, j) = 1 - If width == 1 and height in {1, 2}, H(i, j) = 1 - If height > width, H(i, j) = H(i-1, j) + H(i-2, j) - If width == height, H(i, j) = H(i-1, j-1) + H(i-2, j-2) - Otherwise, H(i, j) = 0 Task: Implement a function `optimized_hosoya_triangle(height: int) -> List[List[int]]` that returns the Hosoya Triangle as a list of lists up to the specified height using an optimized approach. Additionally, ensure the `print_optimized_hosoya_triangle(height: int)` function prints the Hosoya triangle in the format shown below. Requirements: * **Input**: A single integer `height` (0 <= height <= 30) * **Output**: A list of lists, where the ith list contains the elements of the ith row of the Hosoya Triangle. * **Performance**: Must include an optimization over the initial recursive function, such as memoization. Example: For an input height of 6, the printed output and returned list should be: ``` 1 1 1 2 1 2 3 2 2 3 5 3 4 3 5 8 5 6 6 5 8 ``` ```python from typing import List def optimized_hosoya_triangle(height: int) -> List[List[int]]: # Implement the optimized generation of the Hosoya Triangle def print_optimized_hosoya_triangle(height: int) -> None: # Implement the printing based on the optimized generation ``` # Constraints: * The height should always be a non-negative integer. * Aim to optimize the solution with memoization to reduce repeated calculations.","solution":"from typing import List def optimized_hosoya_triangle(height: int) -> List[List[int]]: if height == 0: return [[1]] memo = {} def hosoya(i, j): if (i, j) in memo: # Use memoization to avoid recalculating return memo[(i, j)] if (j == 0) and (i in {0, 1}): return 1 if (j == 1) and (i in {1, 2}): return 1 if i > j: result = hosoya(i-1, j) + hosoya(i-2, j) elif i == j: result = hosoya(i-1, j-1) + hosoya(i-2, j-2) else: result = 0 memo[(i, j)] = result return result triangle = [] for i in range(height + 1): row = [] for j in range(i + 1): row.append(hosoya(i, j)) triangle.append(row) return triangle def print_optimized_hosoya_triangle(height: int) -> None: triangle = optimized_hosoya_triangle(height) for row in triangle: print(\\" \\".join(map(str, row)))"},{"question":"# Euler\'s Totient Function Challenge Objective: Write a function `compute_totient` that computes Euler\'s Totient Function, ϕ(n), for a given integer ( n ). Function Signature: ```python def compute_totient(n: int) -> int: ``` Input: - `n`: A single integer ( n ) ((1 leq n leq 10^6)). Output: - Return a single integer which is the value of ϕ(n). Constraints: - ( n ) will always be a positive integer. Example: ```python assert compute_totient(1) == 1 assert compute_totient(2) == 1 assert compute_totient(3) == 2 assert compute_totient(9) == 6 assert compute_totient(10) == 4 ``` Note: 1. For ( n = 1 ), the function should return 1 because there are no integers between 1 and 1 inclusive except 1 itself. 2. For ( n = 2 ), the function should return 1 because only 1 is coprime with 2. 3. For ( n = 9 ), the function should return 6 because the numbers 1, 2, 4, 5, 7, and 8 are coprime with 9. Detailed Instructions: - Initialize the result as ( n ). - Iterate through each number ( i ) from 2 to ( sqrt{n} ). For each ( i ): - If ( i ) divides ( n ), update ( n ) and the result accordingly. - If after the loop ( n ) is greater than 1, update the result one final time. - Return the result. - Ensure that your function handles large inputs efficiently, within the given constraints.","solution":"def compute_totient(n: int) -> int: if n == 1: return 1 result = n p = 2 while p * p <= n: if n % p == 0: while n % p == 0: n //= p result -= result // p p += 1 if n > 1: result -= result // n return result"},{"question":"# Question Imagine you are an instructor at a coding bootcamp, and you need to design a question that targets your students\' understanding of sorting algorithms. You want to ensure they understand both the mechanics and efficiencies of sorting by leveraging an in-place sorting algorithm. Based on the Insertion Sort algorithm, your task is to craft a challenging, clear, and self-contained question. # Context You run a small office supplies store, and you have a list of orders that need to be sorted based on their total cost in ascending order. You decide to use an in-place sorting algorithm due to space constraints within your order management system. # Task Write a function `sort_orders_by_cost(orders)` that receives a list of dictionaries, where each dictionary represents an order with at least two keys: `order_id` (an integer) and `total_cost` (a float). The function should sort the orders in-place based on the `total_cost`. Input - `orders`: A list of dictionaries, where each dictionary has the following structure: ```python orders = [ {\\"order_id\\": 1, \\"total_cost\\": 10.5}, {\\"order_id\\": 2, \\"total_cost\\": 7.2}, {\\"order_id\\": 3, \\"total_cost\\": 13.9}, # ... additional orders ] ``` Output - The `orders` list sorted in ascending order by `total_cost`. Constraints - The list can be empty. - The list can have up to 10^4 orders, but the number of orders can vary. - The `total_cost` values are unique across orders. Performance Requirements The function should be in-place and use O(1) additional space. # Examples ```python orders = [ {\\"order_id\\": 3, \\"total_cost\\": 11.0}, {\\"order_id\\": 1, \\"total_cost\\": 7.5}, {\\"order_id\\": 2, \\"total_cost\\": 9.0} ] sort_orders_by_cost(orders) print(orders) # Output: [ # {\\"order_id\\": 1, \\"total_cost\\": 7.5}, # {\\"order_id\\": 2, \\"total_cost\\": 9.0}, # {\\"order_id\\": 3, \\"total_cost\\": 11.0} # ] ```","solution":"def sort_orders_by_cost(orders): This function sorts the orders in-place based on the total_cost using the insertion sort algorithm. Args: orders (list of dict): A list of dictionaries where each dictionary contains an \'order_id\' (int) and \'total_cost\' (float). Returns: None: The list is sorted in-place. n = len(orders) for i in range(1, n): key_order = orders[i] key_cost = key_order[\'total_cost\'] j = i - 1 while j >= 0 and orders[j][\'total_cost\'] > key_cost: orders[j + 1] = orders[j] j -= 1 orders[j + 1] = key_order"},{"question":"You are tasked with implementing a set of functions to perform various matrix transformations (rotation and inversion) as described below. The purpose is to assess your understanding of matrix manipulation and handling edge cases in algorithm implementation. **Problem Statement**: Implement the following functions to manipulate an input matrix: 1. `rotate_clockwise(matrix)`: Rotates the given matrix 90 degrees clockwise. 2. `rotate_counterclockwise(matrix)`: Rotates the given matrix 90 degrees counterclockwise. 3. `top_left_invert(matrix)`: Performs a top-left to bottom-right transpose of the matrix. 4. `bottom_left_invert(matrix)`: Performs a bottom-left to top-right transpose of the matrix. **Function Signatures**: ```python def rotate_clockwise(matrix: List[List[int]]) -> List[List[int]]: pass def rotate_counterclockwise(matrix: List[List[int]]) -> List[List[int]]: pass def top_left_invert(matrix: List[List[int]]) -> List[List[int]]: pass def bottom_left_invert(matrix: List[List[int]]) -> List[List[int]]: pass ``` **Input**: - `matrix`: A list of lists representing a 2D matrix of integers. **Output**: - Each function should return a new matrix that has been transformed according to the specific function\'s requirements. **Constraints**: - Matrices can include negative and positive integers. - The size of the input matrix can vary but will be a valid 2D list of integers. - Ensure your solutions handle edge cases such as empty matrices and non-square matrices. **Performance Requirements**: - Aim for a solution with a time complexity of (O(n^2)). - Avoid unnecessary memory use by creating new matrices efficiently. **Example**: Given the matrix: ``` matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] ``` Applying the transformations: 1. `rotate_clockwise(matrix)` should return: ``` [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] ``` 2. `rotate_counterclockwise(matrix)` should return: ``` [ [3, 6, 9], [2, 5, 8], [1, 4, 7] ] ``` 3. `top_left_invert(matrix)` should return: ``` [ [1, 4, 7], [2, 5, 8], [3, 6, 9] ] ``` 4. `bottom_left_invert(matrix)` should return: ``` [ [9, 6, 3], [8, 5, 2], [7, 4, 1] ] ``` Write code to implement these transformations while considering the discussed performance, edge cases, and constraints.","solution":"from typing import List def rotate_clockwise(matrix: List[List[int]]) -> List[List[int]]: Rotates the given matrix 90 degrees clockwise. rows, cols = len(matrix), len(matrix[0]) if matrix else 0 rotated = [[0] * rows for _ in range(cols)] for r in range(rows): for c in range(cols): rotated[c][rows - 1 - r] = matrix[r][c] return rotated def rotate_counterclockwise(matrix: List[List[int]]) -> List[List[int]]: Rotates the given matrix 90 degrees counterclockwise. rows, cols = len(matrix), len(matrix[0]) if matrix else 0 rotated = [[0] * rows for _ in range(cols)] for r in range(rows): for c in range(cols): rotated[cols - 1 - c][r] = matrix[r][c] return rotated def top_left_invert(matrix: List[List[int]]) -> List[List[int]]: Performs a top-left to bottom-right transpose of the matrix. rows, cols = len(matrix), len(matrix[0]) if matrix else 0 inverted = [[0] * rows for _ in range(cols)] for r in range(rows): for c in range(cols): inverted[c][r] = matrix[r][c] return inverted def bottom_left_invert(matrix: List[List[int]]) -> List[List[int]]: Performs a bottom-left to top-right transpose of the matrix. rows, cols = len(matrix), len(matrix[0]) if matrix else 0 inverted = [[0] * rows for _ in range(cols)] for r in range(rows): for c in range(cols): inverted[cols - 1 - c][rows - 1 - r] = matrix[r][c] return inverted"},{"question":"Hamming Weight Calculation Given an unsigned integer, write a function to determine the number of \'1\' bits it has (also known as the Hamming weight). Implement this function using two different approaches: 1. Recursive approach using Brian Kernighan\'s Algorithm. 2. Iterative approach using Brian Kernighan\'s Algorithm. # Function Signature ```python def count_ones_recur(n: int) -> int: Using Brian Kernighan\'s Algorithm. (Recursive Approach) :param n: An unsigned integer :return: The number of \'1\' bits in the binary representation of `n` pass def count_ones_iter(n: int) -> int: Using Brian Kernighan\'s Algorithm. (Iterative Approach) :param n: An unsigned integer :return: The number of \'1\' bits in the binary representation of `n` pass ``` # Input * An unsigned integer `n`. # Output * An integer representing the count of \'1\' bits in the binary representation of `n`. # Constraints * `0 <= n <= 2^31 - 1` # Example ```python assert count_ones_recur(11) == 3 assert count_ones_iter(11) == 3 assert count_ones_recur(128) == 1 assert count_ones_iter(128) == 1 assert count_ones_recur(0) == 0 assert count_ones_iter(0) == 0 ``` # Performance Requirements Your implementations should be efficient with a time complexity of O(k), where k is the number of \'1\' bits in the binary representation of `n`. # Additional Notes * Focus on ensuring the correctness by handling edge cases such as the smallest input (0) effectively. * Although inputs are guaranteed to be valid unsigned integers by constraint definition, think about logical correctness and simple and clean recursive/iterative solutions.","solution":"def count_ones_recur(n: int) -> int: Using Brian Kernighan\'s Algorithm. (Recursive Approach) :param n: An unsigned integer :return: The number of \'1\' bits in the binary representation of `n` if n == 0: return 0 else: return 1 + count_ones_recur(n & (n - 1)) def count_ones_iter(n: int) -> int: Using Brian Kernighan\'s Algorithm. (Iterative Approach) :param n: An unsigned integer :return: The number of \'1\' bits in the binary representation of `n` count = 0 while n != 0: n = n & (n - 1) count += 1 return count"},{"question":"# Question: Counting Number of Distinct Networks on a Connectable Device Grid You are given a grid of `n x m` representing a 2D space where each cell initially represents a device **disconnected** from all others (0 represents disconnection). You can perform a sequence of operations to connect devices (turn 0 into 1) and count the number of distinct networks (groups of connected devices) after each operation. Implement the function `distinct_networks(n, m, positions)`: - **Input**: - `n` (int): Number of rows in the grid. - `m` (int): Number of columns in the grid. - `positions` (List[List[int]]): List of positions to perform \\"connect\\" operations in the form of [row, col]. - **Output**: - List[int]: After each operation in `positions`, output the current number of distinct networks. # Example: ```python def distinct_networks(n, m, positions): # implement this function # Example usage n = 3 m = 3 positions = [[0, 0], [0, 1], [1, 2], [2, 1]] print(distinct_networks(n, m, positions)) # Expected Output: [1, 1, 2, 3] ``` # Constraints: - 1 <= n, m <= 1000 - 1 <= len(positions) <= 10000 # Notes: - You may assume that the grid is surrounded by water and is initially all water. - Use the Union-Find data structure to manage merging and finding connected components efficiently. - Ensure path compression and union by size are used for optimization.","solution":"class UnionFind: def __init__(self, size): self.parent = list(range(size)) self.rank = [1] * size self.count = 0 def find(self, p): if self.parent[p] != p: self.parent[p] = self.find(self.parent[p]) return self.parent[p] def union(self, p, q): rootP = self.find(p) rootQ = self.find(q) if rootP != rootQ: if self.rank[rootP] > self.rank[rootQ]: self.parent[rootQ] = rootP elif self.rank[rootP] < self.rank[rootQ]: self.parent[rootP] = rootQ else: self.parent[rootQ] = rootP self.rank[rootP] += 1 self.count -= 1 def distinct_networks(n, m, positions): uf = UnionFind(n * m) grid = [[0] * m for _ in range(n)] results = [] directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] for x, y in positions: if grid[x][y] == 1: results.append(uf.count) continue grid[x][y] = 1 uf.count += 1 index1 = x * m + y for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and grid[nx][ny] == 1: index2 = nx * m + ny uf.union(index1, index2) results.append(uf.count) return results"},{"question":"# Combination Sum **Problem Statement**: You are given an array `nums` containing unique positive integers and an integer `target`. Write a function that computes the number of unique combinations that sum up to the `target`. A combination means you can use numbers from `nums` multiple times but the order in sequence matters. Implement two approaches: 1. **Top-Down with Memoization**: Recursively solve subproblems and store results to avoid redundant calculations. 2. **Bottom-Up with Tabulation**: Iteratively fill a table where each cell represents the number of combinations summing to that index. **Function Signature**: ```python def find_combination_sum_topdown(nums: List[int], target: int) -> int: pass def find_combination_sum_bottom_up(nums: List[int], target: int) -> int: pass ``` **Constraints**: - Each number in `nums` is a positive integer. - No duplicates in `nums`. - `target` is a positive integer. - Different sequences are counted as different combinations. - Performance should be optimal for target values up to 1000. **Example**: ```python nums = [1, 2, 3] target = 4 find_combination_sum_topdown(nums, target) -> 7 find_combination_sum_bottom_up(nums, target) -> 7 ``` **Follow-Up**: What changes need to be made if negative numbers are allowed in the `nums` array? Explain any extra constraints or techniques that must be applied.","solution":"from typing import List def find_combination_sum_topdown(nums: List[int], target: int) -> int: memo = {} def recurse(current_target): if current_target in memo: return memo[current_target] if current_target == 0: return 1 if current_target < 0: return 0 combination_count = 0 for num in nums: combination_count += recurse(current_target - num) memo[current_target] = combination_count return combination_count return recurse(target) def find_combination_sum_bottom_up(nums: List[int], target: int) -> int: dp = [0] * (target + 1) dp[0] = 1 for i in range(1, target + 1): for num in nums: if i - num >= 0: dp[i] += dp[i - num] return dp[target]"},{"question":"--- **Objective**: Implement a utility function to resolve a potentially relative file path to an absolute file path. **Scenario**: You are developing a logging system for a server application. Logs can be stored in different directories, depending on the configuration. To ensure the logging system correctly accesses and writes to the specified log file, you need a function that takes a given file path and returns its absolute form. # Requirements: * **Function Name**: `resolve_file_path` * **Input**: A single string `file` representing a file path. It may include user home directory shortcuts (`~`) and relative paths. * **Output**: A single string representing the absolute path of the file. # Constraints: * The input path might not necessarily point to an existing file. * The function should work consistently across different operating systems. # Function Signature: ```python def resolve_file_path(file: str) -> str: ``` # Examples: ```python assert resolve_file_path(\\"~/documents/file.txt\\") == \\"/home/user/documents/file.txt\\" # Example path in a Linux environment assert resolve_file_path(\\"./file.txt\\") == \\"/current/working/directory/file.txt\\" assert resolve_file_path(\\"/absolute/path/to/file\\") == \\"/absolute/path/to/file\\" ``` # Explanation: * The first example converts a user home directory shortcut to the full home directory path. * The second example resolves a relative path from the current working directory to an absolute path. * The third example confirms that an already absolute path remains unchanged. # Task: Implement the `resolve_file_path` function to meet the specified requirements and pass the provided test cases.","solution":"import os def resolve_file_path(file: str) -> str: Returns the absolute path of the given file path, resolving any user (~) and relative (.) shortcuts. Parameters: file (str): A file path which can contain user directory shortcuts or be a relative path. Returns: str: The absolute path of the file. return os.path.abspath(os.path.expanduser(file))"},{"question":"# Coding Problem: Cocktail Shaker Sort Implementation You are tasked with implementing the Cocktail Shaker Sort algorithm, which is a variation of Bubble Sort. In this version, the algorithm iterates through the array in both forward and backward directions to sort the elements. This enhances the capability of the regular Bubble Sort, especially with certain array configurations. Function Signature ```python def cocktail_shaker_sort(arr: List[int]) -> List[int]: pass ``` Input - `arr`: A list of integers `arr` where 1 <= len(arr) <= 10^5. Output - Return a list of integers sorted in non-decreasing order. Constraints * You must implement the sorting in-place, and the final array should be sorted in ascending order. * The function should handle edge cases gracefully, such as an empty list or a list with a single element. Performance Requirements * The function should be efficient enough to handle worst-case scenarios within reasonable time constraints for N = 100,000. Example ```python arr1 = [3, 2, 1] assert cocktail_shaker_sort(arr1) == [1, 2, 3] arr2 = [5, 1, 4, 2, 8] assert cocktail_shaker_sort(arr2) == [1, 2, 4, 5, 8] arr3 = [1, 2, 3, 4, 5] assert cocktail_shaker_sort(arr3) == [1, 2, 3, 4, 5] ``` # Additional Context Cocktail Shaker Sort is sometimes referred to as Bidirectional Bubble Sort. While it improves over the traditional Bubble Sort by addressing some inefficiencies, it still shares the same O(N^2) worst-case complexity. Your goal is to implement this algorithm efficiently and handle edge cases properly.","solution":"from typing import List def cocktail_shaker_sort(arr: List[int]) -> List[int]: Sorts the given list using the Cocktail Shaker Sort algorithm. Args: arr (List[int]): The list of integers to sort. Returns: List[int]: The sorted list. n = len(arr) if n <= 1: return arr # already sorted or empty is_sorted = False start = 0 end = n - 1 while not is_sorted: is_sorted = True # Forward pass for i in range(start, end): if arr[i] > arr[i + 1]: arr[i], arr[i + 1] = arr[i + 1], arr[i] is_sorted = False if is_sorted: break is_sorted = True end -= 1 # Backward pass for i in range(end, start, -1): if arr[i] < arr[i - 1]: arr[i], arr[i - 1] = arr[i - 1], arr[i] is_sorted = False start += 1 return arr"},{"question":"**Count the Number of Disjoint Sets after Each Operation** You are given a list of positions in a 2D grid. Initially, the grid contains only water cells represented by `0`. Each position in the list represents a cell that is to be converted from water (`0`) to land (`1`). Create a class `GridIslands` which will efficiently manage the conversion of water cells to land cells and count the number of disjoint islands after each land conversion. Two land cells are considered connected if they are adjacent horizontally or vertically. # Class Methods `class GridIslands:` - `def __init__(self, m: int, n: int) -> None:` * Initializes a `m x n` grid of water cells. - `def addLand(self, x: int, y: int) -> int:` * Converts the cell at position (x, y) to land (`1`). * Returns the number of disjoint islands after this operation. # Input - `m` - an integer representing the number of rows in the grid (m >= 1). - `n` - an integer representing the number of columns in the grid (n >= 1). - A list of operations, where each operation is represented as a tuple (x, y). # Output - A list of integers where each integer is the count of disjoint islands after the respective addLand operation. # Constraints - You can assume the operation `(x, y)` is valid and performed only once for each unique cell. - Dimensions `m` and `n` are guaranteed to be at most 10^3. # Example ```python grid_islands = GridIslands(3, 3) positions = [(0,0), (0,1), (1,2), (2,1)] results = [grid_islands.addLand(x, y) for x, y in positions] print(results) # Output: [1, 1, 2, 3] ``` In this example: - Initially, the grid is filled with water. - After converting (0,0) to land -> There is 1 island. - After converting (0,1) to land -> There is 1 island (since (0,0) and (0,1) are connected). - After converting (1,2) to land -> There are 2 islands. - After converting (2,1) to land -> There are 3 islands.","solution":"class GridIslands: def __init__(self, m: int, n: int) -> None: self.m = m self.n = n self.grid = [[0] * n for _ in range(m)] self.parent = {} self.rank = {} self.count = 0 def find(self, position): if self.parent[position] != position: self.parent[position] = self.find(self.parent[position]) return self.parent[position] def union(self, p1, p2): root1 = self.find(p1) root2 = self.find(p2) if root1 != root2: if self.rank[root1] > self.rank[root2]: self.parent[root2] = root1 elif self.rank[root1] < self.rank[root2]: self.parent[root1] = root2 else: self.parent[root2] = root1 self.rank[root1] += 1 self.count -= 1 def addLand(self, x: int, y: int) -> int: if self.grid[x][y] == 1: return self.count self.grid[x][y] = 1 position = (x, y) self.parent[position] = position self.rank[position] = 0 self.count += 1 directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < self.m and 0 <= ny < self.n and self.grid[nx][ny] == 1: self.union(position, (nx, ny)) return self.count"},{"question":"# Question: Implement and Use a Fenwick Tree You are required to implement a Fenwick Tree (Binary Indexed Tree) to efficiently handle prefix sum queries and point updates. Given a list of integers, your Fenwick Tree should be able to: 1. Construct the tree. 2. Compute the sum of integers from the beginning to a given index. 3. Update the value at a specific index and propagate this change through the tree. Function Specifications **Implementation** 1. Create a class `FenwickTree` which includes the following methods: 1. **`__init__(self, nums: List[int])`**: Initializes the Fenwick Tree with a given list of integers. 2. **`construct(self) -> List[int]`**: Constructs the tree and returns the underlying data structure used by the tree. 3. **`get_sum(self, bit_tree: List[int], index: int) -> int`**: Returns the sum of elements from start to the given index. 4. **`update(self, bit_tree: List[int], index: int, value: int)`**: Updates the tree at the given index by adding the value to it. **Input/Output Formats** - The input to the `__init__` method will be a list of integers. - The `construct` method will return the Fenwick Tree structure used to maintain the prefix sums. - The `get_sum` method will take the constructed tree and an index (0-based) as input and return the prefix sum up to that index. - The `update` method will take the constructed tree, an index (0-based), and a value, and update the tree. Example ```python # Initialize the Fenwick Tree ft = FenwickTree([1, 2, 3, 4, 5]) # Construct the tree bit_tree = ft.construct() # Query the sum of the first 3 elements sum_first_3 = ft.get_sum(bit_tree, 2) # Output should be 1+2+3 = 6 # Update the value at index 1 to 10 ft.update(bit_tree, 1, 10 - 2) # We add 8 because we are changing 2 to 10 # Query the sum again after update sum_first_3_after_update = ft.get_sum(bit_tree, 2) # Output should be 1+10+3 = 14 ``` # Constraints * The input list `nums` will contain at least one and at most 10^5 integers. * All integers in the list and the update values will be in the range of -10^4 to 10^4. Ensure that the solution is efficient and handles edge cases properly.","solution":"class FenwickTree: def __init__(self, nums): Initializes the Fenwick Tree with a given list of integers. self.nums = nums self.bit_tree = [0] * (len(nums) + 1) def construct(self): Constructs the Fenwick Tree and returns the underlying data structure used by the tree. for i, num in enumerate(self.nums): self.update(self.bit_tree, i, num) return self.bit_tree def get_sum(self, bit_tree, index): Returns the sum of elements from start to the given index. index += 1 # Convert to 1-based index total = 0 while index > 0: total += bit_tree[index] index -= index & -index return total def update(self, bit_tree, index, value): Updates the tree at the given index by adding the value to it. index += 1 # Convert to 1-based index while index < len(bit_tree): bit_tree[index] += value index += index & -index"},{"question":"# String Multiplication without Built-in Integer Conversion Objective: You need to implement a function that multiplies two non-negative integers represented as strings and returns the result as a string. You must adhere to the constraints and avoid using any direct integer conversion methods or built-in libraries for large integer manipulation. Function Signature: ```python def multiply(num1: str, num2: str) -> str: ``` Input: * `num1` - A non-negative integer represented as a string. Length is less than 110. * `num2` - A non-negative integer represented as a string. Length is less than 110. Output: * Returns the product of the two numbers, also represented as a string. Constraints: * Both `num1` and `num2` contain only digits 0-9. * Both `num1` and `num2` do not contain any leading zeros, except the number \\"0\\" itself. Performance Requirements: Your solution should handle the string multiplication efficiently, within reasonable time and space complexity, given the constraints. Example: Example 1: ```python multiply(\\"2\\", \\"3\\") ``` Output: ```plaintext \\"6\\" ``` Example 2: ```python multiply(\\"123\\", \\"456\\") ``` Output: ```plaintext \\"56088\\" ``` Points to Consider: 1. Ensure positional values are properly managed. 2. Handle edge cases such as multiplication by zero. 3. Optimize for both time and space while adhering to constraints.","solution":"def multiply(num1: str, num2: str) -> str: if num1 == \\"0\\" or num2 == \\"0\\": return \\"0\\" # Initialize result array to store the results of the multiplication result = [0] * (len(num1) + len(num2)) # Reverse the strings to make it easier to multiply from right to left num1, num2 = num1[::-1], num2[::-1] # Multiply each digit of num1 by each digit of num2 for i in range(len(num1)): for j in range(len(num2)): # Multiply current digits and add to corresponding position in result array result[i + j] += int(num1[i]) * int(num2[j]) # Handle carry over result[i + j + 1] += result[i + j] // 10 result[i + j] %= 10 # Convert result array back to string, removing leading zeros while len(result) > 1 and result[-1] == 0: result.pop() return \'\'.join(map(str, result[::-1]))"},{"question":"# Flatten a Matrix in a More Efficient Way Scenario Given a matrix (2D list) that might contain other nested sublists, your task is to write a function that flattens the matrix into a single-level list. The function should use an iterative approach rather than a recursive one to avoid the potential issues with deep recursion. This means you should rely more on structures like stacks or queues to manage the elements to be processed. Function Signature ```python def flatten_matrix(matrix: List[List[Any]]) -> List[Any]: Flattens a given nested matrix into a single list using an iterative approach. Parameters: - matrix: List[List[Any]] : A 2D matrix which can contain nested lists. Returns: - List[Any]: A flattened list containing all elements of the matrix and sublists in row-major order. pass ``` Input Format - `matrix`: A list of lists where each sublist can itself contain nested lists or elements of any type. Output Format - A single list containing all elements of the matrix and nested lists in row-major order. Constraints - You must use an iterative rather than a recursive approach. - The solution should handle arbitrarily nested lists. - Avoid excessive memory usage, i.e., try to keep the space complexity as low as possible. Example ```python # Example 1: input_matrix = [[1, 2, [3]], [4, [5, 6]], 7, [8]] output_list = flatten_matrix(input_matrix) print(output_list) # Output: [1, 2, 3, 4, 5, 6, 7, 8] # Example 2: input_matrix = [[[\'a\']], [[\'b\', \'c\']], \'d\'] output_list = flatten_matrix(input_matrix) print(output_list) # Output: [\'a\', \'b\', \'c\', \'d\'] ``` Notes: - Consider using a stack or queue to manage the elements to be processed. - Make sure to handle strings correctly, treating them as atomic elements rather than iterables.","solution":"from typing import Any, List def flatten_matrix(matrix: List[List[Any]]) -> List[Any]: Flattens a given nested matrix into a single list using an iterative approach. Parameters: - matrix: List[List[Any]] : A 2D matrix which can contain nested lists. Returns: - List[Any]: A flattened list containing all elements of the matrix and sublists in row-major order. result = [] stack = matrix[::-1] # Initialize stack with matrix elements in reverse order while stack: element = stack.pop() if isinstance(element, list): stack.extend(element[::-1]) # If element is a list, add its contents to the stack in reverse order. else: result.append(element) # If element is not a list, add it to the result list directly. return result"},{"question":"# Context Imagine you are an urban planner tasked with placing a new facility in a city grid that should be as accessible as possible to all residential buildings. The city grid is given as a 2D matrix where: - `0` represents an empty space, - `1` represents a residential building, and - `2` represents an obstacle and cannot be built upon or traversed. # Problem Statement Write a function `shortest_distance(grid: List[List[int]]) -> int` that computes the shortest total distance from a new facility (placed on any empty cell) to all buildings. If it is impossible to place such a facility to satisfy the requirement, return `-1`. # Input * `grid`: A 2D list of integers representing the city layout (values 0, 1, and 2). # Output * An integer representing the shortest total distance from a new facility to all buildings or `-1` if no such placement is possible. # Constraints * The grid dimensions will not exceed 100x100. * There will be at least one building and one empty space. # Example ```python grid = [ [1, 0, 2, 0, 1], [0, 0, 0, 0, 0], [0, 0, 1, 0, 0] ] assert shortest_distance(grid) == 7 grid = [ [1, 0, 2], [0, 2, 2], [2, 2, 1] ] assert shortest_distance(grid) == -1 ``` # Explanation In the first example, placing the facility at grid position (1, 2) yields the minimum distance of 7 (sum of distances to all buildings). In the second example, there is no empty space that can reach all buildings due to the obstacles, so the return value is `-1`.","solution":"from collections import deque from typing import List, Tuple def bfs(grid: List[List[int]], start: Tuple[int, int], distance: List[List[int]], reach_cnt: List[List[int]], num_building: int): rows, cols = len(grid), len(grid[0]) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([(start[0], start[1], 0)]) visited = [[False] * cols for _ in range(rows)] visited[start[0]][start[1]] = True while queue: r, c, dist = queue.popleft() for dx, dy in directions: nr, nc = r + dx, c + dy if 0 <= nr < rows and 0 <= nc < cols and not visited[nr][nc]: visited[nr][nc] = True if grid[nr][nc] == 0: distance[nr][nc] += dist + 1 reach_cnt[nr][nc] += 1 queue.append((nr, nc, dist + 1)) elif grid[nr][nc] == 1: # reachable building case reach_cnt[nr][nc] = -1 def shortest_distance(grid: List[List[int]]) -> int: rows, cols = len(grid), len(grid[0]) distance = [[0] * cols for _ in range(rows)] reach_cnt = [[0] * cols for _ in range(rows)] num_building = sum(cell == 1 for row in grid for cell in row) for r in range(rows): for c in range(cols): if grid[r][c] == 1: bfs(grid, (r, c), distance, reach_cnt, num_building) result = float(\'inf\') for r in range(rows): for c in range(cols): if grid[r][c] == 0 and reach_cnt[r][c] == num_building: result = min(result, distance[r][c]) return result if result != float(\'inf\') else -1"},{"question":"# Question: Scenario: You are working at an e-commerce company managing product catalogs represented as binary trees. The catalog tree needs to be balanced so that searching, inserting, and deleting products can maintain optimal performance. Your task is to write a function to determine if a given catalog tree is balanced. Task: Write a Python function `is_balanced(root)` that takes the root of a binary tree and returns `True` if the tree is balanced and `False` otherwise. A binary tree is considered balanced if for every node in the tree, the height of the left and right subtrees differ by no more than 1. Function Signature: ```python def is_balanced(root) -> bool: pass ``` Input: * `root`: The root node of a binary tree. Each node has attributes `left` and `right` which point to the left and right subtrees respectively. Output: * Return a boolean value: `True` if the binary tree is balanced, `False` otherwise. Constraints: * The number of nodes in the tree is in the range `[0, 10^4]`. * Node values are arbitrary and do not affect the balance check. * Use O(N) time complexity for the solution. Example: Consider the binary tree: ``` 1 / 2 3 / 4 5 / 6 ``` The function call `is_balanced(root)` where root is the node with value 1 should return `False`, as the left subtree height (3) and right subtree height (1) differ by more than 1.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_balanced(root) -> bool: def check_balance(node): if not node: return 0, True left_height, left_balanced = check_balance(node.left) right_height, right_balanced = check_balance(node.right) current_height = max(left_height, right_height) + 1 is_current_balanced = abs(left_height - right_height) <= 1 return current_height, left_balanced and right_balanced and is_current_balanced _, balanced = check_balance(root) return balanced"},{"question":"# Question: Implementing and Optimizing Merge Sort Context: You are tasked with implementing a custom sorting function for a large-scale application where stability (maintaining the relative order of records with equal keys) is crucial. The application frequently processes large datasets that do not fit into memory, thus external sorting is used, and merge sort is identified as a suitable algorithm. Problem Statement: Write a function `optimized_merge_sort` that sorts an array of integers in ascending order using an optimized version of merge sort. Specifically, you need to: 1. Implement the basic merge sort algorithm. 2. Optimize the merge step to reduce additional space complexity by performing in-place merges if possible. 3. Hybridize the algorithm with an insertion sort for small sub-arrays (size <= 7). Input: * A list of integers, `arr`, where 0 <= len(arr) <= 10000. Output: * The input list sorted in ascending order. Constraints: * You should aim to keep the additional space requirement minimal. * You can assume that the integers in the array range from -10^6 to 10^6. Requirements: 1. Implement `optimized_merge_sort(arr: List[int]) -> List[int]`. 2. Make sure your implementation is stable. 3. Ensure your solution has a worst-case time complexity of O(n log(n)). 4. Optimize the merge to reduce space complexity where possible. 5. Hybridize with insertion sort for small sub-arrays. Example: ```python from typing import List def optimized_merge_sort(arr: List[int]) -> List[int]: # Implement your solution here pass # Example usage arr = [5, 2, 9, 1, 5, 6] sorted_arr = optimized_merge_sort(arr) print(sorted_arr) # Output: [1, 2, 5, 5, 6, 9] ```","solution":"from typing import List def insertion_sort(arr: List[int], left: int, right: int) -> None: for i in range(left + 1, right + 1): key = arr[i] j = i - 1 while j >= left and key < arr[j]: arr[j + 1] = arr[j] j -= 1 arr[j + 1] = key def merge(arr: List[int], left: int, middle: int, right: int) -> None: if arr[middle] <= arr[middle + 1]: return # The array is already sorted n1 = middle - left + 1 n2 = right - middle # Create temp arrays left_arr = arr[left:middle + 1] right_arr = arr[middle + 1:right + 1] # Merge the temp arrays back into arr[left:right+1] i = j = 0 k = left while i < n1 and j < n2: if left_arr[i] <= right_arr[j]: arr[k] = left_arr[i] i += 1 else: arr[k] = right_arr[j] j += 1 k += 1 # Copy the remaining elements of left_arr if there are any while i < n1: arr[k] = left_arr[i] i += 1 k += 1 # Copy the remaining elements of right_arr if there are any while j < n2: arr[k] = right_arr[j] j += 1 k += 1 def optimized_merge_sort_helper(arr: List[int], left: int, right: int) -> None: if left < right: # Use insertion sort for small subarrays if right - left + 1 <= 7: insertion_sort(arr, left, right) else: middle = (left + right) // 2 optimized_merge_sort_helper(arr, left, middle) optimized_merge_sort_helper(arr, middle + 1, right) merge(arr, left, middle, right) def optimized_merge_sort(arr: List[int]) -> List[int]: if len(arr) <= 1: return arr optimized_merge_sort_helper(arr, 0, len(arr) - 1) return arr"},{"question":"As a software engineer at a company specializing in text analysis tools, you are assigned the task of finding patterns in large texts efficiently. Your goal is to implement the Rabin-Karp string matching algorithm to locate the first occurrence of a pattern within a text. Task: Write a function `find_pattern(pattern: str, text: str) -> int` that implements the Rabin-Karp algorithm to find and return the starting index of the first occurrence of the pattern within the text. If the pattern is not found, return `-1`. Input: - `pattern` (string): The pattern string to search for. - `text` (string): The text string in which to search the pattern. Output: - Return the starting index (0-based) of the first occurrence of the pattern within the text. If the pattern is not found, return `-1`. Constraints: - The pattern and text will only contain lowercase alphabetic characters (`a-z`). - Consider that hash collisions can occur and need to be checked with actual string matching. Example: ```python print(find_pattern(\\"abc\\", \\"abcdefg\\")) # Output: 0 print(find_pattern(\\"def\\", \\"abcdefg\\")) # Output: 3 print(find_pattern(\\"xyz\\", \\"abcdefg\\")) # Output: -1 print(find_pattern(\\"aaa\\", \\"aaaa\\")) # Output: 0 print(find_pattern(\\"\\", \\"abcdefg\\")) # Output: -1 print(find_pattern(\\"abcdefg\\", \\"\\")) # Output: -1 ``` Note: - Handle edge cases, such as empty strings and the pattern being longer than the text. - Ensure your implementation is efficient concerning time and space complexity considerations. Good luck, and happy coding!","solution":"def find_pattern(pattern: str, text: str) -> int: if not pattern or not text or len(pattern) > len(text): return -1 base = 256 # The number of characters in the input alphabet (a-z). prime = 101 # A prime number to mod the hash values. def get_hash(s: str, end: int) -> int: Calculate hash value for the string `s` up to `end` (exclusive). h = 0 for i in range(end): h = (h * base + ord(s[i])) % prime return h n, m = len(text), len(pattern) pattern_hash = get_hash(pattern, m) text_hash = get_hash(text, m) highest_base = pow(base, m-1, prime) # highest_base = base^(m-1) % prime for i in range(n - m + 1): if pattern_hash == text_hash: # Double check to avoid hash collision if text[i:i+m] == pattern: return i if i < n - m: # Calculate hash for the next substring text_hash = (text_hash - ord(text[i]) * highest_base) % prime text_hash = (text_hash * base + ord(text[i + m])) % prime # We might get negative value of t, converting it to positive if text_hash < 0: text_hash += prime return -1"},{"question":"# Stooge Sort: Educational Exercise Context Stooge Sort is a recursive sorting algorithm, notable for its conceptual simplicity but impractical due to its inefficiency. Despite its impracticality in real-world applications, it presents an interesting example of recursive sorting. Task Implement the Stooge Sort algorithm. Given an array of integers, your task is to sort it using Stooge Sort and output the sorted array. Function Signature ```python def stoogesort(arr: List[int], l: int, h: int) -> None: # implement sorting in place ``` Input/Output Format * **Input:** * arr (List[int]): a list of integers to sort * l (int): starting index of the segment to sort * h (int): ending index of the segment to sort * **Output:** * The function should sort the array in place and should not return any value. Constraints * 0 ≤ len(arr) ≤ 10^2 * -10^3 ≤ arr[i] ≤ 10^3 Example ```python arr = [3, 1, 4, 1, 5, 9, 2, 6, 5] stoogesort(arr, 0, len(arr) - 1) print(arr) # Output: [1, 1, 2, 3, 4, 5, 5, 6, 9] ``` Performance Requirements * Time complexity should be O(n^2.709), which is expected for Stooge Sort. * Space complexity should be O(1), although stack space due to recursion is inevitable.","solution":"from typing import List def stoogesort(arr: List[int], l: int, h: int) -> None: if l >= h: return # If the element at l is greater than the element at h, swap them if arr[l] > arr[h]: arr[l], arr[h] = arr[h], arr[l] # If there are more than 2 elements in the array if h - l + 1 > 2: t = (h - l + 1) // 3 # Recursively sort the first 2/3 of the array stoogesort(arr, l, h - t) # Recursively sort the last 2/3 of the array stoogesort(arr, l + t, h) # Recursively sort the first 2/3 of the array again stoogesort(arr, l, h - t)"},{"question":"# Question: Reverse Words in a Sentence **Objective**: Write a function that takes a sentence as input and returns the sentence with the words reversed. Each word should still maintain its original ordering of characters. Input and Output Formats * **Input**: - A string `sentence` composed of words separated by one or more spaces. * **Output**: - A string in which the words are reversed. Constraints * The input string may contain leading or trailing spaces. * The words in the input string are separated by spaces, and all words are composed of alphabetic characters only. * The function should handle multiple spaces between words appropriately by treating each as a single delimiter. Scenario Suppose you are building a text processing feature for a note-taking app. One of the functionalities required is to provide a reverse ordering of words in the notes for a particular feature. Function Signature ```python def reverse_words(sentence: str) -> str: pass ``` Example ```python print(reverse_words(\\" hello world \\")) # \\"world hello\\" print(reverse_words(\\"The quick brown fox\\")) # \\"fox brown quick The\\" print(reverse_words(\\" \\")) # \\"\\" print(reverse_words(\\"\\")) # \\"\\" ``` # Additional Requirements * The function must be efficient, aiming for linear time complexity. * The function should handle edge cases like empty or whitespace-only strings correctly.","solution":"def reverse_words(sentence: str) -> str: Reverses the words in the given sentence. Args: sentence (str): Input sentence as a string. Returns: str: Sentence with the words in reverse order. # Split the sentence by spaces and remove empty strings caused by multiple spaces words = [word for word in sentence.split(\' \') if word] # Reverse the list of words and join them with a single space reversed_sentence = \' \'.join(words[::-1]) return reversed_sentence"},{"question":"Context You are required to implement a custom doubly linked list. The list should support various operations like adding nodes, removing nodes, and accessing elements based on their position. This implementation will help you understand the core mechanisms and edge cases associated with linked lists. Task Implement a `DoublyLinkedList` class with the following methods: 1. `add_at_head(value)`: Insert a new node with a given value at the head of the list. 2. `add_at_tail(value)`: Insert a new node with a given value at the tail of the list. 3. `remove_at_position(position)`: Remove the node at the specified position in the list. 4. `get_at_position(position)`: Return the value of the node at the specified position in the list. Constraints - Each operation should have its respective time complexity analyzed. - The positions are zero-indexed. - If the `position` is out of bounds, `remove_at_position` and `get_at_position` should return `None`. Input and Output Format All inputs are method calls and their parameters. For `get_at_position`, the output should be the value at the position or `None` if the position is invalid. Example Usage ```python dll = DoublyLinkedList() # Add elements at head dll.add_at_head(10) dll.add_at_head(20) # Add elements at tail dll.add_at_tail(30) # Get element at position print(dll.get_at_position(1)) # Output: 10 # Remove element at position dll.remove_at_position(2) # Get element at position after removal print(dll.get_at_position(2)) # Output: None ``` Performance Requirements - `add_at_head` and `add_at_tail` should operate in O(1) time. - `remove_at_position` and `get_at_position` should ideally operate as efficiently as possible. ```python class DoublyLinkedListNode: def __init__(self, value): self.value = value self.next = None self.prev = None class DoublyLinkedList: def __init__(self): self.head = None self.tail = None def add_at_head(self, value): # Your code here pass def add_at_tail(self, value): # Your code here pass def remove_at_position(self, position): # Your code here pass def get_at_position(self, position): # Your code here pass ```","solution":"class DoublyLinkedListNode: def __init__(self, value): self.value = value self.next = None self.prev = None class DoublyLinkedList: def __init__(self): self.head = None self.tail = None def add_at_head(self, value): new_node = DoublyLinkedListNode(value) if not self.head: self.head = new_node self.tail = new_node else: new_node.next = self.head self.head.prev = new_node self.head = new_node def add_at_tail(self, value): new_node = DoublyLinkedListNode(value) if not self.tail: self.head = new_node self.tail = new_node else: new_node.prev = self.tail self.tail.next = new_node self.tail = new_node def remove_at_position(self, position): if position < 0: return None current = self.head index = 0 while current and index < position: current = current.next index += 1 if not current: return None if current.prev: current.prev.next = current.next else: self.head = current.next if current.next: current.next.prev = current.prev else: self.tail = current.prev return current.value def get_at_position(self, position): if position < 0: return None current = self.head index = 0 while current and index < position: current = current.next index += 1 return current.value if current else None"},{"question":"Scenario You are given a large set of integers and need to analyze coprimality properties for cryptographic usages, particularly in the context of developing secure encryption algorithms. A core part of this analysis involves calculating the Euler\'s Totient function values for given integers. Task Write a Python function `custom_totient(n)` that computes the Euler\'s Totient function φ(n) for a given integer ( n ). Requirements 1. Your function must correctly handle any integer input within the range 1 to ( 10^6 ). 2. Your implementation should have a time complexity of ( O(sqrt{n}) ). 3. You should address any edge cases such as ( n = 1 ). 4. Aim to keep your space complexity to ( O(1) ). Input * An integer ( n ) (1 ≤ ( n ) ≤ ( 10^6 )). Output * An integer representing the count of numbers less than or equal to ( n ) that are coprime with ( n ). Example ```python print(custom_totient(9)) # Output: 6 print(custom_totient(15)) # Output: 8 print(custom_totient(1)) # Output: 1 print(custom_totient(25)) # Output: 20 ``` Explanation 1. For ( n = 9 ), integers 1, 2, 4, 5, 7, and 8 are coprime with 9. 2. For ( n = 15 ), integers 1, 2, 4, 7, 8, 11, 13, and 14 are coprime with 15. Write your function to meet the requirements and ensure all edge cases are considered.","solution":"def custom_totient(n): Computes the Euler\'s Totient function φ(n) for an integer n. Args: n (int): The integer input. Returns: int: The count of numbers less than or equal to n that are coprime with n. if n == 1: return 1 result = n p = 2 while p * p <= n: if n % p == 0: while n % p == 0: n //= p result -= result // p p += 1 if n > 1: result -= result // n return result"},{"question":"Flatten Arrays **Background**: Imagine you are working on a project where you need to preprocess incoming data that consists of several nested arrays. These arrays can be arbitrarily deeply nested and can include elements of different types. Your task is to flatten these nested arrays into a single, one-dimensional array. **Objective**: Write a function `custom_flatten` that flattens a nested array into a single list. Additionally, write a generator function `custom_flatten_iter` that yields elements from the nested array one by one in a flattened manner. Function Signature ```python def custom_flatten(input_arr: list) -> list: pass def custom_flatten_iter(input_arr: list) -> iter: pass ``` **Input Format**: - The input to the function is a list that may contain nested lists. The function should handle lists that contain any level of nesting. **Output Format**: - `custom_flatten` should return a single flattened list containing all the elements from the nested arrays. - `custom_flatten_iter` should yield elements from the nested list one by one in a flattened manner. **Constraints**: - The depth of the nested list can be large but will not exceed the maximum recursion depth of the language. - Elements within the arrays can be of any type. - Strings should not be split into individual characters but should be treated as single values. **Performance Requirements**: - The function should have a time complexity of O(n), where n is the total number of elements in the input list. - Space complexity should be O(n) for the non-generator function and O(1) additional space for the generator function aside from the input and output storage. **Examples**: ```python # Example 1: input_arr = [1, [2, 3, [4]], 5] assert custom_flatten(input_arr) == [1, 2, 3, 4, 5] assert list(custom_flatten_iter(input_arr)) == [1, 2, 3, 4, 5] # Example 2: input_arr = [\\"a\\", [\\"b\\", [\\"c\\", [\\"d\\"]]]] assert custom_flatten(input_arr) == [\\"a\\", \\"b\\", \\"c\\", \\"d\\"] assert list(custom_flatten_iter(input_arr)) == [\\"a\\", \\"b\\", \\"c\\", \\"d\\"] # Example 3: input_arr = [[], [[], [[]]]] assert custom_flatten(input_arr) == [] assert list(custom_flatten_iter(input_arr)) == [] ``` Write your solution below this line: ```python # Your implementation goes here # def custom_flatten(input_arr: list) -> list: # def custom_flatten_iter(input_arr: list) -> iter: ```","solution":"def custom_flatten(input_arr: list) -> list: Flattens a nested list into a single list. result = [] for element in input_arr: if isinstance(element, list): result.extend(custom_flatten(element)) else: result.append(element) return result def custom_flatten_iter(input_arr: list): A generator that flattens a nested list and yields elements one by one. for element in input_arr: if isinstance(element, list): for sub_element in custom_flatten_iter(element): yield sub_element else: yield element"},{"question":"# Question: Implement Enhanced Shell Sort with Optimal Gap Sequence **Objective**: Enhance and implement Shell Sort using an efficient gap sequence strategy to improve its performance. Scenario You\'re tasked with optimizing the sorting performance for medium-sized dataset configurations. The goal is to implement an improved version of Shell Sort using a more efficient gap sequence. This ensures better average-case and potentially worst-case performance compared to the simple implementation. Requirements 1. Write a function `enhanced_shell_sort(arr: List[int]) -> List[int]` that sorts an array of integers. 2. Use an optimal gap sequence to enhance performance. Recommended sequences include Hibbard\'s sequence (1, 3, 7, ...) or Sedgewick\'s sequence. 3. Maintain the in-place sorting characteristic of Shell Sort. Input * A list of integers, `arr`, where (1 leq text{length of } arr leq 10^5). The integers within the list can range between -10^9 to 10^9. Output * A sorted list of integers. Constraints 1. Efficiency is key: target a performance improvement over the basic O(n^2) shell sort. 2. The implementation must be in-place, i.e., use only a constant amount of extra space. Example ```python assert enhanced_shell_sort([12, 34, 54, 2, 3]) == [2, 3, 12, 34, 54] assert enhanced_shell_sort([0, -1, -2, 5, 9, -10]) == [-10, -2, -1, 0, 5, 9] assert enhanced_shell_sort([]) == [] assert enhanced_shell_sort([5]) == [5] ``` In your implementation, explain the choice of gap sequence and its expected impact on the performance. **Note**: Provide thorough testing for edge cases including, but not limited to, empty arrays and arrays with duplicate or uniform elements.","solution":"def enhanced_shell_sort(arr): Sorts an array of integers using enhanced Shell Sort with Hibbard\'s gap sequence. n = len(arr) # Generate Hibbard\'s gap sequence: 1, 3, 7, 15, 31, 63, 127, ... gaps = [] k = 1 while k < n: gaps.append(k) k = 2 * k + 1 gaps = gaps[::-1] # Shell Sort implementation using the gap sequence for gap in gaps: for i in range(gap, n): temp = arr[i] j = i while j >= gap and arr[j - gap] > temp: arr[j] = arr[j - gap] j -= gap arr[j] = temp return arr"},{"question":"# Set Cover Problem Assessment Scenario You are part of a team responsible for resource allocation across multiple projects. Each project has specific resource requirements, and each resource has an associated cost. Your goal is to allocate the minimum cost resources while ensuring that all project requirements are met. Task Given a universe of resources and subsets of these resources with associated costs, create a function `find_minimum_cost_cover` that returns the subsets of resources that together cover all project requirements at the minimum total cost. Function Signature ```python def find_minimum_cost_cover(universe: set, subsets: dict, costs: dict) -> list: Args: universe (set): Universe of resource types. subsets (dict): Dictionary where keys are subset names and values are sets of resources in each subset. costs (dict): Dictionary where keys are subset names and values are the cost of each subset. Returns: list: List of selected subset names that cover the universe with minimum cost. ``` Input - **universe**: A set of resources ( U ). For example, {1, 2, 3, 4, 5}. - **subsets**: A dictionary mapping subset names to sets of resources. For example, {\'S1\': {4, 1, 3}, \'S2\': {2, 5}, \'S3\': {1, 4, 3, 2}}. - **costs**: A dictionary mapping subset names to the associated cost of each subset. For example, {\'S1\': 5, \'S2\': 10, \'S3\': 3}. Output - A list of subset names that together cover the entire universe with the minimum total cost. The output sets must cover all elements in the universe. Constraints - The input universe and subsets are non-empty. - The solution must ensure that the output is a collection of subsets whose union is equal to the entire universe. - You may use either an exact (optimal) or an approximate (greedy) approach to solve the problem. Example ```python universe = {1, 2, 3, 4, 5} subsets = {\'S1\': {4, 1, 3}, \'S2\': {2, 5}, \'S3\': {1, 4, 3, 2}} costs = {\'S1\': 5, \'S2\': 10, \'S3\': 3} result = find_minimum_cost_cover(universe, subsets, costs) print(result) # Output might be [\'S3\', \'S2\'] or [\'S1\', \'S2\', \'S3\'] based on the algorithm used. ``` Evaluation Criteria - Correctness: Does the solution cover the entire universe with the minimum total cost? - Efficiency: Does the solution handle larger inputs effectively? - Clarity: Is the solution code readable and well-documented? - Edge Cases: Does the solution account for atypical inputs, like overlapping subsets or missing universe elements?","solution":"def find_minimum_cost_cover(universe, subsets, costs): Args: universe (set): Universe of resource types. subsets (dict): Dictionary where keys are subset names and values are sets of resources in each subset. costs (dict): Dictionary where keys are subset names and values are the cost of each subset. Returns: list: List of selected subset names that cover the universe with minimum cost. import heapq # Create a priority queue for the subsets based on cost efficiency (cost per item covered) priority_queue = [] for name, subset in subsets.items(): efficiency = costs[name] / len(subset) heapq.heappush(priority_queue, (efficiency, name, subset, costs[name])) covered = set() selected_subsets = [] total_cost = 0 while covered != universe: efficiency, name, subset, cost = heapq.heappop(priority_queue) if not subset.isdisjoint(universe - covered): # if the subset contributes new elements selected_subsets.append(name) total_cost += cost covered.update(subset) return selected_subsets"},{"question":"# Matrix Inversion Function You are required to implement a `matrix_inverse` function that calculates the inverse of an `n x n` matrix using the principles outlined above. Your implementation should follow these steps: 1. **Matrix of Minors**: Compute the minors for each element. 2. **Cofactor Matrix**: Apply alternating signs to form the cofactor matrix. 3. **Adjugate Matrix**: Transpose the cofactor matrix. 4. **Inverse Matrix**: Multiply by the reciprocal of the determinant of the original matrix. # Input * An `n x n` matrix `m` where ( 2 leq n leq 10 ). The matrix is given as a list of lists with integers or floating-point numbers. # Output * An `n x n` matrix that represents the inverse of the input matrix. If the matrix is non-invertible (e.g., singular or not square), return `None`. # Constraints * Handle edge cases such as non-square matrices or singular matrices gracefully by returning `None`. * Optimize for performance within the provided constraints. # Example ```python def matrix_inverse(m): # Your code here # Example usage: matrix = [ [4, 7], [2, 6] ] inverse = matrix_inverse(matrix) print(inverse) # Output: # [[0.6, -0.7], [-0.2, 0.4]] ``` Your task is to implement the `matrix_inverse` function to achieve the correct output.","solution":"def matrix_determinant(matrix): Helper function to compute the determinant of a matrix. n = len(matrix) if n == 1: return matrix[0][0] if n == 2: return matrix[0][0] * matrix[1][1] - matrix[0][1] * matrix[1][0] determinant = 0 for c in range(n): minor = [[matrix[i][j] for j in range(n) if j != c] for i in range(1, n)] determinant += ((-1) ** c) * matrix[0][c] * matrix_determinant(minor) return determinant def get_matrix_minor(matrix, i, j): Helper function to get the minor of the matrix excluding row i and column j. return [[matrix[x][y] for y in range(len(matrix)) if y != j] for x in range(len(matrix)) if x != i] def matrix_inverse(matrix): Function to compute the inverse of a matrix. n = len(matrix) # Check if the input matrix is square if any(len(row) != n for row in matrix): return None # Calculate the determinant det = matrix_determinant(matrix) if det == 0: return None # Singular matrix # Calculate matrix of minors minors = [[matrix_determinant(get_matrix_minor(matrix, i, j)) for j in range(n)] for i in range(n)] # Calculate cofactor matrix cofactors = [[(((-1) ** (i + j)) * minors[i][j]) for j in range(n)] for i in range(n)] # Transpose the cofactor matrix to get adjugate matrix adjugate = [[cofactors[j][i] for j in range(n)] for i in range(n)] # Calculate the inverse matrix inverse = [[adjugate[i][j] / det for j in range(n)] for i in range(n)] return inverse"},{"question":"Sort Colors (Dutch National Flag Problem) Problem Description You are given an array with `n` objects colored red, white, or blue, represented by integers 0, 1, and 2, respectively. Write a function `sort_colors(nums)` that sorts the array in-place so that objects of the same color are adjacent, with the colors in the order red (0), white (1), and blue (2). You are not allowed to use Python’s built-in sorting functions for this problem. Function Signature ```python def sort_colors(nums: List[int]) -> None: This function sorts the list of nums in place according to the Dutch National Flag problem. ``` Input - `nums`: A list of integers where each integer is either 0, 1, or 2. (0 <= len(nums) <= 30000) Output - The function should modify the input list in place to sort the elements as per the Dutch National Flag problem. Constraints - Do not return anything from the function. - The function should run in O(n) time and use O(1) extra space. Example ```python >>> nums = [2, 0, 2, 1, 1, 0] >>> sort_colors(nums) >>> print(nums) [0, 0, 1, 1, 2, 2] >>> nums = [0, 1, 2, 1, 0] >>> sort_colors(nums) >>> print(nums) [0, 0, 1, 1, 2] ``` Edge Cases to consider - An empty list. - A list with all elements the same. - A list that is already sorted. Note: Ensure to update the pointers correctly to avoid overlaps or out-of-bound errors.","solution":"from typing import List def sort_colors(nums: List[int]) -> None: This function sorts the list of nums in place according to the Dutch National Flag problem. low, mid, high = 0, 0, len(nums) - 1 while mid <= high: if nums[mid] == 0: nums[low], nums[mid] = nums[mid], nums[low] low += 1 mid += 1 elif nums[mid] == 1: mid += 1 else: nums[high], nums[mid] = nums[mid], nums[high] high -= 1"},{"question":"# Scenario You are required to assess the functionality of heap sort in order to demonstrate your understanding of the algorithm\'s implementation and optimization. # Task Write a function `generate_kth_largest()` that accepts an unsorted array of integers and an integer ( k ), and returns the ( k )th largest element in the array. Your implementation should make use of the **max heap** for optimal performance. # Expected Function Signature ```python def generate_kth_largest(arr: List[int], k: int) -> int: pass ``` # Input * `arr`: A list of integers, e.g., `[3, 2, 1, 5, 6, 4]` * `k`: An integer (`1 <= k <= len(arr)`), representing which largest element to find # Output * Return the ( k )th largest element from the array. # Constraints and Considerations * You must use the max heap approach for sorting. * Ensure your solution handles edge cases like an empty array or all elements being the same. * Assume all input arrays will have valid integers and the `k` provided will always be in the valid range. # Example ```python assert generate_kth_largest([3, 2, 3, 1, 2, 4, 5, 5, 6], 4) == 4 assert generate_kth_largest([3, 2, 1, 5, 6, 4], 2) == 5 ``` # Performance Requirement * The expected time complexity should be O(n log n) in the worst case. # Hints * You may initialize a max heap from the array and perform `k-1` deletions to get the ( k )th largest element. * Consider leveraging the provided `max_heap_sort` function in your solution.","solution":"import heapq def generate_kth_largest(arr, k): Returns the k-th largest element in an array using a max heap. if not arr or k < 1 or k > len(arr): return None # Convert elements to negative to simulate max-heap using heapq (which is a min-heap) max_heap = [-elem for elem in arr] heapq.heapify(max_heap) # Extract the k-th largest element for _ in range(k - 1): heapq.heappop(max_heap) return -heapq.heappop(max_heap)"},{"question":"Problem Statement You are given an array of integers. Your task is to design a Fenwick Tree (Binary Indexed Tree) class implementing the following methods: 1. `__init__(self, arr: List[int])`: Initializes the tree with the given array. 2. `update(self, index: int, value: int)`: Updates the element at the specified index to the new value. 3. `sum(self, index: int) -> int`: Returns the sum of elements from the start of the array up to the given index. 4. `range_sum(self, left: int, right: int) -> int`: Returns the sum of elements from the index `left` to the index `right` (inclusive). # Input * `__init__(arr)`: Initializes the Fenwick Tree with a list `arr` of length `n` where `1 <= n <= 10^5` and each element is in the range `-10^4 <= arr[i] <= 10^4`. * `update(index, value)`: Updates the element at index `index` with the new value `value`. * `sum(index) -> int`: Returns an integer representing the sum of the first `index + 1` elements of the array. * `range_sum(left, right) -> int`: Returns the sum of elements from index `left` to index `right` (inclusive). # Output * `sum(index)`: Returns the cumulative sum up to the given `index`. * `range_sum(left, right)`: Returns the cumulative sum from `left` to `right`. # Constraints * Indexing is 0-based for all methods. * For `update`, 0 <= `index` < `n`. * For `sum` and `range_sum`, 0 <= `index`, `left`, `right` < `n` and `left` <= `right`. # Example ```python # Initialize the Fenwick Tree with an array fenwick_tree = Fenwick_Tree([1, 2, 3, 4, 5]) # Update the value at index 2 to 6 fenwick_tree.update(2, 6) # Get sum of values from start to index 3 assert fenwick_tree.sum(3) == 13 # 1 + 2 + 6 + 4 # Get sum of values from index 1 to 4 assert fenwick_tree.range_sum(1, 4) == 17 # 2 + 6 + 4 + 5 ``` Write a class `Fenwick_Tree` in Python that implements the above methods and meets the criteria provided.","solution":"class Fenwick_Tree: def __init__(self, arr): Initializes the Fenwick Tree with the given array. self.n = len(arr) self.tree = [0] * (self.n + 1) self.arr = arr[:] for i, val in enumerate(arr): self._add(i + 1, val) def _add(self, index, value): while index <= self.n: self.tree[index] += value index += index & -index def update(self, index, value): Updates the element at the specified index to the new value. difference = value - self.arr[index] self.arr[index] = value self._add(index + 1, difference) def sum(self, index): Returns the sum of elements from the start of the array up to the given index. index += 1 total = 0 while index > 0: total += self.tree[index] index -= index & -index return total def range_sum(self, left, right): Returns the sum of elements from the index `left` to the index `right` (inclusive). return self.sum(right) - self.sum(left - 1)"},{"question":"# Context You are given a square matrix, and you need to calculate the sum of elements for every possible k x k sub-square region within this matrix. This has applications in image processing where kernels are applied over images to apply effects like blurring, sharpening, etc. # Task Write a function `sum_sub_squares_optimized(matrix, k)` that takes a 2D list `matrix` of integers representing an n x n grid and an integer `k`. This function should return a 2D list of integers representing the sums of each k x k sub-square within the larger n x n matrix. The function should be optimized for better performance than the given naive approach. # Input * `matrix` (List[List[int]]): A list of lists representing an n x n grid of integers (1 ≤ n ≤ 1000). * `k` (int): An integer representing the size of the sub-square (1 ≤ k ≤ n). # Output A 2D list of integers containing the sums of each k x k sub-square within the larger matrix. # Constraints * The function should handle cases where k = 1, producing the same matrix as the input. * The function should throw a ValueError if k is greater than the matrix size. # Performance Requirements Optimize to remove redundant calculations, target time complexity of O(n^2). # Example ```python matrix = [ [1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1] ] k = 2 expected_output = [ [4, 4, 4], [4, 4, 4], [4, 4, 4] ] print(sum_sub_squares_optimized(matrix, k)) # Output should be expected_output ``` # Notes * Ensure your solution avoids recalculating overlapping regions to improve performance. * Consider edge cases thoroughly (e.g., if k > n, k = 1, etc.).","solution":"def sum_sub_squares_optimized(matrix, k): This function calculates the sum of all k x k sub-squares in a given n x n matrix. n = len(matrix) # check if k is greater than n if k > n: raise ValueError(\\"k should be less than or equal to the size of the matrix\\") # Step 1: Create the auxiliary sum matrix prefix_sum = [[0] * (n + 1) for _ in range(n + 1)] # Step 2: Fill the prefix_sum matrix for i in range(1, n + 1): for j in range(1, n + 1): prefix_sum[i][j] = matrix[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1] # Step 3: Calculate sums of k x k sub-squares using the prefix_sum matrix result = [] for i in range(n - k + 1): row = [] for j in range(n - k + 1): total_sum = (prefix_sum[i + k][j + k] - prefix_sum[i + k][j] - prefix_sum[i][j + k] + prefix_sum[i][j]) row.append(total_sum) result.append(row) return result"},{"question":"# Question: Check Alternating Bits **Context**: You are part of a team developing a software toolkit for binary data validation. One of the requirements is to verify whether an integer has alternating bits in its binary representation. # Task: Write two Python functions to achieve this: 1. **Iterative Method**: - Function name: `has_alternative_bit(n)` - Input: A non-negative integer `n`. - Output: A boolean `True` or `False` indicating whether the binary representation of `n` consists of alternating bits. 2. **Hexadecimal Mask Method**: - Function name: `has_alternative_bit_fast(n)` - Input: A non-negative integer `n`. - Output: A boolean `True` or `False` indicating whether the binary representation of `n` consists of alternating bits. # Constraints: * `0 <= n <= 10^9` * Your implementation should handle edge cases such as `0`, `1`, and large numbers. * The `has_alternative_bit_fast` method should execute in constant time. # Examples: 1. `has_alternative_bit(5)` - Binary representation of 5: `101` - Output: `True` 2. `has_alternative_bit(7)` - Binary representation of 7: `111` - Output: `False` 3. `has_alternative_bit(11)` - Binary representation of 11: `1011` - Output: `False` 4. `has_alternative_bit_fast(10)` - Binary representation of 10: `1010` - Output: `True` # Implementation: Your implementation should include both the iterative method and the hexadecimal mask method to validate correct alternating bit patterns. ```python # Implement both functions here def has_alternative_bit(n): # Your code for the iterative approach goes here pass def has_alternative_bit_fast(n): # Your code for the hexadecimal mask approach goes here pass ```","solution":"def has_alternative_bit(n): Check if a given non-negative integer has alternating bits in its binary representation. Parameters: n (int): A non-negative integer Returns: bool: True if the binary representation of n has alternating bits, False otherwise prev_bit = n & 1 n >>= 1 while n > 0: current_bit = n & 1 if current_bit == prev_bit: return False prev_bit = current_bit n >>= 1 return True def has_alternative_bit_fast(n): Check if a given non-negative integer has alternating bits in its binary representation using a constant time approach. Parameters: n (int): A non-negative integer Returns: bool: True if the binary representation of n has alternating bits, False otherwise all_ones = n ^ (n >> 1) return (all_ones & (all_ones + 1)) == 0"},{"question":"You are tasked with writing a function to simplify a given Unix-style absolute path. The canonical path format should follow these rules: 1. The path starts with a single slash `/`. 2. There should be only one slash `/` between two directory names. 3. The path does not end with a trailing `/`. 4. The path only contains the directories listed in the path (no `.` or `..`). Write a function `simplify_path(path: str) -> str` that takes a string `path` representing the absolute file path and returns a simplified canonical path. Input * A single string `path` representing the absolute Unix-style file path. * The path is guaranteed to begin with a `/`. Output * A single string representing the simplified canonical path. Constraints * `1 <= len(path) <= 3000` * The given `path` is a valid absolute Unix-style file path. Examples 1. Input: `\\"/home/\\"` Output: `\\"/home\\"` 2. Input: `\\"/a/./b/../../c/\\"` Output: `\\"/c\\"` 3. Input: `\\"/../\\"` Output: `\\"/\\"` 4. Input: `\\"/home//foo/\\"` Output: `\\"/home/foo\\"` 5. Input: `\\"/a/../../b/../c//.//\\"` Output: `\\"/c\\"` Guidance - Refer to how the algorithm uses a stack to navigate and construct the target simplified path. - Remember to account for all edge cases such as multiple slashes, references to the current directory, and parent directory moves beyond the root.","solution":"def simplify_path(path: str) -> str: Simplifies a given Unix-style absolute path. parts = path.split(\'/\') stack = [] for part in parts: if part == \'\' or part == \'.\': continue elif part == \'..\': if stack: stack.pop() else: stack.append(part) return \'/\' + \'/\'.join(stack)"},{"question":"Given an array of strings representing words, implement a function `filter_words_by_keyboard_row` that returns a list of words that can be typed using letters of alphabet on only one row of an American QWERTY keyboard (case insensitive). Function Signature ```python def filter_words_by_keyboard_row(words: List[str]) -> List[str]: ``` Input * `words` (List[str]): A list of words (each word being a non-empty string with alphabetic characters). Output * A list of words that are typed using only one row of an American QWERTY keyboard. Constraints * Each word will contain only alphabetic characters. * Words will contain both lowercase and uppercase characters, but comparison should be case insensitive. * The words list will have at most 10^3 elements. Example ```python # Example 1 input_words = [\\"Hello\\", \\"Alaska\\", \\"Dad\\", \\"Peace\\"] output = filter_words_by_keyboard_row(input_words) print(output) # Output: [\\"Alaska\\", \\"Dad\\"] # Example 2 input_words = [\\"DAD\\", \\"echo\\", \\"percussive\\", \\"crypt\\"] output = filter_words_by_keyboard_row(input_words) print(output) # Output: [\\"DAD\\"] ``` Notes * Your solution should efficiently handle the constraints. * Avoid unnecessary computations to ensure optimal performance. * Consider different scenarios such as mixed case words and various edge cases (e.g., empty word list). Good luck!","solution":"from typing import List def filter_words_by_keyboard_row(words: List[str]) -> List[str]: row1 = set(\\"qwertyuiop\\") row2 = set(\\"asdfghjkl\\") row3 = set(\\"zxcvbnm\\") def can_be_typed_on_one_row(word): lower_word = set(word.lower()) return (lower_word <= row1) or (lower_word <= row2) or (lower_word <= row3) result = [word for word in words if can_be_typed_on_one_row(word)] return result"},{"question":"# Scenario You are tasked with developing an online text editor that helps users check for minor errors in text input. One of the features checks if an intended correction to a word involves only a single edit (either insert, delete, or replace a character). This feature is useful for quickly highlighting typos or small changes. # Problem Statement Write a function `is_one_edit(s, t)` that determines if two strings `s` and `t` are one edit distance apart. The function should return `True` if the strings are exactly one edit distance apart; otherwise, it should return `False`. # Input and Output * **Input**: * A string `s` of length `n` (1 <= n <= 10^4). * A string `t` of length `m` (1 <= m <= 10^4). * **Output**: * A boolean value `True` if `s` and `t` are one edit distance apart, `False` otherwise. * **Constraints**: * The strings can only contain lowercase English letters. # Example Example 1 * **Input**: `s = \\"cat\\"`, `t = \\"cut\\"` * **Output**: `True` * **Explanation**: You can convert \'a\' to \'u\' with one edit. Example 2 * **Input**: `s = \\"cat\\"`, `t = \\"cats\\"` * **Output**: `True` * **Explanation**: You can insert \'s\' at the end of the first string. Example 3 * **Input**: `s = \\"cat\\"`, `t = \\"dog\\"` * **Output**: `False` * **Explanation**: More than one edit is needed. # Function Signature ```python def is_one_edit(s: str, t: str) -> bool: pass ``` Write the function `is_one_edit` to solve the problem as described.","solution":"def is_one_edit(s, t): Determines if the strings `s` and `t` are one edit distance (insert, delete, or replace a character) apart. # Length check len_s = len(s) len_t = len(t) if abs(len_s - len_t) > 1: return False # Make sure s is the shorter string if len_s > len_t: s, t = t, s len_s, len_t = len_t, len_s # Now we have len(s) <= len(t) i = j = 0 edit_count = 0 while i < len_s and j < len_t: if s[i] != t[j]: if edit_count == 1: return False edit_count += 1 if len_s == len_t: # If lengths of s and t are same i += 1 # In either case, we move j to the next position else: i += 1 # If characters match, move pointer of the shorter string j += 1 # Always move pointer of the longer string # If loop completes with a single edit or none at all, check further. if i < len_s or j < len_t: edit_count += 1 return edit_count == 1"},{"question":"# Challenge: Implement a More Efficient Sorting Algorithm **Context:** In software development, efficient sorting algorithms are essential for handling lists of data. Bogo Sort, as given, is highly inefficient due to its random nature. Your task is to implement a more efficient sorting algorithm. **Problem:** Implement the Merge Sort algorithm, which is known for its efficiency, to sort a list of integers. Merge Sort follows the divide-and-conquer paradigm and has a consistent time complexity of O(n log n). **Function Signature:** ```python def merge_sort(arr: list) -> list: ``` **Input:** - `arr`: A list of integers that need to be sorted. The list can contain any integer values, including repeated elements. **Output:** - Returns the sorted list of integers. **Constraints:** - The input list can have a size between 0 and (10^5). **Performance Requirements:** - Your solution should be efficient with a time complexity of O(n log n) and a space complexity of O(n). **Example:** ```python assert merge_sort([3, 1, 2, 5, 4]) == [1, 2, 3, 4, 5] assert merge_sort([10, 7, 8, 5, 9, 6]) == [5, 6, 7, 8, 9, 10] assert merge_sort([1]) == [1] assert merge_sort([]) == [] assert merge_sort([5, -1, 3, 3, 2]) == [-1, 2, 3, 3, 5] ``` **Description:** 1. **Divide:** Split the list into two halves until each sublist contains a single element. 2. **Conquer:** Recursively sort each sublist. 3. **Combine:** Merge the sorted sublists to produce one sorted list. **Merge Function:** Write a helper function to effectively merge two sorted sublists. Good luck with understanding and implementing an efficient sorting algorithm that is fundamental in computer science and real-world applications!","solution":"def merge_sort(arr): Sorts the input list using Merge Sort algorithm. Args: arr (list): List of integers to be sorted. Returns: list: Sorted list of integers. if len(arr) <= 1: return arr def merge(left, right): result = [] i, j = 0, 0 while i < len(left) and j < len(right): if left[i] <= right[j]: result.append(left[i]) i += 1 else: result.append(right[j]) j += 1 result.extend(left[i:]) result.extend(right[j:]) return result mid = len(arr) // 2 left_half = merge_sort(arr[:mid]) right_half = merge_sort(arr[mid:]) return merge(left_half, right_half)"},{"question":"# Detecting Cycle in a Linked List **Objective**: Given a linked list, implement a function to determine if it contains a cycle. # Function Signature ```python def is_cyclic(head: Node) -> bool: :param head: Node - The head of the linked list. :return: bool - True if the linked list contains a cycle, False otherwise. ``` # Scenario Your technical lead asks you to analyze certain data sequences for possible cycles. Each sequence is represented as a singly linked list. Your task is to write a function, `is_cyclic`, that will efficiently determine whether any given linked list has a cycle. # Input - `head`: A `Node` object representing the head of a singly linked list. # Output - Return a boolean `True` if the linked list has a cycle. - Return `False` otherwise. # Constraints - The linked list may have between 0 and (10^4) nodes. - Each node in the linked list will have a value of type `int`. - Optimize your solution to run in linear time and use constant extra space. # Example ```python class Node: def __init__(self, x): self.val = x self.next = None # Example Usage: # Input: head = [3, 2, 0, -4] and pos = 1 (which means the tail connects to the node at position 1) # Explanation: There is a cycle in the linked list where the tail connects to the second node. n1 = Node(3) n2 = Node(2) n3 = Node(0) n4 = Node(-4) n1.next = n2 n2.next = n3 n3.next = n4 n4.next = n2 # creates a cycle print(is_cyclic(n1)) # Output: True # Input: head = [1, 2] and pos = 0 (which means the tail connects to the node at position 0) # Explanation: There is a cycle in the linked list where the tail connects to the first node. n1 = Node(1) n2 = Node(2) n1.next = n2 n2.next = n1 # creates a cycle print(is_cyclic(n1)) # Output: True # Input: head = [1] (which means the list is empty and there is no cycle) # Explanation: No cycle in the linked list. n1 = Node(1) print(is_cyclic(n1)) # Output: False ``` # Notes - Focus on accurately detecting cycles without using any additional space. - Ensure proper handling of edge cases such as an empty list or a single-node list.","solution":"class Node: def __init__(self, x): self.val = x self.next = None def is_cyclic(head: Node) -> bool: Detects if a linked list contains a cycle. :param head: Node - The head of the linked list. :return: bool - True if the linked list contains a cycle, False otherwise. if head is None: return False slow, fast = head, head while fast is not None and fast.next is not None: slow = slow.next fast = fast.next.next if slow == fast: return True return False"},{"question":"You have been tasked with writing a custom sorting algorithm based on the principles of Bogo Sort, but with an important twist to make it slightly more practical. Instead of sorting the entire array through shuffling, the algorithm should recursively break down the array into smaller sub-arrays using the Divide and Conquer strategy, shuffle each sub-array and merge them back together in a sorted order. This new algorithm, named **Recursive Bogo Sort**, involves the following steps: 1. Recursively divide the array into halves until each sub-array has one element. 2. Shuffle the merged arrays and check if they are sorted. 3. If not sorted, recursively shuffle and merge again till sorted. Write a function named `recursive_bogo_sort` that implements this improved algorithm. Function Signature: ```python def recursive_bogo_sort(arr: List[int]) -> List[int]: pass ``` Input: - A list of integers `arr` with ( 1 leq text{len(arr)} leq 10^3 ). Output: - A sorted list of integers. Constraints: 1. You should aim to implement a recursive bogo sort as described. 2. The solution should handle having to shuffle and merge recursively. 3. Use Python\'s built-in `random.shuffle` method for shuffling. Example: ```python >>> recursive_bogo_sort([3, 1, 2]) [1, 2, 3] >>> recursive_bogo_sort([5, 4, 3, 2, 1]) [1, 2, 3, 4, 5] ``` Notes: - Pay attention to edge cases, such as already sorted arrays or arrays with duplicate elements. - Consider the inefficiency of Bogo Sort and address how recursion might impact your strategy.","solution":"import random from typing import List def is_sorted(arr: List[int]) -> bool: Helper function to check if the array is sorted. return all(arr[i] <= arr[i + 1] for i in range(len(arr) - 1)) def recursive_bogo_sort(arr: List[int]) -> List[int]: Recursively Bogo Sort the array. if len(arr) <= 1: return arr mid = len(arr) // 2 left = recursive_bogo_sort(arr[:mid]) right = recursive_bogo_sort(arr[mid:]) merged = left + right while not is_sorted(merged): random.shuffle(merged) return merged"},{"question":"As a junior data analyst, you are tasked with preparing a database for performance testing. Your dataset is a list of integer values that need to be sorted for easy readability. **Write a function `better_exchange_sort(arr)` that implements a more optimized exchange sort algorithm approach.** Your goal is to optimize the existing exchange sort by minimizing the number of redundant comparisons and unnecessary swaps whenever possible. # Requirements 1. Your solution should improve the performance of the basic exchange sort. 2. The function should retain the same interface as provided: ```python def better_exchange_sort(arr: List[int]) -> List[int]: ``` # Input * `arr`: A list of integers where (1 leq len(arr) leq 10000 ). The integers can be negative, zero, or positive. # Output * The function should return the sorted list of integers in ascending order. # Constraints 1. Your solution should avoid any auxiliary memory usage beyond the input list. 2. Avoid any built-in sort functions from the language\'s standard library. # Performance Requirements - Optimally improve upon the naive (O(n^2)) approach without losing accuracy. # Function Signature ```python def better_exchange_sort(arr: List[int]) -> List[int]: pass ``` # Example ```python # Example 1: input_list = [64, 34, 25, 12, 22, 11, 90] print(better_exchange_sort(input_list)) # Output: [11, 12, 22, 25, 34, 64, 90] # Example 2: input_list = [5, 1, 4, 2, 8] print(better_exchange_sort(input_list)) # Output: [1, 2, 4, 5, 8] ```","solution":"def better_exchange_sort(arr): Optimized exchange sort algorithm. n = len(arr) for i in range(n): swapped = False for j in range(0, n - i - 1): if arr[j] > arr[j + 1]: arr[j], arr[j + 1] = arr[j + 1], arr[j] swapped = True if not swapped: break return arr"},{"question":"# Radix Sort for Fixed-Length Strings Context: You are tasked with sorting a list of alphanumeric fixed-length strings, where each string has a length of `k`. Consider each character\'s ASCII value for sorting, and ensure that your algorithm sorts the entire list in ascending lexicographical order. # Task: Implement a function `radix_sort_alphanumeric` that sorts a list of fixed-length alphanumeric strings using the radix sort algorithm. # Function Signature: ```python def radix_sort_alphanumeric(arr: list[str], k: int) -> list[str]: ``` # Input: - `arr`: List of alphanumeric strings of fixed length `k`. - `k`: An integer representing the fixed length of each string. # Output: - Returns a new list of alphanumeric strings sorted in ascending lexicographical order. # Constraints: - The length of each string in `arr` will be exactly `k`. - All characters are alphanumeric (i.e., [0-9, a-z, A-Z]). # Example: ```python arr = [\\"ab4\\", \\"1a2\\", \\"12a\\", \\"aaa\\", \\"abc\\"] k = 3 print(radix_sort_alphanumeric(arr, k)) # Output: [\\"12a\\", \\"1a2\\", \\"aaa\\", \\"ab4\\", \\"abc\\"] ``` *You should consider using ASCII values for character comparison and ensure the sorting is stable across multiple iterations.*","solution":"def radix_sort_alphanumeric(arr, k): def counting_sort(arr, pos): # Counting sort for a specific character position (pos) in the strings count = [0] * 256 # Considering ASCII values output = [\'\'] * len(arr) for s in arr: index = ord(s[pos]) count[index] += 1 for i in range(1, 256): count[i] += count[i-1] for s in reversed(arr): index = ord(s[pos]) output[count[index] - 1] = s count[index] -= 1 return output for pos in range(k-1, -1, -1): arr = counting_sort(arr, pos) return arr"},{"question":"Problem Statement You are given the task of implementing a function to determine the transitive closure of a graph. The transitive closure of a graph is a matrix that indicates whether there is a path between each pair of vertices in the graph. Implement the following class to support this functionality. # Class: `Graph` # Constructor: ```python def __init__(self, vertices): ``` - Initializes the graph with a given number of vertices. - `vertices`: An integer representing the number of vertices in the graph. # Methods: `add_edge(self, source, target)` Add a directed edge from vertex `source` to vertex `target`. - `source`: An integer representing the starting vertex. - `target`: An integer representing the target vertex. `transitive_closure(self)` Compute and return the transitive closure matrix of the graph. - Returns a 2D list `closure` where `closure[i][j]` is 1 if there is a path from vertex `i` to vertex `j`, and 0 otherwise. # Example: ```python # Create a graph with 4 vertices g = Graph(4) # Adding edges g.add_edge(0, 1) g.add_edge(1, 2) g.add_edge(2, 3) # Get the transitive closure matrix closure = g.transitive_closure() # The closure matrix should be: # [[1, 1, 1, 1], # [0, 1, 1, 1], # [0, 0, 1, 1], # [0, 0, 0, 1]] print(closure) ``` # Constraints: - The number of vertices `vertices` is an integer in the range [1, 100]. - The number of edges can vary and be up to `vertices*(vertices-1)`. # Notes: - Ensure your solution handles graphs with no edges and self-loops. - Aim for clarity and efficiency in your implementation. Implement this class and its methods to correctly solve the problem based on the example and constraints provided.","solution":"class Graph: def __init__(self, vertices): Initializes the graph with a given number of vertices. self.V = vertices self.graph = [[0] * vertices for _ in range(vertices)] def add_edge(self, source, target): Adds a directed edge from vertex \'source\' to vertex \'target\'. self.graph[source][target] = 1 def transitive_closure(self): Computes and returns the transitive closure matrix of the graph. # Initialize the closure matrix as a copy of the original graph closure = [[self.graph[i][j] for j in range(self.V)] for i in range(self.V)] # Apply the Floyd-Warshall algorithm for k in range(self.V): for i in range(self.V): for j in range(self.V): closure[i][j] = closure[i][j] or (closure[i][k] and closure[k][j]) # Ensure self-loops are present in the transitive closure for i in range(self.V): closure[i][i] = 1 return closure"},{"question":"# Sorting Analysis and Implementation Enhancement You have been provided with a simple implementation of the exchange sort algorithm. The exchange sort algorithm is one of the basic sorting algorithms with O(n^2) time complexity, known for its simplicity. Objective Your task is to: 1. Analyze the provided implementation and ensure you understand how it works and its limitations. 2. Implement an improved version of the exchange sort algorithm, addressing at least one of the following challenges or optimizing points: - Reduce unnecessary comparisons. - Optimize for already sorted parts of the list. Input * A list of integers, `arr`, where (0 leq text{len(arr)} leq 10^3). Output * The sorted list `arr` in ascending order. **Constraints**: * Ensure your algorithm can handle inputs efficiently within the given constraints. **Performance Requirements**: * Aim to improve the average case performance while maintaining the correct functionality. Example ```python # Input arr = [64, 34, 25, 12, 22, 11, 90] # Output [11, 12, 22, 25, 34, 64, 90] ``` In your improved version, provide an explanation on how your changes enhance the performance over the initial implementation.","solution":"def improved_exchange_sort(arr): Improved version of the exchange sort algorithm. This version reduces unnecessary comparisons by recognizing already sorted portions. n = len(arr) for i in range(n - 1): swapped = False for j in range(i + 1, n): if arr[j] < arr[i]: arr[i], arr[j] = arr[j], arr[i] swapped = True # If no two elements were swapped by the inner loop, then the array is already sorted if not swapped: break return arr"},{"question":"# Matrix Chain Multiplication: Optimal Order Finder In matrix operations, the order in which you multiply matrices matters due to the different number of multiplications required for different orders. The Matrix Chain Multiplication problem aims to find the most efficient way to multiply a given sequence of matrices. You are given `n` matrices represented by an array `array` of `n+1` dimensions, where the ith matrix has dimensions `array[i-1] x array[i]`. Your task is to implement a function `matrix_chain_order` which computes the least number of scalar multiplications needed to multiply the entire chain, and another function `print_optimal_solution` which prints out the actual order required to achieve this optimal multiplication sequence. Function Signature ```python def matrix_chain_order(array: List[int]) -> Tuple[List[List[int]], List[List[int]]]: pass def print_optimal_solution(optimal_solution: List[List[int]], i: int, j: int) -> None: pass ``` Input Format - `array`: a list of integers where `array[i-1]` and `array[i]` provide the dimensions of the ith matrix. - `2 <= len(array) <= 100` Output Format - `matrix_chain_order` returns a tuple of two 2D lists `matrix` and `sol` where: - The `matrix` contains the minimum number of operations required for each subproblem. - The `sol` contains the structure of the solutions to help construct the optimal order. - `print_optimal_solution` prints the order in which matrices should be multiplied. # Example Suppose the dimensions of matrices are given by: ```python array = [30, 35, 15, 5, 10, 20, 25] ``` The matrices are: - A1: 30 x 35 - A2: 35 x 15 - A3: 15 x 5 - A4: 5 x 10 - A5: 10 x 20 - A6: 20 x 25 Using the function `matrix_chain_order`, the minimum number of operations required, and the optimal order to achieve this would be computed. Subsequently, by calling `print_optimal_solution`, the optimal way to parenthesize the given matrices will be displayed. # Constraints - You may assume that the dimensions given are valid for matrix multiplication. - Ensure that your solution efficiently handles the maximum input size within reasonable time limits. Implement these functions and demonstrate their usage with at least one comprehensive test case.","solution":"from typing import List, Tuple def matrix_chain_order(array: List[int]) -> Tuple[List[List[int]], List[List[int]]]: n = len(array) - 1 m = [[0 for _ in range(n)] for _ in range(n)] s = [[0 for _ in range(n)] for _ in range(n)] for l in range(2, n+1): for i in range(n - l + 1): j = i + l - 1 m[i][j] = float(\'inf\') for k in range(i, j): q = m[i][k] + m[k + 1][j] + array[i] * array[k + 1] * array[j + 1] if q < m[i][j]: m[i][j] = q s[i][j] = k + 1 return m, s def print_optimal_solution(s: List[List[int]], i: int, j: int) -> None: if i == j: print(f\\"A{i + 1}\\", end=\\"\\") else: print(\\"(\\", end=\\"\\") print_optimal_solution(s, i, s[i][j] - 1) print_optimal_solution(s, s[i][j], j) print(\\")\\", end=\\"\\") # Example usage array = [30, 35, 15, 5, 10, 20, 25] m, s = matrix_chain_order(array) print(\\"Minimum number of multiplications:\\", m[0][len(array) - 2]) print(\\"Optimal order of multiplications: \\", end=\\"\\") print_optimal_solution(s, 0, len(array) - 2) print()"},{"question":"# Question: Counting Digits in a String of Numbers Context: You are given a string containing a list of integers separated by spaces. Your task is to parse the string, extract the integers, and determine the number of digits in each integer. Requirements: 1. Read a string containing integers separated by spaces. 2. For each integer, compute the number of digits. 3. Return the results as a list of tuples, where each tuple contains the original integer and its corresponding digit count. # Function Signature: ```python def count_digits_in_string(numbers_string: str) -> List[Tuple[int, int]]: ``` Input: - `numbers_string` (str): A space-separated string of integers. Output: - List of Tuples containing integers and their digit counts. Each tuple will follow the format (integer, digit_count). Constraints: - The input string will always contain valid integers and spaces. Example: ```python assert count_digits_in_string(\\"123 45 6789 -10 0\\") == [(123, 3), (45, 2), (6789, 4), (-10, 2), (0, 1)] ``` Hints: - Use the provided `num_digits` function to determine the digit count. - Consider edge cases like negative numbers and zero.","solution":"from typing import List, Tuple def count_digits_in_string(numbers_string: str) -> List[Tuple[int, int]]: def num_digits(n: int) -> int: if n == 0: return 1 count = 0 if n < 0: n = -n while n > 0: count += 1 n //= 10 return count number_strings = numbers_string.split() result = [] for num_str in number_strings: num = int(num_str) digit_count = num_digits(num) result.append((num, digit_count)) return result"},{"question":"Implement the `is_prime` function using the Rabin-Miller primality test. Given an integer (n) and a confidence factor (k), determine if (n) is a prime number with high confidence. # Function Signature ```python def is_prime(n: int, k: int) -> bool: pass ``` # Input - (n) (int): A positive integer to test for primality ((5 leq n leq 10^{18})). - (k) (int): The number of iterations for the test ((1 leq k leq 100)). # Output - Return a boolean: - `True` if (n) is probably prime. - `False` if (n) is definitely composite. # Example ```python print(is_prime(31, 5)) # Expected: True print(is_prime(18, 5)) # Expected: False ``` # Constraints 1. (n) will be a positive integer at least 5. 2. The function should handle up to (10^{18}) efficiently. 3. The random selection should ensure uniform distribution within the specified range. # Additional Notes - Utilize modular exponentiation for efficient computation. - Ensure to manage edge cases such as small values of (n). - Optimize the number of iterations (k) based on required accuracy level.","solution":"import random def is_prime(n: int, k: int) -> bool: Determines if n is a prime number with high confidence using the Rabin-Miller primality test. Args: n (int): A positive integer to test for primality. k (int): The number of iterations for the test. Returns: bool: True if n is probably prime, False if n is definitely composite. if n <= 1: return False if n <= 3: return True if n % 2 == 0: return False # Write n-1 as 2^s * d # keep dividing n-1 by 2 until you get an odd number s = 0 d = n - 1 while d % 2 == 0: d //= 2 s += 1 def miller_rabin_test(a): Perform the Miller-Rabin test as a subroutine x = pow(a, d, n) if x == 1 or x == n - 1: return True for _ in range(s - 1): x = pow(x, 2, n) if x == n - 1: return True return False # Perform k tests for _ in range(k): a = random.randint(2, n - 2) if not miller_rabin_test(a): return False return True"},{"question":"Based on a linear time complexity solution using a constant amount of extra space, write a function `find_single_element` that finds the single element in a list of integers where every other element appears exactly twice except for one. # Input Format * You are given a list of integers `nums` containing `n` elements. # Output Format * Return the single integer that appears only once in the list. * If the list is empty, return `None`. # Constraints * The list will contain at most one unique element that appears only once, and all other elements will appear exactly twice. * You need to implement the solution with O(n) time complexity and O(1) space complexity. # Example * Input: `[2, 2, 1]` * Output: `1` * Input: `[4, 1, 2, 1, 2]` * Output: `4` * Input: `[]` * Output: `None` # Note This solution should leverage XOR properties to achieve the desired time and space complexity. # Function Signature ```python def find_single_element(nums: List[int]) -> int: pass ```","solution":"def find_single_element(nums): Finds the single element in a list of integers where every other element appears exactly twice except for one. Args: nums (List[int]): a list of integers Returns: int: the single element that appears only once or None if the list is empty. if not nums: return None single_element = 0 for num in nums: single_element ^= num return single_element"},{"question":"Given an unsorted array of integers, implement the Comb Sort algorithm to sort the array in ascending order. # Input - An unsorted list of integers, `arr` with length `n`. (1 ≤ n ≤ 10^6) # Output - The sorted list of integers in ascending order. # Constraints - 1 ≤ arr[i] ≤ 10^9 # Requirements - You must use the Comb Sort algorithm as described in the analysis. - The implementation should be efficient in time and space complexity to handle the upper constraints. # Example ```python # Example 1 Input: [8, 4, 1, 56, 3, -44, 23, -6, 28, 0] Output: [-44, -6, 0, 1, 3, 4, 8, 23, 28, 56] # Example 2 Input: [5, 3, 2, 1, 4] Output: [1, 2, 3, 4, 5] ``` # Function Signature ```python def comb_sort(arr: List[int]) -> List[int]: pass ``` Write your solution in the provided `comb_sort` function. # Implementation Guidelines - You may use helper functions if necessary. - Ensure your solution passes edge cases and handles performance requirements.","solution":"from typing import List def comb_sort(arr: List[int]) -> List[int]: def get_next_gap(gap): gap = (gap * 10) // 13 if gap < 1: return 1 return gap n = len(arr) gap = n swapped = True while gap != 1 or swapped: gap = get_next_gap(gap) swapped = False for i in range(n - gap): if arr[i] > arr[i + gap]: arr[i], arr[i + gap] = arr[i + gap], arr[i] swapped = True return arr"},{"question":"# String Reversal Challenge Context You are tasked with implementing a series of functions to reverse a string. Each function utilizes a different approach commonly used in algorithmic challenges and interviews. Demonstrate your understanding of recursion, iteration, and Python\'s built-in capabilities by implementing these functions. Task Implement the following four functions in Python: 1. `recursive_reverse(s: str) -> str`: Reverse the string `s` using a recursive approach. 2. `iterative_reverse(s: str) -> str`: Reverse the string `s` using an iterative approach with two-pointer technique. 3. `pythonic_reverse(s: str) -> str`: Reverse the string `s` using Python’s built-in `reversed()` function and list joining. 4. `ultra_pythonic_reverse(s: str) -> str`: Reverse the string `s` using Python’s slicing syntax. Input - A single string `s` with length `0 <= len(s) <= 10^5`. Output - Return the reversed string. Example ```python s = \\"example\\" print(recursive_reverse(s)) # Output: \\"elpmaxe\\" print(iterative_reverse(s)) # Output: \\"elpmaxe\\" print(pythonic_reverse(s)) # Output: \\"elpmaxe\\" print(ultra_pythonic_reverse(s)) # Output: \\"elpmaxe\\" ``` Constraints - The input string may be empty. - Ensure that your implementations handle long strings efficiently and consider stack depth limitations for the recursive method.","solution":"def recursive_reverse(s: str) -> str: Reverses the string s using a recursive approach. if len(s) == 0: return s else: return s[-1] + recursive_reverse(s[:-1]) def iterative_reverse(s: str) -> str: Reverses the string s using an iterative approach with a two-pointer technique. s_list = list(s) left, right = 0, len(s) - 1 while left < right: s_list[left], s_list[right] = s_list[right], s_list[left] left += 1 right -= 1 return \'\'.join(s_list) def pythonic_reverse(s: str) -> str: Reverses the string s using Python\'s built-in reversed() function and join method. return \'\'.join(reversed(s)) def ultra_pythonic_reverse(s: str) -> str: Reverses the string s using Python\'s slicing syntax. return s[::-1]"},{"question":"Given a string `num` of digits and an integer `target`, implement a function `find_expressions(num, target)` that returns all valid expressions formed by adding binary operators (`+`, `-`, `*`) between the digits such that the resulting expression evaluates to the target value. # Input and Output Formats * **Input**: * `num` (string): A string consisting of digits `0-9`. * `target` (int): A target integer value. * **Output**: * A list of strings, each representing a valid expression. # Constraints * The length of `num` will be between `1` and `10`. * The `target` is within the range `-10^8` to `10^8`. # Examples ```python find_expressions(\\"123\\", 6) # Output: [\\"1+2+3\\", \\"1*2*3\\"] find_expressions(\\"232\\", 8) # Output: [\\"2*3+2\\", \\"2+3*2\\"] find_expressions(\\"105\\", 5) # Output: [\\"1*0+5\\", \\"10-5\\"] find_expressions(\\"00\\", 0) # Output: [\\"0+0\\", \\"0-0\\", \\"0*0\\"] find_expressions(\\"3456237490\\", 9191) # Output: [] ``` # Requirements: * Implement the function `find_expressions(num, target)` using a backtracking approach. * Consider all edge cases, including but not limited to strings with leading zeros, and ensure that all generated expressions use all digits. * Ensure performance is optimized for the constraints provided.","solution":"def find_expressions(num, target): def backtrack(index, prev_operand, current_operand, value, ops): if index == len(num): if value == target and current_operand == 0: expressions.append(\\"\\".join(ops[1:])) # Skip the first operator return current_operand = current_operand * 10 + int(num[index]) str_operand = str(current_operand) if current_operand > 0: backtrack(index + 1, prev_operand, current_operand, value, ops) ops.append(\\"+\\") ops.append(str_operand) backtrack(index + 1, current_operand, 0, value + current_operand, ops) ops.pop() ops.pop() if ops: ops.append(\\"-\\") ops.append(str_operand) backtrack(index + 1, -current_operand, 0, value - current_operand, ops) ops.pop() ops.pop() ops.append(\\"*\\") ops.append(str_operand) backtrack(index + 1, prev_operand * current_operand, 0, value - prev_operand + (prev_operand * current_operand), ops) ops.pop() ops.pop() expressions = [] backtrack(0, 0, 0, 0, []) return expressions"},{"question":"# Problem Description You are given access to a node (not the tail node) in a singly linked list. Your task is to delete this node from the list using the most efficient approach possible. You should not traverse the list to achieve this. # Function Signature ```python def delete_node(node: Node) -> None: pass ``` # Input - `node` (Node): The node to be deleted from the list. This node will not be the tail node. # Output This function does not need to return anything. It should modify the linked list in place. # Constraints - The input node is guaranteed to be a valid node of the singly linked list and not the tail node. - The list contains at least two nodes. # Example ```python # Suppose we have a list 1 -> 2 -> 3 -> 4 -> 5, and we are given the node with value 3. # After calling delete_node on node 3, the linked list should be modified to 1 -> 2 -> 4 -> 5. # Definition for a singly linked list node. class Node: def __init__(self, x): self.val = x self.next = None def delete_node(node: Node) -> None: # Your code here pass # Test Suite import unittest class TestDeleteNode(unittest.TestCase): def test_delete_node(self): # Create linked list 1 -> 2 -> 3 -> 4 -> 5 head = Node(1) curr = head for value in range(2, 6): curr.next = Node(value) curr = curr.next # Node with value 3 node = head.next.next # After delete_node, list should be 1 -> 2 -> 4 -> 5 delete_node(node) # Verify the new linked list order result = [] curr = head while curr: result.append(curr.val) curr = curr.next self.assertEqual(result, [1, 2, 4, 5]) # Edge Case: Ensure ValueError is raised when deleting None or tail node self.assertRaises(ValueError, delete_node, None) tail_node = Node(6) self.assertRaises(ValueError, delete_node, tail_node) if __name__ == \\"__main__\\": unittest.main() ``` # Explanation - Define a `Node` class to represent a node in the linked list. - Implement the `delete_node` function which modifies the list in place to delete the given node. - Write a test suite to validate the solution, ensuring the function handles typical cases and throws errors appropriately for edge cases.","solution":"class Node: def __init__(self, x): self.val = x self.next = None def delete_node(node: Node) -> None: Given access to a node (not the tail node) in a singly linked list, this function deletes the node from the list in place by copying the value of the next node into the given node and then deleting the next node. if node is None or node.next is None: raise ValueError(\\"Cannot delete the given node as it is either None or the tail node\\") # Copy the value of the next node to the current node node.val = node.next.val # Delete the next node by skipping it node.next = node.next.next"},{"question":"You are given a string and need to implement a function to reverse it. Implement and compare different methods to reverse a string in Python. # Function Signatures 1. `def reverse_recursive(s: str) -> str:` 2. `def reverse_iterative(s: str) -> str:` 3. `def reverse_pythonic(s: str) -> str:` 4. `def reverse_ultra_pythonic(s: str) -> str:` # Expected Input and Output - **Input**: A string `s` with length `0 <= len(s) <= 10^5`. - **Output**: A string that is the reverse of `s`. # Constraints - Do not use any external libraries. - Performance is important: For large inputs with length up to 100,000 characters, methods should execute efficiently. # Example ```python assert reverse_recursive(\\"hello\\") == \\"olleh\\" assert reverse_iterative(\\"world\\") == \\"dlrow\\" assert reverse_pythonic(\\"1234\\") == \\"4321\\" assert reverse_ultra_pythonic(\\"abcd\\") == \\"dcba\\" ``` # Requirements - Ensure your implementations handle typical edge cases like empty strings `\\"\\"` and single character strings `\\"a\\"`. - Analyze and compare the performance of each method for large strings (e.g., 10^5 characters).","solution":"def reverse_recursive(s: str) -> str: Reverses a string recursively. if len(s) == 0: return s else: return reverse_recursive(s[1:]) + s[0] def reverse_iterative(s: str) -> str: Reverses a string iteratively. reversed_str = [] for char in s: reversed_str.insert(0, char) return \'\'.join(reversed_str) def reverse_pythonic(s: str) -> str: Reverses a string using slicing. return s[::-1] def reverse_ultra_pythonic(s: str) -> str: Reverses a string using the built-in reversed function. return \'\'.join(reversed(s))"},{"question":"# Problem: Maximum Loot Without Alerting Police You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, and the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected. This system will automatically contact the police if two adjacent houses are broken into on the same night. Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police. # Function Signature ```python def max_loot(houses: List[int]) -> int: ``` # Input - **houses** (List[int]): A list of non-negative integers representing the amount of money in each house. # Output - **int**: The maximum amount of money that can be robbed without breaking into two adjacent houses. # Constraints - 0 <= len(houses) <= 10^4 - 0 <= houses[i] <= 10^4 # Examples Example 1: ```python houses = [2, 3, 2] output = max_loot(houses) print(output) # Output: 4 ``` Explanation: Rob house 1 (money = 2) and then rob house 3 (money = 2). Total amount that can be robbed = 2 + 2 = 4. Example 2: ```python houses = [1, 2, 3, 1] output = max_loot(houses) print(output) # Output: 4 ``` Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3). Total amount that can be robbed = 1 + 3 = 4. Example 3: ```python houses = [2, 7, 9, 3, 1] output = max_loot(houses) print(output) # Output: 12 ``` Explanation: Rob house 1 (money = 2), rob house 3 (money = 9), and rob house 5 (money = 1). Total amount that can be robbed = 2 + 9 + 1 = 12. # Additional Notes Ensure your implementation handles edge cases such as an empty list of houses, single house, and all house values being zeros properly.","solution":"def max_loot(houses: list[int]) -> int: if not houses: return 0 elif len(houses) == 1: return houses[0] # Initialize the maximum loot at the first two houses loot_at_n_minus_2 = houses[0] loot_at_n_minus_1 = max(houses[0], houses[1]) # Iterate through the rest of the houses for i in range(2, len(houses)): current_loot = max(houses[i] + loot_at_n_minus_2, loot_at_n_minus_1) loot_at_n_minus_2 = loot_at_n_minus_1 loot_at_n_minus_1 = current_loot return loot_at_n_minus_1"},{"question":"You are required to implement a Trie (prefix tree), which supports \'insert\', \'search\', and \'starts_with\' operations. The Trie should handle string inputs consisting of lowercase English letters (\'a\' to \'z\'). The operations you need to implement are: 1. **insert(word)**: Inserts the string `word` into the Trie. 2. **search(word)**: Returns `True` if the string `word` is in the Trie (indicating that it is a complete word), otherwise, returns `False`. 3. **starts_with(prefix)**: Returns `True` if there is any string in the Trie that starts with the given `prefix`, otherwise, returns `False`. Implement these operations inside a `Trie` class, using the provided `TrieNode` as nodes of the Trie. # Input/Output Formats Input - `insert(word)` where `word` is a string of lowercase English letters. - `search(word)` where `word` is a string of lowercase English letters. - `starts_with(prefix)` where `prefix` is a string of lowercase English letters. Output - `insert(word)` will not return any value. - `search(word)` will return a boolean (`True` or `False`). - `starts_with(prefix)` will return a boolean (`True` or `False`). Example ```py trie = Trie() trie.insert(\\"apple\\") print(trie.search(\\"apple\\")) # returns True print(trie.search(\\"app\\")) # returns False print(trie.starts_with(\\"app\\")) # returns True trie.insert(\\"app\\") print(trie.search(\\"app\\")) # returns True ``` # Constraints - The input strings will only contain lowercase letters (\'a\' to \'z\'). - The total number of words inserted will not exceed 10^4. - The length of each word will be at most 100. # Performance Requirements - Ensure that each operation runs in O(m) time complexity, where m is the length of the word or prefix. # Implementation Notes 1. Use a `TrieNode` class to represent each node in the Trie, which should contain: * A dictionary `children` to hold child nodes. * A boolean `is_word` to mark the end of a word. 2. The `Trie` class should initialize with a root `TrieNode`.","solution":"class TrieNode: def __init__(self): self.children = {} self.is_word = False class Trie: def __init__(self): self.root = TrieNode() def insert(self, word): node = self.root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.is_word = True def search(self, word): node = self.root for char in word: if char not in node.children: return False node = node.children[char] return node.is_word def starts_with(self, prefix): node = self.root for char in prefix: if char not in node.children: return False node = node.children[char] return True"},{"question":"# Cycle Sort Implementation: Extended Question **Context**: You are given a list of integers that need to be sorted in ascending order using minimal memory. The Cycle Sort algorithm is suitable for minimal memory applications but may be inefficient for larger lists due to its O(N^2) time complexity. To challenge your understanding of sorting algorithms and their characteristics, you will implement an enhanced version of Cycle Sort and analyze its performance. **Task**: 1. **Function Implementation**: Write a function `enhanced_cycle_sort(arr)` in Python that sorts a list of integers using the Cycle Sort algorithm. 2. **Performance Analysis**: After implementing the function, write a brief analysis discussing the performance of Cycle Sort on lists of varying sizes, highlighting scenarios where it performs well and where it does not. 3. **Edge Cases**: Consider and manage edge cases like empty arrays, arrays with one element, arrays with all identical elements, and already sorted arrays. ```python def enhanced_cycle_sort(arr): enhanced_cycle_sort Implement Cycle Sort to sort a list of integers in ascending order. Args: arr: List of integers to be sorted. Returns: A sorted list of integers. Performance Analysis: [Include your performance analysis here after implementing the function] len_arr = len(arr) # Finding cycle to rotate. for cur in range(len_arr - 1): item = arr[cur] # Finding an index to put items in. index = cur for i in range(cur + 1, len_arr): if arr[i] < item: index += 1 # Case where there is no cycle if index == cur: continue # Putting the item immediately right after the duplicate item or on the right. while item == arr[index]: index += 1 arr[index], item = item, arr[index] # Rotating the remaining cycle. while index != cur: # Finding where to put the item. index = cur for i in range(cur + 1, len_arr): if arr[i] < item: index += 1 # After item is duplicated, put it in place or put it there. while item == arr[index]: index += 1 arr[index], item = item, arr[index] return arr ``` **Constraints**: * The length of the input array will not exceed 10^5. * Each integer in the array will be within the range [-10^6, 10^6]. **Example**: ```python input_array = [4, 3, 2, 1] print(enhanced_cycle_sort(input_array)) # Output: [1, 2, 3, 4] ``` After completing the function implementation, include a brief analysis section discussing the algorithm\'s performance with respect to different list sizes and content characteristics.","solution":"def enhanced_cycle_sort(arr): enhanced_cycle_sort Implement Cycle Sort to sort a list of integers in ascending order. Args: arr: List of integers to be sorted. Returns: A sorted list of integers. n = len(arr) for cycle_start in range(n - 1): item = arr[cycle_start] # Find where to place the item. pos = cycle_start for i in range(cycle_start + 1, n): if arr[i] < item: pos += 1 # If the item is already in the correct position. if pos == cycle_start: continue # Otherwise, put the item in its correct position. while item == arr[pos]: pos += 1 arr[pos], item = item, arr[pos] # Rotate the rest of the cycle. while pos != cycle_start: pos = cycle_start for i in range(cycle_start + 1, n): if arr[i] < item: pos += 1 while item == arr[pos]: pos += 1 arr[pos], item = item, arr[pos] return arr # Performance Analysis: # Cycle Sort performs well in cases where memory usage is a primary concern since it # operates in O(1) extra memory. However, due to its O(N^2) time complexity, it is # inefficient for large lists compared to algorithms like Quick Sort or Merge Sort. # Cycle Sort is more useful for small to medium-sized arrays where in-place sorting # with minimal memory usage is needed. # # Edge Cases: # - Empty arrays: The function should return an empty array. # - Single element arrays: The function should return the array as-is. # - Arrays with all identical elements: The function should be able to handle this # smoothly and return the identical elements in the original order. # - Already sorted arrays: The function should simply verify the sorted array without # changing the order."},{"question":"# Coding Problem: Run-Length Encoding Challenge Problem Statement You are given a series of strings that need to be stored or transmitted efficiently. To achieve this, you will use the Run-Length Encoding (RLE) algorithm for compression. Your tasks are to implement functions that encode and decode strings using the RLE method. Task 1: Encoding Write a function `encode_rle(input)` that takes a string and compresses it using Run-Length Encoding. **Function Signature**: ```python def encode_rle(input: str) -> str: pass ``` **Input**: - `input` (string): The string to be encoded. It can contain any printable ASCII characters. **Output**: - Returns a string representing the run-length encoded version of the input. **Examples**: ```python assert encode_rle(\\"aaabbbcc\\") == \\"3a3b2c\\" assert encode_rle(\\"abcd\\") == \\"1a1b1c1d\\" assert encode_rle(\\"\\") == \\"\\" assert encode_rle(\\"aaaaaaaaaaa\\") == \\"11a\\" ``` Task 2: Decoding Write a function `decode_rle(input)` that takes a run-length encoded string and decompresses it back to its original form. **Function Signature**: ```python def decode_rle(input: str) -> str: pass ``` **Input**: - `input` (string): The string to be decoded. It will be a valid run-length encoded string. **Output**: - Returns a string representing the original uncompressed data. **Examples**: ```python assert decode_rle(\\"3a3b2c\\") == \\"aaabbbcc\\" assert decode_rle(\\"1a1b1c1d\\") == \\"abcd\\" assert decode_rle(\\"\\") == \\"\\" assert decode_rle(\\"11a\\") == \\"aaaaaaaaaaa\\" ``` Constraints: - 0 <= len(input) <= 10^6 - The encoded strings for decoding will always be valid. Notes: - Encoding Task: Ensure efficiency in handling large strings and avoid common pitfalls such as excessive string concatenation within loops. - Decoding Task: Carefully handle splitting and conversion of numeric counts to characters.","solution":"def encode_rle(input: str) -> str: if not input: return \\"\\" encoded_str = [] count = 1 for i in range(1, len(input)): if input[i] == input[i - 1]: count += 1 else: encoded_str.append(f\\"{count}{input[i - 1]}\\") count = 1 encoded_str.append(f\\"{count}{input[-1]}\\") return \\"\\".join(encoded_str) def decode_rle(input: str) -> str: if not input: return \\"\\" decoded_str = [] i = 0 while i < len(input): count_str = [] while i < len(input) and input[i].isdigit(): count_str.append(input[i]) i += 1 count = int(\\"\\".join(count_str)) decoded_str.append(input[i] * count) i += 1 return \\"\\".join(decoded_str)"},{"question":"# Question: Counting Sort with Negative Numbers and Custom Range You are asked to implement an enhanced version of Counting Sort which can handle arrays containing both positive and negative integers. The input array will have elements within a specified range. You need to sort the array efficiently while managing the range constraints and negative values correctly. Function Signature ```python def enhanced_counting_sort(arr: List[int], lower: int, upper: int) -> List[int]: pass ``` Input - `arr`: A list of integers `arr` (-10^5 <= arr[i] <= 10^5, 0 <= len(arr) <= 10^5). - `lower`: An integer representing the lower bound of the range of values. - `upper`: An integer representing the upper bound of the range of values. Output - A sorted list of integers containing all elements from `arr` in non-decreasing order. Constraints - The values in `arr` fall within the inclusive range `[lower, upper]`. Performance Requirements - The algorithm should run in O(n + k) time complexity, where `n` is the number of elements in `arr` and `k` is the range of values `(upper - lower + 1)`. - The space complexity should be O(n + k). Edge Cases - Arrays with only positive values. - Arrays with only negative values. - Arrays containing the same elements. - Empty arrays. Example ```python # Example 1 arr = [4, -1, -3, 2, 0] lower = -3 upper = 4 print(enhanced_counting_sort(arr, lower, upper)) # Output: [-3, -1, 0, 2, 4] # Example 2 arr = [] lower = -5 upper = 5 print(enhanced_counting_sort(arr, lower, upper)) # Output: [] # Example 3 arr = [10, -10, 0, 5, -5] lower = -10 upper = 10 print(enhanced_counting_sort(arr, lower, upper)) # Output: [-10, -5, 0, 5, 10] ```","solution":"def enhanced_counting_sort(arr, lower, upper): # Calculate the range of the values range_of_values = upper - lower + 1 # Initialize the count array count_arr = [0] * range_of_values # Fill the count array for num in arr: count_arr[num - lower] += 1 # Reconstruct the sorted array sorted_arr = [] for i in range(range_of_values): if count_arr[i] > 0: sorted_arr.extend([i + lower] * count_arr[i]) return sorted_arr"},{"question":"Context A text editor application often provides suggestions for word abbreviations to speed up typing. To improve this feature, you need to generate all possible abbreviations for given words. Task Implement a function `generate_abbreviations(word)` that takes a single string `word` and returns a list of all possible abbreviations for that word. Input Format * `word`: A non-empty string consisting of lowercase alphabetic characters. (1 <= len(word) <= 20) Output Format * A list of strings containing all possible abbreviations of the input word. Constraints * The function should generate abbreviations in a case-insensitive manner. * No character in the word should be skipped. Performance Requirements * The implementation should handle the worst-case input scenario efficiently (e.g., for the string length of 20). Examples ```python assert generate_abbreviations(\\"word\\") == [\\"word\\", \\"wor1\\", \\"wo1d\\", \\"wo2\\", \\"w1rd\\", \\"w1r1\\", \\"w2d\\", \\"w3\\", \\"1ord\\", \\"1or1\\", \\"1o1d\\", \\"1o2\\", \\"2rd\\", \\"2r1\\", \\"3d\\", \\"4\\"] assert generate_abbreviations(\\"a\\") == [\\"a\\", \\"1\\"] assert generate_abbreviations(\\"ab\\") == [\\"ab\\", \\"a1\\", \\"1b\\", \\"2\\"] ``` Note: Ensure your implementation handles edge cases and returns the correct abbreviations for all test cases.","solution":"def generate_abbreviations(word): Generates all possible abbreviations for the given word. def backtrack(pos, cur, count): if pos == len(word): if count > 0: cur += str(count) results.append(cur) else: # Abbreviate this character backtrack(pos + 1, cur, count + 1) # Keep this character if count > 0: cur += str(count) backtrack(pos + 1, cur + word[pos], 0) results = [] backtrack(0, \\"\\", 0) return results"},{"question":"# Nearest-Neighbor Classification Algorithm You are developing a machine learning model to classify data points using the Nearest-Neighbor (NN) algorithm. Your task is to implement this algorithm in Python. Task Implement the function `nearest_neighbor` that classifies a given input vector according to the closest labeled vector in the training set. Function Signature ```python def nearest_neighbor(x: tuple, tSet: dict) -> any: Classifies the input vector \'x\' using the nearest-neighbor algorithm with the given training set \'tSet\'. Args: x : tuple The input vector to classify. tSet : dict The training set containing labeled vectors. Keys are vectors (tuples) and values are labels (any type). Returns: any The label of the nearest neighbor in the training set. ``` Input Format * `x`: A tuple of numbers representing the input vector. * `tSet`: A dictionary where keys are tuples of numbers (feature vectors) and values can be any type representing labels (for example, strings or numbers). Output Format * The function should return the label of the nearest neighbor found in the training set. Example ```python # Example input input_vector = (3, 4) training_set = { (1, 2): \\"A\\", (5, 6): \\"B\\", (2, 1): \\"C\\" } # Expected output nearest_neighbor(input_vector, training_set) # The expected output may vary ``` Constraints * All vectors (input and training set) will have the same length. * The training set will have at least one vector. * The input vector and training set vectors contain only real numbers. Notes * Consider edge cases such as when the training set is minimal or when vectors have very close distances. * Ensure your calculation of distance is accurate. * Avoid using any external libraries apart from the standard math library.","solution":"import math def nearest_neighbor(x: tuple, tSet: dict) -> any: Classifies the input vector \'x\' using the nearest-neighbor algorithm with the given training set \'tSet\'. Args: x : tuple The input vector to classify. tSet : dict The training set containing labeled vectors. Keys are vectors (tuples) and values are labels (any type). Returns: any The label of the nearest neighbor in the training set. def euclidean_distance(p1, p2): Calculates the Euclidean distance between two points. return math.sqrt(sum((a - b) ** 2 for a, b in zip(p1, p2))) nearest_label = None nearest_distance = float(\'inf\') for vector, label in tSet.items(): distance = euclidean_distance(x, vector) if distance < nearest_distance: nearest_distance = distance nearest_label = label return nearest_label"},{"question":"# Problem Description You are required to implement a function named `find_substring` which replicates and improves upon the provided basic substring search algorithm. # Function Signature ```python def find_substring(haystack: str, needle: str) -> int: ``` # Input * `haystack` (str): The larger string within which to search for the substring. * `needle` (str): The substring to search for within the larger string. # Output * An integer representing the index of the first occurrence of `needle` in `haystack`, or -1 if `needle` is not part of `haystack`. # Constraints * The function should handle edge cases such as: * `needle` being an empty string. * `needle` being longer than `haystack`. * Consider optimizing for performance; aim to improve beyond the basic O((n-m+1)*m) time complexity if possible. # Example ```python haystack = \\"hello\\" needle = \\"ll\\" print(find_substring(haystack, needle)) # Output: 2 haystack = \\"aaaaa\\" needle = \\"bba\\" print(find_substring(haystack, needle)) # Output: -1 ``` # Notes * Think about efficient string-matching algorithms that can reduce the number of comparisons. * Demonstrate your understanding of algorithm optimization by providing a more refined solution if possible.","solution":"def find_substring(haystack: str, needle: str) -> int: Returns the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack. if needle == \\"\\": return 0 if len(needle) > len(haystack): return -1 # Using the Knuth-Morris-Pratt (KMP) Pattern Matching Algorithm def compute_lps(needle): lps = [0] * len(needle) length = 0 i = 1 while i < len(needle): if needle[i] == needle[length]: length += 1 lps[i] = length i += 1 else: if length != 0: length = lps[length - 1] else: lps[i] = 0 i += 1 return lps lps = compute_lps(needle) i = j = 0 while i < len(haystack): if needle[j] == haystack[i]: i += 1 j += 1 if j == len(needle): return i - j elif i < len(haystack) and needle[j] != haystack[i]: if j != 0: j = lps[j - 1] else: i += 1 return -1"},{"question":"# Objective Implement a sorting algorithm based on the principles of randomness. You\'ll create a sort function that keeps randomly shuffling an array until it is sorted. # Detailed Problem Statement You are required to implement the `bogoSort` function that sorts an array of integers. Your implementation should use random shuffling of the elements and repeatedly check if the array is sorted until it is. # Function Signature ```python def bogoSort(arr: List[int], max_iterations: int = 100000) -> List[int]: pass ``` # Input * `arr` (List[int]): A list of integers to be sorted. * `max_iterations` (int): An optional integer providing the maximum number of iterations for shuffling to prevent an infinite loop. Default value is 100,000. # Output * Return a list of integers sorted in non-decreasing order. # Example ```python >>> bogoSort([3, 2, 1]) [1, 2, 3] >>> bogoSort([1, 2, 3]) [1, 2, 3] >>> bogoSort([5, 1, 3, 3, 2], max_iterations=50) \'A given iteration limit has been reached before sorting could be completed\' ``` # Constraints * You must include a way to gracefully terminate execution if the maximum number of iterations (`max_iterations`) is reached before sorting is completed. * Do not use built-in sorting functions (i.e., `arr.sort()` or `sorted()`). * The solution should be attempted manually to demonstrate understanding of the algorithm. # Notes * Ensure your implementation handles cases like empty arrays and arrays with duplicate elements. * Your solution must check the array\'s sorted status after each shuffle and should terminate within 100,000 iterations by default. If sorting cannot be completed within the given iteration limit, return an appropriate message.","solution":"from typing import List import random def is_sorted(arr: List[int]) -> bool: Helper function to check if an array is sorted. for i in range(len(arr) - 1): if arr[i] > arr[i + 1]: return False return True def bogoSort(arr: List[int], max_iterations: int = 100000) -> List[int]: Sorts the array by randomly shuffling it until it is sorted or max_iterations is reached. iterations = 0 while not is_sorted(arr): if iterations >= max_iterations: return \'A given iteration limit has been reached before sorting could be completed\' random.shuffle(arr) iterations += 1 return arr"},{"question":"# Question: Implement Efficient Word Search with Prefix Matching Your task is to implement a dictionary data structure that allows for efficient addition and searching of words. The dictionary should support the following operations: 1. **add_word(word)**: Adds a word into the dictionary. 2. **search(word)**: Searches for word in the dictionary, where `word` can contain the dot character `.` to represent any one letter. Requirements: 1. **Function Signatures**: - `add_word(word: str) -> None` - `search(word: str) -> bool` 2. You should implement the dictionary using a Trie data structure. 3. Handle cases with the dot character `.` which can match any letter. 4. Ensure that your implementation can handle adding and searching for large numbers of words efficiently. Input/Output: * **add_word(word)**: - **Input**: A string `word` consisting of lowercase English letters (1 <= len(word) <= 25). - **Output**: None. * **search(word)**: - **Input**: A string `word` consisting of lowercase English letters and/or `.` (1 <= len(word) <= 25). - **Output**: A boolean indicating whether the word is present in the dictionary matching the given pattern. Constraints: * All words are composed of lowercase English letters. * Focus on optimizing both time and space complexity. Example: ```python dictionary = WordDictionary() dictionary.add_word(\\"bad\\") dictionary.add_word(\\"dad\\") dictionary.add_word(\\"mad\\") print(dictionary.search(\\"pad\\")) # False print(dictionary.search(\\"bad\\")) # True print(dictionary.search(\\".ad\\")) # True print(dictionary.search(\\"b..\\")) # True ``` Explanation: - After adding the words \\"bad\\", \\"dad\\", and \\"mad\\", the searches return the expected results: - \\"pad\\" is not found, so it returns False. - \\"bad\\" matches exactly, so it returns True. - \\".ad\\" matches any letter followed by \\"ad\\", so it matches \\"bad\\", \\"dad\\", and \\"mad\\", thus returns True. - \\"b..\\" matches \\"bad\\", as \'b\' followed by any two characters is found in the dictionary.","solution":"class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False class WordDictionary: def __init__(self): self.root = TrieNode() def add_word(self, word: str) -> None: node = self.root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.is_end_of_word = True def search(self, word: str) -> bool: def search_in_node(word, node): for i, char in enumerate(word): if char == \'.\': return any(search_in_node(word[i + 1:], child) for child in node.children.values()) else: if char not in node.children: return False node = node.children[char] return node.is_end_of_word return search_in_node(word, self.root)"},{"question":"You are provided with a sentence consisting of multiple words separated by spaces. We want to reverse the order of the words in this sentence. Note that words are defined as sequences of non-whitespace characters, and the words in the output should be separated by a single space. # Function Signature ```python def reverse_words_in_sentence(sentence: str) -> str: ``` # Input * A single string `sentence` (0 <= len(sentence) <= 1000), which may contain leading or trailing spaces. # Output * A single string with the words in reversed order, properly trimmed, and separated by a single space. # Constraints * A word is defined as a sequence of non-whitespace characters. # Examples 1. Input: `\\"the sky is blue\\"` Output: `\\"blue is sky the\\"` 2. Input: `\\" hello world \\"` Output: `\\"world hello\\"` 3. Input: `\\"a good example\\"` Output: `\\"example good a\\"` # Notes * You must not use any built-in reverse functions directly on the entire string. * Ensure to handle multiple spaces between words and any leading/trailing spaces. # Scenario Imagine you are working on a text-processing tool that needs to reverse sentences. This tool helps linguists to study the effect of word arrangement in sentences by providing sentence reversals. Implement the `reverse_words_in_sentence()` function to assist in this processing task.","solution":"def reverse_words_in_sentence(sentence: str) -> str: Reverses the words in a given sentence. Parameters: sentence (str): A string sentence containing multiple words. Returns: str: The sentence with the words reversed. # Split the sentence into words, filtering out possible empty strings caused by multiple spaces words = sentence.split() # Reverse the list of words reversed_words = words[::-1] # Join the reversed words with a single space reversed_sentence = \' \'.join(reversed_words) return reversed_sentence"},{"question":"# Nearest Neighbor Search with Optimization In this task, you will implement an optimized version of the nearest neighbor algorithm using a KD-tree data structure to efficiently search for the nearest neighbor. The KD-tree is a space-partitioning data structure that organizes points in a k-dimensional space. You need to complete the following two functions: 1. **KDTree**: This class should implement the construction of the KD-tree from the training set. 2. **nearest_neighbor_search**: This function should use the KD-tree to find the nearest neighbor of a given point. # Input: - A list of tuples representing points in the training set. - A tuple representing the query point whose nearest neighbor needs to be found. # Output: - The nearest neighbor in the training set to the query point. # Constraints: - The training set will contain at most 10^5 points. - Each point in the training set and the query point will have at most 10 dimensions. - Coordinates of the points will be floating-point numbers. # Scenario: You are working on a robotics project where you need to localize a robot based on its distance measurements from known landmarks (training set). To quickly find the nearest landmark to the robot\'s current position (query point), you will use the KD-tree based nearest neighbor algorithm. # Function Signatures: ```python class KDTree: def __init__(self, points): Initialize the KD-Tree with the given list of points. Arguments: points -- list of points represented as tuples def nearest_neighbor(self, query_point): Find the nearest neighbor of the query_point using the KD-Tree. Arguments: query_point -- a single point represented as a tuple Returns: The nearest point in the training set to the query_point. def nearest_neighbor_search(training_set, query_point): Implement nearest neighbor search using KD-Tree. Arguments: training_set -- list of points represented as tuples query_point -- a single point represented as a tuple Returns: The nearest point in the training set to the query_point. ``` # Example: ```python training_set = [(2.1, 3.0), (5.4, 2.1), (3.1, 4.1), (9.0, 6.2)] query_point = (3.0, 4.0) kdtree = KDTree(training_set) result = kdtree.nearest_neighbor(query_point) print(result) # Expected output: (3.1, 4.1) as this is the nearest point to (3.0, 4.0) ``` # Requirements: - Implement the KDTree class to construct the KD-tree. - `nearest_neighbor` method to find the nearest neighbor using the KD-tree. - Use recursion and efficient partitioning for KD-tree construction and search. - Ensure the solution is optimized for performance and handles edge cases appropriately.","solution":"import numpy as np class KDTree: class Node: def __init__(self, point=None, left=None, right=None, axis=None): self.point = point self.left = left self.right = right self.axis = axis def __init__(self, points): def build_kdtree(points, depth): if not points: return None axis = depth % len(points[0]) points.sort(key=lambda x: x[axis]) median = len(points) // 2 return self.Node( point=points[median], left=build_kdtree(points[:median], depth + 1), right=build_kdtree(points[median + 1:], depth + 1), axis=axis ) self.root = build_kdtree(points, 0) def nearest_neighbor(self, query_point, return_distance=False): def distance_squared(point1, point2): return sum((x - y) ** 2 for x, y in zip(point1, point2)) def knn_search(node, point, depth, best_node, best_dist): if node is None: return best_node, best_dist axis = node.axis next_best, next_dist = None, None if point[axis] < node.point[axis]: next_best, next_dist = knn_search(node.left, point, depth + 1, best_node, best_dist) other_side = node.right else: next_best, next_dist = knn_search(node.right, point, depth + 1, best_node, best_dist) other_side = node.left if next_best is None: next_best, next_dist = node.point, distance_squared(point, node.point) if distance_squared(point, node.point) < next_dist: next_best, next_dist = node.point, distance_squared(point, node.point) if (point[axis] - node.point[axis]) ** 2 < next_dist: other_best, other_dist = knn_search(other_side, point, depth + 1, next_best, next_dist) if other_dist < next_dist: next_best, next_dist = other_best, other_dist return next_best, next_dist best_point, best_distance = knn_search(self.root, query_point, 0, None, float(\'inf\')) return (best_point, best_distance) if return_distance else best_point def nearest_neighbor_search(training_set, query_point): kd_tree = KDTree(training_set) return kd_tree.nearest_neighbor(query_point)"},{"question":"You are tasked with implementing a function that takes a string and reverses only the vowels in that string. The order of non-vowel characters should remain unchanged. # Function Signature ```python def reverse_vowel(s: str) -> str: pass ``` # Input - A single string `s` where `0 <= len(s) <= 10^5`. # Output - A single string with the vowels reversed. # Example - Input: `\\"hello\\"` - Output: `\\"holle\\"` - Input: `\\"leetcode\\"` - Output: `\\"leotcede\\"` # Constraints 1. The input string will only contain printable ASCII characters. 2. The solution should handle up to the maximum input size efficiently. # Notes - Vowels are: `a, e, i, o, u` and their uppercase equivalents. - You should process the input and output as strings. # Scenario Consider a scenario where you need to create a word game application. One of the features of this game is to provide hints to the players by reversing only the vowels of given words. This functionality can help players recognize certain patterns without directly giving away the word itself. # Additional Information - Ensure that your implementation handles edge cases such as strings with no vowels, entirely vowel strings, empty strings, and single-character strings correctly.","solution":"def reverse_vowel(s: str) -> str: Reverses only the vowels in the input string s. Parameters: s (str): A string where 0 <= len(s) <= 10^5 Returns: str: A string with the vowels reversed, non-vovel characters are unchanged. vowels = set(\\"aeiouAEIOU\\") s_list = list(s) left, right = 0, len(s) - 1 while left < right: if s_list[left] in vowels and s_list[right] in vowels: s_list[left], s_list[right] = s_list[right], s_list[left] left += 1 right -= 1 if s_list[left] not in vowels: left += 1 if s_list[right] not in vowels: right -= 1 return \\"\\".join(s_list)"},{"question":"You are given a non-negative number represented as a list of digits, with the most significant digit at the head of the list (big-endian format). Your task is to implement a function `increment_number(digits)` that adds one to the number. The function should return the resulting list of digits. # Requirements - The input list will only contain non-negative single digits (0 to 9). - The most significant digit is at the head of the list, and each element in the list represents a single digit. - Handle edge cases such as when the list is empty or all elements are 9. - The function should accommodate numbers of any length. # Input Format - A list of integers `digits` where each integer is between 0 and 9. # Output Format - A list of integers representing the incremented number. # Constraints - The length of the list should be at least 1 and at most (10^4). - No leading zeros in the initial list except for the number 0 itself. # Example Input ```python digits = [1, 2, 3] ``` Output ```python [1, 2, 4] ``` # Additional Information - This problem simulates operations on very large integers that might exceed traditional storage capacities. - Ensure your solution is optimized for both time and space complexity. # Function Signature ```python def increment_number(digits: List[int]) -> List[int]: pass ```","solution":"def increment_number(digits): Increments a number represented as a list of digits by 1. Parameters: digits (list of int): The list of digits representing the number. Returns: list of int: The list of digits representing the incremented number. n = len(digits) # Traverse the digits in reverse order for i in range(n-1, -1, -1): if digits[i] == 9: digits[i] = 0 else: digits[i] += 1 return digits # If all digits were \'9\' return [1] + digits"},{"question":"Implement Shell Sort to arrange a given list of integers in ascending order. Your implementation should follow the steps of the Shell Sort algorithm while ensuring that the correct gap sequence is used. Input: - A list of integers, `arr`, such that 1 <= len(arr) <= 10^4 and each integer 0 <= arr[i] <= 10^6. Output: - Sorted list in ascending order. Constraints: - Ensure your implementation respects the in-place sorting principle. - Handle edge cases such as empty list, list with one element, all elements being the same, and already sorted lists. # Example Example 1: **Input:** ```python arr = [23, 12, 1, 8, 34, 54, 2, 3] ``` **Output:** ```python [1, 2, 3, 8, 12, 23, 34, 54] ``` Example 2: **Input:** ```python arr = [] ``` **Output:** ```python [] ``` Example 3: **Input:** ```python arr = [5] ``` **Output:** ```python [5] ``` # Example 4: **Input:** ```python arr = [9, 7, 5, 3, 2, 1] ``` **Output:** ```python [1, 2, 3, 5, 7, 9] ``` Implement your solution in a function called `shell_sort`. ```python def shell_sort(arr): # Your code here ```","solution":"def shell_sort(arr): Implements the Shell Sort algorithm to sort a list of integers in ascending order. n = len(arr) gap = n // 2 # Start with a big gap, then reduce the gap while gap > 0: for i in range(gap, n): temp = arr[i] j = i # Perform a gapped insertion sort while j >= gap and arr[j - gap] > temp: arr[j] = arr[j - gap] j -= gap arr[j] = temp gap //= 2 return arr"},{"question":"You are tasked with implementing a dynamic hash table that can handle different data types as keys and provides efficient insert, delete, and retrieval operations. The hash table should support resizing when a certain load factor is reached to maintain operational efficiency. Your hash table should: 1. Support any hashable data type as keys (e.g., strings, integers). 2. Implement collision handling using linear probing. 3. Automatically resize itself to maintain a load factor that\'s less than or equal to 0.7. # Function Specification You need to define the following class and methods: Class - `DynamicHashTable` Methods - `put(key, value)`: Insert the key-value pair into the hash table. - `get(key)`: Retrieve the value associated with the key from the hash table. - `del_(key)`: Delete the key-value pair identified by the key from the hash table. - `resize()`: Private method to handle resizing the hash table and rehashing existing elements. # Input & Output - **put(key, value)**: * Input: A key of any hashable type and a value. * Output: None. - **get(key)**: * Input: A key. * Output: The value associated with the key or `None` if the key is not found. - **del_(key)**: * Input: A key. * Output: None. # Constraints - Ensure that the hash table resizes itself when the load factor exceeds 0.7. # Example ```python hash_table = DynamicHashTable() hash_table.put(\'apple\', 12) hash_table.put(42, \'meaning of life\') print(hash_table.get(\'apple\')) # Output: 12 print(hash_table.get(42)) # Output: \'meaning of life\' hash_table.del_(\'apple\') print(hash_table.get(\'apple\')) # Output: None ``` Ensure you handle keys of different data types, collisions efficiently, and resizing as specified.","solution":"class DynamicHashTable: def __init__(self): self.capacity = 8 self.size = 0 self.load_factor = 0.7 self.table = [None] * self.capacity def _hash(self, key): return hash(key) % self.capacity def _resize(self): old_table = self.table self.capacity *= 2 self.table = [None] * self.capacity self.size = 0 for item in old_table: if item: key, value = item self.put(key, value) def put(self, key, value): if self.size / self.capacity > self.load_factor: self._resize() idx = self._hash(key) while self.table[idx] is not None: if self.table[idx][0] == key: self.table[idx] = (key, value) return idx = (idx + 1) % self.capacity self.table[idx] = (key, value) self.size += 1 def get(self, key): idx = self._hash(key) start_idx = idx while self.table[idx] is not None: if self.table[idx][0] == key: return self.table[idx][1] idx = (idx + 1) % self.capacity if idx == start_idx: break return None def del_(self, key): idx = self._hash(key) start_idx = idx while self.table[idx] is not None: if self.table[idx][0] == key: self.table[idx] = None self.size -= 1 idx = (idx + 1) % self.capacity while self.table[idx] is not None: key_rehash, value_rehash = self.table[idx] self.table[idx] = None self.size -= 1 self.put(key_rehash, value_rehash) idx = (idx + 1) % self.capacity return idx = (idx + 1) % self.capacity if idx == start_idx: break"},{"question":"# Question: Anagram Checker for Extended Character Set Background An anagram is a rearrangement of the letters of one word to form another word. Given two strings, write a function to determine if they are anagrams of each other. This time, the strings can contain any printable ASCII characters, and the comparison should be case-sensitive. Function Signature ```python def is_anagram(s1: str, s2: str) -> bool: pass ``` Input * `s1` (string): The first string. * `s2` (string): The second string. Output * `bool`: Returns `True` if `s1` and `s2` are anagrams, `False` otherwise. Constraints * Both `s1` and `s2` are non-null strings and can be of different lengths. * The strings can contain any printable ASCII characters. * The function should run efficiently for strings up to length 10^5. Examples ```python print(is_anagram(\\"apple\\", \\"pleap\\")) # True print(is_anagram(\\"apple\\", \\"apPle\\")) # False print(is_anagram(\\"apple\\", \\"cherry\\")) # False print(is_anagram(\\"123\\", \\"321\\")) # True print(is_anagram(\\"abc!\\", \\"!cbA\\")) # False ``` Performance requirements The solution should maintain a linear time complexity, ensuring efficient performance even for the upper limit constraints. Hint Consider using a dictionary or a Counter from the collections module for managing character frequencies.","solution":"from collections import Counter def is_anagram(s1: str, s2: str) -> bool: Returns True if s1 and s2 are anagrams, False otherwise. # Anagrams must have the same length if len(s1) != len(s2): return False # Use Counter to count character frequencies return Counter(s1) == Counter(s2)"},{"question":"# Level Order Traversal of a Binary Search Tree (BST) Given a binary search tree (BST), implement the function `bst_level_order(root)` that returns the level order traversal of its nodes\' values (from left to right, level by level). **Function Signature:** ```python def bst_level_order(root: TreeNode) -> List[List[int]]: pass ``` # Input * `root` - (TreeNode): The root of the BST, where each node has an integer value, a left child, and a right child. # Output * (List[List[int]]): A list of lists, where each inner list contains the values of the nodes at that level of the BST. # Constraints * The number of nodes in the tree is in the range [0, 10^4]. * The value of each node is in the range [-10^4, 10^4]. * The `TreeNode` class is defined as follows: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` # Scenario Consider delivering level order traversal for a search tree representing patient records sorted according to their unique ID, where you need to access the records level by level for processing. For example: Given the BST: ``` 50 / 30 70 / / 20 40 60 80 ``` Your function should return: ``` [ [50], [30, 70], [20, 40, 60, 80] ] ``` # Requirements * Handle the condition when the tree is empty. * Ensure efficient memory usage, especially handling cases with large trees. * Consider the edge cases, such as very skewed trees or trees with nodes only on one side.","solution":"from collections import deque from typing import List, Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def bst_level_order(root: Optional[TreeNode]) -> List[List[int]]: if not root: return [] result = [] queue = deque([root]) while queue: level_size = len(queue) current_level = [] for _ in range(level_size): node = queue.popleft() current_level.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.append(current_level) return result"},{"question":"Context You are working on a network analysis tool aimed at discovering clusters of interconnected nodes within a network. As part of the tool, you need to implement a function to count the number of connected components in an undirected graph. Requirements * **Function to Implement**: `count_components` * **Expected Input and Output**: - **Input**: - An integer `n` representing the number of nodes. - A list of edges (pairs of integers). Each pair [u, v] represents an undirected edge between nodes u and v. - **Output**: An integer representing the total number of connected components in the graph. * **Constraints**: - Nodes are labeled from 1 through n. - 1 ≤ n ≤ 10^5 (100,000) - 0 ≤ number of edges ≤ 2 * 10^5 (200,000) Function Signature ```python def count_components(n: int, edges: List[Tuple[int, int]]) -> int: pass ``` Performance Requirements - The solution should efficiently handle large graphs up to the provided constraint limits. - Aim to achieve a time complexity of O(V + E) and a space complexity of O(V). Example ```python # Example 1 n = 7 edges = [(1, 2), (2, 4), (6, 5), (3, 7)] assert count_components(n, edges) == 3 # Example 2 n = 5 edges = [(1, 2), (3, 4)] assert count_components(n, edges) == 3 ``` Notes - Ensure that your implementation works correctly for edge cases such as isolated nodes or a fully connected graph. - Consider converting your DFS implementation to an iterative approach if you encounter stack overflow issues with recursive DFS on large graphs. # Hints - You may utilize collections like defaultdict from the collections module for efficient adjacency list representation. - Use a boolean list to keep track of visited nodes.","solution":"from typing import List, Tuple from collections import defaultdict def count_components(n: int, edges: List[Tuple[int, int]]) -> int: def dfs(node): stack = [node] while stack: current = stack.pop() for neighbor in graph[current]: if not visited[neighbor]: visited[neighbor] = True stack.append(neighbor) # Initializing adjacency list for the graph graph = defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) visited = [False] * (n + 1) component_count = 0 for node in range(1, n + 1): if not visited[node]: visited[node] = True component_count += 1 dfs(node) return component_count"},{"question":"# Scenario You are tasked with analyzing the frequency distribution of error codes from a list of error logs generated by a software application. The error codes are represented as integers. Your goal is to determine how many times each error code appears in the list. # Task Implement the function `get_histogram` which calculates the histogram of error codes in the given list. Function Signature: ```python def get_histogram(input_list: list) -> dict: pass ``` Input: * A list of integers, `input_list` (0 <= len(input_list) <= 10^6), where each integer is an error code. Output: * A dictionary where keys are the unique error codes and values are their corresponding frequencies in the input list. Constraints: * The function should run in O(n) time complexity. * The function should use O(k) extra space, where k is the number of unique elements in the input list. Example: ```python input_1 = [3, 3, 2, 1] # Output: {1: 1, 2: 1, 3: 2} input_2 = [2, 3, 5, 5, 5, 6, 4, 3, 7] # Output: {2: 1, 3: 2, 4: 1, 5: 3, 6: 1, 7: 1} ``` Ensure your implementation properly handles edge cases such as empty lists and lists with all identical elements.","solution":"def get_histogram(input_list): Returns a dictionary representing the histogram of error codes. :param input_list: List of integers representing error codes. :return: Dictionary with error codes as keys and their frequencies as values. histogram = {} for code in input_list: if code in histogram: histogram[code] += 1 else: histogram[code] = 1 return histogram"},{"question":"# Scenario: You work for a financial firm that analyzes stock prices to identify periods of the highest profit. Given a list of daily stock price changes, you want to compute the maximum profit you could have made by buying and selling the stock once. Write a function that implements this for an array of price changes. # Problem Statement: Write a Python function `max_subarray_profit(prices: List[int]) -> int` that takes in a list of integers representing daily price changes and outputs the maximum profit that could be achieved from any contiguous subarray of these daily changes. # Input: * `prices`: A list of integers where each integer represents the change in stock price for a day. The length of the list is at least 1 and at most 10^5. # Output: * An integer representing the maximum profit that could be achieved. # Constraints: * The maximum subarray sum can be negative if all price changes are losses. * Consider edge cases such as single element arrays, all elements being negative, and mixture of positive and negative numbers. # Example: ```python assert max_subarray_profit([1, 2, -3, 4, 5, -7, 23]) == 23 assert max_subarray_profit([-1, -2, -3, -4, -5]) == -1 assert max_subarray_profit([10, -3, 2, 5, -5, 6, -1]) == 15 ``` # Function Signature: ```python def max_subarray_profit(prices: List[int]) -> int: # Your code here ```","solution":"from typing import List def max_subarray_profit(prices: List[int]) -> int: Returns the maximum profit that can be achieved from any contiguous subarray of daily stock price changes. if not prices: return 0 max_profit = current_profit = prices[0] for price_change in prices[1:]: current_profit = max(price_change, current_profit + price_change) max_profit = max(max_profit, current_profit) return max_profit"},{"question":"# Task: Implement a Reverse Segment Tree **Background**: The Segment Tree data structure is an efficient way to perform range queries and updates on an array. A common application is a `min` Segment Tree to find the minimum value of a subarray. However, consider a scenario where we want to reverse the operations and query for maximum. Your task is to implement a `ReverseSegmentTree` class based on the Segment Tree provided, but instead of supporting standard range queries and updates, it should support \\"reverse\\" range queries and updates. # Problem Statement Implement a class `ReverseSegmentTree` that supports: 1. Building the tree from an array. 2. Updating individual elements of the array. 3. Performing range queries to find maximum values instead. # Specifications Implement the following methods: - `__init__(self, arr: List[int]) -> None`: Initializes the reverse segment tree with the given array. - `build_tree(self) -> None`: Builds the tree from the initialized array. - `update(self, index: int, value: int) -> None`: Updates the element at the specified index with the given value. - `query(self, left: int, right: int) -> int`: Returns the maximum value in the range `[left, right]`. # Example Usage ```python # Example 1: arr = [2, 4, 5, 3, 4] reverse_tree = ReverseSegmentTree(arr) print(reverse_tree.query(2, 4)) # Output should be 5 reverse_tree.update(3, 6) print(reverse_tree.query(0, 3)) # Output should be 6 # Example 2: arr = [4, 5, 2, 3, 4, 43, 3] reverse_tree = ReverseSegmentTree(arr) print(reverse_tree.query(0, 6)) # Output should be 43 reverse_tree.update(2, -10) print(reverse_tree.query(0, 6)) # Output should be 43 # Example 3: arr = [1, 3, 2, 4] reverse_tree = ReverseSegmentTree(arr) print(reverse_tree.query(1, 3)) # Output should be 4 reverse_tree.update(1, 5) print(reverse_tree.query(1, 3)) # Output should be 5 ``` # Constraints - The length of the input array will not exceed (10^5). - The values of the elements in the array will be in the range ([-10^9, 10^9]). - The number of queries and updates will not exceed (10^5). # Notes - Handle edge cases like querying a single element or querying the whole array. - Optimize for performance and ensure efficient use of memory.","solution":"class ReverseSegmentTree: def __init__(self, arr): self.n = len(arr) self.tree = [0] * (2 * self.n) self.build_tree(arr) def build_tree(self, arr): for i in range(self.n): self.tree[self.n + i] = arr[i] for i in range(self.n - 1, 0, -1): self.tree[i] = max(self.tree[i * 2], self.tree[i * 2 + 1]) def update(self, index, value): pos = self.n + index self.tree[pos] = value while pos > 1: pos //= 2 self.tree[pos] = max(self.tree[2 * pos], self.tree[2 * pos + 1]) def query(self, left, right): left += self.n right += self.n + 1 result = float(\'-inf\') while left < right: if left % 2 == 1: result = max(result, self.tree[left]) left += 1 if right % 2 == 1: right -= 1 result = max(result, self.tree[right]) left //= 2 right //= 2 return result"},{"question":"# Question Title: **Check Bipartite Graph using BFS** Scenario You have been given an undirected graph, and you need to determine if the graph is bipartite. A bipartite graph is one where you can divide the set of vertices into two subsets such that no two vertices within the same subset are adjacent. Task Write a function `is_bipartite_graph(adj_list: List[List[int]]) -> bool` to determine if the graph is bipartite. Function Signature ```python def is_bipartite_graph(adj_list: List[List[int]]) -> bool: ``` Input * `adj_list` (List[List[int]]): A square matrix where `adj_list[i][j]` is 1 if there is an edge between vertex `i` and `j`, and 0 otherwise. Output * Returns `True` if the graph is bipartite, otherwise returns `False`. Constraints * The number of vertices `V` in the graph, `1 ≤ V ≤ 10^3`. * The matrix is symmetric since the graph is undirected. Examples 1. **Example 1** ```python adj_list = [ [0, 1, 0, 1], [1, 0, 1, 0], [0, 1, 0, 1], [1, 0, 1, 0] ] print(is_bipartite_graph(adj_list)) # Output: True ``` 2. **Example 2** ```python adj_list = [ [0, 1, 1], [1, 0, 1], [1, 1, 0] ] print(is_bipartite_graph(adj_list)) # Output: False ```","solution":"from typing import List def is_bipartite_graph(adj_list: List[List[int]]) -> bool: Determines whether the given undirected graph is bipartite. Parameters: adj_list (List[List[int]]): Adjacency matrix of the graph. Returns: bool: True if the graph is bipartite, False otherwise. V = len(adj_list) colors = [-1] * V # -1 means uncolored def bfs(start: int) -> bool: queue = [start] colors[start] = 0 # Start coloring with 0 while queue: u = queue.pop(0) for v in range(V): if adj_list[u][v] == 1: # There\'s an edge between u and v if colors[v] == -1: colors[v] = 1 - colors[u] # Assign alternate color queue.append(v) elif colors[v] == colors[u]: return False # Same color adjacent nodes detected return True for i in range(V): if colors[i] == -1: if not bfs(i): return False return True"},{"question":"Design a Python class named `QuadraticProbingHashTable` that implements a hash table utilizing quadratic probing to resolve hash collisions. The class should support the following operations: - Insert a key-value pair. - Retrieve the value corresponding to a given key. - Delete a key-value pair. - Automatically resize the table when the load factor exceeds 0.7. # Requirements 1. **HashTable**: Implement the hash table with an initial size of 11, using quadratic probing for collision resolution. 2. **Methods**: - `put(key, value)`: Inserts the key-value pair into the hash table. If the load factor exceeds 0.7, double the size of the table and rehash all existing entries. - `get(key)`: Returns the value associated with the key or `None` if the key doesn\'t exist. - `del_(key)`: Deletes the key-value pair associated with the key. - `__len__()`: Returns the number of key-value pairs in the hash table. 3. **Edge Cases**: - Hash table initially empty. - High collision scenarios. - Deletion of nonexistent keys. # Constraints - Keys will be non-negative integers. - Values can be any data type. - Handle the resizing efficiently to maintain performance. # Sample Usage ```python ht = QuadraticProbingHashTable() ht.put(1, \'value1\') ht.put(12, \'value12\') # Example: both 1 and 12 collide initially. print(ht.get(1)) # Returns \'value1\' print(ht.get(12)) # Returns \'value12\' ht.del_(1) print(ht.get(1)) # Returns None print(len(ht)) # Returns 1 ``` # Performance Constraints - Ensure put, get, and del operations are O(1) average time complexity. - Implement resizing such that it takes O(n) time, where n is the number of elements. # Additional Notes Ensure that you handle the `full table` scenario by resizing when necessary. The hash function for this exercise can simply be `key % size`. Remember to use quadratic probing formula `hash = (initial_hash + i^2) % size` for rehashing.","solution":"class QuadraticProbingHashTable: def __init__(self): self.size = 11 self.table = [None] * self.size self.count = 0 def put(self, key, value): if self.load_factor() > 0.7: self.resize() index = self.hash(key) original_index = index i = 1 while self.table[index] is not None and self.table[index][0] != key: index = (original_index + i**2) % self.size i += 1 if self.table[index] is None: self.count += 1 self.table[index] = (key, value) def get(self, key): index = self.hash(key) original_index = index i = 1 while self.table[index] is not None: if self.table[index][0] == key: return self.table[index][1] index = (original_index + i**2) % self.size i += 1 return None def del_(self, key): index = self.hash(key) original_index = index i = 1 while self.table[index] is not None: if self.table[index][0] == key: self.table[index] = None self.count -= 1 # Rehash the subsequent elements in the cluster self.rehash_cluster((original_index + i**2) % self.size) return index = (original_index + i**2) % self.size i += 1 def rehash_cluster(self, start_index): i = 1 index = start_index while self.table[index] is not None: key, value = self.table[index] self.table[index] = None self.count -= 1 # Temporarily decrease count before re-inserting self.put(key, value) # Reinsert the element index = (start_index + i**2) % self.size i += 1 def hash(self, key): return key % self.size def load_factor(self): return self.count / self.size def resize(self): old_table = self.table self.size *= 2 self.table = [None] * self.size self.count = 0 for item in old_table: if item is not None: self.put(item[0], item[1]) def __len__(self): return self.count"},{"question":"Problem Statement # Context You are given the task to find specific digits in an infinite integer sequence where the integers are concatenated sequentially. For example, the sequence is \\"123456789101112...\\". # Task Implement a function `find_nth_digit(n)` that, given an integer `n`, returns the nth digit in this infinite sequence. # Input and Output Format - The input is a single integer `n` (1 ≤ n ≤ 2 * 10^9). - The output is a single integer which is the nth digit of the sequence. # Constraints - You must ensure that the solution is efficient given the constraints (logarithmic time complexity preferred). # Example ```python print(find_nth_digit(3)) # Output: 3 print(find_nth_digit(11)) # Output: 0 print(find_nth_digit(15)) # Output: 2 ``` # Performance Requirements - The solution must handle large values of `n` efficiently, within the given time and space complexity constraints. # Additional Notes - Consider edge cases, such as when `n` is exactly at the transition points between number lengths. ```python def find_nth_digit(n): Find the nth digit of the infinite sequence \\"123456789101112...\\". Args: n (int): The position in the sequence. Returns: int: The nth digit in the sequence. length = 1 count = 9 start = 1 while n > length * count: n -= length * count length += 1 count *= 10 start *= 10 start += (n-1) // length s = str(start) return int(s[(n-1) % length]) ``` Explain how your function works, and why it correctly finds the nth digit efficiently.","solution":"def find_nth_digit(n): Find the nth digit of the infinite sequence \\"123456789101112...\\". Args: n (int): The position in the sequence. Returns: int: The nth digit in the sequence. length = 1 count = 9 start = 1 # Find the length of the number where the nth digit is located while n > length * count: n -= length * count length += 1 count *= 10 start *= 10 # Find the actual number where the nth digit is located start += (n - 1) // length s = str(start) return int(s[(n - 1) % length])"},{"question":"# Bit Manipulation Functions Challenge You are tasked with implementing several functions that manipulate bits within integers. These functions perform fundamental bit-level operations such as retrieving, setting, clearing, and updating a bit at a specific index. # Function Specifications 1. **get_bit(num: int, i: int) -> bool**: - Retrieve the bit at index `i` in the binary representation of `num`. - **Input**: `num` (integer), `i` (index of the bit, 0-based from the right) - **Output**: Boolean value indicating the bit at the index; `True` for 1, `False` for 0 - **Constraints**: `0 <= i < 32` (assuming a 32-bit integer) 2. **set_bit(num: int, i: int) -> int**: - Set the bit at index `i` to 1 in the binary representation of `num`. - **Input**: `num` (integer), `i` (index of the bit, 0-based from the right) - **Output**: New integer with the bit at index `i` set to 1 - **Constraints**: `0 <= i < 32` 3. **clear_bit(num: int, i: int) -> int**: - Clear the bit at index `i` to 0 in the binary representation of `num`. - **Input**: `num` (integer), `i` (index of the bit, 0-based from the right) - **Output**: New integer with the bit at index `i` cleared to 0 - **Constraints**: `0 <= i < 32` 4. **update_bit(num: int, i: int, bit: int) -> int**: - Update the bit at index `i` to the specified value `bit` (0 or 1) in the binary representation of `num`. - **Input**: `num` (integer), `i` (index of the bit, 0-based from the right), `bit` (0 or 1) - **Output**: New integer with the bit at index `i` updated to the given value - **Constraints**: `0 <= i < 32`, bit in {0, 1} # Example ```python # Example usage and expected outputs: assert get_bit(5, 0) == True # binary 101, bit at index 0 is 1 assert get_bit(5, 1) == False # binary 101, bit at index 1 is 0 assert set_bit(5, 1) == 7 # binary 101 | 010 -> 111 (which is 7 in decimal) assert clear_bit(7, 1) == 5 # binary 111 & 101 -> 101 (which is 5 in decimal) assert update_bit(5, 1, 1) == 7 # binary 101, set bit at index 1 to 1 -> 111 (7 in decimal) assert update_bit(5, 2, 0) == 1 # binary 101, set bit at index 2 to 0 -> 001 (1 in decimal) ``` Implement the following functions using bit manipulation techniques. The code must be efficient, and edge cases must be handled properly. Happy coding!","solution":"def get_bit(num: int, i: int) -> bool: Retrieve the bit at index `i` in the binary representation of `num`. return (num & (1 << i)) != 0 def set_bit(num: int, i: int) -> int: Set the bit at index `i` to 1 in the binary representation of `num`. return num | (1 << i) def clear_bit(num: int, i: int) -> int: Clear the bit at index `i` to 0 in the binary representation of `num`. return num & ~(1 << i) def update_bit(num: int, i: int, bit: int) -> int: Update the bit at index `i` to the specified value `bit` (0 or 1) in the binary representation of `num`. return (num & ~(1 << i)) | ((bit & 1) << i)"},{"question":"# Question: Implement a Find Median Operation in a B-tree Scenario: You are a software engineer tasked to enhance a B-tree data structure. The system requires support for finding the median value efficiently. Assume the B-tree is dynamically updated with insertions and deletions. Implement a function `find_median` to determine the median of the elements. Constraints: - The function should have a time complexity of O(log n). - Your implementation should leverage the existing tree traversal and balance mechanisms. - The B-tree can have an even or odd number of elements. Input: The B-tree object implemented as per the provided class definitions and methods. Output: The median value within the B-tree. Function Signature: ```python class BTree: # existing methods def find_median(self) -> float: pass ``` Example: ```python btree = BTree(t_val=2) btree.insert_key(10) btree.insert_key(20) btree.insert_key(5) btree.insert_key(6) btree.insert_key(12) # After various insertions and deletions median = btree.find_median() assert median == 10 # The median in [5, 6, 10, 12, 20] ``` Write the function `find_median` to determine the median of all elements in the B-tree.","solution":"from bisect import insort class BTreeNode: def __init__(self, t, leaf=False): self.t = t self.leaf = leaf self.keys = [] self.children = [] class BTree: def __init__(self, t_val): self.root = BTreeNode(t_val, leaf=True) self.t = t_val # B-Tree insert function def insert_key(self, key): if len(self.root.keys) == (2 * self.t) - 1: new_node = BTreeNode(self.t, leaf=False) new_node.children.append(self.root) self.split_child(new_node, 0) self.root = new_node self.insert_non_full(self.root, key) def insert_non_full(self, node, key): i = len(node.keys) - 1 if node.leaf: node.keys.append(None) while i >= 0 and key < node.keys[i]: node.keys[i + 1] = node.keys[i] i -= 1 node.keys[i + 1] = key else: while i >= 0 and key < node.keys[i]: i -= 1 i += 1 if len(node.children[i].keys) == (2 * self.t) - 1: self.split_child(node, i) if key > node.keys[i]: i += 1 self.insert_non_full(node.children[i], key) def split_child(self, parent, i): t = self.t child = parent.children[i] new_child = BTreeNode(t, child.leaf) parent.keys.insert(i, child.keys[t - 1]) parent.children.insert(i + 1, new_child) new_child.keys = child.keys[t:(2 * t) - 1] child.keys = child.keys[:t - 1] if not child.leaf: new_child.children = child.children[t:(2 * t)] child.children = child.children[:t] def inorder(self, node, keys_list): for i in range(len(node.keys)): if not node.leaf: self.inorder(node.children[i], keys_list) keys_list.append(node.keys[i]) if not node.leaf: self.inorder(node.children[len(node.keys)], keys_list) def find_median(self): keys_list = [] self.inorder(self.root, keys_list) n = len(keys_list) if n % 2 == 0: return (keys_list[n//2 - 1] + keys_list[n//2]) / 2 else: return keys_list[n//2]"},{"question":"# Comb Sort Algorithm Implementation Problem Statement You are required to implement a sorting algorithm based on the Comb Sort principle. Given an unsorted array, your task is to write a function that sorts the array in ascending order using Comb Sort. Function Signature ```python def comb_sort(arr: List[int]) -> List[int]: pass ``` Input * A single list `arr` of integers where `1 <= len(arr) <= 10^6`. Output * The sorted list `arr` in ascending order. Constraints * The algorithm should run within reasonable time constraints for large input sizes. * You may assume all the integers in the list are within the range `[-10^9, 10^9]`. Performance Requirements * Optimize for best average-case performance. * Conduct gap reduction efficiently to ensure the performance is near O(N log N) for practical input sizes. Example ```python # Example 1 arr = [34, 8, 64, 51, 32, 21] print(comb_sort(arr)) # Output: [8, 21, 32, 34, 51, 64] # Example 2 arr = [5, 9, 3, 10, -2, 7, 0] print(comb_sort(arr)) # Output: [-2, 0, 3, 5, 7, 9, 10] ``` Edge Cases to Consider * Already sorted list. * List with all identical elements. * Single element list. * List containing negative numbers.","solution":"from typing import List def comb_sort(arr: List[int]) -> List[int]: def get_next_gap(gap): gap = (gap * 10) // 13 if gap < 1: return 1 return gap n = len(arr) gap = n swapped = True while gap != 1 or swapped: gap = get_next_gap(gap) swapped = False for i in range(n - gap): if arr[i] > arr[i + gap]: arr[i], arr[i + gap] = arr[i + gap], arr[i] swapped = True return arr"},{"question":"# Question: BST In-order Traversal Function Given a Binary Search Tree (BST), your task is to implement both an iterative and recursive in-order traversal function. Your function should take the root of the BST as input and return a list of the node values in the in-order sequence. **Function Signature**: ```python def inorder_iterative(root: Node) -> List[int]: pass def inorder_recursive(root: Node) -> List[int]: pass ``` **Input**: - `root` (Node): The root node of a BST where each node has the following attributes: - `val` (int): The value of the node. - `left` (Node): Pointer to the left child node. - `right` (Node): Pointer to the right child node. **Output**: - Both functions should return a list of integers representing the node values in in-order sequence. **Constraints**: - Nodes values are unique integers. - Tree may contain between 0 to 10,000 nodes. **Example**: ```python # Example Tree Structure # 100 # / # 50 150 # / / # 25 75 125 175 n1 = Node(100) n2 = Node(50) n3 = Node(150) n4 = Node(25) n5 = Node(75) n6 = Node(125) n7 = Node(175) n1.left, n1.right = n2, n3 n2.left, n2.right = n4, n5 n3.left, n3.right = n6, n7 root = n1 # Expected Output # inorder_iterative(root) => [25, 50, 75, 100, 125, 150, 175] # inorder_recursive(root) => [25, 50, 75, 100, 125, 150, 175] ``` **Note**: Your implementation should handle edge cases gracefully, including an empty tree. Make sure to test your functions with various tree structures.","solution":"class Node: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def inorder_iterative(root: Node) -> list[int]: result = [] stack = [] current = root while current or stack: while current: stack.append(current) current = current.left current = stack.pop() result.append(current.val) current = current.right return result def inorder_recursive(root: Node) -> list[int]: def helper(node: Node, result: list[int]): if node: helper(node.left, result) result.append(node.val) helper(node.right, result) result = [] helper(root, result) return result"},{"question":"# Question: Enhanced Interpolation Search You are tasked with implementing an enhanced version of the interpolation search algorithm that gracefully handles edge cases and optimizes performance for non-uniform distributions. Your implementation should switch to binary search if the formula-based position estimation appears ineffective after a few iterations. # Function Signature: ```python def enhanced_interpolation_search(array: List[int], search_key: int) -> int: :param array: List[int] - The sorted array to be searched. :param search_key: int - The key to be searched in the array. :returns: int - Index of search_key in array if found, else -1. ``` # Input and Output: * **Input**: - `array`: A sorted list of integers of length `n` (`1 <= n <= 10^7`). - `search_key`: An integer to search for in the list. * **Output**: - Return the index of `search_key` if found in the array, otherwise return `-1`. # Constraints: - The array will be sorted in ascending order. - The array can have duplicate elements. - You must handle non-uniformly distributed arrays effectively. # Examples: ```python >>> enhanced_interpolation_search([10, 20, 30, 40, 50], 30) 2 >>> enhanced_interpolation_search([5, 10, 12, 14, 17, 20, 21], 22) -1 >>> enhanced_interpolation_search([], 10) -1 ``` # Implementation Notes: 1. Implement the standard interpolation search as the primary algorithm. 2. Monitor the number of iterations and switch to binary search if position estimation does not seem effective after a few iterations. 3. Ensure that all edge cases (e.g. division by zero, empty array) are handled gracefully.","solution":"from typing import List def enhanced_interpolation_search(array: List[int], search_key: int) -> int: Enhanced Interpolation Search Algorithm with a fallback mechanism to binary search. :param array: List[int] - The sorted array to be searched. :param search_key: int - The key to be searched in the array. :returns: int - Index of search_key in array if found, else -1. if not array: return -1 left, right = 0, len(array) - 1 iteration_limit = 5 iteration_count = 0 while left <= right and search_key >= array[left] and search_key <= array[right]: if left == right: if array[left] == search_key: return left return -1 # Calculate the position using interpolation formula if array[right] == array[left]: pos = left else: pos = left + ((right - left) // (array[right] - array[left]) * (search_key - array[left])) if pos < left or pos > right: break if array[pos] == search_key: return pos if array[pos] < search_key: left = pos + 1 else: right = pos - 1 iteration_count += 1 if iteration_count >= iteration_limit: break # Fallback to binary search if interpolation was not effective return binary_search(array, search_key, left, right) def binary_search(array: List[int], search_key: int, left: int, right: int) -> int: while left <= right: mid = (left + right) // 2 if array[mid] == search_key: return mid elif array[mid] < search_key: left = mid + 1 else: right = mid - 1 return -1"},{"question":"# Scenario: Imagine you are developing a search suggestion feature for a large-scale book catalog system. Users of the system want quick and efficient suggestions as they type in a search bar. # Question: Implement a `Trie` class to manage the book catalog and facilitate both word insertion and prefix-based search. Complete the trie data structure with the methods specified below. Ensure your solution handles different edge cases effectively. Methods to Implement: 1. `insert(word: str)`: Adds a word into the trie. 2. `search(word: str)`: Returns True if the word is in the trie. 3. `starts_with(prefix: str)`: Returns True if there is any word in the trie that starts with the given prefix. Input and Output Formats: 1. **insert(word: str)**: * Input: A word consisting of lowercase letters \'a\' to \'z\'. * Output: None. 2. **search(word: str)**: * Input: A word consisting of lowercase letters \'a\' to \'z\'. * Output: Boolean indicating if the word is in the trie. 3. **starts_with(prefix: str)**: * Input: A prefix consisting of lowercase letters \'a\' to \'z\'. * Output: Boolean indicating if any words in the trie start with the given prefix. Constraints: * Each word or prefix provided will have length between 1 and 1000. * The total number of words inserted does not exceed 10^5. # Example: ```python trie = Trie() trie.insert(\\"book\\") trie.insert(\\"bookworm\\") trie.insert(\\"bookmark\\") print(trie.search(\\"book\\")) # Output: True print(trie.search(\\"booker\\")) # Output: False print(trie.starts_with(\\"boo\\")) # Output: True print(trie.starts_with(\\"bra\\")) # Output: False ```","solution":"class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False class Trie: def __init__(self): self.root = TrieNode() def insert(self, word: str): node = self.root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.is_end_of_word = True def search(self, word: str) -> bool: node = self.root for char in word: if char not in node.children: return False node = node.children[char] return node.is_end_of_word def starts_with(self, prefix: str) -> bool: node = self.root for char in prefix: if char not in node.children: return False node = node.children[char] return True"},{"question":"# Question: Generate All Subsets of a Set You are given a list of distinct integers. Your task is to write a function `generate_subsets` that returns all possible subsets of these integers. # Function Signature: ```python def generate_subsets(nums: List[int]) -> Set[Tuple[int]]: ``` # Input: * `nums` (List[int]): A list of distinct integers (1 ≤ len(nums) ≤ 15, -10^4 ≤ nums[i] ≤ 10^4). # Output: * Set[Tuple[int]]: A set containing all possible subsets (as tuples) of the input list. # Example: ```python generate_subsets([1, 2, 3]) ``` Expected output: ```python { (), (1,), (2,), (3,), (1, 2,), (1, 3,), (2, 3,), (1, 2, 3) } ``` # Constraints: * The solution set should not contain duplicate subsets. * The order of the subsets within the set does not matter. * Python\'s built-in data structures (list, set, tuple) should be used. # Scenario: You are working on a configuration management system where each possible configuration is represented by a subset of available features. To ensure compatibility and exhaustiveness tests, you need a utility function that generates all possible configurations from a given set of features. # Performance Requirements: * Your implementation should be efficient given the constraints, ensuring it handles the largest input sizes within reasonable time.","solution":"from typing import List, Set, Tuple from itertools import chain, combinations def generate_subsets(nums: List[int]) -> Set[Tuple[int]]: Returns all possible subsets (as tuples) of the input list of distinct integers. subsets = set() for length in range(len(nums) + 1): for subset in combinations(nums, length): subsets.add(subset) return subsets"},{"question":"# Exchange Sort Implementation You are tasked with implementing the Exchange Sort algorithm on a list of integers to sort them in ascending order. The Exchange Sort algorithm iteratively compares and swaps elements that are in the wrong order. Function Signature ```python def exchange_sort(arr: List[int]) -> List[int]: pass ``` Input * `arr (List[int])`: A list of integers with a length `n` (1 ≤ n ≤ 10^3). Output * Returns a list of integers sorted in ascending order. Constraints * The list can contain duplicate elements. * You must implement the sort in place to achieve O(1) space complexity. # Example ```python print(exchange_sort([64, 25, 12, 22, 11])) # Output: [11, 12, 22, 25, 64] print(exchange_sort([4, 3, 2, 1])) # Output: [1, 2, 3, 4] ``` # Guidelines 1. You need to ensure that the elements within the array are swapped correctly based on the condition mentioned. 2. Consider edge cases such as an empty array (return an empty array), an array with one element, and arrays with all identical elements. 3. Optimize for readability and ensure your code handles the input constraints efficiently.","solution":"def exchange_sort(arr): Sorts an array of integers in ascending order using the Exchange Sort algorithm. Parameters: arr (List[int]): A list of integers to be sorted. Returns: List[int]: A sorted list of integers in ascending order. n = len(arr) for i in range(n - 1): for j in range(i + 1, n): if arr[i] > arr[j]: arr[i], arr[j] = arr[j], arr[i] return arr"},{"question":"# Coding Challenge: Finding Two Unique Numbers in an Array You are given an array of integers, `nums`, where exactly two elements appear only once and all the other elements appear exactly twice. Your task is to implement the function `find_unique_numbers(nums)`, which returns the two elements that appear only once. Function Signature ```python def find_unique_numbers(nums: List[int]) -> List[int]: ``` Constraints * The array `nums` will have exactly two unique elements. * Every other element in the array will appear exactly twice. * The function should have a time complexity of O(N). * The function should have a space complexity of O(1). Input * `nums` (List[int]): The input array containing integers with the given constraints. Output * List[int]: A list containing the two unique elements appearing only once. The order of the elements in the list does not matter. Example ```python >>> find_unique_numbers([1, 2, 1, 3, 2, 5]) [3, 5] # or [5, 3] since the order doesn\'t matter ``` # Note The solution involves: 1. Using the XOR operation to isolate the XOR of the two unique elements. 2. Using bitwise manipulation to split the array and isolate each unique element. Implementation Requirements * The solution must employ XOR and bitwise techniques as described. * No additional data structures (like sets or dictionaries) should be used that consume extra space linearly relative to the input. Good luck, and may your bits be ever in your favor!","solution":"from typing import List def find_unique_numbers(nums: List[int]) -> List[int]: # XOR all the elements in the array xor_result = 0 for num in nums: xor_result ^= num # Find a set bit (rightmost set bit) in xor_result set_bit = xor_result & -xor_result # Divide elements into two groups based on the set bit num1 = 0 num2 = 0 for num in nums: if num & set_bit: num1 ^= num else: num2 ^= num return [num1, num2]"},{"question":"Implement a function `optimized_bubble_sort(arr, simulation=False)` that sorts an array using an optimized version of the bubble sort algorithm. This optimization should ensure that the algorithm stops immediately if no swaps are made in an entire pass through the array (indicating that the array is already sorted). Additionally, the function should be able to simulate the sorting process if the `simulation` parameter is set to `True`. # Input Format * `arr` : A list of integers that need to be sorted. * `simulation` : A boolean (default is `False`). If `True`, the function should print the array after each swap indicating the current iteration number. # Output Format * The sorted list of integers. # Constraints * `0 <= len(arr) <= 10^3` * `-10^3 <= arr[i] <= 10^3` for all valid i. # Performance Requirements The solution must handle the input size efficiently. # Example Usage ```python arr = [64, 34, 25, 12, 22, 11, 90] print(optimized_bubble_sort(arr)) # Should output the sorted array # Example with simulation: optimized_bubble_sort(arr, True) # Should print the array after each swap ``` # Additional Information - The function should be robust enough to handle edge cases, such as an empty list or a list with a single element. - Consider the performance and optimize the algorithm to stop early if the list is already sorted.","solution":"def optimized_bubble_sort(arr, simulation=False): n = len(arr) for i in range(n): swapped = False # Traverse the array from 0 to n-i-1 for j in range(0, n-i-1): # Swap if the element found is greater if arr[j] > arr[j+1]: arr[j], arr[j+1] = arr[j+1], arr[j] swapped = True if simulation: print(f\\"Iteration {i+1}, swap {j}: {arr}\\") # If no two elements were swapped by inner loop, then break if not swapped: break return arr"},{"question":"# Inverting an N x N Matrix Background In linear algebra, the inversion of a matrix ( A ) (if it exists) is a fundamental operation. The inverted matrix ( B ) should satisfy the condition ( AB = BA = I_n ), where ( I_n ) is the identity matrix of size ( n times n ). You are required to implement a function to invert an ( n times n ) matrix. Follow the steps of the given pseudocode and handle edge cases effectively. Input * A non-empty, non-singular square matrix ( A ) of size ( n times n ) (2 ≤ n ≤ 10). Output * Returns the inverted matrix of size ( n times n ). Implement the Following Function ```python def invert_matrix(matrix): Invert a given n x n matrix where 2 ≤ n ≤ 10. Returns the inverted matrix or raises a ValueError for invalid matrices. pass ``` # Constraints 1. The input matrix will always be invertible and square. 2. Return the inverted matrix in the same format as the input matrix. 3. Handle the special cases as indicated: 2x2 should be handled separately for efficiency. # Example Usage ```python matrix_2x2 = [[4, 7], [2, 6]] inverted_matrix = invert_matrix(matrix_2x2) print(inverted_matrix) # Expected Output: [[0.6, -0.7], [-0.2, 0.4]] matrix_3x3 = [[1, 2, 3], [0, 1, 4], [5, 6, 0]] inverted_matrix = invert_matrix(matrix_3x3) print(inverted_matrix) # Expected Output: [[-24, 18, 5], [20, -15, -4], [-5, 4, 1]] ``` Hints * Ensure that a matrix is passed by validating dimensions. * Use cofactor and adjugate steps to aid inversion for sizes larger than 2x2. * Remember to implement determinant calculation accurately for correctness.","solution":"import numpy as np def invert_matrix(matrix): Invert a given n x n matrix where 2 ≤ n ≤ 10. Returns the inverted matrix. # Convert the input matrix to a numpy array for easy manipulation matrix = np.array(matrix) # Check if the matrix is square if matrix.shape[0] != matrix.shape[1]: raise ValueError(\\"Matrix must be square\\") # Compute the determinant to ensure the matrix is invertible det = np.linalg.det(matrix) if det == 0: raise ValueError(\\"Matrix is singular and cannot be inverted\\") # Compute the inverse inv_matrix = np.linalg.inv(matrix) # Convert the result back to a nested list format return inv_matrix.tolist()"},{"question":"# Problem: Efficiently Sort Large Integers You are working for a company that processes a large volume of numerical data. Your team is particularly interested in efficiently sorting lists of large integers that represent transaction amounts. Given the high volume of data, it is crucial to implement a sorting algorithm that can sort these integers quickly. Task Implement a function `efficient_radix_sort(transactions: List[int], verbose: bool = False) -> List[int]`: 1. The function takes in two parameters: * `transactions`: A list of non-negative integers representing transaction amounts. * `verbose`: A boolean flag (default is `False`). When set to `True`, the function should print the array after each significant digit sorting iteration. 2. The function returns a sorted list of integers. Input * `transactions` (List[int]): A list of non-negative integers, each at most 20 digits long. * `verbose` (bool): Determines whether intermediate steps are printed. Output * The function should return a list of integers sorted in non-decreasing order. Constraints * `len(transactions) ≤ 10^6` * Integers in `transactions` are at most 20 digits long and non-negative. Performance Requirements * Time Complexity should be better than O(n log n) if possible. * The sorting algorithm should use limited additional space. Example ```python transactions = [170, 45, 75, 90, 802, 24, 2, 66] result = efficient_radix_sort(transactions) print(result) # Output: [2, 24, 45, 66, 75, 90, 170, 802] ``` Additional Notes * Make sure to handle edge cases, such as empty lists or lists with a single element. * Ensure that the function works efficiently even when transaction amounts vary significantly in digit length. * Optimize for both time and space complexity where possible.","solution":"from typing import List def efficient_radix_sort(transactions: List[int], verbose: bool = False) -> List[int]: def counting_sort_for_radix(array, exp): n = len(array) output = [0] * n count = [0] * 10 for i in range(n): index = (array[i] // exp) % 10 count[index] += 1 for i in range(1, 10): count[i] += count[i - 1] for i in range(n - 1, -1, -1): index = (array[i] // exp) % 10 output[count[index] - 1] = array[i] count[index] -= 1 for i in range(n): array[i] = output[i] if verbose: print(f\\"After sorting on digit {exp}: {array}\\") if not transactions: return [] max_val = max(transactions) exp = 1 while max_val // exp > 0: counting_sort_for_radix(transactions, exp) exp *= 10 return transactions"},{"question":"# Minimum Cost Path for Travel Between Cities You are given a matrix where `matrix[i][j]` represents the cost of travel from city `i` to city `j`. The matrix is a square matrix of size `N x N` where `N` is the number of cities. You can only travel from city `i` to city `j` if `i < j`. Entries where `i >= j` are either marked with `-1` or have a high value `INF` indicating non-travelable paths. Your task is to implement a function: ```python def find_min_cost(matrix: List[List[int]]) -> int: Finds the minimum cost to travel from city 0 to city N-1. Parameters: matrix (List[List[int]]): 2D list representing the cost of travel between cities. Returns: int: Minimum cost to travel from city 0 to city N-1. pass ``` # Input: - An N x N matrix `matrix` where `2 <= N <= 100` - `matrix[i][j]` is an integer where `0 <= matrix[i][j] <= 100`, or `-1`. # Output: - Return a single integer, the minimum cost to travel from city `0` to city `N-1`. If no valid path exists, return `-1`. # Constraints: - You can only move from city `i` to city `j` if `i < j`. # Example: Example 1: **Input:** ```python matrix = [[0, 15, 80, 90], [-1, 0, 40, 50], [-1, -1, 0, 70], [-1, -1, -1, 0]] ``` **Output:** ``` 65 ``` **Explanation:** The minimum cost path is `0 --> 1 --> 3` with cost `15 + 50 = 65`. Example 2: **Input:** ```python matrix = [[0, 10, 75, 94], [-1, 0, 35, 50], [-1, -1, 0, 80], [-1, -1, -1, 0]] ``` **Output:** ``` 60 ``` **Explanation:** The minimum cost path is `0 --> 1 --> 3` with cost `10 + 50 = 60`. # Notes: * You may assume that the input matrix adheres to the constraints provided. * You may use `float(\'inf\')` to represent an infinitely large cost for convenience in handling `-1` values in your implementation.","solution":"from typing import List def find_min_cost(matrix: List[List[int]]) -> int: Finds the minimum cost to travel from city 0 to city N-1. Parameters: matrix (List[List[int]]): 2D list representing the cost of travel between cities. Returns: int: Minimum cost to travel from city 0 to city N-1. # Number of cities N = len(matrix) # Initialize the min_cost array with infinities min_cost = [float(\'inf\')] * N min_cost[0] = 0 # Iterate over the matrix to calculate minimum costs for i in range(N): for j in range(i + 1, N): if matrix[i][j] != -1: min_cost[j] = min(min_cost[j], min_cost[i] + matrix[i][j]) return min_cost[N-1] if min_cost[N-1] != float(\'inf\') else -1"},{"question":"# Robbing Circular Houses You are a professional robber planning to rob houses along a circular street. Each house has a certain amount of money stashed, and the only constraint stopping you from robbing each of them is that adjacent houses have a security system connected, which will automatically contact the police if two adjacent houses are broken into on the same night. Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police. Note: Because the street is circular, the first and last houses are adjacent. Function Signature ```python def circular_house_robber(houses: List[int]) -> int: ``` Input - `houses` (List[int]): A list of non-negative integers representing the money in each house. Output - (int): The maximum amount of money that can be robbed without alerting the police. Constraints - 0 <= len(houses) <= 100 - 0 <= houses[i] <= 1000 Example ```python assert circular_house_robber([2, 3, 2]) == 3 assert circular_house_robber([1, 2, 3, 1]) == 4 assert circular_house_robber([0]) == 0 ``` # Explanation 1. In the first example, the houses have money `[2, 3, 2]`. You can rob house 2 (with 3 units of money), so the maximum amount is 3. 2. In the second example, the houses have money `[1, 2, 3, 1]`. You can rob houses 1 and 3, so the maximum amount is 4. 3. In the third example, the house has no money, hence the maximum amount is 0. # Hints - This problem can be divided into two linear House Robber problems: 1. Rob houses from index 0 to n-2. 2. Rob houses from index 1 to n-1. - Take the maximum of the results from the two scenarios.","solution":"from typing import List def house_robber(houses: List[int]) -> int: n = len(houses) if n == 0: return 0 if n == 1: return houses[0] dp = [0] * n dp[0] = houses[0] dp[1] = max(houses[0], houses[1]) for i in range(2, n): dp[i] = max(dp[i-1], dp[i-2] + houses[i]) return dp[-1] def circular_house_robber(houses: List[int]) -> int: if not houses: return 0 if len(houses) == 1: return houses[0] return max(house_robber(houses[:-1]), house_robber(houses[1:]))"},{"question":"# Scenario You are developing a navigation application that helps drivers find the shortest route from their current location to various destinations within a city. The city map is represented as a directed graph where intersections are vertices, and the roads are edges with weights representing travel time in minutes. # Task Implement a function `find_shortest_paths` to determine the shortest travel time from a given starting intersection to all other intersections in the city. # Function Signature ```python def find_shortest_paths(graph: List[List[int]], src: int) -> List[int]: ``` # Input - `graph`: A two-dimensional list of integers where `graph[i][j]` represents the travel time from intersection `i` to intersection `j`. If there is no direct road between intersections, the value is `0`. - `src`: An integer representing the starting intersection. # Output - A list of integers where the `i-th` element is the shortest travel time from the starting intersection `src` to intersection `i`. # Constraints - `1 <= len(graph) <= 100` - `0 <= graph[i][j] <= 1000` - `0 <= src < len(graph)` # Example Given the graph: ```python graph = [ [0, 10, 20, 0, 0], [10, 0, 0, 50, 10], [20, 0, 0, 20, 33], [0, 50, 20, 0, 20], [0, 10, 33, 20, 0] ] ``` and the starting intersection `src = 0`, the expected output is: ```python [0, 10, 20, 40, 20] ``` # Explanation Starting from intersection `0`: * The travel time to `0` itself is `0`. * To reach `1`, the shortest path has a travel time of `10` (direct road). * To reach `2`, travel time is `20` (direct road). * To reach `3`, travel time is `40` (via intersection `2`). * To reach `4`, travel time is `20` (via intersection `1`). # Note - You need to handle the edge case where there are intersections that are not reachable from the starting intersection. In such cases, the respective travel times should remain as infinite.","solution":"import heapq from typing import List def find_shortest_paths(graph: List[List[int]], src: int) -> List[int]: Determines the shortest travel time from the starting intersection to all other intersections. num_nodes = len(graph) distances = [float(\'inf\')] * num_nodes # Initialize distances with infinity distances[src] = 0 # Distance to the source is 0 priority_queue = [(0, src)] # Start with the source in the priority queue while priority_queue: current_distance, current_node = heapq.heappop(priority_queue) if current_distance > distances[current_node]: continue for neighbor in range(num_nodes): if graph[current_node][neighbor] > 0: # There is a road to the neighbor distance = current_distance + graph[current_node][neighbor] if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return distances"},{"question":"Design and implement a data structure that supports the following operations efficiently using Tries: 1. `insert(word: str) -> None`: Inserts the word into the Trie. 2. `search(word: str) -> bool`: Returns true if the word is in the Trie and false otherwise. 3. `startsWith(prefix: str) -> bool`: Returns true if there is any word in the Trie that starts with the given prefix. Your implementation should handle the following requirements: - All characters in words and prefixes are lowercase English letters (\'a\' to \'z\'). - No additional string handling libraries are allowed (e.g., no use of string or re modules). Input and Output Formats 1. **insert** - **Input**: `word: str` (a non-empty string containing only lowercase letters) - **Output**: None 2. **search** - **Input**: `word: str` (a non-empty string containing only lowercase letters) - **Output**: `bool` (True if the word is found, otherwise False) 3. **startsWith** - **Input**: `prefix: str` (a non-empty string containing only lowercase letters) - **Output**: `bool` (True if any word in the Trie starts with the prefix, otherwise False) Constraints * The input strings will be of moderate length; you can assume the maximum length for any word or prefix will be 1000 characters and there will be at most 10^5 operations. # Example ```python trie = Trie() trie.insert(\\"apple\\") assert trie.search(\\"apple\\") == True # returns True assert trie.search(\\"app\\") == False # returns False assert trie.startsWith(\\"app\\") == True # returns True trie.insert(\\"app\\") assert trie.search(\\"app\\") == True # returns True ``` # Additional Context This question tests the comprehension of Trie data structures, focusing on efficient string handling for operations like insertion, search, and prefix validation. It covers fundamental concepts such as tree traversal and node management, while also touching on performance and optimization concerns for handling large datasets.","solution":"class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False class Trie: def __init__(self): self.root = TrieNode() def insert(self, word: str) -> None: node = self.root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.is_end_of_word = True def search(self, word: str) -> bool: node = self.root for char in word: if char not in node.children: return False node = node.children[char] return node.is_end_of_word def startsWith(self, prefix: str) -> bool: node = self.root for char in prefix: if char not in node.children: return False node = node.children[char] return True"},{"question":"You are given an unsorted integer array and a target integer. Your task is to implement a function to find the first occurrence index of the target in the array using a Linear Search Algorithm. If the target does not exist in the array, return -1. Function Signature ```python def find_first_occurrence(array: List[int], target: int) -> int: # your code here ``` Input & Output Formats * **Input**: * `array`: A list of integers `array` (1 ≤ len(array) ≤ 10^6). * `target`: An integer `target` (-10^7 ≤ target ≤ 10^7). * **Output**: * Returns the index of the first occurrence of `target` in `array`. If the `target` is not found, return -1. Constraints * All elements of the array and the target can be positive or negative integers. * There are no restrictions on the order of the elements in the array. Example ```python array = [4, 2, 5, 1, 5, 9] target = 5 find_first_occurrence(array, target) -> Returns 2 ``` ```python array = [3, 3, 3, 3] target = 3 find_first_occurrence(array, target) -> Returns 0 ``` ```python array = [10, 12, 14, 16] target = 15 find_first_occurrence(array, target) -> Returns -1 ``` Implement the function considering performance and edge cases.","solution":"from typing import List def find_first_occurrence(array: List[int], target: int) -> int: Finds the first occurrence index of the target in the array using a Linear Search Algorithm. Returns -1 if the target does not exist in the array. for index, value in enumerate(array): if value == target: return index return -1"},{"question":"# Question: Efficient Modular Exponentiation You are tasked with implementing an **Efficient Modular Exponentiation** function. This function will take three integers: `base`, `exponent`, and `mod`, and will compute the result of ((text{base}^text{exponent}) mod text{mod}). Given the constraints: - (1 leq text{base}, text{mod} leq 10^9) - (0 leq text{exponent} leq 10^9) Implement a function `efficient_mod_exp(base, exponent, mod)` that correctly calculates the result. Function Signature ```python def efficient_mod_exp(base: int, exponent: int, mod: int) -> int: pass ``` Input - `base`: An integer representing the base. - `exponent`: An integer representing the exponent (non-negative). - `mod`: An integer representing the modulus. Output - An integer that is the result of ((text{base}^text{exponent}) mod text{mod}). Constraints - (1 leq text{base}, text{mod} leq 10^9) - (0 leq text{exponent} leq 10^9) Example ```python assert efficient_mod_exp(2, 10, 1000) == 24 assert efficient_mod_exp(5, 3, 13) == 8 assert efficient_mod_exp(7, 0, 997) == 1 ``` **Explanation**: 1. **First Example**: ((2^{10}) % 1000 = 1024 % 1000 = 24) 2. **Second Example**: ((5^3) % 13 = 125 % 13 = 8) 3. **Third Example**: Any number to the power of 0 is 1, and (1 % 997 = 1) Ensure the function efficiently handles very large values of `base` and `exponent` within the tight performance constraints.","solution":"def efficient_mod_exp(base: int, exponent: int, mod: int) -> int: Computes (base^exponent) % mod using an efficient algorithm. result = 1 base = base % mod # Take mod of base first to make computations smaller while exponent > 0: # If exponent is odd, multiply base with result if (exponent % 2) == 1: result = (result * base) % mod # Do exponent = exponent // 2 exponent = exponent >> 1 # Change base to base^2 base = (base * base) % mod return result"},{"question":"# Binary Search Implementation in a Multi-Dimensional Array **Scenario**: You have a two-dimensional grid (a list of lists in Python) where each row is sorted in ascending order from left to right, and each column is sorted in ascending order from top to bottom. Write a function to search a given value in this grid. The function should return a tuple of indices (i, j) representing the row and column where the element is found or (-1, -1) if the element is not present. # Function Signature ```python def search_2d_matrix(matrix: List[List[int]], target: int) -> Tuple[int, int]: pass ``` # Input * `matrix`: A list of lists of integers representing a 2D grid where each row and each column is sorted in ascending order. * `target`: An integer value to be searched in the grid. # Output * Returns a tuple of two integers representing the row and column index of the target in the matrix. * If the target is not found, return (-1, -1). # Constraints * The number of rows `n` and the number of columns `m` in the matrix is between `1` and `1000`. * The value of each element in the matrix is between `-10^9` and `10^9`. * The function must run with time complexity of O(n + m). # Example ```python matrix = [ [1, 4, 7, 11, 15], [2, 5, 8, 12, 19], [3, 6, 9, 16, 22], [10, 13, 14, 17, 24], [18, 21, 23, 26, 30] ] target = 5 assert search_2d_matrix(matrix, target) == (1, 1) target = 20 assert search_2d_matrix(matrix, target) == (-1, -1) ```","solution":"from typing import List, Tuple def search_2d_matrix(matrix: List[List[int]], target: int) -> Tuple[int, int]: if not matrix or not matrix[0]: return (-1, -1) row = 0 col = len(matrix[0]) - 1 while row < len(matrix) and col >= 0: if matrix[row][col] == target: return (row, col) elif matrix[row][col] > target: col -= 1 else: row += 1 return (-1, -1)"},{"question":"# Problem Description A special number is defined as an integer where the sum of its digits raised to their consecutive powers equals the number itself. For instance, 89 is a special number because (8^1 + 9^2 = 89), and 135 is also a special number because (1^1 + 3^2 + 5^3 = 135). Write a function `sum_dig_pow(low, high)` that finds and returns a list of all special numbers within a given range `[low, high]`, inclusive. # Input * `low (int)`: The lower bound of the range (1 ≤ low ≤ high ≤ 10^6). * `high (int)`: The upper bound of the range. # Output * List of integers, all the special numbers within the specified range `[low, high]`. # Constraints 1. The range can be from 1 to 10^6. 2. Your solution should be optimized to handle large ranges efficiently. # Example ```python assert sum_dig_pow(1, 10) == [1, 2, 3, 4, 5, 6, 7, 8, 9] assert sum_dig_pow(1, 100) == [1, 2, 3, 4, 5, 6, 7, 8, 9, 89] assert sum_dig_pow(90, 150) == [135] assert sum_dig_pow(10, 1000) == [89, 135] ``` # Performance Note Your solution should logically iteratively compute within the given range and check each number against the special number property while minimizing unnecessary computations and memory usage. # Implementation Details * The function should convert each number to a string to access the digits in sequence. * Raise each digit to the power of their one-based positional index and sum these values. * Check if the computed sum is equal to the original number, and if so, add it to the result list.","solution":"def sum_dig_pow(low, high): Finds and returns a list of all special numbers within the range [low, high]. def is_special_number(num): # Convert number to string to access digits by index digits = str(num) sum_powers = sum(int(digit) ** (index + 1) for index, digit in enumerate(digits)) return sum_powers == num result = [] for number in range(low, high + 1): if is_special_number(number): result.append(number) return result"},{"question":"**Objective**: Write a function to convert a Roman numeral to an integer. **Function Specification**: * **Function Name**: `roman_to_int` * **Input**: A single string `s` representing a Roman numeral. * **Output**: An integer that represents the converted value of the Roman numeral. Roman numerals are represented by seven different symbols: * `I` (1), `V` (5), `X` (10), `L` (50), `C` (100), `D` (500), and `M` (1000). Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not `IIII`. Instead, the number four is written as `IV`. Following are the special cases: * `I` can be placed before `V` (5) and `X` (10) to make 4 and 9. * `X` can be placed before `L` (50) and `C` (100) to make 40 and 90. * `C` can be placed before `D` (500) and `M` (1000) to make 400 and 900. **Constraints**: * The input string is guaranteed to be a valid Roman numeral from 1 to 3999. **Performance Requirement**: * The algorithm should run in O(n) time complexity, where n is the length of the input string. * The space complexity should be O(1). **Example**: ```python assert roman_to_int(\\"III\\") == 3 assert roman_to_int(\\"IV\\") == 4 assert roman_to_int(\\"IX\\") == 9 assert roman_to_int(\\"LVIII\\") == 58 assert roman_to_int(\\"MCMXCIV\\") == 1994 ``` **Instructions**: * Define the Roman numeral mappings inside the function. * Iterate through the string once and perform the conversion as outlined in the analysis. * Ensure to handle both additive and subtractive notations correctly. * Return the final computed integer value.","solution":"def roman_to_int(s): Converts a Roman numeral to an integer. Parameters: s (str): A string representing a Roman numeral. Returns: int: The integer value corresponding to the Roman numeral. roman_values = { \'I\': 1, \'V\': 5, \'X\': 10, \'L\': 50, \'C\': 100, \'D\': 500, \'M\': 1000 } total = 0 prev_value = 0 for char in s: value = roman_values[char] if value > prev_value: total += value - 2 * prev_value else: total += value prev_value = value return total"},{"question":"# ZigZag Iterator for Multiple Lists Design a class `ZigZagIteratorK` that takes `k` lists as input and iterates over their elements in a zigzag manner. Write the `__init__`, `next`, and `has_next` methods. The `__init__` method initializes the data structure with the given lists. The `next` method should return the next element following the zigzag pattern, and the `has_next` method should return `true` if there are any remaining elements, and `false` otherwise. Constraints: * Each list contains zero or more integers. * Lists can be of different lengths. * You cannot assume the lists are non-empty. # Function Signature ```python class ZigZagIteratorK: def __init__(self, lists: List[List[int]]): Initialize your data structure here. :type lists: List[List[int]] pass def next(self) -> int: :rtype: int pass def has_next(self) -> bool: :rtype: bool pass # Example: # Input: lists = [[1, 2], [3, 4, 5, 6], [7, 8, 9]] # Iteration sequence: [1, 3, 7, 2, 4, 8, 5, 9, 6] lists = [[1, 2], [3, 4, 5, 6], [7, 8, 9]] it = ZigZagIteratorK(lists) result = [] while it.has_next(): result.append(it.next()) print(result) # Output should be [1, 3, 7, 2, 4, 8, 5, 9, 6] ``` Implementation Guide: 1. **Initialization**: Create a queue that includes references to the input lists. 2. **Next**: Pop the first list from the queue and pop its first element to return. If the list is not empty after popping the element, append it back to the end of the queue. 3. **Has Next**: Return `True` if there are any lists in the queue, `False` otherwise. **Note**: Handle edge cases where input lists may be empty or have varying lengths.","solution":"from collections import deque from typing import List class ZigZagIteratorK: def __init__(self, lists: List[List[int]]): Initialize your data structure here with a list of lists. self.queue = deque((lst, 0) for lst in lists if lst) def next(self) -> int: :rtype: int lst, idx = self.queue.popleft() next_value = lst[idx] if idx + 1 < len(lst): self.queue.append((lst, idx + 1)) return next_value def has_next(self) -> bool: :rtype: bool return bool(self.queue)"},{"question":"You are provided with a method to efficiently represent very large sparse vectors and to compute their dot product. You need to implement an enhanced version of these functions according to the guidelines. # Task 1. **Convert Sparse Vector**: Design a function `convert_sparse_vector` that takes a sparse vector (list of floats) and returns a dictionary where the keys are the indices of the non-zero elements and values are the respective non-zero elements. - Input: A list `vector` of length `n` containing floats. - Output: A dictionary representing the sparse vector. 2. **Dot Product Calculation**: Design a function `sparse_dot_product` that takes two sparse vector dictionaries and returns their dot product. - Input: Two dictionaries `vector1` and `vector2`. - Output: A float representing the dot product of the two vectors. # Constraints - The vectors may contain up to (10^6) elements. - The number of non-zero elements is significantly less. # Example ```python def convert_sparse_vector(vector): # Implement this function pass def sparse_dot_product(vector1, vector2): # Implement this function pass # Example vector = [1.0, 0.0, 3.0, 4.0] sparse_vector = convert_sparse_vector(vector) # Expected Output: {0: 1.0, 2: 3.0, 3: 4.0} vector1 = {0: 1.0, 2: 3.0, 3: 4.0} vector2 = {1: 2.0, 2: 1.0, 3: 1.0} result = sparse_dot_product(vector1, vector2) # Expected Output: 7.0 (since 3.0 * 1.0 + 4.0 * 1.0 = 7.0) ``` # Notes - Provide optimized and readable code. - Handle edge cases like empty vectors and vectors without common non-zero indices.","solution":"def convert_sparse_vector(vector): Converts a dense vector to a sparse vector represented as a dictionary. Keys are indices of non-zero elements and values are the corresponding non-zero values. return {i: value for i, value in enumerate(vector) if value != 0} def sparse_dot_product(vector1, vector2): Calculates the dot product of two sparse vectors represented as dictionaries. # Ensure we iterate over the smaller dictionary for efficiency. if len(vector1) > len(vector2): vector1, vector2 = vector2, vector1 dot_product = sum(value * vector2.get(index, 0) for index, value in vector1.items()) return dot_product"},{"question":"# Wiggle Sort Algorithm Question Context You have been provided with an array of integers. Your task is to rearrange the elements of this array such that they alternate between a lower and higher value compared to their neighbors. Specifically, the arrangement should follow the pattern `nums[0] < nums[1] > nums[2] < nums[3] > ...`. Requirements Write a function `wiggle_sort(nums: List[int]) -> None` in Python that modifies the given list in-place to satisfy the above conditions. # Input * A single list of integers, `nums`. # Output * The function does not return anything. It modifies the list in-place. # Constraints * The list can have any integer values (both positive and negative). * The length of the list, `n`, is in the range `[0, 10^6]`. # Example ```python Input: nums = [3, 5, 2, 1, 6, 4] Output: nums should be modified in-place to any valid wiggle sort order, such as [3, 5, 1, 6, 2, 4] or [1, 6, 2, 5, 3, 4]. ``` # Function Signature ```python def wiggle_sort(nums: List[int]) -> None: # Your implementation here ``` # Notes * Your solution should aim to meet or improve upon the reference implementation\'s time and space complexity. * Consider edge cases such as an empty list or a list with only one element.","solution":"from typing import List def wiggle_sort(nums: List[int]) -> None: Rearranges the elements of the array such that they alternate between lower and higher values compared to their neighbors. The array is modified in-place. for i in range(len(nums)): if i % 2 == 0: if i > 0 and nums[i] > nums[i - 1]: nums[i], nums[i - 1] = nums[i - 1], nums[i] else: if nums[i] < nums[i - 1]: nums[i], nums[i - 1] = nums[i - 1], nums[i]"},{"question":"# Question **Context**: You are working on a configuration tool that should ensure that all file paths provided by the user are absolute paths. This tool needs to handle paths that might be relative and expand user home directories denoted by `~`. **Task**: Write a function `full_path` that takes a single string argument representing a file path and returns the absolute path. Your function must handle cases where the file path is relative or includes a `~` to indicate the home directory. **Function Signature**: ```python def full_path(file: str) -> str: ``` **Input**: * `file` (str): A file path that may be relative or include a `~`. **Output**: * Returns a string representing the absolute path of the given file. **Constraints**: * The input string will be non-empty. * The input string will represent a valid path format (relative, absolute, or user-relative). **Examples**: ```python assert full_path(\\"~/documents/file.txt\\") == \\"/home/user/documents/file.txt\\" assert full_path(\\"project/src/\\") == \\"/current/working/directory/project/src/\\" assert full_path(\\"/etc/hosts\\") == \\"/etc/hosts\\" ``` **Notes**: * Assume the current working directory is `/current/working/directory/`. * Assume the user\'s home directory is `/home/user/`.","solution":"import os def full_path(file: str) -> str: Returns the absolute path of the given file. It handles relative paths, user home directory indicated by \'~\', and already absolute paths. # Expanding user relative paths denoted by `~` expanded_path = os.path.expanduser(file) # Getting absolute path absolute_path = os.path.abspath(expanded_path) return absolute_path"},{"question":"**Context:** You are tasked with developing a text search feature for a large-scale document analysis tool. To efficiently find specific patterns within vast amounts of text data, you need to implement a highly efficient pattern matching algorithm. Your objective is to use the Knuth-Morris-Pratt (KMP) algorithm to solve this problem. **Problem Statement:** Write a function `knuth_morris_pratt(text: str, pattern: str) -> List[int]` that takes in two strings, `text` and `pattern`, and returns a list of starting indices where `pattern` is found within `text`. Use the Knuth-Morris-Pratt (KMP) algorithm to achieve this efficiently. **Function Signature:** ```python from typing import List def knuth_morris_pratt(text: str, pattern: str) -> List[int]: pass ``` **Input Format:** * `text`: A string representing the text to search within (1 <= len(text) <= 10^6). * `pattern`: A string representing the pattern to search for (1 <= len(pattern) <= 10^5). **Output Format:** * Return a list of integers, each representing a starting index of the pattern found within the text. **Constraints:** * Both `text` and `pattern` consist of lowercase and uppercase English letters and/or digits. * If the pattern is not found in the text, return an empty list. **Example:** ```python assert knuth_morris_pratt(\\"abracadabra\\", \\"abra\\") == [0, 7] assert knuth_morris_pratt(\\"hello there hero!\\", \\"he\\") == [0, 7, 12] assert knuth_morris_pratt(\\"aabbaabbaabbaabba\\", \\"aabba\\") == [0, 4, 8, 12] assert knuth_morris_pratt(\\"abc\\", \\"d\\") == [] ``` **Explanation:** 1. In the first example, the pattern \\"abra\\" is found at indices 0 and 7. 2. In the second example, the pattern \\"he\\" is found at indices 0, 7, and 12. 3. In the third example, the pattern \\"aabba\\" is found at indices 0, 4, 8, and 12. 4. In the fourth example, the pattern \\"d\\" is not found in the text \\"abc\\", so an empty list is returned. Your task is to implement `knuth_morris_pratt` function using the KMP algorithm detailed above.","solution":"from typing import List def knuth_morris_pratt(text: str, pattern: str) -> List[int]: # Helper function to construct the partial match table (LPS - longest prefix suffix) def compute_lps(pattern: str) -> List[int]: lps = [0] * len(pattern) length = 0 i = 1 while i < len(pattern): if pattern[i] == pattern[length]: length += 1 lps[i] = length i += 1 else: if length != 0: length = lps[length - 1] else: lps[i] = 0 i += 1 return lps if not pattern or not text: return [] lps = compute_lps(pattern) indices = [] i = 0 # index for text j = 0 # index for pattern while i < len(text): if pattern[j] == text[i]: i += 1 j += 1 if j == len(pattern): indices.append(i - j) j = lps[j - 1] elif i < len(text) and pattern[j] != text[i]: if j != 0: j = lps[j - 1] else: i += 1 return indices"},{"question":"# Question: Implement a Doubly Linked List Context: A Doubly Linked List is a variation of Linked List in which navigation is possible in both directions, forward and backward. Each node contains two pointers, `next` and `prev`, which point to the next and previous node respectively. Task: Implement a `DoublyLinkedList` class that supports the following operations: 1. `insert_at_head(value)`: Insert a new node with the given value at the beginning of the list. 2. `insert_at_tail(value)`: Insert a new node with the given value at the end of the list. 3. `delete(value)`: Remove the first occurrence of the node with the given value. 4. `display_forward()`: Return a list of values representing the linked list when traversed from head to tail. 5. `display_backward()`: Return a list of values representing the linked list when traversed from tail to head. Constraints: * Each of these operations should be implemented in O(1) time for insertions and deletions if the node reference is known. * Assume no duplicate values will be inserted. * The `delete` operation should perform in O(n) time in the worst case. Input: - `insert_at_head(value)`, `insert_at_tail(value)`, or `delete(value)` will have a single integer input value. - `display_forward()`, and `display_backward()` will have no input but will return a list. Output: - For `display_forward()`, and `display_backward()`, return a list of integers. Edge Cases: - Handle operations on an empty list. - Properly update pointers after insertions and deletions.","solution":"class Node: def __init__(self, value): self.value = value # Node value self.next = None # Pointer to next node self.prev = None # Pointer to previous node class DoublyLinkedList: def __init__(self): self.head = None # Head of the list self.tail = None # Tail of the list def insert_at_head(self, value): new_node = Node(value) if self.head is None: # If list is empty self.head = self.tail = new_node else: new_node.next = self.head self.head.prev = new_node self.head = new_node def insert_at_tail(self, value): new_node = Node(value) if self.tail is None: # If list is empty self.head = self.tail = new_node else: new_node.prev = self.tail self.tail.next = new_node self.tail = new_node def delete(self, value): current = self.head while current is not None: if current.value == value: if current.prev is not None: current.prev.next = current.next else: # If it\'s the head node self.head = current.next if current.next is not None: current.next.prev = current.prev else: # If it\'s the tail node self.tail = current.prev return current = current.next def display_forward(self): result = [] current = self.head while current is not None: result.append(current.value) current = current.next return result def display_backward(self): result = [] current = self.tail while current is not None: result.append(current.value) current = current.prev return result"},{"question":"# FizzBuzz Coding Challenge **Problem Statement**: You are given a positive integer `n`. Your task is to write a function `fizzbuzz(n)` that returns an array containing the numbers from 1 to `n`. Replace certain values in the array according to the following conditions: - If the number is a multiple of 3, use the value \'Fizz\' instead. - If the number is a multiple of 5, use the value \'Buzz\' instead. - If the number is a multiple of both 3 and 5, use the value \'FizzBuzz\' instead. **Function Signature**: ```python def fizzbuzz(n: int) -> List[Union[int, str]]: # Your code here pass ``` **Input**: - `n` (int): A positive integer (1 ≤ n ≤ 10,000). **Output**: - List of integers and strings, where each index follows the stated replacement rules. **Example**: ```python assert fizzbuzz(5) == [1, 2, \'Fizz\', 4, \'Buzz\'] assert fizzbuzz(15) == [1, 2, \'Fizz\', 4, \'Buzz\', \'Fizz\', 7, 8, \'Fizz\', \'Buzz\', 11, \'Fizz\', 13, 14, \'FizzBuzz\'] ``` **Constraints**: - You should handle incorrect inputs by raising appropriate exceptions: - Raise `ValueError` if `n` is less than 1. - Raise `TypeError` if `n` is not an integer.","solution":"from typing import List, Union def fizzbuzz(n: int) -> List[Union[int, str]]: if not isinstance(n, int): raise TypeError(\\"Input must be an integer\\") if n < 1: raise ValueError(\\"Input must be a positive integer\\") result = [] for i in range(1, n + 1): if i % 3 == 0 and i % 5 == 0: result.append(\'FizzBuzz\') elif i % 3 == 0: result.append(\'Fizz\') elif i % 5 == 0: result.append(\'Buzz\') else: result.append(i) return result"},{"question":"# Coding Task: Simplify Unix-Style Path **Scenario**: You are working on a file manager application and need to implement a function that simplifies Unix-style file paths. Given a string representing an absolute Unix-like file path, the function should simplify the path according to the following rules: 1. A single dot (`.`) stays in the current directory (do nothing). 2. A double dot (`..`) moves up one directory (popping the last directory from the path). 3. Consecutive slashes are treated as a single slash. **Function Signature**: ```python def simplify_path(path: str) -> str: Simplifies the given Unix-style path and returns the canonical form. :param path: str - A string representing the absolute path. :return: str - A simplified canonical path. ``` **Input**: * `path` (STR): A string representing an absolute path. The path is Unix-style and consists of English letters, digits, periods, slashes, and underscores. **Output**: * (STR): A simplified canonical path that properly resolves relative path movements and removes redundant slashes. **Constraints**: * The input path is always an absolute Unix-style path that starts with a slash (\'/\'). * The returned path should also start with a slash (\'/\') and not contain any trailing slashes unless the path is the root directory (`/`). **Performance Requirements**: * The solution should handle paths up to length 3000 efficiently within O(n) time complexity. **Example Cases**: 1. `simplify_path(\\"/home/\\")` -> `\\"/home\\"` 2. `simplify_path(\\"/a/./b/../../c/\\")` -> `\\"/c\\"` 3. `simplify_path(\\"/../\\")` -> `\\"/\\"` 4. `simplify_path(\\"/home//foo/\\")` -> `\\"/home/foo\\"` Make sure to test your implementation with additional edge cases and document any assumptions in your code comments.","solution":"def simplify_path(path: str) -> str: Simplifies the given Unix-style path and returns the canonical form. :param path: str - A string representing the absolute path. :return: str - A simplified canonical path. # Split the input path by \'/\' to get the components components = path.split(\'/\') stack = [] for component in components: if component == \'\' or component == \'.\': # Ignore empty components and single dot components continue elif component == \'..\': # Pop from the stack if there\'s a directory to go back to if stack: stack.pop() else: # Normal directory name, push onto the stack stack.append(component) # Join the stack with \'/\' to form the simplified canonical path return \'/\' + \'/\'.join(stack)"},{"question":"# Priority Queue Analysis and Implementation Task You are required to analyze and reimplement a priority queue using a more efficient data structure to improve insertion complexity. The provided code represents a priority queue using a linear array. The `push` operation has an O(n) time complexity due to the need to keep the array sorted by priority. Your task is to: 1. Analyze the given priority queue implementation. 2. Implement a new priority queue using a binary heap to improve the insertion complexity to O(log n). 3. Ensure your implementation supports the following methods: - `size()`: Returns the number of elements in the priority queue. - `push(item, priority)`: Inserts the item with the specified priority into the queue. - `pop()`: Removes and returns the element with the lowest priority. # Input Format - Multiple lines of operations which can be either: - `push <item> <priority>`: Use this operation to add an item to the queue with a specified priority. - `pop`: Use this operation to remove and return the item with the lowest priority from the queue. - `size`: Use this operation to return the size of the priority queue. # Output Format - For `pop` operations, output the item with the lowest priority. - For `size` operations, output the current size of the queue. # Constraints - Ensure that `push` operations maintain an insertion complexity of O(log n) using a binary heap. - The priority values are integers and can be positive or negative. - Item values can be strings. # Example Input: ``` push apple 5 push banana 3 push cherry 8 size pop pop size ``` Output: ``` 3 banana apple 1 ``` # Notes - Reimplement the priority queue in a single class named `HeapPriorityQueue`. - Handle edge cases such as popping from an empty queue gracefully by raising an exception or returning `None`. Your solution will be evaluated based on correctness, efficiency, and code readability.","solution":"import heapq class HeapPriorityQueue: def __init__(self): self.heap = [] def size(self): return len(self.heap) def push(self, item, priority): heapq.heappush(self.heap, (priority, item)) def pop(self): if self.size() == 0: raise IndexError(\\"pop from an empty priority queue\\") return heapq.heappop(self.heap)[1]"},{"question":"You are given a DirectedGraph class to model a graph using nodes and edges. Expand the functionality by implementing a method to find all nodes reachable from a given starting node using Depth-First Search (DFS). # Requirements: Function Template: ```python class DirectedGraph: # (Existing code as given in the snippets above) def find_reachable_nodes(self, start_node_name): Find all nodes reachable from the start node using DFS. Args: start_node_name (str): The name of the starting node. Returns: List[str]: List of names of reachable nodes. ``` Input: - The name of the start node as a string. Output: - List of strings representing the names of all nodes reachable from the starting node (including the start node itself). Constraints: - Assume the graph is initialized and populated correctly. - The start node is guaranteed to exist in the graph. - Nodes can have any string identifier. # Example: Given the following graph structure: - A -> B - A -> C - B -> D - D -> E - C -> F Initialization: ```python graph_data = { \'A\': [\'B\', \'C\'], \'B\': [\'D\'], \'D\': [\'E\'], \'C\': [\'F\'] } graph = DirectedGraph(graph_data) ``` Calling Method: ```python print(graph.find_reachable_nodes(\'A\')) ``` Expected Output: ```python [\'A\', \'B\', \'D\', \'E\', \'C\', \'F\'] ``` The order of nodes in the output list can vary based on DFS traversal initiation. # Notes: - Implement the DFS traversal recursively or using a stack. - Ensure nodes are visited only once.","solution":"class DirectedGraph: def __init__(self, graph_data): self.graph_data = graph_data def find_reachable_nodes(self, start_node_name): Find all nodes reachable from the start node using DFS. Args: start_node_name (str): The name of the starting node. Returns: List[str]: List of names of reachable nodes. reachable_nodes = [] visited = set() def dfs(node): if node not in visited: visited.add(node) reachable_nodes.append(node) for neighbor in self.graph_data.get(node, []): dfs(neighbor) dfs(start_node_name) return reachable_nodes"},{"question":"# Minimum Spanning Tree with Kruskal\'s Algorithm Context Suppose you are designing a large computer network. The network has several computers (vertices) and possible direct connections between pairs of computers (edges), each with a different installation cost (weight). To minimize the overall cost of the network, you need to find a way to connect all computers such that the total installation cost is minimized. Task Write a Python function `get_mst_weight` that uses Kruskal\'s algorithm to compute the total weight of the Minimum Spanning Tree given the number of computers and the list of possible connections. Input * An integer `n` representing the number of computers. * A list of tuples `edges` where each tuple contains three integers `(u, v, weight)` representing a possible direct connection between computer `u` and computer `v` with an installation cost of `weight`. Output * An integer representing the total weight of the Minimum Spanning Tree. Constraints * (1 leq n leq 10^4) * (1 leq text{len}(edges) leq 5 times 10^4) * (1 leq text{weight} leq 10^5) * The input graph is connected. Example ```python def get_mst_weight(n, edges): # Your implementation here # Example usage: n = 5 edges = [ (0, 1, 3), (0, 2, 8), (1, 3, 5), (2, 3, 2), (2, 4, 4), (3, 4, 6) ] print(get_mst_weight(n, edges)) # Output: 14 ``` Instructions 1. Implement the `get_mst_weight` function using Kruskal’s algorithm. 2. Ensure to use an efficient union-find data structure to manage the merging and finding of components. 3. Sort the edges by weight and construct the MST by adding edges that connect different components. 4. Consider edge cases and optimize your code for efficiency.","solution":"def get_mst_weight(n, edges): Function to compute the total weight of the Minimum Spanning Tree using Kruskal\'s algorithm. :param n: int: the number of computers (vertices) :param edges: List[Tuples[int, int, int]]: list of possible connections (edges) with weights :return: int: total weight of the Minimum Spanning Tree # Helper function for finding the root of a subset def find(parent, i): if parent[i] == i: return i return find(parent, parent[i]) # Helper function for performing union of two subsets def union(parent, rank, x, y): root_x = find(parent, x) root_y = find(parent, y) if root_x != root_y: # Attach smaller rank tree under the root of the higher rank tree if rank[root_x] < rank[root_y]: parent[root_x] = root_y elif rank[root_x] > rank[root_y]: parent[root_y] = root_x else: parent[root_y] = root_x rank[root_x] += 1 # Sort edges based on their weight edges.sort(key=lambda item: item[2]) # Initialize parent and rank arrays for union-find parent = list(range(n)) rank = [0] * n mst_weight = 0 edge_count = 0 # Iterate through sorted edges and apply Kruskal\'s algorithm for u, v, weight in edges: root_u = find(parent, u) root_v = find(parent, v) # If u and v are in different subsets, include this edge in MST if root_u != root_v: mst_weight += weight union(parent, rank, root_u, root_v) edge_count += 1 # If we have n-1 edges in the MST, we can stop if edge_count == n - 1: break return mst_weight"},{"question":"You are tasked with writing a function to calculate the square root of a given positive number `N` using an iterative method. The function should take two arguments: the number `N` and a precision factor `P`. The function should ensure that the difference between the calculated square root and the true square root is less than `P`. Your function should be efficient in terms of time and space complexity and should handle various edge cases. Below is the function signature you need to implement: ```python def square_root(n, epsilon): Calculate the square root of a positive number n with a precision factor epsilon. Parameters: n (float): The number to find the square root of. Must be a positive number. epsilon (float): The precision factor. Must be a small positive number. Returns: float: The calculated square root of n. # Your code here ``` # Input Format * A positive float `n` representing the number to find the square root of. (`0 < n`). * A positive float `epsilon` representing the desired precision. (`0 < epsilon < 1`). # Output Format * A float representing the calculated square root of `n`, such that the absolute difference between the calculated value and the real square root of `n` is less than `epsilon`. # Constraints * Your solution should have a time complexity of O(log(n/epsilon)). * Your solution should have a space complexity of O(1). # Example ```python assert square_root(5, 0.001) - 2.236 < 0.001, f\\"Failed for 5\\" assert square_root(16, 0.0001) - 4 < 0.0001, f\\"Failed for 16\\" assert abs(square_root(0.25, 0.00001) - 0.5) < 0.00001, f\\"Failed for 0.25\\" assert abs(square_root(2, 0.0001) - 1.4142) < 0.0001, f\\"Failed for 2\\" ``` # Notes * Ensure that your function handles edge cases like `n = 1`, `n = 0.25`, and very small values of `epsilon`. * Optimize the function for both accuracy and performance. * Pay close attention to floating point precision issues as they can affect the convergence of the method.","solution":"def square_root(n, epsilon): Calculate the square root of a positive number n with a precision factor epsilon. Parameters: n (float): The number to find the square root of. Must be a positive number. epsilon (float): The precision factor. Must be a small positive number. Returns: float: The calculated square root of n. if n < 0: raise ValueError(\\"The number must be a positive float\\") guess = n / 2.0 while True: next_guess = (guess + n / guess) / 2 if abs(guess - next_guess) < epsilon: return next_guess guess = next_guess"},{"question":"# Maximum Subarray Sum Problem Problem Statement You are given an array of integers, both positive and negative. Your task is to write a function `max_subarray` that returns the sum of the contiguous subarray within a given one-dimensional array of numbers that has the largest sum. Function Signature ```python def max_subarray(array: List[int]) -> int: pass ``` Input - An array called `array` which contains integers (both positive and negative). - Constraints: 1 ≤ len(array) ≤ 10^5; -10^4 ≤ array[i] ≤ 10^4. Output - An integer representing the maximum sum of a contiguous subarray. Example ```python # Example 1: array = [1, 2, -3, 4, 5, -7, 23] print(max_subarray(array)) # Output: 25 # Explanation: The subarray [4, 5, -7, 23] has the maximum sum of 25. # Example 2: array = [-2, 1, -3, 4, -1, 2, 1, -5, 4] print(max_subarray(array)) # Output: 6 # Explanation: The subarray [4, -1, 2, 1] has the maximum sum of 6. # Example 3: array = [-1, -2, -3, -4] print(max_subarray(array)) # Output: -1 # Explanation: The subarray [-1] has the maximum sum of -1. ``` Notes - Ensure your solution runs efficiently for large inputs within the constraints. - Consider edge cases such as single-element arrays or arrays with all negative numbers in your implementation.","solution":"from typing import List def max_subarray(array: List[int]) -> int: Finds the maximum sum of a contiguous subarray. if not array: return 0 max_current = max_global = array[0] for num in array[1:]: max_current = max(num, max_current + num) if max_current > max_global: max_global = max_current return max_global"},{"question":"# 1-Sparse Recovery Problem Scenario You are an engineer working with data streams that consist of tuples, each storing a number and a sign (+ or -). Your task is to process these streams to determine the unique number that remains when all pairs of cancelling elements are removed. The input stream is considered 1-sparse if, after cancellation, exactly one unique number remains. Task Write a function `is_1_sparse(stream)` that takes in a list of tuples where each tuple contains a non-negative integer and a sign (`\'+\'` or `\'-\'`). The function should return the unique number if the stream is 1-sparse; otherwise, it should return `None`. Expected Input and Output * **Input Format**: A list of tuples `[(int, char)]`, where each tuple contains a non-negative integer and a sign (`\'+\'` or `\'-\'`). * **Output Format**: The unique integer if the stream is 1-sparse; `None` otherwise. Constraints * The integers in the tuple are non-negative and fit within 32 bits. * Only valid signs `\'+\'` and `\'-\'` are allowed. Example ```python # Example 1 input_stream = [(4, \'+\'), (2, \'+\'), (2, \'-\'), (4, \'+\'), (3, \'+\'), (3, \'-\')] print(is_1_sparse(input_stream)) # Output: 4 # Example 2 input_stream = [(2, \'+\'), (2, \'+\'), (2, \'+\'), (2, \'+\'), (2, \'+\'), (2, \'+\'), (2, \'+\')] print(is_1_sparse(input_stream)) # Output: 2 # Example 3 input_stream = [(2, \'+\'), (2, \'+\'), (2, \'+\'), (2, \'+\'), (2, \'+\'), (2, \'+\'), (1, \'+\')] print(is_1_sparse(input_stream)) # Output: None ``` Implementation Details: - Maintain a sum of values adjusted by their signs. - Use a bit-array to sum bit-level representations and ensure all bits are either zero or equal to the sum of signs. - Verify that the sum of values divided by the absolute sum of signs provides a unique number.","solution":"def is_1_sparse(stream): Determines if the stream is 1-sparse and returns the unique number if it is. Otherwise, returns None. num_count = {} for number, sign in stream: if sign == \'+\': num_count[number] = num_count.get(number, 0) + 1 elif sign == \'-\': num_count[number] = num_count.get(number, 0) - 1 if num_count[number] == 0: del num_count[number] if len(num_count) == 1: return next(iter(num_count.keys())) else: return None"},{"question":"You are given an integer array `freq` of size `n`. Implement a Fenwick Tree (Binary Indexed Tree) to support the following two operations efficiently: 1. `sum(i)`: Returns the sum of the first `i` elements of the array. 2. `update(i, x)`: Updates the value of the `i-th` element of the array to `x`. **Input**: - The first line contains an integer `n` denoting the size of the array. - The second line contains `n` space-separated integers representing the initial array `freq`. **Queries**: - The next line contains an integer `q` denoting the number of queries. - The following `q` lines contain either: * `\\"sum i\\"`: A query to return the sum of the first `i` elements. * `\\"update i x\\"`: A query to update the `i-th` element to `x`. **Output**: - For each `\\"sum i\\"` query, print the sum of the first `i` elements of the array. **Constraints**: - 1 ≤ n ≤ 10^5 - 1 ≤ q ≤ 10^5 - 0 ≤ i < n - -10^9 ≤ x ≤ 10^9 **Example**: ``` Input: 5 1 2 3 4 5 3 sum 2 update 1 10 sum 2 Output: 6 14 ``` **Hints**: - Use bitwise operations to manage the updates and queries efficiently. - Maintain a BIT array (of size `n+1`) to store the cumulative frequency information.","solution":"class FenwickTree: def __init__(self, freq): self.n = len(freq) self.tree = [0] * (self.n + 1) self.arr = [0] * self.n for i, val in enumerate(freq): self.update(i, val) def sum(self, i): i += 1 s = 0 while i > 0: s += self.tree[i] i -= i & -i return s def update(self, i, x): delta = x - self.arr[i] self.arr[i] = x i += 1 while i <= self.n: self.tree[i] += delta i += i & -i def process_queries(n, freq, queries): fenwick_tree = FenwickTree(freq) result = [] for query in queries: if query[0] == \\"sum\\": i = int(query[1]) result.append(fenwick_tree.sum(i)) elif query[0] == \\"update\\": i, x = int(query[1]), int(query[2]) fenwick_tree.update(i, x) return result"},{"question":"You are given an array of integers and asked to implement an efficient sorting algorithm using a combination of Insertion Sort and Binary Search to reduce the number of comparisons while sorting. Your task is to write a function that sorts the array in ascending order. Your implementation should perform the sorting using Insertion Sort but must utilize a Binary Search approach to find the correct position for each new element to be inserted. # Function Signature ```python def binary_insertion_sort(array: List[int]) -> List[int]: ``` # Input * `array`: A list of integers, e.g., `[4, 2, 6, 1, 9]` # Output * A list of integers sorted in ascending order, e.g., `[1, 2, 4, 6, 9]` # Constraints * The input array can have up to `10^4` elements. * Each integer in the array is in the range `-10^6` to `10^6`. # Requirements 1. **Edge Cases**: Ensure your function handles edge cases like empty arrays and arrays with duplicate values. 2. **Performance**: The function should efficiently sort the array, utilizing Binary Search within the Insertion Sort to optimize the element insertion process. 3. **Correctness**: Ensure the sorted order is maintained correctly for both positive and negative integers. # Example ``` Input: [5, 2, 9, 1, 5, 6] Output: [1, 2, 5, 5, 6, 9] Input: [-3, -1, -2, -4, 0] Output: [-4, -3, -2, -1, 0] ``` # Instructions 1. Implement a helper function `search_insert(array: List[int], val: int) -> int` to find the correct position to insert an element using binary search. 2. Integrate this helper function within your `binary_insertion_sort` function. 3. Ensure your sort implementation is both correct and optimal for the given constraints.","solution":"from typing import List def search_insert(array: List[int], val: int) -> int: Helper function using binary search to find the correct position to insert val in array. left, right = 0, len(array) while left < right: mid = (left + right) // 2 if array[mid] < val: left = mid + 1 else: right = mid return left def binary_insertion_sort(array: List[int]) -> List[int]: Sorts an array using a combination of Insertion Sort and Binary Search. for i in range(1, len(array)): current_value = array[i] # Find the position to insert the current_value pos = search_insert(array[:i], current_value) # Move all elements after the position to the right array = array[:pos] + [current_value] + array[pos:i] + array[i+1:] return array"},{"question":"# Decoded String from Encoded Pattern Given an encoded string, implement the function `decode_string(s)` to return its decoded string. The encoding rule is defined such that `k[encoded_string]` means the encoded string inside the square brackets is repeated exactly `k` times. Here, `k` is guaranteed to be a positive integer. Assume that the input string is always valid, with no extra spaces and well-formed square brackets. Additionally, assume the original data does not contain any digits except those for repeat counts, meaning there won\'t be inputs like `3a` or `2[4]`. Function Signature ```python def decode_string(s: str) -> str: ``` Input * A single string `s` that represents the encoded string. Output * The decoded string after processing all encoded patterns in `s`. Constraints * The string length `s` will not exceed 30,000 characters. * The repeat numbers used in the encoding are guaranteed to be positive integers. Example * Input: `s = \\"3[a]2[bc]\\"` * Output: `\\"aaabcbc\\"` * Input: `s = \\"3[a2[c]]\\"` * Output: `\\"accaccacc\\"` * Input: `s = \\"2[abc]3[cd]ef\\"` * Output: `\\"abcabccdcdcdef\\"` Performance Requirements * Ensure the function runs efficiently with a complexity of O(n), where n is the length of the string `s`. # Testing Your Implementation Consider testing your function with a variety of encoded strings, including those with shallow and deep levels of nested patterns, different repeat counts, and combinations of alphabetic segments and nested encodings.","solution":"def decode_string(s: str) -> str: Decodes the encoded string according to the pattern k[encoded_string]. stack = [] current_string = \'\' current_num = 0 for char in s: if char.isdigit(): current_num = current_num * 10 + int(char) elif char == \'[\': stack.append((current_string, current_num)) current_string = \'\' current_num = 0 elif char == \']\': last_string, num = stack.pop() current_string = last_string + current_string * num else: current_string += char return current_string"},{"question":"# Subset Sums You are given a list of distinct integers `nums`. Your task is to write a function `subset_sums(nums)` that returns a set containing the sums of all possible subsets of the given list. Input * `nums`: List of distinct integers (1 <= len(nums) <= 20, -10^5 <= nums[i] <= 10^5) Output * A set of integers, where each integer is the sum of one subset of the input list. Example: ```python If nums = [1, 2, 3], the function should return: {0, 1, 2, 3, 4, 5, 6} Explanation: The subsets and their sums are: {} {1} {2} {3} {1, 2} {1, 3} {2, 3} {1, 2, 3} The sums are: 0, 1, 2, 3, 3, 4, 5, 6 ``` Constraints: * The function must run within the constraints provided. * The use of Python\'s built-in functions and standard libraries is permitted. * Handle both positive and negative integers effectively. Function Signature: ```python def subset_sums(nums: List[int]) -> Set[int]: # your code here ```","solution":"from itertools import chain, combinations from typing import List, Set def subset_sums(nums: List[int]) -> Set[int]: Returns a set containing the sums of all possible subsets of the given list. def all_subsets(iterable): Returns all possible subsets of the iterable, including the empty subset. s = list(iterable) return chain.from_iterable(combinations(s, r) for r in range(len(s) + 1)) result = set() for subset in all_subsets(nums): result.add(sum(subset)) return result"},{"question":"# Single Number with XOR Algorithm Given an array of integers `nums`, every element in the array appears twice except for one element which appears only once. Your task is to implement the function `single_number(nums)` that finds and returns the element that appears only once. Function Signature: ```python def single_number(nums: List[int]) -> int: ... ``` # Input: * `nums` (List[int]): A list of integers where every element appears exactly twice except for one element which appears only once. # Output: * An integer representing the single element that appears only once in the array. # Constraints: * Assume that `nums` will always have at least one element. * The array may contain both positive and negative integers. * There is exactly one element that appears only once and every other element appears twice. # Performance Requirements: * Time complexity should be O(n). * Space complexity should be O(1). # Example: ```python assert single_number([2, 2, 1]) == 1 assert single_number([4, 1, 2, 1, 2]) == 4 assert single_number([1]) == 1 ``` # Scenario or Context: Imagine you are working with a large data set of integers where a sensor normally sends duplicate readings but occasionally sends a single unique reading. Your goal is to identify this unique reading efficiently both in terms of speed and memory usage.","solution":"def single_number(nums): Returns the element that appears only once in the array \'nums\', where every other element appears exactly twice. result = 0 for num in nums: result ^= num return result"},{"question":"# Question: Calculate Maximum Depth of a Binary Tree using Iterative BFS Context You are tasked with finding the maximum depth of a binary tree. The maximum depth is defined as the number of nodes along the longest path from the root node down to the farthest leaf node. In this problem, you are required to implement the solution using an iterative Breadth-First Search (BFS) approach. Requirements * **Input**: A binary tree represented by its root node. * **Output**: An integer representing the maximum depth of the tree. Function Signature ```python def max_depth(root: TreeNode) -> int: pass ``` Constraints * The number of nodes in the binary tree will not exceed 10^4. * The tree nodes\' values are integers and can be positive, negative, or zero. Example Consider the following binary tree: ``` 10 / 12 15 / / 25 30 36 100 ``` * **Input**: Root node of the above tree. * **Output**: 4 (The longest path is from the root node 10 to the leaf node 100). Implementation Notes 1. Ensure that the function handles an empty tree by returning 0 when the root is `None`. 2. Utilize a queue to perform level order traversal iteratively. 3. Keep track of the number of levels traversed to determine the depth of the tree.","solution":"from collections import deque class TreeNode: Definition for a binary tree node. def __init__(self, x): self.val = x self.left = None self.right = None def max_depth(root: TreeNode) -> int: if not root: return 0 max_depth = 0 queue = deque([root]) while queue: max_depth += 1 level_size = len(queue) for _ in range(level_size): current_node = queue.popleft() if current_node.left: queue.append(current_node.left) if current_node.right: queue.append(current_node.right) return max_depth"},{"question":"# Scenario: You are hired to enhance the search functionality of a word processing software. The software must handle a vast dictionary of words and allow users to search for words using wildcards. You are to choose and implement an efficient data structure for this problem. # Problem Statement: Implement a versatile data structure that allows for: 1. Adding words to the structure. 2. Searching for words that match a provided pattern where the \'.\' character can represent any letter. Your data structure should support the following methods: - **add_word(word: str)**: Adds a word to the data structure. - **search(word: str) -> bool**: Returns true if the word is in the data structure or matches the pattern; otherwise, returns false. # Input and Output Formats: - **add_word(word)**: `word` is a string that consists of lowercase English letters. - **search(word)**: `word` can contain lowercase English letters and the \'.\' character. - **Output**: Boolean value indicating whether the word or pattern exists in the data structure. # Constraints: - All words contain only lowercase letters. - Word length is between 1 and 100. - Total number of words stored will not exceed 10000. # Performance Requirements: - Aim for efficient time and space complexity. - Avoid excessive memory consumption or deep recursion. # Example: ```python # Initialize your data structure word_dict = WordDictionary() # Add words word_dict.add_word(\\"bad\\") word_dict.add_word(\\"dad\\") word_dict.add_word(\\"mad\\") # Search words and patterns print(word_dict.search(\\"pad\\")) # False print(word_dict.search(\\"bad\\")) # True print(word_dict.search(\\".ad\\")) # True print(word_dict.search(\\"b..\\")) # True ```","solution":"class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False class WordDictionary: def __init__(self): self.root = TrieNode() def add_word(self, word: str) -> None: node = self.root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.is_end_of_word = True def search(self, word: str) -> bool: return self._search_in_node(word, 0, self.root) def _search_in_node(self, word: str, index: int, node: TrieNode) -> bool: if index == len(word): return node.is_end_of_word char = word[index] if char == \'.\': for child in node.children.values(): if self._search_in_node(word, index + 1, child): return True return False else: if char in node.children: return self._search_in_node(word, index + 1, node.children[char]) else: return False"},{"question":"**Context**: You work for a company that deals with various datasets and requires efficient sorting algorithms. While modern algorithms like quicksort and mergesort are generally preferred due to their better performance on large datasets, certain small or nearly-sorted datasets are still best handled by simpler algorithms like insertion sort. **Task**: Implement the `insertion_sort` function that uses the provided `search_insert` function to determine the correct insertion position. # Problem Description - **Function Signature**: ```python def insertion_sort(array: List[int]) -> List[int]: ``` - **Input Parameters**: - `array`: A list of integers to be sorted (0 ≤ len(array) ≤ 10^3). - **Output**: - Returns a new list of integers where the input array is sorted in non-decreasing order. - **Constraints**: - The input list can be empty or have one element, in which case the sorted output is the same as the input. - The input list can contain duplicate integers. # Example: ```python assert insertion_sort([3, 1, 2, 4]) == [1, 2, 3, 4] assert insertion_sort([4, 3, 2, 1]) == [1, 2, 3, 4] assert insertion_sort([]) == [] assert insertion_sort([1]) == [1] assert insertion_sort([5, 5, 5]) == [5, 5, 5] assert insertion_sort([3, -2, 1, 0]) == [-2, 0, 1, 3] ``` **Instructions**: Write the `insertion_sort` function to efficiently sort the list using the `search_insert` method for determining the right position to insert elements into the sorted section.","solution":"from typing import List def search_insert(sorted_part: List[int], value: int) -> int: This function finds the position where the \'value\' should be inserted in the \'sorted_part\' list to keep it sorted. for i in range(len(sorted_part)): if value < sorted_part[i]: return i return len(sorted_part) def insertion_sort(array: List[int]) -> List[int]: Sorts the given list of integers using the insertion sort algorithm. sorted_array = [] for value in array: pos = search_insert(sorted_array, value) sorted_array.insert(pos, value) return sorted_array"},{"question":"# Coding Challenge: Balanced Tree Check Imagine you are tasked with designing a feature for a software that analyzes the structure of binary trees. One important property for efficient operations is whether the tree is balanced. A balanced binary tree is one where the depth of the two subtrees of every node never differ by more than 1. Task Write a function `is_balanced` that determines if a given binary tree is balanced. Input - A binary tree `root` which is an instance of the TreeNode class provided. Output - Return `True` if the tree is balanced, otherwise `False`. Constraints - Tree can have up to 10^4 nodes. - Node values are integers, but they are irrelevant for the balance-checking task. Example Scenario Consider the binary tree: ``` 1 / 2 3 / 4 5 ``` In this example, the tree is balanced because the depth difference between the left and right subtree of every node is at most 1. ```python class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def is_balanced(root: TreeNode) -> bool: # Your implementation here pass # Example Usage: # tree = TreeNode(1) # tree.left = TreeNode(2) # tree.right = TreeNode(3) # tree.left.left = TreeNode(4) # tree.left.right = TreeNode(5) # balanced = is_balanced(tree) # print(balanced) # Should output: True ``` Performance Requirements Your solution should be efficient with time complexity around O(N) and space complexity around O(H), where N is the number of nodes and H is the height of the tree.","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def is_balanced(root: TreeNode) -> bool: def check_balance(node): if not node: return 0, True left_height, left_balanced = check_balance(node.left) right_height, right_balanced = check_balance(node.right) if not left_balanced or not right_balanced: return 0, False if abs(left_height - right_height) > 1: return 0, False return max(left_height, right_height) + 1, True _, balanced = check_balance(root) return balanced"},{"question":"As a dynamic programming exercise, implement a function to compute the number of non-negative integer decompositions of a given positive integer. This demonstrates understanding of dynamic programming concepts and complexity. # Problem Statement Write a function `int_divide(decompose)` that computes the number of ways to decompose a given positive integer `decompose` into a sum of non-negative integers. # Function Signature ```python def int_divide(decompose: int) -> int: pass ``` # Input * A single integer `decompose` (1 <= decompose <= 100). # Output * A single integer representing the number of decompositions of the input integer. # Example ```python assert int_divide(4) == 5 # 4 can be decomposed as 4, 3+1, 2+2, 2+1+1, 1+1+1+1 assert int_divide(7) == 15 # 7 has 15 different decompositions as explained in the example ``` # Constraints * The input integer will be between 1 and 100. * The solution should run efficiently with acceptable time and space usage for the input range. # Notes * Consider edge cases such as the smallest input value. * Think about performance implications when dealing with the upper range of the input size.","solution":"def int_divide(decompose: int) -> int: Function to compute the number of ways to decompose a given positive integer into a sum of non-negative integers. # Create a table to store results of subproblems dp = [[0 for _ in range(decompose + 1)] for _ in range(decompose + 1)] # Base Case: There is one way to decompose 0 for i in range(decompose + 1): dp[i][0] = 1 # Fill the table in bottom-up manner for i in range(1, decompose + 1): for j in range(1, decompose + 1): if j >= i: dp[i][j] = dp[i - 1][j] + dp[i][j - i] else: dp[i][j] = dp[i - 1][j] return dp[decompose][decompose]"},{"question":"# Task: Write a function that, given a positive integer `n`, finds all primitive roots of `n`. # Function Signature: ```python def find_all_primitive_roots(n: int) -> List[int]: ``` # Input: - `n`: A positive integer (1 ≤ n ≤ 10^4). # Output: - A list of integers representing all primitive roots of `n`. If no primitive roots exist, return an empty list. # Constraints: - The function must handle edge cases where `n` might not have any primitive roots. - Optimizations for large `n` should be considered due to potential high computation time. # Example: ```python assert find_all_primitive_roots(10) == [] assert find_all_primitive_roots(13) == [2, 6, 7, 11] assert find_all_primitive_roots(1) == [0] ``` # Solution Requirements: 1. Use Euler\'s Totient function to compute the number count of integers up to `n` that are coprime with `n`. 2. Compute the order of each coprime integer to determine if it is a primitive root. 3. Ensure the function handles the exceptional case where the only primitive root of 1 is `0`.","solution":"from typing import List import math def gcd(a, b): while b: a, b = b, a % b return a def euler_totient(n): amount = 0 for k in range(1, n + 1): if math.gcd(n, k) == 1: amount += 1 return amount def find_all_primitive_roots(n: int) -> List[int]: if n == 1: return [0] # Check if `n` is a power of a prime if n == 2: return [1] if n % 2 == 0: return [] def is_prime(num): if num <= 1: return False if num <= 3: return True if num % 2 == 0 or num % 3 == 0: return False i = 5 while (i * i) <= num: if num % i == 0 or num % (i + 2) == 0: return False i += 6 return True if not is_prime(n): return [] # Euler\'s Totient function phi(n) phi = euler_totient(n) def is_primitive_root(candidate): seen = set() current = 1 for power in range(phi): current *= candidate current %= n if current in seen: return False seen.add(current) return True results = [] for possible_root in range(1, n): if is_primitive_root(possible_root): results.append(possible_root) return results"},{"question":"# Minimal Bit Flips to Convert Integers Scenario In digital communications and computer networks, the Hamming distance is used to quantify the difference between two strings of equal length. Similarly, in embedded systems, efficiently determining bit-level differences is crucial. This task involves computing the minimal number of bit flips required to convert one given integer to another. Problem Statement You are required to write a function `minimal_bit_flips(a: int, b: int) -> int` to find the minimal number of bits that need to be flipped to convert integer `A` to integer `B`. Function Signature ```python def minimal_bit_flips(a: int, b: int) -> int: pass ``` Input * `a`: An integer, representing the initial value. * `b`: An integer, representing the target value. **Constraints**: * `-10^9 <= a, b <= 10^9` Output * An integer representing the minimal number of bits that need to be flipped to convert `a` to `b`. Examples Example 1: ``` minimal_bit_flips(29, 15) Output: 2 ``` Example 2: ``` minimal_bit_flips(1, 2) Output: 2 ``` Example 3: ``` minimal_bit_flips(0, 7) Output: 3 ``` Explanation * In the first example, binary representations are `11101` and `01111`, which differ at two positions (first and second bits). * In the second example, `1` (01) and `2` (10) have two differing bits. * In the third example, `0` (000) and `7` (111) have all bits different. Notes * Handle both positive and negative integers. * Python has built-in functions for integer to binary conversion which might help in visual debugging.","solution":"def minimal_bit_flips(a: int, b: int) -> int: Returns the minimal number of bits that need to be flipped to convert integer a to integer b. # XOR of a and b will give a binary number where 1s represent differing bits xor_result = a ^ b # Counting the number of 1s in the binary representation of xor_result return bin(xor_result).count(\'1\')"},{"question":"You are provided with a sorted array of integers and a target integer value. Implement both an iterative and a recursive function to perform binary search and find the index of the target value in the array. If the target does not exist in the array, return -1. # Input: * A sorted array of integers `array` (0 ≤ len(array) ≤ 10^5) * An integer `target` # Output: * Index of the target integer in the array if it exists, otherwise -1. # Function Signatures: ```python def binary_search_iterative(array: list[int], target: int) -> int: pass def binary_search_recursive(array: list[int], target: int) -> int: pass ``` # Constraints: * The function must have O(log n) time complexity. * Use the provided function signatures. * Avoid unnecessary operations to ensure optimal performance. # Example: ```python array = [1, 3, 5, 7, 9, 11, 13, 15] target = 7 # Output for both functions should be: 6 binary_search_iterative([1, 3, 5, 7, 9, 11, 13, 15], 7) -> 3 binary_search_recursive([1, 3, 5, 7, 9, 11, 13, 15], 7) -> 3 ``` # Implementation Notes: * Ensure to handle edge cases such as empty arrays and arrays with a single element. * Avoid overflowing mid calculations. # Tips: * Plan an iterative solution that uses a while loop. * Plan a recursive solution that calls itself with updated low and high indices until the base case is met. * Test the function with various array and target scenarios to cover all edge cases.","solution":"def binary_search_iterative(array: list[int], target: int) -> int: Perform a binary search in an iterative manner. :param array: List of sorted integers. :param target: The integer value to search for. :return: Index of target if found, otherwise -1. low, high = 0, len(array) - 1 while low <= high: mid = (low + high) // 2 if array[mid] == target: return mid elif array[mid] < target: low = mid + 1 else: high = mid - 1 return -1 def binary_search_recursive(array: list[int], target: int, low: int = 0, high: int = None) -> int: Perform a binary search in a recursive manner. :param array: List of sorted integers. :param target: The integer value to search for. :param low: The lower bound index for the current search range. :param high: The upper bound index for the current search range. :return: Index of target if found, otherwise -1. if high is None: high = len(array) - 1 if low > high: return -1 mid = (low + high) // 2 if array[mid] == target: return mid elif array[mid] < target: return binary_search_recursive(array, target, mid + 1, high) else: return binary_search_recursive(array, target, low, mid - 1)"},{"question":"# Task Implement an optimized version of the Rabin-Miller primality test. Your function should directly use the given snippet as a core reference. You are to focus on refining the random number generation aspect and enhancing the handling of small ( n ) values for a more robust implementation. # Function Signature ```python def optimized_is_prime(n: int, k: int = 5) -> bool: ``` # Input - **n (int)**: The number to be tested for primality. It is guaranteed that ( n geq 1 ). - **k (int)**: The number of iterations to increase accuracy, default is 5. # Output - **bool**: Return `True` if ( n ) is probably prime, otherwise `False`. # Constraints 1. ( 1 leq n leq 10^{18} ) 2. ( 1 leq k leq 100 ) # Example ```python assert optimized_is_prime(17) is True assert optimized_is_prime(18) is False assert optimized_is_prime(109, 10) is True ``` # Requirements - Enhance random number generation so it efficiently selects witnesses. - Handle cases where ( n ) is less than 5. - Ensure the time complexity remains within ( O(k cdot log^3 n) ).","solution":"import random def optimized_is_prime(n: int, k: int = 5) -> bool: Determines if n is a prime number using an optimized Rabin-Miller primality test. Parameters: - n (int): the number to be tested for primality - k (int): the number of iterations to increase accuracy, default is 5 Returns: - bool: True if n is probably prime, False otherwise if n <= 3: return n == 2 or n == 3 if n % 2 == 0: return False # Find d such that d*2^r = n-1 d, r = n - 1, 0 while d % 2 == 0: d //= 2 r += 1 def is_composite(a): x = pow(a, d, n) if x == 1 or x == n - 1: return False for _ in range(r - 1): x = pow(x, 2, n) if x == n - 1: return False return True def get_random_nonzero(low, high): while True: candidate = random.randint(low, high) if candidate != 0: return candidate for _ in range(k): a = get_random_nonzero(2, n - 2) if is_composite(a): return False return True"},{"question":"# Question: Segment Tree for Range Multiplication Queries You are given an array of integers and you need to implement a Segment Tree to support range multiplication queries. The Segment Tree should allow for efficient querying of the product of elements in a subarray, as well as updating an individual element in the array. **Function Signature** ```python class SegmentTree: def __init__(self, arr: List[int]): self.segment: List[int] self.arr: List[int] self.build_tree(self, arr) def build_tree(self, arr: List[int]) -> None: pass def update(self, pos: int, new_value: int) -> None: pass def product_query(self, left: int, right: int) -> int: pass ``` **Constraints** - `1 <= len(arr) <= 10^5` - `-10^4 <= arr[i] <= 10^4` - Queries and updates will be valid and within the bounds of the array. **Input** - A list of integers representing the array elements. - Multiple queries and updates of the format: * `update(i, v)` Updates the element at index i to value v. * `product_query(L, R)` Returns the product of elements from index L to R (inclusive). **Output** - For each `product_query(L, R)`, return the product of the elements in the subarray defined by [L, R]. **Example Usage** ```python # Initialize tree arr = [1, 3, 5, 7, 9, 11] seg_tree = SegmentTree(arr) # Query product of range [1, 3] seg_tree.product_query(1, 3) # Output: 105 (3*5*7) # Update value at index 1 to 2 seg_tree.update(1, 2) # Query product of range [1, 3] seg_tree.product_query(1, 3) # Output: 70 (2*5*7) ``` You are expected to implement efficient methods for both building the tree, querying the product, and updating an element. **Additional Notes** - Consider edge cases where the queried range might be a single element. - Ensure the calculations handle potential overflows and sign changes due to negative numbers in the array.","solution":"class SegmentTree: def __init__(self, arr): self.n = len(arr) self.arr = arr self.segment = [1] * (2 * self.n) self.build_tree(arr) def build_tree(self, arr): # Initialize the leaves of the segment tree for i in range(self.n): self.segment[self.n + i] = arr[i] # Build the tree by calculating parents for i in range(self.n - 1, 0, -1): self.segment[i] = self.segment[2 * i] * self.segment[2 * i + 1] def update(self, pos, new_value): # Update the value at the leaf node pos += self.n self.segment[pos] = new_value # Update the parents while pos > 1: pos //= 2 self.segment[pos] = self.segment[2 * pos] * self.segment[2 * pos + 1] def product_query(self, left, right): result = 1 left += self.n right += self.n while left <= right: if left % 2 == 1: result *= self.segment[left] left += 1 if right % 2 == 0: result *= self.segment[right] right -= 1 left //= 2 right //= 2 return result"},{"question":"# Task: Implement a Robust Path Resolution Function Objective Develop a function `resolve_full_path` that takes an input file path and returns its fully resolved absolute path. The function should handle and validate different types of paths, including relative paths, tilde-prefixed paths, and malformed paths. Requirements: - Use the Python `os` module. - Ensure the function can handle edge cases and invalid inputs gracefully. - The output should always be an absolute path if possible. - If the input is an empty string or an invalid path, return an informative error message. Constraints: - **Input**: A single string representing the file path. - **Output**: A single string representing the absolute path or an error message. Performance: - Time Complexity: Aim for O(n) where `n` is the length of the input path. - Space Complexity: O(n) where `n` is the length of the resulting absolute path string. Example Usage: ```python # Implement the function as specified def resolve_full_path(file): import os # Your code here # Sample scenarios print(resolve_full_path(\\"~/documents/file.txt\\")) # Should return an absolute path based on the user\'s home directory print(resolve_full_path(\\"\\")) # Should return an informative error message print(resolve_full_path(\\"some/relative/path\\")) # Should return an absolute path print(resolve_full_path(\\"///malformed///path\\")) # Should return an informative error message ``` Additional Notes: - Ensure to handle different operating systems if necessary (`os` module abstracts most of it). - Return an appropriate error if the input is not a valid path string.","solution":"def resolve_full_path(file): import os from pathlib import Path # Check if input is a valid string if not isinstance(file, str): return \\"Error: Path must be a string\\" # Strip any leading/trailing whitespaces file = file.strip() # Check if the string is empty if not file: return \\"Error: Path cannot be empty\\" # Expand tilde to the user home directory file = os.path.expanduser(file) try: # Convert to absolute path absolute_path = os.path.abspath(file) return absolute_path except Exception as e: return f\\"Error: {str(e)}\\""},{"question":"# String Merge Validation Challenge Problem Statement: You are given three strings: `s`, `part1`, and `part2`. Write a function `can_merge_strings(s, part1, part2)` that returns `True` if the string `s` can be formed by interleaving characters from `part1` and `part2`, while maintaining the relative order of characters in both `part1` and `part2`. Otherwise, return `False`. You must implement this function in an optimal way, as naive or overly complex solutions may not fit within the time constraints on larger inputs. Input: * `s`: A string of length `n` (0 <= n <= 1000) * `part1`: A string of length `m` (0 <= m <= 1000) * `part2`: A string of length `k` (0 <= k <= 1000) Output: * Return `True` if `s` is a valid merge of `part1` and `part2`, otherwise return `False`. Constraints: * The characters in `part1` and `part2` retain their relative order within `s`. Example Cases: # Example 1: * Input: ``` s = \\"codewars\\" part1 = \\"cdw\\" part2 = \\"oears\\" ``` * Output: ``` True ``` # Example 2: * Input: ``` s = \\"codewars\\" part1 = \\"cod\\" part2 = \\"ewars\\" ``` * Output: ``` True ``` # Example 3: * Input: ``` s = \\"cdew\\" part1 = \\"cd\\" part2 = \\"e\\" ``` * Output: ``` False ``` Detailed Constraints: * You are not allowed to assume a specific distribution of characters in the input strings. * Your solution should work efficiently even for maximum input lengths. Performance Requirements: * Aim to optimize for both time and space complexities considering large input sizes. * Recursive approaches should leverage optimization techniques (e.g., memoization) to handle overlaps and redundancies. * Iterative approaches are encouraged to avoid deep recursion and potential stack overflow issues. Implement `can_merge_strings(s, part1, part2)` function in Python: ```python def can_merge_strings(s, part1, part2): # Your code here ```","solution":"def can_merge_strings(s, part1, part2): Determines if the string `s` can be formed by interleaving characters from `part1` and `part2` while maintaining the relative order of characters in both `part1` and `part2`. n, m, k = len(s), len(part1), len(part2) if n != m + k: return False dp = [[False] * (k + 1) for _ in range(m + 1)] dp[0][0] = True for i in range(m + 1): for j in range(k + 1): if i > 0 and s[i + j - 1] == part1[i - 1]: dp[i][j] = dp[i][j] or dp[i - 1][j] if j > 0 and s[i + j - 1] == part2[j - 1]: dp[i][j] = dp[i][j] or dp[i][j - 1] return dp[m][k]"},{"question":"# Bogo Sort Simulation Context Bogo Sort, also known as permutation sort, is an inefficient sorting algorithm that randomly shuffles an array until it finds a sorted permutation. Despite its inefficiency, Bogo Sort can be a useful educational tool for understanding the importance of algorithm efficiency and the probabilistic model in sorting. Task You are required to implement a function `bogo_sort_simulation(arr, simulation=False)` in Python which sorts the given list using the Bogo Sort algorithm. You should also include an optional simulation mode to display the shuffling process. Function Signature ```python def bogo_sort_simulation(arr: list[int], simulation: bool=False) -> list[int]: ``` Input * `arr` (list of integers): The list of integers to be sorted. * `simulation` (boolean, optional): If set to `True`, it should print the array after every shuffle. Defaults to `False`. Output * Returns the sorted list of integers. Constraints * The length of `arr` can be up to 10 to avoid computational infeasibility during testing. * Elements within `arr` can be any integer values, including negative numbers. Example ```python # Example 1: Simple array arr = [3, 2, 5, 1, 4] sorted_arr = bogo_sort_simulation(arr) print(sorted_arr) # Example 2: With simulation arr = [3, 2, 1] sorted_arr = bogo_sort_simulation(arr, simulation=True) # Example 3: Empty array arr = [] sorted_arr = bogo_sort_simulation(arr) print(sorted_arr) # Example 4: Already sorted array arr = [1, 2, 3, 4, 5] sorted_arr = bogo_sort_simulation(arr) print(sorted_arr) ``` **Note**: Be mindful of the computational limitations of this algorithm when testing with larger arrays.","solution":"import random def is_sorted(arr): Helper function to check if the array is sorted. for i in range(len(arr) - 1): if arr[i] > arr[i + 1]: return False return True def bogo_sort_simulation(arr, simulation=False): Sorts the given list using the Bogo Sort algorithm. Parameters: arr (list[int]): The list of integers to be sorted. simulation (bool): Whether to print the array after every shuffle. Defaults to False. Returns: list[int]: The sorted list of integers. while not is_sorted(arr): if simulation: print(arr) random.shuffle(arr) if simulation: print(arr) return arr"},{"question":"Scenario Every developer faces the challenge of dealing with file paths in their applications. It\'s crucial to ensure that these paths are consistently processed to avoid errors related to file accessibility. You are tasked to enhance your project\'s utility functions to ensure robust and reliable file path manipulations. Problem Statement Write a function `get_full_path` that converts a given file path into its absolute path, expanding any user directory symbols in the process. This ensures that any relative path or user directory reference is properly resolved to its absolute form. Function Signature ```python def get_full_path(file: str) -> str: pass ``` # Input - `file` (str): A string representing the file path, which could be relative, contain user directory symbols (`~`), or both. # Output - Returns a string representing the absolute file path. # Constraints - The input string `file` will not be `None` and its length will be <= 4096 characters. - The underlying file system and OS functions should be used for actual path manipulation. Example ```python assert get_full_path(\\"~/docs/file.txt\\") == \\"/home/user/docs/file.txt\\" # Example path may vary based on the system user assert get_full_path(\\"relative/path/to/file.txt\\") == \\"/current/working/directory/relative/path/to/file.txt\\" assert get_full_path(\\"/absolute/path/to/file.txt\\") == \\"/absolute/path/to/file.txt\\" ``` Notes - The function should be resilient to user error and handle common edge cases, such as resolving an already absolute path without additional changes. - You may assume a Unix-like environment for typical user directory expansions and path formats. Performance Requirements - Ensure that the function performs efficiently within the constraints provided.","solution":"import os def get_full_path(file: str) -> str: Converts a given file path into its absolute path, expanding any user directory symbols and resolving relative paths. Args: file (str): A string representing the file path. Returns: str: The absolute file path. # Expanding user\'s home directory symbol ~ file = os.path.expanduser(file) # Getting the absolute path file = os.path.abspath(file) return file"},{"question":"# Scenario You are tasked with analyzing survey data containing various ratings (integers). To better understand the distribution of the ratings, you need to create a histogram that shows the frequency of each rating. # Task Implement a function `get_histogram` which takes a list of integers representing ratings and returns a dictionary where the keys are the unique ratings and the values are their respective counts. # Function Signature ```python def get_histogram(input_list: list) -> dict: pass ``` # Input * `input_list`: A list of integers, representing ratings (1 ≤ list length ≤ 10^6, each integer in the list is between 1 and 100 inclusive). # Output * A dictionary where: * Keys are integers from the input list. * Values are the counts of each integer in the input list. # Example ```python print(get_histogram([3, 3, 2, 1])) # Output: {1: 1, 2: 1, 3: 2} print(get_histogram([2, 3, 5, 5, 5, 6, 4, 3, 7])) # Output: {2: 1, 3: 2, 4: 1, 5: 3, 6: 1, 7: 1} ``` # Constraints * Handle edge cases like empty input list or the list where all elements are the same. * The implementation should aim for O(n) time complexity and O(k) space complexity where n is the number of elements in the list, and k is the number of unique elements.","solution":"def get_histogram(input_list: list) -> dict: Constructs a histogram (frequency count) of each integer in the input list. :param input_list: List of integers representing ratings. :return: Dictionary where keys are the unique integers and values are their respective counts. histogram = {} for rating in input_list: if rating in histogram: histogram[rating] += 1 else: histogram[rating] = 1 return histogram"},{"question":"# Anagram Frequency Count Function Objective Write a function that checks if one string is an anagram of another by leveraging frequency counts. Function Signature ```python def is_anagram(s: str, t: str) -> bool: ``` Input * `s` (string): A string containing lowercase alphabetic characters. * `t` (string): A string containing lowercase alphabetic characters. Output * `bool`: Return `True` if `t` is an anagram of `s`, otherwise return `False`. Constraints * Strings `s` and `t` will only contain lowercase alphabetic characters. * The length of the strings `s` and `t` can be from 0 to 10^5. Performance Requirements * Time Complexity must be O(n), where n is the length of the strings. * Space Complexity should be O(1), keeping in mind the frequency map requires fixed extra space for 26 characters maximum. Edge Cases * Both strings are empty: should return `True`. * Strings of different lengths: should return `False`. * Normal cases where ~frequency counts must be computed and compared. Example ```python # Example 1 s = \\"listen\\" t = \\"silent\\" is_anagram(s, t) # Output: True # Example 2 s = \\"hello\\" t = \\"billion\\" is_anagram(s, t) # Output: False # Example 3 s = \\"abcdabc\\" t = \\"abcdcba\\" is_anagram(s, t) # Output: True ``` Implementation Implement the function `is_anagram(s: str, t: str) -> bool` to solve the above problem efficiently.","solution":"def is_anagram(s: str, t: str) -> bool: Returns whether string t is an anagram of string s by comparing character frequencies. if len(s) != len(t): return False frequency_s = [0] * 26 frequency_t = [0] * 26 for char in s: frequency_s[ord(char) - ord(\'a\')] += 1 for char in t: frequency_t[ord(char) - ord(\'a\')] += 1 return frequency_s == frequency_t"},{"question":"# Maximum Sum of Contiguous Subsequence In this coding challenge, you are required to implement Kadane\'s Algorithm which identifies the maximum sum of a contiguous subsequence in an array of integers. Requirements * Write a function `max_contiguous_subsequence_sum(arr: List[int]) -> int` that takes an array of integers and returns the maximum sum of any contiguous subsequence. * The function should handle both positive and negative numbers. * If the array is empty, the function should return `0`. Input * An array of integers `arr` where `1 <= len(arr) <= 10^5` and `-10^4 <= arr[i] <= 10^4`. Output * An integer representing the maximum sum of contiguous elements. Example Scenarios **Example 1** ```plaintext Input: [-2, 3, 8, -1, 4] Output: 14 Explanation: The contiguous subsequence [3, 8, -1, 4] yields the maximum sum of 14. ``` **Example 2** ```plaintext Input: [-1, -3, -4] Output: -1 Explanation: The single element -1 is the maximum sum as all other subsequence sums are smaller. ``` **Example 3** ```plaintext Input: [1, 2, 3, 4, -10, 10] Output: 10 Explanation: The contiguous subsequence [10] yields the maximum sum of 10. ``` Use the principles of Kadane\'s Algorithm, ensuring that the results are optimized for both speed and correctness.","solution":"from typing import List def max_contiguous_subsequence_sum(arr: List[int]) -> int: Returns the maximum sum of any contiguous subsequence in an array. if not arr: return 0 max_current = max_global = arr[0] for num in arr[1:]: max_current = max(num, max_current + num) if max_current > max_global: max_global = max_current return max_global"},{"question":"Context Cycle Sort is a unique sorting algorithm that achieves a minimal number of writes. Your task is to implement a variation of this algorithm that enhances its robustness by handling arrays with duplicate values and ensuring it operates correctly. Problem Statement Write a Python function `optimized_cycle_sort(arr: List[int]) -> List[int]` that sorts an array of integers using an optimized version of Cycle Sort. The function should handle cases where there are duplicate values and must ensure that the algorithm does not get stuck in an infinite loop. Input - `arr`: A list of integers, where `1 <= len(arr) <= 10^5` and `-10^9 <= arr[i] <= 10^9` for all valid `i`. Output - The function should return a new list with the elements sorted in non-decreasing order. Constraints - Maintain O(1) space complexity by sorting in place. - Optimize cycle detection to handle duplicate values effectively. Example ```python assert optimized_cycle_sort([4, 3, 2, 1]) == [1, 2, 3, 4] assert optimized_cycle_sort([4, 4, 2, 1]) == [1, 2, 4, 4] assert optimized_cycle_sort([]) == [] assert optimized_cycle_sort([1]) == [1] assert optimized_cycle_sort([2, 3, 5, 1, 3]) == [1, 2, 3, 3, 5] ``` Requirements - Your implementation should correctly handle arrays with duplicate values. - Ensure that the algorithm does not run into an infinite loop. - Aim for clarity and robustness in your code.","solution":"from typing import List def optimized_cycle_sort(arr: List[int]) -> List[int]: Sorts an array using an optimized Cycle Sort algorithm that handles duplicates and ensures no infinite loops. n = len(arr) for start in range(n - 1): item = arr[start] # Find the position where we need to place the item pos = start for i in range(start + 1, n): if arr[i] < item: pos += 1 # If the item is already in the correct position, continue if pos == start: continue # Skip duplicates while item == arr[pos]: pos += 1 # Put the item at its correct position if pos != start: arr[pos], item = item, arr[pos] # Rotate the rest of the cycle while pos != start: pos = start for i in range(start + 1, n): if arr[i] < item: pos += 1 # Skip duplicates while item == arr[pos]: pos += 1 # Put the item at its correct position if item != arr[pos]: arr[pos], item = item, arr[pos] return arr"},{"question":"You are required to implement a function `optimized_primes` that improves upon the Sieve of Eratosthenes algorithm provided, ensuring better space efficiency without compromising much on performance. # Function Signature ```python def optimized_primes(n: int) -> List[int]: ``` # Input - An integer `n` where `1 <= n <= 10^7`, representing the upper limit (exclusive) for counting primes. # Output - A list of all prime numbers less than `n`. # Constraints - Do not use any external libraries for prime generation. - Ensure your solution handles the memory efficiently for `n` as large as 10^7. - Implement improvements by: - Excluding all even numbers to halve the size of the sieve array. - Marking multiples starting from square of each prime base to reduce redundant operations. # Example ```python print(optimized_primes(10)) # Outputs: [2, 3, 5, 7] print(optimized_primes(30)) # Outputs: [2, 3, 5, 7, 11, 13, 17, 19, 23, 29] # Notice we do not include the upper bound n itself if it is prime. ``` **Note**: - Be cautious about handling edge cases like n=2 which is the minimum input and should result in an empty list. - Ensure that the implementation avoids redundant checks and optimizes by excluding even number operations after initial inclusion of 2.","solution":"from typing import List def optimized_primes(n: int) -> List[int]: if n <= 2: return [] sieve = [True] * (n // 2) sieve[0] = False # 1 is not prime for i in range(1, int(n**0.5)//2 + 1): if sieve[i]: for j in range(2*i*(i+1), n//2, 2*i+1): sieve[j] = False primes = [2] + [2*i + 1 for i in range(1, n//2) if sieve[i]] return primes"},{"question":"# Question You are given a partially implemented priority queue data structure using a linear array, as shown in the code snippet. Your task is to complete the following additional operations: 1. **Peek Operation** - `peek()` - **Functionality**: Returns the item with the lowest priority without removing it from the queue. - **Input**: None - **Output**: The item with the lowest priority. - **Constraints**: If the priority queue is empty, raise an `IndexError` with the message \\"Priority Queue is empty\\". 2. **Change Priority Operation** - `change_priority(item, new_priority)` - **Functionality**: Changes the priority of a given item more efficiently. - **Input**: - `item`: The item whose priority needs to be updated. - `new_priority`: The new priority value to be assigned to the item. - **Output**: Update the Priority Queue by removing the old priority value and inserting the item with the new priority value. - **Constraints**: If the item is not present in the priority queue, do nothing. # Implementation ```python class PriorityQueue: # Existing methods as provided in the code snippet def peek(self): Returns the item with the lowest priority without removing it from the queue. Raises: IndexError: If the priority queue is empty. # Your implementation here def change_priority(self, item, new_priority): Changes the priority of a given item. Args: item: The item to update its priority. new_priority: The new priority value. # Your implementation here ``` # Example ```python pq = PriorityQueue([3, 1, 4], [1, 2, 3]) print(pq.peek()) # Output: 1 pq.push(6, 0) print(pq.pop()) # Output: 1 pq.change_priority(3, 6) print(pq.pop()) # Output: 6 print(pq.pop()) # Output: 4 print(pq.pop()) # Output: 6 try: pq.pop() except IndexError as e: print(e) # Output: Priority Queue is empty ```","solution":"class PriorityQueue: def __init__(self, items=[], priorities=[]): self.queue = list(zip(priorities, items)) def push(self, item, priority): self.queue.append((priority, item)) self.queue.sort(key=lambda x: x[0]) def pop(self): if not self.queue: raise IndexError(\\"Priority Queue is empty\\") return self.queue.pop(0)[1] def peek(self): Returns the item with the lowest priority without removing it from the queue. Raises: IndexError: If the priority queue is empty. if not self.queue: raise IndexError(\\"Priority Queue is empty\\") return self.queue[0][1] def change_priority(self, item, new_priority): Changes the priority of a given item. Args: item: The item to update its priority. new_priority: The new priority value. found = False for index, (priority, it) in enumerate(self.queue): if it == item: self.queue[index] = (new_priority, it) found = True break if found: self.queue.sort(key=lambda x: x[0])"},{"question":"# Problem Description You are provided with a dataset that consists of multiple lists of numerical values. Your task is to write a function that generates a histogram for each list and then combines these histograms into a single summary histogram. The summary histogram should represent the combined frequency of each element across all lists. # Function Signature ```python def combined_histogram(data: List[List[int]]) -> Dict[int, int]: ``` # Input * `data`: A list of lists, where each inner list contains integers. * Each inner list is guaranteed to be non-empty. * Example: `[[1, 2, 2, 3], [2, 3, 3, 4], [1, 5, 6]]` # Output * Returns a dictionary where the keys are the integers from all the inner lists, and the values are their combined frequencies. * Example: `{1: 2, 2: 3, 3: 3, 4: 1, 5: 1, 6: 1}` # Constraints * The input may contain up to `10^5` elements in total across all the inner lists. * Each inner list may contain integers in the range from `-10^6` to `10^6`. # Example ```python data = [[1, 2, 2, 3], [2, 3, 3, 4], [1, 5, 6]] assert combined_histogram(data) == {1: 2, 2: 3, 3: 3, 4: 1, 5: 1, 6: 1} data = [[10, 20, 20, 30], [20, 30, 30, 40], [10, 50, 60]] assert combined_histogram(data) == {10: 2, 20: 3, 30: 3, 40: 1, 50: 1, 60: 1} ``` # Requirements * Ensure that the function efficiently handles large lists. * Provide meaningful comments in your code to explain key steps and logic.","solution":"from typing import List, Dict from collections import defaultdict def combined_histogram(data: List[List[int]]) -> Dict[int, int]: Given a list of lists containing integers, this function generates a combined histogram of the frequency of each integer across all lists. :param data: List of lists of integers. :return: Dictionary representing the combined frequency of each integer. histogram = defaultdict(int) for sublist in data: for item in sublist: histogram[item] += 1 return dict(histogram)"},{"question":"# Problem: Efficient Pancake Sorting Scenario You are tasked with sorting an array using a technique derived from flipping pancakes, known as Pancake Sorting. While simple, this algorithm is known to be less efficient for large datasets. For the sake of learning, you are required to implement this Pancake Sort algorithm and understand its intricacies. Task Implement the function `efficient_pancake_sort(arr)` that takes in a list of integers and returns the sorted list using the Pancake Sort algorithm. Ensure that you consider various edge cases such as empty arrays and arrays with all identical elements. Implementation Details * **Input**: - `arr` - A list of integers of length (N) ((0 leq N leq 1000)). * **Output**: - A sorted list of integers. Constraints * The function should run efficiently for the given constraints. * Do not use any built-in sorting functions. # Example ```python arr = [3, 6, 1, 10, 2] sorted_arr = efficient_pancake_sort(arr) print(sorted_arr) # Output: [1, 2, 3, 6, 10] ``` Notes * Focus on making your implementation readable and consider edge cases and potential pitfalls. * Think about the performance of your implementation; while it is acceptable to have a quadratic time complexity, consider the numbers of operations you perform within that. Good luck, and may your pancake flips always land flat!","solution":"def efficient_pancake_sort(arr): Pancake sort the given list. def flip(sublist, end): start = 0 while start < end: sublist[start], sublist[end] = sublist[end], sublist[start] start, end = start + 1, end - 1 def find_max_index(sublist, n): max_index = 0 for i in range(1, n): if sublist[i] > sublist[max_index]: max_index = i return max_index n = len(arr) for size in range(n, 1, -1): max_index = find_max_index(arr, size) if max_index != size - 1: # Flip the maximum element to the front flip(arr, max_index) # Flip it to its correct position flip(arr, size - 1) return arr"},{"question":"# Bit Manipulation Challenge You are given a few fundamental bit manipulation functions: `get_bit`, `set_bit`, `clear_bit`, and `update_bit`. Now it is your turn to implement a more complex function using these basic operations. # Problem Statement Write a function `count_set_bits(num: int) -> int` that counts the number of set bits (i.e., bits with value 1) in the binary representation of a given non-negative integer `num`. # Input - `num` (int): A non-negative integer. # Output - Returns an integer representing the number of set bits in the given integer. # Constraints - The input integer is non-negative. - The result should be calculated using only bitwise operations. # Example ```python count_set_bits(5) # Returns 2 (binary representation: 101) count_set_bits(15) # Returns 4 (binary representation: 1111) count_set_bits(0) # Returns 0 (binary representation: 0) ``` # Requirements - Do not use built-in functions like `bin()` or `str()`. - Time complexity should be O(log n). # Instructions Implement the function `count_set_bits` below: ```python def count_set_bits(num): # Your code here pass ``` Ensure to test your implementation against various edge and typical cases.","solution":"def count_set_bits(num): Counts the number of set bits (1\'s) in the binary representation of a non-negative integer num. count = 0 while num: count += num & 1 # Increment count if the least significant bit is 1 num >>= 1 # Shift right by 1 to check the next bit return count"},{"question":"Background Integer partitioning is a common problem in combinatorics that involves expressing a positive integer `n` as the sum of one or more positive integers, disregarding the order of the addends. For instance, the number 4 can be partitioned in five different ways: 4, 3+1, 2+2, 2+1+1, and 1+1+1+1. Task Write a function called `int_divide` that takes a single positive integer `n` and returns the number of ways it can be partitioned into sums of non-negative integers. Function Signature ```python def int_divide(n: int) -> int: ``` Input Constraints * `1 <= n <= 100` Output * A single integer representing the number of possible partitions of the input number `n`. Examples 1. **Example 1**: * Input: `4` * Output: `5` * Explanation: 4 can be partitioned as follows: - 4 - 3+1 - 2+2 - 2+1+1 - 1+1+1+1 2. **Example 2**: * Input: `7` * Output: `15` * Explanation: 7 can be partitioned in fifteen different ways listed in the provided code snippet. Note * The order of summands for partitions does not matter, meaning 2+3 is considered the same as 3+2. Additional Considerations * Ensure that the algorithm is efficient and adheres to the complexity requirements.","solution":"def int_divide(n: int) -> int: Returns the number of ways to partition the integer n into sums of non-negative integers. # Create a dp array to store the number of ways to partition each integer up to n dp = [0] * (n + 1) dp[0] = 1 # There is one way to partition 0 (using no parts) # Iterate over each number i from 1 to n for i in range(1, n + 1): for j in range(i, n + 1): dp[j] += dp[j - i] return dp[n]"},{"question":"# Rotated Sorted Array Search Scenario You are tasked with developing a software component that efficiently searches for an element in arrays that are first sorted in ascending order and subsequently rotated at an unknown pivot. This scenario is common in circular data structures where data might be shifted periodically. Problem Statement Implement the function `rotated_search(arr, target)` that accepts an array `arr` which is sorted in ascending order and then rotated at some unknown pivot, and an integer `target`. The function should return the index of `target` in the array. If the target is not found, return -1. Aim for a runtime complexity of O(log n). Input - `arr`: List of integers, where the list is initially in ascending order and rotated at an unknown pivot. - Example: `[4,5,6,7,0,1,2]` - `target`: An integer value to be searched. - Example: `5` Output - Return the index of the target value if it is found in the array; otherwise, return -1. - Example: for the input `[4,5,6,7,0,1,2]` and `target 5`, the output should be `1`. Constraints - **Arr:** Size `n` where `1 <= n <= 10^5` - **Element Values:** Each element in `arr` will be distinct and within range `-10^6 <= arr[i] <= 10^6` - **Target:** The `target` will be an integer within the same value range as the array elements. Example ```python assert rotated_search([4,5,6,7,0,1,2], 5) == 1 assert rotated_search([4,5,6,7,0,1,2], 3) == -1 ``` Hints 1. Analyze both halves of the array to determine which half is still in sorted order. 2. Utilize the properties of the binary search for efficient splitting of the search space. 3. Consider writing helper functions if implementing the recursive version.","solution":"def rotated_search(arr, target): Finds the index of target in rotated sorted array arr. Returns -1 if the target is not present in the array. left, right = 0, len(arr) - 1 while left <= right: mid = (left + right) // 2 if arr[mid] == target: return mid # Determine which part is sorted if arr[left] <= arr[mid]: # Left part is sorted if arr[left] <= target < arr[mid]: right = mid - 1 else: left = mid + 1 else: # Right part is sorted if arr[mid] < target <= arr[right]: left = mid + 1 else: right = mid - 1 return -1"},{"question":"# Pathfinding Algorithms in Graphs Context: You are developing a navigation system that requires the capability to find paths between various locations represented as nodes in a graph. Your task is to implement functions to find paths from a start node to an end node in an undirected graph. Specifically, you need to handle finding a single path, all possible paths, and the shortest path between two nodes. # Requirements: Implement three functions: 1. `find_path(graph, start, end)`: - **Input**: `graph` (a dictionary where keys are node labels and values are lists of adjacent nodes), `start` (label of the starting node), `end` (label of the ending node). - **Output**: A list representing one path from `start` to `end`, or `None` if no path exists. 2. `find_all_paths(graph, start, end)`: - **Input**: Same as `find_path`. - **Output**: A list of lists, where each inner list is a unique path from `start` to `end`. Return an empty list if no path exists. 3. `find_shortest_path(graph, start, end)`: - **Input**: Same as `find_path`. - **Output**: A list representing the shortest path from `start` to `end`, or `None` if no path exists. # Constraints: - The graph is undirected and can have cycles. - The graph is represented as an adjacency list. - Node labels are unique strings. # Performance Requirements: - Your solutions should be correct and handle graphs with up to 20 nodes efficiently. - Avoid excessive memory usage and ensure your recursion depth does not lead to stack overflow. # Example Usage: Given the following graph: ```python graph = { \'A\': [\'B\', \'C\'], \'B\': [\'A\', \'D\', \'E\'], \'C\': [\'A\', \'F\'], \'D\': [\'B\'], \'E\': [\'B\', \'F\'], \'F\': [\'C\', \'E\'] } ``` - `find_path(graph, \'A\', \'F\')` could return `[\'A\', \'C\', \'F\']`. - `find_all_paths(graph, \'A\', \'F\')` could return `[[\'A\', \'C\', \'F\'], [\'A\', \'B\', \'E\', \'F\']]`. - `find_shortest_path(graph, \'A\', \'F\')` should return `[\'A\', \'C\', \'F\']`. Implement your solutions based on the above requirements and structure.","solution":"def find_path(graph, start, end, path=None): Returns a list representing one path from start to end. If no path exists, returns None. if path is None: path = [] path = path + [start] if start == end: return path if start not in graph: return None for node in graph[start]: if node not in path: new_path = find_path(graph, node, end, path) if new_path: return new_path return None def find_all_paths(graph, start, end, path=None): Returns a list of lists, where each inner list is a path from start to end. If no path exists, returns an empty list. if path is None: path = [] path = path + [start] paths = [] if start == end: return [path] if start not in graph: return [] for node in graph[start]: if node not in path: new_paths = find_all_paths(graph, node, end, path) for new_path in new_paths: paths.append(new_path) return paths def find_shortest_path(graph, start, end): Returns a list representing the shortest path from start to end. If no path exists, returns None. from collections import deque queue = deque([(start, [start])]) while queue: (vertex, path) = queue.popleft() for next in set(graph[vertex]) - set(path): if next == end: return path + [next] else: queue.append((next, path + [next])) return None"},{"question":"**Scenario**: You are working as a software engineer in a company that deals with logical constraint satisfaction problems. One of your tasks is to determine whether a set of logical conditions can be satisfied. Specifically, you have to solve instances of the 2-SAT (2-satisfiability) problem, which can be reduced to finding strongly connected components in the implication graph of the given formula. **Problem Statement**: Given a set of logical clauses in 2-CNF (Conjunctive Normal Form), where each clause is a disjunction of exactly two literals, write a function `can_satisfy_2SAT(formula)` that determines if there is a way to assign True/False values to all variables such that all clauses are satisfied. # Function Signature: ```python def can_satisfy_2SAT(formula: List[Tuple[Tuple[str, bool], Tuple[str, bool]]]) -> Optional[Dict[str, bool]]: ``` # Input: * `formula`: A list of tuples representing the clauses. Each clause is a tuple of two literals. A literal is a tuple containing a variable name (as a string) and a Boolean indicating whether the variable is negated. # Output: * If there exists a satisfying assignment, return a dictionary mapping each variable to its assigned True/False value. * If no such assignment exists, return `None`. # Constraints: 1. Variable names are unique. 2. Each clause contains exactly two literals. 3. The formula contains at least one clause. # Example: ```python formula = [((\'x\', False), (\'y\', False)), ((\'y\', True), (\'y\', True)), ((\'a\', False), (\'b\', False)), ((\'a\', True), (\'c\', True)), ((\'c\', False), (\'b\', True))] result = can_satisfy_2SAT(formula) print(result) # Output could be: {\'x\': True, \'y\': False, \'a\': True, \'b\': False, \'c\': False} or similar valid solving assignment ``` # Performance Requirements: * The solution should be efficient with a time complexity of `O(V + E)`, where `V` is the number of variables and `E` is the number of clauses. This is necessary to handle large formulas effectively. # Additional Notes: * Ensure your implementation correctly handles the construction of the implication graph, detects strongly connected components, and assigns truthful values in a way that satisfies all the provided clauses. * Consider edge cases such as formulas with contradictory clauses and isolated variables.","solution":"from typing import List, Dict, Tuple, Optional from collections import defaultdict def can_satisfy_2SAT(formula: List[Tuple[Tuple[str, bool], Tuple[str, bool]]]) -> Optional[Dict[str, bool]]: def add_edge(graph, u, v): graph[u].append(v) def tarjan_scc(node): nonlocal index indices[node] = lowlinks[node] = index index += 1 stack.append(node) on_stack[node] = True for neighbor in implication_graph[node]: if neighbor not in indices: tarjan_scc(neighbor) lowlinks[node] = min(lowlinks[node], lowlinks[neighbor]) elif on_stack[neighbor]: lowlinks[node] = min(lowlinks[node], indices[neighbor]) if lowlinks[node] == indices[node]: scc = [] while True: w = stack.pop() on_stack[w] = False scc.append(w) component[w] = node if w == node: break strongly_connected_components.append(scc) variables = set() for clause in formula: for literal in clause: variables.add(literal[0]) implication_graph = defaultdict(list) for (a, v1), (b, v2) in formula: add_edge(implication_graph, (a, not v1), (b, v2)) add_edge(implication_graph, (b, not v2), (a, v1)) indices = {} lowlinks = {} on_stack = {} stack = [] index = 0 component = {} strongly_connected_components = [] for variable in variables: if (variable, True) not in indices: tarjan_scc((variable, True)) if (variable, False) not in indices: tarjan_scc((variable, False)) assignment = {} for variable in variables: if component[(variable, True)] == component[(variable, False)]: return None assignment[variable] = component[(variable, True)] > component[(variable, False)] return assignment"},{"question":"# Scenario/Context You are hired by a software company that develops a text editor with advanced search functionality. One of the features the company wants to implement is the ability to determine if one text snippet is a rotated version of another text snippet. This can be useful in various text manipulation and comparison tasks within the editor. # Task Write a function called `is_rotated` that takes two strings `s1` and `s2` and returns a boolean value indicating whether `s2` is a rotated version of `s1`. # Function Signature ```python def is_rotated(s1: str, s2: str) -> bool: # Your implementation here ``` # Input - `s1`: A string containing the original text snippet. (1 <= len(s1) <= 1000) - `s2`: A string containing the text snippet to be checked. (1 <= len(s2) <= 1000) # Output - Returns `True` if `s2` is a rotated version of `s1`, otherwise returns `False`. # Constraints - You must not use built-in functions like `collections.deque` or similar. - Optimize for time and space complexity. # Examples ```python assert is_rotated(\\"hello\\", \\"llohe\\") == True # Rotation example assert is_rotated(\\"hello\\", \\"helol\\") == False # Non-rotation example assert is_rotated(\\"abcde\\", \\"cdeab\\") == True # Rotation example assert is_rotated(\\"abcde\\", \\"edcba\\") == False # Non-rotation example assert is_rotated(\\"\\", \\"\\") == True # Both empty, edge case assert is_rotated(\\"a\\", \\"a\\") == True # Single character, edge case assert is_rotated(\\"abcd\\", \\"dabc\\") == True # Rotation example assert is_rotated(\\"abcd\\", \\"abdc\\") == False # Characters same but not rotation ``` # Notes - Thoroughly test your implementation to handle various edge cases, such as empty strings, single character strings, and different length strings. - Ensure the implementation is efficient and readable.","solution":"def is_rotated(s1: str, s2: str) -> bool: Determines if s2 is a rotated version of s1. # If lengths are not equal, s2 cannot be a rotation of s1 if len(s1) != len(s2): return False # Concatenate s1 with itself and check if s2 is a substring of this result return s2 in (s1 + s1)"},{"question":"# Maximum Depth of Binary Tree **Context**: You are given a binary tree representing the organizational chart of a company. Your task is to determine the maximum depth of this tree, which corresponds to the longest path from the CEO (root node) to an employee with no subordinates (leaf node). **Function Signature**: ```python def max_depth(root: TreeNode) -> int: pass ``` **Input**: - `root`: The root node of a binary tree (instance of `TreeNode` class). **Output**: - `int`: An integer representing the maximum depth of the binary tree. **Constraints**: - The number of nodes in the tree is in the range [0, 10^4]. - The value of each node is a unique integer. - Nodes may have 0, 1, or 2 children. **Requirements**: - Implement an iterative solution to find the maximum depth of the binary tree using breadth-first search (BFS). - Ensure your solution efficiently handles wide trees. **Example**: ```python # Definition for a binary tree node. class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right tree = TreeNode(1) tree.left = TreeNode(2) tree.right = TreeNode(3) tree.left.left = TreeNode(4) tree.left.right = TreeNode(5) tree.right.right = TreeNode(6) assert max_depth(tree) == 3 tree = TreeNode(1) assert max_depth(tree) == 1 tree = None assert max_depth(tree) == 0 ```","solution":"from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def max_depth(root: TreeNode) -> int: if not root: return 0 queue = deque([root]) depth = 0 while queue: depth += 1 level_length = len(queue) for _ in range(level_length): node = queue.popleft() if node.left: queue.append(node.left) if node.right: queue.append(node.right) return depth"},{"question":"Efficient Exponential Computation Given the need to compute large powers efficiently, you are tasked with implementing the following: 1. An iterative function for binary exponentiation. 2. A recursive function for binary exponentiation with an emphasis on handling large exponents and optional modular operations. # Requirements - Implement the iterative version of binary exponentiation (`power_iter`). - Implement the recursive version of binary exponentiation (`power_recur`). - Both functions should have options to handle modulo operations for large exponents. # Function Specifications Function 1: `power_iter` - **Input**: Three integers `a`, `n`, and an optional `mod` (default to `None`). - **Output**: Compute ( a^n ); if `mod` is provided, return the result modulo `mod`. - **Time Complexity**: O(log(n)) - **Space Complexity**: O(1) Function 2: `power_recur` - **Input**: Three integers `a`, `n`, and an optional `mod` (default to `None`). - **Output**: Compute ( a^n ); if `mod` is provided, return the result modulo `mod`. - **Time Complexity**: O(log(n)) - **Space Complexity**: O(log(n)) # Constraints - (1 leq a leq 10^9) - (0 leq n leq 10^9) - If `mod` is provided, (1 leq mod leq 10^9) # Example ```python # Output: 1024 print(power_iter(2, 10)) # Output: 24 (Because 2^10 % 1000 = 24) print(power_iter(2, 10, 1000)) # Output: 1024 print(power_recur(2, 10)) # Output: 24 (Because 2^10 % 1000 = 24) print(power_recur(2, 10, 1000)) ``` # Edge Cases to Consider - ( a = 0 ) and ( n = 0 ) should return 1. - Large values of ( n ) to trigger deep recursion and test performance. - Modulo operations with large numbers. Your implementation will be graded on correctness, efficiency, and handling of edge cases.","solution":"def power_iter(a, n, mod=None): Compute a^n using iterative binary exponentiation. If mod is provided, the result will be returned modulo mod. result = 1 base = a % mod if mod else a while n > 0: if n % 2 == 1: # If n is odd, multiply by the base result = (result * base) % mod if mod else result * base base = (base * base) % mod if mod else base * base n //= 2 return result def power_recur(a, n, mod=None): Compute a^n using recursive binary exponentiation. If mod is provided, the result will be returned modulo mod. if n == 0: return 1 half_power = power_recur(a, n // 2, mod) half_power = (half_power * half_power) % mod if mod else half_power * half_power if n % 2 == 0: return half_power else: result = (half_power * a) % mod if mod else half_power * a return result"},{"question":"**Problem Description**: You are required to implement a sorting function using the Radix Sort algorithm. The function must be capable of sorting a list of non-negative integers. The function should additionally support a simulation mode that prints the state of the list after each sorting pass. **Function Signature**: ```python def radix_sort(arr: List[int], simulation: bool = False) -> List[int]: ``` **Inputs**: - `arr (List[int])`: A list of non-negative integers to be sorted. - `simulation (bool)`: An optional flag that when set to `True`, will print the state of the list after each pass of digit-based sorting. **Outputs**: - Returns the sorted list of integers. **Constraints**: - The input list can have up to 10^6 elements. - Each number in the list can have up to 9 digits. - You must implement the function without relying on built-in sorting functions. **Performance Requirements**: - Ensure the function operates with a time complexity of O(nk) and space complexity of O(n), where n is the number of elements and k is the maximum number of digits. **Scenario**: A company uses a unique ID system based on numerical codes for tracking products in their inventory. These codes are large non-negative integers. Your task is to implement a sorting mechanism for the IDs using Radix Sort to help the inventory management team quickly sort and search through the product records. **Example**: ```python ids = [170, 45, 75, 90, 802, 24, 2, 66] sorted_ids = radix_sort(ids, simulation=True) print(\\"Sorted IDs:\\", sorted_ids) ``` Expected Output: ``` iteration 0 : 170 45 75 90 802 24 2 66 iteration 1 : 170 90 802 2 24 45 75 66 iteration 2 : 2 24 45 66 75 90 170 802 Sorted IDs: [2, 24, 45, 66, 75, 90, 170, 802] ``` Ensure that your implementation handles edge cases effectively, including lists with one element, already sorted lists, and lists containing duplicate elements.","solution":"from typing import List def counting_sort(arr: List[int], exp: int, simulation: bool, iteration: int) -> List[int]: n = len(arr) output = [0] * n # output array to store sorted numbers count = [0] * 10 # count array to store occurrences of digits # Store count of occurrences in the count array for i in range(n): index = (arr[i] // exp) % 10 count[index] += 1 # Change count so that count contains the actual position of digit in output array for i in range(1, 10): count[i] += count[i - 1] # Build the output array for i in range(n - 1, -1, -1): index = (arr[i] // exp) % 10 output[count[index] - 1] = arr[i] count[index] -= 1 # Copy the output array to arr, so that arr contains sorted numbers according to the current digit for i in range(n): arr[i] = output[i] if simulation: print(f\\"iteration {iteration} : {\' \'.join(map(str, arr))}\\") return arr def radix_sort(arr: List[int], simulation: bool = False) -> List[int]: if len(arr) == 0: return arr # Find the maximum number to know the number of digits max_val = max(arr) # Initialize the iteration count iteration = 0 # Apply counting sort to sort elements based on place value exp = 1 while max_val // exp > 0: arr = counting_sort(arr, exp, simulation, iteration) exp *= 10 iteration += 1 return arr"},{"question":"# Question: Implementing and Utilizing Kosaraju\'s Algorithm You are given the task of determining the number of strongly connected components (SCCs) in a directed graph using Kosaraju\'s algorithm. Kosaraju\'s algorithm follows these steps: 1. Perform a DFS on the original graph to calculate the finish times of all vertices. 2. Transpose the graph (reverse the direction of all edges). 3. Perform a DFS on the transposed graph, processing vertices in decreasing order of their finish times (from the first DFS). Each DFS call in this phase identifies one SCC. Your task is to implement the Kosaraju\'s algorithm to find the number of SCCs in a directed graph. Function Signature ```python def kosaraju_scc_count(V: int, edges: List[Tuple[int, int]]) -> int: pass ``` Input * `V` (int): Number of vertices in the graph (0-based index, 1 <= V <= 10^4). * `edges` (List[Tuple[int, int]]): List of directed edges in the graph, where each edge is represented as a tuple `(u, v)` indicating a directed edge from vertex `u` to vertex `v`. Output * `int`: The number of strongly connected components in the given directed graph. Constraints * The edges are directed. * The graph does not contain multiple edges or self-loops. Example ```python >>> V = 6 >>> edges = [(0, 2), (1, 0), (2, 3), (3, 1), (3, 4), (4, 5), (5, 4)] >>> kosaraju_scc_count(V, edges) 2 ``` * In this example, the graph has 6 vertices and 7 edges. * The output is `2`, indicating that there are 2 strongly connected components in the given graph: 1. The first SCC includes vertices `{0, 1, 2, 3}`. 2. The second SCC includes vertices `{4, 5}`. Note Implement the `kosaraju_scc_count` function as described to solve the problem. Ensure your code is efficient and can handle the upper limits of the constraints.","solution":"from typing import List, Tuple def kosaraju_scc_count(V: int, edges: List[Tuple[int, int]]) -> int: def dfs(graph, v, visited, stack=None): visited[v] = True for neighbour in graph[v]: if not visited[neighbour]: dfs(graph, neighbour, visited, stack) if stack is not None: stack.append(v) def transpose_graph(graph): transposed = [[] for _ in range(V)] for v in range(V): for neighbour in graph[v]: transposed[neighbour].append(v) return transposed graph = [[] for _ in range(V)] for u, v in edges: graph[u].append(v) visited = [False] * V finish_stack = [] for i in range(V): if not visited[i]: dfs(graph, i, visited, finish_stack) transposed_graph = transpose_graph(graph) visited = [False] * V scc_count = 0 while finish_stack: v = finish_stack.pop() if not visited[v]: dfs(transposed_graph, v, visited) scc_count += 1 return scc_count"},{"question":"# Question: Implement Enhanced Binary Search As a software engineer at a tech company, you are tasked with creating an optimized search module. Your module will be part of a larger application that frequently searches sorted arrays for specific values. To maximize the performance of your search operation, you decide to implement both iterative and recursive versions of the Binary Search algorithm. Instructions: 1. **Iterative Binary Search**: - **Function Name**: `iterative_binary_search` - **Input**: A sorted list of integers `array`, and an integer `query`. - **Output**: The index of `query` in `array` if it exists, otherwise `None`. 2. **Recursive Binary Search**: - **Function Name**: `recursive_binary_search` - **Input**: A sorted list of integers `array`, an integer `low`, an integer `high`, and an integer `query`. - **Output**: The index of `query` in `array` if it exists, otherwise `None`. Constraints: - The input list `array` is sorted in ascending order. - You must handle edge cases such as an empty array and values not present in the array. - Optimize for both time and space complexity as discussed in the analysis. Example: ```python array = [1, 3, 5, 7, 9, 11] query = 5 # For iterative_binary_search(array, query), the output should be 2 # For recursive_binary_search(array, 0, len(array) - 1, query), the output should be 2 query = 10 # For iterative_binary_search(array, query), the output should be None # For recursive_binary_search(array, 0, len(array) - 1, query), the output should be None ``` Code Template: ```python def iterative_binary_search(array, query): # Your implementation here pass def recursive_binary_search(array, low, high, query): # Your implementation here pass ``` Write the implementation for both functions considering the analysis provided. Ensure you handle edge cases and optimize your solution for performance.","solution":"def iterative_binary_search(array, query): Performs an iterative binary search on the sorted array to find the query. :param array: List[int] - A sorted list of integers. :param query: int - The integer to search for. :return: int or None - The index of the query in the array if found, otherwise None. low, high = 0, len(array) - 1 while low <= high: mid = (low + high) // 2 if array[mid] == query: return mid elif array[mid] < query: low = mid + 1 else: high = mid - 1 return None def recursive_binary_search(array, low, high, query): Performs a recursive binary search on the sorted array to find the query. :param array: List[int] - A sorted list of integers. :param low: int - The lower index of the current subarray. :param high: int - The upper index of the current subarray. :param query: int - The integer to search for. :return: int or None - The index of the query in the array if found, otherwise None. if low > high: return None mid = (low + high) // 2 if array[mid] == query: return mid elif array[mid] < query: return recursive_binary_search(array, mid + 1, high, query) else: return recursive_binary_search(array, low, mid - 1, query)"},{"question":"# Topological Sorting of Courses Given a list of courses and their prerequisite relationships, implement a function `topo_sort_courses` to determine a valid order in which courses can be completed. Each course is represented by an integer (from 0 to n-1), and prerequisites are given as a list of pairs where the pair `(a, b)` denotes that course `a` must be completed before course `b`. **Function Signature** ```python def topo_sort_courses(num_courses: int, prerequisites: List[Tuple[int, int]]) -> List[int]: pass ``` **Parameters** - `num_courses` (int): The total number of courses. - `prerequisites` (List[Tuple[int, int]]): A list of prerequisite pairs. **Returns** - `List[int]`: A list of course numbers representing the topologically sorted order. If there are multiple valid orders, return any one of them. If no valid ordering exists (due to cycles), return an empty list. **Constraints** - 1 ≤ `num_courses` ≤ 10^4 - 0 ≤ `len(prerequisites)` ≤ (num_courses * (num_courses - 1) // 2) **Example** ```python # Example 1 num_courses = 4 prerequisites = [(1, 0), (2, 1), (3, 2)] print(topo_sort_courses(num_courses, prerequisites)) # Output: [0, 1, 2, 3] # Example 2 num_courses = 2 prerequisites = [(1, 0), (0, 1)] print(topo_sort_courses(num_courses, prerequisites)) # Output: [] (as there is a cycle) ``` **Hint** - You can use either DFS-based topological sorting or Kahn’s Algorithm (BFS-based topological sorting). - Consider edge cases such as cycles and disconnected components.","solution":"from typing import List, Tuple from collections import defaultdict, deque def topo_sort_courses(num_courses: int, prerequisites: List[Tuple[int, int]]) -> List[int]: # Create a graph as an adjacency list and an array to count indegrees graph = defaultdict(list) indegree = [0] * num_courses # Build the graph and populate indegrees for dest, src in prerequisites: graph[src].append(dest) indegree[dest] += 1 # Queue for courses with no incoming edges queue = deque([i for i in range(num_courses) if indegree[i] == 0]) topo_order = [] while queue: course = queue.popleft() topo_order.append(course) # Decrease indegree of neighboring nodes for neighbor in graph[course]: indegree[neighbor] -= 1 if indegree[neighbor] == 0: queue.append(neighbor) # If topo_order contains all courses, we have a valid ordering return topo_order if len(topo_order) == num_courses else []"},{"question":"You are tasked with implementing a function to determine if a directed graph contains any cycles. The graph is represented as a dictionary where keys are vertex labels and values are lists of adjacent vertices. # Function Signature ```python def contains_cycle(graph: Dict[str, List[str]]) -> bool: pass ``` # Input - `graph`: A dictionary representing the directed graph. Keys are vertex labels (strings) and values are lists of labels (strings) indicating adjacent vertices. # Output - Returns `True` if the graph contains a cycle, otherwise returns `False`. # Constraints - Vertices are represented by unique strings. - The graph can have up to 1000 vertices and 5000 edges. # Performance Requirements - Time complexity should be O(V + E). - Space complexity should be O(V). # Example ```python graph1 = { \'A\': [\'B\', \'C\'], \'B\': [\'D\'], \'C\': [\'F\'], \'D\': [\'E\', \'F\'], \'E\': [\'B\'], \'F\': [] } assert contains_cycle(graph1) == True graph2 = { \'A\': [\'B\'], \'B\': [], } assert contains_cycle(graph2) == False ``` # Context This problem emulates the scenario of detecting deadlocks in a system where processes and locks can be modeled as a directed graph. Each node represents a process or lock, and a directed edge from A to B indicates that A is waiting for B.","solution":"def contains_cycle(graph): Determines if the directed graph contains a cycle. Args: graph (dict): A dictionary representing the directed graph where keys are vertex labels and values are lists of adjacent vertices. Returns: bool: True if there is a cycle in the graph, False otherwise. visited = set() rec_stack = set() def visit(vertex): if vertex in rec_stack: return True if vertex in visited: return False visited.add(vertex) rec_stack.add(vertex) for neighbor in graph.get(vertex, []): if visit(neighbor): return True rec_stack.remove(vertex) return False for node in graph: if visit(node): return True return False"},{"question":"You are tasked with implementing a function that computes the factorial of a given non-negative integer `n`, potentially using modular arithmetic for large results. The function should be optimized for performance and handle edge cases effectively. **Function Signature** ```python def compute_factorial(n: int, mod: int = None) -> int: ``` **Input** * `n` (int): A non-negative integer (0 ≤ `n` ≤ 10^5). * `mod` (int, optional): A positive integer to compute the result modulo `mod`. If `mod` is not provided, return the factorial as is. **Output** * Returns the factorial of `n`. If `mod` is provided, return the result of the factorial modulo `mod`. **Constraints** * `n` is guaranteed to be a non-negative integer. * `mod` is a positive integer if provided. **Examples** ```python print(compute_factorial(5)) # Output: 120 print(compute_factorial(5, 13)) # Output: 3 (because 120 % 13 is 3) print(compute_factorial(0)) # Output: 1 print(compute_factorial(10, 1000)) # Output: 800 ``` **Additional Requirements** 1. Optimize for large values of `n`. Ensure that your solution handles up to `n = 10^5` efficiently. 2. Your solution should include edge case handling: * `n = 0` * Large values of `n` with a corresponding `mod`. **Explanation** * Ensure your function handles the base case where `n` is 0 (i.e., factorial(0) = 1). * Take care of boundaries when computing large factorials with `mod`.","solution":"def compute_factorial(n: int, mod: int = None) -> int: Computes the factorial of a given non-negative integer n. If mod is provided, computes the result modulo mod. if n == 0: return 1 factorial = 1 for i in range(1, n + 1): factorial *= i if mod: factorial %= mod return factorial"},{"question":"# Question: Enhanced Binary Exponentiation You are developing a library for performing various mathematical operations efficiently. One of the key operations is exponentiation. Your task is to implement two functions that efficiently compute the power of a number using binary exponentiation. Additionally, you need to handle the modulus operation if specified. **Function Definitions:** 1. `def power(a: int, n: int, mod: int = None) -> int:` - **Parameters**: - `a` (int): The base number. - `n` (int): The exponent. - `mod` (int, optional): The modulus. - **Returns**: The value of ( a^n ) (or ( a^n mod text{mod} ) if `mod` is specified). 2. `def power_recur(a: int, n: int, mod: int = None) -> int:` - **Parameters**: - `a` (int): The base number. - `n` (int): The exponent. - `mod` (int, optional): The modulus. - **Returns**: The value of ( a^n ) (or ( a^n mod text{mod} ) if `mod` is specified). **Performance Requirements**: - **Time Complexity**: Both functions should have a time complexity of ( O(log n) ). - **Space Complexity**: - `power` should use ( O(1) ) space. - `power_recur` should use ( O(log n) ) space due to recursion stack. **Constraints**: - `1 <= a <= 10^9` - `0 <= n <= 10^9` - `1 <= mod <= 10^9` (if specified) **Example Usage and Edge Cases**: 1. `power(2, 10)` should return `1024`. 2. `power(2, 10, 1000)` should return `24`. 3. `power(0, 0)` should return `1` (by convention). 4. `power(5, 0)` should return `1`. 5. `power(5, 1)` should return `5`. Implement both versions of the binary exponentiation function.","solution":"def power(a: int, n: int, mod: int = None) -> int: Iterative function to calculate a^n using binary exponentiation. If mod is specified, computes (a^n) % mod. result = 1 base = a if mod is None else a % mod while n > 0: if n % 2 == 1: result = result * base if mod is None else (result * base) % mod base = base * base if mod is None else (base * base) % mod n //= 2 return result def power_recur(a: int, n: int, mod: int = None, result: int = 1) -> int: Recursive function to calculate a^n using binary exponentiation. If mod is specified, computes (a^n) % mod. if n == 0: return result base = a if mod is None else a % mod if n % 2 == 1: result = result * base if mod is None else (result * base) % mod return power_recur(base * base if mod is None else (base * base) % mod, n // 2, mod, result)"},{"question":"Efficient Recap of Overlapping Array Segments Context: In this task, your goal is to demonstrate a deep understanding of recursive sorting algorithms by implementing an efficient variant of the Stooge Sort. Stooge Sort divides the array into overlapping segments and sorts them multiple times, lingering with inefficiencies. Objective: Write a function `efficient_stoogesort` that efficiently sorts an array by modifying the recursive Stooge Sort approach to minimize redundant operations. Requirements: - Without sacrificing correctness, improve the traditional Stooge Sort to avoid sorting already sorted segments. - Ensure the function requires fewer recursive calls and completes faster on average datasets. Specification: - **Function name**: `efficient_stoogesort` - **Inputs**: - `arr`: List[int] - A list containing the elements to be sorted - `l`: int - Start index of the list segment to be sorted - `h`: int - End index of the list segment to be sorted - **Output**: - The function should sort the `arr` in place and not return any value Constraints: - The array will consist of up to `1000` elements. - Elements of the array can range between `-10^6` and `10^6`. Example: ```python arr = [3, 5, 2, 9, 1, 8, -3] efficient_stoogesort(arr, 0, len(arr) - 1) print(arr) # Output should be [-3, 1, 2, 3, 5, 8, 9] ``` Notes: - Consider using optional checks to determine if a segment of the array is already sorted to avoid unnecessary recursive calls. - Your implementation should showcase thoughtful handling of edge cases.","solution":"def efficient_stoogesort(arr, l, h): Performs an efficient variant of the Stooge Sort on the given array segment. if l >= h: return if arr[l] > arr[h]: arr[l], arr[h] = arr[h], arr[l] if h - l + 1 > 2: t = (h - l + 1) // 3 efficient_stoogesort(arr, l, h - t) efficient_stoogesort(arr, l + t, h) efficient_stoogesort(arr, l, h - t)"},{"question":"Sorting Phone Numbers by Length and Value In a phone directory application, you are tasked with sorting a list of phone numbers. Each phone number is represented as an integer. The phone numbers should be sorted first by the number of digits (ascending order), then by their actual values (ascending order). Write a function `sort_phone_numbers` that takes a list of phone numbers and returns the list sorted as described. Function Signature ```python def sort_phone_numbers(phone_numbers: List[int]) -> List[int]: ``` Input - `phone_numbers` (List[int]): A list of integers representing phone numbers. Output - (List[int]): A list of integers sorted first by the number of digits, then by their values. Example ```python input: [123, 4, 56, 789, 0, 34] output: [0, 4, 34, 56, 123, 789] ``` Constraints - The length of the list `phone_numbers` will not exceed `10^6`. - Each phone number is a non-negative integer. Performance Requirements - The solution should have an average-case time complexity of O(nk), where n is the number of phone numbers and k is the maximum number of digits in the largest phone number. Scenario Consider a phone directory system where you are handling thousands of phone numbers that users input daily. Efficiently sorting these numbers is crucial for quick lookups, generating ordered reports, and performing batch updates. Implementing an efficient sorting algorithm helps in maintaining the performance of the directory system. Implementation Notes - Your implementation should simulate the Radix Sort algorithm for ensuring the sorting by digit length and value. - Ensure the use of stable sorting at intermediate steps to maintain the order of phone numbers with the same number of digits.","solution":"from typing import List def sort_phone_numbers(phone_numbers: List[int]) -> List[int]: return sorted(phone_numbers, key=lambda x: (len(str(x)), x))"},{"question":"# Question: Range Minimum Query with Updates using Segment Tree **Context**: You are working as a software developer for a large-scale data analysis company. Your next task involves implementing a utility function that will help efficiently perform range minimum queries and updates on an array. **Objective**: You are required to implement a segment tree to support the following operations: 1. **Build Tree**: Initialize the segment tree with an array of integers. 2. **Range Minimum Query**: Query the minimum value within a specified range in the array. 3. **Update Element**: Update a specific element in the array and reflect this change in the segment tree. # Task: Implement a class `MinSegmentTree` with the following methods: 1. **`__init__(self, arr: List[int])`**: Initializes the segment tree with the given array `arr`. 2. **`query(self, L: int, R: int) -> int`**: Returns the minimum value in the range `[L, R]`, inclusive. 3. **`update(self, idx: int, value: int)`**: Updates the value at index `idx` to `value` and updates the segment tree accordingly. # Constraints: - Each element in the array is an integer within the range -10^9 to 10^9. - The length of the array will be in the range [1, 10^5]. - Queries and updates will be made such that 0 <= idx < len(arr) and 0 <= L <= R < len(arr). # Example: ```python # Initialize the segment tree min_tree = MinSegmentTree([4, 7, 3, 9, 1, 2, 6]) # Query minimum value between indices 2 and 5 result = min_tree.query(2, 5) print(result) # Output: 1 # Update the value at index 3 to 0 min_tree.update(3, 0) # Query again after the update result = min_tree.query(2, 5) print(result) # Output: 0 ``` **Notes**: - Your implementation should focus on efficiency, aiming for a time complexity of O(log N) for query and update operations. - You may assume there are at least one query and one update operation performed after initialization.","solution":"class MinSegmentTree: def __init__(self, arr): self.n = len(arr) self.tree = [0] * (2 * self.n) self.build(arr) def build(self, arr): for i in range(self.n): self.tree[self.n + i] = arr[i] for i in range(self.n - 1, 0, -1): self.tree[i] = min(self.tree[2 * i], self.tree[2 * i + 1]) def query(self, L, R): L += self.n R += self.n min_val = float(\'inf\') while L <= R: if L % 2 == 1: min_val = min(min_val, self.tree[L]) L += 1 if R % 2 == 0: min_val = min(min_val, self.tree[R]) R -= 1 L //= 2 R //= 2 return min_val def update(self, idx, value): idx += self.n self.tree[idx] = value while idx > 1: idx //= 2 self.tree[idx] = min(self.tree[2 * idx], self.tree[2 * idx + 1])"},{"question":"# Comb Sort Implementation and Analysis Comb Sort is a sorting algorithm that improves on bubble sort by using a larger gap between compared elements for the initial passes. This helps to eliminate small values initially stuck far to the right, keeping the smaller elements at the front after an initial pass. It gradually reduces its gap and completes using bubble sort for the final pass. You are required to implement the `comb_sort` function and make enhancements in such a way that it meets the performance criteria. Given below are the tasks you need to accomplish: 1. **Implement the Comb Sort algorithm**: Write a function `comb_sort(arr)` to sort an array of integers using the comb sort algorithm provided. 2. **Optimize the shrinking factor**: Evaluate different shrinking factors to determine the optimal one for improved performance. 3. **Edge Case Handling**: Ensure that your implementation handles arrays with duplicate values and already sorted arrays efficiently. 4. **Performance Evaluation**: Given the worst-case time complexity of O(N^2), write a brief explanation in comments discussing how you could improve or optimize further if needed. # Function Signature ```python def comb_sort(arr: List[int]) -> List[int]: pass ``` # Input * `arr`: A list of integers. # Output * Return the sorted list of integers. # Constraints * Example: Array of integers in no specific order [e.g., large values, small values, duplicates] * Performance: Explain how your code executes in average and worst cases. # Example ```python # Example usage numbers = [3, 5, 2, 8, 1, 4] sorted_numbers = comb_sort(numbers) print(sorted_numbers) # Output should be [1, 2, 3, 4, 5, 8] numbers = [10, -1, 2, 5, 0, 2, 3, 3, 1] sorted_numbers = comb_sort(numbers) print(sorted_numbers) # Output should be [-1, 0, 1, 2, 2, 3, 3, 5, 10] ``` Note: Focus on optimizing the shrink factor for better performance.","solution":"def comb_sort(arr): Sorts a list of integers using the comb sort algorithm. :param arr: List[int], a list of integers. :return: List[int], the sorted list of integers. n = len(arr) gap = n shrink = 1.3 # A common and effective shrink factor for comb sort sorted = False while not sorted: # Update the gap value for next comb act gap = int(gap / shrink) if gap <= 1: gap = 1 sorted = True # If the gap is 1, this means last run # A single \\"comb\\" over the list for i in range(n - gap): if arr[i] > arr[i + gap]: arr[i], arr[i + gap] = arr[i + gap], arr[i] sorted = False # We are not fully sorted yet return arr # Average and worst-case performance explanation: # Average case: The average case performance of Comb Sort is generally better than # bubble sort and insertion sort, but still O(N^2). The gap shrinkage helps eliminate # small values that may take many swaps to move in bubble sort. # # Worst case: Comb Sort has a worst-case time complexity of O(N^2) similar to bubble sort since # in the worst case, it essentially behaves similarly but with larger initial steps. # # Optimizations: The chosen shrink factor (1.3) is widely considered one of the most effective. # Further improvements could involve experimenting with different forms of gap shrinkage or switching # to a more efficient algorithm like Quick Sort or Merge Sort once the gap reduces to a certain size."},{"question":"# Inorder Binary Tree Traversal Challenge You are given a binary tree, and your task is to implement two functions to perform an inorder traversal (left subtree, root, right subtree) of the tree. One function should be iterative, and the other one should be recursive. Write the functions as specified below: # Function Signatures ```python def inorder_iterative(root: Node) -> List[int]: pass def inorder_recursive(root: Node) -> List[int]: pass ``` # Input Format: - `root`: The root node of a binary tree. A `Node` class is defined, where each `Node` has attributes: * `val` (int): the value of the node. * `left` (Node, optional): reference to the left child node. * `right` (Node, optional): reference to the right child node. # Output Format: - Return a list of integers representing the inorder traversal of the binary tree. # Constraints: - The number of nodes in the tree will not exceed 10^4. - Node values are unique integers. # Example: Input: ```python # Binary Tree: # 1 # / # 2 3 # / # 4 5 n1 = Node(1) n2 = Node(2) n3 = Node(3) n4 = Node(4) n5 = Node(5) n1.left = n2 n1.right = n3 n2.left = n4 n2.right = n5 ``` Output: ```python inorder_iterative(n1) # Expected output: [4, 2, 5, 1, 3] inorder_recursive(n1) # Expected output: [4, 2, 5, 1, 3] ``` # Implementation Ensure to handle cases like empty trees, single-node trees, and trees with only left or right subtrees in your solution.","solution":"class Node: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def inorder_iterative(root: Node) -> list[int]: result = [] stack = [] current = root while current is not None or stack: while current is not None: stack.append(current) current = current.left current = stack.pop() result.append(current.val) current = current.right return result def inorder_recursive(root: Node) -> list[int]: def helper(node: Node, res: list[int]): if node: helper(node.left, res) res.append(node.val) helper(node.right, res) result = [] helper(root, result) return result"},{"question":"Maximum Subarray Sum using Kadane\'s Algorithm Context You are given a list of integers representing daily net profits from a series of investments. Your task is to determine the maximum sum of a contiguous subarray, essentially identifying the period where cumulative profit is maximized. This will help in finding the most profitable period in the given dataset. Task Write a function `max_subarray_profit(profits)` that implements Kadane\'s Algorithm to find and return the maximum subarray sum in a list of integers `profits`. Input - A list of integers `profits` where each integer represents the net profit for a day. The list has at least one element and can contain both positive and negative numbers. Output - An integer, the maximum sum of a contiguous subarray. Constraints - The size of `profits` will not exceed 10^5. - The values in `profits` will be in the range of -10^4 to 10^4. Example ```python print(max_subarray_profit([1, 2, -3, 4, 5, -7, 23])) # Output: 25 print(max_subarray_profit([-8, -3, -6, -2, -5, -4])) # Output: -2 print(max_subarray_profit([0, -1, 2, 3, -5, 7])) # Output: 7 ``` Explanation - In the first example, the subarray [4, 5, -7, 23] produces the maximum sum of 25. - In the second example, the subarray consists of only the element -2 as it is the highest among all negative numbers. - In the third example, the subarray [7] produces the maximum sum of 7.","solution":"def max_subarray_profit(profits): Implements Kadane\'s Algorithm to find the maximum subarray sum. :param profits: List of integers representing daily net profits. :return: Integer representing the maximum sum of a contiguous subarray. max_current = max_global = profits[0] for profit in profits[1:]: max_current = max(profit, max_current + profit) if max_current > max_global: max_global = max_current return max_global"},{"question":"# String Search: Implementing Efficient Substring Search Scenario A text processing software needs an optimized way to search for a word (or substring) within lengthy documents. The current implementation is not efficient enough, especially when dealing with large inputs. As a result, you need to design a faster algorithm to find the first occurrence of a word (needle) within a piece of text (haystack). Task Write a function `find_needle(haystack, needle)` that efficiently finds the starting index of the first occurrence of `needle` in `haystack`. If `needle` is not part of `haystack`, return -1. Function Signature ```python def find_needle(haystack: str, needle: str) -> int: ``` Input * `haystack` (str): The text in which to search; length N (1 ≤ N ≤ 10^5). * `needle` (str): The word to be searched for; length M (0 ≤ M ≤ 10^5). Output * The starting index of the first occurrence of `needle` in `haystack`, or -1 if `needle` is not part of `haystack`. Constraints * The function must handle edge cases efficiently. * Aim for a time complexity lower than O(N*M). * Think about the trade-off between complexity and simplicity. Consider algorithms like KMP or Boyer-Moore for optimization. Examples ```plaintext Example 1: Input: haystack = \\"hello\\", needle = \\"ll\\" Output: 2 Example 2: Input: haystack = \\"aaaaa\\", needle = \\"bba\\" Output: -1 Example 3: Input: haystack = \\"abc\\", needle = \\"\\" Output: 0 Example 4: Input: haystack = \\"a\\" * 10^5, needle = \\"a\\" * (10^5 - 1) + \\"b\\" Output: -1 ```","solution":"def find_needle(haystack: str, needle: str) -> int: Finds the starting index of the first occurrence of needle in haystack. If needle is not part of haystack, returns -1. if not needle: return 0 # Implementing KMP (Knuth-Morris-Pratt) algorithm for efficient substring search def kmp_failure_function(needle): Preprocesses the needle and returns the failure function for the KMP algorithm. failure = [0] * len(needle) j = 0 for i in range(1, len(needle)): if needle[i] == needle[j]: j += 1 failure[i] = j else: if j != 0: j = failure[j - 1] i -= 1 # Since i will be incremented in next iteration else: failure[i] = 0 return failure def kmp_search(haystack, needle): Searches the needle in haystack using the KMP algorithm. n = len(haystack) m = len(needle) failure = kmp_failure_function(needle) i = 0 # index for haystack j = 0 # index for needle while i < n: if needle[j] == haystack[i]: i += 1 j += 1 if j == m: return i - j elif i < n and needle[j] != haystack[i]: if j != 0: j = failure[j - 1] else: i += 1 return -1 # Using KMP search function to find the first occurrence of needle in haystack return kmp_search(haystack, needle)"},{"question":"# String Merge Checker Objective Your task is to implement a function `is_merge_dp` that checks if a given string `s` can be formed by merging two other strings `part1` and `part2`. The characters from `part1` and `part2` should maintain their relative order in `s`. Function Signature ```python def is_merge_dp(s: str, part1: str, part2: str) -> bool: pass ``` Input - `s` (1 ≤ |s| ≤ 1000): A string to be checked. - `part1` (0 ≤ |part1| ≤ 1000): A string representing part of the characters of `s`. - `part2` (0 ≤ |part2| ≤ 1000): Another string representing the rest of the characters in `s`. Output - Return a boolean value: - `True`: If `s` can be formed by merging `part1` and `part2`. - `False`: Otherwise. Constraints - Characters in `part1` and `part2` should maintain their original order in `s`. - `|part1| + |part2|` should equal `|s|`. Example ```plaintext is_merge_dp(\\"codewars\\", \\"cdw\\", \\"oears\\") -> True is_merge_dp(\\"abc\\", \\"ab\\", \\"cd\\") -> False is_merge_dp(\\"\\", \\"\\", \\"\\") -> True is_merge_dp(\\"abc\\", \\"\\", \\"abc\\") -> True ``` Notes - Ensure your implementation is efficient in both time and space. - Consider edge cases, such as empty strings and large inputs. **Good Luck!**","solution":"def is_merge_dp(s: str, part1: str, part2: str) -> bool: Checks if the string s can be formed by merging part1 and part2 while maintaining their relative order in s. len_s, len1, len2 = len(s), len(part1), len(part2) if len1 + len2 != len_s: return False dp = [[False] * (len2 + 1) for _ in range(len1 + 1)] dp[0][0] = True for i in range(len1 + 1): for j in range(len2 + 1): if i > 0 and dp[i - 1][j] and s[i + j - 1] == part1[i - 1]: dp[i][j] = True if j > 0 and dp[i][j - 1] and s[i + j - 1] == part2[j - 1]: dp[i][j] = True return dp[len1][len2]"},{"question":"# URL Parameter Stripping and Deduplication **Objective**: Write a function to clean a URL by removing duplicate query parameters and optionally stripping out specified parameters. **Function Signature**: ```python def strip_url_params(url: str, params_to_strip: List[str] = []) -> str: pass ``` **Parameters**: - `url` (str): The URL string to be processed. It may or may not contain query parameters. - `params_to_strip` (List[str], optional): A list of query parameter names to be removed from the URL. Defaults to an empty list. **Returns**: - str: The processed URL with duplicates and specified parameters removed. **Constraints**: - The length of `url` will not exceed 2048 characters. - Parameter names and values will consist of alphanumeric characters only. - Consider different scenarios like no query parameters, multiple duplicates, and multiple parameters to strip. **Performance Requirements**: - Aim for a time complexity of O(n) where n is the length of the query string. - Maintain a space complexity of O(n) due to the usage of dictionaries and lists. **Example**: ```python url = \'www.saadbenn.com?a=1&b=2&a=2\' params_to_strip = [] print(strip_url_params(url, params_to_strip)) # Output: \'www.saadbenn.com?a=1&b=2\' url = \'www.saadbenn.com?a=1&b=2&a=2&b=3&c=4\' params_to_strip = [\'b\'] print(strip_url_params(url, params_to_strip)) # Output: \'www.saadbenn.com?a=1&c=4\' ``` **Explanation**: 1. For the first example, the function removes the duplicate `a` parameter while keeping the first occurrence, resulting in `www.saadbenn.com?a=1&b=2`. 2. For the second example, the function removes duplicates and also strips out the `b` parameter, resulting in `www.saadbenn.com?a=1&c=4`. Implement the function considering the above requirements, constraints, and examples. Make use of Python\'s built-in libraries where appropriate to simplify URL parsing and manipulation tasks.","solution":"from urllib.parse import urlparse, parse_qsl, urlencode, urlunparse from typing import List def strip_url_params(url: str, params_to_strip: List[str] = []) -> str: Remove duplicate query parameters and optionally strip out specified parameters from the URL. parsed_url = urlparse(url) query_params = parse_qsl(parsed_url.query) # Dictionary to track the first occurrence of each parameter param_dict = {} for key, value in query_params: if key not in param_dict and key not in params_to_strip: param_dict[key] = value clean_query = urlencode(param_dict) clean_url = urlunparse(parsed_url._replace(query=clean_query)) return clean_url"},{"question":"**Merge Sort Implementation** **Objective**: Implement the `merge_sort` function that sorts an array of integers in ascending order using the Merge Sort algorithm. # Function Signature ```python def merge_sort(arr: List[int]) -> List[int]: pass ``` # Input - **arr**: A list of integers (0 ≤ len(arr) ≤ 10^5, -10^6 ≤ arr[i] ≤ 10^6). # Output - Return a new list of integers sorted in ascending order. # Constraints - The function should handle empty arrays and arrays with one element. - The function should maintain the stability of the sorting algorithm. - The solution should be efficient in terms of time (O(n log(n))) and space complexity (O(n)). # Example 1. **Input**: `[34, 7, 23, 32, 5, 62]` **Output**: `[5, 7, 23, 32, 34, 62]` 2. **Input**: `[1, 2, 3, 4, 5]` **Output**: `[1, 2, 3, 4, 5]` 3. **Input**: `[5, 4, 3, 2, 1]` **Output**: `[1, 2, 3, 4, 5]` # Notes - Do not use any built-in sorting functions (`sorted`, `sort`) or external libraries. - Focus on a clean, efficient, and readable implementation.","solution":"from typing import List def merge_sort(arr: List[int]) -> List[int]: if len(arr) <= 1: return arr def merge(left: List[int], right: List[int]) -> List[int]: merged = [] left_index, right_index = 0, 0 while left_index < len(left) and right_index < len(right): if left[left_index] <= right[right_index]: merged.append(left[left_index]) left_index += 1 else: merged.append(right[right_index]) right_index += 1 # Append any remaining elements merged.extend(left[left_index:]) merged.extend(right[right_index:]) return merged mid = len(arr) // 2 left = merge_sort(arr[:mid]) right = merge_sort(arr[mid:]) return merge(left, right)"},{"question":"# Binary Search Tree Operations **Context**: You are tasked with implementing basic operations of a Binary Search Tree (BST). The operations will include inserting a value, deleting a value, and searching for a value in the tree. Additionally, you need to implement a method to retrieve the tree\'s inorder traversal, as this will return elements in their sorted order. **Task**: Implement the following methods for the `TreeNode` class: 1. `insert(node: TreeNode, val: int) -> TreeNode`: Inserts a value into the BST. 2. `delete(node: TreeNode, val: int) -> TreeNode`: Deletes a value from the BST. 3. `search(node: TreeNode, val: int) -> bool`: Searches for a value in the BST, returning `True` if found, `False` otherwise. 4. `inorder_traversal(node: TreeNode) -> List[int]`: Returns a list of values from the BST represented by the inorder traversal of the tree. **Constraints**: - You can assume that values are integers. - You cannot insert duplicate values. - The BST does not initially contain any nodes. Input/Output Formats: * `insert(node: TreeNode, val: int) -> TreeNode`: - **Input**: node (the root of the BST), val (the integer to be inserted) - **Output**: modified root of the BST * `delete(node: TreeNode, val: int) -> TreeNode`: - **Input**: node (the root of the BST), val (the integer to be deleted) - **Output**: modified root of the BST * `search(node: TreeNode, val: int) -> bool`: - **Input**: node (the root of the BST), val (the integer to be searched) - **Output**: `True` if the value is found, `False` otherwise * `inorder_traversal(node: TreeNode) -> List[int]`: - **Input**: node (the root of the BST) - **Output**: list of integers representing the inorder traversal of the tree **Example**: ```python root = TreeNode(5) insert(root, 3) insert(root, 7) insert(root, 2) insert(root, 4) insert(root, 6) insert(root, 8) print(inorder_traversal(root)) # Output: [2, 3, 4, 5, 6, 7, 8] print(search(root, 4)) # Output: True print(search(root, 9)) # Output: False root = delete(root, 3) print(inorder_traversal(root)) # Output: [2, 4, 5, 6, 7, 8] ```","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def insert(node, val): Inserts a value into the BST. if not node: return TreeNode(val) if val < node.val: node.left = insert(node.left, val) elif val > node.val: node.right = insert(node.right, val) return node def delete(node, val): Deletes a value from the BST. if not node: return None if val < node.val: node.left = delete(node.left, val) elif val > node.val: node.right = delete(node.right, val) else: if not node.left: return node.right if not node.right: return node.left temp = find_min(node.right) node.val = temp.val node.right = delete(node.right, temp.val) return node def find_min(node): Finds the node with the minimum value in the BST. while node.left: node = node.left return node def search(node, val): Searches for a value in the BST. if not node: return False if val < node.val: return search(node.left, val) elif val > node.val: return search(node.right, val) return True def inorder_traversal(node): Returns a list of values from the BST represented by the inorder traversal of the tree. if not node: return [] return inorder_traversal(node.left) + [node.val] + inorder_traversal(node.right)"},{"question":"# Context You are implementing a simple lexical analyzer using a Deterministic Finite Automaton (DFA) to identify valid identifiers in a custom programming language. The identifiers must start with a letter and can be followed by any combination of letters or digits. # Task Implement a function `is_valid_identifier(transitions, start, final, string)` that checks if the given string is a valid identifier according to the provided DFA. Function Signature ```python def is_valid_identifier(transitions, start, final, string): # Implement the function ``` # Input 1. `transitions`: A dictionary representing the state transition table of the DFA where `transitions[cur_state][input_char]` gives the next state or None if no valid transition exists for the current state and input character. 2. `start`: The initial state of the DFA. 3. `final`: A list of final (accepting) states of the DFA. 4. `string`: The input string to be checked. # Output * Return `True` if the string is a valid identifier according to the DFA. * Return `False` otherwise. # Constraints * The DFA alphabet consists of lowercase English letters and digits (`\'a\'-\'z\'` and `\'0\'-\'9\'`). * The length of the string will not exceed 100 characters. # Example ```python transitions = { 0: {\'a\': 1, \'b\': 1, \'c\': 1, ..., \'z\': 1}, 1: {\'a\': 1, \'b\': 1, ..., \'z\': 1, \'0\': 1, ... , \'9\': 1}, } start = 0 final = [1] print(is_valid_identifier(transitions, start, final, \\"abc123\\")) # Output: True print(is_valid_identifier(transitions, start, final, \\"123abc\\")) # Output: False print(is_valid_identifier(transitions, start, final, \\"ab@c\\")) # Output: False ``` The provided DFA starts at state 0, where any alphabet character leads it to state 1. State 1 is a final state that loops back upon both letters and digits, allowing for valid identifiers.","solution":"def is_valid_identifier(transitions, start, final, string): Check if the string is a valid identifier according to the provided DFA. current_state = start for char in string: if char in transitions[current_state]: current_state = transitions[current_state][char] else: return False return current_state in final"},{"question":"# Problem: Validate Sorted Linked List You are provided with a linked list, and your task is to check whether this linked list is sorted in ascending order. Write a function `validate_sorted_linked_list` which takes the head of such a linked list as input and returns a boolean indicating whether the list is sorted. Function Signature ```python def validate_sorted_linked_list(head: ListNode) -> bool: pass ``` Input * `head`: A `ListNode` object, which is the head of the linked list. Each node contains an integer `val` and a reference to the next node. Output * Return `True` if the linked list is sorted in ascending order, otherwise return `False`. Sample Input/Output ```python # Example 1: # Input: head = 1 -> 2 -> 3 -> 4 # Output: True # Example 2: # Input: head = 1 -> 2 -> -1 -> 3 # Output: False # Example 3: # Input: head = None # Output: True ``` Constraints * The linked list contains integers (`val` attribute of `ListNode`). * The linked list does not contain cycles. * ListNode definition is: ```python class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next ```","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def validate_sorted_linked_list(head: ListNode) -> bool: Checks whether the linked list starting from \'head\' is sorted in ascending order. :param head: ListNode - Head of the linked list :return: bool - True if the list is sorted in ascending order, else False # An empty list or a single node list is trivially sorted. if not head or not head.next: return True current = head while current.next: if current.val > current.next.val: return False current = current.next return True"},{"question":"Coding Question: Stutter Stack # Background You are provided with two functions that take a stack (implemented as a Python list) and replace each element in the stack with two occurrences of that element. One function (`first_stutter`) uses an additional stack for storage, while the other function (`second_stutter`) uses a queue for storage. # Problem Statement Implement both functions, `first_stutter` and `second_stutter`, according to the described behavior: * `first_stutter(stack)`: Uses a stack to achieve the desired results. * `second_stutter(stack)`: Uses a queue to achieve the desired results. # Input and Output * **Input**: A list `stack` which represents a stack with integers. * **Output**: A modified `stack` where every integer has been replaced by two occurrences of that integer. # Function Signatures ```python 1. def first_stutter(stack: List[int]) -> List[int]: 2. def second_stutter(stack: List[int]) -> List[int]: ``` # Constraints * The input list `stack` will have between 0 and 1000 integers. * Each integer in the stack will be between -1000 and 1000. # Examples Example 1: ```python stack = [3, 7, 1, 14, 9] first_stutter(stack) # Output: [3, 3, 7, 7, 1, 1, 14, 14, 9, 9] stack = [3, 7, 1, 14, 9] second_stutter(stack) # Output: [3, 3, 7, 7, 1, 1, 14, 14, 9, 9] ``` Example 2: ```python stack = [] first_stutter(stack) # Output: [] stack = [] second_stutter(stack) # Output: [] ``` # Edge Cases to Consider * An empty stack should return an empty stack. * A stack with negative integers or repeats should still function correctly. # Tips * Ensure you understand the behavior of the stack and queue data structures. * Consider how the elements move between the stack and auxiliary storage.","solution":"def first_stutter(stack): This function uses an auxiliary stack to duplicate each element in the original stack. aux_stack = [] while stack: element = stack.pop() aux_stack.append(element) aux_stack.append(element) # Reverse the elements back to the original stack to maintain order while aux_stack: stack.append(aux_stack.pop()) return stack from collections import deque def second_stutter(stack): This function uses an auxiliary queue to duplicate each element in the original stack. queue = deque() while stack: element = stack.pop() queue.append(element) queue.append(element) # Reverse the order as items were appended in reverse while queue: stack.append(queue.pop()) return stack"},{"question":"# Description Given an array of integers, implement the `cycle_sort` function to sort the array in ascending order using the Cycle Sort algorithm. Note that Cycle Sort is an in-place sorting algorithm and should minimize the number of writes to the array. # Function Signature ```python def cycle_sort(arr: List[int]) -> List[int]: ``` # Input - `arr`: A list of integers that need to be sorted. Length of the list, `N`, where `1 <= N <= 10^4`. # Output - Returns: A list of integers sorted in ascending order. # Constraints - The input list can contain negative numbers. - All numbers in the list are integers within the range of -10^6 to 10^6. # Examples ```python # Example 1: arr = [4, 3, 2, 1] print(cycle_sort(arr)) # Output: [1, 2, 3, 4] # Example 2: arr = [10, -1, 0, 5, -2] print(cycle_sort(arr)) # Output: [-2, -1, 0, 5, 10] # Example 3: arr = [1, 2, 3, 4, 5] print(cycle_sort(arr)) # Output: [1, 2, 3, 4, 5] ``` # Explanation - The first example demonstrates sorting of a reverse-ordered array. - The second example includes negative integers and zero. - The third example shows that an already sorted array remains unchanged. The function `cycle_sort` should handle edge cases effectively, such as arrays with duplicate elements or already sorted arrays. # Additional Notes - Be mindful of performance issues for larger arrays approaching the upper limit of the input size. - Ensure that the function handles and sorts all elements correctly, including negative numbers.","solution":"def cycle_sort(arr): n = len(arr) # Traverse array elements and put them on the correct index for start in range(0, n - 1): item = arr[start] # Find the position where we put the element pos = start for i in range(start + 1, n): if arr[i] < item: pos += 1 # If the item is already in the correct position if pos == start: continue # Skip duplicates while item == arr[pos]: pos += 1 # Put the item to it\'s right position arr[pos], item = item, arr[pos] # Rotate rest of the cycle while pos != start: pos = start for i in range(start + 1, n): if arr[i] < item: pos += 1 while item == arr[pos]: pos += 1 arr[pos], item = item, arr[pos] return arr"},{"question":"You are required to implement a Dynamic Hash Table that supports efficient key-value pair insertion, retrieval, and deletion. This hash table dynamically resizes when the load factor exceeds 2/3, ensuring consistent performance. Moreover, you must develop and integrate a custom hash function to minimize collision occurrences. # Function Requirements: 1. **class DynamicHashTable**: Implement this class to include the following methods: - `def __init__(self, size=8)`: Initializes the hash table with a given size. - `def put(self, key, value)`: Adds a key-value pair to the hash table. If the load factor exceeds 2/3, resize the table. - `def get(self, key)`: Retrieves the value associated with the given key. Returns `None` if the key is not present. - `def del_(self, key)`: Deletes the key-value pair for the given key. Returns `None` if the key is not present. - `def __len__(self)`: Returns the number of key-value pairs currently stored in the table. # Constraints: - Keys are non-negative integers. - Values can be of any data type. # Performance Requirements: - Aim for average-case time complexity of O(1) for insertion, deletion, and retrieval operations. - The table should dynamically resize efficiently when required. # Scenario: You have been hired to optimize the backend of a web application that relies heavily on fast data retrieval. Your task is to implement and test a Dynamic Hash Table to ensure that the application performs efficiently under heavy load. # Example: ```python ht = DynamicHashTable(size=5) ht.put(1, \\"apple\\") ht.put(2, \\"banana\\") print(ht.get(1)) # Output: \\"apple\\" ht.del_(1) print(ht.get(1)) # Output: None print(len(ht)) # Output: 1 ht.put(3, \\"cherry\\") ht.put(4, \\"date\\") ht.put(5, \\"elderberry\\") ht.put(6, \\"fig\\") print(len(ht)) # Output: 5 (should trigger resize) ```","solution":"class DynamicHashTable: def __init__(self, size=8): self.table_size = size self.table = [None] * self.table_size self.num_items = 0 def custom_hash(self, key): return key % self.table_size def _resize(self, new_size): old_table = self.table self.table_size = new_size self.table = [None] * self.table_size self.num_items = 0 for item in old_table: if item: for key, value in item: self.put(key, value) def put(self, key, value): if self.num_items / self.table_size > 2/3: self._resize(self.table_size * 2) index = self.custom_hash(key) if not self.table[index]: self.table[index] = [] for i, (k, _) in enumerate(self.table[index]): if k == key: self.table[index][i] = (key, value) return self.table[index].append((key, value)) self.num_items += 1 def get(self, key): index = self.custom_hash(key) if not self.table[index]: return None for k, v in self.table[index]: if k == key: return v return None def del_(self, key): index = self.custom_hash(key) if not self.table[index]: return None for i, (k, _) in enumerate(self.table[index]): if k == key: self.table[index].pop(i) self.num_items -= 1 return def __len__(self): return self.num_items"},{"question":"# Context: You\'ve been given a generalized N-Sum algorithm, capable of determining unique tuples within an array that sum up to a given target value. This flexibility enables various forms of sum-based problem solving by tweaking the sum and comparison logic via closures. # Task: Implement a function that identifies unique 4-tuples in an array of integers that sum up to a specified target. Your function should follow the principles and structure detailed in the provided context. # Function Signature: ```python def find_four_sum(nums: List[int], target: int) -> List[List[int]]: # your implementation here ``` # Input: * `nums` - a list of integers. `len(nums)` can range from 1 to 1000. * `target` - an integer representing the sum target. # Output: * A list of lists where each inner list is a unique quadruple (4-tuple) that sums to the target. # Constraints: * Each quad should be sorted in non-decreasing order. * The output list should not contain duplicate quads. * You can assume that nums contain integers only. # Example: Example 1: ```python nums = [1, 0, -1, 0, -2, 2] target = 0 output = [[-2, -1, 1, 2], [-2, 0, 0, 2], [-1, 0, 0, 1]] ``` Example 2: ```python nums = [1, 2, 3, 4, 5] target = 10 output = [[1, 2, 3, 4]] ``` # Note: * It is recommended to utilize appropriate sorting and recursive sub-modules to align with the constraints effectively. * Consider common edge scenarios such as having fewer than 4 numbers or no valid combinations.","solution":"from typing import List def find_four_sum(nums: List[int], target: int) -> List[List[int]]: Identifies unique 4-tuples in an array that sum up to a specified target. Args: nums: List[int] - A list of integers. target: int - The target sum for the 4-tuples. Returns: List[List[int]] - A list of unique 4-tuples that sum to the target. nums.sort() quadruples = [] n = len(nums) for i in range(n - 3): if i > 0 and nums[i] == nums[i - 1]: continue for j in range(i + 1, n - 2): if j > i + 1 and nums[j] == nums[j - 1]: continue left, right = j + 1, n - 1 while left < right: quad_sum = nums[i] + nums[j] + nums[left] + nums[right] if quad_sum == target: quadruples.append([nums[i], nums[j], nums[left], nums[right]]) while left < right and nums[left] == nums[left + 1]: left += 1 while left < right and nums[right] == nums[right - 1]: right -= 1 left += 1 right -= 1 elif quad_sum < target: left += 1 else: right -= 1 return quadruples"},{"question":"# Coding Challenge: Enhanced Minimum Removal from Stack Given a stack represented as a list, your task is to enhance the provided algorithm by: 1. Optimizing it to reduce space complexity. 2. Implementing an in-place version if possible. Function Signature ```python def remove_min(stack: list) -> list: ``` Input * `stack` — A list of integers representing the stack. Output * A modified list (stack) with the smallest element removed. Constraints * Do not use additional data structures except primitive variables. * The function should handle empty stacks gracefully. * Elements in the stack can be negative or positive integers. * Stack order (except the removed element) must be preserved. Performance Requirements * Aim to improve space complexity while keeping time complexity reasonable. Example ```python stack = [2, 8, 3, -6, 7, 3] remove_min(stack) # Expected output: [2, 8, 3, 7, 3] ``` Scenario Consider a scenario where you have a stack of temperatures recorded over several days. You want to remove the day with the lowest temperature but maintain the order of the other recorded temperatures. Implement a solution to optimize for both time and space as best as possible.","solution":"def remove_min(stack: list) -> list: Removes the smallest element from the stack in-place and returns the updated stack. If the stack is empty, it returns the stack as is. if not stack: return stack # Find the index of the minimum element min_index = 0 for i in range(1, len(stack)): if stack[i] < stack[min_index]: min_index = i # Remove the element at the found index stack.pop(min_index) return stack"},{"question":"# Question: Counting Set Bits Using Brian Kernighan\'s Algorithm Implement a function that takes an unsigned integer and returns the number of \'1\' bits in its binary representation using Brian Kernighan\'s Algorithm. Brian Kernighan\'s Algorithm works by subtracting 1 from the number and ANDing it with the original number, effectively clearing the lowest set bit. The count of how many times this operation is performed before the number becomes zero gives the number of 1 bits. Function Signature ```python def count_set_bits(n: int) -> int: ``` Input * The function takes a single integer `n` (0 ≤ n ≤ 2^31 - 1). Output * The function should return an integer representing the number of \'1\' bits in the binary representation of `n`. Constraints * The input is guaranteed to be a non-negative integer within the given range. * The solution should be optimized for time complexity O(k) where k is the number of \'1\' bits in n. * The function must use an iterative approach for stack efficiency. Example ```python assert count_set_bits(11) == 3 # Binary: 00000000000000000000000000001011 assert count_set_bits(128) == 1 # Binary: 00000000000000000000000010000000 assert count_set_bits(255) == 8 # Binary: 00000000000000000000000011111111 ``` # Notes * Provide a detailed explanation for the algorithm used. * Ensure to handle edge cases like the input being zero.","solution":"def count_set_bits(n: int) -> int: Return the number of \'1\' bits in the binary representation of n using Brian Kernighan\'s Algorithm. count = 0 while n: n &= (n - 1) count += 1 return count"},{"question":"# Matrix Inversion Algorithm Problem Statement You have been provided with a Python function `invert_matrix(m)` that inverts an ( n times n ) matrix. The function follows a four-step process to compute the inverse: 1. Computation of the matrix of minors with an alternate sign pattern. 2. Calculation of the determinant. 3. Adjugation (transpose the cofactor matrix). 4. Division by the determinant to get the inverse matrix. Your task is to enhance the current implementation to handle the following: 1. Improve the determinant calculation method to avoid redundancy. 2. Optimize the handling of edge cases specifically for ( 0 times 0 ) matrix and ( 1 times 1 ) matrix. 3. Refactor the code to improve readability and efficiency. Requirements - You must implement the `invert_matrix` function. - Your function should take a square matrix (2D list) as input and return its inverse. - If the matrix is singular or not square, the function should return an appropriate error message. - You are expected to optimize the code for improving performance, particularly the determinant calculation. Input Format - A 2D list `m` where each element is a row in the matrix. Output Format - A 2D list representing the inverse of the input matrix if it is invertible. - Return appropriate error messages for invalid cases: - `Invalid matrix: array is not a matrix` - `Invalid matrix: matrix is not square` - `Invalid matrix: matrix is too small` - `Invalid matrix: matrix is square, but singular (determinant = 0)` Constraints - You may assume all elements of the input matrix are integers or floats. - The matrix will be ( n times n ) where ( 2 leq n leq 10 ). Example ```python # Example Input matrix = [ [4, 7], [2, 6] ] # Example Output [ [0.6, -0.7], [-0.2, 0.4] ] # Edge Case Input singular_matrix = [ [1, 2], [2, 4] ] # Edge Case Output \\"Invalid matrix: matrix is square, but singular (determinant = 0)\\" ``` Function Signature ```python def invert_matrix(m: List[List[Union[int, float]]]) -> List[List[Union[int, float]]]: pass ```","solution":"from typing import List, Union def get_cofactor(matrix, i, j): return [row[:j] + row[j+1:] for row in (matrix[:i] + matrix[i+1:])] def determinant_recursive(matrix): if len(matrix) == 1: return matrix[0][0] if len(matrix) == 2: return matrix[0][0]*matrix[1][1] - matrix[0][1]*matrix[1][0] det = 0 for c in range(len(matrix)): cofactor = get_cofactor(matrix, 0, c) det += ((-1)**c)*matrix[0][c]*determinant_recursive(cofactor) return det def adjugate_matrix(matrix): adjugate = [] for i in range(len(matrix)): adjugate_row = [] for j in range(len(matrix)): minor = get_cofactor(matrix, i, j) cofactor = determinant_recursive(minor) sign = (-1) ** (i + j) adjugate_row.append(sign * cofactor) adjugate.append(adjugate_row) return transpose_matrix(adjugate) def transpose_matrix(matrix): return list(map(list, zip(*matrix))) def invert_matrix(m: List[List[Union[int, float]]]) -> List[List[Union[int, float]]]: if not m or not isinstance(m, list) or not all(isinstance(row, list) for row in m): return \\"Invalid matrix: array is not a matrix\\" n = len(m) if any(len(row) != n for row in m): return \\"Invalid matrix: matrix is not square\\" if n == 0: return \\"Invalid matrix: matrix is too small\\" if n == 1: if m[0][0] == 0: return \\"Invalid matrix: matrix is square, but singular (determinant = 0)\\" else: return [[1 / m[0][0]]] det = determinant_recursive(m) if det == 0: return \\"Invalid matrix: matrix is square, but singular (determinant = 0)\\" adj = adjugate_matrix(m) inverse_matrix = [[adj[i][j] / det for j in range(n)] for i in range(n)] return inverse_matrix"},{"question":"# Polynomial Simplifier and Evaluator Suppose you are working on an algebraic computation library and need to extend the given `Polynomial` and `Monomial` classes to handle operations more efficiently, with a focus on simplifying algebraic expressions and evaluating them for given values of variables. You are required to implement two main functionalities: 1. **Simplify Polynomial:** - Simplify a polynomial by combining like terms and ensuring that the representation is canonical (e.g., no zero coefficients, and terms sorted by variables). 2. **Evaluate Polynomial:** - Evaluate the polynomial for given values of the variables. - Return the resulting value as a simplified fraction where possible. # Input & Output * **Input**: - For simplification, a `Polynomial` instance object. - For evaluation, a `Polynomial` instance object and a dictionary representing variable values. * **Output**: - For simplification, a simplified `Polynomial` instance object. - For evaluation, either an integer, float, or `Fraction`. # Constraints * You should use the provided `Monomial` and `Polynomial` classes. * Ensure correct handling of edge cases such as zero coefficients and division by zero. * Aim for performance efficiency for polynomials with up to 1000 monomials and variables up to 50 in different terms. # Example Given the polynomial: [ P(a_1, a_2) = 3(a_1)^2(a_2) + 5(a_1)(a_2)^2 - (a_1)^2(a_2) + (a_1)(a_2)^2 + 2 ] - **Simplified Form**: Multiply and combine like terms: [ P(a_1, a_2) = 2(a_1)^2(a_2) + 6(a_1)(a_2)^2 + 2 ] - **Evaluation**: Evaluate (P) for (a_1 = 1) and (a_2 = 2): [ P(1, 2) = 2(1)^2(2) + 6(1)(2)^2 + 2 = 4 + 24 + 2 = 30 ] # Function Signature ```python def simplify_polynomial(poly: Polynomial) -> Polynomial: # Your code here def evaluate_polynomial(poly: Polynomial, variable_values: Dict[int, Union[int, float, Fraction]]) -> Union[int, float, Fraction]: # Your code here # Add any needed helper functions or modifications to existing classes. ``` # Tasks 1. Implement the `simplify_polynomial` function. 2. Implement the `evaluate_polynomial` function. 3. Make necessary adjustments or additions to the provided classes to support these functionalities efficiently.","solution":"from fractions import Fraction from collections import defaultdict from typing import List, Dict, Union class Polynomial: def __init__(self, monomials: List[\'Monomial\']): self.monomials = monomials def __str__(self): terms = [str(m) for m in self.monomials] return \\" + \\".join(terms) def __repr__(self): return f\\"Polynomial({self.monomials})\\" class Monomial: def __init__(self, coefficient: Union[int, float, Fraction], variables: Dict[str, int]): self.coefficient = coefficient self.variables = variables def __str__(self): if not self.variables: return str(self.coefficient) var_str = \'\'.join([f\\"{var}^{exp}\\" if exp != 1 else var for var, exp in sorted(self.variables.items())]) return f\\"{self.coefficient}{var_str}\\" def __repr__(self): return f\\"Monomial({self.coefficient}, {self.variables})\\" def __eq__(self, other): return self.variables == other.variables def __hash__(self): return hash(frozenset(self.variables.items())) def simplify_polynomial(poly: Polynomial) -> Polynomial: mono_dict = defaultdict(lambda: 0) for monomial in poly.monomials: variables_tuple = tuple(sorted(monomial.variables.items())) mono_dict[variables_tuple] += monomial.coefficient simplified_monomials = [] for variables_tuple, coefficient in mono_dict.items(): if coefficient != 0: variables = dict(variables_tuple) simplified_monomials.append(Monomial(coefficient, variables)) return Polynomial(simplified_monomials) def evaluate_polynomial(poly: Polynomial, variable_values: Dict[str, Union[int, float, Fraction]]) -> Union[int, float, Fraction]: result = 0 for monomial in poly.monomials: term_value = monomial.coefficient for var, exp in monomial.variables.items(): if var in variable_values: term_value *= variable_values[var] ** exp else: return None result += term_value return result"},{"question":"# Objective You are tasked with implementing an optimized version of the Bron-Kerbosch algorithm to find all maximal cliques in a given undirected graph. Your goal is to enhance performance through the use of pivoting and heuristic pruning. # Problem Statement Given an undirected graph represented as an adjacency list, where vertices are defined by unique string labels, implement a function: ```python def find_all_maximal_cliques(edges: dict) -> list: pass ``` # Input * `edges`: A dictionary where each key is a vertex (string) and the value is a set of adjacent vertices (strings). # Output * A list of lists, where each sublist represents a maximum clique (a fully connected subgraph). # Constraints 1. Vertex labels are unique strings composed of lowercase letters. 2. The adjacency list is symmetric (if vertex A is connected to vertex B, then vertex B is connected to vertex A). 3. The number of vertices ( V ) is in the range [1, 20]. 4. The total number of edges ( E ) will not exceed ( V(V-1)/2 ). # Performance Requirements The solution should: 1. Use pivoting to optimize the algorithm\'s efficiency. 2. Avoid unnecessary recomputation of candidate sets. # Example ```python edges = { \\"a\\": {\\"b\\", \\"c\\"}, \\"b\\": {\\"a\\", \\"c\\"}, \\"c\\": {\\"a\\", \\"b\\", \\"d\\"}, \\"d\\": {\\"c\\"} } # The maximal cliques are [[\\"a\\", \\"b\\", \\"c\\"], [\\"c\\", \\"d\\"]] result = find_all_maximal_cliques(edges) # Expected Output: [[\\"a\\", \\"b\\", \\"c\\"], [\\"c\\", \\"d\\"]] ``` # Guidelines * Ensure correctness by handling various edge cases including fully connected graphs and graphs with isolated vertices. * Optimize the implementation using pivoting during the candidate selection process to improve efficiency.","solution":"def find_all_maximal_cliques(edges): def bron_kerbosch(R, P, X): if not P and not X: cliques.append(list(R)) return pivot = next(iter(P.union(X))) for vertex in P - edges[pivot]: bron_kerbosch(R.union([vertex]), P.intersection(edges[vertex]), X.intersection(edges[vertex])) P.remove(vertex) X.add(vertex) cliques = [] vertices = set(edges.keys()) bron_kerbosch(set(), vertices, set()) return cliques"},{"question":"Given a string `s`, find the index of the first non-repeating character. If it doesn\'t exist, return -1. Write a function `first_unique_char_optimized` that efficiently determines this index using optimal strategies for performance with large input sizes. # Requirements: - **Input**: A string `s` which may contain lowercase English letters. - **Output**: An integer representing the index of the first non-repeating character, or -1 if no such character exists. - **Constraints**: - The length of `s` is within the range `[0, 10^5]`. - Performance should be optimized to handle large strings efficiently. # Function Signature ```python def first_unique_char_optimized(s: str) -> int: pass ``` # Example: ```python # Example 1: first_unique_char_optimized(\\"leetcode\\") # Expected Output: 0 # Example 2: first_unique_char_optimized(\\"loveleetcode\\") # Expected Output: 2 # Example 3: first_unique_char_optimized(\\"aabb\\") # Expected Output: -1 ``` # Explanation: 1. In the string \\"leetcode\\", \'l\' is the first non-repeating character at index 0. 2. In the string \\"loveleetcode\\", \'v\' is the first non-repeating character at index 2. 3. In the string \\"aabb\\", there are no non-repeating characters, hence return -1. # Edge Cases: * An empty string should return -1. * A string of length 1 should return 0 since the only character is non-repeating. Optimize your solution for execution time and memory usage.","solution":"def first_unique_char_optimized(s: str) -> int: This function returns the index of the first non-repeating character in the string `s`. If no such character exists, it returns -1. from collections import Counter # Use Counter to count the frequency of each character count = Counter(s) # Find the first character with a count of 1 and return its index for idx, char in enumerate(s): if count[char] == 1: return idx # If no unique character found, return -1 return -1"},{"question":"You are given a binary tree and need to determine its height. The height is defined as the number of levels from the root node to the deepest leaf node. An empty tree has a height of 0. # Function Signature ```python def calculate_tree_height(root: Node) -> int: pass ``` # Input * A `Node` object representing the root of the binary tree. The `Node` class is defined as follows: ```python class Node: def __init__(self, value): self.value = value self.left = None self.right = None ``` # Output * An integer representing the height of the binary tree. # Example If the binary tree is: ``` 9 / 6 12 / / 3 8 10 15 / 7 18 ``` then the output should be: ``` 4 ``` # Constraints * The number of nodes in the binary tree is between 0 and 10000. * The values of the nodes are integers and unique. * Performance should be optimal with respect to time and space complexity. # Scenario You are working on a tree-related module in a software application. One of the functions requires the height of the tree to balance various operations. Implement the function to ensure the system works efficiently.","solution":"class Node: def __init__(self, value): self.value = value self.left = None self.right = None def calculate_tree_height(root: Node) -> int: Calculates the height of a binary tree, defined as the number of levels from the root node to the deepest leaf node. An empty tree has a height of 0. :param root: Root node of the binary tree :return: Height of the tree if root is None: return 0 left_height = calculate_tree_height(root.left) right_height = calculate_tree_height(root.right) return max(left_height, right_height) + 1"},{"question":"You are provided with a basic `TreeNode` class for creating nodes in a binary tree. Your task is to implement a Binary Search Tree (BST) class with the following operations: 1. **Insert**: Insert a value into the BST. 2. **Search**: Search for a value in the BST, returning `True` if found and `False` otherwise. 3. **Delete**: Remove a value from the BST. 4. **In-order Traversal**: Return the values in the BST in ascending order. Here is the interface you need to implement: ```python class TreeNode: def __init__(self, val=0): self.val = val self.left = None self.right = None class BST: def __init__(self): self.root = None def insert(self, val: int) -> None: pass def search(self, val: int) -> bool: pass def delete(self, val: int) -> None: pass def inorder_traversal(self) -> List[int]: pass ``` # Constraints: * The values in the BST are unique integers. * The `search` method should return `True` or `False`. * The `inorder_traversal` method should return a list of integers. # Example: ```python # create a BST instance bst = BST() # insert elements bst.insert(5) bst.insert(3) bst.insert(7) bst.insert(2) bst.insert(4) bst.insert(6) bst.insert(8) # search elements print(bst.search(4)) # should return True print(bst.search(9)) # should return False # delete an element bst.delete(3) # get in-order traversal print(bst.inorder_traversal()) # should return [2, 4, 5, 6, 7, 8] ``` # Performance Requirements: * The operations should have an average-case time complexity of O(log n) and a worst-case time complexity of O(n). Implement the BST class with its methods considering the edge cases and ensuring optimal performance.","solution":"class TreeNode: def __init__(self, val=0): self.val = val self.left = None self.right = None class BST: def __init__(self): self.root = None def insert(self, val: int) -> None: if not self.root: self.root = TreeNode(val) else: self._insert(self.root, val) def _insert(self, node, val): if val < node.val: if node.left: self._insert(node.left, val) else: node.left = TreeNode(val) else: if node.right: self._insert(node.right, val) else: node.right = TreeNode(val) def search(self, val: int) -> bool: return self._search(self.root, val) def _search(self, node, val): if not node: return False if node.val == val: return True elif val < node.val: return self._search(node.left, val) else: return self._search(node.right, val) def delete(self, val: int) -> None: self.root = self._delete(self.root, val) def _delete(self, node, val): if not node: return node if val < node.val: node.left = self._delete(node.left, val) elif val > node.val: node.right = self._delete(node.right, val) else: if not node.left: return node.right elif not node.right: return node.left temp = self._minValueNode(node.right) node.val = temp.val node.right = self._delete(node.right, temp.val) return node def _minValueNode(self, node): current = node while current.left: current = current.left return current def inorder_traversal(self) -> list: result = [] self._inorder_traversal(self.root, result) return result def _inorder_traversal(self, node, result): if not node: return self._inorder_traversal(node.left, result) result.append(node.val) self._inorder_traversal(node.right, result)"},{"question":"# Question: Get Full Absolute Path of a File Description Given a file path, write a function `full_path(file)` that converts relative paths and those containing \'~\' (indicating the user\'s home directory) into absolute paths. Use the provided Python standard library functions `os.path.expanduser` and `os.path.abspath` for this task. Input * A single string `file` representing the file path. Output * A single string representing the absolute path for the given file. Constraints * The input path `file` may or may not contain a home directory symbol \'~\'. * Handle possible edge cases like filenames only or paths containing relative segments. Example ```python file = \\"~/documents/file.txt\\" print(full_path(file)) # Output: \\"/home/username/documents/file.txt\\" (actual output may vary based on the true home directory) file = \\"folder/../file.txt\\" print(full_path(file)) # Output: \\"/absolute/path/to/file.txt\\" (the exact absolute path may vary) ``` Notes * Ensure that you account for the current working directory when a relative path is provided. * Consider the handling of malformed paths gracefully as part of robust software construction.","solution":"import os def full_path(file): Convert a file path into an absolute path, handling user home directories and relative paths. expanded_path = os.path.expanduser(file) absolute_path = os.path.abspath(expanded_path) return absolute_path"},{"question":"# Anagram Checker **Objective**: You are required to implement a function to determine whether two given strings are anagrams of each other. The function should consider only lowercase alphabetic characters. # Function Signature: ```python def is_anagram(s: str, t: str) -> bool: ``` # Input: - `s` (string): A non-empty string containing only lowercase alphabetic characters. - `t` (string): Another string containing only lowercase alphabetic characters. # Output: - Return `True` if `t` is an anagram of `s`, otherwise return `False`. # Constraints: 1. The input strings `s` and `t` consist of lowercase English characters only. 2. The length of strings `s` and `t` are non-negative and do not exceed 10000 characters. # Example: ```python assert is_anagram(\\"anagram\\", \\"nagaram\\") == True assert is_anagram(\\"rat\\", \\"car\\") == False assert is_anagram(\\"\\", \\"\\") == True # Edge case assert is_anagram(\\"a\\", \\"a\\") == True assert is_anagram(\\"apple\\", \\"ppale\\") == False ``` # Context: In a text processing application, you need to ensure that a shuffled version of a given keyword remains valid after encryption and decryption operations. Use this function to validate that the output remains an anagram of the input after those operations. # Notes: Implement the anagram checker by using a single hashmap for counting character frequencies to optimize space and performance compared to the example provided above.","solution":"def is_anagram(s: str, t: str) -> bool: Determine whether the string `t` is an anagram of the string `s`. Args: s (str): The first string. t (str): The second string. Returns: bool: True if `t` is an anagram of `s`, otherwise False. if len(s) != len(t): return False count = {} for char in s: if char in count: count[char] += 1 else: count[char] = 1 for char in t: if char in count: count[char] -= 1 if count[char] == 0: del count[char] else: return False return len(count) == 0"},{"question":"# Question You need to encode a list of strings into a single string and then decode the string back to the original list. Implement the two functions: `encode` and `decode`. `encode` function: - **Input**: A list of strings `strs` (0 ≤ len(strs) ≤ 10^4, with each string having length ≤ 10^4) - **Output**: A single string that represents the encoded list of strings. - **Rules**: 1. The encoded string should be a single string that you can convert back to the list. 2. Use a colon `:` to separate string lengths and actual strings. 3. Preserve empty strings in the list during encoding and decoding. `decode` function: - **Input**: A single string `s` - **Output**: A list of strings that represents the decoded version of the input string. # Constraints: - The strings can contain any ASCII characters. - Avoid using any libraries or functions that directly solve the problem. # Example: ```python >>> strs = [\\"hello\\", \\"world\\"] >>> encoded_str = encode(strs) >>> print(encoded_str) \\"5:hello5:world\\" >>> decoded_strs = decode(encoded_str) >>> print(decoded_strs) [\\"hello\\", \\"world\\"] >>> strs = [\\"\\", \\"hello\\"] >>> encoded_str = encode(strs) >>> print(encoded_str) \\"0:5:hello\\" >>> decoded_strs = decode(encoded_str) >>> print(decoded_strs) [\\"\\", \\"hello\\"] ``` Implement `encode` and `decode` functions below: ```python def encode(strs): # Your implementation here pass def decode(s): # Your implementation here pass ```","solution":"def encode(strs): Encodes a list of strings into a single string. Args: strs (List[str]): A list of strings to encode. Returns: str: A single string representing the encoded list. encoded_str = \'\' for s in strs: encoded_str += f\'{len(s)}:{s}\' return encoded_str def decode(s): Decodes a single string into a list of strings. Args: s (str): A single string representing the encoded list of strings. Returns: List[str]: The decoded list of strings. decoded_list = [] i = 0 while i < len(s): # Find the next colon and determine the length of the next string j = s.find(\':\', i) length = int(s[i:j]) i = j + 1 decoded_list.append(s[i:i+length]) i += length return decoded_list"},{"question":"# Question: You are tasked with verifying and enhancing the following matrix inversion algorithm. Specifically, focus on improving computational efficiency by optimizing determinant calculations and reducing unnecessary matrix traversals. Input: * An n x n matrix `m` of integers and fractions (matrix format is a list of lists where each inner list represents a row). Output: * An n x n matrix representing the inverse of `m`. * In specific error scenarios, return the corresponding error codes: * `-1`: The input is not a valid matrix. * `-2`: The input matrix is not square. * `-3`: The matrix is too small for this method (i.e., 1x1 or 0x0). * `-4`: The matrix is singular and thus non-invertible. Constraints: * The matrix `m` will have dimensions `n x n`, where `2 <= n <= 10`. * Use fractions.Fraction for numerical stability in divisions. Performance Requirements: * Enhance determinant calculation efficiency. * Optimize traversal to avoid unnecessary computations. # Scenario: You\'re working on a simulation software that frequently inverts matrices as part of its model transformation computations. To keep performance optimal, especially for higher dimensions, refactor the given matrix inversion code. Example: ```python # Base case of a 2x2 matrix m = [ [4, 7], [2, 6] ] print(invert_matrix(m)) # Expected output: [[0.6, -0.7], [-0.2, 0.4]] # Larger matrix (3x3 matrix) m = [ [3, 0, 2], [2, 0, -2], [0, 1, 1] ] print(invert_matrix(m)) # Expected output: [[0.2, 0.2, 0], [-0.2, 0.3, 1], [0.2, -0.3, 0]] ``` # Note: Provide detailed documentation and comments in your code to explain the optimizations made.","solution":"from fractions import Fraction import copy def invert_matrix(m): Returns the inverse of a given matrix m if it exists, otherwise returns an error code. Error Codes: -1: The input is not a valid matrix. -2: The input matrix is not square. -3: The matrix is too small to invert using this method. -4: The matrix is singular and thus non-invertible. # Check if input is a valid matrix if not isinstance(m, list) or not all(isinstance(row, list) for row in m): return -1 # Check if the matrix is square n = len(m) if not all(len(row) == n for row in m): return -2 if n == 1: return -3 # This method does not support 1x1 or 0x0 matrices m = [[Fraction(entry) for entry in row] for row in m] # Create an identity matrix of the same size I = [[Fraction(int(i == j)) for i in range(n)] for j in range(n)] # Forward elimination for i in range(n): # Search for maximum in this column maxEl = abs(m[i][i]) maxRow = i for k in range(i + 1, n): if abs(m[k][i]) > maxEl: maxEl = abs(m[k][i]) maxRow = k # Swap maximum row with current row (column by column) m[i], m[maxRow] = m[maxRow], m[i] I[i], I[maxRow] = I[maxRow], I[i] # The matrix is singular if the maxEl is 0 if m[i][i] == 0: return -4 # Make the diagonal contain all 1\'s diag = m[i][i] for k in range(n): m[i][k] /= diag I[i][k] /= diag # Make the other columns contain all 0\'s for k in range(n): if k != i: c = m[k][i] / m[i][i] for j in range(n): m[k][j] -= c * m[i][j] I[k][j] -= c * I[i][j] return [[float(val) for val in row] for row in I]"},{"question":"# Sudoku Solver Implementation and Analysis **Context**: You\'ve been given a Sudoku puzzle represented as a 9x9 grid. Some cells are filled with digits 1 to 9, while others are filled with a period (\'.\') representing an empty cell. Your task is to write a Python function that solves the given Sudoku by filling all empty cells while keeping the Sudoku rules. **Function to Implement**: `solve_sudoku(board: List[List[str]]) -> None` **Input Format**: - `board`: A 9x9 list of lists, where each element is either a digit `1-9` or a period `.` representing an empty cell. **Output Format**: - The function modifies the `board` in place, so it doesn\'t return anything. **Constraints**: 1. You are guaranteed that the input board corresponds to a valid Sudoku puzzle. 2. The solution will be unique. **Performance Requirements**: 1. Implementations should aim to minimize runtime complexity. 2. The function should run efficiently for typical Sudoku puzzles. **Example**: ```python board = [ [\\"5\\",\\"3\\",\\".\\",\\".\\",\\"7\\",\\".\\",\\".\\",\\".\\",\\".\\"], [\\"6\\",\\".\\",\\".\\",\\"1\\",\\"9\\",\\"5\\",\\".\\",\\".\\",\\".\\"], [\\".\\",\\"9\\",\\"8\\",\\".\\",\\".\\",\\".\\",\\".\\",\\"6\\",\\".\\"], [\\"8\\",\\".\\",\\".\\",\\".\\",\\"6\\",\\".\\",\\".\\",\\".\\",\\"3\\"], [\\"4\\",\\".\\",\\".\\",\\"8\\",\\".\\",\\"3\\",\\".\\",\\".\\",\\"1\\"], [\\"7\\",\\".\\",\\".\\",\\".\\",\\"2\\",\\".\\",\\".\\",\\".\\",\\"6\\"], [\\".\\",\\"6\\",\\".\\",\\".\\",\\".\\",\\".\\",\\"2\\",\\"8\\",\\".\\"], [\\".\\",\\".\\",\\".\\",\\"4\\",\\"1\\",\\"9\\",\\".\\",\\".\\",\\"5\\"], [\\".\\",\\".\\",\\".\\",\\".\\",\\"8\\",\\".\\",\\".\\",\\"7\\",\\"9\\"] ] solve_sudoku(board) print(board) ``` **Expected Output**: The board should be modified in place to: ```python [ [\\"5\\",\\"3\\",\\"4\\",\\"6\\",\\"7\\",\\"8\\",\\"9\\",\\"1\\",\\"2\\"], [\\"6\\",\\"7\\",\\"2\\",\\"1\\",\\"9\\",\\"5\\",\\"3\\",\\"4\\",\\"8\\"], [\\"1\\",\\"9\\",\\"8\\",\\"3\\",\\"4\\",\\"2\\",\\"5\\",\\"6\\",\\"7\\"], [\\"8\\",\\"5\\",\\"9\\",\\"7\\",\\"6\\",\\"1\\",\\"4\\",\\"2\\",\\"3\\"], [\\"4\\",\\"2\\",\\"6\\",\\"8\\",\\"5\\",\\"3\\",\\"7\\",\\"9\\",\\"1\\"], [\\"7\\",\\"1\\",\\"3\\",\\"9\\",\\"2\\",\\"4\\",\\"8\\",\\"5\\",\\"6\\"], [\\"9\\",\\"6\\",\\"1\\",\\"5\\",\\"3\\",\\"7\\",\\"2\\",\\"8\\",\\"4\\"], [\\"2\\",\\"8\\",\\"7\\",\\"4\\",\\"1\\",\\"9\\",\\"6\\",\\"3\\",\\"5\\"], [\\"3\\",\\"4\\",\\"5\\",\\"2\\",\\"8\\",\\"6\\",\\"1\\",\\"7\\",\\"9\\"] ] ``` **Additional Task**: Accompany your solution with a brief analysis on how this function works: the steps it takes, the time complexity, and how it leverages backtracking to efficiently solve the puzzle.","solution":"from typing import List def solve_sudoku(board: List[List[str]]) -> None: Solves the Sudoku puzzle by filling the empty cells. def is_valid(board, row, col, num): Check if it\'s valid to place num at board[row][col]. for i in range(9): if board[row][i] == num: return False if board[i][col] == num: return False if board[row//3*3 + i//3][col//3*3 + i%3] == num: return False return True def solve(board): Solve the Sudoku board using backtracking. for row in range(9): for col in range(9): if board[row][col] == \'.\': for num in \'123456789\': if is_valid(board, row, col, num): board[row][col] = num if solve(board): return True board[row][col] = \'.\' return False return True solve(board)"},{"question":"Given an array of integers, implement a function that returns the indices of two distinct elements that sum up to a specific target. You may assume that the input array has exactly one solution, and each element can only be used once in forming the pair. # Input * An array of integers `nums`, where 1 <= `len(nums)` <= 10^5, and -10^9 <= `nums[i]` <= 10^9. * An integer `target`, where -10^9 <= `target` <= 10^9. # Output Return a tuple (i, j) of the indices of the two numbers such that `nums[i]` + `nums[j]` == `target`. The indices should be returned in a sorted order, i.e., (i, j) with i < j. Constraints: * The input array will contain exactly one solution. * You may not use the same element twice. * The returned indices must be in ascending order. # Example Given `nums = [2, 7, 11, 15]`, `target = 9`, the function should return `(0, 1)`, because `nums[0] + nums[1] = 2 + 7 = 9`. # Function Signature ```python def two_sum(nums: List[int], target: int) -> Optional[Tuple[int, int]]: # Your code here ``` Ensure your code handles: 1. Efficiently finding the pair of indices. 2. Edge cases such as minimal array lengths. 3. Preventing the reuse of the same element.","solution":"from typing import List, Tuple, Optional def two_sum(nums: List[int], target: int) -> Optional[Tuple[int, int]]: Returns a tuple (i, j) of the indices of two numbers such that nums[i] + nums[j] == target. The indices are returned in sorted order (i < j). :param nums: List of integers. :param target: Target sum to find in the list. :return: A tuple (i, j) of the indices of two numbers whose sum equals target. num_to_index = {} for index, num in enumerate(nums): complement = target - num if complement in num_to_index: return (num_to_index[complement], index) num_to_index[num] = index return None"},{"question":"# Pathfinding in a Directed Graph You are working on a navigation system and need to determine if there is a direct or indirect path between two locations represented as nodes in a directed graph. Implement a Python function to check if there is a path between a given source and a target node using Depth First Search (DFS). Function Signature ```python def is_path(graph: List[List[int]], vertex_count: int, source: int, target: int) -> bool: Determine if there is a path from source to target in a directed graph. :param graph: A list of lists where each sublist represents directed edges from a given vertex. :param vertex_count: Total number of vertices in the graph. :param source: The source vertex. :param target: The target vertex. :return: True if there is a path from source to target, False otherwise. ``` Input - `graph`: List of lists, where each sublist represents the nodes directed from the vertex represented by the index (e.g., `graph[i]` contains all nodes that have an edge from node `i`). - `vertex_count`: Integer representing the number of vertices in the graph. - `source`: Integer representing the starting node. - `target`: Integer representing the destination node. Output - Return `True` if there is a path from `source` to `target`, `False` otherwise. Example ```python graph = [[1, 2], [2], [], [1, 2]] vertex_count = 4 source = 0 target = 2 print(is_path(graph, vertex_count, source, target)) # Output: True source = 3 target = 0 print(is_path(graph, vertex_count, source, target)) # Output: False ``` Constraints - The graph is directed and may contain cycles. - The number of vertices `vertex_count` ranges from 1 to 1000. Remarks Consider edge cases where the source is the same as the target, or no path exists. Optimize for both time and space while clearly handling large and cyclic graphs.","solution":"from typing import List def is_path(graph: List[List[int]], vertex_count: int, source: int, target: int) -> bool: def dfs(current, target, visited): if current == target: return True visited.add(current) for neighbor in graph[current]: if neighbor not in visited: if dfs(neighbor, target, visited): return True return False visited = set() return dfs(source, target, visited)"},{"question":"# Ternary Search with Early Exit You have been provided with the concept and an implementation of the ternary search algorithm, which divides the search space of a sorted array into three parts. Given this background, your task is to implement a modified version of the ternary search algorithm that not only finds the position of a target element but also stops and returns the index as soon as it detects that the search is futile. Requirements: * **Function Signature**: ```python def modified_ternary_search(left: int, right: int, key: int, arr: list) -> int: ``` * **Input**: - `left`: An integer representing the starting index of the array to be searched. - `right`: An integer representing the ending index of the array to be searched. - `key`: An integer representing the value to search for within the array. - `arr`: A list of integers, sorted in ascending order. * **Output**: - Returns the index of the target value `key` if found, otherwise returns -1. * **Constraints**: - `0 <= left <= right < len(arr)` - The array `arr` contains unique elements. Function Logic: 1. Calculate mid1 and mid2 as explained in the base algo. 2. Check for early exit conditions like array bounds. 3. Narrow down the search space intelligently and continue the search until the target is found or the search becomes futile. Example: ```python arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] key = 7 left = 0 right = len(arr) - 1 result = modified_ternary_search(left, right, key, arr) print(result) # Output should be 6, as the index of 7 in the array is 6 ``` **Note**: Your algorithm should be well-documented, efficient, and handle all possible edge cases gracefully.","solution":"def modified_ternary_search(left: int, right: int, key: int, arr: list) -> int: Performs a modified ternary search on a sorted list to find the position of a given key. Parameters: left (int): Starting index of the array to be searched. right (int): Ending index of the array to be searched. key (int): The value to search for within the array. arr (list): A list of integers, sorted in ascending order. Returns: int: Index of the target value `key` if found, otherwise -1. while left <= right: # Calculate mid1 and mid2 mid1 = left + (right - left) // 3 mid2 = right - (right - left) // 3 # Check the early exit conditions if arr[mid1] == key: return mid1 if arr[mid2] == key: return mid2 # Determine which segment the key belongs to if key < arr[mid1]: right = mid1 - 1 elif key > arr[mid2]: left = mid2 + 1 else: left = mid1 + 1 right = mid2 - 1 # The key was not found return -1"},{"question":"Given a string, write a function to find the longest substring without repeating characters and return both the length of this substring and the substring itself. You have to implement this function from scratch, without relying on any code from the given code snippets. # Input Format - **string**: A non-null string, which may contain any alphanumeric characters and/or symbols. # Output Format - A tuple of two values: - **int**: Length of the longest substring without repeating characters. - **string**: The longest substring without repeating characters. # Example Example 1 - **Input**: \\"abcabcbb\\" - **Output**: (3, \\"abc\\") Example 2 - **Input**: \\"bbbbb\\" - **Output**: (1, \\"b\\") Example 3 - **Input**: \\"pwwkew\\" - **Output**: (3, \\"wke\\") # Constraints - The string length will not exceed 10000. - The string can include any ASCII characters. # Requirements - You should aim for a time complexity of O(n) where n is the length of the input string. - The solution should handle edge cases like an empty string or string with all identical characters.","solution":"def longest_substring_without_repeating_characters(s): Returns the length of the longest substring without repeating characters and the substring itself. if not s: return 0, \\"\\" start, max_length = 0, 0 longest_substring = \\"\\" seen = {} for end in range(len(s)): if s[end] in seen and seen[s[end]] >= start: start = seen[s[end]] + 1 seen[s[end]] = end current_length = end - start + 1 if current_length > max_length: max_length = current_length longest_substring = s[start:end+1] return max_length, longest_substring"},{"question":"# Bogo Sort Assessment **Context**: Bogo Sort is a notoriously inefficient sorting algorithm that repeatedly shuffles an array until it is sorted. Understanding this algorithm can help solidify your grasp of more complex and efficient sorting techniques. **Task**: Implement a function `optimized_bogo_sort(arr)` that reduces the overall complexity of sorted check operation. The current implementation uses a linear pass to verify sorted order. Function Signature ```python def optimized_bogo_sort(arr, simulation=False) -> list: pass ``` Input: - `arr` (List[int]): A list of integers to be sorted. - `simulation` (bool, optional): A flag to enable simulation mode that prints each iteration. Default is `False`. Output: - Returns the sorted list of integers. Constraints: - You may assume the list contains at least 1 and at most 100 elements. - Values in the list are within the range -1000 to 1000. Requirements: 1. Your function should implement an optimization that skips unnecessary checks or operations if a sub-list has already been verified as sorted in the previous iterations. 2. The function should handle edge cases such as already sorted arrays and arrays with repeating elements gracefully. 3. Maintain the optional simulation mode to visualize iterations. Example: ```python print(optimized_bogo_sort([3, 2, 1], simulation=True)) ``` Output: ``` iteration 0 : 3 2 1 iteration 1 : 2 3 1 iteration 2 : 3 1 2 ... iteration N : 1 2 3 [1, 2, 3] ``` **Note:** This question primarily assesses your understanding of inefficient algorithms, as well as your ability to make improvements and optimizations within given constraints. Although Bogo Sort is impractical, gaining insights from its operation can be valuable for recognizing algorithm efficiency.","solution":"import random def optimized_bogo_sort(arr, simulation=False): Optimized Bogo Sort Algorithm Shuffles the array until it is sorted. Parameters: arr (list): A list of integers to be sorted. simulation (bool): A flag to enable simulation mode that prints each iteration. Default is False. Returns: list: Sorted list of integers. def is_sorted(arr): Helper function to check if the array is sorted. for i in range(len(arr) - 1): if arr[i] > arr[i + 1]: return False return True attempt = 0 while not is_sorted(arr): if simulation: print(f\\"iteration {attempt} : {\' \'.join(map(str, arr))}\\") random.shuffle(arr) attempt += 1 if simulation: print(f\\"iteration {attempt} : {\' \'.join(map(str, arr))}\\") return arr"},{"question":"# Encoding and Decoding Strings You are tasked with designing a pair of functions to encode a list of strings into a single string and to decode that string back into its original list of strings. This will be useful for transmitting or storing lists of strings where the structure needs to be preserved and is not easily reconstructed from the serialized format. Function Implementations 1. **`encode` Function**: ```python def encode(strs): Encodes a list of strings to a single string. :param strs: List[str], List of strings to be encoded. :return: str, A single string representing the encoded list. ``` 2. **`decode` Function**: ```python def decode(s): Decodes a single string to a list of strings. :param s: str, The encoded string. :return: List[str], The decoded list of strings. ``` Input and Output - **For `encode`**: - **Input**: A list of strings (List[str]). - **Output**: A single encoded string (str). - **For `decode`**: - **Input**: A single encoded string (str). - **Output**: A list of the original strings (List[str]). Constraints and Requirements: - The encoded string should be as compact as possible. - The decoded list of strings must match the original list exactly. - Handle special cases such as empty strings and strings containing the delimiter \\":\\". - Ensure the solution handles large lists of strings and long strings efficiently. Scenarios: 1. **Basic Example**: - Input: `[\\"hello\\", \\"world\\"]` - Encoded String Example: `\\"5:hello5:world\\"` - Decoded Result: `[\\"hello\\", \\"world\\"]` 2. **Containing Delimiters**: - Input: `[\\"hello:there\\", \\"this:is\\", \\"a:test\\"]` - Ensure the encoding and decoding appropriately handle the embedded \\":\\" character. 3. **Empty Strings**: - Input: `[\\"\\", \\"this\\", \\"\\", \\"is\\", \\"a\\", \\"test\\", \\"\\"]` - Encoded Output should properly include information about empty strings. Be mindful of edge cases and ensure the functions remain performant with various input sizes.","solution":"def encode(strs): Encodes a list of strings to a single string. :param strs: List[str], List of strings to be encoded. :return: str, A single string representing the encoded list. encoded_strs = [] for s in strs: encoded_strs.append(f\\"{len(s)}:{s}\\") return \\"\\".join(encoded_strs) def decode(s): Decodes a single string to a list of strings. :param s: str, The encoded string. :return: List[str], The decoded list of strings. decoded_strs = [] i = 0 while i < len(s): colon_index = s.find(\\":\\", i) length = int(s[i:colon_index]) start = colon_index + 1 decoded_strs.append(s[start:start+length]) i = start + length return decoded_strs"},{"question":"**Context**: In a large network of cities, you are required to find different traversal paths to ensure that every city can be visited starting from a given city. Each city is represented as a node, and each direct route between cities is represented as an edge in the graph. **Task**: Given an undirected graph represented as an adjacency list, implement functions for Depth-First Search (both iterative and recursive) and Breadth-First Search starting from a given city (node). # Function Specifications **Function 1: dfs_traverse(graph, start)** * **Input**: * `graph`: A dictionary where each key is a node and the value is a list of connected nodes. * `start`: The starting node for the traversal. * **Output**: A set of nodes representing the order in which nodes are visited. **Function 2: bfs_traverse(graph, start)** * **Input**: * `graph`: A dictionary where each key is a node and the value is a list of connected nodes. * `start`: The starting node for the traversal. * **Output**: A set of nodes representing the order in which nodes are visited. **Function 3: dfs_traverse_recursive(graph, start, visited=None)** * **Input**: * `graph`: A dictionary where each key is a node and the value is a list of connected nodes. * `start`: The starting node for the traversal. * `visited`: (Optional) A set of nodes that have been visited so far. * **Output**: A set of nodes representing the order in which nodes are visited. # Constraints * The graph can be disconnected. * The graph may contain cycles. * All nodes referred to in the edges are present as keys in the adjacency list. * The start node will always be a key in the adjacency list. # Example **Graph Representation:** ```python graph = { \'A\': [\'B\', \'C\'], \'B\': [\'A\', \'D\', \'E\'], \'C\': [\'A\', \'F\'], \'D\': [\'B\'], \'E\': [\'B\', \'F\'], \'F\': [\'C\', \'E\'] } ``` **DFS Iterative Output**: ```python dfs_traverse(graph, \'A\') # Example Output: {\'A\', \'B\', \'D\', \'E\', \'F\', \'C\'} ``` **BFS Output**: ```python bfs_traverse(graph, \'A\') # Example Output: {\'A\', \'B\', \'C\', \'D\', \'E\', \'F\'} ``` **DFS Recursive Output**: ```python dfs_traverse_recursive(graph, \'A\') # Example Output: {\'A\', \'B\', \'D\', \'E\', \'F\', \'C\'} ``` **Note**: The exact order of the nodes in the output set may vary based on implementation, as long as the correct traversal logic is followed.","solution":"def dfs_traverse(graph, start): Perform iterative Depth-First Search (DFS) starting from the given node. :param graph: dict, adjacency list of the graph :param start: starting node for the traversal :return: set of visited nodes visited = set() stack = [start] while stack: node = stack.pop() if node not in visited: visited.add(node) stack.extend(graph[node]) return visited def bfs_traverse(graph, start): Perform Breadth-First Search (BFS) starting from the given node. :param graph: dict, adjacency list of the graph :param start: starting node for the traversal :return: set of visited nodes visited = set() queue = [start] while queue: node = queue.pop(0) if node not in visited: visited.add(node) queue.extend(graph[node]) return visited def dfs_traverse_recursive(graph, start, visited=None): Perform recursive Depth-First Search (DFS) starting from the given node. :param graph: dict, adjacency list of the graph :param start: starting node for the traversal :param visited: set of already visited nodes :return: set of visited nodes if visited is None: visited = set() if start not in visited: visited.add(start) for neighbor in graph[start]: dfs_traverse_recursive(graph, neighbor, visited) return visited"},{"question":"You are to implement a program to simulate a priority queue using a Binary Min Heap data structure. You will be provided with a series of operations that are to be performed on the heap. The heap must be implemented as a complete binary tree using an array-based representation. # Operations 1. **insert(val)**: Insert a value `val` into the heap. 2. **remove_min()**: Remove and return the minimum value from the heap. 3. **get_min()**: Return the minimum value from the heap without removing it. # Task You are required to implement the following functions for the heap: 1. `insert(val: int) -> None`: - Inserts the value `val` into the heap. 2. `remove_min() -> int`: - Removes and returns the minimum value from the heap. If the heap is empty, return `None`. 3. `get_min() -> int`: - Returns the minimum value from the heap without removing it. If the heap is empty, return `None`. # Example ```python heap = BinaryHeap() heap.insert(10) heap.insert(5) heap.insert(15) print(heap.get_min()) # Output: 5 print(heap.remove_min()) # Output: 5 print(heap.get_min()) # Output: 10 heap.insert(2) print(heap.get_min()) # Output: 2 ``` # Constraints - The number of operations will be at most 100,000. - Each value inserted will be an integer between -10^9 and 10^9. # Notes - Ensure that the heap maintains the min heap property after each insert and remove operation. - You should not use any built-in heap libraries or functions; implement heap operations manually. Implement the following methods in the `BinaryHeap` class: ```python class BinaryHeap: def __init__(self): self.current_size = 0 self.heap = [0] def perc_up(self, i): pass def insert(self, val: int) -> None: pass def min_child(self, i): pass def perc_down(self, i): pass def remove_min(self) -> int: pass def get_min(self) -> int: pass ```","solution":"class BinaryHeap: def __init__(self): self.heap = [] def perc_up(self, index): parent_index = (index - 1) // 2 if index > 0 and self.heap[index] < self.heap[parent_index]: self.heap[index], self.heap[parent_index] = self.heap[parent_index], self.heap[index] self.perc_up(parent_index) def insert(self, val: int) -> None: self.heap.append(val) self.perc_up(len(self.heap) - 1) def min_child(self, index): left_child_index = 2 * index + 1 right_child_index = 2 * index + 2 if right_child_index < len(self.heap): if self.heap[left_child_index] < self.heap[right_child_index]: return left_child_index else: return right_child_index elif left_child_index < len(self.heap): return left_child_index return -1 def perc_down(self, index): min_child_index = self.min_child(index) if min_child_index != -1 and self.heap[index] > self.heap[min_child_index]: self.heap[index], self.heap[min_child_index] = self.heap[min_child_index], self.heap[index] self.perc_down(min_child_index) def remove_min(self) -> int: if len(self.heap) == 0: return None if len(self.heap) == 1: return self.heap.pop() min_val = self.heap[0] self.heap[0] = self.heap.pop() self.perc_down(0) return min_val def get_min(self) -> int: if len(self.heap) == 0: return None return self.heap[0]"},{"question":"You are given a positive integer `n`. Your task is to write a function `int_partition(n)` that computes the number of ways to partition the integer into sums of other integers, where the order of terms does not matter. # Function Specification: ```python def int_partition(n: int) -> int: Returns the number of integer partitions for a given positive integer n. Parameters: n (int): Positive integer to find the partition count for. Returns: int: Number of integer partitions of n. ``` # Input: * A single integer `n` where (1 leq n leq 100). # Output: * An integer representing the total number of partitions of the input integer `n`. # Example: ```python print(int_partition(4)) # Output: 5 print(int_partition(7)) # Output: 15 ``` # Explanation: For `n = 4`, there are 5 integer partitions: ``` 4 = 4 4 = 3 + 1 4 = 2 + 2 4 = 2 + 1 + 1 4 = 1 + 1 + 1 + 1 ``` For `n = 7`, there are 15 integer partitions: ``` 7 = 7 7 = 6 + 1 7 = 5 + 2 7 = 5 + 1 + 1 7 = 4 + 3 7 = 4 + 2 + 1 7 = 4 + 1 + 1 + 1 7 = 3 + 3 + 1 7 = 3 + 2 + 2 7 = 3 + 2 + 1 + 1 7 = 3 + 1 + 1 + 1 + 1 7 = 2 + 2 + 2 + 1 7 = 2 + 2 + 1 + 1 + 1 7 = 2 + 1 + 1 + 1 + 1 + 1 7 = 1 + 1 + 1 + 1 + 1 + 1 + 1 ``` # Constraints: - Your solution should run within O(n^2) time complexity. - You may assume the input integer is within the range [1, 100]. # Note: Think about how you will handle large values and whether your function will work within Memory constraints for large values of `n`. Additionally, ensure your function handles small edge cases properly.","solution":"def int_partition(n: int) -> int: Returns the number of integer partitions for a given positive integer n. Parameters: n (int): Positive integer to find the partition count for. Returns: int: Number of integer partitions of n. # Create a list to store the number of partitions for each number up to n partitions = [0] * (n + 1) partitions[0] = 1 # There\'s exactly one way to partition 0: using no parts # Use dynamic programming to count the partitions for i in range(1, n + 1): # Current integer to use in partitions for j in range(i, n + 1): # Update partitions for values >= i partitions[j] += partitions[j - i] return partitions[n]"},{"question":"# Gnome Sort Implementation and Improvement You are tasked with implementing the Gnome Sort algorithm and improving it to handle larger datasets more efficiently. Gnome Sort is an intuitive sorting algorithm, but it can be optimized for better performance in certain scenarios. Function Signature: ```python def gnome_sort_optimized(arr: List[int]) -> List[int]: pass ``` Input: * An array `arr` of integers of length `n` (1 <= n <= 10^6). Output: * Returns the sorted version of the input array. Constraints: * The array can contain positive, negative, and zero values. * Try to improve the best case and average case time complexity as much as possible. Requirements: * **Gnome Sort Implementation**: Begin by implementing the basic Gnome Sort algorithm as provided in the code snippet. * **Optimization**: Modify the algorithm to handle nearly sorted arrays more efficiently. You can combine gnome sort with other strategies to enhance performance. * **Edge Cases Consideration**: Handle all edge cases such as an empty array, single element array, and already sorted arrays. Example: ```python assert gnome_sort_optimized([34, 2, 10, -9]) == [-9, 2, 10, 34] assert gnome_sort_optimized([]) == [] assert gnome_sort_optimized([1]) == [1] assert gnome_sort_optimized([5, -2, 3, 0, -2]) == [-2, -2, 0, 3, 5] ``` # Scenario Your local robotics competition requires sorting various lists of sensor readings to quickly find median values and outliers. Despite the ease of implementation, the Gnome Sort\'s performance degrades with longer lists. Your task is to ensure the lists, especially large ones, are sorted efficiently to keep the systems running smoothly.","solution":"from typing import List def gnome_sort_optimized(arr: List[int]) -> List[int]: n = len(arr) if n <= 1: return arr idx = 0 while idx < n: if idx == 0 or arr[idx] >= arr[idx - 1]: idx += 1 else: arr[idx], arr[idx - 1] = arr[idx - 1], arr[idx] idx -= 1 return arr"},{"question":"Perfect Square Detection and Successor Computation Context: Consider you are tasked with designing a mathematical utility that involves detecting perfect squares and determining subsequent perfect squares for educational software. Problem Statement: Write a function `find_next_perfect_square(n)` that takes an integer `n` and returns the next perfect square if `n` is a perfect square. If `n` is not a perfect square, the function should return `-1`. Input Format: - A single integer `n` (0 <= n <= 10^12). Output Format: - A single integer that represents the next perfect square if `n` is a perfect square; otherwise, -1. Function Signature: ```python def find_next_perfect_square(n: int) -> int: # Your code here ``` Example: ```python assert find_next_perfect_square(121) == 144 # 121 is 11^2, the next perfect square is 12^2 = 144 assert find_next_perfect_square(625) == 676 # 625 is 25^2, the next perfect square is 26^2 = 676 assert find_next_perfect_square(114) == -1 # 114 is not a perfect square, hence return -1 assert find_next_perfect_square(0) == 1 # 0 is a perfect square, the next perfect square is 1 (1^2) ``` Constraints: - Ensure the function handles very large values within the given range efficiently. - Consider the edge cases mentioned in the analysis. Performance Requirements: - The function should run in constant time with respect to its operations.","solution":"import math def find_next_perfect_square(n: int) -> int: sqrt_n = math.isqrt(n) if sqrt_n * sqrt_n == n: next_perfect_square = (sqrt_n + 1) * (sqrt_n + 1) return next_perfect_square return -1"},{"question":"# Challenge: Reverse Words in a Sentence You are given a sentence as a string. Your task is to reverse the order of the words in the sentence without changing the individual word itself. Each word in the sentence is separated by a single space. # Function Signature: `def reverse_words_in_sentence(sentence: str) -> str:` # Input: * A string `sentence` with a length of up to 1000 characters. # Output: * A string which is the input sentence with the words in reversed order. # Constraints: * The input sentence should not have leading or trailing spaces. * Words are guaranteed to be separated by a single space. * Each word consists of only alphabetic characters. # Performance Requirements: * The function should run in linear time with respect to the length of the input string. # Examples: Example 1: ```python input: \\"I am a student\\" output: \\"student a am I\\" ``` Example 2: ```python input: \\"hello world\\" output: \\"world hello\\" ``` # Implementation Guidelines: 1. Split the input string into words. 2. Reverse the list of words. 3. Join the reversed list back into a single string with a single space separating the words. 4. Return the resulting string.","solution":"def reverse_words_in_sentence(sentence: str) -> str: Reverses the order of words in a given sentence without changing the individual words themselves. Parameters: sentence (str): A string representing the sentence to be reversed. Returns: str: The sentence with the words in reversed order. words = sentence.split() reversed_words = words[::-1] reversed_sentence = \' \'.join(reversed_words) return reversed_sentence"},{"question":"You are provided with an array of integers where every element appears exactly twice, except for one element which appears exactly once. Your task is to implement a function that finds and returns the unique element that does not have a duplicate. **Input**: - An integer array `nums` where 1 <= `len(nums)` <= 10^5 and every element in the array appears twice except for one. **Output**: - The integer element that appears only once. **Constraints**: - The solution must have a linear runtime complexity O(n). - Use of extra memory beyond a few variables is discouraged. **Function Signature**: ```python def find_unique(nums: List[int]) -> int: pass ``` # Example Example 1: **Input**: ```json { \\"nums\\": [4, 1, 2, 1, 2] } ``` **Output**: ```json { \\"result\\": 4 } ``` Example 2: **Input**: ```json { \\"nums\\": [2, 2, 1] } ``` **Output**: ```json { \\"result\\": 1 } ``` # Guidelines 1. Implement the function `find_unique` in Python. 2. Make sure your solution performs in O(n) time complexity. 3. Do not use extra memory beyond what is needed for input processing and a few constant variables. # Note You can use the XOR operation to solve this problem efficiently. The properties of XOR operation make it possible to identify the unique element effectively.","solution":"from typing import List def find_unique(nums: List[int]) -> int: Finds the unique number in the list that appears only once. All other numbers appear exactly twice. :param nums: List of integers. :return: The integer that appears only once. unique_number = 0 for num in nums: unique_number ^= num return unique_number"},{"question":"You are given a singly linked list. Your task is to rotate the linked list to the right by a given number of positions. Function Signature: ```python def rotate_right(head: Optional[ListNode], k: int) -> Optional[ListNode]: pass ``` Input: * `head`: The head of the singly linked list. (0 <= size of linked list <= 10^5) * `k`: A non-negative integer representing the number of positions to rotate the list. Output: * The head of the rotated singly linked list. Detailed Requirements: 1. If the list is empty, return `None`. 2. If the list has only one node, it should remain unchanged regardless of the value of `k`. 3. Utilize modular arithmetic to handle cases where `k` is greater than or equal to the length of the list. 4. You must aim for a time complexity of O(n) and a space complexity of O(1). # Example: Example 1: ```text Input: head = [1, 2, 3, 4, 5], k = 2 Output: [4, 5, 1, 2, 3] Explanation: Rotating the list right by 2 positions results in 4->5->1->2->3. ``` Example 2: ```text Input: head = [0, 1, 2], k = 4 Output: [2, 0, 1] Explanation: Rotating the list right by 4 is the same as rotating by 1 position (since 4 % 3 = 1). ``` # Constraints: * The number of nodes in the list will be in the range [0, 100,000]. * 0 <= k <= 2 * 10^9 Implement the given function using the provided guidelines and ensure it properly handles edge cases and maintains the specified complexity requirements.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def rotate_right(head: ListNode, k: int) -> ListNode: # Base cases if not head or not head.next or k == 0: return head # First, we need to determine the size of the list old_tail = head length = 1 while old_tail.next: old_tail = old_tail.next length += 1 # Make the list circular old_tail.next = head # Find the new tail: (length - k % length - 1)th node # and the new head: (length - k % length)th node new_tail = head for _ in range(length - k % length - 1): new_tail = new_tail.next new_head = new_tail.next # Break the circle new_tail.next = None return new_head"},{"question":"**Objective**: Develop a function that can convert integers into their hexadecimal string representation and back, supporting both little-endian and big-endian formats. **Function Descriptions**: 1. `int_to_hex(num: int, endian: str) -> str` * Converts an integer to a hexadecimal string in the specified endianness. * **Parameters**: - `num`: an integer to convert. - `endian`: a string indicating the byte order, either \\"big\\" or \\"little\\". * **Returns**: A hexadecimal string. 2. `hex_to_int(hexstr: str, endian: str) -> int` * Converts a hexadecimal string in the specified endianness back to an integer. * **Parameters**: - `hexstr`: a hexadecimal string to convert. - `endian`: a string indicating the byte order, either \\"big\\" or \\"little\\". * **Returns**: The integer value. **Constraints**: - Non-negative integers only (i.e., (0 le num le 2^{64}-1)). - Hexadecimal strings should not include \'0x\' prefix. **Examples**: ```python assert int_to_hex(255, \'big\') == \'ff\' assert int_to_hex(255, \'little\') == \'ff\' assert hex_to_int(\'ff\', \'big\') == 255 assert hex_to_int(\'ff\', \'little\') == 255 assert int_to_hex(4095, \'big\') == \'0fff\' assert int_to_hex(4095, \'little\') == \'ff0f\' assert hex_to_int(\'0fff\', \'big\') == 4095 assert hex_to_int(\'ff0f\', \'little\') == 4095 ``` **Scenario**: You are working on a low-level system programming project involving communication between two processors with different byte orders. To ensure correct interpretation of transmitted data, you decide to implement a utility to convert between integers and their hexadecimal representations respecting endianess. **Additional Notes**: - Pay attention to leading zeroes in hexadecimal representations where appropriate. - Think about how to convert the bytes correctly depending on the endian specified.","solution":"def int_to_hex(num: int, endian: str) -> str: Converts an integer to a hexadecimal string in the specified endianness. Parameters: - num (int): An integer to convert. - endian (str): A string indicating the byte order, either \\"big\\" or \\"little\\". Returns: - str: The hexadecimal string representation of the integer. if endian not in [\\"big\\", \\"little\\"]: raise ValueError(\\"Endianness must be either \'big\' or \'little\'\\") hex_str = format(num, \'x\') # Convert integer to hex without \'0x\' if len(hex_str) % 2 != 0: hex_str = \'0\' + hex_str # Ensure even number of characters if endian == \\"little\\": bytes_arr = [hex_str[i:i+2] for i in range(0, len(hex_str), 2)] bytes_arr.reverse() hex_str = \'\'.join(bytes_arr) return hex_str def hex_to_int(hexstr: str, endian: str) -> int: Converts a hexadecimal string in the specified endianness back to an integer. Parameters: - hexstr (str): A hexadecimal string to convert. - endian (str): A string indicating the byte order, either \\"big\\" or \\"little\\". Returns: - int: The integer value. if endian not in [\\"big\\", \\"little\\"]: raise ValueError(\\"Endianness must be either \'big\' or \'little\'\\") if len(hexstr) % 2 != 0: hexstr = \'0\' + hexstr # Ensure even number of characters if endian == \\"little\\": bytes_arr = [hexstr[i:i+2] for i in range(0, len(hexstr), 2)] bytes_arr.reverse() hexstr = \'\'.join(bytes_arr) return int(hexstr, 16)"},{"question":"**Two Sum Problem - Optimized Version** # Objective You are given an array of integers and a target integer value. Your task is to find and return the indices of the two numbers in the array that add up to the target value. Implement a function `optimized_two_sum(array: List[int], target: int) -> Tuple[int, int]` to solve this problem efficiently. # Input and Output * **Input**: - An array of integers called `array` (size n, where 1 ≤ n ≤ 10^5). Each element in `array` will be between -10^9 and 10^9. - An integer called `target`, to which two integers in `array` should sum up. * **Output**: - A tuple of two integers indicating the indices of the two numbers in the array whose sum is equal to the target. - If there is no such pair, return `None`. # Constraints - There will be exactly one solution for every input array provided. - No element should be used twice (i.e., same index can’t be reused). # Performance - Your solution should be optimized to run in O(n) time complexity. - It should use O(n) additional space if necessary. # Example ```python array = [2, 7, 11, 15] target = 9 print(optimized_two_sum(array, target)) # Output: (0, 1) because array[0] + array[1] = 2 + 7 = 9 ``` # Edge Cases Consider the following while implementing: - Minimal input (`array` of size 2). - Inputs with negative numbers, zero, and large values. - Ensure the function doesn\'t depend on unique values; duplicates may exist. # Implementation ```python def optimized_two_sum(array, target): dic = {} for i, num in enumerate(array): if num in dic: return dic[num], i else: dic[target - num] = i return None ``` Complete the function `optimized_two_sum` as described above and ensure it handles all edge cases efficiently.","solution":"from typing import List, Tuple, Optional def optimized_two_sum(array: List[int], target: int) -> Optional[Tuple[int, int]]: Find two indices in the array such that the numbers at those indices add up to the target value. Return a tuple of the indices. If no such pair exists, return None. num_to_index = {} for index, num in enumerate(array): complement = target - num if complement in num_to_index: return (num_to_index[complement], index) num_to_index[num] = index return None"},{"question":"<|Analysis Begin|> # Algorithm Analysis Core Identification * **Algorithm/Data Structure**: This problem is based on a dynamic programming approach to solve the Egg Dropping Puzzle. * **Complexity**: The time complexity of the dynamic programming solution is O(N*K^2), and the space complexity is O(N*K). * **Principles**: The core of this algorithm is to minimize the worst-case number of trials needed to determine the critical floor F. It uses a 2D table where each entry represents the minimum number of drops required for a given number of floors and eggs. Characteristics & Applications * **Properties**: The dynamic programming table fills based on the recurrence relation. Each entry considers the maximum drops resulting from either the egg breaking or not breaking at a particular floor drop, thereby ensuring the worst-case scenario is minimized. * **Common Use Cases**: This problem is a classical problem typically used in teaching dynamic programming and optimization problems. * **Strengths/Limitations**: - *Strengths*: Ensures the minimum number of drops in the worst-case scenario. - *Limitations*: The algorithm is computationally intensive for large values of N and K, with quadratic complexity in terms of floors and eggs. Implementation Challenges * **Edge Cases**: - F = 0 or F = N. - K = 1 (one egg case). * **Performance Bottlenecks**: The nested loops and repeated computations make the algorithm slow for very large inputs. * **Error Scenarios**: Incorrect table initialization or update logic can lead to wrong answers. * **Optimization Points**: Using memoization techniques to avoid repeated calculations can improve runtime efficiency. <|Analysis End|> <|Question Begin|> # Egg Dropping Puzzle Assessment Given K eggs, and a building with N floors from 1 to N, you are tasked to determine the minimum number of moves needed to find the critical floor F such that any egg dropped above floor F will break, and any egg dropped at or below floor F will not break. You need to compute this in the worst-case scenario. Function Signature ```python def min_egg_drops(K: int, N: int) -> int: pass ``` Input * `K` (1 ≤ K ≤ 100): Number of eggs. * `N` (1 ≤ N ≤ 100): Number of floors. Output Return an integer representing the minimum number of moves required in the worst-case scenario. Constraints * The function should handle edge cases where F = 0 or F = N. * Minimize the worst-case scenarios, and handle cases with different combinations of K and N effectively. Scenarios & Context Consider an edge case where you only have 1 egg and need to determine the critical floor out of 100 floors. The problem requires the understanding and implementation of dynamic programming principles to achieve the optimal solution. Example ```python # Example 1 K = 1; N = 2 # Drops: [drop from floor 1, if it breaks, F = 0, if not, drop from floor 2] # Minimum moves = 2 print(min_egg_drops(K, N)) # Output: 2 # Example 2 K = 2; N = 6 # Minimum moves = 3 print(min_egg_drops(K, N)) # Output: 3 # Example 3 K = 3; N = 14 # Minimum moves = 4 print(min_egg_drops(K, N)) # Output: 4 ``` Note * Use dynamic programming to build a solution. * Consider optimization techniques to improve performance for large inputs. Implement the function to verify it correctly calculates the minimum number of moves needed.","solution":"def min_egg_drops(K: int, N: int) -> int: Function to find the minimum number of moves needed in the worst-case scenario to find the critical floor with K eggs and N floors. # Create a DP table where dp[i][j] will represent the minimum number of moves # required for i eggs and j floors. dp = [[0] * (N + 1) for _ in range(K + 1)] # If we have 0 floors, we need 0 moves; if we have 1 floor, we need 1 move for i in range(1, K + 1): dp[i][0] = 0 dp[i][1] = 1 # If we have 1 egg, we need j moves (check each floor from 1 to j) for j in range(1, N + 1): dp[1][j] = j # Fill the rest of the table for i in range(2, K + 1): for j in range(2, N + 1): dp[i][j] = float(\'inf\') for x in range(1, j + 1): # Calculate the number of moves required: # If the egg breaks, we need to check x-1 floors with i-1 eggs # If the egg does not break, we need to check j-x floors with i eggs res = 1 + max(dp[i-1][x-1], dp[i][j-x]) # We need to minimize the maximum number of moves required in the worst-case dp[i][j] = min(dp[i][j], res) # The answer for K eggs and N floors return dp[K][N]"},{"question":"# Combinatorial Coin Change Problem **Problem Statement**: You are given a value `value` and a list of coin denominations `coins`. Your task is to determine how many different ways you can make the change for `value` amount using the available coins. The order in which the coins are used does not matter. # Specifications: * **Function Signature**: `def count(coins: List[int], value: int) -> int:` * **Input Format**: * `coins`: A list of positive integers representing the denominations of the coins. The list can have a length between `0` and `50`. * `value`: A positive integer (0 ≤ value ≤ 5000) representing the total amount for which the change is required. * **Output Format**: * An integer representing the number of ways to make the change for the given `value` using the given `coins`. * **Constraints**: * Coins can have repetitive denominations. * It is assumed that the input `coins` will always have at least one positive integer. # Examples: Example 1: ```python # Input coins = [1, 2, 3] value = 4 # Output 4 ``` Explanation: There are four ways to make the change for `4` cents using coins `[1, 2, 3]`, which are `[1, 1, 1, 1]`, `[1, 1, 2]`, `[2, 2]`, and `[1, 3]`. Example 2: ```python # Input coins = [2, 5, 3, 6] value = 10 # Output 5 ``` Explanation: There are five ways to make the change for `10` cents using coins `[2, 5, 3, 6]`, which are `[2, 2, 2, 2, 2]`, `[2, 2, 3, 3]`, `[2, 2, 6]`, `[2, 3, 5]`, and `[5, 5]`. # Task: Implement the function `count(coins: List[int], value: int) -> int` that adheres to the specifications given.","solution":"from typing import List def count(coins: List[int], value: int) -> int: Returns the number of ways to make change for the given value using the given coin denominations. # Initialize a list to store the count of ways to make change for each value up to the target value ways = [0] * (value + 1) # There is one way to make the value 0, which is to use no coins ways[0] = 1 # Iterate over each coin for coin in coins: # Update the number of ways to make change for each value for i in range(coin, value + 1): ways[i] += ways[i - coin] return ways[value]"},{"question":"Scenario You have been assigned to develop a function for a color sorting machine that needs to sort objects represented by three different colors: red, white, and blue, using integers 0, 1, and 2 respectively. The machine cannot use the default built-in sort function provided by the programming libraries. Task Implement a function `sort_colors(nums)` that will take a list of integers `nums` where each integer represents a color. The function must sort the list in place such that: - All 0s (reds) come first - Followed by all 1s (whites) - Ended by all 2s (blues) # Requirements * **Function Name**: `sort_colors` * **Input**: A list of integers `nums` where each element is either 0, 1, or 2. * **Output**: The function should sort the array in place and return `None`. * **Constraints**: - Do not use any library sort function. - The length of the input array will be between 0 and 10^5. - The elements will be only 0, 1, or 2. * **Performance**: Aim for a solution with O(n) time complexity and O(1) space complexity. Example ```python nums = [2, 0, 2, 1, 1, 0] sort_colors(nums) print(nums) # Output should be [0, 0, 1, 1, 2, 2] ``` # Edge Cases to Consider 1. An empty array should remain unchanged. 2. Arrays with all elements the same (e.g., [0, 0, 0, 0]). 3. Arrays missing one or more color elements (e.g., [0, 1, 1, 0]). Design your implementation carefully to ensure accurate in-place sorting and address all possible edge cases mentioned above.","solution":"def sort_colors(nums): Sorts a list of colors represented by integers 0 (red), 1 (white), and 2 (blue) in-place. low, mid, high = 0, 0, len(nums) - 1 while mid <= high: if nums[mid] == 0: nums[low], nums[mid] = nums[mid], nums[low] low += 1 mid += 1 elif nums[mid] == 1: mid += 1 else: nums[high], nums[mid] = nums[mid], nums[high] high -= 1"},{"question":"# Question: Coin Change Ways Background: You are given a certain amount of `value` in cents and an infinite supply of coins of denominations specified in an array `coins`. Your task is to determine the total number of ways to make the `value` using any number of `coins`. The combination of coins used matters only by their sum and not by the order in which they appear. Objective: Implement a function `count_ways(coins: List[int], value: int) -> int` that returns the number of ways to achieve the given `value` using the specified `coins`. Input: - `coins` (List[int]): A list of integers where each integer represents a coin denomination. Assumed to always be positive. - `value` (int): The value for which you need to find the number of ways to make change. Output: - An integer representing the total number of ways to make the `value` using any number of `coins`. Example 1: ```python coins = [1, 2, 3] value = 4 count_ways(coins, value) # Output should be 4 ``` Explanation: There are four ways to make 4 using [1, 2, 3]: [1, 1, 1, 1], [1, 1, 2], [2, 2], [1, 3]. Example 2: ```python coins = [2, 5, 3, 6] value = 10 count_ways(coins, value) # Output should be 5 ``` Explanation: There are five ways to make 10 using [2, 5, 3, 6]: [2, 2, 2, 2, 2], [2, 2, 3, 3], [2, 2, 6], [2, 3, 5], [5, 5]. Constraints: - 1 <= `value` <= 10^4 - 1 <= len(`coins`) <= 100 - 1 <= `coins[i]` <= 10^4 Notes: - Ensure you handle edge cases like `value` being zero properly. - Consider performance implications for large `value` and `coins` lengths.","solution":"from typing import List def count_ways(coins: List[int], value: int) -> int: Returns the number of ways to make the given value using the specified coins. # Create a list to store the number of ways to make each amount from 0 to value dp = [0] * (value + 1) dp[0] = 1 # There is 1 way to make 0 value: using no coins # Iterate over each coin for coin in coins: # Update the dp list for this coin for amount in range(coin, value + 1): dp[amount] += dp[amount - coin] return dp[value]"},{"question":"# Finding Optimal Transport Routes in a City You have been assigned to develop navigation software for a city\'s public transport system. The city\'s transport network is represented as a graph where intersections are vertices and roads are edges connecting those intersections. Your task is to find various paths between two given intersections to provide route suggestions. Objective Implement a function to find all distinct paths from the starting intersection to the destination intersection in a given city\'s transport network. # Function Signature ```python def find_all_paths(graph: Dict[str, List[str]], start: str, end: str) -> List[List[str]]: pass ``` # Input - `graph`: A dictionary representing the city\'s transport network. Keys are intersection names (strings), and values are lists of strings representing directly connected intersections. - `start`: A string indicating the starting intersection. - `end`: A string indicating the destination intersection. # Output - Return a list of all distinct paths from `start` to `end`. Each path should be represented as a list of intersection names (strings). # Constraints - Assume there are no self-loops and parallel edges. - Intersections are uniquely identified. - There may not be any path from the start to the end (in this case, return an empty list). # Performance Requirements - Aim for correctness first; optimization can follow. - Consider the inherent complexity of finding all paths in terms of possible performance bottlenecks. # Example: ```python graph = { \\"A\\": [\\"B\\", \\"C\\"], \\"B\\": [\\"C\\", \\"D\\"], \\"C\\": [\\"D\\"], \\"D\\": [\\"C\\"], \\"E\\": [\\"F\\"], \\"F\\": [\\"C\\"] } start = \\"A\\" end = \\"D\\" find_all_paths(graph, start, end) ``` Expected Output ```python [[\'A\', \'B\', \'C\', \'D\'], [\'A\', \'B\', \'D\'], [\'A\', \'C\', \'D\']] ```","solution":"def find_all_paths(graph, start, end): def dfs(current, end, path, paths): path.append(current) if current == end: paths.append(path[:]) else: for neighbor in graph.get(current, []): if neighbor not in path: # Prevent cycles dfs(neighbor, end, path, paths) path.pop() all_paths = [] dfs(start, end, [], all_paths) return all_paths"},{"question":"# Hash Table Implementation with Separate Chaining Objective: Your task is to improve the provided `SeparateChainingHashTable` class by implementing a method for resizing the hash table when it becomes too full. This will help maintain efficient operations even as the number of elements grows. Function Signature: ```python class SeparateChainingHashTable: def resize(self, new_size: int) -> None: # Your code goes here ``` Requirements: 1. **Dynamic Resizing**: * Implement the `resize` method that resizes the hash table to `new_size`. * Rehash all existing elements to fit into the new size. 2. **Performance**: * Ensure that resizing maintains efficient average-case time complexity for subsequent operations. 3. **Edge Cases**: * Handle scenarios where `new_size` is less than the current number of elements. * Ensure no data is lost during the resizing process. Input: * `new_size` (int): The new size of the hash table. Output: * None. The method modifies the internal structure of the hash table. Scenario: Consider a hash table that stores a large dataset. To maintain efficient retrieval and update times, the table must resize dynamically. Implementing the `resize` method will help achieve this by redistributing elements across a potentially larger or smaller number of buckets, depending on `new_size`. Example: ```python # Create a new hash table table = SeparateChainingHashTable(size=5) # Add some elements table.put(\\"apple\\", 1) table.put(\\"banana\\", 2) table.put(\\"cherry\\", 3) # Current size is 5, resizing to 10 table.resize(10) # Check if elements are still accessible assert table.get(\\"apple\\") == 1 assert table.get(\\"banana\\") == 2 assert table.get(\\"cherry\\") == 3 ``` Implement the `resize` method in the `SeparateChainingHashTable` class to complete this task.","solution":"class SeparateChainingHashTable: def __init__(self, size=10): self.size = size self.table = [[] for _ in range(self.size)] def hash_function(self, key): return hash(key) % self.size def put(self, key, value): index = self.hash_function(key) for kv in self.table[index]: if kv[0] == key: kv[1] = value return self.table[index].append([key, value]) def get(self, key): index = self.hash_function(key) for kv in self.table[index]: if kv[0] == key: return kv[1] return None def remove(self, key): index = self.hash_function(key) for kv in self.table[index]: if kv[0] == key: self.table[index].remove(kv) return def resize(self, new_size: int) -> None: old_table = self.table self.size = new_size self.table = [[] for _ in range(new_size)] for bucket in old_table: for key, value in bucket: self.put(key, value)"},{"question":"Given a string `s`, write a function `remove_duplicates` that deletes any recurring character, i.e., only the first occurrence of each character is kept in the string, and returns the resultant string with unique characters. # Input Format * A string `s` composed of printable ASCII characters. * Length `0 <= len(s) <= 10^5`. # Output Format * A single string containing only the first occurrences of each character from the input string `s`, maintaining the original order of characters. # Constraints * The function must run efficiently for input strings of length up to 100,000. # Example ```python assert remove_duplicates(\\"interview\\") == \\"intervw\\" assert remove_duplicates(\\"google\\") == \\"gole\\" assert remove_duplicates(\\"aabbcc\\") == \\"abc\\" assert remove_duplicates(\\"\\") == \\"\\" assert remove_duplicates(\\"abababab\\") == \\"ab\\" ``` # Note 1. Ensure your solution optimizes for time complexity considering the input constraints. 2. The output string should not contain any recurring character from the input string. 3. Be careful with performance when appending characters to the resultant string. # Function Signature ```python def remove_duplicates(s: str) -> str: pass ```","solution":"def remove_duplicates(s: str) -> str: Removes duplicate characters from the string `s`, retaining only the first occurrence of each character and maintaining the original order. Parameters: s (str): The input string from which duplicates will be removed. Returns: str: A string with duplicates removed. seen = set() result = [] for char in s: if char not in seen: seen.add(char) result.append(char) return \'\'.join(result)"},{"question":"# Two Sum Problem: Implement Using Any Preferred Method # Objective: Implement a function that finds two numbers in a sorted array that add up to a specific target number and returns their indices. # Function Signature: ```python def two_sum(numbers: List[int], target: int) -> List[int]: pass ``` # Input: * `numbers` (List[int]): A list of integers sorted in ascending order. (1 <= len(numbers) <= 10^4) * `target` (int): The target sum for two numbers in the list. (-10^9 <= target <= 10^9) # Output: * `List[int]`: A list containing two 1-based indices of the two numbers such that they add up to the target. The first index must be less than the second index. # Constraints: * You may assume that each input would have exactly one solution. * You may not use the same element twice. * Ensure the solution is efficient and handles edge cases effectively. # Example: ```python numbers = [2, 7, 11, 15] target = 9 ``` # Expected Output: ```python [1, 2] ``` # Scenario: You are given a sorted array of integers and a target sum. You need to find two distinct numbers in the array whose sum equals the target number and return their 1-based indices. # Task: Implement the `two_sum` function. Validate it thoroughly with edge cases and ensure it performs efficiently for large inputs.","solution":"from typing import List def two_sum(numbers: List[int], target: int) -> List[int]: Finds two numbers in a sorted array that add up to the target number. Args: numbers (List[int]): A list of integers sorted in ascending order. target (int): The target sum for two numbers in the list. Returns: List[int]: A list containing two 1-based indices of the two numbers such that they add up to the target. left, right = 0, len(numbers) - 1 while left < right: current_sum = numbers[left] + numbers[right] if current_sum == target: return [left + 1, right + 1] elif current_sum < target: left += 1 else: right -= 1 raise ValueError(\\"No two sum solution\\")"},{"question":"# Scenario You are responsible for implementing an improved HashTable for a high-performance caching system. Your hash table needs to support efficient dynamic resizing to ensure minimal collisions under high-load scenarios. # Problem Statement Your task is to implement a dynamically resizable hash table employing double hashing to resolve collisions. Your hash table should start with an initial size and resize itself by doubling the size when the load factor exceeds a given threshold. # Function Signature ```python class DynamicResizableHashTable: def __init__(self, initial_size: int = 8, load_factor: float = 0.75): Initialize the hash table with a given initial size and load factor for resizing. pass def put(self, key: int, value: any) -> None: Add a key-value pair to the hash table. If the key already exists, update its value. pass def get(self, key: int) -> any: Retrieve the value associated with the given key. Return None if the key is not found. pass def delete(self, key: int) -> None: Remove the key-value pair associated with the given key. pass def __len__(self) -> int: Return the number of key-value pairs stored in the hash table. pass def _hash1(self, key: int) -> int: First hash function. pass def _hash2(self, key: int) -> int: Second hash function for double hashing. pass def _resize(self) -> None: Resize the table when load factor exceeds the threshold. pass ``` # Input and Output Formats - `initial_size`: An integer representing the initial size of the hash table. - `load_factor`: A floating-point value representing the load factor threshold for resizing. # Constraints - The initial size will be a positive integer. - Keys will be non-negative integers. - Methods should handle exceptions gracefully and perform efficiently. # Performance Requirements - The average time complexity for `put`, `get`, and `delete` should be O(1). - Space complexity should be managed efficiently with dynamic resizing.","solution":"class DynamicResizableHashTable: def __init__(self, initial_size: int = 8, load_factor: float = 0.75): self.size = initial_size self.load_factor = load_factor self.count = 0 self.table = [None] * self.size def put(self, key: int, value: any) -> None: if self.count / self.size >= self.load_factor: self._resize() index = self._hash1(key) step_size = self._hash2(key) while self.table[index] is not None: if self.table[index][0] == key: break index = (index + step_size) % self.size if self.table[index] is None: self.count += 1 self.table[index] = (key, value) def get(self, key: int) -> any: index = self._hash1(key) step_size = self._hash2(key) while self.table[index] is not None: if self.table[index][0] == key: return self.table[index][1] index = (index + step_size) % self.size return None def delete(self, key: int) -> None: index = self._hash1(key) step_size = self._hash2(key) while self.table[index] is not None: if self.table[index][0] == key: self.table[index] = None self.count -= 1 self._rehash() return index = (index + step_size) % self.size def __len__(self) -> int: return self.count def _hash1(self, key: int) -> int: return key % self.size def _hash2(self, key: int) -> int: return 1 + (key % (self.size - 1)) def _resize(self) -> None: old_table = self.table self.size *= 2 self.table = [None] * self.size self.count = 0 for item in old_table: if item is not None: self.put(item[0], item[1]) def _rehash(self) -> None: old_table = [item for item in self.table if item is not None] self.table = [None] * self.size self.count = 0 for item in old_table: self.put(item[0], item[1])"},{"question":"# Scenario You are tasked with developing a sorting mechanism for a set of numeric identifiers representing products in a warehouse. These identifiers are within a small, fixed range due to being generated in sequence, making distribution-based sorts suitable for the task. # Question Write a function `warehouse_pigeonhole_sort` that sorts an array of product identifiers. Leverage the properties of Pigeonhole Sort to ensure optimal performance for this specific use case. # Function Signature ```python def warehouse_pigeonhole_sort(identifiers: List[int]) -> List[int]: pass ``` # Input - `identifiers`: A list of integers representing product identifiers in the warehouse. The list can contain up to 1000 elements and each identifier is within the range of 0 to 999. # Output - Returns the sorted list of product identifiers. # Constraints - 0 ≤ len(identifiers) ≤ 1000 - 0 ≤ identifier ≤ 999 for each element in `identifiers` # Example ```python assert warehouse_pigeonhole_sort([45, 76, 23, 89, 45, 23, 1]) == [1, 23, 23, 45, 45, 76, 89] assert warehouse_pigeonhole_sort([]) == [] assert warehouse_pigeonhole_sort([99, 100, 100, 102]) == [99, 100, 100, 102] ``` # Notes - Ensure the function handles empty lists correctly. - Optimize for performance and space as much as possible within the given constraints.","solution":"from typing import List def warehouse_pigeonhole_sort(identifiers: List[int]) -> List[int]: if not identifiers: return [] min_val = min(identifiers) max_val = max(identifiers) size = max_val - min_val + 1 pigeonholes = [0] * size for identifier in identifiers: pigeonholes[identifier - min_val] += 1 sorted_identifiers = [] for index in range(size): while pigeonholes[index] > 0: sorted_identifiers.append(index + min_val) pigeonholes[index] -= 1 return sorted_identifiers"},{"question":"# Question: You are working on a file management system and need to standardize file paths provided by users. Write a Python function `standardize_file_path(file: str) -> str` that takes a file path as input and returns its absolute path, expanding any user directory symbols. # Function Signature: ```python def standardize_file_path(file: str) -> str: pass ``` # Input: - `file` (str): A string representing a file path. This path could be relative, start with `~` (user\'s home directory), or be an already absolute path. # Output: - (str): The fully qualified absolute path of the input file. # Constraints: - The length of the input string should be between 0 and 1000 characters. - The input string should be a valid file path string. # Examples: ```python print(standardize_file_path(\\"~/documents/report.txt\\")) # Example output: \\"/home/user/documents/report.txt\\" (output may vary based on the user home directory) print(standardize_file_path(\\"./data/config.yaml\\")) # Example output: \\"/current/working/directory/data/config.yaml\\" (output will vary based on the current working directory) print(standardize_file_path(\\"/var/log/system.log\\")) # Example output: \\"/var/log/system.log\\" ``` # Performance Requirements: - The function should run in O(n) time complexity, where n is the length of the input string. - The function should use a constant amount of extra space apart from the input and output strings. # Notes: - The function should handle empty string inputs gracefully. - Handle user directory symbols (`~`) correctly by expanding them using the current user\'s home directory. - Ensure that the resulting path is an absolute path.","solution":"import os def standardize_file_path(file: str) -> str: Takes a file path and returns its absolute path, expanding any user directory symbols (~). return os.path.abspath(os.path.expanduser(file))"},{"question":"# **Heap Sort Implementation and Analysis Task** **Objective**: Implement Heap Sort algorithm using both a max heap and a min heap to sort an array in ascending order. Then, analyze the performance and properties of your implementation. --- **Context**: You are provided with the skeleton of a Heap Sort algorithm using both max heap and min heap. Your task is to complete the implementation and demonstrate its workings by sorting an array of integers in ascending order. Additionally, provide an analysis of your implementation, discussing complexity, edge cases handled, and potential performance bottlenecks. --- **Function Signatures**: ```python def heap_sort(arr): This function should sort an array using both max heap and min heap logic. Parameters: arr (list): The list of integers to be sorted. Returns: list: The sorted list. pass def max_heapify(arr, end): This helper function builds a max heap. Parameters: arr (list): The list of integers. end (int): The index up to which the heap should be built. Returns: None: This function modifies the list in-place. def min_heapify(arr, start): This helper function builds a min heap. Parameters: arr (list): The list of integers. start (int): The index from which the heapifying should start. Returns: None: This function modifies the list in-place. ``` --- **Tasks**: 1. **Sort Using Max Heap**: - Implement the `max_heapify` function to ensure max heap property. - Use this function to develop the `heap_sort` function to sort the given list in ascending order using max heap. 2. **Sort Using Min Heap**: - Implement the `min_heapify` function to ensure min heap property. - Use this function to develop the `heap_sort` function to sort the given list in ascending order using min heap. 3. **Demonstrate**: - Test your implementation with the provided arrays. - `arr = [4, 7, 3, 9, 1]` - `arr = [10, 20, 15, 30, 40]` - `arr = [1, 1, 1, 1, 1]` - Print the sorted arrays. 4. **Analysis**: - Discuss the time and space complexity of your implementation. - Identify and discuss how edge cases are handled. - Analyze potential performance bottlenecks. - Provide suggestions for optimization. --- **Constraints**: - The elements of the array can be between `-10^6` and `10^6`. - The length of the array can be up to `10^4`. **Example**: ```python # Example usage: arr = [4, 7, 3, 9, 1] print(heap_sort(arr)) # Expected output: [1, 3, 4, 7, 9] ``` --- **Note**: Your implementation should cover both max heap and min heap logic separately, but the main `heap_sort` function should sort using either approach based on internal logic. Be sure to thoroughly test and debug your functions before submission.","solution":"def heap_sort(arr): This function sorts an array using both max heap and min heap logic. For the purpose of this task, we will implement the max heap logic. Parameters: arr (list): The list of integers to be sorted. Returns: list: The sorted list. n = len(arr) # Max Heapify for i in range(n // 2 - 1, -1, -1): max_heapify(arr, n, i) for i in range(n-1, 0, -1): # Swap arr[i], arr[0] = arr[0], arr[i] max_heapify(arr, i, 0) return arr def max_heapify(arr, n, i): This helper function builds a max heap. Parameters: arr (list): The list of integers. n (int): The size of the heap. i (int): The index to heapify from. Returns: None: This function modifies the list in-place. largest = i # Initialize largest as root left = 2 * i + 1 # left = 2*i + 1 right = 2 * i + 2 # right = 2*i + 2 # See if left child of root exists and is greater than root if left < n and arr[largest] < arr[left]: largest = left # See if right child of root exists and is greater than root if right < n and arr[largest] < arr[right]: largest = right # Change root, if needed if largest != i: arr[i], arr[largest] = arr[largest], arr[i] # swap # Heapify the root. max_heapify(arr, n, largest) def min_heapify(arr, n, i): This helper function builds a min heap. Parameters: arr (list): The list of integers. n (int): The size of the heap. i (int): The index to heapify from. Returns: None: This function modifies the list in-place. smallest = i # Initialize smallest as root left = 2 * i + 1 # left = 2 * i + 1 right = 2 * i + 2 # right = 2 * i + 2 # See if left child of root exists and is smaller than root if left < n and arr[smallest] > arr[left]: smallest = left # See if right child of root exists and is smaller than root if right < n and arr[smallest] > arr[right]: smallest = right # Change root, if needed if smallest != i: arr[i], arr[smallest] = arr[smallest], arr[i] # swap # Heapify the root. min_heapify(arr, n, smallest)"},{"question":"Question: Determine If Two Strings Are Anagrams # Scenario You are developing a feature for a word game where players can earn points by forming anagrams. The game needs a function to efficiently verify if two words are anagrams of each other. # Task Write a function `is_anagram(s1: str, s2: str) -> bool` that determines if two given strings `s1` and `s2` are anagrams. Two strings are anagrams if they contain the same characters with the same frequencies, but possibly in different orders. # Input and Output * **Input**: - `s1`: A string containing lowercase English letters (1 <= len(s1) <= 10^5) - `s2`: A string containing lowercase English letters (1 <= len(s2) <= 10^5) * **Output**: - Returns `True` if `s1` and `s2` are anagrams, `False` otherwise. # Constraints - Both strings consist of only lowercase English letters. # Performance Requirements - Your solution should run in linear time, O(n), where n is the length of the longer string. - Ensure the space complexity is kept constant, O(1). # Example ```python assert is_anagram(\\"listen\\", \\"silent\\") == True assert is_anagram(\\"triangle\\", \\"integral\\") == True assert is_anagram(\\"apple\\", \\"pleap\\") == True assert is_anagram(\\"apple\\", \\"orange\\") == False assert is_anagram(\\"aabbcc\\", \\"abcabc\\") == True assert is_anagram(\\"aabbcc\\", \\"aabbc\\") == False ``` # Implementation Notes - First, check if the two strings have the same length. If they do not, they cannot be anagrams. - Use two fixed-sized arrays (or dictionaries) to count the frequency of each character in `s1` and `s2`. - Compare these frequency counts to decide if the strings are anagrams.","solution":"def is_anagram(s1: str, s2: str) -> bool: Determine if two strings are anagrams of each other. if len(s1) != len(s2): return False # Create frequency dictionaries for both strings frequency_s1 = {} frequency_s2 = {} for char in s1: if char in frequency_s1: frequency_s1[char] += 1 else: frequency_s1[char] = 1 for char in s2: if char in frequency_s2: frequency_s2[char] += 1 else: frequency_s2[char] = 1 return frequency_s1 == frequency_s2"},{"question":"You are required to implement a function that balances and manages a Red-Black Tree (RBT). The task involves extending the Red-Black Tree functionality provided in the code snippet by implementing a method that finds the kth smallest element in the Red-Black Tree. # Function Signature ```python def kth_smallest_element(tree: RBTree, k: int) -> int: pass ``` # Input - The function **kth_smallest_element** should take two arguments: - **tree**: An instance of the RBTree class. - **k**: An integer representing the position (1-based) of the smallest element required in the Red-Black Tree. # Output - The function should return an integer representing the kth smallest value in the Red-Black Tree. # Constraints - Assume k always falls within the range of the total number of nodes in the tree. - The tree contains distinct values. # Example ```python if __name__ == \\"__main__\\": rb = RBTree() children = [11, 2, 14, 1, 7, 15, 5, 8, 4] for child in children: node = RBNode(child, 1) rb.insert(node) assert kth_smallest_element(rb, 1) == 1 assert kth_smallest_element(rb, 5) == 7 assert kth_smallest_element(rb, 9) == 15 print(\\"All test cases passed!\\") ``` # Explanation 1. After inserting `[11, 2, 14, 1, 7, 15, 5, 8, 4]` in the Red-Black Tree, the in-order traversal (which inherently gives sorted order) of the tree would result in `[1, 2, 4, 5, 7, 8, 11, 14, 15]`. 2. The 1st smallest element is `1`. 3. The 5th smallest element is `7`. 4. The 9th smallest element is `15`. # Notes - Efficiently make use of the tree properties, particularly focusing on in-order traversal to determine the kth smallest value without modifying the tree structure. - Remember to consider the properties and characteristics discussed in the analysis while implementing your solution.","solution":"class RBNode: def __init__(self, data, color, parent=None, left=None, right=None): self.data = data self.color = color self.parent = parent self.left = left self.right = right class RBTree: def __init__(self): self.TNULL = RBNode(0, 0) self.TNULL.color = 0 self.TNULL.left = None self.TNULL.right = None self.root = self.TNULL def insert(self, key): node = RBNode(key, 1, None, None, None) node.parent = None node.data = key node.left = self.TNULL node.right = self.TNULL node.color = 1 # New node must be red y = None x = self.root while x != self.TNULL: y = x if node.data < x.data: x = x.left else: x = x.right node.parent = y if y == None: self.root = node elif node.data < y.data: y.left = node else: y.right = node if node.parent == None: node.color = 0 return if node.parent.parent == None: return self.fix_insert(node) def fix_insert(self, k): # Fix the tree after inserting a node pass # Assume this method is correctly implemented for RB tree. def kth_smallest_element(self, k): def in_order_traversal(r): if r == self.TNULL: return [] return in_order_traversal(r.left) + [r.data] + in_order_traversal(r.right) nums = in_order_traversal(self.root) return nums[k - 1] def kth_smallest_element(tree: RBTree, k: int) -> int: Returns the kth smallest element in the Red-Black Tree. return tree.kth_smallest_element(k)"},{"question":"You are working on a text editor application that supports searching for substrings within a larger text. To improve the performance of the search functionality, you need to implement an efficient string matching algorithm. Task Implement the Knuth-Morris-Pratt (KMP) string matching algorithm that finds all occurrences of a pattern string within a larger text string. Function Signature ```python from typing import List, Sequence def knuth_morris_pratt(text: Sequence[str], pattern: Sequence[str]) -> List[int]: Given two strings text and pattern, return a list of start indexes in text where the pattern occurs. Args: text: The main text to search within. pattern: The pattern string to search for. Returns: List[int]: A list of start indices where each index represents a match of pattern in text. Example: >>> knuth_morris_pratt(\'hello there hero!\', \'he\') [0, 7, 12] ``` Constraints - The length of `text` and `pattern` will not exceed (10^5). - Both `text` and `pattern` will consist of printable ASCII characters. Notes - You are required to handle edge cases such as when the pattern is longer than the text or when either the text or pattern is empty. - Ensure your solution is efficient and adheres to the expected time complexity of (O(N + M)).","solution":"from typing import List, Sequence def knuth_morris_pratt(text: Sequence[str], pattern: Sequence[str]) -> List[int]: Given two strings text and pattern, return a list of start indexes in text where the pattern occurs. if not pattern or not text or len(pattern) > len(text): return [] def compute_lps_array(pattern: str) -> List[int]: Compute the longest prefix suffix (LPS) array lps = [0] * len(pattern) length = 0 # length of the previous longest prefix suffix i = 1 while i < len(pattern): if pattern[i] == pattern[length]: length += 1 lps[i] = length i += 1 else: if length != 0: length = lps[length - 1] else: lps[i] = 0 i += 1 return lps lps = compute_lps_array(pattern) result = [] i = 0 # index for text j = 0 # index for pattern while i < len(text): if pattern[j] == text[i]: i += 1 j += 1 if j == len(pattern): result.append(i - j) j = lps[j - 1] elif i < len(text) and pattern[j] != text[i]: if j != 0: j = lps[j - 1] else: i += 1 return result"},{"question":"You are tasked with enhancing the `ArrayQueue` class by implementing a method to shrink the array size when the number of elements drops below a certain threshold. This shrinking behavior is very useful for optimizing memory usage when the queue size fluctuates. # Requirements: 1. **Method to Implement**: - `def _shrink(self):` - This method should be a private method. - It should shrink the size of the underlying array when the number of elements in the queue is less than 1/4th of the array\'s current capacity. - The size of the new array should not be less than 10, even if the number of elements is lower than that. 2. **Modifications to Existing Methods**: - Update the `dequeue()` method to call `_shrink()` method after removing an element to ensure the array size is optimized. # Input: You only need to implement the class methods; there is no direct input from the user. # Output: No direct output; the correctness will be determined by the functionality of the `ArrayQueue` class through several test cases. # Constraints: - The array should only shrink if the current size is greater than 10. - You must ensure that the order of elements is maintained throughout the shrink process. # Example Scenario: ```python queue = ArrayQueue(capacity=20) for i in range(15): queue.enqueue(i) # Filling the queue for _ in range(13): queue.dequeue() # After these dequeues, resizing should trigger # Now queue\'s internal array should have been shrunk to optimize memory usage. ``` # Function Signature ```python def _shrink(self): # Implement the shrinking logic here # Update dequeue method def dequeue(self): # Current dequeue logic # Call to _shrink method self._shrink() ``` Implement the necessary logic for the `_shrink` method, ensuring that any array resizing operations maintain the order and integrity of the data stored in the queue.","solution":"class ArrayQueue: def __init__(self, capacity=10): self._array = [None] * capacity self._size = 0 self._front = 0 self._rear = 0 def is_empty(self): return self._size == 0 def enqueue(self, item): if self._size == len(self._array): self._resize(2 * len(self._array)) self._array[self._rear] = item self._rear = (self._rear + 1) % len(self._array) self._size += 1 def dequeue(self): if self.is_empty(): raise IndexError(\\"Dequeue from empty queue\\") item = self._array[self._front] self._array[self._front] = None self._front = (self._front + 1) % len(self._array) self._size -= 1 self._shrink() # Call _shrink to optimize array size return item def _resize(self, capacity): new_array = [None] * capacity for i in range(self._size): new_array[i] = self._array[(self._front + i) % len(self._array)] self._array = new_array self._front = 0 self._rear = self._size def _shrink(self): if len(self._array) > 10 and self._size < len(self._array) // 4: new_capacity = max(10, len(self._array) // 2) self._resize(new_capacity)"},{"question":"# Question: Stack Order Validation You are tasked to implement a function that validates whether the elements in a stack are sorted in ascending order from bottom to top. Function Signature ```python def is_sorted(stack): pass ``` # Inputs: - `stack (List[int])`: A list of integers that represent a stack with the top of the stack at the end of the list. # Outputs: - `bool`: Return `True` if the elements are sorted in ascending order from bottom to top, `False` otherwise. # Constraints: - You cannot modify the initial order of elements in the given stack. - Avoid using built-in sort functionalities. - Ensure the function runs in O(n) time complexity and uses O(n) additional space at most. # Example: ```python assert is_sorted([6, 3, 5, 1, 2, 4]) == False assert is_sorted([1, 2, 3, 4, 5, 6]) == True assert is_sorted([1]) == True assert is_sorted([]) == True assert is_sorted([3, 3, 3]) == True ``` # Scenario: Consider that you are developing a system that validates processing steps in a factory. Each step is stored as an integer priority in a stack, and the system processes steps from top to bottom. To ensure smooth operation, the steps must follow an increasing priority order from bottom to top. Implement the function `is_sorted` to ensure this order is followed before processing the tasks.","solution":"def is_sorted(stack): Returns True if the elements in the stack are sorted in ascending order from bottom to top, otherwise returns False. # Edge cases: if the stack is empty or has only one element, it is sorted if len(stack) < 2: return True # Traverse the stack from bottom to top and check the order for i in range(1, len(stack)): if stack[i-1] > stack[i]: return False return True"},{"question":"You have been given the task of implementing a custom stack data structure. However, in addition to the standard stack operations (`push`, `pop`, `peek`, and `is_empty`), your stack must support a new operation called `min()`, which returns the minimum element present in the stack in constant time. # Requirements: - Implement a stack that supports the following operations: - **push(item)**: Adds a new item to the top of the stack. - **pop()**: Removes the top item from the stack. - **peek()**: Returns the top item from the stack without removing it. - **is_empty()**: Checks whether the stack is empty. - **min()**: Returns the minimum item present in the stack. # Constraints: - You can assume that all elements inserted into the stack are integers. - The stack should be able to handle at least `10^5` operations efficiently. - Operations should have the following complexities: - `push`, `pop`, `peek`, `is_empty`, and `min` should all run in average O(1) time. # Input: - Operations in the form of function calls. # Output: - For `min()` operation, return the minimum element in the stack. - For `pop()` operation, return the popped element. # Example: ```python stack = MinStack() stack.push(3) stack.push(5) print(stack.min()) # Output: 3 stack.push(2) stack.push(1) print(stack.min()) # Output: 1 print(stack.pop()) # Output: 1 print(stack.min()) # Output: 2 stack.push(0) print(stack.min()) # Output: 0 ``` # Implementation Guideline: - Use an auxiliary stack to keep track of minimum elements.","solution":"class MinStack: def __init__(self): self.stack = [] self.min_stack = [] def push(self, item): self.stack.append(item) if not self.min_stack or item <= self.min_stack[-1]: self.min_stack.append(item) def pop(self): if self.stack: item = self.stack.pop() if item == self.min_stack[-1]: self.min_stack.pop() return item else: return None # If stack is empty def peek(self): if self.stack: return self.stack[-1] else: return None # If stack is empty def is_empty(self): return len(self.stack) == 0 def min(self): if self.min_stack: return self.min_stack[-1] else: return None # If stack is empty"},{"question":"Design and implement a Zigzag Iterator for `k` lists. This Zigzag Iterator should iterate over the given `k` lists, yielding elements from each in a round-robin fashion. If one list is exhausted, it continues with the remaining lists until all elements in all lists are returned. # Implementation Details: 1. **Class**: `KZigZagIterator` 2. **Constructor**: Takes a list of `k` lists (`list_of_lists`). 3. **Methods**: - `next() -> int`: Returns the next element in the Zigzag order. - `has_next() -> bool`: Returns True if there are more elements to iterate. 4. **Constraints**: - Lists can contain integers, and their lengths may vary. - Lists contain at least one list with non-zero elements. # Example: ```python lists = [ [1, 2, 3], [4, 5, 6, 7], [8, 9] ] iterator = KZigZagIterator(lists) while iterator.has_next(): print(iterator.next()) ``` Expected output: ```plaintext 1 4 8 2 5 9 3 6 7 ``` # Notes: - You must handle edge cases where some lists are empty. - Ensure the solution performs efficiently even for large lists. # Coding Task: Implement the `KZigZagIterator` class according to the specifications provided.","solution":"from collections import deque class KZigZagIterator: def __init__(self, list_of_lists): self.q = deque() # Add indices with tuples (list, index) for lst in list_of_lists: if lst: # Only add non-empty lists self.q.append((lst, 0)) def next(self): if self.has_next(): lst, idx = self.q.popleft() value = lst[idx] # If there is another element in the current list, add it back to the queue if idx + 1 < len(lst): self.q.append((lst, idx + 1)) return value else: raise StopIteration(\\"No more elements\\") def has_next(self): return len(self.q) > 0"},{"question":"# Scenario You work as a software engineer and have been tasked with implementing a data structure that can efficiently handle two types of operations on an array of integers: 1. Query the sum of the first `i` elements. 2. Update the value at a specific index. To achieve this, you decide to use a Binary Indexed Tree (Fenwick Tree). Implement this data structure to support these operations efficiently. # Objective Write a Python class `FenwickTree` with the following methods: * **`__init__(self, arr: List[int]) -> None`**: * Constructor to initialize the Fenwick Tree with the given list of integers. * **`get_sum(self, i: int) -> int`**: * Returns the sum of the elements from the start of the array up to index `i`. * **`update(self, i: int, val: int) -> None`**: * Updates the value at index `i` to `val`. * **`construct_tree(self) -> None`**: * Constructs the Binary Indexed Tree based on the initial array provided during initialization. # Input and Output * **Input**: An initialization list of integers for constructing the Fenwick Tree and subsequent calls to `get_sum` and `update`. * **Output**: Correct results for sum queries and properly updated values in the tree. # Constraints * The index `i` in `get_sum` and `update` is in the range [0, n-1], where `n` is the length of the initialization array. * `0 <= arr[i] <= 10^6` * `1 <= n <= 10^5` # Example ```python # Initialize Fenwick Tree with an array fenwick_tree = FenwickTree([3, 2, -1, 6, 5, 4, -3, 3, 7, 2, 3]) # Construct the tree fenwick_tree.construct_tree() # Get sum of elements from start to index 5 sum_val = fenwick_tree.get_sum(5) # should return 19 # Update the value at index 3 to 10 fenwick_tree.update(3, 10) # Get sum of elements from start to index 5 again after update sum_val = fenwick_tree.get_sum(5) # should return 23 ```","solution":"class FenwickTree: def __init__(self, arr): self.arr = arr self.n = len(arr) self.bit = [0] * (self.n + 1) self.construct_tree() def construct_tree(self): for i in range(self.n): self._update_internal(i, self.arr[i]) def get_sum(self, i): sum = 0 index = i + 1 while index > 0: sum += self.bit[index] index -= index & -index return sum def update(self, i, val): delta = val - self.arr[i] self.arr[i] = val self._update_internal(i, delta) def _update_internal(self, i, delta): index = i + 1 while index <= self.n: self.bit[index] += delta index += index & -index"},{"question":"# Question: Validate Binary Search Tree Objective Given a binary tree, write a function to determine whether it is a valid binary search tree (BST). Function Signature ```python def is_valid_bst(root: Optional[TreeNode]) -> bool: pass ``` Input * `root`: The root node of the binary tree, where each node contains an integer value. Output * Return `True` if the given tree is a valid BST, otherwise return `False`. Constraints * The number of nodes in the tree can range from `0` to `10^4`. * The value of each node will be an integer within the range `-2^31` to `2^31 - 1`. Example 1. **Example 1**: ``` Input: 2 / 1 3 Output: True ``` 2. **Example 2**: ``` Input: 1 / 2 3 Output: False ``` Requirements * Your solution should have a time complexity of O(n), where n is the number of nodes in the tree. * The space complexity should be O(h), where h is the height of the tree. Explanation * You need to implement an in-order traversal of the tree and check if the node values appear in a strictly increasing order. * Use explicit stack management to facilitate traversal and avoid recursion depth issues. Note * Carefully handle the comparison of node values to prevent boundary issues with very large or very small integers while maintaining the properties of a BST. ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_valid_bst(root: Optional[TreeNode]) -> bool: pass ```","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_valid_bst(root: TreeNode) -> bool: def validate(node, low=float(\'-inf\'), high=float(\'inf\')): if not node: return True if not (low < node.val < high): return False return (validate(node.left, low, node.val) and validate(node.right, node.val, high)) return validate(root)"},{"question":"You are assigned the task of developing a software module that implements two different algorithms for solving the Set Cover problem. Your solutions should include: 1. An exact algorithm that finds the minimal cost set cover using exhaustive search. 2. An approximate algorithm that finds a near-optimal cost set cover using a greedy approach. # Detailed Requirements 1. **Optimal Set Cover (Exhaustive Search)**: * Implement the function `optimal_set_cover(universe, subsets, costs)` to find the exact minimal cost set cover. * The function should take three arguments: ```python universe (set): A set of elements to be covered. subsets (dict): A dictionary where keys are subset names and values are sets of elements. costs (dict): A dictionary where keys are subset names and values are the associated costs. Returns: list: A list of subset names forming the minimal cost cover. ``` * Example: ```python universe = {1, 2, 3, 4, 5} subsets = {\'S1\': {4, 1, 3}, \'S2\': {2, 5}, \'S3\': {1, 4, 3, 2}} costs = {\'S1\': 5, \'S2\': 10, \'S3\': 3} optimal_set_cover(universe, subsets, costs) #Output: [\'S3\', \'S2\'] ``` 2. **Greedy Set Cover**: * Implement the function `greedy_set_cover(universe, subsets, costs)` to find a near-optimal cost set cover. * The function should use the same arguments and return format as `optimal_set_cover`. # Constraints * The input set `universe` contains at most 20 elements. * Each key in `subsets` and `costs` has a maximum length of 10 and contains only alphanumeric characters. * Costs are positive integers less than 100. # Performance Requirements * Your `optimal_set_cover` solution should handle inputs up to the maximum constraint efficiently despite its O(2^n) time complexity. * Your `greedy_set_cover` solution should be able to handle the worst-case input within a reasonable time frame. # Edge Cases * If any subset in `subsets` has an empty set of elements. * If the universe cannot be completely covered by the provided subsets. # Code Template ```python def powerset(iterable): Helper function to calculate the powerset. from itertools import chain, combinations s = list(iterable) return chain.from_iterable(combinations(s, r) for r in range(len(s) + 1)) def optimal_set_cover(universe, subsets, costs): # Your implementation here pass def greedy_set_cover(universe, subsets, costs): # Your implementation here pass ```","solution":"from itertools import chain, combinations def powerset(iterable): Helper function to calculate the powerset. s = list(iterable) return chain.from_iterable(combinations(s, r) for r in range(len(s) + 1)) def optimal_set_cover(universe, subsets, costs): min_cost = float(\'inf\') best_cover = None # Loop through all possible combinations of subsets for subset_comb in powerset(subsets.keys()): union_elements = set() total_cost = 0 for subset_key in subset_comb: union_elements |= subsets[subset_key] total_cost += costs[subset_key] if union_elements == universe and total_cost < min_cost: min_cost = total_cost best_cover = subset_comb return list(best_cover) if best_cover else [] def greedy_set_cover(universe, subsets, costs): covered_elements = set() selected_subsets = [] while covered_elements != universe: best_subset = None best_cost_effectiveness = float(\'inf\') for subset, elements in subsets.items(): new_elements = elements - covered_elements if new_elements: cost_effectiveness = costs[subset] / len(new_elements) if cost_effectiveness < best_cost_effectiveness: best_cost_effectiveness = cost_effectiveness best_subset = subset if not best_subset: return [] # If no best subset is found, solution is not possible selected_subsets.append(best_subset) covered_elements |= subsets[best_subset] return selected_subsets"},{"question":"In the world of applications with flash storage, minimizing the number of write operations is paramount to extending the lifespan of storage devices. Your task is to implement the `cycle_sort` algorithm efficiently as described above to sort an array while ensuring minimal write operations. Function Signature ```python def cycle_sort(arr: List[int]) -> List[int]: pass ``` Input - `arr`: A list of integers. e.g., `[4, 3, 2, 1]` Output - A sorted list of integers in ascending order. Constraints - `1 <= len(arr) <= 10^3`: The length of the array will be between 1 and 1000. - `-10^3 <= arr[i] <= 10^3`: Each element of the array will be within the range -1000 to 1000. Performance Requirements - The solution should minimize the number of write operations to the input array. - Keep the time complexity analysis in mind and aim for a robust implementation. # Example ```python arr = [4, 3, 2, 1] print(cycle_sort(arr)) # Output: [1, 2, 3, 4] arr = [1, 1, 2, 3] print(cycle_sort(arr)) # Output: [1, 1, 2, 3] ``` **Note**: The implementation must be able to handle arrays with duplicate elements efficiently and correctly. Ensure your code follows the described principles of cycle sort to minimize write operations.","solution":"def cycle_sort(arr): Perform cycle sort on the array to minimize writes and sort it in ascending order. n = len(arr) # Traverse the array to find cycles and execute them. for cycle_start in range(n - 1): item = arr[cycle_start] # Find where to place the item. pos = cycle_start for i in range(cycle_start + 1, n): if arr[i] < item: pos += 1 # If the item is already in the correct position, continue. if pos == cycle_start: continue # Skip duplicates. while item == arr[pos]: pos += 1 # Put the item in its correct position. if pos != cycle_start: arr[pos], item = item, arr[pos] # Rotate rest of the cycle. while pos != cycle_start: pos = cycle_start for i in range(cycle_start + 1, n): if arr[i] < item: pos += 1 while item == arr[pos]: pos += 1 if item != arr[pos]: arr[pos], item = item, arr[pos] return arr"},{"question":"# Question: Normalized Path/URL Joiner You are a developer tasked with creating a utility function that correctly joins two parts of a path or a URL into a unified string with exactly one forward slash (`/`) separating them. The function should ensure that whether the parts have leading or trailing slashes, the result always has exactly one separating slash and no extra slashes at the ends. Input: - `base` (string): The base part of the path or URL. - `suffix` (string): The suffix part to be appended to the base. Output: - A string representing the concatenated result with exactly one slash separating the base and the suffix. Constraints: - The inputs can be empty strings. - Inputs will not contain whitespace other than as part of valid path or URL components. Examples: ```python assert join_with_slash(\\"path/to/dir\\", \\"file\\") == \\"path/to/dir/file\\" assert join_with_slash(\\"path/to/dir/\\", \\"file\\") == \\"path/to/dir/file\\" assert join_with_slash(\\"path/to/dir\\", \\"/file\\") == \\"path/to/dir/file\\" assert join_with_slash(\\"http://algorithms.com\\", \\"part\\") == \\"http://algorithms.com/part\\" assert join_with_slash(\\"http://algorithms.com/\\", \\"/part\\") == \\"http://algorithms.com/part\\" ``` Function Signature: ```python def join_with_slash(base: str, suffix: str) -> str: # Your implementation here ``` Write the function `join_with_slash` to ensure it correctly joins the two parts while adhering to the constraints and examples provided.","solution":"def join_with_slash(base: str, suffix: str) -> str: Joins the base and suffix into a single path or URL with exactly one forward slash separating them. Parameters: base (str): The base part of the path or URL. suffix (str): The suffix part to be appended to the base. Returns: str: The concatenated result with exactly one slash separating the base and the suffix. # Remove any trailing / from base and any leading / from suffix base = base.rstrip(\'/\') suffix = suffix.lstrip(\'/\') return f\\"{base}/{suffix}\\""},{"question":"# Serialize and Deserialize N-ary Tree You are given a binary tree structure with nodes defined as follows: ```python class TreeNode(object): def __init__(self, x): self.val = x self.left = None self.right = None ``` Write two functions: `serialize(root)` and `deserialize(data)`. 1. `serialize(root)`: This function should take the root node of a binary tree and produce a string that represents the serialized form of the tree. 2. `deserialize(data)`: This function should take a string representing a serialized binary tree and reconstruct the binary tree, returning the root node. # Requirements * Your solution should correctly handle edge cases, such as empty trees, single-node trees, and imbalanced trees. * Ensure that the serialized format is efficient in terms of space and can be deserialized back to the exact original tree structure. **Input and Output Format**: * `serialize(root)` * **Input**: A `TreeNode` representing the root of the binary tree. * **Output**: A `str` which is the serialized representation of the binary tree. * `deserialize(data)` * **Input**: A `str` which represents the serialized form of a binary tree. * **Output**: A `TreeNode` representing the root of the reconstructed binary tree. Follow the example below for expected behavior: **Example**: ```python # Serialize root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) root.right.left = TreeNode(4) root.right.right = TreeNode(5) serialized_data = serialize(root) # The output might be \\"1 2 # # 3 4 # # 5 # #\\" # Deserialize deserialized_root = deserialize(serialized_data) # The deserialized tree should have the same structure and values as the original tree. ``` # Constraints * The number of nodes in the tree is in the range [0, 1000]. * The values of the nodes are in the range [-1000, 1000]. Implement the `serialize` and `deserialize` functions: ```python class TreeNode(object): def __init__(self, x): self.val = x self.left = None self.right = None def serialize(root): # Your code here def deserialize(data): # Your code here ```","solution":"class TreeNode(object): def __init__(self, x): self.val = x self.left = None self.right = None def serialize(root): Encodes a tree to a single string. def helper(node): if not node: result.append(\'#\') else: result.append(str(node.val)) helper(node.left) helper(node.right) result = [] helper(root) return \' \'.join(result) def deserialize(data): Decodes your encoded data to tree. def helper(): val = next(vals) if val == \'#\': return None node = TreeNode(int(val)) node.left = helper() node.right = helper() return node vals = iter(data.split()) return helper()"},{"question":"# Red-Black Tree Integrity Verification Context You are tasked with writing a function that verifies the integrity of a Red-Black Tree. This function is crucial in systems where maintaining the balanced properties of the tree is imperative for preventing performance degradation. After several insertions and deletions, checking whether the tree still adheres to its red-black properties helps avoid unexpected behaviors during operations. Task Write a function `verify_red_black_tree(RBTree)` that takes an instance of the `RBTree` class and checks its integrity based on red-black tree properties. The function should return `True` if the tree satisfies all the red-black properties and `False` otherwise. Expected Input and Output Formats * **Input**: An instance of `RBTree`. * **Output**: A boolean. # Constraints 1. Node colors follow the modifiable convention where 0 refers to black and 1 refers to red. 2. The input will be an already constructed `RBTree` instance (similar to the provided code structure). # Red-Black Tree Properties Verification: 1. Each node is either red or black. 2. The root is black. 3. Red nodes do not have red children (no consecutive red nodes). 4. Every path from a node to its descendant leaves has the same number of black nodes. # Function Signature ```python def verify_red_black_tree(rb_tree: RBTree) -> bool: # Implementation goes here ``` Additional Notes - You may use any helper functions as required. - `RBNode` and `RBTree` classes, and their methods can be utilized as needed. - Ensure to consider edge cases such as empty trees, single-node trees, etc. Here\'s the function signature to get you started: ```python def verify_red_black_tree(rb_tree: RBTree) -> bool: def is_red(node): return node is not None and node.color == 1 def verify_properties(node): if node is None: return (True, 1) # an empty tree is trivially valid and has a black-height of 1 # Property 1: each node is either red or black is inherently checked by nature # Property 3: check if red nodes do not have red children if is_red(node): if is_red(node.left) or is_red(node.right): return (False, 0) left_valid, left_black_height = verify_properties(node.left) right_valid, right_black_height = verify_properties(node.right) # Property 4: check if every path from node to leaves has the same number of black nodes if left_black_height != right_black_height: return (False, 0) # a black node contributes to the black height black_height = left_black_height + (1 if not is_red(node) else 0) return (left_valid and right_valid, black_height) if rb_tree.root is None: return True # An empty tree is a valid RB Tree # Property 2: the root is black if is_red(rb_tree.root): return False valid, _ = verify_properties(rb_tree.root) return valid ```","solution":"class RBNode: def __init__(self, value, color, left=None, right=None): self.value = value self.color = color # 0 for black, 1 for red self.left = left self.right = right class RBTree: def __init__(self, root=None): self.root = root def verify_red_black_tree(rb_tree: RBTree) -> bool: def is_red(node): return node is not None and node.color == 1 def verify_properties(node): if node is None: return (True, 1) # an empty tree is trivially valid and has a black-height of 1 # Property 3: check if red nodes do not have red children if is_red(node): if is_red(node.left) or is_red(node.right): return (False, 0) left_valid, left_black_height = verify_properties(node.left) right_valid, right_black_height = verify_properties(node.right) # Property 4: check if every path from node to leaves has the same number of black nodes if left_black_height != right_black_height: return (False, 0) # a black node contributes to the black height black_height = left_black_height + (1 if not is_red(node) else 0) return (left_valid and right_valid, black_height) if rb_tree.root is None: return True # An empty tree is a valid RB Tree # Property 2: the root is black if is_red(rb_tree.root): return False valid, _ = verify_properties(rb_tree.root) return valid"},{"question":"You are tasked with implementing a function to reverse a singly linked list. Your goal is to demonstrate your understanding of both iterative and recursive methods to manipulate linked data structures. # Function Signature ```python class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverse_list(head: ListNode) -> ListNode: Iteratively reverse the linked list. :param head: ListNode - The head node of the singly linked list. :return: ListNode - The new head node of the reversed singly linked list. pass def reverse_list_recursive(head: ListNode) -> ListNode: Recursively reverse the linked list. :param head: ListNode - The head node of the singly linked list. :return: ListNode - The new head node of the reversed singly linked list. pass ``` # Input - `head`: The head node of a singly linked list, which could be `None`, consist of one node, or many nodes. # Output - The function should return the new head node of the reversed singly linked list. # Constraints - Do not use extra space for another linked list; reverse the nodes in place. - The linked list may contain up to `10^4` nodes. # Examples Example 1: ```plaintext Input: head = 1 -> 2 -> 3 -> 4 -> 5 -> None Output: 5 -> 4 -> 3 -> 2 -> 1 -> None ``` Example 2: ```plaintext Input: head = None Output: None ``` Example 3: ```plaintext Input: head = 1 -> None Output: 1 -> None ``` # Notes 1. Implement both the iterative and recursive solutions in the provided function signatures. 2. Carefully consider edge cases including empty lists and single-node lists. 3. Ensure your implementation efficiently handles the reversal.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverse_list(head: ListNode) -> ListNode: Iteratively reverse the linked list. :param head: ListNode - The head node of the singly linked list. :return: ListNode - The new head node of the reversed singly linked list. prev = None current = head while current: next_node = current.next current.next = prev prev = current current = next_node return prev def reverse_list_recursive(head: ListNode) -> ListNode: Recursively reverse the linked list. :param head: ListNode - The head node of the singly linked list. :return: ListNode - The new head node of the reversed singly linked list. if not head or not head.next: return head new_head = reverse_list_recursive(head.next) head.next.next = head head.next = None return new_head"},{"question":"You are tasked with building a utility to compute various properties of numbers using algorithms discussed. Function 1: Generalized GCD Write a function `generalized_gcd(num, arr)` that takes an integer `num` and a list of `num` integers `arr`, and returns the greatest common divisor of the integers in the array. ```python def generalized_gcd(num, arr): # Your implementation here ``` * **Input**: - `num`: an integer (2 ≤ num ≤ 1000) - `arr`: a list of `num` integers (1 ≤ arr[i] ≤ 10^6) * **Output**: Returns an integer representing the GCD of the list of integers. * **Constraints**: - All integers in the list are non-zero. Function 2: Count Trailing Zeros Write a function `count_trailing_zeros(n)` that takes a non-negative integer `n` and returns the number of trailing zeros in the binary representation of `n`. ```python def count_trailing_zeros(n): # Your implementation here ``` * **Input**: - `n`: a non-negative integer (0 ≤ n ≤ 10^9) * **Output**: Returns an integer representing the number of trailing zeros in the binary representation of `n`. Example Function 1: ```python print(generalized_gcd(5, [2, 4, 6, 8, 10])) # Output: 2 print(generalized_gcd(3, [20, 40, 60])) # Output: 20 ``` Function 2: ```python print(count_trailing_zeros(16)) # Output: 4 print(count_trailing_zeros(7)) # Output: 0 ```","solution":"import math from functools import reduce def generalized_gcd(num, arr): Returns the GCD of a list of integers. def gcd(x, y): while y: x, y = y, x % y return x return reduce(gcd, arr) def count_trailing_zeros(n): Returns the number of trailing zeros in the binary representation of n. if n == 0: return 0 count = 0 while (n & 1) == 0: n >>= 1 count += 1 return count"},{"question":"# Find the Unique Element in a List Scenario You have been given a list of integers where every element appears exactly twice except for one unique element that appears only once. Your task is to write a function to find that single unique element. Function Signature ```python def find_unique_element(nums: List[int]) -> int: Given a list of integers, return the element that appears only once. :param nums: List of integers where every element appears twice, except one. :return: The single unique integer. ``` Input * `nums` - A list of integers `[a1, a2, ..., an]`, where every element appears exactly twice except for one unique element. * `1 <= len(nums) <= 10^5` * `-10^9 <= nums[i] <= 10^9` Output * The single unique element in the list. Requirements * Your algorithm must run in linear time, O(n). * You cannot use extra memory for this problem. Example ```python print(find_unique_element([4, 1, 2, 1, 2])) # Output: 4 print(find_unique_element([2, 2, 1])) # Output: 1 print(find_unique_element([1])) # Output: 1 ``` Constraints * The list must adhere to the constraints, where exactly one element appears once and all others appear exactly twice.","solution":"def find_unique_element(nums): Given a list of integers, return the element that appears only once. :param nums: List of integers where every element appears twice, except one. :return: The single unique integer. unique_element = 0 for num in nums: unique_element ^= num return unique_element"},{"question":"# Nearest Neighbor Classification Task Scenario You are tasked with implementing a simpler form of a classifier which uses the Nearest Neighbor algorithm. This classifier will be used in a small-scale recommendation system. Objective Your task is to implement a function `nearest_neighbor(x, tSet)` that takes two arguments: - `x`: a tuple representing a data point in an n-dimensional space. - `tSet`: a dictionary where keys are tuples representing points in the same n-dimensional space and values are their corresponding classifications. Requirements 1. Implement the helper function `distance(x, y)` which calculates the Euclidean distance between two points x and y. 2. Use the `distance` function within `nearest_neighbor` to find and return the classification of the nearest neighbor to the point x from the set `tSet`. Expected Input and Output * **Input**: * `x`: A tuple of coordinates (e.g., `(1.0, 2.0)`) * `tSet`: A dictionary where keys are tuples and values are classifications (e.g., `{(2.0, 3.0): \'A\', (3.5, 4.5): \'B\'}`) * **Output**: * The classification of the nearest neighbor (e.g., `\'A\'` or `\'B\'`) Constraints - All points will have the same number of dimensions. - The training set will not be empty. - Dimensions and coordinates are non-negative floating-point numbers. Performance Requirements - Your solution should efficiently handle sets with up to 10,000 points. - Aim to minimize both time and space complexity. Example ```python # Input x = (1.0, 2.0) tSet = {(2.0, 3.0): \'A\', (3.5, 4.5): \'B\'} # Output nearest_neighbor(x, tSet) # should return \'A\' ```","solution":"import math def distance(x, y): Calculate the Euclidean distance between two n-dimensional points x and y. return math.sqrt(sum((a - b) ** 2 for a, b in zip(x, y))) def nearest_neighbor(x, tSet): Find the classification of the nearest neighbor to the point x from the set tSet. tSet is a dictionary where keys are tuples representing points in the n-dimensional space and values are their corresponding classifications. nearest_point = min(tSet.keys(), key=lambda point: distance(x, point)) return tSet[nearest_point]"},{"question":"**Question**: You are given three tasks to implement in Python: 1. Write a function that computes the greatest common divisor (GCD) of two non-negative integers using Euclid\'s algorithm. The function should handle edge cases such as zero inputs and negative values gracefully by raising an appropriate error. 2. Implement a function that computes the least common multiple (LCM) of two non-negative integers using the GCD function you have implemented. 3. Write a function that calculates the number of trailing zeros in the binary representation of a non-negative integer. Functions\' signatures: ```python def gcd(a: int, b: int) -> int: Computes the greatest common divisor of integers a and b using Euclid\'s Algorithm. :param a: First non-negative integer :param b: Second non-negative integer :return: The greatest common divisor of a and b :raises ValueError: If either input is negative or zero pass def lcm(a: int, b: int) -> int: Computes the least common multiple of integers a and b. :param a: First non-negative integer :param b: Second non-negative integer :return: The least common multiple of a and b :raises ValueError: If either input is negative or zero pass def trailing_zero(x: int) -> int: Computes the number of trailing zero bits in integer x\'s binary representation. :param x: Non-negative integer :return: The number of trailing zeros in binary representation of x pass ``` # Requirements: - For the GCD function, ensure to validate inputs and raise `ValueError` if either of the integers is zero or negative. - The LCM function should be able to compute the least common multiple utilizing the GCD function accurately. - Trailing zeros function should return how many zeros follow the first \'1\' bit in the binary representation of `x`. # Constraints: - All input integers will be within the range [0, (10^9)]. # Example Inputs and Outputs: ```python assert gcd(48, 18) == 6 assert gcd(0, 5) == ValueError assert gcd(-2, 4) == ValueError assert lcm(4, 5) == 20 assert lcm(6, 8) == 24 assert lcm(0, 1) == ValueError assert trailing_zero(34) == 1 assert trailing_zero(40) == 3 assert trailing_zero(0) == 0 ```","solution":"def gcd(a: int, b: int) -> int: Computes the greatest common divisor of integers a and b using Euclid\'s Algorithm. :param a: First non-negative integer :param b: Second non-negative integer :return: The greatest common divisor of a and b :raises ValueError: If either input is negative or zero if a < 0 or b < 0: raise ValueError(\\"Negative values are not allowed\\") if a == 0 or b == 0: raise ValueError(\\"Zero value is not allowed\\") while b: a, b = b, a % b return a def lcm(a: int, b: int) -> int: Computes the least common multiple of integers a and b. :param a: First non-negative integer :param b: Second non-negative integer :return: The least common multiple of a and b :raises ValueError: If either input is negative or zero if a < 0 or b < 0: raise ValueError(\\"Negative values are not allowed\\") if a == 0 or b == 0: raise ValueError(\\"Zero value is not allowed\\") return abs(a * b) // gcd(a, b) def trailing_zero(x: int) -> int: Computes the number of trailing zero bits in integer x\'s binary representation. :param x: Non-negative integer :return: The number of trailing zeros in binary representation of x if x == 0: return 0 count = 0 while x & 1 == 0: count += 1 x >>= 1 return count"},{"question":"# Question: Generate All Subsets of an Array Context: You are working on a file management system that needs to generate every possible combination of file permissions for a given set of users. Each user has distinct permissions and you need to generate all possible permission sets. Task: Write a function `generate_subsets` that takes a list of distinct integers (`permissions`) representing user permissions and returns all possible subsets of the permission set. Function Signature: ```python def generate_subsets(permissions: List[int]) -> Set[Tuple[int]]: ``` Input: * A list of distinct integers `permissions` where `1 <= len(permissions) <= 16`. Output: * A set of tuples, where each tuple represents a unique subset of the input list. Constraints: * The permissions list will contain distinct integers. * The length of the permissions list will not exceed 16. Example: ```python input: [1, 2, 3] output: { (), (1,), (2,), (3,), (1, 2,), (1, 3,), (2, 3,), (1, 2, 3,) } ``` Performance Requirement: Your solution should efficiently handle the maximum input size within a reasonable time frame, considering that the maximum possible subsets for 16 elements are 2^16 = 65536 subsets. Hint: Consider using bit manipulation to efficiently generate the subsets.","solution":"from typing import List, Set, Tuple def generate_subsets(permissions: List[int]) -> Set[Tuple[int]]: Returns a set of tuples, where each tuple represents a unique subset of the input list of permissions. def backtrack(start: int, current: List[int]): subsets.add(tuple(current)) for i in range(start, len(permissions)): current.append(permissions[i]) backtrack(i + 1, current) current.pop() # backtrack subsets = set() backtrack(0, []) return subsets"},{"question":"Objective Given an array of integers where every element appears exactly three times except for one, which appears exactly once, implement an efficient algorithm to find the single non-repeating element. Input and Output * **Input**: A list of integers `nums` where each element appears three times except exactly one element. * **Output**: An integer representing the element that appears only once. Constraints - The array will have at least one element. - Each element in the array will fit within the 32-bit signed integer range. - The algorithm should run in O(n) time complexity and use O(1) extra space. Example ```python Input: [2, 2, 3, 2] Output: 3 Input: [0, 1, 0, 1, 0, 1, 99] Output: 99 ``` Requirements 1. Your solution should efficiently find the single number that appears once. 2. You must not use additional memory outside variables for `ones` and `twos` tracking. Function Signature ```python def single_number(nums: List[int]) -> int: # Your implementation here ``` Context You are tasked to design a system for detecting anomalies in a series of network logs where certain errors occur exactly three times to prevent false positives. Your solution will help to highlight the exact error that needs attention.","solution":"def single_number(nums): Given an array of integers where every element appears exactly three times except for one, this function returns that single one-time appearing element. :param nums: List[int] - List of integers where every element appears exactly three times except one :return: int - the single one-time appearing element ones, twos = 0, 0 for num in nums: # twos gets bits which are already in ones and also in the current number twos |= ones & num # ones gets the bits which are in the current number ones ^= num # common_bits gets the bits which are both in ones and twos, these need to be deleted from ones and twos since # we\'re counting 3 bits, meaning we reset these to 0 after we encounter them common_bits = ones & twos # remove the bits from ones and twos ones &= ~common_bits twos &= ~common_bits return ones"},{"question":"# Nearest Neighbor Classification Implementation Scenario Imagine you are developing a simple recommendation system for a movie streaming service. Each movie\'s features (e.g., genre, length, rating) are represented as numerical vectors, and given a user\'s movie preferences, you need to recommend the movie from the database that is the closest match. Task Implement a function to find the \'nearest neighbor\' movie for the user\'s given movie preference vector. You are provided two functions: `distance` (to calculate the Euclidean distance between two vectors) and `nearest_neighbor` (to determine the closest movie in the training set). Function Specification ```python def recommend_movie(user_pref_vector, movies_db): Recommends the nearest movie based on user\'s preference vector. Arguments: user_pref_vector {tuple} -- The feature vector of the user\'s preferences. movies_db {dict} -- A dictionary where: - Keys are tuples representing movie feature vectors. - Values are the corresponding movie titles. Returns: {str} -- The title of the nearest movie. return nearest_neighbor(user_pref_vector, movies_db) ``` Input - `user_pref_vector`: A tuple representing the user\'s movie preference feature vector. - `movies_db`: A dictionary where keys are tuples representing movie feature vectors and values are the corresponding movie titles. Output - The function should return the title of the movie from the `movies_db` that is nearest to the `user_pref_vector`. Constraints * The lengths of all vectors (user preferences and movie features) will be the same. * The movie database will contain at least one movie entry. Example ```python user_pref_vector = (3.5, 4.0, 2.5) movies_db = { (3.5, 4.0, 2.0): \\"Movie A\\", (2.0, 3.0, 5.0): \\"Movie B\\", (3.0, 4.0, 3.0): \\"Movie C\\" } print(recommend_movie(user_pref_vector, movies_db)) # Expected Output: \\"Movie A\\" ``` Notes - Ensure to handle edge cases like different vector lengths properly. - Optimize your solution for the given constraints.","solution":"import math def distance(vec1, vec2): Calculates the Euclidean distance between two vectors. Arguments: vec1 {tuple} -- The first vector. vec2 {tuple} -- The second vector. Returns: {float} -- The Euclidean distance between the two vectors. return math.sqrt(sum((a - b) ** 2 for a, b in zip(vec1, vec2))) def nearest_neighbor(user_pref_vector, movies_db): Finds the nearest neighbor movie to the user\'s preference vector in the movie database. Arguments: user_pref_vector {tuple} -- The feature vector of the user\'s preferences. movies_db {dict} -- A dictionary where: - Keys are tuples representing movie feature vectors. - Values are the corresponding movie titles. Returns: {str} -- The title of the nearest movie. nearest_movie = None min_distance = float(\'inf\') for movie_vector, movie_title in movies_db.items(): dist = distance(user_pref_vector, movie_vector) if dist < min_distance: min_distance = dist nearest_movie = movie_title return nearest_movie def recommend_movie(user_pref_vector, movies_db): Recommends the nearest movie based on user\'s preference vector. Arguments: user_pref_vector {tuple} -- The feature vector of the user\'s preferences. movies_db {dict} -- A dictionary where: - Keys are tuples representing movie feature vectors. - Values are the corresponding movie titles. Returns: {str} -- The title of the nearest movie. return nearest_neighbor(user_pref_vector, movies_db)"},{"question":"You are given an array containing `n` objects colored red, white, or blue, sorted such that objects of the same color are adjacent, with the colors in the order red, white, and blue. Here, the integers `0`, `1`, and `2` represent the colors red, white, and blue respectively. Write a function `sort_three_colors` that sorts the array in the manner described above without using the library\'s sort function. # Function Signature ```python def sort_three_colors(nums: List[int]) -> None: pass ``` # Input * `nums`: A list of integers where each integer is either `0`, `1`, or `2`, representing the colors red, white, and blue respectively (`0 <= len(nums) <= 10^5`). # Output * The function doesn\'t return anything but modifies the list `nums` in place to achieve the required sorting. # Constraints * Do not use any built-in sort functions. * Aim to perform the sorting in a single pass with a time complexity of O(n) and a space complexity of O(1). # Example ``` Input: nums = [2, 0, 2, 1, 1, 0] Output: [0, 0, 1, 1, 2, 2] Input: nums = [1, 0, 1, 0, 2, 2] Output: [0, 0, 1, 1, 2, 2] Input: nums = [2, 2, 2] Output: [2, 2, 2] ``` # Edge Cases 1. An empty list (`[]`). 2. A list where all elements are the same. 3. A list missing one or two of the colors (e.g., `[0, 0, 0]` or `[2, 1, 1]`). Ensure that your solution handles these cases efficiently.","solution":"from typing import List def sort_three_colors(nums: List[int]) -> None: Sorts the colors in place according to the Dutch National Flag problem by Edsger Dijkstra. low, mid, high = 0, 0, len(nums) - 1 while mid <= high: if nums[mid] == 0: nums[low], nums[mid] = nums[mid], nums[low] low += 1 mid += 1 elif nums[mid] == 1: mid += 1 else: nums[mid], nums[high] = nums[high], nums[mid] high -= 1"},{"question":"You are required to implement a data structure that supports the following operations on an array `arr`: 1. Compute the sum of the first `i` elements (`sum(0, i)`). 2. Modify the value of a specified element of the array (`update(i, x)`). The data structure should allow these operations in logarithmic time. Use the Fenwick Tree (Binary Indexed Tree) to achieve this. # Function Signature ```python class FenwickTree: def __init__(self, arr: List[int]): self.construct(arr) def get_sum(self, i: int) -> int: pass def update(self, i: int, x: int) -> None: pass def construct(self, arr: List[int]): pass ``` # Input Format - The constructor takes an array of integers. - `get_sum(i: int) -> int` returns the sum of the first `i+1` elements. - `update(i: int, x: int) -> None` updates the element at index `i` to `x`. # Constraints - 0 ≤ i < n - The number of elements in the array is at most 10^5. - Element values and updates are in the range [-10^6, 10^6]. # Example Usage ```python ft = FenwickTree([1, 2, 3, 4, 5]) assert ft.get_sum(2) == 6 # 1 + 2 + 3 = 6 ft.update(3, 1) # Element at index 3 is now 1 assert ft.get_sum(4) == 12 # 1 + 2 + 3 + 1 + 5 = 12 ``` # Scenario You are designing a system for a financial application where users frequently query the cumulative balance up to a specific transaction and occasionally update a transaction amount. To handle these efficiently, you decide to use the Fenwick Tree for the underlying data structure. Implement the Fenwick Tree such that the above operations can be executed efficiently.","solution":"from typing import List class FenwickTree: def __init__(self, arr: List[int]): self.size = len(arr) self.tree = [0] * (self.size + 1) self.construct(arr) def get_sum(self, i: int) -> int: index = i + 1 # Fenwick tree indices are 1-based sum = 0 while index > 0: sum += self.tree[index] index -= index & (-index) return sum def update(self, i: int, x: int) -> None: index = i + 1 diff = x - (self.get_sum(i) - self.get_sum(i - 1)) while index <= self.size: self.tree[index] += diff index += index & (-index) def construct(self, arr: List[int]): for i in range(self.size): self.update(i, arr[i])"},{"question":"Polynomial Derivative Function **Context**: You are part of a software development team working on a symbolic mathematics engine. The engine needs to support various operations on mathematical expressions, including differentiation. Given the existing data structures for Monomials and Polynomials, your task is to implement the functionality to compute the derivative of a Polynomial. **Objective**: Write a method `derivative` in the `Polynomial` class that calculates the derivative of the polynomial with respect to a specific variable. The derivative should be another Polynomial that represents the derivative of the original polynomial. **Function Specification**: ```python def derivative(self, var: int) -> Polynomial: Compute the derivative of the polynomial with respect to the given variable. Parameters: var (int): The variable with respect to which the derivative is to be calculated. Returns: Polynomial: A polynomial representing the derivative of the original polynomial. # Your code here ``` **Requirements**: - **Input**: - An integer `var` representing the variable index with respect to which the derivative needs to be calculated. - **Output**: - A `Polynomial` object representing the derived polynomial. - **Constraints**: - Handle cases where the variable is not present in the polynomial. - The polynomial can have integer, float, or rational coefficients. **Performance Considerations**: - Optimize for polynomials with large numbers of variables and terms. Example: ```python # Examples of Polynomial instances # Example Polynomial: P(x, y) = 2*x^2*y - 3*x*y^3 + 5 poly = Polynomial([ Monomial({1: 2, 2: 1}, 2), # 2*x^2*y Monomial({1: 1, 2: 3}, -3), # -3*x*y^3 Monomial({}, 5) # 5 ]) # Derivative with respect to variable 1 (x): poly.derivative(1) # Should represent the Polynomial: 4*x*y - 3*y^3 # Derivative with respect to variable 2 (y): poly.derivative(2) # Should represent the Polynomial: 2*x^2 - 9*x*y^2 ``` Note: You are allowed to define any additional helper methods as needed and assume the structure and existing methods of `Monomial` and `Polynomial` classes remain unchanged.","solution":"class Monomial: def __init__(self, variables, coefficient): Initialize a monomial. :param variables: Dictionary where keys are variable indices and values are their exponents. :param coefficient: The coefficient of the monomial. self.variables = variables self.coefficient = coefficient def derivative(self, var): Compute the derivative of the monomial with respect to the given variable. :param var: The variable with respect to which derivative is to be calculated. :return: A new Monomial representing the derivative. if var not in self.variables or self.variables[var] == 0: return None # Derivative with respect to variable not present is 0 new_variables = self.variables.copy() new_coefficient = self.coefficient * new_variables[var] new_variables[var] -= 1 if new_variables[var] == 0: del new_variables[var] return Monomial(new_variables, new_coefficient) class Polynomial: def __init__(self, monomials): Initialize a polynomial. :param monomials: List of Monomial objects. self.monomials = monomials def derivative(self, var): Compute the derivative of the polynomial with respect to the given variable. :param var: The variable index with respect to which the derivative is to be calculated. :return: A Polynomial representing the derivative. new_monomials = [] for monomial in self.monomials: derived_monomial = monomial.derivative(var) if derived_monomial: new_monomials.append(derived_monomial) return Polynomial(new_monomials)"},{"question":"Enhanced Quick Sort Scenario You are tasked with improving the performance of the Quick Sort implementation especially for cases where the array might have many duplicate elements or might already be nearly sorted. You need to implement a version that optimizes the pivot selection process and handles arrays with a large number of duplicates more efficiently. Task Write a Python function `optimized_quick_sort(arr)` that improves the given Quick Sort implementation using the following enhancements: 1. **Randomized Pivot Selection**: Select a random element as the pivot to avoid worst-case performance on already sorted or nearly sorted arrays. 2. **Three-Way Partitioning**: Implement a three-way partitioning process to handle arrays with many duplicate elements more efficiently. Input and Output * **Input**: A list `arr` of integers. * **Output**: The sorted version of `arr`. Constraints * Use in-place sorting (constant additional space). * Aim to maintain an average-case time complexity of O(n log(n)). Performance Requirements * The implementation should handle large arrays efficiently and maintain optimal performance on various input types, including already sorted, reverse sorted, and arrays with many duplicates. Example ```python assert optimized_quick_sort([4, 2, 2, 8, 3, 3, 1]) == [1, 2, 2, 3, 3, 4, 8] assert optimized_quick_sort([10, -1, 2, 5, 0, 6, 4, -5]) == [-5, -1, 0, 2, 4, 5, 6, 10] assert optimized_quick_sort([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5] assert optimized_quick_sort([5, 4, 3, 2, 1]) == [1, 2, 3, 4, 5] assert optimized_quick_sort([2, 2, 2, 2, 2]) == [2, 2, 2, 2, 2] ```","solution":"import random def optimized_quick_sort(arr): def three_way_partition(arr, low, high): if high <= low: return lt, gt = low, high pivot_index = low + random.randint(0, high - low) pivot = arr[pivot_index] i = low while i <= gt: if arr[i] < pivot: arr[lt], arr[i] = arr[i], arr[lt] lt += 1 i += 1 elif arr[i] > pivot: arr[gt], arr[i] = arr[i], arr[gt] gt -= 1 else: i += 1 three_way_partition(arr, low, lt - 1) three_way_partition(arr, gt + 1, high) if arr is None or len(arr) <= 1: return arr three_way_partition(arr, 0, len(arr) - 1) return arr"},{"question":"# Question: You are given an array of integers and are tasked with implementing a sorting algorithm known as Comb Sort. Your function should sort the given array in non-decreasing order. Function Signature ```python def comb_sort(arr: List[int]) -> List[int]: pass ``` Input - `arr` - A list of integers `arr` where (1 <= len(arr) <= 10^5). The elements of `arr` can be any integer between `-10^6 to 10^6`. Output - Return a new list which is the sorted version of the input list `arr`. Implementation Using the Comb Sort algorithm, implement the `comb_sort(arr)` function that follows these principles: - Initially set a gap to the length of the array. - Shrink the gap using the factor 1.3 after each pass through the array. - Continue until the gap reduces to 1 and the array is completely sorted. Constraints - The solution must solve the problem efficiently for large input sizes up to 10^5 elements. - The function cannot use any built-in sort() or sorted() functions. Example ```python arr = [34, -50, 42, 0, 13, 5] print(comb_sort(arr)) # Output should be [-50, 0, 5, 13, 34, 42] ``` # Context Comb Sort improves upon bubble sort by eliminating small values toward the beginning very quickly, and it has been observed to perform better for average cases. However, make sure your implementation handles the worst-case scenarios efficiently without excessive performance degradation.","solution":"from typing import List def comb_sort(arr: List[int]) -> List[int]: Sorts the array using Comb Sort algorithm. def get_next_gap(gap: int) -> int: # Shrink gap by the shrink factor gap = (gap * 10) // 13 if gap < 1: return 1 return gap n = len(arr) gap = n swapped = True # Keep running while gap is more than 1 or last run caused a swap while gap != 1 or swapped: # Find next gap gap = get_next_gap(gap) swapped = False # Compare all elements with current gap for i in range(0, n - gap): if arr[i] > arr[i + gap]: arr[i], arr[i + gap] = arr[i + gap], arr[i] swapped = True return arr"},{"question":"# Question: Scenario You are developing a secure communication system that requires frequent checking of prime numbers as part of its encryption mechanism. Ensuring the numbers used in encryption are prime is crucial for the security of the system. Task Implement a function `is_coprime(prime_func, a, b)` that uses a given prime-checking function to determine if two numbers `a` and `b` are co-prime. Two numbers are considered co-prime if they have no common prime factors other than 1. Function Signature: ```python def is_coprime(prime_func, a, b): prime_func: Function - A reference to a prime-checking function. It should accept an integer and return True if the number is prime, otherwise False. a: Integer - First number to check for co-primality. b: Integer - Second number to check for co-primality. Returns: Boolean - True if `a` and `b` are co-prime, else False. ``` Input: - `prime_func`: A function that determines if a number is prime. - `a`: An integer (1 ≤ a ≤ 10^6) - `b`: An integer (1 ≤ b ≤ 10^6) Output: - Returns `True` if `a` and `b` are co-prime, `False` otherwise. Constraints: - Use the provided `prime_check` function for prime checking. - Consider prime factorization for checking co-primality. Performance Requirements: - The solution must be optimized to handle inputs up to 1,000,000 efficiently.","solution":"import math def is_prime(n): Helper function to determine if a number is prime. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def is_coprime(prime_func, a, b): Checks if two numbers `a` and `b` are co-prime using a provided prime checking function. def factorize(n): Returns a set of prime factors of `n`. factors = set() # Check for number of 2s. while n % 2 == 0: factors.add(2) n = n // 2 # Check for odd factors up to sqrt(n). for i in range(3, int(math.sqrt(n)) + 1, 2): while n % i == 0: if prime_func(i): factors.add(i) n = n // i # If n remains and is a prime number. if n > 2 and prime_func(n): factors.add(n) return factors factors_a = factorize(a) factors_b = factorize(b) common_factors = factors_a.intersection(factors_b) # They are coprime if there are no common prime factors. return len(common_factors) == 0"},{"question":"# Bogo Sort with Constraints and Extensions Objective Design a function to implement the Bogo Sort algorithm with additional constraints and extensions for better understanding. The task will test comprehension of inefficiencies and edge cases. # Task 1. Implement the given Bogo Sort algorithm. 2. Add a constraint to limit the maximum number of iterations to demonstrate how such a limitation can prevent an infinite loop. 3. Extend the code to return additional information: - Whether the sort was successful or not (based on the iteration limit). - The total number of iterations performed. # Function Signature ```python def enhanced_bogo_sort(arr: list[int], max_iterations: int = 1000) -> tuple[list[int], bool, int]: Sorts the array using the Bogo Sort algorithm with an iteration limit. Parameters: arr (list[int]): The list to be sorted. max_iterations (int): Maximum number of iterations to try sorting before giving up. Returns: tuple[list[int], bool, int]: The sorted list (or partially sorted list if limit reached), a boolean indicating success, and the number of iterations performed. # Your code here ``` # Input Format - `arr`: A list of integers to be sorted. - `max_iterations`: An integer specifying the maximum number of iterations. # Output Format - A tuple containing: - The (potentially) sorted list of integers. - A boolean indicating whether the algorithm successfully sorted the list within the iteration limit. - The number of iterations performed. # Example Scenario Here\'s an example to clarify the requirements: ```python input_array = [3, 1, 2] max_iters = 1000 sorted_array, success, num_iterations = enhanced_bogo_sort(input_array, max_iters) print(f\\"Sorted Array: {sorted_array}\\") print(f\\"Success: {success}\\") print(f\\"Iterations: {num_iterations}\\") ``` **Explanation:** - Start with a randomly shuffled array. - Attempt to sort within 1000 iterations. - Return the results indicating the state of the list, whether it was sorted successfully, and how many iterations it took. # Constraints - The array can be any size but should ideally be small due to the inefficiency of Bogo Sort. - The function should be robust enough to handle edge cases such as: - An already sorted list. - An array consisting of the same elements. Completing this task will demonstrate an understanding of algorithm inefficiencies, handling edge cases, and introducing constraints to prevent worst-case scenarios.","solution":"import random def enhanced_bogo_sort(arr, max_iterations=1000): Sorts the array using the Bogo Sort algorithm with an iteration limit. Parameters: arr (list[int]): The list to be sorted. max_iterations (int): Maximum number of iterations to try sorting before giving up. Returns: tuple[list[int], bool, int]: The sorted list (or partially sorted list if limit reached), a boolean indicating success, and the number of iterations performed. def is_sorted(lst): return all(lst[i] <= lst[i+1] for i in range(len(lst)-1)) iterations = 0 while not is_sorted(arr) and iterations < max_iterations: random.shuffle(arr) iterations += 1 success = is_sorted(arr) return (arr, success, iterations)"},{"question":"Context You have been tasked to help in analyzing some data where most elements appear in pairs, but there are exactly two elements that are unique. Your goal is to efficiently identify these two unique elements. Problem Given an array `nums` of integers where exactly two elements appear only once and all other elements appear exactly twice, write a function `find_unique_elements` to find the two elements that appear only once. The order of the result is not important. Function Signature ```python def find_unique_elements(nums: List[int]) -> List[int]: :param nums: List[int] - list of integers where exactly two elements appear once and all other elements appear twice :return: List[int] - list containing the two unique elements ``` Constraints * The function should have a time complexity of O(N) and a space complexity of O(1). * The input list `nums` will have exactly two unique elements and all other elements will appear exactly twice. * The length of the input list `nums` will be at least 2 and can be up to (10^5). Example ```python # Example 1 nums = [1, 2, 1, 3, 2, 5] assert set(find_unique_elements(nums)) == {3, 5} # Example 2 nums = [2, 1, 2, 3, 4, 3] assert set(find_unique_elements(nums)) == {1, 4} ``` Explanation 1. Use XOR to combine all elements in the array. The result will be the XOR of the two unique elements since elements appearing twice will cancel each other out. 2. Identify a bit position where the two unique elements differ. Use this bit to partition the array into two groups. 3. XOR elements within each group to isolate the unique elements. Notes * Your solution should be efficient in terms of both time and space. * Consider edge cases such as negative numbers, large input size, and randomly ordered elements.","solution":"from typing import List def find_unique_elements(nums: List[int]) -> List[int]: :param nums: List[int] - list of integers where exactly two elements appear once and all other elements appear twice :return: List[int] - list containing the two unique elements # Step 1: Find the XOR of all elements xor_all = 0 for num in nums: xor_all ^= num # Step 2: Find a set bit (any bit that is set in xor_all) diff_bit = xor_all & -xor_all # Step 3: Divide elements into two groups based on the set bit unique1, unique2 = 0, 0 for num in nums: if num & diff_bit: unique1 ^= num else: unique2 ^= num return [unique1, unique2]"},{"question":"# Pathfinding in Simple Networks **Problem Description**: You are given a simple transportation network represented as a graph, where intersections are nodes, and roads are edges. Each road has a length of 1 unit. Your task is to write a function to determine the longest path between two intersections in this network. **Objectives**: 1. Implement a function `find_longest_path(graph, start, end)` that finds the longest path between two intersections in the network. 2. The function should return the path as a list of nodes from `start` to `end`. **Function Signature**: ```python def find_longest_path(graph: Dict[str, List[str]], start: str, end: str) -> List[str]: pass ``` **Input**: * `graph`: A dictionary where keys are nodes (intersections) and values are lists of neighboring nodes. * `start`: A string representing the starting node. * `end`: A string representing the destination node. **Output**: * A list of nodes representing the longest path from `start` to `end`. If no path exists, return an empty list. **Constraints**: * Assume all nodes and edges form a valid connected graph. * The graph is unweighted (road lengths are all equal to 1). **Examples**: ```python graph = { \'A\': [\'B\', \'C\'], \'B\': [\'A\', \'D\', \'E\'], \'C\': [\'A\', \'F\'], \'D\': [\'B\'], \'E\': [\'B\', \'F\'], \'F\': [\'C\', \'E\'] } assert find_longest_path(graph, \'A\', \'F\') == [\'A\', \'B\', \'E\', \'F\'] assert find_longest_path(graph, \'A\', \'D\') == [\'A\', \'B\', \'D\'] assert find_longest_path(graph, \'C\', \'C\') == [\'C\'] ``` **Additional Notes**: * Your solution should consider graph traversal techniques and aim to maximize the path length. * Remember to handle possible cycles in the graph effectively to avoid infinite loops.","solution":"def dfs(graph, node, end, visited, path): visited.add(node) path.append(node) if node == end: yield path[:] else: for neighbor in graph[node]: if neighbor not in visited: yield from dfs(graph, neighbor, end, visited, path) path.pop() visited.remove(node) def find_longest_path(graph, start, end): longest_path = [] for path in dfs(graph, start, end, set(), []): if len(path) > len(longest_path): longest_path = path return longest_path"},{"question":"# Decode String Using Stack Given an encoded string, write a function `decode_string` that returns its decoded string based on the encoding rule: k[encoded_string]. The encoded string inside the square brackets is repeated exactly k times. Input Format - A single string `s` that contains the encoded message. Output Format - A single string representing the fully decoded message. Constraints - The input string `s` is always valid, with no extra white spaces and well-formed square brackets. - The original data does not contain any digits, so digits are only for repeat numbers `k`. Performance Requirements - Your solution should efficiently handle input strings of reasonable length up to 10^4 characters. - Ensure memory usage is optimized and operations performed efficiently to decode the string. Example Input: `\\"3[a]2[bc]\\"` Output: `\\"aaabcbc\\"` Input: `\\"3[a2[c]]\\"` Output: `\\"accaccacc\\"` Input: `\\"2[abc]3[cd]ef\\"` Output: `\\"abcabccdcdcdef\\"` Implementation Details - You must use stack-based strategy for decoding. - The function signature is: ```python def decode_string(s: str) -> str: # your implementation ```","solution":"def decode_string(s: str) -> str: stack = [] current_num = 0 current_str = \\"\\" for char in s: if char.isdigit(): current_num = current_num * 10 + int(char) elif char == \'[\': stack.append((current_str, current_num)) current_str, current_num = \\"\\", 0 elif char == \']\': last_str, num = stack.pop() current_str = last_str + num * current_str else: current_str += char return current_str"},{"question":"Context You are given a list of stock prices, where each element represents the price of a stock on that day. Your task is to implement a function that identifies the days (indices) on which buying and later selling the stock would yield the maximum profit. Problem Statement Write a Python function named `max_profit_days` that takes a list of integers representing stock prices and returns a tuple of two integers. These integers are the days (indices) where buying on the first day and selling on the second day would yield the maximum profit. If no profit is possible, return `None`. - You may assume there is at least one selling day after the buying day. # Function Signature ```python def max_profit_days(prices: List[int]) -> Optional[Tuple[int, int]]: ``` # Input & Output - **Input**: * `prices` (List[int]): List of stock prices, where each price is a positive integer. - **Output**: * Returns a tuple (buy_day, sell_day) of indices where the profit is maximum, or `None` if no profitable transaction exists. # Constraints - The length of `prices` is between 2 and 10^5. - Each price is a positive integer less than or equal to 10^4. - You must provide a function that implements an O(n) time complexity solution. # Example Input: ```python prices = [7, 1, 5, 3, 6, 4] ``` Output: ```python (1, 4) ``` Explanation: - Buy on day 1 (price = 1) and sell on day 4 (price = 6), profit = 6-1 = 5, which is the maximum. Input: ```python prices = [7, 6, 4, 3, 1] ``` Output: ```python None ``` Explanation: - No transaction yields a positive profit. # Additional Requirements - Ensure the function handles edge case scenarios like constant or strictly decreasing prices correctly. - Aim for both optimal time and space complexity.","solution":"from typing import List, Optional, Tuple def max_profit_days(prices: List[int]) -> Optional[Tuple[int, int]]: if len(prices) < 2: return None min_price = prices[0] min_day = 0 max_profit = 0 buy_day = 0 sell_day = 0 for current_day in range(1, len(prices)): current_price = prices[current_day] # Calculate current profit current_profit = current_price - min_price # Update maximum profit and days if current_profit > max_profit: max_profit = current_profit buy_day = min_day sell_day = current_day # Update minimum price and its day if current_price < min_price: min_price = current_price min_day = current_day if max_profit > 0: return (buy_day, sell_day) else: return None"},{"question":"**B-Tree implementation and operations** You need to implement the `BTree` class methods as described to perform various operations such as insertion, deletion and search. # Problem Description: Given the class definition and partial implementation of B-Tree, add the required methods to complete the functionality. Specifically: 1. Implement the `find(self, key)` method which searches for the specified key in the B-tree. 2. Implement the `remove_key(self, key)` method which removes the specified key from the B-tree. 3. Implement the `_remove_key(self, node, key)` method which steps into the recursion of removing keys from the tree. # Input and Output Format 1. **find(self, key)** * **Input**: `key` (integer): the key value that needs to be searched in the B-tree. * **Output**: `Boolean` - `True` if the key is found, `False` otherwise. 2. **remove_key(self, key)** * **Input**: `key` (integer): the key value that needs to be removed from the B-tree. * **Output**: `None`, but the tree structure should be updated after removal. 3. **_remove_key(self, node, key)** (*used internally for recursive deletion*) * **Input**: * `node` (Node): the current node where the deletion operation is being performed. * `key` (integer): the key value that needs to be removed. * **Output**: `Boolean` - `True` if the removal is successful, `False` if the key is not found. # Constraints: 1. The tree must always remain balanced. 2. All keys must be maintained in sorted order within each node. # Requirements: * The input values for the keys are unique integers. * The methods should handle all edge cases, including finding and deleting keys in internal nodes, as well as adjusting the tree structure after deletion. --- **Example:** ```python # Create a BTree with degree 2 btree = BTree(2) # Insert keys btree.insert_key(10) btree.insert_key(20) btree.insert_key(5) btree.insert_key(6) btree.insert_key(12) btree.insert_key(30) btree.insert_key(7) # Search for a key assert btree.find(6) == True assert btree.find(15) == False # Remove a key btree.remove_key(6) assert btree.find(6) == False ``` # Note: - The detailed class definition is provided. Implement the requested methods while ensuring proper functionality of the B-Tree. - Do not assume the presence of any additional libraries or constructs. Work with the provided `Node` and `BTree` classes.","solution":"class Node: def __init__(self, t, leaf=False): self.t = t self.leaf = leaf self.keys = [] self.children = [] class BTree: def __init__(self, t): self.t = t self.root = Node(t, True) def _split_child(self, parent, i, child): t = self.t new_child = Node(t, child.leaf) parent.children.insert(i + 1, new_child) parent.keys.insert(i, child.keys[t - 1]) new_child.keys = child.keys[t:(2 * t - 1)] child.keys = child.keys[0:(t - 1)] if not child.leaf: new_child.children = child.children[t:(2 * t)] child.children = child.children[0:t] def _insert_non_full(self, node, key): i = len(node.keys) - 1 if node.leaf: node.keys.append(None) while i >= 0 and key < node.keys[i]: node.keys[i + 1] = node.keys[i] i -= 1 node.keys[i + 1] = key else: while i >= 0 and key < node.keys[i]: i -= 1 i += 1 if len(node.children[i].keys) == (2 * self.t - 1): self._split_child(node, i, node.children[i]) if key > node.keys[i]: i += 1 self._insert_non_full(node.children[i], key) def insert_key(self, key): root = self.root if len(root.keys) == (2 * self.t - 1): new_node = Node(self.t, False) new_node.children.insert(0, root) self._split_child(new_node, 0, root) self._insert_non_full(new_node, key) self.root = new_node else: self._insert_non_full(root, key) def find(self, key): return self._find(self.root, key) def _find(self, node, key): i = 0 while i < len(node.keys) and key > node.keys[i]: i += 1 if i < len(node.keys) and key == node.keys[i]: return True elif node.leaf: return False else: return self._find(node.children[i], key) def _remove_key(self, node, key): t = self.t i = 0 while i < len(node.keys) and key > node.keys[i]: i += 1 if i < len(node.keys) and key == node.keys[i]: if node.leaf: node.keys.pop(i) else: if len(node.children[i].keys) >= t: pred = self._get_pred(node, i) node.keys[i] = pred self._remove_key(node.children[i], pred) elif len(node.children[i+1].keys) >= t: succ = self._get_succ(node, i) node.keys[i] = succ self._remove_key(node.children[i+1], succ) else: self._merge(node, i) self._remove_key(node.children[i], key) else: if node.leaf: return False if len(node.children[i].keys) < t: if i != 0 and len(node.children[i-1].keys) >= t: self._borrow_from_prev(node, i) elif i != len(node.keys) and len(node.children[i+1].keys) >= t: self._borrow_from_next(node, i) else: if i != len(node.keys): self._merge(node, i) else: self._merge(node, i-1) self._remove_key(node.children[i], key) return True def remove_key(self, key): self._remove_key(self.root, key) if len(self.root.keys) == 0: if not self.root.leaf: self.root = self.root.children[0] else: self.root = Node(self.t, True) def _get_pred(self, node, idx): current = node.children[idx] while not current.leaf: current = current.children[len(current.keys)] return current.keys[len(current.keys) - 1] def _get_succ(self, node, idx): current = node.children[idx+1] while not current.leaf: current = current.children[0] return current.keys[0] def _merge(self, node, idx): t = self.t child = node.children[idx] sibling = node.children[idx + 1] child.keys.append(node.keys[idx]) for key in sibling.keys: child.keys.append(key) if not child.leaf: for child_ptr in sibling.children: child.children.append(child_ptr) node.keys.pop(idx) node.children.pop(idx+1) def _borrow_from_prev(self, node, idx): child = node.children[idx] sibling = node.children[idx - 1] child.keys.insert(0, node.keys[idx - 1]) if not child.leaf: child.children.insert(0, sibling.children.pop()) node.keys[idx - 1] = sibling.keys.pop() def _borrow_from_next(self, node, idx): child = node.children[idx] sibling = node.children[idx + 1] child.keys.append(node.keys[idx]) if not child.leaf: child.children.append(sibling.children.pop(0)) node.keys[idx] = sibling.keys.pop(0)"},{"question":"# Compress and Decompress Strings Using Run-Length Encoding You are asked to implement two functions `compress` and `decompress` that efficiently compress and decompress strings using Run-Length Encoding (RLE) technique. # Function One: `compress` Input - A string `s` containing the original data (1 ≤ |s| ≤ 10^4). Output - A string representing the run-length encoded form of the original data. # Function Two: `decompress` Input - A string `e` which is a run-length encoded form of original data (1 ≤ |e| ≤ 10^4). Output - A string representing the original decompressed form of the encoded data. # Constraints - The encoded string will always be a valid run-length encoded string. - Only lowercase alphabets and digits (0-9) are allowed in the input strings. # Example ```python def compress(s): # Your implementation here def decompress(e): # Your implementation here # Sample test cases print(compress(\\"aaabbbcc\\")) # Output: \\"3a3b2c\\" print(decompress(\\"3a3b2c\\")) # Output: \\"aaabbbcc\\" ``` # Notes - Ensure your solution efficiently handles edge cases such as empty strings, strings with single characters, and strings containing numerical characters. - Validate your functions with robust unit tests to avoid common errors.","solution":"def compress(s): if not s: return \\"\\" compressed = [] count = 1 prev_char = s[0] for char in s[1:]: if char == prev_char: count += 1 else: compressed.append(f\\"{count}{prev_char}\\") prev_char = char count = 1 compressed.append(f\\"{count}{prev_char}\\") return \'\'.join(compressed) def decompress(e): if not e: return \\"\\" decompressed = [] count = \'\' for char in e: if char.isdigit(): count += char else: decompressed.append(char * int(count)) count = \'\' return \'\'.join(decompressed)"},{"question":"# FizzBuzz Extended: Divisors and Custom Range Scenario Given the classic FizzBuzz problem, we want to extend its capabilities for more flexible use cases. You are tasked with writing a function that can handle any range of integers and use arbitrary divisors with respective replacement strings. This will be useful for generating customizable FizzBuzz-like sequences for various applications. Task Write a function `custom_fizzbuzz(start, end, divisors)` that generates a list of numbers and/or strings based on the following parameters: - **start**: An integer marking the start of the range. - **end**: An integer marking the end of the range (inclusive). - **divisors**: A dictionary where keys are integers (divisors) and values are the strings used to replace numbers divisible by these keys. Input - **start** (int): The starting integer of the range. - **end** (int): The ending integer of the range (inclusive). - **divisors** (dict): A dictionary containing integer keys and string values for substitution (e.g., {3: \\"Fizz\\", 5: \\"Buzz\\"}). Output - A list of integers and strings where each number is replaced depending on the divisors. Constraints - `start` <= `end`. - `start` and `end` are positive integers. - Each entry in `divisors` has a unique integer key with a non-empty string value. Example ```python custom_fizzbuzz(1, 15, {3: \\"Fizz\\", 5: \\"Buzz\\"}) ``` Expected output: ```python [1, 2, \'Fizz\', 4, \'Buzz\', \'Fizz\', 7, 8, \'Fizz\', \'Buzz\', 11, \'Fizz\', 13, 14, \'FizzBuzz\'] ```","solution":"def custom_fizzbuzz(start, end, divisors): Generates a custom fizzbuzz sequence for the given range and divisors. Parameters: start (int): The starting integer of the range. end (int): The ending integer of the range. divisors (dict): A dictionary containing integer keys and string values for substitution. Returns: list: A list of integers and/or strings based on the divisors. result = [] for number in range(start, end + 1): substitution = \\"\\" for divisor, word in divisors.items(): if number % divisor == 0: substitution += word if substitution: result.append(substitution) else: result.append(number) return result"},{"question":"**Title**: Bitwise Addition of Large Numbers **Objective**: Implement a function to add two non-negative integers using bitwise operations without utilizing the \'+\' operator. **Problem Description**: You are required to write a function that adds two non-negative integers given as input using only bitwise operations. **Function Signature**: ```python def bitwise_addition(a: int, b: int) -> int: ``` **Inputs**: - `a` (0 <= a <= 10^9) - `b` (0 <= b <= 10^9) **Output**: - An integer representing the sum of `a` and `b`. **Constraints**: - You must use bitwise operations to perform the addition. - Do not use the \'+\' operator or other arithmetic operators such as `-`, `*`, etc., to perform the addition. **Example**: ```plaintext Input: a = 15, b = 20 Output: 35 Input: a = 0, b = 0 Output: 0 Input: a = 500000, b = 500000 Output: 1000000 ``` **Performance Requirements**: - The solution should have a time complexity proportional to the number of bits in the integers (thus approximately O(log(max(a, b))) in practical terms). **Scenario**: You\'ve been tasked to develop low-level software for a custom hardware device, which restricts the use of the standard addition operator due to internal design constraints. To bypass this limitation, you must implement addition using bitwise operations. **Solution**: The basic approach involves iteratively applying bitwise operations to simulate the addition: 1. Use `a & b` to find carry bits. 2. Use `a ^ b` to compute the partial sum without carrying. 3. Shift the carry bits left and add them to the partial sum in the next iteration. 4. Repeat until the carry becomes zero.","solution":"def bitwise_addition(a: int, b: int) -> int: Returns the sum of a and b using bitwise operations. while b != 0: carry = a & b a = a ^ b b = carry << 1 return a"},{"question":"You are given a sorted array of integers in ascending order and a target integer. Implement the ternary search algorithm to find the position of the target in the array. If the target is present in the array, return its index. If the target is not present, return -1. Function Signature ```python def ternary_search(left: int, right: int, key: int, arr: List[int]) -> int: ``` Input - `left` (int): The starting index of the array. - `right` (int): The ending index of the array. - `key` (int): The target element you are searching for in the array. - `arr` (List[int]): The sorted array of integers. Output - Return the index of the target if found in the array; otherwise, return -1. Constraints - The length of the array is in the range [0, 10^6]. - The elements of the array are in the range [-10^9, 10^9]. - The target element `key` is in the range [-10^9, 10^9]. - The input array is sorted in non-decreasing order. Example Example 1: ```python arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] left = 0 right = len(arr) - 1 key = 5 print(ternary_search(left, right, key, arr)) # Output: 4 ``` Example 2: ```python arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] left = 0 right = len(arr) - 1 key = 12 print(ternary_search(left, right, key, arr)) # Output: -1 ``` *Note*: Ensure your implementation handles edge cases such as arrays of minimal size, arrays with all identical elements, and empty arrays correctly.","solution":"def ternary_search(left, right, key, arr): Performs a ternary search on the given sorted array. Args: left (int): The starting index of the array. right (int): The ending index of the array. key (int): The target element you are searching for in the array. arr (List[int]): The sorted array of integers. Returns: int: The index of the target if found in the array; otherwise, -1. while right >= left: mid1 = left + (right - left) // 3 mid2 = right - (right - left) // 3 if arr[mid1] == key: return mid1 if arr[mid2] == key: return mid2 if key < arr[mid1]: right = mid1 - 1 elif key > arr[mid2]: left = mid2 + 1 else: left = mid1 + 1 right = mid2 - 1 return -1"},{"question":"# String Reversing You are tasked with implementing a function to reverse a given string. You will use one of the following methods of string reversal: recursive, iterative, or slicing. Requirements: 1. Implement a function `reverse_string` that takes a string `s` and an optional parameter `method`. 2. `method` should determine the approach used - `\\"recursive\\"`, `\\"iterative\\"`, `\\"pythonic\\"`, or `\\"ultra_pythonic\\"`. The default value of `method` is `\\"iterative\\"`. 3. The function should return the reversed string using the specified method. Input: - A string `s` (1 ≤ |s| ≤ 10^4): the string that needs to be reversed. - Optionally, a string `method` specifying the reversal method to use. Constraints: - Consider handling very long strings effectively for the recursive algorithm. - Assume the input string only contains printable ASCII characters. Examples: ```python assert reverse_string(\\"hello\\", \\"recursive\\") == \\"olleh\\" assert reverse_string(\\"world\\", \\"iterative\\") == \\"dlrow\\" assert reverse_string(\\"python\\", \\"pythonic\\") == \\"nohtyp\\" assert reverse_string(\\"reverse\\", \\"ultra_pythonic\\") == \\"esrever\\" assert reverse_string(\\"example\\") == \\"elpmaxe\\" # By default using iterative method ```","solution":"def reverse_string(s, method=\\"iterative\\"): Reverses a given string `s` using the specified method. Parameters: s (str): The string to be reversed. method (str): The method to use for reversing the string - \\"recursive\\", \\"iterative\\", \\"pythonic\\", \\"ultra_pythonic\\". Returns: str: The reversed string. if method == \\"recursive\\": return _reverse_recursive(s) elif method == \\"iterative\\": return _reverse_iterative(s) elif method == \\"pythonic\\": return s[::-1] elif method == \\"ultra_pythonic\\": return \'\'.join(reversed(s)) else: raise ValueError(f\\"Unknown method: {method}\\") def _reverse_recursive(s): if len(s) <= 1: return s return s[-1] + _reverse_recursive(s[:-1]) def _reverse_iterative(s): reversed_str = [] for char in s: reversed_str.insert(0, char) return \'\'.join(reversed_str)"},{"question":"You are tasked with implementing a resizable hash table, similar to the one provided in the code snippets. Focus specifically on enhancing the insert and lookup performance by implementing a dynamic resizing mechanism in Python. Your resizable hash table should: 1. Implement the following operations using method definitions: * `put(key, value)`: Insert a key-value pair into the hash table. * `get(key)`: Retrieve the value associated with the given key. * `del_(key)`: Delete the key-value pair from the hash table. * `size()`: Return the current number of key-value pairs in the hash table. 2. Dynamically resize the table when the load factor exceeds 0.75 and also handle the resizing in such a way to minimize performance degradation and memory usage. 3. Collisions should be handled using linear probing. # Input and Output Format * The hash table should accept integer keys and any type of values. * Functions should return appropriate results or raise exceptions where applicable (e.g., inserting when the table is full and resizing fails). # Constraints 1. Keys will be non-negative integers. 2. Hash table will start with a minimum size of 8. 3. Aim for an efficient solution with proper handling of edge cases and error scenarios. # Example ```python # Example usage: htable = ResizableHashTable() htable.put(1, \\"A\\") htable.put(12, \\"B\\") # Should trigger resizing if high load factor is breached print(htable.get(1)) # Output: \\"A\\" print(htable.get(12)) # Output: \\"B\\" htable.del_(1) print(htable.get(1)) # Output: None ``` Implement the `ResizableHashTable` class below based on the specifications.","solution":"class ResizableHashTable: def __init__(self): self.initial_capacity = 8 self.size = 0 self.buckets = [None] * self.initial_capacity self.load_factor_threshold = 0.75 def _hash(self, key): return key % len(self.buckets) def _resize(self): old_buckets = self.buckets new_capacity = len(self.buckets) * 2 self.buckets = [None] * new_capacity self.size = 0 for pair in old_buckets: if pair is not None: self.put(pair[0], pair[1]) def put(self, key, value): if self.size / len(self.buckets) > self.load_factor_threshold: self._resize() index = self._hash(key) while self.buckets[index] is not None: if self.buckets[index][0] == key: self.buckets[index] = (key, value) return index = (index + 1) % len(self.buckets) self.buckets[index] = (key, value) self.size += 1 def get(self, key): index = self._hash(key) start_index = index while self.buckets[index] is not None: if self.buckets[index][0] == key: return self.buckets[index][1] index = (index + 1) % len(self.buckets) if index == start_index: break return None def del_(self, key): index = self._hash(key) start_index = index while self.buckets[index] is not None: if self.buckets[index][0] == key: self.buckets[index] = None self.size -= 1 self._rehash(index) return index = (index + 1) % len(self.buckets) if index == start_index: break def _rehash(self, empty_index): index = (empty_index + 1) % len(self.buckets) while self.buckets[index] is not None: key, value = self.buckets[index] self.buckets[index] = None self.size -= 1 self.put(key, value) index = (index + 1) % len(self.buckets) def size(self): return self.size"},{"question":"# Radix Sort on Mixed Lists You are given a list that contains both positive and negative integers. Your task is to implement the modified Radix Sort that can handle such lists efficiently. Function Signature ```python def mixed_radix_sort(arr: List[int], simulation: bool = False) -> List[int]: ``` # Input - **arr**: A list of integers (both positive and negative). - **simulation**: A boolean flag that, if set to True, prints the list after each iteration step of the sorting. Default is False. # Output - A sorted list of integers in ascending order. # Constraints - The list size ( n ) is such that ( 1 leq n leq 10^6 ). - The integers in the list can be both positive and negative, typically within the 32-bit signed integer range. # Requirements - You should handle both positive and negative integers. - Demonstrate your understanding of how Radix Sort works and extend it to handle negative integers. # Example ```python input_arr = [170, 45, 75, -90, 802, 24, -2, 66] simulation = True output_arr = mixed_radix_sort(input_arr, simulation) # Expected output: [-90, -2, 24, 45, 66, 75, 170, 802] # The simulation should print the intermediate steps of sorting. ``` # Implementation Note - Modify the existing radix sort to handle negative numbers. You may consider separating positives and negatives, sorting them independently, and then combining them in the end.","solution":"from typing import List def mixed_radix_sort(arr: List[int], simulation: bool = False) -> List[int]: def counting_sort(arr, exp): n = len(arr) output = [0] * n count = [0] * 10 for i in range(n): index = abs(arr[i]) // exp count[(index % 10)] += 1 for i in range(1, 10): count[i] += count[i - 1] i = n - 1 while i >= 0: index = abs(arr[i]) // exp output[count[(index % 10)] - 1] = arr[i] count[(index % 10)] -= 1 i -= 1 for i in range(n): arr[i] = output[i] if not arr: return [] max_val = max(arr, key=abs) exp = 1 while max_val // exp > 0: counting_sort(arr, exp) exp *= 10 if simulation: print(arr) negatives = [x for x in arr if x < 0] positives = [x for x in arr if x >= 0] negatives.sort() arr = negatives + positives return arr"},{"question":"# Question: Check Balanced Binary Tree Context In various applications like balanced search engines, game trees, and self-balancing AVL trees, it\'s crucial to ensure that binary trees remain balanced for optimal performance of operations like insertions, deletions, and searches. Your task is to write a function that checks whether a given binary tree is balanced. Problem Statement Write a function `is_balanced(root)` which accepts a `TreeNode` representing the root of a binary tree and returns `True` if the tree is balanced, `False` otherwise. Input - A binary tree root node `root` where each node has integer value and two children nodes `left` and `right`, or is `None` for no node. Output - A boolean value: `True` if the tree is balanced, `False` if it is not. Constraints - The tree can contain up to 10^5 nodes. - Node values are not required for balance check. Requirements - Efficient solution with O(N) time complexity is expected. - Must handle edge cases and ensure correctness for deep and large trees. Example ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right # Example 1 # Input: # 1 # / # 2 3 # / # 4 5 # # 6 # Output: # is_balanced(root) == True # Example 2 # Input: # 1 # / # 2 3 # / # 4 5 # / # 8 # # 9 # Output: # is_balanced(root) == False ``` Write the function `is_balanced(root)` which should look like: ```python def is_balanced(root): # Your code here ```","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_balanced(root): def check_balance_and_height(node): if not node: return (True, 0) left_balanced, left_height = check_balance_and_height(node.left) right_balanced, right_height = check_balance_and_height(node.right) balanced = left_balanced and right_balanced and abs(left_height - right_height) <= 1 height = max(left_height, right_height) + 1 return (balanced, height) return check_balance_and_height(root)[0]"},{"question":"You are required to implement a function to find the Minimum Spanning Tree (MST) weight of a given connected, undirected graph using Kruskal\'s algorithm. Your implementation should efficiently manage the underlying disjoint sets and handle edge cases gracefully. # Function Signature ```python def calculate_mst_weight(vertex_count: int, edge_list: List[Tuple[int, int, int]]) -> int: ``` # Input - `vertex_count`: An integer representing the number of vertices in the graph (1 ≤ `vertex_count` ≤ 1000). - `edge_list`: A list of tuples where each tuple contains three integers `(u, v, w)` corresponding to an edge between vertices `u` and `v` with weight `w` (0 ≤ `w` ≤ 10^6). # Output - An integer representing the total weight of the minimum spanning tree for the given graph. # Constraints - The graph is guaranteed to be connected and undirected. - Vertices are 1-indexed in the `edge_list`. # Example ```python vertex_count = 5 edge_list = [(1, 2, 3), (1, 3, 8), (2, 4, 5), (3, 4, 2), (3, 5, 4), (4, 5, 6)] print(calculate_mst_weight(vertex_count, edge_list)) # Output: 14 ``` # Description You need to follow these steps: 1. Parse the function inputs. 2. Implement the disjoint set with path compression and union by rank/size. 3. Sort the edges in non-decreasing order of their weights. 4. Iterate over edges and use the disjoint set to ensure adding only edges that do not form a cycle. 5. Return the total weight of the MST once you\'ve added `vertex_count - 1` edges.","solution":"from typing import List, Tuple def calculate_mst_weight(vertex_count: int, edge_list: List[Tuple[int, int, int]]) -> int: Calculate the weight of the minimum spanning tree (MST) of a graph using Kruskal\'s algorithm. # Helper function: Disjoint Set Union Find with path compression and union by rank class DSU: def __init__(self, n): self.parent = list(range(n)) self.rank = [0] * n def find(self, x): if self.parent[x] != x: self.parent[x] = self.find(self.parent[x]) # Path compression return self.parent[x] def union(self, x, y): rootX = self.find(x) rootY = self.find(y) if rootX != rootY: # Union by rank if self.rank[rootX] > self.rank[rootY]: self.parent[rootY] = rootX elif self.rank[rootX] < self.rank[rootY]: self.parent[rootX] = rootY else: self.parent[rootY] = rootX self.rank[rootX] += 1 # Kruskal’s algorithm # Step 1: Sort all the edges in non-decreasing order of their weight. edge_list.sort(key=lambda x: x[2]) # Initialize DSU dsu = DSU(vertex_count + 1) # Since vertices are 1-indexed mst_weight = 0 edges_used = 0 for u, v, w in edge_list: if dsu.find(u) != dsu.find(v): dsu.union(u, v) mst_weight += w edges_used += 1 if edges_used == vertex_count - 1: break return mst_weight"},{"question":"# Dijkstra\'s Algorithm Implementation with Custom Edge Weights In this task, you are required to implement a variation of Dijkstra\'s shortest-path algorithm where you will be given a list of edges instead of an adjacency matrix. # Function Signature: ```python def dijkstra_with_edges(vertex_count: int, edges: List[Tuple[int, int, int]], src: int) -> List[int]: ``` # Input: * `vertex_count` (int): The total number of vertices in the graph. * `edges` (List[Tuple[int, int, int]]): A list of tuples where each tuple represents an edge `(u, v, w)` meaning there\'s an edge from node `u` to node `v` with weight `w`. * `src` (int): The source node from which the shortest paths are calculated. # Output: * `dist` (List[int]): A list where the ith value represents the shortest distance from the source node to the ith node. If a node is unreachable, the distance should be `float(\'inf\')`. # Constraints: * All edge weights are non-negative. * The graph can have up to 1,000 vertices and 10,000 edges. # Performance: Ensure your solution can handle up to 1,000 vertices and 10,000 edges efficiently. # Example: ```python vertex_count = 5 edges = [(0, 1, 9), (0, 2, 6), (0, 3, 5), (0, 4, 3), (2, 1, 2), (2, 3, 4)] src = 0 print(dijkstra_with_edges(vertex_count, edges, src)) # Output should be: [0, 8, 6, 5, 3] ``` # Context: Assume you are working on a network management software, and you need to implement an efficient route planning feature. The provided edges represent the connection between different routers, and you need to compute the shortest paths for efficient data transfer.","solution":"import heapq from typing import List, Tuple def dijkstra_with_edges(vertex_count: int, edges: List[Tuple[int, int, int]], src: int) -> List[int]: Implementation of Dijkstra\'s shortest path algorithm using a list of edges. Parameters: vertex_count (int): Total number of vertices in the graph. edges (List[Tuple[int, int, int]]): Edge list where each tuple represents (u, v, w) meaning there\'s an edge from node u to node v with weight w. src (int): The source node from which the shortest paths are calculated. Returns: List[int]: List where the ith value is the shortest distance from the source to the ith node. Distance is float(\'inf\') if a node is unreachable. # Create an adjacency list from the edge list adj_list = [[] for _ in range(vertex_count)] for u, v, w in edges: adj_list[u].append((v, w)) # Initialize distances array dist = [float(\'inf\')] * vertex_count dist[src] = 0 # Use a priority queue to get the next vertex with the smallest distance priority_queue = [(0, src)] while priority_queue: current_dist, u = heapq.heappop(priority_queue) if current_dist > dist[u]: continue for v, weight in adj_list[u]: distance = current_dist + weight if distance < dist[v]: dist[v] = distance heapq.heappush(priority_queue, (distance, v)) return dist"},{"question":"# Binary Search Tree Implementation Context: You have been hired to design a software component that performs efficient search, insertion, and deletion in a dataset. The dataset can grow dynamically, and all operations need to be optimized for performance. After analyzing various data structures, you decide to implement a Binary Search Tree (BST) due to its average case efficiency in these operations. Task: Implement a Binary Search Tree that supports the following operations: 1. `insert(val)`: Insert a value into the BST. 2. `search(val)`: Search for a value in the BST, returning `True` if the value exists, otherwise `False`. 3. `delete(val)`: Delete a value from the BST. You may assume that all values are unique for simplicity. Requirements: * **Input/Output**: * `insert(val)` takes an integer value `val` to insert. * `search(val)` takes an integer value `val` and returns a boolean indicating whether the value is in the BST. * `delete(val)` takes an integer value `val` to delete. * **Constraints**: * `val` is an integer in the range [-10^4, 10^4]. * There will be at most 10^4 operations performed. * **Performance**: * Operations should be optimized for the average-case time complexity of O(log n). Implementation: ```python class TreeNode: def __init__(self, val=0): self.val = val self.left = None self.right = None class BinarySearchTree: def __init__(self): self.root = None def insert(self, val: int) -> None: pass # Implement this method def search(self, val: int) -> bool: pass # Implement this method def delete(self, val: int) -> None: pass # Implement this method ``` Provide the implementation for the `insert`, `search`, and `delete` methods to complete the BST functionality.","solution":"class TreeNode: def __init__(self, val=0): self.val = val self.left = None self.right = None class BinarySearchTree: def __init__(self): self.root = None def insert(self, val: int) -> None: self.root = self._insert_recursive(self.root, val) def _insert_recursive(self, node, val): if node is None: return TreeNode(val) if val < node.val: node.left = self._insert_recursive(node.left, val) else: node.right = self._insert_recursive(node.right, val) return node def search(self, val: int) -> bool: return self._search_recursive(self.root, val) def _search_recursive(self, node, val): if node is None: return False if val == node.val: return True elif val < node.val: return self._search_recursive(node.left, val) else: return self._search_recursive(node.right, val) def delete(self, val: int) -> None: self.root = self._delete_recursive(self.root, val) def _delete_recursive(self, node, val): if node is None: return node if val < node.val: node.left = self._delete_recursive(node.left, val) elif val > node.val: node.right = self._delete_recursive(node.right, val) else: if node.left is None: return node.right elif node.right is None: return node.left temp_val = self._min_value_node(node.right).val node.val = temp_val node.right = self._delete_recursive(node.right, temp_val) return node def _min_value_node(self, node): current = node while current.left is not None: current = current.left return current"},{"question":"You are given a binary tree where each node contains an integer value, and a target sum. Write a function `find_path_sums` that finds all unique root-to-leaf paths in the binary tree where the sum of the values in the path equals the target sum. Input Format * `root`: The root node of the binary tree. * `target_sum`: An integer representing the target sum. Output Format * A list of lists, where each inner list contains the node values in a root-to-leaf path having the sum equal to `target_sum`. Constraints * The number of nodes in the tree is in the range [0, 5000]. * -1000 <= Node.val <= 1000 * -1000 <= target_sum <= 1000 Example ``` Input: 5 / 4 8 / / 11 13 4 / / 7 2 5 1 target_sum = 22 Output: [ [5, 4, 11, 2], [5, 8, 4, 5] ] ``` Additional Notes - Ensure that your solution handles edge cases, such as an empty tree or target sums that cannot be achieved. - Consider both time and space complexity for optimal performance. - Avoid using any external libraries; implement the solution using basic data structures and algorithms.","solution":"# Definition for a binary tree node. class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def find_path_sums(root, target_sum): def dfs(node, current_path, current_sum): if not node: return current_path.append(node.val) current_sum += node.val if not node.left and not node.right and current_sum == target_sum: result.append(list(current_path)) if node.left: dfs(node.left, current_path, current_sum) if node.right: dfs(node.right, current_path, current_sum) current_path.pop() result = [] dfs(root, [], 0) return result"},{"question":"# Path Finding in Directed Graphs Problem Statement: You are given a directed graph implemented by an adjacency list. Your task is to determine if there exists a path between two given nodes in the graph using Depth-First Search (DFS). Implement a function `is_reachable(graph: Graph, source: int, target: int) -> bool` that returns `True` if there is a path, otherwise `False`. Function Signature: ```python def is_reachable(graph: Graph, source: int, target: int) -> bool: ``` Input: * `graph` (Graph): An instance of the provided `Graph` class which contains the graph data structure. * `source` (int): The starting vertex id. * `target` (int): The target vertex id. Output: * `bool`: Returns `True` if there exists a path from `source` to `target`, otherwise `False`. Constraints: * Assume `0 <= source, target < graph.vertex_count`. * The graph can have at most 10,000 vertices and 50,000 edges. * Consider handling stack overflows for very deep graphs or extremely large inputs. Example: ```python g = Graph(4) g.add_edge(0, 1) g.add_edge(1, 2) g.add_edge(2, 3) g.add_edge(3, 0) print(is_reachable(g, 0, 3)) # Output: True print(is_reachable(g, 3, 1)) # Output: True print(is_reachable(g, 0, 2)) # Output: True print(is_reachable(g, 3, 2)) # Output: False ``` Implementation Tips: 1. Utilize depth-first search principles effectively. 2. Handle graph traversal edge cases (e.g., no outgoing edges, isolated nodes). 3. Ensure the method is efficient and capable of handling large input sizes.","solution":"class Graph: def __init__(self, vertex_count): self.vertex_count = vertex_count self.adjacency_list = [[] for _ in range(vertex_count)] def add_edge(self, u, v): self.adjacency_list[u].append(v) def is_reachable(graph, source, target): Determine if there exists a path from source to target in the given directed graph. visited = [False] * graph.vertex_count def dfs(node): if node == target: return True visited[node] = True for neighbour in graph.adjacency_list[node]: if not visited[neighbour]: if dfs(neighbour): return True return False return dfs(source)"},{"question":"# Question You are provided with a 2D grid initially filled with water. You need to implement a solution to dynamically process a series of land additions and count the number of islands after each addition of land. An island is defined as a group of adjacent (vertically or horizontally) land cells. Task You need to implement the function `num_islands(positions: List[List[int]]) -> List[int]` where: * **positions** (List[List[int]]): A list of positions, each indicating coordinates [i, j] where land is added. The function should return a list of integers, each representing the number of islands after each land addition. Constraints * The grid size is not defined explicitly and can be considered large. * The positions will be unique. * You need to use the Union-Find data structure to manage the sets of connected lands efficiently. Example: ```python positions = [[0, 0], [0, 1], [1, 2], [2, 1]] # Initially: # 0 0 0 # 0 0 0 # 0 0 0 # Operation 1: addLand(0, 0) -> Number of islands = 1 # 1 0 0 # 0 0 0 # 0 0 0 # Operation 2: addLand(0, 1) -> Number of islands = 1 # 1 1 0 # 0 0 0 # 0 0 0 # Operation 3: addLand(1, 2) -> Number of islands = 2 # 1 1 0 # 0 0 1 # 0 0 0 # Operation 4: addLand(2, 1) -> Number of islands = 3 # 1 1 0 # 0 0 1 # 0 1 0 # Output: [1, 1, 2, 3] result = num_islands(positions) print(result) # Output should be [1, 1, 2, 3] ``` You have to ensure efficient performance and handle edge cases appropriately.","solution":"from typing import List class UnionFind: def __init__(self, size): self.parent = list(range(size)) self.rank = [1] * size self.count = 0 def find(self, p): if self.parent[p] != p: self.parent[p] = self.find(self.parent[p]) return self.parent[p] def union(self, p, q): rootP = self.find(p) rootQ = self.find(q) if rootP != rootQ: if self.rank[rootP] > self.rank[rootQ]: self.parent[rootQ] = rootP elif self.rank[rootP] < self.rank[rootQ]: self.parent[rootP] = rootQ else: self.parent[rootQ] = rootP self.rank[rootP] += 1 self.count -= 1 def increment_count(self): self.count += 1 def get_count(self): return self.count def num_islands(positions: List[List[int]]) -> List[int]: direction_vectors = [(0, 1), (0, -1), (1, 0), (-1, 0)] if not positions: return [] row_max, col_max = 0, 0 for position in positions: row_max = max(row_max, position[0]) col_max = max(col_max, position[1]) row_max += 1 col_max += 1 uf = UnionFind(row_max * col_max) visited = [[False] * col_max for _ in range(row_max)] results = [] for r, c in positions: if not visited[r][c]: visited[r][c] = True uf.increment_count() for dr, dc in direction_vectors: nr, nc = r + dr, c + dc if 0 <= nr < row_max and 0 <= nc < col_max and visited[nr][nc]: uf.union(r * col_max + c, nr * col_max + nc) results.append(uf.get_count()) return results"},{"question":"# Question: Implement a Doubly and Singly Linked List with Custom Operations **Objective**: Write Python classes for doubly linked list and singly linked list. Implement core functions such as insertion, deletion, and search in both list types. **Scenario**: You are tasked to manage a collection of playlist songs to demonstrate your understanding of linked lists. Each node in the list represents a song. # Requirements: 1. **Singly Linked List Class**: - Nodes should store the value (song name). - Implement the following functions: * `insert_at_end(value)`: Insert a new node with the given value at the end. * `delete_value(value)`: Delete the first node with the given value. * `search(value)`: Return `True` if a node with the given value exists, otherwise `False`. 2. **Doubly Linked List Class**: - Nodes should store the value (song name). - Implement the following functions: * `insert_at_end(value)`: Insert a new node with the given value at the end. * `delete_value(value)`: Delete the first node with the given value. * `search(value)`: Return `True` if a node with the given value exists, otherwise `False`. # Input/Output: * **Input**: Operations on the linked lists (no direct input to functions). * **Output**: Expected results of operations, such as confirmation messages or boolean values. # Constraints: * Node values are strings (song names). * Assume unique song names for simplicity. * Handle list size up to 10^3 nodes efficiently. Example: ```python # Example usage for Singly Linked List sll = SinglyLinkedList() sll.insert_at_end(\\"Song1\\") sll.insert_at_end(\\"Song2\\") print(sll.search(\\"Song1\\")) # Output: True sll.delete_value(\\"Song1\\") print(sll.search(\\"Song1\\")) # Output: False # Example usage for Doubly Linked List dll = DoublyLinkedList() dll.insert_at_end(\\"Song1\\") dll.insert_at_end(\\"Song2\\") print(dll.search(\\"Song1\\")) # Output: True dll.delete_value(\\"Song1\\") print(dll.search(\\"Song1\\")) # Output: False ``` Implement both classes and ensure your code handles edge cases such as empty lists and non-existent values.","solution":"class SinglyLinkedList: class Node: def __init__(self, value=None): self.value = value self.next = None def __init__(self): self.head = None def insert_at_end(self, value): new_node = self.Node(value) if not self.head: self.head = new_node return last = self.head while last.next: last = last.next last.next = new_node def delete_value(self, value): if not self.head: return if self.head.value == value: self.head = self.head.next return current = self.head while current.next and current.next.value != value: current = current.next if current.next: current.next = current.next.next def search(self, value): current = self.head while current: if current.value == value: return True current = current.next return False class DoublyLinkedList: class Node: def __init__(self, value=None): self.value = value self.next = None self.prev = None def __init__(self): self.head = None def insert_at_end(self, value): new_node = self.Node(value) if not self.head: self.head = new_node return last = self.head while last.next: last = last.next last.next = new_node new_node.prev = last def delete_value(self, value): if not self.head: return if self.head.value == value: self.head = self.head.next if self.head: self.head.prev = None return current = self.head while current and current.value != value: current = current.next if current: if current.next: current.next.prev = current.prev if current.prev: current.prev.next = current.next def search(self, value): current = self.head while current: if current.value == value: return True current = current.next return False"},{"question":"# Question: Implement Improved Ordered Stack Implement a modified version of the OrderedStack class. Your new implementation should ensure the stack remains sorted while aiming to improve the performance of insertion. Specifically, focus on optimizing the `push` method to be more efficient than in the original implementation. Analyze and justify the complexity improvements, if any. # Input and Output Format: **Class Definition**: ```python class ImprovedOrderedStack: def __init__(self): # Initialize your stack and any other required variables here def is_empty(self): # Returns True if the stack is empty def push(self, item): # Insert an item into the stack while maintaining order def pop(self): # Removes the top element from the stack and returns it # Should raise an IndexError if the stack is empty def peek(self): # Returns the top element without removing it def size(self): # Returns the size of the stack ``` **Constraints**: - Elements will be non-negative integers. - Avoid using built-in sort functions directly. **Performance Requirements**: - Aim to make the `push` operation more efficient than O(n) if possible. **Examples**: ```python # Initialization stack = ImprovedOrderedStack() # Push elements stack.push(10) stack.push(5) stack.push(15) # Stack should now be [5, 10, 15] assert stack.peek() == 15 assert stack.size() == 3 # Pop element assert stack.pop() == 15 # Stack should now be [5, 10] assert stack.peek() == 10 assert stack.size() == 2 # Pop all elements assert stack.pop() == 10 assert stack.pop() == 5 # Stack should be empty now assert stack.is_empty() ``` # Discussion: Explain why your implementation is more efficient than the original and discuss any trade-offs or assumptions made.","solution":"class ImprovedOrderedStack: def __init__(self): self.stack = [] def is_empty(self): return len(self.stack) == 0 def push(self, item): # Perform binary search to find the correct position to insert low, high = 0, len(self.stack) while low < high: mid = (low + high) // 2 if self.stack[mid] < item: low = mid + 1 else: high = mid self.stack.insert(low, item) def pop(self): if self.is_empty(): raise IndexError(\\"pop from empty stack\\") return self.stack.pop() def peek(self): if self.is_empty(): raise IndexError(\\"peek from empty stack\\") return self.stack[-1] def size(self): return len(self.stack)"},{"question":"# Coding Challenge: Combinational Sum Finder Context You are tasked with creating a function that can find all unique combinations of numbers from a given set of candidates that sum to a specific target number. Each candidate number can be used an unlimited number of times. Task Implement a function `combination_sum(candidates, target)` in Python with the following specifications: Input - `candidates`: A list of positive integers representing the set of candidate numbers (e.g., `[2, 3, 6, 7]`). - `target`: A positive integer representing the target sum (e.g., `7`). Output - A list of lists, where each inner list represents a unique combination of numbers from `candidates` that sum to `target`. Constraints - The same repeated number may be chosen from `candidates` an unlimited number of times. - All numbers (including `target`) will be positive integers. - The solution set must not contain duplicate combinations. - The candidates list will contain unique integers (no duplicates). Examples 1. `combination_sum([2, 3, 6, 7], 7)` should return `[[7], [2, 2, 3]]`. 2. `combination_sum([2, 3, 5], 8)` could return `[[2, 2, 2, 2], [2, 3, 3], [3, 5]]`. Instructions 1. Sort the `candidates` list to handle duplicates effectively and ensure combinations are examined in order. 2. Utilize a depth-first search (DFS) approach with backtracking to explore all potential combinations. 3. Ensure your recursive function accounts for base cases such as target being zero (solution found) and target being negative (backtrack). 4. Optimize the solution to ensure no duplicate combinations are added to the result. 5. Write clean and readable code with proper variable names and comments explaining your logic. Good luck!","solution":"def combination_sum(candidates, target): Finds all unique combinations in candidates that sum up to the target. Parameters: candidates (list): A list of unique positive integers. target (int): The target sum. Returns: list of lists: A list containing all unique combinations that sum up to target. result = [] candidates.sort() def backtrack(remain, comb, start): if remain == 0: # When the target is met, add the combination to the result result.append(list(comb)) return elif remain < 0: # If the remain is negative, there\'s no point in continuing return for i in range(start, len(candidates)): comb.append(candidates[i]) # Since we can reuse the same number, the `start` stays `i` backtrack(remain - candidates[i], comb, i) # Backtrack, remove the last element and try another number comb.pop() backtrack(target, [], 0) return result"},{"question":"**Objective:** You are required to implement a data structure called `RandomizedSet` that supports the following operations with an average time complexity of O(1): 1. `insert(val)`: Inserts an item `val` to the set if not already present. Returns `True` if the element was successfully added and `False` if it was already present. 2. `remove(val)`: Removes an item `val` from the set if it is present. Returns `True` if the element was successfully removed and `False` if the element was not present. 3. `getRandom()`: Returns a random element from the current set of elements, ensuring each element has the same probability of being selected. If the set is empty, the method should raise an exception. **Example:** ```python # Example Usage rs = RandomizedSet() print(rs.insert(1)) # Output: True print(rs.remove(2)) # Output: False print(rs.insert(2)) # Output: True print(rs.getRandom()) # Output: 1 or 2 print(rs.remove(1)) # Output: True print(rs.insert(2)) # Output: False print(rs.getRandom()) # Output: 2 ``` **Constraints:** 1. Elements are guaranteed to be integers. 2. All values are within the range of the 32-bit signed integer. 3. The `getRandom` method should always return a valid element unless the set is empty, in which case it should raise an exception. **Additional Notes:** - Thoroughly handle edge cases, such as repeated insertions or removals. - Ensure the `getRandom` function handles the possibility of an empty set appropriately.","solution":"import random class RandomizedSet: def __init__(self): Initialize your data structure here. self.dict = {} self.list = [] def insert(self, val: int) -> bool: Inserts an item val to the set if not already present. Returns true if the element was successfully added and false if it was already present. if val in self.dict: return False self.dict[val] = len(self.list) self.list.append(val) return True def remove(self, val: int) -> bool: Removes an item val from the set if it is present. Returns true if the element was successfully removed and false if it was not present. if val not in self.dict: return False last_element = self.list[-1] idx_to_remove = self.dict[val] self.list[idx_to_remove] = last_element self.dict[last_element] = idx_to_remove self.list.pop() del self.dict[val] return True def getRandom(self) -> int: Get a random element from the set. If the set is empty, raise an Exception. if not self.list: raise Exception(\\"The set is empty\\") return random.choice(self.list)"},{"question":"# Byte Conversion and Validation Background In many computer systems, data is represented in bytes, but the order in which these bytes are arranged can differ. The two most common formats are: - **Big Endian**: The most significant byte (highest order) is stored first. - **Little Endian**: The least significant byte (lowest order) is stored first. You have to write functions that can convert an integer to bytes and vice versa, in both endianness formats. Additionally, ensure that the functions handle edge cases like zero and empty inputs appropriately. Task Implement four functions: 1. `int_to_bytes_big_endian(num: int) -> bytes` 2. `int_to_bytes_little_endian(num: int) -> bytes` 3. `bytes_big_endian_to_int(bytestr: bytes) -> int` 4. `bytes_little_endian_to_int(bytestr: bytes) -> int` # Function Specifications 1. **int_to_bytes_big_endian(num)** - **Input**: A non-negative integer `num`. - **Output**: The `num` converted to a `bytes` object in big-endian order. - **Constraint**: `0 <= num < 2^64`. 2. **int_to_bytes_little_endian(num)** - **Input**: A non-negative integer `num`. - **Output**: The `num` converted to a `bytes` object in little-endian order. - **Constraint**: `0 <= num < 2^64`. 3. **bytes_big_endian_to_int(bytestr)** - **Input**: A `bytes` object `bytestr` representing an integer in big-endian order. - **Output**: The integer `num` represented by `bytestr`. - **Edge Case**: If `bytestr` is empty, return `0`. 4. **bytes_little_endian_to_int(bytestr)** - **Input**: A `bytes` object `bytestr` representing an integer in little-endian order. - **Output**: The integer `num` represented by `bytestr`. - **Edge Case**: If `bytestr` is empty, return `0`. Examples ```python # Big Endian Conversion assert int_to_bytes_big_endian(258) == b\'x01x02\' assert bytes_big_endian_to_int(b\'x01x02\') == 258 # Little Endian Conversion assert int_to_bytes_little_endian(258) == b\'x02x01\' assert bytes_little_endian_to_int(b\'x02x01\') == 258 # Edge Cases assert int_to_bytes_big_endian(0) == b\'x00\' assert bytes_big_endian_to_int(b\'\') == 0 assert bytes_little_endian_to_int(b\'\') == 0 ``` **Note**: Ensure that your implementations are efficient and handle the upper constraints of the input gracefully.","solution":"def int_to_bytes_big_endian(num: int) -> bytes: Converts a non-negative integer to a bytes object in big-endian order. if num == 0: return b\'x00\' byte_length = (num.bit_length() + 7) // 8 return num.to_bytes(byte_length, byteorder=\'big\') def int_to_bytes_little_endian(num: int) -> bytes: Converts a non-negative integer to a bytes object in little-endian order. if num == 0: return b\'x00\' byte_length = (num.bit_length() + 7) // 8 return num.to_bytes(byte_length, byteorder=\'little\') def bytes_big_endian_to_int(bytestr: bytes) -> int: Converts a big-endian ordered bytes object to an integer. if not bytestr: return 0 return int.from_bytes(bytestr, byteorder=\'big\') def bytes_little_endian_to_int(bytestr: bytes) -> int: Converts a little-endian ordered bytes object to an integer. if not bytestr: return 0 return int.from_bytes(bytestr, byteorder=\'little\')"},{"question":"# Context Bubble sort is one of the simplest sorting algorithms, often used for educational purposes to demonstrate the basic principle of sorting. Unfortunately, its poor performance for larger datasets makes it impractical for many real-world applications. # Objective Your task is to enhance and then implement the bubble sort algorithm. Specifically, you will introduce optimizations to make the algorithm faster in certain scenarios. # Problem Statement 1. **Function Definition**: - Implement a function `enhanced_bubble_sort(arr: List[int], simulation: bool = False) -> List[int]`. - The function should sort the input list `arr` in ascending order using an optimized version of bubble sort. 2. **Optimizations Needed**: - Implement early termination if the list becomes sorted before completing all passes. - Optimize the algorithm to reduce the number of comparisons in each pass by recognizing the last swap position. 3. **Simulation**: - If the `simulation` flag is set to `True`, print the state of the list after each iteration. # Input & Output - **Input**: A list of integers `arr` (0 ≤ len(arr) ≤ 1000, -10^6 ≤ arr[i] ≤ 10^6). - **Output**: A sorted list of integers in ascending order. - **Example**: ```python enhanced_bubble_sort([64, 34, 25, 12, 22, 11, 90]) # Should return [11, 12, 22, 25, 34, 64, 90] ``` # Constraints - Ensure the algorithm handles edge cases, including empty arrays and arrays with a single element. - Performance: Aim for O(n) time complexity in best-case scenarios, with early termination when the list is already sorted.","solution":"from typing import List def enhanced_bubble_sort(arr: List[int], simulation: bool = False) -> List[int]: Sorts the input list `arr` in ascending order using an optimized version of bubble sort. If `simulation` is True, prints the state of the list after each complete pass. n = len(arr) for i in range(n): swapped = False # Reduce the number of comparisons since the largest elements are already bubbled up for j in range(1, n - i): if arr[j - 1] > arr[j]: arr[j - 1], arr[j] = arr[j], arr[j - 1] swapped = True if simulation: print(f\\"After iteration {i+1}: {arr}\\") # If no two elements were swapped by inner loop, then the list is sorted if not swapped: break return arr"},{"question":"# Question: Calculate the Unknown Side of a Right-Angled Triangle Given a right-angled triangle, you need to compute the length of the unknown side. You will be provided with the lengths of two sides and a placeholder (\\"?\\") indicating the unknown side. The lengths of all sides will be given as integers or as the string \\"?\\" where necessary. Your task is to implement the function `calculate_side` that performs the following: - If the opposite side is unknown, calculate it using the formula: [ text{opposite}^2 = text{hypotenuse}^2 - text{adjacent}^2 ] - If the adjacent side is unknown, calculate it using the formula: [ text{adjacent}^2 = text{hypotenuse}^2 - text{opposite}^2 ] - If the hypotenuse is unknown, calculate it using the formula: [ text{hypotenuse}^2 = text{opposite}^2 + text{adjacent}^2 ] Return the unknown length rounded to 2 decimal places in a string prefixed with the side\'s name (e.g., \\"Opposite = <length>\\"). If an invalid combination of input is given (e.g., multiple \\"?\\"), raise a `ValueError`. Function Signature ```python def calculate_side(opposite: Union[int, str], adjacent: Union[int, str], hypotenuse: Union[int, str]) -> str: pass ``` Input - `opposite` (int or str): The length of the opposite side or \\"?\\" indicating it is unknown. - `adjacent` (int or str): The length of the adjacent side or \\"?\\" indicating it is unknown. - `hypotenuse` (int or str): The length of the hypotenuse or \\"?\\" indicating it is unknown. Output - str: The length of the unknown side rounded to 2 decimal places, prefixed with its side name. Constraints - At most one of `opposite`, `adjacent`, `hypotenuse` will be \\"?\\". - All side lengths, if given, will be positive integers. - The function should handle constraints and edge cases such as invalid inputs gracefully by raising appropriate exceptions. Examples ```python # Example 1 print(calculate_side(\\"?\\", 4, 5)) # Output: \\"Opposite = 3.0\\" # Example 2 print(calculate_side(3, \\"?\\", 5)) # Output: \\"Adjacent = 4.0\\" # Example 3 print(calculate_side(3, 4, \\"?\\")) # Output: \\"Hypotenuse = 5.0\\" # Example 4 print(calculate_side(3, 4, 5)) # Output: \\"You already know the answer!\\" # Example 5 print(calculate_side(3, \\"?\\", \\"?\\")) # Raise ValueError: invalid argument(s) were given. ```","solution":"import math from typing import Union def calculate_side(opposite: Union[int, str], adjacent: Union[int, str], hypotenuse: Union[int, str]) -> str: if isinstance(opposite, str) and isinstance(adjacent, str) or isinstance(opposite, str) and isinstance(hypotenuse, str) or isinstance(adjacent, str) and isinstance(hypotenuse, str): raise ValueError(\\"Invalid arguments: Too many unknown sides.\\") if isinstance(opposite, str): if isinstance(adjacent, int) and isinstance(hypotenuse, int): if hypotenuse <= adjacent: raise ValueError(\\"Invalid arguments: Hypotenuse must be greater than adjacent.\\") opposite_length = math.sqrt(hypotenuse**2 - adjacent**2) return f\\"Opposite = {round(opposite_length, 2)}\\" elif isinstance(adjacent, str): if isinstance(opposite, int) and isinstance(hypotenuse, int): if hypotenuse <= opposite: raise ValueError(\\"Invalid arguments: Hypotenuse must be greater than opposite.\\") adjacent_length = math.sqrt(hypotenuse**2 - opposite**2) return f\\"Adjacent = {round(adjacent_length, 2)}\\" elif isinstance(hypotenuse, str): if isinstance(opposite, int) and isinstance(adjacent, int): hypotenuse_length = math.sqrt(opposite**2 + adjacent**2) return f\\"Hypotenuse = {round(hypotenuse_length, 2)}\\" else: if isinstance(opposite, int) and isinstance(adjacent, int) and isinstance(hypotenuse, int): return \\"You already know the answer!\\" raise ValueError(\\"Invalid arguments: Unable to calculate the unknown side.\\")"},{"question":"# Question: You are given the task to implement a function that requires efficient power computation under modulus. Develop a function that computes `(base^exponent) % mod` using the modular exponential algorithm. Input: - An integer `base` (`1 ≤ base ≤ 10^9`). - An integer `exponent` (`0 ≤ exponent ≤ 10^9`). - An integer `mod` (`2 ≤ mod ≤ 10^9`). Output: - Return an integer which is `(base^exponent) % mod`. Constraints: - Ensure that the function handles very large input values efficiently. - Should raise a `ValueError` if `exponent` is negative. Example: ```python modular_exponential(2, 10, 1000) # returns 24 modular_exponential(7, 2, 13) # returns 10 modular_exponential(0, 0, 1) # returns 1 ``` Notes: - You can\'t use the built-in `pow` function for this implementation. - Make sure to consider edge cases like `exponent` being 0 which should return 1.","solution":"def modular_exponential(base, exponent, mod): Computes (base^exponent) % mod using the modular exponentiation algorithm. Args: - base (int): The base of the exponentiation (1 ≤ base ≤ 10^9) - exponent (int): The exponent (0 ≤ exponent ≤ 10^9) - mod (int): The modulus value (2 ≤ mod ≤ 10^9) Returns: - int: The result of (base^exponent) % mod Raises: - ValueError: If the exponent is negative. if exponent < 0: raise ValueError(\\"Exponent cannot be negative\\") result = 1 base = base % mod while exponent > 0: if (exponent % 2) == 1: # If exponent is odd, multiply base with result result = (result * base) % mod exponent = exponent >> 1 # Divide the exponent by 2 base = (base * base) % mod # Square the base return result"},{"question":"Suppose you are a software engineer at a company that stores and analyzes large sets of sensor data collected in real-time. To facilitate efficient querying and updating of cumulative frequency data, you are asked to implement a Fenwick Tree. **Task**: Write a Python class `FenwickTree` that supports the following operations: 1. Initializing the tree with a given list of integer frequencies. 2. Querying the sum of the first `i` elements of the frequency list. 3. Updating the frequency of a specified element in the list. **Class Signature**: ```python class FenwickTree: def __init__(self, freq: List[int]): pass def get_sum(self, i: int) -> int: pass def update(self, i: int, value: int) -> None: pass ``` **Constraints**: * `0 <= i < len(freq)` * The initial frequencies are integers. * The input list size `n` is such that `1 <= n <= 10^5`. * The frequencies are non-negative integers. **Example**: ```python # Example usage freq = [1, 2, 3, 4, 5] ft = FenwickTree(freq) print(ft.get_sum(3)) # Output: 10 (1 + 2 + 3 + 4) ft.update(2, 6) # Update index 2 to value 6 print(ft.get_sum(3)) # Output: 13 (1 + 2 + 6 + 4) ``` **Hints**: 1. When updating the tree, remember to adjust all affected nodes in the tree. 2. Ensure you handle the transition from zero-based to one-based indexing properly. 3. Make sure to carefully manage the list boundaries during updates and queries to avoid index errors.","solution":"class FenwickTree: def __init__(self, freq): Initialize the Fenwick Tree with the given list of frequencies. self.n = len(freq) self.tree = [0] * (self.n + 1) for i in range(self.n): self.update(i, freq[i]) def get_sum(self, i): Query the sum of the first i+1 elements (0 to i) of the frequency list. sum_val = 0 i += 1 # Convert to 1-based index while i > 0: sum_val += self.tree[i] i -= i & (-i) return sum_val def update(self, i, value): Update the frequency of the element at index i. diff = value - self._get_frequency(i) i += 1 # Convert to 1-based index while i <= self.n: self.tree[i] += diff i += i & (-i) def _get_frequency(self, i): Get the current value at index i. (Helper function) sum_val = self.get_sum(i) if i > 0: sum_val -= self.get_sum(i - 1) return sum_val"},{"question":"**Scenario**: You are given the task of implementing a function to detect the presence of a specific substring within a larger string, commonly used in text processing systems such as search engines and text editors. Your implementation should efficiently determine the position of the first occurrence of the given substring (needle) in the larger string (haystack). **Function to Implement**: Write a function `find_substring` that takes two parameters, `haystack` and `needle`, both of which are non-empty strings, and returns the index of the first occurrence of `needle` in `haystack`. If `needle` is not present in `haystack`, return -1. **Function signature**: `def find_substring(haystack: str, needle: str) -> int:` # Expected Input and Output Formats * **Input**: - `haystack`: A non-empty string (1 ≤ len(haystack) ≤ 10⁴). - `needle`: A non-empty string (1 ≤ len(needle) ≤ 10³). * **Output**: - An integer representing the starting index of the first occurrence of needle in haystack, or -1 if the needle is not in the haystack. # Constraints and Limitations - The function should handle cases where the needle is equal to or longer than the haystack. - You cannot use built-in string matching/substring methods. - Aim for readability and maintainability above micro-optimizations at this stage. # Performance Requirements Though a straightforward implementation of the brute force approach is acceptable, adept students should consider optimizing their approach to improve performance, especially for larger strings. **Example**: ```python assert find_substring(\\"hello\\", \\"ll\\") == 2 assert find_substring(\\"aaaaa\\", \\"bba\\") == -1 assert find_substring(\\"abcdef\\", \\"def\\") == 3 assert find_substring(\\"abcdef\\", \\"gh\\") == -1 ``` **Notes**: - Consider edge cases and scenarios such as empty needle or haystack, and what should the correct behavior be in these instances. - Explain the thought process and decisions regarding algorithm choice and potential optimizations.","solution":"def find_substring(haystack: str, needle: str) -> int: Returns the index of the first occurrence of `needle` in `haystack`, or -1 if `needle` is not found. len_h = len(haystack) len_n = len(needle) if len_n == 0: return 0 for i in range(len_h - len_n + 1): if haystack[i:i + len_n] == needle: return i return -1"},{"question":"# Segment Tree Implementations - Range Sum Query and Point Update You are given a segment tree implementation that can handle range queries and point updates efficiently using a commutative function. Your task is to implement and validate a segment tree for the following scenario: **Scenario**: Given an array of integers, implement a segment tree that supports the following operations: 1. `update(index, value)`: Update the element at the specified index with the given value. 2. `query(left, right)`: Calculate the sum of elements in the subarray from `left` to `right` (inclusive). **Function Specifications**: 1. **Initialize the Segment Tree**: ```python class SegmentTree: def __init__(self, arr: List[int]): # Implementation here ``` 2. **Build Tree**: ```python def build_tree(self): # Implementation here ``` 3. **Update**: ```python def update(self, index: int, value: int): # Implementation here ``` 4. **Query**: ```python def query(self, left: int, right: int) -> int: # Implementation here ``` **Input and Output**: - The class will be initialized with a list of integers, `arr`. - The `update` method will take two parameters: `index` (0-based) and `value` (integer). - The `query` method will return the sum of the elements in the range `[left, right]` inclusive, where `left` and `right` are 0-based indices. **Constraints**: - Array size, N: (1 leq N leq 10^5) - Element value, arr[i]: (-10^4 leq arr[i] leq 10^4) - Number of operations, Q: (1 leq Q leq 10^5) **Example**: ```python # Example initialization and operations arr = [2, 4, 5, 3, 4] segment_tree = SegmentTree(arr) # Query the sum from index 2 to 4 print(segment_tree.query(2, 4)) # Output: 12 # Update the element at index 3 to 6 segment_tree.update(3, 6) # Query the sum from index 0 to 3 print(segment_tree.query(0, 3)) # Output: 17 ``` **Ensure your implementation handles large inputs efficiently and correctly. Pay attention to the edge cases such as single-element queries and updates, and full range queries.**","solution":"class SegmentTree: def __init__(self, arr): self.n = len(arr) self.tree = [0] * (2 * self.n) self.build_tree(arr) def build_tree(self, arr): # Initialize leaves in the tree for i in range(self.n): self.tree[self.n + i] = arr[i] # Build the segment tree by calculating parents for i in range(self.n - 1, 0, -1): self.tree[i] = self.tree[i << 1] + self.tree[i << 1 | 1] def update(self, index, value): # Update the tree at the leaf node pos = index + self.n self.tree[pos] = value # Update the rest of the segment tree while pos > 1: pos >>= 1 self.tree[pos] = self.tree[pos << 1] + self.tree[pos << 1 | 1] def query(self, left, right): res = 0 left += self.n right += self.n + 1 while left < right: if left & 1: res += self.tree[left] left += 1 if right & 1: right -= 1 res += self.tree[right] left >>= 1 right >>= 1 return res"},{"question":"--- Problem Statement: You are tasked with implementing a more efficient version of a common searching algorithm, Ternary Search, to solve a problem of finding elements in a large sorted dataset. Given an array sorted in ascending order and a value `key`, write a function that performs ternary search to find the index of the `key` in the array. Function Signature: ```python def ternary_search_iterative(arr, key) -> int: Perform an iterative ternary search on a sorted array. Parameters: arr (List[int]): A list of integers sorted in ascending order. key (int): The value to search for in the list. Returns: int: The index of the key in the list if found, otherwise -1. pass ``` Input Format: * The input will be a list of integers `arr` sorted in ascending order. * An integer `key`. Output Format: * An integer representing the index of the `key` in the array. * Return `-1` if the `key` is not found in the array. Constraints: * The array `arr` will have at least one element and up to (10^6) elements. * The elements in `arr` and `key` will be within the range [-10^9, 10^9]. Example: ```python # Example 1: assert ternary_search_iterative([1, 2, 3, 4, 5, 6, 7, 8, 9], 5) == 4 # Example 2: assert ternary_search_iterative([1, 2, 3, 4, 5, 6, 7, 8, 9], 10) == -1 # Example 3: assert ternary_search_iterative([2], 2) == 0 # Example 4: assert ternary_search_iterative([], 3) == -1 ``` Performance Requirements: * The solution should have a time complexity of O(log3(N)), ensuring that the search is efficient for large arrays. * The solution should use constant space O(1), without utilizing any additional data structures. Scenario: You are working on a search engine that frequently queries through a large, sorted dataset of unique IDs. Implementing an efficient search technique will significantly enhance the performance of the query operations, ensuring a lightning-fast response time for millions of ID lookups.","solution":"def ternary_search_iterative(arr, key) -> int: Perform an iterative ternary search on a sorted array. Parameters: arr (List[int]): A list of integers sorted in ascending order. key (int): The value to search for in the list. Returns: int: The index of the key in the list if found, otherwise -1. left, right = 0, len(arr) - 1 while left <= right: partition1 = left + (right - left) // 3 partition2 = right - (right - left) // 3 if arr[partition1] == key: return partition1 elif arr[partition2] == key: return partition2 if key < arr[partition1]: right = partition1 - 1 elif key > arr[partition2]: left = partition2 + 1 else: left = partition1 + 1 right = partition2 - 1 return -1"},{"question":"# Coding Challenge: Find the nth Digit Given a sequence of integers concatenated together, create a function to find the nth digit within this infinite sequence. For example, the sequence starts as \\"123456789101112131415...\\". **Function Signature**: ```python def find_nth_digit(n: int) -> int: ``` **Input**: * An integer `n` (1 ≤ n ≤ 10^9). This represents the position of the digit in the infinite sequence. **Output**: * Return the digit (0-9) which is at the nth position in the sequence. **Constraints**: * The input will always be a positive integer. * Optimization is crucial due to the large possible input size (up to 1 billion). # Examples 1. Input: `n = 3` Output: `3` 2. Input: `n = 11` Output: `0` (the sequence is \\"12345678910\\") 3. Input: `n = 15` Output: `2` (the sequence is \\"12345678910111213\\") # Additional Considerations 1. **Edge Case Handling**: * When `n` is very small (like 1 or 2). * When `n` is just past the transitions between digit lengths, e.g., 9 to 10 or 99 to 100. 2. **Performance Requirements**: The function should complete efficiently within the time limits even for the largest inputs. 3. **Error Handling**: Ensure integer operations avoid off-by-one errors and handle large number arithmetic precisely. Make sure you handle the given constraints and edge cases effectively.","solution":"def find_nth_digit(n: int) -> int: Finds the nth digit in the infinite sequence of concatenated integers. # Starting count by the number of digits digit_count = 1 # Boundaries for the range of numbers with the same digit count current_range_start = 1 while True: # Calculate the number of digits contributed by current digit_count range numbers_in_range = 9 * current_range_start range_digit_contribution = numbers_in_range * digit_count if n <= range_digit_contribution: # We found the range where the nth digit falls break # Move to the next digit range n -= range_digit_contribution digit_count += 1 current_range_start *= 10 # Calculate the exact number and the digit within that number target_number_index = (n - 1) // digit_count digit_index_inside_number = (n - 1) % digit_count target_number = current_range_start + target_number_index return int(str(target_number)[digit_index_inside_number])"},{"question":"# Coding Challenge: Base Conversion Algorithm **Objective**: Implement robust algorithms for converting integers to their base-n string representation and vice-versa. # Problem Statement Given two functions `int_to_base(num, base)` and `base_to_int(str_to_convert, base)`, implement the following: 1. **int_to_base(num, base)**: - Convert an integer `num` to its string representation in a specified base between 2 and 36. - If the number is negative, the result should start with a `-` sign. 2. **base_to_int(str_to_convert, base)**: - Convert a string `str_to_convert` which represents a number in the specified base back to an integer. Constraints - `-10^9 <= num <= 10^9` - `2 <= base <= 36` - `str_to_convert` is a valid number in the given base. # Function Signatures: ```python def int_to_base(num, base): # Your code here def base_to_int(str_to_convert, base): # Your code here ``` # Input and Output Format **int_to_base(num, base)**: - **Input**: - `num`: an integer which can be negative. - `base`: an integer between 2 and 36. - **Output**: - A string representing the base-n representation of the given integer. **base_to_int(str_to_convert, base)**: - **Input**: - `str_to_convert`: a string representing the number in the specified base. - `base`: an integer between 2 and 36. - **Output**: - An integer which is the decimal equivalent of the string representation. # Examples - **int_to_base** ```python int_to_base(5, 2) # \\"101\\" int_to_base(-12, 16) # \\"-C\\" int_to_base(255, 16) # \\"FF\\" ``` - **base_to_int** ```python base_to_int(\\"101\\", 2) # 5 base_to_int(\\"-C\\", 16) # -12 base_to_int(\\"FF\\", 16) # 255 ``` # Notes - Ensure your function correctly handles different case scenarios and edge cases as well. - Be mindful of potential errors with invalid input and handle them appropriately.","solution":"def int_to_base(num, base): if base < 2 or base > 36: raise ValueError(\\"Base must be between 2 and 36\\") if num == 0: return \'0\' digits = \\"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\\" is_negative = num < 0 num = abs(num) result = [] while num: result.append(digits[num % base]) num //= base if is_negative: result.append(\'-\') return \'\'.join(reversed(result)) def base_to_int(str_to_convert, base): if base < 2 or base > 36: raise ValueError(\\"Base must be between 2 and 36\\") str_to_convert = str_to_convert.strip().upper() if not str_to_convert: raise ValueError(\\"Input string cannot be empty\\") digits = \\"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\\" is_negative = str_to_convert[0] == \'-\' if is_negative: str_to_convert = str_to_convert[1:] num = 0 for char in str_to_convert: if char not in digits[:base]: raise ValueError(f\\"Invalid character {char} for base {base}\\") num = num * base + digits.index(char) return -num if is_negative else num"},{"question":"# Strongly Connected Components Detector Problem Statement Given a directed graph, determine if it is strongly connected. A graph is strongly connected if there is a path between any pair of vertices. Implement the function `is_strongly_connected` that takes an integer `vertex_count` and a list of tuples `edges` where each tuple represents a directed edge `(source, target)` in the graph, and returns `True` if the graph is strongly connected, otherwise `False`. Input - `vertex_count`: An integer `V` (2 ≤ V ≤ 10^5) representing the number of vertices in the graph. - `edges`: A list of tuples where each tuple contains two integers `(u, v)` representing a directed edge from vertex `u` to vertex `v`. Output - Return `True` if the graph is strongly connected, otherwise return `False`. Constraints - The graph does not have parallel edges or self-loops. - Performance should be efficient with respect to both time and space complexity. Example ```python # Example 1 vertex_count = 5 edges = [(0, 1), (1, 2), (2, 3), (3, 4), (4, 0), (1, 3)] print(is_strongly_connected(vertex_count, edges)) # Output: True # Example 2 vertex_count = 4 edges = [(0, 1), (1, 2), (2, 3)] print(is_strongly_connected(vertex_count, edges)) # Output: False ``` Implementation You must write the `is_strongly_connected` function. ```python def is_strongly_connected(vertex_count, edges): # Your code here ```","solution":"def is_strongly_connected(vertex_count, edges): from collections import defaultdict, deque def bfs(start, graph): visited = set() queue = deque([start]) while queue: vertex = queue.popleft() if vertex not in visited: visited.add(vertex) queue.extend(graph[vertex] - visited) return visited # Create adjacency list for the original graph and its transpose graph = defaultdict(set) transpose_graph = defaultdict(set) for u, v in edges: graph[u].add(v) transpose_graph[v].add(u) # Check reachability from the first node start_node = 0 if len(bfs(start_node, graph)) != vertex_count: return False # Check reachability in the transpose graph if len(bfs(start_node, transpose_graph)) != vertex_count: return False return True"},{"question":"# Word Segmentation Challenge **Objective:** Implement a function `word_break` that determines if a given word can be segmented into a sequence of one or more dictionary words. **Function Signature:** ```python def word_break(word: str, word_dict: Set[str]) -> bool: ``` **Input:** * `word` (str): A non-empty string that contains alphanumeric characters. * `word_dict` (Set[str]): A set of non-empty words assumed to contain no duplicates. **Output:** * Return `True` if the word can be segmented into one or more dictionary words. * Return `False` otherwise. **Constraints:** * The length of the word should not exceed 300 characters. * Dictionary words are non-empty and consist of lowercase English letters only. * Performance requirements must be considered: aim for a solution with O(N^2) time complexity and O(N) space complexity. **Instructions:** 1. Implement the function `word_break` based on the requirements. 2. Ensure to handle edge cases such as empty string or no matching dictionary words. 3. Optimize your solution for performance and memory usage. **Example:** ```python word = \\"leetcode\\" word_dict = {\\"leet\\", \\"code\\"} print(word_break(word, word_dict)) # Output: True word = \\"applepenapple\\" word_dict = {\\"apple\\", \\"pen\\"} print(word_break(word, word_dict)) # Output: True word = \\"catsandog\\" word_dict = {\\"cats\\", \\"dog\\", \\"sand\\", \\"and\\", \\"cat\\"} print(word_break(word, word_dict)) # Output: False ```","solution":"def word_break(word: str, word_dict: set) -> bool: dp = [False] * (len(word) + 1) dp[0] = True for i in range(1, len(word) + 1): for j in range(i): if dp[j] and word[j:i] in word_dict: dp[i] = True break return dp[len(word)]"},{"question":"# Scenario You are developing a text processing tool and one of the requirements is to simplify strings by removing duplicate characters while maintaining the original order. Your task is to implement a function that processes the strings as per the requirement. # Task Write a Python function `unique_characters(s: str) -> str` that takes a string `s` and returns a new string with all duplicate characters removed, while preserving the original order of their first appearance. # Input * A single string `s` with a length between 0 and 10^6. * The string can contain any printable ASCII characters. # Output * A string with duplicates removed, keeping only the first occurrence of each character in the initial order. # Constraints * You should ensure that the solution has a time complexity of O(n) and a space complexity of O(n), where n is the length of the input string. # Edge Cases * Handling of an empty string should return an empty string. * Strings containing mixed characters, different cases, and all identical characters should be properly processed. # Example ```python assert unique_characters(\\"google\\") == \\"gole\\" assert unique_characters(\\"programming\\") == \\"progamin\\" assert unique_characters(\\"AaAaBbBb\\") == \\"AaBb\\" assert unique_characters(\\"\\") == \\"\\" ```","solution":"def unique_characters(s: str) -> str: Removes duplicate characters from the string while maintaining the original order. seen = set() result = [] for char in s: if char not in seen: seen.add(char) result.append(char) return \'\'.join(result)"},{"question":"# Scenario You have been tasked to develop a more advanced hash table that not only stores key-value pairs but also supports dynamic resizing based on user-defined load factor thresholds. This will ensure efficient key distribution and load management by balancing between space and performance efficiently. # Problem Statement Implement a dynamically resizable hash table using quadratic probing for collision resolution and provide user-defined load factor thresholds for resizing. Ensure your hash table supports all the basic operations (`put`, `get`, `delete`) efficiently, manages dynamic resizing properly, and handles edge cases effectively. # Function Implementations * Implement the `put(key, value)` method to insert a key-value pair into the hash table using quadratic probing. * Implement the `get(key)` method to retrieve the value associated with a given key. * Implement the `del_(key)` method to remove the key-value pair associated with a given key. * Implement the `__resize()` method to handle resizing. * Implement proper collision handling using quadratic probing when inserting keys. # Inputs and Outputs * **Input**: * `put(key, value)`: integer or string `key`, `value` to be inserted. * `get(key)`: integer or string `key` to lookup. * `del_(key)`: integer or string `key` to delete. * **Output**: * `put(key, value)`: None, but modifies hash table. * `get(key)`: Returns the value associated with the key or None if key does not exist. * `del_(key)`: Returns None, but modifies hash table by deleting the key-value pair. # Constraints * Use quadratic probing for handling collisions. * The size of the hash table should dynamically resize to maintain efficient load factors. * Ensure linear time complexity for resizing operations. * Handle keys of both integer and string types. * Avoid excessive memory usage by managing load factor thresholds effectively. # Example ```python # Initialize hash table with load factor threshold of 0.5 and initial size 8. hash_table = AdvancedHashTable(load_factor=0.5, initial_size=8) # Insert some key-value pairs hash_table.put(1, \'one\') hash_table.put(2, \'two\') hash_table.put(\'three\', 3) # Retrieve values assert hash_table.get(1) == \'one\' assert hash_table.get(2) == \'two\' assert hash_table.get(\'three\') == 3 # Delete a key hash_table.del_(1) assert hash_table.get(1) == None ``` # Notes * Ensure the hash table maintains good performance even when load factors approach the threshold. * Implement error handling to manage improper key types or edge cases effectively.","solution":"class AdvancedHashTable: def __init__(self, load_factor=0.75, initial_size=8): self.load_factor = load_factor self.capacity = initial_size self.size = 0 self.table = [None] * self.capacity def _hash(self, key, i): h1 = hash(key) % self.capacity h2 = (1 + hash(key) % (self.capacity - 1)) return (h1 + i * i * h2) % self.capacity def _resize(self): old_table = self.table self.capacity *= 2 self.table = [None] * self.capacity self.size = 0 for entry in old_table: if entry and entry[0] is not None: self.put(entry[0], entry[1]) def put(self, key, value): if self.size + 1 > self.capacity * self.load_factor: self._resize() i = 0 while True: idx = self._hash(key, i) if not self.table[idx] or self.table[idx][0] == key: self.table[idx] = (key, value) self.size += 1 return i += 1 def get(self, key): i = 0 while True: idx = self._hash(key, i) if not self.table[idx]: return None elif self.table[idx][0] == key: return self.table[idx][1] i += 1 def del_(self, key): i = 0 while True: idx = self._hash(key, i) if not self.table[idx]: return elif self.table[idx][0] == key: self.table[idx] = (None, None) self.size -= 1 return i += 1"},{"question":"# Cocktail Shaker Sort Implementation and Optimization You have been provided with a sorting algorithm known as Cocktail Shaker Sort. It\'s designed to bidirectionally traverse and sort the list by swapping adjacent elements if they are in the wrong order. While it has its uses, its performance is not ideal for large datasets. Task You are required to perform the following: 1. Implement the Cocktail Shaker Sort algorithm in a function `cocktail_shaker_sort(arr)` as given in the snippet. 2. Write a new function `optimized_cocktail_sort(arr)` that enhances the original Cocktail Shaker Sort, focusing on improving its performance or adapting its behavior for efficiency. # Function Signature ```python def cocktail_shaker_sort(arr: List[int]) -> List[int]: # Your code here def optimized_cocktail_sort(arr: List[int]) -> List[int]: # Your code here ``` # Input and Output Format - Input: A list of integers (`arr`) where 1 <= len(arr) <= 10^4 and elements are integers within the range -10^9 to 10^9. - Output: A list of integers sorted in non-decreasing order. Constraints - Optimize the sorting for partially sorted or small arrays, but ensure the function can handle any input within the given range efficiently. - Maintain the stability of the sorting algorithm. # Examples Example 1 ```python arr = [5, 2, 9, 1, 5, 6] print(optimized_cocktail_sort(arr)) # Output: [1, 2, 5, 5, 6, 9] ``` Example 2 ```python arr = [3, 0, -2, -1, 2] print(optimized_cocktail_sort(arr)) # Output: [-2, -1, 0, 2, 3] ``` Example 3 ```python arr = [1, 2, 3, 4, 5] print(optimized_cocktail_sort(arr)) # Output: [1, 2, 3, 4, 5] ``` # Guidelines - Ensure that your solution passes all edge cases and is optimized for both partially sorted arrays as well as random arrays within the constraints. - Your optimized solution should demonstrate a clear improvement over the naive implementation in terms of time complexity or practical runtime performance.","solution":"from typing import List def cocktail_shaker_sort(arr: List[int]) -> List[int]: Perform the cocktail shaker sort on the given list. n = len(arr) is_sorted = False start = 0 end = n - 1 while not is_sorted: is_sorted = True for i in range(start, end): if arr[i] > arr[i + 1]: arr[i], arr[i + 1] = arr[i + 1], arr[i] is_sorted = False if is_sorted: break is_sorted = True end -= 1 for i in range(end, start, -1): if arr[i] < arr[i - 1]: arr[i], arr[i - 1] = arr[i - 1], arr[i] is_sorted = False start += 1 return arr def optimized_cocktail_sort(arr: List[int]) -> List[int]: Perform the optimized cocktail shaker sort on the given list. This version improves performance by tracking the last swapped positions. n = len(arr) start = 0 end = n - 1 while start < end: new_end = start for i in range(start, end): if arr[i] > arr[i + 1]: arr[i], arr[i + 1] = arr[i + 1], arr[i] new_end = i end = new_end if start >= end: break new_start = end for i in range(end, start, -1): if arr[i] < arr[i - 1]: arr[i], arr[i - 1] = arr[i - 1], arr[i] new_start = i start = new_start return arr"},{"question":"# Binary Tree to Doubly Linked List Transformation Context You are given a binary tree and you need to transform it into a doubly linked list. The goal is to achieve an in-order traversal sequence in the linked list. Task Implement a function `convert_to_doubly_linked_list` that takes the root of a binary tree and returns the head of the doubly linked list. Function Signature ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right class DoublyListNode: def __init__(self, val=0, prev=None, next=None): self.val = val self.prev = prev self.next = next def convert_to_doubly_linked_list(root: TreeNode) -> DoublyListNode: pass ``` Input - `root`: The root node of the binary tree (of type `TreeNode`). Output - The head node of the resulting doubly linked list (of type `DoublyListNode`). Constraints 1. Implement the conversion using recursion. 2. Ensure the doubly linked list has no cycles. 3. Preserve the in-order traversal order in the linked list. Performance Requirements - Time Complexity: O(n), where n is the number of nodes in the binary tree. - Space Complexity: O(h), due to the recursion call stack, where h is the height of the tree. Examples 1. Example 1: - Input: `root = TreeNode(4, TreeNode(2, TreeNode(1), TreeNode(3)), TreeNode(5))` - Output: 1 <-> 2 <-> 3 <-> 4 <-> 5 2. Example 2: - Input: `root = None` - Output: `None` 3. Example 3: - Input: `root = TreeNode(1)` - Output: 1 Note You may assume that each node contains a unique integer value.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right class DoublyListNode: def __init__(self, val=0, prev=None, next=None): self.val = val self.prev = prev self.next = next def convert_to_doubly_linked_list(root: TreeNode) -> DoublyListNode: if not root: return None def inorder_traversal(node): nonlocal prev, head if not node: return inorder_traversal(node.left) new_node = DoublyListNode(node.val) if prev: prev.next = new_node new_node.prev = prev else: head = new_node prev = new_node inorder_traversal(node.right) head = None prev = None inorder_traversal(root) return head"},{"question":"You are tasked with implementing a function to process a string by removing duplicate characters, keeping only the first occurrence of each character. Your solution should maintain the order of characters as they first appear in the input string. Function Signature ```python def deduplicate_string(input: str) -> str: pass ``` Input - `input`: A string `s` containing lowercase English letters. `1 <= len(s) <= 10^5`. Output - A new string `result` which has all recurring characters removed, preserving the order of their first occurrence. # Constraints - You should aim for a linear time complexity O(n). - The additional space complexity should be within reasonable bounds (consider using sets or dictionaries). # Scenario/Context Imagine you are developing a feature for a social media platform where users can enter tags. To ensure each tag is processed only once while maintaining the initial order, you need to implement a function that deduplicates the tags. # Example Example 1 Input: ``` \\"abbcad\\" ``` Output: ``` \\"abcd\\" ``` Example 2 Input: ``` \\"google\\" ``` Output: ``` \\"gole\\" ``` # Edge Cases to Consider 1. Empty string input: - Input: `\\"\\"` - Output: `\\"\\"` 2. String with all unique characters: - Input: `\\"abcdef\\"` - Output: `\\"abcdef\\"` 3. String with all duplicates: - Input: `\\"aaaaaa\\"` - Output: `\\"a\\"` # Notes - Ensure your function runs efficiently with a time complexity of O(n). - Remember to handle different edge cases appropriately.","solution":"def deduplicate_string(input: str) -> str: Function to remove duplicate characters, keeping only the first occurrence of each character. seen = set() result = [] for char in input: if char not in seen: seen.add(char) result.append(char) return \'\'.join(result)"},{"question":"You are provided with the implementation of preorder traversal for binary trees, both iteratively and recursively. Your task is to extend this functionality to include the Inorder and Postorder traversals for a binary tree. # Objectives 1. Implement the iterative version of the Inorder and Postorder traversals. 2. Implement the recursive version of the Inorder and Postorder traversals. # Input - A binary tree defined by a Node class where each node contains: - `val`: The value of the node. - `left`: A reference to the left child node (or None). - `right`: A reference to the right child node (or None). # Output - A list of node values representing the order of traversal. # Constraints - You may assume that the tree contains at most 10^4 nodes. - Node values are distinct. # Definitions - **Inorder Traversal**: Traverse the left subtree first, then visit the root node, and finally traverse the right subtree. - **Postorder Traversal**: Traverse the left subtree first, then traverse the right subtree, and finally visit the root node. # Function Signatures ```python def inorder_iter(root: Node) -> List[int]: pass def inorder_rec(root: Node) -> List[int]: pass def postorder_iter(root: Node) -> List[int]: pass def postorder_rec(root: Node) -> List[int]: pass ``` # Example Given the tree: ``` 1 / 2 3 / 4 5 ``` - Inorder Iterative: `[4, 2, 5, 1, 3]` - Inorder Recursive: `[4, 2, 5, 1, 3]` - Postorder Iterative: `[4, 5, 2, 3, 1]` - Postorder Recursive: `[4, 5, 2, 3, 1]` # Requirements - Ensure your implementation efficiently handles trees with up to 10^4 nodes. - Consider handling edge cases like a single node or completely unbalanced trees.","solution":"from typing import List class Node: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def inorder_iter(root: Node) -> List[int]: result, stack = [], [] current = root while current or stack: while current: stack.append(current) current = current.left current = stack.pop() result.append(current.val) current = current.right return result def inorder_rec(root: Node) -> List[int]: result = [] def traverse(node): if node: traverse(node.left) result.append(node.val) traverse(node.right) traverse(root) return result def postorder_iter(root: Node) -> List[int]: result, stack = [], [root] while stack: node = stack.pop() if node: result.insert(0, node.val) stack.append(node.left) stack.append(node.right) return result def postorder_rec(root: Node) -> List[int]: result = [] def traverse(node): if node: traverse(node.left) traverse(node.right) result.append(node.val) traverse(root) return result"},{"question":"# Cycle Detection in a Directed Graph You are given a directed graph as an adjacency list. Your task is to implement a function that detects if there is a cycle in the graph using depth-first search (DFS). **Function Signature**: ```python def contains_cycle(graph: Dict[str, List[str]]) -> bool: pass ``` # Input - `graph`: A dictionary where the keys represent vertices, and the values are lists representing the directed edges from the key vertex to other vertices. # Output - Returns a boolean: * `True` if the graph contains a cycle. * `False` otherwise. # Constraints - The graph can contain up to 1000 vertices. - Each vertex is represented as a string. - The graph may be disconnected. # Scenario You are tasked with implementing a cycle detection system for a task scheduling application. Given graph data representing task dependencies, determine if there is a circular dependency among the tasks. # Example ```python graph = { \'A\': [\'B\', \'C\'], \'B\': [\'D\'], \'C\': [\'F\'], \'D\': [\'E\', \'F\'], \'E\': [\'B\'], \'F\': [] } print(contains_cycle(graph)) # Output: True ``` # Guidelines - Implement the `contains_cycle(graph: Dict[str, List[str]]) -> bool` function, adhering to the depth-first search approach. - Manage traversal states using an appropriate data structure. - Consider edge cases such as isolated vertices and self-loops. - Ensure your solution handles graphs with up to 1000 vertices efficiently.","solution":"def contains_cycle(graph): Detects if there is a cycle in the directed graph using DFS approach. Args: graph (dict): A dictionary where keys are vertices and values are lists representing the directed edges from the key vertex to other vertices. Returns: bool: True if the graph contains a cycle, False otherwise def dfs(vertex, visited, rec_stack): visited.add(vertex) rec_stack.add(vertex) for neighbor in graph.get(vertex, []): if neighbor not in visited: if dfs(neighbor, visited, rec_stack): return True elif neighbor in rec_stack: return True rec_stack.remove(vertex) return False visited = set() rec_stack = set() for vertex in graph: if vertex not in visited: if dfs(vertex, visited, rec_stack): return True return False"},{"question":"**Description**: Write a class `HuffmanCodingUtility` to implement a simplified version of the Huffman Coding compression algorithm. This class will provide methods for encoding and decoding strings. **Objective**: The goal is to demonstrate your understanding of how Huffman coding works, including building the Huffman Tree, generating Huffman codes, and performing encoding and decoding. # Function Specifications 1. **build_huffman_tree(self, text: str) -> Node**: - **Description**: Builds the Huffman Tree using the character frequencies from the input text. - **Input**: `text (str)` - The input string. - **Output**: The root node of the Huffman Tree. 2. **generate_codes(self, root: Node) -> dict**: - **Description**: Generates the Huffman codes by traversing the Huffman Tree. - **Input**: `root (Node)` - The root node of the Huffman Tree. - **Output**: A dictionary mapping characters to their corresponding Huffman codes. 3. **encode(self, text: str) -> str**: - **Description**: Encodes the input text using the generated Huffman codes. - **Input**: `text (str)` - The input string. - **Output**: The encoded string representation of the input text. 4. **decode(self, encoded_text: str, root: Node) -> str**: - **Description**: Decodes the encoded string back to the original text using the Huffman Tree. - **Input**: `encoded_text (str)` - The encoded string. `root (Node)` - The root node of the Huffman Tree used for decoding. - **Output**: The original decoded string. # Example Usage: ```python utility = HuffmanCodingUtility() text = \\"example text for huffman coding\\" root = utility.build_huffman_tree(text) codes = utility.generate_codes(root) encoded_text = utility.encode(text) decoded_text = utility.decode(encoded_text, root) print(\\"Original Text:\\", text) print(\\"Encoded Text:\\", encoded_text) print(\\"Decoded Text:\\", decoded_text) ``` # Constraints: * Assume all input characters are ASCII characters. * The maximum length of the input string is (10^5). # Performance Requirement: * Your solution should efficiently handle strings up to the maximum length within reasonable time and space constraints.","solution":"import heapq from collections import defaultdict class Node: def __init__(self, char, freq): self.char = char self.freq = freq self.left = None self.right = None def __lt__(self, other): return self.freq < other.freq class HuffmanCodingUtility: def build_huffman_tree(self, text: str) -> Node: if not text: return None # Calculate frequency of each character freq = defaultdict(int) for char in text: freq[char] += 1 # Create a priority queue with the frequencies heap = [Node(char, fr) for char, fr in freq.items()] heapq.heapify(heap) while len(heap) > 1: node1 = heapq.heappop(heap) node2 = heapq.heappop(heap) merged = Node(None, node1.freq + node2.freq) merged.left = node1 merged.right = node2 heapq.heappush(heap, merged) return heap[0] def generate_codes(self, root: Node) -> dict: def _generate_codes_helper(node, current_code): if node is None: return if node.char is not None: codes[node.char] = current_code return _generate_codes_helper(node.left, current_code + \\"0\\") _generate_codes_helper(node.right, current_code + \\"1\\") codes = {} _generate_codes_helper(root, \\"\\") return codes def encode(self, text: str) -> str: if not text: return \\"\\" root = self.build_huffman_tree(text) codes = self.generate_codes(root) encoded_text = \\"\\".join(codes[char] for char in text) self.root = root return encoded_text def decode(self, encoded_text: str) -> str: if not encoded_text: return \\"\\" decoded_text = [] current_node = self.root for bit in encoded_text: if bit == \'0\': current_node = current_node.left else: current_node = current_node.right if current_node.char is not None: decoded_text.append(current_node.char) current_node = self.root return \\"\\".join(decoded_text)"},{"question":"# Question: Implement and Analyze a Randomized Set Context You are working on a project that requires frequent insertions and deletions of elements from a set, and you also need to retrieve a random element from the set efficiently. You need to design a data structure that supports these operations in average O(1) time complexity. Requirements Implement a class `RandomizedSet` with the following methods: - `insert(val: int) -> bool`: Inserts a value. Returns `True` if the element was successfully added, otherwise `False`. - `remove(val: int) -> bool`: Removes a value. Returns `True` if the element was successfully removed, otherwise `False`. - `random_element() -> int`: Returns a random element from the current set of elements. Each element should have the same probability of being returned. Constraints * Elements within the set are unique. * The `random_element` method should be operable even if the set contains only one element, but should handle the empty set scenario appropriately by raising an exception or similar behavior. Input/Output Assume you have the following operations to perform on the `RandomizedSet`: ```python # Initialize a new RandomizedSet rset = RandomizedSet() # Insert elements print(rset.insert(1)) # Output: True print(rset.insert(2)) # Output: True print(rset.insert(1)) # Output: False # Remove elements print(rset.remove(1)) # Output: True print(rset.remove(1)) # Output: False # Retrieve a random element print(rset.random_element()) # Output can vary: 2 or any from current set elements ``` Task 1. Implement the `RandomizedSet` class with the described methods. 2. Ensure the operations are performed in average O(1) time complexity. 3. Handle edge cases appropriately (e.g., inserting duplicates, removing non-existent elements, retrieving from an empty set). Example Here is how the `RandomizedSet` might be used: ```python rset = RandomizedSet() assert rset.insert(1) == True assert rset.insert(2) == True assert rset.insert(1) == False assert rset.remove(1) == True assert rset.remove(1) == False # Output can vary due to randomness print(rset.random_element()) ```","solution":"import random class RandomizedSet: def __init__(self): self.dict = {} self.list = [] def insert(self, val: int) -> bool: if val not in self.dict: self.dict[val] = len(self.list) self.list.append(val) return True return False def remove(self, val: int) -> bool: if val in self.dict: # Swap the element to remove with the last element last_element = self.list[-1] index_to_remove = self.dict[val] self.list[index_to_remove] = last_element self.dict[last_element] = index_to_remove # Remove the last element self.list.pop() del self.dict[val] return True return False def random_element(self) -> int: if not self.list: raise IndexError(\\"Cannot get random element from an empty set\\") return random.choice(self.list)"},{"question":"# Swapping Every Two Nodes in a Linked List Scenario You are developing a feature for an application that processes linked lists representing sequences of user data. For one of the functionalities, you need to rearrange these lists by swapping every two adjacent nodes, without changing the node values themselves but only by manipulating their connections. Task Implement the function `swap_pairs` that takes a linked list\'s head node as input and returns the head node of the modified list where every two adjacent nodes are swapped. For example, given a linked list: `1 -> 2 -> 3 -> 4`, the output should be: `2 -> 1 -> 4 -> 3`. The function should meet the following constraints: * The function should use only (O(1)) extra space. * The node values must not be modified, only the node connections can be changed. Input * `head`: A `Node` object representing the head of a singly linked list where a `Node` is defined as: ```python class Node(object): def __init__(self, x): self.val = x self.next = None ``` Output * The function should return the head of the modified linked list. Examples 1. **Input**: `1 -> 2 -> 3 -> 4` **Output**: `2 -> 1 -> 4 -> 3` 2. **Input**: `1 -> 2 -> 3` **Output**: `2 -> 1 -> 3` 3. **Input**: `1` **Output**: `1` Constraints * The linked list will have at most `10⁴` nodes. Function Signature ```python def swap_pairs(head: Node) -> Node: # Your code here ``` Write the code to implement the above function within the given constraints and returning the expected output.","solution":"class Node(object): def __init__(self, x): self.val = x self.next = None def swap_pairs(head: Node) -> Node: if not head or not head.next: return head dummy = Node(0) dummy.next = head prev_node = dummy while head and head.next: first_node = head second_node = head.next # Swapping prev_node.next = second_node first_node.next = second_node.next second_node.next = first_node # Reinitializing the head and prev_node for next swap prev_node = first_node head = first_node.next return dummy.next"},{"question":"You are tasked with creating a utility to read and write integers to a network communication protocol that uses mixed endianness formats. This utility needs to accurately convert integers to byte arrays in both big-endian and little-endian formats and back. **Function Implementations**: 1. **`mixed_endian_to_bytes(num, order)`**: Convert an integer to a byte array where the byte order can be \'big\' for big-endian or \'little\' for little-endian. 2. **`bytes_to_mixed_endian(bytestr, order)`**: Convert a byte array back to an integer given the byte order (\'big\' or \'little\'). **Input/Output**: - **mixed_endian_to_bytes(num, order)**: * `num` (int): The integer to convert. * `order` (str): A string indicating the byte order, either \'big\' or \'little\'. * Returns: A `bytes` object representing the integer in the specified byte order. - **bytes_to_mixed_endian(bytestr, order)**: * `bytestr` (bytes): The byte array to convert. * `order` (str): A string indicating the byte order, either \'big\' or \'little\'. * Returns: An integer representing the byte array in the specified byte order. **Constraints**: - The `num` will be a non-negative integer. - The `bytestr` will be a byte sequence of valid length. - The `order` will always be either \'big\' or \'little\'. **Example**: ```python assert mixed_endian_to_bytes(305419896, \'big\') == b\'x12x34x56x78\' assert mixed_endian_to_bytes(305419896, \'little\') == b\'x78x56x34x12\' assert bytes_to_mixed_endian(b\'x12x34x56x78\', \'big\') == 305419896 assert bytes_to_mixed_endian(b\'x78x56x34x12\', \'little\') == 305419896 ``` **Implementation Note**: - You may use Python\'s built-in functions or libraries, but ensure the implementation is efficient and meets the specified constraints.","solution":"def mixed_endian_to_bytes(num, order): Convert an integer to a byte array where the byte order can be \'big\' for big-endian or \'little\' for little-endian. if order == \'big\': return num.to_bytes((num.bit_length() + 7) // 8, byteorder=\'big\') or b\'x00\' elif order == \'little\': return num.to_bytes((num.bit_length() + 7) // 8, byteorder=\'little\') or b\'x00\' else: raise ValueError(\\"Order must be either \'big\' or \'little\'\\") def bytes_to_mixed_endian(bytestr, order): Convert a byte array back to an integer given the byte order (\'big\' or \'little\'). if order == \'big\': return int.from_bytes(bytestr, byteorder=\'big\') elif order == \'little\': return int.from_bytes(bytestr, byteorder=\'little\') else: raise ValueError(\\"Order must be either \'big\' or \'little\'\\")"},{"question":"Advanced Fibonacci-Based Dynamic Programming Context You are tasked with finding the number of ways to climb a staircase with a twist. Besides climbing 1 or 2 steps at a time, you can also skip up to m steps at once. This generalized version of the problem requires an efficient solution to handle large inputs. Problem Statement Write a function `generalized_climb_stairs(steps: int, max_step: int) -> int` to find the number of distinct ways you can reach the top of a staircase with `steps` steps, given that you can climb up to `max_step` steps at a time. Input * `steps` (int): The total number of steps to reach the top (1 ≤ steps ≤ 10^5). * `max_step` (int): The maximum number of steps you can take at once (1 ≤ max_step ≤ 100). Output * Returns an integer representing the number of distinct ways to climb to the top. Examples * `generalized_climb_stairs(4, 2)` should return `5`. * `generalized_climb_stairs(5, 3)` should return `13`. Constraints * Optimize the solution to handle large values of `steps` efficiently. * Consider edge cases where `steps` or `max_step` are at their minimum or maximum values. Notes * Using dynamic programming can help optimize the solution by breaking down the problem into smaller subproblems. * Keep track of space usage to ensure that your solution remains efficient even for the largest inputs. ```python def generalized_climb_stairs(steps: int, max_step: int) -> int: # Write your implementation here pass # Test the function with the provided examples print(generalized_climb_stairs(4, 2)) # Expected Output: 5 print(generalized_climb_stairs(5, 3)) # Expected Output: 13 ```","solution":"def generalized_climb_stairs(steps: int, max_step: int) -> int: if steps == 0: return 1 dp = [0] * (steps + 1) dp[0] = 1 for i in range(1, steps + 1): for j in range(1, max_step + 1): if i - j >= 0: dp[i] += dp[i - j] return dp[steps]"},{"question":"Context You are working on a natural language processing module for a new chat application. One of the features ensures that predefined patterns for certain expressions are adhered to strictly. Your task is to write a function that validates whether a given string follows a specified pattern as described. Requirements * Write a function `validate_pattern(pattern: str, string: str) -> bool` that checks whether the given string follows the given pattern. * There is a one-to-one correspondence between each character in the pattern and a word in the string. * Both pattern and string are non-empty and consist of lowercase letters. * The string may have words separated by single spaces. Input and Output Formats * **Input**: * `pattern` (str): A string containing only lowercase letters. * `string` (str): A string with words separated by single spaces. * **Output**: * `bool`: Returns `True` if the string follows the pattern, otherwise `False`. Example Cases **Example 1**: ```python pattern = \\"abba\\" string = \\"dog cat cat dog\\" print(validate_pattern(pattern, string)) # Output: True ``` **Example 2**: ```python pattern = \\"abba\\" string = \\"dog cat cat fish\\" print(validate_pattern(pattern, string)) # Output: False ``` **Example 3**: ```python pattern = \\"aaaa\\" string = \\"dog cat cat dog\\" print(validate_pattern(pattern, string)) # Output: False ``` **Example 4**: ```python pattern = \\"abba\\" string = \\"dog dog dog dog\\" print(validate_pattern(pattern, string)) # Output: False ``` Constraints * Assume all inputs are valid. No need to check for input validity. * The length of `pattern` and string is such that it fits in memory. Performance Considerations * The solution must run in linear time relative to `pattern` and `string`. * Ensure that your solution handles large inputs efficiently without excessive memory use. Implement the function `validate_pattern` to meet these requirements.","solution":"def validate_pattern(pattern: str, string: str) -> bool: words = string.split() if len(pattern) != len(words): return False char_to_word = {} word_to_char = {} for p_char, word in zip(pattern, words): if p_char in char_to_word: if char_to_word[p_char] != word: return False else: char_to_word[p_char] = word if word in word_to_char: if word_to_char[word] != p_char: return False else: word_to_char[word] = p_char return True"},{"question":"# Hash Table with Custom Resizing Function Given the implementation of a resizable hash table above, write a custom hash table class `CustomHashTable` that inherits from `ResizableHashTable`. Modify the resizing mechanism to increase the table size by a factor of 1.5 instead of 2 when the hash table reaches two-thirds of its capacity. **Function Specification**: 1. Implement a method `__resize()` in the `CustomHashTable` to resize the table. 2. Override the `put()` method to ensure resizing is triggered properly when the table reaches 2/3 capacity. **Input and Output**: - You may assume that keys and values are both positive integers. - Your `put()` method should accept two integer parameters: `key` and `value`. - Other methods (`get()`, `del_()`, `__getitem__()`, `__delitem__()`, `__setitem__()`, and `__len__()`) should behave as described in the given snippets. **Constraints**: - The hash table should not use any external libraries. - Keep the rehash mechanism as linear probing. **Example**: ```python custom_hash_table = CustomHashTable() custom_hash_table.put(1, 100) custom_hash_table.put(2, 200) print(custom_hash_table.get(1)) # Output: 100 print(len(custom_hash_table)) # Output: 2 for i in range(3, 14): # Trigger resize custom_hash_table.put(i, i*100) custom_hash_table.put(10, 5000) print(custom_hash_table.get(10)) # Output: 5000 print(custom_hash_table.size) # Output should be 11 * 1.5 = 16.5 which is fixed to 16 ``` **Notes**: - Ensure the resizing factor is effectively calculated and properly applied. - Test edge cases such as adding enough elements to trigger multiple resizes.","solution":"class ResizableHashTable: def __init__(self, initial_capacity=8): self.table = [None] * initial_capacity self.capacity = initial_capacity self.size = 0 def put(self, key, value): if self.size >= 2 * self.capacity // 3: self.__resize() index = self.__hash(key) while self.table[index] is not None: if self.table[index][0] == key: self.table[index] = (key, value) return index = (index + 1) % self.capacity self.table[index] = (key, value) self.size += 1 def get(self, key): index = self.__hash(key) while self.table[index] is not None: if self.table[index][0] == key: return self.table[index][1] index = (index + 1) % self.capacity return None def del_(self, key): index = self.__hash(key) while self.table[index] is not None: if self.table[index][0] == key: self.table[index] = None self.size -= 1 return True index = (index + 1) % self.capacity return False def __hash(self, key): return key % self.capacity def __resize(self): new_capacity = self.capacity * 2 new_table = [None] * new_capacity for item in self.table: if item is not None: index = item[0] % new_capacity while new_table[index] is not None: index = (index + 1) % new_capacity new_table[index] = item self.table = new_table self.capacity = new_capacity def __getitem__(self, key): return self.get(key) def __delitem__(self, key): self.del_(key) def __setitem__(self, key, value): self.put(key, value) def __len__(self): return self.size class CustomHashTable(ResizableHashTable): def __resize(self): new_capacity = int(self.capacity * 1.5) new_table = [None] * new_capacity for item in self.table: if item is not None: index = item[0] % new_capacity while new_table[index] is not None: index = (index + 1) % new_capacity new_table[index] = item self.table = new_table self.capacity = new_capacity def put(self, key, value): if self.size >= 2 * self.capacity // 3: self.__resize() super().put(key, value)"},{"question":"**Title**: Optimized Insertion Sort using Binary Search **Scenario**: You are working with a financial application that routinely sorts small lists of transactions. Given the frequency and nature of your dataset, you determine that optimizing the Insertion Sort algorithm—by using Binary Search to determine the correct insert position—will yield significant performance improvements. **Task**: Write a function `insertion_sort(nums)` that takes a list of integers and sorts them in non-decreasing order using the binary search optimized insertion sort method. Implement the `search_insert(array, val)` function for determining the insert positions and utilize it within your insertion sort implementation. **Function Signature**: ```python def insertion_sort(nums: List[int]) -> List[int]: ``` **Input**: - `nums`: A list of integers, with 1 <= len(nums) <= 1000. Each integer can be in the range of -10^6 to 10^6. **Output**: - A list of sorted integers in non-decreasing order. **Constraints**: - Minimize the number of comparisons and shifts to enhance performance. **Examples**: 1. `insertion_sort([4, 2, 6, 1, 3])` should return `[1, 2, 3, 4, 6]`. 2. `insertion_sort([10, 5, 3, 8, 6])` should return `[3, 5, 6, 8, 10]`. **Instructions**: 1. Implement the `search_insert` function which will be used to find the insertion index. 2. Utilize `search_insert` within the `insertion_sort` to determine where to insert each element. 3. Ensure that your implementation handles edge cases, such as empty lists or lists with a single element efficiently. 4. Avoid using in-built sort functions.","solution":"from typing import List def search_insert(array: List[int], val: int) -> int: Uses binary search to find the index where `val` should be inserted to keep `array` sorted. low, high = 0, len(array) while low < high: mid = (low + high) // 2 if array[mid] < val: low = mid + 1 else: high = mid return low def insertion_sort(nums: List[int]) -> List[int]: Sorts the list of integers using the optimized insertion sort with binary search. for i in range(1, len(nums)): key = nums[i] insert_pos = search_insert(nums[:i], key) # efficient binary search for position nums = nums[:insert_pos] + [key] + nums[insert_pos:i] + nums[i+1:] return nums"},{"question":"**Scenario**: In a digital library, we need to verify whether concatenated strings from various book titles can be accurately broken into valid words from an existing dictionary. This is crucial for text analysis and categorization purposes. Given a non-empty string `sentence` and a dictionary `wordDict` containing a list of non-empty words, determine if the sentence can be segmented into a space-separated sequence of one or more dictionary words. You may assume the dictionary does not contain duplicate words. **Function Signature**: ```python def can_segment(sentence: str, wordDict: List[str]) -> bool: # Implementation here ``` **Input**: - `sentence`: A non-empty string ( s ) with length ( 1 le |s| le 300 ). - `wordDict`: A list of non-empty words, each with length ( 1 le |word| le 20 ). **Output**: - A boolean value: `True` if the string can be segmented, `False` otherwise. **Constraints**: - The string and dictionary words contain only lowercase English letters. **Examples**: ```python print(can_segment(\\"leetcode\\", [\\"leet\\", \\"code\\"])) # Output: True print(can_segment(\\"applepenapple\\", [\\"apple\\", \\"pen\\"])) # Output: True print(can_segment(\\"catsandog\\", [\\"cats\\", \\"dog\\", \\"sand\\", \\"and\\", \\"cat\\"])) # Output: False ``` **Requirements**: - Implement the function `can_segment()` using the dynamic programming approach described. - Ensure the solution handles all specified constraints and edge cases effectively.","solution":"from typing import List def can_segment(sentence: str, wordDict: List[str]) -> bool: word_set = set(wordDict) dp = [False] * (len(sentence) + 1) dp[0] = True for i in range(1, len(sentence) + 1): for j in range(i): if dp[j] and sentence[j:i] in word_set: dp[i] = True break return dp[len(sentence)]"},{"question":"# Challenge: Enhanced Run-Length Encoding and Decoding **Objective**: Implement two functions for advanced RLE encoding and decoding while handling both upper-case and lower-case characters distinctly and including edge cases. Function Definitions: 1. **Function**: `encode_enhanced_rle(input_string: str) -> str` 2. **Function**: `decode_enhanced_rle(encoded_string: str) -> str` Input: - `encode_enhanced_rle`: A string `input_string` consisting of alphanumeric characters and special characters. - `decode_enhanced_rle`: An encoded string `encoded_string` adhering to the RLE format generated by `encode_enhanced_rle`. Output: - `encode_enhanced_rle`: A string representing the RLE encoded data. - `decode_enhanced_rle`: The original string after decoding the `encoded_string`. Constraints: - The input string can be empty. - Case sensitivity should be maintained (\'a\' and \'A\' should be treated differently). Example: ```python # Example 1 input_string = \\"aabccDDD\\" encoded_string = encode_enhanced_rle(input_string) # encoded_string should be \\"2a1b2c3D\\" decoded_string = decode_enhanced_rle(encoded_string) # decoded_string should be \\"aabccDDD\\" # Example 2 input_string = \\"\\" encoded_string = encode_enhanced_rle(input_string) # encoded_string should be \\"\\" decoded_string = decode_enhanced_rle(encoded_string) # decoded_string should be \\"\\" # Example 3 input_string = \\"AAAaaa\\" encoded_string = encode_enhanced_rle(input_string) # encoded_string should be \\"3A3a\\" decoded_string = decode_enhanced_rle(encoded_string) # decoded_string should be \\"AAAaaa\\" ``` # Requirements: 1. Implement the `encode_enhanced_rle` function to encode the input string in the RLE format. 2. Implement the `decode_enhanced_rle` function to decode an RLE formatted string back to its original form. 3. Ensure the functions handle edge cases such as empty input and strings without repeated characters. 4. Maintain case sensitivity in both encoding and decoding processes. 5. Optimize for performance while ensuring correctness. **Note**: Do not use any external libraries for encoding or decoding.","solution":"def encode_enhanced_rle(input_string: str) -> str: if not input_string: return \\"\\" encoded_string = [] count = 1 previous_char = input_string[0] for char in input_string[1:]: if char == previous_char: count += 1 else: encoded_string.append(f\\"{count}{previous_char}\\") count = 1 previous_char = char encoded_string.append(f\\"{count}{previous_char}\\") return \\"\\".join(encoded_string) def decode_enhanced_rle(encoded_string: str) -> str: if not encoded_string: return \\"\\" decoded_string = [] count = \\"\\" for char in encoded_string: if char.isdigit(): count += char else: decoded_string.append(char * int(count)) count = \\"\\" return \\"\\".join(decoded_string)"},{"question":"Objective To assess the student\'s ability to implement and understand tree serialization and deserialization techniques using preorder traversal. Question You are working on a system that needs to save and load the binary tree structure efficiently. Your task is to write functions to serialize and deserialize a binary tree. The tree nodes are defined as follows: ```python class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None ``` # Function Specifications 1. **serialize**: * **Input**: A TreeNode object representing the root of the binary tree. * **Output**: A single string containing the serialized tree. 2. **deserialize**: * **Input**: A string representation of the serialized tree. * **Output**: A TreeNode object representing the root of the binary tree. # Constraints * The input tree can have up to 10^4 nodes. * Node values are integers within the range [-10^5, 10^5]. * Each node can have up to two children. * The input string for `deserialize` is guaranteed to be a valid serialized tree string. # Examples **Example 1:** ```python # For the serialization part root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) root.right.left = TreeNode(4) root.right.right = TreeNode(5) serialized_tree = serialize(root) print(serialized_tree) # Output: \\"1 2 # # 3 4 # # 5 # #\\" # For the deserialization part data = \\"1 2 # # 3 4 # # 5 # #\\" root = deserialize(data) print(root.val) # Output: 1 print(root.left.val) # Output: 2 print(root.right.val) # Output: 3 print(root.right.left.val)# Output: 4 print(root.right.right.val)# Output: 5 ``` **Example 2:** ```python # For the serialization part root = None serialized_tree = serialize(root) print(serialized_tree) # Output: \\"#\\" # For the deserialization part data = \\"#\\" root = deserialize(data) print(root) # Output: None ``` Use these examples for guidance and implement the functions `serialize` and `deserialize` accordingly.","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def serialize(root): Encodes a tree to a single string. def helper(node): if node: vals.append(str(node.val)) helper(node.left) helper(node.right) else: vals.append(\'#\') vals = [] helper(root) return \' \'.join(vals) def deserialize(data): Decodes your encoded data to tree. def helper(): val = next(vals) if val == \'#\': return None node = TreeNode(int(val)) node.left = helper() node.right = helper() return node vals = iter(data.split()) return helper()"},{"question":"# Missing Number Finder You are given a list of unique integers `nums` which can contain any number from 0 to n inclusive, except for one missing integer in this range. Write a function `find_missing_number(nums)` that finds the missing integer and returns it. If there are no missing numbers, return the next integer in the sequence. Input * `nums`: List of unique integers of length n, where the integers are within the range [0, n]. Output * An integer, which is the missing number in the sequence. If no number is missing, return the next number in the sequence. Constraints * `0 <= len(nums) <= 10^5` * All elements in `nums` are unique. * The difference between the smallest and largest number in `nums` is at most `len(nums)`. Function Signature ```python def find_missing_number(nums: List[int]) -> int: # your code here ``` Example ```python # Example 1: nums = [3, 0, 1] print(find_missing_number(nums)) # Output: 2 # Example 2: nums = [0, 1, 2, 3] print(find_missing_number(nums)) # Output: 4 ``` Explanation 1. **Example 1**: - Input: nums = [3, 0, 1] - The numbers 0, 1, and 3 are present, but 2 is missing. - Output: 2 2. **Example 2**: - Input: nums = [0, 1, 2, 3] - All numbers from 0 to 3 are present. - The sequence needs the next integer after 3, which is 4. Notes - Ensure your function handles edge cases like an empty list, a list with a single element, and regular sequences correctly. - Aim for an O(n) time complexity solution with O(1) space complexity.","solution":"from typing import List def find_missing_number(nums: List[int]) -> int: Returns the missing number in the sequence 0 to n, or the next integer if no number is missing. n = len(nums) expected_sum = n * (n + 1) // 2 actual_sum = sum(nums) missing_number = expected_sum - actual_sum return missing_number"},{"question":"Context: You are tasked with implementing an AVL Tree, a type of balanced binary search tree. Your AVL Tree should support insertion of keys while maintaining balance, ensuring that the tree doesn\'t skew too much to the left or right. This can be achieved through rotations. Task: Implement the AVL Tree with the following functionalities: 1. **Insertion**: Add a key to the tree, ensuring the tree remains balanced. 2. **In-Order Traversal**: Return the keys of the tree in sorted order. # Specifications: * **Input Format**: * For insertion: A key (integer value) to be inserted into the tree. * For in-order traversal: No input parameters. * **Output Format**: * For insertion: No return value. * For in-order traversal: List of keys in in-order. # Constraints: 1. All keys are unique integer values. 2. The keys to be inserted are in the range of -10^6 to 10^6. 3. The total number of keys inserted into the tree does not exceed 10^5. # Example: ```python # Initialize an empty AVL Tree avl_tree = AvlTree() # Insert keys avl_tree.insert(10) avl_tree.insert(20) avl_tree.insert(30) # Perform in-order traversal print(avl_tree.in_order_traverse()) # Output: [10, 20, 30] ``` # Implementation Details: 1. **Insert Method**: - Create a new node with the given key if the tree is empty. - Recursively insert the key into the left or right subtree based on comparison. - Rebalance the tree if it\'s unbalanced post insertion. 2. **Rebalance Method**: - Update the height of the nodes. - Calculate the balance factor. - Perform rotations based on the balance factor to maintain tree balance. 3. **In-Order Traversal Method**: - Traverse the left subtree recursively. - Visit the node. - Traverse the right subtree recursively.","solution":"class TreeNode: def __init__(self, key): self.key = key self.left = None self.right = None self.height = 1 class AvlTree: def __init__(self): self.root = None def insert(self, key): self.root = self._insert(self.root, key) def _insert(self, node, key): if not node: return TreeNode(key) if key < node.key: node.left = self._insert(node.left, key) else: node.right = self._insert(node.right, key) node.height = 1 + max(self._get_height(node.left), self._get_height(node.right)) balance = self._get_balance(node) if balance > 1: if key < node.left.key: return self._right_rotate(node) else: node.left = self._left_rotate(node.left) return self._right_rotate(node) if balance < -1: if key > node.right.key: return self._left_rotate(node) else: node.right = self._right_rotate(node.right) return self._left_rotate(node) return node def _left_rotate(self, z): y = z.right T2 = y.left y.left = z z.right = T2 z.height = 1 + max(self._get_height(z.left), self._get_height(z.right)) y.height = 1 + max(self._get_height(y.left), self._get_height(y.right)) return y def _right_rotate(self, z): y = z.left T3 = y.right y.right = z z.left = T3 z.height = 1 + max(self._get_height(z.left), self._get_height(z.right)) y.height = 1 + max(self._get_height(y.left), self._get_height(y.right)) return y def _get_height(self, node): if not node: return 0 return node.height def _get_balance(self, node): if not node: return 0 return self._get_height(node.left) - self._get_height(node.right) def in_order_traverse(self): result = [] self._in_order_traverse(self.root, result) return result def _in_order_traverse(self, node, result): if not node: return self._in_order_traverse(node.left, result) result.append(node.key) self._in_order_traverse(node.right, result)"},{"question":"# Context You are working on a data storage service that needs to process binary trees. The trees need to be saved and loaded efficiently. # Task Implement two functions, `serialize` and `deserialize`, to convert a binary tree to/from a string representation using a pre-order traversal method. # Function Signatures ```python def serialize(root: TreeNode) -> str: Serializes a binary tree to a string. Parameters: - root (TreeNode): the root node of the binary tree. Returns: - str: the serialized string representation of the binary tree. # Your code here def deserialize(data: str) -> TreeNode: Deserializes the string representation to a binary tree. Parameters: - data (str): the serialized string representation of the binary tree. Returns: - TreeNode: the root node of the deserialized binary tree. # Your code here ``` # Input and Output Formats * `serialize`: * **Input**: * `root` (TreeNode): the root of a binary tree. * **Output**: * A `str` representing the tree using a pre-order traversal. `None` nodes are denoted by \\"#\\". * `deserialize`: * **Input**: * A `str` representing a serialized binary tree. * **Output**: * A `TreeNode` that is the root of the reconstructed binary tree. # Constraints * The binary tree does not necessarily follow the properties of binary search trees. * The input for deserialization is guaranteed to be valid. # Example ```python # Example: # Construct a sample binary tree # 1 # / # 2 3 # / # 4 5 root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) root.right.left = TreeNode(4) root.right.right = TreeNode(5) serialized = serialize(root) print(serialized) # Expected: \\"1 2 # # 3 4 # # 5 # #\\" deserialized = deserialize(serialized) print(deserialized.val) # Expected: 1 print(deserialized.left.val) # Expected: 2 print(deserialized.right.val) # Expected: 3 print(deserialized.right.left.val) # Expected: 4 print(deserialized.right.right.val) # Expected: 5 ``` # Additional Notes Consider edge cases such as: * An empty tree. * A tree with only one node. * Trees with only left or only right children.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def serialize(root: TreeNode) -> str: Serializes a binary tree to a string using pre-order traversal. def helper(node): if node is None: return \\"#\\" return f\\"{node.val} {helper(node.left)} {helper(node.right)}\\" return helper(root).strip() def deserialize(data: str) -> TreeNode: Deserializes the string representation to a binary tree. def helper(values): val = next(values) if val == \\"#\\": return None node = TreeNode(int(val)) node.left = helper(values) node.right = helper(values) return node values = iter(data.split()) return helper(values)"},{"question":"Context You are developing a system that heavily relies on mathematical operations related to integers. As part of this system, you need robust implementations for calculating the greatest common divisor (GCD), the least common multiple (LCM), and counting trailing zeros in the binary representation of numbers. These operations will be used in cryptographic algorithms, number theory analyses, and large integer computations. Task Implement the following functions in Python based on the specifications provided: 1. **gcd(a, b)**: - **Input**: Two integers, a and b. - **Output**: An integer representing the greatest common divisor of a and b. - **Constraints**: The inputs will be non-zero integers. 2. **lcm(a, b)**: - **Input**: Two integers, a and b. - **Output**: An integer representing the least common multiple of a and b. - **Constraints**: The inputs will be non-zero integers. 3. **trailing_zero(x)**: - **Input**: A non-negative integer, x. - **Output**: An integer representing the number of trailing zeros in the binary representation of x. - **Constraints**: The input will be a non-negative integer. 4. **gcd_bit(a, b)**: - **Input**: Two non-negative integers, a and b. - **Output**: An integer representing the greatest common divisor of a and b using bitwise operations. - **Constraints**: The inputs will be non-negative integers. Example ```python # Test Cases print(gcd(48, 18)) # Output: 6 print(lcm(4, 5)) # Output: 20 print(trailing_zero(40)) # Output: 3 print(gcd_bit(48, 18)) # Output: 6 ``` Guidelines - Ensure proper handling of edge cases, such as negative inputs (for gcd and lcm). - Optimize the functions for performance, especially for large integers. - Implement robust error handling for invalid inputs where applicable. - Provide a comprehensive set of test cases to validate the correctness of your implementations.","solution":"import math def gcd(a, b): Returns the greatest common divisor (GCD) of a and b. while b: a, b = b, a % b return abs(a) def lcm(a, b): Returns the least common multiple (LCM) of a and b. return abs(a * b) // gcd(a, b) def trailing_zero(x): Returns the number of trailing zeros in the binary representation of x. if x == 0: return 0 count = 0 while (x & 1) == 0: x >>= 1 count += 1 return count def gcd_bit(a, b): Returns the greatest common divisor (GCD) of a and b using bitwise operations. if a == 0: return b if b == 0: return a # Finding the common factor of 2 for both a and b shift = trailing_zero(a | b) # Now divide both a and b by 2 until they are odd. a >>= trailing_zero(a) while b != 0: b >>= trailing_zero(b) if a > b: a, b = b, a b -= a return a << shift"},{"question":"# Reverse a Singly Linked List with Constraints Description Given a singly linked list, write a function to reverse it. However, your function should handle potential large lists efficiently. Thus, use an iterative approach and include handling for cases where the list might be cyclic. Function Signature ```python def reverse_list_with_constraints(head: ListNode) -> ListNode: pass ``` Input - `head`: The head node of the singly linked list. `ListNode` is a class that has two attributes: `val` (integer) and `next` (ListNode or None). Output - Return the head of the reversed singly linked list. Example ```python # Assuming ListNode is defined as: # class ListNode: # def __init__(self, val=0, next=None): # self.val = val # self.next = next # Input: 1 -> 2 -> 3 -> 4 # Output: 4 -> 3 -> 2 -> 1 head = ListNode(1, ListNode(2, ListNode(3, ListNode(4)))) new_head = reverse_list_with_constraints(head) ``` # Constraints - The list may contain up to 10^5 nodes. - The list might be empty. - You need to handle cyclic lists where some nodes may point back to previous nodes instead of `None`. # Additional Notes - Pay attention to edge cases, such as empty lists or single-element lists. - Ensure your solution avoids infinite loops in cyclic lists by detecting cycles and breaking them appropriately before reversal. Hints 1. Consider using a set for cycle detection. 2. Carefully handle pointer reassignment to prevent infinite loops and properly reverse the list.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverse_list_with_constraints(head: ListNode) -> ListNode: # Detect cycle in the list and break it if head is None: return None slow = fast = head while fast is not None and fast.next is not None: slow = slow.next fast = fast.next.next if slow == fast: break if fast is not None and fast.next is not None: # Cycle detected slow = head while slow != fast: slow = slow.next fast = fast.next # Now `slow` and `fast` meet at the cycle start cycle_start = slow prev = None while True: prev = fast fast = fast.next if fast == cycle_start: prev.next = None break # Reverse the linked list prev = None current = head while current is not None: next_node = current.next current.next = prev prev = current current = next_node return prev"},{"question":"# Question: Efficient GCD Computation and Optimization Scenario: In the world of competitive programming and optimization, computing the greatest common divisor (GCD) of two non-negative integers efficiently is a frequent requirement. Your task is to implement a function to find the GCD using both traditional Euclidean algorithm and an optimized bitwise approach. This question will challenge your understanding of algorithmic optimizations, handling edge cases, and efficient use of bitwise operations. Requirements: 1. **Function 1**: `gcd(a: int, b: int) -> int` - Use the classic Euclid\'s Algorithm. - Input: Two non-negative integers a and b. - Output: The GCD of `a` and `b`. - Constraints: - ( 0 leq a, b leq 10^{18} ) - Edge cases: Ensure to handle zero and negative values appropriately. 2. **Function 2**: `gcd_bit(a: int, b: int) -> int` - Use the optimized bitwise method to compute GCD. - Input: Two non-negative integers a and b. - Output: The GCD of `a` and `b`. - Constraints: - ( 0 leq a, b leq 10^{18} ) - Performance: Aim for an efficient runtime and avoid unnecessary operations. - Edge cases: Ensure it safely handles very large numbers and zero values. Example: ```python # Function 1 Example print(gcd(34, 40)) # Output: 2 print(gcd(0, 40)) # Output: 40 print(gcd(18, 35)) # Output: 1 # Function 2 Example print(gcd_bit(34, 40)) # Output: 2 print(gcd_bit(0, 40)) # Output: 40 print(gcd_bit(18, 35)) # Output: 1 ``` Criteria: - Ensure code correctness even for large inputs. - Code should be well-optimized and demonstrate a clear understanding of both algorithms. - Handle edge cases with appropriate validations and explain the rationale for your decisions in comments where necessary.","solution":"def gcd(a: int, b: int) -> int: Returns the greatest common divisor (GCD) of two non-negative integers a and b using the classical Euclidean algorithm. while b: a, b = b, a % b return a def gcd_bit(a: int, b: int) -> int: Returns the greatest common divisor (GCD) of two non-negative integers a and b using an optimized bitwise method. if a == 0: return b if b == 0: return a # Finding the largest power of 2 that divides both a and b shift = 0 while ((a | b) & 1) == 0: # while both a and b are even a >>= 1 b >>= 1 shift += 1 # Make sure a is odd while (a & 1) == 0: a >>= 1 while b != 0: while (b & 1) == 0: # Remove all factors of 2 in b b >>= 1 # Now both a and b are odd. Swap if necessary so a <= b, then set b = b - a if a > b: a, b = b, a b = b - a # Here b >= a, so b - a is non-negative # Add back the common factors of 2 return a << shift"},{"question":"You are given a directed graph and need to determine if there is a path between a given source and target node. Implement the necessary functionality to add edges to the graph and perform a depth-first search to find if a path exists. # Specifications * **Class**: `Graph` * **Methods**: * `__init__(self, vertex_count:int)`: Initializes the graph with the specified number of vertices. * `add_edge(self, source:int, target:int)`: Adds a directed edge from `source` to `target`. * `is_reachable(self, source:int, target:int) -> bool`: Returns `True` if there is a path from `source` to `target`, otherwise `False`. # Input and Output * **Input**: * Vertex count for initializing the graph. * Edge list to add to the graph. * Source and target nodes for the pathfinding query. * **Output**: * Boolean indicating if a path exists between the source and target nodes. # Constraints * All node values are non-negative integers and within the range of the vertex count. * No self-loops (edges that connect a node to itself). * Duplicate edges are not allowed. # Example Case ```plaintext Input: vertex_count = 4 edges = [(0, 1), (1, 2), (2, 3)] source = 0 target = 3 Output: True Explanation: There is a path from node 0 to node 3 via nodes 1 and 2. ``` # Implementation Students are expected to: 1. Initialize the graph with the given number of vertices. 2. Add edges as specified in the edges list. 3. Implement the depth-first search algorithm in the `is_reachable` method to check the connectivity from source to target nodes.","solution":"class Graph: def __init__(self, vertex_count): self.vertex_count = vertex_count self.graph = {i: [] for i in range(vertex_count)} def add_edge(self, source, target): if target not in self.graph[source]: self.graph[source].append(target) def is_reachable(self, source, target): visited = [False] * self.vertex_count return self._dfs(source, target, visited) def _dfs(self, source, target, visited): if source == target: return True visited[source] = True for neighbor in self.graph[source]: if not visited[neighbor]: if self._dfs(neighbor, target, visited): return True return False"},{"question":"# Segment Tree with Custom Commutative Function The segment tree is a data structure that allows querying and updating an array efficiently. Implement a segment tree that supports a custom commutative function. Task You need to implement a `SegmentTree` class that supports the following operations: 1. **Initialization**: Create a segment tree with a given array and a commutative function. 2. **Query**: Return the result of the commutative function applied over a range of the array. 3. **Update**: Update an element in the array and adjust the segment tree accordingly. Specifications 1. **Initialization (`__init__` Function)**: * Input: * `arr` - A list of elements (type can be int, tuple, etc.) * `function` - A commutative function that takes two elements and returns an element of the same type. * Output: None 2. **Update (`update` Function)**: * Input: * `p` - Index of the element to update (0-based index). * `v` - New value to update at index `p`. * Output: None 3. **Query (`query` Function)**: * Input: * `l` - Left index of the range (0-based index). * `r` - Right index of the range (0-based index). * Output: Value obtained by applying the commutative function across the range from index `l` to `r`. Example ```python # Example usage seg_tree = SegmentTree([2, 4, 5, 3, 4], max) print(seg_tree.query(2, 4)) # Output should be 5 seg_tree.update(3, 6) print(seg_tree.query(0, 3)) # Output should be 6 seg_tree = SegmentTree([4, 5, 2, 3, 4, 43, 3], lambda a, b: a + b) print(seg_tree.query(0, 6)) # Output should be 64 seg_tree.update(2, -10) print(seg_tree.query(0, 6)) # Output should be 52 ``` Constraints * The commutative function must be applied correctly to retrieve the proper results for both range queries and updates. * The array length will be between 1 and 10^5.","solution":"class SegmentTree: def __init__(self, arr, function): self.n = len(arr) self.tree = [None] * (2 * self.n) self.function = function self.build(arr) def build(self, arr): # Initialize leaves in the segment tree for i in range(self.n): self.tree[self.n + i] = arr[i] # Build the segment tree by calculating internal nodes for i in range(self.n - 1, 0, -1): self.tree[i] = self.function(self.tree[i * 2], self.tree[i * 2 + 1]) def update(self, p, v): # Update the value at index p p += self.n self.tree[p] = v # Adjust the segment tree accordingly while p > 1: p //= 2 self.tree[p] = self.function(self.tree[2 * p], self.tree[2 * p + 1]) def query(self, l, r): # Query from index l to r (inclusive) l += self.n r += self.n + 1 result = None while l < r: if l & 1: result = self.tree[l] if result is None else self.function(result, self.tree[l]) l += 1 if r & 1: r -= 1 result = self.tree[r] if result is None else self.function(result, self.tree[r]) l //= 2 r //= 2 return result"},{"question":"You are tasked with implementing a dynamic array data structure that supports efficient range sum queries and point updates. This can be efficiently achieved using a Fenwick Tree / Binary Indexed Tree. # Requirements 1. **Class Definition**: * Implement a class `FenwickTree` that supports initializing with an array, updating values, and querying range sums. 2. **Functions to Implement**: * `__init__(self, freq: List[int]) -> None`: Initialize the Fenwick Tree with the given array. * `update(self, i: int, value: int) -> None`: Update the value at index `i` to `value`. * `query(self, l: int, r: int) -> int`: Return the sum of the array elements from index `l` to `r` inclusive. # Input and Output - **Input**: 1. An initial list of integers. 2. A series of operations (updates and queries). - **Output**: 1. The result of each query operation. # Constraints - `1 <= n <= 10^5`: The length of the initial array. - `-10^9 <= arr[i], value <= 10^9`: The values in the array and the update values. # Example ```python # Initialization arr = [2, 1, 5, 3, 7, 9] # Operations tree = FenwickTree(arr) tree.update(3, 5) # Update index 3 to value 5 print(tree.query(1, 4)) # Query the sum from index 1 to 4 -> Output should be 19 # Also, initial sum queries print(tree.query(0, 2)) # Output should be 8 (2 + 1 + 5) print(tree.query(2, 5)) # Output should be 24 (5 + 3 (recently updated to 5) + 7 + 9) ``` # Notes 1. You are encouraged to use a 1-based index internally in the BIT to simplify logic, but your interface should use 0-based indexing like standard Python lists. 2. Ensure to handle edge cases such as updating the first and last items, querying single elements, and an initially empty or single-element array.","solution":"from typing import List class FenwickTree: def __init__(self, freq: List[int]) -> None: self.n = len(freq) self.bit = [0] * (self.n + 1) self.array = [0] * self.n # Build the BIT for i in range(self.n): self.update(i, freq[i]) def update(self, i: int, value: int) -> None: diff = value - self.array[i] self.array[i] = value i += 1 # converting to 1-based index while i <= self.n: self.bit[i] += diff i += (i & -i) def prefix_sum(self, i: int) -> int: sum = 0 i += 1 # converting to 1-based index while i > 0: sum += self.bit[i] i -= (i & -i) return sum def query(self, l: int, r: int) -> int: return self.prefix_sum(r) - self.prefix_sum(l - 1)"},{"question":"Objective: Write a function to determine the nth digit in an infinitely long sequence formed by concatenating positive integers consecutively (i.e., \\"123456789101112...\\"). Description: Given a positive integer n, find the nth digit of the infinite sequence of digits made by concatenating positive integers starting from 1. Input: * A single integer, n (1 ≤ n ≤ 2^31 - 1). Output: * A single integer representing the nth digit in the sequence. Function Signature: ```python def find_nth_digit(n: int) -> int: pass ``` Example: ```python assert find_nth_digit(3) == 3 # The sequence is \\"123\\", the third digit is 3 assert find_nth_digit(11) == 0 # The sequence is \\"12345678910\\", the 11th digit is 0 assert find_nth_digit(15) == 2 # The sequence is \\"123456789101112\\", the 15th digit is 2 ``` Constraints: * Your solution should aim for logarithmic time complexity. * Consider edge cases where n lies at boundary transitions. **Context Note**: This problem focuses on understanding digit sequences and efficient traversal using mathematical calculations. It ensures students grasp sequence navigation, mathematical computations, and efficient implementation handling large inputs.","solution":"def find_nth_digit(n: int) -> int: Returns the nth digit in the sequence formed by concatenating positive integers consecutively. length = 1 count = 9 start = 1 while n > length * count: n -= length * count length += 1 count *= 10 start *= 10 start += (n - 1) // length s = str(start) return int(s[(n - 1) % length])"},{"question":"You are given an array of integers that needs to be sorted in non-decreasing order. You will implement the Comb Sort algorithm to sort this array. Make sure to adhere strictly to the principles of Comb Sort as described below and handle edge cases effectively. **Function Signature:** ```python def comb_sort(arr: list) -> list: # Your code here ``` # Input * A list of integers, `arr` (0 ≤ len(arr) ≤ 10^5) * Each integer, `arr[i]`, will be in the range of [-10^9, 10^9]. # Output * A list of integers sorted in non-decreasing order. # Constraints * The solution should run efficiently for large inputs. * The original list should be modified in-place to save space. # Example ```python assert comb_sort([4, 3, 10, -1, 12]) == [-1, 3, 4, 10, 12] assert comb_sort([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5] assert comb_sort([]) == [] ``` # Explanation 1. Initialize the gap to be the size of the list. 2. Reduce the gap by a shrink factor of 1.3 in each iteration while comparing and swapping elements if needed. 3. When the gap is reduced to 1, use a similar approach to Bubble Sort to finalize the sorted order. 4. Ensure edge cases such as an empty list or already sorted list are handled appropriately.","solution":"def comb_sort(arr: list) -> list: Sort an array using the Comb Sort algorithm. if len(arr) <= 1: return arr gap = len(arr) shrink_factor = 1.3 sorted = False while not sorted: # Update the gap value for a next comb gap = int(gap // shrink_factor) if gap <= 1: gap = 1 sorted = True # A single \\"comb\\" pass i = 0 while i + gap < len(arr): if arr[i] > arr[i + gap]: # Swap elements arr[i], arr[i + gap] = arr[i + gap], arr[i] sorted = False # If we made a swap, we are not sorted i += 1 return arr"},{"question":"You are given a knapsack that can hold a maximum weight of `capacity`. You are also given a list of items, each defined by its `value` and `weight`. You need to determine the maximum summed value of items that can be packed into the knapsack without exceeding the weight limit. Each item can be taken at most once. # Function Signature ```python def get_maximum_value(items: List[Tuple[int, int]], capacity: int) -> int: ``` # Input * `items`: A list of tuples, where each tuple (value, weight) represents the value and weight of an item. (1 <= value <= 1000, 1 <= weight <= 1000) * `capacity`: An integer representing the maximum weight the knapsack can hold. (0 <= capacity <= 10000) # Output * An integer representing the maximum value that can be achieved within the given capacity. # Constraints * All items have a non-zero value and weight. * The function should run in O(n * m) time and O(m) space, where n is the number of items and m is the capacity. # Example ```python assert get_maximum_value([(60, 5), (50, 3), (70, 4), (30, 2)], 5) == 80 assert get_maximum_value([(20, 3), (40, 4), (30, 2)], 5) == 50 assert get_maximum_value([], 5) == 0 assert get_maximum_value([(60, 5), (50, 3), (70, 4), (30, 2)], 0) == 0 assert get_maximum_value([(10, 1)], 100) == 10 ``` # Explanation of Example * In the first example, the items valued at 50 and 30 can both fit into the knapsack for a total value of 80. * In the second example, the item valued at 50 is the highest value that can fit into the knapsack with a capacity of 5. * In the third example, an empty list of items results in a maximum value of 0. * In the fourth example, a capacity of 0 means no items can be included, resulting in a maximum value of 0. * In the fifth example, only one item will fit, but as many times as needed (up to once). # Notes * Make sure to consider edge cases, such as having no items or a capacity of 0. * Efficiently use the DP array to store intermediate results to avoid recalculations and save space.","solution":"from typing import List, Tuple def get_maximum_value(items: List[Tuple[int, int]], capacity: int) -> int: Returns the maximum value that can be achieved within the given knapsack capacity. # Initialize DP array for the current and previous rows dp = [0] * (capacity + 1) for value, weight in items: # Traverse the dp array backwards to avoid overwriting the values needed for this round calculation for c in range(capacity, weight - 1, -1): dp[c] = max(dp[c], dp[c - weight] + value) return dp[capacity]"},{"question":"Context You are tasked with implementing a function that searches for the first occurrence of a given substring in a larger string. This function is crucial in many text processing applications, such as search engines, text editors, and DNA sequence analysis. Problem Statement Implement a function `find_substring(haystack: str, needle: str) -> int` that returns the index of the first occurrence of the substring `needle` in the string `haystack`, or -1 if `needle` is not part of `haystack`. If `needle` is an empty string, return 0. Your implementation should handle various edge cases and ensure optimal performance. Input and Output * **Input**: * `haystack` (string, 0 ≤ len(haystack) ≤ 10^5): The string in which to search for the substring. * `needle` (string, 0 ≤ len(needle) ≤ 10^5): The substring to search for. * **Output**: * An integer representing the index of the first occurrence of `needle` in `haystack`, or -1 if `needle` is not found. Constraints 1. `haystack` and `needle` are both lower-case English letters. 2. Aim to achieve the best possible performance. Examples Example 1: ```python haystack = \\"hello\\" needle = \\"ll\\" Output: 2 ``` Example 2: ```python haystack = \\"aaaaa\\" needle = \\"bba\\" Output: -1 ``` Example 3: ```python haystack = \\"\\" needle = \\"\\" Output: 0 ``` Performance Requirements Your implementation should strive for a time complexity better than O(N*M) where N is the length of `haystack` and M is the length of `needle`. Consider more advanced algorithms that might enhance performance. Edge Cases to Consider 1. `needle` is empty. 2. `needle` is longer than `haystack`. 3. `haystack` starts with `needle`. 4. `haystack` ends with `needle`. 5. Both `haystack` and `needle` are empty. Implement the function based on these requirements: ```python def find_substring(haystack: str, needle: str) -> int: # Your code here pass ```","solution":"def find_substring(haystack: str, needle: str) -> int: Returns the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack. If needle is an empty string, returns 0. if not needle: return 0 h_len = len(haystack) n_len = len(needle) if n_len > h_len: return -1 for i in range(h_len - n_len + 1): if haystack[i:i + n_len] == needle: return i return -1"},{"question":"**Preorder Traversal of a Binary Tree** **Context**: You are given the implementation of a binary tree node and an iterative as well as a recursive approach for preorder traversal (root -> left -> right), which visits all the nodes in this order. **Objective**: Extend the above implementations by adding a detailed explanation of preorder traversal and then write a function that performs a similar traversal but returns a particular traversal result based on a specific condition. **Special Condition**: Define a function that performs preorder traversal and collects nodes\' values only if the node’s value is greater than a given threshold. **Function Signature**: ```python def preorder_custom(root: Node, threshold: int) -> List[int]: pass ``` # Input * `root`: The root node of the binary tree (type: Node). * `threshold`: An integer representing the threshold value. # Output * A list of integers, representing the node values visited in preorder and greater than the given threshold. # Constraints * The binary tree can have up to 10^4 nodes. * Node values and the threshold are integers. # Example ```python # Construct binary tree # 10 # / # 5 15 # / # 1 8 20 # # Threshold: 7 root = Node(10, Node(5, Node(1), Node(8)), Node(15, None, Node(20))) output = preorder_custom(root, 7) print(output) # Expected Output: [10, 8, 15, 20] ``` **Notes**: * Both iterative and recursive solutions are acceptable. However, explain your chosen approach clearly. * Consider edge cases and ensure the function handles empty trees and trees with only one node correctly.","solution":"class Node: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def preorder_custom(root: Node, threshold: int): Perform a preorder traversal of the binary tree and collect the node values only if they are greater than the given threshold. result = [] def helper(node): if node is None: return if node.value > threshold: result.append(node.value) helper(node.left) helper(node.right) helper(root) return result"},{"question":"# Coding Assessment: Implementing OrderedStack Scenario You are developing an application that needs a stack data structure but with the additional constraint that elements must always remain in sorted order, with the largest element on top and the smallest at the bottom. This will ensure that whenever an item is added or removed, the order is invariantly maintained. Problem Given the `OrderedStack` data structure partially implemented in the provided snippets, complete the implementation ensuring it maintains the ordered property after each element insertion. Requirements 1. Implement the missing methods and ensure all operations maintain the stack order. 2. You must maintain this invariance after every `push` to the stack. 3. Ensure your implementation handles edge cases like attempting to pop from an empty stack. Expected Input and Output Formats * **Input**: No direct input through a function, class implementation expected. * **Output**: No direct output through a function, class implementation expected. - Utilize the class methods to modify and retrieve stack elements. Performance Requirements - Ensure the `push` method is optimized for least amount of unnecessary operations while maintaining the order. - Handle edge cases and prevent stack underflow. ```python class OrderedStack: def __init__(self): self.items = [] def is_empty(self): return self.items == [] def push_t(self, item): self.items.append(item) # Complete the push method to maintain order when pushing new elements def push(self, item): raise NotImplementedError(\\"Complete the push method\\") def pop(self): if self.is_empty(): raise IndexError(\\"Stack is empty\\") return self.items.pop() def peek(self): return self.items[len(self.items) - 1] def size(self): return len(self.items) ``` Notes - Do not use any external libraries for sorting. - Do not alter the provided method signatures or class structure. Testing - Ensure you test with various cases: - Push operations when the stack is empty. - Insertions where the new item is smaller or larger than existing elements. - Popping all elements to ensure order is maintained.","solution":"class OrderedStack: def __init__(self): self.items = [] def is_empty(self): return not self.items def push_t(self, item): self.items.append(item) def push(self, item): # To maintain order, find the correct position to insert the new item temp_stack = [] while not self.is_empty() and self.items[-1] > item: temp_stack.append(self.pop()) self.push_t(item) while temp_stack: self.push_t(temp_stack.pop()) def pop(self): if self.is_empty(): raise IndexError(\\"Stack is empty\\") return self.items.pop() def peek(self): if self.is_empty(): raise IndexError(\\"Stack is empty\\") return self.items[-1] def size(self): return len(self.items)"},{"question":"You are given a description of a machine that processes input strings to determine whether they should be accepted or rejected based on a predefined set of rules. This machine operates as a Deterministic Finite Automaton (DFA). # Task Write a function `DFA(transitions, start, final, string)` where: * `transitions` is a dictionary where each key is a state, and its corresponding value is another dictionary mapping input characters to next states. * `start` is the state where the DFA starts. * `final` is a list of accepting states. * `string` is the input string that the DFA will process. The function should return `True` if the DFA accepts the string (i.e., ends in one of the accepting states), and `False` otherwise. # Input and Output Format * **Input:** - `transitions`: A dictionary representing the transition function `{state: {character: next_state}}` - `start`: An initial state (a string). - `final`: A list of accepting states (list of strings). - `string`: The input string to be processed (a string). * **Output:** - Returns `True` if the input string is accepted by the DFA, `False` otherwise. # Example **Input:** ```python transitions = { \'q0\': {\'a\': \'q1\', \'b\': \'q2\'}, \'q1\': {\'a\': \'q0\', \'b\': \'q1\'}, \'q2\': {\'a\': \'q2\', \'b\': \'q1\'} } start = \'q0\' final = [\'q1\'] string = \\"ab\\" ``` **Output:** `True` # Constraints * The DFA can have up to 100 states. * The input string\'s length will not exceed 1000 characters. * Each state transition dictionary will only contain valid transition characters, and all characters in the input string will be included in the transition maps provided.","solution":"def DFA(transitions, start, final, string): Determines if a given string is accepted by the DFA. :param transitions: Dictionary representing state transitions :param start: Initial state :param final: List of accepting states :param string: Input string to be processed by the DFA :return: True if the input string is accepted by the DFA, False otherwise current_state = start for char in string: if char in transitions[current_state]: current_state = transitions[current_state][char] else: return False return current_state in final"},{"question":"# Question: Matrix Manipulator Function **Scenario**: You are hired by a game development company to help with processing game boards. One crucial step in their game mechanics involves transforming the board\'s state represented as 2D matrices. They require a new function that can perform not only the rotations and inversions provided but also flipping the matrix horizontally and vertically. # Objective: Write a function `matrix_transform(matrix, operation)` that takes in a 2D list `matrix` and a string `operation`. The `operation` can be one of the following: - \\"rotate_clockwise\\" - \\"rotate_counterclockwise\\" - \\"top_left_invert\\" - \\"bottom_left_invert\\" - \\"flip_horizontal\\" - \\"flip_vertical\\" # Input: - `matrix`: List of lists where each inner list represents a row of the matrix. - `operation`: A string representing the operation to be performed. # Output: - The function should return a new matrix (list of lists) that results from applying the specified operation. # Constraints: - The dimensions of the matrix (n x m) will be such that 1 ≤ n, m ≤ 100. - Elements in matrix can be any integer. - Ensure that the function handles edge cases such as empty matrices or non-square matrices gracefully. # Examples: ```python matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9], ] assert matrix_transform(matrix, \\"rotate_clockwise\\") == [ [7, 4, 1], [8, 5, 2], [9, 6, 3], ] assert matrix_transform(matrix, \\"flip_horizontal\\") == [ [3, 2, 1], [6, 5, 4], [9, 8, 7], ] ``` **Hint**: Consider leveraging the existing definitions for similar operations, but ensure the new transformations are implemented correctly within the `matrix_transform` function. # Testing: Your implementation will be tested against several test cases, including: - Standard 3x3 matrices - Edge cases with empty matrices - Non-square matrices (e.g., 3x2 or 2x3) - Single row or column matrices Good luck!","solution":"def matrix_transform(matrix, operation): n = len(matrix) if n == 0: return matrix m = len(matrix[0]) def rotate_clockwise(mat): return [[mat[n - j - 1][i] for j in range(n)] for i in range(m)] def rotate_counterclockwise(mat): return [[mat[j][m - i - 1] for j in range(n)] for i in range(m)] def top_left_invert(mat): return [[-1 * mat[i][j] if i <= j else mat[i][j] for j in range(m)] for i in range(n)] def bottom_left_invert(mat): return [[-1 * mat[i][j] if i + j >= n - 1 else mat[i][j] for j in range(m)] for i in range(n)] def flip_horizontal(mat): return [row[::-1] for row in mat] def flip_vertical(mat): return mat[::-1] operations = { \\"rotate_clockwise\\": rotate_clockwise, \\"rotate_counterclockwise\\": rotate_counterclockwise, \\"top_left_invert\\": top_left_invert, \\"bottom_left_invert\\": bottom_left_invert, \\"flip_horizontal\\": flip_horizontal, \\"flip_vertical\\": flip_vertical } return operations[operation](matrix)"},{"question":"# Coding Challenge: Efficient String Merge Sort **Context**: You are working on optimizing a text processing application that frequently needs to sort large lists of strings. To handle this efficiently, you decide to implement the merge sort algorithm tailored for strings. **Task**: Implement a function `merge_sort_strings` that uses the merge sort algorithm to sort a list of strings in ascending alphabetical order. **Function Signature**: ```python def merge_sort_strings(arr: List[str]) -> List[str]: ``` **Input**: - A list of strings `arr` with length `n` (0 ≤ n ≤ 100000). **Output**: - A new list sorted in ascending alphabetical order. **Constraints**: - The function should be efficient, with a time complexity of O(n log(n)) and a space complexity of O(n). - String comparisons should be case-insensitive (i.e., \\"apple\\" and \\"Apple\\" should be considered equal). **Edge Cases**: - Handle lists that are empty or contain a single string. - Strings may contain spaces and special characters. - All string comparisons should ignore case differences. **Examples**: ```python assert merge_sort_strings([\\"apple\\", \\"Orange\\", \\"banana\\", \\"grape\\"]) == [\\"apple\\", \\"banana\\", \\"grape\\", \\"Orange\\"] assert merge_sort_strings([\\"Apple\\", \\"orange\\"]) == [\\"apple\\", \\"orange\\"] assert merge_sort_strings([]) == [] assert merge_sort_strings([\\"Zebra\\", \\"elephant\\", \\"Apple\\", \\"dEer\\"]) == [\\"Apple\\", \\"dEer\\", \\"elephant\\", \\"Zebra\\"] ``` **Implementation Requirements**: - You are required to implement the `merge_sort_strings` function using a recursive approach. - Ensure all the string comparisons are case-insensitive using helper functions as needed.","solution":"from typing import List def merge_sort_strings(arr: List[str]) -> List[str]: Sorts a list of strings in ascending alphabetical order using merge sort algorithm. :param arr: List of strings to be sorted. :return: A new list of sorted strings. if len(arr) <= 1: return arr def merge(left: List[str], right: List[str]) -> List[str]: result = [] i = j = 0 while i < len(left) and j < len(right): if left[i].lower() <= right[j].lower(): result.append(left[i]) i += 1 else: result.append(right[j]) j += 1 # Collect remaining elements result.extend(left[i:]) result.extend(right[j:]) return result mid = len(arr) // 2 left = merge_sort_strings(arr[:mid]) right = merge_sort_strings(arr[mid:]) return merge(left, right)"},{"question":"# Minimum Spanning Tree with Prim\'s Algorithm **Context**: You are tasked with designing a communication network connecting several cities with the minimum possible total cable length. Each connection (cable) has a certain length associated with it. # Problem Function Implementation Write a function `prims_minimum_spanning(graph)` that takes in an undirected weighted graph represented as a dictionary and returns the total weight of the Minimum Spanning Tree (MST). Input Format - `graph`: A dictionary where each key is a node, and the associated value is a list of lists. Each inner list represents an edge where the first element is the weight of the edge and the second element is the connected node. Example: ```python graph = { \'a\': [ [3, \'b\'], [8, \'c\'] ], \'b\': [ [3, \'a\'], [5, \'d\'] ], \'c\': [ [8, \'a\'], [2, \'d\'], [4, \'e\'] ], \'d\': [ [5, \'b\'], [2, \'c\'], [6, \'e\'] ], \'e\': [ [4, \'c\'], [6, \'d\'] ] } ``` Output Format - Return an integer representing the total weight of the MST. Constraints - The graph is connected. - Each edge weight is a positive integer. - No parallel edges (no two edges have the same vertices). # Example ```python def prims_minimum_spanning(graph): import heapq vis = [] heap = [[0, next(iter(graph))]] prim = set() mincost = 0 while heap: cost, node = heapq.heappop(heap) if node in vis: continue mincost += cost prim.add(node) vis.append(node) for distance, adjacent in graph[node]: if adjacent not in vis: heapq.heappush(heap, [distance, adjacent]) return mincost # Example Usage graph = { \'a\': [ [3, \'b\'], [8, \'c\'] ], \'b\': [ [3, \'a\'], [5, \'d\'] ], \'c\': [ [8, \'a\'], [2, \'d\'], [4, \'e\'] ], \'d\': [ [5, \'b\'], [2, \'c\'], [6, \'e\'] ], \'e\': [ [4, \'c\'], [6, \'d\'] ] } print(prims_minimum_spanning(graph)) # Output: 14 ``` Notes - Ensure that your implementation handles diverse test cases, including graphs with only one node, graphs with uniform weights, and graphs with various sizes. - Evaluate your implementation for time and memory efficiency, and ensure it appropriately manages the priority queue.","solution":"import heapq def prims_minimum_spanning(graph): Function to compute the total weight of the Minimum Spanning Tree (MST) using Prim\'s algorithm from a given undirected weighted graph. :param graph: Dictionary representing the graph where keys are nodes and values are lists of [weight, node] pairs representing the edges. :return: Integer representing the total weight of the MST. # If the graph is empty, return zero weight if not graph: return 0 # Choose an arbitrary starting node start_node = next(iter(graph)) # Min-heap to store the edges with corresponding weights min_heap = [[0, start_node]] # Set to keep track of visited nodes visited = set() # Variable to keep track of the total cost of the MST total_weight = 0 while min_heap: # Pop the smallest weight edge from heap weight, current_node = heapq.heappop(min_heap) # If the current node has already been visited, skip it if current_node in visited: continue # Add the weight to the total cost total_weight += weight visited.add(current_node) # Look at all the neighbors of the current node for edge_weight, neighbor in graph[current_node]: if neighbor not in visited: # If the neighbor hasn\'t been visited, push the edge to the heap heapq.heappush(min_heap, [edge_weight, neighbor]) # Return the total weight of the MST return total_weight"},{"question":"# Question: Binary Tree Operations You are given a binary tree. Your task is to implement two functions to determine the minimum depth of the tree and to print all elements in the tree. Function 1: `min_depth` **Definition**: Implement a function `min_depth(root: TreeNode) -> int` that calculates the minimum depth of a binary tree using a recursive approach. * **Input**: The function takes a single argument - the root node of the binary tree. * **Output**: It returns an integer representing the minimum depth of the tree. Function 2: `print_tree` **Definition**: Implement a function `print_tree(root: TreeNode) -> None` that prints all nodes of a binary tree using pre-order traversal. * **Input**: The function takes a single argument - the root node of the binary tree. * **Output**: It does not return a value. Instead, it prints the value of each node to the standard output, one per line. # Constraints and Notes: * You may assume that the tree nodes follow the class definition: ```python class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None ``` # Example: ```python # Tree structure: # 3 # / # 9 20 # / # 15 7 root = TreeNode(3) root.left = TreeNode(9) root.right = TreeNode(20) root.right.left = TreeNode(15) root.right.right = TreeNode(7) print(min_depth(root)) # Output: 2 print_tree(root) # Expected Output: # 3 # 9 # 20 # 15 # 7 ``` Implement these functions as specified, paying special attention to handling edge cases and optimizing performance where necessary.","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def min_depth(root): Returns the minimum depth of a binary tree where depth is defined as the number of nodes along the shortest path from the root node down to the nearest leaf node. if root is None: return 0 if not root.left and not root.right: return 1 if not root.left: return min_depth(root.right) + 1 if not root.right: return min_depth(root.left) + 1 return min(min_depth(root.left), min_depth(root.right)) + 1 def print_tree(root): Prints the values of the nodes in a binary tree using pre-order traversal. if root is None: return print(root.val) print_tree(root.left) print_tree(root.right)"},{"question":"You are given an array of integers that need to be sorted in non-decreasing order using an exotic sorting algorithm known as Stooge Sort. # Function Signature ```python def stoogesort(arr: List[int]) -> None: # Your code here ``` # Input - An array `arr` of integers, where `1 <= len(arr) <= 500`, and each integer `-10^3 <= arr[i] <= 10^3`. # Output - The function should modify the array `arr` in place to have its elements sorted in non-decreasing order. # Constraints - The array should be sorted using the Stooge Sort algorithm. - The function should handle edge cases such as an empty array or an array with identical elements gracefully. # Example ```python arr = [2, 4, 5, 3, 1] stoogesort(arr) print(arr) # Output: [1, 2, 3, 4, 5] arr = [7, 3, 8] stoogesort(arr) print(arr) # Output: [3, 7, 8] arr = [5] stoogesort(arr) print(arr) # Output: [5] ``` # Additional Notes: - Focus on correctly implementing the Stooge Sort algorithm as outlined in the principles and ensure that you respect array bounds to avoid indexing errors. - There will be no explicit return from the function as the array should be sorted in place.","solution":"from typing import List def stoogesort(arr: List[int], l: int, h: int) -> None: Sorts an array using the Stooge Sort algorithm recursively. The function modifies the array in place. Parameters: arr (List[int]): The array to be sorted. l (int): The starting index of the array to be sorted. h (int): The ending index of the array to be sorted. if l >= h: return # Swap if elements are out of order if arr[l] > arr[h]: arr[l], arr[h] = arr[h], arr[l] # More than two elements if h - l + 1 > 2: t = (h - l + 1) // 3 stoogesort(arr, l, h - t) stoogesort(arr, l + t, h) stoogesort(arr, l, h - t) def sort_array(arr: List[int]) -> None: A helper function to sort the array using the Stooge Sort algorithm. Parameters: arr (List[int]): The array to be sorted. stoogesort(arr, 0, len(arr) - 1)"},{"question":"Context You are given a task to develop an expression builder algorithm. Your task is to generate all possible expressions by adding binary operators (+, -, or *) between the digits of a given string of digits that evaluate to a given target value. Problem Statement **Function Signature**: ```python def add_operators(num: str, target: int) -> List[str]: pass ``` **Expected Input/Output**: - **Input**: - `num` (string): A non-empty string consisting only of digits (0-9). - `target` (integer): An integer target value. - **Output**: - A list of strings where each string is an expression that evaluates to the target value. **Constraints**: - The length of `num` will be ≤ 10. - The target value is an integer. Example ```python add_operators(\\"123\\", 6) # Output: [\\"1+2+3\\", \\"1*2*3\\"] add_operators(\\"232\\", 8) # Output: [\\"2*3+2\\", \\"2+3*2\\"] add_operators(\\"105\\", 5) # Output: [\\"1*0+5\\", \\"10-5\\"] add_operators(\\"00\\", 0) # Output: [\\"0+0\\", \\"0-0\\", \\"0*0\\"] add_operators(\\"3456237490\\", 9191) # Output: [] ``` # Requirements: 1. Implement the function `add_operators` to find all possible ways to add binary operators +, -, or * between the digits in the string `num` such that the resultant expression evaluates to `target`. 2. Ensure your solution accounts for edge cases like strings with leading zeroes. 3. Your solution should be able to handle the constraints efficiently. 4. You are expected to write clean, readable, and optimized code.","solution":"from typing import List def add_operators(num: str, target: int) -> List[str]: result = [] def backtrack(expression, prev_operand, current_operand, value, index): if index == len(num): if value == target and current_operand == 0: result.append(\\"\\".join(expression[1:])) # to skip the first empty string(\\"\\") element return current_operand = current_operand * 10 + int(num[index]) str_op = str(current_operand) if current_operand > 0: backtrack(expression, prev_operand, current_operand, value, index + 1) expression.append(\'+\') expression.append(str_op) backtrack(expression, current_operand, 0, value + current_operand, index + 1) expression.pop() expression.pop() if len(expression) > 0: expression.append(\'-\') expression.append(str_op) backtrack(expression, -current_operand, 0, value - current_operand, index + 1) expression.pop() expression.pop() expression.append(\'*\') expression.append(str_op) backtrack(expression, current_operand * prev_operand, 0, value - prev_operand + (current_operand * prev_operand), index + 1) expression.pop() expression.pop() backtrack([], 0, 0, 0, 0) return result"},{"question":"# ZigZag Iterator for Multiple Lists Scenario: You are given multiple lists of integers and you need to create a `ZigZagIterator` that iterates through these lists in a round-robin manner until all the lists are exhausted. This means that for lists `l1`, `l2`, ..., `ln`, the iterator should output the first element of `l1`, then the first element of `l2`, ..., then the first element of `ln`, then the second element of `l1`, and so on, skipping any lists that are already exhausted. Requirements: You need to implement a `ZigZagIterator` class with the following methods: - `__init__(self, lists: List[List[int]])`: Initializes the iterator with a list of lists. - `next(self) -> int`: Returns the next integer in the interleaved sequence. - `has_next(self) -> bool`: Returns `True` if there are more integers to iterate over, otherwise returns `False`. Example: ```python l1 = [1, 2] l2 = [3, 4, 5, 6] l3 = [7, 8, 9] it = ZigZagIterator([l1, l2, l3]) result = [] while it.has_next(): result.append(it.next()) print(result) # Should print [1, 3, 7, 2, 4, 8, 5, 9, 6] ``` Constraints: - The lists will contain integers with varying lengths, including possibly being empty. - You are expected to handle up to 10^3 integers spread across the lists efficiently. **Function Signature**: ```python class ZigZagIterator: def __init__(self, lists: List[List[int]]): pass def next(self) -> int: pass def has_next(self) -> bool: pass ``` Complete the `ZigZagIterator` class implementation as described above.","solution":"from typing import List class ZigZagIterator: def __init__(self, lists: List[List[int]]): self.queue = [] for i, lst in enumerate(lists): if lst: self.queue.append((i, 0)) self.lists = lists def next(self) -> int: if not self.has_next(): raise Exception(\\"No more elements\\") list_index, element_index = self.queue.pop(0) value = self.lists[list_index][element_index] if element_index + 1 < len(self.lists[list_index]): self.queue.append((list_index, element_index + 1)) return value def has_next(self) -> bool: return len(self.queue) > 0"},{"question":"# Hailstone Sequence Convergence Length Description The hailstone sequence, starting from any positive integer ( n ), produces a sequence by repeatedly applying the rules: * If ( n ) is even, the next term is ( n/2 ). * If ( n ) is odd, the next term is ( 3n + 1 ). The sequence inevitably results in the number 1, according to the Collatz Conjecture. Write a function `hailstone_convergence_length(n: int) -> int` that returns the number of terms in the sequence from ( n ) to 1, inclusive. Function Signature ```python def hailstone_convergence_length(n: int) -> int: pass ``` Input * An integer ( n ) where ( 1 leq n leq 10^6 ). Output * An integer representing the number of terms in the hailstone sequence starting from ( n ) and ending at 1. Example ```python assert hailstone_convergence_length(6) == 9 # Explanation: Sequence is 6, 3, 10, 5, 16, 8, 4, 2, 1 # Length is 9 assert hailstone_convergence_length(1) == 1 # Explanation: Sequence is 1 # Length is 1 assert hailstone_convergence_length(19) == 21 # Explanation: Sequence is 19, 58, 29, 88, 44, 22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1 # Length is 21 ``` Constraints * Aim for optimized performance, bearing in mind the wide range ( 1 leq n leq 10^6 ).","solution":"def hailstone_convergence_length(n: int) -> int: count = 1 while n != 1: if n % 2 == 0: n //= 2 else: n = 3 * n + 1 count += 1 return count"},{"question":"# Unique Single Number Finder Problem Statement You are given an array of integers where every element appears exactly three times, except for one element which appears exactly once. Write a function that finds and returns the element that appears only once. Your solution should have a linear runtime complexity (O(n)) and should not use extra memory (O(1) space complexity). You are encouraged to use bit manipulation to achieve these constraints. Function Signature ```python def find_unique_number(nums: List[int]) -> int: pass ``` Input * `nums`: List[int] - an array of integers, where every element appears exactly three times except for one integer that appears exactly once. * The length of `nums` will be in the range [1, 10^4] Output * Returns the integer that appears exactly once. Constraints * The algorithm must have O(n) time complexity. * Cannot use extra memory - constant additional space O(1). Example ```python assert find_unique_number([2, 2, 3, 2]) == 3 assert find_unique_number([0, 1, 0, 1, 0, 1, 99]) == 99 ``` Edge Cases * Arrays containing the maximum or minimum integer values. Scenario Imagine you are working on a data processing system that receives a stream of data where most of the data points are logged in triplicate, except for a few unique identifiers that should be tracked. You need to implement a solution that efficiently identifies these unique identifiers without consuming extensive memory resources.","solution":"def find_unique_number(nums): Finds the element that appears exactly once in an array where every other element appears exactly three times. Args: nums (List[int]): List of integers where every element appears three times except for one which appears once. Returns: int: The element that appears exactly once. ones, twos = 0, 0 for num in nums: # \\"ones & num\\" gives the bits that are there in both \'ones\' and the new number \'num\'. # We add these bits to \'twos\' using a bitwise OR twos |= ones & num # XOR the new bits with \'ones\' (flips bits in ones where num has bits) ones ^= num # common_bit_mask will have those bits set which are appearing 3 times. common_bit_mask = ~(ones & twos) # Remove bits which are appearing 3 times from \'ones\' ones &= common_bit_mask # Remove bits which are appearing 3 times from \'twos\' twos &= common_bit_mask return ones"},{"question":"# Question You are given a graph as an adjacency list, where the keys are node identifiers and the values are lists of nodes that can be directly reached from the key node. Your task is to implement a function that finds the longest path between two given nodes. The longest path is defined as the path with the maximum number of edges between the start and end nodes without traversing any node more than once. Write a function `find_longest_path(graph: dict, start: str, end: str) -> list` that returns the longest path from the `start` node to the `end` node. If there are multiple paths of the same length, return any one of them. If no path exists, return an empty list. Constraints - All node identifiers are unique. - The graph does not contain self-loops. - The graph may be disconnected, meaning there might be nodes that cannot be reached from others. Input - `graph`: A dictionary representing the adjacency list of the graph. - `start`: A string representing the starting node. - `end`: A string representing the ending node. Output - A list representing the nodes in the longest path from `start` to `end`. If no path exists, return an empty list. Example ```python graph = { \'A\': [\'B\', \'C\'], \'B\': [\'D\'], \'C\': [\'E\'], \'D\': [\'E\', \'F\'], \'E\': [\'F\'], \'F\': [] } print(find_longest_path(graph, \'A\', \'F\')) # Possible Output: [\'A\', \'B\', \'D\', \'E\', \'F\'] ``` # Guidelines - Ensure you handle edge cases such as cycles and disconnected nodes. - Aim for a solution that is clear and avoid unnecessary complexity.","solution":"def find_longest_path(graph, start, end): def dfs(node, path, visited): visited.add(node) path.append(node) # If end node is reached if node == end: nonlocal longest_path if len(path) > len(longest_path): longest_path = path[:] for neighbor in graph.get(node, []): if neighbor not in visited: dfs(neighbor, path, visited) # Backtracking path.pop() visited.remove(node) longest_path = [] dfs(start, [], set()) return longest_path"},{"question":"# Problem Description Given a string `s`, write a function to reverse it. You are required to implement the following methods to reverse the string: 1. **Recursive Method**: `recursive_reverse(s)` 2. **Iterative Method**: `iterative_reverse(s)` 3. **Pythonic Method**: `pythonic_reverse(s)` 4. **Ultra-Pythonic Method**: `ultra_pythonic_reverse(s)` # Function Definitions 1. **recursive_reverse(s)**: - Input: A string `s`. - Output: The reversed string. 2. **iterative_reverse(s)**: - Input: A string `s`. - Output: The reversed string. 3. **pythonic_reverse(s)**: - Input: A string `s`. - Output: The reversed string. 4. **ultra_pythonic_reverse(s)**: - Input: A string `s`. - Output: The reversed string. # Constraints - The string `s` can have a length between 0 and 10^6. - The string `s` will contain only ASCII characters. # Examples 1. **Input**: ``` s = \\"hello\\" ``` **Output**: ``` \\"olleh\\" ``` 2. **Input**: ``` s = \\"A man, a plan, a canal, Panama\\" ``` **Output**: ``` \\"amanaP ,lanac a ,nalp a ,nam A\\" ``` 3. **Input**: ``` s = \\"\\" ``` **Output**: ``` \\"\\" ``` # Additional Notes - Optimize for time and space complexity as much as possible. - Handle all edge cases such as empty strings and single-character strings effectively. - Ensure your iterative solution does not use additional memory unnecessarily.","solution":"def recursive_reverse(s): Recursively reverses a string. if s == \\"\\": return s else: return recursive_reverse(s[1:]) + s[0] def iterative_reverse(s): Iteratively reverses a string. reversed_str = \\"\\" for char in s: reversed_str = char + reversed_str return reversed_str def pythonic_reverse(s): Reverses a string using Python\'s slicing mechanism. return s[::-1] def ultra_pythonic_reverse(s): Reverses a string using Python\'s built-in reversed() function and join method. return \'\'.join(reversed(s))"},{"question":"# Task: You are tasked with implementing a function `generate_abbr` that generates all possible abbreviations for a given word. The function should use a backtracking approach to ensure all potential abbreviations are explored. # Function Signature: ```python def generate_abbr(word: str) -> list: pass ``` # Input: * `word`: A string of length between 1 and 10 (inclusive), consisting of only lowercase English letters. # Output: * A list of strings representing all possible abbreviations of the input word. # Examples: ```python assert generate_abbr(\\"word\\") == [\\"word\\", \\"wor1\\", \\"wo1d\\", \\"wo2\\", \\"w1rd\\", \\"w1r1\\", \\"w2d\\", \\"w3\\", \\"1ord\\", \\"1or1\\", \\"1o1d\\", \\"1o2\\", \\"2rd\\", \\"2r1\\", \\"3d\\", \\"4\\"] assert generate_abbr(\\"a\\") == [\\"a\\", \\"1\\"] assert generate_abbr(\\"ab\\") == [\\"ab\\", \\"a1\\", \\"1b\\", \\"2\\"] ``` # Constraints: * The word will contain only lowercase English letters. * The length of the word will be at least 1 and at most 10. You should aim to implement this function with consideration of both time and space complexity, recognizing the potential exponential growth based on input length. Note edge cases and ensure your function handles them appropriately.","solution":"def generate_abbr(word: str) -> list: result = [] def backtrack(pos, cur, count): if pos == len(word): if count > 0: cur += str(count) result.append(cur) return # Option 1: Skip the current character (increase count) backtrack(pos + 1, cur, count + 1) # Option 2: Add the current character if count > 0: cur += str(count) backtrack(pos + 1, cur + word[pos], 0) backtrack(0, \\"\\", 0) return result"},{"question":"You are tasked with creating a function that reverses the order of characters in each word of a given string, while maintaining the order of the words. The input string will only contain alphabetic characters and spaces. # Function Signature ```python def reverse_characters_in_words(s: str) -> str: pass ``` # Input - `s (str)`: A non-empty string of length up to 10^4, consisting only of lowercase alphabetic characters and spaces. # Output - Returns a string where each word\'s characters are reversed, but the word order remains unchanged. # Example ```python input: \\"I am keon kim and I like pizza\\" output: \\"I ma noek mik dna I ekil azzip\\" input: \\"hello world\\" output: \\"olleh dlrow\\" input: \\"python is fun\\" output: \\"nohtyp si nuf\\" ``` # Constraints 1. Ensure the function is efficient and optimally handles the input size. 2. The function should handle leading, trailing, and multiple intermediate spaces correctly: - Input: `\\" hello world \\"` - Output: `\\" olleh dlrow \\"` # Hints 1. You may use Python\'s string methods to help split and join strings. 2. Consider defining a helper function to reverse characters in each word.","solution":"def reverse_characters_in_words(s: str) -> str: Reverse the order of characters in each word of the given string, while maintaining the order of the words. words = s.split(\' \') reversed_words = [word[::-1] for word in words] return \' \'.join(reversed_words)"},{"question":"**Insertion Sort with Binary Search Optimization** You are required to implement a modified version of the Insertion Sort algorithm that uses a binary search to find the correct insertion point of an element. This approach optimizes the searching part of the Insertion Sort but still requires shifting elements. Problem Statement You are given an unsorted list of integers. Your task is to sort this list using the Insertion Sort algorithm. To optimize the insertion process, you should use the provided `search_insert` function to determine the correct position to insert each element. Function Signature ```python def insertion_sort(nums: List[int]) -> List[int]: ``` Input - A list of integers `nums` where 1 <= nums.length <= 10^4 and -10^5 <= nums[i] <= 10^5. Output - A list of integers sorted in non-descending order. Constraints - The input list can contain duplicate elements. - Maintain the stability of the sorting algorithm. - Optimize the insertion process using binary search. Example ```python Input: [4, 2, 7, 1, 9, 3] Output: [1, 2, 3, 4, 7, 9] Input: [10, 20, 5, 15] Output: [5, 10, 15, 20] ``` Notes - You should use the provided `search_insert` function within your `insertion_sort` implementation. - Focus on correct implementation and efficiency within the given constraints.","solution":"from typing import List def search_insert(nums: List[int], x: int, low: int, high: int) -> int: A helper function that uses binary search to find the index where x should be inserted in the list nums between indexes low and high. while low < high: mid = (low + high) // 2 if nums[mid] < x: low = mid + 1 else: high = mid return low def insertion_sort(nums: List[int]) -> List[int]: Sorts a list of integers using insertion sort with binary search optimization. for i in range(1, len(nums)): key = nums[i] insert_position = search_insert(nums, key, 0, i) nums = nums[:insert_position] + [key] + nums[insert_position:i] + nums[i+1:] return nums"},{"question":"# Question You are given two binary strings `a` and `b`. Your task is to write a function `add_binary(a: str, b: str) -> str` that returns their sum as a binary string. Function Signature ```python def add_binary(a: str, b: str) -> str: ``` # Input * `a`: A string representing a binary number (1 ≤ length of `a` ≤ 10^4). * `b`: A string representing a binary number (1 ≤ length of `b` ≤ 10^4). # Output * Returns a string representing the binary sum of `a` and `b`. # Constraints * The input strings `a` and `b` are non-empty and contain only the characters `\'0\'` and `\'1\'`. # Performance Requirements * The implementation should run in O(max(n, m)) time complexity where `n` and `m` are the lengths of `a` and `b` respectively. * The implementation should use O(max(n, m)) additional space. # Context Imagine you are working on a basic calculator for binary numbers. One of the core functionalities is to add two binary numbers and return their sum as another binary number. This function will play a critical role in the binary calculator. Example ```python a = \\"1010\\" b = \\"1011\\" print(add_binary(a, b)) # Output: \\"10101\\" a = \\"11\\" b = \\"1\\" print(add_binary(a, b)) # Output: \\"100\\" ``` Implement the `add_binary` function that performs this operation correctly and efficiently.","solution":"def add_binary(a: str, b: str) -> str: Returns the binary sum of two binary strings a and b. # Initialize the result string and carry result = [] carry = 0 # Pad the shorter string with zeros max_len = max(len(a), len(b)) a = a.zfill(max_len) b = b.zfill(max_len) # Traverse both strings from the end towards the beginning for i in range(max_len - 1, -1, -1): total = carry total += int(a[i]) total += int(b[i]) # Append the sum of both bits and carry to the result result.append(str(total % 2)) carry = total // 2 # If there\'s any carry left, append it to the result if carry: result.append(str(carry)) # The result is appended in reverse order, so reverse it result.reverse() return \'\'.join(result)"},{"question":"**Title**: Kruskal’s Algorithm Implementation **Description**: You are given an undirected, connected, weighted graph represented by its number of vertices (V) and edges (E). You are required to implement Kruskal\'s algorithm to find the Minimum Spanning Tree (MST). The graph\'s vertices are indexed from 0 to (V-1). **Input**: - The first line contains two integers (V) (number of vertices) and (E) (number of edges). - The next (E) lines each contain three integers (u), (v), and (w), representing an edge between vertices (u) and (v) with weight (w). **Output**: - Print a single integer representing the sum of the weights of all edges in the MST. **Constraints**: - (1 leq V leq 1000) - (V-1 leq E leq V(V-1)/2) - The graph might have multiple edges and self-loops should be ignored. - Weights ((w)) are positive integers and will not be greater than (10^6). **Example**: ``` Input: 4 5 0 1 10 0 2 6 0 3 5 1 3 15 2 3 4 Output: 19 ``` In this example, the MST consists of edges with weights 4, 5, and 10, resulting in a total weight of 19. **Guidelines**: - Implement Kruskal’s algorithm as described in the analysis. - Use the provided structure for Edge and DisjointSet classes. - Ensure your solution handles all possible edge cases and performs efficiently within the given constraints.","solution":"class DisjointSet: def __init__(self, n): self.parent = list(range(n)) self.rank = [0] * n def find(self, u): if self.parent[u] != u: self.parent[u] = self.find(self.parent[u]) return self.parent[u] def union(self, u, v): root_u = self.find(u) root_v = self.find(v) if root_u != root_v: if self.rank[root_u] > self.rank[root_v]: self.parent[root_v] = root_u elif self.rank[root_u] < self.rank[root_v]: self.parent[root_u] = root_v else: self.parent[root_v] = root_u self.rank[root_u] += 1 def kruskal(V, edges): edges.sort(key=lambda edge: edge[2]) disjoint_set = DisjointSet(V) mst_weight = 0 num_edges_in_mst = 0 for u, v, w in edges: if disjoint_set.find(u) != disjoint_set.find(v): disjoint_set.union(u, v) mst_weight += w num_edges_in_mst += 1 if num_edges_in_mst == V - 1: break return mst_weight"},{"question":"# Stack ADT Implementation and Applications You have been given the implementation of a Stack Abstract Data Type (ADT) using both an array (`ArrayStack`) and a linked list (`LinkedListStack`). Implement additional functionality and solve a real-world problem using these stacks. Task 1: Implement a Balanced Parentheses Checker Write a function `is_balanced(expression: str, stack_type: str) -> bool` that checks if the parentheses in a given expression are balanced. The function should use the specified stack type (`array` for `ArrayStack`, `linked_list` for `LinkedListStack`) to do so. **Input:** - `expression`: A string consisting of characters including \'(\', \')\', \'{\', \'}\', \'[\' and \']\'. - `stack_type`: A string either `\'array\'` or `\'linked_list\'` specifying which type of stack implementation to use, `ArrayStack` or `LinkedListStack`. **Output:** - Return `True` if the parentheses are balanced, otherwise return `False`. **Constraints:** - The length of the expression will not exceed 10^3 characters. - Assume the input expression only consists of the specified characters. **Example:** ```python is_balanced(\\"({[]})\\", \\"array\\") # Returns True is_balanced(\\"({[)]}\\", \\"linked_list\\") # Returns False ``` Task 2: Implement a Restricted Queue Using Stacks Write a class `QueueUsingStacks` that uses two stacks to implement a queue. The class should support the following operations: - `enqueue(item)`: Add an item to the end of the queue. - `dequeue()`: Remove the item from the front of the queue and return it. **Input:** - `item` for the `enqueue` function is an integer. **Output:** - The `dequeue` function returns an integer. **Example:** ```python queue = QueueUsingStacks(\\"array\\") queue.enqueue(1) queue.enqueue(2) print(queue.dequeue()) # Outputs 1 print(queue.dequeue()) # Outputs 2 ``` **Constraints:** - The queue operations must use a `stack_type` parameter to initialize the underlying stacks (`array` or `linked_list`). - The maximum number of items you can enqueue/dequeue will not exceed 10^3. **Notes:** - Ensure your implementation handles edge cases such as empty stack operations gracefully. - Provide comments explaining the logic behind your implementation.","solution":"class ArrayStack: def __init__(self): self.stack = [] def push(self, item): self.stack.append(item) def pop(self): if not self.is_empty(): return self.stack.pop() return None def is_empty(self): return len(self.stack) == 0 class LinkedListStack: class Node: def __init__(self, value): self.value = value self.next = None def __init__(self): self.head = None def push(self, item): new_node = self.Node(item) new_node.next = self.head self.head = new_node def pop(self): if not self.is_empty(): value = self.head.value self.head = self.head.next return value return None def is_empty(self): return self.head is None def is_balanced(expression: str, stack_type: str) -> bool: if stack_type == \'array\': stack = ArrayStack() elif stack_type == \'linked_list\': stack = LinkedListStack() else: raise ValueError(\\"Invalid stack type\\") matching_parentheses = {\')\': \'(\', \'}\': \'{\', \']\': \'[\'} for char in expression: if char in matching_parentheses.values(): stack.push(char) elif char in matching_parentheses: if stack.is_empty() or stack.pop() != matching_parentheses[char]: return False return stack.is_empty() class QueueUsingStacks: def __init__(self, stack_type: str): if stack_type == \'array\': self.stack1 = ArrayStack() self.stack2 = ArrayStack() elif stack_type == \'linked_list\': self.stack1 = LinkedListStack() self.stack2 = LinkedListStack() else: raise ValueError(\\"Invalid stack type\\") def enqueue(self, item): self.stack1.push(item) def dequeue(self): if self.stack2.is_empty(): while not self.stack1.is_empty(): self.stack2.push(self.stack1.pop()) return self.stack2.pop()"},{"question":"Context You are tasked with developing a function to improve the efficiency of linked list operations for a large dataset. Specifically, you need to implement an optimized solution for removing duplicate values from a singly linked list. Task Implement a function `remove_dups_optimized(head: Node) -> Node` that removes duplicate values from a singly linked list. You must not use any additional structures like sets or arrays that use extra space other than standard pointer manipulation. Function Signature ```python class Node: def __init__(self, val=None): self.val = val self.next = None def remove_dups_optimized(head: Node) -> Node: # your code here ``` Input - `head: Node` - The head node of the singly linked list where each node contains a `val`. Output - The function should modify the linked list in-place and return the head of the modified list with duplicates removed. Constraints - You cannot use additional data structures like arrays or sets. - The linked list may contain up to 10^4 nodes. - Node values are assumed to be integers. Example ```python # Example Linked List: 1 -> 2 -> 2 -> 3 -> 4 -> 4 -> 5 # Create nodes a = Node(1) b = Node(2) c = Node(2) d = Node(3) e = Node(4) f = Node(4) g = Node(5) # Link nodes a.next = b b.next = c c.next = d d.next = e e.next = f f.next = g # Call the function new_head = remove_dups_optimized(a) # Output Linked List: 1 -> 2 -> 3 -> 4 -> 5 ``` Notes - Ensure your solution runs efficiently without exceeding the available memory. - Carefully handle the pointer manipulations to avoid breaking the list. - Consider edge cases like an empty list, lists with a single element, and all elements being the same.","solution":"class Node: def __init__(self, val=None): self.val = val self.next = None def remove_dups_optimized(head: Node) -> Node: if not head: return head current = head while current: runner = current while runner.next: if runner.next.val == current.val: runner.next = runner.next.next else: runner = runner.next current = current.next return head"},{"question":"Implementing and Validating Red-Black Tree Operations Objective You are tasked with implementing a Red-Black Tree and writing additional functions to perform specific operations. Description You will be provided with the Red-Black Tree functionality for insertion and deletion. Your job is to extend its functionality by adding methods to: 1. Find the height of the Red-Black Tree. 2. Validate whether the tree maintains the Red-Black properties after a series of operations. Requirements 1. **Function to Find Tree Height**: * **Input**: None * **Output**: An integer representing the height of the tree (height of an empty tree is 0). 2. **Function to Validate Red-Black Tree Properties**: * **Input**: None * **Output**: A boolean value indicating whether the tree satisfies Red-Black properties. Constraints * Your solution should handle the properties of the Red-Black Trees defined in the provided analysis. * Consider edge cases such as empty trees, single-node trees, and trees with complex balancing. Examples ```python # Assume rb is an instance of RBTree with multiple insertion operations already performed height = rb.find_height() print(height) # should print the height of the tree is_valid = rb.validate_rbtree() print(is_valid) # should print True if the tree is a valid Red-Black Tree, False otherwise ``` Function Signatures ```python def find_height(self) -> int: Implement this method to find the height of the Red-Black Tree. pass def validate_rbtree(self) -> bool: Implement this method to validate if the current tree satisfies Red-Black Tree properties. pass ```","solution":"class Node: def __init__(self, data, color=\'red\', left=None, right=None, parent=None): self.data = data self.color = color self.left = left self.right = right self.parent = parent class RBTree: def __init__(self): self.NIL_LEAF = Node(data=None, color=\'black\') self.root = self.NIL_LEAF def find_height(self): def height_helper(node): if node == self.NIL_LEAF: return 0 left_height = height_helper(node.left) right_height = height_helper(node.right) return max(left_height, right_height) + 1 return height_helper(self.root) def validate_rbtree(self): def is_red_black_node(node): if not node: return True if node.color == \'red\': if node.left.color == \'red\' or node.right.color == \'red\': return False return is_red_black_node(node.left) and is_red_black_node(node.right) def black_height(node): if node == self.NIL_LEAF: return 1 left_black_height = black_height(node.left) right_black_height = black_height(node.right) if left_black_height == 0 or right_black_height == 0 or left_black_height != right_black_height: return 0 return left_black_height + (1 if node.color == \'black\' else 0) if self.root.color != \'black\': return False return is_red_black_node(self.root) and black_height(self.root) > 0 # Additional methods for insertion, deletion, and other operations should be also implemented here"},{"question":"# Markov Chain State Generator You are given an implementation of a Markov chain model in Python. Your task is to extend this functionality by implementing a function that predicts the most likely sequence of states given an initial state and number of steps. Specifically, write a function `predict_sequence` that returns the sequence of predicted states. Function Signature ```python def predict_sequence(chain: dict, initial_state: str, steps: int) -> list: pass ``` Input 1. `chain`: A dictionary representing the Markov chain, where keys are states and values are dictionaries of possible next states with their associated probabilities. 2. `initial_state`: A string representing the initial state from which the sequence should start. 3. `steps`: An integer representing the number of steps to predict. Output * A list of strings representing the sequence of states starting from the `initial_state` and proceeding for the given number of `steps`. Constraints * The probabilities for each state must sum up to 1. * The number of steps will be a positive integer. Performance Requirements * The function should efficiently handle up to `10^4` steps. Example ```python chain = { \'A\': {\'A\': 0.6, \'E\': 0.4}, \'E\': {\'A\': 0.7, \'E\': 0.3} } initial_state = \'A\' steps = 5 print(predict_sequence(chain, initial_state, steps)) # Output could be: [\'A\', \'A\', \'A\', \'E\', \'A\'] or other valid sequences based on the probabilities ``` Scenario Imagine you are developing a predictive text generator. Given the current word (state) and a probability model of transitions between words, you want to predict the next few words the user is likely to type. This problem mimics such a scenario in a simplified form.","solution":"def predict_sequence(chain: dict, initial_state: str, steps: int) -> list: import random sequence = [initial_state] current_state = initial_state for _ in range(steps): next_states = list(chain[current_state].keys()) probabilities = list(chain[current_state].values()) next_state = random.choices(next_states, probabilities)[0] sequence.append(next_state) current_state = next_state return sequence"},{"question":"Set Cover Problem # Scenario You are a traffic manager responsible for placing minimal surveillance on intersections within the city. Each surveillance camera can cover certain intersections. You receive a list of camera models with their respective costs and the intersections they cover. Your goal is to determine a cost-efficient way to ensure all intersections are covered. # Task Implement a function `min_cost_set_cover` that takes the following inputs: 1. `universe` - A set of all intersections that need coverage (e.g., `{1, 2, 3, 4, 5}`). 2. `subsets` - A dictionary where each key is a camera model and the value is a set of intersections it can cover (e.g., `{\'CamA\': {1, 2}, \'CamB\': {2, 3, 4}, \'CamC\': {4, 5}}`). 3. `costs` - A dictionary where each key is a camera model, and the value is the cost to install that camera (e.g., `{\'CamA\': 5, \'CamB\': 10, \'CamC\': 3}`). Return a tuple containing the set of chosen camera models and their total cost. If it\'s not possible to cover all intersections, return `None`. # Constraints - All intersections in `universe` must be covered at least once. - The number of subsets (camera models) is less than or equal to 20. - Costs are positive integers. # Expected Function Signature ```python def min_cost_set_cover(universe: set, subsets: dict, costs: dict) -> tuple: pass ``` # Performance Requirements Optimize your solution to handle up to 2^20-1 subset combinations efficiently. # Examples ```python universe = {1, 2, 3, 4, 5} subsets = {\'CamA\': {1, 3}, \'CamB\': {2, 4}, \'CamC\': {1, 2, 3, 4, 5}} costs = {\'CamA\': 5, \'CamB\': 10, \'CamC\': 3} assert min_cost_set_cover(universe, subsets, costs) == ({\'CamC\'}, 3) universe = {1, 2, 3, 4, 5} subsets = {\'CamA\': {1, 2}, \'CamB\': {2, 3}, \'CamC\': {3, 4}, \'CamD\': {4, 5}} costs = {\'CamA\': 3, \'CamB\': 4, \'CamC\': 5, \'CamD\': 6} assert min_cost_set_cover(universe, subsets, costs) == ({\'CamA\', \'CamD\', \'CamC\'}, 14) Univeres = {1, 2, 3} subsets = {\'CamA\': {1, 3}, \'CamB\': {2, 3}} costs = {\'CamA\': 5, \'CamB\': 10} assert min_cost_set_cover(universe, subsets, costs) == ({\'CamA\', \'CamB\'}, 15) ``` # Notes - Handle edge cases where some intersections in `universe` cannot be covered by any combination of cameras. - Consider scenarios with overlapping coverage and redundant subsets by providing an efficient and minimal-cost solution.","solution":"from itertools import combinations def min_cost_set_cover(universe, subsets, costs): Returns the set of camera models that cover the universe of intersections at minimal cost. Args: universe (set): The set of all intersections that need coverage. subsets (dict): Dictionary where each key is a camera model and the value is a set of intersections it can cover. costs (dict): Dictionary where each key is a camera model and the value is the cost to install that camera. Returns: tuple: Containing the set of chosen camera models and their total cost, or None if not all intersections can be covered. # List of all camera models cameras = list(subsets.keys()) # Minimum cost and selected cameras min_cost = float(\'inf\') selected_cameras = None # Iterate through all possible combinations of camera models for r in range(1, len(cameras) + 1): for comb in combinations(cameras, r): covered_intersections = set() cost = 0 for cam in comb: covered_intersections.update(subsets[cam]) cost += costs[cam] if covered_intersections >= universe: if cost < min_cost: min_cost = cost selected_cameras = set(comb) # If no combination covers all intersections, return None if selected_cameras is None: return None return (selected_cameras, min_cost)"},{"question":"# Question: Efficient Set Cover Algorithm Implementation **Context**: You\'ve been assigned to implement an efficient algorithm to solve the set cover problem commonly found in network design and resource optimization. To maximize practical applicability, particularly for large datasets, you should focus on an efficient approximation approach rather than an optimal but computationally expensive brute-force solution. Assume that the subsets provided will always have necessary coverage for the universe. **Problem Statement**: Implement a function `efficient_set_cover` to find and return a subcollection of subsets covering all elements of the universe at minimal cost using a greedy approach. **Function Signature**: ```python def efficient_set_cover(universe: Set[int], subsets: Dict[str, Set[int]], costs: Dict[str, int]) -> List[str]: pass ``` **Input**: - `universe` (Set[int]): a set of n unique elements. - `subsets` (Dict[str, Set[int]]): a dictionary where the key is the subset name and value is a set of elements. - `costs` (Dict[str, int]): a dictionary where the key is the subset name and value is an integer cost. **Output**: - List[str]: a list of subset names forming a minimum-cost coverage. **Example**: ```python universe = {1, 2, 3, 4, 5} subsets = {\'S1\': {4, 1, 3}, \'S2\': {2, 5}, \'S3\': {1, 4, 3, 2}} costs = {\'S1\': 5, \'S2\': 10, \'S3\': 3} output = efficient_set_cover(universe, subsets, costs) # Output should be according to the Greedy Algorithm, e.g.: # Output: [\'S3\', \'S2\'] ``` **Constraints**: - The given subsets will always cover the universe fully. - The size of the universe does not exceed 100 elements. - The number of subsets does not exceed 50. - The cost of subsets is a positive integer. **Requirement**: - Implement the `efficient_set_cover` function using a greedy strategy as explained in the provided code snippets.","solution":"def efficient_set_cover(universe, subsets, costs): Greedy algorithm for the set cover problem. covered = set() chosen_subsets = [] while covered != universe: subset_best, cost_best, coverage_best = None, float(\'inf\'), set() for subset_name, subset_elements in subsets.items(): current_coverage = subset_elements - covered if current_coverage: # avoid already covered subsets cost_per_element = costs[subset_name] / len(current_coverage) if cost_per_element < cost_best: subset_best = subset_name cost_best = cost_per_element coverage_best = current_coverage if subset_best is not None: covered.update(coverage_best) chosen_subsets.append(subset_best) else: break return chosen_subsets"},{"question":"**Challenge**: Write a Python function `remove_duplicates(head, use_set=True)` that removes duplicates from an unsorted singly linked list. The function should take two arguments: the head of the linked list and a boolean `use_set`. When `use_set` is `True`, implement the O(N) time complexity approach using a set. When `use_set` is `False`, implement the O(N^2) time complexity approach without using any additional data structures. **Function Signature**: ```python def remove_duplicates(head: Node, use_set: bool = True) -> None: pass ``` **Input**: - `head`: The head node of the input unsorted singly linked list. - `use_set`: A boolean flag (default `True`). If `True`, remove duplicates using O(N) time complexity method with additional space. If `False`, remove duplicates using O(N^2) method without additional space. **Output**: - The function should modify the linked list in place and not return any value. **Constraints**: - The linked list nodes contain integer values. - Ensure efficient usage of memory and time, according to the method specified by the `use_set` flag. **Example**: ```python class Node: def __init__(self, val=None): self.val = val self.next = None # Helper function to print the linked list def print_linked_list(head): elements = [] while head: elements.append(str(head.val)) head = head.next print(\\" -> \\".join(elements)) # Example usage # Create linked list: 1 -> 2 -> 3 -> 2 -> 1 node1 = Node(1) node2 = Node(2) node3 = Node(3) node4 = Node(2) node5 = Node(1) node1.next = node2 node2.next = node3 node3.next = node4 node4.next = node5 # Remove duplicates with set remove_duplicates(node1, use_set=True) print_linked_list(node1) # Output: 1 -> 2 -> 3 # Create linked list again: 1 -> 2 -> 3 -> 2 -> 1 node1 = Node(1) node2 = Node(2) node3 = Node(3) node4 = Node(2) node5 = Node(1) node1.next = node2 node2.next = node3 node3.next = node4 node4.next = node5 # Remove duplicates without set remove_duplicates(node1, use_set=False) print_linked_list(node1) # Output: 1 -> 2 -> 3 ```","solution":"class Node: def __init__(self, val=None): self.val = val self.next = None def remove_duplicates(head: Node, use_set: bool = True) -> None: if use_set: # Use a set to track seen values current = head prev = None seen = set() while current: if current.val in seen: prev.next = current.next # Remove current node else: seen.add(current.val) prev = current current = current.next else: # No additional data structure (use two-pointer technique) current = head while current: runner = current while runner.next: if runner.next.val == current.val: runner.next = runner.next.next # Remove runner.next node else: runner = runner.next current = current.next"},{"question":"# Stooge Sorting Algorithm Implementation You are tasked with implementing the stooge sorting algorithm. This algorithm is a theoretical sorting method that sorts an array by recursively comparing and swapping elements. **Problem Statement**: Write a Python function `stoogesort(arr, l, h)` that sorts an array of integers using the stooge sort algorithm. The implementation should follow these steps: 1. If the left index `l` is greater than or equal to the right index `h`, return immediately. 2. If the element at index `l` is greater than the element at index `h`, swap them. 3. If there are more than two elements in the array segment ([l:h]), recursively sort these segments: - The first 2/3 of the segment. - The last 2/3 of the segment. - The first 2/3 of the segment again. **Function Signature**: ```python def stoogesort(arr, l, h): pass ``` **Input**: - `arr`: A list of integers to be sorted. - `l` and `h`: The starting and ending indices of the list segment to be sorted (0-based index). **Output**: - The function should sort the array/list in place. **Constraints**: - The function should handle arrays with up to 1000 elements. - Values in the array should be in the range from [-10^6, 10^6]. **Example**: ```python # Example usage array = [5, 3, 2, 6, 4, 1] stoogesort(array, 0, len(array)-1) print(array) # Output should be: [1, 2, 3, 4, 5, 6] ``` **Performance Requirements**: The solution should have a time complexity of ( O(n^{2.709}) ) and a space complexity that is primarily driven by the recursion stack. You should handle arrays with edge cases like an empty array, a single-element array, and already sorted arrays.","solution":"def stoogesort(arr, l, h): Sorts an array arr from index l to h using the stooge sort algorithm. if l >= h: return if arr[l] > arr[h]: arr[l], arr[h] = arr[h], arr[l] if h - l + 1 > 2: t = (h - l + 1) // 3 stoogesort(arr, l, h - t) stoogesort(arr, l + t, h) stoogesort(arr, l, h - t) # Example usage: # array = [5, 3, 2, 6, 4, 1] # stoogesort(array, 0, len(array)-1) # print(array) # Output should be: [1, 2, 3, 4, 5, 6]"},{"question":"# Context The given code implements the Quick Sort algorithm, a popular and efficient sorting algorithm under average case scenarios. Your task is to further enhance and adapt the Quick Sort implementation to address some common pitfalls and optimize its performance to handle large datasets effectively. # Problem Statement Implement an optimized version of Quick Sort in Python, incorporating the following requirements: 1. **Choose a pivot smartly**: Implement the \\"median-of-three\\" strategy to pick the pivot element. 2. **Handle small arrays**: For arrays smaller than a specified threshold `k`, use the Insertion Sort algorithm for sorting. 3. **Recursive call optimization**: Apply tail-call optimization by sorting the smaller partition first, reducing the recursion depth. # Function Signature ```python def optimized_quick_sort(arr: List[int], k: int, simulation: bool=False) -> List[int]: ``` # Input - `arr`: A list of integers to sort. - `k`: An integer threshold. For subarrays smaller than this size, use Insertion Sort for optimization. - `simulation`: A boolean indicating whether to print the iteration states for debugging purposes. # Output - Returns a sorted list of integers. # Constraints - The length of `arr` will be in the range `[0, 10000]`. - The integers in `arr` can range from `-1000000` to `1000000`. - `k` will be in the range `[1, 50]`. # Example ```python # Example 1 arr = [5, 2, 9, 1, 5, 6] k = 10 print(optimized_quick_sort(arr, k)) # Output should be [1, 2, 5, 5, 6, 9] # Example 2 arr = [3, -1, 0, -1000000, 1000000, 2, -3, 4] k = 3 print(optimized_quick_sort(arr, k)) # Output should be [-1000000, -3, -1, 0, 2, 3, 4, 1000000] ``` # Additional Notes You may assume that the `partition` and `insertion_sort` functions provided below can be used directly in your implementation, modifying only `optimized_quick_sort` and `quick_sort_recur` to meet the requirements.","solution":"from typing import List def median_of_three(a, b, c): Return the median of the three elements. return sorted([a, b, c])[1] def partition(arr, low, high): Partition the array using the median-of-three method to choose the pivot. mid = (low + high) // 2 pivot = median_of_three(arr[low], arr[mid], arr[high]) pivot_index = [low, mid, high][[arr[low], arr[mid], arr[high]].index(pivot)] arr[pivot_index], arr[high] = arr[high], arr[pivot_index] # Move pivot to the end pivot_value = arr[high] i = low - 1 for j in range(low, high): if arr[j] < pivot_value: i += 1 arr[i], arr[j] = arr[j], arr[i] arr[i + 1], arr[high] = arr[high], arr[i + 1] return i + 1 def insertion_sort(arr, low, high): Insertion sort for the subarray arr[low:high+1]. for i in range(low + 1, high + 1): key = arr[i] j = i - 1 while j >= low and arr[j] > key: arr[j + 1] = arr[j] j -= 1 arr[j + 1] = key def optimized_quick_sort(arr: List[int], k: int, simulation: bool=False) -> List[int]: Optimized Quick Sort algorithm with median-of-three pivot choice, insertion sort for small arrays, and tail-call optimization. def quick_sort_recur(arr, low, high): while low < high: if high - low + 1 < k: insertion_sort(arr, low, high) if simulation: print(f\\"Insertion sort called for subarray {arr[low:high+1]}\\") break pivot_index = partition(arr, low, high) if simulation: print(f\\"Pivot chosen at index {pivot_index} with value {arr[pivot_index]}\\") if pivot_index - low < high - pivot_index: quick_sort_recur(arr, low, pivot_index - 1) low = pivot_index + 1 else: quick_sort_recur(arr, pivot_index + 1, high) high = pivot_index - 1 quick_sort_recur(arr, 0, len(arr) - 1) return arr"},{"question":"# Bubble Sort Algorithm Enhancement Given the bubble sort algorithm described above, your task is to improve its efficiency. The provided bubble sort implementation stops if the array is already sorted before all the passes, which is an improvement. But, it may still conduct unnecessary comparisons in the best case where the array is partially sorted. You will implement an optimized version of bubble sort. The function should minimize the number of comparisons by keeping track of the last swapped position, and only iterating up to that position on the next pass. This further optimization reduces redundant comparisons. # Function Signature ```python def optimized_bubble_sort(arr: List[int], simulation: bool = False) -> List[int]: ``` # Input * `arr`: A list of integers to be sorted. * `simulation`: A boolean flag (default is `False`). If `True`, print the array state after every pass through the array. # Output * `List[int]`: The input list sorted in ascending order. # Constraints * The input list can contain up to `10^4` elements. * The elements of the list are integers within the range `-10^6` to `10^6`. # Example Input ```python arr = [64, 34, 25, 12, 22, 11, 90] ``` Output ```python [11, 12, 22, 25, 34, 64, 90] ``` # Description * You must minimize the number of comparisons during sorting. * Your algorithm should keep track of the last position where a swap was made and use it to limit the number of comparisons in subsequent passes. * The simulation flag should print the intermediate array states on each pass just like the provided bubble sort algorithm if set to `True`. # Note * Aim to preserve the simplicity while improving the performance.","solution":"from typing import List def optimized_bubble_sort(arr: List[int], simulation: bool = False) -> List[int]: An optimized version of bubble sort that minimizes the number of comparisons by keeping track of the last swapped position. n = len(arr) while n > 0: last_swapped_index = 0 for i in range(1, n): if arr[i-1] > arr[i]: arr[i-1], arr[i] = arr[i], arr[i-1] last_swapped_index = i n = last_swapped_index if simulation: print(arr) return arr"},{"question":"# Context You are working on a predictive text algorithm that uses Markov chains to forecast the next word in a sentence based on the current word. A Markov chain is represented as a dictionary where each state maps to possible next states with associated probabilities. # Task Write a function `generate_sentence` which generates a sentence using a Markov chain. The function should take the Markov chain, an initial state, the desired sentence length, and produce a sequence of states adhering to the given chain rules. # Function Signature ```python def generate_sentence(chain: dict, initial_state: str, length: int) -> list: ``` # Input 1. `chain` (dict): A dictionary representing a Markov chain, where the keys are states and values are dictionaries mapping the next states to their probabilities. 2. `initial_state` (str): The state to start the sequence from. 3. `length` (int): The desired length of the output sequence. # Output - Returns a list of states representing the generated sentence. # Example ```python my_chain = { \'A\': {\'A\': 0.6, \'B\': 0.4}, \'B\': {\'A\': 0.3, \'B\': 0.7} } initial_state = \'A\' length = 5 print(generate_sentence(my_chain, initial_state, length)) # Might print: [\'A\', \'A\', \'B\', \'B\', \'B\'] ``` # Constraints - Assume the chain contains valid probabilities (sum to 1 for each state). - The initial state is always valid and present in the chain. - Length will be a positive integer. # Additional Requirements 1. The function should handle an invalid transition gracefully by halting the process if it encounters an undefined state. 2. Performance should be efficient enough to support a chain with up to 10,000 states.","solution":"import random def generate_sentence(chain: dict, initial_state: str, length: int) -> list: Generates a sequence of states based on a given Markov chain. :param chain: A dictionary representing the Markov chain. :param initial_state: The state to start the sequence from. :param length: The desired length of the output sequence. :return: A list of states representing the generated sentence. current_state = initial_state sentence = [current_state] for _ in range(length - 1): if current_state not in chain: break next_states = list(chain[current_state].keys()) probabilities = list(chain[current_state].values()) current_state = random.choices(next_states, probabilities)[0] sentence.append(current_state) return sentence"},{"question":"<|Analysis Begin|> # Core Identification * **Algorithm/Data Structure**: The key algorithm here is the Longest Common Subsequence (LCS) used in the context of calculating the minimum steps to make two strings identical by deleting characters. * **Complexity**: * Recursive LCS Approach: Time complexity is (O(2^{max(n, m)})) where `n` and `m` are lengths of `word1` and `word2` respectively. Space complexity is (O(max(n, m))) due to the recursion stack. * Dynamic Programming (DP) Approach: Time complexity is (O(n cdot m)), Space complexity is (O(n cdot m)). * **Principles**: The problem is solved by calculating the LCS of the two strings using both recursive and dynamic programming approaches, and then deriving the minimum deletion steps from it. # Characteristics & Applications * **Properties**: The problem leverages the LCS approach to identify the longest common subsequence of two strings. This LCS is used to calculate the minimum number of deletions required. * **Common Use Cases**: Useful in text comparison, version control systems, diff tools, and bioinformatics for DNA sequence alignment. * **Strengths/Limitations**: * Strengths: Provides an optimal solution using dynamic programming, ensuring the minimal number of operations. * Limitations: Recursive approach is highly inefficient for large strings due to exponential time complexity. # Implementation Challenges * **Edge Cases**: Inputs where one or both strings are empty, both strings being the same, or completely disjoint strings. * **Performance Bottlenecks**: The recursive approach has a significant performance issue with large input sizes due to redundant calculations. * **Error Scenarios**: Incorrect handling of base cases in recursion, or improper indexing in the dynamic programming table. * **Optimization Points**: * Memoization in the recursive approach can significantly reduce redundant calculations. * Space optimization in the DP approach can be done by using only two rows/vectors since only the current and previous rows are required. <|Analysis End|> <|Question Begin|> # Coding Assessment Question **Problem Statement**: Given two words `word1` and `word2`, write a function `min_steps_to_make_same(word1: str, word2: str) -> int` to find the minimum number of steps required to make the two strings identical by deleting characters from either of the strings. The solution should use dynamic programming to ensure efficiency. **Input**: * `word1` (1 <= len(word1) <= 1000): A string of lowercase English letters. * `word2` (1 <= len(word2) <= 1000): A string of lowercase English letters. **Output**: * An integer representing the minimum number of deletions required to make `word1` and `word2` identical. **Constraints**: * You can delete characters from either string in each step. * The inputs are non-empty strings. **Performance Requirements**: * Your solution should run in O(length(word1) * length(word2)) time complexity and O(length(word1) * length(word2)) space complexity. **Function Signature**: ```python def min_steps_to_make_same(word1: str, word2: str) -> int: pass ``` **Example**: ```python assert min_steps_to_make_same(\\"sea\\", \\"eat\\") == 2 assert min_steps_to_make_same(\\"leetcode\\", \\"etco\\") == 4 ``` **Detailed Requirements**: To implement the function `min_steps_to_make_same`, follow these steps: 1. Create a 2D list (`dp`) where `dp[i][j]` stores the length of the longest common subsequence of `word1[0..i-1]` and `word2[0..j-1]`. 2. Initialize the table where `dp[i][0] = 0` for all `i` and `dp[0][j] = 0` for all `j`. 3. Fill the table based on character comparison between `word1[i-1]` and `word2[j-1]`: * If they match, `dp[i][j] = 1 + dp[i-1][j-1]`. * If they don\'t match, `dp[i][j] = max(dp[i-1][j], dp[i][j-1])`. 4. The minimum deletions required would be the combined length of both strings minus twice the length of the LCS (`len(word1) + len(word2) - 2 * dp[len(word1)][len(word2)]`). Implement the function and ensure it meets the outlined criteria.","solution":"def min_steps_to_make_same(word1: str, word2: str) -> int: Returns the minimum number of steps required to make word1 and word2 identical by deleting characters. # Lengths of the given words len1 = len(word1) len2 = len(word2) # Creating a 2D list to store the dp values dp = [[0] * (len2 + 1) for _ in range(len1 + 1)] # Fill the dp array for i in range(1, len1 + 1): for j in range(1, len2 + 1): if word1[i-1] == word2[j-1]: dp[i][j] = dp[i-1][j-1] + 1 else: dp[i][j] = max(dp[i-1][j], dp[i][j-1]) # Length of the longest common subsequence lcs_length = dp[len1][len2] # Minimum deletions to make the words identical min_deletions = (len1 - lcs_length) + (len2 - lcs_length) return min_deletions"},{"question":"# AVL Tree Implementation and Range Search You are given a partial implementation of an AVL Tree which supports insertions and maintaining balance. Your task is to complete two functions: 1. **Implement the `delete` method**: - The `delete` method should remove a key from the tree while maintaining its balance. 2. **Implement the `range_search` method**: - The `range_search` method should return all keys within a given range [low, high] in sorted order. # Function Specifications Method 1: `delete` **Input**: - `key`: An integer key to be removed from the tree. **Output**: - None. The tree should be updated in-place. **Constraints**: - The `key` to be deleted exists in the tree. - You must maintain the AVL tree properties after deletion. Method 2: `range_search` **Input**: - `low`: An integer representing the lower bound of the range (inclusive). - `high`: An integer representing the upper bound of the range (inclusive). **Output**: - A list of integers representing the keys within the range in sorted order. **Constraints**: - `low` and `high` are integers where `low <= high`. # Example ```python # Initialization avl = AvlTree() # Insertion for key in [20, 15, 25, 10, 18, 23, 30]: avl.insert(key) # Deletion avl.delete(15) # Range Search result = avl.range_search(10, 23) print(result) # Output should be [10, 18, 20, 23] ``` # Notes - Ensure the `delete` and `range_search` methods adhere to the AVL tree properties. - Pay special attention to edge cases and maintain balance after the tree is modified. - Optimize for efficiency where possible.","solution":"class TreeNode: def __init__(self, key, height=1, left=None, right=None): self.key = key self.height = height self.left = left self.right = right class AvlTree: def __init__(self): self.root = None def get_height(self, node): if not node: return 0 return node.height def update_height(self, node): if node: node.height = max(self.get_height(node.left), self.get_height(node.right)) + 1 def get_balance(self, node): if not node: return 0 return self.get_height(node.left) - self.get_height(node.right) def rotate_right(self, y): x = y.left T2 = x.right x.right = y y.left = T2 self.update_height(y) self.update_height(x) return x def rotate_left(self, x): y = x.right T2 = y.left y.left = x x.right = T2 self.update_height(x) self.update_height(y) return y def insert(self, key): def _insert(node, key): if not node: return TreeNode(key) if key < node.key: node.left = _insert(node.left, key) else: node.right = _insert(node.right, key) self.update_height(node) balance = self.get_balance(node) if balance > 1 and key < node.left.key: return self.rotate_right(node) if balance < -1 and key > node.right.key: return self.rotate_left(node) if balance > 1 and key > node.left.key: node.left = self.rotate_left(node.left) return self.rotate_right(node) if balance < -1 and key < node.right.key: node.right = self.rotate_right(node.right) return self.rotate_left(node) return node self.root = _insert(self.root, key) def delete(self, key): def _delete(node, key): if not node: return node if key < node.key: node.left = _delete(node.left, key) elif key > node.key: node.right = _delete(node.right, key) else: if not node.left: return node.right elif not node.right: return node.left temp = self.get_min_value_node(node.right) node.key = temp.key node.right = _delete(node.right, temp.key) self.update_height(node) balance = self.get_balance(node) if balance > 1 and self.get_balance(node.left) >= 0: return self.rotate_right(node) if balance > 1 and self.get_balance(node.left) < 0: node.left = self.rotate_left(node.left) return self.rotate_right(node) if balance < -1 and self.get_balance(node.right) <= 0: return self.rotate_left(node) if balance < -1 and self.get_balance(node.right) > 0: node.right = self.rotate_right(node.right) return self.rotate_left(node) return node self.root = _delete(self.root, key) def get_min_value_node(self, node): current = node while current.left is not None: current = current.left return current def range_search(self, low, high): result = [] def _range_search(node, low, high): if not node: return if node.key >= low and node.key <= high: result.append(node.key) if node.left: _range_search(node.left, low, high) if node.right: _range_search(node.right, low, high) _range_search(self.root, low, high) return sorted(result)"},{"question":"# AVL Tree Rotation Implementation You\'re tasked with completing and optimizing the implementation of an AVL Tree. The AVL Tree class provided partially implements insert and re-balance functionalities, but the rotations (right and left) are adapted in a basic format. The goal is to: 1. Correctly implement node rotations. 2. Validate the functioning of insertion by performing in-order traversal to check if the tree remains balanced and ordered after insertions. Requirements: 1. **Function Signature**: ```python class AvlTree(object): def insert(self, key): Insert `key` into the AVL tree and re-balance if necessary. # ... Your implementation goes here def insert_sequence(self, keys): Insert a sequence of keys into the AVL tree. # ... Your implementation goes here def in_order_traverse(self): Return the in-order traversal of the tree. # ... Your implementation goes here ``` 2. **Expected Input and Output Formats**: - `insert(self, key)`: Inserts a single key. - `insert_sequence(self, keys)`: Accepts a list of keys and inserts them into the tree in the given order. - `in_order_traverse(self)`: Returns a list of all keys in in-order traversal. 3. **Constraints**: - Assume all keys are integers. - The tree should handle `n` up to 10^5 efficiently. - The AVL Tree should maintain balance properties. 4. **Performance Requirements**: - All operations should generally perform in O(log n) time, ensuring efficient balance operations. Example: ```python avl_tree = AvlTree() avl_tree.insert_sequence([10, 20, 30, 40, 50, 25]) print(avl_tree.in_order_traverse()) # Output: [10, 20, 25, 30, 40, 50] (indicating a balanced AVL tree) ``` Hint: - Carefully consider edge cases such as inserting into an empty tree, causing imbalances, and subtree rotations. - Rotations must strictly adhere to AVL tree properties ensuring balanced height at every step. Develop a robust AVL Tree class ensuring all insertions maintain necessary tree balancing and demonstrate the balance through in-order traversal.","solution":"class TreeNode: def __init__(self, key): self.key = key self.left = None self.right = None self.height = 1 class AvlTree: def __init__(self): self.root = None def insert(self, key): if not self.root: self.root = TreeNode(key) else: self.root = self._insert(self.root, key) def insert_sequence(self, keys): for key in keys: self.insert(key) def in_order_traverse(self): result = [] def _in_order_traverse(node): if node: _in_order_traverse(node.left) result.append(node.key) _in_order_traverse(node.right) _in_order_traverse(self.root) return result def _insert(self, node, key): if not node: return TreeNode(key) elif key < node.key: node.left = self._insert(node.left, key) else: node.right = self._insert(node.right, key) node.height = 1 + max(self._get_height(node.left), self._get_height(node.right)) balance = self._get_balance(node) if balance > 1 and key < node.left.key: return self._right_rotate(node) if balance < -1 and key > node.right.key: return self._left_rotate(node) if balance > 1 and key > node.left.key: node.left = self._left_rotate(node.left) return self._right_rotate(node) if balance < -1 and key < node.right.key: node.right = self._right_rotate(node.right) return self._left_rotate(node) return node def _get_height(self, node): if not node: return 0 return node.height def _get_balance(self, node): if not node: return 0 return self._get_height(node.left) - self._get_height(node.right) def _left_rotate(self, z): y = z.right T2 = y.left y.left = z z.right = T2 z.height = 1 + max(self._get_height(z.left), self._get_height(z.right)) y.height = 1 + max(self._get_height(y.left), self._get_height(y.right)) return y def _right_rotate(self, z): y = z.left T3 = y.right y.right = z z.left = T3 z.height = 1 + max(self._get_height(z.left), self._get_height(z.right)) y.height = 1 + max(self._get_height(y.left), self._get_height(y.right)) return y"},{"question":"# Programming Assessment Question **Title**: Enhanced Cocktail Shaker Sort Implementation **Objective**: Implement a modified version of Cocktail Shaker Sort that reduces unnecessary comparisons and swaps by tracking the boundaries of the sorted region dynamically. **Context**: You are required to optimize the classic Cocktail Shaker Sort algorithm by reducing its time complexity where possible. Your optimized version should track the boundary of sorted elements and avoid redundant comparisons beyond these boundaries. **Task**: Implement a function named `optimized_cocktail_shaker_sort` that takes a list of integers and sorts the list in-place in ascending order using the optimized version of Cocktail Shaker Sort. **Function Signature**: ```python def optimized_cocktail_shaker_sort(arr: List[int]) -> None: ``` **Input**: * `arr` (List[int]): A list of integers to be sorted. The list may contain duplicate values. **Output**: * The function should modify the input list `arr` to be sorted in ascending order. **Constraints**: * The input list `arr` can have up to 10^4 elements. **Performance Requirements**: * Your implementation should be efficient and avoid unnecessary comparisons. Aim for fewer comparisons than the classic O(N^2) worst-case performance seen in a non-optimized Cocktail Shaker Sort. **Example**: ```python arr = [5, 1, 4, 2, 8, 0, 2] optimized_cocktail_shaker_sort(arr) print(arr) # Output: [0, 1, 2, 2, 4, 5, 8] ``` Ensure to handle edge cases such as empty arrays and arrays with one element. **Note**: * Do not use any in-built sorting functions. * Focus on maintaining the stability of the sort and efficiency in handling partially sorted arrays. * Test your implementation with various test cases including edge cases.","solution":"def optimized_cocktail_shaker_sort(arr): Sorts the list in-place using the optimized cocktail shaker sort algorithm. n = len(arr) if n < 2: return start = 0 end = n - 1 sorted = False while not sorted: sorted = True # Traverse the list from left to right for i in range(start, end): if arr[i] > arr[i + 1]: arr[i], arr[i + 1] = arr[i + 1], arr[i] sorted = False if sorted: break end -= 1 sorted = True # Traverse the list from right to left for i in range(end, start, -1): if arr[i] < arr[i - 1]: arr[i], arr[i - 1] = arr[i - 1], arr[i] sorted = False start += 1"},{"question":"Problem: Path Existence in a Directed Graph You are given a directed graph with `n` vertices labeled from `0` to `n-1` represented by a list of edges. Each edge is a pair of two integers [u, v] where `u` is directed to `v`. Write a function `is_path_exists(n: int, edges: List[Tuple[int, int]], source: int, target: int) -> bool` to determine if there is a path from the source node to the target node. # Input * `n` (1 ≤ n ≤ 10^5): An integer representing the number of vertices. * `edges` (0 ≤ len(edges) ≤ 2 * 10^5): A list of tuples where each tuple (u, v) represents an edge directed from node u to node v. * `source` (0 ≤ source < n): An integer representing the starting node. * `target` (0 ≤ target < n): An integer representing the destination node. # Output * Return `True` if there is a path from the `source` node to the `target` node; otherwise, return `False`. # Example ```python assert is_path_exists(5, [(0, 1), (0, 2), (1, 2), (2, 3), (3, 4)], 0, 4) == True assert is_path_exists(5, [(0, 1), (0, 2), (3, 4)], 0, 4) == False ``` # Constraints * You must come up with a solution with a time complexity of O(V + E) and a space complexity of O(V). # Guidelines * Develop a function `is_path_exists` using DFS or BFS. * Handle edge cases like no edges, source equals to target, and non-existent nodes.","solution":"from typing import List, Tuple def is_path_exists(n: int, edges: List[Tuple[int, int]], source: int, target: int) -> bool: Determines if there is a path from the source node to the target node in a directed graph. if source == target: return True # Create adjacency list adj_list = [[] for _ in range(n)] for u, v in edges: adj_list[u].append(v) # Use DFS to check for the path visited = [False] * n def dfs(node): if node == target: return True visited[node] = True for neighbor in adj_list[node]: if not visited[neighbor] and dfs(neighbor): return True return False return dfs(source)"},{"question":"In-order Traversal Alternative Given the in-order traversal algorithm for a binary tree, both iterative and recursive forms, write a Python function `inorder_with_elements_sum` which performs in-order traversal and returns a list of tuples. Each tuple should contain the node value and the cumulative sum of all previously visited node values (including the current node itself). # Function Signature ```python def inorder_with_elements_sum(root: Node) -> List[Tuple[int, int]]: pass ``` # Input - `root`: a `Node` object representing the root of the binary tree. # Output - List of tuples `[(node_value1, cumulative_sum1), (node_value2, cumulative_sum2), ...]` where `cumulative_sum` is the sum of all node values visited up to that point. # Example ```python # Construct the tree: # 100 # / # 50 150 # / / # 25 75 125 175 n1 = Node(100) n2 = Node(50) n3 = Node(150) n4 = Node(25) n5 = Node(75) n6 = Node(125) n7 = Node(175) n1.left, n1.right = n2, n3 n2.left, n2.right = n4, n5 n3.left, n3.right = n6, n7 assert inorder_with_elements_sum(n1) == [(25, 25), (50, 75), (75, 150), (100, 250), (125, 375), (150, 525), (175, 700)] ``` # Constraints - You may assume that all node values are unique. - The sum of node values will fit within a 32-bit signed integer range. # Notes - Consider edge cases such as an empty tree and trees with a single node. - Ensure your solution is efficient in terms of time and space complexity.","solution":"class Node: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def inorder_with_elements_sum(root): Perform in-order traversal and returns a list of tuples with cumulative sums. if root is None: return [] stack = [] current = root result = [] cumulative_sum = 0 while stack or current: while current: stack.append(current) current = current.left current = stack.pop() cumulative_sum += current.value result.append((current.value, cumulative_sum)) current = current.right return result"},{"question":"# Question: Optimal Quick Sort with Randomized Pivot Background: Quick Sort is an efficient, in-place sorting algorithm that uses a divide-and-conquer approach to sort an array. However, its performance heavily depends on the choice of pivot. A poor pivot choice can degrade it to O(n^2) time complexity. To mitigate this, one common optimization is to use a randomized pivot, which ensures a more balanced partition on average. Task: Implement an optimized version of Quick Sort called `optimal_quick_sort` that uses a randomized pivot selection to handle the worst-case scenario more efficiently. Function Signature: ```python def optimal_quick_sort(arr: List[int], simulation: bool = False) -> List[int]: ``` Input: * `arr`: List of integers that need to be sorted. * `simulation` (optional): A boolean flag to indicate if the sorting process should simulate and print each iteration step. Default is `False`. Output: * Returns a sorted list of integers. Example: ```python arr = [3,6,8,10,1,2,1] print(optimal_quick_sort(arr)) # Output: [1, 1, 2, 3, 6, 8, 10] arr = [1,2,3,4,5] print(optimal_quick_sort(arr, simulation=True)) # Example Output (with simulation=True): # iteration 0: 1 2 3 4 5 # iteration 1: 1 2 3 4 5 # [1, 2, 3, 4, 5] ``` Constraints: * 1 <= len(arr) <= 10^5 * -10^9 <= arr[i] <= 10^9 Requirements: * Your implementation should use an optimized pivot selection (e.g., randomized pivot). * It should handle edge cases such as arrays with duplicate values efficiently. * Ensure that the algorithm performs sorting within the average time complexity of O(n log(n)). Notes: * Implement the helper functions you deem necessary. * Properly document your code and print states as requested when `simulation=True`.","solution":"import random def optimal_quick_sort(arr, simulation=False): Sort an array using quick sort with a randomized pivot. Parameters: arr (list): List of integers that need to be sorted. simulation (bool): Optional flag to indicate if the sorting process should simulate and print each iteration step. Returns: list: Sorted list of integers. def quick_sort(arr, low, high, iteration): if low < high: p = partition(arr, low, high) if simulation: print(f\\"iteration {iteration}: {\' \'.join(map(str, arr))}\\") iteration += 1 quick_sort(arr, low, p - 1, iteration) quick_sort(arr, p + 1, high, iteration) def partition(arr, low, high): pivot_index = random.randint(low, high) arr[pivot_index], arr[high] = arr[high], arr[pivot_index] pivot = arr[high] i = low - 1 for j in range(low, high): if arr[j] <= pivot: i += 1 arr[i], arr[j] = arr[j], arr[i] arr[i + 1], arr[high] = arr[high], arr[i + 1] return i + 1 quick_sort(arr, 0, len(arr) - 1, 0) return arr"},{"question":"Problem Statement: You have been given a non-negative integer represented as a list of digits, where each element of the list is a single digit and the list forms the number in big-endian format (most significant digit first). You are required to write a function that increments this number by one and returns the new list of digits. Input: * A list of integers `digits` where each integer is in the range `[0, 9]` representing a non-negative integer. The list will not have any leading zeros except when the number is itself zero. Output: * A list of integers which is the input number incremented by one. Function Signature: ```python def plus_one(digits: List[int]) -> List[int]: ``` Constraints: * The input list can have up to 100,000 digits. Examples: 1. **Example 1** ```python Input: digits = [1, 2, 3] Output: [1, 2, 4] ``` Explanation: 123 + 1 = 124 2. **Example 2** ```python Input: digits = [4, 3, 2, 1] Output: [4, 3, 2, 2] ``` Explanation: 4321 + 1 = 4322 3. **Example 3** ```python Input: digits = [9, 9, 9] Output: [1, 0, 0, 0] ``` Explanation: 999 + 1 = 1000 4. **Example 4** ```python Input: digits = [0] Output: [1] ``` Explanation: 0 + 1 = 1 Performance Requirements: Your function should be optimized to run in O(n) time complexity, where n is the number of digits in the input list. It should also aim to use O(1) additional space complexity wherever possible.","solution":"from typing import List def plus_one(digits: List[int]) -> List[int]: Increment a number represented as a list of digits by one. n = len(digits) # Traverse the list from the end to the beginning for i in range(n-1, -1, -1): if digits[i] < 9: digits[i] += 1 return digits digits[i] = 0 # If the loop terminates, it means all the digits were 9, thus we need an extra digit at the beginning. return [1] + [0] * n"},{"question":"Scenario You are working on a project that involves navigating through a decision tree and listing all possible decision paths. Your goal is to write a function that generates all root-to-leaf paths in a binary tree, formatted as strings with each value separated by \'->\'. Function Implementation **Function Name**: `binary_tree_paths` **Input**: * A binary tree node `root`, where a node is defined as: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` **Output**: * A list of strings, where each string represents a path from root to a leaf, with node values separated by \'->\'. **Constraints**: * The number of nodes in the tree is in the range `[0, 1000]`. * `-1000 <= Node.val <= 1000`. **Performance Requirements**: * The function should run efficiently within the given constraints. * Optimize for both time and space complexity where possible. Example ```python # Example 1 # Input: # 1 # / # 2 3 # # 5 # Output: [\\"1->2->5\\", \\"1->3\\"] # Example 2 # Input: # 1 # / # 2 3 # Output: [\\"1->2\\", \\"1->3\\"] def binary_tree_paths(root): # [Your implementation goes here] pass ``` Additional Notes * Ensure that the function generates paths correctly even for skewed or single-node trees. * Handle edge cases appropriately, such as an empty tree (return an empty list).","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def binary_tree_paths(root): Generates all root-to-leaf paths in a binary tree. if not root: return [] paths = [] def construct_paths(node, path): if node: path += str(node.val) if not node.left and not node.right: # if leaf node paths.append(path) else: path += \'->\' construct_paths(node.left, path) construct_paths(node.right, path) construct_paths(root, \\"\\") return paths"},{"question":"# OrderedStack Implementation and Usage You are given a stack class `OrderedStack` which ensures that all elements are stored in ascending order at all times. Your task is to extend this `OrderedStack` class to add new functionalities and provide additional operations to better manipulate and utilize ordered stacks. Task 1. Implement a `merge` method that merges another `OrderedStack` into the current stack while maintaining the order. 2. Implement a `to_list` method that converts the stack’s current elements into a sorted list. 3. Write a function `reverse_ordered_stack(ordered_stack: OrderedStack) -> OrderedStack` that reverses the order of the stack. Input and Output - The `merge` method should take another `OrderedStack` as input and merge it into the current stack in (O(n)). - The `to_list` method should return a list of elements in sorted order in (O(n)). - `reverse_ordered_stack` function should return a new `OrderedStack` where elements are reversed from the input stack in (O(n)). # Constraints - All elements will be integers. - The maximum number of elements in the stack will not exceed (10^4). - You should not use any in-built sorting methods. # Example ```python # Assume OrderedStack class is already implemented as provided # Example usage: stack1 = OrderedStack() stack1.push(1) stack1.push(3) stack1.push(5) stack2 = OrderedStack() stack2.push(2) stack2.push(4) stack2.push(6) # Merging stack2 into stack1 stack1.merge(stack2) print(stack1.to_list()) # Output: [1, 2, 3, 4, 5, 6] # Reversing the ordered stack reversed_stack = reverse_ordered_stack(stack1) print(reversed_stack.to_list()) # Output: [6, 5, 4, 3, 2, 1] ``` Notes - Ensure the methods are efficient and adhere to the constraints. - Properly manage edge cases, like merging empty stacks or merging into an empty stack.","solution":"class OrderedStack: def __init__(self): self.stack = [] def push(self, value): if not self.stack or value >= self.stack[-1]: self.stack.append(value) else: temp = [] while self.stack and self.stack[-1] > value: temp.append(self.stack.pop()) self.stack.append(value) while temp: self.stack.append(temp.pop()) def merge(self, other): self.stack = self._merge_sorted_lists(self.stack, other.stack) def to_list(self): return self.stack[:] def _merge_sorted_lists(self, list1, list2): merged_list = [] i, j = 0, 0 while i < len(list1) and j < len(list2): if list1[i] <= list2[j]: merged_list.append(list1[i]) i += 1 else: merged_list.append(list2[j]) j += 1 while i < len(list1): merged_list.append(list1[i]) i += 1 while j < len(list2): merged_list.append(list2[j]) j += 1 return merged_list def reverse_ordered_stack(ordered_stack): reversed_stack = OrderedStack() reversed_stack.stack = ordered_stack.stack[::-1] return reversed_stack"},{"question":"Hamming Weight Calculation with Extended Functionality You are given two functions `count_ones_recur(n)` and `count_ones_iter(n)` that use Brian Kernighan\'s Algorithm to count \'1\' bits in a binary representation of an unsigned integer. Your task is to implement a new function `count_ones_list(lst)` that, given a list of unsigned integers, returns a list of their Hamming weights. # Input Format - A list of unsigned integers `lst` where `1 <= len(lst) <= 10^5` and each integer `0 <= lst[i] < 2^32`. # Output Format - A list of integers representing the number of \'1\' bits for each input integer in the same order. # Constraints - You may use the `count_ones_iter` function internally if needed. - Your solution must be efficient with respect to time and space complexities. # Function Signature ```python def count_ones_list(lst: List[int]) -> List[int]: pass ``` # Example ```python # Example Input lst = [3, 5, 7, 11] # Example Output # 3 -> 00000000000000000000000000000011 -> 2 \'1\' bits # 5 -> 00000000000000000000000000000101 -> 2 \'1\' bits # 7 -> 00000000000000000000000000000111 -> 3 \'1\' bits # 11 -> 00000000000000000000000000001011 -> 3 \'1\' bits # Output will be: [2, 2, 3, 3] result = count_ones_list(lst) print(result) # Output: [2, 2, 3, 3] ``` # Additional Notes - Your solution should handle the given constraints and be optimized to run efficiently even for the upper limits.","solution":"from typing import List def count_ones_recur(n: int) -> int: Counts the number of \'1\' bits in the binary representation of an integer using recursion and Brian Kernighan\'s Algorithm. This is for demonstration purposes and won\'t be used in the final implementation. if n == 0: return 0 return 1 + count_ones_recur(n & (n - 1)) def count_ones_iter(n: int) -> int: Counts the number of \'1\' bits in the binary representation of an integer using an iterative approach and Brian Kernighan\'s Algorithm. count = 0 while n: n &= (n - 1) count += 1 return count def count_ones_list(lst: List[int]) -> List[int]: Given a list of unsigned integers, returns a list of their Hamming weights. Uses the count_ones_iter function internally as it is efficient and concise. return [count_ones_iter(x) for x in lst]"},{"question":"# Graph Shortest Path Implementation Scenario: You are tasked with developing a function that finds the shortest path in an unweighted graph. The function should use Breadth-First Search (BFS) to ensure that the path found is the shortest in terms of the number of edges. Requirements: 1. Implement the `shortest_path(graph, start, goal)` function. 2. The function should return the shortest path from the `start` node to the `goal` node as a list of nodes. If no path exists, return an empty list. 3. The graph is represented using an adjacency list (a dictionary where keys are nodes and values are lists of adjacent nodes). Function Signature: ```python def shortest_path(graph: dict, start: int, goal: int) -> list: pass ``` Input: - `graph`: A dictionary representing the graph where nodes are integers. - `start`: An integer representing the starting node. - `goal`: An integer representing the goal node. Output: - A list of integers representing the shortest path from `start` to `goal`, inclusive. If no path exists, return an empty list. Constraints: - The graph can have up to 1000 nodes. - No weights on the edges (unweighted graph). Example: ```python graph = { 1: [2, 4], 2: [1, 3, 4], 3: [2, 4, 5], 4: [1, 2, 3], 5: [3] } print(shortest_path(graph, 1, 5)) # Output: [1, 2, 3, 5] print(shortest_path(graph, 1, 8)) # Output: [] ```","solution":"from collections import deque def shortest_path(graph: dict, start: int, goal: int) -> list: Finds the shortest path in an unweighted graph using BFS. :param graph: A dictionary representing the graph :param start: The starting node :param goal: The goal node :return: The shortest path as a list of nodes, or an empty list if no path exists if start == goal: return [start] visited = set() # A set to keep track of visited nodes queue = deque([(start, [start])]) # Queue for BFS, stores tuples of (current_node, path_to_current_node) while queue: current_node, path = queue.popleft() if current_node in visited: continue visited.add(current_node) for neighbor in graph.get(current_node, []): if neighbor == goal: return path + [neighbor] else: queue.append((neighbor, path + [neighbor])) return []"},{"question":"# B-Tree Operations Implementation Problem Statement Design and implement a B-tree class that supports the following operations efficiently: 1. **Search** for a key in the B-tree. 2. **Insert** a new key in the B-tree. 3. **Delete** an existing key from the B-tree. 4. **Traverse** the B-tree in sorted order. Context A library management system uses a B-tree to store and manage book identifiers due to its efficient search, insertion, and deletion operations. Each book identifier is a unique integer. The system\'s primary requirements are to quickly find, add, remove, and list book identifiers in ascending order. Requirements 1. **Class Definition**: Define a class `MyBTree` with methods for insertion, deletion, search, and traversal. 2. **Node Definition**: Define a nested class `Node` to represent the nodes of the B-tree. 3. **Constructor**: Initialize the B-tree with a user-defined degree `t` (minimum degree of the B-tree). 4. **Method `insert(self, key: int) -> None`**: Insert a key into the B-tree. 5. **Method `search(self, key: int) -> bool`**: Search for a key in the B-tree and return `True` if found, otherwise return `False`. 6. **Method `delete(self, key: int) -> None`**: Delete a key from the B-tree. 7. **Method `traverse(self) -> List[int]`**: Traverse the B-tree and return a list of keys in sorted order. Input and Output - **Insert Method**: - **Input**: An integer `key`. - **Output**: None. - **Search Method**: - **Input**: An integer `key`. - **Output**: A boolean value. - **Delete Method**: - **Input**: An integer `key`. - **Output**: None. - **Traverse Method**: - **Input**: None. - **Output**: A list of integers representing keys in sorted order. Constraints - All keys are unique integers. - The degree `t` of the B-tree is greater than or equal to 2. - Handle edge cases such as inserting duplicate keys, deleting non-existent keys, and searching in an empty tree. Example ```python tree = MyBTree(t=3) tree.insert(10) tree.insert(20) tree.insert(5) tree.insert(6) tree.insert(12) tree.insert(30) tree.insert(7) tree.insert(17) assert tree.traverse() == [5, 6, 7, 10, 12, 17, 20, 30] assert tree.search(10) == True assert tree.search(15) == False tree.delete(6) assert tree.traverse() == [5, 7, 10, 12, 17, 20, 30] tree.delete(15) # Key not found tree.delete(10) assert tree.traverse() == [5, 7, 12, 17, 20, 30] ```","solution":"class MyBTree: class Node: def __init__(self, t, leaf=False): self.t = t self.leaf = leaf self.keys = [] self.children = [] def __init__(self, t): self.t = t self.root = self.Node(t, leaf=True) def traverse(self, node=None): if node is None: node = self.root result = [] for i in range(len(node.keys)): if not node.leaf: result.extend(self.traverse(node.children[i])) result.append(node.keys[i]) if not node.leaf: result.extend(self.traverse(node.children[-1])) return result def search(self, key, node=None): if node is None: node = self.root i = 0 while i < len(node.keys) and key > node.keys[i]: i += 1 if i < len(node.keys) and node.keys[i] == key: return True if node.leaf: return False return self.search(key, node.children[i]) def insert(self, key): root = self.root if len(root.keys) == 2 * self.t - 1: new_node = self.Node(self.t) self.root = new_node new_node.children.append(root) self._split_child(new_node, 0) self._insert_non_full(new_node, key) else: self._insert_non_full(root, key) def _insert_non_full(self, node, key): i = len(node.keys) - 1 if node.leaf: node.keys.append(0) while i >= 0 and key < node.keys[i]: node.keys[i + 1] = node.keys[i] i -= 1 node.keys[i + 1] = key else: while i >= 0 and key < node.keys[i]: i -= 1 i += 1 if len(node.children[i].keys) == 2 * self.t - 1: self._split_child(node, i) if key > node.keys[i]: i += 1 self._insert_non_full(node.children[i], key) def _split_child(self, parent, i): t = self.t node = parent.children[i] new_node = self.Node(t, node.leaf) parent.children.insert(i + 1, new_node) parent.keys.insert(i, node.keys[t - 1]) new_node.keys = node.keys[t: (2 * t - 1)] node.keys = node.keys[: (t - 1)] if not node.leaf: new_node.children = node.children[t:] node.children = node.children[:t] def delete(self, key): self._delete(self.root, key) if not self.root.keys: if not self.root.leaf: self.root = self.root.children[0] else: self.root = self.Node(self.t, leaf=True) def _delete(self, node, key): t = self.t i = 0 while i < len(node.keys) and key > node.keys[i]: i += 1 if node.leaf: if i < len(node.keys) and node.keys[i] == key: node.keys.pop(i) return if i < len(node.keys) and node.keys[i] == key: self._delete_internal_node(node, key, i) else: if len(node.children[i].keys) < t: self._fill(node, i) self._delete(node.children[i], key) def _delete_internal_node(self, node, key, i): t = self.t if len(node.children[i].keys) >= t: pred_key = self._get_pred(node, i) node.keys[i] = pred_key self._delete(node.children[i], pred_key) elif len(node.children[i + 1].keys) >= t: succ_key = self._get_succ(node, i) node.keys[i] = succ_key self._delete(node.children[i + 1], succ_key) else: self._merge(node, i) self._delete(node.children[i], key) def _get_pred(self, node, i): current = node.children[i] while not current.leaf: current = current.children[-1] return current.keys[-1] def _get_succ(self, node, i): current = node.children[i + 1] while not current.leaf: current = current.children[0] return current.keys[0] def _fill(self, node, i): t = self.t if i != 0 and len(node.children[i - 1].keys) >= t: self._borrow_from_prev(node, i) elif i != len(node.children) - 1 and len(node.children[i + 1].keys) >= t: self._borrow_from_next(node, i) else: if i != len(node.children) - 1: self._merge(node, i) else: self._merge(node, i - 1) def _borrow_from_prev(self, node, i): child = node.children[i] sibling = node.children[i - 1] child.keys.insert(0, node.keys[i - 1]) if not child.leaf: child.children.insert(0, sibling.children.pop()) node.keys[i - 1] = sibling.keys.pop() def _borrow_from_next(self, node, i): child = node.children[i] sibling = node.children[i + 1] child.keys.append(node.keys[i]) if not child.leaf: child.children.append(sibling.children.pop(0)) node.keys[i] = sibling.keys.pop(0) def _merge(self, node, i): child = node.children[i] sibling = node.children[i + 1] child.keys.append(node.keys.pop(i)) child.keys.extend(sibling.keys) if not child.leaf: child.children.extend(sibling.children) node.children.pop(i + 1)"},{"question":"Custom Bucket Sort Implementation You are tasked with implementing a modified version of the bucket sort algorithm. Given an array of floating-point numbers between 0 and 1, you need to sort the array in ascending order. Instructions: 1. **Function Signature**: Implement the function `custom_bucket_sort(arr: List[float]) -> List[float]`. 2. **Input**: * `arr` - a list of floating-point numbers between 0 and 1 (inclusive). 3. **Output**: * A new list with the same elements sorted in ascending order. 4. **Constraints**: * You cannot use built-in sort functions (e.g., `sorted()`, `sort()`). * Optimize your solution for performance, favoring algorithms that scale well with n. * Assume the array can be very large. Examples: Input: [0.23, 0.45, 0.12, 0.36, 0.29] Output: [0.12, 0.23, 0.29, 0.36, 0.45] Notes: * Ensure that your algorithm handles edge cases such as arrays with one element and empty arrays. * Carefully choose the number of buckets to balance the number of elements within each bucket. * Each bucket should be sorted using a suitable algorithm of your choice. * The method chosen for sorting within buckets should ensure the overall efficiency of the algorithm.","solution":"from typing import List def custom_bucket_sort(arr: List[float]) -> List[float]: Sorts a list of floating-point numbers between 0 and 1 in ascending order using bucket sort algorithm. if not arr: return [] # Step 1: Create a number of empty buckets num_buckets = len(arr) buckets = [[] for _ in range(num_buckets)] # Step 2: Distribute the elements into the buckets for num in arr: index = int(num * num_buckets) buckets[index].append(num) # Step 3: Sort individual buckets for bucket in buckets: bucket.sort() # Step 4: Concatenate all sorted buckets sorted_arr = [] for bucket in buckets: sorted_arr.extend(bucket) return sorted_arr"},{"question":"# RSA Encryption and Decryption (Advanced) You are tasked to implement a secure communication channel using the RSA encryption algorithm. This requires generating keys (public and private), encrypting a message, and then decrypting it. **Function Specifications**: 1. **generate_key(k: int, seed: int = None) -> Tuple[int, int, int]**: - **Input**: an integer `k` representing the bit-length of the modulus, and an optional integer `seed` for random number generation. - **Output**: a tuple of three integers `(n, e, d)` where `n` is the modulus, `e` is the public exponent, and `d` is the private exponent. 2. **encrypt(data: int, e: int, n: int) -> int**: - **Input**: an integer `data` representing the plaintext, and two integers `e` and `n` representing the public key. - **Output**: an integer representing the encrypted data. 3. **decrypt(data: int, d: int, n: int) -> int**: - **Input**: an integer `data` representing the ciphertext, and two integers `d` and `n` representing the private key. - **Output**: an integer representing the decrypted data (original plaintext). Write your implementation for these functions ensuring correctness and efficiency. **Constraints**: - **k** will be at least 16 and at most 1024. - `data` will be a non-negative integer less than `n`. **Performance Requirements**: - Efficient prime checking and modular arithmetic. - Ensure solution runs effectively for the maximum constraint inputs. **Edge Cases**: - Ensure handling of invalid `k` values (should be multiple of 4). - Test with boundary values (e.g., small `data`, various `seed`). **Functional Context**: You will need these functions for a secure messaging application where messages will be encrypted by the sender using the receiver\'s public key and decrypted by the receiver using their private key. # Example Usage ```python n, e, d = generate_key(16) data = 42 encrypted_data = encrypt(data, e, n) decrypted_data = decrypt(encrypted_data, d, n) assert decrypted_data == data # Should be true if encryption and decryption are correct ```","solution":"import random from sympy import isprime, mod_inverse def generate_prime_number(bit_length): while True: num = random.getrandbits(bit_length) if isprime(num): return num def generate_key(k: int, seed: int = None): if k % 4 != 0: raise ValueError(\\"Bit length k must be a multiple of 4\\") if seed is not None: random.seed(seed) half_k = k // 2 p = generate_prime_number(half_k) q = generate_prime_number(half_k) n = p * q phi_n = (p - 1) * (q - 1) e = 65537 d = mod_inverse(e, phi_n) return (n, e, d) def encrypt(data: int, e: int, n: int) -> int: return pow(data, e, n) def decrypt(data: int, d: int, n: int) -> int: return pow(data, d, n)"},{"question":"# Red-Black Tree Modification Problem A Red-Black Tree (RBT) is a self-balancing binary search tree with specific properties ensuring that the tree remains reasonably balanced. Your task is to implement key functionalities of an RBT, specifically handling insertion while maintaining the balance properties. # Problem Statement Implement a Red-Black Tree data structure with the following functionalities: 1. **Insert a Node**: Insert a given value into the RBT while maintaining the tree properties. 2. **Inorder Traversal**: Return the inorder traversal of the tree as a list of values. 3. **Search for a Value**: Return True if a specific value exists in the tree, otherwise return False. You need to account for: * The structure and properties of a Red-Black Tree. * Handling edge cases such as inserting in an empty tree, duplicate values, and maintaining balance properties. # Input and Output Formats **Insert a Node** * Input: An integer value to be inserted. * Output: None. **Inorder Traversal** * Input: None. * Output: List of integers representing inorder traversal of the RBT. **Search for a Value** * Input: An integer value to search. * Output: Boolean indicating whether the value is present in the tree. # Constraints * Nodes contain only integer values. * Duplicate insertions should be ignored. * Maximum number of nodes (n): 1 leq n leq 10^4 * Values are integer within range: -10^6 leq value leq 10^6 # Example Suppose you create an empty RBT and insert the values [11, 2, 14, 1, 7, 15, 5, 8, 4] in that order. Input: Inserting values one by one into the tree: ``` 11, 2, 14, 1, 7, 15, 5, 8, 4 ``` Search for value: ``` 8 ``` Inorder traversal request Output: Search for value 8: ``` True ``` Inorder traversal: ``` [1, 2, 4, 5, 7, 8, 11, 14, 15] ``` Method Signatures: ```python class RBTree: def __init__(self): pass def insert(self, value: int) -> None: pass def inorder(self) -> List[int]: pass def search(self, value: int) -> bool: pass ``` Implement the above-class `RBTree` to perform the insert, search, and inorder traversal operations.","solution":"class RBTreeNode: def __init__(self, value, color=\\"red\\"): self.value = value self.color = color # \\"red\\" or \\"black\\" self.left = None self.right = None self.parent = None class RBTree: def __init__(self): self.nil = RBTreeNode(value=None, color=\\"black\\") # Sentinel node for leaves self.root = self.nil def insert(self, value: int) -> None: new_node = RBTreeNode(value) new_node.left = new_node.right = self.nil parent = None current = self.root while current != self.nil: parent = current if new_node.value < current.value: current = current.left elif new_node.value > current.value: current = current.right else: return # Ignore duplicates new_node.parent = parent if parent is None: self.root = new_node elif new_node.value < parent.value: parent.left = new_node else: parent.right = new_node new_node.color = \\"red\\" self._insert_fix(new_node) def _insert_fix(self, node): while node.parent and node.parent.color == \\"red\\": grandparent = node.parent.parent if node.parent == grandparent.left: uncle = grandparent.right if uncle.color == \\"red\\": node.parent.color = \\"black\\" uncle.color = \\"black\\" grandparent.color = \\"red\\" node = grandparent else: if node == node.parent.right: node = node.parent self._left_rotate(node) node.parent.color = \\"black\\" grandparent.color = \\"red\\" self._right_rotate(grandparent) else: uncle = grandparent.left if uncle.color == \\"red\\": node.parent.color = \\"black\\" uncle.color = \\"black\\" grandparent.color = \\"red\\" node = grandparent else: if node == node.parent.left: node = node.parent self._right_rotate(node) node.parent.color = \\"black\\" grandparent.color = \\"red\\" self._left_rotate(grandparent) self.root.color = \\"black\\" def _left_rotate(self, x): y = x.right x.right = y.left if y.left != self.nil: y.left.parent = x y.parent = x.parent if x.parent is None: self.root = y elif x == x.parent.left: x.parent.left = y else: x.parent.right = y y.left = x x.parent = y def _right_rotate(self, y): x = y.left y.left = x.right if x.right != self.nil: x.right.parent = y x.parent = y.parent if y.parent is None: self.root = x elif y == y.parent.right: y.parent.right = x else: y.parent.left = x x.right = y y.parent = x def inorder(self) -> list: result = [] self._inorder_helper(self.root, result) return result def _inorder_helper(self, node, result): if node != self.nil: self._inorder_helper(node.left, result) result.append(node.value) self._inorder_helper(node.right, result) def search(self, value: int) -> bool: current = self.root while current != self.nil: if value == current.value: return True elif value < current.value: current = current.left else: current = current.right return False"},{"question":"Topological Sorting on a Directed Graph **Context**: A key application of directed acyclic graphs (DAGs) is determining the order in which tasks should be performed where some tasks must be done before others. Topological Sort is the algorithm to produce such an ordering. Given the classes for `Node`, `DirectedEdge`, and `DirectedGraph` provided above, your task is to implement the topological sort algorithm for the `DirectedGraph` class. **Instructions**: 1. Add a method `topological_sort` to the `DirectedGraph` class. 2. The method should return a list of `Node` instances representing the topological ordering of nodes in the graph. 3. Raise an exception if the graph contains a cycle, as topological sorting is not possible. **Input**: - No direct input. Use the `DirectedGraph` class provided. **Output**: - A list of `Node` instances representing the topological order. **Constraints**: - The graph may have up to 1,000 nodes and 10,000 edges. - The graph is not guaranteed to be connected. **Example**: Assuming the graph contains the following nodes and edges: - Nodes: `[\'A\', \'B\', \'C\', \'D\']` - Edges: `[\'A\' -> \'B\', \'B\' -> \'C\', \'A\' -> \'C\', \'C\' -> \'D\']` A possible topological sort order would be: `[A, B, C, D]`. ```python def topological_sort(self): Perform topological sort on the directed graph and return the ordering of nodes. Returns: list of Node: Nodes in topological order. Raises: Exception: If the graph contains a cycle. # Your implementation here ```","solution":"class Node: def __init__(self, value): self.value = value self.edges = [] class DirectedEdge: def __init__(self, from_node, to_node): self.from_node = from_node self.to_node = to_node class DirectedGraph: def __init__(self): self.nodes = [] self.adjacency_list = {} def add_node(self, node): self.nodes.append(node) self.adjacency_list[node] = [] def add_edge(self, edge): if edge.from_node not in self.adjacency_list: self.adjacency_list[edge.from_node] = [] self.adjacency_list[edge.from_node].append(edge.to_node) def topological_sort(self): Perform topological sort on the directed graph and return the ordering of nodes. Returns: list of Node: Nodes in topological order. Raises: Exception: If the graph contains a cycle. def dfs(node): if visiting[node]: raise Exception(\\"Graph contains a cycle\\") if not visited[node]: visiting[node] = True for neighbor in self.adjacency_list[node]: dfs(neighbor) visiting[node] = False visited[node] = True order.append(node) visited = {node: False for node in self.nodes} visiting = {node: False for node in self.nodes} order = [] for node in self.nodes: if not visited[node]: dfs(node) return order[::-1]"},{"question":"You are given a set of utility functions to convert between integers and their byte representations in big-endian and little-endian formats. Your task is to implement a new function that leverages these conversions to perform the following task: # Context Imagine you are designing a network protocol that requires a specific byte sequence to be sent over the network. The byte sequence starts with a 4-byte integer header in big-endian format, followed by the payload length in little-endian format. # Specifications - **Function Name**: `create_network_packet` - **Input**: - An integer `header` (0 <= header < 2^32) - A list of bytes `payload` in the form of a list of integers (0 <= byte < 256) - **Output**: A single byte sequence that: 1. Starts with the 4-byte big-endian representation of the `header`. 2. Followed by the 4-byte little-endian representation of the length of the `payload`. 3. Followed finally by the `payload` itself. # Example ```python header = 305419896 payload = [100, 101, 102, 103] # The resulting byte sequence should be: # Big endian of 305419896 -> b\'x12x34x56x78\' # Little endian of length of payload (4) -> b\'x04x00x00x00\' # payload remains the same -> b\'x64x65x66x67\' # Combined result -> b\'x12x34x56x78x04x00x00x00x64x65x66x67\' ``` # Your Task Implement the `create_network_packet` function to generate the described byte sequence. ```python def create_network_packet(header, payload): # Import existing utility functions from collections import deque def int_to_bytes_big_endian(num): bytestr = deque() while num > 0: bytestr.appendleft(num & 0xff) num >>= 8 return bytes(bytestr) def int_to_bytes_little_endian(num): bytestr = [] while num > 0: bytestr.append(num & 0xff) num >>= 8 return bytes(bytestr) # Solution implementation here ``` # Constraints - The function should handle any valid integer header within the specified range. - The payload list can be of any length including zero. # Notes - The utility functions provided should be used in your implementation. - Ensure the resulting byte sequence is constructed efficiently.","solution":"def create_network_packet(header, payload): from collections import deque def int_to_bytes_big_endian(num): bytestr = deque() for _ in range(4): bytestr.appendleft(num & 0xff) num >>= 8 return bytes(bytestr) def int_to_bytes_little_endian(num): bytestr = [] for _ in range(4): bytestr.append(num & 0xff) num >>= 8 return bytes(bytestr) header_bytes = int_to_bytes_big_endian(header) payload_length = int_to_bytes_little_endian(len(payload)) payload_bytes = bytes(payload) return header_bytes + payload_length + payload_bytes"},{"question":"# Scenario: Imagine you are working on a low-level data processing module where efficiency is crucial. In this module, you need precise control over individual bits of a number. To facilitate this, you need to implement a bit manipulation function that supports a specific set of operations. # Task: You are required to implement a function `bit_manipulation(num, index, operation, value=None)` which supports the following operations on the bits of an integer: 1. `\\"GET\\"`: Retrieve the bit at the specified index. 2. `\\"SET\\"`: Set the bit at the specified index to `1`. 3. `\\"CLEAR\\"`: Clear the bit at the specified index to `0`. 4. `\\"UPDATE\\"`: Update the bit at the specified index to the specified value (`0` or `1`). # Function Signature: ```python def bit_manipulation(num: int, index: int, operation: str, value: int = None) -> int: ``` # Input: - `num`: an integer whose bits need to be manipulated. - `index`: an integer representing the bit position. - `operation`: a string (`\\"GET\\"`, `\\"SET\\"`, `\\"CLEAR\\"`, or `\\"UPDATE\\"`) indicating the operation to be performed. - `value`: an optional integer (`0` or `1`), used only when the operation is `\\"UPDATE\\"`. # Output: - For `\\"GET\\"` operation: Return the bit (`0` or `1`) at the specified index. - For `\\"SET\\"`, `\\"CLEAR\\"`, and `\\"UPDATE\\"` operations: Return the modified number after performing the specified operation. # Constraints: - You may assume `index` is a non-negative integer. - For `\\"UPDATE\\"` operation, `value` will be either `0` or `1`. # Example cases: ```python # Example 1 assert bit_manipulation(10, 1, \\"GET\\") == 1 # 10 in binary is 1010, so bit at index 1 is 1 # Example 2 assert bit_manipulation(10, 2, \\"SET\\") == 14 # 10 in binary is 1010, setting bit at index 2 gives 1110 which is 14 # Example 3 assert bit_manipulation(10, 1, \\"CLEAR\\") == 8 # 10 in binary is 1010, clearing bit at index 1 gives 1000 which is 8 # Example 4 assert bit_manipulation(10, 2, \\"UPDATE\\", 0) == 10 # 10 in binary is 1010, updating bit at index 2 to 0 remains 1010 assert bit_manipulation(10, 1, \\"UPDATE\\", 0) == 8 # 10 in binary is 1010, updating bit at index 1 to 0 gives 1000 which is 8 ``` # Note: - You are expected to utilize the fundamental bit operations (get_bit, set_bit, clear_bit, update_bit) analyzed earlier. - Ensure your solution handles the specified operations accurately and efficiently.","solution":"def bit_manipulation(num: int, index: int, operation: str, value: int = None) -> int: Manipulate the bit at the specified index of the given number according to the given operation. :param num: The integer whose bit needs to be manipulated. :param index: The position of the bit to be manipulated. :param operation: The operation to be performed: \\"GET\\", \\"SET\\", \\"CLEAR\\", or \\"UPDATE\\". :param value: The value to update the bit with for \\"UPDATE\\" operation (0 or 1). Default is None. :return: The manipulated number or the bit value at the specified index. if operation == \\"GET\\": return (num >> index) & 1 elif operation == \\"SET\\": return num | (1 << index) elif operation == \\"CLEAR\\": return num & ~(1 << index) elif operation == \\"UPDATE\\": if value is None: raise ValueError(\\"Value must be provided for UPDATE operation\\") if value == 1: return num | (1 << index) else: return num & ~(1 << index) else: raise ValueError(\\"Invalid operation\\") # Example usage: # print(bit_manipulation(10, 1, \\"GET\\")) # Expected output: 1 # print(bit_manipulation(10, 2, \\"SET\\")) # Expected output: 14 # print(bit_manipulation(10, 1, \\"CLEAR\\")) # Expected output: 8 # print(bit_manipulation(10, 2, \\"UPDATE\\", 0)) # Expected output: 10 # print(bit_manipulation(10, 1, \\"UPDATE\\", 0)) # Expected output: 8"},{"question":"You are given a singly linked list where each node contains an integer value. Your task is to implement a function that checks if the linked list is sorted in increasing order. However, in the provided linked list, there might be duplicate values and your function should consider such lists as sorted. Write a function `is_sorted_with_duplicates()` that accepts the head of a linked list and returns True if the list is sorted (increasing order with possible duplicates) and False otherwise. An empty list should be considered sorted. Function Signature ```python def is_sorted_with_duplicates(head: \'ListNode\') -> bool: ``` Input - `head`: The head node of a singly linked list. A singly linked list is a class `ListNode` where each node has `.val` (the integer value) and `.next` (reference to the next node). Output - Return `True` if the linked list is sorted in increasing order (with possible duplicates), and `False` otherwise. Constraints - The linked list can contain negative and positive integers. - The linked list may also contain duplicate values. - If the linked list is empty, return `True`. Example ```python # Example ListNode class definition class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next # Example usage # Linked List: 1 -> 2 -> 2 -> 3 head = ListNode(1, ListNode(2, ListNode(2, ListNode(3)))) print(is_sorted_with_duplicates(head)) # Output: True # Linked List: 3 -> 1 -> 4 -> 2 head = ListNode(3, ListNode(1, ListNode(4, ListNode(2)))) print(is_sorted_with_duplicates(head)) # Output: False ```","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def is_sorted_with_duplicates(head: ListNode) -> bool: current = head while current and current.next: if current.val > current.next.val: return False current = current.next return True"},{"question":"You have been tasked with implementing a data structure for storing and searching words that efficiently allows for both direct word searches and pattern searches using the dot (`.`) character, which can match any letter. # Requirements: 1. Implement a `WordTrie` class to support the operations: * `add_word(word)`: Add a word to the data structure. * `search(word)`: Search for a word or a pattern in the data structure using `.` to represent any letter. 2. Your implementation should conform to the following constraints and conditions: * All words and pattern searches contain only lowercase English letters (`a-z`) and the `.` character for patterns. * Words and patterns are non-empty and have a maximum length of 26. # Input: * `word` - a string representing the word to be inserted or searched. * `pattern` - a string representing the pattern to be searched, may include dot (`.`) characters. # Output: * For `add_word(word)`, there is no output. * For `search(word/pattern)`, return a boolean indicating whether the word or pattern match exists in the data structure. Example: ```python trie = WordTrie() trie.add_word(\\"bad\\") trie.add_word(\\"dad\\") trie.add_word(\\"mad\\") print(trie.search(\\"pad\\")) # -> False print(trie.search(\\"bad\\")) # -> True print(trie.search(\\".ad\\")) # -> True print(trie.search(\\"b..\\")) # -> True ``` # Implementation Constraints: * Your solution must implement: * Efficient insertion and search operations. * Appropriate handling and recursive traversal for `.` characters in the pattern.","solution":"class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False class WordTrie: def __init__(self): self.root = TrieNode() def add_word(self, word): current = self.root for char in word: if char not in current.children: current.children[char] = TrieNode() current = current.children[char] current.is_end_of_word = True def search(self, word): def search_in_node(word, node): for i, char in enumerate(word): if char == \'.\': for child in node.children.values(): if search_in_node(word[i + 1:], child): return True return False else: if char not in node.children: return False node = node.children[char] return node.is_end_of_word return search_in_node(word, self.root)"},{"question":"Context You are playing a game where you need to decompose a number into all possible products of factors. For example, for the number 12, possible factorizations would be [2, 6], [2, 2, 3], and [3, 4]. Task Write a function `find_factor_combinations` that takes an integer `n` and returns all possible combinations of its factors, excluding 1 and `n`. Each combination must be sorted in ascending order. Function Signature ```python def find_factor_combinations(n: int) -> List[List[int]]: ``` Input * An integer `n` (2 ≤ n ≤ 10^4). Output * A list of lists, where each list contains integers representing a combination of factors of `n`. Constraints * Factors in each combination should be greater than 1 and less than `n`. * The order of combinations in the output list does not matter. Examples ```python print(find_factor_combinations(8)) # Output: [[2, 4], [2, 2, 2]] print(find_factor_combinations(37)) # Output: [] print(find_factor_combinations(12)) # Output: [[2, 6], [2, 2, 3], [3, 4]] print(find_factor_combinations(32)) #Output: [[2, 16], [2, 2, 8], [2, 2, 2, 4], [2, 2, 2, 2, 2], [2, 4, 4], [4, 8]] ``` Notes * Although the direct results of factorization may include combinations like [4, 8] and [8, 4], only the sorted order [4, 8] should be included in the final result.","solution":"from typing import List def find_factor_combinations(n: int) -> List[List[int]]: def backtrack(start, product, path): if product == 1: if len(path) > 1: results.append(path) return for i in range(start, n): if product % i == 0: backtrack(i, product // i, path + [i]) results = [] backtrack(2, n, []) return results"},{"question":"**Objective**: Write a Python function to find the **k shortest paths** between two nodes in an unweighted graph. **Scenario**: You are working with a navigation system where you need not just the shortest path but multiple shortest paths to provide alternate routes in case of obstructions or traffic. Given a graph represented as an adjacency list and two nodes in this graph, implement a function that returns the k shortest paths from the start node to the end node. # Function Specification ```python def find_k_shortest_paths(graph, start, end, k): Find the k shortest paths between two nodes in an unweighted graph. Parameters: graph (dict): The graph represented as an adjacency list. start: The starting node. end: The ending node. k (int): The number of shortest paths to find. Returns: list: A list of k paths, each path is a list of nodes. pass ``` # Input - `graph`: A dictionary where keys are nodes and values are lists of adjacent nodes. - `start`: The starting node. - `end`: The ending node. - `k`: The number of shortest paths to find. # Output - A list of k paths, each path being a list of nodes representing a route from the start node to the end node. # Constraints - The graph is unweighted. - The number of nodes V and the number of edges E in the graph are constrained such that 1 ≤ V, E ≤ 1000. - The path should not contain cycles. # Example Given the graph: ```python graph = { \'A\': [\'B\', \'C\'], \'B\': [\'A\', \'D\', \'E\'], \'C\': [\'A\', \'F\'], \'D\': [\'B\'], \'E\': [\'B\', \'F\'], \'F\': [\'C\', \'E\'] } ``` and parameters `start = \'A\'`, `end = \'F\'`, and `k = 2`, a function call may return: ```python [[\'A\', \'B\', \'E\', \'F\'], [\'A\', \'C\', \'F\']] ``` # Notes 1. Consider the efficiency of your solution, as time complexity may become a concern for large graphs and high values of k. 2. Ensure that edge cases such as disconnected graphs or no paths available are handled gracefully.","solution":"from collections import deque def find_k_shortest_paths(graph, start, end, k): Find the k shortest paths between two nodes in an unweighted graph. Parameters: graph (dict): The graph represented as an adjacency list. start: The starting node. end: The ending node. k (int): The number of shortest paths to find. Returns: list: A list of k paths, each path is a list of nodes. if start == end: return [[start]] paths = [] queue = deque([(start, [start])]) while queue and len(paths) < k: current_node, current_path = queue.popleft() for neighbor in graph.get(current_node, []): if neighbor not in current_path: new_path = current_path + [neighbor] if neighbor == end: paths.append(new_path) if len(paths) == k: break else: queue.append((neighbor, new_path)) if len(paths) == k: break return paths"},{"question":"# DFA Implementation Challenge Context A Deterministic Finite Automaton (DFA) is used to determine if a given input string is accepted by the automaton. To test your knowledge of state-based pattern recognition, you are asked to implement a function for processing strings based on a given DFA. Task You need to complete the `DFA` function provided below: ```python def DFA(transitions, start, final, string): Determines if the input string is accepted by the given DFA. Parameters: transitions (dict): A dictionary where keys are states and values are dictionaries that represent the state transitions based on input characters. start (int): The starting state of the DFA. final (list): A list of accepting states. string (str): The input string to be processed by the DFA. Returns: bool: True if the string is accepted by the DFA, False otherwise. # Your implementation here ``` Input and Output - **Input:** - `transitions`: A dictionary representing the state transition table. E.g., `{0: {\'a\': 1}, 1: {\'b\': 0}}` - `start`: An integer representing the start state. E.g., `0` - `final`: A list of integers representing the accepting states. E.g., `[1]` - `string`: A string to be processed. E.g., `\\"ab\\"` - **Output:** - `True` if the string is accepted by the DFA (ends in an accepting state), `False` otherwise. Constraints - Assume all characters in the input string appear in the transition table. - The DFA described by the transitions dictionary is properly defined (no missing transitions). Example ```python transitions = { 0: {\'a\': 1, \'b\': 0}, 1: {\'a\': 1, \'b\': 2}, 2: {\'a\': 2, \'b\': 2} } start = 0 final = [2] string = \\"ab\\" # DFA(0) -> \'a\' -> state 1, DFA(1) -> \'b\' -> state 2 (Accepting state) print(DFA(transitions, start, final, string)) # Output: True ``` Implement the function and test it with various test cases to ensure its correctness.","solution":"def DFA(transitions, start, final, string): Determines if the input string is accepted by the given DFA. Parameters: transitions (dict): A dictionary where keys are states and values are dictionaries that represent the state transitions based on input characters. start (int): The starting state of the DFA. final (list): A list of accepting states. string (str): The input string to be processed by the DFA. Returns: bool: True if the string is accepted by the DFA, False otherwise. current_state = start for char in string: if char in transitions[current_state]: current_state = transitions[current_state][char] else: return False return current_state in final"},{"question":"# Scenario You have been tasked with optimizing the food supply chain for a cluster of hospitals. Each hospital requires a list of prime numbers for their resource allocation algorithm, and given that each hospital has different requirements in terms of range for primes, your task is to implement a function that returns all prime numbers less than a given number `n`. # Problem Statement Implement the function `get_primes(n)` that returns all prime numbers less than `n`. Utilize the modified Sieve of Eratosthenes algorithm described above to optimize your solution\'s time and space complexity. # Function Specification ```python def get_primes(n: int) -> List[int]: Return list of all primes less than n, using a modified Sieve of Eratosthenes. Parameters: n (int): The upper limit (exclusive), must be a positive integer. Returns: List[int]: A list of prime numbers less than n. Raises: ValueError: If \'n\' is not a positive integer. ``` # Input and Output Formats * **Input**: * An integer `n` where `1 <= n <= 10^7`. * **Output**: * A list of integers, representing all prime numbers less than `n`. # Constraints 1. The value of `n` will be a positive integer within the given range. 2. Your algorithm should have a time complexity of approximately O(n log log n). # Examples ```python assert get_primes(10) == [2, 3, 5, 7] assert get_primes(20) == [2, 3, 5, 7, 11, 13, 17, 19] assert get_primes(1) == [] assert get_primes(2) == [] assert get_primes(29) == [2, 3, 5, 7, 11, 13, 17, 19, 23] ``` # Additional Notes * Ensure to address edge cases such as when `n` is less than 2. * Optimize for both time and space complexity. * Properly handle invalid inputs by raising a ValueError.","solution":"from typing import List def get_primes(n: int) -> List[int]: Return list of all primes less than n, using a modified Sieve of Eratosthenes. Parameters: n (int): The upper limit (exclusive), must be a positive integer. Returns: List[int]: A list of prime numbers less than n. Raises: ValueError: If \'n\' is not a positive integer. if n < 1: raise ValueError(\\"n must be a positive integer.\\") if n <= 2: return [] is_prime = [True] * n is_prime[0] = is_prime[1] = False # 0 and 1 are not primes for i in range(2, int(n**0.5) + 1): if is_prime[i]: for multiples in range(i*i, n, i): is_prime[multiples] = False return [i for i in range(2, n) if is_prime[i]]"},{"question":"# Scenario You are working on a system that requires efficient calculations involving binary data. Specifically, you need to accurately count the number of \'1\' bits in the binary representation of an unsigned integer. This information is crucial for performance optimizations in various binary operations and networking tasks. # Task Implement a function `hamming_weight(n: int) -> int` that takes an unsigned integer `n` and returns the number of \'1\' bits in its binary representation. You are required to use Brian Kernighan\'s Algorithm, leveraging the efficient methodology it provides. # Input - `n` (int): An unsigned integer (0 <= n <= 2^32 - 1). # Output - An integer representing the number of \'1\' bits in the binary representation of `n`. # Constraints - You must use Brian Kernighan\'s Algorithm as part of your solution. - The algorithm should handle typical edge cases gracefully. - Aim to implement an iterative approach, considering its efficiency in handling large inputs. # Examples 1. `hamming_weight(11)` should return `3`. - Explanation: 11 in binary is `1011`, which has three \'1\' bits. 2. `hamming_weight(128)` should return `1`. - Explanation: 128 in binary is `10000000`, which has one \'1\' bit. 3. `hamming_weight(255)` should return `8`. - Explanation: 255 in binary is `11111111`, which has eight \'1\' bits. 4. `hamming_weight(0)` should return `0`. - Explanation: 0 in binary is `0`, which has no \'1\' bits. # Function Signature ```python def hamming_weight(n: int) -> int: pass ``` Make sure to thoroughly test your solution and consider edge cases such as when `n` is 0 or when `n` has a high number of \'1\' bits.","solution":"def hamming_weight(n: int) -> int: Returns the number of \'1\' bits in the binary representation of an unsigned integer n using Brian Kernighan\'s Algorithm. count = 0 while n: n &= (n - 1) count += 1 return count"},{"question":"# Climbing Stairs with Additional Constraints You are climbing a staircase with `steps` number of stairs to reach the top. Each time, you can climb either 1, 2, or 3 steps. Your goal is to determine the number of distinct ways to reach the top. # Function Signature ```python def count_ways_to_climb(steps: int) -> int: pass ``` # Input * `steps`: an integer (1 ≤ steps ≤ 10^5) representing the total number of steps to be climbed. # Output * Return an integer representing the number of distinct ways to climb to the top. # Example ```python assert count_ways_to_climb(3) == 4 # [1-1-1, 1-2, 2-1, 3] assert count_ways_to_climb(4) == 7 # [1-1-1-1, 1-1-2, 1-2-1, 2-1-1, 2-2, 1-3, 3-1] ``` # Explanation In the examples: * For 3 steps: The possible combinations are: * (1, 1, 1) * (1, 2) * (2, 1) * (3) Thus, there are 4 ways to climb 3 steps. * For 4 steps: The possible combinations are: * (1, 1, 1, 1) * (1, 1, 2) * (1, 2, 1) * (2, 1, 1) * (2, 2) * (1, 3) * (3, 1) Thus, there are 7 ways to climb 4 steps. # Constraints and Performance Requirements * Your solution should run efficiently for `steps` up to 100,000. * Aim for a time complexity of O(n) and a space complexity of O(1). # Notes * Consider edge cases such as the smallest input (e.g., `steps = 1`).","solution":"def count_ways_to_climb(steps: int) -> int: Returns the number of distinct ways to climb to the top of a staircase with a given number of steps, where you can climb 1, 2, or 3 steps at a time. if steps == 1: return 1 elif steps == 2: return 2 elif steps == 3: return 4 # Dynamic Programming approach to keep track of previous three steps a, b, c = 1, 2, 4 for i in range(4, steps + 1): ways = a + b + c a, b, c = b, c, ways return c"},{"question":"You are tasked with implementing a WordDictionary class that supports adding words and searching patterns where dots (.) can represent any character. Your implementation should maintain efficient insertion and search operations. # Requirements: 1. **Class Signature**: ```python class WordDictionary: def __init__(self): # Initializes the data structure def add_word(self, word: str) -> None: # Adds a word into the data structure def search(self, word: str) -> bool: # Returns true if there is any string in the data structure # that matches the given word, else false ``` 2. **Functions**: - **add_word(word: str) -> None**: Adds a word into the WordDictionary. - **search(word: str) -> bool**: Returns true if there is any string in the WordDictionary that matches the given word or pattern (with \'.\'), otherwise returns false. # Input and Output Formats: - `add_word(word: str) -> None`: - **Input**: A string `word` containing lowercase alphabetic characters (1 <= word.length <= 500). - **Output**: None. - `search(word: str) -> bool`: - **Input**: A string `word` containing lowercase alphabetic characters and/or \'.\' wildcard characters (1 <= word.length <= 500). - **Output**: `True` if a matching word is found, `False` otherwise. # Constraints: - Assume all words only contain lowercase alphabetic characters (\'a\' to \'z\') and \'.\'. # Performance Requirements: - The add operation should be optimized for quickly adding new words. - The search operation should handle both literal searches and wildcard pattern searches efficiently. # Example: ```python dictionary = WordDictionary() dictionary.add_word(\\"bad\\") dictionary.add_word(\\"dad\\") dictionary.add_word(\\"mad\\") print(dictionary.search(\\"pad\\")) # Output: False print(dictionary.search(\\"bad\\")) # Output: True print(dictionary.search(\\".ad\\")) # Output: True print(dictionary.search(\\"b..\\")) # Output: True ``` **Note**: Implement the most appropriate data structures and algorithms to meet the requirements and ensure the operations are efficient. Additionally, address edge cases and optimize recursive search performance.","solution":"class WordDictionary: def __init__(self): self.trie = {} def add_word(self, word: str) -> None: node = self.trie for char in word: if char not in node: node[char] = {} node = node[char] node[\'#\'] = True # Mark the end of a word def search(self, word: str) -> bool: return self._search_in_node(word, 0, self.trie) def _search_in_node(self, word, index, node): if index == len(word): return \'#\' in node char = word[index] if char == \'.\': for child in node: if child != \'#\' and self._search_in_node(word, index + 1, node[child]): return True elif char in node: return self._search_in_node(word, index + 1, node[char]) return False"},{"question":"Context Max is learning about sorting algorithms in his computer science class, and he is introduced to Exchange Sort. While Max understands the basic concept, he is curious about implementing and optimizing it. Given your knowledge of algorithms, help him out by writing an optimized version of Exchange Sort that terminates early if the array is already sorted during a pass. Task You need to implement an optimized version of Exchange Sort called `optimized_exchange_sort(arr)`. The optimized version should include an enhancement to stop the algorithm early if no elements were swapped in a complete inner loop pass, indicating that the array is already sorted. Input and Output Format * **Input**: A list of integers, `arr`, where `2 <= len(arr) <= 1000`. * **Output**: A sorted list of integers. Constraints * Your implementation should improve the best-case time complexity, which is when the array is already sorted. * Do not use any built-in `sort()` or `sorted()` functions. * The sorting should be done in-place, i.e., without using extra lists. Example ```python # Input: [34, 7, 23, 32, 5, 62] # Output: [5, 7, 23, 32, 34, 62] # Input: [1, 2, 3, 4, 5] # Output: [1, 2, 3, 4, 5] ``` Implement the function `optimized_exchange_sort(arr)` below: ```python def optimized_exchange_sort(arr): Function to perform optimized exchange sort on the provided list. :param arr: List of integers to be sorted :return: Sorted list of integers arr_len = len(arr) for i in range(arr_len-1): swapped = False # Flag to check if any swap happened for j in range(i+1, arr_len): if arr[i] > arr[j]: arr[i], arr[j] = arr[j], arr[i] swapped = True if not swapped: # If no elements were swapped, the list is already sorted break return arr # Example usage print(optimized_exchange_sort([34, 7, 23, 32, 5, 62])) # Output: [5, 7, 23, 32, 34, 62] print(optimized_exchange_sort([1, 2, 3, 4, 5])) # Output: [1, 2, 3, 4, 5] ```","solution":"def optimized_exchange_sort(arr): Function to perform optimized exchange sort on the provided list. :param arr: List of integers to be sorted :return: Sorted list of integers arr_len = len(arr) for i in range(arr_len-1): swapped = False # Flag to check if any swap happened for j in range(i+1, arr_len): if arr[i] > arr[j]: arr[i], arr[j] = arr[j], arr[i] swapped = True if not swapped: # If no elements were swapped, the list is already sorted break return arr"},{"question":"# Coding Challenge: Frequency-Controlled List Creation Problem Statement Given a list of integers `lst` and an integer `N`, implement a function `delete_nth` that returns a new list where each integer in `lst` appears at most `N` times without changing the order of the elements. Function Signatures ```python def delete_nth(lst, N): # Your code here ``` Input * `lst` - A list of integers (0 ≤ len(lst) ≤ 10^6) * `N` - An integer (0 ≤ N ≤ 10^6) Output * A list of integers that contains each number from `lst` at most `N` times, maintaining the original order. Constraints * If `N` is 0, return an empty list. * The list should maintain the order of first occurrences as in the original list. Example ```python print(delete_nth([1,2,3,1,2,1,2,3], 2)) # Output: [1, 2, 3, 1, 2, 3] print(delete_nth([20,37,20,21], 1)) # Output: [20, 37, 21] ``` Performance Requirements * The solution must be efficient with a linear time complexity, i.e., O(n). Hints * Consider using hash tables (e.g., `collections.defaultdict`) to efficiently track and count occurrences.","solution":"def delete_nth(lst, N): Returns a new list where each integer from lst appears at most N times. Maintains the original order of appearance. if N == 0: return [] result = [] counts = {} for num in lst: if counts.get(num, 0) < N: result.append(num) counts[num] = counts.get(num, 0) + 1 return result"},{"question":"Generate All Possible Permutations **Scenario**: You are developing a feature in a scheduling application where each possible arrangement of tasks needs to be generated. You\'ve been provided with a list of distinct tasks and your goal is to return all possible orders in which these tasks can be completed. **Task**: Write a Python function `generate_permutations(tasks)` that takes a list of distinct integers `tasks` and returns a list of lists, where each inner list is a unique permutation of the input list. # Function Signature: ```python def generate_permutations(tasks: List[int]) -> List[List[int]]: ``` # Input: * `tasks` (List[int]): A list of distinct integers representing tasks. `1 <= len(tasks) <= 6` # Output: * List[List[int]]: A list containing all possible permutations of the input list. # Constraints: 1. The input list must contain between 1 and 6 distinct integers. 2. The solution should handle edge cases such as an empty list and single-element lists. # Requirements: * Do not use libraries that provide permutation functionalities directly (e.g. itertools.permutations). * Ensure your solution is efficient enough to handle the constraints. * Consider both recursive and iterative solutions that meet the requirements as described. # Example: ```python assert generate_permutations([1, 2, 3]) == [ [1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1] ] assert generate_permutations([1]) == [ [1] ] ``` # Notes: * You may assume that the input always consists of distinct integers and is never an empty list within the constraints.","solution":"def generate_permutations(tasks): Generate all possible permutations of a list of distinct integers. Args: tasks (List[int]): A list of distinct integers representing tasks. Returns: List[List[int]]: A list containing all possible permutations of the input list. def permute(arr): if len(arr) == 1: return [arr] permutations = [] for i in range(len(arr)): current = arr[i] remaining = arr[:i] + arr[i+1:] for p in permute(remaining): permutations.append([current] + p) return permutations return permute(tasks)"},{"question":"# Fenwick Tree (Binary Indexed Tree) - Implementation & Testing You are provided with the Fenwick Tree (also known as Binary Indexed Tree) structure. The main purpose of Fenwick Tree is to manage prefix sums and updates on an array efficiently - both operations can be achieved in O(log n) time. Task: 1. Implement a method to get the range sum between two indices. 2. Extend the Fenwick Tree to support range updates. Background: - The existing code supports the construction, individual point updates, and prefix sum queries. # Functions to Implement: 1. **range_sum(self, bit_tree, left, right)** - Input: A Binary Indexed Tree (bit_tree), integers `left` and `right` representing the bounds of the range sum query. - Output: The sum of elements in the range `[left, right]`. 2. **range_update(self, bit_tree, start, end, value)** - Input: A Binary Indexed Tree (bit_tree), integers `start` and `end` representing the bounds of the range update and the value to be added to each element within. - Output: None, but updates the binary indexed tree. Input/Output requirements: - Input: - `bit_tree`: List[int] - The Binary Indexed Tree created by the constructor. - `start`: int - The starting index for the range update. - `end`: int - The ending index for the range update. - `value`: int - The value to add to each element in the specified range. - `left`: int - The starting index of the range sum query. - `right`: int - The ending index of the range sum query. - Output: - For `range_sum`: An integer representing the sum of elements in the range `[left, right]`. - For `range_update`: None. The function should modify the tree in place. # Example: ```python freq = [1, 3, 5, 7, 9] fenwick_tree = Fenwick_Tree(freq) bit_tree = fenwick_tree.construct() # Range Sum Query print(fenwick_tree.range_sum(bit_tree, 1, 3)) # Expected output: 15 # Range Update fenwick_tree.range_update(bit_tree, 1, 2, 3) print(fenwick_tree.range_sum(bit_tree, 1, 3)) # Expected output: 21 ``` # Hints: - Consider extending the `update_bit` function for the range update. - The range sum can be derived by modifying the `get_sum` function to obtain sums at two indices and taking their difference.","solution":"class Fenwick_Tree: def __init__(self, freq): self.freq = freq self.size = len(freq) def construct(self): bit_tree = [0] * (self.size + 1) for i, val in enumerate(self.freq): self.update_bit(bit_tree, i, val) return bit_tree def update_bit(self, bit_tree, index, value): index += 1 while index <= self.size: bit_tree[index] += value index += index & -index def get_sum(self, bit_tree, index): sum = 0 index += 1 while index > 0: sum += bit_tree[index] index -= index & -index return sum def range_sum(self, bit_tree, left, right): if left > 0: return self.get_sum(bit_tree, right) - self.get_sum(bit_tree, left - 1) else: return self.get_sum(bit_tree, right) def point_update(self, bit_tree, index, value): self.update_bit(bit_tree, index, value) def range_update(self, bit_tree, start, end, value): for i in range(start, end + 1): self.update_bit(bit_tree, i, value)"},{"question":"# Context: You are working on a project that involves visualizing hierarchical data structures. One approach to enhance the visualization is by applying a zigzag pattern in the traversal of these structures, enhancing readability and differentiation of hierarchical levels. # Challenge: Implement a function that performs zigzag level order traversal on a binary tree and returns the result in an appropriate format. # Function Signature: ```python def zigzag_level_order(root: TreeNode) -> List[List[int]]: ``` # Input: * `root` - A TreeNode object representing the root of the binary tree. # Output: * A list of lists where each sublist contains the values of the tree nodes at each level in zigzag order. The first level should be traversed from left to right, the second from right to left, and this alternating pattern should continue for the entire tree. # Constraints: * The number of nodes in the tree is in the range `[0, 2000]`. * `-100 <= Node.val <= 100`. # Example: Input: ```python 3 / 9 20 / 15 7 ``` Output: ```python [ [3], [20, 9], [15, 7] ] ``` # Notes: * Ensure your solution handles edge cases such as empty trees and trees with only one node. * Aim to achieve a balance between clarity and performance.","solution":"from typing import List, Optional class TreeNode: def __init__(self, val: int = 0, left: \'TreeNode\' = None, right: \'TreeNode\' = None): self.val = val self.left = left self.right = right def zigzag_level_order(root: Optional[TreeNode]) -> List[List[int]]: if not root: return [] results = [] current_level = [root] left_to_right = True while current_level: current_values = [] next_level = [] for node in current_level: current_values.append(node.val) if node.left: next_level.append(node.left) if node.right: next_level.append(node.right) if not left_to_right: current_values.reverse() results.append(current_values) current_level = next_level left_to_right = not left_to_right return results"},{"question":"# Maximum Flow in Different Shipment Networks You are given the task to determine the maximum shipment capacity between two hubs in several shipment networks. Each network is represented as a directed graph through an adjacency matrix where the value at matrix[i][j] signifies the maximum flow capacity from hub i to hub j. You need to implement three different methods to compute the maximum flow between the source hub and the sink hub using: 1. The Ford-Fulkerson method with DFS. 2. The Edmonds-Karp method with BFS. 3. The Dinic\'s Algorithm. Your implementation will be tested on different networks to evaluate the maximum flow. Function Signatures: ```python def ford_fulkerson(capacity: List[List[int]], source: int, sink: int) -> int: pass def edmonds_karp(capacity: List[List[int]], source: int, sink: int) -> int: pass def dinic(capacity: List[List[int]], source: int, sink: int) -> int: pass ``` Input: - **capacity**: a 2D list of integers where capacity[i][j] represents the capacity of the edge from node i to node j. If there is no edge, capacity[i][j] = 0. - **source**: an integer representing the index of the source node. - **sink**: an integer representing the index of the sink node. Output: - **max_flow**: an integer representing the maximum flow from the source node to the sink node. Constraints: - The number of vertices V is between 2 and 100. - The capacities are non-negative integers and do not exceed 10^5. Example: ```python capacity = [ [0, 16, 13, 0, 0, 0], [0, 0, 10, 12, 0, 0], [0, 4, 0, 0, 14, 0], [0, 0, 9, 0, 0, 20], [0, 0, 0, 7, 0, 4], [0, 0, 0, 0, 0, 0] ] source = 0 sink = 5 print(ford_fulkerson(capacity, source, sink)) # Output: 23 print(edmonds_karp(capacity, source, sink)) # Output: 23 print(dinic(capacity, source, sink)) # Output: 23 ```","solution":"from typing import List import sys from collections import deque def ford_fulkerson(capacity: List[List[int]], source: int, sink: int) -> int: n = len(capacity) residual_capacity = [row[:] for row in capacity] max_flow = 0 def dfs(source, sink, flow, visited): if source == sink: return flow visited[source] = True for next_node in range(n): if not visited[next_node] and residual_capacity[source][next_node] > 0: min_cap = min(flow, residual_capacity[source][next_node]) result = dfs(next_node, sink, min_cap, visited) if result > 0: residual_capacity[source][next_node] -= result residual_capacity[next_node][source] += result return result return 0 flow = dfs(source, sink, float(\'Inf\'), [False] * n) while flow > 0: max_flow += flow flow = dfs(source, sink, float(\'Inf\'), [False] * n) return max_flow def edmonds_karp(capacity: List[List[int]], source: int, sink: int) -> int: n = len(capacity) residual_capacity = [row[:] for row in capacity] max_flow = 0 def bfs(): parent = [-1] * n visited = [False] * n visited[source] = True queue = deque([source]) while queue: current = queue.popleft() for next_node in range(n): if not visited[next_node] and residual_capacity[current][next_node] > 0: queue.append(next_node) visited[next_node] = True parent[next_node] = current if next_node == sink: return parent return None parent = bfs() while parent: path_flow = float(\'Inf\') s = sink while s != source: path_flow = min(path_flow, residual_capacity[parent[s]][s]) s = parent[s] max_flow += path_flow v = sink while v != source: u = parent[v] residual_capacity[u][v] -= path_flow residual_capacity[v][u] += path_flow v = parent[v] parent = bfs() return max_flow def dinic(capacity: List[List[int]], source: int, sink: int) -> int: n = len(capacity) residual_capacity = [row[:] for row in capacity] max_flow = 0 def bfs(): level = [-1] * n level[source] = 0 queue = deque([source]) while queue: u = queue.popleft() for v in range(n): if level[v] < 0 and residual_capacity[u][v] > 0: level[v] = level[u] + 1 queue.append(v) return level def dfs(u, flow, level, sink): if u == sink: return flow for v in range(n): if level[v] == level[u] + 1 and residual_capacity[u][v] > 0: min_cap = min(flow, residual_capacity[u][v]) result = dfs(v, min_cap, level, sink) if result > 0: residual_capacity[u][v] -= result residual_capacity[v][u] += result return result return 0 level = bfs() while level[sink] >= 0: while (flow := dfs(source, float(\'Inf\'), level, sink)) > 0: max_flow += flow level = bfs() return max_flow"},{"question":"# Question: Implement Cycle Sort with Array Bounds Handling Background You are tasked with developing a sorting algorithm for a system with memory constraints. The system uses flash memory, which can only withstand a limited number of write operations. Cycle Sort is particularly suitable here because it minimizes the number of writes; however, it has a time complexity limitation. Requirements Write a function `cycle_sort_with_bounds` which sorts an array using Cycle Sort, but also includes bounds checking to ensure that indices do not go out of range. The function should handle arrays with duplicate elements efficiently without causing infinite loops. Input * An array `arr` of integers, where `1 <= len(arr) <= 10^5` and `-10^6 <= arr[i] <= 10^6`. Output * The modified input array `arr` sorted in non-decreasing order. Constraints * The solution must run in `O(N^2)` time complexity and `O(1)` space complexity. * You should include bounds checking to ensure no out-of-bounds access happens. Example ```python arr = [5, 2, 9, 8, 2, 6] cycle_sort_with_bounds(arr) print(arr) # Expected Output: [2, 2, 5, 6, 8, 9] ``` Edge cases to handle 1. Arrays already sorted. 2. Arrays with identical elements. 3. Arrays with both negative and positive integers. 4. Single element arrays. 5. Large arrays within the given constraints. Function Signature ```python def cycle_sort_with_bounds(arr: List[int]) -> None: # Your implementation here ```","solution":"from typing import List def cycle_sort_with_bounds(arr: List[int]) -> None: n = len(arr) for start in range(n): item = arr[start] pos = start for i in range(start + 1, n): if arr[i] < item: pos += 1 if pos == start: continue while item == arr[pos]: pos += 1 if pos < n: arr[pos], item = item, arr[pos] while pos != start: pos = start for i in range(start + 1, n): if arr[i] < item: pos += 1 while item == arr[pos]: pos += 1 if pos < n: arr[pos], item = item, arr[pos]"},{"question":"# Scenario You are tasked with creating a utility for conversions between different numeral systems for a software tool that needs to handle various encoding formats. Implement two functions, `int_to_base` and `base_to_int`. Your solution must accurately handle both positive and negative integers for base conversions up to base 36. # Objective Implement the following functions to handle base conversions: 1. **Function: `int_to_base`** * **Input**: * `num`: An integer (positive or negative) to convert. * `base`: An integer representing the target base (2 <= base <= 36). * **Output**: * A string representing the number in the given base. * **Constraints**: * The function should handle zero and negative numbers correctly. * It must support bases from 2 to 36. 2. **Function: `base_to_int`** * **Input**: * `str_to_convert`: A string representation of a number in the given base. * `base`: An integer representing the base of the input string. * **Output**: * An integer resulting from the conversion of the input string from the specified base. * **Constraints**: * The base must be between 2 and 36. * The function should handle both uppercase and lowercase inputs. # Example ```python assert int_to_base(15, 2) == \'1111\' assert int_to_base(-31, 16) == \'-1F\' assert base_to_int(\'1111\', 2) == 15 assert base_to_int(\'1F\', 16) == 31 ``` # Additional Constraints * Do not use Python\'s built-in `int` function for `base_to_int`. * Do not use Python\'s built-in `format` function for `int_to_base`.","solution":"def int_to_base(num, base): if base < 2 or base > 36: raise ValueError(\\"Base must be between 2 and 36\\") if num == 0: return \\"0\\" digits = \\"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\\" result = \\"\\" is_negative = num < 0 num = abs(num) while num: result = digits[num % base] + result num //= base if is_negative: result = \\"-\\" + result return result def base_to_int(str_to_convert, base): if base < 2 or base > 36: raise ValueError(\\"Base must be between 2 and 36\\") digits = \\"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\\" str_to_convert = str_to_convert.upper() if not all(char in digits[:base] for char in str_to_convert.strip(\'-\')): raise ValueError(\\"Invalid character for base\\") is_negative = str_to_convert[0] == \'-\' if is_negative: str_to_convert = str_to_convert[1:] result = 0 for char in str_to_convert: result = result * base + digits.index(char) return -result if is_negative else result"},{"question":"Context You are given a binary matrix representing a map where \'1\' represents land and \'0\' represents water. Your goal is to find the number of islands in the matrix. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. Assume that all four edges of the grid are surrounded by water. Write a function `num_islands` that calculates the number of distinct islands in the matrix. Input * A 2D list `grid` containing \'0\'s and \'1\'s. * 1 <= len(grid), len(grid[0]) <= 300. Output * Return an integer representing the number of islands in the grid. Constraints * Each cell in the grid is either \'0\' (water) or \'1\' (land). * Do not modify the input grid. Example ```python # Example 1: grid = [ [1, 1, 1, 1, 0], [1, 1, 0, 1, 0], [1, 1, 0, 0, 0], [0, 0, 0, 0, 0] ] print(num_islands(grid)) # Output: 1 # Example 2: grid = [ [1, 1, 0, 0, 0], [1, 1, 0, 0, 0], [0, 0, 1, 0, 0], [0, 0, 0, 1, 1] ] print(num_islands(grid)) # Output: 3 ``` Function Signature ```python def num_islands(grid: List[List[int]]) -> int: pass ``` Requirements * Implement the function using depth-first search (DFS). * Clearly handle boundary conditions and input constraints. * Ensure the solution runs efficiently on grids up to the given size.","solution":"def num_islands(grid): Returns the number of islands in the given grid where \'1\' represents land and \'0\' represents water. Islands are connected vertically or horizontally. if not grid or not grid[0]: return 0 nrows, ncols = len(grid), len(grid[0]) visited = [[False] * ncols for _ in range(nrows)] def dfs(r, c): if r < 0 or c < 0 or r >= nrows or c >= ncols or grid[r][c] == 0 or visited[r][c]: return visited[r][c] = True directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] for dr, dc in directions: dfs(r + dr, c + dc) islands = 0 for r in range(nrows): for c in range(ncols): if grid[r][c] == 1 and not visited[r][c]: islands += 1 dfs(r, c) return islands"},{"question":"You are given an array of integers and need to design a class `DynamicArray` which can efficiently handle the following operations: 1. Update the value of an element at a specific position. 2. Calculate the prefix sum up to a given index. **Requirements:** - Implement the Fenwick Tree (Binary Indexed Tree) data structure within the `DynamicArray` class. - Your class should support the following operations: * `update(index: int, value: int)`: Update the element at position `index` to `value`. * `prefix_sum(index: int) -> int`: Return the sum of elements from the start of the array to the position `index`. **Input:** - Initialization with an integer array. - Multiple calls to `update` and `prefix_sum` methods. **Output:** - Each `prefix_sum` call should return an integer representing the sum of the elements from the start of the array to the given index. **Constraints:** - Initialize the object with an array of at most (10^5) elements. - Each element can be updated at most (10^4) times. - Values in the array can be both positive and negative integers. **Example Usage:** ```python # Initialize the object with an array [1, 7, 3, 0, 7, 8] dyn_array = DynamicArray([1, 7, 3, 0, 7, 8]) # Get the sum of the first 3 elements: 1 + 7 + 3 = 11 print(dyn_array.prefix_sum(2)) # Output: 11 # Update the value at index 3 to 5: array becomes [1, 7, 3, 5, 7, 8] dyn_array.update(3, 5) # Get the sum of the first 4 elements: 1 + 7 + 3 + 5 = 16 print(dyn_array.prefix_sum(3)) # Output: 16 ``` Ensure your code is efficient and well-tested to handle the upper limits of the input constraints.","solution":"class DynamicArray: def __init__(self, arr): Initialize the DynamicArray with the given list. self.n = len(arr) self.arr = arr[:] self.bit = [0] * (self.n + 1) for idx, val in enumerate(arr): self._update_bit(idx + 1, val) def _update_bit(self, index, value): Helper function to update the BIT (Fenwick Tree) while index <= self.n: self.bit[index] += value index += index & -index def update(self, index, value): Update the element at position `index` to `value`. diff = value - self.arr[index] self.arr[index] = value self._update_bit(index + 1, diff) def prefix_sum(self, index): Return the sum of elements from the start of the array to the position `index`. sum_ = 0 index += 1 # Since BIT uses 1-based index while index > 0: sum_ += self.bit[index] index -= index & -index return sum_"},{"question":"# Context You are tasked with a problem where you need to fill each empty room in a 2D grid with the distance to its nearest gate. This is a common scenario in path planning problems where obstacles exist and certain points need to reach specific other points with the shortest possible distance. # Problem Description You are given a 2D grid initialized with three possible values: - `-1`: Represents a wall or an obstacle. - `0`: Represents a gate. - `INF`: Represents an empty room. We use the value `2^31 - 1` (2147483647) to represent `INF` as you may assume that the distance to a gate is less than `2147483647`. **Objective**: Fill the empty rooms with the distance to the nearest gate. If it is impossible to reach a gate, the room should remain filled with `INF`. **Input Format**: - A 2D list of integers representing the grid. **Output Format**: - The grid should be modified in place such that each empty room contains the distance to its nearest gate. **Constraints**: - `1 <= m, n <= 200` where `m` is the number of rows and `n` is the number of columns. - You can assume that no grid cell contains both a gate and a wall or obstacle simultaneously. **Example**: ```python rooms = [ [2147483647, -1, 0, 2147483647], [2147483647, 2147483647, 2147483647, -1], [2147483647, -1, 2147483647, -1], [0, -1, 2147483647, 2147483647] ] # Expected output: # rooms should be: # [ # [3, -1, 0, 1], # [2, 2, 1, -1], # [1, -1, 2, -1], # [0, -1, 3, 4] # ] def walls_and_gates(rooms): # Implementation here pass ``` **Performance Requirements**: - The solution should efficiently handle the maximum input size of 200 x 200 grid. - Consider handling the problem using BFS for optimal performance. Provide the implementation for the `walls_and_gates` function that modifies the grid in place.","solution":"from collections import deque def walls_and_gates(rooms): INF = 2147483647 rows, cols = len(rooms), len(rooms[0]) queue = deque() # Find all gates initially for r in range(rows): for c in range(cols): if rooms[r][c] == 0: queue.append((r, c)) # Directions array for moving in 4 directions (up, down, left, right) directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] while queue: r, c = queue.popleft() for dr, dc in directions: rr, cc = r + dr, c + dc if 0 <= rr < rows and 0 <= cc < cols and rooms[rr][cc] == INF: rooms[rr][cc] = rooms[r][c] + 1 queue.append((rr, cc))"},{"question":"**Scenario** You are working on a library for linked list manipulation. One functionality you need to implement is a method to swap every two adjacent nodes in a given singly linked list. This operation is common in certain data reordering and manipulation tasks. **Task** Write a function `swap_pairs(head)` that takes the head node of a singly linked list as input and returns the head node of the modified list, where every two adjacent nodes are swapped. The objective is to use constant space and only modify the node\'s links, not their values. # Function Signature ```python class Node: def __init__(self, x): self.val = x self.next = None def swap_pairs(head: Node) -> Node: # your code here ``` # Input - `head`: The head node of a singly linked list. # Output - The head node of the linked list after swapping every two adjacent nodes. # Constraints - The input linked list can contain zero or more nodes. - You may not modify the values in the nodes, only the links between nodes. # Example ```python # Example usage: # Given the linked list 1 -> 2 -> 3 -> 4 # You should return the linked list as 2 -> 1 -> 4 -> 3 head = Node(1) head.next = Node(2) head.next.next = Node(3) head.next.next.next = Node(4) new_head = swap_pairs(head) # The result should be the list 2 -> 1 -> 4 -> 3 ``` # Additional Notes - Consider edge cases where the list is empty, has only one node, or has an odd number of nodes. - Aim for an efficient solution with linear time complexity and constant space usage.","solution":"class Node: def __init__(self, x): self.val = x self.next = None def swap_pairs(head: Node) -> Node: if not head or not head.next: return head new_head = head.next prev = None current = head while current and current.next: next_pair = current.next.next first_node = current second_node = current.next # Swap the pair second_node.next = first_node first_node.next = next_pair # Connect previous pair to the swapped pair if prev: prev.next = second_node # Move to the next pair prev = first_node current = next_pair return new_head"},{"question":"You are tasked with designing a system that helps convert numbers with minimal changes in their binary representation. Specifically, you need to write a function that calculates the number of bits needed to be flipped to change one integer into another. This functionality is important in scenarios like data transmission error correction, where minimal bit errors need to be detected and corrected. # Function Signature: ```python def count_flips_to_convert(a: int, b: int) -> int: ``` # Input: - `a`: An integer `a` (0 <= a <= 2^31 - 1). - `b`: An integer `b` (0 <= b <= 2^31 - 1). # Output: - An integer representing the minimal number of bits that need to be flipped to convert integer `a` to integer `b`. # Constraints: - Both input integers will be non-negative (0 or positive). # Performance Requirements: - The solution should be efficient with a time complexity of O(k), where k is the number of bits in the larger of the two integers. - Space complexity should be O(1). # Example: Input: ```python a = 29 # binary: 11101 b = 15 # binary: 01111 ``` Output: ```python 2 ``` # Explanation: - In the given example, the binary representation of `a` is `11101` and `b` is `01111`. - The differing bits are the second from the right and the fourth from the right, requiring two flips. # Implementation Details: Use bitwise XOR to identify differing bits, and employ a loop to count the number of differing bits by checking set bits in the XOR result.","solution":"def count_flips_to_convert(a: int, b: int) -> int: Returns the number of bits needed to be flipped to convert integer a to integer b. xor = a ^ b count = 0 while xor: count += xor & 1 xor >>= 1 return count"},{"question":"# Question: Interval Management In this exercise, you need to create a class for managing intervals of real numbers. You will implement functionalities such as interval creation, merging intervals, checking containment, and printing intervals. **Functionality Details:** 1. **Constructor**: * Initialize with `start` and `end` values. 2. **Merge Intervals**: * Merge a list of intervals into disjoint intervals. 3. **Containment Check**: * Check if a value is contained within the interval. 4. **Interval Representation**: * Implement a string representation for the intervals. 5. **Print Intervals**: * Print a simplified string representing a list of intervals. **Input/Output**: * **Input**: List of intervals represented as `[start, end]` pairs. * **Output**: Merged, simplified intervals. # Requirements * **Input Constraints**: * Intervals are inclusive and sorted by starting values. * `start` and `end` are integers where `start <= end`. * **Performance Requirements**: * The solution should be efficient, with logarithmic time complexity for sorting and linear for merging. Here is the function signature you need to implement: ```python class Interval: def __init__(self, start=0, end=0): self.start = start self.end = end def __repr__(self): return \\"Interval({}, {})\\".format(self.start, self.end) def __contains__(self, item): Check if an item is within the interval. if self.start <= item <= self.end: return True return False @staticmethod def merge(intervals): Merge a list of intervals into disjoint intervals. out = [] for i in sorted(intervals, key=lambda i: i.start): if out and i.start <= out[-1].end: out[-1].end = max(out[-1].end, i.end) else: out += i, return out @staticmethod def print_intervals(intervals): Print out the intervals. res = [repr(i) for i in intervals] print(\\"\\".join(res)) ``` # Example: ```python # Create intervals intervals = [Interval(1, 3), Interval(2, 4), Interval(5, 7), Interval(6, 8)] merged = Interval.merge(intervals) Interval.print_intervals(merged) # Output: Interval(1, 4)Interval(5, 8) ``` # Assumptions: 1. Intervals are represented in the form of `[start, end]`. 2. The intervals to be merged are provided in a list. 3. The intervals might not be pre-sorted. Get started by implementing the Interval class with the specified methods. Good luck!","solution":"class Interval: def __init__(self, start=0, end=0): self.start = start self.end = end def __repr__(self): return \\"Interval({}, {})\\".format(self.start, self.end) def __contains__(self, item): Check if an item is within the interval. return self.start <= item <= self.end @staticmethod def merge(intervals): Merge a list of intervals into disjoint intervals. if not intervals: return [] sorted_intervals = sorted(intervals, key=lambda x: x.start) merged = [sorted_intervals[0]] for current in sorted_intervals[1:]: last = merged[-1] if current.start <= last.end: last.end = max(last.end, current.end) else: merged.append(current) return merged @staticmethod def print_intervals(intervals): Print out the intervals. res = \', \'.join([repr(i) for i in intervals]) print(res) return res # Added for testing purposes"},{"question":"Scenario: Suppose you are working on a mathematical library that provides utility functions to identify numbers with unique properties. One of the functionalities needed is to find numbers within a given range where the digits, when raised to consecutive powers, sum up to the original number. Objective: Write a function `sum_dig_pow` that returns a list of all such numbers within a defined range [low, high]. Function Signature: ```python def sum_dig_pow(low: int, high: int) -> List[int]: ``` Input: * `low` (int): The lower bound of the range (inclusive). * `high` (int): The upper bound of the range (inclusive). Output: * `List[int]`: A list containing all numbers within the range that satisfy the property where the sum of digits, each raised to consecutive powers, equals the number itself. The list should be in ascending order. Constraints: * 1 ≤ low ≤ high ≤ 10^6 Example: ```python assert sum_dig_pow(1, 10) == [1, 2, 3, 4, 5, 6, 7, 8, 9] assert sum_dig_pow(1, 100) == [1, 2, 3, 4, 5, 6, 7, 8, 9, 89] assert sum_dig_pow(90, 150) == [135] ``` # Requirements: 1. The function should be efficient with respect to time and space. 2. Handle edge cases such as single-digit numbers and the lower bound being equal to the upper bound.","solution":"from typing import List def sum_dig_pow(low: int, high: int) -> List[int]: def is_eureka_number(n: int) -> bool: digits = [int(d) for d in str(n)] return sum(digits[i] ** (i + 1) for i in range(len(digits))) == n return [num for num in range(low, high + 1) if is_eureka_number(num)]"},{"question":"**Context**: You are tasked with designing a robot that can navigate a binary maze grid. The robot can move up, down, left, and right but can only travel on cells containing `1`. Your goal is to find the shortest path from the top-left corner to the bottom-right corner (without including the starting point in the path length). If no path exists, return `-1`. You must avoid visiting cells twice to prevent the robot from becoming stuck in loops. **Function Specification**: - **Function Name**: `find_path` - **Input**: An n x m binary matrix `maze` where `maze[i][j]` can either be `0` (blocked) or `1` (free path). - **Output**: An integer representing the length of the shortest path from the top-left corner to the bottom-right corner, excluding the start cell. If no path exists, return `-1`. **Constraints**: 1. `1 <= n, m <= 100` - The dimensions of the maze grid. 2. The cells are either `1` (path) or `0` (blocked). **Performance Requirements**: - Your solution should effectively handle edge cases and avoid excessive recursion depth errors. **Examples**: 1. Input: ``` maze = [ [1,0,1,1,1,1], [1,0,1,0,1,0], [1,0,1,0,1,1], [1,1,1,0,1,1] ] ``` Output: ``` 14 ``` 2. Input: ``` maze = [ [1,0,0], [0,1,1], [0,1,1] ] ``` Output: ``` -1 ``` Implement the `find_path` function using a depth-first search (DFS) approach, ensuring you address the identified edge cases and performance concerns.","solution":"from collections import deque def find_path(maze): Finds the shortest path from (0,0) to (n-1, m-1) in a binary maze. If no path exists, returns -1. def is_valid(x, y): return 0 <= x < n and 0 <= y < m and maze[x][y] == 1 n = len(maze) m = len(maze[0]) if maze[0][0] == 0 or maze[n-1][m-1] == 0: return -1 directions = [(1, 0), (0, 1), (-1, 0), (0, -1)] queue = deque([(0, 0, 0)]) # (x, y, distance) visited = set((0, 0)) while queue: x, y, dist = queue.popleft() if (x, y) == (n-1, m-1): return dist for dx, dy in directions: nx, ny = x + dx, y + dy if is_valid(nx, ny) and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny, dist + 1)) return -1"},{"question":"Background During text processing or search highlighting, it\'s common to replace specific keywords or symbols within a given text with marked versions to emphasize or categorize them. This problem involves taking a list of words and a list of symbols, then replacing occurrences of these symbols in the words with bracketed versions. If a word matches multiple symbols, the symbol with the longest length should be chosen. # Problem Statement Implement the function `match_symbol(words, symbols)` that processes a list of `words` and a list of `symbols`. Replace any occurrence of each symbol in the words with its bracketed form. However, if a word contains multiple symbols, replace the symbol that has the longest length. If no symbols match a word, keep the word unchanged. # Function Signature ```python def match_symbol(words: List[str], symbols: List[str]) -> List[str]: pass ``` # Input - `words` (List[str]): List of strings representing words. - `symbols` (List[str]): List of strings representing symbols. # Output - List of strings with symbols replaced as described. # Constraints - All inputs are non-empty and contain only alphabetic characters. - A word may or may not contain symbols. - Symbols may overlap within words. - The input list sizes will not exceed 10^3 items. # Example ```python words = [\'Amazon\', \'Microsoft\', \'Google\'] symbols = [\'i\', \'Am\', \'cro\', \'Na\', \'le\', \'abc\'] print(match_symbol(words, symbols)) # Output should be [\'[Am]azon\', \'Mi[cro]soft\', \'Goog[le]\'] ``` # Requirements - Ensure that the solution is efficient and works in an optimal time complexity. - Handle edge cases such as words without any symbols or symbols that appear multiple times within words.","solution":"def match_symbol(words, symbols): Replaces occurrences of symbols in the words with bracketed versions. If multiple symbols match, the longest one is chosen. # Sort symbols by length in descending order to make sure the longest symbols are matched first symbols.sort(key=len, reverse=True) result = [] for word in words: replaced = False for symbol in symbols: if symbol in word: word = word.replace(symbol, f\'[{symbol}]\') replaced = True break result.append(word) return result"},{"question":"Secure Encrypted Message Exchange Objective Based on the Diffie-Hellman key exchange algorithm provided, your task is to implement a secure message exchange between Alice and Bob. They will use the shared secret key generated from the key exchange to encrypt and decrypt messages using a simple substitution cipher. Requirements 1. Implement functions to encrypt and decrypt messages using a shared secret key. 2. Integrate the Diffie-Hellman key exchange to securely generate the shared secret. 3. Ensure the message after decryption matches the original message. Scenario Alice and Bob want to communicate securely. They decide to use the Diffie-Hellman key exchange algorithm to exchange a shared secret key. Once they have the shared key, they will use it to encrypt and decrypt messages. Implementation 1. **Encrypt Function**: Modify each character in the plaintext by shifting it by the shared key value. 2. **Decrypt Function**: Reverse the encryption process to retrieve the original message. Specifications * **Input Format**: * `prime(p)`: A large prime number. * `primitive_root(a)`: A primitive root of that prime number. * `message(str)`: The plaintext message Alice wants to send to Bob. * **Output Format**: * `encrypted_message(str)`: The encrypted message. * `decrypted_message(str)`: The decrypted message matching the original plaintext. * **Constraints**: * Ensure p is a prime and a is a primitive root of p as verified by the previous functions. * The message will consist of uppercase letters and spaces only. * Sample input limits are p < 100 and message length < 100 characters for simplicity. Code Template Here is the code template to get you started. Fill in the required functionality to complete the task. ```python def encrypt_message(message, key): Encrypts the message using the shared key. encrypted_message = \'\'.join(chr((ord(char) + key) % 256) for char in message) return encrypted_message def decrypt_message(encrypted_message, key): Decrypts the message using the shared key. decrypted_message = \'\'.join(chr((ord(char) - key) % 256) for char in encrypted_message) return decrypted_message # Provided Functions for Diffie-Hellman Key Exchange # Copy the relevant functions here # Your complete Diffie-Hellman key exchange implementation def secure_message_exchange(prime, primitive_root, message): # Step 1: Perform Diffie-Hellman Key Exchange shared_key = diffie_hellman_key_exchange(primitive_root, prime) # Step 2: Encrypt and Decrypt Message encrypted_message = encrypt_message(message, shared_key) decrypted_message = decrypt_message(encrypted_message, shared_key) return encrypted_message, decrypted_message # Test the function with example inputs prime = 23 primitive_root = 5 message = \\"HELLO WORLD\\" encrypted_message, decrypted_message = secure_message_exchange(prime, primitive_root, message) print(f\\"Encrypted Message: {encrypted_message}\\") print(f\\"Decrypted Message: {decrypted_message}\\") ``` Performance Requirements Ensure that the implemented algorithm can efficiently handle the encryption and decryption processes for messages of up to 100 characters.","solution":"def encrypt_message(message, key): Encrypts the message using the shared key. encrypted_message = \'\'.join(chr((ord(char) + key - 32) % 95 + 32) for char in message) return encrypted_message def decrypt_message(encrypted_message, key): Decrypts the message using the shared key. decrypted_message = \'\'.join(chr((ord(char) - key - 32) % 95 + 32) for char in encrypted_message) return decrypted_message import random def diffie_hellman_key_exchange(primitive_root, prime): Perform the Diffie-Hellman Key Exchange and return the shared secret key. # Private keys (a and b) are chosen randomly private_key_A = random.randint(1, prime - 2) # Alice\'s private key private_key_B = random.randint(1, prime - 2) # Bob\'s private key # Public keys (A and B) are computed as primitive_root^private_key % prime public_key_A = pow(primitive_root, private_key_A, prime) public_key_B = pow(primitive_root, private_key_B, prime) # Shared secret is computed shared_secret_A = pow(public_key_B, private_key_A, prime) shared_secret_B = pow(public_key_A, private_key_B, prime) # Since shared_secret_A should be equal to shared_secret_B, we can return either return shared_secret_A def secure_message_exchange(prime, primitive_root, message): # Step 1: Perform Diffie-Hellman Key Exchange shared_key = diffie_hellman_key_exchange(primitive_root, prime) # Step 2: Encrypt and Decrypt Message encrypted_message = encrypt_message(message, shared_key) decrypted_message = decrypt_message(encrypted_message, shared_key) return encrypted_message, decrypted_message"},{"question":"# Scenario: You are given a binary tree and need to determine the largest diameter of the tree. The **diameter** of a binary tree is the length of the longest path between any two nodes in a tree. This path may or may not pass through the root. # Task: Write a function `diameter_of_binary_tree` that calculates the diameter of the given binary tree. # Function Signature: ```python def diameter_of_binary_tree(root: TreeNode) -> int: ``` # Input: - `root`: The root node of a binary tree (instance of `TreeNode`). # Output: - An integer representing the diameter of the binary tree. # Constraints: - The number of nodes in the tree is in the range [0, 10^4]. - `-100 <= Node.val <= 100` # Example: ```python # Example Binary Tree: # 1 # / # 2 3 # / # 4 5 # Creating the tree root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) root.left.left = TreeNode(4) root.left.right = TreeNode(5) # Function Call print(diameter_of_binary_tree(root)) # Output = 3 ``` # Explanation: The longest path (diameter) is `[4 -> 2 -> 1 -> 3]` or `[5 -> 2 -> 1 -> 3]`, with 3 edges. # Note: - Be mindful of handling edge cases like an empty tree (`root` is `None`). - Optimize the calculation to handle large trees efficiently.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def diameter_of_binary_tree(root: TreeNode) -> int: Calculates the diameter of a binary tree. def depth(node: TreeNode): nonlocal diameter if not node: return 0 left_depth = depth(node.left) right_depth = depth(node.right) diameter = max(diameter, left_depth + right_depth) return max(left_depth, right_depth) + 1 diameter = 0 depth(root) return diameter"},{"question":"**Task**: Write a Python function that sorts an array using the Bogo Sort algorithm. However, given the impracticality of Bogo Sort, your task is to modernize this algorithm slightly by implementing a \\"Bogo-Simulation Sort\\" that: - Continues shuffling if the array is unsorted. - Stops if a specified maximum number of iterations is reached. - Prints each iteration for visualizing the shuffling process. # Function Signature ```python def bogo_simulation_sort(arr: list, max_iterations: int) -> list: pass ``` # Input 1. `arr`: A list of integers to be sorted. 2. `max_iterations`: An integer representing the maximum number of iterations to limit the operation to. # Output - A sorted list of integers if sorted within the maximum iterations. - The array in its current state if the maximum iterations are reached without achieving a sorted order. # Constraints - The length of `arr` will be at most 10. - The values in `arr` will be integers between `-1000` and `1000`. - `max_iterations` is a positive integer and should not exceed 10000. # Example ```python # Example 1 print(bogo_simulation_sort([3, 2, 1], 1000)) # Output might be a sorted array [1, 2, 3] within the 1000 iterations # Example 2 print(bogo_simulation_sort([4, 5, 6, 1], 5)) # Output might be the same array [4, 5, 6, 1] if max iterations reached ```","solution":"import random def is_sorted(arr): Helper function to check if the array is sorted. return all(arr[i] <= arr[i+1] for i in range(len(arr)-1)) def bogo_simulation_sort(arr, max_iterations): Bogo-Simulation Sort that shuffles the array until it\'s sorted or reaches the maximum number of iterations. Prints each iteration for visualizing the shuffling process. iteration = 0 while not is_sorted(arr) and iteration < max_iterations: print(f\\"Iteration {iteration}: {arr}\\") random.shuffle(arr) iteration += 1 print(f\\"Iteration {iteration}: {arr}\\") return arr"},{"question":"Implement a class `ZigzagKIterator` that iterates over `k` lists in a round-robin fashion. This iterator alternates between elements of `k` lists in sequence, moving to the next list after returning one element from the current list. If a list is exhausted, it should be skipped. # Function Signatures: ``` python class ZigzagKIterator: def __init__(self, lists: List[List[int]]): Initialize your data structure here. :param lists: List of k input lists :type lists: List[List[int]] pass def next(self) -> int: Return the next element in the round-robin sequence. :rtype: int pass def has_next(self) -> bool: Check if any more elements are remaining in the iterator. :rtype: bool pass ``` # Example: ``` python # Initializing with three lists lists = [[1, 2, 3], [4, 5, 6, 7], [8, 9]] iterator = ZigzagKIterator(lists) result = [] while iterator.has_next(): result.append(iterator.next()) # result should be [1, 4, 8, 2, 5, 9, 3, 6, 7] ``` # Constraints: * The input lists will have at least one list with at least one element. * The elements in the lists are non-negative integers. * The total number of elements across `k` lists will not exceed `10^4`. * Minimize the number of operations in `next` and `has_next` for optimal performance. # Points to Consider: * Efficiently manage the queue to avoid performance bottlenecks. * Handle edge cases such as varying lengths of input lists.","solution":"from typing import List class ZigzagKIterator: def __init__(self, lists: List[List[int]]): Initialize the ZigzagKIterator with k input lists. self.queue = [] for i, lst in enumerate(lists): if lst: self.queue.append((i, 0)) self.lists = lists def next(self) -> int: Return the next element in the round-robin sequence. if not self.has_next(): raise Exception(\\"No more elements\\") # Take the first element in the queue index, pos = self.queue.pop(0) val = self.lists[index][pos] # If there\'s another element in the same list, add it back to the queue if pos + 1 < len(self.lists[index]): self.queue.append((index, pos + 1)) return val def has_next(self) -> bool: Check if any more elements are remaining in the iterator. return len(self.queue) > 0"},{"question":"# Question Given the lengths of two sides of a right-angled triangle, write a function `find_third_side` that returns the length of the missing third side using the Pythagorean theorem. Your function should handle three inputs: `a`, `b`, and `c`, where: - `a` is the length of one side, - `b` is the length of the other side, - `c` is the length of the hypotenuse. One of these inputs will be the string `\\"?\\"`, indicating which side\'s length should be calculated. # Input Format - The inputs `a` and `b` will be positive floats or integers. - The input `c` will be a positive float or integer. - One and only one of `a`, `b`, or `c` will be the string `\\"?\\"`. # Output Format - The output should be a float representing the length of the missing side rounded to two decimal places. # Constraints - If the inputs do not form a valid right-angled triangle, the function should raise a `ValueError` with the message `\\"Invalid triangle sides\\"`. # Examples ```python # Example 1 # Input: a = 3, b = \\"?\\", c = 5 # Output: 4.00 # Example 2 # Input: a = \\"?\\", b = 4, c = 5 # Output: 3.00 # Example 3 # Input: a = 3, b = 4, c = \\"?\\" # Output: 5.00 def find_third_side(a, b, c): Function to find the missing side length in a right-angled triangle. :param a: Length of side a or \\"?\\" if unknown. :param b: Length of side b or \\"?\\" if unknown. :param c: Length of the hypotenuse or \\"?\\" if unknown. :return: Length of the missing side. :raises: ValueError for invalid triangle sides. # Implement the function based on Pythagorean theorem ``` Implement the function `find_third_side` that meets the above requirements.","solution":"import math def find_third_side(a, b, c): Function to find the missing side length in a right-angled triangle. :param a: Length of side a or \\"?\\" if unknown. :param b: Length of side b or \\"?\\" if unknown. :param c: Length of the hypotenuse or \\"?\\" if unknown. :return: Length of the missing side rounded to two decimal places. :raises: ValueError for invalid triangle sides. if (a == \\"?\\"): b = float(b) c = float(c) if b >= c: raise ValueError(\\"Invalid triangle sides\\") return round(math.sqrt(c**2 - b**2), 2) elif (b == \\"?\\"): a = float(a) c = float(c) if a >= c: raise ValueError(\\"Invalid triangle sides\\") return round(math.sqrt(c**2 - a**2), 2) elif (c == \\"?\\"): a = float(a) b = float(b) return round(math.sqrt(a**2 + b**2), 2) else: raise ValueError(\\"One of the sides must be unknown\\")"},{"question":"# Wiggle Sort Implementation You are given an unsorted array of integers. Your task is to reorder the array such that it alternates between increasing and decreasing order like a wave. This means that given an array `nums`, you need to ensure that: nums[0] < nums[1] > nums[2] < nums[3]... Write a function `wiggle_sort(nums)` that modifies the array in place to follow this pattern. Input - A list of integers `nums`. Output - The input list sorted in wiggle order. Constraints - The length of the array will be in the range [1, 1000]. - Integer values in the array will be between -10^6 and 10^6. Example ```python array = [3, 5, 2, 1, 6, 4] print(array) wiggle_sort(array) print(array) ``` **Expected Output** ``` [3, 5, 2, 1, 6, 4] [3, 5, 1, 6, 2, 4] ``` Notes - The function should directly modify the input array and not return anything. - Ensure that the resulting array maintains the required wiggle pattern (`nums[0] < nums[1] > nums[2] < nums[3]...`). Implement the function `wiggle_sort(nums)` that respects the specifications above.","solution":"def wiggle_sort(nums): Reorders the input array in place to follow the wiggle sort pattern: nums[0] < nums[1] > nums[2] < nums[3]... for i in range(len(nums) - 1): if (i % 2 == 0 and nums[i] > nums[i + 1]) or (i % 2 != 0 and nums[i] < nums[i + 1]): nums[i], nums[i + 1] = nums[i + 1], nums[i]"},{"question":"# Atbash Cipher Implementation Scenario You\'re working as a software engineer for a text processing company. One of the tasks requires implementing an encoding feature using the Atbash Cipher. Given an input string, your function needs to convert each alphabet character to its reversed counterpart in the alphabet while keeping the non-alphabet characters unchanged. Task Write a function `atbash_cipher(input_text: str) -> str` that takes a string and returns a new string where each alphabet character has been substituted with its reverse in the alphabet. Requirements: 1. Preserve the case of the letters. 2. Non-alphabet characters should remain unchanged. 3. Handle edge cases such as empty strings and strings with mixed character types. Input: * `input_text`: A string containing any printable ASCII characters. Output: * A string where each alphabet character has been replaced by its corresponding character in the reverse alphabet order, preserving the case and leaving non-alphabet characters unchanged. Examples: ```python atbash_cipher(\\"Attack at dawn\\") # Output: \\"Zggzxp zg wzdm\\" atbash_cipher(\\"Hello, World!\\") # Output: \\"Svool, Dliow!\\" atbash_cipher(\\"Python 3.9\\") # Output: \\"Kbgslm 3.9\\" atbash_cipher(\\"\\") # Output: \\"\\" ``` Constraints: - You may assume the input text\'s length does not exceed 10,000 characters. Write your function below: ```python def atbash_cipher(input_text): # Your implementation here ```","solution":"def atbash_cipher(input_text: str) -> str: Encodes the input text using the Atbash cipher. Parameters: - input_text (str): The input string to be encoded Returns: - str: The encoded string with each alphabet character replaced by its reversed counterpart in the alphabet def transform_char(c): if \'A\' <= c <= \'Z\': return chr(ord(\'Z\') - (ord(c) - ord(\'A\'))) elif \'a\' <= c <= \'z\': return chr(ord(\'z\') - (ord(c) - ord(\'a\'))) else: return c return \'\'.join(transform_char(c) for c in input_text)"},{"question":"# Coding Challenge **Problem Statement**: Given a string consisting solely of digits `0-9` and a target integer value, write a function that returns all valid expressions by adding binary operators (`+`, `-`, or `*`) between the digits such that the expression evaluates to the target value. Your function should be named `findAllExpressions` and should have the following signature: ```python def findAllExpressions(digits: str, target: int) -> List[str]: ``` # Input * `digits` (str): A non-empty string consisting of digits `0-9` with length at most 10. * `target` (int): An integer (positive, negative, or zero) that the expression should evaluate to. # Output A list of strings where each string is a valid expression built from the input digits string and evaluates to the target value. # Constraints and Requirements * Each digit should be used exactly once, and all digits must be used in each expression. * You can use the operators `+`, `-`, and `*`. * Expressions must be valid and respect the precedence of operations (`*` before `+` and `-`). * Handling of leading zeros should be considered (e.g., \\"012\\" in input should not lead to \\"012\\" in output). # Example ```python findAllExpressions(\\"123\\", 6) # Output: [\\"1+2+3\\", \\"1*2*3\\"] findAllExpressions(\\"232\\", 8) # Output: [\\"2*3+2\\", \\"2+3*2\\"] findAllExpressions(\\"105\\", 5) # Output: [\\"1*0+5\\", \\"10-5\\"] findAllExpressions(\\"00\\", 0) # Output: [\\"0+0\\", \\"0-0\\", \\"0*0\\"] findAllExpressions(\\"3456237490\\", 9191) # Output: [] ``` # Additional Notes * Ensure to handle edge cases like continuous zeros, large numbers, and verify correctness of the resultant expressions. * Make use of a depth-first approach with backtracking to explore all possibilities for operator placement.","solution":"from typing import List def findAllExpressions(digits: str, target: int) -> List[str]: def backtrack(index, current_str, value, last_operand): if index == len(digits): if value == target: result.append(current_str) return for i in range(index, len(digits)): part = digits[index:i + 1] # Avoid expressions with leading zeros if len(part) > 1 and part[0] == \'0\': continue current_num = int(part) if index == 0: backtrack(i + 1, part, current_num, current_num) else: backtrack(i + 1, current_str + \'+\' + part, value + current_num, current_num) backtrack(i + 1, current_str + \'-\' + part, value - current_num, -current_num) backtrack(i + 1, current_str + \'*\' + part, value - last_operand + last_operand * current_num, last_operand * current_num) result = [] backtrack(0, \\"\\", 0, 0) return result"},{"question":"# Removing Duplicate Characters from a String Scenario You are cleaning up data entries in a customer database, and you need a specific tool that removes duplicate characters from any given input string while preserving their first occurrence order. Task Write a function `remove_duplicate_characters(input_str: str) -> str` that takes a string as input and returns a new string with all recurring characters removed, retaining only the first occurrence of each character. Input * A single string `input_str` (1 ≤ |input_str| ≤ 10^5), consisting of ASCII characters. Output * A string with all recurring characters removed. Constraints * The function should efficiently handle strings with up to 100,000 characters. * Performance is key. Avoid using data structures that involve O(n^2) operations. Example 1 * Input: `\\"programming\\"` * Output: `\\"progamin\\"` Example 2 * Input: `\\"aabbcc\\"` * Output: `\\"abc\\"` Example 3 * Input: `\\"\\"` * Output: `\\"\\"` # Function Signature ```python def remove_duplicate_characters(input_str: str) -> str: pass ``` Good luck with your task! Remember to test your function with various edge cases to ensure its robustness.","solution":"def remove_duplicate_characters(input_str: str) -> str: Removes duplicate characters from the string while preserving the first occurrence order. :param input_str: A single string consisting of ASCII characters. :return: A new string with all recurring characters removed. seen = set() result = [] for char in input_str: if char not in seen: seen.add(char) result.append(char) return \'\'.join(result)"},{"question":"# String Merge Validation You are tasked with implementing a function to determine if a given string `s` can be created by merging two other strings `part1` and `part2`. All characters in `part1` and `part2` must appear in `s` in their original order. **Function Signature** ```python def is_merge(s: str, part1: str, part2: str) -> bool: pass ``` **Input** * `s` (1 <= len(s) <= 1000): Target string to be formed. * `part1` (0 <= len(part1) <= 1000): First part string. * `part2` (0 <= len(part2) <= 1000): Second part string. **Output** * Return `True` if `s` can be formed by merging `part1` and `part2`, otherwise return `False`. **Constraints** * Both `part1` and `part2` together will have a length that is equal to or less than `s`. **Example** ```python assert is_merge(\\"codewars\\", \\"cdw\\", \\"oears\\") == True assert is_merge(\\"codewars\\", \\"code\\", \\"wars\\") == True assert is_merge(\\"codewars\\", \\"cod\\", \\"wars\\") == True assert is_merge(\\"codewars\\", \\"code\\", \\"warsx\\") == False assert is_merge(\\"codewars\\", \\"codex\\", \\"wars\\") == False ``` **Explanation** * For the first example, \\"codewars\\" can be formed by merging \\"cdw\\" and \\"oears\\". * Each character follows the sequence in `s`, and all characters in `part1` and `part2` are used to compose `s`. You need to implement this function using either a recursive or an iterative approach. Your function should handle edge cases and be efficient for larger inputs up to the constraints provided.","solution":"def is_merge(s: str, part1: str, part2: str) -> bool: len_s, len_p1, len_p2 = len(s), len(part1), len(part2) # If the total length of part1 and part2 doesn\'t match with s, return False if len_s != len_p1 + len_p2: return False # Create a DP table dp = [[False] * (len_p2 + 1) for _ in range(len_p1 + 1)] # Base case: empty strings dp[0][0] = True # Fill the DP table for i in range(len_p1 + 1): for j in range(len_p2 + 1): # Check if we can take a character from part1 if i > 0 and dp[i - 1][j] and s[i + j - 1] == part1[i - 1]: dp[i][j] = True # Check if we can take a character from part2 if j > 0 and dp[i][j - 1] and s[i + j - 1] == part2[j - 1]: dp[i][j] = True return dp[len_p1][len_p2]"},{"question":"# Scenario You are a software engineer in a financial technology company. Your team is developing a backend service that performs a vast number of mathematical calculations to verify digital signatures as part of a blockchain system. A crucial part of these calculations involves efficient large exponentiations often involving prime numbers. # Task Implement efficient functions for exponentiation. Your functions should: 1. Efficiently compute the power of a number. 2. Handle large values of a and n without resulting in overflow. 3. Optionally, perform computations under a modulo to keep numbers manageable. # Question Function Specifications 1. **Function Name**: `iterative_power` * **Parameters**: * `a` (integer): the base number. * `n` (integer): the exponent. * `mod` (integer, optional): the modulus. If not provided, return regular exponentiation result. * **Returns**: * An integer representing the result of `a` raised to the power of `n`, optionally modulo `mod`. 2. **Function Name**: `recursive_power` * **Parameters**: * `a` (integer): the base number. * `n` (integer): the exponent. * `mod` (integer, optional): the modulus. If not provided, return regular exponentiation result. * **Returns**: * An integer representing the result of `a` raised to the power of `n`, optionally modulo `mod`. # Performance Requirements - Both functions should handle large exponents efficiently, ideally in O(log(n)) time complexity. - `iterative_power` should use O(1) space. - `recursive_power` should use O(log(n)) space due to recursion depth. Constraints - (0 leq a leq 10^9) - (0 leq n leq 10^9) - (1 leq mod leq 10^9) (if provided) Example ```python assert iterative_power(2, 10) == 1024 assert iterative_power(2, 10, 1000) == 24 assert recursive_power(2, 10) == 1024 assert recursive_power(2, 10, 1000) == 24 ``` # Notes * You may assume that all inputs are valid and do not need to handle inputs outside the constraints given. * Think carefully about edge cases like (a = 0), (n = 0), and (mod = 1).","solution":"def iterative_power(a, n, mod=None): Compute a^n efficiently using an iterative method. If mod is provided, compute a^n % mod. Parameters: a (int): Base integer. n (int): Exponent integer. mod (int, optional): Modulus integer. Returns: int: Result of a^n, optionally modulo mod. result = 1 base = a while n > 0: if n % 2 == 1: result = (result * base) % mod if mod else result * base base = (base * base) % mod if mod else base * base n = n // 2 return result % mod if mod else result def recursive_power(a, n, mod=None): Compute a^n efficiently using a recursive method. If mod is provided, compute a^n % mod. Parameters: a (int): Base integer. n (int): Exponent integer. mod (int, optional): Modulus integer. Returns: int: Result of a^n, optionally modulo mod. if n == 0: return 1 half_power = recursive_power(a, n // 2, mod) if n % 2 == 0: return (half_power * half_power) % mod if mod else half_power * half_power else: if mod: return (half_power * half_power * a) % mod else: return half_power * half_power * a"},{"question":"Problem Statement You are provided with an unsorted array of integers. Your task is to reorder it in-place such that elements at even indices are less than the next element and elements at odd indices are greater than the next element. Write a function `wiggle_sort` that rearranges the elements of the array to meet the wiggle sort conditions. # Function Signature ```python def wiggle_sort(nums: List[int]) -> None: pass ``` # Input - A list of integers `nums` with at least one element. # Output - The function should modify the input list `nums` in-place to satisfy wiggle sorting requirements. No return value is expected. # Constraints 1. The input list `nums` has at least one element. 2. Elements of `nums` are integers. 3. The function should perform the sorting in-place with O(1) space complexity. 4. Aim for an O(n) time complexity solution. # Example ```python # Example 1 nums = [3, 5, 2, 1, 6, 4] wiggle_sort(nums) print(nums) # Output could be [3, 5, 1, 6, 2, 4] (or any valid wiggle sort array) # Example 2 nums = [1, 3, 2, 2, 3, 1] wiggle_sort(nums) print(nums) # Output could be [1, 3, 2, 3, 1, 2] (or any valid wiggle sort array) ``` # Explanation of Examples 1. In the first example, the array `[3, 5, 2, 1, 6, 4]` can be arranged as `[3, 5, 1, 6, 2, 4]` to meet the wiggle sort requirement. 2. In the second example, the array `[1, 3, 2, 2, 3, 1]` can be rearranged to `[1, 3, 2, 3, 1, 2]`. Note how the wiggle pattern is maintained. Your function should handle various edge cases like arrays of different lengths, arrays with duplicate values, and already wiggle-sorted arrays.","solution":"from typing import List def wiggle_sort(nums: List[int]) -> None: Rearrange the elements of the array to meet the wiggle sort conditions where elements at even indices are less than the next element and elements at odd indices are greater than the next element. for i in range(len(nums) - 1): if i % 2 == 0: if nums[i] > nums[i + 1]: nums[i], nums[i + 1] = nums[i + 1], nums[i] else: if nums[i] < nums[i + 1]: nums[i], nums[i + 1] = nums[i + 1], nums[i]"},{"question":"You are working as a data analyst and are required to frequently identify the most common elements in a dataset. To facilitate this, you need to implement a function capable of determining the mode (most frequent elements) in a data collection. Function Signature ```python def find_modes(arr: List[int]) -> List[int]: ``` Input * `arr` (List[int]): A list of integers, where `1 <= len(arr) <= 10^5` and `-10^5 <= arr[i] <= 10^5`. Output * `List[int]`: A list of integers indicating the most frequent value(s) in the input list. If there are multiple values with the same frequency, include each of them in the result list. Constraints - You should ensure the function works efficiently for large lists. - The input list can have any integer values within the specified range. - If the list is empty, return an empty list. Example ```python assert find_modes([1, 2, 2, 3, 4, 4, 4]) == [4] assert find_modes([1, 2, 2, 3, 3, 4]) == [2, 3] assert find_modes([]) == [] ``` Notes * The function should handle both small and large lists effectively. * Edge cases like empty lists and all unique elements should be considered. * The input array can include negative integers. Write your solution in Python.","solution":"from typing import List from collections import Counter def find_modes(arr: List[int]) -> List[int]: Finds the mode(s) of the given list of integers. Parameters: arr (List[int]): A list of integers Returns: List[int]: A list of the most frequent value(s) in the input list if not arr: return [] frequency = Counter(arr) max_count = max(frequency.values()) return [num for num, count in frequency.items() if count == max_count]"},{"question":"# Question: One Edit Distance In a text processing system, it is often useful to determine if two strings are similar, but with potentially one small typo or edit. Write a function `is_one_edit_distance(s: str, t: str) -> bool` that determines whether two input strings `s` and `t` are exactly one edit distance apart. Definitions: An edit is defined as: * **Insert** a single character. * **Delete** a single character. * **Replace** a single character. Two strings are one edit distance apart if you can: 1. Insert exactly one character into one of the strings to make the two strings the same. 2. Delete exactly one character from one of the strings to make the two strings the same. 3. Replace exactly one character in one of the strings to make the two strings the same. Function Signature: ```python def is_one_edit_distance(s: str, t: str) -> bool: pass ``` Input: * `s` - A string `s` with the constraints 0 <= len(s) <= 10^4. * `t` - A string `t` with the constraints 0 <= len(t) <= 10^4. Output: * Returns `True` if the strings `s` and `t` are one edit distance apart, otherwise returns `False`. Constraints: * The input strings will only contain lower case alphabetical characters. Example: ```python # Example 1 # Input: s = \\"abc\\", t = \\"ab\\" # Output: True (deleting \'c\' from \\"abc\\" makes it \\"ab\\") # Example 2 # Input: s = \\"abc\\", t = \\"abcd\\" # Output: True (adding \'d\' to \\"abc\\" makes it \\"abcd\\") # Example 3 # Input: s = \\"a\\", t = \\"b\\" # Output: True (replacing \'a\' with \'b\' in \\"a\\" makes it \\"b\\") # Example 4 # Input: s = \\"\\", t = \\"\\" # Output: False (both strings are identical so zero edits are needed) ``` Note: * Make sure your implementation is optimized for efficiency considering time and space complexity. * Handle all edge cases such as empty strings carefully.","solution":"def is_one_edit_distance(s: str, t: str) -> bool: m, n = len(s), len(t) if abs(m - n) > 1: return False # If length difference is more than 1, it\'s impossible to be one edit away if m > n: s, t = t, s # Ensure that s is the shorter string i = j = 0 edit_found = False while i < len(s) and j < len(t): if s[i] != t[j]: if edit_found: return False edit_found = True if m == n: # If lengths are the same, move both pointers i += 1 # If lengths are different, move pointer of the longer one else: i += 1 j += 1 # If no edit is found till the end, make sure there\'s only one char left unmatched in the longer string return edit_found or j == len(t) - 1"},{"question":"# Regular Expression Matching You are tasked with implementing a function that performs regular expression matching with support for the special characters \'.\' and \'*\'. The matching function should determine whether the entire input string matches with the given pattern. Here’s what each special character does: * `.` Matches any single character. * `*` Matches zero or more of the preceding element. The function prototype is: ```python def is_match(s: str, p: str) -> bool ``` # Input & Output * **Input**: - `s`: A string `s` consisting of lowercase letters. - `p`: A pattern string `p` that may contain lowercase letters, \'.\' and \'*\'. * **Output**: - A boolean value indicating whether the string `s` matches the pattern `p` entirely. # Constraints * The string and pattern can have a maximum length of 1000. # Performance Requirements * Aim for O(m * n) time complexity and O(m * n) space complexity where m is the length of `s` and n is the length of `p`. # Example Cases 1. **Example 1**: - Input: `s = \\"aa\\"`, `p = \\"a\\"` - Output: `False` - Explanation: The pattern does not cover both \'a\'s in the string. 2. **Example 2**: - Input: `s = \\"aa\\"`, `p = \\"a*\\"` - Output: `True` - Explanation: The \'*\' allows \'a\' to appear zero or more times, so it matches the entire string. 3. **Example 3**: - Input: `s = \\"ab\\"`, `p = \\".*\\"` - Output: `True` - Explanation: \'.*\' matches any character (.) and any number of times (*), thus it covers the entire string. 4. **Example 4**: - Input: `s = \\"aab\\"`, `p = \\"c*a*b\\"` - Output: `True` - Explanation: The pattern can be considered as zero \'c\', followed by two \'a\'s, and one \'b\'. Write a function `is_match` that implements the above requirements.","solution":"def is_match(s: str, p: str) -> bool: Returns whether the given string `s` matches the pattern `p`. if p == \\"\\": return s == \\"\\" # Check if the first character matches or if the pattern has \'.\' first_match = bool(s) and p[0] in {s[0], \'.\'} # Handle the case with \'*\' if len(p) >= 2 and p[1] == \'*\': return (is_match(s, p[2:]) or (first_match and is_match(s[1:], p))) else: return first_match and is_match(s[1:], p[1:])"},{"question":"**Problem Statement:** Implement a function `find_mode(arr)` that takes an array of integers and returns a list of the most frequently occurring integer(s) in the array. If the array contains multiple values with the same highest frequency, the function should return all such values. # Input: * `arr`: A list of integers, where each integer can be positive, negative, or zero. The length of the list, `n`, can be up to 100,000. # Output: * A list of integer(s) that are the mode(s) of the input array. If the array is empty, return an empty list. # Constraints: * The input list can contain positive, negative integers, and zero. * If the input list is empty, return an empty list. # Example: ```python # Example 1 print(find_mode([1, 1, 2, 2, 3, 4])) # Expected output: [1, 2] # Example 2 print(find_mode([3, 3, 3, -1, -1, 0])) # Expected output: [3] # Example 3 print(find_mode([])) # Expected output: [] # Example 4 print(find_mode([1, 2, 3, 4, 5, 6])) # Expected output: [1, 2, 3, 4, 5, 6] ``` # Performance Requirements: The function must run with a time complexity of O(n) and space complexity of O(n), where `n` is the length of the input array.","solution":"def find_mode(arr): from collections import defaultdict if not arr: return [] frequency = defaultdict(int) max_count = 0 for num in arr: frequency[num] += 1 if frequency[num] > max_count: max_count = frequency[num] mode_list = [num for num, count in frequency.items() if count == max_count] return mode_list"},{"question":"Context In ancient Rome, numbers were written using combinations of the following symbols: - `I` = 1 - `V` = 5 - `X` = 10 - `L` = 50 - `C` = 100 - `D` = 500 - `M` = 1000 For example, 2 is written as `II` in Roman numeral, just two one\'s added together. 12 is written as `XII`, which is simply `X` + `II`. The number `27` is written as `XXVII`, which is `XX` + `V` + `II`. Roman numerals are usually written from largest to smallest from left to right. However, the numeral for four is not `IIII`. Instead, the number four is written as `IV`. Because the one is before the five, we subtract it making four. The same principle applies to the number nine, which is written as `IX`. There are six instances where subtraction is used: - `I` can be placed before `V` (5) and `X` (10) to make 4 and 9. - `X` can be placed before `L` (50) and `C` (100) to make 40 and 90. - `C` can be placed before `D` (500) and `M` (1000) to make 400 and 900. Given an integer, convert it to a roman numeral. Input is guaranteed to be within the range from 1 to 3999. Task Implement a function `int_to_roman(num)` that converts a given integer to a Roman numeral. # Function Signature ```python def int_to_roman(num): :type num: int :rtype: str ``` # Input - `num` (int): an integer within the range from 1 to 3999 inclusive. # Output - (str): the Roman numeral representation of the given integer. # Example ```python print(int_to_roman(1)) # Output: \\"I\\" print(int_to_roman(3999)) # Output: \\"MMMCMXCIX\\" print(int_to_roman(58)) # Output: \\"LVIII\\" print(int_to_roman(1994)) # Output: \\"MCMXCIV\\" ``` Constraints - The function should handle edge cases and ensure the output matches the classical Roman numeral format. - The function should be efficient and work in constant time and space.","solution":"def int_to_roman(num): Converts an integer to a Roman numeral. :type num: int :rtype: str val = [ 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1 ] syms = [ \\"M\\", \\"CM\\", \\"D\\", \\"CD\\", \\"C\\", \\"XC\\", \\"L\\", \\"XL\\", \\"X\\", \\"IX\\", \\"V\\", \\"IV\\", \\"I\\" ] roman_numeral = \'\' i = 0 while num > 0: for _ in range(num // val[i]): roman_numeral += syms[i] num -= val[i] i += 1 return roman_numeral"},{"question":"You are tasked with writing a function to determine if a given password is strong based on specific rules. If the password is not strong, the function should return the minimum number of characters that need to be added to make it strong. # Password Strength Rules A password is considered strong if: 1. It has at least one digit (0-9). 2. It has at least one lowercase letter (a-z). 3. It has at least one uppercase letter (A-Z). 4. It has at least one special character from the set: `!@#%^&*()-+`. 5. It is at least 6 characters long. # Function Specification Write a function `strong_password` that takes in two parameters: 1. `n` (Integer): The length of the password string. 2. `password` (String): The string representing the password. The function should return an integer representing the minimum number of characters that must be added to make the password strong. # Input Format - The first parameter is an integer `n` denoting the length of the string. - The second parameter is a string `password` consisting of `n` characters. # Output Format - Return an integer representing the minimum number of characters that must be added. # Examples Example 1 **Input**: `strong_password(3, \\"Ab1\\")` **Output**: `3` **Explanation**: The password can be made strong by adding 3 characters, for example, `hk`, making it \\"Ab1hk\\". This makes the password length at least 6 and satisfies all required conditions. Example 2 **Input**: `strong_password(11, \\"#Algorithms\\")` **Output**: `1` **Explanation**: The password \\"#Algorithms\\" is missing a digit but satisfies other conditions. Adding just one digit will make it strong. # Constraints - The length of the password `n` will be in the range [1, 100]. Use the following character sets to identify required character types: ```python numbers = \\"0123456789\\" lower_case = \\"abcdefghijklmnopqrstuvwxyz\\" upper_case = \\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\\" special_characters = \\"!@#%^&*()-+\\" ``` # Implementation Implement the function in Python as shown below: ```python def strong_password(n, password): count_error = 0 # Return the minimum number of characters to make the password strong if not any(i.isdigit() for i in password): count_error += 1 if not any(i.islower() for i in password): count_error += 1 if not any(i.isupper() for i in password): count_error += 1 if not any(i in \'!@#%^&*()-+\' for i in password): count_error += 1 return max(count_error, 6 - n) ```","solution":"def strong_password(n, password): Determine if the given password is strong, and if not, return the minimum number of characters needed to make it strong. required_characters = 0 # Check for at least one digit if not any(char.isdigit() for char in password): required_characters += 1 # Check for at least one lowercase letter if not any(char.islower() for char in password): required_characters += 1 # Check for at least one uppercase letter if not any(char.isupper() for char in password): required_characters += 1 # Check for at least one special character if not any(char in \'!@#%^&*()-+\' for char in password): required_characters += 1 # Check for the length if n < 6: return max(required_characters, 6 - n) return required_characters"},{"question":"You need to implement a feature to find all *strongly connected components (SCCs)* in a directed graph. An SCC in a directed graph is a maximal subgraph where each pair of vertices in the subgraph is mutually reachable. # Function Signature ```python def find_scc(graph: DirectedGraph) -> List[List[str]]: pass ``` # Input - A directed graph represented as an instance of `DirectedGraph` containing nodes and directed edges. # Output - A list of strongly connected components, where each SCC is represented as a list of strings (the names of the nodes in the SCC). # Constraints - All node names are unique. - There can be up to 10^3 nodes and 10^4 edges. # Example ```python graph_data = { \'A\': [\'B\'], \'B\': [\'C\', \'D\'], \'C\': [\'A\'], \'D\': [\'E\'], \'E\': [\'D\'] } graph = DirectedGraph(graph_data) result = find_scc(graph) print(result) # Output: [[\'A\', \'B\', \'C\'], [\'D\', \'E\']] ``` # Requirements 1. Implement an algorithm to identify SCCs based on Tarjan\'s or Kosaraju\'s algorithm. 2. Handle edge cases such as disconnected nodes or nodes without outgoing/incoming edges. 3. Ensure your solution is efficient given the constraints of the problem. # Note - The order of nodes in each SCC and the order of SCCs in the result can vary. - You can use the provided `Node`, `DirectedEdge`, and `DirectedGraph` classes as needed for graph operations.","solution":"from collections import defaultdict from typing import List, Dict class DirectedGraph: def __init__(self, data: Dict[str, List[str]]): self.graph = data self.nodes = list(data.keys()) def find_scc(graph: DirectedGraph) -> List[List[str]]: Tarjan\'s Algorithm to find all Strongly Connected Components (SCCs) in a directed graph. def strong_connect(node): nonlocal index, stack, index_map, low_link, on_stack, sccs index_map[node] = index low_link[node] = index index += 1 stack.append(node) on_stack[node] = True for neighbor in graph.graph[node]: if neighbor not in index_map: strong_connect(neighbor) low_link[node] = min(low_link[node], low_link[neighbor]) elif on_stack[neighbor]: low_link[node] = min(low_link[node], index_map[neighbor]) if low_link[node] == index_map[node]: scc = [] while True: w = stack.pop() on_stack[w] = False scc.append(w) if w == node: break sccs.append(scc) index = 0 stack = [] index_map = {} low_link = {} on_stack = defaultdict(bool) sccs = [] for node in graph.nodes: if node not in index_map: strong_connect(node) return sccs"},{"question":"# Binary Tree Maximum Depth Assessment **Context**: You are developing a feature in a software system that requires understanding the maximum depth of hierarchical structures represented as binary trees. Your task is to implement a function to determine the maximum depth of a given binary tree. **Function Signature**: `def max_depth(root: TreeNode) -> int:` Input: * A single variable `root`, which is the root node of the binary tree. The `TreeNode` class is defined as: ```python class TreeNode: def __init__(self, val: int, left: \'TreeNode\' = None, right: \'TreeNode\' = None): self.val = val self.left = left self.right = right ``` Output: * An integer representing the maximum depth of the tree. **Constraints**: * The number of nodes in the tree is between 0 and 10,000. * The values of the nodes are integers and can be positive or negative. **Additional Information**: * A tree with only one node has a depth of 1. * An empty tree has a depth of 0. **Performance Requirements**: * The solution should efficiently handle trees with up to 10,000 nodes. Example: ```python # Example 1 root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) root.left.left = TreeNode(4) root.left.right = TreeNode(5) print(max_depth(root)) # Output: 3 # Example 2 root = TreeNode(1) print(max_depth(root)) # Output: 1 # Example 3 print(max_depth(None)) # Output: 0 ``` Task: Implement the `max_depth` function using any method you prefer (recursive or iterative). Ensure to handle all edge cases and optimize for performance where necessary.","solution":"class TreeNode: def __init__(self, val: int, left: \'TreeNode\' = None, right: \'TreeNode\' = None): self.val = val self.left = left self.right = right def max_depth(root: TreeNode) -> int: Returns the maximum depth of the binary tree with given root. if root is None: return 0 left_depth = max_depth(root.left) right_depth = max_depth(root.right) return max(left_depth, right_depth) + 1"},{"question":"# Objective Implement a `PriorityQueue` class that extends the functionality of a standard queue by adding elements based on their priority levels. A `PriorityQueue` should allow elements with higher priority to be dequeued before elements with lower priority regardless of the order they were enqueued. # Requirements * You are required to implement a `PriorityQueue` class in Python. * The `PriorityQueue` should maintain elements such that the highest priority element is always at the front, ready to be dequeued next. * If two elements have the same priority, they should be dequeued in the order they were added. # Class Definition * The `PriorityQueue` class should include the following methods: - `enqueue(item, priority)`: Adds an item with the given priority to the queue. Parameters: `item` (the item to be added), `priority` (an integer representing the priority, with higher values having higher priority). - `dequeue()`: Removes and returns the front element with the highest priority from the queue. - `peek()`: Returns the front element with the highest priority without removing it from the queue. - `isEmpty()`: Checks if the queue is empty. Returns `True` if it\'s empty; otherwise, returns `False`. - `size()`: Returns the number of elements currently in the queue. # Implementation Constraints * The `PriorityQueue` should use a min-heap (using Python `heapq` module) to manage the order of the elements based on their priority. * The time complexity of `enqueue`, `dequeue`, and `peek` operations should be logarithmic, i.e., O(log n). * The space complexity should be O(n), where n is the number of elements in the queue. # Input / Output Format * `enqueue(item, priority)` * Input: item (any data type), priority (integer) * Output: None * `dequeue()` * Input: None * Output: item with the highest priority * `peek()` * Input: None * Output: item with the highest priority * `isEmpty()` * Input: None * Output: True or False * `size()` * Input: None * Output: integer representing the number of elements # Example Usage ```python pq = PriorityQueue() pq.enqueue(\'Task 1\', 2) pq.enqueue(\'Task 2\', 1) pq.enqueue(\'Task 3\', 3) print(pq.peek()) # Output: \'Task 3\' print(pq.dequeue()) # Output: \'Task 3\' print(pq.size()) # Output: 2 print(pq.isEmpty()) # Output: False print(pq.dequeue()) # Output: \'Task 1\' ``` # Guidelines * Use Python\'s `heapq` module to efficiently manage the heap operations. * Ensure that the code handles edge cases such as dequeueing from an empty queue. * The constructor should initialize an empty priority queue. * Strive for clean, readable, and efficient code.","solution":"import heapq class PriorityQueue: def __init__(self): self.heap = [] self.counter = 0 def enqueue(self, item, priority): # Using negative priority because heapq implements a min-heap heapq.heappush(self.heap, (-priority, self.counter, item)) self.counter += 1 def dequeue(self): if self.isEmpty(): raise IndexError(\\"dequeue from an empty priority queue\\") return heapq.heappop(self.heap)[2] def peek(self): if self.isEmpty(): raise IndexError(\\"peek from an empty priority queue\\") return self.heap[0][2] def isEmpty(self): return len(self.heap) == 0 def size(self): return len(self.heap)"},{"question":"You are tasked with extending the functionality of a Markov chain. Specifically, you need to implement a function that generates a finite sequence of states given an initial state and a predefined number of transitions. # Requirements * Implement a function `generate_markov_sequence(chain, initial_state, transitions)` that generates a list of states. * **Input**: * `chain`: A dictionary representing the Markov chain with state transition probabilities. * `initial_state`: The state from which to start the sequence. * `transitions`: An integer indicating the number of state transitions. * **Output**: * A list of states representing the sequence of transitions starting from `initial_state`. # Constraints * The transition probabilities in the chain sum to 1 for each state. * Assume `transitions` is a positive integer. * Assume `initial_state` is a valid key in the chain dictionary. # Example ```python chain = { \'A\': {\'A\': 0.6, \'E\': 0.4}, \'E\': {\'A\': 0.7, \'E\': 0.3} } initial_state = \'A\' transitions = 5 sequence = generate_markov_sequence(chain, initial_state, transitions) # Example Output: [\'A\', \'E\', \'A\', \'A\', \'E\'] ``` # Performance Requirements * The function should handle chains with up to 1000 states efficiently. # Implementation Details 1. Use the existing `next_state` and `__choose_state` functions to determine the next state. 2. Ensure proper random state selections conforming to the probability distribution. Implement the function `generate_markov_sequence(chain, initial_state, transitions)`.","solution":"import random def __choose_state(prob_dist): Helper function to choose the next state based on a probability distribution. states = list(prob_dist.keys()) probabilities = list(prob_dist.values()) return random.choices(states, probabilities)[0] def generate_markov_sequence(chain, initial_state, transitions): Generates a sequence of states given a Markov chain, an initial state, and a number of transitions. current_state = initial_state sequence = [current_state] for _ in range(transitions): next_state = __choose_state(chain[current_state]) sequence.append(next_state) current_state = next_state return sequence"},{"question":"Power of Two Array Check Context Given the need to frequently verify whether elements in an array are powers of two, it\'s essential to extend the individual power-of-two check to work on arrays efficiently. Objective Write a function `power_of_twos(arr)` that, given an array of integers, returns a list of booleans indicating whether each element is a power of two. Function Signature ```python def power_of_twos(arr: List[int]) -> List[bool]: Determine if each integer in the array is a power of two. :param arr: List[int] - A list of integers to check. :return: List[bool] - A list with boolean values indicating whether each integer is a power of two. pass ``` Input - `arr`: A list of integers where `1 <= len(arr) <= 10^5` and `-2^31 <= arr[i] <= 2^31 - 1`. Output - A list of booleans where each boolean corresponds to whether the integer at that index in the input list is a power of two. Constraints - Optimize for time complexity since the input list can be large. Example ```python assert power_of_twos([1, 2, 3, 4, 5]) == [True, True, False, True, False] assert power_of_twos([16, 32, 64, 128, -128]) == [True, True, True, True, False] assert power_of_twos([1024, 1025, 2048, 4096, 0]) == [True, False, True, True, False] ``` Performance Requirements - The solution should run in O(n) time complexity where n is the length of the input list `arr`.","solution":"from typing import List def is_power_of_two(n: int) -> bool: Check if a given integer is a power of two. :param n: int - Integer to check. :return: bool - Whether the integer is a power of two. if n <= 0: return False return (n & (n - 1)) == 0 def power_of_twos(arr: List[int]) -> List[bool]: Determine if each integer in the array is a power of two. :param arr: List[int] - A list of integers to check. :return: List[bool] - A list with boolean values indicating whether each integer is a power of two. return [is_power_of_two(num) for num in arr]"},{"question":"# Question You are given a non-negative integer represented as a list of digits, where the most significant digit is at the head of the list. Your task is to write a function `increment_list_number(digits)` that returns a new list representing the number plus one, using only constant O(1) space if possible. Input: - `digits`: A non-empty list of integers `[d1, d2, ..., dn]` where `0 ≤ di ≤ 9`. Output: - A list of integers representing the incremented number. Constraints: - The list will contain between 1 and 1000 digits. - You need to handle in-place modifications when possible. Example: ```python assert increment_list_number([1, 2, 3]) == [1, 2, 4] assert increment_list_number([4, 3, 2, 1]) == [4, 3, 2, 2] assert increment_list_number([9, 9, 9]) == [1, 0, 0, 0] assert increment_list_number([0]) == [1] ``` Remember to consider edge cases such as a list with all nines or single-element lists. Ensure your solution is optimized for performance on large inputs and correctly modifies the input list when possible to save space.","solution":"def increment_list_number(digits): Increment the number represented by the list of digits by one. Args: digits (list of int): The list of digits representing the number. Returns: list of int: The incremented number represented as a list of digits. n = len(digits) # Traverse the list from the end towards the beginning for i in range(n - 1, -1, -1): if digits[i] < 9: # If current digit is less than 9, increment it by 1 and return the result immediately digits[i] += 1 return digits else: # If current digit is 9, set it to 0 digits[i] = 0 # If all digits were 9, we need an extra digit at the beginning return [1] + digits"},{"question":"**Objective**: Create a function to determine if a directed graph is strongly connected by implementing an algorithm similar to the one analyzed above. You are providing a highly realistic scenario for application of this algorithm. **Scenario**: You are tasked with developing a system to ensure the reliability of a communications network. The network must be able to transmit data between any two nodes (computers) reliably, regardless of the communication direction. To validate the network\'s robustness, you need to verify if it forms a single strongly connected component. **Problem Statement**: Write a function `is_strongly_connected_graph(vertex_count, edges)` that determines if a given directed graph is strongly connected. **Input**: * `vertex_count (int)`: The number of vertices in the graph (numbered from 0 to vertex_count-1). * `edges (List[Tuple[int, int]])`: A list of directed edges in the graph. Each edge is represented as a tuple `(source, target)`. **Output**: * Returns `True` if the graph is strongly connected, `False` otherwise. **Constraints**: * Vertices are indexed from `0` to `vertex_count-1`. * There are no self-loops or multiple edges between the same pair of vertices. * The number of vertices `vertex_count` is between 1 and 1000. * The number of edges is between 0 and 5000. **Function Signature**: ```python def is_strongly_connected_graph(vertex_count: int, edges: List[Tuple[int, int]]) -> bool: ``` **Example**: ```python print(is_strongly_connected_graph(4, [(0, 1), (1, 2), (2, 3), (3, 0)])) # Output: True print(is_strongly_connected_graph(4, [(0, 1), (1, 2), (2, 3)])) # Output: False ``` **Explanation**: In the first example, each node can reach every other node directly or indirectly, and vice versa. So, the graph is strongly connected. In the second example, node 3 cannot reach node 0, hence it is not strongly connected. **Notes**: - Handle edge cases such as graphs with no edges and graphs where some vertices are completely isolated. - Consider the potential limitations and edge cases of recursive DFS and memory usage in large graphs.","solution":"def is_strongly_connected_graph(vertex_count, edges): from collections import defaultdict, deque def bfs(start, graph): visited = [False] * vertex_count queue = deque([start]) visited[start] = True count = 1 while queue: node = queue.popleft() for neighbor in graph[node]: if not visited[neighbor]: visited[neighbor] = True queue.append(neighbor) count += 1 return count == vertex_count # Create the adjacency list graph = defaultdict(list) reverse_graph = defaultdict(list) for u, v in edges: graph[u].append(v) reverse_graph[v].append(u) # Check if all vertices are reachable from the initial vertex in the original graph if not bfs(0, graph): return False # Check if all vertices are reachable from the initial vertex in the reversed graph if not bfs(0, reverse_graph): return False return True"},{"question":"Implement a Red-Black Tree Deletion Function Objective Implement the `delete` function for a Red-Black tree, which removes a node with a given value and ensures the tree remains balanced following the Red-Black properties. This function should be capable of handling typical edge cases and performing necessary adjustments to maintain balance and properties of the RB tree. Problem Statement You are provided with a partially implemented Red-Black Tree as shown in the provided code snippet. Your task is to complete the `delete` function, and `delete_fixup` method so that nodes can be removed correctly while maintaining the Red-Black tree\'s properties. Input * An instance of the class `RBTree`. * An integer `val`, representing the value of the node to be deleted. Output * None. The Red-Black Tree structure should be modified in-place. Constraints * The node to be deleted is guaranteed to exist. * You should maintain all the Red-Black Tree properties after deletion. * The tree size will be `n` where `1 <= n <= 1000`. Example ```python rb = RBTree() children = [20, 15, 25, 10, 5, 1, 30] for child in children: node = RBNode(child, 1) rb.insert(node) rb.delete(rb.root.left) # assuming you want to delete node with value 15 print(rb.inorder()) # The inorder traversal should not include the deleted node ``` # Task * Complete the `delete` and `delete_fixup` methods in the given Red-Black Tree implementation.","solution":"class RBNode: def __init__(self, key, color, left=None, right=None, p=None): self.key = key self.color = color # 0 for black, 1 for red self.left = left self.right = right self.p = p class RBTree: def __init__(self): self.TNULL = RBNode(0, 0) self.root = self.TNULL def __search_tree_helper(self, node, key): if node == self.TNULL or key == node.key: return node if key < node.key: return self.__search_tree_helper(node.left, key) return self.__search_tree_helper(node.right, key) def searchTree(self, k): return self.__search_tree_helper(self.root, k) def __rb_transplant(self, u, v): if u.p == None: self.root = v elif u == u.p.left: u.p.left = v else: u.p.right = v v.p = u.p def __minimum(self, node): while node.left != self.TNULL: node = node.left return node def __delete_node_helper(self, node, key): z = self.TNULL while node != self.TNULL: if node.key == key: z = node if node.key <= key: node = node.right else: node = node.left if z == self.TNULL: print(\\"Couldn\'t find key in the tree\\") return y = z y_original_color = y.color if z.left == self.TNULL: x = z.right self.__rb_transplant(z, z.right) elif z.right == self.TNULL: x = z.left self.__rb_transplant(z, z.left) else: y = self.__minimum(z.right) y_original_color = y.color x = y.right if y.p == z: x.p = y else: self.__rb_transplant(y, y.right) y.right = z.right y.right.p = y self.__rb_transplant(z, y) y.left = z.left y.left.p = y y.color = z.color if y_original_color == 0: self.__fix_delete(x) def __fix_delete(self, x): while x != self.root and x.color == 0: if x == x.p.left: s = x.p.right if s.color == 1: s.color = 0 x.p.color = 1 self.__left_rotate(x.p) s = x.p.right if s.left.color == 0 and s.right.color == 0: s.color = 1 x = x.p else: if s.right.color == 0: s.left.color = 0 s.color = 1 self.__right_rotate(s) s = x.p.right s.color = x.p.color x.p.color = 0 s.right.color = 0 self.__left_rotate(x.p) x = self.root else: s = x.p.left if s.color == 1: s.color = 0 x.p.color = 1 self.__right_rotate(x.p) s = x.p.left if s.left.color == 0 and s.left.color == 0: s.color = 1 x = x.p else: if s.left.color == 0: s.right.color = 0 s.color = 1 self.__left_rotate(s) s = x.p.left s.color = x.p.color x.p.color = 0 s.left.color = 0 self.__right_rotate(x.p) x = self.root x.color = 0 def __left_rotate(self, x): y = x.right x.right = y.left if y.left != self.TNULL: y.left.p = x y.p = x.p if x.p == None: self.root = y elif x == x.p.left: x.p.left = y else: x.p.right = y y.left = x x.p = y def __right_rotate(self, x): y = x.left x.left = y.right if y.right != self.TNULL: y.right.p = x y.p = x.p if x.p == None: self.root = y elif x == x.p.right: x.p.right = y else: x.p.left = y y.right = x x.p = y def insert(self, key): node = RBNode(key, 1) node.p = None node.left = self.TNULL node.right = self.TNULL node.color = 1 y = None x = self.root while x != self.TNULL: y = x if node.key < x.key: x = x.left else: x = x.right node.p = y if y == None: self.root = node elif node.key < y.key: y.left = node else: y.right = node if node.p == None: node.color = 0 return if node.p.p == None: return self.__fix_insert(node) def __fix_insert(self, k): while k.p.color == 1: if k.p == k.p.p.right: u = k.p.p.left if u.color == 1: u.color = 0 k.p.color = 0 k.p.p.color = 1 k = k.p.p else: if k == k.p.left: k = k.p self.__right_rotate(k) k.p.color = 0 k.p.p.color = 1 self.__left_rotate(k.p.p) else: u = k.p.p.right if u.color == 1: u.color = 0 k.p.color = 0 k.p.p.color = 1 k = k.p.p else: if k == k.p.right: k = k.p self.__left_rotate(k) k.p.color = 0 k.p.p.color = 1 self.__right_rotate(k.p.p) if k == self.root: break self.root.color = 0 def delete_node(self, data): self.__delete_node_helper(self.root, data) def inorder_helper(self, node): if node != self.TNULL: self.inorder_helper(node.left) print(node.key, end=\\" \\") self.inorder_helper(node.right) def inorder(self): self.inorder_helper(self.root) print() def __len__(self): def count(node): if node == self.TNULL: return 0 return 1 + count(node.left) + count(node.right) return count(self.root) def __contains__(self, item): node = self.__search_tree_helper(self.root, item) return node != self.TNULL"},{"question":"# Disjoint Set Union-Find Challenge Context: You are working for a mapping application where users can mark locations on a grid as land. Initially, all cells in the grid are considered water. When a user marks a specific cell as land, it\'s important to determine the number of distinct islands on the grid. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. Objective: Implement a function `count_islands(grid_size: Tuple[int, int], positions: List[Tuple[int, int]]) -> List[int]`. Given a grid size in the form of (rows, columns) and a list of positions where land is added sequentially, return a list of integers where each integer represents the number of islands after each successive land addition. Function Signature: ```python from typing import List, Tuple def count_islands(grid_size: Tuple[int, int], positions: List[Tuple[int, int]]) -> List[int]: pass ``` Input: - `grid_size` (Tuple[int, int]): A tuple representing the dimensions of the grid. - `positions` (List[Tuple[int, int]]): A list of tuples representing the positions to add land, in the order they are added. Output: - Returns a list of integers, where each integer represents the number of islands on the grid after each add-land operation. Constraints: - The grid will have at most 10^4 cells. - Positions will contain at most 10^4 add operations. - Positions are 0-indexed inside the grid. Example: ```python assert count_islands((3, 3), [(0, 0), (0, 1), (1, 2), (2, 1)]) == [1, 1, 2, 3] ``` **Explanation**: 1. Adding land at (0, 0): 1 island. 2. Adding land at (0, 1): 1 island. 3. Adding land at (1, 2): 2 islands. 4. Adding land at (2, 1): 3 islands. Your task is to implement the `count_islands` function using the Union-Find data structure to efficiently track and count the number of islands formed after each land addition.","solution":"from typing import List, Tuple class UnionFind: def __init__(self, size: int): self.parent = list(range(size)) self.rank = [1] * size self.count = 0 def find(self, x: int) -> int: if self.parent[x] != x: self.parent[x] = self.find(self.parent[x]) return self.parent[x] def union(self, x: int, y: int) -> bool: rootX = self.find(x) rootY = self.find(y) if rootX != rootY: if self.rank[rootX] > self.rank[rootY]: self.parent[rootY] = rootX elif self.rank[rootX] < self.rank[rootY]: self.parent[rootX] = rootY else: self.parent[rootY] = rootX self.rank[rootX] += 1 self.count -= 1 return True return False def add_count(self): self.count += 1 def get_count(self) -> int: return self.count def count_islands(grid_size: Tuple[int, int], positions: List[Tuple[int, int]]) -> List[int]: rows, cols = grid_size total_cells = rows * cols uf = UnionFind(total_cells) result = [] directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] land_set = set() for r, c in positions: if (r, c) in land_set: result.append(uf.get_count()) continue land_set.add((r, c)) uf.add_count() index = r * cols + c for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < rows and 0 <= nc < cols and (nr, nc) in land_set: uf.union(index, nr * cols + nc) result.append(uf.get_count()) return result"},{"question":"# Scenario You are working on a search engine that supports flexible word matching. Users can search for exact words or use a wildcard character \'.\' to denote any letter. Your task is to implement an efficient data structure to store and search for words with or without wildcard characters. # Task Implement a class `WordDictionary` that supports adding words and searching for words, leveraging a Trie (Prefix Tree) data structure to handle the operations efficiently. # Function Specifications 1. `add_word(word: str) -> None`: Add a word to the data structure. 2. `search(word: str) -> bool`: Return True if the word (or pattern with \'.\') exists in the data structure, False otherwise. # Constraints - The words consist of lowercase English letters only. - Maximum word length is 500. - The number of words added and searched can be large, up to 10^5. # Example Usage ```python wd = WordDictionary() wd.add_word(\\"bad\\") wd.add_word(\\"dad\\") wd.add_word(\\"mad\\") print(wd.search(\\"pad\\")) # Output: False print(wd.search(\\"bad\\")) # Output: True print(wd.search(\\".ad\\")) # Output: True print(wd.search(\\"b..\\")) # Output: True ``` # Performance Requirements Your implementation should be optimized for both time and space to handle up to 10^5 operations efficiently. **Note**: Consider edge cases such as an empty word or a word consisting entirely of wildcards.","solution":"class TrieNode: A node in the Trie structure. def __init__(self): self.children = {} self.is_end_of_word = False class WordDictionary: A data structure for storing words and searching for words with or without wildcards. def __init__(self): self.root = TrieNode() def add_word(self, word: str) -> None: Adds a word into the data structure. node = self.root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.is_end_of_word = True def search(self, word: str) -> bool: Returns if the word (with \'.\' acting as wildcard) is in the data structure. return self._search_recursive(word, self.root, 0) def _search_recursive(self, word: str, node: TrieNode, index: int) -> bool: Helper function to search recursively through the Trie. if index == len(word): return node.is_end_of_word char = word[index] if char == \'.\': for child in node.children.values(): if self._search_recursive(word, child, index + 1): return True return False else: if char in node.children: return self._search_recursive(word, node.children[char], index + 1) else: return False"},{"question":"# Coding Challenge: Remove Reoccurring Characters Context In many text processing applications, it is useful to remove duplicate characters to ensure uniqueness and improve data quality. Your task is to write a function that processes a given string to remove all duplicate characters, maintaining only the first occurrence of each character. Problem Statement Write a function `remove_reoccurring_characters` that takes a string as input and returns a new string with all duplicate characters removed while preserving the order of first occurrences. Function Signature ```python def remove_reoccurring_characters(s: str) -> str: ``` Input * `s` (String): A string that can contain any printable characters. Length of `s` is `0 <= len(s) <= 10^6`. Output * Returns a string with all duplicate characters removed. Constraints * The order of characters in the output must match their first occurrence in the input. * The function should perform efficiently even for large input strings. Example ```python remove_reoccurring_characters(\\"programming\\") ``` * Expected Output: `\\"progamin\\"` ```python remove_reoccurring_characters(\\"aabcc\\") ``` * Expected Output: `\\"abc\\"` ```python remove_reoccurring_characters(\\"\\") ``` * Expected Output: `\\"\\"` (empty string) Notes 1. Inputs will only include printable ASCII characters. 2. Characters are case sensitive, so \'A\' and \'a\' are considered distinct. Requirements - Ensure the function operates in linear time O(n) with respect to the length of the input string. - Minimize additional space consumption to input-related data structures.","solution":"def remove_reoccurring_characters(s: str) -> str: Removes duplicate characters from the input string, maintaining only the first occurrence of each character and preserving their order. Args: s (str): The input string. Returns: str: The string with all duplicate characters removed. seen = set() result = [] for char in s: if char not in seen: seen.add(char) result.append(char) return \'\'.join(result)"},{"question":"# Question You are part of a software development team building a lightweight and fast Autocomplete feature for a text editing application. One of the core components of this feature is the implementation of a Trie (Prefix Tree) to store the dictionary of words and allow quick lookup operations. Your task is to implement the Trie with the following functionalities: 1. **Insert**: Method to add a word to the trie. 2. **Search**: Method to search for a word in the trie and return `True` if the word exists, otherwise `False`. 3. **Starts_With**: Method to check if there is any word in the trie that starts with the given prefix. # Input and Output Formats **Function 1: `insert(word: str) -> None`** * **Input**: A single word, `word`, which consists of lowercase letters \'a\' to \'z\'. * **Output**: This function does not return a value. It simply inserts the word into the trie. **Function 2: `search(word: str) -> bool`** * **Input**: A single word, `word`, which consists of lowercase letters \'a\' to \'z\'. * **Output**: Returns `True` if the word is in the trie, otherwise returns `False`. **Function 3: `starts_with(prefix: str) -> bool`** * **Input**: A single string, `prefix`, which consists of lowercase letters \'a\' to \'z\'. * **Output**: Returns `True` if there is any word in the trie that starts with the given prefix, otherwise returns `False`. # Constraints 1. All inputs will be non-empty strings consisting of lowercase letters (\'a\' to \'z\'). 2. The total number of calls to `insert`, `search`, and `starts_with` methods combined will not exceed 10^4. # Example ```python # Example usage of the Trie trie = Trie() trie.insert(\\"apple\\") print(trie.search(\\"apple\\")) # Output: True print(trie.search(\\"app\\")) # Output: False print(trie.starts_with(\\"app\\")) # Output: True trie.insert(\\"app\\") print(trie.search(\\"app\\")) # Output: True ``` Write the code that implements the above-described `Trie` class with the specified methods.","solution":"class TrieNode: def __init__(self): self.children = {} self.end_of_word = False class Trie: def __init__(self): self.root = TrieNode() def insert(self, word: str) -> None: node = self.root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.end_of_word = True def search(self, word: str) -> bool: node = self._find_node(word) return node is not None and node.end_of_word def starts_with(self, prefix: str) -> bool: node = self._find_node(prefix) return node is not None def _find_node(self, prefix: str) -> TrieNode: node = self.root for char in prefix: if char in node.children: node = node.children[char] else: return None return node"},{"question":"# Objective Implement an optimized version of Dijkstra\'s algorithm using a priority queue for finding the shortest path from a source node to all other nodes in a graph. # Task Write a function `optimized_dijkstra(graph: List[List[Tuple[int, int]]], vertex_count: int, src: int) -> List[float]` that accepts a directed graph, represented as an adjacency list, the number of vertices, and a source vertex. The function should return the shortest distance from the source vertex to every other vertex in the graph. # Inputs * **graph**: A list of lists where each sub-list contains tuples representing the target vertex and the edge weight from the source vertex. `graph[u] = [(v1, w1), (v2, w2), ..., (vn, wn)]` implies there is an edge from vertex `u` to vertex `v1`, `v2`, ..., `vn` with weights `w1`, `w2`, ..., `wn` respectively. * **vertex_count**: An integer, the number of vertices in the graph. * **src**: An integer, the source vertex. # Output * A list of floats representing the shortest distance from the source vertex to all vertices. If a vertex is not reachable from the source, its distance should be `inf`. # Constraints * The number of vertices, ( V ), is `1 <= vertex_count <= 1000`. * The number of edges, ( E ), is `0 <= E <= vertex_count * (vertex_count - 1)`. * Edge weights are non-negative and reasonably small positive numbers. * Graph is directed and may have 0 or more edges. # Performance * Expected time complexity: ( O(E + V log V) ) * Expected space complexity: ( O(V + E) ) # Example Input: ```python graph = [ [(1, 4), (2, 1)], # Connections from vertex 0 [(3, 1)], # Connections from vertex 1 [(1, 2), (3, 5)], # Connections from vertex 2 [] # Connections from vertex 3 ] vertex_count = 4 src = 0 ``` Output: ```python [0, 3, 1, 4] ``` # Explanation The shortest paths from vertex 0 are: * To vertex 1: 0 -> 2 -> 1 (total weight 3) * To vertex 2: 0 -> 2 (total weight 1) * To vertex 3: 0 -> 2 -> 1 -> 3 (total weight 4)","solution":"import heapq from typing import List, Tuple import math def optimized_dijkstra(graph: List[List[Tuple[int, int]]], vertex_count: int, src: int) -> List[float]: Implements Dijkstra\'s algorithm using a priority queue to find the shortest path from the source vertex to all other vertices in a graph. :param graph: List of lists where each sub-list contains tuples representing the target vertex and the edge weight. :param vertex_count: Integer, number of vertices in the graph. :param src: Integer, the source vertex. :return: List of floats representing the shortest distance from the source vertex to all vertices. distances = [math.inf] * vertex_count distances[src] = 0 priority_queue = [(0, src)] # (distance, vertex) while priority_queue: current_distance, u = heapq.heappop(priority_queue) if current_distance > distances[u]: continue for v, weight in graph[u]: distance = current_distance + weight if distance < distances[v]: distances[v] = distance heapq.heappush(priority_queue, (distance, v)) return distances"},{"question":"# Matrix Multiplication Coding Assessment Objective Implement the matrix multiplication algorithm that multiplies two given 2D matrices if they are compatible in dimensions. Description You are provided with two 2D lists (matrices) representing multiplicand and multiplier. Your task is to write a function that returns their product. The function should handle the case when the matrices are not compatible for multiplication by raising an appropriate exception. Function Signature ```python def multiply(multiplicand: list, multiplier: list) -> list: ``` Inputs - `multiplicand`: A 2D list of integers representing the first matrix. - `multiplier`: A 2D list of integers representing the second matrix. Outputs - A 2D list of integers representing the product matrix if the input matrices are compatible. - If not compatible, the function should raise an exception with a clear error message. Constraints - Matrix elements will be integers. - Matrix dimensions will be within the range of 1 to 100 inclusive. - Ensure to validate the dimensions before proceeding with multiplication. Example ```python multiplicand = [ [1, 2, 3], [4, 5, 6] ] multiplier = [ [7, 8], [9, 10], [11, 12] ] result = [ [58, 64], [139, 154] ] assert multiply(multiplicand, multiplier) == result ``` Edge Cases - Ensure that the function correctly handles and raises exceptions for incompatible dimensions, such as: ```python multiplicand = [ [1, 2, 3], [4, 5, 6] ] multiplier = [ [7, 8, 9] ] # Should raise an exception multiply(multiplicand, multiplier) ``` Performance Requirements Ensure the implementation adheres to the time complexity of O(n^3) and space complexity of O(n^2).","solution":"def multiply(multiplicand: list, multiplier: list) -> list: # Validate dimensions if len(multiplicand[0]) != len(multiplier): raise ValueError(\\"Incompatible dimensions for matrix multiplication.\\") # Initialize the product matrix with zeros product = [[0 for _ in range(len(multiplier[0]))] for _ in range(len(multiplicand))] # Perform multiplication for i in range(len(multiplicand)): for j in range(len(multiplier[0])): for k in range(len(multiplier)): product[i][j] += multiplicand[i][k] * multiplier[k][j] return product"},{"question":"**Problem Statement:** You are required to implement a variant of the Heap Sort algorithm that can switch between using a max heap and a min heap to sort an array in ascending order. Additionally, as a part of this question, optimize your heap sorting method to reduce potential performance overhead. **Objective:** 1. Implement a function `heap_sort(arr, use_max_heap=True)` that sorts the given array `arr` using heap sort. - If `use_max_heap` is True, utilize a max heap to sort. - If `use_max_heap` is False, utilize a min heap to sort. 2. Optimize the heapify process to reduce overhead by using an iterative approach. # Function Signature ```python def heap_sort(arr, use_max_heap=True): Function to perform heap sort using either a max heap or min heap. Args: arr (list): Array of integers to be sorted. use_max_heap (bool): flag to decide whether to use max heap or min heap. Defaults to True. Returns: list: Sorted array pass ``` # Input - `arr`: A list of integers (1 ≤ len(arr) ≤ 10^5) - `use_max_heap`: A boolean flag (True/False) to determine the type of heap to be used. # Output - A list of integers sorted in ascending order. # Constraints - The function should handle empty arrays and arrays with one element gracefully. - The function should avoid recursion for heapify to prevent stack overflow on large arrays. - The algorithm should achieve a time complexity of O(n log n) and a space complexity of O(1). # Example ```python # Test with max heap print(heap_sort([4, 10, 3, 5, 1])) # Output: [1, 3, 4, 5, 10] # Test with min heap print(heap_sort([4, 10, 3, 5, 1], use_max_heap=False)) # Output: [1, 3, 4, 5, 10] ``` # Notes 1. Focus on designing the `heap_sort` function that calls `max_heapify` or `min_heapify` based on the `use_max_heap` flag. 2. Rewrite the heapify functions iteratively to improve both memory and time efficiency.","solution":"def heap_sort(arr, use_max_heap=True): Function to perform heap sort using either a max heap or min heap. Args: arr (list): Array of integers to be sorted. use_max_heap (bool): flag to decide whether to use max heap or min heap. Defaults to True. Returns: list: Sorted array in ascending order def heapify(arr, n, i, use_max_heap): largest_smallest = i left = 2 * i + 1 right = 2 * i + 2 if use_max_heap: if left < n and arr[i] < arr[left]: largest_smallest = left if right < n and arr[largest_smallest] < arr[right]: largest_smallest = right else: if left < n and arr[i] > arr[left]: largest_smallest = left if right < n and arr[largest_smallest] > arr[right]: largest_smallest = right if largest_smallest != i: arr[i], arr[largest_smallest] = arr[largest_smallest], arr[i] heapify(arr, n, largest_smallest, use_max_heap) n = len(arr) for i in range(n // 2 - 1, -1, -1): heapify(arr, n, i, use_max_heap) for i in range(n - 1, 0, -1): arr[i], arr[0] = arr[0], arr[i] heapify(arr, i, 0, use_max_heap) return arr if use_max_heap else arr[::-1]"},{"question":"**Scenario**: You are given a dataset that needs to be sorted quickly and efficiently. After considering various sorting algorithms, you decide to use Comb Sort because of its simple implementation and better performance over Bubble Sort. **Objective**: Implement the `comb_sort` function to sort an array of integers in ascending order. **Function Signature**: The function signature is `def comb_sort(arr: List[int]) -> List[int]`. **Input**: * `arr`: A list of integers (0 <= len(arr) <= 10^6, -10^9 <= arr[i] <= 10^9). **Output**: * A list of integers sorted in ascending order. **Constraints**: * The function should handle the given input size efficiently. * Memory usage should be minimal, O(1) extra space. **Performance**: The sorting should be performed in place to satisfy O(1) space complexity. Consider the provided code to implement Comb Sort and enhance it to handle all edge cases and constraints efficiently. ```python from typing import List def comb_sort(arr: List[int]) -> List[int]: def swap(i, j): arr[i], arr[j] = arr[j], arr[i] n = len(arr) gap = n shrink = 1.3 sorted = False while not sorted: gap = int(gap / shrink) if gap > 1: sorted = False else: gap = 1 sorted = True i = 0 while i + gap < n: if arr[i] > arr[i + gap]: swap(i, i + gap) sorted = False i = i + 1 return arr # Implement the function here and test with various cases ``` **Example**: ```python assert comb_sort([34, 7, 23, 32, 5, 62]) == [5, 7, 23, 32, 34, 62] assert comb_sort([5, 1, 4, 2, 8]) == [1, 2, 4, 5, 8] assert comb_sort([]) == [] assert comb_sort([1]) == [1] assert comb_sort([3, 3, 3, 3]) == [3, 3, 3, 3] ```","solution":"from typing import List def comb_sort(arr: List[int]) -> List[int]: def swap(i, j): arr[i], arr[j] = arr[j], arr[i] n = len(arr) gap = n shrink = 1.3 sorted = False while not sorted: gap = int(gap / shrink) if gap > 1: sorted = False else: gap = 1 sorted = True i = 0 while i + gap < n: if arr[i] > arr[i + gap]: swap(i, i + gap) sorted = False i += 1 return arr"},{"question":"# Regular Expression Matching Introduction You need to implement a function that simulates regular expression matching with support for \'.\' and \'*\' where: - \'.\' matches any single character. - \'*\' matches zero or more of the preceding element. The matching should cover the entire input string (not partial). Problem Statement Implement the function `is_match` such that it takes two arguments: - `s` (a string): representing the text to be matched. - `p` (a string): representing the pattern. The function `is_match` should return a boolean indicating whether the string `s` matches the pattern `p`. Input - `s`: A string with length 0 <= |s| <= 200. - `p`: A string with length 0 <= |p| <= 200. Output - A boolean value indicating whether `s` matches `p`. Constraints - `s` and `p` consist of only lowercase letters and/or characters `.` and `*`. - \'.\' matches any single character. - \'*\' matches zero or more of the preceding element. Examples ```python # Example 1 s = \\"aa\\" p = \\"a\\" is_match(s, p) # Returns: False # Example 2 s = \\"aa\\" p = \\"a*\\" is_match(s, p) # Returns: True # Example 3 s = \\"ab\\" p = \\".*\\" is_match(s, p) # Returns: True # Example 4 s = \\"aab\\" p = \\"c*a*b\\" is_match(s, p) # Returns: True # Example 5 s = \\"mississippi\\" p = \\"mis*is*p*.\\" is_match(s, p) # Returns: False ``` Instructions Write the function `is_match(s, p)` correctly implementing the described behavior and performance considerations. Ensure your solution handles all edge cases adequately. Hints - Review how Dynamic Programming (DP) can assist in managing state transitions and reducing complexity. - Pay attention to proper initialization and updating of the DP table. - Consider the implications of patterns starting or ending with special characters like \'.\' and \'*\'.","solution":"def is_match(s, p): Returns True if the string s matches the pattern p, else False. # DP approach dp = [[False] * (len(p) + 1) for _ in range(len(s) + 1)] dp[0][0] = True for j in range(1, len(p) + 1): if p[j-1] == \'*\': dp[0][j] = dp[0][j-2] for i in range(1, len(s) + 1): for j in range(1, len(p) + 1): if p[j-1] == \'*\' and j >= 2: dp[i][j] = dp[i][j-2] or (dp[i-1][j] and (p[j-2] == s[i-1] or p[j-2] == \'.\')) else: if p[j-1] == \'.\' or p[j-1] == s[i-1]: dp[i][j] = dp[i-1][j-1] return dp[-1][-1]"},{"question":"# Problem: Euler\'s Totient Function Enhancement Context: Euler\'s Totient Function, ( phi(n) ), counts the number of integers between 1 and ( n ) that are coprime to ( n ). This fundamental function in number theory typically runs in ( O(sqrt{n}) ) time complexity. While efficient for moderate values, for large ( n ), computation needs further optimization. Task: Optimize the Euler\'s Totient Function for multiple queries that involve a large range of values up to ( n ). Implement a function that precomputes the totient values for all integers from 1 to a given maximum value ( m ) using an efficient sieve-like method. Function Signature: `def euler_totient_sieve(m: int) -> List[int]:` Input: - An integer ( m ) (1 ≤ ( m ) ≤ ( 10^6 )) representing the maximum value to compute the totient function for. Output: - A list of integers where the ( i )-th element is ( phi(i) ). Constraints: - Ensure the function runs efficiently within the given constraints. - Use a sieve-like approach to precompute the totient values. Example: ```python assert euler_totient_sieve(10) == [0, 1, 1, 2, 2, 4, 2, 6, 4, 6, 4] ``` (The output contains the totient values from ( 0 ) through ( 10 ). Index 0 is a placeholder since ( phi(0) ) is undefined.) Explanation: - The sieve approach will avoid repetitive computation by iterating over multiples. - You may initialize an array with totient values set to their respective indices, then iteratively update them to reflect the number of coprimes for each number.","solution":"def euler_totient_sieve(m: int) -> list: Computes the Euler\'s Totient function for each number from 1 to m using a sieve approach. Args: m (int): the maximum value to compute the totient function for. Returns: List[int]: a list where the i-th element is φ(i). phi = list(range(m + 1)) for i in range(2, m + 1): if phi[i] == i: # i is a prime number for j in range(i, m + 1, i): phi[j] *= (i - 1) phi[j] //= i return phi"},{"question":"# Set Covering Problem: Efficient Approximation Context Imagine you are working for a tech company that needs to ensure its data coverage is both complete and cost-effective. Given a universe of required data points and multiple data sources each with associated costs, your task is to develop an efficient algorithm to select a minimum-cost combination of sources that covers all required data points. Task Implement a function `efficient_set_cover(universe, subsets, costs)` that uses a heuristic or approximation method to select a subcollection of subsets that covers all elements in the universe `U` at minimal cost. The function should return the selected subsets and the total cost. Specifications - Input: - `universe`: A set of unique elements. - `subsets`: A dictionary where keys are subset identifiers and values are sets of elements from the universe. - `costs`: A dictionary where keys are subset identifiers and values are the costs associated with each subset. - Output: - A list of selected subset identifiers that cover all elements in the universe. - The total cost of the selected subsets. Constraints - Assume the universe contains at least one element. - Subsets provided will contain only elements from the universe. - All subset identifiers are unique. - At least one valid solution exists. Performance - Aim to implement the solution with a time complexity better than the brute-force method (exponential time). Example ```python universe = {1, 2, 3, 4, 5} subsets = {\'S1\': {4, 1, 3}, \'S2\': {2, 5}, \'S3\': {1, 4, 3, 2}} costs = {\'S1\': 5, \'S2\': 10, \'S3\': 3} cover, total_cost = efficient_set_cover(universe, subsets, costs) print(cover) # Example Output: [\'S3\', \'S2\'] print(total_cost) # Example Output: 13 ``` Implement the function `efficient_set_cover`.","solution":"def efficient_set_cover(universe, subsets, costs): Implements a greedy algorithm to approximate the minimum-cost set covering problem. Parameters: universe (set): The set of all required data points. subsets (dict): A dictionary where keys are subset identifiers and values are sets of elements from the universe. costs (dict): A dictionary where keys are subset identifiers and values are the costs associated with each subset. Returns: tuple: A list of selected subset identifiers that cover all elements in the universe, and the total cost of the selected subsets. selected_subsets = [] total_cost = 0 uncovered_elements = universe.copy() # While there are still uncovered elements while uncovered_elements: # Choose the subset that covers the most uncovered elements per unit cost best_subset = None best_subset_coverage = 0 best_subset_cost_efficiency = float(\'inf\') for subset_id, subset in subsets.items(): covered = uncovered_elements & subset if covered: cost_efficiency = costs[subset_id] / len(covered) if cost_efficiency < best_subset_cost_efficiency: best_subset = subset_id best_subset_coverage = len(covered) best_subset_cost_efficiency = cost_efficiency # Take the best subset selected_subsets.append(best_subset) total_cost += costs[best_subset] uncovered_elements -= subsets[best_subset] return selected_subsets, total_cost"},{"question":"You are given two arrays, `preorder` and `postorder`, of integers representing the preorder and postorder traversal of a full binary tree respectively. Your task is to reconstruct the binary tree and return its inorder traversal. # Function Signature ```python def inorder_from_pre_post(preorder: List[int], postorder: List[int]) -> List[int]: pass ``` # Input - `preorder`: A list of integers representing the preorder traversal of a full binary tree. - `postorder`: A list of integers representing the postorder traversal of the same full binary tree. # Output - A list of integers representing the inorder traversal of the constructed binary tree. # Constraints - The number of elements in `preorder` and `postorder` will be the same. - Arrays will only contain unique elements. - The binary tree represented by the traversals will always be a full binary tree. # Example **Example 1:** ```plaintext preorder = [1, 2, 4, 5, 3, 6, 7] postorder = [4, 5, 2, 6, 7, 3, 1] Output: [4, 2, 5, 1, 6, 3, 7] ``` **Example 2:** ```plaintext preorder = [2, 1, 3] postorder = [1, 3, 2] Output: [1, 2, 3] ``` # Notes 1. You need to ensure that your code handles large arrays efficiently. 2. Consider edge cases such as arrays of length 1. 3. You should not assume any prior state or initialization before calling the function.","solution":"from typing import List class TreeNode: def __init__(self, value=0): self.value = value self.left = None self.right = None def build_tree_from_pre_post(preorder: List[int], postorder: List[int]) -> TreeNode: if not preorder or not postorder: return None root = TreeNode(preorder[0]) if len(preorder) == 1: return root left_subtree_root_val = preorder[1] left_subtree_size = postorder.index(left_subtree_root_val) + 1 root.left = build_tree_from_pre_post(preorder[1:1 + left_subtree_size], postorder[:left_subtree_size]) root.right = build_tree_from_pre_post(preorder[1 + left_subtree_size:], postorder[left_subtree_size:-1]) return root def inorder_traversal(root: TreeNode) -> List[int]: if root is None: return [] return inorder_traversal(root.left) + [root.value] + inorder_traversal(root.right) def inorder_from_pre_post(preorder: List[int], postorder: List[int]) -> List[int]: root = build_tree_from_pre_post(preorder, postorder) return inorder_traversal(root)"},{"question":"# Question: Binary Tree to Doubly Linked List Objective Given the root node of a binary tree, transform the tree into a doubly linked list in-place where the doubly linked list maintains the in-order traversal of the tree. Design your algorithm to achieve this transformation with linear time complexity. Function Signature ```python from typing import Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def bin_tree_to_list(root: Optional[TreeNode]) -> Optional[TreeNode]: Convert a binary tree to doubly linked list in-place. :param root: Root node of the binary tree :return: Head node of the converted doubly linked list # Your implementation here ``` Example ```python # Example TreeNode creation root = TreeNode(10) root.left = TreeNode(6) root.right = TreeNode(14) root.left.left = TreeNode(4) root.left.right = TreeNode(8) root.right.left = TreeNode(12) root.right.right = TreeNode(16) # Convert binary tree to doubly linked list list_head = bin_tree_to_list(root) # Traverse and print the doubly linked list current = list_head while current: print(current.val, end=\\" \\") current = current.right # Expected Output: 4 6 8 10 12 14 16 ``` Constraints 1. The input tree node values are integers. 2. The tree will have at most (10^4) nodes. 3. The tree is properly formed (no cyclic references). Performance Requirements - Implement the conversion in O(n) time complexity. - The tree transformation should be in-place without using additional data structures.","solution":"from typing import Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def bin_tree_to_list(root: Optional[TreeNode]) -> Optional[TreeNode]: Convert a binary tree to a doubly linked list in-place. :param root: Root node of the binary tree :return: Head node of the converted doubly linked list if not root: return None # Helper function to perform in-order traversal def in_order_traversal(node): nonlocal last, head if not node: return # Traverse the left subtree in_order_traversal(node.left) # Processing the current node if last: last.right = node node.left = last else: head = node last = node # Traverse the right subtree in_order_traversal(node.right) last, head = None, None in_order_traversal(root) return head"},{"question":"# Merge k Sorted Linked Lists Background You are working on a data integration project where you need to merge several sorted linked lists into one single sorted linked list. Each linked list contains sorted integer values, and you will get multiple such lists as input. Your task is to implement the merging mechanism using an efficient algorithm. Objective Given an array of (k) sorted singly-linked lists, merge all the lists into one sorted singly-linked list and return its head. Function Signature ```python class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def merge_k_lists(lists: List[ListNode]) -> ListNode: pass ``` Input - The input is a list of (k) singly-linked lists, each represented by its head node. - (1 leq k leq 10^4) - Each linked list contains integers sorted in non-decreasing order. - The total number of nodes across all linked lists is (n), with (0 leq n leq 5 times 10^4). Output - Return the head of the merged singly-linked list, sorted in non-decreasing order. Constraints - Ensure that the algorithm has a time complexity of (O(n log k)) where (n) is the total number of elements in all lists and (k) is the number of lists. - The space complexity should be (O(k)) due to the utilization of a heap or priority queue. Example Let\'s consider the following example: **Input:** ```python list1 = ListNode(1, ListNode(4, ListNode(5))) list2 = ListNode(1, ListNode(3, ListNode(4))) list3 = ListNode(2, ListNode(6)) lists = [list1, list2, list3] ``` **Output:** A singly-linked list that represents `[1, 1, 2, 3, 4, 4, 5, 6]`. **Explanation:** The merged linked list contains all the elements from (list1), (list2), and (list3) in sorted order. Notes - Make sure to handle edge cases, such as when the input list is empty or when one or more of the input linked lists is empty. - Avoid unnecessary recomputation or storage overloads to optimize performance.","solution":"import heapq from typing import List class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def merge_k_lists(lists: List[ListNode]) -> ListNode: Merges k sorted linked lists into one sorted linked list and returns the head of the merged list. # Custom comparator for the heap to compare ListNode instances ListNode.__lt__ = lambda self, other: self.val < other.val # Initialize a heap and a dummy node to build the final sorted list heap = [] for l in lists: if l: heapq.heappush(heap, l) dummy = ListNode() current = dummy # Extract the smallest elements from the heap and add to the result list while heap: smallest = heapq.heappop(heap) current.next = smallest current = current.next if smallest.next: heapq.heappush(heap, smallest.next) return dummy.next"},{"question":"You are given an array containing integers and strings. The task is to write a function `remove_duplicates` that processes the array and returns a new array with all duplicates removed while preserving their first occurrence order. # Function Signature ```python def remove_duplicates(array: List[Union[int, str]]) -> List[Union[int, str]]: ``` # Input * An array of integers and strings, e.g., `[1, 2, \\"a\\", 1, \\"b\\", \\"a\\"]` # Output * A new array with duplicates removed, e.g., `[1, 2, \\"a\\", \\"b\\"]` # Constraints * The input array can contain up to 10^6 elements. * Each element in the array can either be an integer or a string. * Entries are case-sensitive for strings. # Examples 1. Given input: `[1, 1 ,1 ,2 ,2 ,3 ,4 ,\\"hey\\", \\"hey\\", \\"hello\\", True, True]` Expected output: `[1, 2, 3, 4, \'hey\', \'hello\']` 2. Given input: `[\\"a\\", \\"A\\", \\"a\\", \\"B\\", \\"C\\", \\"b\\", \\"B\\" ]` Expected output: `[\\"a\\", \\"A\\", \\"B\\", \\"C\\", \\"b\\"]` # Constraints * The solution should efficiently handle input arrays up to a size of 10^6 elements. # Hint Consider using appropriate data structures to optimize the time complexity of the duplicate check during implementation.","solution":"from typing import List, Union def remove_duplicates(array: List[Union[int, str]]) -> List[Union[int, str]]: This function removes duplicates from the input array while preserving the order of first occurrences. seen = set() result = [] for item in array: if item not in seen: seen.add(item) result.append(item) return result"},{"question":"# Shell Sort Implementation Objective You are given an array of integers that need to be sorted in ascending order. Implement the Shell Sort algorithm. Function Signature ```python def shell_sort(arr: List[int]) -> List[int]: pass ``` Input * `arr` - List of integers where (1 leq text{len(arr)} leq 10^5) and (-10^9 leq text{arr[i]} leq 10^9). Output * The array sorted in ascending order. Constraints * Ensure a time complexity not worse than (O(n^2)). Performance Requirements * Must handle arrays of length up to 100,000 efficiently. Example ```python assert shell_sort([8, 4, 1, 3, 9, 6, 2, 7, 5]) == [1, 2, 3, 4, 5, 6, 7, 8, 9] assert shell_sort([100, -20, 15, 0, 60, 35]) == [-20, 0, 15, 35, 60, 100] assert shell_sort([2, 3, 2, 3, 1]) == [1, 2, 2, 3, 3] assert shell_sort([]) == [] assert shell_sort([10]) == [10] ``` Scenario Consider that we have a list of integers representing the scores of players in a game. We want to sort these scores to determine their ranking from the lowest to the highest. Implementing Shell Sort will allow us to effectively achieve this goal.","solution":"from typing import List def shell_sort(arr: List[int]) -> List[int]: Sorts an array of integers using the Shell Sort algorithm. n = len(arr) gap = n // 2 while gap > 0: for i in range(gap, n): temp = arr[i] j = i while j >= gap and arr[j - gap] > temp: arr[j] = arr[j - gap] j -= gap arr[j] = temp gap //= 2 return arr"},{"question":"You are given a linked list, and your task is to determine whether the list is sorted in increasing order. The linked list implementation and a node are defined as follows: ```python class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next ``` Write a function `is_sorted(head)` that checks if the linked list is sorted. An empty list is considered sorted. If the list is sorted in increasing order, return `True`. Otherwise, return `False`. # Input * `head`: The head node of the linked list (e.g., `ListNode` object) # Output * Return `True` if the list is sorted in increasing order, otherwise, return `False`. # Constraints 1. The linked list can have zero or more nodes. 2. Node values are integers. 3. The function should run in O(n) time and use O(1) space. # Example ```python # An empty list head = None print(is_sorted(head)) # True # A sorted list head = ListNode(1, ListNode(2, ListNode(3, ListNode(4)))) print(is_sorted(head)) # True # A non-sorted list head = ListNode(1, ListNode(2, ListNode(-1, ListNode(3)))) print(is_sorted(head)) # False ```","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def is_sorted(head): Checks if the linked list is sorted in increasing order. if not head: return True current = head while current.next: if current.val > current.next.val: return False current = current.next return True"},{"question":"Background Scenario You are part of a team developing a high-frequency trading application where actions must be taken on financial markets in real-time. Given a series of trades occurring in real-time, it\'s crucial to maintain a sorted list of trade values to ensure the accuracy of trend analysis and decision-making processes. Description Implement an optimized version of Bucket Sort in Python that deals with floating-point numbers in the range `[0, 1)`. You are to distribute the numbers into buckets and sort the contents of each bucket using the Insertion Sort algorithm. Function Signature ```python def optimized_bucket_sort(arr: list[float]) -> list[float]: ``` Input - `arr`: A list of floating-point numbers, where each number is in the range `[0, 1)`. Output - A new list of floating-point numbers sorted in increasing order. Constraints 1. The length of `arr` will not exceed `10^6`. 2. Elements in `arr` will be real numbers in the range `[0, 1)`. Example ```python assert optimized_bucket_sort([0.23, 0.45, 0.12, 0.89, 0.25]) == [0.12, 0.23, 0.25, 0.45, 0.89] assert optimized_bucket_sort([0.5, 0.25, 0.75, 0.1, 0.9, 0.60]) == [0.1, 0.25, 0.5, 0.6, 0.75, 0.9] ``` Notes 1. Ensure you handle edge cases such as an empty list or a list with all identical elements. 2. Optimize for performance and ensure the solution runs efficiently for large input sizes. 3. Consider the trade-offs and justify the choices of bucket size and the inner sorting algorithm.","solution":"def insertion_sort(arr): Perform an insertion sort on the list `arr`. for i in range(1, len(arr)): key = arr[i] j = i - 1 while j >= 0 and key < arr[j]: arr[j + 1] = arr[j] j -= 1 arr[j + 1] = key return arr def optimized_bucket_sort(arr): Sorts a list of floating-point numbers in the range [0, 1) using the Bucket Sort algorithm. if len(arr) == 0: return arr # Create buckets bucket_count = len(arr) buckets = [[] for _ in range(bucket_count)] # Distribute input array values into buckets for val in arr: index = int(val * bucket_count) buckets[index].append(val) # Sort individual buckets using insertion sort for i in range(bucket_count): buckets[i] = insertion_sort(buckets[i]) # Concatenate all buckets into a single list sorted_arr = [] for bucket in buckets: sorted_arr.extend(bucket) return sorted_arr"},{"question":"# Coding Task: Implement `resize` Method for a Separate Chaining Hash Table Background You have a partially implemented separate chaining hash table using linked lists to handle collisions. Your task is to extend this implementation by adding a resizing functionality. Objective Implement a method `resize` that doubles the size of the hash table and rehashes all existing elements to maintain the efficiency of the hash table operations. Requirements 1. **Function Signature**: Implement the `resize` method within the `SeparateChainingHashTable` class. 2. **Impact on Existing Methods**: Ensure that all other methods (`put`, `get`, `del_`, `__len__`, etc.) remain functional and correctly leverage the newly resized table. 3. **Performance Consideration**: The resize operation should efficiently relocate all existing elements to the appropriate buckets of the new table. Constraints * Rehash the elements proportionally to the new table size. * Maintain the correct count of elements (`self._len`). # Example ```python table = SeparateChainingHashTable(size=3) table.put(\\"one\\", 1) table.put(\\"two\\", 2) print(len(table)) # Expected Output: 2 table.resize() # Resize operation table.put(\\"three\\", 3) print(table.get(\\"one\\")) # Expected Output: 1 print(table.get(\\"two\\")) # Expected Output: 2 print(table.get(\\"three\\")) # Expected Output: 3 print(len(table)) # Expected Output: 3 ``` Implementation Steps 1. Create a new table with double the size of the original. 2. Rehash all existing elements. 3. Update internal references to point to the new table. Full Implementation Example with Resize Complete the `resize` method in the following class: ```python import unittest class Node(object): ... # (assume provided implementation) class SeparateChainingHashTable(object): ... # (assume provided implementation without resize function) def resize(self): # Implement the resize method here pass # (unittest code if necessary) ```","solution":"class Node: def __init__(self, key, val): self.key = key self.val = val self.next = None class SeparateChainingHashTable: def __init__(self, size=3): self.size = size self.table = [None] * size self._len = 0 def _hash(self, key): return hash(key) % self.size def put(self, key, value): index = self._hash(key) node = self.table[index] if node is None: self.table[index] = Node(key, value) self._len += 1 return while node: if node.key == key: node.val = value return if node.next is None: break node = node.next node.next = Node(key, value) self._len += 1 def get(self, key): index = self._hash(key) node = self.table[index] while node: if node.key == key: return node.val node = node.next return None def del_(self, key): index = self._hash(key) node = self.table[index] prev = None while node: if node.key == key: if prev: prev.next = node.next else: self.table[index] = node.next self._len -= 1 return True prev, node = node, node.next return False def __len__(self): return self._len def resize(self): new_size = self.size * 2 new_table = [None] * new_size old_table = self.table self.table = new_table self.size = new_size self._len = 0 # Will be updated in self.put for node in old_table: while node: self.put(node.key, node.val) node = node.next"},{"question":"# Question: You are required to implement a function that performs regular expression matching with support for the characters \'.\' and \'*\'. The matching should cover the entire input string and not just part of it. Write a function `is_match` with the following signature: ```python def is_match(s: str, p: str) -> bool: # your code here ``` # Input: * `s` (string): the input string that needs to be matched. * `p` (string): the pattern containing the characters a-z, \'.\' and \'*\'. # Output: * Return `True` if the string `s` matches the pattern `p` entirely, otherwise return `False`. # Constraints: * Each input string is guaranteed to be non-null. * The pattern `p` will not contain empty strings with the exception of an empty pattern matching an empty string. # Example: ```python assert is_match(\\"aa\\", \\"a\\") == False assert is_match(\\"aa\\", \\"aa\\") == True assert is_match(\\"aaa\\", \\"aa\\") == False assert is_match(\\"aa\\", \\"a*\\") == True assert is_match(\\"aa\\", \\".*\\") == True assert is_match(\\"ab\\", \\".*\\") == True assert is_match(\\"aab\\", \\"c*a*b\\") == True ``` # Additional Requirements: * You should focus on the efficiency of your code in terms of time and space complexity. * Special attention should be given to edge cases like empty strings and patterns, consecutive \'*\' characters in patterns, and patterns that are longer than the input string.","solution":"def is_match(s: str, p: str) -> bool: # Define a recursive function with memoization memo = {} def dp(i, j): if (i, j) not in memo: if j == len(p): ans = i == len(s) else: first_match = i < len(s) and p[j] in {s[i], \'.\'} if j + 1 < len(p) and p[j + 1] == \'*\': ans = (dp(i, j + 2) or first_match and dp(i + 1, j)) else: ans = first_match and dp(i + 1, j + 1) memo[i, j] = ans return memo[i, j] return dp(0, 0)"},{"question":"# Question: Finding the Single Non-Repeating Number You are given an array of integers where every element appears exactly twice, except for one element which appears only once. Implement a function `single_number(nums)` that finds and returns this single element. Function Signature ```python def single_number(nums: List[int]) -> int: ``` # Input * `nums` (List[int]): A list of integers where every element appears twice except for one element which appears exactly once. # Output * Returns the integer that appears only once in the list. # Constraints * The time complexity must be linear, O(n). * The space complexity must be constant, O(1). # Examples 1. Input: `nums = [2, 2, 1]` Output: `1` 2. Input: `nums = [4, 1, 2, 1, 2]` Output: `4` 3. Input: `nums = [1]` Output: `1` # Notes * You must implement the function without using extra memory beyond a fixed amount of variables. * The list will always have a valid configuration as per the constraints (one unique element, others appearing exactly twice).","solution":"from typing import List def single_number(nums: List[int]) -> int: Finds the single number in a list where all other numbers appear exactly twice. Args: nums (List[int]): The list of integers where one integer appears once and all others appear twice. Returns: int: The single integer that appears only once in the list. # Initialize result with 0 since XOR with 0 is the number itself. result = 0 for num in nums: # XOR the result with the current number result ^= num return result"},{"question":"As a software engineer working on a database system, you are tasked with implementing a B-Tree data structure. The B-Tree helps in efficiently managing large data sets that need frequent read/write operations while maintaining sorted order. Task You need to implement a function to insert keys into a B-Tree. Given a series of keys, the function should insert them into the B-Tree one by one and then traverse and print the B-Tree in-order (ascending order of keys). Function Signature ```python def insert_and_traverse_btree(t_val: int, keys: List[int]) -> List[int]: pass ``` Input - `t_val`: An integer (t ≥ 2) representing the degree of the B-Tree. - `keys`: A list of integers representing keys to be inserted into the B-Tree. Output - A list of integers representing the keys of the B-Tree in in-order traversal after all insertions. Constraints - The `t_val` (degree of the B-Tree) is at least 2. - The `keys` list will contain between 1 and 1000 integers. Example ```python assert insert_and_traverse_btree(2, [10, 20, 5, 6, 12, 30, 7, 17]) == [5, 6, 7, 10, 12, 17, 20, 30] ``` This example demonstrates the insertion of `8` keys into a B-Tree of degree `2` and returning the sorted keys after all insertions. Notes - Ensure your solution handles edge cases such as minimum and maximum node capacity correctly. - Optimize your solution for efficiency considering time complexity.","solution":"class BTreeNode: def __init__(self, t, leaf=False): self.t = t # Minimum degree (defines the range for number of keys) self.leaf = leaf # True if leaf node, false otherwise self.keys = [] # Array of keys self.children = [] # Array of children BTreeNode, length is len(keys)+1 class BTree: def __init__(self, t): self.t = t self.root = BTreeNode(t, True) def insert(self, k): root = self.root if len(root.keys) == 2 * self.t - 1: temp = BTreeNode(self.t) self.root = temp temp.children.append(root) self.split_child(temp, 0) self.insert_non_full(temp, k) else: self.insert_non_full(root, k) def insert_non_full(self, node, k): i = len(node.keys) - 1 if node.leaf: node.keys.append(None) while i >= 0 and k < node.keys[i]: node.keys[i + 1] = node.keys[i] i -= 1 node.keys[i + 1] = k else: while i >= 0 and k < node.keys[i]: i -= 1 i += 1 if len(node.children[i].keys) == 2 * self.t - 1: self.split_child(node, i) if k > node.keys[i]: i += 1 self.insert_non_full(node.children[i], k) def split_child(self, parent, i): t = self.t y = parent.children[i] z = BTreeNode(t, y.leaf) parent.children.insert(i + 1, z) parent.keys.insert(i, y.keys[t - 1]) z.keys = y.keys[t:(2 * t - 1)] y.keys = y.keys[0:(t - 1)] if not y.leaf: z.children = y.children[t:(2 * t)] y.children = y.children[0:t] def in_order_traverse(self, node, result): if node is not None: for i in range(len(node.keys)): if not node.leaf: self.in_order_traverse(node.children[i], result) result.append(node.keys[i]) if not node.leaf: self.in_order_traverse(node.children[len(node.keys)], result) def insert_and_traverse_btree(t_val, keys): btree = BTree(t_val) for key in keys: btree.insert(key) result = [] btree.in_order_traverse(btree.root, result) return result"},{"question":"# Scenario You are working for a tech company specialized in managing tree data structures. One of your current projects involves assessing the structure of various binary search trees used in data storage systems. Your task is to write a function that will evaluate the number of empty branches present in a given binary search tree. You need to account for all absent branches as empty branches. # Problem Statement Write a function `num_empty(root)` which takes the root of a binary search tree and returns the total number of empty branches in that tree. An empty branch is defined as a missing (null) child of a node. For instance, a leaf node has two empty branches, and if the tree itself is empty (root is None), it has one empty branch. # Expected Input and Output * **Input**: - `root`: The root node of the binary search tree. * **Output**: - An integer representing the total number of empty branches in the tree. # Constraints * You may assume that tree nodes have an integer value and up to two children (left and right). * The binary search tree is immutable and will not change during your function execution. # Example ```plaintext Consider the following binary search tree structure: 9 / 6 12 / / 3 8 10 15 / 7 18 The number of empty branches in this tree is 10. ``` # Function Signature ```python def num_empty(root: Optional[Node]) -> int: # Your implementation goes here ``` # Additional Information * You can use the following `Node` class definition: ```python class Node: def __init__(self, key: int): self.left = None self.right = None self.val = key ``` * The BST class and associated methods for creating and manipulating trees might be provided but are not within the scope of this question. You will implement and test your function with appropriate test cases.","solution":"from typing import Optional class Node: def __init__(self, key: int): self.left = None self.right = None self.val = key def num_empty(root: Optional[Node]) -> int: if root is None: return 1 # The entire tree is empty, it contains one empty branch count = 0 if root.left is None: count += 1 else: count += num_empty(root.left) if root.right is None: count += 1 else: count += num_empty(root.right) return count"},{"question":"# Scenario You are implementing a system for extracting logs from a file system that is represented using a binary tree structure. Each node in the binary tree represents a file or folder, and the postorder traversal is used to process each node (file/folder) after all its children have been processed. # Coding Task Implement a function that performs a postorder traversal of a given binary tree and returns the list of values in the correct postorder sequence. You will implement both an iterative and recursive approach to ensure a comprehensive understanding of the data structure and algorithm. # Function Signature For the iterative approach: ```python def postorder_iterative(root: Optional[Node]) -> List[int]: ``` For the recursive approach: ```python def postorder_recursive(root: Optional[Node]) -> List[int]: ``` # Input Format - `root` : An instance of `Node` representing the root of the binary tree. This node can be `None` if the tree is empty. # Output Format - A list of integers representing the values of the nodes in postorder traversal sequence. # Constraints - The number of nodes in the tree will be between 0 and 10^4. - Each node value will be an integer between -10^5 and 10^5. - You should handle empty trees gracefully, returning an empty list. # Examples Example 1 ```python root = Node(1, None, Node(2, Node(3))) assert postorder_iterative(root) == [3, 2, 1] assert postorder_recursive(root) == [3, 2, 1] ``` Example 2 ```python root = None assert postorder_iterative(root) == [] assert postorder_recursive(root) == [] ```","solution":"from typing import List, Optional class Node: def __init__(self, val: int, left: Optional[\'Node\'] = None, right: Optional[\'Node\'] = None): self.val = val self.left = left self.right = right def postorder_iterative(root: Optional[Node]) -> List[int]: if not root: return [] stack, result = [root], [] while stack: node = stack.pop() result.append(node.val) if node.left: stack.append(node.left) if node.right: stack.append(node.right) return result[::-1] def postorder_recursive(root: Optional[Node]) -> List[int]: def helper(node: Optional[Node], res: List[int]): if node: helper(node.left, res) helper(node.right, res) res.append(node.val) result = [] helper(root, result) return result"},{"question":"You are tasked with implementing a function that removes a specified range of nodes from a singly linked list. This function should handle edge cases properly and ensure that the linked list remains valid after the operation. # Function Signature ```python def remove_range(head: ListNode, start: int, end: int) -> ListNode: ``` # Input * `head` (ListNode): The head node of the singly linked list. * `start` (int): The starting index (inclusive) from which nodes should be removed. * `end` (int): The ending index (inclusive) up to which nodes should be removed. # Output * The function should return the head of the modified linked list. # Constraints * `0 <= start <= end` * The indices are valid within the current length of the linked list. * The linked list may be empty or may contain only one element. # Example ```python # Suppose ListNode is a class that defines linked list nodes as follows: class ListNode: def __init__(self, value=0, next=None): self.value = value self.next = next # Example linked list: [8, 13, 17, 4, 9, 12, 98, 41, 7, 23, 0, 92] head = ListNode(8) head.next = ListNode(13) ... head = ListNode(92) # Run the remove_range function new_head = remove_range(head, 3, 8) # The new list should be: [8, 13, 17, 23, 0, 92] ``` # Notes * Students should make sure to handle edge cases such as removal from the head of the list (`start` index is 0). * Properly manage list traversal and pointer updates to ensure nodes within the specified range are correctly removed. * Return `None` if after removal the list becomes completely empty.","solution":"class ListNode: def __init__(self, value=0, next=None): self.value = value self.next = next def remove_range(head: ListNode, start: int, end: int) -> ListNode: Removes all nodes in the linked list from index `start` to `end` (inclusive). Returns the head of the modified linked list. if head is None: return None dummy = ListNode(0) dummy.next = head current = dummy # advance to node just before start for i in range(start): if current.next is None: return dummy.next current = current.next # remove nodes from start to end remove_start = current for i in range(start, end + 1): if current.next is None: break current = current.next remove_start.next = current.next return dummy.next"},{"question":"Given an array of integers and optional minimum and maximum limits, implement a function `filter_in_range` that filters elements in the array such that only those within the specified range (inclusive) are returned. The function should handle cases where either the minimum limit or the maximum limit is not provided. If the array is empty, the function should return an empty list. # Function Signature: ```python def filter_in_range(arr: List[int], min_lim: Optional[int]=None, max_lim: Optional[int]=None) -> List[int]: pass ``` # Input: * `arr`: A list of integers `arr` (0 ≤ len(arr) ≤ 10^5) * `min_lim`: Optional integer representing the minimum inclusive limit. * `max_lim`: Optional integer representing the maximum inclusive limit. # Output: * The function should return a list of integers containing elements from `arr` that fall within the range `[min_lim, max_lim]` inclusively. # Constraints: * When `min_lim` is None, it is interpreted as no lower bound. * When `max_lim` is None, it is interpreted as no upper bound. # Example: ```python assert filter_in_range([1, 2, 3, 4, 5], None, 3) == [1, 2, 3] assert filter_in_range([1, 3, 5, 7, 9], 4, None) == [5, 7, 9] assert filter_in_range([1, 2, 3, 4, 5], 2, 4) == [2, 3, 4] assert filter_in_range([], 1, 10) == [] assert filter_in_range([10, 20, 30], None, None) == [10, 20, 30] ``` # Note: The list preserved the order of elements as they appear in the original array. Make sure to handle edge cases such as empty arrays, arrays where no elements meet the criteria, and cases where only one of the limits is provided.","solution":"from typing import List, Optional def filter_in_range(arr: List[int], min_lim: Optional[int]=None, max_lim: Optional[int]=None) -> List[int]: Filters the elements of the array such that only those within the specified range (inclusive) are returned. If min_lim or max_lim is None, it is interpreted as no limit on that bound. if min_lim is None and max_lim is None: return arr result = [] for num in arr: if ((min_lim is None or num >= min_lim) and (max_lim is None or num <= max_lim)): result.append(num) return result"},{"question":"# Question: Sentence Construction from String Segments You are given a string `str_piece` and a list of valid words `dictionaries`. Your task is to write a function `number_of_sentences` that counts how many sentences you can construct from `str_piece` such that all of the words in the sentence are contained in the `dictionaries`. Each word must be used in its entirety, and you cannot partially use any word from the dictionary. Function Signature: ```python def number_of_sentences(str_piece: str, dictionaries: List[str]) -> int: pass ``` Input: - `str_piece` (str): A string containing lowercase alphabets between 1 and 100 characters in length. - `dictionaries` (List[str]): A list of unique words where each word contains lowercase alphabets and the list length is between 1 and 1000. Output: - (int): The number of valid sentences that can be formed using the words in the `dictionaries`. Constraints: - The list `dictionaries` contains words between 1 and 10 characters in length. - Words in `dictionaries` and `str_piece` are composed only of lowercase alphabets. Example: ```python # Example 1 str_piece = \\"appletablet\\" dictionaries = [\\"apple\\", \\"tablet\\", \\"app\\", \\"let\\", \\"able\\", \\"t\\"] # Explanation: Possible sentences are \\"apple tablet\\", \\"app let able t\\", \\"apple table t\\" print(number_of_sentences(str_piece, dictionaries)) # Output: 3 # Example 2 str_piece = \\"thing\\" dictionaries = [\\"thing\\"] # Explanation: Only one possible sentence \\"thing\\" print(number_of_sentences(str_piece, dictionaries)) # Output: 1 ``` Notes: - You may assume all strings in `dictionaries` are unique. - Words can be used in multiple valid sentences in different arrangements. - Aim to optimize the solution for better performance with memoization techniques where possible.","solution":"from typing import List def number_of_sentences(str_piece: str, dictionaries: List[str]) -> int: word_set = set(dictionaries) memo = {} def helper(s): if s in memo: return memo[s] if not s: return 1 count = 0 for i in range(1, len(s) + 1): if s[:i] in word_set: count += helper(s[i:]) memo[s] = count return count return helper(str_piece)"},{"question":"# Task Description Given a string `s` and a list of valid words `wordDict`, write a function `countSentences(s, wordDict)` that returns the number of different sentences you can form by splitting the string `s` into words contained in the dictionary `wordDict`. # Function Signature ```python def countSentences(s: str, wordDict: List[str]) -> int: ``` # Input * `s`: A string (1 <= len(s) <= 1000) consisting of lowercase alphabetic characters. * `wordDict`: A list of valid words (1 <= len(wordDict) <= 1000), each word consisting of lowercase alphabetic characters. # Output * Returns an integer representing the number of different valid sentences that can be formed. # Constraints 1. The string `s` will only contain lowercase English letters. 2. The dictionary `wordDict` will contain only lowercase English words. 3. Each word in the dictionary will be in the range of 1 to 20 characters. # Example ```python assert countSentences(\\"appletablet\\", [\\"apple\\", \\"tablet\\", \\"applet\\", \\"able\\", \\"t\\"]) == 3 assert countSentences(\\"applet\\", [\\"app\\", \\"let\\", \\"apple\\", \\"t\\", \\"applet\\"]) == 3 assert countSentences(\\"thing\\", [\\"thing\\"]) == 1 assert countSentences(\\"abcd\\", [\\"a\\", \\"abc\\", \\"b\\", \\"cd\\"]) == 1 ``` # Notes 1. Avoiding the use of a global variable. 2. Consider edge cases such as an empty dictionary or strings that cannot be split into valid words. 3. Focus on optimizing the function using memoization to avoid redundant calculations.","solution":"def countSentences(s, wordDict): Returns the number of different sentences you can form by splitting the string \'s\' into words contained in \'wordDict\'. wordSet = set(wordDict) memo = {} def dfs(s): if s in memo: return memo[s] if not s: return 1 total_ways = 0 for end in range(1, len(s) + 1): if s[:end] in wordSet: total_ways += dfs(s[end:]) memo[s] = total_ways return total_ways return dfs(s)"},{"question":"Scenario: An e-commerce company wants to optimize its search system for a list of products sorted by price. The task is to identify the starting and ending positions of products priced at a specific target value. This is crucial for rendering products effectively in a sub-range during sales or bulk operations. Problem Statement: Write a function `find_price_range` that takes a sorted list of integers `prices` and an integer `target_price`. The function should return the starting and ending positions of `target_price` in the list. If `target_price` is not found, return `[-1, -1]`. Function Signature: ```python def find_price_range(prices: List[int], target_price: int) -> List[int]: pass ``` Input: * `prices` - A list of integers sorted in ascending order, where 1 ≤ len(prices) ≤ 10^5 and 1 ≤ prices[i] ≤ 10^9. * `target_price` - An integer (1 ≤ target_price ≤ 10^9). Output: * A list of two integers representing the starting and ending indices of `target_price` in the `prices` list. If `target_price` is not found, return `[-1, -1]`. Constraints: * The algorithm should have a time complexity of O(log n). Examples: ``` # Example 1: input: prices = [5,7,7,8,8,8,10], target_price = 8 output: [3, 5] # Example 2: input: prices = [5,7,7,8,8,8,10], target_price = 11 output: [-1, -1] ``` Performance Requirements: * Your solution should optimize both time and space complexity. * Avoid using any auxiliary data structures that increase space complexity beyond O(1).","solution":"from typing import List def find_price_range(prices: List[int], target_price: int) -> List[int]: def binary_search_left(prices, target): left, right = 0, len(prices) while left < right: mid = (left + right) // 2 if prices[mid] < target: left = mid + 1 else: right = mid return left def binary_search_right(prices, target): left, right = 0, len(prices) while left < right: mid = (left + right) // 2 if prices[mid] <= target: left = mid + 1 else: right = mid return left left_index = binary_search_left(prices, target_price) right_index = binary_search_right(prices, target_price) - 1 if left_index <= right_index and left_index < len(prices) and prices[left_index] == target_price and prices[right_index] == target_price: return [left_index, right_index] else: return [-1, -1]"},{"question":"# Task You are given a tree-like dictionary where each key corresponds to a list of sub-elements which could be strings or integers. Your goal is to write a function `print_tree` that prints the tree in a specific format as described. # Function Signature ```python def print_tree(tree: dict) -> None: pass ``` # Input * A dictionary `tree` where each key is a string, and the associated value is a list of mixed types (strings and integers). # Output * Print the tree structure in the specified format. # Example Given the tree: ```python { \'a\': [\'Adam\', \'Book\', 4], \'b\': [\'Bill\', \'Computer\', 5, \'TV\', 6, \'Jill\', \'Sports\', 1], \'c\': [\'Bill\', \'Sports\', 3], \'d\': [\'Adam\', \'Computer\', 3, \'Quin\', \'Computer\', 3], \'e\': [\'Quin\', \'Book\', 5, \'TV\', 2], \'f\': [\'Adam\', \'Computer\', 7], } ``` The output should be: ``` a -> Adam -> Book -> 4 b -> Bill -> Computer -> 5 -> TV -> 6 -> Jill -> Sports -> 1 c -> Bill -> Sports -> 3 d -> Adam -> Computer -> 3 -> Quin -> Computer -> 3 e -> Quin -> Book -> 5 -> TV -> 2 f -> Adam -> Computer -> 7 ``` # Constraints * Assume the length of the list for each key will be at least one. * You do not need to handle nested lists (lists within lists). # Instructions 1. Implement the function `print_tree`. 2. Ensure the function handles the traversal and printing in satisfactory performance for typical input sizes. 3. Focus on edge cases such as empty sub-element lists and mixed data type handling within the lists.","solution":"def print_tree(tree: dict) -> None: Prints the tree-like dictionary in a specific format with arrows \'->\' indicating the hierarchical structure. for key, values in tree.items(): print(key, end=\\" -> \\") print(\\" -> \\".join(map(str, values)))"},{"question":"You are given a list of integers and a number `N`. The task is to implement a function that returns a new list with each number allowed to appear at most `N` times, maintaining the original order. If a number appears more than `N` times, only the first `N` occurrences should be retained. # Function Signature ```python def delimited_frequency_filter(arr: List[int], N: int) -> List[int]: pass ``` # Input * `arr`: A List of integers. * `N`: An integer representing the maximum allowed frequency of any element in the list. # Output * A List of integers where each number appears at most `N` times, and the order of numbers is maintained from the original list. # Constraints * 1 ≤ len(arr) ≤ 10^5 * 1 ≤ N ≤ len(arr) * -10^9 ≤ arr[i] ≤ 10^9 # Example Example 1: * Input: `arr = [1, 2, 3, 1, 2, 1, 2, 3]`, `N = 2` * Output: `[1, 2, 3, 1, 2, 3]` Example 2: * Input: `arr = [20, 37, 20, 21]`, `N = 1` * Output: `[20, 37, 21]` Example 3: * Input: `arr = []`, `N = 2` * Output: `[]` # Implementation Notes 1. Use a hashmap or similar data structure to count occurrences efficiently. 2. Ensure to handle edge cases such as empty list and lists with all unique elements gracefully. 3. Given the constraint on list size, make sure the solution is optimized to run within acceptable time limits.","solution":"from typing import List def delimited_frequency_filter(arr: List[int], N: int) -> List[int]: Returns a new List where each number in the input List `arr` appears at most `N` times, maintaining the original order. count = {} result = [] for num in arr: if count.get(num, 0) < N: result.append(num) count[num] = count.get(num, 0) + 1 return result"},{"question":"You are given a graph represented as an adjacency matrix, where the matrix element `graph[i][j]` denotes the weight of the edge between vertex `i` and vertex `j`. If there is no edge, the weight is represented as `0`. Write a Python function `dijkstra(graph, src)` that implements Dijkstra\'s algorithm to find the shortest path from the source vertex `src` to all other vertices in the graph. The function should return a list of distances where the value at index `i` represents the shortest distance from the source vertex to vertex `i`. # Input - `graph`: A 2D list of integers where `graph[i][j]` represents the weight of the edge from vertex `i` to vertex `j`. - `src`: An integer indicating the source vertex. # Output - A list of integers where the value at index `i` represents the shortest distance from the source vertex to vertex `i`. # Constraints - The number of vertices `V` in the graph is between `1` and `1000`. - All weights are non-negative integers. - There are no negative weight edges in the graph. # Example ```python graph = [ [0, 10, 20, 0, 0], [10, 0, 5, 0, 0], [20, 5, 0, 7, 13], [0, 0, 7, 0, 8], [0, 0, 13, 8, 0] ] src = 0 print(dijkstra(graph, src)) # Output should be [0, 10, 15, 22, 28] ``` # Note - Your function should handle any possible edge cases mentioned in the analysis. - You should optimize your implementation to handle up to the maximum constraint efficiently. - Consider using a priority queue to improve performance.","solution":"import heapq def dijkstra(graph, src): Implements Dijkstra\'s algorithm to find the shortest paths from the source vertex to all other vertices. :param graph: 2D list of integers representing the adjacency matrix of the graph. :param src: Int source vertex. :return: List of integers where the value at index i represents the shortest distance from the source vertex to vertex i. V = len(graph) dist = [float(\'inf\')] * V dist[src] = 0 priority_queue = [(0, src)] while priority_queue: current_dist, u = heapq.heappop(priority_queue) if current_dist > dist[u]: continue for v in range(V): if graph[u][v] != 0: distance = current_dist + graph[u][v] if distance < dist[v]: dist[v] = distance heapq.heappush(priority_queue, (distance, v)) return dist"},{"question":"You are provided with the head of a singly linked list. Your task is to write a function that determines if the linked list contains a strictly increasing sequence. A list is considered strictly increasing if every element is strictly greater than the previous element. Function Signature ```python def is_strictly_increasing(head): pass ``` Input - `head`: A reference to the head node of the singly linked list. Each node is an instance of the `ListNode` class, where `ListNode` is defined as follows: ```python class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next ``` - `None` represents an empty list. Output - Return `True` if the list is strictly increasing, `False` otherwise. Example - Example 1: ```python Input: head = ListNode(1, ListNode(2, ListNode(3, ListNode(4, None)))) Output: True ``` - Example 2: ```python Input: head = ListNode(1, ListNode(2, ListNode(2, ListNode(3, None)))) Output: False ``` - Example 3: ```python Input: head = None Output: True ``` Constraints - The number of nodes in the list can be any non-negative integer. - Node values are integers and can be both positive and negative. # Detailed Requirements 1. Ensure correctness by considering all edge cases, such as empty lists and lists with identical values. 2. The solution should have O(n) time complexity where n is the number of nodes in the list. 3. Optimize for clarity in code, ensuring it handles all edge cases gracefully. # Notes - An empty list is considered to be strictly increasing by definition. - A list with a single element is also strictly increasing.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def is_strictly_increasing(head): if not head or not head.next: return True current = head while current.next: if current.val >= current.next.val: return False current = current.next return True"},{"question":"Implement a function that takes two positive integers and returns their sum without using the \'+\' operator. The function should use bitwise operations to compute the result. Function Signature ```python def bitwise_add(x: int, y: int) -> int: pass ``` Input Format * Two positive integers `x` and `y` (1 <= x, y <= 10^9). Output Format * A single integer which is the sum of `x` and `y`. Constraints * Both `x` and `y` are guaranteed to be positive integers. * You may not use any arithmetic operators such as `+`, `-`, `*`, or `/`. Example # Input ```python x = 2 y = 3 ``` # Output ```python 5 ``` Performance Requirements * The implementation should complete within 1 second for the maximum input size.","solution":"def bitwise_add(x: int, y: int) -> int: Returns the sum of x and y using bitwise operations. while y != 0: carry = x & y # carry now contains common set bits of x and y x = x ^ y # sum of bits of x and y where at least one of the bits is not set y = carry << 1 # carry is shifted by one so that adding it to x gives the required sum return x"},{"question":"Add Two Numbers Without Using \'+\' Operator You have been provided with an algorithm that adds two positive integers using bitwise operations. Your task is to implement an enhanced version of this function to ensure it can correctly handle additional edge cases, such as very large integers and adding zero to a number. Function Signature ```python def add_bitwise_operator(x: int, y: int) -> int: # Your code here ``` # Input * `x` (int): A positive integer. * `y` (int): A positive integer. # Output * The sum of the two integers, calculated without using the `+` operator. # Constraints * You may assume that `x` and `y` are non-negative integers. * Focus on handling cases where the result could be a very large integer. * Ensure zero is handled correctly in your solution. # Performance Requirements * Your solution must be efficient and run in O(n) time complexity, where n is the number of bits in the larger of the two numbers. # Example ```python assert add_bitwise_operator(2, 3) == 5 assert add_bitwise_operator(0, 7) == 7 assert add_bitwise_operator(12345, 67890) == 80235 ``` Additional Notes * Do not use the `+` or `-` operator in your implementation. * You may use other arithmetic and bitwise operators as needed. * Pay particular attention to handling very large inputs to ensure your function remains efficient and correct.","solution":"def add_bitwise_operator(x: int, y: int) -> int: Adds two integers using bitwise operations. while y != 0: # carry now contains common set bits of x and y carry = x & y # sum of bits of x and y where at least one is not set x = x ^ y # Carry is shifted by one so that adding it to x gives the required sum y = carry << 1 return x"},{"question":"# Find the Unique Number in an Array of Triplicates Objective You are given an array of integers where every element appears exactly three times, except for one element which appears only once. Implement a function that identifies and returns the element that appears only once. Your solution must have a linear runtime complexity and should not use extra memory beyond a fixed amount. Function Signature ```python def find_unique(nums: List[int]) -> int: pass ``` Input * A list of integers `nums`, where `1 <= len(nums) <= 10^6`. * Each integer in `nums` is a 32-bit signed integer. Output * A single integer which is the unique element in the list. Constraints * Input integers range from `-2^31` to `2^31 - 1`. * Every element in the array appears exactly three times except for one element. Example ```python nums = [2, 2, 3, 2] print(find_unique(nums)) # Output: 3 nums = [0, 1, 0, 1, 0, 1, 99] print(find_unique(nums)) # Output: 99 ``` Performance Requirements * The algorithm must run in O(n) time. * The algorithm must use O(1) extra space. Notes * The function should handle edge cases such as arrays with minimal size. * Review of bit manipulation techniques may assist in achieving the solution.","solution":"from typing import List def find_unique(nums: List[int]) -> int: one, two = 0, 0 for num in nums: two |= one & num one ^= num three = one & two one &= ~three two &= ~three return one"},{"question":"# Scenario You have been hired to develop a transportation network analysis tool. Part of this tool needs to check if there is a direct route between two cities in a network of roads. You are given a list of cities and roads between them, and you need to determine if it is possible to travel from one city to another directly using the road network. # Task Write a function that determines if there is a path between two cities in a directed road network. Implement the function using Depth-First Search (DFS). The function should return `True` if there is a path from the source city to the target city, otherwise return `False`. # Requirements Implement the following function: ```python def is_reachable(vertex_count, edges, source, target): Determine if there is a path from source to target in a directed graph. :param vertex_count: Number of vertices in the graph. :param edges: List of tuples (source, target) representing directed edges in the graph. :param source: The starting vertex. :param target: The target vertex. :return: True if there is a path from source to target, False otherwise. pass ``` # Function Input - `vertex_count`: An integer representing the number of vertices (cities). - `edges`: A list of tuples where each tuple (source, target) represents a directed edge between two vertices. - `source`: An integer representing the starting vertex. - `target`: An integer representing the target vertex. # Function Output - Return a boolean `True` if there is a path from the source to the target vertex, `False` otherwise. # Constraints - 1 ≤ `vertex_count` ≤ 10^3 - 0 ≤ `source`, `target` < `vertex_count` - Edges may contain self-loops and parallel edges. # Example ```python # Example usage: vertex_count = 5 edges = [(0, 1), (1, 2), (2, 3), (3, 4), (1, 3), (4, 2)] source = 0 target = 3 print(is_reachable(vertex_count, edges, source, target)) # Output: True ``` # Note - Ensure your implementation handles all specified edge cases effectively. - The solution should find the path using Depth-First Search (DFS), and it should be optimized to run efficiently within the provided constraints.","solution":"def is_reachable(vertex_count, edges, source, target): Determine if there is a path from source to target in a directed graph. :param vertex_count: Number of vertices in the graph. :param edges: List of tuples (source, target) representing directed edges in the graph. :param source: The starting vertex. :param target: The target vertex. :return: True if there is a path from source to target, False otherwise. from collections import defaultdict def dfs(vertex, visited, adj_list): if vertex == target: return True if vertex in visited: return False visited.add(vertex) for neighbor in adj_list[vertex]: if dfs(neighbor, visited, adj_list): return True return False # Create adjacency list adj_list = defaultdict(list) for u, v in edges: adj_list[u].append(v) # Use DFS to determine if there is a path from source to target visited = set() return dfs(source, visited, adj_list)"},{"question":"# B-Tree Coding Challenge Objective: Implement an advanced operation on the B-Tree data structure to assess understanding of insertion, deletion, and space optimization scenarios. Problem Statement: Given a B-Tree implementation (like the one discussed), extend it by implementing a method to rebalance the tree. Specifically, create a method that invokes balancing of nodes and as a side advantage, compresses the B-Tree nodes, ensuring that they utilize the minimum and maximum keys optimally with considerations to disk operations. Instructions: 1. **Function Definition**: Implement the function `balance_tree` in the BTree class which will ensure that all nodes (except the root) are checked for compliance within the minimum and maximum constraints. The process should compress and redistribute keys and children as necessary to maintain the B-Tree properties effectively. 2. **Input Format**: - The function `balance_tree` should take no inputs directly, and should operate on the B-Tree instance calling it. 3. **Output**: - The function should adjust the nodes in-place, ensuring all nodes adhere to B-Tree\'s constraints. 4. **Constraints**: - Assume that the B-Tree is valid before calling `balance_tree`. - Nodes (other than root) should only contain between t-1 and 2t-1 keys after rebalancing. - Do not use any auxiliary space beyond what is necessary for temporary operations on nodes. Performance Requirements: - The `balance_tree` operation should run in O(n log n). Example Usage: ```python # Create B-Tree object btree = BTree(t_val=2) # Insert some keys to build tree keys_to_insert = [10, 20, 5, 6, 12, 30, 7, 17] for key in keys_to_insert: btree.insert_key(key) # Rebalance the tree btree.balance_tree() ```","solution":"class BTreeNode: def __init__(self, t, leaf=False): self.t = t self.leaf = leaf self.keys = [] self.children = [] class BTree: def __init__(self, t): self.t = t self.root = BTreeNode(t, True) def insert_key(self, k): root = self.root if len(root.keys) == 2 * self.t - 1: new_root = BTreeNode(self.t, False) new_root.children.append(self.root) self.split_child(new_root, 0) self.root = new_root self.insert_non_full(self.root, k) def split_child(self, node, i): t = self.t y = node.children[i] z = BTreeNode(t, y.leaf) node.children.insert(i + 1, z) node.keys.insert(i, y.keys[t - 1]) z.keys = y.keys[t:2*t - 1] y.keys = y.keys[:t - 1] if not y.leaf: z.children = y.children[t:2*t] y.children = y.children[:t] def insert_non_full(self, node, k): i = len(node.keys) - 1 if node.leaf: node.keys.append(None) while i >= 0 and k < node.keys[i]: node.keys[i + 1] = node.keys[i] i -= 1 node.keys[i + 1] = k else: while i >= 0 and k < node.keys[i]: i -= 1 i += 1 if len(node.children[i].keys) == 2 * self.t - 1: self.split_child(node, i) if k > node.keys[i]: i += 1 self.insert_non_full(node.children[i], k) def balance_tree(self): def compress(node): while len(node.keys) < self.t - 1: if node is self.root: if self.root.keys == [] and len(self.root.children) == 1: self.root = self.root.children[0] return for i, key in enumerate(node.keys): if len(node.children[i].keys) > self.t - 1: node.keys.insert(i, node.children[i].keys.pop()) break if len(node.children[i + 1].keys) > self.t - 1: node.keys.insert(i, node.children[i + 1].keys.pop(0)) break else: # If no child has more than t-1 keys, then merge two nodes node.keys.append(node.children[i].keys.pop()) node.children[i].keys.extend(node.children.pop(i + 1).keys) if not node.children[i].leaf: node.children[i].children.extend(node.children.pop(i + 1).children) # Depth-first search to apply compress method on all nodes def dfs(node): if not node.leaf: for child in node.children: dfs(child) compress(node) dfs(self.root)"},{"question":"# Scenario You are tasked with creating a utility library for mathematical computations. One of the functions to include is the factorial, both in its basic form and with a modulus operation to handle large numbers efficiently. The library is required for a variety of applications, including statistical computation, permutations, and combinations. # Task Implement two functions: 1. `factorial_iterative(n, mod=None)`: Calculate the factorial of `n` using an iterative approach. 2. `factorial_recursive(n, mod=None)`: Calculate the factorial of `n` using a recursive approach. Both functions should have the following: - Input: - `n`: a non-negative integer (0 <= n <= 1000). - `mod`: an optional positive integer. If provided, the result should be the factorial modulo `mod`. - Output: - Return the factorial of `n`, or `(n! % mod)` if `mod` is provided. # Constraints - Raise a ValueError for invalid `n` or `mod`. # Example ```python # Example Cases # Case 1: # The factorial of 5 is 120 result = factorial_iterative(5) assert result == 120 # Case 2: # The factorial of 5 with mod 3 is 0 because 120 % 3 == 0 result = factorial_iterative(5, 3) assert result == 0 # Case 3: # The factorial of 0 is 1 result = factorial_recursive(0) assert result == 1 # Case 4: # The factorial of 5 with mod 100 is 20 because 120 % 100 == 20 result = factorial_recursive(5, 100) assert result == 20 ``` # Note Ensure your functions are optimized and handle edge cases properly. Focus on both correctness and efficiency.","solution":"def factorial_iterative(n, mod=None): Calculate the factorial of n iteratively. If mod is provided, return n! % mod. if not isinstance(n, int) or n < 0 or n > 1000: raise ValueError(\\"n must be a non-negative integer within the range 0 to 1000.\\") if mod is not None and (not isinstance(mod, int) or mod <= 0): raise ValueError(\\"mod must be a positive integer.\\") result = 1 for i in range(1, n + 1): result *= i if mod: result %= mod return result def factorial_recursive(n, mod=None): Calculate the factorial of n recursively. If mod is provided, return n! % mod. if not isinstance(n, int) or n < 0 or n > 1000: raise ValueError(\\"n must be a non-negative integer within the range 0 to 1000.\\") if mod is not None and (not isinstance(mod, int) or mod <= 0): raise ValueError(\\"mod must be a positive integer.\\") def factorial_helper(x): if x == 0 or x == 1: return 1 return x * factorial_helper(x - 1) result = factorial_helper(n) if mod: result %= mod return result"},{"question":"# Insertion Sort Implementation using Binary Search **Challenge:** Implement an optimized version of the insertion sort algorithm using a helper function `search_insert` described below. Given an unsorted list of integers, sort the list in ascending order. **Function Signature:** ```python def insertion_sort(array: List[int]) -> List[int]: ``` **Inputs:** * `array` - a list of integers, `1 <= len(array) <= 10^4` and `-10^4 <= array[i] <= 10^4`. **Output:** * Returns a sorted list in ascending order. **Constraints:** * Input contains only integers. * Performance constraints: Efficiently handle lists up to size 10,000. **Helper Function Provided:** ```python def search_insert(array, val): Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order. low = 0 high = len(array) - 1 while low <= high: mid = low + (high - low) // 2 if val > array[mid]: low = mid + 1 else: high = mid - 1 return low ``` # Example: ```python # Input: print(insertion_sort([6, 3, 7, 1, 5])) # Output: [1, 3, 5, 6, 7] ``` # Hint: Use the `search_insert` function for finding the correct insertion index during the sort phase. This will optimize the index search time to O(log n), improving the performance of the overall algorithm from O(n²) to a more efficient variant.","solution":"from typing import List def search_insert(array, val): Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order. low = 0 high = len(array) - 1 while low <= high: mid = low + (high - low) // 2 if val > array[mid]: low = mid + 1 else: high = mid - 1 return low def insertion_sort(array: List[int]) -> List[int]: Sorts a list of integers in ascending order using insertion sort algorithm, optimized with binary search for finding the correct insertion index. for i in range(1, len(array)): key = array[i] j = search_insert(array[:i], key) array = array[:j] + [key] + array[j:i] + array[i+1:] return array"},{"question":"# Context Cryptographic algorithms often require efficient computation of large powers with modulus operations. A common need is to compute (base^exponent % mod) efficiently due to the large size of numbers involved. # Problem Statement Write a function `secure_modular_exponential(base, exponent, mod)` that computes the value of ((base^exponent) % mod) efficiently. The function should handle various edge cases and throw appropriate errors when needed. # Function Signature ```python def secure_modular_exponential(base: int, exponent: int, mod: int) -> int: pass ``` # Expected Input and Output Format **Input**: * `base` (int): The base of the exponentiation. * `exponent` (int): The exponent (must be non-negative). * `mod` (int): The modulus (should be a positive integer). **Output**: * Returns an integer that is the result of the expression ((base^exponent) % mod). # Constraints * (0 leq base leq 10^9) * (0 leq exponent leq 10^9) * (1 leq mod leq 10^9) # Performance Requirements * Solution should run in (O(log n)) time where (n) is the value of `exponent`. # Example Cases **Example 1**: ```python assert secure_modular_exponential(2, 10, 1000) == 24 ``` Explanation: (2^{10} = 1024). (1024 % 1000 = 24). **Example 2**: ```python assert secure_modular_exponential(5, 0, 3) == 1 ``` Explanation: (5^0 = 1). (1 % 3 = 1). # Requirements * Implement the function within the given constraints. * Handle edge cases appropriately. * Raise appropriate errors for invalid input (e.g., negative exponent). Implement the function `secure_modular_exponential`.","solution":"def secure_modular_exponential(base: int, exponent: int, mod: int) -> int: Computes (base^exponent) % mod efficiently using the method of exponentiation by squaring. Handles edge cases and input validations appropriately. if exponent < 0: raise ValueError(\\"Exponent must be non-negative\\") if mod <= 0: raise ValueError(\\"Modulus must be a positive integer\\") result = 1 base = base % mod # In case base is greater than mod while exponent > 0: # If exponent is odd, multiply base with the result if exponent % 2 == 1: result = (result * base) % mod # Now exponent must be even exponent = exponent >> 1 # Divide exponent by 2 base = (base * base) % mod # Square the base return result"},{"question":"# Matrix Multiplication Challenge Problem Description You are required to implement a function that multiplies two given matrices (multiplicand and multiplier) and returns the resulting matrix. The matrices are represented as lists of lists of integers. If the matrices are not compatible for multiplication, the function should raise an exception. Requirements * Implement the function `multiply(multiplicand: list, multiplier: list) -> list` that multiplies the `multiplicand` matrix by the `multiplier` matrix and returns the resultant matrix. * If the matrices are not compatible for multiplication (i.e., the number of columns in the first matrix is not equal to the number of rows in the second matrix), the function should raise an `Exception` with the message \\"Multiplicand matrix not compatible with Multiplier matrix.\\" Input * **multiplicand** (List[List[int]]): A 2D list representing the first matrix with dimensions ( m times n ). * **multiplier** (List[List[int]]): A 2D list representing the second matrix with dimensions ( n times p ). Output * **result** (List[List[int]]): A 2D list representing the resultant matrix with dimensions ( m times p ). Constraints * Each matrix contains integers only. * Each matrix has at least one row and one column. * Each row in the matrices contains the same number of elements. Example ```python # Example 1 multiplicand = [ [1, 2, 3], [4, 5, 6] ] multiplier = [ [7, 8], [9, 10], [11, 12] ] # Expected Output: [[58, 64], [139, 154]] # Example 2 multiplicand = [ [1, 0], [0, 1] ] multiplier = [ [1, 2], [3, 4] ] # Expected Output: [[1, 2], [3, 4]] ``` **Note**: Ensure your implementation correctly handles edge cases and optimizes performance where possible.","solution":"def multiply(multiplicand, multiplier): Multiplies two matrices and returns the resulting matrix. Args: multiplicand (list): The first matrix multiplier (list): The second matrix Returns: list: The resulting matrix after multiplication Raises: Exception: If matrices are not compatible for multiplication # Validate the dimensions of matrices for multiplication compatibility rows_multiplicand = len(multiplicand) cols_multiplicand = len(multiplicand[0]) rows_multiplier = len(multiplier) cols_multiplier = len(multiplier[0]) if cols_multiplicand != rows_multiplier: raise Exception(\\"Multiplicand matrix not compatible with Multiplier matrix.\\") # Initialize the result matrix with zeros result = [[0 for _ in range(cols_multiplier)] for _ in range(rows_multiplicand)] # Perform matrix multiplication for i in range(rows_multiplicand): for j in range(cols_multiplier): for k in range(cols_multiplicand): result[i][j] += multiplicand[i][k] * multiplier[k][j] return result"},{"question":"Given two large sparse vectors represented by lists of floating-point numbers, implement efficient methods to: 1. Convert these sparse vectors into a more space-efficient representation using an index-value list. 2. Calculate the dot product of two such index-value lists. # Function Signature You need to implement the following two functions: ```python def vector_to_index_value_list(vector: List[float]) -> List[Tuple[int, float]]: Convert a given sparse vector into an index-value list. :param vector: A list of floats representing the sparse vector. :return: A list of tuples where each tuple contains an index and a non-zero value from the vector. ``` ```python def dot_product(iv_list1: List[Tuple[int, float]], iv_list2: List[Tuple[int, float]]) -> float: Calculate the dot product of two index-value lists. :param iv_list1: First index-value list. :param iv_list2: Second index-value list. :return: The dot product of the two input index-value lists. ``` # Input Constraints * The vectors will be of length `n` where `1 <= n <= 10^6`. * The number of non-zero elements in each vector will be `k` where `0 <= k <= n`. # Output Format * The `vector_to_index_value_list` function should return a list of tuples. * The `dot_product` function should return a float representing the dot product of the two input index-value lists. # Performance Requirements * The implementations should efficiently handle vectors of length up to `10^6` and should operate within reasonable time limits for the given constraints. # Example ```python # Convert vectors to index-value lists: vector1 = [0.0, 3.0, 0.0, 4.0] vector2 = [0.0, 1.0, 0.0, 2.0] iv_list1 = vector_to_index_value_list(vector1) # [(1, 3.0), (3, 4.0)] iv_list2 = vector_to_index_value_list(vector2) # [(1, 1.0), (3, 2.0)] # Dot product result = dot_product(iv_list1, iv_list2) # Returns 11.0 ``` # Notes * Ensure that your solution handles edge cases such as completely zero vectors and vectors of different lengths. * Avoid unnecessary computations by focusing only on non-zero elements.","solution":"from typing import List, Tuple def vector_to_index_value_list(vector: List[float]) -> List[Tuple[int, float]]: Convert a given sparse vector into an index-value list. :param vector: A list of floats representing the sparse vector. :return: A list of tuples where each tuple contains an index and a non-zero value from the vector. return [(i, value) for i, value in enumerate(vector) if value != 0.0] def dot_product(iv_list1: List[Tuple[int, float]], iv_list2: List[Tuple[int, float]]) -> float: Calculate the dot product of two index-value lists. :param iv_list1: First index-value list. :param iv_list2: Second index-value list. :return: The dot product of the two input index-value lists. index_value_dict2 = {index: value for index, value in iv_list2} return sum(value * index_value_dict2.get(index, 0.0) for index, value in iv_list1)"},{"question":"# Insertion Sort with Binary Search You are required to implement the insertion sort algorithm utilizing the binary search method provided in the `search_insert` function. The goal is to efficiently sort an array of integers by inserting each new element at its correct position within the sorted portion of the array using binary search to find the insertion point. # Function Signature ```python def insertion_sort_with_binary_search(array: List[int]) -> List[int]: pass ``` # Input - `array`: List[int] - A list of integers that need to be sorted. # Output - A new list of integers sorted in non-decreasing order. # Constraints - The input list can contain up to 10^5 integers. - Each integer can be in the range of -10^9 to 10^9. # Example ```python assert insertion_sort_with_binary_search([4, 3, 2, 10, 12, 1, 5, 6]) == [1, 2, 3, 4, 5, 6, 10, 12] assert insertion_sort_with_binary_search([100, 20, 15, 30, 5, 75, 40]) == [5, 15, 20, 30, 40, 75, 100] assert insertion_sort_with_binary_search([]) == [] assert insertion_sort_with_binary_search([1]) == [1] assert insertion_sort_with_binary_search([-1, -3, -2, -10, 0]) == [-10, -3, -2, -1, 0] ``` # Performance Expectations - The algorithm should efficiently handle arrays with up to 10^5 elements. - The time complexity should effectively use the binary search to keep the insertion process efficient. # Instructions 1. Implement the `search_insert` function provided. 2. Use this function to determine the correct insertion point for each element in the input array during the insertion sort process. 3. Insert the element at the found position and shift the other elements accordingly. # Implementation Please write the implementation in Python, ensuring that the code is properly structured and handles edge cases as described.","solution":"from typing import List def search_insert(array: List[int], value: int, start: int, end: int) -> int: Perform binary search to find the index at which the value should be inserted to keep the sorted order. while start < end: mid = (start + end) // 2 if array[mid] < value: start = mid + 1 else: end = mid return start def insertion_sort_with_binary_search(array: List[int]) -> List[int]: Sorts the array using the binary search insertion method. for i in range(1, len(array)): value = array[i] insert_pos = search_insert(array, value, 0, i) array = array[:insert_pos] + [value] + array[insert_pos:i] + array[i+1:] return array"},{"question":"# Question Description You are tasked with implementing a word dictionary that supports two main operations: adding a word and searching for a word with optional wildcard support. Your task is to implement the `WordDictionary` class with the following methods: * `add_word(word: str)` - Adds a word into the data structure. * `search(word: str) -> bool` - Returns whether the word is in the data structure. The word can contain the dot character `.` to represent any one letter. Implement this using a **Trie** to ensure efficient word search operations. You need to handle the following edge cases and ensure optimized performance: * The input string for search may contain multiple dot characters representing unknown characters at any position. * The data structure should be initialized empty. # Constraints * All string inputs consist of lowercase English letters. * Length of word while `add_word` or `search` is called ranges from 1 to 50000. * Total number of `add_word` and `search` operations will not exceed 10^6. # Function Signature ```python class WordDictionary: def __init__(self): # Initialize your data structure here pass def add_word(self, word: str) -> None: # Adds a word into the data structure pass def search(self, word: str) -> bool: # Returns if the word is in the data structure. pass ``` # Example ```python # Example usage word_dictionary = WordDictionary() word_dictionary.add_word(\\"bad\\") word_dictionary.add_word(\\"dad\\") word_dictionary.add_word(\\"mad\\") print(word_dictionary.search(\\"pad\\")) # Output: False print(word_dictionary.search(\\"bad\\")) # Output: True print(word_dictionary.search(\\".ad\\")) # Output: True print(word_dictionary.search(\\"b..\\")) # Output: True ``` # Additional Notes * Ensure your implementation is efficient and optimized for high-volume operations. * Handle edge cases such as empty inputs, repeated words, and multiple wildcard searches.","solution":"class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False class WordDictionary: def __init__(self): self.root = TrieNode() def add_word(self, word: str) -> None: current_node = self.root for char in word: if char not in current_node.children: current_node.children[char] = TrieNode() current_node = current_node.children[char] current_node.is_end_of_word = True def search(self, word: str) -> bool: return self._search_in_node(word, self.root) def _search_in_node(self, word, node): for i, char in enumerate(word): if char == \'.\': for child in node.children: if self._search_in_node(word[i + 1:], node.children[child]): return True return False else: if char not in node.children: return False node = node.children[char] return node.is_end_of_word"},{"question":"Your task is to implement a function that generates all permutations of a provided list of distinct integers. Instead of returning all permutations at once, you need to implement an iterator that yields one permutation at a time. # Function Signature ```python def permute_generator(elements): Generate all permutations of the given list and yield them one at a time. Parameters: elements (List[int]): List of distinct integers to permute. Yields: List[int]: A permutation of the given list. pass ``` # Input - `elements`: A list of distinct integers, e.g., `[1, 2, 3]`. # Output - Yields one permutation at a time. For example, for input `[1, 2, 3]`, the function should yield: - `[1, 2, 3]` - `[1, 3, 2]` - `[2, 1, 3]` - `[2, 3, 1]` - `[3, 1, 2]` - `[3, 2, 1]` # Constraints - Do not use any library functions that directly solve the problem. - The function must handle lists of lengths from 0 to 9 inclusively, but note that the number of permutations grows factorially. # Example Usage ```python for perm in permute_generator([1, 2, 3]): print(perm) ``` Expected output: ``` [1, 2, 3] [1, 3, 2] [2, 1, 3] [2, 3, 1] [3, 1, 2] [3, 2, 1] ``` # Performance Requirements The generator should yield permutations in an orderly manner with minimal delay between successive yields. # Edge Cases 1. An empty list should yield an empty list: `[]`. 2. A single-element list should yield the single-element list: `[1]`. # Additional Information Do not modify the input list directly. Always work with copies of the list when making changes during permutation generation.","solution":"def permute_generator(elements): Generate all permutations of the given list and yield them one at a time. Parameters: elements (List[int]): List of distinct integers to permute. Yields: List[int]: A permutation of the given list. if len(elements) <= 1: yield elements else: for i in range(len(elements)): remaining = elements[:i] + elements[i+1:] for perm in permute_generator(remaining): yield [elements[i]] + perm"},{"question":"# Single Number III Coding Question Objective: You are given an array of integers where exactly two elements appear only once and all other elements appear exactly twice. Your task is to identify and return the two elements that appear only once. Instructions: 1. **Function Signature**: You need to complete the function `single_number3(nums: List[int]) -> List[int]`. 2. **Input**: * A list of integers `nums`, where exactly two elements appear only once, and all other elements appear exactly twice. * The list is guaranteed to have at least two unique elements. 3. **Output**: * A list containing the two unique elements. * The order of the resulting list does not matter (i.e., `[3, 5]` and `[5, 3]` are both correct). Examples ```python assert single_number3([1, 2, 1, 3, 2, 5]) in [[3, 5], [5, 3]] assert single_number3([4, 7, 9, 4, 1, 3, 9, 1]) in [[7, 3], [3, 7]] assert single_number3([0, 0, 1, 2]) in [[1, 2], [2, 1]] ``` Constraints * Time Complexity: O(N), where N is the number of elements in the input list. * Space Complexity: O(1). * Use XOR operations to isolate the unique numbers. Function Definition ```python def single_number3(nums: List[int]) -> List[int]: # Your code here ``` **Hint**: Utilize the XOR operation to efficiently isolate the unique numbers and partition the array for extraction.","solution":"from typing import List def single_number3(nums: List[int]) -> List[int]: # First pass: XOR all numbers to get the XOR of the two unique numbers xor_all = 0 for num in nums: xor_all ^= num # Isolate the rightmost set bit in xor_all rightmost_set_bit = xor_all & -xor_all # Second pass: Divide the numbers into two groups based on the rightmost set bit unique1, unique2 = 0, 0 for num in nums: if num & rightmost_set_bit: unique1 ^= num else: unique2 ^= num return [unique1, unique2]"},{"question":"Given a stream of integers and a fixed window size, your task is to implement a data structure that efficiently computes the moving median of the numbers in the sliding window. The median of a finite list of numbers can be found by arranging the numbers in order and picking the middle one. If there\'s an even number of numbers, the median is the average of the two middle numbers. Implement the `MovingMedian` class with the following methods: 1. **Initializer**: ```python def __init__(self, size: int): ``` Initializes the class with the window size `size`. 2. **Next**: ```python def next(self, val: int) -> float: ``` Processes the next number in the stream, updates the sliding window, and returns the current median. # Constraints: - The window size `size` is a positive integer. - The stream of numbers contains only integers. - The method `next` will be called at least as many times as the size set in the initializer. # Example: ```python # Example usage m = MovingMedian(3) print(m.next(1)) # Output: 1.0 print(m.next(10)) # Output: 5.5 (average of 1 and 10) print(m.next(3)) # Output: 3.0 (median of [1, 3, 10]) print(m.next(5)) # Output: 5.0 (median of [3, 5, 10]) ``` **Key Points to Consider**: - Think about efficient ways to keep track of the elements in the sliding window. - Consider the best data structures to maintain the order and to quickly fetch the median. - You may use additional helper functions if necessary.","solution":"import heapq class MovingMedian: def __init__(self, size: int): self.size = size self.min_heap = [] self.max_heap = [] self.window = [] def next(self, val: int) -> float: if len(self.window) == self.size: outgoing = self.window.pop(0) if outgoing >= self.min_heap[0]: self.min_heap.remove(outgoing) heapq.heapify(self.min_heap) else: self.max_heap.remove(-outgoing) heapq.heapify(self.max_heap) self.window.append(val) if len(self.max_heap) == 0 or val <= -self.max_heap[0]: heapq.heappush(self.max_heap, -val) else: heapq.heappush(self.min_heap, val) if len(self.max_heap) > len(self.min_heap) + 1: heapq.heappush(self.min_heap, -heapq.heappop(self.max_heap)) elif len(self.min_heap) > len(self.max_heap): heapq.heappush(self.max_heap, -heapq.heappop(self.min_heap)) if len(self.max_heap) > len(self.min_heap): return float(-self.max_heap[0]) else: return (-self.max_heap[0] + self.min_heap[0]) / 2.0"},{"question":"You are tasked with implementing a simplified inventory management system for a supermarket using a doubly linked list. Each node in the list will represent an item in the inventory, storing the item\'s name, quantity, and price. The system should allow the following operations: 1. Add a new item to the inventory. 2. Search for an item by name and return its current stock and price. 3. Update the quantity and price of an existing item. 4. Delete an item from the inventory. 5. List all items in the inventory. # Detailed Requirements 1. **Add New Item**: * **Input**: Item name (string), quantity (integer), price (float). * **Output**: None. * **Operation**: Insert the new item at the end of the list. If the item already exists, throw an exception or print a relevant message. 2. **Search Item**: * **Input**: Item name (string) * **Output**: Item’s quantity (integer) and price (float). * **Operation**: Traverse the list to find the item. 3. **Update Item**: * **Input**: Item name (string), new quantity (integer), new price (float). * **Output**: None. * **Operation**: Find the item and update its quantity and price. If the item does not exist, throw an exception or print a relevant message. 4. **Delete Item**: * **Input**: Item name (string). * **Output**: None. * **Operation**: Find the item and remove it from the list. Handle updating pointers correctly to maintain the integrity of the list. 5. **List Items**: * **Input**: None. * **Output**: A list of tuples containing item names, quantities, and prices. * **Operation**: Traverse the list and collect items into a list for display. # Constraints * The item names are unique. * The list should be dynamic, capable of handling at least 1000 items. **Implementation Notes** * Define a `DoublyLinkedListNode` class with attributes for the item name, quantity, price, and pointers to the next and previous nodes. * Define an `InventoryDoublyLinkedList` class with methods for the outlined operations. Write your implementation in Python.","solution":"class DoublyLinkedListNode: def __init__(self, name, quantity, price): self.name = name self.quantity = quantity self.price = price self.next = None self.prev = None class InventoryDoublyLinkedList: def __init__(self): self.head = None self.tail = None def add_item(self, name, quantity, price): if self.search_item(name): raise ValueError(f\\"Item \'{name}\' already exists in the inventory.\\") new_node = DoublyLinkedListNode(name, quantity, price) if self.head is None: self.head = new_node self.tail = new_node else: self.tail.next = new_node new_node.prev = self.tail self.tail = new_node def search_item(self, name): current = self.head while current: if current.name == name: return current current = current.next return None def update_item(self, name, quantity, price): node = self.search_item(name) if not node: raise ValueError(f\\"Item \'{name}\' does not exist in the inventory.\\") node.quantity = quantity node.price = price def delete_item(self, name): node = self.search_item(name) if not node: raise ValueError(f\\"Item \'{name}\' does not exist in the inventory.\\") if node.prev: node.prev.next = node.next if node.next: node.next.prev = node.prev if node == self.head: self.head = node.next if node == self.tail: self.tail = node.prev def list_items(self): items = [] current = self.head while current: items.append((current.name, current.quantity, current.price)) current = current.next return items"},{"question":"# Context: Implementing telephone digit to letter combination generation can be useful for various applications such as predictive text entry, mnemonic creation, or decoding systems. Given a string of digits, each digit maps to a set of characters (like old mobile phone keypads), and we need to generate all possible combinations of these characters. # Task: Write a function `generate_combinations(digits: str) -> List[str]` that takes a string of digits (ranging from \'2\' to \'9\') and returns a list of all possible letter combinations that the number could represent. # Input Format: - A single string `digits` containing digits from \'2\' to \'9\'. - The length of `digits` will be between 0 and 4. # Output Format: - A list of strings representing all possible letter combinations. # Constraints: - If the input is an empty string, the output should be an empty list. # Performance: - The algorithm should be able to handle all constraints within a reasonable time (considering the exponential growth of combinations). # Example: ```python generate_combinations(\\"23\\") ``` Expected Output: ```python [\'ad\', \'ae\', \'af\', \'bd\', \'be\', \'bf\', \'cd\', \'ce\', \'cf\'] ```","solution":"from typing import List def generate_combinations(digits: str) -> List[str]: if not digits: return [] digit_to_char = { \'2\': \'abc\', \'3\': \'def\', \'4\': \'ghi\', \'5\': \'jkl\', \'6\': \'mno\', \'7\': \'pqrs\', \'8\': \'tuv\', \'9\': \'wxyz\' } def backtrack(index: int, path: str): if index == len(digits): combinations.append(path) return for char in digit_to_char[digits[index]]: backtrack(index + 1, path + char) combinations = [] backtrack(0, \\"\\") return combinations"},{"question":"# Linked List Manipulation Challenge Background: You are tasked with managing a doubly linked list and implementing key operations such as addition, deletion, and traversal. Doubly linked lists are essential in implementing various data structures and algorithms efficiently due to their bi-directional traversal capabilities. Task: Implement a doubly linked list with the following operations/functionality: 1. **Initialization**: Create an empty doubly linked list. 2. **Insertion at Head**: Add a new node with a given value at the head of the list. 3. **Insertion at Tail**: Add a new node with a given value at the tail of the list. 4. **Deletion**: Remove the first occurrence of a node containing a specific value. 5. **Traversal and Print**: Traverse the list and print all the node values from head to tail, and vice versa. 6. **Size**: Return the current size of the list. 7. **Check Existence**: Check if a value exists in the list. Input/Output Specifications: - **Insertions**: Methods will take the value (integer) to be inserted as a parameter. - **Deletion**: Method will take the value (integer) to be deleted as a parameter. - **Traversal and Print**: Method will print the list\'s elements from head to tail and from tail to head. - **Size**: Method will return the number of elements in the list. - **Check Existence**: Method will return a boolean indicating whether a given value exists in the list. Constraints: - All values are non-negative integers. - The list will have a maximum of 1000 nodes. - Deletion will handle trying to delete nodes not present in the list gracefully. Example Usage: ```python dll = DoublyLinkedList() dll.insert_at_head(10) dll.insert_at_head(5) dll.insert_at_tail(15) dll.traverse_and_print() # Output: Head to Tail: 5 -> 10 -> 15, Tail to Head: 15 -> 10 -> 5 print(dll.size()) # Output: 3 print(dll.exists(10)) # Output: True dll.delete(10) dll.traverse_and_print() # Output: Head to Tail: 5 -> 15, Tail to Head: 15 -> 5 print(dll.size()) # Output: 2 print(dll.exists(10)) # Output: False ``` Note: Your solution should encompass all the necessary edge cases like attempting to delete from an empty list, inserting into an initially empty list, and deleting the only node in a list.","solution":"class Node: def __init__(self, value): self.value = value self.next = None self.prev = None class DoublyLinkedList: def __init__(self): self.head = None self.tail = None self._size = 0 def insert_at_head(self, value): new_node = Node(value) if self.head is None: self.head = self.tail = new_node else: new_node.next = self.head self.head.prev = new_node self.head = new_node self._size += 1 def insert_at_tail(self, value): new_node = Node(value) if self.tail is None: self.head = self.tail = new_node else: new_node.prev = self.tail self.tail.next = new_node self.tail = new_node self._size += 1 def delete(self, value): current = self.head while current is not None: if current.value == value: if current.prev: current.prev.next = current.next else: self.head = current.next if current.next: current.next.prev = current.prev else: self.tail = current.prev self._size -= 1 return current = current.next def traverse_and_print(self): current = self.head head_to_tail = [] while current is not None: head_to_tail.append(current.value) current = current.next print(\\"Head to Tail:\\", \\" -> \\".join(map(str, head_to_tail))) current = self.tail tail_to_head = [] while current is not None: tail_to_head.append(current.value) current = current.prev print(\\"Tail to Head:\\", \\" -> \\".join(map(str, tail_to_head))) def size(self): return self._size def exists(self, value): current = self.head while current is not None: if current.value == value: return True current = current.next return False"},{"question":"# Question You are tasked with developing a function that limits the values in an array to a specified range. This range is defined by a minimum limit (`min_lim`) and a maximum limit (`max_lim`). Your function should return a new array containing only the elements that fall within the specified range, inclusive. If the minimum or maximum limit is not provided, assume they are unbounded. **Function Signature**: `def range_limiter(arr: List[int], min_lim: Optional[int], max_lim: Optional[int]) -> List[int]` Input * `arr`: A list of integers, the array to filter. It can be empty. * `min_lim`: An optional integer representing the minimum value limit. If `None`, it implies no minimum limit. * `max_lim`: An optional integer representing the maximum value limit. If `None`, it implies no maximum limit. Output * Returns a list of integers containing only the elements from the input array `arr` that fall within the range defined by `min_lim` and `max_lim`. Constraints * The elements of `arr` are all integers. * If both `min_lim` and `max_lim` are `None`, return the entire array. * The function should run in O(n) time complexity and use O(n) additional space where n is the length of the input array. Examples 1. `range_limiter([1, 2, 3, 4, 5], None, 3)` should return `[1, 2, 3]`. 2. `range_limiter([10, 20, 30, 40, 50], 15, 35)` should return `[20, 30]`. 3. `range_limiter([5, 10, 15, 20], 8, None)` should return `[10, 15, 20]`. 4. `range_limiter([], 1, 100)` should return `[]`. 5. `range_limiter([1, 2, 3, 4, 5], None, None)` should return `[1, 2, 3, 4, 5]`. Your task is to implement the `range_limiter` function to pass these examples and account for potential edge cases.","solution":"from typing import List, Optional def range_limiter(arr: List[int], min_lim: Optional[int], max_lim: Optional[int]) -> List[int]: Filters the input list `arr` to include only the elements within the range [min_lim, max_lim]. If min_lim is None, there is no lower bound. If max_lim is None, there is no upper bound. :param arr: List of integers to filter :param min_lim: Optional integer representing the minimum limit (inclusive) :param max_lim: Optional integer representing the maximum limit (inclusive) :return: A new list containing only the elements within the specified range if min_lim is None and max_lim is None: return arr result = [] for num in arr: if (min_lim is None or num >= min_lim) and (max_lim is None or num <= max_lim): result.append(num) return result"},{"question":"# Merge Check Coding Challenge **Objective**: Write a function that determines if a given string `s` can be formed by merging two other strings `part1` and `part2`. The characters in `part1` and `part2` must appear in the same order as in `s`, but can be interleaved. **Function Signature**: ```python def can_merge(s: str, part1: str, part2: str) -> bool: ``` **Input/Output**: - **Input**: - `s` (str): The target string. - `part1` (str): The first part of the string. - `part2` (str): The second part of the string. - **Output**: - `bool`: Return `True` if `s` can be formed by merging `part1` and `part2`, otherwise return `False`. **Constraints**: - All strings consist of lowercase English characters. - The lengths of the strings will not exceed 1000 characters. **Performance Requirements**: - The function should be optimized for time and space complexity, considering the constraints. **Context/Scenario**: Suppose you are developing a text merging tool for a text editor. The tool needs to decide if a final document can be created given two separate pieces of text. The text pieces must retain their original order when combined. Implement the function to check if a given `final_text` can be formed using `text_part1` and `text_part2`. **Examples**: ```python # Example 1 assert can_merge(\\"codewars\\", \\"cdw\\", \\"oears\\") == True # \'codewars\' can be formed by merging \'cdw\' and \'oears\' # Example 2 assert can_merge(\\"abcde\\", \\"ace\\", \\"bd\\") == True # \'abcde\' can be formed by merging \'ace\' and \'bd\' # Example 3 assert can_merge(\\"abc\\", \\"abc\\", \\"\\") == True # \'abc\' can be formed by merging \'abc\' and \'\' # Example 4 assert can_merge(\\"abc\\", \\"ab\\", \\"cd\\") == False # \'abc\' cannot be formed by merging \'ab\' and \'cd\' ``` **Note**: Handle edge cases appropriately and consider optimizing your function with memoization if necessary.","solution":"def can_merge(s: str, part1: str, part2: str) -> bool: m, n = len(part1), len(part2) # First check if the lengths match if len(s) != m + n: return False # Create a 2D DP table dp = [[False] * (n + 1) for _ in range(m + 1)] dp[0][0] = True for i in range(m + 1): for j in range(n + 1): if i > 0 and s[i + j - 1] == part1[i - 1]: dp[i][j] = dp[i][j] or dp[i - 1][j] if j > 0 and s[i + j - 1] == part2[j - 1]: dp[i][j] = dp[i][j] or dp[i][j - 1] return dp[m][n]"},{"question":"You are given two lists: one containing words and the other containing symbols. Your task is to implement a function `highlight_symbols` that will search for each symbol in the words and if found, replace the found symbol in the word by surrounding it with square brackets `[]`. If multiple symbols match a word, you should prioritize the longest symbol. If the word contains no symbols, it should be returned as is. # Function Signature: ```python def highlight_symbols(words: List[str], symbols: List[str]) -> List[str]: ``` # Input: * `words` (List[str]): A list of words consisting of lowercase and uppercase Latin letters. * `symbols` (List[str]): A list of symbols consisting of lowercase and uppercase Latin letters. # Output: * `List[str]`: A list of words where matching symbols are surrounded by brackets. Words without matching symbols remain unchanged. # Example: ```python words = [\'Amazon\', \'Microsoft\', \'Google\'] symbols = [\'i\', \'Am\', \'cro\', \'Na\', \'le\', \'abc\'] highlight_symbols(words, symbols) # Output: [\'[Am]azon\', \'Mi[cro]soft\', \'Goog[le]\'] ``` # Constraints: * All words and symbols are non-empty strings. * The number of words does not exceed 1000. * The number of symbols does not exceed 100. # Specific Requirements: * If a word matches multiple symbols, choose the one with the longest length. * Ensure implementation handles edge cases and avoids performance bottlenecks. # Notes: Ensure the solution handles and processes each word independently and efficiently. You may use data structures like Trie to optimize the symbol matching process.","solution":"from typing import List def highlight_symbols(words: List[str], symbols: List[str]) -> List[str]: This function takes a list of words and a list of symbols, and returns a list of words where each symbol found in the words is surrounded by square brackets []. If a word contains no symbols, it will be returned as is. The function prioritizes longer symbols. # Sort symbols by length in descending order to prioritize longer symbols symbols = sorted(symbols, key=len, reverse=True) def highlight_word(word: str) -> str: for symbol in symbols: index = word.find(symbol) if index != -1: return word[:index] + \'[\' + symbol + \']\' + word[index + len(symbol):] return word return [highlight_word(word) for word in words]"},{"question":"# String Reversal Challenge **Objective:** Your task is to implement a function to reverse a given string using a recursive approach. This will test your understanding of recursion and string manipulation in Python. **Function Signature:** ```python def reverse_string_recursive(s: str) -> str: pass ``` **Input:** - A single string `s` with length (0 leq len(s) leq 10^5). **Output:** - A new string which is the reverse of the input string `s`. **Constraints:** - You must use a recursive approach to solve the problem. - Avoid using any Python built-in functions like `reversed()`, slicing, or libraries that can reverse the string directly. **Performance Requirements:** - Your solution should handle the edge cases and large input sizes efficiently within the given constraints. **Examples:** 1. **Input:** `\\"hello\\"` **Output:** `\\"olleh\\"` 2. **Input:** `\\"\\"` (Empty string) **Output:** `\\"\\"` 3. **Input:** `\\"a\\"` **Output:** `\\"a\\"` 4. **Input:** `\\"abcdef\\"` **Output:** `\\"fedcba\\"` # Explanation: 1. For `\\"hello\\"`, recursively breaking and reversing the halves would yield a reversal: `(\\"he\\", \\"llo\\") -> (\\"h\\", \\"e\\") + (\\"ll\\", \\"o\\") -> \\"o\\" + \\"ll\\" + \\"e\\" + \\"h\\"`. 2. An empty string remains empty after reversal. 3. A single-character string is its own reverse. 4. For `\\"abcdef\\"`, the recursive breakdown and concatenation will yield the reversed string in similar steps as discussed.","solution":"def reverse_string_recursive(s: str) -> str: # Base case: If the string is empty or contains a single character if len(s) <= 1: return s # Recursive case: slice the string and call the function recursively return reverse_string_recursive(s[1:]) + s[0]"},{"question":"# Coding Assessement Question You have been provided with three different methods to solve the Two-Sum Problem on a sorted array of integers. Write a function `enhanced_two_sum` that selects and executes the most efficient method based on the input size. Specifically, use: - Binary Search (`two_sum`) for arrays smaller than 50 elements. - Hash Table (`two_sum1`) for arrays with 50 to 1000 elements. - Two-Pointer (`two_sum2`) for arrays larger than 1000 elements. Your function should take the following inputs: - `numbers`: List[int] - A list of integers sorted in ascending order. - `target`: int - The target sum for two numbers within the list. Your task is to write a Python function `enhanced_two_sum` that implements the selection logic and returns the indices of two numbers such that they add up to `target`. If no such indices are found, return `None`. **Constraints**: 1. The function should return indices as 1-based numbers (i.e., starting from 1). 2. Each input will have exactly one solution. 3. An element cannot be used twice. **Example:** ```python numbers = [2, 7, 11, 15] target = 9 print(enhanced_two_sum(numbers, target)) # Output: [1, 2] numbers = [1, 2, 3, 4, 4, 9, 56, 90] target = 8 print(enhanced_two_sum(numbers, target)) # Output: [4, 5] ``` **Note**: Do not modify the given `two_sum`, `two_sum1`, or `two_sum2` functions. Your task is only to implement `enhanced_two_sum`.","solution":"def two_sum(numbers, target): # Binary Search Method for i in range(len(numbers)): low, high = i + 1, len(numbers) - 1 while low <= high: mid = (low + high) // 2 complement = target - numbers[i] if numbers[mid] == complement: return [i + 1, mid + 1] elif numbers[mid] < complement: low = mid + 1 else: high = mid - 1 return None def two_sum1(numbers, target): # Hash Table Method num_map = {} for i, num in enumerate(numbers): complement = target - num if complement in num_map: return [num_map[complement] + 1, i + 1] num_map[num] = i return None def two_sum2(numbers, target): # Two-Pointer Method left, right = 0, len(numbers) - 1 while left < right: cur_sum = numbers[left] + numbers[right] if cur_sum == target: return [left + 1, right + 1] elif cur_sum < target: left += 1 else: right -= 1 return None def enhanced_two_sum(numbers, target): if len(numbers) < 50: return two_sum(numbers, target) elif len(numbers) <= 1000: return two_sum1(numbers, target) else: return two_sum2(numbers, target)"},{"question":"# Question You are given a binary tree. Implement a function to perform a postorder traversal of this tree and return the values in a list. Function Signature ```python def postorder_traversal(root: Node) -> List[int]: pass ``` Input - `root`: A `Node` object representing the root of the binary tree. - `Node` class attributes: - `val`: Integer value stored in the node. - `left`: A reference to the left child node, or `None`. - `right`: A reference to the right child node, or `None`. Output - List of integers representing the postorder traversal of the binary tree. Constraints - The number of nodes in the tree will be in the range [0, 10^4]. - The value of each node will be unique and will fit in a 32-bit signed integer. Example ```python # Example 1 root = Node(1, None, Node(2, Node(3))) assert postorder_traversal(root) == [3, 2, 1] # Example 2 root = Node(1, Node(2, Node(3), Node(4)), Node(5)) assert postorder_traversal(root) == [3, 4, 2, 5, 1] # Example 3 root = None assert postorder_traversal(root) == [] ```","solution":"from typing import List, Optional class Node: def __init__(self, val: int = 0, left: Optional[\'Node\'] = None, right: Optional[\'Node\'] = None): self.val = val self.left = left self.right = right def postorder_traversal(root: Optional[Node]) -> List[int]: Perform a postorder traversal of a binary tree and return the values in a list. result = [] def traverse(node: Optional[Node]): if not node: return traverse(node.left) traverse(node.right) result.append(node.val) traverse(root) return result"},{"question":"# Context You are working on a text editor application that relies heavily on an undo feature. To implement this feature, you need an efficient stack that can handle frequent push and pop operations. The text editor should be capable of storing a very large number of operations. # Task Implement a stack using a linked list that provides the following methods: `push`, `pop`, `peek`, `is_empty`, and `get_max_element`. The `get_max_element` method should return the maximum element in the stack at any given time. The stack should handle integer values exclusively. # Function Signatures ```python class ListNode: def __init__(self, value): self.value = value self.next = None class MaxStack: def __init__(self): self.main_stack = None self.max_stack = None def push(self, value: int) -> None: pass def pop(self) -> int: pass def peek(self) -> int: pass def is_empty(self) -> bool: pass def get_max_element(self) -> int: pass ``` # Requirements * **Push**: Add an integer value to the stack. * **Pop**: Remove and return the top integer value from the stack. * **Peek**: Return the top integer value without removing it. * **Is_empty**: Return a boolean indicating if the stack is empty. * **Get_max_element**: Return the maximum integer value in the stack. # Constraints * All integer values in the stack will be in the range `-10^5` to `10^5`. * The stack can contain up to `10^5` elements. # Example ```python stack = MaxStack() stack.push(10) stack.push(20) print(stack.peek()) # Output: 20 print(stack.get_max_element()) # Output: 20 stack.pop() print(stack.get_max_element()) # Output: 10 print(stack.is_empty()) # Output: False stack.pop() print(stack.is_empty()) # Output: True ``` # Performance Requirements * Your implementation should have: - O(1) average time complexity for `push`, `pop`, `peek`, `is_empty`, and `get_max_element`.","solution":"class ListNode: def __init__(self, value): self.value = value self.next = None class MaxStack: def __init__(self): self.main_stack = None self.max_stack = None def push(self, value: int) -> None: new_node = ListNode(value) new_node.next = self.main_stack self.main_stack = new_node if self.max_stack is None or value >= self.max_stack.value: new_max_node = ListNode(value) new_max_node.next = self.max_stack self.max_stack = new_max_node def pop(self) -> int: if self.main_stack is None: raise IndexError(\\"pop from empty stack\\") popped_value = self.main_stack.value self.main_stack = self.main_stack.next if popped_value == self.max_stack.value: self.max_stack = self.max_stack.next return popped_value def peek(self) -> int: if self.main_stack is None: raise IndexError(\\"peek from empty stack\\") return self.main_stack.value def is_empty(self) -> bool: return self.main_stack is None def get_max_element(self) -> int: if self.max_stack is None: raise IndexError(\\"max from empty stack\\") return self.max_stack.value"},{"question":"# Run-Length Encoding and Decoding Challenge Context Run-length encoding (RLE) is a simple and efficient way to compress data by reducing repetitive characters. Your task is to implement both encoding and decoding functions for run-length encoded data, and address improvements and edge cases our initial analysis revealed. Task 1. Implement a function `encode_rle_advanced(input: str) -> str` that takes a string and compresses it using RLE. 2. Implement a function `decode_rle_advanced(input: str) -> str` that takes an encoded string and decompresses it. Input * For `encode_rle_advanced`: * A string `input` (0 <= length of input <= 10^6) consisting of printable ASCII characters. * For `decode_rle_advanced`: * A string `input` representing run-length encoded data, assumed to be correctly encoded. Output * For both functions: * A string representing the encoded or decoded result. Constraints * Consider edge cases such as: * Empty strings. * Strings with no consecutive runs. * Optimize your solution for large input sizes. Examples * Encoding: ```python encode_rle_advanced(\\"aaaabbbccdaa\\") -> \\"4a3b2c1d2a\\" encode_rle_advanced(\\"abc\\") -> \\"1a1b1c\\" encode_rle_advanced(\\"\\") -> \\"\\" ``` * Decoding: ```python decode_rle_advanced(\\"4a3b2c1d2a\\") -> \\"aaaabbbccdaa\\" decode_rle_advanced(\\"1a1b1c\\") -> \\"abc\\" decode_rle_advanced(\\"\\") -> \\"\\" ``` Note that students are asked to handle both typical and edge cases (e.g., empty and single-character strings) and to care about performance due to potential large input sizes.","solution":"def encode_rle_advanced(input: str) -> str: if not input: return \\"\\" encoded_str = [] count = 1 prev_char = input[0] for char in input[1:]: if char == prev_char: count += 1 else: encoded_str.append(f\\"{count}{prev_char}\\") prev_char = char count = 1 encoded_str.append(f\\"{count}{prev_char}\\") return \'\'.join(encoded_str) def decode_rle_advanced(input: str) -> str: if not input: return \\"\\" decoded_str = [] count = 0 for char in input: if char.isdigit(): count = count * 10 + int(char) else: decoded_str.append(char * count) count = 0 return \'\'.join(decoded_str)"},{"question":"# Cellular Network Connection Optimization A telecom company is planning to establish a new cellular network. The company\'s field engineers have identified several key positions where new cell towers can be installed. Each position is represented as coordinates in a 2D grid. Initially, the entire grid is empty. Each cell tower can only cover its immediate adjacent cells (up, down, left, right). The task is to analyze the impact of installing these cell towers on the network connectivity. Specifically, the goal is to determine the number of isolated networks (clusters of connected cell towers) after each installation. Write a function `cell_network(positions: List[List[int]]) -> List[int]` that, given a list of positions where cell towers will be installed, returns the number of isolated networks after each installation. Function Signature ```python from typing import List def cell_network(positions: List[List[int]]) -> List[int]: pass ``` Input - `positions`: A list of lists where each inner list contains two integers `[x, y]` representing the grid coordinates of a new cell tower, in the order of installation. Output - A list of integers, where the i-th integer represents the number of isolated networks after the i-th installation. Constraints - Each position in `positions` is unique. - The grid size is not defined but can be considered very large (infinite). - No two cell towers will be installed in the same position. Example ```python positions = [[0, 0], [0, 1], [1, 2], [2, 1]] print(cell_network(positions)) # Output: [1, 1, 2, 3] ``` Additional Notes - A position `[x, y]` is considered connected to its adjacent positions `[x-1, y]`, `[x+1, y]`, `[x, y-1]`, and `[x, y+1]`. - The output should reflect the dynamic changes in the number of isolated networks as each cell tower is installed. # Background This problem can be effectively solved using the Union-Find (Disjoint Set) data structure. Please carefully optimize the union-find algorithm with path compression and union by size to handle a potentially large number of operations efficiently.","solution":"from typing import List class UnionFind: def __init__(self): self.parent = {} self.rank = {} self.count = 0 def find(self, x): if self.parent[x] != x: self.parent[x] = self.find(self.parent[x]) # Path compression return self.parent[x] def union(self, x, y): rootX = self.find(x) rootY = self.find(y) if rootX != rootY: # Union by rank if self.rank[rootX] > self.rank[rootY]: self.parent[rootY] = rootX elif self.rank[rootX] < self.rank[rootY]: self.parent[rootX] = rootY else: self.parent[rootY] = rootX self.rank[rootX] += 1 self.count -= 1 def add(self, x): if x not in self.parent: self.parent[x] = x self.rank[x] = 0 self.count += 1 def cell_network(positions: List[List[int]]) -> List[int]: uf = UnionFind() result = [] for x, y in positions: uf.add((x, y)) for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nx, ny = x + dx, y + dy if (nx, ny) in uf.parent: uf.union((x, y), (nx, ny)) result.append(uf.count) return result"},{"question":"# Scenario You are tasked with developing a multiplication function for a custom arithmetic library designed to handle arbitrarily large numbers. Standard integer types in your environment handle only up to 64-bit numbers, but your function should support much larger numbers, represented as strings. # Problem Implement a function that multiplies two non-negative integers represented as strings and returns the product as a string. Do not use any built-in libraries that handle large integers or convert the inputs directly to integers. # Function Signature ```python def multiply(num1: \\"str\\", num2: \\"str\\") -> \\"str\\": pass ``` # Input - **num1** (string): A string representing the first non-negative integer. The length of num1 is < 110. - **num2** (string): A string representing the second non-negative integer. The length of num2 is < 110. Both `num1` and `num2` will contain only digits 0-9 and will not have leading zeros. # Output - (string): The product of the two numbers represented as a string. # Constraints - You must not use any built-in BigInteger library or convert the inputs to integers directly. # Example ```python assert multiply(\\"123\\", \\"456\\") == \\"56088\\" assert multiply(\\"2\\", \\"3\\") == \\"6\\" assert multiply(\\"100\\", \\"1000\\") == \\"100000\\" assert multiply(\\"0\\", \\"123456\\") == \\"0\\" ``` # Notes - Ensure to handle edge cases like multiplication by zero. - Consider the time complexity and optimize the loops where possible.","solution":"def multiply(num1: str, num2: str) -> str: if num1 == \\"0\\" or num2 == \\"0\\": return \\"0\\" # Initialize result to zero in the form of an array result = [0] * (len(num1) + len(num2)) # Reverse both of the input numbers num1, num2 = num1[::-1], num2[::-1] # Multiply every digit of the first number with every digit of the second number for i in range(len(num1)): for j in range(len(num2)): result[i + j] += int(num1[i]) * int(num2[j]) result[i + j + 1] += result[i + j] // 10 # Carry over to the next digit result[i + j] %= 10 # Save the current digit # Strip leading zeros from the result and reverse back to the correct order while len(result) > 1 and result[-1] == 0: result.pop() return \'\'.join(map(str, result[::-1]))"},{"question":"# Question: Implement an AVL Tree with Range Sum Query **Objective**: Implement an AVL Tree with an additional method to calculate the sum of elements within a given range `[L, R]`. **Instructions**: 1. Implement the `insert`, `re_balance`, `update_heights`, `update_balances`, `rotate_right`, `rotate_left`, and `in_order_traverse` methods as specified in the provided AVL tree class. 2. Add a new method `range_sum(L, R)` to calculate the sum of all elements in the tree within the inclusive range `[L, R]`. **Input/Output Format**: - `insert(key)`: Inserts a new `key` into the AVL tree. - `range_sum(L, R)`: Returns the sum of all keys in the tree within the range `[L, R]`. **Constraints**: - You may assume that `L <= R`. - All keys are unique. - The `range_sum` method should run in O(log N + K) time, where `N` is the number of nodes in the tree and `K` is the number of elements in the range `[L, R]`. **Example**: ```python avl = AvlTree() avl.insert(10) avl.insert(5) avl.insert(15) avl.insert(3) avl.insert(8) avl.insert(12) avl.insert(18) print(avl.range_sum(5, 15)) # Output: 50 (since 5 + 8 + 10 + 12 + 15 = 50) ``` Provide the implementation of the `range_sum` method below the AVL tree implementation.","solution":"class Node: def __init__(self, key): self.key = key self.left = None self.right = None self.height = 1 # Height of node in tree self.balance = 0 # Balance factor self.sum = key # Sum of subtree class AvlTree: def __init__(self): self.root = None def insert(self, key): if not self.root: self.root = Node(key) else: self.root = self._insert(self.root, key) def _insert(self, root, key): if not root: return Node(key) if key < root.key: root.left = self._insert(root.left, key) else: root.right = self._insert(root.right, key) self.update_heights(root) self.update_sums(root) self.update_balances(root) return self.re_balance(root) def re_balance(self, root): if root.balance < -1: if root.left.balance > 0: root.left = self.rotate_left(root.left) return self.rotate_right(root) if root.balance > 1: if root.right.balance < 0: root.right = self.rotate_right(root.right) return self.rotate_left(root) return root def update_heights(self, root): if root: left_height = root.left.height if root.left else 0 right_height = root.right.height if root.right else 0 root.height = max(left_height, right_height) + 1 def update_balances(self, root): if root: left_height = root.left.height if root.left else 0 right_height = root.right.height if root.right else 0 root.balance = right_height - left_height def update_sums(self, root): if root: left_sum = root.left.sum if root.left else 0 right_sum = root.right.sum if root.right else 0 root.sum = root.key + left_sum + right_sum def rotate_right(self, y): x = y.left T2 = x.right x.right = y y.left = T2 self.update_heights(y) self.update_heights(x) self.update_balances(y) self.update_balances(x) self.update_sums(y) self.update_sums(x) return x def rotate_left(self, x): y = x.right T2 = y.left y.left = x x.right = T2 self.update_heights(x) self.update_heights(y) self.update_balances(x) self.update_balances(y) self.update_sums(x) self.update_sums(y) return y def range_sum(self, L, R): return self._range_sum(self.root, L, R) def _range_sum(self, root, L, R): if not root: return 0 if root.key < L: return self._range_sum(root.right, L, R) elif root.key > R: return self._range_sum(root.left, L, R) else: return (root.key + self._range_sum(root.left, L, R) + self._range_sum(root.right, L, R))"},{"question":"Linked List Intersection Detection You are given two singly linked lists. Write a function `find_intersection_node(head1, head2)` that identifies the first common node between the two input linked lists, if any. The linked lists are represented by their head nodes. # Function Signature ```python def find_intersection_node(head1: Node, head2: Node) -> Node: ``` Parameters: - `head1`: Node - Head node of the first singly linked list. - `head2`: Node - Head node of the second singly linked list. Returns: - Node - The reference to the first intersecting node. - `None` if there is no intersection. # Constraints: - The linked lists form straight paths (no circular references). - If the linked lists intersect, they include nodes onwards from the point of intersection. - The maximum length of a list is 10,000 nodes. - Node comparison is based on the node instance, not the node value. # Example: ```python class Node: def __init__(self, val=None): self.val = val self.next = None # list1: 1 -> 3 -> 5 # # 7 -> 9 -> 11 # / # list2: 2 -> 4 -> 6 a1 = Node(1) b1 = Node(3) c1 = Node(5) d = Node(7) a2 = Node(2) b2 = Node(4) c2 = Node(6) e = Node(9) f = Node(11) a1.next = b1 b1.next = c1 c1.next = d a2.next = b2 b2.next = c2 c2.next = d d.next = e e.next = f # Test assert find_intersection_node(a1, a2) == d ``` Explanation: In this example, the intersection occurs at the node with value 7. From this node onwards, both linked lists share the same nodes 7, 9, 11. Hence, the function should return the reference to node 7. Additional Considerations: - Ensure the function handles empty lists gracefully by returning `None`. - Plan for performance optimization, ensuring suitable handling of large datasets. - Validate edge cases such as lists of unequal lengths and no intersection scenarios. Note: Avoid using any additional lists, sets, or dictionaries for node storage; the goal is to accomplish it with constant space usage.","solution":"class Node: def __init__(self, val=None): self.val = val self.next = None def get_length(node): length = 0 while node: length += 1 node = node.next return length def find_intersection_node(head1, head2): Identifies the first common node between two singly linked lists. Parameters: head1 : Node - Head node of the first singly linked list head2 : Node - Head node of the second singly linked list Returns: Node - The reference to the first intersecting node, or None if no intersection if not head1 or not head2: return None len1 = get_length(head1) len2 = get_length(head2) # Adjust starting points for both linked lists based on their lengths if len1 > len2: for _ in range(len1 - len2): head1 = head1.next elif len2 > len1: for _ in range(len2 - len1): head2 = head2.next # Traverse both lists together to find the intersection while head1 and head2: if head1 == head2: return head1 head1 = head1.next head2 = head2.next return None"},{"question":"Context Counting the number of digits in an integer is a common requirement in many computational tasks, such as formatting numerical data, validation inputs, or analyzing numerical properties. This task requires you to extend this simple digit-counting functionality to handle additional requirements. Task You are required to write a Python function `extended_num_digits` that accomplishes the following: 1. Takes an integer `n` as input and computes the number of digits. 2. If the input is not an integer (e.g., float, string, or other non-numerical type), the function should raise a `ValueError` with an appropriate message. 3. For very large integers, your function should still compute the number of digits accurately. Function Signature ```python def extended_num_digits(n): Given an integer, compute the number of digits. Raise ValueError for non-integer inputs. :param n: int - The input integer to count digits of. :return: int - The number of digits in the integer. :raises: ValueError - If the input is not an integer. pass ``` Constraints * Input will be a single integer `n` or other types (float, string, etc.) which should raise a `ValueError`. * You should ensure robustness for large integer inputs. Examples ```python >>> extended_num_digits(12345) 5 >>> extended_num_digits(0) 1 >>> extended_num_digits(-789) 3 >>> extended_num_digits(1.234) ValueError: Input must be an integer >>> extended_num_digits(\\"hello\\") ValueError: Input must be an integer >>> extended_num_digits(int(\\"9\\"*304)) 304 ``` Write the function `extended_num_digits` to meet the above specifications.","solution":"def extended_num_digits(n): Given an integer, compute the number of digits. Raise ValueError for non-integer inputs. :param n: int - The input integer to count digits of. :return: int - The number of digits in the integer. :raises: ValueError - If the input is not an integer. if not isinstance(n, int): raise ValueError(\\"Input must be an integer\\") return len(str(abs(n)))"},{"question":"# Prime Number Identification Given a number `n`, create a function `detect_prime(n: int) -> bool` that checks whether `n` is a prime number. # Function Signature ```python def detect_prime(n: int) -> bool: pass ``` # Description A prime number is defined as a natural number greater than 1 that has no positive divisors other than 1 and itself. Your task is to implement the function `detect_prime` which determines if the given `n` is a prime number. The function should follow an efficient approach to handle moderately large integers. # Input * `n`: An integer (0 ≤ n ≤ 10^9) # Output A boolean value: * `True` if `n` is a prime number. * `False` otherwise. # Constraints * Time complexity of the function must be O(√n). * Space complexity must be O(1). # Example ```python print(detect_prime(29)) # Output: True print(detect_prime(15)) # Output: False ``` # Requirements * Ensure proper handling of edge cases, such as very small values of `n`. * Optimize performance to handle the upper limit of `n`. Good luck!","solution":"def detect_prime(n: int) -> bool: Returns True if n is a prime number, else returns False. if n <= 1: return False if n == 2: return True if n % 2 == 0: return False for i in range(3, int(n ** 0.5) + 1, 2): if n % i == 0: return False return True"},{"question":"**Problem Statement:** In a given row-wise and column-wise sorted matrix, write a function `find_element(matrix, rows, cols, elem)` that searches for a specified element. If the element is found, return its position as a tuple (row, column). If the element is not found, return `None`. The function should efficiently utilize the properties of the matrix to minimize the number of comparisons made during the search. # Input: - `matrix` - List[List[int]]: A 2D list of integers representing the matrix which is sorted non-decreasing in both rows and columns. - `rows` - int: The number of rows in the matrix. - `cols` - int: The number of columns in the matrix. - `elem` - int: The element to search for in the matrix. # Output: - Tuple[int, int]: A tuple representing the (row, column) position of the found element (1-based index). - `None`: If the element is not found in the matrix. # Constraints: 1. (1 leq rows, cols leq 10^3) 2. All elements in the matrix are unique. 3. The matrix is guaranteed to be sorted non-decreasing in the row-wise and column-wise manner. # Performance Requirements: 1. The solution should run within (O(m + n)) time complexity where (m) is the number of rows and (n) is the number of columns. 2. Space complexity should remain (O(1)) - constant space usage. # Example: Input: ```plaintext matrix = [ [2, 5, 7], [4, 8, 13], [9, 11, 15], [12, 17, 20] ] rows = 4 cols = 3 elem = 13 ``` Output: ```plaintext (2, 3) ``` Explanation: The element 13 is found at row 2, column 3 (1-based index). # Function Signature: ```python def find_element(matrix: List[List[int]], rows: int, cols: int, elem: int) -> Union[Tuple[int, int], None]: ... ```","solution":"from typing import List, Union, Tuple def find_element(matrix: List[List[int]], rows: int, cols: int, elem: int) -> Union[Tuple[int, int], None]: Searches for an element in a row-wise and column-wise sorted matrix. Args: matrix (List[List[int]]): The matrix to search in. rows (int): The number of rows in the matrix. cols (int): The number of columns in the matrix. elem (int): The element to search for. Returns: Tuple[int, int]: The position (1-based index) of the found element. None: If the element is not found. # Start from the top-right corner of the matrix row = 0 col = cols - 1 while row < rows and col >= 0: current = matrix[row][col] if current == elem: return (row + 1, col + 1) # return 1-based index elif current < elem: row += 1 else: col -= 1 return None"},{"question":"# Depth First Search vs Breadth First Search You are given an undirected graph represented as an adjacency list. Your task is to implement two functions for graph traversal as described: 1. `dfs_traverse(graph: dict, start: Any) -> Set[Any]`: This function should traverse the graph using an iterative depth-first search starting from the node `start` and return a set of all visited nodes. 2. `bfs_traverse(graph: dict, start: Any) -> Set[Any]`: This function should traverse the graph using a breadth-first search starting from the node `start` and return a set of all visited nodes. Input * `graph`: A dictionary representing the adjacency list of an undirected graph. The keys are nodes, and the values are lists of neighboring nodes. * `start`: The node from which the traversal should begin. Output * Return a set containing all the nodes visited during the traversal. Constraints * The graph will have at most 1000 nodes and 2000 edges. * Nodes are unique and can be any hashable type (e.g., int, string). * The start node is guaranteed to be in the graph. Examples Example 1: ```python graph = { 0: [1, 2], 1: [0, 3], 2: [0, 4], 3: [1], 4: [2] } dfs_traverse(graph, 0) # Output: {0, 1, 2, 3, 4} bfs_traverse(graph, 0) # Output: {0, 1, 2, 3, 4} ``` Example 2: ```python graph = { \'A\': [\'B\', \'C\'], \'B\': [\'A\', \'D\', \'E\'], \'C\': [\'A\'], \'D\': [\'B\'], \'E\': [\'B\'] } dfs_traverse(graph, \'A\') # Output: {\'A\', \'B\', \'D\', \'E\', \'C\'} bfs_traverse(graph, \'A\') # Output: {\'A\', \'B\', \'C\', \'D\', \'E\'} ``` Implement the `dfs_traverse` and `bfs_traverse` functions to complete this task.","solution":"def dfs_traverse(graph, start): Perform a Depth-First Search traversal of the graph. Parameters: graph (dict): The graph represented as an adjacency list. start (Any): The starting node for the traversal. Returns: Set[Any]: A set containing all visited nodes. visited = set() stack = [start] while stack: node = stack.pop() if node not in visited: visited.add(node) stack.extend(neighbor for neighbor in graph[node] if neighbor not in visited) return visited def bfs_traverse(graph, start): Perform a Breadth-First Search traversal of the graph. Parameters: graph (dict): The graph represented as an adjacency list. start (Any): The starting node for the traversal. Returns: Set[Any]: A set containing all visited nodes. visited = set() queue = [start] while queue: node = queue.pop(0) if node not in visited: visited.add(node) queue.extend(neighbor for neighbor in graph[node] if neighbor not in visited) return visited"},{"question":"**Question**: Implement a function `remove_min_repeat` that removes all occurrences of the smallest value from a given stack. The stack is represented as a list where the end of the list is the top of the stack. Assume you cannot use any additional collections (such as lists or stacks) except basic integer variables. # Input: - A list representing the stack of integers, e.g., `[2, 8, 3, -6, 7, 3, -6]` # Output: - The modified stack with all minimum values removed. For the given example, output should be `[2, 8, 3, 7, 3]` # Constraints: - The input list can have negative and positive integers. - Do not use any additional collections for storing elements temporarily. # Performance Requirements: - Aim to minimize auxiliary space usage. # Function Signature: ```python def remove_min_repeat(stack: list) -> list: pass ``` # Example: ```python stack = [2, 8, 3, -6, 7, 3, -6] print(remove_min_repeat(stack)) # Output should be [2, 8, 3, 7, 3] ``` # Scenario: You need to process a series of operations where a specific handler function modifies existing stacks to omit all smallest elements from them. The solution must work within strict space constraints and efficiently.","solution":"def remove_min_repeat(stack: list) -> list: if not stack: return stack # Return directly if the stack is empty # Find the minimum value in the stack min_value = min(stack) # Remove all occurrences of the minimum value in-place i = 0 while i < len(stack): if stack[i] == min_value: del stack[i] # Delete the element at index i else: i += 1 # Move to the next element only if no deletion is done return stack"},{"question":"# Scenario You work as a software engineer at a company that processes large numbers. Your team needs a function to handle arbitrary large number addition by incrementing a given non-negative number (provided as an array of digits) by one. The function needs to be efficient both in time and space as you will handle numbers with up to a million digits. # Problem Statement Write a function `increment_number` that takes a list of non-negative integers representing digits of a large number, increments the number by one, and returns the new list of digits. # Input * `digits`: List of integers where each element in the list is a digit (0 through 9) of a large number. Constraints * The length of digits list can go up to (10^6). # Output Return a list of integers representing the incremented number. # Example ```python def increment_number(digits): pass # Example 1 print(increment_number([1, 2, 3])) # Output: [1, 2, 4] # Example 2 print(increment_number([9, 9, 9])) # Output: [1, 0, 0, 0] # Example 3 print(increment_number([0])) # Output: [1] # Example 4 print(increment_number([2, 3, 9])) # Output: [2, 4, 0] ``` # Requirements * Your solution must have a time complexity of O(n) and space complexity of O(1) – no extra space proportional to input size. * Handle all edge cases including when all digits in the list are `9`.","solution":"def increment_number(digits): Increment a number represented as a list of digits by one. :param digits: List[int] where each element is a digit :return: List[int] representing the incremented number n = len(digits) # Iterate from the last digit to the first digit for i in range(n - 1, -1, -1): if digits[i] < 9: digits[i] += 1 return digits digits[i] = 0 # If we are here, it means all the digits were 9 # Hence we need to add a \'1\' at the beginning return [1] + digits"},{"question":"# Graph Traversal with DFS and BFS You are given an unweighted, undirected graph represented as an adjacency list. Implement functions to traverse this graph using both Depth First Search (DFS) and Breadth First Search (BFS). You must write two separate functions: 1. `dfs_traverse(graph: Dict[int, List[int]], start: int) -> Set[int]` 2. `bfs_traverse(graph: Dict[int, List[int]], start: int) -> Set[int]` Input and Output Formats 1. `dfs_traverse(graph, start)`: - **Input**: - `graph`: A dictionary where the key is an integer representing a node, and the value is a list of integers representing the neighbors of that node. - `start`: An integer representing the starting node for the traversal. - **Output**: - A set of integers representing all nodes visited during the traversal. 2. `bfs_traverse(graph, start)`: - **Input**: - `graph`: A dictionary where the key is an integer representing a node, and the value is a list of integers representing the neighbors of that node. - `start`: An integer representing the starting node for the traversal. - **Output**: - A set of integers representing all nodes visited during the traversal. Constraints * Assume that the graph does not contain self-loops or parallel edges. * All node values in the graph are non-negative integers. * Assume the starting node exists in the graph. * Handle disconnected components properly by ensuring all reachable nodes are visited from the start node. Example ```python graph = { 0: [1, 2], 1: [0, 3, 4], 2: [0], 3: [1], 4: [1, 5], 5: [4] } # Example DFS traversal starting at node 0 dfs_result = dfs_traverse(graph, 0) print(dfs_result) # Output might be {0, 1, 3, 4, 5, 2} # Example BFS traversal starting at node 0 bfs_result = bfs_traverse(graph, 0) print(bfs_result) # Output might be {0, 1, 2, 3, 4, 5} ``` Your task is to implement the functions `dfs_traverse` and `bfs_traverse` such that they perform the graph traversal correctly as described above.","solution":"def dfs_traverse(graph, start): Perform DFS traversal on the graph starting from the given node. Args: graph (dict): The graph represented as an adjacency list. start (int): The starting node for DFS traversal. Returns: set: A set of all nodes visited during the traversal. visited = set() stack = [start] while stack: node = stack.pop() if node not in visited: visited.add(node) stack.extend(neighbor for neighbor in graph[node] if neighbor not in visited) return visited def bfs_traverse(graph, start): Perform BFS traversal on the graph starting from the given node. Args: graph (dict): The graph represented as an adjacency list. start (int): The starting node for BFS traversal. Returns: set: A set of all nodes visited during the traversal. visited = set() queue = [start] while queue: node = queue.pop(0) if node not in visited: visited.add(node) queue.extend(neighbor for neighbor in graph[node] if neighbor not in visited) return visited"},{"question":"You are given a singly linked list where each node contains a string value and a pointer to the next node. The list structure is provided, and your task is to implement a function that efficiently finds the k-th to last node in the linked list. **Function Signature:** ```python def find_kth_to_last(head: Node, k: int) -> Node: ``` **Input:** * `head` (Node): The head node of the singly linked list. * `k` (int): An integer representing the position from the end (1-based). **Output:** * (Node): The k-th to last node in the linked list. If k is invalid (greater than the list length or non-positive), return `None`. # Constraints * `1 <= len(linked_list) <= 10000` * `Node.val` is a string containing alphanumeric characters. # Requirements: 1. Do not use built-in functions such as `eval` or data structures like dictionaries for intermediate storage. 2. Ensure the implementation uses O(1) extra space and runs in O(n) time. # Example: ```python # Input construction a1 = Node(\\"A\\") a2 = Node(\\"A\\") b = Node(\\"B\\") c1 = Node(\\"C\\") d = Node(\\"D\\") c2 = Node(\\"C\\") f = Node(\\"F\\") g = Node(\\"G\\") a1.next = a2 a2.next = b b.next = c1 c1.next = d d.next = c2 c2.next = f f.next = g # Usage result = find_kth_to_last(a1, 4) assert result.val == \\"D\\" invalid_result = find_kth_to_last(a1, 10) assert invalid_result is None negative_k_result = find_kth_to_last(a1, -1) assert negative_k_result is None ``` Ensure your function conforms to these constraints and returns the appropriate node or `None` for invalid inputs.","solution":"class Node: def __init__(self, val: str): self.val = val self.next = None def find_kth_to_last(head: Node, k: int) -> Node: if k <= 0: return None fast = slow = head for _ in range(k): if fast is None: return None fast = fast.next while fast is not None: slow = slow.next fast = fast.next return slow"},{"question":"**Question**: **Context**: You are working on a text processing tool that needs to quickly and efficiently find all occurrences of a specified pattern in a given text. To this end, you need to implement the Knuth-Morris-Pratt (KMP) string matching algorithm. **Problem Statement**: Write a function `knuth_morris_pratt(text: str, pattern: str) -> List[int]` that takes as input a `text` string and a `pattern` string, and returns a list of starting indices where the `pattern` is found in the `text`. **Function Signature**: ```python def knuth_morris_pratt(text: str, pattern: str) -> List[int]: pass ``` **Input**: - `text`: A string representing the text to search within. (1 ≤ len(text) ≤ 10^5) - `pattern`: A string representing the pattern to search for. (1 ≤ len(pattern) ≤ 10^4) **Output**: - A list of integers representing the starting indices of each occurrence of the `pattern` within the `text`. The list should be in ascending order. **Constraints**: - The implementation should run in O(N + M) time complexity where N is the length of the text and M is the length of the pattern. - Space complexity should be O(M) for storing the prefix table. **Example**: ```python knuth_morris_pratt(\'hello there hero!\', \'he\') # Output: [0, 7, 12] knuth_morris_pratt(\'ababababca\', \'abab\') # Output: [0, 2, 4] knuth_morris_pratt(\'aaaaa\', \'aa\') # Output: [0, 1, 2, 3] ``` **Notes**: - Ensure that the solution handles edge cases gracefully, such as when the pattern is an empty string or when no matches are found. - The function should be designed for optimal performance to handle the upper bounds of the input sizes efficiently.","solution":"from typing import List def knuth_morris_pratt(text: str, pattern: str) -> List[int]: Returns a list of starting indices where the pattern is found in the text. def build_lps(pattern: str) -> List[int]: Builds the longest prefix which is also suffix (LPS) array for KMP pattern matching. length = 0 lps = [0] * len(pattern) i = 1 while i < len(pattern): if pattern[i] == pattern[length]: length += 1 lps[i] = length i += 1 else: if length != 0: length = lps[length - 1] else: lps[i] = 0 i += 1 return lps if not pattern: return [] lps = build_lps(pattern) result = [] i, j = 0, 0 # i -> text, j -> pattern while i < len(text): if text[i] == pattern[j]: i += 1 j += 1 if j == len(pattern): result.append(i - j) j = lps[j - 1] elif i < len(text) and text[i] != pattern[j]: if j != 0: j = lps[j - 1] else: i += 1 return result"},{"question":"Scenario In a robotics competition, you are required to program a robot to navigate through a grid. The robot starts at the top-left corner of the grid and can only move either right or down to reach the bottom-right corner. Given the dimensions of the grid, determine the number of unique paths from the start to the destination. Function Implementation Implement the function `count_paths(m: int, n: int) -> int` that calculates the number of unique paths in an `m x n` grid. # Input * `m (int)`: Number of rows in the grid. (1 ≤ m ≤ 100) * `n (int)`: Number of columns in the grid. (1 ≤ n ≤ 100) # Output * `int`: The number of unique paths from the top-left corner to the bottom-right corner of the grid. # Constraints * Both `m` and `n` are positive integers. * You can only move right or down. # Performance Requirements * Time Complexity: (O(m times n)) * Space Complexity: (O(m times n)) # Example * Input: `m = 3, n = 3` * Output: `6` * Input: `m = 4, n = 2` * Output: `4` # Explanation * In the first example, there are 6 unique paths to navigate a 3x3 grid from top-left to bottom-right. * In the second example, there are 4 unique paths to navigate a 4x2 grid. You are suggested to use dynamic programming to solve this problem efficiently.","solution":"def count_paths(m, n): Returns the number of unique paths in an m x n grid from the top-left corner to the bottom-right corner. # Create a 2D list with dimensions m x n and initialize all entries to 1. dp = [[1] * n for _ in range(m)] # Populate the dp list by summing the paths from the top and left cells. for i in range(1, m): for j in range(1, n): dp[i][j] = dp[i - 1][j] + dp[i][j - 1] return dp[m - 1][n - 1]"},{"question":"**Problem: Duplicate Removal in Singly Linked List** You are given the head of a singly linked list. Your task is to write a function that removes all duplicate elements from the list and returns the modified list such that each element appears only once. # Function Signature ```python def remove_duplicates(head: ListNode) -> ListNode: ``` # Input - `head` (ListNode): A singly linked list where each node contains an integer value. # Output - Return the head of the modified list with duplicates removed. # Constraints - The list is not sorted. - The list size can be large (within reasonable bounds to avoid stack overflow in recursive solutions). # Example ```python # Input: 1 --> 2 --> 3 --> 2 --> 4 --> 1 # Output: 1 --> 2 --> 3 --> 4 # Input: None # Output: None # Input: 1 # Output: 1 # Input: 1 --> 1 --> 1 # Output: 1 ``` # Notes 1. Consider using an auxiliary data structure to keep track of seen elements. 2. Optimize to use minimal additional space if possible. 3. Handle edge cases, such as an empty list or a single node list.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def remove_duplicates(head: ListNode) -> ListNode: if not head: return None seen = set() current = head seen.add(current.val) while current and current.next: if current.next.val in seen: current.next = current.next.next else: seen.add(current.next.val) current = current.next return head def list_to_array(head: ListNode) -> list: array = [] current = head while current: array.append(current.val) current = current.next return array def array_to_list(array: list) -> ListNode: if not array: return None head = ListNode(array[0]) current = head for value in array[1:]: current.next = ListNode(value) current = current.next return head"},{"question":"You are given a linked list and your task is to write a function that will determine if the list is in a strict alternating pattern of ascending and descending order. A list is considered to follow this pattern if it alternates between increasing and decreasing at each node. For example, a list `1 -> 3 -> 2 -> 5 -> 4` is considered to follow the strict alternating pattern, but the list `1 -> 2 -> 3 -> 4 -> 5` does not. # Function Signature ```python def is_alternating(head): # Your code here ``` # Input * `head`: - A `ListNode` object representing the head of a singly linked list. - Each node contains an attribute `val` (integer) and `next` (reference to the next node or `None`). # Output * Return `True` if the linked list follows a strict alternating pattern of ascending and descending order, otherwise return `False`. # Constraints * The node values are integers. * The length of the list will not exceed 10^4. # Example ```python # Example of a list: 1 -> 3 -> 2 -> 5 -> 4 -> None head = ListNode(1) head.next = ListNode(3) head.next.next = ListNode(2) head.next.next.next = ListNode(5) head.next.next.next.next = ListNode(4) print(is_alternating(head)) # Output: True # Example of a list: 1 -> 2 -> 3 -> None head = ListNode(1) head.next = ListNode(2) head.next.next = ListNode(3) print(is_alternating(head)) # Output: False ``` # Notes * Make sure to handle edge cases such as an empty list or a single-element list. * You may assume the ListNode class is provided as follows: ```python class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next ```","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def is_alternating(head): Determines if a linked list follows a strict alternating pattern of ascending and descending values. if not head or not head.next: return True # A single node or empty list is trivially alternating current = head is_increasing = None while current.next: if current.val == current.next.val: return False # Equal values wouldn\'t result in a strict alternating pattern elif current.val < current.next.val: if is_increasing is False: return False # Transition mismatch is_increasing = False else: if is_increasing is True: return False # Transition mismatch is_increasing = True current = current.next return True"},{"question":"As part of a machine learning project, you need to implement a function that computes the product of two matrices. Ensure that the matrices are compatible for multiplication, and handle any exceptions that may arise due to incompatibility. Function Signature ```python def matrix_multiply(multiplicand: list[list[int]], multiplier: list[list[int]]) -> list[list[int]]: ``` Input - `multiplicand` (List[List[int]]): A two-dimensional list representing the first matrix. - `multiplier` (List[List[int]]): A two-dimensional list representing the second matrix. Output - Returns a two-dimensional list representing the product of the two matrices if they are compatible. - Raises an exception if the matrices are not compatible for multiplication. Constraints - Each element in the matrices is an integer. - The matrices can have dimensions up to 1000 x 1000. Example ```python # Example 1 multiplicand = [ [1, 2, 3], [4, 5, 6] ] multiplier = [ [7, 8], [9, 10], [11, 12] ] print(matrix_multiply(multiplicand, multiplier)) # Output: [[58, 64], [139, 154]] # Example 2 multiplicand = [ [1, 2], [3, 4] ] multiplier = [ [5, 6], [7, 8] ] print(matrix_multiply(multiplicand, multiplier)) # Output: [[19, 22], [43, 50]] ``` Additional Notes 1. Ensure the function is optimized to handle the upper constraint efficiently. 2. You may use nested loops for the implementation. 3. Pay special attention to edge cases such as incompatible matrices and matrices with zero dimensions. 4. You do not need to handle matrices with non-integer elements within the constraints specified.","solution":"def matrix_multiply(multiplicand: list[list[int]], multiplier: list[list[int]]) -> list[list[int]]: Multiplies two matrices and returns the result if compatible. Raises an exception if matrices are not compatible for multiplication. rows_multiplicand = len(multiplicand) cols_multiplicand = len(multiplicand[0]) if rows_multiplicand > 0 else 0 rows_multiplier = len(multiplier) cols_multiplier = len(multiplier[0]) if rows_multiplier > 0 else 0 if cols_multiplicand != rows_multiplier: raise ValueError(\\"Incompatible matrices for multiplication\\") # Initialize the result matrix with zeros result = [[0 for _ in range(cols_multiplier)] for _ in range(rows_multiplicand)] for i in range(rows_multiplicand): for j in range(cols_multiplier): for k in range(cols_multiplicand): result[i][j] += multiplicand[i][k] * multiplier[k][j] return result"},{"question":"You need to write a function that generates a modified version of the hailstone (Collatz) sequence. The sequence starts from a given positive integer `n` and follows these rules until it reaches 1: 1. If `n` is 1, the sequence ends. 2. If `n` is even, the next number in the sequence is obtained by dividing `n` by 2. 3. If `n` is odd, the next number in the sequence is obtained by multiplying `n` by 3 and adding 1, **only if the sequence does not already contain this result.** Otherwise, divide the current number by 3. Your task is to implement the function `modified_hailstone(n)` that returns the modified hailstone sequence as a list of integers from `n` to 1. # Input Format - A single integer `n` where `1 ≤ n ≤ 10^6` # Output Format - A list of integers representing the modified hailstone sequence from `n` to 1. # Constraints - Ensure your solution handles the constraints efficiently. # Performance Requirements - Your solution should run within a reasonable time for large values of `n`. # Example Input: `n = 7` Output: `[7, 22, 11, 34, 17, 52, 26, 13, 4, 2, 1]` **Explanation**: 1. Start with 7 (odd). 2. 3*7 + 1 = 22 (not in the sequence), add 22. 3. 22 (even), divide by 2, get 11, add 11. 4. 11 (odd), 3*11 + 1 = 34 (not in the sequence), add 34. 5. 34 (even), divide by 2, get 17, add 17. 6. 17 (odd), 3*17 + 1 = 52 (not in the sequence), add 52. 7. 52 (even), divide by 2, get 26, add 26. 8. 26 (even), divide by 2, get 13, add 13. 9. 13 (odd), 3*13 + 1 = 40 (since 40 is not in the sequence but we don\'t use it in original problem), divide 13 by 3 and continue. 10. Continue until the sequence reaches 1. Implement the function `modified_hailstone(n)` below: ```python def modified_hailstone(n): Generate the modified hailstone sequence. n: The starting point of the hailstone sequence. Returns List[int]: The modified hailstone sequence. sequence = [n] # Initialize sequence with the starting number. while n != 1: # Continue until n reaches 1. if n % 2 == 0: n = n // 2 # If n is even, divide by 2. else: next_n = 3 * n + 1 if next_n in sequence: n = n // 3 # if 3n+1 already in sequence, divide by 3 else: n = 3 * n + 1 # Otherwise, use the standard rule. sequence.append(n) return sequence ```","solution":"def modified_hailstone(n): Generate the modified hailstone sequence. n: The starting point of the hailstone sequence. Returns List[int]: The modified hailstone sequence. sequence = [n] # Initialize sequence with the starting number. while n != 1: # Continue until n reaches 1. if n % 2 == 0: n = n // 2 # If n is even, divide by 2. else: next_n = 3 * n + 1 if next_n in sequence: n = n // 3 # if 3n+1 already in sequence, divide by 3 else: n = 3 * n + 1 # Otherwise, use the standard rule. sequence.append(n) return sequence"},{"question":"# Scenario/Context Imagine you are developing a text editor and need to implement a search functionality to find and highlight specific substrings within a larger body of text the user is editing. # Problem Statement Please implement a function `find_substring_index(haystack: str, needle: str) -> int`. This function should return the index of the first occurrence of the string `needle` in the string `haystack`, or -1 if `needle` is not part of `haystack`. # Input and Output Formats - **Input**: - A string `haystack` with a length `n` (1 <= n <= 10^4). - A string `needle` with a length `m` (0 <= m <= 10^4). - **Output**: - An integer representing the index of the first occurrence of `needle` in `haystack`, or -1 if `needle` is not found. # Constraints - The function should handle the edge case where `needle` is an empty string by returning 0. - If `needle` is longer than `haystack`, the function should return -1. - Implement within a time complexity that is manageable for the input limits, keeping in mind that a brute-force solution may not be efficient for inputs at the maximum allowed size. # Example 1 Input: `haystack = \\"hello\\"`, `needle = \\"ll\\"` Output: `2` # Example 2 Input: `haystack = \\"aaaaa\\"`, `needle = \\"bba\\"` Output: `-1` # Example 3 Input: `haystack = \\"abc\\"`, `needle = \\"\\"` Output: `0` # Example 4 Input: `haystack = \\"mississippi\\"`, `needle = \\"issip\\"` Output: `4` # Example 5 Input: `haystack = \\"a\\"`, `needle = \\"a\\"` Output: `0` # Implementation Implement the function `find_substring_index(haystack: str, needle: str) -> int` meeting the above requirements and constraints. Ensure to handle edge cases properly and aim for optimal performance.","solution":"def find_substring_index(haystack: str, needle: str) -> int: Returns the index of the first occurrence of the string `needle` in the string `haystack`, or -1 if `needle` is not part of `haystack`. If `needle` is an empty string, returns 0. If `needle` is longer than `haystack`, returns -1. if not needle: return 0 needle_length = len(needle) haystack_length = len(haystack) for i in range(haystack_length - needle_length + 1): if haystack[i:i + needle_length] == needle: return i return -1"},{"question":"# Question: **Problem Statement:** You are given a list of integers `lst` and an integer `N`. Your task is to write a function `limited_frequency_list` that returns a new list containing elements from `lst` such that no element appears more than `N` times. The order of the elements in the new list should be the same as their order in the input list. **Function Signature:** ```python def limited_frequency_list(lst: list, n: int) -> list: ``` **Input:** - `lst`: A list of integers (e.g. [1, 2, 3, 1, 2, 1, 2, 3]). - `n`: An integer, indicating the maximum allowed frequency for any element. **Output:** - A new list in which no integer appears more than `n` times, preserving the order of appearance from the original list. **Constraints:** - Each element in `lst` is an integer. - `n` is a non-negative integer. - The length of `lst` does not exceed (10^5). - The integers in `lst` are within the range of (-10^4) to (10^4). **Example:** ```python assert limited_frequency_list([1, 2, 3, 1, 2, 1, 2, 3], 2) == [1, 2, 3, 1, 2, 3] assert limited_frequency_list([1, 2, 3, 1, 2, 1, 2, 3], 0) == [] assert limited_frequency_list([], 1) == [] assert limited_frequency_list([1, 1, 1, 1], 2) == [1, 1] ``` **Explanation:** - For the first example, the final list should include each number at most twice, maintaining the order from the input. - The function should return an empty list if the maximum allowed frequency `n` is zero. - With an empty input list, the function should also return an empty list. - For the list `[1, 1, 1, 1]` with `n = 2`, the function should return `[1, 1]` since `1` can appear at most 2 times. **Note:** You must implement an efficient solution with a time complexity of (O(n)).","solution":"def limited_frequency_list(lst, n): if n == 0: return [] freq = {} result = [] for num in lst: if num not in freq: freq[num] = 0 if freq[num] < n: result.append(num) freq[num] += 1 return result"},{"question":"# Question **Objective**: Implement an enhanced variant of the Cooley-Tukey FFT algorithm to handle input arrays of any size, padding the array with zeroes to the next power of two if necessary. Problem Statement Given an array ( x ) of complex numbers, implement the function `enhanced_fft(x)` that computes the Discrete Fourier Transform (DFT) using the Cooley-Tukey FFT algorithm. If the size of ( x ) is not a power of two, pad ( x ) with zeroes until its size reaches the next power of two. Requirements * You must handle arrays of any size, padding the input array with zeroes to the next power of two if required. * Implement the FFT recursively as shown. * Input array will contain only complex numbers. Input * An array ( x ) of complex numbers with ( 1 leq text{length}(x) leq 10^6 ). Output * An array of complex numbers representing the DFT of ( x ). Function Signature ```python def enhanced_fft(x: List[complex]) -> List[complex]: ``` Examples ```python Input: [2.0+2j, 1.0+3j, 3.0+1j, 2.0+2j] Output: [8+8j, 2j, 2-2j, -2+0j] Input: [1.0+0j, 2.0+0j] Output: [(3+0j), (-1+0j)] Input: [1.0+0j] Output: [(1+0j)] ``` Constraints 1. The implementation should have a time complexity of ( O(N log N) ). 2. The solution should handle edge cases appropriately, including arrays of non-power-of-two lengths.","solution":"import cmath from math import ceil, log2 def _fft(x): N = len(x) if N <= 1: return x even = _fft(x[0::2]) odd = _fft(x[1::2]) T = [cmath.exp(-2j * cmath.pi * k / N) * odd[k] for k in range(N // 2)] return [even[k] + T[k] for k in range(N // 2)] + [even[k] - T[k] for k in range(N // 2)] def enhanced_fft(x): N = len(x) if N == 0: return [] # Find the next power of 2 next_power_of_2 = 1 << (ceil(log2(len(x)))) # Pad with zeros padded_x = x + [0] * (next_power_of_2 - len(x)) return _fft(padded_x)"},{"question":"# Question Title: Hierarchical Data Printer Problem Statement: You are given a hierarchical data structure organized in the form of a tree. Your task is to write a function `enhanced_tree_print` that prints the tree elements in a structured format with proper indentation for non-string data types. Function Signature: ```python def enhanced_tree_print(tree: dict) -> None: pass ``` Input: * `tree` - A dictionary where the key is a node and the value is a list of sub-elements. Sub-elements can be strings or other lists containing further nested sub-elements. Output: * The function should print the tree in a structured format with the following specifications: * Each node (key) should be printed on a new line. * Each sub-element of the node should be printed along with the node in a single line unless the sub-element is not a string. * If a sub-element is not a string, it should be printed on a new line with proper indentation (one additional space). Constraints: * You can assume that the tree does not contain circular references. * Handles up to 1000 nodes. Example: Given the input: ```python tree = { \'a\': [\'Adam\', \'Book\', 4], \'b\': [\'Bill\', [\'Computer\', 5], [\'TV\', 6]], \'Jill\': [\'Sports\', 1], \'c\': [\'Bill\', [\'Sports\', 3]], \'d\': [\'Adam\', \'Computer\', 3], \'e\': [\'Quin\', \'Book\', 5, [\'TV\', 2]], \'f\': [\'Adam\', \'Computer\', 7] } ``` The output should be: ``` a -> Adam -> Book -> 4 b -> Bill -> Computer -> 5 -> TV -> 6 Jill -> Sports -> 1 c -> Bill -> Sports -> 3 d -> Adam -> Computer -> 3 e -> Quin -> Book -> 5 -> TV -> 2 f -> Adam -> Computer -> 7 ``` Notes: * Ensure that the function handles nested structures correctly and maintains the required format. * Pay attention to the details specified for sub-elements that are not strings, and ensure they are printed with proper indentation.","solution":"def enhanced_tree_print(tree: dict) -> None: def print_node(node, indent=\\"\\"): if isinstance(node, str): return node elif isinstance(node, (list, tuple)): lines = [] for n in node: if isinstance(n, (list, tuple)): lines.append(f\\" -> n{indent} {print_node(n, indent + \' \')}\\") else: lines.append(f\\" -> {n}\\") return \\"\\".join(lines) return str(node) for key, value in tree.items(): result = f\\"{key}\\" result += print_node(value) print(result)"},{"question":"# Transitive Closure Challenge Context You are a software engineer tasked with developing a feature that determines whether certain nodes are reachable from others in a large transportation network. To solve this, you must compute the transitive closure of a directed graph representing the network. In this graph, nodes represent locations, and directed edges indicate routes. Objective Write a function `find_transitive_closure` to determine the transitive closure of the graph provided as an input. The function should return a matrix indicating reachability between each pair of nodes. Use the Depth First Search (DFS) approach to compute this. Function Signature ```python def find_transitive_closure(vertices: int, edges: List[Tuple[int, int]]) -> List[List[int]]: ``` Parameters * `vertices` (int): The number of nodes (vertices) in the graph, labeled from 0 to `vertices-1`. * `edges` (List[Tuple[int, int]]): A list of directed edges where each edge is a tuple `(source, target)` representing a directed edge from `source` to `target`. Output * Returns a list of lists (`List[List[int]]`), equivalent to a 2D array, representing the transitive closure matrix. The value `closure[i][j]` should be `1` if there is a path from node `i` to node `j`, and `0` otherwise. Constraints * `1 <= vertices <= 1000` * `0 <= len(edges) <= vertices * (vertices - 1)` Example ```python vertices = 4 edges = [(0, 1), (1, 2), (2, 3)] print(find_transitive_closure(vertices, edges)) ``` Expected Output ``` [ [1, 1, 1, 1], [0, 1, 1, 1], [0, 0, 1, 1], [0, 0, 0, 1] ] ``` Note Use the provided `Graph` class as a reference to implement the transitive closure via DFS. Your solution should correctly handle various edge cases, including disconnected nodes and self-loops.","solution":"from typing import List, Tuple def find_transitive_closure(vertices: int, edges: List[Tuple[int, int]]) -> List[List[int]]: def dfs(v: int, u: int): if closure[v][u] == 0: closure[v][u] = 1 for neighbor in graph[u]: dfs(v, neighbor) # Initialize the adjacency list for the graph graph = [[] for _ in range(vertices)] for (src, tgt) in edges: graph[src].append(tgt) # Initialize the transitive closure matrix with 0\'s closure = [[0] * vertices for _ in range(vertices)] # Each node is reachable from itself for i in range(vertices): closure[i][i] = 1 # Compute the transitive closure using DFS for v in range(vertices): for u in graph[v]: dfs(v, u) return closure # Example usage vertices = 4 edges = [(0, 1), (1, 2), (2, 3)] print(find_transitive_closure(vertices, edges))"},{"question":"**Scenario**: A software system processes large datasets of sequential numbers. To extract insights, it often needs to determine the exact digit at a specific position within these sequences. You\'re responsible for implementing a function to efficiently extract the desired digit from an infinite series of numbers. **Task**: Implement a Python function `find_nth_digit(n)` that returns the nth digit in an infinite sequence of natural numbers. **Specifications**: 1. **Input**: - `n` (int): A positive integer representing the position in the sequence (1-based index). 2. **Output**: - An integer representing the digit at the nth position in the infinite sequence. **Example**: ```python assert find_nth_digit(1) == 1 # The sequence starts with 1 assert find_nth_digit(10) == 1 # The 10th digit in the sequence is \'1\' from \'10\' assert find_nth_digit(11) == 0 # The 11th digit in the sequence is \'0\' from \'10\' ``` **Constraints**: 1. The solution must operate within O(log n) time complexity. 2. The solution must use O(1) extra space. 3. Assume that `n` is a valid integer satisfying `1 ≤ n ≤ 2^31 - 1`. **Considerations**: * Ensure proper handling of edge cases. * Pay attention to integer arithmetic when dealing with large numbers. * Optimize the code to avoid unnecessary calculations and ensure robust handling of sequence transitions. **Function Signature**: ```python def find_nth_digit(n: int) -> int: # Your code here ```","solution":"def find_nth_digit(n): Returns the nth digit in an infinite sequence of natural numbers. digit_length = 1 count = 9 start = 1 # Find the range in which the nth digit falls while n > digit_length * count: n -= digit_length * count digit_length += 1 count *= 10 start *= 10 # Find the exact number in that range start += (n - 1) // digit_length # Find the exact digit in the number return int(str(start)[(n - 1) % digit_length])"},{"question":"# Combination Sum Problem **Context**: You are working for a company that provides tools for financial planning. One specific tool allows users to find combinations of savings options that sum up to a desired target amount. You need to implement a function to support this feature. **Problem Statement**: You are given a list of candidate numbers (`candidates`) without duplicates and a target number (`target`). Write a function `combination_sum(candidates, target)` that returns all unique combinations in `candidates` where the candidate numbers sum to `target`. You may repeatedly use the same number from `candidates`. **Function Signature**: ```python def combination_sum(candidates: List[int], target: int) -> List[List[int]]: pass ``` **Input**: - `candidates`: List of positive integers (1 ≤ |candidates| ≤ 30) - `target`: A positive integer (1 ≤ target ≤ 500) **Output**: - List of all unique combinations of `candidates` where the numbers sum up to `target`. Each combination should be a List of integers, and the list should not contain duplicate combinations. **Constraints**: - All numbers (including the target) will be positive integers. - The solution set must not contain duplicate combinations. **Example**: ```python # Example 1: candidates = [2, 3, 6, 7] target = 7 # Expected Output: [[7], [2, 2, 3]] # Example 2: candidates = [2, 3, 5] target = 8 # Expected Output: [[2, 2, 2, 2], [2, 3, 3], [3, 5]] ``` **Additional Notes**: - Consider edge cases such as when `candidates` is empty, when the smallest candidate is larger than `target`, or when no combination can be found. **Performance Requirements**: - Your solution should be efficient enough to handle the upper limits of the constraints.","solution":"def combination_sum(candidates, target): result = [] def backtrack(remaining, combo, start): if remaining == 0: result.append(list(combo)) return elif remaining < 0: return for i in range(start, len(candidates)): combo.append(candidates[i]) backtrack(remaining - candidates[i], combo, i) combo.pop() candidates.sort() backtrack(target, [], 0) return result"},{"question":"You are given an array `arr` of integers. You need to design a data structure that can efficiently support the following operations: 1. Update the value at a specified index. 2. Calculate the sum of elements from the start of the array up to a specified index. Implement a class `FenwickTree` that includes the following methods: * `__init__(self, nums: List[int])`: Initializes the data structure with the input list `nums`. * `update(self, index: int, value: int)`: Updates the value at index with `value`. * `prefix_sum(self, index: int) -> int`: Returns the prefix sum from start to the given `index`. Constraints: * The length of the array will not exceed 10^4. * The value of each element can range from -10^3 to 10^3. * Multiple update and query operations will be tested to evaluate performance. # Input Format: - The `__init__` method will be called once with the initial array. - Multiple calls to `update` and `prefix_sum` methods will be made. # Example: ```python # Example usage: tree = FenwickTree([1, 2, 3, 4, 5]) print(tree.prefix_sum(3)) # Output: 10 (i.e., 1+2+3+4) tree.update(2, 2) print(tree.prefix_sum(3)) # Output: 9 (i.e., 1+2+2+4) ``` # Explanation: - After initializing the Fenwick Tree with `[1, 2, 3, 4, 5]`, the prefix sum query up to index 3 returns 10. - After updating the value at index 2 to 2, the new array becomes `[1, 2, 2, 4, 5]`, and the prefix sum query up to index 3 now returns 9.","solution":"class FenwickTree: def __init__(self, nums): Initializes the Fenwick Tree with the provided nums list. self.n = len(nums) self.tree = [0] * (self.n + 1) self.nums = nums[:] for i in range(self.n): self._update_tree(i + 1, nums[i]) def _update_tree(self, index, value): Updates the tree with value at the specified tree index. while index <= self.n: self.tree[index] += value index += index & -index def update(self, index, value): Updates the value at the specified index. diff = value - self.nums[index] self.nums[index] = value self._update_tree(index + 1, diff) def prefix_sum(self, index): Returns the prefix sum from the start to the given index. sum_ = 0 index += 1 while index > 0: sum_ += self.tree[index] index -= index & -index return sum_"},{"question":"Objective: Write a function `cocktail_shaker_sort` that sorts an input list of integers in ascending order using the Cocktail Shaker Sort algorithm. Function Signature: ```python def cocktail_shaker_sort(arr: List[int]) -> List[int]: ``` Input: * `arr` (List[int]): A list of integers that need to be sorted. Output: * (List[int]): A sorted list in ascending order. Constraints: * The length of the list, `n`, ranges from 1 to 10^3. * The list elements range from -10^9 to 10^9. Scenario: You are tasked to implement an order processing system where you need to maintain an inventory list. This list occasionally needs to be sorted for efficient querying and updates. Implement the `cocktail_shaker_sort` function to sort your inventory list. Requirements: 1. Ensure the sorting logic adheres strictly to the Cocktail Shaker methodology. 2. Optimize to detect already sorted lists and handle them efficiently. 3. Consider all edge cases, including but not limited to an already sorted list, reverse ordered list, and lists with repeated elements. Example: ```python assert cocktail_shaker_sort([3, 0, -1, 8, 7, 3]) == [-1, 0, 3, 3, 7, 8] assert cocktail_shaker_sort([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5] assert cocktail_shaker_sort([100, 50, 20, -20, -40]) == [-40, -20, 20, 50, 100] ``` Your implementation should ensure the sorted output for the given edge cases and general lists.","solution":"def cocktail_shaker_sort(arr): Sorts an input list of integers in ascending order using the Cocktail Shaker Sort algorithm. Args: arr (List[int]): A list of integers that need to be sorted. Returns: List[int]: A sorted list in ascending order. n = len(arr) if n == 0: return arr swapped = True start = 0 end = n - 1 while swapped: swapped = False # Traverse the array from left to right for i in range(start, end): if arr[i] > arr[i + 1]: arr[i], arr[i + 1] = arr[i + 1], arr[i] swapped = True if not swapped: break # Otherwise, reset the swapped flag so that it can be used in the next stage swapped = False # Move the end point back by one, because the item at the end is in the correct position end -= 1 # Traverse the array from right to left for i in range(end - 1, start - 1, -1): if arr[i] > arr[i + 1]: arr[i], arr[i + 1] = arr[i + 1], arr[i] swapped = True # Increase the starting point because the item at the start is in the correct position start += 1 return arr"},{"question":"You are tasked with helping an athlete prepare for a competition. The athlete has a staircase with a certain number of steps to practice on, and they can either take 1 or 2 steps at a time. You must write an optimized function that calculates the number of distinct ways they can reach the top of the staircase, given `steps` (a positive integer representing the number of steps). # Function Signature: ```python def calculate_ways(steps: int) -> int: :param steps: int :return: int ``` # Input/Output Requirements: - **Input**: A single positive integer `steps` representing the number of steps to reach the top. - **Output**: An integer representing the number of distinct ways to reach the top of the staircase. # Constraints: - `steps` will be a positive integer. - Performance should be optimized to handle reasonably large values of `steps` efficiently. # Examples: ```python assert calculate_ways(2) == 2 # Explanation: (1,1) or (2) assert calculate_ways(3) == 3 # Explanation: (1,1,1) or (1,2) or (2,1) assert calculate_ways(4) == 5 # Explanation: (1,1,1,1) or (1,1,2) or (1,2,1) or (2,1,1) or (2,2) ``` - **Scenario Context**: The athlete must know all possible ways to reach the top as it helps to plan varying intensity workouts by choosing different climbing patterns. # Additional Notes: - Focus on developing an algorithm that minimizes space complexity. - Think about edge cases where `steps` is minimal, such as 1 or 2, to ensure your solution is robust. **Good luck, and may the best algorithm win!**","solution":"def calculate_ways(steps: int) -> int: Calculate the number of distinct ways to reach the top of a staircase taking either 1 or 2 steps at a time. :param steps: int - the number of steps in the staircase :return: int - the number of distinct ways to reach the top if steps == 1: return 1 if steps == 2: return 2 one_step_before = 2 two_steps_before = 1 for _ in range(3, steps + 1): current = one_step_before + two_steps_before two_steps_before = one_step_before one_step_before = current return one_step_before"},{"question":"# Word Dictionary Search with Wildcards You are tasked with implementing a data structure that allows the addition and searching of words, where the search operation supports literal words and pattern matching using the wildcard character `.` that can represent any letter. # Requirements: 1. Implement the `WordDictionary` class with the following methods: - `add_word(word: str)` - Adds a word to the data structure. - `search(word: str) -> bool` - Searches for a word in the data structure. The word can contain the wildcard character `.` representing any letter. # Constraints: - Words consist of lowercase English letters. - The maximum length of any word is 10,000. - The total number of words added to the data structure will not exceed 500,000. # Example: ```python wd = WordDictionary() wd.add_word(\\"bad\\") wd.add_word(\\"dad\\") wd.add_word(\\"mad\\") assert wd.search(\\"pad\\") == False, \\"Test Case 1 Failed\\" assert wd.search(\\"bad\\") == True, \\"Test Case 2 Failed\\" assert wd.search(\\".ad\\") == True, \\"Test Case 3 Failed\\" assert wd.search(\\"b..\\") == True, \\"Test Case 4 Failed\\" print(\\"All test cases passed.\\") ``` # Implementation: ```python class WordDictionary: def __init__(self): self.root = TrieNode(\\"\\") def add_word(self, word: str) -> None: cur = self.root for letter in word: if letter not in cur.children: cur.children[letter] = TrieNode(letter) cur = cur.children[letter] cur.is_terminal = True def search(self, word: str, node=None) -> bool: cur = node if not cur: cur = self.root for i, letter in enumerate(word): if letter == \\".\\": if i == len(word) - 1: for child in cur.children.values(): if child.is_terminal: return True return False for child in cur.children.values(): if self.search(word[i+1:], child): return True return False if letter not in cur.children: return False cur = cur.children[letter] return cur.is_terminal class TrieNode(object): def __init__(self, letter, is_terminal=False): self.children = {} self.letter = letter self.is_terminal = is_terminal ``` Implement the `WordDictionary` class such that it satisfies the given requirements and constraints. Ensure your solution is well-optimized to handle large inputs efficiently.","solution":"class TrieNode: def __init__(self, letter): self.letter = letter self.children = {} self.is_terminal = False class WordDictionary: def __init__(self): self.root = TrieNode(\\"\\") def add_word(self, word: str) -> None: cur = self.root for letter in word: if letter not in cur.children: cur.children[letter] = TrieNode(letter) cur = cur.children[letter] cur.is_terminal = True def search(self, word: str, node=None) -> bool: cur = node if node else self.root for i, letter in enumerate(word): if letter == \\".\\": return any(self.search(word[i + 1:], child) for child in cur.children.values()) if letter not in cur.children: return False cur = cur.children[letter] return cur.is_terminal"},{"question":"# Context You are working on a software application that processes tree-structured data and need to implement a function that extracts specific paths from this data. Given a binary tree, you need to find all root-to-leaf paths where the sum of node values equals a specified target sum. # Task Write a function `find_paths_with_sum(root, target_sum)` which takes the root of a binary tree and a target sum as inputs and returns a list of all root-to-leaf paths such that the sum of the values in each path equals the target sum. # Input Format - `root`: Node object representing the root of a binary tree. - `target_sum`: Integer representing the required sum of the node values in a path. # Output Format - A list of lists where each inner list represents a path from root to leaf nodes with values summing up to `target_sum`. # Constraints - Node values are integers. - 1 <= number of nodes <= 10^4. - -1000 <= node value, target_sum <= 1000. # Performance Requirements - The solution should have a time complexity of O(N) and space complexity of O(N), where N is the number of nodes in the binary tree. # Example ```python # Given binary tree and target_sum == 22: # 5 # / # 4 8 # / / # 11 13 4 # / / # 7 2 5 1 # # Expected output: # [ # [5, 4, 11, 2], # [5, 8, 4, 5] # ] result = find_paths_with_sum(tree_root, 22) print(result) # Output: [[5, 4, 11, 2], [5, 8, 4, 5]] ``` Complete the function `find_paths_with_sum(root, target_sum)` that meets the requirements mentioned above.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def find_paths_with_sum(root, target_sum): Finds all paths from root to leaf nodes in a binary tree such that the sum of the values in the path equals target_sum. Args: - root (TreeNode): The root node of the binary tree. - target_sum (int): The target sum for the paths. Returns: - List[List[int]]: A list of lists where each list represents a path with the required sum. def dfs(node, current_path, current_sum): if not node: return current_path.append(node.val) current_sum += node.val if not node.left and not node.right and current_sum == target_sum: result.append(list(current_path)) else: if node.left: dfs(node.left, current_path, current_sum) if node.right: dfs(node.right, current_path, current_sum) # backtrack current_path.pop() result = [] dfs(root, [], 0) return result"},{"question":"# Longest Common Substring with Distinct Character Set Problem Statement Given two input strings `s1` and `s2`, you need to find the length of the longest common substring between them. The string `s2` is guaranteed to contain all distinct characters. Implement a function `longest_common_substring(s1, s2)` that returns the length of the longest common substring. Input * `s1`: A string consisting of lower-case English characters. * `s2`: A string consisting of lower-case English characters, with all distinct characters. * Length of `s1` and `s2` will be between 1 and 1000. Output * An integer representing the length of the longest common substring between `s1` and `s2`. Constraints * You need to achieve a time complexity of O(n log n). * Consider edge cases such as empty substrings or no common substring present. Example ```python # Example 1: s1 = \\"abcdxyz\\" s2 = \\"xyzabcd\\" # The longest common substring is \\"abcd\\" or \\"xyz\\", both have length 4. assert longest_common_substring(s1, s2) == 4 # Example 2: s1 = \\"abc\\" s2 = \\"def\\" # There\'s no common substring. assert longest_common_substring(s1, s2) == 0 # Example 3: s1 = \\"abc\\" s2 = \\"bc\\" # The longest common substring is \\"bc\\" which has length 2. assert longest_common_substring(s1, s2) == 2 ```","solution":"def longest_common_substring(s1, s2): Returns the length of the longest common substring between s1 and s2. s2 guarantees all distinct characters. if not s1 or not s2: return 0 len_s1 = len(s1) len_s2 = len(s2) longest = 0 dp = [[0] * (len_s2 + 1) for _ in range(len_s1 + 1)] for i in range(1, len_s1 + 1): for j in range(1, len_s2 + 1): if s1[i - 1] == s2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 longest = max(longest, dp[i][j]) return longest"},{"question":"You are given a grid represented by a 2D list, where: - `0` represents an empty place you can walk on. - `1` represents a building where people reside. - `2` represents an obstacle that you cannot walk through. Your task is to write a function called `shortest_distance` that returns the shortest distance from all buildings to an empty place such that the sum of distances from all buildings to this empty place is minimized. If it is not possible to place the building such that every building can reach it, return `-1`. # Function Signature ```python def shortest_distance(grid: List[List[int]]) -> int: # implementation here ``` # Input * `grid`: A 2D list with size `m x n` (1 ≤ `m, n` ≤ 50) containing values 0, 1, or 2. # Output * Returns an integer representing the minimum sum of distances from all buildings to an empty place or `-1` if such a placement is impossible. # Constraints 1. The grid will contain at least one building. 2. Buildings and obstacles will not change their positions. # Example ```python grid = [ [1, 0, 2, 0, 1], [0, 0, 0, 0, 0], [0, 0, 1, 0, 0] ] assert shortest_distance(grid) == 7 grid = [ [1, 0, 2, 0, 1], [0, 2, 0, 2, 0], [0, 0, 1, 0, 0] ] assert shortest_distance(grid) == -1 ``` # Hints 1. Consider using BFS to compute the distance from each building to all reachable empty places. 2. Keep track of the number of buildings that have contributed to the distance at each empty place to make sure all buildings are considered.","solution":"from typing import List from collections import deque def shortest_distance(grid: List[List[int]]) -> int: def bfs(start_row, start_col): visited = [[False] * cols for _ in range(rows)] distances = [[0] * cols for _ in range(rows)] queue = deque([(start_row, start_col, 0)]) visited[start_row][start_col] = True while queue: row, col, dist = queue.popleft() for d_row, d_col in directions: n_row, n_col = row + d_row, col + d_col if 0 <= n_row < rows and 0 <= n_col < cols and not visited[n_row][n_col] and grid[n_row][n_col] == 0: visited[n_row][n_col] = True distances[n_row][n_col] = dist + 1 queue.append((n_row, n_col, dist + 1)) total_distances[n_row][n_col] += dist + 1 reachable_buildings[n_row][n_col] += 1 rows = len(grid) cols = len(grid[0]) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] total_distances = [[0] * cols for _ in range(rows)] reachable_buildings = [[0] * cols for _ in range(rows)] num_buildings = sum(val == 1 for row in grid for val in row) for r in range(rows): for c in range(cols): if grid[r][c] == 1: bfs(r, c) min_distance = float(\'inf\') for r in range(rows): for c in range(cols): if grid[r][c] == 0 and reachable_buildings[r][c] == num_buildings: min_distance = min(min_distance, total_distances[r][c]) return min_distance if min_distance != float(\'inf\') else -1"},{"question":"You are provided with the skeleton implementation of functions to calculate the minimum depth of a given binary tree. The tree nodes are represented by the `TreeNode` class: ```python class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right ``` Implement a function `find_min_depth(root: TreeNode) -> int` that calculates the minimum depth of the binary tree using an iterative approach. The function should return the minimum depth of the tree. The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node. # Expected Input and Output Formats * **Input**: A binary tree represented by a `TreeNode` object. * **Output**: An integer representing the minimum depth. # Constraints * The number of nodes in the tree is in the range `[0, 10^4]`. * The values of the tree nodes are in the range `[-1000, 1000]`. Example: Consider the following binary tree: ``` 10 / 12 15 / / 25 30 36 / 100 ``` * **Input**: The root node of the above tree. * **Output**: 3 * **Explanation**: The minimum depth path is `10 -> 15 -> 36` which has a length of 3. # Your Task Provide the implementation for the `find_min_depth` function: ```python def find_min_depth(root: TreeNode) -> int: # Your code here pass ``` # Performance Requirements * Optimize your solution to handle up to `10^4` nodes efficiently. * Ensure that your function handles edge cases correctly, such as an empty tree (`root` is `None`).","solution":"from collections import deque class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def find_min_depth(root: TreeNode) -> int: if not root: return 0 queue = deque([(root, 1)]) while queue: node, depth = queue.popleft() # Check if the node is a leaf if not node.left and not node.right: return depth if node.left: queue.append((node.left, depth + 1)) if node.right: queue.append((node.right, depth + 1))"},{"question":"# Constructing Full Binary Tree from Preorder and Postorder Traversals You are given two lists, `preorder` and `postorder`, which denote the preorder and postorder traversal sequences of a full binary tree (a binary tree where every node has either 0 or 2 children). Your task is to reconstruct the original tree and return its inorder traversal. Function Signature: ```python def build_tree(preorder: List[int], postorder: List[int]) -> List[int]: pass ``` Input: * `preorder` - List of integers where each integer represents the node data in preorder sequence. * `postorder` - List of integers where each integer represents the node data in postorder sequence. Output: * Return a list of integers representing the inorder traversal of the constructed binary tree. Constraints: * Both `preorder` and `postorder` lists contain unique integers. * Both lists represent the traversal of the same full binary tree and have a length between 1 to 1000 inclusive. Example: ```python preorder = [1, 2, 4, 8, 9, 5, 3, 6, 7] postorder = [8, 9, 4, 5, 2, 6, 7, 3, 1] # Expected output: [8, 4, 9, 2, 5, 1, 6, 3, 7] ``` Required Knowledge: * Understanding of tree traversals (preorder, postorder, inorder). * Familiarity with recursion and tree node structure. * Time complexity and space complexity analysis. Challenge: Your implementation should run efficiently within the given input constraints while ensuring the correct reconstruction of the tree followed by the accurate computation of its inorder traversal.","solution":"from typing import List class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def build_tree(preorder: List[int], postorder: List[int]) -> List[int]: def build(pre_start, pre_end, post_start, post_end): if pre_start > pre_end: return None root_val = preorder[pre_start] root = TreeNode(root_val) if pre_start == pre_end: return root # the left subtree\'s root value left_subtree_root_val = preorder[pre_start + 1] # find left subtree root in post order L = post_index[left_subtree_root_val] - post_start + 1 root.left = build(pre_start + 1, pre_start + L, post_start, post_start + L - 1) root.right = build(pre_start + L + 1, pre_end, post_start + L, post_end - 1) return root def inorder_traversal(root): if not root: return [] return inorder_traversal(root.left) + [root.val] + inorder_traversal(root.right) # create a mapping from node value to its index in postorder post_index = {val: idx for idx, val in enumerate(postorder)} # build the tree root = build(0, len(preorder) - 1, 0, len(postorder) - 1) # generate the inorder traversal of the built tree return inorder_traversal(root)"},{"question":"Implement a function that sorts a list of floating-point numbers using Bucket Sort. For sorting the elements within each bucket, you should use a sorting algorithm of your choice (not necessarily insertion sort). Ensure your implementation handles edge cases and can efficiently sort the elements. # Function Signature: ```python def bucket_sort_floats(arr: List[float]) -> List[float]: pass ``` # Inputs: * `arr` - a list of floating-point numbers (0 leq text{value} leq 1). # Outputs: * A list of floating-point numbers sorted in ascending order. # Performance Requirements: * The implementation should aim for a time complexity of (O(n log n)) on average. * Space complexity must be (O(n)). # Constraints: * (0 leq text{len(arr)} leq 10^6). * Each element in `arr` is a float between 0 and 1 (inclusive). # Example: ```python >>> bucket_sort_floats([0.25, 0.36, 0.58, 0.41, 0.90, 0.27]) [0.25, 0.27, 0.36, 0.41, 0.58, 0.90] >>> bucket_sort_floats([]) [] >>> bucket_sort_floats([0.50, 0.50, 0.50]) [0.50, 0.50, 0.50] ``` # Notes: * Your solution should handle empty input gracefully. * Consider efficient ways to distribute and sort the elements within the buckets. * Ensure to test your function with edge cases such as all elements being the same or having an empty list.","solution":"from typing import List def bucket_sort_floats(arr: List[float]) -> List[float]: if not arr: return [] n = len(arr) buckets = [[] for _ in range(n)] # Insert elements into buckets for num in arr: index = int(num * n) if index != n: buckets[index].append(num) else: buckets[n-1].append(num) # Sort each bucket for i in range(n): buckets[i].sort() # Concatenate sorted buckets sorted_arr = [] for bucket in buckets: sorted_arr.extend(bucket) return sorted_arr"},{"question":"You are tasked with implementing a function to encode a string using Run-Length Encoding (RLE), and another to decode a string encoded with RLE. These functions will help determine your understanding of common compression techniques and string manipulation in Python. Functions to Implement 1. `def encode_rle(input: str) -> str`: - **Input**: A string `input`. - **Output**: A run-length encoded string. - **Constraints**: - The input will contain only ASCII characters. - The length of the input string will not exceed 10^4 characters. 2. `def decode_rle(input: str) -> str`: - **Input**: A run-length encoded string `input`. - **Output**: The decoded string. - **Constraints**: - The input encoded string will be a valid RLE format string. - The length of the encoded string will not exceed 10^4 characters. Examples - **Encoding** ```python encode_rle(\\"aaabbcccc\\") # Output: \\"3a2b4c\\" encode_rle(\\"\\") # Output: \\"\\" ``` - **Decoding** ```python decode_rle(\\"3a2b4c\\") # Output: \\"aaabbcccc\\" decode_rle(\\"\\") # Output: \\"\\" ``` Requirements - Your implementation should handle the edge cases described in the analysis. - Ensure your code is optimized for performance considering the complexity and constraints provided. - Be mindful of handling any potential errors when decoding, assuming the input to `decode_rle` is always valid but could challenge the algorithm\'s efficiency. The functions should be self-contained, independent of any extraneous input/output operations except for the provided parameters.","solution":"def encode_rle(input: str) -> str: Encode a string using Run-Length Encoding (RLE). if not input: return \\"\\" encoded_string = [] count = 1 for i in range(1, len(input)): if input[i] == input[i - 1]: count += 1 else: encoded_string.append(f\\"{count}{input[i - 1]}\\") count = 1 # Append the last group of characters encoded_string.append(f\\"{count}{input[-1]}\\") return \'\'.join(encoded_string) def decode_rle(input: str) -> str: Decode a Run-Length Encoded (RLE) string. if not input: return \\"\\" decoded_string = [] count = 0 for char in input: if char.isdigit(): count = count * 10 + int(char) else: decoded_string.append(char * count) count = 0 return \'\'.join(decoded_string)"},{"question":"You are given an array of integers. Your task is to implement the Gnome Sort algorithm to sort the array in non-decreasing order. # Requirements * Implement the function `gnome_sort(arr: List[int]) -> List[int]` that sorts the array using Gnome Sort. * The function should return the sorted array. * Ensure your implementation handles the following scenarios: * Empty array. * Array with one element. * Array with duplicate elements. # Input * An array `arr` of length `n` where `0 <= n <= 10^5`. # Output * A sorted array `arr` in non-decreasing order. # Constraints * The elements of the array `arr` will be integers: `-10^6 <= arr[i] <= 10^6`. * Your function should run efficiently for input size up to 100,000. # Example Example 1 * Input: `[34, 2, 10, -9]` * Output: `[-9, 2, 10, 34]` Example 2 * Input: `[1, 2, 3, 4, 5]` * Output: `[1, 2, 3, 4, 5]` # Explanation In Example 1, the array `[34, 2, 10, -9]` is not in order, so after applying Gnome Sort it becomes `[-9, 2, 10, 34]`. In Example 2, the array is already sorted, so the output remains `[1, 2, 3, 4, 5]`. Implement the required function to solve this problem.","solution":"from typing import List def gnome_sort(arr: List[int]) -> List[int]: Sorts the array using Gnome Sort algorithm and returns the sorted array. index = 0 n = len(arr) while index < n: if index == 0 or arr[index] >= arr[index - 1]: index += 1 else: arr[index], arr[index - 1] = arr[index - 1], arr[index] index -= 1 return arr"},{"question":"# Question **Problem Statement**: You are given a `Union` class implementing the Union-Find (Disjoint Set) data structure. Your task is to extend this class to detect cycles in an undirected graph. Given a list of edges where each edge connects two nodes, determine if adding each edge to the graph would create a cycle. Input: - A list of edges `edges`, where each edge is defined as `[u, v]`, representing a connection between node `u` and node `v`. Output: - Return a list of boolean values where `True` indicates the creation of a cycle by adding the corresponding edge, and `False` indicates no cycle. **Constraints**: - The number of nodes `n` is not specified in advance. - The number of edges `m` does not exceed `10^4`. **Performance Requirements**: - Your implementation should be efficient and avoid timeouts for up to `10^4` edges. # Example: Input: ```python edges = [[0, 1], [1, 2], [2, 0], [3, 4], [4, 5], [5, 3]] ``` Output: ```python [False, False, True, False, False, True] ``` **Explanation**: - Adding edge `[0, 1]` connects nodes 0 and 1, no cycle. - Adding edge `[1, 2]` connects nodes 1 and 2, no cycle. - Adding edge `[2, 0]` connects nodes 2 and 0, forming a cycle. - Adding edge `[3, 4]` connects nodes 3 and 4, no cycle. - Adding edge `[4, 5]` connects nodes 4 and 5, no cycle. - Adding edge `[5, 3]` connects nodes 5 and 3, forming a cycle. **Function Signature**: ```python def detect_cycles(edges): pass ``` **Task**: Implement the `detect_cycles` function. Extend the provided `Union` class to support cycle detection in an undirected graph and use it in your function.","solution":"class UnionFind: def __init__(self): self.parent = {} self.rank = {} def find(self, u): if self.parent[u] != u: self.parent[u] = self.find(self.parent[u]) return self.parent[u] def union(self, u, v): root_u = self.find(u) root_v = self.find(v) if root_u == root_v: return False if self.rank[root_u] > self.rank[root_v]: self.parent[root_v] = root_u elif self.rank[root_u] < self.rank[root_v]: self.parent[root_u] = root_v else: self.parent[root_v] = root_u self.rank[root_u] += 1 return True def add(self, u): if u not in self.parent: self.parent[u] = u self.rank[u] = 0 def detect_cycles(edges): uf = UnionFind() result = [] for u, v in edges: uf.add(u) uf.add(v) if not uf.union(u, v): result.append(True) else: result.append(False) return result"},{"question":"You are given an array of integers `nums` where exactly two elements appear only once, and all the other elements appear exactly twice. Write a function `find_unique_elements` to identify the two unique elements. The function should run in linear time and use constant auxiliary space. # Function Signature: ```python def find_unique_elements(nums: List[int]) -> List[int]: ``` # Input: * `nums`: A list of integers (1 <= len(nums) <= 10^5). Each integer will fit within the range of a 32-bit signed integer. # Output: * A list of two integers representing the unique elements. The order of the result is not important. # Constraints: * Time Complexity: O(N) * Space Complexity: O(1) # Example: ```python nums = [1, 2, 1, 3, 2, 5] assert find_unique_elements(nums) == [3, 5] or find_unique_elements(nums) == [5, 3] nums = [-1, 0, -1, 2, 1, 2] assert find_unique_elements(nums) == [0, 1] or find_unique_elements(nums) == [1, 0] ``` # Explanation: 1. **Step 1**: XOR all numbers to find the XOR result of the two unique numbers (A^B). 2. **Step 2**: Isolate the rightmost set bit from the XOR result. 3. **Step 3**: Divide all numbers into two groups based on the isolated bit and XOR the numbers within each group to find the unique elements.","solution":"from typing import List def find_unique_elements(nums: List[int]) -> List[int]: # Step 1: Find the XOR of the two unique numbers xor_result = 0 for num in nums: xor_result ^= num # Step 2: Find the rightmost set bit in xor_result rightmost_set_bit = xor_result & -xor_result # Step 3: Divide numbers into two groups based on the rightmost set bit and XOR them within each group a = 0 b = 0 for num in nums: if num & rightmost_set_bit: a ^= num else: b ^= num return [a, b]"},{"question":"You are given access to a node in the middle of a singly linked list, and you need to delete this node. However, you are not provided with the head of the list, nor is the node the tail. Write a function `delete_node` to accomplish this. # Requirements 1. **Function Signature**: ```python def delete_node(node: Node) -> None: ``` 2. **Input**: - `node` - A non-tail node in a singly linked list. 3. **Output**: - The list should exclude the given node, and no value should be returned. 4. **Constraints**: - You can assume that the node to be deleted is not the tail and has a valid next node. 5. **Error Handling**: - Raise a `ValueError` if `node` is None or `node.next` is None. # Explanation Given a linked list: `1 -> 2 -> 3 -> 4 -> 5` and you have access to node `3`. After calling your function, the linked list should look like `1 -> 2 -> 4 -> 5`. # Function Implementation You should implement the following function to achieve the desired goal: - **delete_node(node)**: - Copy the value of the next node to the current node. - Adjust the next pointer to skip the next node. - Edge cases should raise the appropriate exceptions. # Example ```python # Constructing linked list: 1 -> 2 -> 3 -> 4 head = Node(1) head.next = Node(2) head.next.next = Node(3) head.next.next.next = Node(4) # Assume we are given access to node `3` node_to_delete = head.next.next # Calling your function delete_node(node_to_delete) # New linked list should be: 1 -> 2 -> 4 ``` # Testing - Test the function with a variety of linked lists containing more than two nodes. - Ensure that nodes can be deleted from different positions except the tail.","solution":"class Node: def __init__(self, val: int = 0, next=None): self.val = val self.next = next def delete_node(node: Node) -> None: Deletes a node (except the tail) from a singly linked list. Parameters: node (Node): The node to be deleted Returns: None if node is None or node.next is None: raise ValueError(\\"The given node is not valid, either it\'s None or it\'s the tail node.\\") # Copy the value from the next node into the current node next_node = node.next node.val = next_node.val # Skip the next node node.next = next_node.next # Clear the next node\'s next reference next_node.next = None"},{"question":"# Problem Description You are a network engineer assigned the task of improving data transmission between data centers. Given a network diagram representing data centers and the bandwidth capacities between them, compute the maximum possible data flow from a designated source to a designated sink using the Dinic\'s Algorithm. # Task Write a function `max_flow_dinic` that: - Takes three arguments: 1. `capacity`: A 2D list (NxN grid) where `capacity[i][j]` represents the bandwidth capacity from data center `i` to data center `j`. 2. `source`: An integer representing the index of the source data center. 3. `sink`: An integer representing the index of the sink data center. - Returns an integer representing the maximum possible data flow from `source` to `sink`. # Constraints - All capacities are non-negative integers. - 0 ≤ source, sink < N - N (number of data centers) ≤ 1000 - There can be direct and/or indirect paths between the source and sink. # Example ```python capacity = [ [0, 16, 13, 0, 0, 0], [0, 0, 10, 12, 0, 0], [0, 4, 0, 0, 14, 0], [0, 0, 9, 0, 0, 20], [0, 0, 0, 7, 0, 4], [0, 0, 0, 0, 0, 0] ] source = 0 sink = 5 print(max_flow_dinic(capacity, source, sink)) # Output: 23 ``` # Notes - Efficiently utilize the Dinic Algorithm procedures: BFS for level graph construction and DFS for finding augmenting paths. - Ensure you handle edge cases such as disconnected nodes or paths with zero capacity correctly.","solution":"from collections import deque, defaultdict def max_flow_dinic(capacity, source, sink): class Dinic: def __init__(self, capacity, n): self.capacity = capacity self.level = [-1] * n self.ptr = [0] * n self.n = n self.adj = [[] for _ in range(n)] for u in range(n): for v in range(n): if capacity[u][v] > 0: self.adj[u].append(v) self.adj[v].append(u) def bfs(self, source, sink): self.level = [-1] * self.n self.level[source] = 0 q = deque([source]) while q: u = q.popleft() for v in self.adj[u]: if self.level[v] < 0 and self.capacity[u][v] > 0: self.level[v] = self.level[u] + 1 q.append(v) if v == sink: return True return False def dfs(self, u, sink, flow): if u == sink: return flow while self.ptr[u] < len(self.adj[u]): v = self.adj[u][self.ptr[u]] if self.level[v] == self.level[u] + 1 and self.capacity[u][v] > 0: pushed = self.dfs(v, sink, min(flow, self.capacity[u][v])) if pushed > 0: self.capacity[u][v] -= pushed self.capacity[v][u] += pushed return pushed self.ptr[u] += 1 return 0 def max_flow(self, source, sink): flow = 0 inf = float(\'inf\') while self.bfs(source, sink): self.ptr = [0] * self.n while True: pushed = self.dfs(source, sink, inf) if pushed == 0: break flow += pushed return flow n = len(capacity) dinic = Dinic(capacity, n) return dinic.max_flow(source, sink)"},{"question":"# **Sliding Window Maximum** **Context**: You are developing an application that requires efficient real-time analysis of data streams to monitor peak values over pre-defined sliding windows. To achieve this, you need to implement a function that processes a list of integers and produces the maximum values for each sliding window of a given size. **Task**: Implement a function, `max_sliding_window(arr, k)`, that takes in: 1. A list of integers `arr`. 2. An integer `k` representing the size of the sliding window. Your function should return a list containing the maximum values for each sliding window of size `k`. **Function Signature**: ```python def max_sliding_window(arr, k): # Your implementation here ``` **Input**: - `arr`: A list of integers, with a length of (n) where (0 leq n leq 10^5). - `k`: An integer, the size of the sliding window where (1 leq k leq |arr|). **Output**: - A list of integers representing the maximum values for each sliding window. **Example**: ```python arr = [1, 3, -1, -3, 5, 3, 6, 7] k = 3 # The sliding windows are: [1, 3, -1], [3, -1, -3], [-1, -3, 5], [-3, 5, 3], [5, 3, 6], [3, 6, 7] # Their maximum values are: [3, 3, 5, 5, 6, 7] result = max_sliding_window(arr, k) # [3, 3, 5, 5, 6, 7] ``` **Constraints**: 1. The list `arr` will have at most (10^5) elements. 2. Each element in the list and the value of `k` will be such that (1 leq k leq |arr|). Make sure your solution is optimized for large inputs and consider all possible edge cases.","solution":"from collections import deque def max_sliding_window(arr, k): Returns a list of the maximum values for each sliding window of size k. if not arr: return [] n = len(arr) if k == 1: return arr result = [] deq = deque() # stores indexes of arr in decreasing order for i in range(n): # Remove indices that are out of the current window if deq and deq[0] == i - k: deq.popleft() # Remove elements from back that are less than the current element while deq and arr[deq[-1]] < arr[i]: deq.pop() deq.append(i) # Start adding results to the list for windows of size k if i >= k - 1: result.append(arr[deq[0]]) return result"},{"question":"Merging and Manipulating Intervals You are given a set of intervals, each defined by a start and an end point. Your task is to implement a class to manage these intervals and provide functionalities to determine if a number lies in any interval, and to merge overlapping intervals. # Requirements 1. **Class Definition**: Implement a class `IntervalSet` which maintains a list of interval objects. 2. **Methods**: - **add_interval(start, end)**: Adds a new interval to the set. - **merge_intervals()**: Merges overlapping intervals and updates the interval set. - **contains(value)**: Returns `True` if the value lies within any interval in the set, otherwise returns `False`. - **print_intervals()**: Prints all intervals in the set. # Constraints 1. Each interval is represented by two integers, `start` and `end`, where `start` can be equal to but not greater than `end`. 2. The input values for `start` and `end` are always non-negative integers. # Example ```python # Define IntervalSet class and its methods as specified interval_set.add_interval(1, 3) interval_set.add_interval(2, 6) interval_set.add_interval(8, 10) interval_set.add_interval(15, 18) # Before merging interval_set.print_intervals() # Output: Interval(1, 3), Interval(2, 6), Interval(8, 10), Interval(15, 18) interval_set.merge_intervals() interval_set.print_intervals() # Output: Interval(1, 6), Interval(8, 10), Interval(15, 18) print(interval_set.contains(5)) # Output: True print(interval_set.contains(12)) # Output: False ``` # Implementation ```python class IntervalSet: def __init__(self): self.intervals = [] def add_interval(self, start, end): if start > end: raise ValueError(\\"Start should be less than or equal to End\\") self.intervals.append((start, end)) def merge_intervals(self): if not self.intervals: return self.intervals.sort(key=lambda x: x[0]) merged = [self.intervals[0]] for current in self.intervals[1:]: last_merged = merged[-1] if current[0] <= last_merged[1]: merged[-1] = (last_merged[0], max(last_merged[1], current[1])) else: merged.append(current) self.intervals = merged def contains(self, value): for interval in self.intervals: if interval[0] <= value <= interval[1]: return True return False def print_intervals(self): res = [f\\"Interval({start}, {end})\\" for start, end in self.intervals] print(\\", \\".join(res)) ``` Implement the `IntervalSet` class and ensure it passes the provided example scenario.","solution":"class IntervalSet: def __init__(self): self.intervals = [] def add_interval(self, start, end): if start > end: raise ValueError(\\"Start should be less than or equal to End\\") self.intervals.append((start, end)) def merge_intervals(self): if not self.intervals: return self.intervals.sort(key=lambda x: x[0]) merged = [self.intervals[0]] for current in self.intervals[1:]: last_merged = merged[-1] if current[0] <= last_merged[1]: merged[-1] = (last_merged[0], max(last_merged[1], current[1])) else: merged.append(current) self.intervals = merged def contains(self, value): for interval in self.intervals: if interval[0] <= value <= interval[1]: return True return False def print_intervals(self): res = [f\\"Interval({start}, {end})\\" for start, end in self.intervals] print(\\", \\".join(res))"},{"question":"**Context**: You are a developer working on a geometry toolkit that helps students learn about right-angled triangles. One of the tools you need to create is a function that computes the length of the unknown side of a right-angled triangle given the lengths of the other two sides. **Task**: Implement a function called `find_third_side` that computes the length of the missing side of a right-angled triangle. The function will take three inputs: `side1`, `side2`, and `side3`, two of which will be numeric values and the third will be the string \\"?\\" indicating the unknown side. The function should return the length of the unknown side as a numeric value. # Function signature ```python def find_third_side(side1: Union[float, str], side2: Union[float, str], side3: Union[float, str]) -> float: ``` # Input * `side1`, `side2`, `side3`: Union[float, str] - lengths of the three sides of a right-angled triangle, where exactly one of the values will be the string \\"?\\" indicating the unknown side. # Output * `float` - the length of the unknown side. # Constraints * If the unknown side is the hypotenuse, it will be the longest of the three sides. * The function should handle invalid inputs gracefully by raising a `ValueError`. # Performance Requirements * The function should compute the result in constant time. # Examples ```python assert find_third_side(3, 4, \\"?\\") == 5.0 # missing hypotenuse assert find_third_side(3, \\"?\\", 5) == 4.0 # missing side (other than hypotenuse) assert find_third_side(\\"?\\", 4, 5) == 3.0 # missing side (other than hypotenuse) ``` Implement the `find_third_side` function to complete this task.","solution":"import math from typing import Union def find_third_side(side1: Union[float, str], side2: Union[float, str], side3: Union[float, str]) -> float: Returns the length of the unknown side of a right-angled triangle given the other two sides. # If all the sides are known and none of them is unknown, raise ValueError if isinstance(side1, (int, float)) and isinstance(side2, (int, float)) and isinstance(side3, (int, float)): raise ValueError(\\"One of the sides must be the unknown side.\\") # If two sides are given and the third is unknown known_sides = [side for side in [side1, side2, side3] if isinstance(side, (int, float))] if len(known_sides) != 2: raise ValueError(\\"Exactly two sides must be known with one side indicated by \'?\'\\") if side1 == \\"?\\": # side1 is the unknown if side2 >= side3: raise ValueError(\\"Side1 cannot be longer or equal to the hypotenuse in a right-angled triangle.\\") return math.sqrt(side3**2 - side2**2) if side2 == \\"?\\": # side2 is the unknown if side1 >= side3: raise ValueError(\\"Side2 cannot be longer or equal to the hypotenuse in a right-angled triangle.\\") return math.sqrt(side3**2 - side1**2) if side3 == \\"?\\": # side3 is the unknown (hypotenuse) return math.sqrt(side1**2 + side2**2) raise ValueError(\\"Invalid inputs. Only one side should be marked as unknown with \'?\'\\")"},{"question":"# Printing Nested Data Dictionary Context: You have a hierarchical data structure represented by a nested dictionary in Python. Each key can be linked to a list of values or nested dictionaries, simulating a tree-like structure. Your task is to write a function to print this data structure in a readable manner, following the format established in the provided code snippet. Function Definition: Define a function `structured_print(data_dict)`, which takes a single argument: * `data_dict` (dict): The nested dictionary representing the tree. Expected Output Format: The function should print the tree structure so that each key and its values or nested structures are displayed clearly, following these rules: 1. Print each key followed by \\" -> \\". 2. Print each value or nested dictionary on the same line. 3. If a value is a nested dictionary or list, print it on a new line with the appropriate indentation. Example: Given the input: ```python data_dict = { \'a\': [\'Adam\', {\'Book\': 4}], \'b\': [\'Bill\', {\'Computer\': 5, \'TV\': 6}, \'Jill\', {\'Sports\': 1}], \'c\': [\'Bill\', {\'Sports\': 3}], \'d\': [\'Adam\', {\'Computer\': 3}, \'Quin\', {\'Computer\': 3}], \'e\': [\'Quin\', {\'Book\': 5, \'TV\': 2}], \'f\': [\'Adam\', {\'Computer\': 7}] } ``` The output should be: ``` a -> Adam -> Book -> 4 b -> Bill -> Computer -> 5 -> TV -> 6 -> Jill -> Sports -> 1 c -> Bill -> Sports -> 3 d -> Adam -> Computer -> 3 -> Quin -> Computer -> 3 e -> Quin -> Book -> 5 -> TV -> 2 f -> Adam -> Computer -> 7 ``` Constraints: * The dictionary will not be deeper than two levels. * Dictionary keys and string values will not contain newline characters. * The function should run in O(n) time complexity, where n is the total number of keys and values in the dictionary. Your implementation should consider edge cases and handle them gracefully, ensuring the function does not break with empty or minimally populated dictionaries.","solution":"def structured_print(data_dict): def print_nested(key, value, indent=\\"\\"): if isinstance(value, list): for item in value: if isinstance(item, dict): for sub_key, sub_value in item.items(): print(f\\"{indent}{key} -> {sub_key} -> {sub_value}\\") else: print(f\\"{indent}{key} -> {item}\\") elif isinstance(value, dict): for sub_key, sub_value in value.items(): print(f\\"{indent}{key} -> {sub_key} -> {sub_value}\\") else: print(f\\"{indent}{key} -> {value}\\") for key, value in data_dict.items(): if isinstance(value, list): for item in value: if isinstance(item, dict): for sub_key, sub_value in item.items(): print(f\\"{key} -> {sub_key} -> {sub_value}\\") else: print(f\\"{key} -> {item}\\") else: print(f\\"{key} -> {value}\\")"},{"question":"# Question: Ternary Search Implementation As a software developer at a company that processes large amounts of sorted data, you are tasked with implementing a highly efficient search algorithm to locate specific elements within datasets. You decide to use the ternary search algorithm due to its effectiveness in reducing the number of comparisons needed. Write a function called `ternary_search` that takes four parameters: 1. `left`: an integer representing the left boundary of the array segment to search. 2. `right`: an integer representing the right boundary of the array segment to search. 3. `key`: the value that needs to be searched within the array. 4. `arr`: a sorted list of integers. Your function should return the index of `key` if it\'s found within the array segment defined by `left` and `right` (inclusive). If `key` is not found, return -1. # Input Constraints - `left` and `right` are integers such that (0 leq text{left} leq text{right} < text{len(arr)}). - `arr` is a list of integers, sorted in non-decreasing order. - `key` can be any integer. # Output - Return the index of the key if found, otherwise return -1. # Example ```python # Example 1: arr = [1, 2, 3, 4, 5, 6, 7, 8, 9] key = 5 left = 0 right = len(arr) - 1 print(ternary_search(left, right, key, arr)) # Output: 4 # Example 2: arr = [1, 2, 3, 4, 5, 6, 7, 8, 9] key = 10 left = 0 right = len(arr) - 1 print(ternary_search(left, right, key, arr)) # Output: -1 ``` # Additional Considerations - Make sure your function handles the edge cases effectively, such as when the array is empty or when the key is not present in the array. - Optimize your function to prevent performance degradation when the array is very large.","solution":"def ternary_search(left, right, key, arr): Perform a ternary search on a sorted array to find the index of the key. :param left: int, the left index of the segment to search. :param right: int, the right index of the segment to search. :param key: int, the value to search for. :param arr: list of int, the sorted array. :return: int, the index of the key if found, otherwise -1. while left <= right: mid1 = left + (right - left) // 3 mid2 = right - (right - left) // 3 if arr[mid1] == key: return mid1 if arr[mid2] == key: return mid2 if key < arr[mid1]: right = mid1 - 1 elif key > arr[mid2]: left = mid2 + 1 else: left = mid1 + 1 right = mid2 - 1 return -1"},{"question":"Implement a function `word_pattern` to determine if a string follows a given pattern. The function signature is provided below: ```python def word_pattern(pattern: str, str: str) -> bool: ``` # Input: 1. `pattern`: A string pattern containing only lowercase letters. 2. `str`: A string containing lowercase words separated by a single space. # Output: - A boolean value indicating whether the string follows the given pattern. # Constraints: - The pattern is composed of only lowercase letters. - The string is composed of lowercase words separated by a single space. # Performance Requirements: - The algorithm should run in linear time relative to the number of words in the `str`. # Examples: ```python assert word_pattern(\\"abba\\", \\"dog cat cat dog\\") == True assert word_pattern(\\"abba\\", \\"dog cat cat fish\\") == False assert word_pattern(\\"aaaa\\", \\"dog cat cat dog\\") == False assert word_pattern(\\"abba\\", \\"dog dog dog dog\\") == False ``` # Edge Cases to Consider: - Different lengths of pattern and split words in the string. - Repeating words that do not follow the bijective pattern rules. Implement the function according to the provided specifications and constraints.","solution":"def word_pattern(pattern: str, str: str) -> bool: words = str.split() # Early return if pattern and words differ in length if len(pattern) != len(words): return False # Two dictionaries to maintain bijective mapping between pattern and words pattern_to_word = {} word_to_pattern = {} for p, w in zip(pattern, words): if p in pattern_to_word: if pattern_to_word[p] != w: return False else: pattern_to_word[p] = w if w in word_to_pattern: if word_to_pattern[w] != p: return False else: word_to_pattern[w] = p return True"},{"question":"You are to implement a search function similar to the `strStr()` function, which finds the first occurrence of a substring (`needle`) in another string (`haystack`). If the `needle` is not found in the `haystack`, you should return -1. If the `needle` is an empty string, return 0, as an empty string is trivially found at the beginning of any string. **Function Signature**: ```python def strStr(haystack: str, needle: str) -> int: ``` # Input * `haystack` (string): The string to search within. (1 <= len(haystack) <= 1000) * `needle` (string): The string to find. (0 <= len(needle) <= 1000) # Output * Returns the index of the first occurrence of `needle` in `haystack`. * Returns -1 if `needle` is not part of `haystack`. # Constraints * The function should run efficiently for `haystack` and `needle` of lengths up to 1000. * The algorithm should handle edge cases, including an empty `needle` or a `needle` longer than `haystack`. # Examples ```python # Example 1 haystack = \\"hello\\" needle = \\"ll\\" # Output: 2 # Example 2 haystack = \\"aaaaa\\" needle = \\"bba\\" # Output: -1 # Example 3 haystack = \\"\\" needle = \\"\\" # Output: 0 # Example 4 haystack = \\"abcd\\" needle = \\"\\" # Output: 0 # Example 5 haystack = \\"abc\\" needle = \\"abcd\\" # Output: -1 ``` Implement the function in Python. Ensure your code correctly handles all the edge cases and performs efficiently within the given constraints.","solution":"def strStr(haystack: str, needle: str) -> int: Returns the index of the first occurrence of `needle` in `haystack`. If `needle` is not found, returns -1. If `needle` is an empty string, returns 0. if needle == \\"\\": return 0 return haystack.find(needle)"},{"question":"# Question You are given an integer and need to determine if it is a power of two. Use the principles of bitwise operations to solve this problem efficiently. Function Signature ```python def is_power_of_two(n: int) -> bool: Determines if the given integer n is a power of two. :param n: integer :return: True if n is a power of two, False otherwise ``` Input * An integer `n` (−2<sup>31</sup> ≤ n ≤ 2<sup>31</sup> − 1) Output * Return `True` if `n` is a power of two, otherwise return `False`. Constraints * Your solution should strive for O(1) time complexity. Examples ```python assert is_power_of_two(1) == True assert is_power_of_two(16) == True assert is_power_of_two(218) == False assert is_power_of_two(-16) == False assert is_power_of_two(0) == False ``` Explanation * For example `n = 16`, its binary representation is `10000`, and `16 & (16 - 1)` equals `0`, so it is a power of two. * Similarly, for `n = 218`, its binary representation is `11011010`, and `218 & (218 - 1)` does not equal zero, so it is not a power of two. Scenario You are tasked with optimizing an algorithm used in a CPU scheduler to determine if the number of cycles allocated to a process is a power of two. Write a function to accomplish this task efficiently using bitwise operations.","solution":"def is_power_of_two(n: int) -> bool: Determines if the given integer n is a power of two. :param n: integer :return: True if n is a power of two, False otherwise if n <= 0: return False return (n & (n - 1)) == 0"},{"question":"You are given an absolute path for a file (Unix-style), which may include redundant elements or unnecessary path navigation. You need to simplify this path to its shortest canonical form. # Function Signature ```python def simplify_path(path: str) -> str: ``` # Input * **path**: A string representing the Unix-style path, adhering to the following constraints: * The path must start with a \'/\' (root). * The path may include alphanumeric characters, \'/\', \'.\', and \'..\'. # Output * The simplified, canonical path as a string. # Constraints * The absolute path does not have any invalid characters. * The normalized path should not go above the root directory by following \'..\'. # Edge Cases * Input `\\"/../\\"` should return `\\"/\\"`. * Input `\\"/home//foo/\\"` should return `\\"/home/foo\\"`. # Example ```python assert simplify_path(\\"/home/\\") == \\"/home\\" assert simplify_path(\\"/a/./b/../../c/\\") == \\"/c\\" assert simplify_path(\\"/../\\") == \\"/\\" assert simplify_path(\\"/home//foo/\\") == \\"/home/foo\\" assert simplify_path(\\"/home/../../..\\") == \\"/\\" ``` # Task Implement the `simplify_path` function that receives a Unix-style absolute path and returns its simplified canonical form.","solution":"def simplify_path(path): Given a Unix-style path, this function simplifies it to its shortest canonical form. parts = path.split(\'/\') stack = [] for part in parts: if part == \'..\': if stack: stack.pop() elif part and part != \'.\': stack.append(part) return \'/\' + \'/\'.join(stack)"},{"question":"# Problem Description You have been tasked with writing a function to determine whether the binary representation of a given positive integer consists of alternating bits. Your solution should demonstrate efficient bitwise manipulation. # Task Implement a function `has_alternate_bits(n: int) -> bool` that takes a single integer input `n` and returns `True` if the binary representation of `n` has alternating bits, and `False` otherwise. **Function Signature**: ```python def has_alternate_bits(n: int) -> bool: pass ``` # Input - An integer `n` (1 <= n <= 2^31 - 1). # Output - A boolean value (`True` or `False`). # Constraints - The solution should be efficient in terms of time complexity (optimally O(1)) and space complexity (O(1)). # Examples Example 1 ```plaintext Input: 5 Output: True Explanation: The binary representation of 5 is 101. ``` Example 2 ```plaintext Input: 7 Output: False Explanation: The binary representation of 7 is 111. ``` Example 3 ```plaintext Input: 11 Output: False Explanation: The binary representation of 11 is 1011. ``` Example 4 ```plaintext Input: 10 Output: True Explanation: The binary representation of 10 is 1010. ``` # Note In your implementation: - Consider edge cases such as the smallest number (1) and numbers where all bits except one are the same. - Ensure your implementation handles large integers effectively with minimal performance overhead. - Use bitwise operations to achieve optimal performance. Good luck! Your task is to demonstrate deep understanding and effective use of bitwise operations.","solution":"def has_alternate_bits(n: int) -> bool: Determine if the binary representation of n consists of alternating bits. # First, n XOR (n >> 1) must result in a binary number consisting solely of 1s. x = n ^ (n >> 1) # Checking if x + 1 is a power of 2. A power of 2 in binary is always a single 1 followed by all 0s. return (x & (x + 1)) == 0"},{"question":"# Question: Filter Values within a Specified Range You are given an array of integers and two optional integer values, `min_lim` and `max_lim`. Your task is to implement a function that filters the array and returns a new array containing only the elements that lie within the range `[min_lim, max_lim]`. If `min_lim` is `None`, you should consider the minimum value of the array as the lower limit. Similarly, if `max_lim` is `None`, you should consider the maximum value of the array as the upper limit. Function Signature ```python def limit(arr: List[int], min_lim: Optional[int] = None, max_lim: Optional[int] = None) -> List[int]: pass ``` Input - `arr`: A list of integers `[a1, a2, ..., an]`. - `min_lim`: An optional integer specifying the minimum limit (or `None`). - `max_lim`: An optional integer specifying the maximum limit (or `None`). Output - A list of integers that are within the interval `[min_lim, max_lim]`. Constraints - The input array can be empty. - If both `min_lim` and `max_lim` are `None`, return the sorted array. Examples ```python assert limit([1, 2, 3, 4, 5], None, 3) == [1, 2, 3] assert limit([1, 2, 3, 4, 5], 2, 4) == [2, 3, 4] assert limit([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5] assert limit([], 2, 4) == [] assert limit([10, -5, 2, 11, 6], None, 5) == [-5, 2] ``` Special Note Consider edge cases such as: - What if the array is empty? - What if `min_lim` or `max_lim` is `None`? - How do you handle all elements falling outside the specified limits?","solution":"from typing import List, Optional def limit(arr: List[int], min_lim: Optional[int] = None, max_lim: Optional[int] = None) -> List[int]: if not arr: return [] if min_lim is None: min_lim = min(arr) if max_lim is None: max_lim = max(arr) return [x for x in arr if min_lim <= x <= max_lim] # Example usage: # print(limit([1, 2, 3, 4, 5], None, 3)) # Output: [1, 2, 3] # print(limit([1, 2, 3, 4, 5], 2, 4)) # Output: [2, 3, 4] # print(limit([1, 2, 3, 4, 5])) # Output: [1, 2, 3, 4, 5] # print(limit([], 2, 4)) # Output: [] # print(limit([10, -5, 2, 11, 6], None, 5)) # Output: [-5, 2]"},{"question":"Implementing Pigeonhole Sort Context You are tasked with developing a sorting solution for a set of integers. The data falls within a predictable and small range, so you decide to implement the Pigeonhole Sort algorithm. This algorithm distributes elements into a series of holes (or buckets) and then collects them, ensuring each element is in its correct position. Problem Statement Write a function `pigeonhole_sort(arr: List[int]) -> List[int]` that performs the pigeonhole sort on an array of integers. Function Signature ```python def pigeonhole_sort(arr: List[int]) -> List[int]: ``` Input * `arr`: A list of integers `(-10^6 ≤ arr[i] ≤ 10^6)`, where `1 ≤ len(arr) ≤ 10^5`. Output * Returns a sorted list of integers. Constraints * Your solution must run within O(n + Range) time complexity, where n is the number of elements and Range is the difference between the maximum and minimum values in the array. * Ensure your solution is efficient in terms of space complexity. * Handle negative numbers appropriately. Edge Cases * Handle cases where `arr` is empty. * Handle cases where `arr` contains only one element. * Handle cases with all elements identical. Example ```python # Example 1 input: [8, 3, 2, 7, 4, 6, 8] output: [2, 3, 4, 6, 7, 8, 8] # Example 2 input: [-5, -10, 0, -3, 8, 5, -1, 10] output: [-10, -5, -3, -1, 0, 5, 8, 10] # Example 3 input: [1, 1, 1, 1, 1] output: [1, 1, 1, 1, 1] ``` Notes * Make sure your solution handles the largest possible input size and range efficiently (within the given constraints).","solution":"from typing import List def pigeonhole_sort(arr: List[int]) -> List[int]: if not arr: return [] # Find the minimum and maximum values in the array min_val = min(arr) max_val = max(arr) # Calculate the range of values range_val = max_val - min_val + 1 # Create the pigeonholes (or buckets) holes = [0] * range_val # Populate the pigeonholes for num in arr: holes[num - min_val] += 1 # Collect the sorted elements sorted_arr = [] for index in range(range_val): sorted_arr.extend([index + min_val] * holes[index]) return sorted_arr"},{"question":"# Coding Challenge: kth Smallest Element in a Binary Search Tree Problem Statement You are given the root node of a Binary Search Tree (BST) and an integer `k`. Write a function `kth_smallest(root, k)` that returns the kth smallest element in the Binary Search Tree. Objective Implement a function that efficiently finds the kth smallest element in a BST. Function Signature ```python def kth_smallest(root: Node, k: int) -> int: pass ``` Input - `root`: The root node of the Binary Search Tree. - `k`: An integer representing the order of the smallest element to find (1-based index). Output - Returns the kth smallest element in the Binary Search Tree. Constraints - `1 <= k <= number of nodes in the BST`. - The BST will contain unique integer values. Performance Requirements - The solution must have a time complexity of O(N), where N is the number of nodes in the BST. - The solution must efficiently handle a large BST. Example Consider the BST represented as follows (using level order traversal for simplicity): ``` 100 / 50 150 / / 25 75 125 175 ``` For `k = 2`, the 2nd smallest element is `50`. Edge Cases - The BST is empty. Return `None` or an appropriate message. - k is invalid (greater than the number of nodes). Handle appropriately. Explanation & Hint - Use in-order traversal of the tree as it yields elements in a sorted order. - You can implement this either iteratively or recursively. ```python # You may use the Node class definition provided below: class Node: def __init__(self, val: int, left: \'Node\' = None, right: \'Node\' = None): self.val = val self.left = left self.right = right ``` Good Luck!","solution":"class Node: def __init__(self, val: int, left: \'Node\' = None, right: \'Node\' = None): self.val = val self.left = left self.right = right def kth_smallest(root: Node, k: int) -> int: Returns the k-th smallest element in a BST def in_order_traversal(node): if node: yield from in_order_traversal(node.left) yield node.val yield from in_order_traversal(node.right) for idx, value in enumerate(in_order_traversal(root), start=1): if idx == k: return value"},{"question":"# Question: Implement and Compare String Reversal Methods Given the versatility of methods to reverse a string, your task is to implement four different ways to reverse a string in Python. Afterwards, you must analyze the time and space complexity of each implementation and determine the most efficient method for very large strings. Function Signature You need to implement four separate functions: 1. `def reverse_recursive(s: str) -> str` 2. `def reverse_iterative(s: str) -> str` 3. `def reverse_pythonic(s: str) -> str` 4. `def reverse_ultrapythonic(s: str) -> str` Input - `s` (string): The input string to be reversed. It can be empty, contain special characters, white spaces, or numbers. Output - (string): The reversed string. Example ```python assert reverse_recursive(\\"hello\\") == \\"olleh\\" assert reverse_iterative(\\"world\\") == \\"dlrow\\" assert reverse_pythonic(\\"reverse\\") == \\"esrever\\" assert reverse_ultrapythonic(\\"string\\") == \\"gnirts\\" assert reverse_recursive(\\"\\") == \\"\\" assert reverse_iterative(\\"12345\\") == \\"54321\\" assert reverse_pythonic(\\"a\\") == \\"a\\" assert reverse_ultrapythonic(\\"Test string!\\") == \\"!gnirts tseT\\" ``` Constraints - The string length is within the range `0 <= len(s) <= 10^6`. - The function must handle all edge cases efficiently. - Provide comments explaining the time and space complexity analysis for each method. Additional Notes - Avoid using built-in reversing functions directly in `reverse_recursive` and `reverse_iterative`.","solution":"def reverse_recursive(s: str) -> str: Reverses the string recursively. Time Complexity: O(n), where n is the length of the string Space Complexity: O(n) due to recursion stack if len(s) == 0: return s else: return reverse_recursive(s[1:]) + s[0] def reverse_iterative(s: str) -> str: Reverses the string iteratively. Time Complexity: O(n), where n is the length of the string Space Complexity: O(n) for the reversed string storage reversed_str = \\"\\" for char in s: reversed_str = char + reversed_str return reversed_str def reverse_pythonic(s: str) -> str: Reverses the string using Python\'s slicing feature. Time Complexity: O(n), where n is the length of the string Space Complexity: O(n) for the reversed string storage return s[::-1] def reverse_ultrapythonic(s: str) -> str: Reverses the string using Python\'s built-in reversed function and join. Time Complexity: O(n), where n is the length of the string Space Complexity: O(n) for the reversed string storage return \'\'.join(reversed(s))"},{"question":"You are provided with a partially implemented Bitonic Sort algorithm. Your task is to extend the functionality to handle arrays of arbitrary lengths by padding them to the nearest power of 2 with a special value that does not interfere with the normal sorting process. # Instructions - Implement a function `pad_to_power_of_two` that takes an array and pads it to the nearest power of two using infinity (`float(\'inf\')`). This will help in managing arrays that are not initially of size power of 2. - Modify the `bitonic_sort` method to handle the padding and return only the original elements sorted from the resulting padded array. # Function Signature ```python def pad_to_power_of_two(arr: list) -> list: Pads the input array with `float(\'inf\')` until its length is a power of two. Args: arr (list): The input array to be padded. Returns: list: A new array padded to the nearest power of two length. pass ``` # Bitonic Sort Function Signature Modify the existing `bitonic_sort` function so it can handle the padded array and correctly return only the sorted original elements. # Example ```python input_arr = [3, 7, 2, 8, 1, 5] padded_arr = pad_to_power_of_two(input_arr) # padded_arr should be [3, 7, 2, 8, 1, 5, inf, inf] because 8 is the nearest power of 2 sorted_arr = bitonic_sort(padded_arr) # sorted_arr should return [1, 2, 3, 5, 7, 8] ``` # Constraints - Input array will have at least one element and at most 1000 elements. - Elements in the array can be any integer values. # Notes - Ensure that the padding value does not interfere with the sorting process. - Be sure to strip out the padding values before returning the sorted array.","solution":"import math def pad_to_power_of_two(arr): Pads the input array with `float(\'inf\')` until its length is a power of two. Args: arr (list): The input array to be padded. Returns: list: A new array padded to the nearest power of two length. length = len(arr) next_power_of_two = 1 << (length - 1).bit_length() padded_arr = arr + [float(\'inf\')] * (next_power_of_two - length) return padded_arr def compare_and_swap(arr, i, j, dire): if (dire == 1 and arr[i] > arr[j]) or (dire == 0 and arr[i] < arr[j]): arr[i], arr[j] = arr[j], arr[i] def bitonic_merge(arr, low, cnt, dire): if cnt > 1: k = cnt // 2 for i in range(low, low + k): compare_and_swap(arr, i, i + k, dire) bitonic_merge(arr, low, k, dire) bitonic_merge(arr, low + k, k, dire) def bitonic_sort_util(arr, low, cnt, dire): if cnt > 1: k = cnt // 2 bitonic_sort_util(arr, low, k, 1) # sort in ascending order since dire is 1 bitonic_sort_util(arr, low + k, k, 0) # sort in descending order since dire is 0 bitonic_merge(arr, low, cnt, dire) def bitonic_sort(arr): Bitonic Sort implementation. Args: arr (list): The input array to be sorted. Returns: list: The sorted array. n = len(arr) # Pad the array to the nearest power of two padded_arr = pad_to_power_of_two(arr) bitonic_sort_util(padded_arr, 0, len(padded_arr), 1) # direction 1 means ascending # Strip out the padding values before returning return [x for x in padded_arr if x != float(\'inf\')] # Example usage (uncomment to test) # input_arr = [3, 7, 2, 8, 1, 5] # sorted_arr = bitonic_sort(input_arr) # print(sorted_arr) # [1, 2, 3, 5, 7, 8]"}]'),S={name:"App",components:{PoemCard:A},data(){return{searchQuery:"",visibleCount:4,poemsData:O,isLoading:!1}},computed:{filteredPoems(){const r=this.searchQuery.trim().toLowerCase();return r?this.poemsData.filter(e=>e.question&&e.question.toLowerCase().includes(r)||e.solution&&e.solution.toLowerCase().includes(r)):this.poemsData},displayedPoems(){return this.searchQuery.trim()?this.filteredPoems:this.filteredPoems.slice(0,this.visibleCount)},hasMorePoems(){return!this.searchQuery.trim()&&this.visibleCount<this.poemsData.length}},methods:{async loadMore(){this.isLoading=!0,await new Promise(r=>setTimeout(r,1e3)),this.visibleCount+=4,this.isLoading=!1}}},C={class:"search-container"},F={class:"card-container"},z={key:0,class:"empty-state"},L=["disabled"],R={key:0},Y={key:1};function j(r,e,l,p,s,a){const f=g("PoemCard");return n(),i("section",null,[e[4]||(e[4]=t("div",{class:"top-banner"},[t("div",{class:"top-banner-title"},[t("div",{class:"top-banner-title-text"},"🤔prompts chat🧠")])],-1)),t("div",C,[e[3]||(e[3]=t("span",{class:"search-icon"},"🔍",-1)),_(t("input",{type:"text",class:"search-input","onUpdate:modelValue":e[0]||(e[0]=o=>s.searchQuery=o),placeholder:"Search..."},null,512),[[y,s.searchQuery]]),s.searchQuery?(n(),i("button",{key:0,class:"clear-search",onClick:e[1]||(e[1]=o=>s.searchQuery="")}," ✕ ")):u("",!0)]),t("div",F,[(n(!0),i(b,null,v(a.displayedPoems,(o,m)=>(n(),w(f,{key:m,poem:o},null,8,["poem"]))),128)),a.displayedPoems.length===0?(n(),i("div",z,' No results found for "'+d(s.searchQuery)+'". ',1)):u("",!0)]),a.hasMorePoems?(n(),i("button",{key:0,class:"load-more-button",disabled:s.isLoading,onClick:e[2]||(e[2]=(...o)=>a.loadMore&&a.loadMore(...o))},[s.isLoading?(n(),i("span",Y,"Loading...")):(n(),i("span",R,"See more"))],8,L)):u("",!0)])}const P=c(S,[["render",j],["__scopeId","data-v-86ace5f5"]]),M=JSON.parse('{"title":"","description":"","frontmatter":{"page":true},"headers":[],"relativePath":"library/50.md","filePath":"library/50.md"}'),D={name:"library/50.md"},U=Object.assign(D,{setup(r){return(e,l)=>(n(),i("div",null,[x(P)]))}});export{M as __pageData,U as default};
