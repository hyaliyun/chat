import{_ as m,o as s,c as i,a as t,m as d,t as _,C as h,M as g,U as b,f as l,F as x,p as y,e as v,q as w}from"./chunks/framework.B1z0IdBH.js";const q={name:"PoemCard",props:{poem:{type:Object,required:!0}}},k={class:"poem-container"},T={class:"review"},L={class:"review-title"},N={class:"review-content"};function R(n,e,u,c,r,a){return s(),i("div",k,[t("div",T,[t("div",L,[e[0]||(e[0]=t("span",{class:"icon"},"question:",-1)),d(_(u.poem.question),1)]),e[2]||(e[2]=t("div",{class:"divider"},null,-1)),t("p",N,[e[1]||(e[1]=t("span",{class:"icon"},"answer:",-1)),d(_(u.poem.solution),1)])])])}const A=m(q,[["render",R],["__scopeId","data-v-afa46565"]]),E=JSON.parse(`[{"question":"def solve(grid_data): Given the initial state of the canvas, determine the minimum number of color changes that the painter needs to make to achieve the desired pattern. Input: A list of strings where the first element is the number of test cases (T). For each test case, the next element contains two integers N and M denoting the number of rows and columns of the canvas, and the subsequent N elements are strings representing the grid. Output: A list of integers where each integer represents the minimum number of color changes needed for each test case. Example: >>> solve([\\"2\\", \\"3 3\\", \\"RRB\\", \\"BRB\\", \\"RRB\\", \\"2 2\\", \\"RR\\", \\"BB\\"]) [4, 2] >>> solve([\\"1\\", \\"2 3\\", \\"RBR\\", \\"BBR\\"]) [2] >>> solve([\\"1\\", \\"3 3\\", \\"BRB\\", \\"BRB\\", \\"BRB\\"]) [3] results = [] def calculate_changes(grid, pattern1, pattern2): changes1 = changes2 = 0 for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] != pattern1[i % 2][j % 2]: changes1 += 1 if grid[i][j] != pattern2[i % 2][j % 2]: changes2 += 1 return min(changes1, changes2) T = int(grid_data[0]) index = 1 for _ in range(T): N, M = map(int, grid_data[index].split()) grid = grid_data[index + 1 : index + N + 1] index += N + 1 pattern1 = [['R', 'B'], ['B', 'R']] pattern2 = [['B', 'R'], ['R', 'B']] min_changes = calculate_changes(grid, pattern1, pattern2) results.append(min_changes) return results","solution":"def min_color_changes(T, test_cases): results = [] def calculate_changes(grid, pattern1, pattern2): changes1 = changes2 = 0 for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] != pattern1[i % 2][j % 2]: changes1 += 1 if grid[i][j] != pattern2[i % 2][j % 2]: changes2 += 1 return min(changes1, changes2) for case in test_cases: N, M, grid = case pattern1 = [['R', 'B'], ['B', 'R']] pattern2 = [['B', 'R'], ['R', 'B']] min_changes = calculate_changes(grid, pattern1, pattern2) results.append(min_changes) return results # Function to parse input and call the main function def solve(grid_data): T = int(grid_data[0]) test_cases = [] index = 1 for _ in range(T): N, M = map(int, grid_data[index].split()) grid = grid_data[index + 1 : index + N + 1] test_cases.append((N, M, grid)) index += N + 1 results = min_color_changes(T, test_cases) return results"},{"question":"from typing import List def longest_subarray_with_limit(arr: List[int], K: int) -> int: Given an integer array \`arr\`, return the length of the longest contiguous subarray where the difference between the minimum and maximum values in the subarray is less than or equal to a given integer \`K\`. >>> longest_subarray_with_limit([8, 2, 4, 7], 4) 2 >>> longest_subarray_with_limit([10, 1, 2, 4, 7, 2], 5) 4 >>> longest_subarray_with_limit([4, 2, 2, 2, 4, 4, 2, 2], 0) 3","solution":"from collections import deque from typing import List def longest_subarray_with_limit(arr: List[int], K: int) -> int: min_deque = deque() max_deque = deque() left = 0 max_length = 0 for right in range(len(arr)): while min_deque and arr[right] < arr[min_deque[-1]]: min_deque.pop() while max_deque and arr[right] > arr[max_deque[-1]]: max_deque.pop() min_deque.append(right) max_deque.append(right) while arr[max_deque[0]] - arr[min_deque[0]] > K: left += 1 if left > min_deque[0]: min_deque.popleft() if left > max_deque[0]: max_deque.popleft() max_length = max(max_length, right - left + 1) return max_length"},{"question":"def count_valid_groups(population): Returns the number of valid groups that can be formed. Each group should consist of exactly two animals from two different species. >>> count_valid_groups([2, 3, 4]) 26 >>> count_valid_groups([1, 1]) 1 >>> count_valid_groups([2, 2]) 4 >>> count_valid_groups([10**9, 10**9, 10**9]) 3000000000000000000 >>> count_valid_groups([1, 10**9]) 1000000000 >>> count_valid_groups([3, 6, 8, 10]) 229 >>> count_valid_groups([1, 2, 3, 4, 5]) 0","solution":"def count_valid_groups(population): Returns the number of valid groups that can be formed. Each group should consist of exactly two animals from two different species. total_groups = 0 n = len(population) for i in range(n): for j in range(i + 1, n): total_groups += population[i] * population[j] return total_groups"},{"question":"def is_right_angle(x1, y1, x2, y2, x3, y3): Returns \\"RIGHT\\" if the points A(x1, y1), B(x2, y2), and C(x3, y3) form a right-angled triangle, otherwise returns \\"NOT RIGHT\\". pass def check_datasets(datasets): Given a list of datasets, each containing the coordinates of three points, returns a list of results where each result is either \\"RIGHT\\" or \\"NOT RIGHT\\". >>> check_datasets([(0, 0, 3, 0, 0, 4), (1, 1, 4, 5, 6, 1), (0, 0, 1, 1, 2, 2)]) [\\"RIGHT\\", \\"NOT RIGHT\\", \\"NOT RIGHT\\"] >>> check_datasets([(0, 0, 1, 0, 0, 1), (2, 3, 5, 7, 8, 3)]) [\\"RIGHT\\", \\"NOT RIGHT\\"] pass from is_right_angle_check import is_right_angle, check_datasets def test_is_right_angle(): assert is_right_angle(0, 0, 3, 0, 0, 4) == \\"RIGHT\\" assert is_right_angle(1, 1, 4, 5, 6, 1) == \\"NOT RIGHT\\" assert is_right_angle(0, 0, 1, 1, 2, 2) == \\"NOT RIGHT\\" assert is_right_angle(0, 0, 1, 0, 0, 1) == \\"RIGHT\\" assert is_right_angle(2, 3, 5, 7, 8, 3) == \\"NOT RIGHT\\" def test_check_datasets(): datasets = [ (0, 0, 3, 0, 0, 4), (1, 1, 4, 5, 6, 1), (0, 0, 1, 1, 2, 2) ] assert check_datasets(datasets) == [\\"RIGHT\\", \\"NOT RIGHT\\", \\"NOT RIGHT\\"] datasets = [ (0, 0, 1, 0, 0, 1), (2, 3, 5, 7, 8, 3) ] assert check_datasets(datasets) == [\\"RIGHT\\", \\"NOT RIGHT\\"]","solution":"def is_right_angle(x1, y1, x2, y2, x3, y3): Returns \\"RIGHT\\" if the points A(x1, y1), B(x2, y2), and C(x3, y3) form a right-angled triangle, otherwise returns \\"NOT RIGHT\\". def dist_sq(xa, ya, xb, yb): return (xb - xa) ** 2 + (yb - ya) ** 2 a2 = dist_sq(x2, y2, x3, y3) b2 = dist_sq(x1, y1, x3, y3) c2 = dist_sq(x1, y1, x2, y2) if a2 + b2 == c2 or a2 + c2 == b2 or b2 + c2 == a2: return \\"RIGHT\\" else: return \\"NOT RIGHT\\" def check_datasets(datasets): results = [] for dataset in datasets: x1, y1, x2, y2, x3, y3 = dataset result = is_right_angle(x1, y1, x2, y2, x3, y3) results.append(result) return results"},{"question":"def count_palindromic_numbers(a: int, b: int) -> int: Returns the count of palindromic numbers within the range [a, b]. >>> count_palindromic_numbers(1, 10) 9 >>> count_palindromic_numbers(100, 200) 10 >>> count_palindromic_numbers(111, 111) 1 >>> count_palindromic_numbers(123, 130) 0 >>> count_palindromic_numbers(1, 100000) 1099 >>> count_palindromic_numbers(200, 100) 0","solution":"def count_palindromic_numbers(a, b): Returns the count of palindromic numbers within the range [a, b]. count = 0 for num in range(a, b + 1): if str(num) == str(num)[::-1]: count += 1 return count"},{"question":"def sum_submatrix(matrix, r1, c1, r2, c2): Calculate the sum of items in a sub-matrix defined by the top-left (r1, c1) and bottom-right (r2, c2) corners. >>> matrix = [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ] >>> sum_submatrix(matrix, 1, 1, 2, 2) 28 >>> sum_submatrix(matrix, 0, 0, 2, 2) 45 >>> sum_submatrix(matrix, 0, 0, 0, 0) 1 >>> sum_submatrix(matrix, 0, 1, 0, 2) 5 >>> matrix = [ ... [5] ... ] >>> sum_submatrix(matrix, 0, 0, 0, 0) 5 >>> matrix = [ ... [3, 8, 4] ... ] >>> sum_submatrix(matrix, 0, 0, 0, 2) 15 >>> sum_submatrix(matrix, 0, 1, 0, 1) 8 >>> matrix = [ ... [3], ... [2], ... [10] ... ] >>> sum_submatrix(matrix, 0, 0, 2, 0) 15 >>> sum_submatrix(matrix, 1, 0, 1, 0) 2","solution":"def sum_submatrix(matrix, r1, c1, r2, c2): Calculate the sum of items in a sub-matrix defined by the top-left (r1, c1) and bottom-right (r2, c2) corners. submatrix_sum = 0 for i in range(r1, r2 + 1): for j in range(c1, c2 + 1): submatrix_sum += matrix[i][j] return submatrix_sum"},{"question":"def max_profit(prices): Simulates a simplified stock trading strategy and determines the maximum possible profit. Args: prices (list of int): A list of integers representing stock prices where the i-th element is the price of the stock on the i-th day. Returns: int: The maximum profit you can achieve. Examples: >>> max_profit([7, 1, 5, 3, 6, 4]) 7 >>> max_profit([1, 2, 3, 4, 5]) 4 >>> max_profit([7, 6, 4, 3, 1]) 0","solution":"def max_profit(prices): Returns the maximum profit that can be made by buying and selling the stock where you can buy and sell the stock multiple times. if len(prices) < 2: return 0 max_profit = 0 for i in range(1, len(prices)): if prices[i] > prices[i - 1]: max_profit += prices[i] - prices[i - 1] return max_profit"},{"question":"def num_different_rectangular_plots(W: int, H: int) -> int: Returns the total number of different rectangular plots that can be created in a WxH garden. :param W: Width of the garden (1 ≤ W ≤ 1000) :param H: Height of the garden (1 ≤ H ≤ 1000) :return: Total number of different rectangular plots >>> num_different_rectangular_plots(2, 2) 9 >>> num_different_rectangular_plots(3, 2) 18 >>> num_different_rectangular_plots(1, 1) 1 >>> num_different_rectangular_plots(3, 3) 36 >>> num_different_rectangular_plots(4, 4) 100","solution":"def num_different_rectangular_plots(W, H): Returns the total number of different rectangular plots that can be created in a WxH garden. :param W: Width of the garden (1 ≤ W ≤ 1000) :param H: Height of the garden (1 ≤ H ≤ 1000) :return: Total number of different rectangular plots total_plots = 0 for width in range(1, W+1): for height in range(1, H+1): total_plots += (W - width + 1) * (H - height + 1) return total_plots"},{"question":"def unique_paths(m: int, n: int) -> int: Calculate the number of unique paths from the top-left corner to the bottom-right corner of an m x n grid. The robot can only move down or right at any point in time. >>> unique_paths(3, 7) == 28 >>> unique_paths(3, 3) == 6 >>> unique_paths(1, 1) == 1 >>> unique_paths(2, 2) == 2 >>> unique_paths(5, 5) == 70 >>> unique_paths(7, 3) == 28 >>> unique_paths(10, 10) == 48620 >>> unique_paths(100, 100) == 22750883079422934966181954039568885395604168260154104734000","solution":"def unique_paths(m: int, n: int) -> int: Calculate the number of unique paths from the top-left corner to the bottom-right corner of an m x n grid. The robot can only move down or right at any point in time. # Create a 2D array \`dp\` where dp[i][j] represents the number of unique paths to reach cell (i, j). dp = [[1] * n for _ in range(m)] for i in range(1, m): for j in range(1, n): dp[i][j] = dp[i-1][j] + dp[i][j-1] return dp[m-1][n-1]"},{"question":"def isStrongPassword(password: str) -> bool: Determines whether the given password is strong based on predefined criteria. Args: password (str): The password to be checked. Returns: bool: True if the password is strong, otherwise False. Examples: >>> isStrongPassword(\\"Abcdef1!\\") True >>> isStrongPassword(\\"abcdef1!\\") False >>> isStrongPassword(\\"Abcdefgh\`\\") False >>> isStrongPassword(\\"Abcdef\\") False >>> isStrongPassword(\\"A1!aA1!a\\") True","solution":"def isStrongPassword(password): Determines whether the given password is strong based on predefined criteria. Args: password (str): The password to be checked. Returns: bool: True if the password is strong, otherwise False. if len(password) < 8: return False has_lower = any(c.islower() for c in password) has_upper = any(c.isupper() for c in password) has_digit = any(c.isdigit() for c in password) has_special = any(c in \\"!@#%^&*()-+\\" for c in password) return all([has_lower, has_upper, has_digit, has_special])"},{"question":"def sum_of_digits(n: int) -> int: Returns the sum of digits of the given number n. >>> sum_of_digits(1) 1 >>> sum_of_digits(4) 4 >>> sum_of_digits(16) 7 >>> sum_of_digits(25) 7 >>> sum_of_digits(100) 1 pass # Implement this function def generate_sequence(n: int) -> List[int]: Generates the first n terms of the sequence where each term is the sum of the digits of the square of the index of that term. >>> generate_sequence(5) [1, 4, 9, 7, 7] >>> generate_sequence(10) [1, 4, 9, 7, 7, 9, 13, 10, 9, 1] >>> generate_sequence(1) [1] pass # Implement this function if __name__ == \\"__main__\\": n = int(input().strip()) sequence = generate_sequence(n) print(\\" \\".join(map(str, sequence)))","solution":"def sum_of_digits(n): Returns the sum of digits of the given number n. return sum(int(digit) for digit in str(n)) def generate_sequence(n): Generates the first n terms of the sequence where each term is the sum of the digits of the square of the index of that term. sequence = [] for k in range(1, n+1): term = sum_of_digits(k ** 2) sequence.append(term) return sequence if __name__ == \\"__main__\\": n = int(input().strip()) sequence = generate_sequence(n) print(\\" \\".join(map(str, sequence)))"},{"question":"def vending_machine(commands): Simulates a vending machine operation. Processes a series of commands to dispense products or add items to the machine, tracks the stock of each item, and maintains a balance of the total revenue generated. The initial stock and prices are as follows: - Soda: 1.50 - Chips: 2.00 - Candy: 1.25 The machine only accepts whole dollar bills (i.e., 1, 2, 5, 10, 20). Commands to the machine: 1. \\"ADD item count\\": Adds the specified count of the item to the machine. 2. \\"REMOVE item count\\": Removes the specified count of the item, if available. 3. \\"BUY item amount\\": Dispenses the item if at least the exact amount is provided (no change given); prints \\"Insufficient funds\\" otherwise. 4. \\"INVENTORY\\": Prints current stock of each item. 5. \\"REVENUE\\": Prints total revenue generated so far. The series of commands ends with the line \\"END\\". Args: - commands (List[str]): List of command strings to operate the vending machine. Example usage: >>> vending_machine([ ... \\"ADD Soda 10\\", ... \\"BUY Soda 2\\", ... \\"REMOVE Candy 5\\", ... \\"INVENTORY\\", ... \\"REVENUE\\", ... \\"END\\" ... ]) Output: Added 10 Soda(s) Dispensed 1 Soda Insufficient funds Removed 0 Candy(s) Soda: 9, Chips: 0, Candy: 0 Total revenue: 1.50 pass def test_vending_machine_add_and_inventory(capsys): commands = [ \\"ADD Soda 10\\", \\"INVENTORY\\", \\"END\\" ] vending_machine(commands) captured = capsys.readouterr() assert \\"Added 10 Soda(s)\\" in captured.out assert \\"Soda: 10, Chips: 0, Candy: 0\\" in captured.out def test_vending_machine_buy(capsys): commands = [ \\"ADD Soda 10\\", \\"BUY Soda 2\\", \\"INVENTORY\\", \\"REVENUE\\", \\"END\\" ] vending_machine(commands) captured = capsys.readouterr() assert \\"Added 10 Soda(s)\\" in captured.out assert \\"Dispensed 1 Soda\\" in captured.out assert \\"Soda: 9, Chips: 0, Candy: 0\\" in captured.out assert \\"Total revenue: 1.50\\" in captured.out def test_vending_machine_insufficient_funds(capsys): commands = [ \\"ADD Soda 10\\", \\"BUY Soda 1\\", \\"INVENTORY\\", \\"REVENUE\\", \\"END\\" ] vending_machine(commands) captured = capsys.readouterr() assert \\"Insufficient funds\\" in captured.out def test_vending_machine_remove(capsys): commands = [ \\"ADD Candy 5\\", \\"REMOVE Candy 3\\", \\"REMOVE Candy 3\\", \\"INVENTORY\\", \\"END\\" ] vending_machine(commands) captured = capsys.readouterr() assert \\"Removed 3 Candy(s)\\" in captured.out assert \\"Removed 2 Candy(s)\\" in captured.out assert \\"Candy: 0\\" in captured.out def test_vending_machine_end(capsys): commands = [ \\"ADD Chips 3\\", \\"REVENUE\\", \\"END\\", \\"INVENTORY\\" # this command should not be executed ] vending_machine(commands) captured = capsys.readouterr() assert \\"Total revenue: 0.00\\" in captured.out assert \\"Chips: 3\\" not in captured.out","solution":"def vending_machine(commands): # Initial stock and prices inventory = { \\"Soda\\": {\\"stock\\": 0, \\"price\\": 1.50}, \\"Chips\\": {\\"stock\\": 0, \\"price\\": 2.00}, \\"Candy\\": {\\"stock\\": 0, \\"price\\": 1.25} } total_revenue = 0.0 for command in commands: parts = command.split() action = parts[0] if action == \\"ADD\\": item = parts[1] count = int(parts[2]) inventory[item][\\"stock\\"] += count print(f\\"Added {count} {item}(s)\\") elif action == \\"REMOVE\\": item = parts[1] count = int(parts[2]) actual_removed = min(count, inventory[item][\\"stock\\"]) inventory[item][\\"stock\\"] -= actual_removed print(f\\"Removed {actual_removed} {item}(s)\\") elif action == \\"BUY\\": item = parts[1] amount = float(parts[2]) if amount >= inventory[item][\\"price\\"] and inventory[item][\\"stock\\"] > 0: inventory[item][\\"stock\\"] -= 1 total_revenue += inventory[item][\\"price\\"] print(\\"Dispensed 1 \\" + item) else: print(\\"Insufficient funds\\") elif action == \\"INVENTORY\\": print(\\", \\".join(f\\"{k}: {v['stock']}\\" for k, v in inventory.items())) elif action == \\"REVENUE\\": print(f\\"Total revenue: {total_revenue:.2f}\\") elif action == \\"END\\": break"},{"question":"def process_commands(commands: List[str]) -> List[str]: Processes a sequence of commands to manipulate a list of integers and performs the specified operations. Commands: - \\"ADD x\\" - adds the integer x to the end of the list. - \\"REMOVE x\\" - removes the first occurrence of the integer x from the list. If x is not in the list, ignore the command. - \\"PRINT\\" - prints the current state of the list. >>> process_commands([ ... \\"ADD 5\\", ... \\"ADD 3\\", ... \\"PRINT\\", ... \\"REMOVE 5\\", ... \\"PRINT\\", ... \\"REMOVE 10\\", ... \\"ADD -2\\", ... \\"PRINT\\", ... \\"END\\" ... ]) [\\"[5, 3]\\", \\"[3]\\", \\"[3, -2]\\"] >>> process_commands([ ... \\"ADD 1\\", ... \\"ADD 2\\", ... \\"ADD 3\\", ... \\"PRINT\\", ... \\"REMOVE 2\\", ... \\"PRINT\\", ... \\"REMOVE 1\\", ... \\"REMOVE 3\\", ... \\"PRINT\\", ... \\"END\\" ... ]) [\\"[1, 2, 3]\\", \\"[1, 3]\\", \\"[]\\"] >>> process_commands([ ... \\"ADD 5\\", ... \\"ADD 5\\", ... \\"ADD 5\\", ... \\"REMOVE 5\\", ... \\"PRINT\\", ... \\"END\\" ... ]) [\\"[5, 5]\\"] >>> process_commands([\\"PRINT\\", \\"END\\"]) [\\"[]\\"] >>> process_commands([\\"ADD 10\\", \\"REMOVE 10\\", \\"END\\"]) []","solution":"def process_commands(commands): lst = [] results = [] for command in commands: if command == \\"END\\": break action = command.split() if action[0] == \\"ADD\\": lst.append(int(action[1])) elif action[0] == \\"REMOVE\\": try: lst.remove(int(action[1])) except ValueError: pass elif action[0] == \\"PRINT\\": results.append(str(lst)) return results"},{"question":"def find_smallest_missing_positive_number(n: int, arr: List[int]) -> int: Find the smallest positive integer that is not present in the array. Parameters: n (int): The length of the array. arr (list of int): The array of positive integers. Returns: int: The smallest positive integer missing from the array. Examples: >>> find_smallest_missing_positive_number(5, [1, 3, 6, 4, 1, 2]) 5 >>> find_smallest_missing_positive_number(3, [1, 2, 3]) 4 >>> find_smallest_missing_positive_number(3, [5, 7, 9]) 1","solution":"def find_smallest_missing_positive_number(n, arr): Find the smallest positive integer that is not present in the array. Parameters: n (int): The length of the array. arr (list of int): The array of positive integers. Returns: int: The smallest positive integer missing from the array. # Create a set from the array for O(1) lookups num_set = set(arr) # Start checking from 1 upwards smallest_missing = 1 while smallest_missing in num_set: smallest_missing += 1 return smallest_missing"},{"question":"def check_balance(s: str) -> str: Checks if the braces in the string are balanced. >>> check_balance(\\"{int x = {10}; if (x > 0) { x -= 1; }}\\") == \\"Balanced\\" >>> check_balance(\\"function() { if (something) { do_something(); }\\") == \\"Not Balanced\\" >>> check_balance(\\"{[()]}\\") == \\"Balanced\\" >>> check_balance(\\"}{\\") == \\"Not Balanced\\" >>> check_balance(\\"{}\\") == \\"Balanced\\" >>> check_balance(\\"{\\") == \\"Not Balanced\\" >>> check_balance(\\"}\\") == \\"Not Balanced\\" >>> check_balance(\\"abc def ghi\\") == \\"Balanced\\" >>> check_balance(\\"{{{{{{{\\") == \\"Not Balanced\\" >>> check_balance(\\"}}}}}}}\\") == \\"Not Balanced\\"","solution":"def check_balance(s): Checks if the braces in the string are balanced. stack = [] for char in s: if char == '{': stack.append(char) elif char == '}': if not stack: return \\"Not Balanced\\" stack.pop() return \\"Balanced\\" if not stack else \\"Not Balanced\\" # Example usage # print(check_balance(\\"{int x = {10}; if (x > 0) { x -= 1; }}\\")) # Output: Balanced"},{"question":"def max_concurrent_requests(log_entries: List[str]) -> int: Determine the maximum number of concurrent requests on any server over any one second time interval. Args: log_entries: A list of timestamps representing the time at which each request was received. Returns: An integer representing the maximum number of requests that occurred in any one-second interval. >>> max_concurrent_requests([ ... \\"2023-10-17 12:35:04\\", ... \\"2023-10-17 12:35:04\\", ... \\"2023-10-17 12:35:04\\", ... \\"2023-10-17 12:35:05\\", ... \\"2023-10-17 12:35:06\\" ... ]) 3 >>> max_concurrent_requests([ ... \\"2023-10-17 12:35:01\\", ... \\"2023-10-17 12:35:01\\", ... \\"2023-10-17 12:35:01\\", ... \\"2023-10-17 12:35:02\\", ... \\"2023-10-17 12:35:03\\", ... \\"2023-10-17 12:35:03\\", ... \\"2023-10-17 12:35:03\\" ... ]) 3","solution":"def max_concurrent_requests(log_entries): from collections import defaultdict request_counts = defaultdict(int) for entry in log_entries: request_counts[entry] += 1 return max(request_counts.values())"},{"question":"def length_of_longest_increasing_subsequence(n: int, sequence: List[int]) -> int: Determine the length of the longest subsequence in which the elements are in strictly increasing order. :param n: Integer, the length of the sequence. :param sequence: List of integers, the sequence of integers. :return: Integer, the length of the longest increasing subsequence. >>> length_of_longest_increasing_subsequence(8, [10, 22, 9, 33, 21, 50, 41, 60]) 5 >>> length_of_longest_increasing_subsequence(5, [5, 4, 3, 2, 1]) 1 >>> length_of_longest_increasing_subsequence(6, [5, 1, 3, 7, 4, 8]) 4 # Unit tests def test_length_of_longest_increasing_subsequence_basic(): assert length_of_longest_increasing_subsequence(8, [10, 22, 9, 33, 21, 50, 41, 60]) == 5 def test_length_of_longest_increasing_subsequence_single_element(): assert length_of_longest_increasing_subsequence(1, [10]) == 1 def test_length_of_longest_increasing_subsequence_decreasing(): assert length_of_longest_increasing_subsequence(5, [5, 4, 3, 2, 1]) == 1 def test_length_of_longest_increasing_subsequence_same_elements(): assert length_of_longest_increasing_subsequence(5, [2, 2, 2, 2, 2]) == 1 def test_length_of_longest_increasing_subsequence_mixed_sequence(): assert length_of_longest_increasing_subsequence(6, [5, 1, 3, 7, 4, 8]) == 4 def test_length_of_longest_increasing_subsequence_empty(): assert length_of_longest_increasing_subsequence(0, []) == 0 def test_length_of_longest_increasing_subsequence_two_elements(): assert length_of_longest_increasing_subsequence(2, [1, 2]) == 2 assert length_of_longest_increasing_subsequence(2, [2, 1]) == 1","solution":"def length_of_longest_increasing_subsequence(n, sequence): Returns the length of the longest subsequence in which the elements are in strictly increasing order. :param n: Integer, the length of the sequence. :param sequence: List of integers, the sequence for which to find the longest increasing subsequence. :return: Integer, the length of the longest increasing subsequence. if n == 0: return 0 lis = [1] * n # Initialize LIS values for all indexes # Compute optimized LIS values for i in range(1, n): for j in range(0, i): if sequence[i] > sequence[j] and lis[i] < lis[j] + 1: lis[i] = lis[j] + 1 # Return the maximum value in lis[] return max(lis)"},{"question":"from typing import List def min_distance(n: int, m: int, grid: List[List[int]]) -> int: Calculate the minimum distance required to get from the top-left corner of the grid to the bottom-right corner. A cell with 1 represents an obstacle and a cell with 0 represents an open space. If it is not possible to reach the bottom-right corner, return -1. Args: n (int): number of rows in the grid m (int): number of columns in the grid grid (List[List[int]]): the grid itself Returns: int: the minimum distance required to get from the top-left to the bottom-right corner, or -1 if it is not possible. Examples: >>> min_distance(5, 5, [[0, 1, 0, 0, 0], [0, 1, 0, 1, 0], [0, 0, 0, 1, 0], [1, 1, 0, 1, 0], [0, 0, 0, 0, 0]]) 8 >>> min_distance(5, 5, [[0, 1, 0, 1, 0], [1, 1, 0, 1, 0], [0, 0, 0, 1, 1], [0, 1, 1, 0, 0], [0, 0, 0, 1, 0]]) -1 # Test cases def test_example_1(): n = 5 m = 5 grid = [ [0, 1, 0, 0, 0], [0, 1, 0, 1, 0], [0, 0, 0, 1, 0], [1, 1, 0, 1, 0], [0, 0, 0, 0, 0] ] assert min_distance(n, m, grid) == 8 def test_example_2(): n = 5 m = 5 grid = [ [0, 1, 0, 1, 0], [1, 1, 0, 1, 0], [0, 0, 0, 1, 1], [0, 1, 1, 0, 0], [0, 0, 0, 1, 0] ] assert min_distance(n, m, grid) == -1 def test_single_cell_open(): n = 1 m = 1 grid = [ [0] ] assert min_distance(n, m, grid) == 0 def test_single_cell_blocked(): n = 1 m = 1 grid = [ [1] ] assert min_distance(n, m, grid) == -1 def test_no_path(): n = 3 m = 3 grid = [ [0, 1, 1], [1, 0, 1], [1, 1, 0] ] assert min_distance(n, m, grid) == -1 def test_clear_path(): n = 3 m = 3 grid = [ [0, 0, 0], [0, 0, 0], [0, 0, 0] ] assert min_distance(n, m, grid) == 4","solution":"from collections import deque def min_distance(n, m, grid): if grid[0][0] == 1 or grid[n-1][m-1] == 1: return -1 directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([(0, 0, 0)]) # (row, col, distance) visited = [[False for _ in range(m)] for _ in range(n)] visited[0][0] = True while queue: row, col, dist = queue.popleft() if row == n-1 and col == m-1: return dist for dr, dc in directions: new_row, new_col = row + dr, col + dc if 0 <= new_row < n and 0 <= new_col < m and not visited[new_row][new_col] and grid[new_row][new_col] == 0: queue.append((new_row, new_col, dist + 1)) visited[new_row][new_col] = True return -1"},{"question":"def rotate_image(image: List[List[int]], k: int) -> List[List[int]]: Rotates the image k times by 90 degrees clockwise. Parameters: image (list of list of int): The input 2D list representing the image. k (int): The number of times to rotate the image by 90 degrees clockwise. Returns: list of list of int: The rotated image. Examples: >>> rotate_image([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 1) [[7, 4, 1], [8, 5, 2], [9, 6, 3]] >>> rotate_image([[1, 2], [3, 4], [5, 6]], 2) [[6, 5], [4, 3], [2, 1]]","solution":"def rotate_image(image, k): Rotates the image k times by 90 degrees clockwise. Parameters: image (list of list of int): The input 2D list representing the image. k (int): The number of times to rotate the image by 90 degrees clockwise. Returns: list of list of int: The rotated image. if not image or k == 0: return image k %= 4 # Only need to consider up to 3 rotations since 4 rotations is a full cycle for _ in range(k): image = list(zip(*image[::-1])) image = [list(row) for row in image] return image"},{"question":"def is_valid_hex(string: str) -> bool: Returns True if the provided string is a valid hexadecimal number, otherwise returns False. >>> is_valid_hex(\\"0x1a3f\\") True >>> is_valid_hex(\\"0X1A3F\\") True >>> is_valid_hex(\\"1A3F\\") False >>> is_valid_hex(\\"0X1G3D\\") False >>> is_valid_hex(\\"0x\\") False >>> is_valid_hex(\\"0X123\\") True >>> is_valid_hex(\\"0xG\\") False >>> is_valid_hex(\\"0xA\\") True >>> is_valid_hex(\\"0X5B6\\") True >>> is_valid_hex(\\"xyz\\") False","solution":"def is_valid_hex(string: str) -> bool: Returns True if the provided string is a valid hexadecimal number, otherwise returns False. # Check if the string starts with the prefix \\"0x\\" or \\"0X\\" if string.startswith(\\"0x\\") or string.startswith(\\"0X\\"): # Check if every character after the prefix is a valid hex digit hex_digits = set(\\"0123456789abcdefABCDEF\\") for char in string[2:]: if char not in hex_digits: return False # Validate if there's at least one digit after the prefix return len(string) > 2 return False"},{"question":"from typing import List def find_zero_sum_subset(numbers: List[int]) -> None: Determine whether there exists a subset of integers that add up to zero, and print the subset if it exists. >>> find_zero_sum_subset([3, -2, 1, -4, 2]) Yes 3 -2 -1 >>> find_zero_sum_subset([1, 2, 3, 4, 5]) No subset found >>> find_zero_sum_subset([0]) Yes 0 >>> find_zero_sum_subset([0, 0, 0]) Yes 0 0 0 >>> find_zero_sum_subset([-3, 1, 2]) Yes -3 1 2 >>> find_zero_sum_subset([1000, -1000, 500, -500]) Yes 1000 -1000 # Implement the function here","solution":"from itertools import combinations def find_zero_sum_subset(numbers): n = len(numbers) for i in range(1, n + 1): for subset in combinations(numbers, i): if sum(subset) == 0: print(\\"Yes\\") print(\\" \\".join(map(str, subset))) return print(\\"No subset found\\") # Example usage: # find_zero_sum_subset([3, -2, 1, -4, 2])"},{"question":"def prime_factors_count_up_to_m(M): Returns a list where the value at index i is the number of prime factors of i. The returned list covers the range from 1 to M (inclusive). # Implement the function to return prime factors count up to M pass def sum_prime_factor_counts(T, test_cases): Returns the sum of the number of prime factors (including multiplicity) for each integer from 1 to given number M for each test case. # Implement the function to compute the required sum of prime factors pass def parse_input(input_str): Parses the input string and returns T (number of test cases) and a list of test cases. # Implement the function to parse input pass def main(input_str): Takes an input string, processes the number of prime factors for each test case, and returns the formatted result string. # Implement the main function to process input and produce output pass import pytest def test_prime_factors_count_up_to_m(): assert prime_factors_count_up_to_m(5) == [0, 0, 1, 1, 2, 1] assert prime_factors_count_up_to_m(10) == [0, 0, 1, 1, 2, 1, 2, 1, 3, 2, 2] def test_sum_prime_factor_counts(): assert sum_prime_factor_counts(2, [5, 10]) == [5, 15] assert sum_prime_factor_counts(1, [1]) == [0] assert sum_prime_factor_counts(3, [2, 3, 4]) == [1, 2, 4] def test_parse_input(): T, test_cases = parse_input(\\"2n5n10\\") assert T == 2 assert test_cases == [5, 10] def test_main(): input_str = \\"2n5n10\\" expected_output = \\"5n15\\" assert main(input_str) == expected_output input_str = \\"1n1\\" expected_output = \\"0\\" assert main(input_str) == expected_output input_str = \\"3n2n3n4\\" expected_output = \\"1n2n4\\" assert main(input_str) == expected_output pytest.main()","solution":"def prime_factors_count_up_to_m(M): Returns a list where the value at index i is the number of prime factors of i. The returned list covers the range from 1 to M (inclusive). # Initialize a list for counting prime factors. factor_counts = [0] * (M + 1) # Perform a sieve-like approach to count the prime factors for i in range(2, M + 1): if factor_counts[i] == 0: # \`i\` is a prime number for j in range(i, M + 1, i): k = j while k % i == 0: factor_counts[j] += 1 k //= i return factor_counts def sum_prime_factor_counts(T, test_cases): results = [] for M in test_cases: factors_count = prime_factors_count_up_to_m(M) sum_factors = sum(factors_count) results.append(sum_factors) return results def parse_input(input_str): lines = input_str.strip().split('n') T = int(lines[0]) test_cases = [int(lines[i]) for i in range(1, T + 1)] return T, test_cases def main(input_str): T, test_cases = parse_input(input_str) results = sum_prime_factor_counts(T, test_cases) return 'n'.join(map(str, results))"},{"question":"def calculate_final_bacteria(initial_bacteria: int, daily_removal_percentage: int, number_of_days: int) -> float: Calculate the final number of bacteria after a certain number of days, given an initial number of bacteria, a daily removal percentage, and the number of days. :param initial_bacteria: int - initial number of bacteria :param daily_removal_percentage: int - percentage of bacteria removed daily :param number_of_days: int - number of days bacteria grows :return: float - final number of bacteria after the given number of days >>> round(calculate_final_bacteria(100, 20, 3), 1) 409.6 >>> round(calculate_final_bacteria(100, 0, 3), 1) 800.0 >>> round(calculate_final_bacteria(100, 100, 3), 1) 0.0 >>> round(calculate_final_bacteria(50, 50, 1), 1) 50.0 >>> round(calculate_final_bacteria(100, 10, 2), 1) 324.0","solution":"def calculate_final_bacteria(initial_bacteria, daily_removal_percentage, number_of_days): Calculate the final number of bacteria after a certain number of days, given an initial number of bacteria, a daily removal percentage, and the number of days. :param initial_bacteria: int - initial number of bacteria :param daily_removal_percentage: int - percentage of bacteria removed daily :param number_of_days: int - number of days bacteria grows :return: float - final number of bacteria after the given number of days remaining_bacteria = initial_bacteria for _ in range(number_of_days): # Double the number of bacteria remaining_bacteria *= 2 # Remove the specified percentage of bacteria remaining_bacteria *= (1 - daily_removal_percentage / 100) return remaining_bacteria"},{"question":"def longest_road_to_remove(n: int, m: int, roads: List[Tuple[int, int, int]]) -> int: Monica is designing a ring road network for a new city. The city has n intersections connected by m bidirectional roads. Each road has a specific length in kilometers. Monica wants to identify the longest road in the city that, when removed, does not change the city from being fully connected, such that all intersections are still reachable from every other intersection through some paths. Parameters: n (int): the number of intersections. m (int): the number of roads. roads (List[Tuple[int, int, int]]): each tuple represents a road of length w kilometers connecting intersection u with intersection v. Returns: int: the length of the longest road that, when removed, keeps all intersections still connected. If no such road exists, returns -1. Examples: >>> longest_road_to_remove(5, 6, [(1, 2, 3), (1, 3, 4), (2, 3, 2), (3, 4, 6), (4, 5, 5), (2, 5, 8)]) 8 >>> longest_road_to_remove(3, 3, [(1, 2, 1), (2, 3, 2), (3, 1, 3)]) 3","solution":"from collections import defaultdict import heapq def find(parent, x): if parent[x] != x: parent[x] = find(parent, parent[x]) return parent[x] def union(parent, rank, x, y): rootX = find(parent, x) rootY = find(parent, y) if rootX != rootY: if rank[rootX] > rank[rootY]: parent[rootY] = rootX elif rank[rootX] < rank[rootY]: parent[rootX] = rootY else: parent[rootY] = rootX rank[rootX] += 1 def kruskal(n, edges): parent = list(range(n+1)) rank = [0] * (n+1) mst = [] edges.sort(key=lambda x: x[2], reverse=True) while edges: u, v, w = edges.pop() if find(parent, u) != find(parent, v): union(parent, rank, u, v) mst.append((u, v, w)) return mst def longest_road_to_remove(n, m, roads): if m < n - 1: return -1 edges = [] for u, v, w in roads: edges.append((u, v, w)) mst = kruskal(n, edges) max_edge = -1 for u, v, w in roads: if (u, v, w) in mst or (v, u, w) in mst: continue max_edge = max(max_edge, w) return max_edge if max_edge != -1 else -1"},{"question":"def compute_aggregate_grid(t, test_cases): Compute a new grid for each test case where each cell (i, j) in the new grid is the sum of all the elements in the subgrid ranging from (1, 1) to (i, j) in the original grid. Args: t (int): The number of test cases. test_cases (list): A list containing the test cases. Each test case is a tuple (n, m, grid) where: n (int): Number of rows in the grid. m (int): Number of columns in the grid. grid (list of list of int): The n x m grid containing non-negative integers. Returns: list: A list containing new grids for each test case. >>> compute_aggregate_grid(2, [(3, 3, [[1, 2, 3], [4, 5, 6], [7, 8, 9]]), (2, 2, [[1, 2], [3, 4]])]) [[[1, 3, 6], [5, 12, 21], [12, 27, 45]], [[1, 3], [4, 10]]] >>> compute_aggregate_grid(1, [(1, 1, [[5]])]) [[[5]]]","solution":"def compute_aggregate_grid(t, test_cases): results = [] for case in test_cases: n, m, original_grid = case aggregate_grid = [[0] * m for _ in range(n)] for i in range(n): for j in range(m): current_value = original_grid[i][j] if i > 0: current_value += aggregate_grid[i-1][j] if j > 0: current_value += aggregate_grid[i][j-1] if i > 0 and j > 0: current_value -= aggregate_grid[i-1][j-1] aggregate_grid[i][j] = current_value results.append(aggregate_grid) return results"},{"question":"def count_beautiful_numbers(L: int, R: int) -> int: Count the number of beautiful numbers (powers of 2) in the range [L, R]. A beautiful number is defined as a power of 2. >>> count_beautiful_numbers(2, 16) 4 >>> count_beautiful_numbers(1, 64) 7 >>> count_beautiful_numbers(20, 40) 1","solution":"def count_beautiful_numbers(L, R): Count the number of beautiful numbers (powers of 2) in the range [L, R]. A beautiful number is defined as a power of 2. count = 0 power = 1 while power <= R: if L <= power <= R: count += 1 power *= 2 return count"},{"question":"from typing import List def stable_merge_sort(arr: List[int]) -> List[int]: Merge sort algorithm that sorts an array in non-decreasing order and is stable. >>> stable_merge_sort([3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5]) [1, 1, 2, 3, 3, 4, 5, 5, 5, 6, 9] >>> stable_merge_sort([1, 2, 3, 4, 5]) [1, 2, 3, 4, 5] >>> stable_merge_sort([5, 4, 3, 2, 1]) [1, 2, 3, 4, 5] >>> stable_merge_sort([2, 3, 2, 1, 4, 1]) [1, 1, 2, 2, 3, 4] >>> stable_merge_sort([42]) [42] >>> stable_merge_sort([]) [] >>> stable_merge_sort([7, 7, 7, 7, 7, 7]) [7, 7, 7, 7, 7, 7]","solution":"from typing import List def stable_merge_sort(arr: List[int]) -> List[int]: if len(arr) <= 1: return arr def merge(left: List[int], right: List[int]) -> List[int]: sorted_array = [] i = j = 0 while i < len(left) and j < len(right): if left[i] <= right[j]: sorted_array.append(left[i]) i += 1 else: sorted_array.append(right[j]) j += 1 sorted_array.extend(left[i:]) sorted_array.extend(right[j:]) return sorted_array def merge_sort(arr: List[int]) -> List[int]: if len(arr) <= 1: return arr mid = len(arr) // 2 left = merge_sort(arr[:mid]) right = merge_sort(arr[mid:]) return merge(left, right) return merge_sort(arr)"},{"question":"def manage_parking_slots(N: int, operations: List[str]) -> List[str]: Manage the series of parking slots with the given operations. :param N: int - number of parking slots :param operations: List[str] - list of operations to perform :return: List[str] - results of the 'S' operations >>> manage_parking_slots(5, [\\"O 1\\", \\"O 3\\", \\"S 1\\", \\"V 1\\", \\"S 1\\"]) ['OCCUPIED', 'VACANT'] >>> manage_parking_slots(5, [\\"S 1\\", \\"S 2\\", \\"S 3\\", \\"S 4\\", \\"S 5\\"]) ['VACANT', 'VACANT', 'VACANT', 'VACANT', 'VACANT']","solution":"def manage_parking_slots(N, operations): Manage the series of parking slots with the given operations. :param N: int - number of parking slots :param operations: List[str] - list of operations to perform :return: List[str] - results of the 'S' operations slots = [\\"VACANT\\"] * N # Initialize all slots as vacant result = [] for operation in operations: op, i = operation.split() index = int(i) - 1 if op == \\"O\\": slots[index] = \\"OCCUPIED\\" elif op == \\"V\\": slots[index] = \\"VACANT\\" elif op == \\"S\\": result.append(slots[index]) return result"},{"question":"def find_highest_scoring_player(n, g, scores): Given the number of players (n), the number of games (g), and the scores of each player for each game, returns the ID (0-based index) of the player with the highest total score. pass # Unit tests def test_all_different_scores(): assert find_highest_scoring_player(4, 3, [ [10, 20, 30], [20, 30, 40], [30, 40, 50], [40, 50, 60] ]) == 3 def test_some_equal_scores(): assert find_highest_scoring_player(3, 2, [ [50, 60], [60, 50], [30, 80] ]) == 0 def test_single_player_single_game(): assert find_highest_scoring_player(1, 1, [ [100] ]) == 0 def test_all_equal_scores(): assert find_highest_scoring_player(2, 2, [ [50, 50], [50, 50] ]) == 0 def test_player_with_zero_scores(): assert find_highest_scoring_player(3, 2, [ [0, 0], [10, 10], [5, 5] ]) == 1 def test_edge_case_min_values(): assert find_highest_scoring_player(1, 1, [ [1] ]) == 0 def test_edge_case_max_values(): n, g = 100, 50 scores = [[i + j for j in range(g)] for i in range(n)] assert find_highest_scoring_player(n, g, scores) == 99","solution":"def find_highest_scoring_player(n, g, scores): Given the number of players (n), the number of games (g), and the scores of each player for each game, returns the ID (0-based index) of the player with the highest total score. max_score = -1 max_player_id = -1 for player_id in range(n): total_score = sum(scores[player_id]) if total_score > max_score or (total_score == max_score and player_id < max_player_id): max_score = total_score max_player_id = player_id return max_player_id"},{"question":"from typing import List def is_prime(n: int) -> bool: Return True if n is prime, else False pass def prime_sum_subarrays(n: int, a: List[int]) -> str: Given an array of integers, determine if there exist two non-overlapping subarrays with sums equal to the same prime number. >>> prime_sum_subarrays(7, [1, 2, 3, 6, 10, 3, 7]) == \\"YES\\" >>> prime_sum_subarrays(4, [4, 6, 8, 12]) == \\"NO\\" pass def test_case_1(): assert prime_sum_subarrays(7, [1, 2, 3, 6, 10, 3, 7]) == \\"YES\\" def test_case_2(): assert prime_sum_subarrays(4, [4, 6, 8, 12]) == \\"NO\\" def test_case_3(): assert prime_sum_subarrays(5, [1, 2, 1, 2, 3]) == \\"YES\\" def test_case_4(): assert prime_sum_subarrays(3, [17, 2, 3]) == \\"NO\\" def test_case_5(): assert prime_sum_subarrays(6, [1, 1, 1, 1, 1, 1]) == \\"YES\\" def test_case_6(): assert prime_sum_subarrays(1, [2]) == \\"NO\\" def test_case_7(): assert prime_sum_subarrays(8, [2, 7, 1, 4, 2, 7, 3, 6]) == \\"YES\\"","solution":"def is_prime(n): Return True if n is prime, else False if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def prime_sum_subarrays(n, a): # Compute all possible subarray sums sums = [] for i in range(n): current_sum = 0 for j in range(i, n): current_sum += a[j] sums.append(current_sum) # Store sums that are prime prime_sums = set() for s in sums: if is_prime(s): if s in prime_sums: return \\"YES\\" prime_sums.add(s) return \\"NO\\""},{"question":"def find_shortest_cycle(n: int, adj_list: List[List[Tuple[int, int]]]) -> int: Determine the length of the shortest cycle in a directed graph. If no cycles exist, return -1. pass def solve_cases(input_data: List[str]) -> List[str]: Solve multiple cases of finding the shortest cycle in a directed graph. Each case consists of graph parameters and edges details given in \`input_data\`. Returns a list of strings with results for each case. pass","solution":"def find_shortest_cycle(n, adj_list): import heapq def dijkstra(start): dist = [float('inf')] * n dist[start] = 0 pq = [(0, start)] while pq: d, u = heapq.heappop(pq) if d > dist[u]: continue for v, weight in adj_list[u]: if dist[u] + weight < dist[v]: dist[v] = dist[u] + weight heapq.heappush(pq, (dist[v], v)) return dist shortest_cycle_length = float('inf') for node in range(n): dist = dijkstra(node) for u in range(n): for v, weight in adj_list[u]: if v == node and dist[u] + weight < shortest_cycle_length: shortest_cycle_length = dist[u] + weight return shortest_cycle_length if shortest_cycle_length != float('inf') else -1 def solve_cases(input_data): results = [] case_num = 1 index = 0 while index < len(input_data): n, m = map(int, input_data[index].split()) if n == 0 and m == 0: break adj_list = [[] for _ in range(n)] for i in range(m): x, y = map(int, input_data[index + 1 + i].split()) adj_list[x - 1].append((y - 1, 1)) # edge weight of 1 shortest_cycle_length = find_shortest_cycle(n, adj_list) results.append(f\\"Case {case_num}: {shortest_cycle_length}\\") index += 1 + m case_num += 1 return results def main(input_lines): results = solve_cases(input_lines) for result in results: print(result) # Example of how to call the main function with input data input_data = [ \\"3 3\\", \\"1 2\\", \\"2 3\\", \\"3 1\\", \\"3 2\\", \\"1 2\\", \\"2 3\\", \\"4 3\\", \\"1 2\\", \\"2 3\\", \\"3 4\\", \\"0 0\\" ] main(input_data)"},{"question":"def min_diff_between_prizes(n: int, k: int, scores: List[int]) -> int: Determines the minimum possible difference between the highest and lowest scores among the participants who receive the prizes. :param n: int - number of participants :param k: int - number of prizes :param scores: List[int] - scores of the participants :return: int - minimum possible difference >>> min_diff_between_prizes(5, 3, [1, 3, 7, 9, 2]) 2 >>> min_diff_between_prizes(6, 2, [8, 1, 4, 3, 6, 10]) 1 from solution import min_diff_between_prizes def test_min_diff_general_case(): assert min_diff_between_prizes(5, 3, [1, 3, 7, 9, 2]) == 2 def test_min_diff_pair_case(): assert min_diff_between_prizes(6, 2, [8, 1, 4, 3, 6, 10]) == 1 def test_min_diff_single_prize(): assert min_diff_between_prizes(5, 1, [1, 3, 7, 9, 2]) == 0 def test_min_diff_all_prizes(): assert min_diff_between_prizes(4, 4, [1, 7, 3, 8]) == 7 def test_min_diff_identical_scores(): assert min_diff_between_prizes(5, 3, [5, 5, 5, 5, 5]) == 0 def test_min_diff_large_case(): scores = list(range(1, 100001)) assert min_diff_between_prizes(100000, 100000, scores) == 99999","solution":"def min_diff_between_prizes(n, k, scores): Returns the minimum possible difference between the highest and lowest scores among the participants who receive the prizes. :param n: int - number of participants :param k: int - number of prizes :param scores: List[int] - scores of the participants :return: int - minimum possible difference scores.sort() min_diff = float('inf') for i in range(n - k + 1): min_diff = min(min_diff, scores[i + k - 1] - scores[i]) return min_diff"},{"question":"from typing import List def single_number(nums: List[int]) -> int: Returns the integer that appears only once in the list. Each other integer appears exactly twice. >>> single_number([4, 1, 2, 1, 2, 4, 3]) == 3 >>> single_number([10, 20, 10, 30, 20]) == 30 >>> single_number([99]) == 99","solution":"def single_number(nums): Returns the integer that appears only once in the list. Each other integer appears exactly twice. result = 0 for num in nums: result ^= num return result"},{"question":"def find_brightest_trees(M: int, N: int, tree_brightness: List[int], nights_data: List[List[int]]) -> List[Union[int, str]]: In a dense forest, there are M special trees numbered 1 to M, which emit a unique light at night. Each tree has a specific brightness level represented by an integer. A group of scientists has been observing these trees for N nights. Every night, they record the brightness of a subset of these trees. The scientists need your help to find the brightness of the tree that is most frequently observed as the brightest or determine if there is a tie. Parameters: M (int): Number of trees. N (int): Number of nights. tree_brightness (List[int]): Brightness levels of each tree from 1 to M. nights_data (List[List[int]]): Brightness data for each night. Returns: List[Union[int, str]]: The index of the tree that is most frequently observed as the brightest each night, or \\"Tie\\". Example: >>> find_brightest_trees(5, 3, [10, 20, 15, 5, 25], [[3, 1, 10, 3, 15, 4, 25], [2, 2, 20, 5, 25], [3, 1, 10, 3, 15, 2, 20]]) [5, 5, 2] >>> find_brightest_trees(4, 1, [10, 20, 20, 15], [[3, 2, 20, 3, 20, 4, 15]]) ['Tie']","solution":"def find_brightest_trees(M, N, tree_brightness, nights_data): results = [] for night in nights_data: K = night[0] observed_trees = night[1::2] observed_bright = night[2::2] max_brightness = -1 brightest_trees = [] for i in range(K): if observed_bright[i] > max_brightness: max_brightness = observed_bright[i] brightest_trees = [observed_trees[i]] elif observed_bright[i] == max_brightness: brightest_trees.append(observed_trees[i]) if len(brightest_trees) > 1: results.append(\\"Tie\\") else: results.append(brightest_trees[0]) return results"},{"question":"def findSubsets(nums: List[int]) -> List[List[int]]: Returns all possible subsets of the given list of integers in lexicographical order. >>> findSubsets([]) == [[]] >>> findSubsets([1]) == [[], [1]] >>> findSubsets([1, 2]) == [[], [1], [1, 2], [2]] >>> findSubsets([1, 2, 3]) == [[], [1], [1, 2], [1, 2, 3], [1, 3], [2], [2, 3], [3]] >>> findSubsets([3, 1, 2]) == [[], [1], [1, 2], [1, 2, 3], [1, 3], [2], [2, 3], [3]] >>> findSubsets([-1, 0, 1]) == [[], [-1], [-1, 0], [-1, 0, 1], [-1, 1], [0], [0, 1], [1]]","solution":"from typing import List def findSubsets(nums: List[int]) -> List[List[int]]: Returns all possible subsets of the given list of integers in lexicographical order. def backtrack(start, path): result.append(path[:]) for i in range(start, len(nums)): path.append(nums[i]) backtrack(i + 1, path) path.pop() nums.sort() result = [] backtrack(0, []) return result"},{"question":"from typing import List def longest_substring_with_two_chars(s: str) -> str: Find the longest substring in the given DNA sequence that contains at most two different characters. Args: s (str): A string representing the DNA sequence. Returns: str: The longest substring with at most two different characters. >>> longest_substring_with_two_chars(\\"GATTACA\\") \\"ATTA\\" >>> longest_substring_with_two_chars(\\"CGCGATTA\\") \\"CGCG\\" >>> longest_substring_with_two_chars(\\"A\\") \\"A\\" >>> longest_substring_with_two_chars(\\"AAAA\\") \\"AAAA\\" >>> longest_substring_with_two_chars(\\"AACCCB\\") \\"AACCC\\" >>> longest_substring_with_two_chars(\\"AABCAA\\") \\"AAB\\" pass def process_sequences(sequences: List[str]) -> List[str]: Process multiple DNA sequences to find the longest substring with at most two different characters for each sequence. Args: sequences (List[str]): A list of DNA sequences. Returns: List[str]: A list of results in the format \\"Case i:nresult\\" for each sequence. >>> input_data = [\\"GATTACA\\", \\"CGCGATTA\\"] >>> process_sequences(input_data) [\\"Case 1:nATTA\\", \\"Case 2:nCGCG\\"] pass","solution":"def longest_substring_with_two_chars(s): from collections import defaultdict # Sliding window approach with two pointers left = 0 right = 0 max_substring = \\"\\" char_map = defaultdict(int) while right < len(s): char_map[s[right]] += 1 while len(char_map) > 2: char_map[s[left]] -= 1 if char_map[s[left]] == 0: del char_map[s[left]] left += 1 if right - left + 1 > len(max_substring): max_substring = s[left:right+1] right += 1 return max_substring def process_sequences(sequences): results = [] for i, s in enumerate(sequences): result = longest_substring_with_two_chars(s) results.append(f\\"Case {i+1}:n{result}\\") return results"},{"question":"def process_game_operations(N: int, Q: int, items: List[int], operations: List[Tuple[int]]) -> List[int]: Process the game operations and return the results of the queries. :param int N: Number of players :param int Q: Number of operations :param List[int] items: Initial number of items each player has :param List[Tuple[int]] operations: Operations to perform :return List[int]: Results of \`Query\` operations >>> process_game_operations(3, 4, [10, 5, 3], [(1, 1, 2), (2, 3, 4), (3, 2), (3, 3)]) [15, 7] >>> process_game_operations(2, 0, [8, 12], []) []","solution":"def process_game_operations(N, Q, items, operations): Process the game operations and return the results of the queries. :param int N: Number of players :param int Q: Number of operations :param List[int] items: Initial number of items each player has :param List[Tuple[int]] operations: Operations to perform :return List[int]: Results of \`Query\` operations results = [] for operation in operations: if operation[0] == 1: # Trade operation a, b = operation[1] - 1, operation[2] - 1 items[b] += items[a] items[a] = 0 elif operation[0] == 2: # Collect operation a, x = operation[1] - 1, operation[2] items[a] += x elif operation[0] == 3: # Query operation a = operation[1] - 1 results.append(items[a]) return results"},{"question":"def can_alice_win(n: int, m: int, edges: List[Tuple[int, int]]) -> str: Determines if Alice can always win if both players play optimally. Parameters: n (int): Number of nodes m (int): Number of edges edges (List[Tuple[int, int]]): List of edges in the graph Returns: str: \\"Yes\\" if Alice can always win, \\"No\\" otherwise >>> can_alice_win(3, 3, [(1, 2), (2, 3), (3, 1)]) \\"No\\" >>> can_alice_win(4, 5, [(1, 2), (1, 3), (1, 4), (2, 3), (3, 4)]) \\"Yes\\"","solution":"def can_alice_win(n, m, edges): Determines if Alice can always win if both players play optimally Parameters: n (int): Number of nodes m (int): Number of edges edges (list of tuples): List of edges in the graph Returns: str: \\"Yes\\" if Alice can always win, \\"No\\" otherwise if m < n - 1: return \\"No\\" # Not enough edges to keep the graph connected for i in range(1, n + 1): degree_count = sum(1 for u, v in edges if u == i or v == i) if degree_count >= 3: return \\"Yes\\" return \\"No\\""},{"question":"class TreeNode: def __init__(self, value): self.value = value self.left = None self.right = None def build_tree(node_descriptions, k): Construct a binary tree given the node descriptions. Args: node_descriptions: A list of tuples (p, l, r) where p is the parent node, l is the left child node, and r is the right child node. k: The number of nodes in the tree. Returns: The root of the constructed binary tree. def in_order_traversal(node, traversal): Perform in-order traversal on a binary tree. Args: node: The root node of the binary tree. traversal: A list to store the in-order traversal sequence. def canonical_form(k, node_descriptions): Transform a binary tree to its canonical form and return the sorted sequence of node values. Args: k: The number of nodes in the binary tree. node_descriptions: A list of tuples (p, l, r) where p is the parent node, l is the left child node, and r is the right child node. Returns: A list of node values sorted in ascending order. >>> canonical_form(5, [(1, 2, 3), (2, 4, 0), (3, 0, 5), (4, 0, 0), (5, 0, 0)]) [1, 2, 3, 4, 5] >>> canonical_form(3, [(1, 2, 3), (2, 0, 0), (3, 0, 0)]) [1, 2, 3] >>> canonical_form(1, [(1, 0, 0)]) [1]","solution":"class TreeNode: def __init__(self, value): self.value = value self.left = None self.right = None def build_tree(node_descriptions, k): nodes = {i: TreeNode(i) for i in range(1, k + 1)} for parent, left, right in node_descriptions: if left != 0: nodes[parent].left = nodes[left] if right != 0: nodes[parent].right = nodes[right] return nodes[1] # Root node is always 1 based on the constraints def in_order_traversal(node, traversal): if node is not None: in_order_traversal(node.left, traversal) traversal.append(node.value) in_order_traversal(node.right, traversal) def canonical_form(k, node_descriptions): root = build_tree(node_descriptions, k) traversal = [] in_order_traversal(root, traversal) return sorted(traversal)"},{"question":"def group_anagrams(datasets): Group a list of words into sets of anagrams. >>> group_anagrams([\\"listen silent enlist inlets google goolge\\"]) [[['enlist', 'inlets', 'listen', 'silent'], ['google', 'goolge']]] >>> group_anagrams([ \\"listen silent enlist inlets google goolge\\", \\"cat act tac bat tab\\", \\"rat tar art star\\" ]) [ [['enlist', 'inlets', 'listen', 'silent'], ['google', 'goolge']], [['act', 'cat', 'tac'], ['bat', 'tab']], [['art', 'rat', 'tar'], ['star']] ]","solution":"def group_anagrams(datasets): def sorted_word(word): return ''.join(sorted(word)) def process_dataset(words): sorted_word_dict = {} for word in words: key = sorted_word(word) if key in sorted_word_dict: sorted_word_dict[key].append(word) else: sorted_word_dict[key] = [word] result = [] for anagrams in sorted_word_dict.values(): anagrams.sort() result.append(anagrams) return result results = [] for dataset in datasets: words = dataset.split() groups = process_dataset(words) groups_sorted = sorted(groups, key=lambda x: x[0]) results.append(groups_sorted) return results"},{"question":"def process_transactions(n: int, transactions: List[Tuple[str, float]]) -> Tuple[float, float]: Processes user transactions and returns the total amount and the maximum single transaction amount. :param n: Integer number of transactions :param transactions: List of tuples, where each tuple contains a transaction ID and an amount :return: Tuple containing the total amount and the maximum single transaction amount, both rounded to 2 decimal places from typing import List, Tuple def test_process_transactions_example(): n = 4 transactions = [(\\"T1\\", 10.50), (\\"T2\\", 20.75), (\\"T3\\", 5.00), (\\"T4\\", 25.25)] assert process_transactions(n, transactions) == (61.50, 25.25) def test_process_transactions_single_transaction(): n = 1 transactions = [(\\"T1\\", 100.00)] assert process_transactions(n, transactions) == (100.00, 100.00) def test_process_transactions_same_amount_transactions(): n = 3 transactions = [(\\"T1\\", 10.00), (\\"T2\\", 10.00), (\\"T3\\", 10.00)] assert process_transactions(n, transactions) == (30.00, 10.00) def test_process_transactions_varied_amount_transactions(): n = 3 transactions = [(\\"T1\\", 10.50), (\\"T2\\", 200.20), (\\"T3\\", 15.75)] assert process_transactions(n, transactions) == (226.45, 200.20) def test_process_transactions_large_number_of_transactions(): n = 10000 transactions = [(\\"T\\"+str(i), i*0.01) for i in range(1, 10001)] assert process_transactions(n, transactions) == (500050.00, 100.00)","solution":"def process_transactions(n, transactions): Processes user transactions and returns the total amount and the maximum single transaction amount. :param n: Integer number of transactions :param transactions: List of tuples, where each tuple contains a transaction ID and an amount :return: Tuple containing the total amount and the maximum single transaction amount, both rounded to 2 decimal places total_amount = 0.0 max_transaction = float('-inf') for tx_id, amount in transactions: amount = float(amount) total_amount += amount if amount > max_transaction: max_transaction = amount total_amount = round(total_amount, 2) max_transaction = round(max_transaction, 2) return total_amount, max_transaction"},{"question":"def max_profit_for_single_transaction(days, prices): Given a list of prices for a certain number of days, returns the maximum profit that could be achieved from one buy-sell transaction. If no profit can be made, returns 0. pass def max_profits_for_test_cases(test_cases): Given multiple test cases, calculates and returns the maximum profits for each one. pass # Unit tests from solution import max_profit_for_single_transaction, max_profits_for_test_cases def test_single_transaction_examples(): assert max_profit_for_single_transaction(6, [7, 1, 5, 3, 6, 4]) == 5 assert max_profit_for_single_transaction(5, [7, 6, 4, 3, 1]) == 0 assert max_profit_for_single_transaction(3, [1, 2, 3]) == 2 assert max_profit_for_single_transaction(3, [3, 2, 1]) == 0 def test_edge_cases(): assert max_profit_for_single_transaction(1, [5]) == 0 # Only one day, no possible transactions assert max_profit_for_single_transaction(2, [2, 4]) == 2 # Simple case with only two days def test_multiple_test_cases(): test_cases = [ (6, [7, 1, 5, 3, 6, 4]), (5, [7, 6, 4, 3, 1]), (4, [1, 2, 3, 4]), ] expected_results = [5, 0, 3] assert max_profits_for_test_cases(test_cases) == expected_results","solution":"def max_profit_for_single_transaction(days, prices): Given a list of prices for a certain number of days, returns the maximum profit that could be achieved from one buy-sell transaction. If no profit can be made, returns 0. if days < 2: return 0 min_price = prices[0] max_profit = 0 for price in prices[1:]: profit = price - min_price if profit > max_profit: max_profit = profit if price < min_price: min_price = price return max_profit def max_profits_for_test_cases(test_cases): Given multiple test cases, calculates and returns the maximum profits for each one. results = [] for days, prices in test_cases: results.append(max_profit_for_single_transaction(days, prices)) return results"},{"question":"from collections import deque from typing import List def min_steps_to_destination(n: int, m: int, grid: List[str], sx: int, sy: int, dx: int, dy: int) -> int: Given a grid with n rows and m columns, consisting of empty cells and walls, calculates the minimum number of steps required to move from the starting position (sx, sy) to the destination position (dx, dy). If it is not possible to reach the destination, returns -1. Parameters: n (int): Number of rows in the grid m (int): Number of columns in the grid grid (List[str]): The grid representation with '.' as empty cell and '#' as wall sx (int): Starting position row (1-indexed) sy (int): Starting position column (1-indexed) dx (int): Destination position row (1-indexed) dy (int): Destination position column (1-indexed) Returns: int: The minimum number of steps to reach the destination or -1 if not possible Examples: >>> min_steps_to_destination(5, 5, [\\".....\\", \\"..#..\\", \\".....\\", \\"..#..\\", \\".....\\"], 1, 1, 5, 5) 8 >>> min_steps_to_destination(3, 3, [\\"..#\\", \\"#..\\", \\"..#\\"], 1, 1, 3, 3) -1 from solution import min_steps_to_destination def test_min_steps_case1(): n, m = 5, 5 grid = [ \\".....\\", \\"..#..\\", \\".....\\", \\"..#..\\", \\".....\\" ] sx, sy, dx, dy = 1, 1, 5, 5 assert min_steps_to_destination(n, m, grid, sx, sy, dx, dy) == 8 def test_min_steps_case2(): n, m = 3, 3 grid = [ \\"..#\\", \\"#..\\", \\"..#\\" ] sx, sy, dx, dy = 1, 1, 3, 3 assert min_steps_to_destination(n, m, grid, sx, sy, dx, dy) == -1 def test_min_steps_start_equals_destination(): n, m = 3, 3 grid = [ \\"...\\", \\"...\\", \\"...\\" ] sx, sy, dx, dy = 1, 1, 1, 1 assert min_steps_to_destination(n, m, grid, sx, sy, dx, dy) == 0 def test_min_steps_start_or_destination_is_wall(): n, m = 3, 3 grid = [ \\".#.\\", \\"...\\", \\"#..\\" ] sx, sy, dx, dy = 1, 2, 2, 2 assert min_steps_to_destination(n, m, grid, sx, sy, dx, dy) == -1 def test_min_steps_border_case(): n, m = 5, 5 grid = [ \\".....\\", \\".#.\\", \\".#.\\", \\".#.\\", \\".....\\" ] sx, sy, dx, dy = 1, 1, 5, 5 assert min_steps_to_destination(n, m, grid, sx, sy, dx, dy) == 8 def test_min_steps_possible_directions(): n, m = 3, 3 grid = [ \\"...\\", \\"...\\", \\"...\\" ] sx, sy, dx, dy = 1, 1, 3, 3 assert min_steps_to_destination(n, m, grid, sx, sy, dx, dy) == 4","solution":"from collections import deque def min_steps_to_destination(n, m, grid, sx, sy, dx, dy): # Directions to move in the grid, right, left, down, up directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] # Convert input to zero-indexed sx, sy, dx, dy = sx - 1, sy - 1, dx - 1, dy - 1 # Check if start or destination are walls if grid[sx][sy] == '#' or grid[dx][dy] == '#': return -1 # BFS initialization queue = deque([(sx, sy, 0)]) visited = set((sx, sy)) while queue: x, y, steps = queue.popleft() # Check if we reached the destination if (x, y) == (dx, dy): return steps # Explore neighboring cells for direction in directions: nx, ny = x + direction[0], y + direction[1] if 0 <= nx < n and 0 <= ny < m: if grid[nx][ny] == '.' and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny, steps + 1)) # If the queue is empty and we never reached the destination return -1"},{"question":"import heapq from typing import List, Tuple def dijkstra(n: int, m: int, edges: List[Tuple[int, int, int]], start: int) -> List[int]: Computes the shortest distances from the specified start building to all other buildings. Returns a list where the ith element represents the shortest distance from start to the ith building. If a building is not reachable, its distance is marked as -1. Parameters: n (int): Number of buildings m (int): Number of roads edges (List[Tuple[int, int, int]]): Each tuple represents a road from building u to building v of length l start (int): The starting building for the delivery Returns: List[int]: Shortest distances from the start building to each building >>> dijkstra(5, 6, [(1, 2, 2), (1, 4, 1), (2, 3, 3), (4, 5, 2), (5, 2, 1), (3, 5, 4)], 1) [0, 2, 5, 1, 3] >>> dijkstra(3, 2, [(1, 2, 4), (2, 3, 6)], 2) [-1, 0, 6] from solution import dijkstra def test_example_1(): n = 5 m = 6 edges = [(1, 2, 2), (1, 4, 1), (2, 3, 3), (4, 5, 2), (5, 2, 1), (3, 5, 4)] start = 1 assert dijkstra(n, m, edges, start) == [0, 2, 5, 1, 3] def test_example_2(): n = 3 m = 2 edges = [(1, 2, 4), (2, 3, 6)] start = 2 assert dijkstra(n, m, edges, start) == [-1, 0, 6] def test_no_connections(): n = 4 m = 0 edges = [] start = 1 assert dijkstra(n, m, edges, start) == [0, -1, -1, -1] def test_bidirectional_paths(): n = 4 m = 4 edges = [(1, 2, 5), (2, 3, 5), (3, 4, 5), (4, 1, 5)] start = 1 assert dijkstra(n, m, edges, start) == [0, 5, 10, 15] def test_large_graph(): n = 6 m = 8 edges = [(1, 2, 1), (1, 3, 12), (2, 3, 9), (2, 4, 3), (3, 5, 1), (4, 5, 2), (4, 6, 7), (5, 6, 2)] start = 1 assert dijkstra(n, m, edges, start) == [0, 1, 10, 4, 6, 8]","solution":"import heapq def dijkstra(n, m, edges, start): Computes the shortest distances from the specified start building to all other buildings. Returns a list where the ith element represents the shortest distance from start to the ith building. If a building is not reachable, its distance is marked as -1. graph = [[] for _ in range(n + 1)] for u, v, l in edges: graph[u].append((v, l)) # Initialize the distances array and the min heap distances = [-1] * (n + 1) distances[start] = 0 min_heap = [(0, start)] # (distance, node) while min_heap: current_dist, u = heapq.heappop(min_heap) # If we find a larger distance in the heap, we skip if current_dist > distances[u]: continue # Relax the edges for v, weight in graph[u]: new_dist = current_dist + weight if distances[v] == -1 or new_dist < distances[v]: distances[v] = new_dist heapq.heappush(min_heap, (new_dist, v)) # Replace the start position with 0 (distance from start to start is 0) distances = distances[1:] # Removing the first index to match the 1-based indexing return distances # Example Usage: # n = 5 # m = 6 # edges = [(1, 2, 2), (1, 4, 1), (2, 3, 3), (4, 5, 2), (5, 2, 1), (3, 5, 4)] # start = 1 # print(dijkstra(n, m, edges, start))"},{"question":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def build_tree(node_values): Build a binary tree from a list of node values. Args: node_values (List[Tuple[int, int, int]]): Each tuple contains (value, left_index, right_index) Returns: TreeNode: The root node of the binary tree nodes = [None] * len(node_values) for idx, (value, left_idx, right_idx) in enumerate(node_values): if nodes[idx] is None: nodes[idx] = TreeNode(value) nodes[idx].value = value if left_idx != -1: if nodes[left_idx] is None: nodes[left_idx] = TreeNode(node_values[left_idx][0]) nodes[idx].left = nodes[left_idx] if right_idx != -1: if nodes[right_idx] is None: nodes[right_idx] = TreeNode(node_values[right_idx][0]) nodes[idx].right = nodes[right_idx] return nodes[0] def find_value_in_tree(root, target): Determines if a target value exists in the binary tree. Args: root (TreeNode): The root node of the binary tree. target (int): The target value to search for. Returns: bool: True if the target value is found, False otherwise. >>> node_values = [(10, 1, 2), (4, -1, -1), (6, 3, 4), (3, -1, -1), (8, -1, -1)] >>> target = 8 >>> root = build_tree(node_values) >>> find_value_in_tree(root, target) True >>> target = 5 >>> root = build_tree(node_values) >>> find_value_in_tree(root, target) False pass","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def build_tree(node_values): nodes = [None] * len(node_values) for idx, (value, left_idx, right_idx) in enumerate(node_values): if nodes[idx] is None: nodes[idx] = TreeNode(value) nodes[idx].value = value if left_idx != -1: if nodes[left_idx] is None: nodes[left_idx] = TreeNode(node_values[left_idx][0]) nodes[idx].left = nodes[left_idx] if right_idx != -1: if nodes[right_idx] is None: nodes[right_idx] = TreeNode(node_values[right_idx][0]) nodes[idx].right = nodes[right_idx] return nodes[0] def find_value_in_tree(root, target): if root is None: return False if root.value == target: return True return find_value_in_tree(root.left, target) or find_value_in_tree(root.right, target)"},{"question":"def is_prefix_pair_present(n: int, strings: List[str]) -> str: Determine if there exists a pair of strings such that one is a prefix of the other. :param n: int - number of strings :param strings: List[str] - list of strings :return: str - \\"YES\\" if there exists a pair, otherwise \\"NO\\" Examples: >>> is_prefix_pair_present(3, [\\"cat\\", \\"dog\\", \\"bat\\"]) \\"NO\\" >>> is_prefix_pair_present(2, [\\"abc\\", \\"ab\\"]) \\"YES\\" from solution import is_prefix_pair_present def test_no_prefix_pair(): assert is_prefix_pair_present(3, [\\"cat\\", \\"dog\\", \\"bat\\"]) == \\"NO\\" def test_simple_prefix_pair(): assert is_prefix_pair_present(2, [\\"abc\\", \\"ab\\"]) == \\"YES\\" def test_multiple_strings_with_prefix(): assert is_prefix_pair_present(4, [\\"abc\\", \\"ab\\", \\"abcd\\", \\"a\\"]) == \\"YES\\" def test_one_element(): assert is_prefix_pair_present(1, [\\"a\\"]) == \\"NO\\" def test_no_common_prefix(): assert is_prefix_pair_present(3, [\\"cow\\", \\"dog\\", \\"hen\\"]) == \\"NO\\" def test_all_strings_are_same(): assert is_prefix_pair_present(3, [\\"abc\\", \\"abc\\", \\"abc\\"]) == \\"YES\\"","solution":"def is_prefix_pair_present(n, strings): Determine if there exists a pair of strings such that one is a prefix of the other. :param n: int - number of strings :param strings: List[str] - list of strings :return: str - \\"YES\\" if there exists a pair, otherwise \\"NO\\" strings.sort() for i in range(n - 1): if strings[i + 1].startswith(strings[i]): return \\"YES\\" return \\"NO\\""},{"question":"def is_coloring_possible(n: int, m: int, k: int) -> str: Determines if it's possible to fill a grid of size n x m with k distinct colors such that no two adjacent cells have the same color. Args: n (int): Number of rows. m (int): Number of columns. k (int): Number of distinct colors. Returns: str: \\"Yes\\" if it's possible, otherwise \\"No\\". >>> is_coloring_possible(3, 4, 2) \\"Yes\\" >>> is_coloring_possible(2, 2, 1) \\"No\\"","solution":"def is_coloring_possible(n, m, k): Determines if it's possible to fill a grid of size n x m with k distinct colors such that no two adjacent cells have the same color. Args: n (int): Number of rows. m (int): Number of columns. k (int): Number of distinct colors. Returns: str: \\"Yes\\" if it's possible, otherwise \\"No\\". # To avoid adjacent cells having the same color, at least 2 colors are required if k >= 2: return \\"Yes\\" else: return \\"No\\""},{"question":"def min_additional_routes(n, m, routes): Find the minimum number of additional routes required to make the network fully connected. n: int - number of stations m: int - number of existing direct routes routes: List[Tuple[int, int]] - list of existing routes Returns: int - minimum number of additional routes required >>> min_additional_routes(4, 2, [(1, 2), (3, 4)]) 1 >>> min_additional_routes(5, 3, [(1, 2), (2, 3), (4, 5)]) 1 >>> min_additional_routes(6, 0, []) 5 >>> min_additional_routes(1, 0, []) 0 >>> min_additional_routes(4, 3, [(1, 2), (2, 3), (3, 4)]) 0 >>> min_additional_routes(4, 4, [(1, 2), (2, 3), (3, 4), (1, 3)]) 0 >>> min_additional_routes(100, 0, []) 99 >>> min_additional_routes(7, 4, [(1, 2), (3, 4), (4, 5), (6, 7)]) 2 # Write your code here","solution":"def find_root(parent, i): if parent[i] == i: return i else: return find_root(parent, parent[i]) def union(parent, rank, x, y): root_x = find_root(parent, x) root_y = find_root(parent, y) if root_x != root_y: if rank[root_x] > rank[root_y]: parent[root_y] = root_x elif rank[root_x] < rank[root_y]: parent[root_x] = root_y else: parent[root_y] = root_x rank[root_x] += 1 def min_additional_routes(n, m, routes): parent = list(range(n)) rank = [0] * n for u, v in routes: union(parent, rank, u-1, v-1) unique_components = len(set(find_root(parent, i) for i in range(n))) return unique_components - 1"},{"question":"def sieve_of_eratosthenes(n: int) -> List[int]: Returns a list of all prime numbers up to n (inclusive) using the sieve of Eratosthenes algorithm. >>> sieve_of_eratosthenes(10) [2, 3, 5, 7] >>> sieve_of_eratosthenes(2) [2] >>> sieve_of_eratosthenes(1) []","solution":"def sieve_of_eratosthenes(n): Returns a list of all prime numbers up to n (inclusive) using the sieve of Eratosthenes algorithm. if n < 2: return [] # Initialize the sieve is_prime = [True] * (n + 1) is_prime[0] = is_prime[1] = False p = 2 while (p * p <= n): if is_prime[p]: for i in range(p * p, n + 1, p): is_prime[i] = False p += 1 primes = [num for num in range(2, n + 1) if is_prime[num]] return primes"},{"question":"from typing import List, Tuple def create_playlist(n: int, T: int, songs: List[Tuple[str, int]]) -> List[str]: Creates a playlist maximizing the number of songs without exceeding the duration T. If multiple playlists have the same number of songs, choose the one with the minimal total duration. If there are still multiple options, choose the lexicographically smallest list of song names. pass def test_example_1(): n = 5 T = 20 songs = [ ('song1', 5), ('song2', 6), ('song3', 7), ('song4', 15), ('song5', 10) ] result = create_playlist(n, T, songs) assert result == ['song1', 'song2', 'song3'] def test_example_2(): n = 4 T = 10 songs = [ ('alpha', 3), ('beta', 4), ('gamma', 5), ('delta', 6) ] result = create_playlist(n, T, songs) assert result == ['alpha', 'beta'] def test_no_songs_fit(): n = 3 T = 5 songs = [ ('song1', 6), ('song2', 7), ('song3', 10) ] result = create_playlist(n, T, songs) assert result == [] def test_all_songs_fit(): n = 2 T = 100 songs = [ ('song1', 50), ('song2', 50) ] result = create_playlist(n, T, songs) assert result == ['song1', 'song2'] def test_choosing_lexicographically_smallest(): n = 3 T = 10 songs = [ ('beta', 5), ('alpha', 5), ('gamma', 10) ] result = create_playlist(n, T, songs) assert result == ['alpha', 'beta'] def test_single_song(): n = 1 T = 10 songs = [ ('song1', 5) ] result = create_playlist(n, T, songs) assert result == ['song1']","solution":"from typing import List, Tuple def create_playlist(n: int, T: int, songs: List[Tuple[str, int]]) -> List[str]: Creates a playlist maximizing the number of songs without exceeding the duration T. If multiple playlists have the same number of songs, choose the one with the minimal total duration. If there are still multiple options, choose the lexicographically smallest list of song names. from itertools import combinations songs.sort() # Sort lexicographically by song name initially best_playlist = [] max_songs_count = 0 min_duration = float('inf') for i in range(1, n + 1): for combo in combinations(songs, i): total_duration = sum(song[1] for song in combo) if total_duration <= T: if i > max_songs_count or (i == max_songs_count and total_duration < min_duration): max_songs_count = i min_duration = total_duration best_playlist = list(combo) best_playlist.sort() # Ensure lexicographically smallest order return [song[0] for song in best_playlist]"},{"question":"def build_circular_network(n: int, roads: List[Tuple[int, int]]) -> Tuple[str, List[Tuple[int, int]]]: Determine if it is possible to build a circular network and provide the road orientations. Args: n (int): Number of neighborhoods. roads (List[Tuple[int, int]]): List of proposed roads connecting neighborhoods. Returns: Tuple[str, List[Tuple[int, int]]]: \\"YES\\" with road orientations if possible, \\"NO\\" otherwise. >>> build_circular_network(4, [(1, 2), (2, 3), (3, 4), (4, 1)]) (\\"YES\\", [(1, 2), (2, 3), (3, 4), (4, 1)]) >>> build_circular_network(3, [(1, 2), (2, 3), (3, 1)]) (\\"YES\\", [(1, 2), (2, 3), (3, 1)]) >>> build_circular_network(4, [(1, 2), (2, 3), (3, 4), (1, 3)]) (\\"NO\\", []) from solution import build_circular_network def test_example_1(): n = 4 roads = [(1, 2), (2, 3), (3, 4), (4, 1)] result, orientation = build_circular_network(n, roads) assert result == \\"YES\\" assert len(orientation) == 4 assert set(orientation) == set([(1, 2), (2, 3), (3, 4), (4, 1)]) def test_example_2(): n = 3 roads = [(1, 2), (2, 3), (3, 1)] result, orientation = build_circular_network(n, roads) assert result == \\"YES\\" assert len(orientation) == 3 assert set(orientation) == set([(1, 2), (2, 3), (3, 1)]) def test_example_3(): n = 4 roads = [(1, 2), (2, 3), (3, 4), (1, 3)] result, orientation = build_circular_network(n, roads) assert result == \\"NO\\" assert orientation == [] def test_case_no_with_more_than_cycle(): n = 4 roads = [(1, 2), (2, 3), (3, 4), (4, 1), (2, 4)] result, orientation = build_circular_network(n, roads) assert result == \\"NO\\" assert orientation == [] def test_complex_valid_case(): n = 5 roads = [(1, 2), (2, 3), (3, 4), (4, 5), (5, 1)] result, orientation = build_circular_network(n, roads) assert result == \\"YES\\" assert len(orientation) == 5 assert set(orientation) == set([(1, 2), (2, 3), (3, 4), (4, 5), (5, 1)])","solution":"def build_circular_network(n, roads): from collections import defaultdict # Create graph graph = defaultdict(list) for a, b in roads: graph[a].append(b) graph[b].append(a) # Check if each node has exactly 2 neighbors for node in graph: if len(graph[node]) != 2: return \\"NO\\", [] # Visited set to keep track of the visited nodes visited = set() # To store the circular path path = [] def dfs(node, parent): visited.add(node) path.append(node) for neighbor in graph[node]: if neighbor == parent: # Don't go back to the parent node continue if neighbor in visited: # If we visit a visited node and it's not the parent # then it's a cycle and so we should end the search path.append(neighbor) return True if dfs(neighbor, node): return True path.pop() return False # Start DFS from any node, we'll pick node 1 if dfs(1, -1): # If the path represents a circular route if len(path) == n + 1 and path[0] == path[-1]: orientation = [(path[i], path[i + 1]) for i in range(n)] return \\"YES\\", orientation else: return \\"NO\\", [] else: return \\"NO\\", []"},{"question":"import heapq class CarWhiteboard: def __init__(self): self.present_cars = set() self.min_heap = [] def register_car(self, car_id): Register the arrival of the car with ID car_id on the whiteboard pass def sell_car(self, car_id): Sell (remove) the car with ID car_id from the whiteboard pass def get_smallest_car_id(self): Query the smallest car ID currently on the whiteboard. Returns the smallest car ID or -1 if the whiteboard is empty. pass def manage_car_operations(n, q, operations): Perform q operations to maintain the records of car IDs on the whiteboard. Returns results of each query (\\"3\\" operation). Args: n (int): The total number of different car IDs. q (int): The number of operations. operations (List[List[int]]): The list of operations. Returns: List[int]: The results of each query operation. pass # Unit tests def test_example_case(): n, q = 5, 7 operations = [[1, 3], [1, 1], [1, 2], [3], [2, 1], [3], [2, 3]] assert manage_car_operations(n, q, operations) == [1, 2] def test_no_cars(): n, q = 5, 1 operations = [[3]] assert manage_car_operations(n, q, operations) == [-1] def test_single_register_and_query(): n, q = 5, 2 operations = [[1, 2], [3]] assert manage_car_operations(n, q, operations) == [2] def test_sell_all_cars(): n, q = 5, 7 operations = [[1, 4], [1, 3], [1, 1], [2, 3], [2, 1], [2, 4], [3]] assert manage_car_operations(n, q, operations) == [-1] def test_multiple_queries(): n, q = 5, 6 operations = [[1, 5], [1, 3], [3], [2, 3], [3], [2, 5]] assert manage_car_operations(n, q, operations) == [3, 5] def test_register_all_sell_some(): n, q = 5, 8 operations = [[1, 1], [1, 2], [1, 3], [1, 4], [1, 5], [2, 2], [2, 4], [3]] assert manage_car_operations(n, q, operations) == [1]","solution":"import heapq class CarWhiteboard: def __init__(self): self.present_cars = set() self.min_heap = [] def register_car(self, car_id): if car_id not in self.present_cars: self.present_cars.add(car_id) heapq.heappush(self.min_heap, car_id) def sell_car(self, car_id): if car_id in self.present_cars: self.present_cars.remove(car_id) def get_smallest_car_id(self): while self.min_heap and self.min_heap[0] not in self.present_cars: heapq.heappop(self.min_heap) if self.min_heap: return self.min_heap[0] else: return -1 def manage_car_operations(n, q, operations): whiteboard = CarWhiteboard() result = [] for operation in operations: if operation[0] == 1: whiteboard.register_car(operation[1]) elif operation[0] == 2: whiteboard.sell_car(operation[1]) elif operation[0] == 3: result.append(whiteboard.get_smallest_car_id()) return result"},{"question":"def find_special_number(n: int) -> int: Returns the smallest \\"special\\" number that is greater than or equal to n. A number is \\"special\\" if it is divisible by 7 or contains the digit '7'. >>> find_special_number(20) == 21 >>> find_special_number(70) == 70 >>> find_special_number(5) == 7 pass def special_numbers_for_cases(cases: List[int]) -> List[int]: Returns the special numbers for each test case. >>> special_numbers_for_cases([20, 70, 5]) == [21, 70, 7] pass from solution import find_special_number, special_numbers_for_cases def test_find_special_number(): # Test cases assert find_special_number(20) == 21 assert find_special_number(70) == 70 assert find_special_number(5) == 7 assert find_special_number(1) == 7 assert find_special_number(18) == 21 assert find_special_number(77) == 77 assert find_special_number(100) == 105 def test_special_numbers_for_cases(): # Test case input list cases = [20, 70, 5, 1, 18, 77, 100] output = [21, 70, 7, 7, 21, 77, 105] assert special_numbers_for_cases(cases) == output","solution":"def find_special_number(n): Returns the smallest \\"special\\" number that is greater than or equal to n. A number is \\"special\\" if it is divisible by 7 or contains the digit '7'. while True: if n % 7 == 0 or '7' in str(n): return n n += 1 def special_numbers_for_cases(cases): Returns the special numbers for each test case. result = [] for num in cases: result.append(find_special_number(num)) return result"},{"question":"class SimpleQueue: def __init__(self): self.queue = [] def enqueue(self, x): self.queue.append(x) def dequeue(self): if self.queue: return self.queue.pop(0) else: return 'empty' def process_instructions(instructions): queue = SimpleQueue() result = [] for instruction in instructions: if instruction.startswith('enqueue'): _, x = instruction.split() queue.enqueue(int(x)) elif instruction == 'dequeue': result.append(queue.dequeue()) return result def test_enqueue_and_dequeue(): instructions = [ \\"enqueue 5\\", \\"enqueue 10\\", \\"dequeue\\", \\"enqueue 15\\", \\"dequeue\\", \\"dequeue\\", \\"dequeue\\", ] expected_output = [5, 10, 15, 'empty'] assert process_instructions(instructions) == expected_output def test_dequeue_empty(): instructions = [ \\"dequeue\\", \\"enqueue 7\\", \\"enqueue 3\\", \\"dequeue\\", \\"enqueue 12\\", ] expected_output = ['empty', 7] assert process_instructions(instructions) == expected_output def test_multiple_enqueues(): instructions = [ \\"enqueue 1\\", \\"enqueue 2\\", \\"enqueue 3\\", \\"dequeue\\", \\"dequeue\\", \\"dequeue\\", \\"dequeue\\" ] expected_output = [1, 2, 3, 'empty'] assert process_instructions(instructions) == expected_output def test_all_dequeues(): instructions = [ \\"enqueue 4\\", \\"enqueue 5\\", \\"dequeue\\", \\"dequeue\\", \\"dequeue\\", \\"enqueue 6\\", \\"dequeue\\" ] expected_output = [4, 5, 'empty', 6] assert process_instructions(instructions) == expected_output def test_single_enqueue_dequeue(): instructions = [ \\"enqueue 99\\", \\"dequeue\\" ] expected_output = [99] assert process_instructions(instructions) == expected_output","solution":"class SimpleQueue: def __init__(self): self.queue = [] def enqueue(self, x): self.queue.append(x) def dequeue(self): if self.queue: return self.queue.pop(0) else: return 'empty' def process_instructions(instructions): queue = SimpleQueue() result = [] for instruction in instructions: if instruction.startswith('enqueue'): _, x = instruction.split() queue.enqueue(int(x)) elif instruction == 'dequeue': result.append(queue.dequeue()) return result"},{"question":"def has_subarray_with_sum(arr, target_sum): Check if there exists a subarray with a sum equal to the target_sum. >>> has_subarray_with_sum([1, 2, 3, 4, 5], 9) True >>> has_subarray_with_sum([1, 2, 3, 4, 5], 15) True >>> has_subarray_with_sum([1, 2, 3, 4, 5], 20) False >>> has_subarray_with_sum([-1, -2, -3, -4, -5], -10) True >>> has_subarray_with_sum([5], 5) True >>> has_subarray_with_sum([5], 10) False >>> has_subarray_with_sum([], 0) False >>> has_subarray_with_sum([0, 1, 2], 0) True >>> has_subarray_with_sum([1, -1, 2, -2, 3, -3], 0) True","solution":"def has_subarray_with_sum(arr, target_sum): Check if there exists a subarray with a sum equal to the target_sum. current_sum = 0 prefix_sums = {0: -1} # Store cumulative sums with their corresponding index for i, num in enumerate(arr): current_sum += num # Check if there is a prefix sum that we can subtract to get the target_sum if current_sum - target_sum in prefix_sums: return True # Store the current_sum with its corresponding index prefix_sums[current_sum] = i return False"},{"question":"from typing import List, Tuple def max_tasks(tasks: List[Tuple[int, int]]) -> int: Calculate the maximum number of non-overlapping tasks that can be completed before their deadlines. pass def process_input(input_data: str) -> List[int]: Process the input data and applies the \`max_tasks\` function on each dataset. pass # Example test cases def test_single_task(): tasks = [(5, 3)] assert max_tasks(tasks) == 1 def test_multiple_tasks_no_overlap(): tasks = [(6, 2), (8, 1), (7, 4)] assert max_tasks(tasks) == 3 def test_multiple_tasks_with_overlap(): tasks = [(6, 4), (8, 2), (7, 3)] assert max_tasks(tasks) == 2 def test_process_input(): input_data = \\"3n6 4n8 2n7 3n4n6 2n8 1n7 4n9 3n0\\" expected_output = [2, 3] assert process_input(input_data) == expected_output def test_zero_tasks(): input_data = \\"0\\" assert process_input(input_data) == [] def test_edge_case_deadline_equals_duration(): tasks = [(5, 5), (10, 5)] assert max_tasks(tasks) == 2","solution":"def max_tasks(tasks): Calculate the maximum number of non-overlapping tasks that can be completed before their deadlines. # Sort tasks by their deadlines tasks.sort(key=lambda x: x[0]) completed_tasks = 0 current_time = 0 for deadline, duration in tasks: if current_time + duration <= deadline: current_time += duration completed_tasks += 1 return completed_tasks def process_input(input_data): Process the input data and applies the \`max_tasks\` function on each dataset. result = [] lines = input_data.strip().split('n') i = 0 while i < len(lines): n = int(lines[i]) if n == 0: break i += 1 tasks = [] for _ in range(n): d, t = map(int, lines[i].split()) tasks.append((d, t)) i += 1 result.append(max_tasks(tasks)) return result"},{"question":"def process_queries(n: int, m: int, array: List[int], queries: List[List[int]]) -> None: Process the queries on the array as per the described rules. For each query of type 2, print the sum of the sub-array in a new line. Args: n : int : The number of elements in the array m : int : The number of queries array : List[int] : The initial array of integers queries : List[List[int]] : The list of queries, where each query is in the format [type, l, r, (optional) x] Example: >>> n = 5 >>> m = 4 >>> array = [5, 3, -1, 7, 2] >>> queries = [ >>> [1, 2, 4, 3], >>> [2, 1, 5], >>> [1, 1, 3, -2], >>> [2, 2, 4] >>> ] >>> process_queries(n, m, array, queries) 25 14 # You can use the following test cases to verify your implementation: def test_process_queries_with_example(): from io import StringIO import sys # Capture the output output = StringIO() sys.stdout = output n = 5 m = 4 array = [5, 3, -1, 7, 2] queries = [ [1, 2, 4, 3], [2, 1, 5], [1, 1, 3, -2], [2, 2, 4] ] process_queries(n, m, array, queries) # Reset stdout sys.stdout = sys.__stdout__ # Get the expected output expected_output = \\"25n14n\\" assert output.getvalue() == expected_output def test_process_queries_with_another_example(): from io import StringIO import sys # Capture the output output = StringIO() sys.stdout = output n = 3 m = 2 array = [1, 2, 3] queries = [ [1, 1, 2, 1], [2, 1, 3], ] process_queries(n, m, array, queries) # Reset stdout sys.stdout = sys.__stdout__ # Get the expected output expected_output = \\"8n\\" assert output.getvalue() == expected_output def test_process_queries_with_all_type_1_queries(): n = 4 m = 3 array = [1, 1, 1, 1] queries = [ [1, 1, 2, 2], [1, 2, 3, 3], [1, 3, 4, 4] ] expected_result = [3, 6, 8, 5] process_queries(n, m, array, queries) assert array == expected_result def test_process_queries_with_only_type_2_queries(): from io import StringIO import sys # Capture the output output = StringIO() sys.stdout = output n = 4 m = 2 array = [1, 2, 3, 4] queries = [ [2, 1, 4], [2, 2, 3] ] process_queries(n, m, array, queries) # Reset stdout sys.stdout = sys.__stdout__ # Get the expected output expected_output = \\"10n5n\\" assert output.getvalue() == expected_output","solution":"def process_queries(n, m, array, queries): for query in queries: if query[0] == 1: _, l, r, x = query for i in range(l-1, r): array[i] += x elif query[0] == 2: _, l, r = query print(sum(array[l-1:r]))"},{"question":"def min_moves_to_destination(n: int, teleport_coords: List[Tuple[int, int, int]], final_dest: Tuple[int, int, int]) -> int: Determine the minimum number of moves required for a spaceship to reach the final destination from the origin. The spaceship can either \\"Travel\\" to a specified coordinate directly, or \\"Teleport\\" to one of the given teleport coordinates once. The \\"Travel\\" operation can be used any number of times. :param n: Number of available teleport coordinates :param teleport_coords: List of n tuples, each tuple representing (xi, yi, zi) :param final_dest: A tuple representing the final destination coordinates (xf, yf, zf) :return: Minimum number of moves as an integer Examples: >>> min_moves_to_destination(3, [(10, 0, 0), (5, 5, 5), (1, 2, 3)], (1, 1, 1)) 2 >>> min_moves_to_destination(2, [(1, 2, 3), (4, 5, 6)], (4, 5, 6)) 1 >>> min_moves_to_destination(0, [], (3, 4, 5)) 1","solution":"def min_moves_to_destination(n, teleport_coords, final_dest): Returns the minimum number of moves required to reach the final destination from the origin. :param n: Number of available teleport coordinates :param teleport_coords: List of n tuples, each tuple representing (xi, yi, zi) :param final_dest: A tuple representing the final destination coordinates (xf, yf, zf) :return: Minimum number of moves as an integer # Unpack final destination coordinates xf, yf, zf = final_dest # If final destination is the same as one of the teleport coordinates, # we can teleport directly to the destination in one move. if (xf, yf, zf) in teleport_coords: return 1 min_moves = 1 # Direct travel to the final destination # Check if we can minimize moves using teleportation for (xi, yi, zi) in teleport_coords: # We would perform 1 move to teleport and another move to travel to the final destination if xi != xf or yi != yf or zi != zf: min_moves = 2 return min_moves"},{"question":"from typing import List from collections import Counter def can_form_palindrome(s: str) -> str: Checks if it is possible to rearrange the gems to form a palindrome. :param s: A string representing the gems in the necklace. :return: \\"YES\\" if it's possible to rearrange the gems to form a palindrome, otherwise \\"NO\\". Examples: >>> can_form_palindrome(\\"aabb\\") \\"YES\\" >>> can_form_palindrome(\\"aaabb\\") \\"YES\\" >>> can_form_palindrome(\\"abc\\") \\"NO\\"","solution":"from collections import Counter def can_form_palindrome(s): Checks if it is possible to rearrange the gems to form a palindrome. :param s: A string representing the gems in the necklace. :return: \\"YES\\" if it's possible to rearrange the gems to form a palindrome, otherwise \\"NO\\". # count the occurrences of each character char_count = Counter(s) # count how many characters have odd occurrences odd_count = sum(1 for count in char_count.values() if count % 2 != 0) # a palindrome can have at most one character with an odd count if odd_count > 1: return \\"NO\\" else: return \\"YES\\""},{"question":"def max_time_difference(n: int, times: List[int]) -> int: Returns the maximum difference in completion time between any two participants. >>> max_time_difference(5, [120, 85, 140, 95, 110]) 55 >>> max_time_difference(3, [200, 150, 180]) 50","solution":"def max_time_difference(n, times): Returns the maximum difference in completion time between any two participants. max_time = max(times) min_time = min(times) return max_time - min_time"},{"question":"def magical_powers(n: int, q: int, powers: List[int], queries: List[Tuple[int, int]]) -> List[int]: Compute the sum of magical powers for the specified range of trees. Args: n (int): Number of magical trees. q (int): Number of queries. powers (list of int): List of magical powers of the trees. queries (list of tuples): List of queries where each query is a tuple (l, r). Returns: list of int: The sum of magical powers for each query. Example: >>> magical_powers(5, 3, [1, 2, 3, 4, 5], [(1, 3), (2, 4), (1, 5)]) [6, 9, 15] >>> magical_powers(4, 2, [-1, -2, -3, -4], [(1, 2), (2, 4)]) [-3, -9] pass from typing import List, Tuple def test_example_case(): n = 5 q = 3 powers = [1, 2, 3, 4, 5] queries = [(1, 3), (2, 4), (1, 5)] expected_output = [6, 9, 15] assert magical_powers(n, q, powers, queries) == expected_output def test_single_tree(): n = 1 q = 1 powers = [10] queries = [(1, 1)] expected_output = [10] assert magical_powers(n, q, powers, queries) == expected_output def test_all_negative_powers(): n = 4 q = 2 powers = [-1, -2, -3, -4] queries = [(1, 2), (2, 4)] expected_output = [-3, -9] assert magical_powers(n, q, powers, queries) == expected_output def test_mixed_powers(): n = 6 q = 3 powers = [-1, -2, 3, 4, -5, 6] queries = [(1, 3), (2, 5), (3, 6)] expected_output = [0, 0, 8] assert magical_powers(n, q, powers, queries) == expected_output def test_large_case(): n = 100000 q = 1 powers = [i for i in range(1, 100001)] queries = [(1, 100000)] expected_output = [5000050000] # Sum of first 100000 natural numbers assert magical_powers(n, q, powers, queries) == expected_output","solution":"def magical_powers(n, q, powers, queries): Compute the sum of magical powers for the specified range of trees. Args: n (int): Number of magical trees. q (int): Number of queries. powers (list of int): List of magical powers of the trees. queries (list of tuples): List of queries where each query is a tuple (l, r). Returns: list of int: The sum of magical powers for each query. # Create a prefix sum array prefix_sum = [0] * (n + 1) for i in range(1, n + 1): prefix_sum[i] = prefix_sum[i - 1] + powers[i - 1] results = [] for l, r in queries: results.append(prefix_sum[r] - prefix_sum[l - 1]) return results"},{"question":"def min_matches_to_determine_champion(n: int, player_types: str, matches: List[Tuple[int, int]]) -> int: Determines the minimum number of matches required to find a unique champion in the tournament. :param n: int - number of players. :param player_types: str - string of length n, where 'R' represents rookie and 'V' represents veteran. :param matches: list of tuples - each tuple (ui, vi) represents a match in which player ui won against player vi. The sequence stops when the tuple (0, 0) is encountered. :return: int - minimum number of matches required to ensure a unique champion's determination. pass from solution import min_matches_to_determine_champion def test_min_matches_case_1(): assert min_matches_to_determine_champion(5, \\"RRRVV\\", [(5, 2), (4, 3), (1, 2), (3, 5), (4, 1), (0, 0)]) == 4 def test_min_matches_case_2(): assert min_matches_to_determine_champion(6, \\"RRVVVV\\", [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (0, 0)]) == 5 def test_min_matches_single_player(): assert min_matches_to_determine_champion(1, \\"R\\", [(0, 0)]) == 0 def test_min_matches_two_players(): assert min_matches_to_determine_champion(2, \\"RV\\", [(1, 2), (0, 0)]) == 1 def test_min_matches_three_players(): assert min_matches_to_determine_champion(3, \\"RRV\\", [(1, 2), (2, 3), (0, 0)]) == 2","solution":"def min_matches_to_determine_champion(n, player_types, matches): Determines the minimum number of matches required to find a unique champion in the tournament. :param n: int - number of players. :param player_types: str - string of length n, where 'R' represents rookie and 'V' represents veteran. :param matches: list of tuples - each tuple (ui, vi) represents a match in which player ui won against player vi. The sequence stops when the tuple (0, 0) is encountered. :return: int - minimum number of matches required to ensure a unique champion's determination. # We need at least n-1 matches to determine a unique champion min_matches = n - 1 return min_matches"},{"question":"def can_form_perfect_skyline(n: int, heights: List[int]) -> str: Determines if the list of building heights can be arranged to form a perfect skyline. Args: n (int): The number of buildings. heights (list): The heights of the buildings. Returns: str: \\"YES\\" if a perfect skyline can be formed, otherwise \\"NO\\". ... def test_perfect_skyline(): assert can_form_perfect_skyline(5, [3, 6, 7, 5, 1]) == \\"YES\\" assert can_form_perfect_skyline(4, [2, 4, 6, 6]) == \\"NO\\" assert can_form_perfect_skyline(3, [1, 3, 2]) == \\"YES\\" assert can_form_perfect_skyline(1, [1]) == \\"NO\\" assert can_form_perfect_skyline(5, [5, 5, 5, 5, 5]) == \\"NO\\" assert can_form_perfect_skyline(6, [1, 2, 3, 4, 5, 6]) == \\"YES\\" assert can_form_perfect_skyline(7, [8, 3, 5, 6, 7, 4, 2]) == \\"YES\\" # Include this to ensure pytest can find the function in this block if __name__ == \\"__main__\\": import pytest pytest.main([__file__])","solution":"def can_form_perfect_skyline(n, heights): Determines if the list of building heights can be arranged to form a perfect skyline. Args: n (int): The number of buildings. heights (list): The heights of the buildings. Returns: str: \\"YES\\" if a perfect skyline can be formed, otherwise \\"NO\\". if n == 1: return \\"NO\\" # A single building can't form a perfect skyline unique_heights = set(heights) if len(unique_heights) != len(heights): # Ensure all heights are unique return \\"NO\\" sorted_heights = sorted(heights) mid = n // 2 # Handle case with even number of buildings if n % 2 == 0: if sorted_heights[mid - 1] != sorted_heights[mid]: return \\"YES\\" # Handle case with odd number of buildings else: if sorted_heights[mid - 1] != sorted_heights[mid + 1]: return \\"YES\\" return \\"NO\\""},{"question":"def num_routes(n: int, m: int) -> int: Returns the number of unique routes from the top-left corner (1, 1) to the bottom-right corner (n, m) in a grid. >>> num_routes(2, 3) 3 >>> num_routes(3, 3) 6 >>> num_routes(4, 4) 20 >>> num_routes(1, 1) 1 >>> num_routes(2, 2) 2 >>> num_routes(3, 2) 3 >>> num_routes(2, 4) 4 pass from solution import num_routes def test_num_routes_2x3(): assert num_routes(2, 3) == 3 def test_num_routes_3x3(): assert num_routes(3, 3) == 6 def test_num_routes_4x4(): assert num_routes(4, 4) == 20 def test_num_routes_1x1(): assert num_routes(1, 1) == 1 def test_num_routes_2x2(): assert num_routes(2, 2) == 2 def test_num_routes_3x2(): assert num_routes(3, 2) == 3 def test_num_routes_2x4(): assert num_routes(2, 4) == 4 def test_num_routes_large_grid(): # Large test case to ensure the function handles the upper limits assert num_routes(15, 15) == 40116600 # This is a known combinatorial result","solution":"def num_routes(n, m): Returns the number of unique routes from the top-left corner (1, 1) to the bottom-right corner (n, m) in a grid. # Create a 2D array to store the number of ways to reach each cell dp = [[0] * m for _ in range(n)] # Starting point dp[0][0] = 1 # Fill the dp array for i in range(n): for j in range(m): if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[n-1][m-1]"},{"question":"def max_books(n, weights, limit): Calculate the maximum number of books that can be transported without exceeding the weight limit. Parameters: n (int): Number of books weights (list of int): List of weights of the books limit (int): Weight limit of the car Returns: int: Maximum number of books that can be transported >>> max_books(5, [3000, 2000, 4000, 1000, 3500], 8500) 3 >>> max_books(4, [2000, 2000, 2000, 2000], 8000) 4 >>> max_books(3, [3000, 4000, 5000], 2000) 0 >>> max_books(4, [2000, 1000, 3000, 4000], 1000) 1 >>> max_books(5, [1000000, 1000000, 1000000, 1000000, 1000000], 1000000) 1 >>> max_books(5, [500, 3000, 2500, 1500, 1000], 4500) 3","solution":"def max_books(n, weights, limit): Calculate the maximum number of books that can be transported without exceeding the weight limit. Parameters: n (int): Number of books weights (list of int): List of weights of the books limit (int): Weight limit of the car Returns: int: Maximum number of books that can be transported # Sorting weights in ascending order weights.sort() total_weight = 0 count = 0 for weight in weights: if total_weight + weight <= limit: total_weight += weight count += 1 else: break return count"},{"question":"def classify_dish(): Classifies a dish as \\"simple\\" or \\"complex\\" based on the number of ingredients and steps. Example: Interaction: > Ingredients > Steps Output: > 3 (number of ingredients) > 4 (number of steps) > simple pass","solution":"def classify_dish(): Classifies a dish as \\"simple\\" or \\"complex\\" based on the number of ingredients and steps. print(\\"Ingredients\\", flush=True) num_ingredients = int(input()) print(\\"Steps\\", flush=True) num_steps = int(input()) if num_ingredients < 5 and num_steps < 5: print(\\"simple\\") else: print(\\"complex\\")"},{"question":"from typing import List, Tuple def update_value(values: List[int], x: int, y: int): Updates the value at node x to y. values[x-1] = y def max_shortest_path_value(graph: List[List[int]], values: List[int], x: int, y: int) -> int: Finds the maximum shortest path value between nodes x and y. Args: graph: A list of lists representing the graph adjacency list. values: A list of integers representing the node values. x: The starting node. y: The ending node. Returns: The maximum value among all nodes on the shortest path between x and y. pass def process_queries(n: int, m: int, q: int, values: List[int], edges: List[Tuple[int, int]], queries: List[Tuple[str, int, int]]) -> List[int]: Processes a list of queries. Args: n: The number of nodes. m: The number of edges. q: The number of queries. values: A list of integers representing the node values. edges: A list of tuples representing the edges between nodes. queries: A list of tuples representing the queries. Returns: A list of integers representing the results of 'S' queries. pass def main(): import sys input = sys.stdin.read data = input().split() index = 0 n = int(data[index]) m = int(data[index + 1]) q = int(data[index + 2]) index += 3 values = list(map(int, data[index:index + n])) index += n edges = [] for _ in range(m): u = int(data[index]) v = int(data[index + 1]) edges.append((u, v)) index += 2 queries = [] for _ in range(q): type = data[index] x = data[index + 1] y = data[index + 2] queries.append((type, x, y)) index += 3 results = process_queries(n, m, q, values, edges, queries) for result in results: print(result) if __name__ == \\"__main__\\": main()","solution":"import heapq def update_value(values, x, y): values[x-1] = y def max_shortest_path_value(graph, values, x, y): n = len(values) INF = float('inf') dist = [INF] * n visited = [False] * n max_values = [0] * n pq = [] dist[x-1] = 0 max_values[x-1] = values[x-1] heapq.heappush(pq, (0, x-1)) while pq: d, node = heapq.heappop(pq) if visited[node]: continue visited[node] = True for neighbor in graph[node]: if dist[neighbor] > d + 1: dist[neighbor] = d + 1 max_values[neighbor] = max(max_values[node], values[neighbor]) heapq.heappush(pq, (dist[neighbor], neighbor)) elif dist[neighbor] == d + 1: if max_values[neighbor] < max(max_values[node], values[neighbor]): max_values[neighbor] = max(max_values[node], values[neighbor]) heapq.heappush(pq, (dist[neighbor], neighbor)) return max_values[y-1] def process_queries(n, m, q, values, edges, queries): graph = [[] for _ in range(n)] for u, v in edges: graph[u-1].append(v-1) graph[v-1].append(u-1) results = [] for query in queries: type, x, y = query[0], int(query[1]), int(query[2]) if type == 'U': update_value(values, x, y) elif type == 'S': result = max_shortest_path_value(graph, values, x, y) results.append(result) return results def main(): import sys input = sys.stdin.read data = input().split() index = 0 n = int(data[index]) m = int(data[index + 1]) q = int(data[index + 2]) index += 3 values = list(map(int, data[index:index + n])) index += n edges = [] for _ in range(m): u = int(data[index]) v = int(data[index + 1]) edges.append((u, v)) index += 2 queries = [] for _ in range(q): type = data[index] x = data[index + 1] y = data[index + 2] queries.append((type, x, y)) index += 3 results = process_queries(n, m, q, values, edges, queries) for result in results: print(result) if __name__ == \\"__main__\\": main()"},{"question":"def distinct_substrings_count(s: str) -> int: Returns the number of distinct substrings of the string s that start and end with the same character. >>> distinct_substrings_count(\\"ababc\\") 7 >>> distinct_substrings_count(\\"aaaaa\\") 15 def count_substrings_in_test_cases(test_cases: List[str]) -> List[int]: For each string S in test_cases, compute the number of distinct substrings that start and end with the same character. >>> count_substrings_in_test_cases([\\"ababc\\", \\"aaaaa\\"]) [7, 15] >>> count_substrings_in_test_cases([\\"abcde\\", \\"aa\\"]) [5, 3] def test_distinct_substrings_count(): assert distinct_substrings_count(\\"ababc\\") == 7 assert distinct_substrings_count(\\"aaaaa\\") == 15 assert distinct_substrings_count(\\"abcde\\") == 5 assert distinct_substrings_count(\\"a\\") == 1 assert distinct_substrings_count(\\"aa\\") == 3 def test_count_substrings_in_test_cases(): test_cases = [\\"ababc\\", \\"aaaaa\\"] expected_outputs = [7, 15] assert count_substrings_in_test_cases(test_cases) == expected_outputs test_cases = [\\"abcde\\", \\"aa\\"] expected_outputs = [5, 3] assert count_substrings_in_test_cases(test_cases) == expected_outputs","solution":"def distinct_substrings_count(s): Returns the number of distinct substrings of the string s that start and end with the same character. count = 0 n = len(s) for i in range(n): for j in range(i, n): if s[i] == s[j]: count += 1 return count def count_substrings_in_test_cases(test_cases): For each string S in test_cases, compute the number of distinct substrings that start and end with the same character. results = [] for s in test_cases: results.append(distinct_substrings_count(s)) return results"},{"question":"def can_fit_books_on_shelf(n, w, b): Given the capacity of the shelf (n), the width of each book (w), and the number of books (b) on the cart, determine if all books can fit on the shelf. :param n: int - capacity of the shelf :param w: int - width of each book :param b: int - number of books :return: str - \\"YES\\" if all books can fit, otherwise \\"NO\\" def process_test_cases(t, test_cases): Process multiple test cases and determine if all books can fit on the shelf for each test case. :param t: int - number of test cases :param test_cases: List[Tuple[int, int, int]] - list of tuples, where each tuple contains (n, w, b) :return: List[str] - list of results for each test case, \\"YES\\" or \\"NO\\"","solution":"def can_fit_books_on_shelf(n, w, b): Given the capacity of the shelf (n), the width of each book (w), and the number of books (b) on the cart, determine if all books can fit on the shelf. :param n: int - capacity of the shelf :param w: int - width of each book :param b: int - number of books :return: str - \\"YES\\" if all books can fit, otherwise \\"NO\\" return \\"YES\\" if (w * b) <= n else \\"NO\\" def process_test_cases(t, test_cases): results = [] for case in test_cases: n, w, b = case results.append(can_fit_books_on_shelf(n, w, b)) return results"},{"question":"def can_partition(nums): Determine if the array can be partitioned into two subsets with equal sum. >>> can_partition([1, 5, 11, 5]) 'true' >>> can_partition([1, 2, 3, 5]) 'false'","solution":"def can_partition(nums): Determine if the array can be partitioned into two subsets with equal sum. total_sum = sum(nums) # If the total sum is odd, we can't partition it into two equal subsets if total_sum % 2 != 0: return \\"false\\" target = total_sum // 2 n = len(nums) dp = [False] * (target + 1) dp[0] = True for num in nums: for j in range(target, num - 1, -1): dp[j] = dp[j] or dp[j - num] return \\"true\\" if dp[target] else \\"false\\""},{"question":"def min_cost_path(grid: List[List[int]]) -> int: Returns the minimum cost path for the robot to reach the bottom-right corner of the grid. Args: grid: A 2D list of integers representing the cost grid. Returns: An integer representing the minimum cost path from the top-left to the bottom-right corner. Examples: >>> min_cost_path([ ... [1, 3, 1], ... [1, 5, 1], ... [4, 2, 1] ... ]) 7 >>> min_cost_path([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) 21","solution":"def min_cost_path(grid): Returns the minimum cost path for the robot to reach the bottom-right corner of the grid. m = len(grid) n = len(grid[0]) dp = [[0] * n for _ in range(m)] dp[0][0] = grid[0][0] # Initialize the first row for i in range(1, n): dp[0][i] = dp[0][i - 1] + grid[0][i] # Initialize the first column for i in range(1, m): dp[i][0] = dp[i - 1][0] + grid[i][0] # Fill the rest of the dp table for i in range(1, m): for j in range(1, n): dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j] return dp[m - 1][n - 1]"},{"question":"def distribute_participants(total_participants: int, num_groups: int) -> List[int]: Distributes participants into groups as evenly as possible. :param total_participants: Total number of participants (integer) :param num_groups: Number of groups (integer) :return: A list of integers representing the number of participants in each group >>> distribute_participants(10, 2) == [5, 5] >>> distribute_participants(10, 3) == [4, 3, 3] >>> distribute_participants(7, 3) == [3, 2, 2] >>> distribute_participants(9, 3) == [3, 3, 3] >>> distribute_participants(5, 10) == [1, 1, 1, 1, 1, 0, 0, 0, 0, 0] >>> distribute_participants(1, 1) == [1] >>> distribute_participants(10, 1) == [10] >>> distribute_participants(0, 5) == [0, 0, 0, 0, 0] try: distribute_participants(10, 0) except ZeroDivisionError: assert True else: assert False","solution":"def distribute_participants(total_participants, num_groups): Distributes participants into groups as evenly as possible. :param total_participants: Total number of participants (integer) :param num_groups: Number of groups (integer) :return: A list of integers representing the number of participants in each group base_participants = total_participants // num_groups remainder = total_participants % num_groups # Initially assign the 'base_participants' to each group distribution = [base_participants] * num_groups # Distribute the remainder among the groups for i in range(remainder): distribution[i] += 1 return distribution"},{"question":"def max_non_overlapping_tasks(n, tasks): Determines the maximum number of non-overlapping tasks that can be completed. Args: n (int): The number of tasks. tasks (list of tuples): Each tuple contains the start and end time of a task (si, ei). Returns: int: The maximum number of non-overlapping tasks. # Your code here # Unit Tests def test_example_1(): n = 5 tasks = [(1, 3), (2, 5), (4, 6), (6, 7), (5, 9)] assert max_non_overlapping_tasks(n, tasks) == 3 def test_example_2(): n = 3 tasks = [(1, 2), (2, 3), (3, 4)] assert max_non_overlapping_tasks(n, tasks) == 3 def test_all_tasks_overlap(): n = 3 tasks = [(1, 4), (2, 5), (3, 6)] assert max_non_overlapping_tasks(n, tasks) == 1 def test_no_tasks_overlap(): n = 4 tasks = [(1, 2), (3, 4), (5, 6), (7, 8)] assert max_non_overlapping_tasks(n, tasks) == 4 def test_mixed_tasks(): n = 6 tasks = [(1, 3), (1, 2), (2, 4), (3, 5), (5, 7), (6, 8)] assert max_non_overlapping_tasks(n, tasks) == 3 def test_single_task(): n = 1 tasks = [(0, 1)] assert max_non_overlapping_tasks(n, tasks) == 1 def test_large_input(): n = 100000 tasks = [(i, i+1) for i in range(0, 200000, 2)] assert max_non_overlapping_tasks(n, tasks) == 100000","solution":"def max_non_overlapping_tasks(n, tasks): Determines the maximum number of non-overlapping tasks that can be completed. Args: n (int): The number of tasks. tasks (list of tuples): Each tuple contains the start and end time of a task (si, ei). Returns: int: The maximum number of non-overlapping tasks. # Sort tasks by their end times tasks.sort(key=lambda x: x[1]) # Initialize the end time of the last finished task end_time = 0 count = 0 # Iterate through the tasks for task in tasks: if task[0] >= end_time: # If the start time of the current task is greater or equal to # the end time of the last finished task, we can schedule it. count += 1 end_time = task[1] return count"},{"question":"def min_height_difference(n, m, heights): Distribute m operations to minimize the difference between the height of the tallest and the shortest building. >>> min_height_difference(5, 3, [4, 9, 7, 8, 5]) 3 >>> min_height_difference(3, 1, [1, 2, 3]) 1","solution":"def min_height_difference(n, m, heights): heights.sort() # While we still have operations left to perform while m > 0: # Find the building with the maximum height heights.sort(reverse=True) max_height = heights[0] # Decrease the height of the tallest building heights[0] -= 1 m -= 1 # After all operations, calculate the difference return max(heights) - min(heights)"},{"question":"def kth_largest_elements(test_cases): Determines the k-th largest element from a sequence of integers for multiple test cases. Args: test_cases (list): List of tuples, where each tuple contains three elements: - int: n (number of integers) - int: k (which largest element to find) - list: Sequence of n integers Returns: list: List of k-th largest elements for each test case Examples: >>> kth_largest_elements([(5, 2, [1, 3, 5, 7, 9]), (5, 4, [4, 5, 1, 3, 2]), (6, 1, [7, 10, 4, 3, 20, 15])]) [7, 2, 20] >>> kth_largest_elements([(1, 1, [10])]) [10] >>> kth_largest_elements([(5, 1, [-1, -2, -3, -4, -5]), (5, 2, [-1, -2, -3, -4, -5])]) [-1, -2] >>> kth_largest_elements([(4, 2, [1, 2, 2, 3]), (4, 4, [1, 2, 2, 3])]) [2, 1] >>> kth_largest_elements([(105, 1, [i for i in range(1, 106)]), (105, 105, [i for i in range(1, 106)])]) [105, 1]","solution":"def kth_largest_elements(test_cases): results = [] for n, k, arr in test_cases: arr.sort(reverse=True) results.append(arr[k-1]) return results"},{"question":"from typing import List, Tuple def get_top_users(users: List[int], likes: List[Tuple[int, int]], k: int) -> List[int]: Given a list of user IDs and a list of likes where each like contains a post ID and the number of likes received, return the IDs of the top K users who have received the most likes. Args: users (List[int]): A list of integers representing user IDs. likes (List[Tuple[int, int]]): A list of tuples where each tuple consists of a post ID and the number of likes the post received. k (int): An integer representing the number of top users to return. Returns: List[int]: A list of integers representing the IDs of the top K users with the highest total likes. >>> users = [1, 2, 3, 4] >>> likes = [(1, 100), (2, 40), (3, 60), (4, 50), (1, 50), (2, 10), (3, 90), (4, 20)] >>> k = 2 >>> get_top_users(users, likes, k) [1, 3] >>> users = [1] >>> likes = [(1, 100), (1, 50), (1, 70)] >>> k = 1 >>> get_top_users(users, likes, k) [1] >>> users = [1, 2, 3] >>> likes = [(1, 30), (2, 40), (3, 30)] >>> k = 1 >>> get_top_users(users, likes, k) [2] >>> users = [1, 2, 3, 4] >>> likes = [(1, 10), (2, 10), (3, 10), (4, 10)] >>> k = 3 >>> result = get_top_users(users, likes, k) >>> len(result) 3 >>> users = [1, 2] >>> likes = [(1, 10), (2, 20)] >>> k = 3 >>> set(get_top_users(users, likes, k)) {1, 2}","solution":"from typing import List, Tuple from collections import defaultdict import heapq def get_top_users(users: List[int], likes: List[Tuple[int, int]], k: int) -> List[int]: user_likes = defaultdict(int) # Aggregate total likes for each user for post_id, like_count in likes: user_likes[post_id] += like_count # Use a heap to get the top k users by likes top_users = heapq.nlargest(k, user_likes.keys(), key=user_likes.get) return top_users # Example usage: users = [1, 2, 3, 4] likes = [(1, 100), (2, 40), (3, 60), (4, 50), (1, 50), (2, 10), (3, 90), (4, 20)] k = 2 print(get_top_users(users, likes, k)) # Output: [1, 3]"},{"question":"def text_editor(n: int, operations: List[str]) -> List[str]: Simulate the operations on a simple text editor. There are four types of operations: 1. '1 w' - Insert substring w at the end of the current text. 2. '2 k' - Delete the last k characters from the current text. 3. '3 k' - Print the character at the k-th position (1-based index) of the current text. 4. '4' - Undo the last operation (insert or delete, not print). Args: n: number of operations operations: a list of operations to be performed Returns: A list of characters printed by '3 k' operations. >>> text_editor(8, ['1 abc', '1 def', '3 4', '2 3', '3 3', '1 xyz', '4', '3 3']) ['d', 'c', 'c'] >>> text_editor(6, ['1 hello', '1 world', '3 1', '2 5', '3 5', '4']) ['h', 'o'] ...","solution":"def text_editor(n, operations): text = [] history = [] outputs = [] for operation in operations: command = operation.split() if command[0] == '1': # Insert history.append('1 ' + ''.join(text)) text.extend(command[1]) elif command[0] == '2': # Delete k = int(command[1]) history.append(''.join(text)) text = text[:-k] elif command[0] == '3': # Print k = int(command[1]) outputs.append(text[k-1]) elif command[0] == '4': # Undo if len(history) > 0: last_op = history.pop() if last_op.startswith('1 '): text = list(last_op[2:]) else: text = list(last_op) return outputs"},{"question":"def max_fully_completed_rows(n: int) -> int: Determines the maximum number of fully completed rows that can be formed with the given number of coins. Args: n (int): The total number of coins. Returns: int: The maximum number of fully completed rows. Examples: >>> max_fully_completed_rows(5) 2 >>> max_fully_completed_rows(8) 3","solution":"def max_fully_completed_rows(n): Determines the maximum number of fully completed rows that can be formed with the given number of coins. Args: n (int): The total number of coins. Returns: int: The maximum number of fully completed rows. # Binary search approach to find the maximum k such that (k * (k + 1)) / 2 <= n left, right = 0, n while left <= right: mid = (left + right) // 2 if mid * (mid + 1) // 2 <= n: left = mid + 1 else: right = mid - 1 return right"},{"question":"def optimize_container_stacking(r: int, c: int, weights: List[int]) -> List[List[int]]: Returns the optimized grid of containers such that the heaviest container is on top of any other container as less as possible. Args: - r (int): number of rows in the grid - c (int): number of columns in the grid - weights (list of int): weights of the containers in row-major order Returns: - grid (list of list of int): The 2D array representing the stacked containers. >>> optimize_container_stacking(2, 3, [3, 1, 2, 6, 4, 5]) [[1, 2, 3], [4, 5, 6]] >>> optimize_container_stacking(3, 2, [7, 6, 4, 3, 2, 1]) [[1, 2], [3, 4], [6, 7]] >>> optimize_container_stacking(1, 5, [5, 1, 3, 2, 4]) [[1, 2, 3, 4, 5]] >>> optimize_container_stacking(4, 1, [9, 3, 4, 2]) [[2], [3], [4], [9]] >>> optimize_container_stacking(1, 1, [10]) [[10]] >>> optimize_container_stacking(3, 3, [5, 2, 8, 1, 7, 4, 3, 6, 9]) [[1, 2, 3], [4, 5, 6], [7, 8, 9]]","solution":"def optimize_container_stacking(r, c, weights): Returns the optimized grid of containers such that the heaviest container is on top of any other container as less as possible. Args: - r (int): number of rows in the grid - c (int): number of columns in the grid - weights (list of int): weights of the containers in row-major order Returns: - grid (list of list of int): The 2D array representing the stacked containers. # Sort the container weights sorted_weights = sorted(weights) # Create the grid and fill it row by row grid = [] for i in range(r): row = sorted_weights[i*c:(i+1)*c] grid.append(row) return grid"},{"question":"def longest_contiguous_digits(strings): Extracts the longest contiguous substring of digits from each input string. Args: strings (list): List of input strings. Returns: list: List of results with the longest contiguous substring of digits from each input string. Example: >>> longest_contiguous_digits([\\"abc1234xyz123\\", \\"a1b2c3\\", \\"abcd\\"]) ['1234', '1', ''] >>> longest_contiguous_digits([\\"ab123cd456ef\\"]) ['123']","solution":"def longest_contiguous_digits(strings): Extracts the longest contiguous substring of digits from each input string. Args: strings (list): List of input strings. Returns: list: List of results with the longest contiguous substring of digits from each input string. results = [] for s in strings: max_substring = \\"\\" current_substring = \\"\\" for char in s: if char.isdigit(): current_substring += char if len(current_substring) > len(max_substring): max_substring = current_substring else: current_substring = \\"\\" results.append(max_substring) return results"},{"question":"def are_permutations(s1: str, s2: str) -> bool: Returns True if s1 is a permutation of s2, otherwise False. >>> are_permutations(\\"abc\\", \\"cab\\") True >>> are_permutations(\\"abc\\", \\"def\\") False >>> are_permutations(\\"aab\\", \\"baa\\") True >>> are_permutations(\\"abc\\", \\"abcd\\") False","solution":"def are_permutations(s1, s2): Returns True if s1 is a permutation of s2, otherwise False. if len(s1) != len(s2): return False from collections import Counter return Counter(s1) == Counter(s2)"},{"question":"def final_position(directions: str) -> tuple: Determine the final position of the robot on the grid following the directions. >>> final_position(\\"UUDDLRLR\\") (0, 0) >>> final_position(\\"UUUU\\") (0, 4) >>> final_position(\\"LLLLRRRR\\") (0, 0) >>> final_position(\\"D\\") (0, -1) >>> final_position(\\"RULDRUL\\") (0, 1)","solution":"def final_position(directions): Returns the final position of the robot after following the directions. x, y = 0, 0 for direction in directions: if direction == 'U': y += 1 elif direction == 'D': y -= 1 elif direction == 'L': x -= 1 elif direction == 'R': x += 1 return x, y"},{"question":"def find_peak(arr): Returns the index of any one peak element in the array. Args: arr (List[int]): The input array of integers. Returns: int: The index of any one peak element or -1 if the array is empty. Test cases: >>> find_peak([1, 3, 2]) 1 >>> find_peak([1, 2, 1, 3, 5]) in [1, 4] True >>> find_peak([10]) 0 >>> find_peak([]) -1 >>> find_peak([5, 4, 3, 2, 1]) 0 >>> find_peak([1, 2, 3, 4, 5]) 4 >>> find_peak([1000, 2000, 1500, 3000, 2500, 4000, 3500, 5000, 4500]) in [1, 3, 5, 7] True pass def find_peaks(test_cases): Find the peak elements for multiple test cases. Args: test_cases (List[Tuple[int, List[int]]]): List of test cases, each containing the size of array and the array itself. Returns: List[int]: List containing the index of the peak element for each test case. Test case: >>> find_peaks([(3, [1, 3, 2]), (5, [1, 2, 1, 3, 5])]) [1, 1] pass","solution":"def find_peak(arr): Returns the index of any one peak element in the array. if not arr: return -1 n = len(arr) # Binary search approach to find a peak, which operates in O(log N) time low, high = 0, n - 1 while low <= high: mid = (low + high) // 2 # Check if mid is a peak if (mid == 0 or arr[mid - 1] <= arr[mid]) and (mid == n - 1 or arr[mid + 1] <= arr[mid]): return mid # If the left neighbor is greater, then the peak must be in the left half if mid > 0 and arr[mid - 1] > arr[mid]: high = mid - 1 else: # Otherwise, the peak is in the right half low = mid + 1 return -1 def find_peaks(test_cases): results = [] for case in test_cases: n, arr = case results.append(find_peak(arr)) return results"},{"question":"def can_reach_bottom_right(n: int, m: int, grid: List[str]) -> str: Determine if there is a path for the robot from the top-left corner to the bottom-right corner. >>> can_reach_bottom_right(3, 3, [\\"..#\\", \\".#.\\", \\"...\\"]) \\"YES\\" >>> can_reach_bottom_right(3, 3, [\\"...\\", \\"#\\", \\"...\\"]) \\"NO\\"","solution":"def can_reach_bottom_right(n, m, grid): def is_valid(x, y): return 0 <= x < n and 0 <= y < m and grid[x][y] == '.' visited = [[False] * m for _ in range(n)] queue = [(0, 0)] while queue: x, y = queue.pop(0) if x == n-1 and y == m-1: return \\"YES\\" if visited[x][y]: continue visited[x][y] = True if is_valid(x + 1, y) and not visited[x + 1][y]: queue.append((x + 1, y)) if is_valid(x, y + 1) and not visited[x][y + 1]: queue.append((x, y + 1)) return \\"NO\\""},{"question":"from typing import List, Tuple def has_cycle(edges: List[Tuple[int, int]]) -> bool: Determine if the given undirected graph contains any cycles. Args: edges (List[Tuple[int, int]]): A list of tuples, where each tuple contains two integers representing a pair of nodes connected by an edge in the undirected graph. Returns: bool: True if there is at least one cycle in the graph, False otherwise. >>> has_cycle([(1, 2), (2, 3), (3, 1)]) True >>> has_cycle([(1, 2), (2, 3), (3, 4)]) False pass def test_has_cycle_simple_cycle(): edges = [(1, 2), (2, 3), (3, 1)] assert has_cycle(edges) == True def test_has_cycle_no_cycle(): edges = [(1, 2), (2, 3), (3, 4)] assert has_cycle(edges) == False def test_has_cycle_disconnected_parts_with_cycle(): edges = [(1, 2), (2, 3), (3, 1), (4, 5)] assert has_cycle(edges) == True def test_has_cycle_disconnected_no_cycle(): edges = [(1, 2), (3, 4)] assert has_cycle(edges) == False def test_has_cycle_large_cycle(): edges = [(i, i+1) for i in range(1, 10000)] + [(10000, 1)] assert has_cycle(edges) == True def test_has_cycle_large_no_cycle(): edges = [(i, i+1) for i in range(1, 10001)] assert has_cycle(edges) == False def test_has_cycle_one_edge(): edges = [(1, 2)] assert has_cycle(edges) == False def test_has_cycle_two_disconnected_cycles(): edges = [(1, 2), (2, 3), (3, 1), (4, 5), (5, 6), (6, 4)] assert has_cycle(edges) == True","solution":"from typing import List, Tuple def has_cycle(edges: List[Tuple[int, int]]) -> bool: parent = {} def find(node): if parent[node] != node: parent[node] = find(parent[node]) return parent[node] def union(node1, node2): root1 = find(node1) root2 = find(node2) if root1 == root2: return False parent[root2] = root1 return True for edge in edges: node1, node2 = edge if node1 not in parent: parent[node1] = node1 if node2 not in parent: parent[node2] = node2 if not union(node1, node2): return True return False"},{"question":"def smooth_path(n: int, m: int, k: int, elevation_lines: List[str]) -> str: Determine if there exists a smooth path from the upper-left corner to the bottom-right corner. Args: n (int): Number of rows in the grid. m (int): Number of columns in the grid. k (int): Maximum permitted elevation change. elevation_lines (List[str]): List of strings representing the grid's elevation rows. Returns: str: \\"YES\\" if there exists a smooth path, otherwise \\"NO\\". >>> smooth_path(3, 3, 2, [\\"1 2 3\\", \\"4 8 2\\", \\"1 4 7\\"]) 'NO' >>> smooth_path(2, 2, 1, [\\"0 1\\", \\"1 0\\"]) 'YES' pass # Unit tests def test_smooth_path_case1(): n, m, k = 3, 3, 2 elevation_lines = [ \\"1 2 3\\", \\"4 8 2\\", \\"1 4 7\\" ] assert smooth_path(n, m, k, elevation_lines) == \\"NO\\" def test_smooth_path_case2(): n, m, k = 2, 2, 1 elevation_lines = [ \\"0 1\\", \\"1 0\\" ] assert smooth_path(n, m, k, elevation_lines) == \\"YES\\" def test_smooth_path_case3(): n, m, k = 4, 4, 3 elevation_lines = [ \\"1 2 3 4\\", \\"8 7 6 5\\", \\"10 9 8 7\\", \\"13 12 11 10\\" ] assert smooth_path(n, m, k, elevation_lines) == \\"YES\\" def test_smooth_path_case4(): n, m, k = 1, 1, 0 elevation_lines = [ \\"0\\" ] assert smooth_path(n, m, k, elevation_lines) == \\"YES\\" def test_smooth_path_case5(): n, m, k = 3, 3, 1 elevation_lines = [ \\"0 2 4\\", \\"1 3 5\\", \\"2 4 6\\" ] assert smooth_path(n, m, k, elevation_lines) == \\"NO\\"","solution":"def is_smooth_path(grid, n, m, k): from collections import deque directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] visited = [[False for _ in range(m)] for _ in range(n)] queue = deque([(0, 0)]) visited[0][0] = True while queue: r, c = queue.popleft() if r == n-1 and c == m-1: return \\"YES\\" for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < n and 0 <= nc < m and not visited[nr][nc]: if abs(grid[nr][nc] - grid[r][c]) <= k: visited[nr][nc] = True queue.append((nr, nc)) return \\"NO\\" # Helper function to parse input and trigger smooth path check. def smooth_path(n, m, k, elevation_lines): grid = [list(map(int, line.split())) for line in elevation_lines] return is_smooth_path(grid, n, m, k)"},{"question":"def remove_duplicate_photographs(n, photographs): Returns the number of unique photographs after removing duplicates based on color codes. Parameters: n (int): Number of photographs. photographs (list of list of int): List containing color codes of each photograph. Returns: int: Number of unique photographs. pass # Implementation goes here # Unit tests def test_remove_duplicate_photographs_example_1(): n = 4 photographs = [ [1, 2, 3], [4, 5, 6], [1, 2, 3], [2, 3, 1] ] assert remove_duplicate_photographs(n, photographs) == 2 def test_remove_duplicate_photographs_example_2(): n = 3 photographs = [ [5, 5, 5], [1, 2, 2], [5, 5] ] assert remove_duplicate_photographs(n, photographs) == 3 def test_remove_duplicate_photographs_no_duplicates(): n = 4 photographs = [ [1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12] ] assert remove_duplicate_photographs(n, photographs) == 4 def test_remove_duplicate_photographs_all_duplicates(): n = 3 photographs = [ [1, 2, 3], [3, 1, 2], [2, 3, 1] ] assert remove_duplicate_photographs(n, photographs) == 1 def test_remove_duplicate_photographs_mixed(): n = 6 photographs = [ [1, 2], [2, 3, 1], [1, 3, 2], [4, 4], [4], [4, 4] ] assert remove_duplicate_photographs(n, photographs) == 4","solution":"def remove_duplicate_photographs(n, photographs): Returns the number of unique photographs after removing duplicates based on color codes. Parameters: n (int): Number of photographs. photographs (list of list of int): List containing color codes of each photograph. Returns: int: Number of unique photographs. unique_photographs = set() for photograph in photographs: sorted_colors = tuple(sorted(photograph)) unique_photographs.add(sorted_colors) return len(unique_photographs)"},{"question":"from typing import List class MazeGame: def __init__(self, n: int, m: int, coins: List[int]): Initialize the MazeGame with n rooms and m operations. Args: n : int : Number of rooms m : int : Number of operations coins : List[int] : List of integers representing the coin count in each room. pass def change_coins(self, i: int, x: int): Update the number of coins in the i-th room to x. Args: i : int : Room index to be updated (1-indexed). x : int : New number of coins in the room. pass def add_path(self, u: int, v: int): Add a new bidirectional path between room u and room v. Args: u : int : Room index at one end of the path (1-indexed). v : int : Room index at the other end of the path (1-indexed). pass def max_coins(self, start: int) -> int: Query the maximum coins that can be collected starting from room s. Args: start : int : Starting room index (1-indexed). Returns: int : Maximum number of coins that can be collected starting from the given room. pass def coin_queries(n: int, m: int, coins: List[int], operations: List[List[int]]) -> List[int]: Execute a list of operations on the MazeGame and return the results for query operations. Args: n : int : Number of rooms. m : int : Number of operations. coins : List[int] : List of integers representing the initial coin count in each room. operations : List[List[int]] : List of operations to perform on the MazeGame. Returns: List[int] : Results from the query operations. pass # Test cases if __name__ == \\"__main__\\": n = 5 m = 7 coins = [10, 20, 30, 40, 50] operations = [ [1, 3, 15], [2, 1, 2], [2, 2, 3], [2, 3, 4], [2, 4, 5], [3, 1], [3, 3], ] expected = [105, 90] assert coin_queries(n, m, coins, operations) == expected n = 1 m = 1 coins = [100] operations = [ [3, 1] ] expected = [100] assert coin_queries(n, m, coins, operations) == expected n = 3 m = 3 coins = [10, 20, 30] operations = [ [3, 1], [3, 2], [3, 3], ] expected = [10, 20, 30] assert coin_queries(n, m, coins, operations) == expected n = 4 m = 5 coins = [5, 10, 15, 20] operations = [ [1, 2, 25], [2, 1, 2], [2, 2, 3], [2, 3, 4], [3, 1] ] expected = [65] assert coin_queries(n, m, coins, operations) == expected n = 6 m = 5 coins = [1, 2, 3, 4, 5, 6] operations = [ [2, 1, 2], [2, 3, 4], [2, 5, 6], [3, 1], [3, 5], ] expected = [3, 11] assert coin_queries(n, m, coins, operations) == expected","solution":"from collections import defaultdict, deque class MazeGame: def __init__(self, n, m, coins): self.n = n self.coins = coins self.graph = defaultdict(list) def change_coins(self, i, x): self.coins[i - 1] = x def add_path(self, u, v): self.graph[u].append(v) self.graph[v].append(u) def max_coins(self, start): visited = [False] * self.n queue = deque([start]) visited[start - 1] = True max_coins = 0 while queue: room = queue.popleft() max_coins += self.coins[room - 1] for neighbor in self.graph[room]: if not visited[neighbor - 1]: visited[neighbor - 1] = True queue.append(neighbor) return max_coins def coin_queries(n, m, coins, operations): game = MazeGame(n, m, coins) results = [] for op in operations: if op[0] == 1: _, i, x = op game.change_coins(i, x) elif op[0] == 2: _, u, v = op game.add_path(u, v) elif op[0] == 3: _, s = op results.append(game.max_coins(s)) return results"},{"question":"def count_inversions(arr: List[int]) -> int: Returns the number of inversions in the array \`arr\`. >>> count_inversions([2, 4, 1, 3, 5]) 3 >>> count_inversions([1, 2, 3, 4, 5]) 0 >>> count_inversions([5, 4, 3, 2, 1]) 10 >>> count_inversions([1, 1, 1, 1]) 0 >>> count_inversions([1]) 0 >>> count_inversions([1, 3, 2]) 1 >>> count_inversions([3, 1, 2]) 2","solution":"def count_inversions(arr): Returns the number of inversions in the array \`arr\`. def merge_sort_counting_inversions(array): if len(array) < 2: return array, 0 mid = len(array) // 2 left, left_inv = merge_sort_counting_inversions(array[:mid]) right, right_inv = merge_sort_counting_inversions(array[mid:]) merged, split_inv = merge_count_split_inv(left, right) return merged, left_inv + right_inv + split_inv def merge_count_split_inv(left, right): i = j = 0 merged = [] inversions = 0 while i < len(left) and j < len(right): if left[i] <= right[j]: merged.append(left[i]) i += 1 else: merged.append(right[j]) j += 1 inversions += len(left) - i merged += left[i:] merged += right[j:] return merged, inversions _, total_inversions = merge_sort_counting_inversions(arr) return total_inversions"},{"question":"def bee_addition(a: int, b: int) -> int: Given two integers a and b, performs a bitwise OR on their binary representations and returns the result. >>> bee_addition(5, 3) 7 >>> bee_addition(10, 15) 15 >>> bee_addition(7, 7) 7 >>> bee_addition(0, 0) 0 >>> bee_addition(0, 1) 1 >>> bee_addition(10**18, 0) 10**18 >>> bee_addition(2**60, 2**60) 2**60 >>> bee_addition(2**60, 2**61) 2**61 + 2**60 >>> bee_addition(123456789, 987654321) 1071639989 >>> bee_addition(2**100, 2**1000) 2**100 + 2**1000","solution":"def bee_addition(a, b): Given two integers a and b, performs a bitwise OR on their binary representations and returns the result. return a | b"},{"question":"def count_unobstructed_view(buildings: List[int]) -> int: Determine the number of buildings that have an unobstructed view of the horizon. >>> count_unobstructed_view([3, 7, 8, 3, 6, 1]) 3 >>> count_unobstructed_view([1, 2, 3, 4, 5]) 1 >>> count_unobstructed_view([5, 4, 3, 2, 1]) 5 from typing import List","solution":"def count_unobstructed_view(buildings): Returns the number of buildings with an unobstructed view of the horizon. count = 0 max_height_so_far = 0 # Traverse the list from right to left for height in reversed(buildings): if height > max_height_so_far: count += 1 max_height_so_far = height return count"},{"question":"from itertools import permutations from typing import List def count_unique_shuffles(s: str) -> int: Returns the number of unique strings that can be created by shuffling the characters of the input string s. >>> count_unique_shuffles(\\"aab\\") 3 >>> count_unique_shuffles(\\"abc\\") 6 >>> count_unique_shuffles(\\"aaaa\\") 1","solution":"from itertools import permutations def count_unique_shuffles(s): Returns the number of unique strings that can be created by shuffling the characters of the input string s. # Generate all possible permutations of the string perm = set(permutations(s)) # The length of the set gives the number of unique permutations return len(perm)"},{"question":"def max_matrix_sum(n: int, m: int) -> int: Given dimensions n and m, compute the maximum sum of an n x m matrix after applying the special operation on each cell starting from a matrix of all 0s. >>> max_matrix_sum(3, 3) 9 >>> max_matrix_sum(1, 4) 4 >>> max_matrix_sum(2, 2) 4","solution":"def max_matrix_sum(n, m): Given dimensions n and m, compute the maximum sum of an n x m matrix after applying the special operation on each cell starting from a matrix of all 0s. # If we start with all 0s and flip each cell along its row and column, every cell will eventually be 1. # Therefore, the maximum sum of the matrix possible is just the total number of cells. return n * m"},{"question":"def fibonacci(n: int) -> int: Returns the nth Fibonacci number modulo 10^9 + 7. >>> fibonacci(0) == 0 >>> fibonacci(1) == 1 >>> fibonacci(10) == 55 >>> fibonacci(100) == 354224848179261915075 % (10**9 + 7) >>> fibonacci(1000) == 43466557686937456435688527675040625802564660517371780402481729089536555417949051890403879840079255169295922593080322634775209689623239873322471161642996440906533187938298969649928516003704476137795166849228875 % (10**9 + 7)","solution":"def fibonacci(n): Returns the nth Fibonacci number modulo 10^9 + 7. MOD = 10**9 + 7 def matrix_mult(A, B): return [ [(A[0][0]*B[0][0] + A[0][1]*B[1][0]) % MOD, (A[0][0]*B[0][1] + A[0][1]*B[1][1]) % MOD], [(A[1][0]*B[0][0] + A[1][1]*B[1][0]) % MOD, (A[1][0]*B[0][1] + A[1][1]*B[1][1]) % MOD] ] def matrix_pow(matrix, power): result = [[1, 0], [0, 1]] # Identity matrix while power > 0: if power % 2 == 1: result = matrix_mult(result, matrix) matrix = matrix_mult(matrix, matrix) power //= 2 return result if n == 0: return 0 F = [[1, 1], [1, 0]] result = matrix_pow(F, n - 1) return result[0][0]"},{"question":"def shortest_path(grid): Determines the number of steps in the shortest path from the top-left corner to the bottom-right corner in a grid. If there is no such path, returns -1. Parameters: grid (List[List[int]]): 2D integer array representing the grid where '0' indicates an open space and '1' indicates an obstacle. Returns: int: The number of steps in the shortest path from top-left to bottom-right or -1 if no such path exists. Examples: >>> shortest_path([ ... [0, 0, 0], ... [0, 1, 0], ... [0, 0, 0] ... ]) 4 >>> shortest_path([ ... [0, 0, 0], ... [1, 1, 0], ... [0, 0, 0] ... ]) 4 >>> shortest_path([ ... [1, 0, 0], ... [0, 1, 0], ... [0, 0, 0] ... ]) -1 >>> shortest_path([ ... [0] ... ]) 0 pass","solution":"from collections import deque def shortest_path(grid): Determines the number of steps in the shortest path from the top-left corner to the bottom-right corner in a grid. m = len(grid) n = len(grid[0]) if grid[0][0] == 1 or grid[m-1][n-1] == 1: return -1 # Directions for right and down movements directions = [(0, 1), (1, 0)] # Initialize queue for BFS queue = deque([(0, 0, 0)]) # (row, column, distance) visited = set((0, 0)) while queue: x, y, distance = queue.popleft() # Check if we've reached the bottom-right corner if x == m-1 and y == n-1: return distance # Explore all possible directions for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] == 0 and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny, distance + 1)) return -1 # Return -1 if there is no path"},{"question":"MOD = 1000000007 def count_topological_orderings(n: int, m: int, edges: List[Tuple[int, int]]) -> int: Determine the number of distinct topological orderings of a directed acyclic graph. >>> count_topological_orderings(3, 2, [(1, 2), (2, 3)]) 1 >>> count_topological_orderings(4, 3, [(1, 2), (1, 3), (3, 4)]) 3 >>> count_topological_orderings(3, 0, []) 6","solution":"MOD = 1000000007 def count_topological_orderings(n, m, edges): from functools import lru_cache from itertools import permutations graph = {i: [] for i in range(n)} indegree = {i: 0 for i in range(n)} for u, v in edges: graph[u - 1].append(v - 1) indegree[v - 1] += 1 @lru_cache(None) def dfs(mask, last): dp = 0 if mask == 0: return 1 for i in range(n): if (mask & (1 << i)) and all((mask & (1 << j)) == 0 for j in graph[i]): dp += dfs(mask ^ (1 << i), i) return dp % MOD return dfs((1 << n) - 1, -1) def solve_topological_orderings(graph_input): n, m = map(int, graph_input[0].split()) edges = [list(map(int, e.split())) for e in graph_input[1:]] return count_topological_orderings(n, m, edges) # Example usage: # graph_input = [ # \\"4 3\\", # \\"1 2\\", # \\"1 3\\", # \\"3 4\\" # ] # print(solve_topological_orderings(graph_input)) # Output: 3"},{"question":"class TreeNode: def __init__(self, value, left=None, right=None): self.value = value self.left = left self.right = right def is_balanced(root): Helper function to check if the binary tree is balanced. def check_height(node): if not node: return 0, True left_height, left_balanced = check_height(node.left) right_height, right_balanced = check_height(node.right) if not left_balanced or not right_balanced: return 0, False if abs(left_height - right_height) > 1: return 0, False return max(left_height, right_height) + 1, True return check_height(root)[1] def build_tree(nodes): Helper function to build the tree from node list. if not nodes: return None nodes_dict = {i + 1: TreeNode(value) for i, (value, left, right) in enumerate(nodes)} for i, (value, left, right) in enumerate(nodes): if left != -1: nodes_dict[i + 1].left = nodes_dict[left] if right != -1: nodes_dict[i + 1].right = nodes_dict[right] return nodes_dict[1] def is_binary_tree_balanced(node_count, node_list): Determine if the binary tree is height-balanced. Args: node_count (int): Number of nodes in the binary tree. node_list (List[Tuple[int, int, int]]): List of tuples representing nodes, where each tuple contains (value_i, left_i, right_i). Returns: str: \\"YES\\" if the binary tree is height-balanced, otherwise \\"NO\\". Examples: >>> is_binary_tree_balanced(5, [(1, 2, 3), (2, 4, 5), (3, -1, -1), (4, -1, -1), (5, -1, -1)]) 'YES' >>> is_binary_tree_balanced(3, [(1, 2, -1), (2, 3, -1), (3, -1, -1)]) 'NO' root = build_tree(node_list) return \\"YES\\" if is_balanced(root) else \\"NO\\"","solution":"class TreeNode: def __init__(self, value, left=None, right=None): self.value = value self.left = left self.right = right def is_balanced(root): def check_height(node): if not node: return 0, True left_height, left_balanced = check_height(node.left) right_height, right_balanced = check_height(node.right) if not left_balanced or not right_balanced: return 0, False if abs(left_height - right_height) > 1: return 0, False return max(left_height, right_height) + 1, True return check_height(root)[1] def build_tree(nodes): if not nodes: return None nodes_dict = {i + 1: TreeNode(value) for i, (value, left, right) in enumerate(nodes)} for i, (value, left, right) in enumerate(nodes): if left != -1: nodes_dict[i + 1].left = nodes_dict[left] if right != -1: nodes_dict[i + 1].right = nodes_dict[right] return nodes_dict[1] def is_binary_tree_balanced(node_count, node_list): root = build_tree(node_list) return \\"YES\\" if is_balanced(root) else \\"NO\\""},{"question":"import re def is_palindrome(s: str) -> str: Determines if the given string is a palindrome, ignoring spaces, punctuation, and capitalization. Args: s (str): The input string. Returns: str: \\"YES\\" if the string is a palindrome, \\"NO\\" otherwise. >>> is_palindrome(\\"A man, a plan, a canal, Panama\\") 'YES' >>> is_palindrome(\\"Hello, World!\\") 'NO'","solution":"import re def is_palindrome(s): Determines if the given string is a palindrome, ignoring spaces, punctuation, and capitalization. Args: s (str): The input string. Returns: str: \\"YES\\" if the string is a palindrome, \\"NO\\" otherwise. # Remove non-alphanumeric characters and convert to lowercase cleaned_s = re.sub(r'[^A-Za-z0-9]', '', s).lower() return \\"YES\\" if cleaned_s == cleaned_s[::-1] else \\"NO\\""},{"question":"def max_sensor_values(N: int, M: int, initial_sensor_values: List[int], transfers: List[Tuple[int, int]]) -> List[int]: Calculate the maximum possible sensor value for each robot after applying all possible transfers. Args: N (int): Number of robots. M (int): Number of transfer ways. initial_sensor_values (List[int]): List of initial sensor values for each robot. transfers (List[Tuple[int, int]]): List of transfers, each defined by a tuple (a_i, b_i) indicating a one-way transfer from robot a_i to robot b_i. Returns: List[int]: List of maximum possible sensor values for each robot after applying all possible transfers. >>> max_sensor_values(3, 2, [5, 2, 3], [(1, 2), (2, 3)]) [5, 5, 5] >>> max_sensor_values(4, 3, [10, 7, 5, 1], [(1, 2), (2, 3), (3, 4)]) [10, 10, 10, 10] >>> max_sensor_values(5, 4, [1, 2, 3, 4, 5], [(5, 4), (4, 3), (3, 2), (2, 1)]) [5, 5, 5, 5, 5] >>> max_sensor_values(4, 0, [1, 2, 3, 4], []) [1, 2, 3, 4] >>> max_sensor_values(5, 4, [10, 20, 30, 40, 50], [(1, 2), (1, 3), (1, 4), (1, 5)]) [10, 20, 30, 40, 50]","solution":"def max_sensor_values(N, M, initial_sensor_values, transfers): from collections import defaultdict, deque # Initialize the sensor values and transferred map max_sensors = initial_sensor_values[:] transfer_dict = defaultdict(list) for a, b in transfers: transfer_dict[a].append(b) # Use BFS or DFS to propagate maximum values queue = deque() for robot in range(N): queue.append(robot + 1) while queue: current = queue.popleft() for neighbor in transfer_dict[current]: if max_sensors[neighbor-1] < max_sensors[current-1]: max_sensors[neighbor-1] = max_sensors[current-1] queue.append(neighbor) return max_sensors if __name__ == \\"__main__\\": import sys input = sys.stdin.read data = input().split() N = int(data[0]) M = int(data[1]) initial_sensor_values = list(map(int, data[2:N+2])) transfers = [] for i in range(M): a = int(data[N+2 + 2*i]) b = int(data[N+3 + 2*i]) transfers.append((a, b)) result = max_sensor_values(N, M, initial_sensor_values, transfers) for value in result: print(value)"},{"question":"def largest_rectangle_area(heights: List[int]) -> int: This function takes a list of integers representing the heights of buildings and returns the area of the largest rectangle that can be formed under the skyline. >>> largest_rectangle_area([2, 1, 5, 6, 2, 3, 1]) 10 >>> largest_rectangle_area([6, 2, 5, 4, 5, 1, 6]) 12 >>> largest_rectangle_area([1, 2, 3, 4, 5]) 9 pass def test_largest_rectangle_area(): assert largest_rectangle_area([2, 1, 5, 6, 2, 3, 1]) == 10 assert largest_rectangle_area([6, 2, 5, 4, 5, 1, 6]) == 12 assert largest_rectangle_area([1, 2, 3, 4, 5]) == 9 assert largest_rectangle_area([5, 4, 3, 2, 1]) == 9 assert largest_rectangle_area([1]) == 1 assert largest_rectangle_area([100, 100, 100, 100]) == 400 assert largest_rectangle_area([2, 4, 6, 8, 10, 6, 4, 2]) == 24 assert largest_rectangle_area([1, 1, 1, 1, 1, 1, 1, 1, 1, 1]) == 10 assert largest_rectangle_area([1, 2, 3, 4, 5, 4, 3, 2, 1]) == 15 assert largest_rectangle_area([6]) == 6","solution":"def largest_rectangle_area(heights): This function takes a list of integers representing the heights of buildings and returns the area of the largest rectangle that can be formed under the skyline. stack = [] max_area = 0 index = 0 while index < len(heights): if not stack or heights[stack[-1]] <= heights[index]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"def count_palindromic_substrings(s: str) -> int: Returns the number of palindromic substrings in the given string \`s\`. >>> count_palindromic_substrings(\\"ababa\\") 9 >>> count_palindromic_substrings(\\"abc\\") 3 >>> count_palindromic_substrings(\\"a\\") 1 >>> count_palindromic_substrings(\\"aa\\") 3 >>> count_palindromic_substrings(\\"ab\\") 2 >>> count_palindromic_substrings(\\"abcd\\") 4 >>> count_palindromic_substrings(\\"aaa\\") 6 >>> count_palindromic_substrings(\\"a\\" * 1000) 500500","solution":"def count_palindromic_substrings(s): Returns the number of palindromic substrings in the given string \`s\`. n = len(s) count = 0 def is_palindrome(l, r): while l >= 0 and r < n and s[l] == s[r]: l -= 1 r += 1 return True return False for i in range(n): left, right = i, i # check for odd length palindromes while is_palindrome(left, right): count += 1 left -= 1 right += 1 left, right = i, i + 1 # check for even length palindromes while is_palindrome(left, right): count += 1 left -= 1 right += 1 return count"},{"question":"def count_unique_substrings(T: int, test_cases: List[str]) -> List[int]: Count the number of unique substrings in each test case that have the same character repeated consecutively. >>> count_unique_substrings(3, [\\"aabbcc\\", \\"abc\\", \\"aaa\\"]) [3, 0, 1] >>> count_unique_substrings(3, [\\"aabbaa\\", \\"abbbba\\", \\"ccccc\\"]) [2, 1, 1] >>> count_unique_substrings(2, [\\"a\\", \\"b\\"]) [0, 0] >>> count_unique_substrings(1, [\\"aaaaa\\"]) [1] >>> count_unique_substrings(1, [\\"\\"]) [0] >>> count_unique_substrings(1, [\\"abababa\\"]) [0]","solution":"def count_unique_substrings(T, test_cases): results = [] for string in test_cases: unique_substrings = set() i = 0 while i < len(string): start = i while i + 1 < len(string) and string[i] == string[i + 1]: i += 1 if i > start: unique_substrings.add(string[start:i + 1]) i += 1 results.append(len(unique_substrings)) return results"},{"question":"def is_pangram(sentence: str) -> bool: Write a function that checks if a string is a pangram or not. A pangram is a sentence that contains every single letter of the alphabet at least once. For example, the sentence \\"The quick brown fox jumps over the lazy dog\\" is a pangram because it includes every letter in the English alphabet. >>> is_pangram(\\"The quick brown fox jumps over the lazy dog\\") True >>> is_pangram(\\"Hello World\\") False","solution":"def is_pangram(sentence: str) -> bool: Returns True if the given sentence is a pangram, False otherwise. A pangram is a sentence that contains every single letter of the English alphabet at least once. alphabet = set(\\"abcdefghijklmnopqrstuvwxyz\\") sentence_letters = set(sentence.lower()) return alphabet.issubset(sentence_letters)"},{"question":"def calculate_popularity(test_cases): Calculates the popularity of each post in given test cases. Parameters: test_cases (list): A list of test cases where each test case is represented as a tuple of number of posts and a list of likes and shares. Returns: list: A list of lists where each inner list contains the popularities of posts in that test case. pass # Unit tests def test_single_test_case(): test_cases = [ (3, [(10, 20), (15, 15), (5, 10)]) ] assert calculate_popularity(test_cases) == [[30, 30, 15]] def test_multiple_test_cases(): test_cases = [ (3, [(10, 20), (15, 15), (5, 10)]), (2, [(0, 0), (1000000, 1000000)]) ] assert calculate_popularity(test_cases) == [[30, 30, 15], [0, 2000000]] def test_zero_likes_and_shares(): test_cases = [ (2, [(0, 0), (0, 0)]) ] assert calculate_popularity(test_cases) == [[0, 0]] def test_large_values(): test_cases = [ (1, [(1000000, 1000000)]) ] assert calculate_popularity(test_cases) == [[2000000]] def test_min_edge_case(): test_cases = [ (1, [(0, 0)]) ] assert calculate_popularity(test_cases) == [[0]] def test_all_zeros(): test_cases = [ (3, [(0, 0), (0, 0), (0, 0)]) ] assert calculate_popularity(test_cases) == [[0, 0, 0]]","solution":"def calculate_popularity(test_cases): Calculates the popularity of each post in given test cases. Parameters: test_cases (list): A list of test cases where each test case is represented as a tuple of number of posts and a list of likes and shares. Returns: list: A list of lists where each inner list contains the popularities of posts in that test case. results = [] for case in test_cases: n, posts = case popularities = [likes + shares for likes, shares in posts] results.append(popularities) return results"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def sum_of_left_leaves(root) -> int: Returns the sum of all left leaves in the given binary tree. >>> root = TreeNode(3) >>> root.left = TreeNode(9) >>> root.right = TreeNode(20) >>> root.right.left = TreeNode(15) >>> root.right.right = TreeNode(7) >>> sum_of_left_leaves(root) 24 >>> root = TreeNode(1) >>> sum_of_left_leaves(root) 0 pass def test_example_1(): # Building the tree [3,9,20,None,None,15,7] root = TreeNode(3) root.left = TreeNode(9) root.right = TreeNode(20) root.right.left = TreeNode(15) root.right.right = TreeNode(7) assert sum_of_left_leaves(root) == 24 def test_example_2(): # Building the tree [1] root = TreeNode(1) assert sum_of_left_leaves(root) == 0 def test_complete_binary_tree(): # Building the tree [1,2,3,4,5,6,7] root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) root.left.left = TreeNode(4) root.left.right = TreeNode(5) root.right.left = TreeNode(6) root.right.right = TreeNode(7) assert sum_of_left_leaves(root) == 10 def test_left_heavy_tree(): # Building the tree [1,2,None,3,None,4] root = TreeNode(1) root.left = TreeNode(2) root.left.left = TreeNode(3) root.left.left.left = TreeNode(4) assert sum_of_left_leaves(root) == 4 def test_no_left_leaves(): # Building the tree [1,2,3,None,4,None,5] root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) root.left.right = TreeNode(4) root.right.right = TreeNode(5) assert sum_of_left_leaves(root) == 0 def test_empty_tree(): assert sum_of_left_leaves(None) == 0","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def sum_of_left_leaves(root): Returns the sum of all left leaves in the given binary tree. if not root: return 0 def is_leaf(node): return node and not node.left and not node.right def dfs(node, is_left): if not node: return 0 if is_leaf(node) and is_left: return node.val return dfs(node.left, True) + dfs(node.right, False) return dfs(root, False)"},{"question":"def min_balls_required(n: int, pattern: List[int]) -> int: Determine the minimum number of balls needed to follow the juggling pattern. >>> min_balls_required(3, [1, 2, 1]) == 2 >>> min_balls_required(5, [2, 0, 3, 1, 1]) == 3 from typing import List def test_example_1(): assert min_balls_required(3, [1, 2, 1]) == 2 def test_example_2(): assert min_balls_required(5, [2, 0, 3, 1, 1]) == 3 def test_single_toss(): assert min_balls_required(1, [0]) == 0 assert min_balls_required(1, [1]) == 1 def test_multiple_tosses(): assert min_balls_required(4, [1, 1, 1, 1]) == 1 assert min_balls_required(4, [1, 2, 1, 2]) == 2 def test_no_tosses(): assert min_balls_required(5, [0, 0, 0, 0, 0]) == 0 def test_large_pattern(): n = 100000 pattern = [1] * n assert min_balls_required(n, pattern) == 1","solution":"def min_balls_required(n, pattern): max_balls_tossed = 0 current_balls = 0 for toss in pattern: current_balls += toss max_balls_tossed = max(max_balls_tossed, current_balls) current_balls -= toss return max_balls_tossed def read_input(): import sys input = sys.stdin.read data = input().split() n = int(data[0]) pattern = list(map(int, data[1:])) return n, pattern if __name__ == \\"__main__\\": n, pattern = read_input() print(min_balls_required(n, pattern))"},{"question":"def max_total_reward(n: int, k: int, complexities: List[int], rewards: List[int]) -> int: Given 'n' projects each with an associated complexity and reward value, and 'k' engineers, maximize the total reward by appropriately assigning engineers to the projects. Parameters: n (int): The number of projects. k (int): The number of engineers. complexities (List[int]): List of integers where each represents the complexity required for the i-th project. rewards (List[int]): List of integers where each represents the reward for completing the i-th project. Returns: int: The maximum total reward that can be achieved given the constraints. Examples: >>> max_total_reward(3, 5, [2, 3, 1], [100, 200, 50]) 300 >>> max_total_reward(4, 4, [1, 1, 1, 1], [100, 100, 100, 100]) 400","solution":"def max_total_reward(n, k, complexities, rewards): # Pair each complexity with its reward and sort by reward descending projects = sorted(zip(complexities, rewards), key=lambda x: x[1], reverse=True) total_reward = 0 for complexity, reward in projects: if complexity <= k: # If we have enough engineers for the complexity total_reward += reward k -= complexity # Deduct the assigned engineers from the available pool return total_reward"},{"question":"class LibrarySystem: def __init__(self): Initialize the library system with empty categories and books dictionaries. self.categories = {} self.books = {} def add_category(self, id, parent_id=None): Adds a new category or subcategory. Parameters: id (int): Unique identifier for the category. parent_id (int, optional): Unique identifier for parent category, if it is a subcategory. >>> ls = LibrarySystem() >>> ls.add_category(1) >>> ls.categories == {1: {'parent_id': None, 'books': [], 'subcategories': []}} True >>> ls.add_category(2, 1) >>> ls.categories == {1: {'parent_id': None, 'books': [], 'subcategories': [2]}, 2: {'parent_id': 1, 'books': [], 'subcategories': []}} True pass def add_book(self, category_id, isbn, title, copies): Adds a new book to a category or subcategory. Parameters: category_id (int): Unique identifier for the category. isbn (str): Unique ISBN of the book. title (str): Title of the book. copies (int): Number of copies available. >>> ls = LibrarySystem() >>> ls.add_category(1) >>> ls.add_book(1, '978-0-13-110362-7', 'The C Programming Language', 5) >>> ls.books == {'978-0-13-110362-7': {'title': 'The C Programming Language', 'copies': 5, 'category_id': 1}} True >>> ls.categories == {1: {'parent_id': None, 'books': ['978-0-13-110362-7'], 'subcategories': []}} True pass def update_copies(self, isbn, copies): Updates the number of copies available for a specific book. Parameters: isbn (str): Unique ISBN of the book. copies (int): Updated number of copies. >>> ls = LibrarySystem() >>> ls.add_category(1) >>> ls.add_book(1, '978-0-13-110362-7', 'The C Programming Language', 5) >>> ls.update_copies('978-0-13-110362-7', 10) >>> ls.books['978-0-13-110362-7']['copies'] == 10 True pass def get_book(self, isbn): Retrieves information about a book. Parameters: isbn (str): Unique ISBN of the book. Returns: str: Book information in the format \`Title: title, Copies: copies\` >>> ls = LibrarySystem() >>> ls.add_category(1) >>> ls.add_book(1, '978-0-13-110362-7', 'The C Programming Language', 5) >>> ls.get_book('978-0-13-110362-7') 'Title: The C Programming Language, Copies: 5' pass def get_category(self, id): Retrieves information for a category or subcategory. Parameters: id (int): Unique identifier for the category. Returns: str: Category information in the format \`Books: [title1, title2, ...], Subcategories: [id1, id2, ...]\` >>> ls = LibrarySystem() >>> ls.add_category(1) >>> ls.add_category(2, 1) >>> ls.add_book(1, '978-0-13-110362-7', 'The C Programming Language', 5) >>> ls.get_category(1) \\"Books: ['The C Programming Language'], Subcategories: [2]\\" >>> ls.add_book(2, '978-3-16-148410-0', 'Discrete Mathematics', 3) >>> ls.get_category(2) \\"Books: ['Discrete Mathematics'], Subcategories: []\\" pass","solution":"class LibrarySystem: def __init__(self): self.categories = {} self.books = {} def add_category(self, id, parent_id=None): if parent_id: if parent_id in self.categories: self.categories[id] = {'parent_id': parent_id, 'books': [], 'subcategories': []} self.categories[parent_id]['subcategories'].append(id) else: self.categories[id] = {'parent_id': None, 'books': [], 'subcategories': []} def add_book(self, category_id, isbn, title, copies): if category_id in self.categories: self.books[isbn] = {'title': title, 'copies': copies, 'category_id': category_id} self.categories[category_id]['books'].append(isbn) def update_copies(self, isbn, copies): if isbn in self.books: self.books[isbn]['copies'] = copies def get_book(self, isbn): if isbn in self.books: book = self.books[isbn] return f'Title: {book[\\"title\\"]}, Copies: {book[\\"copies\\"]}' return None def get_category(self, id): if id in self.categories: category = self.categories[id] books = [self.books[isbn]['title'] for isbn in category['books']] subcategories = category['subcategories'] return f'Books: {books}, Subcategories: {subcategories}' return None"},{"question":"from typing import List, Dict def can_reach_end_with_fuel(m: int, n: int, f: int, grid: List[List[str]]) -> str: Determines if the robots can reach the bottom-right corner of the grid within the given number of moves. >>> can_reach_end_with_fuel(3, 3, 4, [['.', '.', '.'], ['.', '#', '.'], ['.', '.', '.']]) \\"YES\\" >>> can_reach_end_with_fuel(2, 2, 3, [['.', '#'], ['#', '.']]) \\"NO\\" >>> can_reach_end_with_fuel(4, 4, 7, [['.', '.', '.', '.'], ['.', '#', '.', '.'], ['.', '.', '#', '.'], ['.', '.', '.', '.']]) \\"YES\\" def process_cases(t: int, cases: List[Dict]) -> List[str]: Processes multiple test cases and returns list of results. >>> process_cases(3, [{'dims': (3, 3, 4), 'grid': [['.', '.', '.'], ['.', '#', '.'], ['.', '.', '.']]}, {'dims': (2, 2, 3), 'grid': [['.', '#'], ['#', '.']]}, {'dims': (4, 4, 7), 'grid': [['.', '.', '.', '.'], ['.', '#', '.', '.'], ['.', '.', '#', '.'], ['.', '.', '.', '.']]}]) [\\"YES\\", \\"NO\\", \\"YES\\"]","solution":"def can_reach_end_with_fuel(m, n, f, grid): if grid[0][0] == '#' or grid[m-1][n-1] == '#': return \\"NO\\" # Directions for right and down movements directions = [(0, 1), (1, 0)] queue = [(0, 0, 0)] # (row, col, steps) visited = set() visited.add((0, 0)) while queue: x, y, steps = queue.pop(0) if steps > f: continue if x == m-1 and y == n-1: return \\"YES\\" for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] == '.' and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny, steps + 1)) return \\"NO\\" def process_cases(t, cases): results = [] for case in cases: m, n, f = case['dims'] grid = case['grid'] results.append(can_reach_end_with_fuel(m, n, f, grid)) return results"},{"question":"def is_special_matrix(n: int, matrix: List[List[int]]) -> str: Determines if a given n x n matrix is a special matrix. A special matrix is defined as one where each element is either 0 or 1, each row and each column contain at most one 1. :param n: The size of the matrix. :param matrix: The n x n matrix to be evaluated. :return: \\"YES\\" if the matrix is special, otherwise \\"NO\\". >>> is_special_matrix(3, [[1, 0, 0], [0, 0, 1], [0, 0, 0]]) \\"YES\\" >>> is_special_matrix(3, [[1, 0, 1], [0, 0, 0], [0, 1, 0]]) \\"NO\\" >>> is_special_matrix(4, [[1, 0, 0, 0], [0, 0, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1]]) \\"YES\\"","solution":"def is_special_matrix(n, matrix): Determines if a given n x n matrix is a special matrix. A special matrix is defined as one where each element is either 0 or 1, each row and each column contain at most one 1. :param n: The size of the matrix. :param matrix: The n x n matrix to be evaluated. :return: \\"YES\\" if the matrix is special, otherwise \\"NO\\". for row in matrix: if sum(row) > 1: return \\"NO\\" for col in range(n): if sum(matrix[row][col] for row in range(n)) > 1: return \\"NO\\" return \\"YES\\""},{"question":"def is_prime(num: int) -> bool: Check if a number is prime. >>> is_prime(2) True >>> is_prime(3) True >>> is_prime(4) False >>> is_prime(29) True >>> is_prime(1) False def find_prime_sum_pair(n: int) -> str: Determine if \`n\` can be expressed as the sum of two prime numbers. If yes, return \\"YES\\" followed by the pair of prime numbers. If no, return \\"NO\\". >>> find_prime_sum_pair(34) \\"YESn3 31\\" >>> find_prime_sum_pair(5) \\"YESn2 3\\" >>> find_prime_sum_pair(27) \\"NO\\"","solution":"def is_prime(num): Check if a number is prime. if num <= 1: return False if num <= 3: return True if num % 2 == 0 or num % 3 == 0: return False i = 5 while i * i <= num: if num % i == 0 or num % (i + 2) == 0: return False i += 6 return True def find_prime_sum_pair(n): Determine if \`n\` can be expressed as the sum of two prime numbers. for i in range(2, n): if is_prime(i) and is_prime(n - i): return f\\"YESn{i} {n - i}\\" return \\"NO\\""},{"question":"def generate_parentheses(n: int) -> List[str]: Generate all combinations of n pairs of parentheses. >>> generate_parentheses(1) == [\\"()\\"] >>> generate_parentheses(2) == [\\"(())\\", \\"()()\\"] >>> generate_parentheses(3) == [\\"((()))\\", \\"(()())\\", \\"(())()\\", \\"()(())\\", \\"()()()\\"] >>> generate_parentheses(4) == [ ... \\"(((())))\\", \\"((()()))\\", \\"((())())\\", \\"((()))()\\", \\"(()(()))\\", \\"(()()())\\", ... \\"(()())()\\", \\"(())(())\\", \\"(())()()\\", \\"()((()))\\", \\"()(()())\\", \\"()(())()\\", ... \\"()()(())\\", \\"()()()()\\" ... ]","solution":"def generate_parentheses(n): Generate all combinations of n pairs of parentheses. :param n: Integer, number of pairs of parentheses :return: List of strings, each string represents a valid combination of n pairs of parentheses def backtrack(s='', left=0, right=0): if len(s) == 2 * n: results.append(s) return if left < n: backtrack(s+'(', left+1, right) if right < left: backtrack(s+')', left, right+1) results = [] backtrack() return results"},{"question":"def max_rectangle_area(heights: List[int]) -> int: Determine the maximum area of a rectangle that can be formed by selecting consecutive buildings' heights. >>> max_rectangle_area([2, 1, 5, 6, 2, 3]) 10 >>> max_rectangle_area([2, 2, 2, 2, 2]) 10 >>> max_rectangle_area([1, 2, 3, 4, 5]) 9 >>> max_rectangle_area([5, 4, 3, 2, 1]) 9 >>> max_rectangle_area([2, 4, 6, 5, 1, 4]) 12 >>> max_rectangle_area([5]) 5 >>> max_rectangle_area([2, 4]) 4 >>> max_rectangle_area([3, 3]) 6","solution":"def max_rectangle_area(heights): stack = [] max_area = 0 index = 0 while index < len(heights): if not stack or heights[stack[-1]] <= heights[index]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"def can_form_palindrome_with_one_edit(num_str: str) -> str: Determines if a number can be rearranged to form a palindrome with at most one digit change. >>> can_form_palindrome_with_one_edit('12321') == 'Yes 12321' >>> can_form_palindrome_with_one_edit('12121') == 'Yes 12121' >>> can_form_palindrome_with_one_edit('2002') == 'Yes 2002' >>> can_form_palindrome_with_one_edit('98765') == 'No' >>> can_form_palindrome_with_one_edit('1221') == 'Yes 1221' >>> can_form_palindrome_with_one_edit('1231') == 'Yes 1331' >>> can_form_palindrome_with_one_edit('123456') == 'No' def process_input_numbers(numbers: List[str]) -> List[str]: Processes a list of number strings to determine if each can form a palindrome with at most one digit change. >>> input_data = ['12321', '12121', '2002', '98765', '0'] >>> expected_output = ['Yes 12321', 'Yes 12121', 'Yes 2002', 'No'] >>> process_input_numbers(input_data) == expected_output if __name__ == \\"__main__\\": import sys input_numbers = sys.stdin.read().strip().split() results = process_input_numbers(input_numbers) for res in results: print(res)","solution":"def can_form_palindrome_with_one_edit(num_str): Determines if a number can be rearranged to form a palindrome with at most one digit change. n = len(num_str) left, right = 0, n - 1 changes = 0 chars = list(num_str) while left < right: if chars[left] != chars[right]: if changes == 1: return \\"No\\" changes += 1 # Set the higher value for the change to minimize further mismatches if chars[left] > chars[right]: chars[right] = chars[left] else: chars[left] = chars[right] left += 1 right -= 1 # Handle the middle part for odd length cases if changes > 1: return \\"No\\" return f\\"Yes {''.join(chars)}\\" def process_input_numbers(numbers): results = [] for number in numbers: if number == '0': break result = can_form_palindrome_with_one_edit(number) results.append(result) return results if __name__ == \\"__main__\\": import sys input_numbers = sys.stdin.read().strip().split() results = process_input_numbers(input_numbers) for res in results: print(res)"},{"question":"def is_palindrome(s: str) -> str: Determine if the given string \`s\` is a palindrome, considering only alphanumeric characters and ignoring cases. Args: s (str): The input string. Returns: str: \\"YES\\" if the string is a palindrome, otherwise \\"NO\\". Examples: >>> is_palindrome(\\"A man, a plan, a canal: Panama\\") \\"YES\\" >>> is_palindrome(\\"race a car\\") \\"NO\\"","solution":"def is_palindrome(s: str) -> str: Determine if the given string \`s\` is a palindrome. Args: s (str): The input string. Returns: str: \\"YES\\" if the string is a palindrome, otherwise \\"NO\\". # Filter out non-alphanumeric characters and convert to lowercase filtered_chars = ''.join(char.lower() for char in s if char.isalnum()) # Check if the filtered string is equal to its reverse if filtered_chars == filtered_chars[::-1]: return \\"YES\\" else: return \\"NO\\""},{"question":"def length_of_longest_substring_two_distinct(s: str) -> int: Returns the length of the longest substring with at most two distinct characters. >>> length_of_longest_substring_two_distinct(\\"abcabcabc\\") 2 >>> length_of_longest_substring_two_distinct(\\"ccaabbb\\") 5 >>> length_of_longest_substring_two_distinct(\\"\\") 0 >>> length_of_longest_substring_two_distinct(\\"aaaaa\\") 5 >>> length_of_longest_substring_two_distinct(\\"aAaAa\\") 5 >>> length_of_longest_substring_two_distinct(\\"aAaAbB\\") 4","solution":"def length_of_longest_substring_two_distinct(s): Returns the length of the longest substring with at most two distinct characters. if len(s) == 0: return 0 left = 0 right = 0 max_length = 0 char_map = {} while right < len(s): char_map[s[right]] = char_map.get(s[right], 0) + 1 while len(char_map) > 2: char_map[s[left]] -= 1 if char_map[s[left]] == 0: del char_map[s[left]] left += 1 max_length = max(max_length, right - left + 1) right += 1 return max_length"},{"question":"from typing import List from collections import Counter def can_rearrange_no_consecutive_same(N: int, A: List[int]) -> str: Determine if it's possible to rearrange the list such that no two consecutive integers are the same. Args: N: int : The number of integers in the list. A: list of int : The list of integers. Returns: str : \\"Yes\\" if possible, otherwise \\"No\\". >>> can_rearrange_no_consecutive_same(5, [1, 1, 2, 2, 3]) 'Yes' >>> can_rearrange_no_consecutive_same(4, [4, 4, 4, 4]) 'No'","solution":"from collections import Counter def can_rearrange_no_consecutive_same(N, A): Determine if it's possible to rearrange the list such that no two consecutive integers are the same. Args: N: int : The number of integers in the list. A: list of int : The list of integers. Returns: str : \\"Yes\\" if possible, otherwise \\"No\\". if N == 1: return \\"Yes\\" freq = Counter(A) max_freq = max(freq.values()) if max_freq <= (N + 1) // 2: return \\"Yes\\" else: return \\"No\\""},{"question":"from typing import List, Tuple def min_independent_project_groups(n: int, d: int, dependencies: List[Tuple[int, int]]) -> int: Determine the minimum number of independent project groups needed to complete all projects. Args: n (int): Total number of projects. d (int): Total number of dependency pairs. dependencies (List[Tuple[int, int]]): List of dependency pairs (a, b) indicating project b depends on project a. Returns: int: Minimum number of independent project groups required. Examples: >>> min_independent_project_groups(5, 4, [(1, 2), (2, 3), (3, 4), (4, 5)]) 5 >>> min_independent_project_groups(6, 5, [(1, 2), (2, 3), (3, 4), (5, 6), (1, 5)]) 4 from solution import min_independent_project_groups def test_min_groups_case1(): n = 5 d = 4 dependencies = [ (1, 2), (2, 3), (3, 4), (4, 5), ] assert min_independent_project_groups(n, d, dependencies) == 5 def test_min_groups_case2(): n = 6 d = 5 dependencies = [ (1, 2), (2, 3), (3, 4), (5, 6), (1, 5), ] assert min_independent_project_groups(n, d, dependencies) == 4 def test_min_groups_no_dependencies(): n = 3 d = 0 dependencies = [] assert min_independent_project_groups(n, d, dependencies) == 1 def test_min_groups_single_dependency(): n = 3 d = 1 dependencies = [ (1, 3), ] assert min_independent_project_groups(n, d, dependencies) == 2 def test_min_groups_disjoint_dependencies(): n = 4 d = 2 dependencies = [ (1, 2), (3, 4), ] assert min_independent_project_groups(n, d, dependencies) == 2","solution":"from collections import defaultdict, deque def min_independent_project_groups(n, d, dependencies): def topological_sort(graph, in_degree, n): queue = deque() order = [] for i in range(1, n + 1): if in_degree[i] == 0: queue.append(i) while queue: node = queue.popleft() order.append(node) for neighbor in graph[node]: in_degree[neighbor] -= 1 if in_degree[neighbor] == 0: queue.append(neighbor) return order # Create graph and in-degree array graph = defaultdict(list) in_degree = [0] * (n + 1) for a, b in dependencies: graph[a].append(b) in_degree[b] += 1 order = topological_sort(graph, in_degree, n) if len(order) != n: return -1 # Means there's a cycle, which shouldn't be the case as per problem constraints # Calculate the levels of each node levels = [0] * (n + 1) for node in order: for neighbor in graph[node]: levels[neighbor] = max(levels[neighbor], levels[node] + 1) return max(levels) + 1"},{"question":"def is_subsequence(source: str, target: str) -> str: Determines if \`target\` can be obtained by deleting some characters from \`source\` without reordering the remaining characters. Parameters: source (str): The source string. target (str): The target string. Returns: str: \\"YES\\" if \`target\` is a subsequence of \`source\`, otherwise \\"NO\\". >>> is_subsequence(\\"abpcplea\\", \\"apple\\") \\"YES\\" >>> is_subsequence(\\"abc\\", \\"acb\\") \\"NO\\"","solution":"def is_subsequence(source, target): Determines if \`target\` can be obtained by deleting some characters from \`source\` without reordering the remaining characters. Parameters: source (str): The source string. target (str): The target string. Returns: str: \\"YES\\" if \`target\` is a subsequence of \`source\`, otherwise \\"NO\\". it = iter(source) return \\"YES\\" if all(char in it for char in target) else \\"NO\\""},{"question":"from typing import List def is_palindrome(num: int) -> bool: Check if a given number is a palindrome. return str(num) == str(num)[::-1] def next_palindrome(N: int) -> int: Find the smallest palindromic number greater than N. >>> next_palindrome(123) 131 >>> next_palindrome(99) 101 pass def find_next_palindromes(test_cases: List[int]) -> List[int]: Given a list of integers, find the smallest palindromic number greater than each integer. >>> find_next_palindromes([123, 99]) [131, 101] >>> find_next_palindromes([0, 1, 8, 88]) [1, 2, 9, 99] pass","solution":"def is_palindrome(num): Check if a given number is a palindrome. return str(num) == str(num)[::-1] def next_palindrome(N): Find the smallest palindromic number greater than N. N += 1 while not is_palindrome(N): N += 1 return N def find_next_palindromes(test_cases): results = [] for N in test_cases: results.append(next_palindrome(N)) return results"},{"question":"from typing import List, Tuple def is_bipartite(n: int, m: int, edges: List[Tuple[int, int]]) -> str: Determine whether it is possible to rename the graph's vertices to make the graph bipartite. >>> is_bipartite(5, 4, [(1, 2), (1, 3), (2, 4), (3, 5)]) 'Yes' >>> is_bipartite(3, 3, [(1, 2), (2, 3), (3, 1)]) 'No' def test_bipartite_case_1(): n, m = 5, 4 edges = [(1, 2), (1, 3), (2, 4), (3, 5)] assert is_bipartite(n, m, edges) == \\"Yes\\" def test_bipartite_case_2(): n, m = 3, 3 edges = [(1, 2), (2, 3), (3, 1)] assert is_bipartite(n, m, edges) == \\"No\\" def test_bipartite_single_vertex(): n, m = 1, 0 edges = [] assert is_bipartite(n, m, edges) == \\"Yes\\" def test_bipartite_no_edges(): n, m = 5, 0 edges = [] assert is_bipartite(n, m, edges) == \\"Yes\\" def test_bipartite_disconnected_bipartite_graph(): n, m = 6, 4 edges = [(1, 2), (2, 3), (4, 5), (5, 6)] assert is_bipartite(n, m, edges) == \\"Yes\\" def test_bipartite_disconnected_non_bipartite_graph(): n, m = 6, 5 edges = [(1, 2), (2, 3), (3, 1), (4, 5), (5, 6)] assert is_bipartite(n, m, edges) == \\"No\\"","solution":"def is_bipartite(n, m, edges): from collections import deque, defaultdict def bfs(start): queue = deque([start]) color[start] = 0 # Start coloring with 0 while queue: node = queue.popleft() for neighbor in graph[node]: if color[neighbor] == -1: color[neighbor] = 1 - color[node] queue.append(neighbor) elif color[neighbor] == color[node]: return False return True graph = defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) color = [-1] * (n + 1) for i in range(1, n + 1): if color[i] == -1: if not bfs(i): return \\"No\\" return \\"Yes\\""},{"question":"from typing import List, Tuple def find_shortest_paths(n: int, roads: List[Tuple[int, int, int]], queries: List[Tuple[int, int]]) -> List[int]: Find the shortest delivery routes between pairs of cities in Bellworld. Args: n: Number of cities. roads: List of tuples where each tuple represents a road with the start city, end city and the travel time. queries: List of tuples where each tuple represents a query for the shortest delivery time from one city to another. Returns: A list of shortest delivery times for each query. If there is no path between the cities, returns -1 for that query. Example: >>> find_shortest_paths(3, [(1, 2, 5), (2, 3, 10), (1, 3, 15)], [(1, 3), (2, 1)]) [15, -1] >>> find_shortest_paths(4, [(1, 2, 2), (1, 3, 1), (2, 4, 4), (3, 4, 3), (1, 4, 2)], [(1, 4), (1, 2), (2, 3), (3, 2), (4, 1)]) [2, 2, -1, -1, -1]","solution":"import sys def floyd_warshall(n, dist): for k in range(n): for i in range(n): for j in range(n): if dist[i][j] > dist[i][k] + dist[k][j]: dist[i][j] = dist[i][k] + dist[k][j] def find_shortest_paths(n, roads, queries): # Initialize the distances matrix with infinity dist = [[float('inf')] * n for _ in range(n)] # Distance to self is 0 for i in range(n): dist[i][i] = 0 # Populate the distances with the given road times for u, v, t in roads: dist[u-1][v-1] = t # Use the Floyd-Warshall algorithm to find all-pairs shortest paths floyd_warshall(n, dist) # Answer the queries results = [] for a, b in queries: distance = dist[a-1][b-1] if distance == float('inf'): results.append(-1) else: results.append(distance) return results"},{"question":"def determine_winner(t: int, cases: List[int]) -> List[str]: Determines who will win given the number of stones in each test case. Parameters: t (int): The number of test cases. cases (list of int): List containing cases with the initial number of stones. Returns: list of str: List containing \\"Alice\\" if Alice wins or \\"Bob\\" if Bob wins for each test case. from typing import List def test_determine_winner_single_case(): assert determine_winner(1, [1]) == [\\"Alice\\"] assert determine_winner(1, [4]) == [\\"Bob\\"] assert determine_winner(1, [7]) == [\\"Alice\\"] assert determine_winner(1, [16]) == [\\"Bob\\"] def test_determine_winner_multiple_cases(): assert determine_winner(4, [1, 2, 3, 4]) == [\\"Alice\\", \\"Alice\\", \\"Alice\\", \\"Bob\\"] assert determine_winner(3, [5, 6, 7]) == [\\"Alice\\", \\"Alice\\", \\"Alice\\"] assert determine_winner(5, [8, 9, 10, 11, 12]) == [\\"Bob\\", \\"Alice\\", \\"Alice\\", \\"Alice\\", \\"Bob\\"] def test_determine_winner_edge_cases(): assert determine_winner(1, [10000]) == [\\"Bob\\"] assert determine_winner(1, [9999]) == [\\"Alice\\"] assert determine_winner(1, [9998]) == [\\"Alice\\"] def test_determine_winner_mixed_cases(): assert determine_winner(6, [1, 2, 4, 5, 12, 16]) == [\\"Alice\\", \\"Alice\\", \\"Bob\\", \\"Alice\\", \\"Bob\\", \\"Bob\\"]","solution":"def determine_winner(t, cases): Determines who will win given the number of stones in each test case. Parameters: t (int): The number of test cases. cases (list of int): List containing cases with the initial number of stones. Returns: list of str: List containing \\"Alice\\" if Alice wins or \\"Bob\\" if Bob wins for each test case. results = [] for n in cases: if n % 4 == 0: results.append(\\"Bob\\") else: results.append(\\"Alice\\") return results"},{"question":"def evaluate_expression(expression: str) -> float: Takes a string representing a simple mathematical expression made of two positive single-digit numbers and a multiplication or division operator, then calculates and returns the result. >>> evaluate_expression(\\"4*3\\") 12 >>> evaluate_expression(\\"8/3\\") 2.67 pass","solution":"def evaluate_expression(expression): Takes a string representing a simple mathematical expression made of two positive single-digit numbers and a multiplication or division operator, then calculates and returns the result. if '*' in expression: left, right = expression.split('*') return int(left) * int(right) elif '/' in expression: left, right = expression.split('/') return round(int(left) / int(right), 2)"},{"question":"def min_subset_difference(arr): Returns the smallest possible absolute difference between the sums of two subsets. >>> min_subset_difference([1, 6, 11, 5]) 1 >>> min_subset_difference([3, 1, 4]) 0 >>> min_subset_difference([10, 10, 10]) 10 >>> min_subset_difference([1, 2, 3, 4, 5]) 1 >>> min_subset_difference([5]) 5","solution":"def min_subset_difference(arr): Returns the smallest possible absolute difference between the sums of two subsets. total_sum = sum(arr) n = len(arr) # Initialize a 2D dp array dp = [[False for _ in range(total_sum // 2 + 1)] for _ in range(n + 1)] # Base case: it is always possible to form a subset with sum 0 for i in range(n + 1): dp[i][0] = True # Fill the dp array for i in range(1, n + 1): for j in range(1, total_sum // 2 + 1): if arr[i - 1] <= j: dp[i][j] = dp[i - 1][j] or dp[i - 1][j - arr[i - 1]] else: dp[i][j] = dp[i - 1][j] # Find the maximum j such that dp[n][j] is True, which will be the closest # to sum/2 for j in range(total_sum // 2, -1, -1): if dp[n][j]: return total_sum - 2 * j return total_sum # In case n is 1, the difference is the element itself # Read the input def solve(): import sys input = sys.stdin.read data = input().split() N = int(data[0]) arr = list(map(int, data[1:])) print(min_subset_difference(arr))"},{"question":"def max_contiguous_subarray_sum(efficiencies): Finds the maximum contiguous subarray sum using Kadane's algorithm. >>> max_contiguous_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) 6 >>> max_contiguous_subarray_sum([1, 2, 3, 4, 5]) 15 >>> max_contiguous_subarray_sum([-5, -2, -3, -4, -1, -2]) -1 >>> max_contiguous_subarray_sum([3, -2, 5, -1]) 6 >>> max_contiguous_subarray_sum([1, -2, 3]) 3 >>> max_contiguous_subarray_sum([1, -2, 1, 1]) 2 pass def process_test_cases(test_cases): Processes a list of test cases, returning the maximum contiguous subarray sum for each. >>> test_cases = [(8, [-2, 1, -3, 4, -1, 2, 1, -5, 4]), (5, [1, 2, 3, 4, 5]), (6, [-5, -2, -3, -4, -1, -2])] >>> process_test_cases(test_cases) [6, 15, -1] pass","solution":"def max_contiguous_subarray_sum(efficiencies): Finds the maximum contiguous subarray sum using Kadane's algorithm. max_sum = current_sum = efficiencies[0] for efficiency in efficiencies[1:]: current_sum = max(efficiency, current_sum + efficiency) max_sum = max(max_sum, current_sum) return max_sum def process_test_cases(test_cases): results = [] for case in test_cases: _, efficiencies = case results.append(max_contiguous_subarray_sum(efficiencies)) return results"},{"question":"def count_even_sum_pairs(n, arr): Returns the number of pairs (i, j) such that i < j and arr[i] + arr[j] is even. >>> count_even_sum_pairs(3, [1, 2, 3]) == 1 >>> count_even_sum_pairs(4, [2, 4, 6, 8]) == 6 def process_test_cases(T, cases): Processes multiple test cases and returns the results as a list. >>> process_test_cases(2, [(3, [1, 2, 3]), (4, [2, 4, 6, 8])]) == [1, 6] >>> process_test_cases(1, [(5, [1, 3, 5, 7, 9])]) == [10]","solution":"def count_even_sum_pairs(n, arr): Returns the number of pairs (i, j) such that i < j and arr[i] + arr[j] is even. if n < 2: return 0 even_count = sum(1 for x in arr if x % 2 == 0) odd_count = n - even_count even_pairs = even_count * (even_count - 1) // 2 odd_pairs = odd_count * (odd_count - 1) // 2 return even_pairs + odd_pairs def process_test_cases(T, cases): results = [] for i in range(T): n = cases[i][0] arr = cases[i][1] results.append(count_even_sum_pairs(n, arr)) return results"},{"question":"def max_consecutive_zero_rainfall_days(n: int, rainfall: List[int]) -> int: Returns the maximum number of consecutive days with zero rainfall. :param n: int, the number of days :param rainfall: list of int, the amount of rainfall on each day :return: int, the length of the longest sequence of consecutive days with zero rainfall >>> max_consecutive_zero_rainfall_days(7, [0, 1, 0, 0, 2, 0, 0, 0]) 3 >>> max_consecutive_zero_rainfall_days(5, [1, 2, 1, 2, 3]) 0","solution":"def max_consecutive_zero_rainfall_days(n, rainfall): Returns the maximum number of consecutive days with zero rainfall. :param n: int, the number of days :param rainfall: list of int, the amount of rainfall on each day :return: int, the length of the longest sequence of consecutive days with zero rainfall max_length = 0 current_length = 0 for amount in rainfall: if amount == 0: current_length += 1 if current_length > max_length: max_length = current_length else: current_length = 0 return max_length"},{"question":"class FileStorageSystem: def __init__(self): self.files = [] def add_file(self, size): Adds a file of the specified size to the system. pass def query_files(self, max_size): Returns the number of files with sizes less than or equal to max_size. pass def process_operations(operations): Processes a list of operations and returns results for QUERY operations. Example: >>> operations = [\\"ADD 100\\", \\"ADD 200\\", \\"QUERY 150\\", \\"ADD 50\\", \\"QUERY 150\\", \\"ADD 150\\", \\"QUERY 150\\", \\"END\\"] >>> process_operations(operations) [1, 2, 3] pass def test_add_and_query_operations(): operations = [ \\"ADD 100\\", \\"ADD 200\\", \\"QUERY 150\\", \\"ADD 50\\", \\"QUERY 150\\", \\"ADD 150\\", \\"QUERY 150\\", \\"END\\" ] expected_results = [1, 2, 3] assert process_operations(operations) == expected_results def test_only_add_operations(): operations = [ \\"ADD 100\\", \\"ADD 200\\", \\"ADD 50\\", \\"END\\" ] expected_results = [] assert process_operations(operations) == expected_results def test_only_query_operations(): operations = [ \\"QUERY 150\\", \\"QUERY 200\\", \\"END\\" ] expected_results = [0, 0] assert process_operations(operations) == expected_results def test_no_operations(): operations = [\\"END\\"] expected_results = [] assert process_operations(operations) == expected_results def test_mixed_size_operations(): operations = [ \\"ADD 300\\", \\"ADD 400\\", \\"ADD 500\\", \\"QUERY 350\\", \\"QUERY 450\\", \\"QUERY 550\\", \\"END\\" ] expected_results = [1, 2, 3] assert process_operations(operations) == expected_results","solution":"class FileStorageSystem: def __init__(self): self.files = [] def add_file(self, size): self.files.append(size) def query_files(self, max_size): return len([file for file in self.files if file <= max_size]) def process_operations(operations): system = FileStorageSystem() results = [] for operation in operations: if operation.startswith(\\"ADD\\"): size = int(operation.split()[1]) system.add_file(size) elif operation.startswith(\\"QUERY\\"): max_size = int(operation.split()[1]) count = system.query_files(max_size) results.append(count) return results"},{"question":"def detect_spam(messages: List[str]) -> List[str]: Detects messages that have been sent consecutively multiple times (spam). Args: messages (list): A list of messages sent by a user. Returns: list: A list of messages identified as spam. >>> detect_spam([ ... \\"Hey, are you there?\\", ... \\"Yes, I'm here.\\", ... \\"Yes, I'm here.\\", ... \\"What's up?\\", ... \\"What's up?\\", ... \\"What's up?\\", ... \\"Nothing much, you?\\", ... \\"Nothing much, you?\\", ... \\"Just chilling\\", ... \\"Just chilling\\" ... ]) [\\"Yes, I'm here.\\", \\"What's up?\\", \\"Nothing much, you?\\", \\"Just chilling\\"]","solution":"def detect_spam(messages): Detects messages that have been sent consecutively multiple times (spam). Args: messages (list): A list of messages sent by a user. Returns: list: A list of messages identified as spam. if not messages: return [] spam_messages = [] previous_message = messages[0] is_spam = False for message in messages[1:]: if message == previous_message: is_spam = True else: if is_spam: spam_messages.append(previous_message) is_spam = False previous_message = message if is_spam: # Check if the last set of messages were spams spam_messages.append(previous_message) return list(set(spam_messages)) # Remove duplicates"},{"question":"def is_aspect_ratio_acceptable(min_aspect: float, max_aspect: float, width: float, height: float) -> str: Determines if the aspect ratio of the template is within the acceptable range. Parameters: min_aspect (float): minimum acceptable aspect ratio max_aspect (float): maximum acceptable aspect ratio width (float): width of the template in inches height (float): height of the template in inches Returns: str: \\"Acceptable\\" if the aspect ratio is within the range, \\"Unacceptable\\" otherwise. >>> is_aspect_ratio_acceptable(1.0, 2.0, 8.0, 5.5) 'Acceptable' >>> is_aspect_ratio_acceptable(1.5, 3.0, 5.5, 8.0) 'Unacceptable' >>> is_aspect_ratio_acceptable(1.3, 1.7, 13.0, 10.0) 'Acceptable' >>> is_aspect_ratio_acceptable(1.3, 1.7, 17.0, 10.0) 'Acceptable' >>> is_aspect_ratio_acceptable(1.0, 2.0, 20.0, 5.5) 'Unacceptable'","solution":"def is_aspect_ratio_acceptable(min_aspect, max_aspect, width, height): Determines if the aspect ratio of the template is within the acceptable range. Parameters: min_aspect (float): minimum acceptable aspect ratio max_aspect (float): maximum acceptable aspect ratio width (float): width of the template in inches height (float): height of the template in inches Returns: str: \\"Acceptable\\" if the aspect ratio is within the range, \\"Unacceptable\\" otherwise. aspect_ratio = width / height if min_aspect <= aspect_ratio <= max_aspect: return \\"Acceptable\\" else: return \\"Unacceptable\\""},{"question":"def min_segments_with_unique_integers(n: int, lst: List[int]) -> int: Returns the minimum number of contiguous, non-overlapping sublists such that each sublist contains all unique integers. >>> min_segments_with_unique_integers(6, [1, 2, 3, 1, 2, 3]) 2 >>> min_segments_with_unique_integers(8, [4, 4, 4, 4, 4, 4, 4, 4]) 8 >>> min_segments_with_unique_integers(7, [1, 2, 1, 2, 1, 2, 1]) 4","solution":"def min_segments_with_unique_integers(n, lst): Returns the minimum number of contiguous, non-overlapping sublists such that each sublist contains all unique integers. segment_count = 0 seen = set() for number in lst: if number in seen: segment_count += 1 seen = set() seen.add(number) segment_count += 1 if seen else 0 return segment_count"},{"question":"from typing import List, Tuple def count_loyal_customers(c: int, k: int, d: int, purchases: List[Tuple[int, str, int]]) -> int: Counts the number of loyal customers in the database. A loyal customer is defined as one who has made at least \`k\` purchases and has spent a cumulative amount of at least \`d\` dollars. Args: c (int): Number of customers. k (int): Minimum number of purchases to be considered loyal. d (int): Minimum cumulative amount spent to be considered loyal. purchases (List[Tuple[int, str, int]]): A list of tuples, where each tuple contains the customer ID, the date of purchase, and the amount spent on that purchase. Returns: int: The number of loyal customers. >>> c, k, d = 5, 3, 300 >>> purchases = [ >>> (1, '2022-01-10', 150), >>> (2, '2022-01-15', 100), >>> (1, '2022-01-20', 50), >>> (1, '2022-02-05', 100), >>> (3, '2022-02-12', 200), >>> (2, '2022-03-01', 100), >>> (3, '2022-03-15', 150), >>> (4, '2022-04-01', 100), >>> (3, '2022-04-10', 50), >>> (5, '2022-05-25', 200), >>> (4, '2022-06-12', 200) >>> ] >>> count_loyal_customers(c, k, d, purchases) == 2","solution":"def count_loyal_customers(c, k, d, purchases): from collections import defaultdict # Create dictionaries to keep track of number of purchases and cumulative amount spent purchase_counts = defaultdict(int) cumulative_amounts = defaultdict(int) for purchase in purchases: ID, date, amount = purchase purchase_counts[ID] += 1 cumulative_amounts[ID] += amount # Count the number of loyal customers loyal_customers = 0 for customer_id in purchase_counts: if purchase_counts[customer_id] >= k and cumulative_amounts[customer_id] >= d: loyal_customers += 1 return loyal_customers"},{"question":"def satisfaction_trend(ratings: List[int]) -> str: Analyze the trend in customer satisfaction ratings. There are four possible trends for the ratings: - \\"I\\" for increasing trend - \\"D\\" for decreasing trend - \\"C\\" for constant trend - \\"M\\" for mixed trend Args: ratings (List[int]): A list of integers representing customer satisfaction ratings. Returns: str: A single character representing the trend in the ratings. Examples: >>> satisfaction_trend([1, 2, 3, 4, 5]) 'I' >>> satisfaction_trend([5, 4, 3, 2, 1]) 'D' >>> satisfaction_trend([3, 3, 3, 3]) 'C' >>> satisfaction_trend([3, 1, 4, 5, 2]) 'M'","solution":"from typing import List def satisfaction_trend(ratings: List[int]) -> str: if len(ratings) <= 1: return \\"C\\" increasing = decreasing = constant = True for i in range(1, len(ratings)): if ratings[i] > ratings[i - 1]: decreasing = constant = False elif ratings[i] < ratings[i - 1]: increasing = constant = False else: increasing = decreasing = False if increasing: return \\"I\\" if decreasing: return \\"D\\" if constant: return \\"C\\" return \\"M\\""},{"question":"def are_anagrams(a: str, b: str) -> str: Checks if two given strings are anagrams of each other. Args: a (str): First input string. b (str): Second input string. Returns: str: \\"YES\\" if the strings are anagrams, otherwise \\"NO\\". >>> are_anagrams(\\"listen\\", \\"silent\\") \\"YES\\" >>> are_anagrams(\\"hello\\", \\"world\\") \\"NO\\" >>> are_anagrams(\\"anagram\\", \\"nagaram\\") \\"YES\\"","solution":"def are_anagrams(a, b): Checks if two given strings are anagrams of each other. Args: a (str): First input string. b (str): Second input string. Returns: str: \\"YES\\" if the strings are anagrams, otherwise \\"NO\\". return \\"YES\\" if sorted(a) == sorted(b) else \\"NO\\""},{"question":"def max_cumulative_amount(blocks): Finds the maximum cumulative transaction amount in any continuous sub-chain of blocks. :param blocks: List of tuples, where each tuple contains (identifier, transaction_amount) :return: Maximum cumulative transaction amount >>> max_cumulative_amount([(1, 3), (2, -5), (3, 2), (4, 7), (5, -1)]) 9 >>> max_cumulative_amount([(1, -1), (2, -2), (3, -3)]) -1","solution":"def max_cumulative_amount(blocks): Finds the maximum cumulative transaction amount in any continuous sub-chain of blocks. :param blocks: List of tuples, where each tuple contains (identifier, transaction_amount) :return: Maximum cumulative transaction amount max_ending_here = max_so_far = blocks[0][1] for block in blocks[1:]: transaction = block[1] max_ending_here = max(transaction, max_ending_here + transaction) max_so_far = max(max_so_far, max_ending_here) return max_so_far"},{"question":"def kth_smallest_element(n: int, k: int, array: List[int]) -> int: Returns the k-th smallest element in the array. >>> kth_smallest_element(6, 3, [7, 10, 4, 3, 20, 15]) == 7 >>> kth_smallest_element(7, 4, [7, 10, 4, 3, 20, 15, 3]) == 7 >>> kth_smallest_element(8, 5, [2, 1, 5, 3, 2, 5, 6, 8]) == 5 >>> kth_smallest_element(4, 1, [2, 2, 2, 2]) == 2","solution":"def kth_smallest_element(n, k, array): Returns the k-th smallest element in the array. array.sort() return array[k - 1]"},{"question":"def min_operations_to_non_decreasing(n: int, heights: List[int]) -> int: Returns the minimum number of operations required to make the heights of all buildings non-decreasing. >>> min_operations_to_non_decreasing(5, [2, 1, 5, 3, 4]) == 4 >>> min_operations_to_non_decreasing(3, [3, 2, 1]) == 3 >>> min_operations_to_non_decreasing(4, [1, 2, 3, 4]) == 0","solution":"def min_operations_to_non_decreasing(n, heights): Returns the minimum number of operations required to make the heights of all buildings non-decreasing. operations = 0 for i in range(1, n): if heights[i] < heights[i-1]: operations += (heights[i-1] - heights[i]) heights[i] = heights[i-1] return operations"},{"question":"def min_color_changes(s: str) -> int: Returns the minimum number of color changes required to make all blocks the same color. >>> min_color_changes(\\"RGBR\\") 2 >>> min_color_changes(\\"RRRG\\") 1 >>> min_color_changes(\\"BGRRRG\\") 3","solution":"def min_color_changes(s): Returns the minimum number of color changes required to make all blocks the same color. count_r = s.count('R') count_g = s.count('G') count_b = s.count('B') # To make the entire line 'R', you'd need to change all 'G's and 'B's to 'R's changes_to_r = count_g + count_b # To make the entire line 'G', you'd need to change all 'R's and 'B's to 'G's changes_to_g = count_r + count_b # To make the entire line 'B', you'd need to change all 'R's and 'G's to 'B's changes_to_b = count_r + count_g # Return the minimum of the three values return min(changes_to_r, changes_to_g, changes_to_b)"},{"question":"def count_approved_tasks(m: int, decisions: List[List[int]]) -> int: Returns the number of tasks approved by at least two out of three students. Parameters: m (int): the number of tasks. decisions (list of list of int): a list containing m sub-lists each with three integers (0 for disapprove, 1 for approve). Returns: int: the number of tasks approved. Examples: >>> count_approved_tasks(4, [[1, 0, 1], [1, 1, 0], [0, 0, 1], [1, 1, 1]]) 3 >>> count_approved_tasks(3, [[0, 0, 0], [1, 0, 0], [1, 1, 0]]) 1","solution":"def count_approved_tasks(m, decisions): Returns the number of tasks approved by at least two out of three students. Parameters: m (int): the number of tasks. decisions (list of list of int): a list containing m sub-lists each with three integers (0 for disapprove, 1 for approve). Returns: int: the number of tasks approved. approved_count = 0 for decision in decisions: if sum(decision) >= 2: approved_count += 1 return approved_count"},{"question":"def process_input(data: str) -> str: Processes the input data to handle the aggregation as specified. The input data consists of a number of records, each containing a string (label) and a numerical value. The task is to group the records by their labels and find the sum of values for each group. Example: >>> process_input(\\"5napple 50nbanana 20napple 30nbanana 25ncherry 15\\") 'apple 80nbanana 45ncherry 15' >>> process_input(\\"3nfruit 10napple 25nfruit 40\\") 'apple 25nfruit 50' from typing import List, Tuple def aggregate_records(records: List[Tuple[str, int]]) -> dict: Aggregates a list of records by their labels and finds the sum of values for each group. Args: records (List[Tuple[str, int]]): A list of records, each is a tuple of (label, value) Returns: dict: A dictionary where the key is the label, and the value is the sum of values for that label def test_example1(): input_data = \\"5napple 50nbanana 20napple 30nbanana 25ncherry 15\\" expected_output = \\"apple 80nbanana 45ncherry 15\\" assert process_input(input_data) == expected_output def test_example2(): input_data = \\"3nfruit 10napple 25nfruit 40\\" expected_output = \\"apple 25nfruit 50\\" assert process_input(input_data) == expected_output def test_example3(): input_data = \\"7ndog 5ncat 3ndog 8ncat 4ndog 1nfish 7ncat 6\\" expected_output = \\"cat 13ndog 14nfish 7\\" assert process_input(input_data) == expected_output def test_single_record(): input_data = \\"1napple 50\\" expected_output = \\"apple 50\\" assert process_input(input_data) == expected_output def test_same_label_more_entries(): input_data = \\"4napple 20napple 10napple 15napple 5\\" expected_output = \\"apple 50\\" assert process_input(input_data) == expected_output def test_multiple_different_labels(): input_data = \\"4nbanana 30ngrape 50nwatermelon 45napple 20\\" expected_output = \\"apple 20nbanana 30ngrape 50nwatermelon 45\\" assert process_input(input_data) == expected_output","solution":"def aggregate_records(records): Aggregates a list of records by their labels and finds the sum of values for each group. Args: records (list of tuple): A list of records, each is a tuple of (label, value) Returns: dict: A dictionary where the key is the label, and the value is the sum of values for that label aggregation = {} for label, value in records: if label in aggregation: aggregation[label] += value else: aggregation[label] = value return dict(sorted(aggregation.items())) def process_input(data): Processes the input data to handle the aggregation as specified Args: data (str): The input data as a single string Returns: str: The formatted result as required by the problem statement lines = data.strip().split('n') n = int(lines[0]) records = [] for i in range(1, n + 1): parts = lines[i].rsplit(' ', 1) records.append((parts[0], int(parts[1]))) result = aggregate_records(records) output = [] for label, value in result.items(): output.append(f\\"{label} {value}\\") return 'n'.join(output)"},{"question":"def minimize_max_value(n: int, sequence: List[int]) -> int: Returns the minimum possible maximum value of the sequence after performing any number of allowed operations. >>> minimize_max_value(4, [2, 3, 7, 9]) 1 >>> minimize_max_value(3, [12, 15, 18]) 3","solution":"def minimize_max_value(n, sequence): Returns the minimum possible maximum value of the sequence after performing any number of allowed operations. # If the sequence contains all zero elements or only one element if all(x == 0 for x in sequence) or len(sequence) == 1: return 0 # Reduce the problem to considering the gcd of the numbers in the list from math import gcd from functools import reduce def find_gcd_of_list(seq): return reduce(gcd, seq) return find_gcd_of_list(sequence)"},{"question":"def is_palindrome(s: str) -> bool: Write a function that takes a string \`s\` and returns \`True\` if \`s\` is a palindrome and \`False\` otherwise. A palindrome is defined as a string that reads the same backward as forward. The function should be case-insensitive and ignore non-alphanumeric characters. >>> is_palindrome(\\"A man, a plan, a canal: Panama\\") True >>> is_palindrome(\\"race a car\\") False >>> is_palindrome(\\" \\") True","solution":"def is_palindrome(s: str) -> bool: # Filter only alphanumeric characters and convert to lowercase filtered_str = ''.join(char.lower() for char in s if char.isalnum()) # Check if the filtered string is equal to its reverse return filtered_str == filtered_str[::-1]"},{"question":"def largest_circle_radius(input_str: str) -> str: Find the largest possible radius of the resultant circle obtained by multiplying exactly two circles from the list. Args: input_str: A string containing an integer n followed by n integers representing the radii of circles. Returns: The largest possible radius of the resultant circle as a string formatted to 2 decimal places. >>> largest_circle_radius(\\"4 3 5 2 8\\") == \\"40.00\\" >>> largest_circle_radius(\\"2 1 1\\") == \\"1.00\\" >>> largest_circle_radius(\\"5 3 3 3 3 3\\") == \\"9.00\\" >>> largest_circle_radius(\\"3 999 1000 999\\") == \\"999000.00\\" >>> largest_circle_radius(\\"6 1 2 3 4 5 6\\") == \\"30.00\\" >>> largest_circle_radius(\\"5 1000 2 999 3 4\\") == \\"999000.00\\" >>> largest_circle_radius(\\"4 7 7 7 7\\") == \\"49.00\\"","solution":"def largest_circle_radius(input_str): input_list = list(map(int, input_str.split())) n = input_list[0] radii = input_list[1:] # Sort the radii to get the two largest radii.sort() largest = radii[-1] second_largest = radii[-2] # Compute the product largest_radius = largest * second_largest # Return formatted result return f\\"{largest_radius:.2f}\\""},{"question":"def unique_sentences(n: int, sentences: List[str]) -> List[str]: Returns a list of unique sentences in the order they first appeared. Parameters: n (int): Number of sentences. sentences (List[str]): List of sentences. Returns: List[str]: List of unique sentences in the order they first appeared. from solution import unique_sentences def test_unique_sentences(): input_data = [ \\"hello world\\", \\"programmers write code\\", \\"hello world\\", \\"python is cool\\", \\"programmers write code\\", \\"learn new things\\" ] expected_output = [ \\"hello world\\", \\"programmers write code\\", \\"python is cool\\", \\"learn new things\\" ] assert unique_sentences(6, input_data) == expected_output def test_all_unique(): input_data = [ \\"this is the first sentence\\", \\"this is the second sentence\\", \\"this is the third sentence\\" ] expected_output = [ \\"this is the first sentence\\", \\"this is the second sentence\\", \\"this is the third sentence\\" ] assert unique_sentences(3, input_data) == expected_output def test_all_duplicates(): input_data = [ \\"repeat\\", \\"repeat\\", \\"repeat\\", \\"repeat\\" ] expected_output = [ \\"repeat\\" ] assert unique_sentences(4, input_data) == expected_output def test_mixed(): input_data = [ \\"one\\", \\"two\\", \\"three\\", \\"one\\", \\"two\\", \\"four\\", \\"three\\", \\"four\\" ] expected_output = [ \\"one\\", \\"two\\", \\"three\\", \\"four\\" ] assert unique_sentences(8, input_data) == expected_output def test_empty_sentences(): input_data = [] expected_output = [] assert unique_sentences(0, input_data) == expected_output","solution":"def unique_sentences(n, sentences): Returns a list of unique sentences in the order they first appeared. Parameters: n (int): Number of sentences. sentences (List[str]): List of sentences. Returns: List[str]: List of unique sentences in the order they first appeared. seen = set() unique_list = [] for sentence in sentences: if sentence not in seen: seen.add(sentence) unique_list.append(sentence) return unique_list"},{"question":"from typing import List, Tuple def merge_sort_and_count(arr: List[int]) -> Tuple[List[int], int]: Function to perform merge sort and count inversions in the array. if len(arr) <= 1: return arr, 0 mid = len(arr) // 2 left, left_inv = merge_sort_and_count(arr[:mid]) right, right_inv = merge_sort_and_count(arr[mid:]) merged, split_inv = merge_and_count(left, right) total_inv = left_inv + right_inv + split_inv return merged, total_inv def merge_and_count(left: List[int], right: List[int]) -> Tuple[List[int], int]: Helper function to merge two sorted arrays and count inversions. merged = [] i = j = 0 split_inv = 0 while i < len(left) and j < len(right): if left[i] <= right[j]: merged.append(left[i]) i += 1 else: merged.append(right[j]) j += 1 split_inv += len(left) - i merged.extend(left[i:]) merged.extend(right[j:]) return merged, split_inv def count_inversions(arr: List[int]) -> int: Given an array of integers, count the total number of inversions required to transform the array into a sorted state using merge sort. >>> count_inversions([2, 4, 1, 3, 5]) 3 >>> count_inversions([5, 4, 3, 2, 1]) 10 _, inv_count = merge_sort_and_count(arr) return inv_count def test_example_case_1(): arr = [2, 4, 1, 3, 5] assert count_inversions(arr) == 3 def test_example_case_2(): arr = [5, 4, 3, 2, 1] assert count_inversions(arr) == 10 def test_no_inversions(): arr = [1, 2, 3, 4, 5] assert count_inversions(arr) == 0 def test_all_identical_elements(): arr = [1, 1, 1, 1, 1] assert count_inversions(arr) == 0 def test_single_element(): arr = [1] assert count_inversions(arr) == 0 def test_large_range(): arr = list(range(1000, 0, -1)) assert count_inversions(arr) == 499500","solution":"def merge_sort_and_count(arr): Function to perform merge sort and count inversions. if len(arr) <= 1: return arr, 0 mid = len(arr) // 2 left, left_inv = merge_sort_and_count(arr[:mid]) right, right_inv = merge_sort_and_count(arr[mid:]) merged, split_inv = merge_and_count(left, right) total_inv = left_inv + right_inv + split_inv return merged, total_inv def merge_and_count(left, right): Helper function to merge two sorted arrays and count inversions. merged = [] i = j = 0 split_inv = 0 while i < len(left) and j < len(right): if left[i] <= right[j]: merged.append(left[i]) i += 1 else: merged.append(right[j]) j += 1 split_inv += len(left) - i merged.extend(left[i:]) merged.extend(right[j:]) return merged, split_inv def count_inversions(arr): Function to count inversions in the array using merge sort. _, inv_count = merge_sort_and_count(arr) return inv_count"},{"question":"from itertools import permutations from typing import List, Tuple def place_cows(n: int) -> List[Tuple[int]]: Returns all possible ways to place n cows in an n x n grid such that no two cows share the same row or the same column. Arguments: n -- Number of cows and the dimension of the grid. Returns: A list of tuples, where each tuple represents a valid arrangement. pass def test_place_cows_1(): assert place_cows(1) == [(0,)] def test_place_cows_2(): assert place_cows(2) == [(0, 1), (1, 0)] def test_place_cows_3(): assert place_cows(3) == [ (0, 1, 2), (0, 2, 1), (1, 0, 2), (1, 2, 0), (2, 0, 1), (2, 1, 0) ] def test_place_cows_4(): assert len(place_cows(4)) == 24 # 4! = 24 def test_place_cows_5(): assert len(place_cows(5)) == 120 # 5! = 120","solution":"from itertools import permutations def place_cows(n): Returns all possible ways to place n cows in an n x n grid such that no two cows share the same row or the same column. Arguments: n -- Number of cows and the dimension of the grid. Returns: A list of lists, where each list represents a valid arrangement. return list(permutations(range(n)))"},{"question":"def product_of_even_digits(M: int) -> int: Returns the product of all the even digits present in M. If there are no even digits, return 1. >>> product_of_even_digits(123456) 48 >>> product_of_even_digits(1111111) 1 def process_test_cases(T: int, test_cases: List[int]) -> List[int]: Processes multiple test cases and returns the result for each test case. >>> process_test_cases(2, [123456, 1111111]) [48, 1] >>> process_test_cases(3, [2468, 13579, 0]) [384, 1, 0]","solution":"def product_of_even_digits(M): Returns the product of all the even digits present in M. If there are no even digits, return 1. product = 1 has_even_digit = False for digit in str(M): digit = int(digit) if digit % 2 == 0: product *= digit has_even_digit = True return product if has_even_digit else 1 def process_test_cases(T, test_cases): Processes multiple test cases and returns the result for each test case. results = [] for M in test_cases: results.append(product_of_even_digits(M)) return results if __name__ == \\"__main__\\": T = int(input()) test_cases = [int(input()) for _ in range(T)] results = process_test_cases(T, test_cases) for result in results: print(result)"},{"question":"def is_sorted_non_decreasing(arr): Determines if a list of integers is sorted in non-decreasing order. :param arr: List of integers :return: \\"YES\\" if the list is sorted in non-decreasing order, otherwise \\"NO\\" Examples: >>> is_sorted_non_decreasing([1, 2, 3, 4, 5]) \\"YES\\" >>> is_sorted_non_decreasing([3, 2, 1, 4]) \\"NO\\" from solution import is_sorted_non_decreasing def test_sorted_list(): assert is_sorted_non_decreasing([1, 2, 3, 4, 5]) == \\"YES\\" def test_unsorted_list(): assert is_sorted_non_decreasing([3, 2, 1, 4]) == \\"NO\\" def test_single_element_list(): assert is_sorted_non_decreasing([1]) == \\"YES\\" def test_all_elements_same(): assert is_sorted_non_decreasing([2, 2, 2, 2]) == \\"YES\\" def test_list_with_negative_numbers(): assert is_sorted_non_decreasing([-1, 0, 1, 2]) == \\"YES\\" def test_list_with_negative_and_positive_numbers(): assert is_sorted_non_decreasing([-3, -2, -1, 0, 1, 2, 3]) == \\"YES\\" def test_empty_list(): assert is_sorted_non_decreasing([]) == \\"YES\\" def test_large_unsorted_list(): assert is_sorted_non_decreasing([1, 2, 3, 5, 4]) == \\"NO\\"","solution":"def is_sorted_non_decreasing(arr): Determines if a list of integers is sorted in non-decreasing order. :param arr: List of integers :return: \\"YES\\" if the list is sorted in non-decreasing order, otherwise \\"NO\\" for i in range(len(arr) - 1): if arr[i] > arr[i + 1]: return \\"NO\\" return \\"YES\\""},{"question":"def solve(test_cases): Function to compute the sum of the first N Fibonacci numbers modulo M for each test case. Args: - test_cases: list of tuples, where each tuple contains two integers N and M Returns: - list of integers representing the results for each test case Examples: >>> solve([(5, 100)]) [12] >>> solve([(10, 1000)]) [143]","solution":"def fibonacci_sum_modulo(N, M): Function to calculate the sum of the first N Fibonacci numbers modulo M. def matrix_mult(A, B, mod): return [[(A[0][0] * B[0][0] + A[0][1] * B[1][0]) % mod, (A[0][0] * B[0][1] + A[0][1] * B[1][1]) % mod], [(A[1][0] * B[0][0] + A[1][1] * B[1][0]) % mod, (A[1][0] * B[0][1] + A[1][1] * B[1][1]) % mod]] def matrix_pow(matrix, n, mod): result = [[1, 0], [0, 1]] base = matrix while n > 0: if n % 2 == 1: result = matrix_mult(result, base, mod) base = matrix_mult(base, base, mod) n //= 2 return result def nth_fib(n, mod): if n <= 2: return 1 F = [[1, 1], [1, 0]] result = matrix_pow(F, n-1, mod) return result[0][0] def sum_fib(n, mod): if n == 0: return 0 return (nth_fib(n+2, mod) - 1) % mod return sum_fib(N, M) def solve(test_cases): results = [] for N, M in test_cases: results.append(fibonacci_sum_modulo(N, M)) return results"},{"question":"def min_subset_sum_difference(arr: List[int]) -> int: Returns the minimum possible difference between the sum of the elements in the two subsets. >>> min_subset_sum_difference([1, 2, 3, 9]) 3 >>> min_subset_sum_difference([1, 2, 7, 1, 5]) 0 >>> min_subset_sum_difference([1, 6, 11, 5]) 1 >>> min_subset_sum_difference([10]) 10 >>> min_subset_sum_difference([10, 5]) 5 >>> min_subset_sum_difference([5, 5, 5, 5]) 0 >>> min_subset_sum_difference([1]*100) 0 >>> min_subset_sum_difference([1000, 999, 998, 997, 996, 995]) 1","solution":"def min_subset_sum_difference(arr): Returns the minimum possible difference between the sum of the elements in the two subsets. total_sum = sum(arr) n = len(arr) target = total_sum // 2 # Initialize a DP table where dp[i] will be True if a subset with sum i can be formed. dp = [False] * (target + 1) dp[0] = True # Update dp table based on the numbers in the array for num in arr: for i in range(target, num - 1, -1): if dp[i - num]: dp[i] = True # Find the maximum possible sum closest to total_sum // 2 for i in range(target, -1, -1): if dp[i]: subset1_sum = i break # Calculate minimum difference subset2_sum = total_sum - subset1_sum return abs(subset1_sum - subset2_sum)"},{"question":"def rotate_matrix_90_clockwise(matrix): Rotates a 2D matrix 90 degrees clockwise and returns the rotated matrix. Args: matrix (list of list of int): The input 2D matrix to rotate. Returns: list of list of int: The rotated 2D matrix. >>> rotate_matrix_90_clockwise([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) == [ ... [7, 4, 1], ... [8, 5, 2], ... [9, 6, 3] ... ] >>> rotate_matrix_90_clockwise([ ... [-1, 0, 1, 2], ... [3, 4, 5, 6] ... ]) == [ ... [3, -1], ... [4, 0], ... [5, 1], ... [6, 2] ... ]","solution":"def rotate_matrix_90_clockwise(matrix): Rotates a 2D matrix 90 degrees clockwise and returns the rotated matrix. Args: matrix (list of list of int): The input 2D matrix to rotate. Returns: list of list of int: The rotated 2D matrix. if not matrix: return [] n = len(matrix) m = len(matrix[0]) rotated_matrix = [[0] * n for _ in range(m)] for i in range(n): for j in range(m): rotated_matrix[j][n - 1 - i] = matrix[i][j] return rotated_matrix"},{"question":"from typing import List, Tuple def count_even_sum_pairs(arr: List[int]) -> int: Counts the number of pairs (i, j) such that 0 ≤ i < j < N and the sum of the elements at those indices is even. pass def process_test_cases(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Process the given test cases and return a list of results for each test case. Parameters: T (int): The number of test cases. test_cases (List[Tuple[int, List[int]]]): List of tuples where each tuple contains the size of the array and the array itself. Returns: List[int]: List of results for each test case. pass # Unit tests def test_multiple_cases(): test_cases = [ (4, [1, 2, 3, 4]), (5, [5, 5, 5, 5, 5]) ] assert process_test_cases(2, test_cases) == [2, 10] def test_all_even_numbers(): test_cases = [ (6, [2, 4, 6, 8, 10, 12]) ] assert process_test_cases(1, test_cases) == [15] def test_all_odd_numbers(): test_cases = [ (6, [1, 3, 5, 7, 9, 11]) ] assert process_test_cases(1, test_cases) == [15] def test_mixed_numbers(): test_cases = [ (5, [1, 2, 3, 4, 6]) ] assert process_test_cases(1, test_cases) == [4] def test_minimum_size(): test_cases = [ (1, [1]) ] assert process_test_cases(1, test_cases) == [0] def test_all_same_odd(): test_cases = [ (4, [3, 3, 3, 3]) ] assert process_test_cases(1, test_cases) == [6] def test_all_same_even(): test_cases = [ (4, [2, 2, 2, 2]) ] assert process_test_cases(1, test_cases) == [6]","solution":"def count_even_sum_pairs(arr): Counts the number of pairs (i, j) such that 0 ≤ i < j < N and the sum of the elements at those indices is even. count_even = 0 count_odd = 0 for num in arr: if num % 2 == 0: count_even += 1 else: count_odd += 1 # The number of ways to choose 2 even numbers from count_even even_pairs = count_even * (count_even - 1) // 2 # The number of ways to choose 2 odd numbers from count_odd odd_pairs = count_odd * (count_odd - 1) // 2 return even_pairs + odd_pairs def process_test_cases(T, test_cases): results = [] for i in range(T): N, arr = test_cases[i] results.append(count_even_sum_pairs(arr)) return results"},{"question":"def is_prime(n: int) -> bool: Returns True if n is a prime number, otherwise False. >>> is_prime(2) True >>> is_prime(4) False def find_goldbach_pair(E: int) -> (int, int): Returns two prime numbers P1 and P2 such that E = P1 + P2. >>> find_goldbach_pair(20) (3, 17) >>> find_goldbach_pair(28) (5, 23)","solution":"def is_prime(n): Returns True if n is a prime number, otherwise False. if n < 2: return False if n == 2: return True if n % 2 == 0: return False for i in range(3, int(n**0.5) + 1, 2): if n % i == 0: return False return True def find_goldbach_pair(E): Returns two prime numbers P1 and P2 such that E = P1 + P2. for P1 in range(2, E): P2 = E - P1 if is_prime(P1) and is_prime(P2): return P1, P2 # Example usage E = 20 result = find_goldbach_pair(E) print(result)"},{"question":"def min_trucks(n: int, C: int, weights: List[int]) -> int: Returns the minimum number of trucks required to transport all packages. Parameters: - n (int): Number of packages - C (int): Maximum load capacity of a single truck - weights (list of int): Weights of the packages Returns: - (int): Minimum number of trucks required >>> min_trucks(7, 10, [2, 3, 5, 7, 1, 4, 5]) 3 >>> min_trucks(5, 10, [5, 5, 5, 5, 5]) 3 >>> min_trucks(1, 10, [9]) 1 >>> min_trucks(4, 4, [4, 4, 4, 4]) 4","solution":"import itertools def min_trucks(n, C, weights): Returns the minimum number of trucks required to transport all packages. Parameters: - n (int): Number of packages - C (int): Maximum load capacity of a single truck - weights (list of int): Weights of the packages Returns: - (int): Minimum number of trucks required weights.sort(reverse=True) if not weights: return 0 trucks = [] for weight in weights: placed = False for truck in trucks: if sum(truck) + weight <= C: truck.append(weight) placed = True break if not placed: trucks.append([weight]) return len(trucks)"},{"question":"class VersionHistoryLog: A class to maintain a version history log for each user in a system. Each version of user data is represented by an integer. Methods: addVersion(userId, version): Adds a new version for the given user. getVersion(userId): Returns the latest version of data for the given user. getVersionAtTime(userId, timestamp): Returns the version for the given user at the specified timestamp. def addVersion(self, userId: int, version: int) -> None: Adds a new version for the given user. Args: userId (int): The ID of the user. version (int): The version to be added. # Your code here def getVersion(self, userId: int) -> int: Returns the latest version of data for the given user. Args: userId (int): The ID of the user. Returns: int: The latest version of data for the given user. # Your code here def getVersionAtTime(self, userId: int, timestamp: int) -> int: Returns the version for the given user at the specified timestamp. Args: userId (int): The ID of the user. timestamp (int): The timestamp at which the version was added. Returns: int: The version of data for the given user at the specified timestamp. # Your code here # Unit tests def test_add_and_get_latest_version(): vhl = VersionHistoryLog() vhl.addVersion(1, 100) vhl.addVersion(2, 200) assert vhl.getVersion(1) == 100 assert vhl.getVersion(2) == 200 def test_get_version_at_time(): vhl = VersionHistoryLog() vhl.addVersion(1, 100) vhl.addVersion(1, 150) vhl.addVersion(1, 200) assert vhl.getVersionAtTime(1, 1) == 100 assert vhl.getVersionAtTime(1, 2) == 150 assert vhl.getVersionAtTime(1, 3) == 200 def test_get_version_without_additions(): vhl = VersionHistoryLog() assert vhl.getVersion(1) == None assert vhl.getVersionAtTime(1, 1) == None def test_mixed_operations(): vhl = VersionHistoryLog() vhl.addVersion(1, 50) vhl.addVersion(1, 60) assert vhl.getVersion(1) == 60 assert vhl.getVersionAtTime(1, 1) == 50 vhl.addVersion(2, 70) vhl.addVersion(1, 80) assert vhl.getVersion(2) == 70 assert vhl.getVersionAtTime(1, 3) == 80 assert vhl.getVersion(1) == 80","solution":"class VersionHistoryLog: def __init__(self): self.user_versions = {} def addVersion(self, userId, version): if userId not in self.user_versions: self.user_versions[userId] = [] self.user_versions[userId].append(version) def getVersion(self, userId): if userId in self.user_versions and self.user_versions[userId]: return self.user_versions[userId][-1] return None def getVersionAtTime(self, userId, timestamp): if userId in self.user_versions and 0 <= timestamp-1 < len(self.user_versions[userId]): return self.user_versions[userId][timestamp-1] return None"},{"question":"def get_winner(a: int, b: int, c: int, d: int) -> tuple: Determines the total points of Alex and Bob and declares the winner. Parameters: a (int): Total points Alex scored on problems he and Bob both solved b (int): Total points Bob scored on problems he and Alex both solved c (int): Total points Alex scored on problems only he solved d (int): Total points Bob scored on problems only he solved Returns: tuple: Total points of Alex, total points of Bob, and the winner (\\"Alex\\", \\"Bob\\", or \\"Draw\\") >>> get_winner(10, 20, 15, 5) (25, 25, \\"Draw\\") >>> get_winner(30, 20, 10, 5) (40, 25, \\"Alex\\") >>> get_winner(20, 30, 5, 15) (25, 45, \\"Bob\\") >>> get_winner(0, 0, 0, 0) (0, 0, \\"Draw\\") >>> get_winner(100, 50, 25, 75) (125, 125, \\"Draw\\") >>> get_winner(100, 50, 50, 25) (150, 75, \\"Alex\\") >>> get_winner(50, 100, 25, 75) (75, 175, \\"Bob\\")","solution":"def get_winner(a, b, c, d): Determines the total points of Alex and Bob and declares the winner. Parameters: a (int): Total points Alex scored on problems he and Bob both solved b (int): Total points Bob scored on problems he and Alex both solved c (int): Total points Alex scored on problems only he solved d (int): Total points Bob scored on problems only he solved Returns: tuple: Total points of Alex, total points of Bob, and the winner (\\"Alex\\", \\"Bob\\", or \\"Draw\\") alex_points = a + c bob_points = b + d if alex_points > bob_points: winner = \\"Alex\\" elif bob_points > alex_points: winner = \\"Bob\\" else: winner = \\"Draw\\" return alex_points, bob_points, winner"},{"question":"def min_visits_to_deplete_inventory(N: int, A: List[int]) -> int: Returns the minimum number of visits required to deplete the entire stock of toys. Args: N: An integer representing the number of types of toys. A: An array of N integers, where A[i] is the stock of the ith type of toy. Returns: An integer representing the minimum number of visits required to deplete the entire inventory of toys. Example: >>> min_visits_to_deplete_inventory(5, [3, 6, 2, 8, 3]) 22 >>> min_visits_to_deplete_inventory(1, [10]) 10 >>> min_visits_to_deplete_inventory(3, [5, 5, 5]) 15 >>> min_visits_to_deplete_inventory(4, [1, 2, 3, 4]) 10 >>> min_visits_to_deplete_inventory(3, [3, 2, 1]) 6","solution":"def min_visits_to_deplete_inventory(N, A): Returns the minimum number of visits required to deplete the entire stock of toys. return sum(A)"},{"question":"def count_unique_countries(t: int, test_cases: List[Tuple[int, List[str]]]) -> List[int]: Function to count the number of unique countries from which Bob has stamps. Parameters: t: integer, the number of test cases test_cases: list of tuples, each tuple contains: n: integer, number of stamps in Bob's collection for this test case stamps: list of strings, each string represents the country of origin of a stamp. Returns: list: a list of integers representing the number of unique countries for each test case. >>> count_unique_countries(3, [(6, [\\"Brazil\\", \\"Argentina\\", \\"Brazil\\", \\"Germany\\", \\"Brazil\\", \\"Japan\\"]), (4, [\\"USA\\", \\"Canada\\", \\"Mexico\\", \\"USA\\"]), (5, [\\"India\\", \\"India\\", \\"China\\", \\"China\\", \\"Japan\\"])]) [4, 3, 3] >>> count_unique_countries(1, [(4, [\\"Italy\\", \\"Italy\\", \\"Italy\\", \\"Italy\\"])]) [1]","solution":"def count_unique_countries(t, test_cases): Function to count the number of unique countries from which Bob has stamps. Parameters: t: integer, the number of test cases test_cases: list of tuples, each tuple contains: n: integer, number of stamps in Bob's collection for this test case stamps: list of strings, each string represents the country of origin of a stamp. Returns: list: a list of integers representing the number of unique countries for each test case. unique_counts = [] for case in test_cases: n, stamps = case unique_countries = set(stamps) unique_counts.append(len(unique_countries)) return unique_counts"},{"question":"def find_odd_occurrence(n: int, arr: List[int]) -> Tuple[int, int]: Find the element that occurs an odd number of times and the number of times it appears. Args: n: int : the number of elements in the array arr: List[int] : the array of integers Returns: Tuple[int, int] : a tuple containing the element that appears an odd number of times and the number of times it appears. >>> find_odd_occurrence(7, [4, 3, 2, 4, 3, 3, 2]) (3, 3) >>> find_odd_occurrence(5, [10, 20, 10, 20, 10]) (10, 3)","solution":"def find_odd_occurrence(n, arr): frequency_dict = {} # Count the frequency of each element in the array for num in arr: if num in frequency_dict: frequency_dict[num] += 1 else: frequency_dict[num] = 1 # Find the element with odd occurrence for num, count in frequency_dict.items(): if count % 2 != 0: return num, count"},{"question":"from typing import List def min_removals(n: int, m: int, heights: List[int]) -> int: You are given an array of n integers, each representing a building's height in a skyline. The skyline creates a silhouette when viewed from a distance. Your task is to determine the minimum number of buildings that need to be removed so that the remaining buildings create a skyline silhouette with at most m peaks. A peak is defined as any building that is taller than both its neighboring buildings. The first and last buildings cannot be peaks since they do not have two neighbors. Input: - n (1 ≤ n ≤ 10^5): the number of buildings. - m (0 ≤ m ≤ n - 2): the maximum number of peaks allowed in the skyline. - heights (1 ≤ heights[i] ≤ 10^9): the heights of the buildings. Output: - int: The minimum number of buildings that need to be removed to satisfy the peak constraint. Example: >>> min_removals(6, 1, [1, 3, 2, 4, 1, 5]) 1 >>> min_removals(6, 2, [1, 3, 2, 4, 1, 5]) 0 >>> min_removals(5, 0, [5, 5, 5, 5, 5]) 0 >>> min_removals(4, 1, [1, 2, 3, 1]) 0 >>> min_removals(100000, 0, [1] * 100000) 0","solution":"def min_removals(n, m, heights): def count_peaks(heights): peaks = 0 for i in range(1, len(heights) - 1): if heights[i] > heights[i - 1] and heights[i] > heights[i + 1]: peaks += 1 return peaks current_peaks = count_peaks(heights) if current_peaks <= m: return 0 removal_count = 0 while current_peaks > m: found_removal = False for i in range(1, len(heights) - 1): if heights[i] > heights[i - 1] and heights[i] > heights[i + 1]: heights.pop(i) current_peaks = count_peaks(heights) removal_count += 1 found_removal = True break if not found_removal: break return removal_count"},{"question":"from typing import List def has_uniform_subgrid(n: int, k: int, grid: List[List[int]]) -> str: Determine whether there is a sub-grid of size k × k where all the pixel values are the same. >>> has_uniform_subgrid(5, 2, [ [1, 2, 3, 4, 5], [1, 1, 1, 1, 1], [3, 1, 1, 3, 2], [4, 1, 1, 5, 6], [5, 5, 5, 5, 5] ]) 'YES' >>> has_uniform_subgrid(4, 3, [ [1, 2, 3, 4], [4, 4, 4, 4], [1, 1, 1, 1], [0, 1, 2, 3] ]) 'NO' >>> has_uniform_subgrid(3, 1, [ [2, 3, 4], [5, 6, 7], [8, 9, 0] ]) 'YES' import pytest from solution import has_uniform_subgrid def test_case_1(): n, k = 5, 2 grid = [ [1, 2, 3, 4, 5], [1, 1, 1, 1, 1], [3, 1, 1, 3, 2], [4, 1, 1, 5, 6], [5, 5, 5, 5, 5] ] assert has_uniform_subgrid(n, k, grid) == \\"YES\\" def test_case_2(): n, k = 4, 3 grid = [ [1, 2, 3, 4], [4, 4, 4, 4], [1, 1, 1, 1], [0, 1, 2, 3] ] assert has_uniform_subgrid(n, k, grid) == \\"NO\\" def test_case_3(): n, k = 3, 1 grid = [ [2, 3, 4], [5, 6, 7], [8, 9, 0] ] assert has_uniform_subgrid(n, k, grid) == \\"YES\\" def test_case_4(): n, k = 3, 3 grid = [ [1, 1, 1], [1, 1, 1], [1, 1, 1] ] assert has_uniform_subgrid(n, k, grid) == \\"YES\\" def test_case_5(): n, k = 2, 2 grid = [ [1, 2], [3, 4] ] assert has_uniform_subgrid(n, k, grid) == \\"NO\\" def test_case_6(): n, k = 6, 3 grid = [ [1, 1, 2, 1, 1, 1], [1, 1, 2, 1, 1, 1], [2, 2, 2, 1, 1, 1], [1, 1, 2, 1, 1, 1], [1, 1, 2, 1, 1, 1], [2, 2, 2, 1, 1, 1] ] assert has_uniform_subgrid(n, k, grid) == \\"YES\\"","solution":"def has_uniform_subgrid(n, k, grid): for i in range(n - k + 1): for j in range(n - k + 1): is_uniform = True initial_value = grid[i][j] for x in range(i, i + k): for y in range(j, j + k): if grid[x][y] != initial_value: is_uniform = False break if not is_uniform: break if is_uniform: return \\"YES\\" return \\"NO\\""},{"question":"def perform_operations(N: int, arr: List[int], Q: int, operations: List[List[int]]) -> List[int]: Given an array of integers \`arr\` of size \`N\`, perform Q operations on it. Each operation can be one of the following two types: 1. Add a value \`V\` to all elements in a subarray from index \`L\` to \`R\` (both inclusive). 2. Compute the sum of all elements in a subarray from index \`L\` to \`R\` (both inclusive). Input: - N: the size of the array. - arr: the elements of the array. - Q: the number of operations. - operations: a list of operations to be performed, each operation specified by a list. Output: For each operation of type 2, append the sum of the specified subarray to the results list. >>> perform_operations(5, [1, 2, 3, 4, 5], 4, [[1, 1, 3, 2], [2, 1, 3], [1, 2, 5, -1], [2, 1, 3]]) [12, 10]","solution":"def perform_operations(N, arr, Q, operations): result = [] for op in operations: if op[0] == 1: L, R, V = op[1], op[2], op[3] for i in range(L - 1, R): arr[i] += V elif op[0] == 2: L, R = op[1], op[2] result.append(sum(arr[L - 1:R])) return result"},{"question":"def count_subarrays_with_sum(arr, M): Returns the number of subarrays whose sum is exactly M. Parameters: arr (list of int): List of integers representing the array. M (int): The desired subarray sum. Returns: int: The count of subarrays with sum equal to M. >>> count_subarrays_with_sum([1, 2, 3, 2, 1], 5) 2 >>> count_subarrays_with_sum([5], 5) 1 >>> count_subarrays_with_sum([1], 5) 0 >>> count_subarrays_with_sum([1, 1, 1, 1, 1], 2) 4 >>> count_subarrays_with_sum([1, 2, 1, 2, 1], 10) 0 >>> count_subarrays_with_sum([1, -1, 1, -1, 1], 0) 6","solution":"def count_subarrays_with_sum(arr, M): Returns the number of subarrays whose sum is exactly M. Parameters: arr (list of int): List of integers representing the array. M (int): The desired subarray sum. Returns: int: The count of subarrays with sum equal to M. count = 0 curr_sum = 0 prefix_sums = {0: 1} for num in arr: curr_sum += num if (curr_sum - M) in prefix_sums: count += prefix_sums[curr_sum - M] if curr_sum in prefix_sums: prefix_sums[curr_sum] += 1 else: prefix_sums[curr_sum] = 1 return count # Example usage N, M = 5, 5 arr = [1, 2, 3, 2, 1] print(count_subarrays_with_sum(arr, M)) # Output: 2"},{"question":"def can_complete_delivery_plan(datasets): Determines whether each truck can complete its assigned delivery plan without exceeding its weight capacity for multiple datasets. Args: datasets: List of tuples containing the truck's weight capacity, number of cities to visit, and the weights of the delivery requests for each city. Returns: List of strings \\"YES\\" or \\"NO\\" for each dataset. Examples: >>> can_complete_delivery_plan([(100, 3, [50, 30, 20]), (150, 4, [40, 60, 20, 10]), (200, 2, [150, 60]), (80, 3, [50, 20, 30])]) ['YES', 'YES', 'NO', 'NO'] pass def process_input(input_data): Processes the input data for multiple datasets. Args: input_data: Multiline string containing the datasets. Returns: List of tuples where each tuple contains the truck's weight capacity, number of cities to visit, and the weights of the delivery requests for each city. Examples: >>> process_input(''' 100 3 50 30 20 150 4 40 60 20 10 200 2 150 60 80 3 50 20 30''') [(100, 3, [50, 30, 20]), (150, 4, [40, 60, 20, 10]), (200, 2, [150, 60]), (80, 3, [50, 20, 30])] pass from solution import can_complete_delivery_plan, process_input def test_can_complete_delivery_plan(): input_data = 100 3 50 30 20 150 4 40 60 20 10 200 2 150 60 80 3 50 20 30 datasets = process_input(input_data) results = can_complete_delivery_plan(datasets) assert results == [\\"YES\\", \\"YES\\", \\"NO\\", \\"NO\\"] def test_all_no(): input_data = 50 3 30 30 30 60 3 20 30 40 datasets = process_input(input_data) results = can_complete_delivery_plan(datasets) assert results == [\\"NO\\", \\"NO\\"] def test_all_yes(): input_data = 300 3 100 100 100 100 2 50 50 datasets = process_input(input_data) results = can_complete_delivery_plan(datasets) assert results == [\\"YES\\", \\"YES\\"] def test_single_dataset_yes(): input_data = 100 1 90 datasets = process_input(input_data) results = can_complete_delivery_plan(datasets) assert results == [\\"YES\\"] def test_single_dataset_no(): input_data = 10 1 20 datasets = process_input(input_data) results = can_complete_delivery_plan(datasets) assert results == [\\"NO\\"]","solution":"def can_complete_delivery_plan(datasets): results = [] for data in datasets: C, D, weights = data if sum(weights) <= C: results.append(\\"YES\\") else: results.append(\\"NO\\") return results # Function to process multiple datasets from the input format def process_input(input_data): lines = input_data.strip().split(\\"n\\") datasets = [] i = 0 while i < len(lines): C, D = map(int, lines[i].split()) weights = list(map(int, lines[i+1].split())) datasets.append((C, D, weights)) i += 2 return datasets"},{"question":"def max_sum_of_k_consecutive_elements(n: int, k: int, sequence: List[int]) -> int: Finds the maximum sum of k consecutive elements in the given sequence. Args: n (int): The number of elements in the sequence. k (int): The number of consecutive elements to be summed. sequence (list): The list of integers representing the sequence. Returns: int: The maximum sum of k consecutive elements. >>> max_sum_of_k_consecutive_elements(8, 3, [2, 1, 5, 1, 3, 2, -6, 4]) 9 >>> max_sum_of_k_consecutive_elements(5, 2, [-1, -2, -3, -4, -5]) -3 >>> max_sum_of_k_consecutive_elements(5, 2, [1, 2, 3, 4, 5]) 9 >>> max_sum_of_k_consecutive_elements(6, 3, [2, -1, 2, 3, -5, 1]) 4 >>> max_sum_of_k_consecutive_elements(1, 1, [5]) 5 >>> max_sum_of_k_consecutive_elements(5, 5, [1, 2, 3, 4, 5]) 15 >>> max_sum_of_k_consecutive_elements(3, 3, [1, 2, 3]) 6 pass","solution":"def max_sum_of_k_consecutive_elements(n, k, sequence): Finds the maximum sum of k consecutive elements in the given sequence. Args: n (int): The number of elements in the sequence. k (int): The number of consecutive elements to be summed. sequence (list): The list of integers representing the sequence. Returns: int: The maximum sum of k consecutive elements. current_sum = sum(sequence[:k]) max_sum = current_sum for i in range(k, n): current_sum = current_sum + sequence[i] - sequence[i - k] max_sum = max(max_sum, current_sum) return max_sum"},{"question":"def generate_tournament_schedule(n: int): Generate a balanced tournament schedule where no player has consecutive matches. Args: n (int): The number of players in the tournament. Returns: List or str: \\"NO\\" if it's impossible to generate the schedule, else a list with \\"YES\\" followed by n lists of length n-1 representing the schedule. >>> generate_tournament_schedule(3) [\\"YES\\", [2, 3], [3, 1], [1, 2]] >>> generate_tournament_schedule(2) \\"NO\\"","solution":"def generate_tournament_schedule(n): if n < 3: return \\"NO\\" schedule = [] for i in range(1, n+1): row = [(i + j) % n for j in range(1, n)] row = [x if x != 0 else n for x in row] schedule.append(row) return [\\"YES\\"] + schedule"},{"question":"def handle_operations(operations): Process a list of operations on a shopping cart. Args: operations (list): A list of operation strings. Returns: list: A list of dictionaries representing the state of the cart after each \\"get_cart()\\" operation. Example: >>> handle_operations([\\"add 101 3\\", \\"add 102 5\\", \\"get_cart()\\"]) [{101: 3, 102: 5}] >>> handle_operations([\\"add 101 3\\", \\"add 102 5\\", \\"remove 101 2\\", \\"get_cart()\\"]) [{101: 1, 102: 5}] def test_handle_operations_single_add_get_cart(): operations = [\\"add 101 3\\", \\"get_cart()\\"] assert handle_operations(operations) == [{101: 3}] def test_handle_operations_multiple_adds(): operations = [\\"add 101 3\\", \\"add 102 5\\", \\"get_cart()\\"] assert handle_operations(operations) == [{101: 3, 102: 5}] def test_handle_operations_add_and_remove(): operations = [\\"add 101 3\\", \\"add 102 5\\", \\"remove 101 2\\", \\"get_cart()\\"] assert handle_operations(operations) == [{101: 1, 102: 5}] def test_handle_operations_remove_to_zero(): operations = [\\"add 101 3\\", \\"remove 101 3\\", \\"get_cart()\\"] assert handle_operations(operations) == [{}] def test_handle_operations_remove_non_existent_product(): operations = [\\"remove 101 2\\", \\"get_cart()\\"] assert handle_operations(operations) == [{}] def test_handle_operations_add_remove_get_cart(): operations = [ \\"add 101 3\\", \\"add 102 5\\", \\"get_cart()\\", \\"remove 101 2\\", \\"get_cart()\\", \\"remove 102 5\\", \\"get_cart()\\", ] assert handle_operations(operations) == [ {101: 3, 102: 5}, {101: 1, 102: 5}, {101: 1} ]","solution":"def handle_operations(operations): cart = {} def add(product_id, quantity): if product_id in cart: cart[product_id] += quantity else: cart[product_id] = quantity def remove(product_id, quantity): if product_id in cart: cart[product_id] -= quantity if cart[product_id] <= 0: del cart[product_id] def get_cart(): return dict(sorted(cart.items())) results = [] for operation in operations: parts = operation.split() action = parts[0] if action == \\"add\\": product_id = int(parts[1]) quantity = int(parts[2]) add(product_id, quantity) elif action == \\"remove\\": product_id = int(parts[1]) quantity = int(parts[2]) remove(product_id, quantity) elif action == \\"get_cart()\\": results.append(get_cart()) return results"},{"question":"def minimal_weight_difference(n: int, weights: List[int]) -> int: Distribute items into two separate boxes such that the difference in the total weight of the items in the two boxes is minimized. Args: n (int): The number of items. weights (List[int]): A list of weights of the items. Returns: int: The minimal difference between the total weights of the items in the two boxes. >>> minimal_weight_difference(4, [1, 2, 3, 4]) 0 >>> minimal_weight_difference(3, [8, 5, 3]) 0 from solution import minimal_weight_difference def test_minimal_weight_difference_example_1(): assert minimal_weight_difference(4, [1, 2, 3, 4]) == 0 def test_minimal_weight_difference_example_2(): assert minimal_weight_difference(3, [8, 5, 3]) == 0 def test_minimal_weight_difference_single_item(): assert minimal_weight_difference(1, [10]) == 10 def test_minimal_weight_difference_two_items(): assert minimal_weight_difference(2, [10, 15]) == 5 def test_minimal_weight_difference_identical_weights(): assert minimal_weight_difference(4, [2, 2, 2, 2]) == 0 def test_minimal_weight_difference_different_weights(): assert minimal_weight_difference(5, [1, 2, 3, 9, 10]) == 1","solution":"def minimal_weight_difference(n, weights): total_sum = sum(weights) half_sum = total_sum // 2 dp = [False] * (half_sum + 1) dp[0] = True for weight in weights: for i in range(half_sum, weight - 1, -1): dp[i] = dp[i] or dp[i - weight] for i in range(half_sum, -1, -1): if dp[i]: return abs(total_sum - 2 * i) return total_sum"},{"question":"from collections import deque def shortest_path_length(n, m, edges, s, t): Find the shortest path length between two nodes in an undirected graph with unit weight edges. Parameters: - n (int): Number of nodes in the graph. - m (int): Number of edges in the graph. - edges (list of tuples): List of edges where each edge is represented by a tuple (u, v). - s (int): Source node. - t (int): Target node. Returns: - int: The length of the shortest path from node s to node t, or -1 if no such path exists. pass # Test cases def test_example_1(): n = 6 m = 7 edges = [(1, 2), (1, 3), (2, 4), (3, 4), (4, 5), (5, 6), (2, 3)] s = 1 t = 6 assert shortest_path_length(n, m, edges, s, t) == 4 def test_example_2(): n = 4 m = 2 edges = [(1, 2), (3, 4)] s = 1 t = 3 assert shortest_path_length(n, m, edges, s, t) == -1 def test_single_node(): n = 1 m = 0 edges = [] s = 1 t = 1 assert shortest_path_length(n, m, edges, s, t) == 0 def test_direct_connection(): n = 2 m = 1 edges = [(1, 2)] s = 1 t = 2 assert shortest_path_length(n, m, edges, s, t) == 1 def test_no_connection(): n = 3 m = 0 edges = [] s = 1 t = 3 assert shortest_path_length(n, m, edges, s, t) == -1 def test_larger_graph(): n = 5 m = 5 edges = [(1, 2), (2, 3), (3, 4), (4, 5), (1, 5)] s = 1 t = 4 assert shortest_path_length(n, m, edges, s, t) == 2","solution":"from collections import deque def shortest_path_length(n, m, edges, s, t): Find the shortest path length between two nodes in an undirected graph with unit weight edges. Parameters: - n (int): Number of nodes in the graph. - m (int): Number of edges in the graph. - edges (list of tuples): List of edges where each edge is represented by a tuple (u, v). - s (int): Source node. - t (int): Target node. Returns: - int: The length of the shortest path from node s to node t, or -1 if no such path exists. # Initialize adjacency list adj_list = {i: [] for i in range(1, n + 1)} for u, v in edges: adj_list[u].append(v) adj_list[v].append(u) # BFS to find the shortest path queue = deque([(s, 0)]) visited = set() visited.add(s) while queue: node, dist = queue.popleft() if node == t: return dist for neighbor in adj_list[node]: if neighbor not in visited: visited.add(neighbor) queue.append((neighbor, dist + 1)) return -1"},{"question":"def longest_increasing_subarray(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Determine the length of the longest contiguous subarray where each element is strictly greater than the element immediately before it. Args: t: Number of test cases test_cases: A list of tuples, where each tuple contains an integer n (length of the array) and a list of integers (the array elements). Returns: A list of integers where each integer is the length of the longest contiguous subarray for respective test case. Example: >>> longest_increasing_subarray(3, [(5, [1, 2, 2, 1, 2]), (6, [1, 2, 3, 4, 5, 6]), (4, [7, 7, 7, 7])]) [2, 6, 1] from typing import List, Tuple def test_longest_increasing_subarray(): t = 3 test_cases = [ (5, [1, 2, 2, 1, 2]), (6, [1, 2, 3, 4, 5, 6]), (4, [7, 7, 7, 7]) ] expected = [2, 6, 1] assert longest_increasing_subarray(t, test_cases) == expected def test_single_element(): t = 2 test_cases = [ (1, [5]), (1, [10]) ] expected = [1, 1] assert longest_increasing_subarray(t, test_cases) == expected def test_no_increasing_elements(): t = 1 test_cases = [ (5, [5, 4, 3, 2, 1]) ] expected = [1] assert longest_increasing_subarray(t, test_cases) == expected def test_all_elements_same(): t = 1 test_cases = [ (3, [2, 2, 2]) ] expected = [1] assert longest_increasing_subarray(t, test_cases) == expected def test_multiple_increasing_sequences(): t = 1 test_cases = [ (7, [1, 2, 1, 2, 3, 1, 2]) ] expected = [3] assert longest_increasing_subarray(t, test_cases) == expected def test_large_input(): t = 1 test_cases = [ (10**5, list(range(1, 10**5 + 1))) ] expected = [10**5] assert longest_increasing_subarray(t, test_cases) == expected","solution":"def longest_increasing_subarray(t, test_cases): results = [] for case in test_cases: n, arr = case if n == 1: results.append(1) continue max_length = 1 current_length = 1 for i in range(1, n): if arr[i] > arr[i-1]: current_length += 1 max_length = max(max_length, current_length) else: current_length = 1 results.append(max_length) return results"},{"question":"def max_candles_to_blow(n: int, heights: List[int]) -> int: Returns the maximum number of the tallest candles that can be blown out in one breath. >>> max_candles_to_blow(4, [3, 2, 1, 3]) 2 >>> max_candles_to_blow(1, [1]) 1 >>> max_candles_to_blow(5, [2, 2, 2, 2, 2]) 5 >>> max_candles_to_blow(5, [1, 3, 2, 3, 1]) 2 >>> max_candles_to_blow(4, [1, 2, 3, 4]) 1 >>> max_candles_to_blow(4, [4, 3, 2, 1]) 1 >>> max_candles_to_blow(5, [10000000, 9999999, 10000000, 9999998, 10000000]) 3 return 0 # replace this with the actual implementation","solution":"def max_candles_to_blow(n, heights): Returns the maximum number of the tallest candles that can be blown out in one breath. Parameters: n (int): The number of candles. heights (list): The heights of the candles. Returns: int: The number of tallest candles. max_height = max(heights) return heights.count(max_height)"},{"question":"def max_sum_after_removal(arr: List[int]) -> int: Find the maximum sum of remaining elements of a contiguous subarray after removing exactly one element. >>> max_sum_after_removal([1, 2, 3, 4, 5]) 14 >>> max_sum_after_removal([9, 8, 7, 6, 5]) 30","solution":"def max_sum_after_removal(arr): Find the maximum sum of remaining elements of a contiguous subarray after removing exactly one element n = len(arr) # Special cases if n == 2: return max(arr) # max_ending_before[i] means maximum sum subarray ending before the i-th element max_ending_before = [0] * n current_max = 0 for i in range(n): current_max = max(arr[i], current_max + arr[i]) max_ending_before[i] = current_max # max_starting_after[i] means maximum sum subarray starting after the i-th element max_starting_after = [0] * n current_max = 0 for j in range(n-1, -1, -1): current_max = max(arr[j], current_max + arr[j]) max_starting_after[j] = current_max max_sum = float('-inf') for i in range(n): if i == 0: max_sum = max(max_sum, max_starting_after[i + 1]) elif i == n - 1: max_sum = max(max_sum, max_ending_before[i - 1]) else: max_sum = max(max_sum, max_ending_before[i - 1] + max_starting_after[i + 1]) return max_sum"},{"question":"def count_palindromic_substrings(s: str) -> int: Returns the number of palindromic substrings in the given string s. >>> count_palindromic_substrings(\\"abba\\") 6 >>> count_palindromic_substrings(\\"abc\\") 3 >>> count_palindromic_substrings(\\"aaa\\") 6","solution":"def count_palindromic_substrings(s): Returns the number of palindromic substrings in the given string s. n = len(s) ans = 0 dp = [[False] * n for _ in range(n)] for i in range(n): dp[i][i] = True ans += 1 for i in range(n-1): if s[i] == s[i+1]: dp[i][i+1] = True ans += 1 for length in range(3, n+1): for i in range(n-length+1): j = i + length - 1 if s[i] == s[j] and dp[i+1][j-1]: dp[i][j] = True ans += 1 return ans"},{"question":"def tallest_plant(n: int, m: int, growth_patterns: List[List[int]]) -> int: Determines the type of plant that will be the tallest on the last day (m-th day). Returns the 1-based index of the type with the maximum height on the m-th day. >>> tallest_plant(3, 4, [[10, 20, 30, 40], [5, 15, 25, 35], [8, 18, 28, 38]]) 1 >>> tallest_plant(2, 3, [[100, 200, 300], [100, 200, 400]]) 2","solution":"def tallest_plant(n, m, growth_patterns): Determines the type of plant that will be the tallest on the last day (m-th day). Returns the 1-based index of the type with the maximum height on the m-th day. tallest_index = 0 max_height = -1 for i in range(n): height_on_last_day = growth_patterns[i][m-1] if height_on_last_day > max_height: max_height = height_on_last_day tallest_index = i elif height_on_last_day == max_height: if i < tallest_index: tallest_index = i return tallest_index + 1"},{"question":"def max_full_weeks(D: int) -> int: Computes the maximum number of full weeks (each containing 7 days) that can be formed from the given number of days \`D\`. Parameters: D (int): The number of days. Returns: int: The maximum number of full weeks. Examples: >>> max_full_weeks(10) 1 >>> max_full_weeks(15) 2 >>> max_full_weeks(21) 3 >>> max_full_weeks(100) 14 >>> max_full_weeks(1) 0 >>> max_full_weeks(365) 52 >>> max_full_weeks(1000000000) 142857142 # Your implementation here","solution":"def max_full_weeks(D: int) -> int: Returns the maximum number of full weeks (each containing 7 days) that can be formed from the given number of days \`D\`. Parameters: D (int): The number of days. Returns: int: The maximum number of full weeks. return D // 7"},{"question":"def has_pair_with_sum(n: int, k: int, arr: List[int]) -> str: Determines if there exist two distinct indices i and j such that the sum of the elements at these indices equals target value k. Parameters: n (int): The number of elements in the list. k (int): The target sum. arr (list of int): The list of integers. Returns: str: \\"YES\\" if such a pair exists, \\"NO\\" otherwise. pass # Example test cases assert has_pair_with_sum(5, 9, [2, 7, 11, 15, 3]) == \\"YES\\" assert has_pair_with_sum(4, 8, [1, 2, 3, 4]) == \\"NO\\" assert has_pair_with_sum(3, 10, [1, 2, 3]) == \\"NO\\" assert has_pair_with_sum(4, 3, [1, 2, 4, 5]) == \\"YES\\" assert has_pair_with_sum(5, -1, [0, -1, -2, 2, 1]) == \\"YES\\" assert has_pair_with_sum(5, 1000000000, [500000000, 500000000, 0, -500000000, -500000000]) == \\"YES\\" assert has_pair_with_sum(6, 7, [1, 2, 3, 4, 5, 6]) == \\"YES\\"","solution":"def has_pair_with_sum(n, k, arr): Determines if there exist two distinct indices i and j such that the sum of the elements at these indices equals target value k. Parameters: n (int): The number of elements in the list. k (int): The target sum. arr (list of int): The list of integers. Returns: str: \\"YES\\" if such a pair exists, \\"NO\\" otherwise. seen = set() for num in arr: if (k - num) in seen: return \\"YES\\" seen.add(num) return \\"NO\\""},{"question":"def largest_subgrid_sum(grid: List[List[int]]) -> int: Find the largest sum of values of cells in any subgrid of the grid. >>> largest_subgrid_sum([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) 45 >>> largest_subgrid_sum([[1, 1], [1, 1]]) 4","solution":"def largest_subgrid_sum(grid): n = len(grid) m = len(grid[0]) # Create an auxiliary matrix to store the sum of the subgrids. aux = [[0]*m for _ in range(n)] # Fill the auxiliary matrix with cumulative sums. for i in range(n): for j in range(m): aux[i][j] = grid[i][j] if i > 0: aux[i][j] += aux[i-1][j] if j > 0: aux[i][j] += aux[i][j-1] if i > 0 and j > 0: aux[i][j] -= aux[i-1][j-1] max_sum = 0 # Iterate over all possible subgrids and calculate their sums using aux matrix. for i1 in range(n): for j1 in range(m): for i2 in range(i1, n): for j2 in range(j1, m): subgrid_sum = aux[i2][j2] if i1 > 0: subgrid_sum -= aux[i1-1][j2] if j1 > 0: subgrid_sum -= aux[i2][j1-1] if i1 > 0 and j1 > 0: subgrid_sum += aux[i1-1][j1-1] max_sum = max(max_sum, subgrid_sum) return max_sum # Function to process multiple test cases def process_test_cases(test_cases): results = [] for case in test_cases: grid = case[\\"grid\\"] results.append(largest_subgrid_sum(grid)) return results"},{"question":"def is_well_balanced(s: str) -> str: Determines if the string can be transformed into a well-balanced string. \`s\` is a string consisting of '(', ')', and '*' characters. Returns \\"YES\\" if the string can be transformed into a well-balanced string, otherwise \\"NO\\". # Unit Tests def test_example_1(): assert is_well_balanced(\\"(*)*\\") == \\"YES\\" def test_example_2(): assert is_well_balanced(\\"*))\\") == \\"NO\\" def test_example_3(): assert is_well_balanced(\\"((**))\\") == \\"YES\\" def test_all_stars(): assert is_well_balanced(\\"****\\") == \\"YES\\" def test_no_transformations_needed(): assert is_well_balanced(\\"(())\\") == \\"YES\\" def test_no_possible_way(): assert is_well_balanced(\\"()(\\") == \\"NO\\" def test_stars_between_parentheses(): assert is_well_balanced(\\"(*)(*)\\") == \\"YES\\" def test_stars_as_wildcards(): assert is_well_balanced(\\"(*))((***)\\") == \\"YES\\"","solution":"def is_well_balanced(s): Determines if the string can be transformed into a well-balanced string. \`s\` is a string consisting of '(', ')', and '*' characters. Returns \\"YES\\" if the string can be transformed into a well-balanced string, otherwise \\"NO\\". def can_be_well_balanced(s): low = high = 0 for char in s: if char == '(': low += 1 high += 1 elif char == ')': low -= 1 high -= 1 else: low -= 1 high += 1 if high < 0: return False low = max(low, 0) return low == 0 return \\"YES\\" if can_be_well_balanced(s) else \\"NO\\""},{"question":"from typing import List def check_palindrome_status(strings: List[str]) -> List[str]: Check if the strings are palindromes, not palindromes, or invalid based on the given rules. >>> check_palindrome_status([\\"madam\\", \\"hello\\", \\"racecar1\\"]) ['Yes', 'No', 'Invalid'] >>> check_palindrome_status([\\"racecar\\", \\"hello!\\", \\"a\\"]) ['Yes', 'Invalid', 'Yes'] Unit Test: from solution import check_palindrome_status def test_all_palindromes(): assert check_palindrome_status([\\"madam\\", \\"racecar\\", \\"level\\"]) == [\\"Yes\\", \\"Yes\\", \\"Yes\\"] def test_non_palindrome(): assert check_palindrome_status([\\"hello\\", \\"world\\"]) == [\\"No\\", \\"No\\"] def test_invalid_character_in_string(): assert check_palindrome_status([\\"racecar1\\", \\"hello!\\", \\"Invalid@\\"]) == [\\"Invalid\\", \\"Invalid\\", \\"Invalid\\"] def test_mixed_cases(): assert check_palindrome_status([\\"madam\\", \\"hello\\", \\"racecar1\\"]) == [\\"Yes\\", \\"No\\", \\"Invalid\\"] def test_empty_string(): assert check_palindrome_status([\\"\\"]) == [\\"Invalid\\"] def test_single_character(): assert check_palindrome_status([\\"a\\", \\"b\\", \\"c\\"]) == [\\"Yes\\", \\"Yes\\", \\"Yes\\"]","solution":"def check_palindrome_status(strings): results = [] for s in strings: if not s.isalpha() or not s.islower(): results.append(\\"Invalid\\") elif s == s[::-1]: results.append(\\"Yes\\") else: results.append(\\"No\\") return results"},{"question":"def process_packets(packet_ids): Given a list of packet IDs as they are received, return the order in which they should be processed, ensuring they are processed in ascending order starting from ID 1. Examples: >>> process_packets([4, 1, 3, 2]) [1, 2, 3, 4] >>> process_packets([3, 2, 1]) [1, 2, 3] >>> process_packets([1, 4, 2, 6, 3, 7, 5]) [1, 2, 3, 4, 5, 6, 7] >>> process_packets([10, 9, 8, 3, 2, 1]) [1, 2, 3, 8, 9, 10] >>> process_packets([1, 2, 3]) [1, 2, 3] >>> process_packets([5, 4, 3, 2, 1]) [1, 2, 3, 4, 5] >>> process_packets([100, 50, 25, 12, 6]) [6, 12, 25, 50, 100]","solution":"def process_packets(packet_ids): Given a list of packet IDs as they are received, return the order in which they should be processed, ensuring they are processed in ascending order starting from ID 1. return sorted(packet_ids)"},{"question":"def max_path_sum(grid: List[List[int]]) -> int: Returns the maximum sum possible for a path from the top-left to the bottom-right corner of a grid. Args: grid (List[List[int]]): A 2D list of non-negative integers representing the grid. Returns: int: The maximum sum possible for a path from the top-left to the bottom-right corner. Examples: >>> max_path_sum([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) 29 >>> max_path_sum([ ... [0, 0, 0, 0], ... [0, 1, 1, 1], ... [0, 1, 1, 1], ... [0, 1, 1, 1] ... ]) 5","solution":"def max_path_sum(grid): Returns the maximum sum possible for a path from the top-left to the bottom-right corner n = len(grid) m = len(grid[0]) # Initialize a DP table with the same dimensions as the grid dp = [[0 for _ in range(m)] for _ in range(n)] # Set the starting point dp[0][0] = grid[0][0] # Fill the first row for j in range(1, m): dp[0][j] = dp[0][j-1] + grid[0][j] # Fill the first column for i in range(1, n): dp[i][0] = dp[i-1][0] + grid[i][0] # Fill the rest of the DP table for i in range(1, n): for j in range(1, m): dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j] return dp[n-1][m-1]"},{"question":"def total_cookies(promotions): Calculates the total number of cookies a customer ends up with (including free cookies) for each promotion. Args: promotions (list of tuples): List of tuples where each tuple contains two integers X and Y. Returns: list: List of total cookies including free cookies for each promotion. pass def process_input(input_str): Processes the input string and returns a list of promotions. Args: input_str (str): Input string containing the number of promotions followed by pairs of X and Y. Returns: list: List of tuples where each tuple contains two integers X and Y. pass import pytest def test_total_cookies(): promotions = [(5, 2), (1, 1), (10, 5)] assert total_cookies(promotions) == [7, 2, 15] def test_total_cookies_single_promotion(): promotions = [(3, 3)] assert total_cookies(promotions) == [6] def test_total_cookies_no_free_cookies(): promotions = [(2, 0), (7, 0), (9, 0)] assert total_cookies(promotions) == [2, 7, 9] def test_process_input(): input_str = \\"3n5 2n1 1n10 5n\\" expected_promotions = [(5, 2), (1, 1), (10, 5)] assert process_input(input_str) == expected_promotions def test_process_input_single_promotion(): input_str = \\"1n3 3n\\" expected_promotions = [(3, 3)] assert process_input(input_str) == expected_promotions def test_process_input_edge_case(): input_str = \\"0n\\" expected_promotions = [] assert process_input(input_str) == expected_promotions","solution":"def total_cookies(promotions): Calculates the total number of cookies a customer ends up with (including free cookies) for each promotion. Args: promotions (list of tuples): List of tuples where each tuple contains two integers X and Y. Returns: list: List of total cookies including free cookies for each promotion. totals = [] for X, Y in promotions: totals.append(X + Y) return totals def process_input(input_str): Processes the input string and returns a list of promotions. Args: input_str (str): Input string containing the number of promotions followed by pairs of X and Y. Returns: list: List of tuples where each tuple contains two integers X and Y. lines = input_str.strip().split('n') T = int(lines[0]) promotions = [tuple(map(int, line.split())) for line in lines[1:T+1]] return promotions"},{"question":"def max_productivity(n: int, projects: List[Tuple[int, int, int]]) -> int: Given a number of possible project intervals and their corresponding productivity values, determine the maximum total productivity the company can achieve by choosing exactly two non-overlapping projects. Args: n: An integer representing the number of projects. projects: A list of tuples where each tuple contains three integers representing the start day, end day, and productivity value of the project respectively. Returns: An integer representing the maximum total productivity by choosing two disjoint projects, or -1 if it is impossible to choose such projects. >>> max_productivity(5, [(1, 3, 10), (2, 5, 20), (6, 7, 30), (8, 10, 40), (4, 9, 25)]) 70 >>> max_productivity(4, [(1, 2, 5), (2, 3, 15), (3, 4, 10), (5, 6, 20)]) 35","solution":"def max_productivity(n, projects): projects.sort(key=lambda x: x[1]) # Sort by end time max_prod = -1 max_end = [0] * n max_end[0] = projects[0][2] for i in range(1, n): max_end[i] = max(max_end[i-1], projects[i][2]) j = 0 for i in range(1, n): while j < i and projects[j][1] < projects[i][0]: j += 1 if j > 0: max_prod = max(max_prod, projects[i][2] + max_end[j-1]) return max_prod"},{"question":"def find_minimal_sum_rotation_point(n: int, a: List[int]) -> int: Given an array a of length n, find the integer x that minimizes the sum of absolute differences between elements of the array and x. >>> find_minimal_sum_rotation_point(5, [1, 2, 3, 4, 5]) 3 >>> find_minimal_sum_rotation_point(4, [1, 2, 3, 4]) 2 >>> find_minimal_sum_rotation_point(1, [100]) 100 >>> find_minimal_sum_rotation_point(3, [5, 5, 5]) 5 >>> find_minimal_sum_rotation_point(3, [-1, -2, -3]) -2 >>> find_minimal_sum_rotation_point(6, [-10, 12, 3, 7, -1, 4]) 3","solution":"def find_minimal_sum_rotation_point(n, a): Given an array a of length n, find the integer x that minimizes the sum of absolute differences between elements of the array and x. # Sort the array a.sort() # If n is odd, the median is the middle element. # If n is even, we need to choose the smaller of the two middle elements. if n % 2 == 1: return a[n // 2] else: return a[(n // 2) - 1]"},{"question":"import heapq from typing import List, Tuple def dijkstra(n: int, edges: List[Tuple[int, int, int]], start: int, end: int) -> int: Determines the minimum travel time from station start to station end using Dijkstra's algorithm. :param n: The number of stations. :param edges: A list of tuples (u, v, t) representing the tracks between stations u and v with time t. :param start: The starting station. :param end: The destination station. :return: The minimum travel time from start to end, or -1 if no path exists. graph = [[] for _ in range(n + 1)] for u, v, t in edges: graph[u].append((v, t)) graph[v].append((u, t)) min_heap = [(0, start)] # (cost, station) min_time = {i: float('inf') for i in range(1, n + 1)} min_time[start] = 0 while min_heap: current_time, u = heapq.heappop(min_heap) if u == end: return current_time if current_time > min_time[u]: continue for v, time in graph[u]: total_time = current_time + time if total_time < min_time[v]: min_time[v] = total_time heapq.heappush(min_heap, (total_time, v)) return -1 def find_minimum_travel_time(n: int, m: int, tracks: List[Tuple[int, int, int]], s: int, d: int) -> int: Find the minimum travel time required to travel from a specified starting station to a destination station. :param n: Number of stations :param m: Number of tracks :param tracks: List of tuples containing track information (u, v, t) :param s: Starting station :param d: Destination station :return: Minimum travel time or -1 if no path exists >>> find_minimum_travel_time(5, 7, [(1, 2, 4), (1, 3, 2), (2, 4, 7), (3, 4, 1), (3, 5, 3), (4, 5, 2), (2, 3, 5)], 1, 5) 5 >>> find_minimum_travel_time(3, 3, [(1, 2, 1), (2, 3, 1), (1, 3, 4)], 1, 3) 2 >>> find_minimum_travel_time(4, 2, [(1, 2, 1), (3, 4, 1)], 1, 4) -1 >>> find_minimum_travel_time(6, 9, [(1, 2, 2), (1, 3, 4), (1, 4, 1), (2, 3, 3), (2, 5, 2), (3, 6, 2), (4, 5, 4), (5, 6, 3)], 1, 6) 6 >>> find_minimum_travel_time(1, 0, [], 1, 1) 0 >>> find_minimum_travel_time(2, 1, [(1, 2, 2)], 2, 1) 2","solution":"import heapq def dijkstra(n, edges, start, end): Determines the minimum travel time from station start to station end using Dijkstra's algorithm. :param n: The number of stations. :param edges: A list of tuples (u, v, t) representing the tracks between stations u and v with time t. :param start: The starting station. :param end: The destination station. :return: The minimum travel time from start to end, or -1 if no path exists. graph = [[] for _ in range(n + 1)] for u, v, t in edges: graph[u].append((v, t)) graph[v].append((u, t)) min_heap = [(0, start)] # (cost, station) min_time = {i: float('inf') for i in range(1, n + 1)} min_time[start] = 0 while min_heap: current_time, u = heapq.heappop(min_heap) if u == end: return current_time if current_time > min_time[u]: continue for v, time in graph[u]: total_time = current_time + time if total_time < min_time[v]: min_time[v] = total_time heapq.heappush(min_heap, (total_time, v)) return -1 def find_minimum_travel_time(n, m, tracks, s, d): return dijkstra(n, tracks, s, d)"},{"question":"def can_deliver_all_flowers(m: int, i: int, t: int, delivery_positions: List[int]) -> str: This function checks if it is possible to deliver all flowers without spoilage. Parameters: - m: int: The length of the line - i: int: The maximum range of the cart - t: int: The number of delivery requests - delivery_positions: list of int: The delivery positions for each day Returns: - str: \\"YES\\" if all deliveries can be made without spoilage, \\"NO\\" otherwise Example: >>> can_deliver_all_flowers(10, 3, 3, [2, 5, 8]) \\"YES\\" >>> can_deliver_all_flowers(12, 2, 4, [1, 4, 7, 10]) \\"NO\\" pass # Test cases def test_can_deliver_all_flowers(): assert can_deliver_all_flowers(10, 3, 3, [2, 5, 8]) == \\"YES\\" assert can_deliver_all_flowers(12, 2, 4, [1, 4, 7, 10]) == \\"NO\\" assert can_deliver_all_flowers(10, 2, 1, [5]) == \\"YES\\" assert can_deliver_all_flowers(10, 1, 5, [1, 2, 3, 4, 5]) == \\"YES\\" assert can_deliver_all_flowers(20, 5, 4, [1, 6, 11, 16]) == \\"YES\\" assert can_deliver_all_flowers(20, 2, 3, [1, 4, 7]) == \\"NO\\"","solution":"def can_deliver_all_flowers(m, i, t, delivery_positions): This function checks if it is possible to deliver all flowers without spoilage. Parameters: - m: int: The length of the line - i: int: The maximum range of the cart - t: int: The number of delivery requests - delivery_positions: list of int: The delivery positions for each day Returns: - str: \\"YES\\" if all deliveries can be made without spoilage, \\"NO\\" otherwise for day in range(1, t): if abs(delivery_positions[day] - delivery_positions[day - 1]) > i: return \\"NO\\" return \\"YES\\" # Example usage # m = 10, i = 3, t = 3, [2, 5, 8] example_result = can_deliver_all_flowers(10, 3, 3, [2, 5, 8]) print(\\"Output for example 1:\\", example_result) # Output: YES # m = 12, i = 2, t = 4, [1, 4, 7, 10] example_result = can_deliver_all_flowers(12, 2, 4, [1, 4, 7, 10]) print(\\"Output for example 2:\\", example_result) # Output: NO"},{"question":"def min_deletions_to_palindrome(s: str) -> int: Determine the minimum number of deletions needed to make the string a palindrome. >>> min_deletions_to_palindrome(\\"abc\\") 2 >>> min_deletions_to_palindrome(\\"aab\\") 1 >>> min_deletions_to_palindrome(\\"racecar\\") 0 >>> min_deletions_to_palindrome(\\"leetcode\\") 5 pass if __name__ == \\"__main__\\": import doctest doctest.testmod() # Unit tests def test_example_1(): assert min_deletions_to_palindrome(\\"abc\\") == 2 def test_example_2(): assert min_deletions_to_palindrome(\\"aab\\") == 1 def test_example_3(): assert min_deletions_to_palindrome(\\"racecar\\") == 0 def test_example_4(): assert min_deletions_to_palindrome(\\"leetcode\\") == 5 def test_single_character_string(): assert min_deletions_to_palindrome(\\"a\\") == 0 def test_already_palindrome(): assert min_deletions_to_palindrome(\\"aba\\") == 0 def test_mixed_characters(): assert min_deletions_to_palindrome(\\"abca\\") == 1 def test_all_characters_same(): assert min_deletions_to_palindrome(\\"aaaa\\") == 0 def test_no_palindrome_possible(): assert min_deletions_to_palindrome(\\"abcdef\\") == 5","solution":"def min_deletions_to_palindrome(s): Determines the minimum number of deletions needed to make the string a palindrome. # Find the length of the longest palindromic subsequence n = len(s) dp = [[0] * n for _ in range(n)] for i in range(n): dp[i][i] = 1 for cl in range(2, n + 1): for i in range(n - cl + 1): j = i + cl - 1 if s[i] == s[j]: dp[i][j] = dp[i + 1][j - 1] + 2 else: dp[i][j] = max(dp[i][j - 1], dp[i + 1][j]) length_of_longest_palindromic_subsequence = dp[0][n - 1] return n - length_of_longest_palindromic_subsequence"},{"question":"def min_supply_lines(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Returns a list of minimum supply lines required for each test case. Parameters: t: int - Number of test cases test_cases: List of tuples. Each tuple contains: n: int - The number of skyscrapers heights: List of int - The heights of the skyscrapers Returns: List of int - Minimum number of supply lines for each test case. pass def parse_input(input_str: str) -> Tuple[int, List[Tuple[int, List[int]]]]: Parses the input string and returns the number of test cases and the test cases themselves. Parameters: input_str: str - Input string in the format specified in the task description Returns: Tuple containing: int - Number of test cases List of tuples - Each tuple contains: int - The number of skyscrapers List of int - The heights of the skyscrapers pass def format_output(results: List[int]) -> str: Formats the output results into a string separated by new lines. Parameters: results: List of int - The results to format Returns: str - The formatted string pass","solution":"def min_supply_lines(t, test_cases): Returns a list of minimum supply lines required for each test case. Parameters: t: int - Number of test cases test_cases: List of tuples. Each tuple contains: n: int - The number of skyscrapers heights: List of int - The heights of the skyscrapers Returns: List of int - Minimum number of supply lines for each test case. results = [] for case in test_cases: n, heights = case unique_heights = set(heights) results.append(len(unique_heights)) return results def parse_input(input_str): lines = input_str.strip().split('n') t = int(lines[0]) test_cases = [] index = 1 for _ in range(t): n = int(lines[index]) heights = list(map(int, lines[index + 1].split())) test_cases.append((n, heights)) index += 2 return t, test_cases def format_output(results): return 'n'.join(map(str, results))"},{"question":"from typing import List, Tuple from collections import defaultdict, deque def bfs_sum_at_distance_k(N: int, edges: List[Tuple[int, int]], queries: List[int]) -> List[int]: Given a binary tree with N nodes, where each node has a unique value in the range from 1 to N, and the tree is rooted at node 1, answer Q queries. Each query is represented by a single integer k. For each query, print the sum of values of all nodes that are k distance away from the root. >>> bfs_sum_at_distance_k(7, [(1, 2), (1, 3), (2, 4), (2, 5), (3, 6), (3, 7)], [1, 2, 3]) [5, 22, 0] >>> bfs_sum_at_distance_k(1, [], [0, 1, 2]) [1, 0, 0] >>> bfs_sum_at_distance_k(5, [(1, 2), (1, 3), (1, 4), (1, 5)], [1, 2]) [14, 0] >>> bfs_sum_at_distance_k(5, [(1, 2), (2, 3), (3, 4), (4, 5)], [1, 2, 3, 4]) [2, 3, 4, 5] >>> bfs_sum_at_distance_k(5, [(1, 2), (2, 3), (3, 4), (4, 5)], []) []","solution":"from collections import defaultdict, deque def bfs_sum_at_distance_k(N, edges, queries): # Build the tree using adjacency list tree = defaultdict(list) for u, v in edges: tree[u].append(v) tree[v].append(u) # Perform BFS to calculate the sum at each distance from root distance_sum = defaultdict(int) visited = set() queue = deque([(1, 0)]) # (node, current distance from root) visited.add(1) while queue: node, dist = queue.popleft() distance_sum[dist] += node for neighbor in tree[node]: if neighbor not in visited: visited.add(neighbor) queue.append((neighbor, dist + 1)) # Answer each query result = [] for k in queries: result.append(distance_sum.get(k, 0)) return result"},{"question":"def minZerobucks(S: int) -> int: Determine the minimum number of Zerobuck units required to represent S. >>> minZerobucks(3) 2 >>> minZerobucks(7) 3 >>> minZerobucks(10) 2","solution":"def minZerobucks(S): Returns the minimum number of Zerobuck units required to represent S. count = 0 # Go through each bit of the integer S while S > 0: # Increment count for each bit that is set (i.e., equals 1) count += S & 1 S >>= 1 # Right shift S by one bit return count"},{"question":"def can_segment_string(s: str, word_dict: List[str]) -> str: Determine if s can be segmented into a space-separated sequence of one or more dictionary words from dict. >>> can_segment_string(\\"leetcode\\", [\\"leet\\", \\"code\\"]) \\"YES\\" >>> can_segment_string(\\"applepenapple\\", [\\"apple\\", \\"pen\\"]) \\"YES\\" >>> can_segment_string(\\"catsandog\\", [\\"cats\\", \\"sand\\", \\"dog\\"]) \\"NO\\"","solution":"def can_segment_string(s, word_dict): word_set = set(word_dict) dp = [False] * (len(s) + 1) dp[0] = True for i in range(1, len(s) + 1): for j in range(i): if dp[j] and s[j:i] in word_set: dp[i] = True break return \\"YES\\" if dp[len(s)] else \\"NO\\""},{"question":"def longest_increasing_period(days: int, words: List[int]) -> int: Finds the length of the longest continuous period where the number of words learned either increased or stayed the same each day. >>> longest_increasing_period(7, [5, 6, 7, 7, 2, 8, 9]) == 4 >>> longest_increasing_period(5, [1, 2, 3, 4, 5]) == 5 >>> longest_increasing_period(5, [5, 4, 3, 2, 1]) == 1 >>> longest_increasing_period(4, [2, 2, 2, 2]) == 4 >>> longest_increasing_period(1, [10]) == 1 >>> longest_increasing_period(6, [1, 3, 5, 2, 2, 7]) == 3 >>> longest_increasing_period(0, []) == 0","solution":"def longest_increasing_period(days, words): Finds the length of the longest continuous period where the number of words learned either increased or stayed the same each day. if days == 0: return 0 longest_period = 1 current_period = 1 for i in range(1, days): if words[i] >= words[i - 1]: current_period += 1 if current_period > longest_period: longest_period = current_period else: current_period = 1 return longest_period"},{"question":"def max_number_in_pyramid(H: int, A: int) -> int: Calculate the maximum possible number that can be found at the top of the pyramid after adjustments. Args: H (int): The height of the pyramid. A (int): The topmost number of the pyramid. Returns: int: The maximum number that can be found at the top of the pyramid after adjustments. Examples: >>> max_number_in_pyramid(3, 2) 5 >>> max_number_in_pyramid(2, 7) 9 >>> max_number_in_pyramid(1, 1) 2 >>> max_number_in_pyramid(100, 1000) 1100 >>> max_number_in_pyramid(3, 100) 103 >>> max_number_in_pyramid(100, 1) 101 >>> max_number_in_pyramid(10, 10) 20","solution":"def max_number_in_pyramid(H, A): Returns the maximum number at the top of the pyramid after adjustments. return A + H"},{"question":"from typing import List def large_number_operations(A: str, B: str, queries: List[str]) -> List[str]: Perform operations on two large numbers A and B based on the provided queries. A: str : The first large number as a string B: str : The second large number as a string queries: List[str] : List of queries which are either \\"add\\", \\"multiply\\" or \\"compare\\" >>> large_number_operations(\\"123456789123456789\\", \\"987654321987654321\\", [\\"add\\"]) [\\"1111111111111111110\\"] >>> large_number_operations(\\"123456789123456789\\", \\"987654321987654321\\", [\\"multiply\\"]) [\\"121932631356500531347203169112635269\\"] >>> large_number_operations(\\"123456789123456790\\", \\"123456789123456789\\", [\\"compare\\"]) [\\"A\\"] >>> large_number_operations(\\"123456789123456789\\", \\"987654321987654321\\", [\\"compare\\"]) [\\"B\\"] >>> large_number_operations(\\"123456789123456789\\", \\"123456789123456789\\", [\\"compare\\"]) [\\"equal\\"] ...","solution":"def large_number_operations(A, B, queries): results = [] for query in queries: if query == \\"add\\": result = str(int(A) + int(B)) elif query == \\"multiply\\": result = str(int(A) * int(B)) elif query == \\"compare\\": if A > B: result = \\"A\\" elif A < B: result = \\"B\\" else: result = \\"equal\\" else: raise ValueError(f\\"Unknown query: {query}\\") results.append(result) return results"},{"question":"def check_possibility(arr: List[int]) -> bool: Determines if it is possible to make the array non-decreasing by modifying at most one element. :param arr: List[int] - input array of integers :return: bool - True if it's possible to make the array non-decreasing by modifying at most one element, False otherwise >>> check_possibility([4, 2, 3]) True >>> check_possibility([4, 2, 1]) False","solution":"def check_possibility(arr): Determines if it is possible to make the array non-decreasing by modifying at most one element. :param arr: List[int] - input array of integers :return: bool - True if it's possible to make the array non-decreasing by modifying at most one element, False otherwise count = 0 n = len(arr) for i in range(1, n): if arr[i] < arr[i - 1]: if count == 1: return False count += 1 if i - 2 < 0 or arr[i - 2] <= arr[i]: arr[i - 1] = arr[i] # modify arr[i - 1] else: arr[i] = arr[i - 1] # modify arr[i] return True"},{"question":"from typing import List, Tuple def findBuildOrder(n: int, dependencies: List[Tuple[int, int]]) -> List[int]: Determine a valid build order of the modules given the number of modules and dependencies. >>> findBuildOrder(5, [(3, 1), (3, 2), (4, 2), (5, 4)]) [1, 2, 3, 4, 5] >>> findBuildOrder(3, [(3, 1), (3, 2)]) [1, 2, 3] >>> findBuildOrder(3, []) [1, 2, 3] >>> findBuildOrder(4, [(2, 1), (3, 2), (4, 3)]) [1, 2, 3, 4] >>> findBuildOrder(4, [(2, 1), (2, 3), (4, 2)]) [1, 3, 2, 4]","solution":"from collections import deque, defaultdict def findBuildOrder(n, dependencies): # Create a graph in the form of an adjacency list graph = defaultdict(list) # Create a list to track the in-degree (number of dependencies) of each node in_degree = [0] * (n + 1) # Fill in the graph and in-degree list based on dependencies for a, b in dependencies: graph[b].append(a) in_degree[a] += 1 # Use a queue to perform topological sort queue = deque() # Initialize the queue with all nodes having in-degree of 0 for i in range(1, n + 1): if in_degree[i] == 0: queue.append(i) build_order = [] while queue: node = queue.popleft() build_order.append(node) # Reduce the in-degree of each neighbor by 1 for neighbor in graph[node]: in_degree[neighbor] -= 1 # If in-degree becomes 0, add it to the queue if in_degree[neighbor] == 0: queue.append(neighbor) return build_order"},{"question":"def largest_square_area(m: int, n: int, grid: List[List[str]]) -> int: Find the area of the largest square without any trees. >>> grid = [ ... ['.', '.', 'X', '.'], ... ['.', '.', '.', '.'], ... ['.', 'X', '.', 'X'] ... ] >>> largest_square_area(3, 4, grid) == 4 >>> grid = [ ... ['X', '.', '.'], ... ['.', '.', '.'], ... ['.', '.', 'X'] ... ] >>> largest_square_area(3, 3, grid) == 4 >>> grid = [ ... ['X', 'X', 'X', 'X'], ... ['X', 'X', 'X', 'X'], ... ['X', 'X', 'X', 'X'] ... ] >>> largest_square_area(3, 4, grid) == 0 >>> grid = [ ... ['.', '.', '.', '.'], ... ['.', '.', '.', '.'], ... ['.', '.', '.', '.'], ... ['.', '.', '.', '.'] ... ] >>> largest_square_area(4, 4, grid) == 16 >>> grid = [ ... ['.', '.', 'X', '.', '.'], ... ['.', 'X', 'X', '.', '.'], ... ['.', '.', 'X', '.', '.'], ... ['.', '.', '.', '.', '.'] ... ] >>> largest_square_area(4, 5, grid) == 4","solution":"def largest_square_area(m, n, grid): if m == 0 or n == 0: return 0 # Create DP table dp = [[0] * n for _ in range(m)] max_side = 0 for i in range(m): for j in range(n): if grid[i][j] == '.': if i == 0 or j == 0: dp[i][j] = 1 # Base case for first row or column else: dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1 # Update max_side max_side = max(max_side, dp[i][j]) # Area of the largest square return max_side * max_side"},{"question":"from typing import List def min_jumps(steps: List[int]) -> int: Determine the minimum number of jumps required to reach the end of the array. If it is not possible, return -1. Params: - steps (List[int]): A list of non-negative integers where each integer represents the maximum number of steps that can be taken forward from that position. Returns: - int: Minimum number of jumps to reach the end, or -1 if not possible. >>> min_jumps([2, 3, 1, 1, 4]) 2 >>> min_jumps([1, 1, 1, 1, 0]) 4 >>> min_jumps([0, 2, 3, 1, 1]) -1 >>> min_jumps([0]) 0","solution":"def min_jumps(steps): Returns the minimum number of jumps to reach the end of the array. If it is not possible, returns -1. n = len(steps) if n == 1: return 0 # Initialize variables jumps = 0 current_end = 0 farthest = 0 for i in range(n - 1): # Update the farthest we can reach farthest = max(farthest, i + steps[i]) # If we have reached the end of the current jump if i == current_end: jumps += 1 current_end = farthest # If the current end is beyond or at the last element, break if current_end >= n - 1: break # If you can't advance from the current position if current_end == i and steps[i] == 0: return -1 return jumps if current_end >= n - 1 else -1"},{"question":"def can_turn_off_all_lights(n: int, lights: str) -> str: Determine if it's possible to turn off all the lights with exactly one operation. >>> can_turn_off_all_lights(5, \\"10101\\") \\"NO\\" >>> can_turn_off_all_lights(3, \\"111\\") \\"YES\\" >>> can_turn_off_all_lights(4, \\"0101\\") \\"NO\\"","solution":"def can_turn_off_all_lights(n, lights): # Check if there is any segment of three consecutive '1's for i in range(n - 2): if lights[i] == '1' and lights[i + 1] == '1' and lights[i + 2] == '1': return \\"YES\\" return \\"NO\\""},{"question":"def max_apples(grid: List[List[int]]) -> int: Calculate the maximum number of apples that can be collected from the top-left to the bottom-right corner of the grid moving only right or down. >>> max_apples([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) 29 >>> max_apples([[5, 4, 7, 8]]) 24 >>> max_apples([[2], [3], [1], [9]]) 15 >>> max_apples([[7]]) 7 >>> max_apples([[1, 3, 1], [1, 5, 1], [4, 2, 1]]) 12","solution":"def max_apples(grid): n = len(grid) m = len(grid[0]) # Initialize a dp table with the same dimensions as grid dp = [[0]*m for _ in range(n)] dp[0][0] = grid[0][0] # Fill the first row for j in range(1, m): dp[0][j] = dp[0][j-1] + grid[0][j] # Fill the first column for i in range(1, n): dp[i][0] = dp[i-1][0] + grid[i][0] # Fill the rest of the dp table for i in range(1, n): for j in range(1, m): dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j] # The bottom-right corner will have the result return dp[-1][-1]"},{"question":"def rearrange_array(arr): Rearranges the array such that all even integers are moved to the front and all odd integers are moved to the back while preserving their relative order. Args: arr (list): List of integers. Returns: list: Rearranged list with evens at the front and odds at the back. >>> rearrange_array([3, 1, 2, 4]) [2, 4, 3, 1] >>> rearrange_array([0, -2, 5, -3]) [0, -2, 5, -3] >>> rearrange_array([1, 3, 5, 7]) [1, 3, 5, 7] >>> rearrange_array([2, 4, 6, 8]) [2, 4, 6, 8] >>> rearrange_array([4, 1, 3, 2]) [4, 2, 1, 3] >>> large_input = list(range(1, 100001)) >>> rearrange_array(large_input) == list(range(2, 100001, 2)) + list(range(1, 100000, 2)) True >>> rearrange_array([-1, -2, -3, -4]) [-2, -4, -1, -3]","solution":"def rearrange_array(arr): Rearranges the array such that all even integers are moved to the front and all odd integers are moved to the back while preserving their relative order. Args: arr (list): List of integers. Returns: list: Rearranged list with evens at the front and odds at the back. even = [x for x in arr if x % 2 == 0] odd = [x for x in arr if x % 2 != 0] return even + odd"},{"question":"def can_make_anagrams(n: int, s: str, t: str) -> str: Determine if it is possible to make the two strings anagrams of each other using the allowed operations: 1. You can swap any two characters in string s. 2. You can swap any two characters in string t. 3. You can replace any character in string s with any other character that is present in string t. >>> can_make_anagrams(5, \\"abcde\\", \\"edcba\\") == \\"YES\\" >>> can_make_anagrams(4, \\"abcd\\", \\"efgh\\") == \\"NO\\" Args: n (int): the length of the strings s (str): the first string t (str): the second string Returns: str: \\"YES\\" if it is possible to make the two strings anagrams, otherwise \\"NO\\"","solution":"def can_make_anagrams(n, s, t): from collections import Counter counter_s = Counter(s) counter_t = Counter(t) # Compare the frequency counts of characters in both strings if counter_s == counter_t: return \\"YES\\" else: return \\"NO\\""},{"question":"def find_genres(G: int, Q: int, Low: List[int], High: List[int], book_ids: List[int]) -> List[int]: Finds the genre index for each book id in book_ids. Parameters: G (int): Number of genres Q (int): Number of book identifiers Low (list): List of lower bounds for genres High (list): List of upper bounds for genres book_ids (list): List of book identifiers to be queried Returns: list: List where each element is the genre index for corresponding book identifier in book_ids pass # Example Tests def test_find_genres_sample_input(): G = 3 Q = 5 Low = [1, 100, 200] High = [50, 150, 250] book_ids = [10, 101, 199, 201, 300] expected_output = [0, 1, -1, 2, -1] assert find_genres(G, Q, Low, High, book_ids) == expected_output def test_find_genres_all_in_first_genre(): G = 2 Q = 3 Low = [1, 200] High = [150, 300] book_ids = [50, 149, 1] expected_output = [0, 0, 0] assert find_genres(G, Q, Low, High, book_ids) == expected_output def test_find_genres_all_in_last_genre(): G = 3 Q = 4 Low = [10, 20, 30] High = [19, 29, 39] book_ids = [30, 35, 32, 39] expected_output = [2, 2, 2, 2] assert find_genres(G, Q, Low, High, book_ids) == expected_output def test_find_genres_no_matching_genre(): G = 2 Q = 2 Low = [10, 200] High = [30, 300] book_ids = [5, 400] expected_output = [-1, -1] assert find_genres(G, Q, Low, High, book_ids) == expected_output def test_find_genres_single_genre(): G = 1 Q = 3 Low = [1] High = [1] book_ids = [0, 1, 2] expected_output = [-1, 0, -1] assert find_genres(G, Q, Low, High, book_ids) == expected_output","solution":"def find_genres(G, Q, Low, High, book_ids): Finds the genre index for each book id in book_ids. Parameters: G (int): Number of genres Q (int): Number of book identifiers Low (list): List of lower bounds for genres High (list): List of upper bounds for genres book_ids (list): List of book identifiers to be queried Returns: list: List where each element is the genre index for corresponding book identifier in book_ids result = [] for book_id in book_ids: genre_found = -1 for i in range(G): if Low[i] <= book_id <= High[i]: genre_found = i break result.append(genre_found) return result"},{"question":"def find_substring(s: str, words: List[str]) -> List[int]: Find all starting indices of substring(s) in 's' that are concatenations of each word in 'words' exactly once and without any intervening characters. Args: s (str): A string of length n consisting of lower case English letters. words (List[str]): A list of words, each of length m. All words are non-zero length and consist of lower case English letters. Returns: List[int]: A list of all starting indices of concatenation substrings in 's'. The indices are returned in ascending order. Examples: >>> find_substring(\\"barfoothefoobarman\\", [\\"foo\\", \\"bar\\"]) [0, 9] >>> find_substring(\\"wordgoodgoodgoodbestword\\", [\\"word\\",\\"good\\",\\"best\\",\\"word\\"]) [] >>> find_substring(\\"barfoofoobarthefoobarman\\", [\\"bar\\",\\"foo\\",\\"the\\"]) [6, 9, 12] >>> find_substring(\\"abcdefg\\", [\\"hij\\"]) [] >>> find_substring(\\"\\", [\\"foo\\", \\"bar\\"]) [] >>> find_substring(\\"barfoothefoobarman\\", []) [] >>> find_substring(\\"foobarfoobar\\", [\\"foo\\",\\"bar\\"]) [0, 3, 6]","solution":"def find_substring(s, words): if not s or not words: return [] word_length = len(words[0]) word_count = len(words) total_length = word_length * word_count # Creating a frequency map of the words word_map = {} for word in words: if word in word_map: word_map[word] += 1 else: word_map[word] = 1 def is_valid(start): seen = {} words_used = 0 for i in range(start, start + total_length, word_length): part = s[i:i+word_length] if part in word_map: if part in seen: seen[part] += 1 else: seen[part] = 1 if seen[part] > word_map[part]: return False words_used += 1 else: return False return words_used == word_count result = [] for i in range(len(s) - total_length + 1): if is_valid(i): result.append(i) return result"},{"question":"from typing import List, Union def magical_sequence(n: int, m: int) -> Union[List[int], int]: Generate a sequence of \`n\` positive integers each not exceeding \`m\` that are pairwise coprime. If no such sequence exists, return -1. pass # Unit tests def test_case_1(): assert magical_sequence(3, 6) == [1, 2, 3] or magical_sequence(3, 6) == [2, 3, 5] def test_case_2(): assert magical_sequence(4, 10) == [1, 2, 3, 4] def test_case_3(): assert magical_sequence(2, 1) == -1 def test_case_4(): # Even with large \`m\`, a valid sequence is the first \`n\` positive integers assert magical_sequence(5, 100) == [1, 2, 3, 4, 5] def test_case_5(): # If n==1, the sequence can be [1] assert magical_sequence(1, 3) == [1] def test_case_6(): # If \`n\` > \`m\`, should return -1 assert magical_sequence(5, 4) == -1 def test_case_7(): assert magical_sequence(1000, 100000) == list(range(1, 1001))","solution":"def magical_sequence(n, m): Generate a sequence of \`n\` positive integers each not exceeding \`m\` that are pairwise coprime. If no such sequence exists, return -1. # If m < n, it's impossible to have n pairwise coprime numbers all <= m if m < n: return -1 result = [] for i in range(1, n + 1): result.append(i) return result"},{"question":"def subset_sum_zero(arr): Determine if there exists a subset of the given list of integers that sums to zero. The empty subset is not considered valid. >>> subset_sum_zero([3, 1, -4, 2, 6]) == 'Yes' >>> subset_sum_zero([-4, -2, 2, 4]) == 'Yes' >>> subset_sum_zero([1, 1, -2, 5, 7]) == 'Yes' >>> subset_sum_zero([1, 2, 3, 10]) == 'No' >>> subset_sum_zero([1, 2, 4, 5]) == 'No' >>> subset_sum_zero([10, -3, 1]) == 'No' >>> subset_sum_zero([0]) == 'Yes' >>> subset_sum_zero([1]) == 'No' >>> subset_sum_zero([1, 2, 3, 4, 5]) == 'No' >>> subset_sum_zero([-1, -2, -3, -4, -5]) == 'No'","solution":"def subset_sum_zero(arr): Determine if there exists a subset of the given list of integers that sums to zero. The empty subset is not considered valid. n = len(arr) # Create a set to store already seen sums seen_sums = set() # Initialize sum_so_far to 0 sum_so_far = 0 # Traverse each element in the array for num in arr: sum_so_far += num # If sum_so_far is in seen_sums or sum_so_far is 0, we found a valid subset if sum_so_far == 0 or sum_so_far in seen_sums: return 'Yes' seen_sums.add(sum_so_far) return 'No'"},{"question":"def most_frequent_integer(n: int, nums: List[int]) -> int: Returns the most frequent integer in the list. If there is a tie, returns the smallest integer among the most frequent ones. >>> most_frequent_integer(6, [1, 3, 2, 2, 1, 3]) == 1 >>> most_frequent_integer(5, [3, 3, 3, 3, 3]) == 3 >>> most_frequent_integer(6, [1, 2, 2, 1, 3, 3]) == 1 >>> most_frequent_integer(4, [1000000000, 1000000000, -1000000000, -1000000000]) == -1000000000 >>> most_frequent_integer(7, [4, 4, 6, 6, 6, 4, 5]) == 4 >>> most_frequent_integer(9, [5, 5, 5, 2, 2, 2, 3, 3, 3]) == 2 from typing import List from collections import Counter","solution":"def most_frequent_integer(n, nums): Returns the most frequent integer in the list. If there is a tie, returns the smallest integer among the most frequent ones. from collections import Counter # Count the frequency of each integer freq_counter = Counter(nums) # Find the highest frequency max_freq = max(freq_counter.values()) # Find the smallest number with the highest frequency most_frequent = min(num for num in freq_counter if freq_counter[num] == max_freq) return most_frequent"},{"question":"def min_repaints(t: int, test_cases: List[Tuple[int, List[str]]]) -> List[int]: Determine the minimum number of repaints required so that every row and column contains at least one 'B'. Args: t (int): The number of test cases. test_cases (List[Tuple[int, List[str]]]): A list of test cases, where each test case is a tuple containing: - an integer n: the side length of the square grid. - a list of n strings: representing the grid. Returns: List[int]: List of integers representing the minimum number of repaints needed for each test case. Example: >>> min_repaints(2, [(3, ['BWW', 'WBW', 'WWW']), (4, ['BBBB', 'WWWW', 'WWWW', 'WWWW'])]) [1, 3]","solution":"def min_repaints(t, test_cases): results = [] for i in range(t): n = test_cases[i][0] grid = test_cases[i][1] rows_to_repaint = sum(1 for r in grid if 'B' not in r) cols_to_repaint = sum(1 for c in zip(*grid) if 'B' not in c) results.append(max(rows_to_repaint, cols_to_repaint)) return results"},{"question":"def balance_string(s: str) -> str: Returns the minimum deletions required to balance the given string. Params: s (str): Input string consisting of lowercase alphabets and brackets. Returns: str: Balanced string with minimal deletions. >>> balance_string(\\"a)b(c)d\\") \\"ab(c)d\\" >>> balance_string(\\"))a((bcd)\\") \\"a(bcd)\\" >>> balance_string(\\")(\\") \\"\\"","solution":"def balance_string(s): Returns the minimum deletions required to balance the given string. n = len(s) open_stack = [] to_delete = set() # First pass to find unbalanced closing brackets for i, char in enumerate(s): if char == '(': open_stack.append(i) elif char == ')': if open_stack: open_stack.pop() else: to_delete.add(i) # Remaining indices in open_stack are unbalanced opening brackets to_delete = to_delete.union(set(open_stack)) balanced_string = ''.join([s[i] for i in range(n) if i not in to_delete]) return balanced_string"},{"question":"def transform_string(s: str) -> str: Transform the string according to the specified rules where each character in the string is mapped to its position in the alphabet and consecutive characters are compared for their differences. Args: s (str): The input string consisting of lowercase English letters. Returns: str: The resulting sequence of differences as space-separated integers. Examples: >>> transform_string(\\"abcd\\") \\"1 1 1\\" >>> transform_string(\\"zabc\\") \\"-25 1 1\\" pass def test_example_1(): result = transform_string(\\"abcd\\") expected = \\"1 1 1\\" assert result == expected def test_example_2(): result = transform_string(\\"zabc\\") expected = \\"-25 1 1\\" assert result == expected def test_single_character(): result = transform_string(\\"a\\") expected = \\"\\" assert result == expected def test_repeated_characters(): result = transform_string(\\"aaa\\") expected = \\"0 0\\" assert result == expected def test_random_string_1(): result = transform_string(\\"acdf\\") expected = \\"2 1 2\\" assert result == expected def test_random_string_2(): result = transform_string(\\"zyxw\\") expected = \\"-1 -1 -1\\" assert result == expected","solution":"def transform_string(s): Transform the string according to the specified rules. differences = [] for i in range(1, len(s)): current_value = ord(s[i]) - ord('a') + 1 previous_value = ord(s[i-1]) - ord('a') + 1 differences.append(current_value - previous_value) return ' '.join(map(str, differences))"},{"question":"def is_round_array(n, array): Determines if the array is round. Parameters: n (int): The number of elements in the array. array (list of int): The elements of the array. Returns: str: \\"YES\\" if the array is round, \\"NO\\" otherwise. from solution import is_round_array def test_example_1(): assert is_round_array(4, [3, 4, 1, 2]) == \\"YES\\" def test_example_2(): assert is_round_array(4, [2, 1, 3, 4]) == \\"NO\\" def test_example_3(): assert is_round_array(5, [2, 3, 4, 5, 1]) == \\"YES\\" def test_single_element(): assert is_round_array(1, [1]) == \\"YES\\" def test_already_sorted(): assert is_round_array(3, [1, 2, 3]) == \\"YES\\" def test_reverse_sorted(): assert is_round_array(3, [3, 2, 1]) == \\"NO\\" def test_all_same_elements(): assert is_round_array(5, [5, 5, 5, 5, 5]) == \\"YES\\" def test_long_round_array(): assert is_round_array(6, [4, 5, 6, 1, 2, 3]) == \\"YES\\" def test_long_non_round_array(): assert is_round_array(6, [4, 5, 1, 2, 6, 3]) == \\"NO\\"","solution":"def is_round_array(n, array): Determines if the array is round. Parameters: n (int): The number of elements in the array. array (list of int): The elements of the array. Returns: str: \\"YES\\" if the array is round, \\"NO\\" otherwise. # Double the array to handle circular movements doubled_array = array + array # Generate all possible subarrays of length n for i in range(n): subarray = doubled_array[i:i + n] if subarray == sorted(array): return \\"YES\\" return \\"NO\\""},{"question":"def rotate_matrix_90_clockwise(matrix: List[List[int]]) -> List[List[int]]: Rotates a given NxN matrix by 90 degrees clockwise. Args: - matrix (List[List[int]]): An NxN matrix. Returns: - List[List[int]]: The rotated NxN matrix. Example: >>> rotate_matrix_90_clockwise([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) [[7, 4, 1], [8, 5, 2], [9, 6, 3]] def process_input(matrix_strings: List[str]) -> List[List[int]]: Processes the input to convert it into a matrix and then calls rotate_matrix_90_clockwise to get the rotated matrix. Args: - matrix_strings (List[str]): A list of strings, each representing a row of an NxN matrix. Returns: - List[List[int]]: The rotated NxN matrix. Example: >>> process_input([\\"1 2 3\\", \\"4 5 6\\", \\"7 8 9\\"]) [[7, 4, 1], [8, 5, 2], [9, 6, 3]]","solution":"def rotate_matrix_90_clockwise(matrix): Rotates a given NxN matrix by 90 degrees clockwise. n = len(matrix) rotated_matrix = [[0] * n for _ in range(n)] for i in range(n): for j in range(n): rotated_matrix[j][n-1-i] = matrix[i][j] return rotated_matrix def process_input(matrix_strings): Processes the input to convert it into a matrix and then calls rotate_matrix_90_clockwise to get the rotated matrix. matrix = [] for row in matrix_strings: matrix.append(list(map(int, row.split()))) return rotate_matrix_90_clockwise(matrix)"},{"question":"def length_of_longest_substring_two_distinct(s: str) -> int: Returns the length of the longest substring that contains at most two distinct characters. >>> length_of_longest_substring_two_distinct(\\"eceba\\") == 3 >>> length_of_longest_substring_two_distinct(\\"ccaabbb\\") == 5 >>> length_of_longest_substring_two_distinct(\\"a\\") == 1 >>> length_of_longest_substring_two_distinct(\\"ab\\") == 2 >>> length_of_longest_substring_two_distinct(\\"aaaa\\") == 4 >>> length_of_longest_substring_two_distinct(\\"\\") == 0 >>> length_of_longest_substring_two_distinct(\\"abcdefgh\\") == 2 >>> length_of_longest_substring_two_distinct(\\"a\\" * 50000 + \\"b\\" * 50000) == 100000","solution":"def length_of_longest_substring_two_distinct(s): Returns the length of the longest substring that contains at most two distinct characters. if len(s) == 0: return 0 left = 0 char_map = {} max_length = 0 for right in range(len(s)): char_map[s[right]] = char_map.get(s[right], 0) + 1 while len(char_map) > 2: char_map[s[left]] -= 1 if char_map[s[left]] == 0: del char_map[s[left]] left += 1 max_length = max(max_length, right - left + 1) return max_length"},{"question":"def make_beautiful(s: str) -> int: Returns the minimum number of changes required to make the binary string beautiful. >>> make_beautiful(\\"0000\\") == 1 >>> make_beautiful(\\"111011\\") == 1 >>> make_beautiful(\\"010101\\") == 0 >>> make_beautiful(\\"111\\") == 1 >>> make_beautiful(\\"000\\") == 1 >>> make_beautiful(\\"0101010101\\") == 0 >>> make_beautiful(\\"1010101010\\") == 0 >>> make_beautiful(\\"110111\\") == 1 pass def process_test_cases(t: int, test_cases: List[str]) -> List[int]: Process multiple test cases to determine the number of changes required for each. >>> process_test_cases(3, [\\"0000\\", \\"111011\\", \\"010101\\"]) == [1, 1, 0] >>> process_test_cases(2, [\\"000\\", \\"111\\"]) == [1, 1] >>> process_test_cases(1, [\\"1010101010\\"]) == [0] pass","solution":"def make_beautiful(s): Returns the minimum number of changes required to make the binary string beautiful. changes = 0 n = len(s) for i in range(n - 2): if s[i] == s[i + 1] == s[i + 2]: changes += 1 # Change the next character to avoid more than two consecutive same characters. # Note: It's sufficient to change the third one in the sequence. if s[i + 2] == '0': s = s[:i + 2] + '1' + s[i + 3:] else: s = s[:i + 2] + '0' + s[i + 3:] return changes def process_test_cases(t, test_cases): results = [] for case in test_cases: result = make_beautiful(case) results.append(result) return results"},{"question":"from typing import List def min_insertions_to_balance(t: int, test_cases: List[str]) -> List[int]: Emma has a string s consisting of lowercase English letters. She wants to make this string as balanced as possible. A string is considered balanced if the absolute difference in the number of occurrences of any two characters in the string is at most 1. Emma can insert any character in the string at any position she chooses. Help Emma determine the minimum number of insertions required to make the string balanced. Args: t (int): The number of test cases. test_cases (List[str]): List of strings for which Emma wants to determine the minimum number of insertions. Returns: List[int]: The minimum number of insertions required for each test case. Examples: >>> min_insertions_to_balance(2, [\\"abcbc\\", \\"aabbccc\\"]) [1, 2] >>> min_insertions_to_balance(1, [\\"aaaa\\"]) [0] >>> min_insertions_to_balance(1, [\\"aabbcc\\"]) [0] >>> min_insertions_to_balance(1, [\\"abc\\"]) [0] >>> min_insertions_to_balance(2, [\\"aabb\\", \\"aabbcccddd\\"]) [0, 2]","solution":"def min_insertions_to_balance(t, test_cases): results = [] for s in test_cases: from collections import Counter count = Counter(s) max_count = max(count.values()) total_chars = len(count) min_insertions = max_count * total_chars - sum(count.values()) results.append(min_insertions) return results # Sample usage: # t = 2 # test_cases = [\\"abcbc\\", \\"aabbccc\\"] # print(min_insertions_to_balance(t, test_cases)) # Output: [1, 2]"},{"question":"def max_profit(prices: List[int]) -> int: Calculate the maximum possible profit from buying and selling a single stock given its prices over a number of days. :param prices: List of integers representing the stock prices on consecutive days. :return: Maximum profit achievable. If no profit is possible, return 0. >>> max_profit([7, 1, 5, 3, 6, 4]) 5 >>> max_profit([7, 6, 4, 3, 1]) 0 from solution import max_profit def test_max_profit_example(): assert max_profit([7, 1, 5, 3, 6, 4]) == 5 def test_max_profit_no_profit(): assert max_profit([7, 6, 4, 3, 1]) == 0 def test_max_profit_single_price(): assert max_profit([10]) == 0 def test_max_profit_constant_price(): assert max_profit([2, 2, 2, 2, 2]) == 0 def test_max_profit_increasing_prices(): assert max_profit([1, 2, 3, 4, 5]) == 4 def test_max_profit_decreasing_then_increasing(): assert max_profit([5, 3, 1, 2, 4, 6]) == 5 def test_max_profit_empty_prices(): assert max_profit([]) == 0","solution":"def max_profit(prices): Returns the maximum profit achievable from buying and selling a single stock given its prices over a number of days. If no profit is possible, returns 0. if not prices: return 0 min_price = float('inf') max_profit = 0 for price in prices: if price < min_price: min_price = price elif price - min_price > max_profit: max_profit = price - min_price return max_profit"},{"question":"def max_activities(N, activities): Returns the maximum number of non-overlapping activities that can be attended. Args: N : int : Number of activities. activities : list of tuples : Each tuple contains the start and end times of an activity. Returns: int : Maximum number of non-overlapping activities. # Implementation goes here # Unit tests def test_example_1(): activities = [(1, 4), (2, 3), (3, 5)] assert max_activities(3, activities) == 2 def test_example_2(): activities = [(5, 9), (1, 2), (3, 4), (0, 6)] assert max_activities(4, activities) == 3 def test_no_activities(): activities = [] assert max_activities(0, activities) == 0 def test_all_overlapping_activities(): activities = [(1, 10), (2, 9), (3, 8), (4, 7)] assert max_activities(4, activities) == 1 def test_all_non_overlapping_activities(): activities = [(1, 2), (3, 4), (5, 6), (7, 8)] assert max_activities(4, activities) == 4 def test_mixed_activities(): activities = [(2, 3), (1, 3), (3, 4), (1, 2)] assert max_activities(4, activities) == 3","solution":"def max_activities(N, activities): Returns the maximum number of non-overlapping activities that can be attended. Args: N : int : Number of activities. activities : list of tuples : Each tuple contains the start and end times of an activity. Returns: int : Maximum number of non-overlapping activities. # Sort activities based on their end times activities.sort(key=lambda x: x[1]) count = 0 last_end_time = 0 for start, end in activities: if start >= last_end_time: count += 1 last_end_time = end return count"},{"question":"def longest_bitonic_subsequence(arr): Returns the length of the longest subsequence which is first increasing and then decreasing in nature. pass # Unit Tests def test_example_case(): assert longest_bitonic_subsequence([1, 2, 3, 4, 5, 3, 2]) == 7 def test_all_increasing(): assert longest_bitonic_subsequence([1, 2, 3, 4, 5]) == 5 def test_all_decreasing(): assert longest_bitonic_subsequence([5, 4, 3, 2, 1]) == 5 def test_single_peak(): assert longest_bitonic_subsequence([1, 3, 5, 7, 6, 4, 2]) == 7 def test_no_bitonic_subsequence(): assert longest_bitonic_subsequence([1, 1, 1, 1]) == 1 def test_small_cases(): assert longest_bitonic_subsequence([1, 2]) == 2 assert longest_bitonic_subsequence([2, 1]) == 2 def test_large_random_case(): assert longest_bitonic_subsequence([5, 10, 20, 25, 20, 15, 10, 5, 1]) == 9","solution":"def longest_bitonic_subsequence(arr): Returns the length of the longest subsequence which is first increasing and then decreasing in nature. n = len(arr) # Initialize the increasing subsequence lengths inc = [1] * n # Initialize the decreasing subsequence lengths dec = [1] * n # Fill the inc[] array (length of increasing subsequence ending at each index) for i in range(1, n): for j in range(0, i): if arr[i] > arr[j] and inc[i] < inc[j] + 1: inc[i] = inc[j] + 1 # Fill the dec[] array (length of decreasing subsequence starting at each index) for i in range(n-2, -1, -1): for j in range(n-1, i, -1): if arr[i] > arr[j] and dec[i] < dec[j] + 1: dec[i] = dec[j] + 1 # Find the length of the maximum length bitonic subsequence max_len = 0 for i in range(n): max_len = max(max_len, inc[i] + dec[i] - 1) return max_len"},{"question":"def max_weight_without_exceeding(n: int, w: int, weights: List[int]) -> int: Determines the maximum total weight of a subset of the provided weights that does not exceed the target weight. >>> max_weight_without_exceeding(5, 10, [3, 1, 4, 2, 8]) 10 >>> max_weight_without_exceeding(4, 7, [5, 4, 3, 2]) 7","solution":"def max_weight_without_exceeding(n, w, weights): Determines the maximum total weight of a subset of the provided weights that does not exceed the target weight. Parameters: n (int): the number of ingredients w (int): the target weight weights (list): list of weights of the ingredients Returns: int: the maximum total weight that does not exceed the target weight # dp will store the maximum weight that can be achieved for each weight limit up to w dp = [0] * (w + 1) for weight in weights: # Traverse backwards to prevent using the same item more than once for i in range(w, weight - 1, -1): dp[i] = max(dp[i], dp[i - weight] + weight) return dp[w]"},{"question":"def contains_duplicates(n: int, numbers: List[int]) -> str: Checks if the list contains any duplicates. :param n: Integer, number of elements in the list :param numbers: List of integers :return: \\"YES\\" if there are duplicates, otherwise \\"NO\\" >>> contains_duplicates(5, [1, 2, 3, 4, 5]) 'NO' >>> contains_duplicates(6, [1, 2, 3, 4, 5, 1]) 'YES' pass","solution":"def contains_duplicates(n, numbers): Checks if the list contains any duplicates. :param n: Integer, number of elements in the list :param numbers: List of integers :return: \\"YES\\" if there are duplicates, otherwise \\"NO\\" if len(numbers) != n: raise ValueError(\\"The length of numbers must be equal to n.\\") number_set = set() for num in numbers: if num in number_set: return \\"YES\\" number_set.add(num) return \\"NO\\""},{"question":"from typing import List, Tuple def preprocess_matrix(matrix: List[List[int]]) -> List[List[int]]: Preprocess the matrix to create a prefix sum matrix. pass def query_sum(prefix_sum: List[List[int]], r1: int, c1: int, r2: int, c2: int) -> int: Calculate the sum of the submatrix from (r1, c1) to (r2, c2) using the prefix sum matrix. pass def matrix_sum_queries(matrix: List[List[int]], queries: List[Tuple[int, int, int, int]]) -> List[int]: Given a matrix and a list of queries, return a list of sums of elements within each specified submatrix. pass if __name__ == \\"__main__\\": matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] queries = [ (1, 1, 2, 2), (2, 2, 3, 3) ] # Expected output: [12, 28] print(matrix_sum_queries(matrix, queries))","solution":"def preprocess_matrix(matrix): Preprocess the matrix to create a prefix sum matrix. n = len(matrix) m = len(matrix[0]) # Create a prefix sum matrix initialized with zeros prefix_sum = [[0] * (m + 1) for _ in range(n + 1)] # Fill the prefix sum matrix for i in range(1, n + 1): for j in range(1, m + 1): prefix_sum[i][j] = ( matrix[i-1][j-1] + prefix_sum[i-1][j] + prefix_sum[i][j-1] - prefix_sum[i-1][j-1] ) return prefix_sum def query_sum(prefix_sum, r1, c1, r2, c2): Calculate the sum of the submatrix from (r1, c1) to (r2, c2) using the prefix sum matrix. return ( prefix_sum[r2][c2] - prefix_sum[r1-1][c2] - prefix_sum[r2][c1-1] + prefix_sum[r1-1][c1-1] ) def matrix_sum_queries(matrix, queries): Given a matrix and a list of queries, return a list of sums of elements within each specified submatrix. prefix_sum = preprocess_matrix(matrix) results = [] for r1, c1, r2, c2 in queries: results.append(query_sum(prefix_sum, r1, c1, r2, c2)) return results"},{"question":"def evaluate_rpn_expression(expression): Evaluate the value of an arithmetic expression in Reverse Polish Notation (RPN). >>> evaluate_rpn_expression([\\"2\\", \\"1\\", \\"+\\", \\"3\\", \\"*\\"]) 9 >>> evaluate_rpn_expression([\\"4\\", \\"13\\", \\"5\\", \\"/\\", \\"+\\"]) 6 >>> evaluate_rpn_expression([\\"10\\", \\"6\\", \\"9\\", \\"3\\", \\"+\\", \\"-11\\", \\"*\\", \\"/\\", \\"*\\", \\"17\\", \\"+\\", \\"5\\", \\"+\\"]) 22 >>> evaluate_rpn_expression([\\"1\\", \\"2\\", \\"+\\"]) 3 >>> evaluate_rpn_expression([\\"4\\", \\"2\\", \\"/\\"]) 2 >>> evaluate_rpn_expression([\\"5\\", \\"1\\", \\"2\\", \\"+\\", \\"4\\", \\"*\\", \\"+\\", \\"3\\", \\"-\\"]) 14 >>> evaluate_rpn_expression([\\"3\\", \\"4\\", \\"+\\", \\"2\\", \\"*\\", \\"7\\", \\"/\\"]) 2 >>> evaluate_rpn_expression([\\"10\\", \\"3\\", \\"/\\"]) 3 >>> evaluate_rpn_expression([\\"10\\", \\"-3\\", \\"/\\"]) -3 >>> evaluate_rpn_expression([\\"-10\\", \\"3\\", \\"/\\"]) -3 >>> evaluate_rpn_expression([\\"-10\\", \\"-3\\", \\"/\\"]) 3 def evaluate_rpn_expressions(test_cases): Evaluate multiple RPN expressions. :param test_cases: List of RPN expressions. :return: List of results for each RPN expression. >>> evaluate_rpn_expressions([[\\"2\\", \\"1\\", \\"+\\", \\"3\\", \\"*\\"], [\\"4\\", \\"13\\", \\"5\\", \\"/\\", \\"+\\"], [\\"10\\", \\"6\\", \\"9\\", \\"3\\", \\"+\\", \\"-11\\", \\"*\\", \\"/\\", \\"*\\", \\"17\\", \\"+\\", \\"5\\", \\"+\\"]]) [9, 6, 22]","solution":"def evaluate_rpn_expression(expression): Evaluate the value of an arithmetic expression in Reverse Polish Notation (RPN). stack = [] for token in expression: if token in \\"+-*/\\": b = int(stack.pop()) a = int(stack.pop()) if token == \\"+\\": result = a + b elif token == \\"-\\": result = a - b elif token == \\"*\\": result = a * b elif token == \\"/\\": result = int(a / b) # truncate toward zero stack.append(result) else: stack.append(int(token)) return stack[0] def evaluate_rpn_expressions(test_cases): results = [] for expression in test_cases: results.append(evaluate_rpn_expression(expression)) return results"},{"question":"def count_letters(s: str) -> dict: Returns a dictionary with the count of each letter in the string s. Spaces are ignored. >>> count_letters(\\"hello world\\") == {'h': 1, 'e': 1, 'l': 3, 'o': 2, 'w': 1, 'r': 1, 'd': 1} >>> count_letters(\\"hello\\") == {'h': 1, 'e': 1, 'l': 2, 'o': 1} >>> count_letters(\\"abcdefghijklmnopqrstuvwxyz\\") == {'a': 1, 'b': 1, 'c': 1, 'd': 1, 'e': 1, 'f': 1, 'g': 1, 'h': 1, 'i': 1, 'j': 1, 'k': 1, 'l': 1, 'm': 1, 'n': 1, 'o': 1, 'p': 1, 'q': 1, 'r': 1, 's': 1, 't': 1, 'u': 1, 'v': 1, 'w': 1, 'x': 1, 'y': 1, 'z': 1} >>> count_letters(\\"aaa bbb ccc\\") == {'a': 3, 'b': 3, 'c': 3} >>> count_letters(\\"\\") == {} >>> count_letters(\\" \\") == {}","solution":"def count_letters(s): Returns a dictionary with the count of each letter in the string s. Spaces are ignored. letter_counts = {} for char in s: if char.isalpha(): # Ensure that only letters are counted if char in letter_counts: letter_counts[char] += 1 else: letter_counts[char] = 1 return letter_counts"},{"question":"def max_non_adjacent_sum(nums): Find the maximum possible sum of non-adjacent elements from the array. :param nums: List[int] - List of integers representing scores :return: int - Maximum possible sum of non-adjacent elements >>> max_non_adjacent_sum([3, 2, 5, 10, 7]) 15 >>> max_non_adjacent_sum([5]) 5 >>> max_non_adjacent_sum([1, 2]) 2 >>> max_non_adjacent_sum([5, 1]) 5 >>> max_non_adjacent_sum([-1, -2, -3, -4, -5]) 0 >>> max_non_adjacent_sum([-2, 1, 3, -4, 5]) 8 >>> max_non_adjacent_sum([0, 0, 0]) 0 >>> max_non_adjacent_sum([10] * 100000) 500000","solution":"def max_non_adjacent_sum(nums): Find the maximum possible sum of non-adjacent elements from the array. :param nums: List[int] - List of integers representing scores :return: int - Maximum possible sum of non-adjacent elements if not nums: return 0 include = 0 exclude = 0 for num in nums: # Current max excluding i new_exclude = max(include, exclude) # Current max including i include = exclude + num exclude = new_exclude # return max of include and exclude return max(include, exclude)"},{"question":"from typing import List def smallest_lexicographical_string(s: str) -> str: Returns the smallest lexicographical string obtained by performing any number of operations on the input string \`s\`. Args: s: A string consisting of lowercase English letters. Returns: The lexicographically smallest string that can be obtained. Examples: >>> smallest_lexicographical_string(\\"bcda\\") 'abcd' >>> smallest_lexicographical_string(\\"zxy\\") 'xyz' >>> smallest_lexicographical_string(\\"baaa\\") 'aaab' pass def test_smallest_lexicographical_string_with_various_cases(): # Test with general cases assert smallest_lexicographical_string('bcda') == 'abcd' assert smallest_lexicographical_string('zxy') == 'xyz' assert smallest_lexicographical_string('baaa') == 'aaab' assert smallest_lexicographical_string('aabcb') == 'aabbc' # Test with single character assert smallest_lexicographical_string('a') == 'a' # Test with already sorted string assert smallest_lexicographical_string('abc') == 'abc' # Test with string that includes all same characters assert smallest_lexicographical_string('aaaa') == 'aaaa' # Test with string with mixed characters assert smallest_lexicographical_string('dcba') == 'abcd' assert smallest_lexicographical_string('badc') == 'abcd' def test_smallest_lexicographical_string_with_same_characters(): # Test with all characters being the same assert smallest_lexicographical_string('cccc') == 'cccc' assert smallest_lexicographical_string('bbbb') == 'bbbb'","solution":"def smallest_lexicographical_string(s): Returns the smallest lexicographically string obtained by performing any number of operations on the input string \`s\`. return ''.join(sorted(s))"},{"question":"def balanced_distribution(n: int, m: int) -> tuple: Determines the maximum and minimum number of saplings in any park after distributing them as evenly as possible. Parameters: n (int): The number of saplings. m (int): The number of parks. Returns: tuple: A tuple containing two integers, the maximum and minimum number of saplings in any park. >>> balanced_distribution(10, 3) (4, 3) >>> balanced_distribution(7, 2) (4, 3) >>> balanced_distribution(5, 5) (1, 1)","solution":"def balanced_distribution(n, m): Determines the maximum and minimum number of saplings in any park after distributing them as evenly as possible. Parameters: n (int): The number of saplings. m (int): The number of parks. Returns: tuple: A tuple containing two integers, the maximum and minimum number of saplings in any park. max_saplings = (n + m - 1) // m # Maximum saplings in any park min_saplings = n // m # Minimum saplings in any park return max_saplings, min_saplings"},{"question":"def minimal_steps(n: int, string_pairs: List[Tuple[str, str]]) -> List[int]: Write a program that, given a list of string pairs, finds the minimum number of steps required to transform the first string in each pair into the second string. A step consists of either inserting, deleting, or replacing a single character. Examples: >>> minimal_steps(2, [(\\"horse\\", \\"ros\\"), (\\"intention\\", \\"execution\\")]) [3, 5] >>> minimal_steps(3, [(\\"a\\", \\"b\\"), (\\"a\\", \\"\\"), (\\"\\", \\"b\\")]) [1, 1, 1] :param n: int, the number of string pairs :param string_pairs: List of tuples containing the string pairs :return: List of integers representing minimum steps for each pair","solution":"def minDistance(word1, word2): Given two words word1 and word2, this function returns the minimum number of operations required to convert word1 to word2. You can insert, delete, or replace a character. m, n = len(word1), len(word2) dp = [[0] * (n + 1) for _ in range(m + 1)] for i in range(m + 1): for j in range(n + 1): if i == 0: dp[i][j] = j # fill the first row elif j == 0: dp[i][j] = i # fill the first column elif word1[i - 1] == word2[j - 1]: dp[i][j] = dp[i - 1][j - 1] else: dp[i][j] = 1 + min(dp[i - 1][j], # delete dp[i][j - 1], # insert dp[i - 1][j - 1]) # replace return dp[m][n] def minimal_steps(n, string_pairs): results = [] for i in range(n): word1 = string_pairs[i][0] word2 = string_pairs[i][1] results.append(minDistance(word1, word2)) return results"},{"question":"def perform_operations(n: int, m: int, arr: List[int], operations: List[List[int]]) -> List[int]: Perform operations (add or query) on the given array. Args: n (int): The number of elements in the array. m (int): The number of operations. arr (List[int]): The initial array. operations (List[List[int]]): The operations to be performed. - If the first integer is 1, the operation adds a value to each element in a range. The next three integers are l (int), r (int), and d (int) where (1 ≤ l ≤ r ≤ n, -1000000000 ≤ d ≤ 1000000000). - If the first integer is 2, the operation queries the sum of elements in a range. The next two integers are l (int) and r (int) where (1 ≤ l ≤ r ≤ n). Returns: List[int]: Result of the query operations. Examples: >>> perform_operations(5, 4, [1, 2, 3, 4, 5], [[1, 2, 4, 3], [2, 1, 5], [1, 3, 5, -2], [2, 1, 5]]) [24, 18] >>> perform_operations(3, 1, [2, 4, 6], [[1, 1, 3, 1]]) [] >>> perform_operations(4, 1, [2, 4, 6, 8], [[2, 2, 4]]) [18] >>> perform_operations(6, 3, [1, 2, 3, 4, 5, 6], [[1, 2, 5, 2], [2, 1, 3], [2, 4, 6]]) [10, 19]","solution":"def perform_operations(n, m, arr, operations): result = [] for op in operations: if op[0] == 1: _, l, r, d = op for i in range(l - 1, r): arr[i] += d elif op[0] == 2: _, l, r = op result.append(sum(arr[l - 1:r])) return result"},{"question":"from typing import List, Tuple def longest_increasing_sequence(n: int, transactions: List[Tuple[int, int]]) -> int: Determine the longest sequence of consecutive transactions by a single customer where the product IDs form a strictly increasing sequence. Args: n (int): Number of transactions. transactions (List[Tuple[int, int]]): List containing tuples of customer ID and product ID. Returns: int: Length of the longest increasing sequence of transactions for any customer. >>> longest_increasing_sequence(5, [(1, 2), (1, 3), (2, 1), (1, 4), (2, 2)]) 3 >>> longest_increasing_sequence(7, [(3, 1), (1, 3), (3, 2), (2, 4), (3, 3), (1, 5), (1, 6)]) 3","solution":"def longest_increasing_sequence(n, transactions): from collections import defaultdict customers = defaultdict(list) # Group transactions by customer for customer_id, product_id in transactions: customers[customer_id].append(product_id) def find_longest_increasing_subseq(arr): if not arr: return 0 lis = [1] * len(arr) for i in range(1, len(arr)): for j in range(i): if arr[i] > arr[j] and lis[i] < lis[j] + 1: lis[i] = lis[j] + 1 return max(lis) max_length = 0 # Calculate the longest increasing sequence for each customer for product_ids in customers.values(): max_length = max(max_length, find_longest_increasing_subseq(product_ids)) return max_length # Reading input if __name__ == \\"__main__\\": n = int(input()) transactions = [tuple(map(int, input().split())) for _ in range(n)] print(longest_increasing_sequence(n, transactions))"},{"question":"def min_switches(initial: str, target: str) -> int: Returns the minimum number of switches required to transform the initial sequence into the target pattern. >>> min_switches(\\"10101\\", \\"10001\\") 1 >>> min_switches(\\"11111\\", \\"00000\\") 5 >>> min_switches(\\"110011\\", \\"100111\\") 2 >>> min_switches(\\"100101\\", \\"100101\\") 0","solution":"def min_switches(initial, target): Returns the minimum number of switches required to transform the initial sequence into the target pattern. # Initialize the count of switches count = 0 # Loop through the initial and target strings for i in range(len(initial)): # If the characters at the current position are different, increment the count if initial[i] != target[i]: count += 1 return count"},{"question":"import re def count_distinct_words(text: str) -> int: Returns the number of distinct words in the given text. Words are compared in a case-insensitive manner and ignore punctuation. >>> count_distinct_words(\\"The quick brown fox jumps over the lazy dog.\\") 8 >>> count_distinct_words(\\"Hello, world! Hello world.\\") 2 >>> count_distinct_words(\\"test test test test test.\\") 1 >>> count_distinct_words(\\"\\") 0 >>> count_distinct_words(\\",.!?:;\\") 0 >>> count_distinct_words(\\"Apple apple Apple apple.\\") 1 >>> count_distinct_words(\\"Cat, Dog! Mouse? Bird: Fish; Elephant\\") 6","solution":"import re def count_distinct_words(text): Returns the number of distinct words in the given text. Words are compared in a case-insensitive manner and ignore punctuation. # Remove punctuation and convert text to lowercase cleaned_text = re.sub(r'[.,!?:;]', ' ', text).lower() # Split text into words words = cleaned_text.split() # Use a set to find unique words distinct_words = set(words) return len(distinct_words)"},{"question":"def is_valid_transaction(sequence): Checks if the given transaction sequence is valid according to the bank's policy. :param sequence: List of integers representing the transaction sequence. :return: Boolean indicating whether the sequence is valid. Examples: >>> is_valid_transaction([100, -50, -50, 200, -100]) True >>> is_valid_transaction([100, -150, 50, -50, 100]) False >>> is_valid_transaction([10, 20, 30, 40, 50]) True >>> is_valid_transaction([100, -100, 100, -100, 200, -200]) True >>> is_valid_transaction([100, -50, 50, -200]) False >>> is_valid_transaction([100]) True >>> is_valid_transaction([-100]) False >>> is_valid_transaction([50, -30, 20, -10, 40, -20, 10]) True >>> is_valid_transaction([50, -60, 20, 10, -5]) False >>> is_valid_transaction([1000000, -500000, 700000, -200000, -100000]) True >>> is_valid_transaction([500000, -1000000, 300000]) False","solution":"def is_valid_transaction(sequence): Checks if the given transaction sequence is valid. :param sequence: List of integers representing the transaction sequence. :return: Boolean indicating whether the sequence is valid. balance = 0 for transaction in sequence: balance += transaction if balance < 0: return False return True"},{"question":"def minimum_total_tax(n: int, m: int, roads: List[Tuple[int, int, int]]) -> int: Compute the minimum total tax the government can collect while maintaining the connectivity of all cities. >>> minimum_total_tax(4, 5, [ ... (1, 2, 1), ... (1, 3, 2), ... (1, 4, 3), ... (2, 3, 4), ... (3, 4, 5) ... ]) 6 >>> minimum_total_tax(3, 3, [ ... (1, 2, 2), ... (2, 3, 3), ... (1, 3, 4) ... ]) 5","solution":"def find(parent, i): if parent[i] == i: return i else: return find(parent, parent[i]) def union(parent, rank, x, y): xroot = find(parent, x) yroot = find(parent, y) if rank[xroot] < rank[yroot]: parent[xroot] = yroot elif rank[xroot] > rank[yroot]: parent[yroot] = xroot else: parent[yroot] = xroot rank[xroot] += 1 def kruskal(n, edges): edges.sort(key=lambda item: item[2]) parent = [] rank = [] for node in range(n): parent.append(node) rank.append(0) result = [] e = 0 i = 0 while e < n - 1: u, v, w = edges[i] i += 1 x = find(parent, u - 1) y = find(parent, v - 1) if x != y: e += 1 result.append((u, v, w)) union(parent, rank, x, y) minimum_cost = sum([w for u, v, w in result]) return minimum_cost def minimum_total_tax(n, m, roads): return kruskal(n, roads)"},{"question":"def can_make_grid_equal(grid): Determines if it's possible to make all numbers in the grid equal. If possible, returns a list of operations to achieve it. m = len(grid) n = len(grid[0]) def process_grids(t, test_cases): Processes multiple test cases to determine if it's possible to make all numbers in the grid equal. Returns the results in the desired output format. # Example test cases def test_can_make_grid_equal(): grid1 = [ [1, 2, 3], [4, 5, 6] ] grid2 = [ [1, 2], [3, 4] ] grid3 = [ [5, 5], [5, 5] ] assert can_make_grid_equal(grid1) == (\\"NO\\", []) assert can_make_grid_equal(grid2) == (\\"NO\\", []) assert can_make_grid_equal(grid3) == (\\"YES\\", [(1, 1, 2, 2, 0)]) def test_process_grids(): test_cases = [ (2, 3, [ [1, 2, 3], [4, 5, 6] ]), (2, 2, [ [1, 2], [3, 4] ]), (2, 2, [ [5, 5], [5, 5] ]), ] expected_output = [ \\"NO\\", \\"NO\\", \\"YES\\", \\"1 1 2 2 0\\" ] assert process_grids(3, test_cases) == expected_output","solution":"def can_make_grid_equal(grid): Determines if it's possible to make all numbers in the grid equal. If possible, returns a list of operations to achieve it. m = len(grid) n = len(grid[0]) # Calculate the modulo with respect to the first element in the grid. base = grid[0][0] differences = set(grid[i][j] - base for i in range(m) for j in range(n)) # If the differences set contains only one element, it's possible to make them equal if len(differences) == 1: operations = [(1, 1, m, n, base - grid[0][0])] return \\"YES\\", operations else: return \\"NO\\", [] def process_grids(t, test_cases): results = [] for case in test_cases: m, n, grid = case result, operations = can_make_grid_equal(grid) if result == \\"YES\\": results.append(\\"YES\\") for op in operations: results.append(f\\"{op[0]} {op[1]} {op[2]} {op[3]} {op[4]}\\") else: results.append(\\"NO\\") return results"},{"question":"def is_symmetrical_number(num): Determines if the number can be rearranged to form a palindrome. >>> is_symmetrical_number(\\"121\\") == True >>> is_symmetrical_number(\\"12321\\") == True >>> is_symmetrical_number(\\"1221\\") == True >>> is_symmetrical_number(\\"123\\") == False >>> is_symmetrical_number(\\"1212\\") == True pass def symmetrical_numbers(N, numbers): Given N numbers, returns a list with \\"YES\\" if the number is a symmetricalNumber and \\"NO\\" otherwise. >>> symmetrical_numbers(3, [\\"121\\", \\"12321\\", \\"1221\\"]) == [\\"YES\\", \\"YES\\", \\"YES\\"] >>> symmetrical_numbers(2, [\\"123\\", \\"456\\"]) == [\\"NO\\", \\"NO\\"] >>> symmetrical_numbers(1, [\\"1111\\"]) == [\\"YES\\"] >>> symmetrical_numbers(1, [\\"112233\\"]) == [\\"YES\\"] >>> symmetrical_numbers(1, [\\"1122332\\"]) == [\\"YES\\"] >>> symmetrical_numbers(1, [\\"1123345\\"]) == [\\"NO\\"] pass","solution":"def is_symmetrical_number(num): Determines if the number can be rearranged to form a palindrome. from collections import Counter # Count the frequency of each digit in the number count = Counter(num) # A number can form a palindrome if at most one digit has an odd count odd_count = sum(1 for v in count.values() if v % 2 != 0) return odd_count <= 1 def symmetrical_numbers(N, numbers): Given N numbers, returns a list with \\"YES\\" if the number is a symmetricalNumber and \\"NO\\" otherwise. results = [] for number in numbers: if is_symmetrical_number(number): results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"from typing import List def largest_rectangle_area(heights: List[int]) -> int: Returns the area of the largest rectangle that can be formed in the histogram. >>> largest_rectangle_area([2, 1, 4, 5, 1, 3, 3]) 8 >>> largest_rectangle_area([5, 4, 3, 2, 1]) 9 >>> largest_rectangle_area([1, 1, 1, 1]) 4 >>> largest_rectangle_area([6, 2, 5, 4, 5, 1, 6]) 12 pass def test_largest_rectangle_area(): assert largest_rectangle_area([2, 1, 4, 5, 1, 3, 3]) == 8 assert largest_rectangle_area([5, 4, 3, 2, 1]) == 9 assert largest_rectangle_area([1, 1, 1, 1]) == 4 assert largest_rectangle_area([6, 2, 5, 4, 5, 1, 6]) == 12 assert largest_rectangle_area([]) == 0 assert largest_rectangle_area([0, 0, 0]) == 0 assert largest_rectangle_area([1]) == 1 assert largest_rectangle_area([2, 4]) == 4 assert largest_rectangle_area([4, 4, 4]) == 12 if __name__ == \\"__main__\\": import pytest pytest.main([__file__])","solution":"def largest_rectangle_area(heights): Returns the area of the largest rectangle that can be formed in the histogram. stack = [] max_area = 0 index = 0 while index < len(heights): if not stack or heights[stack[-1]] <= heights[index]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"def floyd_warshall(n: int, graph: List[Tuple[int, int, int]]) -> int: Calculate the sum of the shortest paths between all pairs of villages using the Floyd-Warshall algorithm. Args: n: The number of villages. graph: A list of tuples where each tuple contains three integers representing a bidirectional road connecting two villages and its length. Returns: int: The sum of the shortest paths between all pairs of villages. Example: >>> floyd_warshall(3, [(1, 2, 4), (2, 3, 1), (3, 1, 3)]) 8 >>> floyd_warshall(3, [(1, 2, 2), (2, 3, 2), (3, 1, 2)]) 6 def process_input(input_data: str) -> List[int]: Process the input data containing multiple datasets of villages and roads, and calculate the sum of shortest paths for each dataset. Args: input_data: A string representation of multiple datasets terminated by '0 0'. Returns: List[int]: A list of integers where each integer is the sum of the shortest paths for a dataset. Example: >>> input_data = \\"\\"\\"3 3 1 2 4 2 3 1 3 1 3 3 3 1 2 2 2 3 2 3 1 2 0 0\\"\\"\\" >>> process_input(input_data) [8, 6]","solution":"def floyd_warshall(n, graph): # Initialize distance array dist = [[float('inf')] * n for _ in range(n)] for i in range(n): dist[i][i] = 0 # Populate initial distances from graph for u, v, l in graph: dist[u-1][v-1] = l dist[v-1][u-1] = l # Floyd-Warshall Algorithm for k in range(n): for i in range(n): for j in range(n): if dist[i][j] > dist[i][k] + dist[k][j]: dist[i][j] = dist[i][k] + dist[k][j] # Sum of shortest paths between all pairs total_sum = 0 for i in range(n): for j in range(i+1, n): total_sum += dist[i][j] return total_sum def process_input(input_data): input_lines = input_data.strip().split('n') index = 0 results = [] while index < len(input_lines): line = input_lines[index] n, m = map(int, line.split()) if n == 0 and m == 0: break graph = [] for _ in range(m): index += 1 u, v, l = map(int, input_lines[index].split()) graph.append((u, v, l)) index += 1 results.append(floyd_warshall(n, graph)) return results # Example input input_data = 3 3 1 2 4 2 3 1 3 1 3 3 3 1 2 2 2 3 2 3 1 2 0 0 # Process the example input output = process_input(input_data) print(\\"n\\".join(map(str, output)))"},{"question":"def gaming_platform(n: int, operations: List[str]) -> List[int]: Implement the points-tracking system for a gaming platform. Args: n (int): The number of players. operations (List[str]): The list of operations in the format specified. Returns: List[int]: The list of results corresponding to the query operations. >>> gaming_platform(5, [\\"1 1 100\\", \\"1 2 150\\", \\"2 1\\", \\"2 2\\", \\"1 1 50\\", \\"2 1\\", \\"2 5\\"]) [100, 150, 150, 0] >>> gaming_platform(1, [\\"1 1 200\\", \\"2 1\\"]) [200]","solution":"def gaming_platform(n, operations): # Initialize points for each player points = [0] * (n + 1) results = [] for operation in operations: op = operation.split() if op[0] == '1': # Add points operation p = int(op[1]) x = int(op[2]) points[p] += x elif op[0] == '2': # Query points operation p = int(op[1]) results.append(points[p]) return results"},{"question":"def increasing_triplet(n: int, array: List[int]) -> str: Determines if there exists an increasing triplet in the array. >>> increasing_triplet(5, [1, 2, 3, 4, 5]) \\"YES\\" >>> increasing_triplet(4, [5, 4, 3, 2, 1]) \\"NO\\"","solution":"def increasing_triplet(n, array): Determines if there exists an increasing triplet in the array. if n < 3: return \\"NO\\" first = float('inf') second = float('inf') for num in array: if num <= first: first = num elif num <= second: second = num else: return \\"YES\\" return \\"NO\\""},{"question":"def unique_total_distances(n, distances): Returns the number of unique total distances that can be achieved by summing any non-empty subset of the distances. >>> unique_total_distances(3, [1, 2, 3]) 6 >>> unique_total_distances(1, [5]) 1 >>> unique_total_distances(2, [1, 2]) 3 >>> unique_total_distances(4, [1, 1, 1, 1]) 4 >>> unique_total_distances(4, [1, 2, 4, 8]) 15 >>> unique_total_distances(3, [2, 2, 2]) 3","solution":"def unique_total_distances(n, distances): Returns the number of unique total distances that can be achieved by summing any non-empty subset of the distances. from itertools import combinations unique_sums = set() for r in range(1, n + 1): for subset in combinations(distances, r): unique_sums.add(sum(subset)) return len(unique_sums)"},{"question":"def can_transform_into_subsequence(A: str, B: str) -> str: Determines if A can be transformed into a subsequence of B. Parameters: A (str): The word that needs to be transformed. B (str): The target word which might contain the partial anagram. Returns: str: 'YES' if A can be transformed into a subsequence of B, otherwise 'NO'. >>> can_transform_into_subsequence(\\"abc\\", \\"abc\\") == \\"YES\\" >>> can_transform_into_subsequence(\\"abc\\", \\"aabbcc\\") == \\"YES\\" >>> can_transform_into_subsequence(\\"abc\\", \\"acbd\\") == \\"NO\\"","solution":"def can_transform_into_subsequence(A, B): Determines if A can be transformed into a subsequence of B. Parameters: A (str): The word that needs to be transformed. B (str): The target word which might contain the partial anagram. Returns: str: 'YES' if A can be transformed into a subsequence of B, otherwise 'NO'. a_idx = 0 b_idx = 0 while a_idx < len(A) and b_idx < len(B): if A[a_idx] == B[b_idx]: a_idx += 1 b_idx += 1 return \\"YES\\" if a_idx == len(A) else \\"NO\\""},{"question":"def is_palindrome(s: str) -> str: Determines whether the given string is a palindrome. Args: s (str): Input string containing between 1 and 100 lowercase English letters. Returns: str: \\"YES\\" if the string is a palindrome, \\"NO\\" otherwise. >>> is_palindrome(\\"radar\\") \\"YES\\" >>> is_palindrome(\\"hello\\") \\"NO\\" >>> is_palindrome(\\"level\\") \\"YES\\"","solution":"def is_palindrome(s): Determines whether the given string is a palindrome. Args: s (str): Input string containing between 1 and 100 lowercase English letters. Returns: str: \\"YES\\" if the string is a palindrome, \\"NO\\" otherwise. if s == s[::-1]: return \\"YES\\" else: return \\"NO\\""},{"question":"from typing import List def replace_most_frequent_with_minus_one(test_cases: List[List[int]]) -> List[List[int]]: Finds the element with the most frequency in each array of integers from test cases. If there are multiple elements with the same maximum frequency, selects the smallest element among them. Replaces all its occurrences in the array with the number -1 and returns the resulting arrays. >>> replace_most_frequent_with_minus_one([[1, 2, 2, 3, 3, 3], [4, 4, 5, 5, 6]]) [[1, 2, 2, -1, -1, -1], [-1, -1, 5, 5, 6]] >>> replace_most_frequent_with_minus_one([[3]]) [[-1]] >>> replace_most_frequent_with_minus_one([[1, 2, 3]]) [[-1, 2, 3]] >>> replace_most_frequent_with_minus_one([[9, 9, 9, 8, 8, 7, 7, 7, 7, 7]]) [[9, 9, 9, 8, 8, -1, -1, -1, -1, -1]] # Implementation will be provided by the user","solution":"from collections import Counter def replace_most_frequent_with_minus_one(test_cases): results = [] for arr in test_cases: counter = Counter(arr) most_freq_count = max(counter.values()) # Find the smallest element among those with the highest frequency most_freq_elem = min(key for key, value in counter.items() if value == most_freq_count) # Replace all occurrences of the most frequent element with -1 result = [-1 if x == most_freq_elem else x for x in arr] results.append(result) return results def parse_input(input_data): lines = input_data.strip().split('n') t = int(lines[0]) index = 1 test_cases = [] for _ in range(t): n = int(lines[index]) arr = list(map(int, lines[index + 1].split())) test_cases.append(arr) index += 2 return test_cases"},{"question":"def min_difference(m: int, skills: List[int]) -> int: Returns the minimum possible absolute difference in the total skill levels of the two teams. :param m: int, number of players :param skills: list of int, skill levels of the players :return: int, minimal possible absolute difference in total skill levels of two teams >>> min_difference(5, [3, 1, 4, 2, 2]) 0 >>> min_difference(2, [1, 2]) 1 >>> min_difference(4, [10, 10, 10, 10]) 0 >>> min_difference(6, [10, 20, 30, 40, 50, 60]) 10 >>> min_difference(3, [7, 11, 5]) 1 >>> min_difference(4, [1, 2, 3, 8]) 2","solution":"def min_difference(m, skills): Returns the minimum possible absolute difference in the total skill levels of the two teams. :param m: int, number of players :param skills: list of int, skill levels of the players :return: int, minimal possible absolute difference in total skill levels of two teams total_skill = sum(skills) half_total_skill = total_skill // 2 # Initialize DP array, where dp[i] indicates whether i skill sum is possible dp = [False] * (half_total_skill + 1) dp[0] = True for skill in skills: for j in range(half_total_skill, skill - 1, -1): dp[j] = dp[j] or dp[j - skill] for i in range(half_total_skill, -1, -1): if dp[i]: return abs(total_skill - 2 * i)"},{"question":"def modify_sequence(n: int, k: int, a: List[int]) -> List[int]: Modifies the sequence such that each element is the sum of the previous k elements in a cyclic manner. :param n: Length of the sequence (integer) :param k: Number of elements to sum (integer) :param a: Original sequence (list of integers) :return: Modified sequence (list of integers) >>> modify_sequence(4, 2, [1, 2, 3, 4]) [1, 3, 5, 7] >>> modify_sequence(5, 3, [1, 2, 3, 4, 5]) [1, 3, 6, 9, 12] >>> modify_sequence(3, 1, [3, 3, 3]) [3, 3, 3] pass","solution":"def modify_sequence(n, k, a): Modifies the sequence such that each element is the sum of the previous k elements in a cyclic manner. :param n: Length of the sequence (integer) :param k: Number of elements to sum (integer) :param a: Original sequence (list of integers) :return: Modified sequence (list of integers) b = [0] * n for i in range(n): b[i] = sum(a[max(i - k + 1, 0): i + 1]) return b # Example usage with print statements if __name__ == \\"__main__\\": n, k = 4, 2 a = [1, 2, 3, 4] print(modify_sequence(n, k, a)) # Should print [1, 3, 5, 7] n, k = 5, 3 a = [1, 2, 3, 4, 5] print(modify_sequence(n, k, a)) # Should print [1, 3, 6, 9, 12] n, k = 3, 1 a = [3, 3, 3] print(modify_sequence(n, k, a)) # Should print [3, 3, 3]"},{"question":"def longest_consecutive_segment(nums: List[int]) -> int: Calculate the length of the longest segment that contains consecutive integers. >>> longest_consecutive_segment([100, 4, 200, 1, 3, 2]) 4 >>> longest_consecutive_segment([6, 6, 7, 8, 8]) 3 pass def process_test_cases(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Process multiple test cases to find the longest segment of consecutive integers for each case. >>> process_test_cases(2, [(6, [100, 4, 200, 1, 3, 2]), (5, [6, 6, 7, 8, 8])]) [4, 3] pass","solution":"def longest_consecutive_segment(nums): if not nums: return 0 num_set = set(nums) max_length = 0 for num in num_set: if num - 1 not in num_set: current_num = num current_length = 1 while current_num + 1 in num_set: current_num += 1 current_length += 1 max_length = max(max_length, current_length) return max_length def process_test_cases(T, test_cases): results = [] for i in range(T): n, nums = test_cases[i] results.append(longest_consecutive_segment(nums)) return results"},{"question":"def dungeon_navigation(room_count: int, room_definitions: List[str], commands: str) -> int: You are developing a simple text-based role-playing game (RPG) where players move between different rooms in a dungeon. Each room is connected to other rooms via doors, and each door is associated with a directional indicator (e.g., 'N' for north, 'S' for south, etc.). Your task is to design the player movement and room navigation system. Args: room_count (int): The number of rooms. room_definitions (List[str]): A list of strings containing the room connections. commands (str): A string of space-separated directional commands. Returns: int: The final room id where the player ends up after following all the commands, starting from room 1. Example: >>> dungeon_navigation(4, [ ... \\"1 2 N 2 E 3\\", ... \\"2 1 S 1\\", ... \\"3 1 W 1\\", ... \\"4 0\\" ... ], \\"N E S\\") 1","solution":"def dungeon_navigation(room_count, room_definitions, commands): # Initialize the rooms dictionary rooms = {} for definition in room_definitions: parts = definition.split() room_id = int(parts[0]) num_connections = int(parts[1]) connections = {} for i in range(num_connections): direction = parts[2 + 2*i] connected_room_id = int(parts[3 + 2*i]) connections[direction] = connected_room_id rooms[room_id] = connections current_room = 1 for command in commands.split(): if command in rooms[current_room]: current_room = rooms[current_room][command] return current_room"},{"question":"def check_collision(start, end, obstacles): Determines whether the spaceship's flight path intersects with any spherical obstacle. Parameters: start (tuple): The coordinates of the spaceship's starting position (x1, y1, z1). end (tuple): The coordinates of the spaceship's ending position (x2, y2, z2). obstacles (list): A list of tuples, each containing the coordinates of the center of an obstacle (xc, yc, zc) and its radius r. Returns: str: \\"COLLISION\\" if the spaceship's flight path intersects with any spherical obstacle, otherwise \\"SAFE\\". Examples: >>> check_collision((0, 0, 0), (10, 10, 10), [(5, 5, 5, 3), (8, 8, 8, 1)]) 'COLLISION' >>> check_collision((0, 0, 0), (10, 10, 10), [(20, 20, 20, 4), (-4, -4, -4, 2)]) 'SAFE'","solution":"def check_collision(start, end, obstacles): def distance_sq_point_to_segment(px, py, pz, ax, ay, az, bx, by, bz): abx, aby, abz = bx - ax, by - ay, bz - az apx, apy, apz = px - ax, py - ay, pz - az ab_ap_product = abx * apx + aby * apy + abz * apz ab_ab_product = abx * abx + aby * aby + abz * abz if ab_ab_product == 0: # segment is a point return apx * apx + apy * apy + apz * apz t = max(0, min(1, ab_ap_product / ab_ab_product)) closest_point_x = ax + t * abx closest_point_y = ay + t * aby closest_point_z = az + t * abz dx, dy, dz = px - closest_point_x, py - closest_point_y, pz - closest_point_z return dx * dx + dy * dy + dz * dz x1, y1, z1 = start x2, y2, z2 = end for (xc, yc, zc, r) in obstacles: if distance_sq_point_to_segment(xc, yc, zc, x1, y1, z1, x2, y2, z2) <= r * r: return \\"COLLISION\\" return \\"SAFE\\" # Example usage start = (0, 0, 0) end = (10, 10, 10) obstacles = [(5, 5, 5, 3), (8, 8, 8, 1)] print(check_collision(start, end, obstacles)) # Output: \\"COLLISION\\""},{"question":"def organize_ebooks(n, ebooks): Organize eBooks by ratings and then by the number of pages. Parameters: n (int): Number of eBooks ebooks (list of tuples): List of tuples where each tuple has two integers, p (number of pages) and r (rating) Returns: list of lists: List of eBooks grouped by their ratings with pages sorted in ascending order within each group >>> organize_ebooks(5, [(350, 3), (200, 1), (450, 2), (500, 1), (150, 2)]) [[200, 500], [150, 450], [350]] >>> organize_ebooks(3, [(100, 1), (150, 1), (200, 1)]) [[100, 150, 200]] pass def format_organized_ebooks(organized_ebooks): Format and print the organized eBooks. Parameters: organized_ebooks (list of lists): List of grouped and sorted eBooks Returns: str: Formatted string output as described in the problem statement >>> format_organized_ebooks([[200, 500], [150, 450], [350]]) \\"200n500nn150n450nn350\\" >>> format_organized_ebooks([[100, 150, 200]]) \\"100n150n200\\" pass","solution":"def organize_ebooks(n, ebooks): Organize eBooks by ratings and then by the number of pages. Parameters: n (int): Number of eBooks ebooks (list of tuples): List of tuples where each tuple has two integers, p (number of pages) and r (rating) Returns: list of lists: List of eBooks grouped by their ratings with pages sorted in ascending order within each group from collections import defaultdict # Initialize dictionary to store eBooks by rating books_by_rating = defaultdict(list) # Group books by rating for pages, rating in ebooks: books_by_rating[rating].append(pages) # Sort each rating group by number of pages sorted_ebooks = [] for rating in range(1, 6): if rating in books_by_rating: sorted_books = sorted(books_by_rating[rating]) if sorted_books: sorted_ebooks.append(sorted_books) return sorted_ebooks def format_organized_ebooks(organized_ebooks): Format and print the organized eBooks. Parameters: organized_ebooks (list of lists): List of grouped and sorted eBooks Returns: str: Formatted string output as described in the problem statement result = [] for books in organized_ebooks: result.append('n'.join(map(str, books))) return 'nn'.join(result)"},{"question":"def unique_paths_with_obstacles(grid: List[str]) -> int: Calculate the number of unique paths in a grid with obstacles. :param grid: List of strings representing the grid. :return: Number of unique paths from top-left to bottom-right. Example: >>> unique_paths_with_obstacles([\\"...\\",\\".#.\\",\\"...\\"]) 2 >>> unique_paths_with_obstacles([\\"#\\",\\".#.\\",\\"...\\"]) 0 from typing import List def test_unique_paths_with_obstacles(): assert unique_paths_with_obstacles([\\"...\\",\\".#.\\",\\"...\\"]) == 2 assert unique_paths_with_obstacles([\\"#\\",\\".#.\\",\\"...\\"]) == 0 assert unique_paths_with_obstacles([\\"..\\", \\"..\\"]) == 2 assert unique_paths_with_obstacles([\\".#\\", \\"..\\"]) == 1 assert unique_paths_with_obstacles([\\".#\\", \\"#.\\"]) == 0 assert unique_paths_with_obstacles([\\"#.\\", \\"..\\"]) == 0 test_unique_paths_with_obstacles()","solution":"def unique_paths_with_obstacles(grid): Calculate the number of unique paths in a grid with obstacles. :param grid: List of strings representing the grid. :return: Number of unique paths from top-left to bottom-right. R = len(grid) C = len(grid[0]) # If starting position or ending position is an obstacle if grid[0][0] == '#' or grid[R-1][C-1] == '#': return 0 # Create a DP table initialized with 0s dp = [[0] * C for _ in range(R)] # Starting point dp[0][0] = 1 for i in range(R): for j in range(C): if grid[i][j] == '#': dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[R-1][C-1]"},{"question":"def create_matrix(N, M): Creates an N x M matrix where the value at cell (i, j) is equal to the sum of its row index and column index. Parameters: N (int): Number of rows M (int): Number of columns Returns: List[List[int]]: The resulting matrix >>> create_matrix(2, 3) [[0, 1, 2], [1, 2, 3]] >>> create_matrix(1, 1) [[0]] >>> create_matrix(3, 3) [[0, 1, 2], [1, 2, 3], [2, 3, 4]] >>> create_matrix(4, 5) [[0, 1, 2, 3, 4], [1, 2, 3, 4, 5], [2, 3, 4, 5, 6], [3, 4, 5, 6, 7]] def print_matrix(matrix): Prints the given N x M matrix with values in each row separated by a space, and a line break at the end. Parameters: matrix (List[List[int]]): The matrix to print def main(): Main function to take input of N and M and to create and print the matrix. N, M = map(int, input().split()) matrix = create_matrix(N, M) print_matrix(matrix)","solution":"def create_matrix(N, M): Creates an N x M matrix where the value at cell (i, j) is equal to the sum of its row index and column index. Parameters: N (int): Number of rows M (int): Number of columns Returns: List[List[int]]: The resulting matrix matrix = [] for i in range(N): row = [] for j in range(M): row.append(i + j) matrix.append(row) return matrix def print_matrix(matrix): for row in matrix: print(' '.join(map(str, row)))"},{"question":"from typing import List, Tuple def analyze_transactions(transactions: List[Tuple[int, int, float]]) -> Tuple[int, int, Tuple[int, float]]: Analyze the given list of transactions and find: 1. The user who spent the most money. 2. The user who made the highest number of transactions. 3. The details of the single highest transaction. Each transaction is a tuple: (transaction_id, user_id, amount). Args: transactions: List of tuples representing transactions (transaction ID, user ID, amount spent). Returns: A tuple containing: 1. User ID of the user who spent the most money. 2. User ID of the user who made the highest number of transactions. 3. A tuple with the transaction ID and amount of the highest transaction. >>> analyze_transactions([(101, 1, 29.99), (102, 2, 79.95), (103, 1, 49.99)]) == (1, 1, (103, 49.99)) >>> analyze_transactions([(104, 3, 19.99), (105, 2, 99.95)]) == (2, 2, (105, 99.95))","solution":"def analyze_transactions(transactions): Analyze the given list of transactions and find: 1. The user who spent the most money. 2. The user who made the highest number of transactions. 3. The details of the single highest transaction. Each transaction is a tuple: (transaction_id, user_id, amount). from collections import defaultdict user_spending = defaultdict(float) user_trans_count = defaultdict(int) highest_transaction = None for tx_id, user_id, amount in transactions: user_spending[user_id] += amount user_trans_count[user_id] += 1 if highest_transaction is None or amount > highest_transaction[1]: highest_transaction = (tx_id, amount) # Find the user who spent the most max_spent_user = max(user_spending, key=user_spending.get) # Find the user with the highest number of transactions max_trans_user = max(user_trans_count, key=user_trans_count.get) return (max_spent_user, max_trans_user, highest_transaction) # Example runs with provided data transactions = [ (101, 1, 29.99), (102, 2, 79.95), (103, 1, 49.99), (104, 3, 19.99), (105, 2, 99.95), (106, 1, 9.99), (107, 3, 29.99), (108, 2, 9.99) ] analyze_transactions(transactions) # Expected output: (2, 1, (105, 99.95))"},{"question":"def largest_palindromic_product(n: int) -> int: Returns the largest palindromic number that is a product of two n-digit numbers. >>> largest_palindromic_product(1) 9 >>> largest_palindromic_product(2) 9009 >>> largest_palindromic_product(3) 906609 >>> largest_palindromic_product(4) 99000099 # This is an example value, adjust accordingly after verification","solution":"def is_palindrome(number): Returns True if the given number is a palindrome, False otherwise. return str(number) == str(number)[::-1] def largest_palindromic_product(n): Returns the largest palindromic number that is a product of two n-digit numbers. max_digit = 10 ** n - 1 min_digit = 10 ** (n - 1) max_palindrome = 0 for i in range(max_digit, min_digit - 1, -1): for j in range(i, min_digit - 1, -1): product = i * j if product <= max_palindrome: break if is_palindrome(product): max_palindrome = product return max_palindrome"},{"question":"from typing import List, Optional from collections import deque # Definition for a binary tree node. class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def zigzagLevelOrder(root: Optional[TreeNode]) -> List[List[int]]: Return the zigzag level order traversal of a binary tree. :param TreeNode root: The root node of the binary tree. :return List[List[int]]: The zigzag level order traversal of the nodes' values. >>> zigzagLevelOrder(TreeNode(3, TreeNode(9), TreeNode(20, TreeNode(15), TreeNode(7)))) [[3], [20, 9], [15, 7]] >>> zigzagLevelOrder(None) [] >>> zigzagLevelOrder(TreeNode(1)) [[1]] >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> zigzagLevelOrder(root) [[1], [3, 2]] >>> root.left.left = TreeNode(4) >>> root.left.right = TreeNode(5) >>> root.right.left = TreeNode(6) >>> root.right.right = TreeNode(7) >>> zigzagLevelOrder(root) [[1], [3, 2], [4, 5, 6, 7]]","solution":"from collections import deque # Definition for a binary tree node. class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def zigzagLevelOrder(root): Return the zigzag level order traversal of a binary tree. :param TreeNode root: The root node of the binary tree. :return List[List[int]]: The zigzag level order traversal of the nodes' values. if not root: return [] results = [] nodes_queue = deque([root]) left_to_right = True while nodes_queue: level = deque() level_length = len(nodes_queue) for _ in range(level_length): node = nodes_queue.popleft() if left_to_right: level.append(node.val) else: level.appendleft(node.val) if node.left: nodes_queue.append(node.left) if node.right: nodes_queue.append(node.right) results.append(list(level)) left_to_right = not left_to_right return results"},{"question":"from typing import List, Tuple def min_transformations(initial: str, target: str, n: int, rules: List[Tuple[str, str]]) -> int: Returns the minimum number of transformations required to change the initial string into the target string using the given set of rules. If it is impossible to transform the initial string into the target string using the given rules, returns -1. >>> min_transformations(\\"abc\\", \\"def\\", 3, [(\\"a\\", \\"d\\"), (\\"b\\", \\"e\\"), (\\"c\\", \\"f\\")]) 3 >>> min_transformations(\\"abc\\", \\"xyz\\", 2, [(\\"a\\", \\"x\\"), (\\"b\\", \\"y\\")]) -1 >>> min_transformations(\\"abc\\", \\"abc\\", 0, []) 0","solution":"from collections import defaultdict, deque def min_transformations(initial, target, n, rules): Returns the minimum number of transformations required to change the initial string into the target string using the given set of rules. If it is impossible to transform the initial string into the target string using the given rules, returns -1. if initial == target: return 0 transformations = defaultdict(set) for x, y in rules: transformations[x].add(y) def bfs(source, destination): Perform BFS to find the shortest transformation path from source to destination character. if source == destination: return 0 visited = set() queue = deque([(source, 0)]) while queue: current, steps = queue.popleft() if current == destination: return steps for next_char in transformations[current]: if next_char not in visited: visited.add(next_char) queue.append((next_char, steps + 1)) return float('inf') total_transformations = 0 for s_char, t_char in zip(initial, target): if s_char == t_char: continue steps = bfs(s_char, t_char) if steps == float('inf'): return -1 total_transformations += steps return total_transformations"},{"question":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def goodNodes(root: TreeNode) -> int: Count the number of good nodes in a binary tree. A node X in the tree is considered good if in the path from the root to X there are no nodes with a value greater than X's value. :param root: TreeNode, the root of the binary tree :return: int, the number of good nodes >>> root = TreeNode(3) >>> root.left = TreeNode(1) >>> root.right = TreeNode(4) >>> root.left.left = TreeNode(3) >>> root.right.left = TreeNode(1) >>> root.right.right = TreeNode(5) >>> goodNodes(root) 4 >>> root = TreeNode(3) >>> goodNodes(root) 1 >>> root = TreeNode(3) >>> root.left = TreeNode(3) >>> root.right = TreeNode(4) >>> root.left.left = TreeNode(3) >>> root.left.right = TreeNode(3) >>> root.right.left = TreeNode(4) >>> root.right.right = TreeNode(5) >>> goodNodes(root) 7 >>> root = TreeNode(-1) >>> root.left = TreeNode(-2) >>> root.right = TreeNode(-3) >>> root.left.left = TreeNode(-4) >>> root.right.right = TreeNode(-5) >>> goodNodes(root) 1 >>> root = TreeNode(2) >>> root.left = TreeNode(1) >>> root.right = TreeNode(3) >>> root.left.left = TreeNode(0) >>> root.right.right = TreeNode(4) >>> goodNodes(root) 3","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def goodNodes(root: TreeNode) -> int: def dfs(node, max_val): if not node: return 0 good = 1 if node.val >= max_val else 0 max_val = max(max_val, node.val) good += dfs(node.left, max_val) good += dfs(node.right, max_val) return good return dfs(root, root.val)"},{"question":"def lexicographically_smallest_permutation(s: str) -> str: Returns the lexicographically smallest permutation of the string s. >>> lexicographically_smallest_permutation(\\"coder\\") 'cdeor' >>> lexicographically_smallest_permutation(\\"algorithm\\") 'aghilmort' >>> lexicographically_smallest_permutation(\\"a\\") 'a' >>> lexicographically_smallest_permutation(\\"banana\\") 'aaabnn' >>> lexicographically_smallest_permutation(\\"apple\\") 'aelpp' >>> lexicographically_smallest_permutation(\\"abcdef\\") 'abcdef' >>> test_string = \\"zyxwvutsrqponmlkjihgfedcba\\" * 2 >>> lexicographically_smallest_permutation(test_string) == ''.join(sorted(test_string)) True","solution":"def lexicographically_smallest_permutation(s): Returns the lexicographically smallest permutation of string s. return ''.join(sorted(s))"},{"question":"def minimum_tracking_stations(n: int, m: int, logs: List[Tuple[int, int]]) -> int: Determine minimum number of tracking stations needed to cover all detected bird IDs at least once. Parameters: n (int): Number of birds detected. m (int): Number of log entries. logs (list of tuples): Each tuple contains (bird_id, station_id). Returns: int: Minimum number of distinct tracking stations required. >>> logs = [(1, 1), (1, 2), (2, 2), (2, 3), (3, 3)] >>> minimum_tracking_stations(3, 5, logs) 2 >>> logs = [(1, 1), (2, 1), (3, 1)] >>> minimum_tracking_stations(3, 3, logs) 1 >>> logs = [(1, 1), (2, 2), (3, 3)] >>> minimum_tracking_stations(3, 3, logs) 3 >>> logs = [(1, 1), (1, 2), (2, 3), (2, 4), (3, 5), (3, 6)] >>> minimum_tracking_stations(3, 6, logs) 3 >>> logs = [(1, 1), (2, 1), (2, 2), (3, 2), (3, 3)] >>> minimum_tracking_stations(3, 5, logs) 2 >>> logs = [(1, 1)] >>> minimum_tracking_stations(1, 1, logs) 1 >>> logs = [(i, (i % 5) + 1) for i in range(1, 1001)] >>> assert minimum_tracking_stations(1000, 1000, logs) >= 1 >>> assert minimum_tracking_stations(1000, 1000, logs) <= 5 pass","solution":"def minimum_tracking_stations(n, m, logs): Determine minimum number of tracking stations needed to cover all detected bird IDs at least once. Parameters: n (int): Number of birds detected. m (int): Number of log entries. logs (list of tuples): Each tuple contains (bird_id, station_id). Returns: int: Minimum number of distinct tracking stations required. from collections import defaultdict bird_stations = defaultdict(set) for bird_id, station_id in logs: bird_stations[bird_id].add(station_id) station_coverages = {} for st_id in range(1, 1001): station_coverages[st_id] = set() for bird_id, stations in bird_stations.items(): for station_id in stations: station_coverages[station_id].add(bird_id) all_birds = set(range(1, n + 1)) covered_birds = set() station_counts = [] while covered_birds != all_birds: max_cover_station = None max_cover = 0 for station_id, birds in station_coverages.items(): cover_size = len(birds - covered_birds) if cover_size > max_cover: max_cover = cover_size max_cover_station = station_id covered_birds.update(station_coverages[max_cover_station]) station_counts.append(max_cover_station) del station_coverages[max_cover_station] return len(station_counts)"},{"question":"def find_ranks_and_queries(n, q, scores, queries): Dana is organizing a dart tournament. Each player scores some points during their turn, and the score is always an integer. Dana wants to find out the rank of each player after all turns are completed. The rank of a player is determined by their total score, sorted in descending order. In case two players have the same total score, they get the same rank. n (int): the number of players. q (int): the number of queries. scores (List[int]): the total scores of each player after the tournament. queries (List[int]): the index of the player for each query (1-based index). Returns: List[int]: The rank of each queried player. Examples: >>> find_ranks_and_queries(5, 3, [100, 200, 100, 400, 300], [1, 3, 5]) [4, 4, 2] >>> find_ranks_and_queries(1, 1, [0], [1]) [1] >>> find_ranks_and_queries(6, 6, [300, 300, 300, 300, 300, 300], [1, 2, 3, 4, 5, 6]) [1, 1, 1, 1, 1, 1] >>> find_ranks_and_queries(4, 2, [400, 300, 200, 100], [1, 4]) [1, 4] >>> find_ranks_and_queries(4, 4, [1000000000, 999999999, 999999999, 1], [1, 2, 3, 4]) [1, 2, 2, 4]","solution":"def find_ranks_and_queries(n, q, scores, queries): # Create a list of (score, index) tuples for sorting score_index_pairs = [(scores[i], i) for i in range(n)] # Sort based on score in descending order score_index_pairs.sort(reverse=True, key=lambda x: x[0]) # Initialize ranks array ranks = [0] * n current_rank = 1 for i in range(n): if i == 0: ranks[score_index_pairs[i][1]] = current_rank else: if score_index_pairs[i][0] < score_index_pairs[i - 1][0]: current_rank = i + 1 ranks[score_index_pairs[i][1]] = current_rank # Handle the queries results = [] for query in queries: results.append(ranks[query - 1]) return results"},{"question":"import math from typing import List def is_prime(num: int) -> bool: Returns True if the num is a prime number, else False. >>> is_prime(2) == True >>> is_prime(3) == True >>> is_prime(4) == False >>> is_prime(10) == False >>> is_prime(17) == True >>> is_prime(1) == False >>> is_prime(0) == False >>> is_prime(97) == True def game_result(n: int, numbers: List[int]) -> str: Determines the result of the game. >>> game_result(5, [1, 3, 5, 8, 14]) == \\"Anna\\" >>> game_result(4, [0, 1, 4, 6]) == \\"Draw\\" >>> game_result(3, [2, 4, 9]) == \\"Anna\\" >>> game_result(3, [0, 1, 4]) == \\"Draw\\" >>> game_result(3, [14, 15, 16]) == \\"Draw\\" >>> game_result(6, [0, 1, 4, 6, 8, 10]) == \\"Draw\\" >>> game_result(6, [0, 1, 4, 6, 8, 11]) == \\"Anna\\"","solution":"import math def is_prime(num): Returns True if the num is a prime number, else False. if num <= 1: return False if num <= 3: return True if num % 2 == 0 or num % 3 == 0: return False i = 5 while i * i <= num: if num % i == 0 or num % (i + 2) == 0: return False i += 6 return True def game_result(n, numbers): Determines the result of the game. for number in numbers: if is_prime(number): return \\"Anna\\" return \\"Draw\\""},{"question":"def min_max_cumulative_duration(n, m, tasks): Schedule tasks to minimize the maximum cumulative task duration. :param n: int - Number of tasks :param m: int - Number of processors :param tasks: List[int] - Durations of the tasks :return: int - Minimum possible value of the maximum cumulative task duration. >>> min_max_cumulative_duration(5, 2, [3, 5, 2, 7, 1]) 9 >>> min_max_cumulative_duration(4, 3, [8, 3, 7, 2]) 8 >>> min_max_cumulative_duration(1, 1, [10]) 10 >>> min_max_cumulative_duration(3, 3, [4, 2, 6]) 6 >>> min_max_cumulative_duration(4, 2, [5, 5, 5, 5]) 10 >>> min_max_cumulative_duration(6, 3, [1, 2, 3, 4, 5, 6]) 7 >>> min_max_cumulative_duration(3, 5, [7, 8, 9]) 9","solution":"def min_max_cumulative_duration(n, m, tasks): tasks.sort(reverse=True) # Sort tasks in descending order processors = [0] * m # Initialize all processors with 0 duration for task in tasks: # Assign the task to the processor with the least cumulative duration min_processor_index = processors.index(min(processors)) processors[min_processor_index] += task return max(processors)"},{"question":"def min_operations_to_transform(s: str) -> int: Returns the minimum number of operations required to turn the string s into a string that contains only the letter 'a' by replacing any substring with 'a'. >>> min_operations_to_transform(\\"bba\\") 2 >>> min_operations_to_transform(\\"abacaba\\") 3","solution":"def min_operations_to_transform(s): Returns the minimum number of operations required to turn the string s into a string that contains only the letter 'a' by replacing any substring with 'a'. # Number of non-'a' characters in the string is the minimum number of operations needed return sum(1 for char in s if char != 'a')"},{"question":"def maximize_experience(n: int, m: int, drivers: list[int], vehicles: list[int]) -> int: Assign drivers to vehicles to maximize the total experience level, while each vehicle gets one and only one driver. >>> maximize_experience(5, 3, [7, 10, 3, 12, 15], [8, 5, 4]) 37 >>> maximize_experience(1, 1, [10], [5]) 10 >>> maximize_experience(4, 2, [8, 9, 10, 11], [5, 5]) 21 >>> maximize_experience(4, 4, [2, 3, 4, 5], [6, 7, 8, 9]) 0 >>> maximize_experience(5, 3, [1, 2, 3, 4, 5], [6, 7, 8]) 0 >>> maximize_experience(5, 3, [7, 10, 3, 12, 15], [5, 5, 5]) 37","solution":"def maximize_experience(n, m, drivers, vehicles): drivers.sort(reverse=True) vehicles.sort(reverse=True) total_experience = 0 j = 0 for i in range(m): while j < n and drivers[j] < vehicles[i]: j += 1 if j < n: total_experience += drivers[j] j += 1 return total_experience"},{"question":"class TreeNode: def __init__(self, key): self.left = None self.right = None self.val = key class BST: def __init__(self): self.root = None def insert(self, key): Insert a value into the BST. pass def delete(self, key): Delete a value from the BST. pass def find_min(self): Find the minimum value in the BST. pass def find_max(self): Find the maximum value in the BST. pass def find_height(self): Find the height of the BST. pass def inorder(self): Perform an inorder traversal of the BST. pass def process_bst_operations(operations): Process a list of operations on the BST. Args: operations (List[str]): List of operations to be performed on the BST. Returns: List: Results of the operations in the order they are performed. Examples: >>> process_bst_operations([ \\"insert 5\\", \\"insert 3\\", \\"insert 7\\", \\"find_min\\", \\"find_max\\", \\"find_height\\", \\"inorder\\", \\"delete 3\\", \\"find_min\\", \\"inorder\\" ]) [3, 7, 1, [3, 5, 7], 5, [5, 7]] >>> process_bst_operations([\\"insert 8\\", \\"find_min\\", \\"find_max\\"]) [8, 8] bst = BST() results = [] for op in operations: if op.startswith(\\"insert\\"): _, value = op.split() bst.insert(int(value)) elif op.startswith(\\"delete\\"): _, value = op.split() bst.delete(int(value)) elif op == \\"find_min\\": results.append(bst.find_min()) elif op == \\"find_max\\": results.append(bst.find_max()) elif op == \\"find_height\\": results.append(bst.find_height()) elif op == \\"inorder\\": results.append(bst.inorder()) return results","solution":"class TreeNode: def __init__(self, key): self.left = None self.right = None self.val = key class BST: def __init__(self): self.root = None def insert(self, key): if self.root is None: self.root = TreeNode(key) else: self._insert(self.root, key) def _insert(self, root, key): if key < root.val: if root.left is None: root.left = TreeNode(key) else: self._insert(root.left, key) elif key > root.val: if root.right is None: root.right = TreeNode(key) else: self._insert(root.right, key) def delete(self, key): self.root = self._delete(self.root, key) def _delete(self, root, key): if root is None: return root if key < root.val: root.left = self._delete(root.left, key) elif key > root.val: root.right = self._delete(root.right, key) else: if root.left is None: return root.right elif root.right is None: return root.left temp_val = self._min_value_node(root.right).val root.val = temp_val root.right = self._delete(root.right, temp_val) return root def find_min(self): min_node = self._min_value_node(self.root) return min_node.val if min_node else None def _min_value_node(self, root): current = root while current and current.left: current = current.left return current def find_max(self): max_node = self._max_value_node(self.root) return max_node.val if max_node else None def _max_value_node(self, root): current = root while current and current.right: current = current.right return current def find_height(self): return self._find_height(self.root) def _find_height(self, root): if root is None: return -1 left_height = self._find_height(root.left) right_height = self._find_height(root.right) return 1 + max(left_height, right_height) def inorder(self): return self._inorder_traversal(self.root) def _inorder_traversal(self, root): return self._inorder_traversal(root.left) + [root.val] + self._inorder_traversal(root.right) if root else [] def process_bst_operations(operations): bst = BST() results = [] for op in operations: if op.startswith(\\"insert\\"): _, value = op.split() bst.insert(int(value)) elif op.startswith(\\"delete\\"): _, value = op.split() bst.delete(int(value)) elif op == \\"find_min\\": results.append(bst.find_min()) elif op == \\"find_max\\": results.append(bst.find_max()) elif op == \\"find_height\\": results.append(bst.find_height()) elif op == \\"inorder\\": results.append(bst.inorder()) return results"},{"question":"def count_occurrences(list1: list, list2: list) -> dict: Returns a dictionary where the keys are elements from list2 and the values are the counts of these elements in list1. >>> count_occurrences([1, 3, 2, 3, 2, 1], [1, 2, 4]) == {1: 2, 2: 2, 4: 0} >>> count_occurrences([], [1, 2, 3]) == {1: 0, 2: 0, 3: 0} >>> count_occurrences([1, 2, 3], []) == {} >>> count_occurrences([], []) == {} >>> count_occurrences([1, 2, 3], [4, 5, 6]) == {4: 0, 5: 0, 6: 0} >>> count_occurrences([1, 2, 1, 2, 1, 2], [1, 2]) == {1: 3, 2: 3}","solution":"def count_occurrences(list1: list, list2: list) -> dict: Returns a dictionary where the keys are elements from list2 and the values are the counts of these elements in list1. counts = {elem: 0 for elem in list2} for elem in list1: if elem in counts: counts[elem] += 1 return counts"},{"question":"def count_unique_characters(strings: List[str]) -> List[int]: Returns a list of counts of unique characters in each string. >>> count_unique_characters([\\"abcabc\\", \\"abcdef\\"]) [0, 6] >>> count_unique_characters([\\"aabbcc\\", \\"zzz\\", \\"eeffee\\"]) [0, 0, 0] >>> count_unique_characters([\\"a\\", \\"abcd\\", \\"xyz\\"]) [1, 4, 3] >>> count_unique_characters([\\"aabbccdd\\", \\"abcdabcd\\", \\"aabbccddeeff\\"]) [0, 0, 0] >>> count_unique_characters([\\"a\\" * 1000000, \\"abcdefg\\" * 142857]) [0, 0]","solution":"def count_unique_characters(strings): Returns a list of counts of unique characters in each string. results = [] for s in strings: char_count = {} for char in s: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 unique_count = sum(1 for v in char_count.values() if v == 1) results.append(unique_count) return results"},{"question":"def subtree_sums(n, values, edges, queries): Compute the sum of values in the subtree of a given vertex for each query. Parameters: n (int): Number of vertices. values (List[int]): Values associated with each vertex. edges (List[Tuple[int, int]]): Edges forming the tree. queries (List[int]): Queries to be processed. Returns: List[int]: Sum of values in the subtree of the given vertex for each query. Example: >>> subtree_sums(5, [1, 2, 3, 4, 5], [(1, 2), (1, 3), (2, 4), (2, 5)], [1, 2, 4]) [15, 11, 4] >>> subtree_sums(2, [1, 2], [(1, 2)], [1, 2]) [3, 2]","solution":"def subtree_sums(n, values, edges, queries): from collections import defaultdict, deque # Create adjacency list for the tree tree = defaultdict(list) for u, v in edges: tree[u].append(v) tree[v].append(u) # Helper function to perform DFS and calculate subtree sums def dfs(node, parent): subtree_sum = values[node - 1] for neighbor in tree[node]: if neighbor != parent: subtree_sum += dfs(neighbor, node) subtree_sums[node] = subtree_sum return subtree_sum # Dictionary to store the subtree sum for each node subtree_sums = {} # Start DFS from the root (vertex 1) dfs(1, -1) # Process each query and return the result return [subtree_sums[x] for x in queries]"},{"question":"def find_common_gemstones(T: int, cases: List[Tuple[int, List[str]]]) -> List[str]: Find the types of gemstones common across all family members' collections. Args: T (int): The number of test cases. cases (List[Tuple[int, List[str]]]): A list of tuples, where each tuple represents a test case with the number of family members and their gemstone collections. Returns: List[str]: A list of strings representing the common types of gemstones in lexicographical order for each test case. If there are no common gemstones, the string will be empty. Example: >>> find_common_gemstones(2, [[3, ['abc', 'ab', 'bc']], [2, ['def', 'cf']]]) ['b', 'f']","solution":"def find_common_gemstones(T, cases): results = [] for i in range(T): N = cases[i][0] collections = cases[i][1] # Use set intersection to find common gemstones common_gemstones = set(collections[0]) for collection in collections[1:]: common_gemstones &= set(collection) results.append(''.join(sorted(common_gemstones))) return results # Example function call # find_common_gemstones(2, [[3, ['abc', 'ab', 'bc']], [2, ['def', 'cf']]])"},{"question":"from typing import List def min_steps_to_reach_end(H: int, W: int, grid: List[str]) -> int: Determine the minimum number of steps required to reach the bottom-right corner from the top-left corner of a grid, avoiding obstacles. Args: H (int): The number of rows in the grid. W (int): The number of columns in the grid. grid (List[str]): The grid representation, where each string is a row of the grid and each character is either '.' (empty) or '#' (obstacle). Returns: int: The minimum number of steps to reach the bottom-right corner, or -1 if it is impossible. Examples: >>> min_steps_to_reach_end(3, 4, [\\"....\\", \\"..\\", \\"....\\"]) 5 >>> min_steps_to_reach_end(3, 3, [\\".#.\\", \\"#\\", \\".#.\\"]) -1","solution":"from collections import deque def min_steps_to_reach_end(H, W, grid): directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] if grid[0][0] == '#' or grid[H-1][W-1] == '#': return -1 visited = [[False] * W for _ in range(H)] queue = deque([(0, 0, 0)]) # (row, column, step_count) visited[0][0] = True while queue: r, c, steps = queue.popleft() if r == H-1 and c == W-1: return steps for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < H and 0 <= nc < W and not visited[nr][nc] and grid[nr][nc] == '.': visited[nr][nc] = True queue.append((nr, nc, steps + 1)) return -1"},{"question":"from collections import deque from typing import List, Tuple def min_steps(maze: List[str], start: Tuple[int, int], goal: Tuple[int, int]) -> int: Find the minimum number of steps required to reach the goal in the maze. If it is impossible, return -1. >>> min_steps([\\".....\\", \\".#.\\", \\".#.#.\\", \\".#...\\", \\".....\\"], (0, 0), (4, 4)) 8 >>> min_steps([\\"#\\", \\"#...#\\", \\"#.#\\", \\"#.#.#\\", \\"#\\"], (0, 1), (3, 3)) -1 >>> min_steps([\\"..\\", \\"..\\"], (0, 0), (1, 1)) 2 >>> min_steps([\\"..\\", \\".#\\"], (0, 0), (1, 1)) -1 def process_input(input_str: str) -> List[int]: Process the input string and return a list of results indicating the minimum number of steps for each dataset. >>> process_input(\\"5 5n.....n.#.n.#.#.n.#...n.....n0 0 4 4n5 5n#n#...#n#.#n#.#.#n#n0 1 3 3n0 0n\\") [8, -1] >>> process_input(\\"2 2n..n..n0 0 1 1n0 0n\\") [2]","solution":"from collections import deque def min_steps(maze, start, goal): R, C = len(maze), len(maze[0]) Sx, Sy = start Gx, Gy = goal directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] queue = deque([(Sx, Sy, 0)]) # (current_x, current_y, current_steps) visited = set() visited.add((Sx, Sy)) while queue: x, y, steps = queue.popleft() if (x, y) == (Gx, Gy): return steps for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < R and 0 <= ny < C and maze[nx][ny] == '.' and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny, steps + 1)) return -1 def process_input(input_str): lines = input_str.strip().split('n') index = 0 results = [] while index < len(lines): R, C = map(int, lines[index].split()) if R == 0 and C == 0: break maze = [] for i in range(R): maze.append(lines[index + 1 + i]) Sx, Sy, Gx, Gy = map(int, lines[index + 1 + R].split()) results.append(min_steps(maze, (Sx, Sy), (Gx, Gy))) index += R + 2 return results"},{"question":"from typing import List def max_contiguous_sum_with_limit(weights: List[int], limit: int) -> int: Finds the maximum possible sum of any contiguous subsequence of weights that does not exceed the limit. Args: weights: List of integers representing weights of scepters. limit: Integer representing the maximum allowed weight sum. Returns: Integer representing the maximum sum of any contiguous subsequence of weights that does not exceed the limit. Example Usage: >>> max_contiguous_sum_with_limit([1, 2, 10, 7, 5, 3, 2, 8], 15) 15 >>> max_contiguous_sum_with_limit([1, 2, 3, 4, 5], 5) 5 >>> max_contiguous_sum_with_limit([2, 4, 2, 2, 1], 4) 4","solution":"def max_contiguous_sum_with_limit(weights, limit): Finds the maximum possible sum of any contiguous subsequence of weights that does not exceed the limit. max_sum = current_sum = 0 left = 0 for right in range(len(weights)): current_sum += weights[right] while current_sum > limit and left <= right: current_sum -= weights[left] left += 1 max_sum = max(max_sum, current_sum) return max_sum # Example usage: # N, W = 8, 15 # weights = [1, 2, 10, 7, 5, 3, 2, 8] # print(max_contiguous_sum_with_limit(weights, W)) # Output: 15"},{"question":"def calculate_course_averages(M: int, P: int, grades: List[List[int]]) -> List[float]: Calculates the average grade for each course. Parameters: - M: int, number of courses - P: int, number of students per course - grades: list of list of int, grades of students for each course Returns: - list of float, average grades for each course rounded to two decimal places pass # Function to read input and produce output def main(): import sys input = sys.stdin.read data = input().strip().split() M = int(data[0]) P = int(data[1]) grades = [] index = 2 for i in range(M): course_grades = list(map(int, data[index:index+P])) grades.append(course_grades) index += P averages = calculate_course_averages(M, P, grades) for average in averages: print(f\\"{average:.2f}\\") import sys from typing import List # Tests def test_calculate_course_averages_example1(): M = 3 P = 4 grades = [ [100, 90, 80, 70], [85, 95, 75, 65], [60, 70, 80, 90] ] result = calculate_course_averages(M, P, grades) assert result == [85.00, 80.00, 75.00] def test_calculate_course_averages_example2(): M = 2 P = 2 grades = [ [50, 40], [60, 70] ] result = calculate_course_averages(M, P, grades) assert result == [45.00, 65.00] def test_calculate_course_averages_single_course(): M = 1 P = 5 grades = [ [10, 20, 30, 40, 50] ] result = calculate_course_averages(M, P, grades) assert result == [30.00] def test_calculate_course_averages_min_values(): M = 1 P = 1 grades = [ [0] ] result = calculate_course_averages(M, P, grades) assert result == [0.00] def test_calculate_course_averages_max_values(): M = 100 P = 100 grades = [[100] * 100 for _ in range(100)] result = calculate_course_averages(M, P, grades) assert result == [100.00] * 100","solution":"def calculate_course_averages(M, P, grades): Calculates the average grade for each course. Parameters: - M: int, number of courses - P: int, number of students per course - grades: list of list of int, grades of students for each course Returns: - list of float, average grades for each course rounded to two decimal places averages = [] for i in range(M): course_grades = grades[i] average = sum(course_grades) / P averages.append(round(average, 2)) return averages # Function to read input and produce output def main(): import sys input = sys.stdin.read data = input().strip().split() M = int(data[0]) P = int(data[1]) grades = [] index = 2 for i in range(M): course_grades = list(map(int, data[index:index+P])) grades.append(course_grades) index += P averages = calculate_course_averages(M, P, grades) for average in averages: print(f\\"{average:.2f}\\")"},{"question":"def is_valid_number_sculpture(n, sequence): Determines if the given sequence forms a valid Number Sculpture. Parameters: n (int): Size of the sequence sequence (list of int): The sequence of numbers Returns: str: \\"YES\\" if the sequence is a valid Number Sculpture, \\"NO\\" otherwise. pass def analyze_number_sculptures(test_cases): Analyze multiple test cases to determine if each sequence forms a valid Number Sculpture. Parameters: test_cases (list of tuples): A list of tuples where each tuple contains the size of the sequence and the sequence itself. Returns: list of str: A list of \\"YES\\" or \\"NO\\" for each test case. pass # Unit tests def test_is_valid_number_sculpture(): assert is_valid_number_sculpture(4, [1, 3, 2, 4]) == \\"YES\\" assert is_valid_number_sculpture(3, [3, 2, 1]) == \\"NO\\" assert is_valid_number_sculpture(5, [5, 1, 9, 3, 8]) == \\"YES\\" assert is_valid_number_sculpture(3, [5, 7, 6]) == \\"YES\\" assert is_valid_number_sculpture(3, [3, 6, 9]) == \\"NO\\" def test_analyze_number_sculptures(): test_cases = [ (4, [1, 3, 2, 4]), (3, [3, 2, 1]), (5, [5, 1, 9, 3, 8]) ] expected_results = [\\"YES\\", \\"NO\\", \\"YES\\"] assert analyze_number_sculptures(test_cases) == expected_results test_cases = [ (3, [5, 7, 6]), (3, [3, 6, 9]) ] expected_results = [\\"YES\\", \\"NO\\"] assert analyze_number_sculptures(test_cases) == expected_results def test_edge_cases(): assert is_valid_number_sculpture(2, [1, 2]) == \\"YES\\" assert is_valid_number_sculpture(2, [2, 1]) == \\"YES\\" assert is_valid_number_sculpture(3, [1, 10, 1]) == \\"YES\\" assert is_valid_number_sculpture(4, [1, 2, 3, 2]) == \\"NO\\"","solution":"def is_valid_number_sculpture(n, sequence): Determines if the given sequence forms a valid Number Sculpture. Parameters: n (int): Size of the sequence sequence (list of int): The sequence of numbers Returns: str: \\"YES\\" if the sequence is a valid Number Sculpture, \\"NO\\" otherwise. for i in range(1, n - 1): if not ((sequence[i-1] < sequence[i] > sequence[i+1]) or (sequence[i-1] > sequence[i] < sequence[i+1])): return \\"NO\\" return \\"YES\\" def analyze_number_sculptures(test_cases): Analyze multiple test cases to determine if each sequence forms a valid Number Sculpture. Parameters: test_cases (list of tuples): A list of tuples where each tuple contains the size of the sequence and the sequence itself. Returns: list of str: A list of \\"YES\\" or \\"NO\\" for each test case. results = [] for n, sequence in test_cases: results.append(is_valid_number_sculpture(n, sequence)) return results"},{"question":"def max_days(k: int) -> int: Given the maximum card number k in the deck, returns the highest number of days Alice can continue playing the game. >>> max_days(10) 10 >>> max_days(2) 2 >>> max_days(1) 1","solution":"def max_days(k): Given the maximum card number k in the deck, returns the highest number of days Alice can continue playing the game. return k"},{"question":"def preprocess_prefix_sums(arr): Preprocesses the array to calculate prefix sums. pass def subarray_sum(prefix_sums, l, r): Returns the sum of the subarray from index l to r (1-based index). pass def solve(n, m, arr, queries): Processes all the queries to find the sum of each subarray. def test_preprocess_prefix_sums(): arr = [1, 2, 3, 4, 5] expected_prefix_sums = [0, 1, 3, 6, 10, 15] assert preprocess_prefix_sums(arr) == expected_prefix_sums def test_subarray_sum(): prefix_sums = [0, 1, 3, 6, 10, 15] assert subarray_sum(prefix_sums, 1, 3) == 6 assert subarray_sum(prefix_sums, 2, 4) == 9 assert subarray_sum(prefix_sums, 1, 5) == 15 def test_solve(): n = 5 m = 3 arr = [1, 2, 3, 4, 5] queries = [(1, 3), (2, 4), (1, 5)] expected_results = [6, 9, 15] assert solve(n, m, arr, queries) == expected_results def test_solve_with_negative_numbers(): n = 5 m = 3 arr = [-1, -2, -3, -4, -5] queries = [(1, 3), (2, 4), (1, 5)] expected_results = [-6, -9, -15] assert solve(n, m, arr, queries) == expected_results def test_solve_with_mixed_numbers(): n = 5 m = 2 arr = [-1, 2, -3, 4, -5] queries = [(1, 5), (2, 4)] expected_results = [-3, 3] assert solve(n, m, arr, queries) == expected_results def test_solve_single_element(): n = 1 m = 1 arr = [5] queries = [(1, 1)] expected_result = [5] assert solve(n, m, arr, queries) == expected_result","solution":"def preprocess_prefix_sums(arr): Preprocesses the array to calculate prefix sums. n = len(arr) prefix_sums = [0] * (n + 1) for i in range(n): prefix_sums[i + 1] = prefix_sums[i] + arr[i] return prefix_sums def subarray_sum(prefix_sums, l, r): Returns the sum of the subarray from index l to r (1-based index). return prefix_sums[r] - prefix_sums[l - 1] def solve(n, m, arr, queries): Processes all the queries to find the sum of each subarray. prefix_sums = preprocess_prefix_sums(arr) results = [] for l, r in queries: results.append(subarray_sum(prefix_sums, l, r)) return results"},{"question":"def are_files_identical(file1: str, file2: str, block_size: int) -> bool: Compare two files block by block to determine if they are identical. Args: file1 (str): The content of the first file. file2 (str): The content of the second file. block_size (int): The size of each block to divide the files into for the comparison. Returns: bool: True if the files are identical, False otherwise. Example: >>> are_files_identical(\\"abcdefghij\\", \\"abcdefghij\\", 5) True >>> are_files_identical(\\"abcdefghij\\", \\"abcdefghik\\", 5) False >>> are_files_identical(\\"abcdefghij\\", \\"abcdefghij\\", 3) True >>> are_files_identical(\\"abcdefghijk\\", \\"abcdefghij\\", 4) False pass","solution":"def are_files_identical(file1: str, file2: str, block_size: int) -> bool: Compare two files block by block to determine if they are identical. Args: file1 (str): The content of the first file. file2 (str): The content of the second file. block_size (int): The size of each block to divide the files into for the comparison. Returns: bool: True if the files are identical, False otherwise. # If the lengths of the files are different, they can't be identical if len(file1) != len(file2): return False # Loop through the files block by block for i in range(0, len(file1), block_size): # Compare each block if file1[i:i+block_size] != file2[i:i+block_size]: return False # If all blocks are equal, the files are identical return True"},{"question":"def temperature_anomaly_index(n: int, temperatures: List[int]) -> float: Calculate and print the Temperature Anomaly Index for the given temperature readings. The Temperature Anomaly Index (TAI) is defined as the sum of the differences between each day's temperature and the average temperature, divided by the total number of days. Args: n: An integer representing the number of temperature readings. temperatures: A list of integers representing the daily temperature readings. Returns: A floating point number representing the Temperature Anomaly Index, rounded to six decimal places. Examples: >>> temperature_anomaly_index(5, [3, 7, 8, 10, 2]) 0.000000 >>> temperature_anomaly_index(4, [20, 15, 10, 5]) 0.000000","solution":"def temperature_anomaly_index(n, temperatures): average_temp = sum(temperatures) / n anomaly_sum = sum(t - average_temp for t in temperatures) tai = anomaly_sum / n return round(tai, 6)"},{"question":"def minimize_sum_of_absolute_differences(H: int, W: int, grid: List[List[int]]) -> int: This function takes the height (H) and width (W) of a grid and the grid itself as input and returns the minimum possible sum of the absolute differences between adjacent cells after making zero or more changes to the grid values. >>> minimize_sum_of_absolute_differences(2, 3, [[1, 5, 3], [4, 8, 6]]) 0 >>> minimize_sum_of_absolute_differences(3, 3, [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) 0 >>> minimize_sum_of_absolute_differences(2, 2, [[1, 0], [0, 1]]) 0 >>> minimize_sum_of_absolute_differences(1, 1, [[42]]) 0 >>> minimize_sum_of_absolute_differences(2, 3, [[7, 7, 7], [7, 7, 7]]) 0","solution":"def minimize_sum_of_absolute_differences(H, W, grid): This function takes the height (H) and width (W) of a grid and the grid itself as input and returns the minimum possible sum of the absolute differences between adjacent cells after making zero or more changes to the grid values. # Since we can change all cells to any value, the minimum difference is obtained # by setting all cells to the same value. Thus the minimum sum of absolute differences # between adjacent cells will always be 0. return 0"},{"question":"def min_max_time(n: int, tasks: List[int]) -> int: Returns the minimum possible time the longest working developer will take to finish all their tasks. >>> min_max_time(3, [8, 3, 5, 7]) 8 >>> min_max_time(2, [1, 2, 3, 4]) 6","solution":"def min_max_time(n, tasks): Returns the minimum possible time the longest working developer will take to finish all their tasks. if n >= len(tasks): return max(tasks) def can_complete_in_time(mid): required_developers = 1 current_sum = 0 for task in tasks: if current_sum + task <= mid: current_sum += task else: required_developers += 1 current_sum = task if required_developers > n: return False return True low, high = max(tasks), sum(tasks) while low < high: mid = (low + high) // 2 if can_complete_in_time(mid): high = mid else: low = mid + 1 return low"},{"question":"from typing import List, Tuple def min_max_sum(arr: List[int]) -> Tuple[int, int]: Given a list of positive integers, returns the minimum and maximum sums obtainable by summing all but one of the integers. Args: arr (List[int]): List of positive integers Returns: Tuple[int, int]: A tuple containing the minimum sum and maximum sum Examples: >>> min_max_sum([1, 2, 3, 4, 5]) (10, 14) >>> min_max_sum([1, 2]) (1, 2) pass def test_min_max_sum_example_case(): assert min_max_sum([1, 2, 3, 4, 5]) == (10, 14) def test_min_max_sum_two_elements(): assert min_max_sum([1, 2]) == (1, 2) def test_min_max_sum_identical_elements(): assert min_max_sum([3, 3, 3, 3, 3]) == (12, 12) def test_min_max_sum_large_numbers(): assert min_max_sum([1000000, 1000000, 1000000, 1000000, 999999]) == (3999999, 4000000) def test_min_max_sum_mixed_numbers(): assert min_max_sum([10, 20, 30, 40, 50]) == (100, 140)","solution":"def min_max_sum(arr): Given a list of positive integers, returns the minimum and maximum sums obtainable by summing all but one of the integers. total_sum = sum(arr) min_sum = total_sum - max(arr) max_sum = total_sum - min(arr) return min_sum, max_sum"},{"question":"def is_beautiful(s: str) -> str: Determine if the string s is beautiful based on the given conditions. The string is considered beautiful if at least one of the following conditions is met: 1. All letters in the string are vowels (a, e, i, o, u, A, E, I, O, U). 2. The string is a palindrome (it reads the same forward and backward). 3. The string contains both lowercase and uppercase letters. Args: s (str): Input string to check for beauty. Returns: str: \\"Beautiful\\" if the string is beautiful, \\"Not Beautiful\\" otherwise. Examples: >>> is_beautiful(\\"aEi\\") \\"Beautiful\\" >>> is_beautiful(\\"radar\\") \\"Beautiful\\" >>> is_beautiful(\\"HELLO\\") \\"Not Beautiful\\"","solution":"def is_beautiful(s): Determine if the string s is beautiful based on the given conditions. vowels = set('aeiouAEIOU') # Check if all characters are vowels if all(char in vowels for char in s): return \\"Beautiful\\" # Check if the string is a palindrome if s == s[::-1]: return \\"Beautiful\\" # Check if the string contains both lowercase and uppercase letters has_lowercase = any(char.islower() for char in s) has_uppercase = any(char.isupper() for char in s) if has_lowercase and has_uppercase: return \\"Beautiful\\" return \\"Not Beautiful\\""},{"question":"def max_sum_no_consecutive(arr) -> int: Returns the maximum sum of any non-empty subarray such that no two consecutive elements are included. >>> max_sum_no_consecutive([1, 2, 3, 4, 5]) == 9 >>> max_sum_no_consecutive([10, 3, 4]) == 14 >>> max_sum_no_consecutive([5]) == 5 >>> max_sum_no_consecutive([5, 10]) == 10 >>> max_sum_no_consecutive([5, 5, 5, 5, 5]) == 15 >>> max_sum_no_consecutive([1000, 2000, 3000, 4000, 5000]) == 9000 >>> max_sum_no_consecutive([1000, 1, 1000, 1, 1000]) == 3000","solution":"def max_sum_no_consecutive(arr): Returns the maximum sum of any non-empty subarray such that no two consecutive elements are included. n = len(arr) if n == 0: return 0 if n == 1: return arr[0] # dp[i] will store the maximum sum possible considering arr[0] ... arr[i] dp = [0] * n # Base cases dp[0] = arr[0] if n > 1: dp[1] = max(arr[0], arr[1]) # Fill the dp array for i in range(2, n): dp[i] = max(dp[i-1], arr[i] + dp[i-2]) return dp[n-1]"},{"question":"def has_triplet_with_zero_sum(arr: List[int]) -> str: Check if there exists three different indices i, j, and k such that arr[i] + arr[j] + arr[k] == 0. >>> has_triplet_with_zero_sum([-1, 0, 1, 2, -1]) == \\"YES\\" >>> has_triplet_with_zero_sum([1, 2, 3, 4]) == \\"NO\\" pass def process_test_cases(test_cases: List[List[int]]) -> List[str]: Processes multiple test cases to determine if a triplet sums to zero exists. >>> test_cases = [ [-1, 0, 1, 2, -1], [1, 2, 3, 4], [-8, -3, 1, 2, 3, 5], [3, -1, -2, -3, 5] ] >>> process_test_cases(test_cases) == [\\"YES\\", \\"NO\\", \\"YES\\", \\"YES\\"] pass","solution":"def has_triplet_with_zero_sum(arr): This function checks if there exists three different indices i, j, and k such that arr[i] + arr[j] + arr[k] == 0. If such a triplet exists, it returns \\"YES\\", otherwise \\"NO\\". arr.sort() n = len(arr) for i in range(n - 2): left = i + 1 right = n - 1 while left < right: sum = arr[i] + arr[left] + arr[right] if sum == 0: return \\"YES\\" elif sum < 0: left += 1 else: right -= 1 return \\"NO\\" def process_test_cases(test_cases): results = [] for arr in test_cases: results.append(has_triplet_with_zero_sum(arr)) return results"},{"question":"from typing import List, Tuple class Graph: def __init__(self, n: int): self.n = n def add_edge(self, u: int, v: int) -> None: pass def remove_edge(self, u: int, v: int) -> None: pass def has_path(self, u: int, v: int) -> bool: pass def process_queries(n: int, m: int, q: int, initial_edges: List[Tuple[int, int]], queries: List[Tuple[int, int, int]]) -> List[str]: Given an undirected graph with n nodes and m edges, process a list of queries to add/remove edges or check if there is a path between nodes, and return the results for path-check queries. >>> process_queries(5, 4, 5, [(1, 2), (2, 3), (3, 4), (4, 5)], [(3, 1, 5), (2, 3, 4), (3, 1, 5), (1, 3, 4), (3, 1, 5)]) [\\"yes\\", \\"no\\", \\"yes\\"] >>> process_queries(3, 0, 3, [], [(1, 1, 2), (3, 1, 3), (1, 2, 3)]) [\\"no\\"] >>> process_queries(1, 0, 1, [], [(3, 1, 1)]) [\\"yes\\"] >>> process_queries(4, 2, 3, [(1, 2), (3, 4)], [(3, 1, 3), (1, 2, 3), (3, 1, 4)]) [\\"no\\", \\"yes\\"] >>> process_queries(4, 3, 4, [(1, 2), (2, 3), (3, 4)], [(2, 2, 3), (3, 1, 4), (1, 2, 3), (3, 1, 4)]) [\\"no\\", \\"yes\\"]","solution":"from collections import defaultdict, deque class Graph: def __init__(self, n): self.n = n self.adj_list = defaultdict(set) def add_edge(self, u, v): self.adj_list[u].add(v) self.adj_list[v].add(u) def remove_edge(self, u, v): if v in self.adj_list[u]: self.adj_list[u].remove(v) if u in self.adj_list[v]: self.adj_list[v].remove(u) def has_path(self, u, v): if u == v: return True visited = set() queue = deque([u]) while queue: node = queue.popleft() if node == v: return True if node not in visited: visited.add(node) for neighbor in self.adj_list[node]: if neighbor not in visited: queue.append(neighbor) return False def process_queries(n, m, q, initial_edges, queries): graph = Graph(n) for u, v in initial_edges: graph.add_edge(u, v) result = [] for query in queries: type_, u, v = query if type_ == 1: graph.add_edge(u, v) elif type_ == 2: graph.remove_edge(u, v) elif type_ == 3: if graph.has_path(u, v): result.append(\\"yes\\") else: result.append(\\"no\\") return result"},{"question":"def min_total_pressure(N: int, balloon_pressures: List[int]) -> int: Given N is the number of balloons and balloon_pressures is a list of required pressures to burst each balloon, returns the minimum value of the total pressure required. pass from typing import List def test_single_balloon(): assert min_total_pressure(1, [5]) == 5 def test_all_same_pressure(): assert min_total_pressure(3, [1, 1, 1]) == 6 def test_descending_order(): assert min_total_pressure(5, [5, 4, 3, 2, 1]) == 35 def test_mixed_pressures(): assert min_total_pressure(5, [4, 2, 3, 1, 5]) == 35 def test_already_sorted(): assert min_total_pressure(3, [1, 2, 3]) == 10","solution":"def min_total_pressure(N, balloon_pressures): Given N is the number of balloons and balloon_pressures is a list of required pressures to burst each balloon, returns the minimum value of the total pressure required. # Sort balloon pressures in ascending order to minimize the cumulative pressure balloon_pressures.sort() total_pressure = 0 cumulative_pressure = 0 for pressure in balloon_pressures: cumulative_pressure += pressure total_pressure += cumulative_pressure return total_pressure"},{"question":"def largest_sum_of_k_distinct_elements(n: int, k: int, arr: List[int]) -> int: Determine the largest sum of distinct integers that can be formed by selecting exactly K elements from the array. If it is not possible to select exactly K distinct elements, return -1. >>> largest_sum_of_k_distinct_elements(5, 3, [1, 2, 2, 3, 4]) 9 >>> largest_sum_of_k_distinct_elements(4, 4, [1, 1, 1, 1]) -1 from solution import largest_sum_of_k_distinct_elements def test_largest_sum_of_k_distinct_elements_example_1(): assert largest_sum_of_k_distinct_elements(5, 3, [1, 2, 2, 3, 4]) == 9 def test_largest_sum_of_k_distinct_elements_example_2(): assert largest_sum_of_k_distinct_elements(4, 4, [1, 1, 1, 1]) == -1 def test_largest_sum_of_k_distinct_elements_not_enough_distinct(): assert largest_sum_of_k_distinct_elements(6, 5, [5, 5, 5, 5, 6, 7]) == -1 def test_largest_sum_of_k_distinct_elements_just_enough_distinct(): assert largest_sum_of_k_distinct_elements(6, 4, [5, 5, 7, 8, 6, 6]) == 26 def test_largest_sum_of_k_distinct_elements_all_distinct(): assert largest_sum_of_k_distinct_elements(5, 3, [10, 4, 5, 6, 8]) == 24 def test_largest_sum_of_k_distinct_elements_k_equals_1(): assert largest_sum_of_k_distinct_elements(5, 1, [3, 3, 3, 3, 3]) == 3 def test_largest_sum_of_k_distinct_elements_more_complex_case(): assert largest_sum_of_k_distinct_elements(8, 3, [100, 200, 300, 100, 200, 300, 1000]) == 1500 def test_largest_sum_of_k_distinct_elements_single_element_array(): assert largest_sum_of_k_distinct_elements(1, 1, [42]) == 42","solution":"def largest_sum_of_k_distinct_elements(n, k, arr): Returns the largest sum of exactly K distinct integers from the array. If it's not possible to select exactly K distinct elements, returns -1. distinct_elements = list(set(arr)) # get unique elements if len(distinct_elements) < k: return -1 # not enough distinct elements to select K of them distinct_elements.sort(reverse=True) # sort in descending order return sum(distinct_elements[:k])"},{"question":"def generate_special_sequence(n: int) -> list[int]: Generate a special sequence of length n where no two elements sum to a perfect square. >>> generate_special_sequence(3) [1, 3, 8] >>> generate_special_sequence(4) [2, 4, 6, 10] >>> generate_special_sequence(5) [5, 7, 11, 13, 17] def solve(t: int, cases: list[int]) -> list[list[int]]: Solve the problem for multiple test cases. >>> solve(3, [3, 4, 5]) [[1, 3, 8], [2, 4, 6, 10], [5, 7, 11, 13, 17]] def test_generate_special_sequence(): result = generate_special_sequence(3) assert len(result) == 3 assert all([result[i] + result[j] not in [k*k for k in range(1, int((result[i] + result[j])**0.5)+1)] for i in range(len(result)) for j in range(i+1, len(result))]) result = generate_special_sequence(4) assert len(result) == 4 assert all([result[i] + result[j] not in [k*k for k in range(1, int((result[i] + result[j])**0.5)+1)] for i in range(len(result)) for j in range(i+1, len(result))]) result = generate_special_sequence(5) assert len(result) == 5 assert all([result[i] + result[j] not in [k*k for k in range(1, int((result[i] + result[j])**0.5)+1)] for i in range(len(result)) for j in range(i+1, len(result))]) def test_solve(): t = 3 cases = [3, 4, 5] expected_lengths = [3, 4, 5] results = solve(t, cases) for result, length in zip(results, expected_lengths): assert len(result) == length assert all([result[i] + result[j] not in [k*k for k in range(1, int((result[i] + result[j])**0.5)+1)] for i in range(len(result)) for j in range(i+1, len(result))]) t = 1 cases = [10] expected_lengths = [10] results = solve(t, cases) for result, length in zip(results, expected_lengths): assert len(result) == length assert all([result[i] + result[j] not in [k*k for k in range(1, int((result[i] + result[j])**0.5)+1)] for i in range(len(result)) for j in range(i+1, len(result))])","solution":"from math import isqrt def generate_special_sequence(n): sequence = [] current_number = 1 while len(sequence) < n: valid = True for num in sequence: sum_pair = current_number + num root = isqrt(sum_pair) if root * root == sum_pair: valid = False break if valid: sequence.append(current_number) current_number += 1 return sequence def solve(t, cases): results = [] for n in cases: result = generate_special_sequence(n) results.append(result) return results"},{"question":"def int_to_roman(num: int) -> str: Converts an integer to its Roman numeral equivalent. >>> int_to_roman(3) \\"III\\" >>> int_to_roman(58) \\"LVIII\\" >>> int_to_roman(1994) \\"MCMXCIV\\" pass def test_int_to_roman_single_digits(): assert int_to_roman(1) == \\"I\\" assert int_to_roman(4) == \\"IV\\" assert int_to_roman(9) == \\"IX\\" def test_int_to_roman_double_digits(): assert int_to_roman(10) == \\"X\\" assert int_to_roman(40) == \\"XL\\" assert int_to_roman(58) == \\"LVIII\\" assert int_to_roman(90) == \\"XC\\" def test_int_to_roman_triple_digits(): assert int_to_roman(100) == \\"C\\" assert int_to_roman(400) == \\"CD\\" assert int_to_roman(500) == \\"D\\" assert int_to_roman(900) == \\"CM\\" def test_int_to_roman_quadriple_digits(): assert int_to_roman(1000) == \\"M\\" assert int_to_roman(1987) == \\"MCMLXXXVII\\" assert int_to_roman(3999) == \\"MMMCMXCIX\\" def test_int_to_roman_various_numbers(): assert int_to_roman(3) == \\"III\\" assert int_to_roman(44) == \\"XLIV\\" assert int_to_roman(99) == \\"XCIX\\" assert int_to_roman(2021) == \\"MMXXI\\" assert int_to_roman(1994) == \\"MCMXCIV\\"","solution":"def int_to_roman(num: int) -> str: Converts an integer to its Roman numeral equivalent. val = [ 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1 ] syms = [ \\"M\\", \\"CM\\", \\"D\\", \\"CD\\", \\"C\\", \\"XC\\", \\"L\\", \\"XL\\", \\"X\\", \\"IX\\", \\"V\\", \\"IV\\", \\"I\\" ] roman_num = '' i = 0 while num > 0: for _ in range(num // val[i]): roman_num += syms[i] num -= val[i] i += 1 return roman_num"},{"question":"def robot_paths(n: int, m: int, grid: List[List[str]]) -> int: Determine the number of distinct paths the robot can take to reach its destination. >>> robot_paths(3, 3, [['.', '.', '.'], ['.', '#', '.'], ['.', '.', '.']]) 2 >>> robot_paths(2, 2, [['.', '#'], ['#', '.']]) 0","solution":"def robot_paths(n, m, grid): MOD = 10**9 + 7 # Initialize a dp array with zero values dp = [[0] * m for _ in range(n)] # Starting point dp[0][0] = 1 for i in range(n): for j in range(m): if grid[i][j] == '#': dp[i][j] = 0 else: if i > 0: dp[i][j] = (dp[i][j] + dp[i-1][j]) % MOD if j > 0: dp[i][j] = (dp[i][j] + dp[i][j-1]) % MOD return dp[n-1][m-1]"},{"question":"def determine_time_of_day(h: int) -> str: Determine the part of the day given an hour in 24-hour clock format. Parameters: h (int): An integer representing the hour (0 ≤ h ≤ 23). Returns: str: A string representing the part of the day: \\"morning\\", \\"afternoon\\", \\"evening\\", or \\"night\\". >>> determine_time_of_day(10) 'morning' >>> determine_time_of_day(15) 'afternoon' >>> determine_time_of_day(19) 'evening' >>> determine_time_of_day(2) 'night'","solution":"def determine_time_of_day(h): Determine the part of the day given an hour in 24-hour clock format. Parameters: h (int): An integer representing the hour (0 ≤ h ≤ 23). Returns: str: A string representing the part of the day: \\"morning\\", \\"afternoon\\", \\"evening\\", or \\"night\\". if 6 <= h <= 11: return \\"morning\\" elif 12 <= h <= 17: return \\"afternoon\\" elif 18 <= h <= 20: return \\"evening\\" else: return \\"night\\""},{"question":"def count_contiguous_substrings(S: str) -> int: Returns the number of contiguous substrings of S that start and end with the same character. >>> count_contiguous_substrings(\\"abcab\\") 7 >>> count_contiguous_substrings(\\"aaaa\\") 10 def process_multiple_cases(test_cases: List[str]) -> List[int]: Processes multiple test cases and returns the results for each test case. >>> process_multiple_cases([\\"abcab\\", \\"aaaa\\", \\"a\\", \\"abac\\", \\"\\"]) [7, 10, 1, 5, 0] from solution import count_contiguous_substrings, process_multiple_cases def test_single_case_1(): assert count_contiguous_substrings(\\"abcab\\") == 7 def test_single_case_2(): assert count_contiguous_substrings(\\"aaaa\\") == 10 def test_single_case_3(): assert count_contiguous_substrings(\\"a\\") == 1 def test_single_case_4(): assert count_contiguous_substrings(\\"abac\\") == 5 def test_single_case_empty(): assert count_contiguous_substrings(\\"\\") == 0 def test_multiple_cases(): test_cases = [\\"abcab\\", \\"aaaa\\", \\"a\\", \\"abac\\", \\"\\"] expected_output = [7, 10, 1, 5, 0] assert process_multiple_cases(test_cases) == expected_output","solution":"def count_contiguous_substrings(S): Returns the number of contiguous substrings of S that start and end with the same character. n = len(S) count = 0 for i in range(n): j = i while j < n: if S[i] == S[j]: count += 1 j += 1 return count def process_multiple_cases(test_cases): Processes multiple test cases and returns the results for each test case. results = [] for case in test_cases: results.append(count_contiguous_substrings(case)) return results"},{"question":"def can_rearrange(s: str, k: int) -> str: Determines if the string s can be rearranged such that no two adjacent characters are the same and the number of distinct characters in the resulting string is at least k. Args: s (str): The input string consisting of lowercase Latin letters. k (int): The required number of distinct characters in the rearranged string. Returns: str: \\"YES\\" if the rearrangement is possible, otherwise \\"NO\\". Examples: >>> can_rearrange(\\"aabb\\", 2) \\"YES\\" >>> can_rearrange(\\"aaab\\", 2) \\"NO\\" >>> can_rearrange(\\"abcd\\", 4) \\"YES\\" pass def handle_queries(queries: list[tuple[str, int]]) -> list[str]: Handles multiple queries. Args: queries (list[tuple[str, int]]): A list of queries where each query is a tuple of (string, integer). Returns: list[str]: A list of results for each query, either \\"YES\\" or \\"NO\\". Examples: >>> handle_queries([(\\"aabb\\", 2), (\\"aaab\\", 2), (\\"abcd\\", 4)]) [\\"YES\\", \\"NO\\", \\"YES\\"] pass from can_rearrange import can_rearrange, handle_queries def test_single_query_yes(): assert can_rearrange(\\"aabb\\", 2) == \\"YES\\" def test_single_query_no(): assert can_rearrange(\\"aaab\\", 2) == \\"NO\\" def test_single_query_yes_distinct_chars(): assert can_rearrange(\\"abcd\\", 4) == \\"YES\\" def test_single_query_no_rearrange(): assert can_rearrange(\\"aaaa\\", 2) == \\"NO\\" def test_handle_queries_mixed_results(): queries = [ (\\"aabb\\", 2), (\\"aaab\\", 2), (\\"abcd\\", 4) ] results = [\\"YES\\", \\"NO\\", \\"YES\\"] assert handle_queries(queries) == results def test_handle_queries_all_yes(): queries = [ (\\"aabbcc\\", 2), (\\"abcdef\\", 4), (\\"abc\\", 2) ] results = [\\"YES\\", \\"YES\\", \\"YES\\"] assert handle_queries(queries) == results def test_handle_queries_all_no(): queries = [ (\\"aaa\\", 2), (\\"bbbbb\\", 3), (\\"cccccc\\", 2) ] results = [\\"NO\\", \\"NO\\", \\"NO\\"] assert handle_queries(queries) == results def test_single_query_edge_case(): assert can_rearrange(\\"a\\", 1) == \\"YES\\" assert can_rearrange(\\"a\\", 2) == \\"NO\\"","solution":"def can_rearrange(s, k): Determines if the string s can be rearranged such that no two adjacent characters are the same and the number of distinct characters in the resulting string is at least k. from collections import Counter char_count = Counter(s) max_freq = max(char_count.values()) # Check if it is possible to rearrange so that no two adjacent characters are the same if max_freq > (len(s) + 1) // 2: return \\"NO\\" unique_chars = len(char_count) if unique_chars >= k: return \\"YES\\" else: return \\"NO\\" def handle_queries(queries): Handles multiple queries. results = [] for s, k in queries: results.append(can_rearrange(s, k)) return results"},{"question":"def can_form_palindrome(s: str) -> str: Tom is a cryptographer and he deals with different encryption techniques. One day, he encountered an interesting problem: he needs to find out if a given string can be rearranged to form a palindrome. A palindrome is a string that reads the same backward as forward. For example, \\"radar\\" and \\"level\\" are palindromes. Tom needs to automate this process and he asked you to help him by writing a program that checks if the given string can be rearranged to form a palindrome. Args: s: Input string consisting of lowercase English letters. Returns: \\"YES\\" if the string can be rearranged to form a palindrome, otherwise \\"NO\\". Examples: >>> can_form_palindrome(\\"civic\\") \\"YES\\" >>> can_form_palindrome(\\"ivicc\\") \\"YES\\" >>> can_form_palindrome(\\"hello\\") \\"NO\\" # Write your code here. # Unit Tests def test_single_character(): assert can_form_palindrome(\\"a\\") == \\"YES\\" def test_even_length_palindrome(): assert can_form_palindrome(\\"aabbcc\\") == \\"YES\\" def test_odd_length_palindrome(): assert can_form_palindrome(\\"aabbc\\") == \\"YES\\" def test_non_palindrome(): assert can_form_palindrome(\\"abc\\") == \\"NO\\" def test_repeated_characters(): assert can_form_palindrome(\\"aaaabbbbcccc\\") == \\"YES\\" def test_edge_case_empty_string(): assert can_form_palindrome(\\"\\") == \\"YES\\" def test_edge_case_all_same_character(): assert can_form_palindrome(\\"aaaaaaa\\") == \\"YES\\" def test_edge_case_one_odd_among_even(): assert can_form_palindrome(\\"aaabbbb\\") == \\"YES\\" def test_all_unique_characters(): assert can_form_palindrome(\\"abcdefg\\") == \\"NO\\" def test_mixed_case(): assert can_form_palindrome(\\"TactCoa\\") == \\"NO\\" # Note: Case matters, function should assume lowercase only","solution":"def can_form_palindrome(s): Checks if the input string can be rearranged to form a palindrome. A string can be rearranged to form a palindrome if at most one character has an odd frequency. :param s: Input string consisting of lowercase English letters. :return: \\"YES\\" if it can be rearranged to form a palindrome, otherwise \\"NO\\". from collections import Counter count = Counter(s) odd_count = sum(1 for c in count.values() if c % 2 != 0) return \\"YES\\" if odd_count <= 1 else \\"NO\\""},{"question":"def encode_string(s: str) -> str: Encodes a string such that consecutive identical characters are represented by the character followed by the number of times it appears consecutively. Args: s (str): The input string consisting of lowercase English letters. Returns: str: The encoded string. Examples: >>> encode_string(\\"aaaabbbccdaa\\") 'a4b3c2d1a2' >>> encode_string(\\"abcd\\") 'a1b1c1d1' >>> encode_string(\\"zzzzzzzzz\\") 'z9'","solution":"def encode_string(s): Encodes a string such that consecutive identical characters are represented by the character followed by the number of times it appears consecutively. Args: s (str): The input string consisting of lowercase English letters. Returns: str: The encoded string. if not s: return \\"\\" encoded = [] count = 1 previous_char = s[0] for char in s[1:]: if char == previous_char: count += 1 else: encoded.append(f\\"{previous_char}{count}\\") previous_char = char count = 1 encoded.append(f\\"{previous_char}{count}\\") return ''.join(encoded)"},{"question":"def length_of_LIS(heights: List[int]) -> int: Determine the length of the longest strictly increasing subsequence of tree heights. :param heights: List of integers representing tree heights. :return: Length of the longest strictly increasing subsequence. >>> length_of_LIS([10, 22, 9, 33, 21, 50, 41, 60]) 5 >>> length_of_LIS([1, 2, 3, 4, 5]) 5 >>> length_of_LIS([5, 4, 3, 2, 1]) 1 >>> length_of_LIS([]) 0 >>> length_of_LIS([10]) 1","solution":"def length_of_LIS(heights): Determine the length of the longest strictly increasing subsequence of tree heights. :param heights: List of integers representing tree heights. :return: Length of the longest strictly increasing subsequence. if not heights: return 0 n = len(heights) lis = [1] * n for i in range(1, n): for j in range(i): if heights[i] > heights[j]: lis[i] = max(lis[i], lis[j] + 1) return max(lis)"},{"question":"def max_combined_beauty(test_cases): Determines the maximum possible combined beauty from any pair of crystals for each test case. def process_input(input_data): Parses the input data and returns the list of test cases. >>> process_input(\\"2n3n3 1 4n4n10 12 15 10n\\") [[3, 1, 4], [10, 12, 15, 10]] # Example Unit Tests def test_example_cases(): input_data = \\"2n3n3 1 4n4n10 12 15 10n\\" test_cases = process_input(input_data) results = max_combined_beauty(test_cases) expected = [3, 5] assert results == expected def test_single_case_multiple_crystals(): input_data = \\"1n5n8 11 7 2 19n\\" test_cases = process_input(input_data) results = max_combined_beauty(test_cases) expected = [17] assert results == expected def test_identical_beauty_values(): input_data = \\"1n4n5 5 5 5n\\" test_cases = process_input(input_data) results = max_combined_beauty(test_cases) expected = [0] assert results == expected def test_min_max_beauty_values(): input_data = \\"1n3n1 10 1000000000n\\" test_cases = process_input(input_data) results = max_combined_beauty(test_cases) expected = [999999999] assert results == expected def test_multiple_cases_mixed_inputs(): input_data = \\"3n3n2 2 2n4n10 9 8 7n2n1 2n\\" test_cases = process_input(input_data) results = max_combined_beauty(test_cases) expected = [0, 3, 1] assert results == expected","solution":"def max_combined_beauty(test_cases): Determines the maximum possible combined beauty from any pair of crystals for each test case. results = [] for crystals in test_cases: max_beauty = max(crystals) min_beauty = min(crystals) results.append(max_beauty - min_beauty) return results def process_input(input_data): lines = input_data.split(\\"n\\") t = int(lines[0]) index = 1 test_cases = [] for _ in range(t): n = int(lines[index]) index += 1 crystals = list(map(int, lines[index].split())) index += 1 test_cases.append(crystals) return test_cases"},{"question":"def kth_smallest_pair_sum(n: int, k: int, nums: List[int]) -> int: Finds the k-th smallest sum of distinct pairs in a list of numbers. Args: n (int): The number of integers in the list. k (int): The k-th position to find the smallest sum. nums (List[int]): The list of integers. Returns: int: The k-th smallest sum of distinct pairs. >>> kth_smallest_pair_sum(5, 3, [1, 2, 3, 4, 5]) 5 >>> kth_smallest_pair_sum(3, 1, [1, 2, 3]) 3 >>> kth_smallest_pair_sum(6, 15, [10, 20, 30, 40, 50, 60]) 110 >>> kth_smallest_pair_sum(4, 3, [5, 5, 5, 5]) 10 >>> kth_smallest_pair_sum(5, 10, [1, 1, 1, 1, 50]) 51 pass","solution":"def kth_smallest_pair_sum(n, k, nums): Finds the k-th smallest sum of distinct pairs in a list of numbers. sums = [] for i in range(n): for j in range(i + 1, n): sums.append(nums[i] + nums[j]) sums.sort() return sums[k - 1]"},{"question":"def max_valid_pairs(P: int, D: int, ratings: List[int]) -> int: Given a list of player ratings and a maximum allowed difference in ratings, returns the maximum number of valid pairs. Parameters: P (int): Number of players D (int): Maximum allowed difference in ratings within a pair ratings (List[int]): List of player ratings Returns: int: Maximum number of valid pairs Examples: >>> max_valid_pairs(5, 3, [1, 4, 2, 3, 7]) 2 >>> max_valid_pairs(6, 4, [8, 12, 3, 5, 9, 2]) 3 from typing import List def test_example_1(): assert max_valid_pairs(5, 3, [1, 4, 2, 3, 7]) == 2 def test_example_2(): assert max_valid_pairs(6, 4, [8, 12, 3, 5, 9, 2]) == 3 def test_no_pairs_possible(): assert max_valid_pairs(4, 1, [10, 20, 30, 40]) == 0 def test_all_pairs_possible(): assert max_valid_pairs(6, 5, [10, 15, 20, 25, 30, 35]) == 3 def test_single_player(): assert max_valid_pairs(1, 10, [5]) == 0 def test_large_difference_allowed(): assert max_valid_pairs(4, 100, [1, 50, 100, 150]) == 2 def test_edge_min_values(): assert max_valid_pairs(1, 1, [1]) == 0 def test_edge_max_values(): assert max_valid_pairs(2, 10000, [1, 10001]) == 1","solution":"def max_valid_pairs(P, D, ratings): Returns the maximum number of valid pairs given the player ratings and the maximum allowed difference in ratings. ratings.sort() i, j = 0, 1 pairs = 0 while j < P: if ratings[j] - ratings[i] <= D: pairs += 1 i += 2 j += 2 else: i += 1 j = i + 1 return pairs"},{"question":"class NumArray: def __init__(self, nums): # Initialize your data structure here. pass def update(self, i, val): # Update the value at index i to val pass def sumRange(self, l, r): # Sum of elements from index l to r (inclusive) pass def process_operations(N, Q, A, queries): Process the given operations on the array. Args: N (int): The length of the array. Q (int): The number of queries. A (List[int]): The array elements. queries (List[Tuple[int, int, int]]): The list of queries. Returns: List[int]: The result of sum range queries. pass def main(): import sys input = sys.stdin.read data = input().split() N = int(data[0]) Q = int(data[1]) A = list(map(int, data[2:N+2])) queries = [] idx = N + 2 for _ in range(Q): op = int(data[idx]) if op == 1: queries.append((op, int(data[idx+1]), int(data[idx+2]))) idx += 3 elif op == 2: queries.append((op, int(data[idx+1]), int(data[idx+2]))) idx += 3 results = process_operations(N, Q, A, queries) for result in results: print(result)","solution":"class NumArray: def __init__(self, nums): self.n = len(nums) self.tree = [0] * (self.n + 1) self.nums = nums[:] for i in range(self.n): self._update_tree(i + 1, self.nums[i]) def _update_tree(self, i, val): while i <= self.n: self.tree[i] += val i += i & -i def update(self, i, val): diff = val - self.nums[i] self.nums[i] = val self._update_tree(i + 1, diff) def _query_tree(self, i): res = 0 while i > 0: res += self.tree[i] i -= i & -i return res def sumRange(self, l, r): return self._query_tree(r + 1) - self._query_tree(l) def process_operations(N, Q, A, queries): num_array = NumArray(A) results = [] for query in queries: if query[0] == 1: num_array.update(query[1] - 1, query[2]) elif query[0] == 2: results.append(num_array.sumRange(query[1] - 1, query[2] - 1)) return results # Function to read input and call process_operations def main(): import sys input = sys.stdin.read data = input().split() N = int(data[0]) Q = int(data[1]) A = list(map(int, data[2:N+2])) queries = [] idx = N + 2 for _ in range(Q): op = int(data[idx]) if op == 1: queries.append((op, int(data[idx+1]), int(data[idx+2]))) idx += 3 elif op == 2: queries.append((op, int(data[idx+1]), int(data[idx+2]))) idx += 3 results = process_operations(N, Q, A, queries) for result in results: print(result)"},{"question":"def min_cut_palindrome_partition(s: str) -> int: Determine the minimum number of cuts needed to partition the string such that every substring is a palindrome. >>> min_cut_palindrome_partition(\\"aab\\") 1 >>> min_cut_palindrome_partition(\\"racecar\\") 0","solution":"def min_cut_palindrome_partition(s): n = len(s) # Edge case for single character or empty string if n == 0 or n == 1: return 0 # Check if a substring s[i:j+1] is a palindrome def is_palindrome(i, j): while i < j: if s[i] != s[j]: return False i += 1 j -= 1 return True # Create a table to store the minimum cuts for \`s\` cuts = [0] * n for i in range(n): min_cuts = i # Maximum cuts possible is i (cutting each character itself) for j in range(i + 1): if is_palindrome(j, i): min_cuts = 0 if j == 0 else min(min_cuts, cuts[j - 1] + 1) cuts[i] = min_cuts return cuts[-1]"},{"question":"from typing import List def calculate_score(card_inputs: List[str]) -> int: Calculate the total score of a set of cards based on the unique scoring system. Each card has a value and a suit, and the score is calculated as follows: - Numeric values (2 through 10) have the same score as their value. - Face values (J, Q, K, A) have scores 11, 12, 13, and 14 respectively. - Bonus points based on suits: - Hearts (H) multiply the card’s value by 2. - Spades (S) multiply the card’s value by 3. - Diamonds (D) add 5 to the card’s value. - Clubs (C) add no bonus to the card’s value. Example: >>> calculate_score([\\"2 H\\", \\"3 S\\", \\"A D\\", \\"10 C\\", \\"Q H\\"]) 66 >>> calculate_score([\\"5 H\\", \\"Q D\\", \\"9 C\\", \\"A S\\"]) 84 pass def test_calculate_score_example(): card_inputs = [\\"2 H\\", \\"3 S\\", \\"A D\\", \\"10 C\\", \\"Q H\\"] assert calculate_score(card_inputs) == 66 def test_calculate_score_low_values(): card_inputs = [\\"2 C\\", \\"3 D\\", \\"4 H\\", \\"5 S\\"] assert calculate_score(card_inputs) == 2 + (3 + 5) + (4 * 2) + (5 * 3) def test_calculate_score_face_cards(): card_inputs = [\\"J H\\", \\"Q S\\", \\"K D\\", \\"A C\\"] assert calculate_score(card_inputs) == (11 * 2) + (12 * 3) + (13 + 5) + 14 def test_calculate_score_mixed(): card_inputs = [\\"5 H\\", \\"Q D\\", \\"9 C\\", \\"A S\\"] assert calculate_score(card_inputs) == (5 * 2) + (12 + 5) + 9 + (14 * 3) def test_calculate_score_all_clubs(): card_inputs = [\\"2 C\\", \\"3 C\\", \\"4 C\\", \\"5 C\\"] assert calculate_score(card_inputs) == 2 + 3 + 4 + 5 def test_calculate_score_all_same_card(): card_inputs = [\\"A D\\", \\"A D\\", \\"A D\\"] assert calculate_score(card_inputs) == 3 * (14 + 5)","solution":"def calculate_score(card_inputs): value_mapping = {'J': 11, 'Q': 12, 'K': 13, 'A': 14} suit_multipliers = {'H': 2, 'S': 3, 'D': 5, 'C': 0} def score_card(value, suit): if value in value_mapping: card_value = value_mapping[value] else: card_value = int(value) if suit == 'H': return card_value * 2 elif suit == 'S': return card_value * 3 elif suit == 'D': return card_value + 5 elif suit == 'C': return card_value score = 0 for card in card_inputs: value, suit = card.split() score += score_card(value, suit) return score # Example usage: # card_inputs = [\\"2 H\\", \\"3 S\\", \\"A D\\", \\"10 C\\", \\"Q H\\"] # print(calculate_score(card_inputs)) # Output: 66"},{"question":"def find_longest_palindromic_substrings(test_cases: List[str]) -> List[int]: For each string in test_cases, return the length of the longest palindromic substring. >>> find_longest_palindromic_substrings([\\"babad\\", \\"cbbd\\", \\"a\\"]) [3, 2, 1] pass # Implement this function import pytest def test_single_character_string(): assert find_longest_palindromic_substrings([\\"a\\"]) == [1] assert find_longest_palindromic_substrings([\\"z\\"]) == [1] def test_non_palindromic_string(): assert find_longest_palindromic_substrings([\\"abc\\"]) == [1] def test_palindromic_string(): assert find_longest_palindromic_substrings([\\"aaaa\\"]) == [4] def test_mixed_string_cases(): test_cases = [\\"babad\\", \\"cbbd\\", \\"a\\"] expected = [3, 2, 1] assert find_longest_palindromic_substrings(test_cases) == expected def test_multiple_palindromic_substrings(): test_cases = [\\"racecar\\", \\"noon\\", \\"level\\"] expected = [7, 4, 5] assert find_longest_palindromic_substrings(test_cases) == expected def test_all_same_characters(): test_cases = [\\"aaaaa\\"] expected = [5] assert find_longest_palindromic_substrings(test_cases) == expected def test_large_mixed_case(): s = \\"abcdefghhgfedcba\\" assert find_longest_palindromic_substrings([s]) == [16] def test_mixed_characters(): assert find_longest_palindromic_substrings([\\"abacdfgdcaba\\"]) == [3]","solution":"def longest_palindromic_substring_length(s): Returns the length of the longest palindromic substring in s. n = len(s) if n <= 1: return n longest = 1 dp = [[False] * n for _ in range(n)] for i in range(n): dp[i][i] = True for start in range(n - 1, -1, -1): for end in range(start + 1, n): if s[start] == s[end]: if end - start == 1 or dp[start + 1][end - 1]: dp[start][end] = True longest = max(longest, end - start + 1) return longest def find_longest_palindromic_substrings(test_cases): For each string in test_cases, returns the length of the longest palindromic substring. return [longest_palindromic_substring_length(s) for s in test_cases]"},{"question":"def fibonacci_string(n: int) -> str: Given n, returns the last character of the F-string sequence up to F(n). >>> fibonacci_string(0) \\"0\\" >>> fibonacci_string(1) \\"1\\" >>> fibonacci_string(5) \\"1\\" def get_last_character_of_fstrings(t: int, test_cases: List[int]) -> List[str]: Given number of test cases t and list of test cases, Returns the list with the last character of the Fibonacci strings for each case. >>> get_last_character_of_fstrings(1, [0]) [\\"0\\"] >>> get_last_character_of_fstrings(1, [1]) [\\"1\\"] >>> get_last_character_of_fstrings(1, [5]) [\\"1\\"] >>> get_last_character_of_fstrings(3, [0, 1, 5]) [\\"0\\", \\"1\\", \\"1\\"] >>> get_last_character_of_fstrings(1, [30]) [\\"0\\"] >>> get_last_character_of_fstrings(1, [29]) [\\"1\\"]","solution":"def fibonacci_string(n): Given n, returns the F-string sequence up to F(n) and finds the last character. if n == 0: return \\"0\\" elif n == 1: return \\"1\\" f0, f1 = \\"0\\", \\"1\\" for _ in range(2, n + 1): fn = f1 + f0 f0, f1 = f1, fn return fn[-1] def get_last_character_of_fstrings(t, test_cases): Given number of test cases t and list of test cases, Returns the list with the last character of the Fibonacci strings for each case. results = [] for n in test_cases: results.append(fibonacci_string(n)) return results"},{"question":"from typing import List, Tuple def traveling_salesman_problem(distances: List[List[int]]) -> int: Solves the Traveling Salesman Problem for a given distance matrix. >>> traveling_salesman_problem([ [0, 10, 15, 20], [10, 0, 35, 25], [15, 35, 0, 30], [20, 25, 30, 0] ]) == 80 >>> traveling_salesman_problem([ [0, 29, 20], [29, 0, 25], [20, 25, 0] ]) == 74 def solve_tsp(test_cases: List[Tuple[int, List[List[int]]]]) -> List[int]: Solves multiple TSP test cases. >>> solve_tsp([ (4, [ [0, 10, 15, 20], [10, 0, 35, 25], [15, 35, 0, 30], [20, 25, 30, 0] ]), (3, [ [0, 29, 20], [29, 0, 25], [20, 25, 0] ]) ]) == [80, 74]","solution":"import itertools def traveling_salesman_problem(distances): Solves the Traveling Salesman Problem for a given distance matrix. :param distances: A 2D list representing the distances between each pair of points. :returns: The minimum total distance of the shortest route. N = len(distances) min_path = float('inf') for perm in itertools.permutations(range(1, N)): current_path = 0 k = 0 for j in perm: current_path += distances[k][j] k = j current_path += distances[k][0] min_path = min(min_path, current_path) return min_path def solve_tsp(test_cases): Solves multiple TSP test cases. :param test_cases: A list of tuples each containing an integer and a 2D list representing the number of points and their distances. :returns: A list of integers representing the minimum distances for each test case. results = [] for N, distances in test_cases: results.append(traveling_salesman_problem(distances)) return results"},{"question":"def find_matching_indices(n: int, nums: List[int]) -> List[int]: Returns a list of indices in nums where the integer matches the integer at the last index. >>> find_matching_indices(5, [1, 2, 3, 4, 3]) [2, 4] >>> find_matching_indices(3, [5, 7, 5]) [0, 2] >>> find_matching_indices(4, [10, 20, 20, 10]) [0, 3]","solution":"def find_matching_indices(n, nums): Returns a list of indices in nums where the integer matches the integer at the last index. last_value = nums[-1] matching_indices = [i for i, num in enumerate(nums) if num == last_value] return matching_indices"},{"question":"def can_prepare_recipe(ingredients, recipe): Determines if a recipe can be prepared with the available ingredients in the pantry. Parameters: - ingredients (dict): A dictionary with the available quantities of each ingredient. - recipe (dict): A dictionary with the required quantities of each ingredient. Returns: - str: \\"YES\\" if the recipe can be prepared with the available ingredients, \\"NO\\" otherwise. Examples: >>> ingredients = { ... \\"flour\\": 500, ... \\"sugar\\": 200, ... \\"eggs\\": 5, ... \\"milk\\": 1000 ... } >>> recipe = { ... \\"flour\\": 400, ... \\"sugar\\": 100, ... \\"eggs\\": 4, ... \\"milk\\": 500 ... } >>> can_prepare_recipe(ingredients, recipe) \\"YES\\" >>> ingredients = { ... \\"flour\\": 300, ... \\"sugar\\": 150, ... \\"eggs\\": 2, ... \\"milk\\": 750 ... } >>> recipe = { ... \\"flour\\": 350, ... \\"sugar\\": 100, ... \\"eggs\\": 3, ... \\"milk\\": 500 ... } >>> can_prepare_recipe(ingredients, recipe) \\"NO\\"","solution":"def can_prepare_recipe(ingredients, recipe): Determines if a recipe can be prepared with the available ingredients in the pantry. Parameters: - ingredients (dict): A dictionary with the available quantities of each ingredient. - recipe (dict): A dictionary with the required quantities of each ingredient. Returns: - str: \\"YES\\" if the recipe can be prepared with the available ingredients, \\"NO\\" otherwise. for ingredient, required_quantity in recipe.items(): if ingredients.get(ingredient, 0) < required_quantity: return \\"NO\\" return \\"YES\\""},{"question":"def find_circle_sequence(n: int, connections: List[Tuple[int, int]]) -> List[int]: Determine the sequence of friends in the circle using the information provided by each friend regarding their connections. >>> find_circle_sequence(6, [(2, 3), (3, 4), (4, 5), (5, 6), (6, 1), (1, 2)]) [1, 2, 3, 4, 5, 6] >>> find_circle_sequence(4, [(2, 3), (3, 4), (4, 1), (1, 2)]) [1, 2, 3, 4]","solution":"def find_circle_sequence(n, connections): from collections import defaultdict, deque # Building the graph graph = defaultdict(list) for i, (a, b) in enumerate(connections): graph[a].append(b) graph[b].append(a) # Finding starting point for node in graph: if len(graph[node]) == 2: start = node break # Using deque to maintain the sequence sequence = deque([start]) next_node = graph[start][0] prev_node = start while len(sequence) < n: sequence.append(next_node) neighbors = graph[next_node] if neighbors[0] == prev_node: prev_node, next_node = next_node, neighbors[1] else: prev_node, next_node = next_node, neighbors[0] return list(sequence)"},{"question":"def calculate_beauty(n, m, grid): Find the maximum possible beauty of any word that can be formed from the grid. The word can be formed by moving horizontally or vertically from one cell to an adjacent cell. Args: n: Number of rows in the grid m: Number of columns in the grid grid: 2D list representing the grid of characters Returns: An integer representing the maximum possible beauty >>> calculate_beauty(3, 3, [['a', 'b', 'c'], ['d', 'e', 'f'], ['g', 'h', 'i']]) 45 >>> calculate_beauty(2, 2, [['a', 'b'], ['c', 'd']]) 10 >>> calculate_beauty(4, 1, [['d'], ['c'], ['b'], ['a']]) 10","solution":"def calculate_beauty(n, m, grid): # Creating a mapping for character to their position index (1-based) char_positions = {} for i in range(n): for j in range(m): char_positions[grid[i][j]] = (i * m) + j + 1 # Sorting the indices to maximize the beauty sorted_indices = sorted(char_positions.values()) # Summing up the indices max_beauty = sum(sorted_indices) return max_beauty"},{"question":"def max_non_overlapping_events(T: int, cases: list) -> list: Finds the maximum number of non-overlapping events that can be attended. Args: T: int - number of test cases cases: list of tuples, where each tuple represents a test case. Each test case contains (n, events), where: - n: int - number of events - events: list of tuples (start, end): representing the start and end times of the event Returns: list of int - maximum number of non-overlapping events for each test case >>> max_non_overlapping_events(3, [ ... (3, [(1, 2), (2, 3), (3, 4)]), ... (4, [(1, 3), (2, 4), (3, 5), (4, 6)]), ... (5, [(1, 4), (2, 3), (3, 5), (2, 6), (4, 7)]) ... ]) == [3, 2, 2] >>> max_non_overlapping_events(1, [(4, [(1, 3), (2, 4), (3, 5), (4, 6)])]) == [2]","solution":"def max_non_overlapping_events(T, cases): Finds the maximum number of non-overlapping events that can be attended. Args: T: int - number of test cases cases: list of tuples, where each tuple represents a test case. Each test case contains (n, events), where: - n: int - number of events - events: list of tuples (start, end): representing the start and end times of the event Returns: list of int - maximum number of non-overlapping events for each test case results = [] for n, events in cases: # Sort events by their ending time events.sort(key=lambda x: x[1]) # Initialize variables to keep track of the end time of the last added event and count of non-overlapping events last_end_time = 0 count = 0 for start, end in events: if start >= last_end_time: count += 1 last_end_time = end results.append(count) return results"},{"question":"def has_pair_with_sum(arr, x): Determines if there exist two distinct indices i and j such that arr[i] + arr[j] = x. Parameters: arr (list): Array of non-negative integers x (int): Target sum Returns: str: \\"Yes\\" if such a pair exists, \\"No\\" otherwise. >>> has_pair_with_sum([1, 2, 3, 4, 5], 9) 'Yes' >>> has_pair_with_sum([1, 2, 3], 6) 'No' from solution import has_pair_with_sum def test_example1(): assert has_pair_with_sum([1, 2, 3, 4, 5], 9) == \\"Yes\\" def test_example2(): assert has_pair_with_sum([1, 2, 3], 6) == \\"No\\" def test_single_element(): assert has_pair_with_sum([1], 2) == \\"No\\" def test_no_possible_pair(): assert has_pair_with_sum([1, 2, 3, 4, 5], 10) == \\"No\\" def test_positive_case(): assert has_pair_with_sum([0, 0, 0, 1, 6], 6) == \\"Yes\\" def test_another_positive_case(): assert has_pair_with_sum([10, 15, 3, 7], 17) == \\"Yes\\" def test_large_numbers(): assert has_pair_with_sum([500000, 500000], 1000000) == \\"Yes\\" def test_large_array_with_no_pairs(): assert has_pair_with_sum(list(range(100000)), 1000000) == \\"No\\"","solution":"def has_pair_with_sum(arr, x): Determines if there exist two distinct indices i and j such that arr[i] + arr[j] = x. Parameters: arr (list): Array of non-negative integers x (int): Target sum Returns: str: \\"Yes\\" if such a pair exists, \\"No\\" otherwise. seen = set() for num in arr: if x - num in seen: return \\"Yes\\" seen.add(num) return \\"No\\""},{"question":"def longest_equal_positive_negative_subarray(arr): Returns the length of the longest contiguous subarray containing an equal number of positive and negative integers. >>> longest_equal_positive_negative_subarray([1, -1, 2, -2, 3, -3, 4, -4, 5, -5]) == 10 >>> longest_equal_positive_negative_subarray([1, -1, 2, 3, -3]) == 4 >>> longest_equal_positive_negative_subarray([-1, -1, 1, 1, 1, -1]) == 6 >>> longest_equal_positive_negative_subarray([1, 2, 3, 4, 5]) == 0","solution":"def longest_equal_positive_negative_subarray(arr): Returns the length of the longest contiguous subarray containing an equal number of positive and negative integers. max_len = 0 sum_index_map = {0: -1} sum_val = 0 for i, value in enumerate(arr): if value > 0: sum_val += 1 elif value < 0: sum_val -= 1 if sum_val in sum_index_map: max_len = max(max_len, i - sum_index_map[sum_val]) else: sum_index_map[sum_val] = i return max_len"},{"question":"def minimal_lexicographical_string(n: int, s: str) -> str: Returns the minimal lexicographical string by performing the allowed operations. Args: n (int): The length of the string. s (str): The string consisting of only lowercase English letters. Returns: str: The minimal lexicographical string possible after performing the described operations. Examples: >>> minimal_lexicographical_string(5, 'bcdea') 'abcde' >>> minimal_lexicographical_string(4, 'dcba') 'abcd' >>> minimal_lexicographical_string(1, 'a') 'a'","solution":"def minimal_lexicographical_string(n, s): Returns the minimal lexicographical string by performing the allowed operations. return ''.join(sorted(s))"},{"question":"def count_pairs_at_distance_k(n: int, k: int, edges: List[Tuple[int, int]]) -> int: Given a tree with n nodes, find the number of unique pairs (u, v) where u and v are distinct nodes and the distance between u and v is exactly k. >>> count_pairs_at_distance_k(5, 2, [(1, 2), (1, 3), (2, 4), (2, 5)]) == 4 >>> count_pairs_at_distance_k(6, 3, [(1, 2), (1, 3), (2, 4), (2, 5), (5, 6)]) == 4 >>> count_pairs_at_distance_k(2, 1, [(1, 2)]) == 1 >>> count_pairs_at_distance_k(4, 2, [(1, 2), (2, 3), (3, 4)]) == 2 >>> count_pairs_at_distance_k(3, 3, [(1, 2), (2, 3)]) == 0","solution":"def count_pairs_at_distance_k(n, k, edges): from collections import deque, defaultdict def bfs(node): distance = [-1] * (n + 1) queue = deque([(node, 0)]) distance[node] = 0 while queue: current, dist = queue.popleft() for neighbor in tree[current]: if distance[neighbor] == -1: distance[neighbor] = dist + 1 queue.append((neighbor, dist + 1)) return distance tree = defaultdict(list) for u, v in edges: tree[u].append(v) tree[v].append(u) total_pairs = 0 for node in range(1, n + 1): distance = bfs(node) total_pairs += distance.count(k) return total_pairs // 2 # Each pair is counted twice # Example usage: n = 5 k = 2 edges = [(1, 2), (1, 3), (2, 4), (2, 5)] print(count_pairs_at_distance_k(n, k, edges)) # Output: 4"},{"question":"def min_weeks_to_complete_training(n: int, m: int, h: int, durations: List[int]) -> int: Determine the minimum number of weeks required to ensure all recruits complete all the training sessions. :param n: Number of training sessions :param m: Number of recruits :param h: Maximum hours a recruit can train in a week :param durations: List of durations of each training session :return: Minimum number of weeks required >>> min_weeks_to_complete_training(5, 2, 10, [5, 3, 4, 6, 7]) 2 >>> min_weeks_to_complete_training(3, 3, 5, [2, 3, 4]) 1 >>> min_weeks_to_complete_training(1, 1, 1, [1]) 1 >>> min_weeks_to_complete_training(4, 1, 1, [1, 1, 1, 1]) 4 >>> min_weeks_to_complete_training(2, 5, 3, [9, 3, 1]) 1 >>> min_weeks_to_complete_training(5, 2, 5, [1, 1, 1, 1, 1]) 1","solution":"import math def min_weeks_to_complete_training(n, m, h, durations): Determine the minimum number of weeks required to ensure all recruits complete all the training sessions. :param n: Number of training sessions :param m: Number of recruits :param h: Maximum hours a recruit can train in a week :param durations: List of durations of each training session :return: Minimum number of weeks required total_duration = sum(durations) weeks_required = math.ceil(total_duration / (m * h)) return weeks_required"},{"question":"from typing import List def count_subarrays_with_sum(nums: List[int], target: int) -> int: Returns the count of subarrays with sum equal to target. >>> count_subarrays_with_sum([1, 1, 1], 2) 2 >>> count_subarrays_with_sum([5], 5) 1 >>> count_subarrays_with_sum([1], 2) 0 >>> count_subarrays_with_sum([1, 2, 3, 4, 5], 5) 2 >>> count_subarrays_with_sum([-1, -1, 1, 1, 0], 0) 4 >>> count_subarrays_with_sum([1, 2, 3, 4], 10) 1 >>> count_subarrays_with_sum([0, 0, 0, 0], 0) 10 >>> count_subarrays_with_sum([10**5, -10**5, 10**5, -10**5], 0) 4 >>> count_subarrays_with_sum([1, 2, 3, 4], 100) 0","solution":"def count_subarrays_with_sum(nums, target): Returns the count of subarrays with sum equal to target. count = 0 prefix_sum = 0 prefix_sum_count = {0: 1} for num in nums: prefix_sum += num if prefix_sum - target in prefix_sum_count: count += prefix_sum_count[prefix_sum - target] if prefix_sum in prefix_sum_count: prefix_sum_count[prefix_sum] += 1 else: prefix_sum_count[prefix_sum] = 1 return count"},{"question":"from typing import List def shortestPath(grid: List[List[str]]) -> int: Finds the shortest path that collects all treasures and returns to the starting point. The grid is represented by a matrix of characters where: - '.' represents an empty cell, - '#' represents an obstacle, - 'S' represents the starting and ending point, - 'T' represents a cell containing a treasure. Args: grid (List[List[str]]): The grid representing the map. Returns: int: The length of the shortest path to collect all treasures and return to the starting point, or -1 if not possible. Examples: >>> n = 3 >>> m = 4 >>> grid = [ ... \\"S..T\\", ... \\".#..\\", ... \\"..T.\\" ... ] >>> shortestPath(grid) 10 >>> n = 3 >>> m = 3 >>> grid = [ ... \\"S.T\\", ... \\"#\\", ... \\".T.\\" ... ] >>> shortestPath(grid) -1","solution":"from typing import List, Tuple from collections import deque def shortestPath(grid: List[List[str]]) -> int: rows, cols = len(grid), len(grid[0]) # Locate all the positions start = None treasures = [] for r in range(rows): for c in range(cols): if grid[r][c] == 'S': start = (r, c) elif grid[r][c] == 'T': treasures.append((r, c)) # Edge case: No treasures if not treasures: return 0 # Edge case: No start point found if not start: return -1 def bfs(start: Tuple[int, int], target: Tuple[int, int]) -> int: visited = [[False] * cols for _ in range(rows)] queue = deque([(start[0], start[1], 0)]) # (row, col, distance) visited[start[0]][start[1]] = True while queue: r, c, dist = queue.popleft() if (r, c) == target: return dist for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]: nr, nc = r + dr, c + dc if 0 <= nr < rows and 0 <= nc < cols and not visited[nr][nc] and grid[nr][nc] != '#': visited[nr][nc] = True queue.append((nr, nc, dist + 1)) return -1 # Calculate distance from start to all treasures dists = {} elements = [start] + treasures for i in range(len(elements)): for j in range(i + 1, len(elements)): dist = bfs(elements[i], elements[j]) if dist == -1: return -1 dists[(elements[i], elements[j])] = dist dists[(elements[j], elements[i])] = dist # Use TSP to find the shortest path visiting all treasures and returning to start start_idx = 0 all_treasures_idx = range(1, len(elements)) from itertools import permutations min_path_len = float('inf') for perm in permutations(all_treasures_idx): current_path_len = 0 perm = [start_idx] + list(perm) + [start_idx] for i in range(len(perm) - 1): current_path_len += dists[(elements[perm[i]], elements[perm[i+1]])] min_path_len = min(min_path_len, current_path_len) return min_path_len"},{"question":"def max_population_difference(n: int, populations: List[int]) -> int: Returns the maximum population difference between any two cities such that the more populous city is to the right of the less populous city in the array. >>> max_population_difference(6, [3, 1, 4, 8, 7, 2]) 7 >>> max_population_difference(5, [10, 9, 8, 7, 6]) 0 >>> max_population_difference(4, [5, 5, 5, 5]) 0 >>> max_population_difference(4, [1, 2, 3, 4]) 3 >>> max_population_difference(6, [10, 5, 1, 10, 2, 20]) 19 >>> max_population_difference(3, [1, 1000000000, 500000000]) 999999999","solution":"def max_population_difference(n, populations): Returns the maximum population difference between any two cities such that the more populous city is to the right of the less populous city in the array. min_pop = populations[0] max_difference = 0 for i in range(1, n): if populations[i] > min_pop: max_difference = max(max_difference, populations[i] - min_pop) min_pop = min(min_pop, populations[i]) return max_difference"},{"question":"def is_monotonic(arr: List[int]) -> bool: Determines if the given array is monotonic (either increasing or decreasing). Parameters: arr (list): A list of integers Returns: bool: True if the array is monotonic, False otherwise Examples: >>> is_monotonic([1, 2, 2, 3, 4]) True >>> is_monotonic([6, 5, 4, 4, 7]) False","solution":"def is_monotonic(arr): Determines if the given array is monotonic (either increasing or decreasing). Parameters: arr (list): A list of integers Returns: bool: True if the array is monotonic, False otherwise increasing = decreasing = True for i in range(1, len(arr)): if arr[i] < arr[i - 1]: increasing = False if arr[i] > arr[i - 1]: decreasing = False return increasing or decreasing"},{"question":"def distribute_rewards(ratings: List[int]) -> int: Distribute rewards to each employee such that each one gets at least one reward and those with a higher rating get more rewards than their neighbors. >>> distribute_rewards([1, 0, 2]) 5 >>> distribute_rewards([1, 2, 2]) 4 >>> distribute_rewards([4, 6, 4, 5, 6, 2]) 10 from solution import distribute_rewards def test_simple_case(): assert distribute_rewards([1, 0, 2]) == 5 def test_simple_case_with_equals(): assert distribute_rewards([1, 2, 2]) == 4 def test_mixed_case(): assert distribute_rewards([4, 6, 4, 5, 6, 2]) == 10 def test_all_equals(): assert distribute_rewards([3, 3, 3, 3]) == 4 def test_increasing_order(): assert distribute_rewards([1, 2, 3, 4, 5]) == 15 def test_decreasing_order(): assert distribute_rewards([5, 4, 3, 2, 1]) == 15 def test_single_element(): assert distribute_rewards([1]) == 1 def test_two_elements(): assert distribute_rewards([2, 1]) == 3 assert distribute_rewards([1, 2]) == 3 def test_large_numbers(): assert distribute_rewards([10000, 9000, 8000, 7000]) == 10 assert distribute_rewards([7000, 8000, 9000, 10000]) == 10","solution":"def distributeRewards(ratings): n = len(ratings) if n == 0: return 0 rewards = [1] * n # From left to right, ensure right neighbor rules are met for i in range(1, n): if ratings[i] > ratings[i - 1]: rewards[i] = rewards[i - 1] + 1 # From right to left, ensure left neighbor rules are met for i in range(n - 2, -1, -1): if ratings[i] > ratings[i + 1]: rewards[i] = max(rewards[i], rewards[i + 1] + 1) return sum(rewards)"},{"question":"def most_frequent_char(S: str, queries: List[Tuple[int, int]]) -> List[str]: Given a string S and a list of queries, each query consisting of two integers, find the most frequent character in the specified range of the string. If there are multiple characters with the highest frequency, return the lexicographically smallest one. >>> most_frequent_char(\\"abacabad\\", [(1, 4)]) ['a'] >>> most_frequent_char(\\"abacabad\\", [(1, 4), (2, 6), (1, 8)]) ['a', 'a', 'a']","solution":"def most_frequent_char(S, queries): def get_most_frequent_char_in_range(start, end): sub_str = S[start-1:end] frequency = {} for char in sub_str: if char in frequency: frequency[char] += 1 else: frequency[char] = 1 # Find the max frequency and lexicographically smallest character with that frequency max_freq = 0 result_char = '' for char in sorted(frequency.keys()): if frequency[char] > max_freq: max_freq = frequency[char] result_char = char return result_char results = [] for l, r in queries: results.append(get_most_frequent_char_in_range(l, r)) return results"},{"question":"def min_distance(n: int, points: List[Tuple[int, int]]) -> int: Find the minimum distance between any two points from a given list of points in a 2D plane. The distance between two points (xi, yi) and (xj, yj) is defined as |xi - xj| + |yi - yj|. >>> min_distance(4, [(0, 0), (3, 4), (3, 0), (0, 4)]) 3 >>> min_distance(2, [(1, 1), (1, 2)]) 1 >>> min_distance(2, [(0, 0), (1000000000, 1000000000)]) 2000000000 >>> min_distance(5, [(1, 1), (2, 2), (1, 2), (2, 3), (3, 1)]) 1 >>> min_distance(3, [(2, 2), (2, 2), (2, 2)]) 0 pass","solution":"def min_distance(n, points): import sys min_dist = sys.maxsize for i in range(n): for j in range(i + 1, n): xi, yi = points[i] xj, yj = points[j] dist = abs(xi - xj) + abs(yi - yj) if dist < min_dist: min_dist = dist return min_dist"},{"question":"def sum_of_absolute_differences(n: int, array: List[int]) -> int: Returns the sum of the absolute differences between all pairs of elements in the array. Parameters: n (int): Length of the array. array (list of int): The array of integers. Returns: int: The sum of absolute differences between all pairs of elements. Examples: >>> sum_of_absolute_differences(3, [1, 3, 2]) 4 >>> sum_of_absolute_differences(4, [1, 1, 1, 1]) 0 >>> sum_of_absolute_differences(5, [1, 3, 5, 7, 9]) 40","solution":"def sum_of_absolute_differences(n, array): Returns the sum of the absolute differences between all pairs of elements in the array. Parameters: n (int): Length of the array. array (list of int): The array of integers. Returns: int: The sum of absolute differences between all pairs of elements. sum_diff = 0 for i in range(n): for j in range(i + 1, n): sum_diff += abs(array[i] - array[j]) return sum_diff"},{"question":"from typing import List, Dict def find_possible_recipes(recipes: List[Dict[str, List[str]]], available_ingredients: List[str]) -> List[str]: Determine which recipes can be prepared using only the available ingredients. >>> find_possible_recipes([ {\\"Pancakes\\": [\\"eggs\\", \\"flour\\", \\"milk\\", \\"sugar\\"]}, {\\"Omelette\\": [\\"eggs\\", \\"milk\\", \\"cheese\\"]}, {\\"Salad\\": [\\"lettuce\\", \\"tomato\\", \\"cucumber\\", \\"olive oil\\"]} ], [\\"eggs\\", \\"flour\\", \\"milk\\", \\"sugar\\", \\"lettuce\\", \\"tomato\\"]) [\\"Pancakes\\", \\"Salad\\"] >>> find_possible_recipes([ {\\"Pasta\\": [\\"tomato\\", \\"pasta\\", \\"basil\\"]}, {\\"Sandwich\\": [\\"bread\\", \\"cheese\\", \\"ham\\"]}, {\\"Smoothie\\": [\\"banana\\", \\"milk\\"]} ], [\\"tomato\\", \\"pasta\\", \\"basil\\", \\"banana\\", \\"milk\\"]) [\\"Pasta\\", \\"Smoothie\\"]","solution":"from typing import List, Dict def find_possible_recipes(recipes: List[Dict[str, List[str]]], available_ingredients: List[str]) -> List[str]: available_set = set(available_ingredients) possible_recipes = [] for recipe in recipes: for name, ingredients in recipe.items(): if all(ingredient in available_set for ingredient in ingredients): possible_recipes.append(name) return possible_recipes"},{"question":"def filter_logs(log_entries, min_severity): Filters log entries based on a minimum severity level. Args: log_entries (list of tuples): List of log entries where each entry is a tuple (timestamp, severity, message) min_severity (int): Minimum severity level to filter log entries. Returns: list of tuples: Filtered list of log entries with severity >= min_severity. Examples: >>> log_entries = [ ... (\\"2023-01-15 12:00:00\\", 2, \\"User login successful\\"), ... (\\"2023-01-15 12:05:00\\", 4, \\"Disk space running low\\"), ... (\\"2023-01-15 12:10:00\\", 1, \\"Debugging connection issues\\"), ... (\\"2023-01-15 12:15:00\\", 5, \\"System crash\\"), ... (\\"2023-01-15 12:20:00\\", 3, \\"New user registered\\") ... ] >>> min_severity = 3 >>> filter_logs(log_entries, min_severity) [ (\\"2023-01-15 12:05:00\\", 4, \\"Disk space running low\\"), (\\"2023-01-15 12:15:00\\", 5, \\"System crash\\"), (\\"2023-01-15 12:20:00\\", 3, \\"New user registered\\") ]","solution":"def filter_logs(log_entries, min_severity): Filters log entries based on a minimum severity level. Args: log_entries (list of tuples): List of log entries where each entry is a tuple (timestamp, severity, message) min_severity (int): Minimum severity level to filter log entries. Returns: list of tuples: Filtered list of log entries with severity >= min_severity. return [entry for entry in log_entries if entry[1] >= min_severity]"},{"question":"from typing import List, Tuple def count_unique_words(lines: List[str]) -> List[Tuple[str, int]]: Process a list of strings to identify unique words and count their occurrences. >>> count_unique_words([\\"hello world\\"]) [(\\"hello\\", 1), (\\"world\\", 1)] >>> count_unique_words([\\"hello world\\", \\"Hello there world\\"]) [(\\"hello\\", 2), (\\"there\\", 1), (\\"world\\", 2)] >>> count_unique_words([\\"One fish two fish red fish blue fish\\", \\"Red Red Blue Blue\\"]) [(\\"blue\\", 3), (\\"fish\\", 4), (\\"one\\", 1), (\\"red\\", 3), (\\"two\\", 1)] >>> count_unique_words([\\"\\"]) [] >>> count_unique_words([\\"spam spam spam spam\\"]) [(\\"spam\\", 4)]","solution":"def count_unique_words(lines): from collections import Counter import re word_counter = Counter() for line in lines: # Convert to lower case and find all words words = re.findall(r'b[a-zA-Z]+b', line.lower()) word_counter.update(words) # Get a sorted list of words and their counts sorted_word_counts = sorted(word_counter.items()) return sorted_word_counts"},{"question":"def longest_palindromic_substring(s: str) -> str: Find the longest palindromic substring within a given string. >>> longest_palindromic_substring(\\"babad\\") 'bab' >>> longest_palindromic_substring(\\"cbbd\\") 'bb' Unit Test: from solution import longest_palindromic_substring def test_example_1(): assert longest_palindromic_substring(\\"babad\\") == \\"bab\\" or longest_palindromic_substring(\\"babad\\") == \\"aba\\" def test_example_2(): assert longest_palindromic_substring(\\"cbbd\\") == \\"bb\\" def test_single_character(): assert longest_palindromic_substring(\\"a\\") == \\"a\\" def test_no_palindrome(): assert longest_palindromic_substring(\\"abc\\") == \\"a\\" def test_entire_string_palindrome(): assert longest_palindromic_substring(\\"racecar\\") == \\"racecar\\" def test_palindrome_at_the_end(): assert longest_palindromic_substring(\\"abcddcb\\") == \\"bcddcb\\" def test_empty_string(): assert longest_palindromic_substring(\\"\\") == \\"\\" def test_long_string(): long_string = \\"abccbaasdf\\" assert longest_palindromic_substring(long_string) == \\"abccba\\"","solution":"def longest_palindromic_substring(s: str) -> str: def expand_around_center(s, left, right): while left >= 0 and right < len(s) and s[left] == s[right]: left -= 1 right += 1 return s[left+1:right] longest_palindrome = \\"\\" for i in range(len(s)): # Odd length palindromes palindrome1 = expand_around_center(s, i, i) # Even length palindromes palindrome2 = expand_around_center(s, i, i+1) if len(palindrome1) > len(longest_palindrome): longest_palindrome = palindrome1 if len(palindrome2) > len(longest_palindrome): longest_palindrome = palindrome2 return longest_palindrome"},{"question":"def max_sum_with_one_change(n: int, arr: List[int]) -> int: Determine the maximum possible sum of any contiguous subarray after changing at most one element. >>> max_sum_with_one_change(5, [1, -2, 3, -4, 5]) 8 >>> max_sum_with_one_change(3, [-1, -2, -3]) 0","solution":"def max_sum_with_one_change(n, arr): def kadane(arr): max_sum = current_sum = arr[0] for x in arr[1:]: current_sum = max(x, current_sum + x) max_sum = max(max_sum, current_sum) return max_sum max_sum = kadane(arr) for i in range(n): original = arr[i] # Attempt changing arr[i] to 0 and then applying kadane's algorithm arr[i] = 0 max_sum = max(max_sum, kadane(arr)) arr[i] = original return max_sum"},{"question":"def min_energy_to_palindrome(S: str) -> int: Returns the minimum energy required to convert the string S into a palindrome. >>> min_energy_to_palindrome(\\"abcd\\") 2 >>> min_energy_to_palindrome(\\"aab\\") 1 >>> min_energy_to_palindrome(\\"racecar\\") 0 def process_test_cases(T: int, test_cases: List[str]) -> List[int]: Processes multiple test cases and returns the results as a list of integers. >>> process_test_cases(3, [\\"abcd\\", \\"aab\\", \\"racecar\\"]) [2, 1, 0] >>> process_test_cases(2, [\\"madam\\", \\"hello\\"]) [0, 2]","solution":"def min_energy_to_palindrome(S): Returns the minimum energy required to convert the string S into a palindrome. n = len(S) energy = 0 for i in range(n // 2): if S[i] != S[-(i + 1)]: energy += 1 return energy def process_test_cases(T, test_cases): Processes multiple test cases and returns the results as a list of integers. results = [] for S in test_cases: results.append(min_energy_to_palindrome(S)) return results"},{"question":"from typing import List def largest_submatrix_sum(H: int, W: int, k: int, matrix: List[List[int]]) -> int: Create a program that inputs the height and width of a matrix followed by the matrix itself and a submatrix size, and outputs the largest sum of any submatrix of the given size. Args: - H (int): Height of the matrix - W (int): Width of the matrix - matrix (List[List[int]]): 2D matrix of integers Returns: - int: Maximum sum of any k x k submatrix Example: >>> largest_submatrix_sum(4, 4, 2, [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]]) 54 >>> largest_submatrix_sum(3, 3, 2, [[-1, -2, -3], [4, 5, 6], [7, 8, 9]]) 28 def process_multiple_datasets(input_data: str) -> List[int]: Process multiple datasets and return the maximum sum of any k x k submatrix for each dataset. Args: - input_data (str): Multiline string representing multiple datasets Returns: - List[int]: List of maximum sums for each dataset Example: >>> process_multiple_datasets(\\"4 4 2n1 2 3 4n5 6 7 8n9 10 11 12n13 14 15 16n3 3 2n-1 -2 -3n4 5 6n7 8 9n0 0 0\\") [54, 28]","solution":"def largest_submatrix_sum(H, W, k, matrix): max_sum = -float('inf') # Computing sum of all k x k submatrices for i in range(H - k + 1): for j in range(W - k + 1): submatrix_sum = 0 for x in range(i, i + k): for y in range(j, j + k): submatrix_sum += matrix[x][y] max_sum = max(max_sum, submatrix_sum) return max_sum def process_multiple_datasets(input_data): result = [] lines = input_data.split(\\"n\\") idx = 0 while idx < len(lines): H, W, k = map(int, lines[idx].split()) if H == 0 and W == 0 and k == 0: break idx += 1 matrix = [] for _ in range(H): matrix.append(list(map(int, lines[idx].split()))) idx += 1 result.append(largest_submatrix_sum(H, W, k, matrix)) return result"},{"question":"def longest_balanced_subsequence(s: str) -> int: Returns the length of the longest contiguous subsequence with an equal number of heads (1s) and tails (0s). Args: s (str): A string representing the sequence of coin flips, where '1' denotes heads and '0' denotes tails. Returns: int: The length of the longest contiguous subsequence with an equal number of heads and tails. If no such subsequence exists, returns 0. Examples: >>> longest_balanced_subsequence(\\"110100110\\") 8 >>> longest_balanced_subsequence(\\"1111\\") 0 >>> longest_balanced_subsequence(\\"0101\\") 4 >>> longest_balanced_subsequence(\\"111000\\") 6 >>> longest_balanced_subsequence(\\"1001\\") 4","solution":"def longest_balanced_subsequence(s): Returns the length of the longest contiguous subsequence with an equal number of heads (1s) and tails (0s). balance_dict = {0: -1} balance = 0 max_length = 0 for i, char in enumerate(s): if char == '1': balance += 1 else: balance -= 1 if balance in balance_dict: max_length = max(max_length, i - balance_dict[balance]) else: balance_dict[balance] = i return max_length"},{"question":"def rearrange_numbers(arr: List[int]) -> List[int]: Rearrange the elements of the array such that all positive numbers appear before all negative numbers while maintaining their relative order. >>> rearrange_numbers([10, -1, 3, -5, 2, -6]) [10, 3, 2, -1, -5, -6] >>> rearrange_numbers([-8, -7, 6, -5, 4]) [6, 4, -8, -7, -5] >>> rearrange_numbers([1, 2, 3, 4, 5]) [1, 2, 3, 4, 5] >>> rearrange_numbers([-1, -2, -3, -4, -5]) [-1, -2, -3, -4, -5] >>> rearrange_numbers([]) [] >>> rearrange_numbers([5]) [5] >>> rearrange_numbers([-5]) [-5] >>> rearrange_numbers([0, -1, 1, -2, 2, -3, 3, -4, 4, -5, 5]) [0, 1, 2, 3, 4, 5, -1, -2, -3, -4, -5]","solution":"def rearrange_numbers(arr): Rearranges the elements of the array such that all positive numbers appear before all negative numbers while maintaining their relative order. positives = [x for x in arr if x >= 0] negatives = [x for x in arr if x < 0] return positives + negatives # Example usage # input_array = [10, -1, 3, -5, 2, -6] # result = rearrange_numbers(input_array) # print(result) # Output: [10, 3, 2, -1, -5, -6]"},{"question":"def create_board(N, M, special_cells): Create the board with exactly M connected regions, each containing one special cell. >>> create_board(2, 1, [(1, 1, 1)]) [[[1, 1], [1, 1]], [[1, 1], [1, 1]]] >>> create_board(2, 2, [(1, 1, 1), (2, 2, 2)]) [[[1, 0], [0, 0]], [[0, 0], [0, 2]]] from collections import deque def test_small_board_single_special_cell(): N = 2 M = 1 special_cells = [(1, 1, 1)] expected = [ [ [1, 1], [1, 1] ], [ [1, 1], [1, 1] ], ] assert create_board(N, M, special_cells) == expected def test_small_board_multiple_special_cells(): N = 2 M = 2 special_cells = [(1, 1, 1), (2, 2, 2)] result = create_board(N, M, special_cells) assert result[0][0][0] == 1 assert result[1][1][1] == 2 def test_bigger_board(): N = 3 M = 2 special_cells = [(2, 2, 2), (3, 3, 3)] result = create_board(N, M, special_cells) assert result[1][1][1] == 1 assert result[2][2][2] == 2 def test_custom_board(): N = 4 M = 3 special_cells = [(1, 1, 1), (2, 2, 2), (3, 3, 3)] result = create_board(N, M, special_cells) assert result[0][0][0] == 1 assert result[1][1][1] == 2 assert result[2][2][2] == 3","solution":"def create_board(N, M, special_cells): # Create the initial board with all cells set to 0 board = [[[0 for _ in range(N)] for _ in range(N)] for _ in range(N)] # Function to check if the cell is within the board limits def is_valid(x, y, z): return 0 <= x < N and 0 <= y < N and 0 <= z < N # Directions for moving to adjacent cells (6 possible moves: x±1, y±1, z±1) directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)] # A Breadth-First Search to fill the regions from collections import deque for idx, (x, y, z) in enumerate(special_cells, 1): queue = deque([(x-1, y-1, z-1)]) board[x-1][y-1][z-1] = idx while queue: cx, cy, cz = queue.popleft() for dx, dy, dz in directions: nx, ny, nz = cx + dx, cy + dy, cz + dz if is_valid(nx, ny, nz) and board[nx][ny][nz] == 0: board[nx][ny][nz] = idx queue.append((nx, ny, nz)) return board # Example usage # N = 3 # M = 2 # special_cells = [(2, 2, 2), (3, 3, 3)] # board = create_board(N, M, special_cells) # for layer in board: # for row in layer: # print(\\" \\".join(map(str, row))) # print()"},{"question":"def max_gift_bags(a: int, b: int, c: int) -> int: Determine the maximum number of gift bags that can be created, each containing one chocolate, one candy, and one toy. >>> max_gift_bags(4, 5, 6) 4 >>> max_gift_bags(10, 3, 5) 3 >>> max_gift_bags(0, 2, 3) 0","solution":"def max_gift_bags(a, b, c): Returns the maximum number of gift bags containing one chocolate, one candy, and one toy. return min(a, b, c)"},{"question":"def min_cost_to_connect_cities(n: int, m: int, roads: List[Tuple[int, int, int]]) -> int: Determine the minimum cost to construct roads such that all cities are connected directly or indirectly. If it is impossible to connect all the cities, return -1. Args: n : int : The number of cities. m : int : The number of possible roads. roads : List[Tuple[int, int, int]] : Each tuple represents a road with two cities and a cost. Returns: int : The minimum cost to connect all cities or -1 if it is impossible. Examples: >>> min_cost_to_connect_cities(4, 5, [(1, 2, 3), (2, 3, 1), (3, 4, 4), (2, 4, 2), (1, 4, 5)]) 6 >>> min_cost_to_connect_cities(3, 1, [(1, 2, 4)]) -1 from typing import List, Tuple","solution":"def find(parent, i): if parent[i] == i: return i else: parent[i] = find(parent, parent[i]) return parent[i] def union(parent, rank, x, y): root_x = find(parent, x) root_y = find(parent, y) if root_x != root_y: if rank[root_x] > rank[root_y]: parent[root_y] = root_x elif rank[root_x] < rank[root_y]: parent[root_x] = root_y else: parent[root_y] = root_x rank[root_x] += 1 def kruskal(n, roads): parent = [] rank = [] result = 0 edges_included = 0 for node in range(n): parent.append(node) rank.append(0) roads = sorted(roads, key=lambda x: x[2]) for road in roads: u, v, w = road root_u = find(parent, u - 1) root_v = find(parent, v - 1) if root_u != root_v: result += w edges_included += 1 union(parent, rank, root_u, root_v) if edges_included == n - 1: return result return -1 def min_cost_to_connect_cities(n, m, roads): if n == 0 or m == 0: return -1 return kruskal(n, roads) # Example n = 4 m = 5 roads = [ (1, 2, 3), (2, 3, 1), (3, 4, 4), (2, 4, 2), (1, 4, 5) ] print(min_cost_to_connect_cities(n, m, roads)) # Output: 6"},{"question":"from typing import List, Tuple from math import gcd from functools import reduce def max_common_divisor_subarray(n: int, array: List[int], queries: List[Tuple[int, int]]) -> List[int]: Given an array of n integers and a list of queries, compute the maximum common divisor (MCD) for each subarray specified by the queries. Args: n (int): The number of elements in the array. array (List[int]): The list of n integers. queries (List[Tuple[int, int]]): The list of queries, each query is a tuple (li, ri) representing the subarray from li to ri. Returns: List[int]: A list of integers where each integer is the MCD of the subarray specified by the corresponding query. Examples: >>> max_common_divisor_subarray(6, [12, 15, 21, 6, 18, 9], [(1, 3), (2, 5), (4, 6)]) [3, 3, 3] >>> max_common_divisor_subarray(4, [10, 20, 30, 40], [(1, 1), (3, 3)]) [10, 30]","solution":"from math import gcd from functools import reduce def max_common_divisor_subarray(n, array, queries): def calculate_mcd(subarray): return reduce(gcd, subarray) result = [] for li, ri in queries: subarray = array[li-1:ri] result.append(calculate_mcd(subarray)) return result"},{"question":"def count_subsequences_with_sum(a, k): Function to count the number of subsequences in a list that sum to k. Parameters: a (list): The input list of non-negative integers. k (int): The target sum value. Returns: int: The number of subsequences whose sum is exactly k. n = len(a) dp = [[0] * (k + 1) for _ in range(n + 1)] dp[0][0] = 1 # There's one way to get sum 0 by selecting no elements. for i in range(1, n + 1): for j in range(k + 1): dp[i][j] = dp[i - 1][j] if j >= a[i - 1]: dp[i][j] += dp[i - 1][j - a[i - 1]] return dp[n][k] def process_queries(queries): Function to process multiple queries for counting subsequences with a specific sum. Parameters: queries (list): A list of queries, where each query is a dictionary with keys 'n', 'a', 'k'. Returns: list: A list of results where each result corresponds to the number of subsequences of 'a' that sum to 'k'. results = [] for query in queries: n = query['n'] a = query['a'] k = query['k'] result = count_subsequences_with_sum(a, k) results.append(result) return results from process_queries import process_queries def test_process_queries(): queries = [ {'n': 3, 'a': [1, 2, 3], 'k': 4}, {'n': 4, 'a': [1, 1, 1, 1], 'k': 2} ] result = process_queries(queries) assert result == [1, 6], f\\"Expected [1, 6] but got {result}\\" def test_process_queries_single_element_zero(): queries = [ {'n': 1, 'a': [0], 'k': 0} ] result = process_queries(queries) assert result == [2], f\\"Expected [2] but got {result}\\" def test_process_queries_sum_zero(): queries = [ {'n': 3, 'a': [1, 2, 3], 'k': 0}, {'n': 4, 'a': [1, 1, 1, 1], 'k': 0} ] result = process_queries(queries) assert result == [1, 1], f\\"Expected [1, 1] but got {result}\\" def test_process_queries_no_valid_subsequence(): queries = [ {'n': 3, 'a': [1, 2, 3], 'k': 7} ] result = process_queries(queries) assert result == [0], f\\"Expected [0] but got {result}\\" def test_process_queries_all_elements_same(): queries = [ {'n': 4, 'a': [2, 2, 2, 2], 'k': 4} ] result = process_queries(queries) assert result == [6], f\\"Expected [6] but got {result}\\"","solution":"def count_subsequences_with_sum(a, k): n = len(a) dp = [[0] * (k + 1) for _ in range(n + 1)] dp[0][0] = 1 # There's one way to get sum 0 by selecting no elements. for i in range(1, n + 1): for j in range(k + 1): dp[i][j] = dp[i - 1][j] # subsequences without including the current element if j >= a[i - 1]: dp[i][j] += dp[i - 1][j - a[i - 1]] # subsequences including the current element return dp[n][k] def process_queries(queries): results = [] for query in queries: n = query['n'] a = query['a'] k = query['k'] result = count_subsequences_with_sum(a, k) results.append(result) return results"},{"question":"def digital_root_of_string(s: str) -> int: Calculate the digital root of the sum of all digits in the input string. >>> digital_root_of_string(\\"ab123cd4\\") 1 >>> digital_root_of_string(\\"hello123\\") 6 >>> digital_root_of_string(\\"abcde\\") 0 from solution import digital_root_of_string def test_digital_root_of_string_example_1(): assert digital_root_of_string(\\"ab123cd4\\") == 1 def test_digital_root_of_string_example_2(): assert digital_root_of_string(\\"hello123\\") == 6 def test_digital_root_of_string_example_3(): assert digital_root_of_string(\\"abcde\\") == 0 def test_digital_root_of_string_empty_string(): assert digital_root_of_string(\\"\\") == 0 def test_digital_root_of_string_single_digit(): assert digital_root_of_string(\\"9\\") == 9 def test_digital_root_of_string_multiple_zeros(): assert digital_root_of_string(\\"0a0b0\\") == 0 def test_digital_root_of_string_large_numbers(): assert digital_root_of_string(\\"123456789012345678901234567890\\") == 9","solution":"def digital_root_of_string(s): Calculate the digital root of the sum of all digits in the input string. digit_sum = sum(int(char) for char in s if char.isdigit()) def digital_root(n): while n >= 10: n = sum(int(x) for x in str(n)) return n return digital_root(digit_sum)"},{"question":"def max_cargo_value(datasets: List[List[List[int]]]) -> List[int]: Calculate the maximum total value of containers that can be loaded onto the ship without exceeding the weight capacity. Args: datasets (List[List[List[int]]]): Each dataset is a list of list of integers, where the first list contains n and W, and the following lists contain wi and vi for each container. Returns: List[int]: The maximum total value for each dataset. >>> max_cargo_value([ ... [ ... [3, 50], ... [10, 60], ... [20, 100], ... [30, 120] ... ], ... [ ... [4, 10], ... [5, 50], ... [4, 40], ... [6, 30], ... [3, 0] ... ] ... ]) [220, 90] >>> max_cargo_value([[[2, 0], [15, 20], [25, 15]]]) [0] >>> max_cargo_value([[[3, 10], [15, 20], [25, 15], [10, 5]]]) [5] >>> max_cargo_value([[[0, 0]]]) []","solution":"def max_cargo_value(datasets): Function to calculate the maximum total value of containers that can be loaded onto the ship without exceeding the weight capacity. results = [] for dataset in datasets: n, W = dataset[0] if n == 0 and W == 0: continue weights = [] values = [] for i in range(1, n+1): wi, vi = dataset[i] weights.append(wi) values.append(vi) dp = [0] * (W + 1) for i in range(n): for w in range(W, weights[i] - 1, -1): if w >= weights[i]: dp[w] = max(dp[w], dp[w - weights[i]] + values[i]) results.append(dp[W]) return results"},{"question":"def closest_pair_to_target(nums, target): Finds two numbers in the list nums such that their sum is closest to the given target. Parameters: nums (list of int): The list of integers. target (int): The target sum. Returns: tuple: A tuple containing the two integers whose sum is closest to the target. def test_closest_pair_to_target(): assert closest_pair_to_target([1, 3, 4, 7, 10], 10) == (3, 7) assert closest_pair_to_target([1, 5, 11, 3, 8, 12], 15) == (3, 12) or (5, 11) assert closest_pair_to_target([-1, 2, 9, -5, 4, 6], 0) == (-1, 1) or (2, -5) assert closest_pair_to_target([2, 3, 6, -1, 4, 7], 8) == (3, 6) or (4, 4) assert closest_pair_to_target([10, 20, 30, 40, 50], 45) == (10, 30) # Check edge cases assert closest_pair_to_target([-10**9, 10**9, 0], 0) == (-10**9, 10**9) assert closest_pair_to_target([5, 15], 25) == (5, 15) assert closest_pair_to_target([5, 15], 20) == (5, 15) def test_closest_pair_to_target_insufficient_data(): assert closest_pair_to_target([5], 10) == None assert closest_pair_to_target([], 10) == None","solution":"def closest_pair_to_target(nums, target): Finds two numbers in the list nums such that their sum is closest to the given target. Parameters: nums (list of int): The list of integers. target (int): The target sum. Returns: tuple: A tuple containing the two integers whose sum is closest to the target. n = len(nums) if n < 2: return None # Not enough elements to form a pair closest_sum = float('inf') result_pair = (None, None) # Iterate over each pair of numbers for i in range(n): for j in range(i + 1, n): current_sum = nums[i] + nums[j] if abs(current_sum - target) < abs(closest_sum - target): closest_sum = current_sum result_pair = (nums[i], nums[j]) return result_pair # Read input and call the solution function def main(): import sys input = sys.stdin.read data = input().split() n = int(data[0]) t = int(data[1]) nums = list(map(int, data[2:])) a, b = closest_pair_to_target(nums, t) print(a, b) if __name__ == \\"__main__\\": main()"},{"question":"def max_exchanged_bags(n: int, candies: List[int]) -> int: Determine the maximum number of candy bags that can be exchanged in pairs where the sum of candies in each pair is even. Args: n (int): The number of candy bags. candies (List[int]): A list containing the number of candies in each bag. Returns: int: The maximum number of bags that can be exchanged in pairs. Examples: >>> max_exchanged_bags(5, [1, 2, 3, 4, 5]) 4 >>> max_exchanged_bags(6, [2, 4, 6, 8, 10, 12]) 6","solution":"def max_exchanged_bags(n, candies): # Separate candies into even and odd evens = sum(1 for x in candies if x % 2 == 0) odds = n - evens # The number of pairs we can form is the minimum of the counts of even and odd numbers # because each pair needs either both even or both odd numbers return (evens // 2) * 2 + (odds // 2) * 2"},{"question":"def max_total_power(N: int, stones: List[Tuple[int, int, int]]) -> int: Determine the maximum total power Mr. Orb can collect on his journey from (X1, Y1) to (X2, Y2) in a grid of size 500 x 500. Args: N (int): The number of magical stones in the forest. stones (List[Tuple[int, int, int]]): A list of tuples where each tuple contains three integers (X_i, Y_i, P_i) indicating the cell and power level of a stone. Returns: int: The maximum total power of the stones collected along the path. Example: >>> max_total_power(5, [(1, 2, 100), (2, 3, 200), (3, 3, 300), (4, 4, 400), (4, 5, 500)]) 1500 >>> max_total_power(1, [(250, 250, 9999)]) 9999","solution":"def max_total_power(N, stones): grid = [[0] * 501 for _ in range(501)] for x, y, p in stones: grid[x][y] = p dp = [[0] * 501 for _ in range(501)] for i in range(1, 501): for j in range(1, 501): dp[i][j] = grid[i][j] + max(dp[i-1][j], dp[i][j-1]) return dp[500][500] # Example usage: N = 5 stones = [ (1, 2, 100), (2, 3, 200), (3, 3, 300), (4, 4, 400), (4, 5, 500) ] print(max_total_power(N, stones)) # Should print 1500"},{"question":"def find_unique_pairs(n: int, k: int, a: List[int]) -> int: Returns the number of unique pairs whose sum is equal to k. Parameters: n (int): Number of elements in the array. k (int): Desired sum of pairs. a (list of ints): Array of elements. Returns: int: Number of unique pairs. >>> find_unique_pairs(5, 9, [2, 7, 11, 15, 1]) 1 >>> find_unique_pairs(4, 6, [3, 3, 3, 3]) 1 from typing import List def test_find_unique_pairs_example1(): assert find_unique_pairs(5, 9, [2, 7, 11, 15, 1]) == 1 def test_find_unique_pairs_example2(): assert find_unique_pairs(4, 6, [3, 3, 3, 3]) == 1 def test_find_unique_pairs_no_pairs(): assert find_unique_pairs(5, 10, [1, 2, 3, 4, 5]) == 0 def test_find_unique_pairs_multiple_pairs(): assert find_unique_pairs(6, 10, [1, 2, 3, 4, 6, 9]) == 2 def test_find_unique_pairs_negative_numbers(): assert find_unique_pairs(5, 0, [-1, 1, -2, 2, 0]) == 2 def test_find_unique_pairs_large_numbers(): assert find_unique_pairs(6, 1000000000, [500000000, 500000000, -999999999, 999999999, 1, 999999999]) == 2 def test_find_unique_pairs_mixed_sign_numbers(): assert find_unique_pairs(6, 1, [-1, 2, -2, 3, 0, 1]) == 3","solution":"def find_unique_pairs(n, k, a): Returns the number of unique pairs whose sum is equal to k. Parameters: n (int): Number of elements in the array. k (int): Desired sum of pairs. a (list of ints): Array of elements. Returns: int: Number of unique pairs. seen = set() pairs = set() for number in a: target = k - number if target in seen: pairs.add(tuple(sorted((number, target)))) seen.add(number) return len(pairs)"},{"question":"def max_parked_cars(num_parking_lots, capacities, num_cars, car_sizes): Determine the maximum number of cars that can be parked without exceeding the capacity of any parking lot. >>> max_parked_cars(5, [3, 5, 2, 4, 1], 7, [3, 3, 2, 2, 1, 1, 1]) 5 >>> max_parked_cars(4, [2, 2, 3, 3], 6, [1, 2, 2, 3, 3, 3]) 4 >>> max_parked_cars(0, [], 3, [1, 2, 3]) 0 >>> max_parked_cars(3, [2, 3, 4], 0, []) 0 >>> max_parked_cars(3, [2, 5, 5], 3, [1, 2, 4]) 3 >>> max_parked_cars(4, [1, 2, 3, 4], 5, [1, 2, 2, 5, 6]) 3 >>> max_parked_cars(3, [1, 2, 3], 3, [1, 2, 3]) 3","solution":"def max_parked_cars(num_parking_lots, capacities, num_cars, car_sizes): capacities.sort() car_sizes.sort() parked_cars = 0 cap_index = 0 for car_size in car_sizes: while cap_index < num_parking_lots and capacities[cap_index] < car_size: cap_index += 1 if cap_index == num_parking_lots: break parked_cars += 1 cap_index += 1 return parked_cars"},{"question":"def max_programs(N: int, T: int, times: List[int]) -> int: Find the maximum number of programs a student can complete without any overlapping based on their estimated completion times. Args: N (int): Number of programs. T (int): Total available time. times (List[int]): List of time required to complete each program. Returns: int: Maximum number of programs that can be completed within the given total time T. Example: >>> max_programs(5, 10, [2, 1, 3, 2, 4]) 4 >>> max_programs(0, 10, []) 0 pass # Test cases def test_max_programs_example_case(): assert max_programs(5, 10, [2, 1, 3, 2, 4]) == 4 def test_max_programs_no_programs(): assert max_programs(0, 10, []) == 0 def test_max_programs_single_program_fits(): assert max_programs(1, 5, [3]) == 1 assert max_programs(1, 3, [3]) == 1 assert max_programs(1, 2, [3]) == 0 def test_max_programs_multiple_programs_all_fit(): assert max_programs(3, 15, [5, 5, 5]) == 3 def test_max_programs_multiple_programs_some_fit(): assert max_programs(4, 10, [3, 6, 3, 2]) == 3 def test_max_programs_large_times(): assert max_programs(3, 1000000000, [500000000, 300000000, 200000000]) == 3 def test_max_programs_large_N(): times = [i for i in range(1, 101)] assert max_programs(100, 5050, times) == 100","solution":"def max_programs(N, T, times): Returns the maximum number of programs a student can complete within the given total time T. times.sort() # Sort times in ascending order to prioritize shorter programs total_time = 0 program_count = 0 for time in times: if total_time + time <= T: total_time += time program_count += 1 else: break # If adding the next program exceeds T, stop counting return program_count"},{"question":"def smallest_subgrid_with_all_colors(grid: List[List[int]]) -> Tuple[int, int, int, int]: Determine the smallest subgrid (contiguous rectangle of cells) that contains all unique colors present in the grid. Args: grid (List[List[int]]): A 2D list representing the n x n grid where each cell contains a color. Returns: Tuple[int, int, int, int]: Four integers r1, c1, r2, c2 representing the coordinates of the top-left and bottom-right corners of the smallest subgrid that contains all unique colors. Example: >>> smallest_subgrid_with_all_colors([ ... [1, 2, 3, 4], ... [2, 1, 3, 4], ... [2, 2, 3, 4], ... [2, 2, 2, 4] ... ]) (1, 1, 4, 4) >>> smallest_subgrid_with_all_colors([ ... [5, 5, 5], ... [5, 5, 5], ... [5, 5, 5] ... ]) (1, 1, 3, 3) pass def test_single_color_grid(): grid = [ [5, 5, 5], [5, 5, 5], [5, 5, 5] ] assert smallest_subgrid_with_all_colors(grid) == (1, 1, 3, 3) def test_example_one(): grid = [ [1, 2, 3, 4], [2, 1, 3, 4], [2, 2, 3, 4], [2, 2, 2, 4] ] assert smallest_subgrid_with_all_colors(grid) == (1, 1, 4, 4) def test_large_n(): grid = [ [1, 2, 3], [4, 1, 1], [4, 4, 1] ] assert smallest_subgrid_with_all_colors(grid) == (1, 1, 3, 3) def test_multiple_colors(): grid = [ [1, 2], [2, 1] ] assert smallest_subgrid_with_all_colors(grid) == (1, 1, 2, 2) def test_one_by_one_grid(): grid = [ [1] ] assert smallest_subgrid_with_all_colors(grid) == (1, 1, 1, 1)","solution":"def smallest_subgrid_with_all_colors(grid): n = len(grid) # Flatten the grid and get all unique colors all_unique_colors = set() for row in grid: all_unique_colors.update(row) # If there's only one unique color if len(all_unique_colors) == 1: return (1, 1, n, n) # Otherwise, we need to find the top-left and bottom-right corners of the smallest subgrid # Initialize positions min_row = n min_col = n max_row = -1 max_col = -1 # Track occurrence of each color color_positions = {color: [] for color in all_unique_colors} for i in range(n): for j in range(n): color_positions[grid[i][j]].append((i, j)) # Find the boundary for each color for positions in color_positions.values(): for (row, col) in positions: min_row = min(min_row, row) min_col = min(min_col, col) max_row = max(max_row, row) max_col = max(max_col, col) return (min_row + 1, min_col + 1, max_row + 1, max_col + 1) # To run the function n = 4 grid = [ [1, 2, 3, 4], [2, 1, 3, 4], [2, 2, 3, 4], [2, 2, 2, 4] ] result = smallest_subgrid_with_all_colors(grid) print(result) # Output: (1, 1, 4, 4)"},{"question":"from typing import List def count_distinct_values(m: int, n: int) -> int: Returns the number of distinct values in the sequence from the M-th term to the N-th term. >>> count_distinct_values(3, 6) 4 >>> count_distinct_values(5, 10) 6 >>> count_distinct_values(7, 7) 1 >>> count_distinct_values(1, 10) 10 >>> count_distinct_values(15, 17) 3 >>> count_distinct_values(500, 510) 11","solution":"def count_distinct_values(m, n): Returns the number of distinct values in the sequence from the M-th term to the N-th term. if m == n: return 1 a1, a2 = 1, 2 sequence = [a1, a2] values_set = set(sequence) # Generate the sequence up to the N-th term for _ in range(3, n + 1): next_val = (sequence[-1] + sequence[-2]) % 100000 sequence.append(next_val) values_set.add(next_val) # Only consider values from the M-th to the N-th term return len(set(sequence[m-1:n]))"},{"question":"def was_warehouse_overloaded(test_cases: List[Tuple[int, int, List[str]]]) -> List[str]: Determine if the warehouse was overloaded at any point in time. Each test case contains the initial capacity, number of events and the events themselves. Returns a list of \\"YES\\" or \\"NO\\" for each test case indicating if the warehouse was overloaded. >>> was_warehouse_overloaded([(100, 3, [\\"+ 50\\", \\"+ 30\\", \\"- 20\\"])]) [\\"YES\\"] >>> was_warehouse_overloaded([(50, 4, [\\"+ 30\\", \\"+ 30\\", \\"- 10\\", \\"+ 20\\"])]) [\\"NO\\"]","solution":"def was_warehouse_overloaded(test_cases): results = [] for test_case in test_cases: n, m, events = test_case current_load = 0 overloaded = False for event in events: op, x = event.split() x = int(x) if op == \\"+\\": current_load += x elif op == \\"-\\": current_load -= x if current_load > n: overloaded = True break results.append(\\"NO\\" if overloaded else \\"YES\\") return results"},{"question":"def is_symmetric(name: str) -> str: Determine if a given string is a symmetric name. A symmetric name is composed exclusively of English lowercase letters and follows a pattern where the first half of the name matches the reverse of the second half exactly. Args: name (str): The candidate name string to check. Returns: str: \\"SYMMETRIC\\" if the name is symmetric, otherwise \\"NOT SYMMETRIC\\". Examples: >>> is_symmetric(\\"radar\\") 'SYMMETRIC' >>> is_symmetric(\\"hello\\") 'NOT SYMMETRIC' >>> is_symmetric(\\"wow\\") 'SYMMETRIC' # Your code here","solution":"def is_symmetric(name): Checks if the given name is symmetric. n = len(name) if n % 2 == 0: first_half = name[:n//2] second_half = name[n//2:] else: first_half = name[:n//2] second_half = name[n//2+1:] if first_half == second_half[::-1]: return \\"SYMMETRIC\\" else: return \\"NOT SYMMETRIC\\""},{"question":"import heapq from typing import List, Tuple def dijkstra(n: int, edges: List[Tuple[int, int, int]], start: int) -> List[int]: Determine the shortest travel time from a given starting city to all other cities in the country. Args: n (int): Number of cities. edges (List[Tuple[int, int, int]]): List of roads, each represented as a tuple (u, v, t) where u is the starting city, v is the destination city, and t is the travel time. start (int): The starting city. Returns: List[int]: The shortest travel time from the start city to each city. If a city is unreachable, it will have a travel time of -1. >>> dijkstra(5, [(1, 2, 2), (1, 3, 3), (2, 4, 4), (3, 4, 6), (4, 5, 1), (5, 3, 1)], 1) [0, 2, 3, 6, 7] >>> dijkstra(4, [(1, 2, 5), (1, 3, 10)], 1) [0, 5, 10, -1] >>> dijkstra(1, [], 1) [0] >>> dijkstra(2, [(1, 2, 1)], 1) [0, 1] >>> dijkstra(4, [(1, 2, 1), (2, 3, 1), (3, 4, 1), (1, 3, 2), (1, 4, 10)], 1) [0, 1, 2, 3]","solution":"import heapq def dijkstra(n, edges, start): graph = [[] for _ in range(n)] for u, v, t in edges: graph[u - 1].append((v - 1, t)) INF = float('inf') distances = [INF] * n distances[start - 1] = 0 priority_queue = [(0, start - 1)] while priority_queue: current_distance, current_vertex = heapq.heappop(priority_queue) if current_distance > distances[current_vertex]: continue for neighbor, weight in graph[current_vertex]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return [dist if dist != INF else -1 for dist in distances]"},{"question":"def is_cubic_subsequence(n: int, lst: List[int]) -> str: Determines if there exists a cubic subsequence of length 3 in the list. >>> is_cubic_subsequence(5, [1, 8, 27, 64, 125]) 'YES' >>> is_cubic_subsequence(6, [1, 2, 4, 8, 16, 32]) 'NO' >>> is_cubic_subsequence(4, [9, 10, 27, 64]) 'NO'","solution":"def is_cubic_subsequence(n, lst): Determines if there exists a cubic subsequence of length 3 in the list. import math def is_perfect_cube(num): root = round(num ** (1/3)) return root ** 3 == num cubes = [num for num in lst if is_perfect_cube(num)] if len(cubes) < 3: return \\"NO\\" for i in range(len(cubes)-2): for j in range(i+1, len(cubes)-1): for k in range(j+1, len(cubes)): if cubes[i] < cubes[j] < cubes[k]: return \\"YES\\" return \\"NO\\" # Example usage if __name__ == \\"__main__\\": import sys input = sys.stdin.read data = input().split() n = int(data[0]) lst = list(map(int, data[1:])) print(is_cubic_subsequence(n, lst))"},{"question":"from typing import List def min_effort_path(matrix: List[List[int]]) -> int: Determine the minimal possible effort required to walk from the top-left corner to the bottom-right corner of the height matrix. Parameters: matrix (List[List[int]]): A 2D list representing the heights of the tiles in the matrix. Returns: int: The minimal possible effort required to reach the bottom-right corner from the top-left corner. Example: >>> min_effort_path([ ... [1, 3, 5], ... [2, 8, 3], ... [5, 3, 1] ... ]) 2 pass # This is where the function implementation will go. # Test Cases def test_case_1(): matrix = [ [1, 3, 5], [2, 8, 3], [5, 3, 1] ] assert min_effort_path(matrix) == 2 def test_case_2(): matrix = [ [3, 4, 3], [2, 3, 5], [5, 3, 1] ] assert min_effort_path(matrix) == 2 def test_case_3(): matrix = [ [1, 2], [2, 1] ] assert min_effort_path(matrix) == 1 def test_case_4(): matrix = [ [1] ] assert min_effort_path(matrix) == 0 def test_case_5(): matrix = [ [1, 2, 1], [2, 8, 3], [5, 3, 1] ] assert min_effort_path(matrix) == 2 def test_case_6(): matrix = [ [4, 4], [4, 4] ] assert min_effort_path(matrix) == 0","solution":"import heapq def min_effort_path(matrix): Returns the minimum effort required to walk from the top-left corner to the bottom-right corner of the given height matrix. n, m = len(matrix), len(matrix[0]) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] def is_valid(x, y): return 0 <= x < n and 0 <= y < m effort = [[float('inf')] * m for _ in range(n)] effort[0][0] = 0 min_heap = [(0, 0, 0)] # (effort, x, y) while min_heap: curr_effort, x, y = heapq.heappop(min_heap) if x == n - 1 and y == m - 1: return curr_effort for dx, dy in directions: nx, ny = x + dx, y + dy if is_valid(nx, ny): new_effort = max(curr_effort, abs(matrix[nx][ny] - matrix[x][y])) if new_effort < effort[nx][ny]: effort[nx][ny] = new_effort heapq.heappush(min_heap, (new_effort, nx, ny)) return effort[-1][-1]"},{"question":"from typing import List def min_subarray_len(target: int, nums: List[int]) -> int: Given an integer array \`nums\`, determines the length of the shortest contiguous subarray, such that the sum of the elements in this subarray is at least \`target\`. >>> min_subarray_len(7, [2, 3, 1, 2, 4, 3]) 2 >>> min_subarray_len(4, [1, 4, 4]) 1 >>> min_subarray_len(11, [1, 1, 1, 1, 1, 1, 1, 1]) 0 pass def test_min_subarray_len(): assert min_subarray_len(7, [2, 3, 1, 2, 4, 3]) == 2, \\"Test case 1 failed\\" assert min_subarray_len(4, [1, 4, 4]) == 1, \\"Test case 2 failed\\" assert min_subarray_len(11, [1, 1, 1, 1, 1, 1, 1, 1]) == 0, \\"Test case 3 failed\\" assert min_subarray_len(15, [1, 2, 3, 4, 5]) == 5, \\"Test case 4 failed\\" assert min_subarray_len(3, [1, 1, 1, 1, 1, 1, 1, 3]) == 1, \\"Test case 5 failed\\" assert min_subarray_len(10, [2, 3, 1, 2, 4, 3]) == 4, \\"Test case 6 failed\\" assert min_subarray_len(5, [5]) == 1, \\"Test case 7 failed\\" assert min_subarray_len(100, []) == 0, \\"Test case 8 failed\\" assert min_subarray_len(100, [50, 50, 50]) == 2, \\"Test case 9 failed\\" assert min_subarray_len(1, [1]) == 1, \\"Test case 10 failed\\" test_min_subarray_len()","solution":"from typing import List def min_subarray_len(target: int, nums: List[int]) -> int: n = len(nums) left = 0 sum_subarray = 0 min_length = float('inf') for right in range(n): sum_subarray += nums[right] while sum_subarray >= target: min_length = min(min_length, right - left + 1) sum_subarray -= nums[left] left += 1 return min_length if min_length != float('inf') else 0"},{"question":"from typing import List, Tuple def delivery_queries(queries: List[Tuple[int, int, int]], t: int) -> List[str]: Handles delivery queries and determines if tasks can be completed within their urgency time frame. Tasks are processed in the order they are received. Args: queries (List[Tuple[int, int, int]]): A list of queries where each query is represented by a tuple. The first element of the tuple is the type of query. If the query type is 1, the second and third elements are p and u respectively (p is processing time, u is urgency factor). If the query type is 2, there are no additional parameters. t (int): The constant time unit. Returns: List[str]: A list of results for each query of type 2. \\"COMPLETED\\" if the task can be completed within its urgency time frame, otherwise \\"SKIPPED\\". >>> delivery_queries([(1, 5, 2), (2,), (1, 6, 1), (2,)], 10) [\\"COMPLETED\\", \\"SKIPPED\\"] >>> delivery_queries([(1, 7, 2), (2,), (1, 5, 5), (2,), (1, 8, 2), (2,)], 10) [\\"COMPLETED\\", \\"COMPLETED\\", \\"COMPLETED\\"] >>> delivery_queries([(1, 2, 2), (2,), (1, 1, 1), (2,)], 5) [\\"SKIPPED\\", \\"SKIPPED\\"] >>> delivery_queries([(1, 2, 3)], 15) [] >>> delivery_queries([(2,), (2,), (2,)], 10) []","solution":"from collections import deque def delivery_queries(queries, t): task_queue = deque() results = [] for query in queries: if query[0] == 1: # Add a new task p, u = query[1], query[2] task_queue.append((p, u)) elif query[0] == 2: # Process next task if task_queue: p, u = task_queue.popleft() if p * u >= t: results.append(\\"COMPLETED\\") else: results.append(\\"SKIPPED\\") return results"},{"question":"from typing import List def all_chars_same_frequency(s: str) -> str: Determine if all characters of the string appear the same number of times. >>> all_chars_same_frequency(\\"aabbcc\\") \\"YES\\" >>> all_chars_same_frequency(\\"aabbc\\") \\"NO\\"","solution":"def all_chars_same_frequency(s): Returns 'YES' if all characters in string s appear the same number of times. Otherwise, returns 'NO'. from collections import Counter freq = Counter(s) values = list(freq.values()) if len(set(values)) == 1: return \\"YES\\" else: return \\"NO\\""},{"question":"def subarray_sums(arr: List[int], K: int) -> List[int]: Find the sum of each possible sub-array of size K and return these sums in order. >>> subarray_sums([2, 3, 5, 1, 4], 2) [5, 8, 6, 5] >>> subarray_sums([1, 2, 3, 4, 5], 1) [1, 2, 3, 4, 5] >>> subarray_sums([1, 2, 3, 4, 5], 5) [15] >>> subarray_sums([1, 1, 1, 1, 1], 2) [2, 2, 2, 2] >>> subarray_sums([1000, 1000, 1000, 1000, 1000], 3) [3000, 3000, 3000] from typing import List def test_subarray_sums_example(): assert subarray_sums([2, 3, 5, 1, 4], 2) == [5, 8, 6, 5] def test_subarray_sums_single_element_subarray(): assert subarray_sums([1, 2, 3, 4, 5], 1) == [1, 2, 3, 4, 5] def test_subarray_sums_entire_array_as_subarray(): assert subarray_sums([1, 2, 3, 4, 5], 5) == [15] def test_subarray_sums_with_duplicates(): assert subarray_sums([1, 1, 1, 1, 1], 2) == [2, 2, 2, 2] def test_subarray_sums_large_elements(): assert subarray_sums([1000, 1000, 1000, 1000, 1000], 3) == [3000, 3000, 3000]","solution":"def subarray_sums(arr, K): Finds the sum of each possible sub-array of size K and prints these sums in order. Parameters: arr (List[int]): Array of integers K (int): Size of the sub-arrays Returns: List[int]: Sum of each sub-array of size K N = len(arr) result = [] current_sum = sum(arr[:K]) result.append(current_sum) for i in range(1, N - K + 1): current_sum += arr[i + K - 1] - arr[i - 1] result.append(current_sum) return result"},{"question":"def longest_consecutive(nums: List[int]) -> int: Given an unsorted array of integers nums, return the length of the longest consecutive elements sequence. Args: nums (List[int]): The input list of integers. Returns: int: The length of the longest consecutive elements sequence. Examples: >>> longest_consecutive([100, 4, 200, 1, 3, 2]) 4 >>> longest_consecutive([0, 0]) 1 >>> longest_consecutive([1, 2, 0, 1]) 3 >>> longest_consecutive([]) 0 >>> longest_consecutive([8, 4, 9, 10, 1, 1, 2, 3]) 4 >>> longest_consecutive([10, 20, 30, 40]) 1 >>> longest_consecutive([1, 2, 3, 4, 5]) 5 >>> longest_consecutive([10, 5, 12, 8, 50, 3, 11, 4]) 3","solution":"def longest_consecutive(nums): Returns the length of the longest consecutive elements sequence in the unsorted list of integers nums. # Using a set to store the unique elements from the input list num_set = set(nums) longest_streak = 0 # Iterate over each element in the set for num in num_set: # Check if it's the start of a sequence if num - 1 not in num_set: current_num = num current_streak = 1 # Count the length of the sequence starting from current_num while current_num + 1 in num_set: current_num += 1 current_streak += 1 # Update the longest_streak if current_streak is longer longest_streak = max(longest_streak, current_streak) return longest_streak"},{"question":"from typing import List def determine_trend(arr: List[int]) -> str: Determines if the list is strictly increasing, strictly decreasing, or neither for a given list of integers. Parameters: arr (List[int]): A list of integers Returns: str: \\"Strictly Increasing\\", \\"Strictly Decreasing\\", or \\"Neither\\" >>> determine_trend([1, 2, 3, 4, 5]) 'Strictly Increasing' >>> determine_trend([5, 4, 3, 2, 1]) 'Strictly Decreasing' >>> determine_trend([1, 3, 2, 4]) 'Neither' def process_input(input_data: str) -> List[str]: Processes multiple test cases of integer lists and returns the results of their trends. Parameters: input_data (str): A string containing multiple lines with space-separated integers. Returns: List[str]: A list of strings indicating the trend for each test case. >>> process_input(\\"1 2 3 4 5n5 4 3 2 1n1 3 2 4n0n\\") ['Strictly Increasing', 'Strictly Decreasing', 'Neither']","solution":"def determine_trend(arr): Determines if the list is strictly increasing, strictly decreasing, or neither. Parameters: arr (list): A list of integers Returns: str: \\"Strictly Increasing\\", \\"Strictly Decreasing\\", or \\"Neither\\" if len(arr) < 2: return \\"Neither\\" increasing = all(arr[i] < arr[i + 1] for i in range(len(arr) - 1)) if increasing: return \\"Strictly Increasing\\" decreasing = all(arr[i] > arr[i + 1] for i in range(len(arr) - 1)) if decreasing: return \\"Strictly Decreasing\\" return \\"Neither\\" def process_input(input_data): output_data = [] for line in input_data.split('n'): if line.strip() == '0': break if not line.strip(): continue arr = list(map(int, line.strip().split())) result = determine_trend(arr) output_data.append(result) return output_data"},{"question":"def build_roads(n: int, m: int, roads: List[Tuple[int, int, int]]) -> List[Tuple[int, int]]: Determines the order in which roads should be built to maintain the city's connectivity with the minimum sum of priorities. Args: n : int : number of places m : int : number of roads roads : list of tuples : each tuple contains (u, v, p) representing a road between places u and v with priority p Returns: list of tuples : List of (u, v) representing the roads in the order they should be built >>> build_roads(4, 5, [(1, 2, 1), (1, 3, 2), (2, 3, 2), (3, 4, 3), (2, 4, 4)]) [(1, 2), (1, 3), (3, 4)] >>> build_roads(3, 3, [(1, 2, 5), (1, 3, 6), (2, 3, 1)]) [(2, 3), (1, 2)]","solution":"def build_roads(n, m, roads): Determines the order in which roads should be built to maintain the city's connectivity with the minimum sum of priorities. Args: n : int : number of places m : int : number of roads roads : list of tuples : each tuple contains (u, v, p) representing a road between places u and v with priority p Returns: list of tuples : List of (u, v) representing the roads in the order they should be built # Using Kruskal's algorithm to find the Minimum Spanning Tree (MST) # First, sort the roads by priority roads.sort(key=lambda x: x[2]) parent = list(range(n + 1)) rank = [0] * (n + 1) def find(x): if parent[x] != x: parent[x] = find(parent[x]) return parent[x] def union(x, y): rootX = find(x) rootY = find(y) if rootX != rootY: if rank[rootX] > rank[rootY]: parent[rootY] = rootX elif rank[rootX] < rank[rootY]: parent[rootX] = rootY else: parent[rootY] = rootX rank[rootX] += 1 result = [] for u, v, p in roads: if find(u) != find(v): union(u, v) result.append((u, v)) if len(result) == n - 1: break return result"},{"question":"class Library: def __init__(self, n, availability): Initialize the library with n books and their initial availability status. Args: n (int): Number of books. availability (List[int]): Initial availability status of each book. def issue(self, x): Mark book x as issued, making it unavailable and incrementing its issue count. Args: x (int): The book number to be issued. def return_book(self, x): Mark book x as returned, making it available. Args: x (int): The book number to be returned. def is_available(self, x): Query the availability status of book x. Args: x (int): The book number whose availability status is to be queried. Returns: int: 1 if the book is available, 0 otherwise. def times_issued(self, x): Query the total number of times book x has been issued. Args: x (int): The book number whose issue count is to be queried. Returns: int: The total number of times the book has been issued. def process_operations(n, availability, operations): Process a series of operations on the library. Args: n (int): Number of books. availability (List[int]): Initial availability status of each book. operations (List[str]): List of operations to be performed. Returns: List[int]: Results of 'AVAILABLE' and 'COUNT' operations. # Unit test cases def test_example_1(): n = 5 availability = [1, 0, 1, 1, 0] operations = [ \\"ISSUE 3\\", \\"AVAILABLE 3\\", \\"ISSUE 1\\", \\"AVAILABLE 1\\", \\"COUNT 1\\", \\"COUNT 3\\" ] expected = [0, 0, 1, 1] assert process_operations(n, availability, operations) == expected def test_example_2(): n = 4 availability = [1, 1, 0, 1] operations = [ \\"ISSUE 2\\", \\"AVAILABLE 2\\", \\"COUNT 2\\" ] expected = [0, 1] assert process_operations(n, availability, operations) == expected def test_already_issued_book(): n = 3 availability = [0, 0, 1] operations = [ \\"ISSUE 1\\", \\"AVAILABLE 1\\", \\"COUNT 1\\" ] expected = [0, 0] assert process_operations(n, availability, operations) == expected def test_repeated_issue_return(): n = 2 availability = [1, 1] operations = [ \\"ISSUE 1\\", \\"RETURN 1\\", \\"ISSUE 1\\", \\"COUNT 1\\", \\"AVAILABLE 1\\" ] expected = [2, 0] assert process_operations(n, availability, operations) == expected","solution":"class Library: def __init__(self, n, availability): self.availability = availability self.issue_count = [0] * n def issue(self, x): if self.availability[x-1] == 1: self.availability[x-1] = 0 self.issue_count[x-1] += 1 def return_book(self, x): self.availability[x-1] = 1 def is_available(self, x): return self.availability[x-1] def times_issued(self, x): return self.issue_count[x-1] def process_operations(n, availability, operations): library = Library(n, availability) results = [] for operation in operations: if operation.startswith(\\"ISSUE\\"): _, x = operation.split() library.issue(int(x)) elif operation.startswith(\\"RETURN\\"): _, x = operation.split() library.return_book(int(x)) elif operation.startswith(\\"AVAILABLE\\"): _, x = operation.split() results.append(library.is_available(int(x))) elif operation.startswith(\\"COUNT\\"): _, x = operation.split() results.append(library.times_issued(int(x))) return results"},{"question":"from typing import List, Tuple def maximum_aesthetic_appeal(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Returns the maximum aesthetic appeal for each test case. Parameters: t (int): The number of test cases. test_cases (list of tuple): Each tuple contains n (int) followed by a list of n integers representing the coin values. Returns: list of int: The maximum aesthetic appeal for each test case. pass # Example test cases that can be used to verify the solution def test_single_case(): assert maximum_aesthetic_appeal(1, [(5, [1, 3, 6, 7, 9])]) == [2] def test_multiple_cases(): assert maximum_aesthetic_appeal(3, [ (5, [1, 3, 6, 7, 9]), (4, [2, 2, 2, 2]), (3, [5, 15, 25]) ]) == [2, 0, 10] def test_all_same_values(): assert maximum_aesthetic_appeal(1, [(4, [100, 100, 100, 100])]) == [0] def test_large_range_values(): assert maximum_aesthetic_appeal(1, [(4, [1, 500, 1000, 750])]) == [250] def test_two_coin_case(): assert maximum_aesthetic_appeal(1, [(2, [10, 20])]) == [10]","solution":"def maximum_aesthetic_appeal(t, test_cases): Returns the maximum aesthetic appeal for each test case. Parameters: t (int): The number of test cases. test_cases (list of tuple): Each tuple contains n (int) followed by a list of n integers representing the coin values. Returns: list of int: The maximum aesthetic appeal for each test case. results = [] for case in test_cases: n, coins = case coins.sort() min_diff = float('inf') for i in range(1, n): min_diff = min(min_diff, coins[i] - coins[i - 1]) results.append(min_diff) return results"},{"question":"from typing import List, Tuple def can_assign_types(T: int, test_cases: List[Tuple[int, int, List[Tuple[int, int]]]]) -> List[str]: Determine if it is possible to assign types to all animals such that no pair of friends has the same type. >>> can_assign_types(2, [(3, 3, [(1, 2), (2, 3), (3, 1)]), (4, 2, [(1, 2), (2, 3)])]) ['NO', 'YES'] from typing import List, Tuple def test_example_cases(): T = 2 test_cases = [ (3, 3, [(1, 2), (2, 3), (3, 1)]), (4, 2, [(1, 2), (2, 3)]) ] assert can_assign_types(T, test_cases) == ['NO', 'YES'] def test_single_animal(): T = 1 test_cases = [ (1, 0, []) ] assert can_assign_types(T, test_cases) == ['YES'] def test_two_animals_friends(): T = 1 test_cases = [ (2, 1, [(1, 2)]) ] assert can_assign_types(T, test_cases) == ['YES'] def test_two_animals_no_friends(): T = 1 test_cases = [ (2, 0, []) ] assert can_assign_types(T, test_cases) == ['YES'] def test_large_no_conflict(): T = 1 test_cases = [ (5, 4, [(1, 2), (2, 3), (3, 4), (4, 5)]) ] assert can_assign_types(T, test_cases) == ['YES'] def test_large_with_conflict(): T = 1 test_cases = [ (6, 7, [(1, 2), (2, 3), (3, 1), (3, 4), (4, 5), (5, 6), (6, 4)]) ] assert can_assign_types(T, test_cases) == ['NO']","solution":"def is_bipartite(graph, start, color_map): queue = [start] color_map[start] = 0 # Start coloring with 0 while queue: node = queue.pop(0) for neighbor in graph[node]: if neighbor not in color_map: color_map[neighbor] = 1 - color_map[node] queue.append(neighbor) elif color_map[neighbor] == color_map[node]: return False return True def can_assign_types(T, test_cases): results = [] for i in range(T): N, M, friends = test_cases[i] graph = {x: [] for x in range(1, N + 1)} for u, v in friends: graph[u].append(v) graph[v].append(u) color_map = {} possible = True for animal in range(1, N + 1): if animal not in color_map and not is_bipartite(graph, animal, color_map): possible = False break if possible: results.append(\\"YES\\") else: results.append(\\"NO\\") return results # Example usage: T = 2 test_cases = [ (3, 3, [(1, 2), (2, 3), (3, 1)]), (4, 2, [(1, 2), (2, 3)]) ] print(can_assign_types(T, test_cases)) # Output: ['NO', 'YES']"},{"question":"from typing import List, Tuple def max_sessions(n: int, sessions: List[Tuple[int, int]]) -> int: Given a list of proposed sessions, determine the maximum number of sessions that can be attended without any overlap. >>> max_sessions(5, [(1, 4), (2, 3), (3, 5), (7, 8), (5, 7)]) 4 >>> max_sessions(4, [(2, 3), (3, 4), (4, 5), (1, 2)]) 4 >>> max_sessions(3, [(10, 12), (12, 13), (11, 12)]) 2 >>> max_sessions(1, [(1, 2)]) 1 >>> max_sessions(3, [(1, 3), (3, 4), (2, 5)]) 2 >>> max_sessions(6, [(5, 7), (1, 4), (3, 5), (2, 3), (7, 8), (8, 9)]) 5 >>> max_sessions(7, [(1, 5), (5, 10), (10, 15), (2, 4), (4, 8), (7, 9), (9, 14)]) 3 >>> max_sessions(3, [(1, 3), (3, 5), (5, 10)]) 3","solution":"def max_sessions(n, sessions): # Sort the sessions by end time sessions.sort(key=lambda session: session[1]) max_count = 0 last_end_time = 0 for start, end in sessions: if start >= last_end_time: max_count += 1 last_end_time = end return max_count"},{"question":"def can_schedule_all_training(n: int, k: int, trainer_hours: List[int], animal_times: List[int]) -> str: Determine if it is possible to schedule all required animal training within one day. Args: n (int): Number of animals. k (int): Number of trainers. trainer_hours (List[int]): Working hours of each trainer. animal_times (List[int]): Training time required for each animal. Returns: str: \\"Yes\\" if it is possible to schedule all training within one day, otherwise \\"No\\". Examples: >>> can_schedule_all_training(3, 2, [8, 8], [3, 5, 7]) \\"Yes\\" >>> can_schedule_all_training(3, 2, [4, 5], [5, 4, 2]) \\"No\\"","solution":"def can_schedule_all_training(n, k, trainer_hours, animal_times): # Sort the trainer hours in descending order trainer_hours.sort(reverse=True) # Sort the animal times in descending order animal_times.sort(reverse=True) # Try to assign each animal to a trainer for i in range(n): assigned = False for j in range(k): if trainer_hours[j] >= animal_times[i]: trainer_hours[j] -= animal_times[i] assigned = True break if not assigned: return \\"No\\" return \\"Yes\\""},{"question":"def can_avoid_deadlock(T: int, test_cases: List[List[str]]) -> List[str]: Determine if it's possible to avoid a deadlock given the initial configuration of traffic lights. >>> can_avoid_deadlock(1, [['G', 'G', 'G', 'G']]) [\\"Yes\\"] >>> can_avoid_deadlock(1, [['R', 'R', 'R', 'R']]) [\\"No\\"] >>> can_avoid_deadlock(3, [['R', 'G', 'R', 'G'], ['G', 'G', 'G', 'G'], ['R', 'R', 'R', 'R']]) [\\"Yes\\", \\"Yes\\", \\"No\\"] from typing import List def test_all_green(): assert can_avoid_deadlock(1, [['G', 'G', 'G', 'G']]) == [\\"Yes\\"] def test_all_red(): assert can_avoid_deadlock(1, [['R', 'R', 'R', 'R']]) == [\\"No\\"] def test_mixed(): assert can_avoid_deadlock(3, [['R', 'G', 'R', 'G'], ['G', 'G', 'G', 'G'], ['R', 'R', 'R', 'R']]) == [\\"Yes\\", \\"Yes\\", \\"No\\"] def test_one_green(): assert can_avoid_deadlock(1, [['R', 'R', 'R', 'G']]) == [\\"Yes\\"] def test_one_red(): assert can_avoid_deadlock(1, [['R', 'R', 'R', 'R']]) == [\\"No\\"] def test_three_test_cases(): assert can_avoid_deadlock(3, [['R', 'G', 'R', 'G'], ['G', 'G', 'G', 'G'], ['R', 'R', 'R', 'R']]) == [\\"Yes\\", \\"Yes\\", \\"No\\"]","solution":"def can_avoid_deadlock(T, test_cases): results = [] for case in test_cases: if 'G' in case: results.append(\\"Yes\\") else: results.append(\\"No\\") return results"},{"question":"def find_smallest_missing_positive(n: int, arr: List[int]) -> int: Identifies the smallest missing positive integer from a sorted list of distinct integers. Parameters: n (int): The number of integers in the list. arr (list of int): The sorted list of integers. Returns: int: The smallest missing positive integer. Example: >>> find_smallest_missing_positive(5, [-3, -1, 2, 3, 7]) 1 >>> find_smallest_missing_positive(4, [1, 2, 3, 4]) 5 >>> find_smallest_missing_positive(6, [-5, -2, 1, 2, 3, 10]) 4 # Unit tests def test_example_1(): assert find_smallest_missing_positive(5, [-3, -1, 2, 3, 7]) == 1 def test_example_2(): assert find_smallest_missing_positive(4, [1, 2, 3, 4]) == 5 def test_example_3(): assert find_smallest_missing_positive(6, [-5, -2, 1, 2, 3, 10]) == 4 def test_only_positive_numbers(): assert find_smallest_missing_positive(3, [1, 2, 6]) == 3 def test_only_negative_numbers(): assert find_smallest_missing_positive(4, [-4, -3, -2, -1]) == 1 def test_mixed_numbers(): assert find_smallest_missing_positive(6, [-5, -4, -1, 1, 2, 5]) == 3 def test_large_list(): n = 100000 arr = list(range(1, n + 1)) assert find_smallest_missing_positive(n, arr) == n + 1","solution":"def find_smallest_missing_positive(n, arr): Returns the smallest missing positive integer in a sorted list of distinct integers. Parameters: n (int): The number of integers in the list. arr (list of int): The sorted list of integers. Returns: int: The smallest missing positive integer. current = 1 for num in arr: if num == current: current += 1 elif num > current: break return current"},{"question":"def nth_fibonacci_like(a: int, b: int, n: int) -> int: Returns the nth number in a Fibonacci-like sequence starting with a and b. Args: a (int): The first number in the sequence. b (int): The second number in the sequence. n (int): The position of the number in the sequence to return. Returns: int: The nth number in the sequence. >>> nth_fibonacci_like(1, 2, 1) 1 >>> nth_fibonacci_like(1, 2, 2) 2 >>> nth_fibonacci_like(1, 2, 5) 8 >>> nth_fibonacci_like(2, 3, 3) 5 >>> nth_fibonacci_like(-1, 1, 4) 1","solution":"def nth_fibonacci_like(a, b, n): Returns the nth number in a Fibonacci-like sequence starting with a and b. if n == 1: return a elif n == 2: return b for _ in range(3, n+1): a, b = b, a + b return b"},{"question":"def is_palindrome(s: str) -> str: Determine if a string is a palindrome. Returns \\"YES\\" if the string s is a palindrome, otherwise \\"NO\\". >>> is_palindrome(\\"racecar\\") \\"YES\\" >>> is_palindrome(\\"hello\\") \\"NO\\" # Your code here","solution":"def is_palindrome(s): Returns \\"YES\\" if the string s is a palindrome, otherwise \\"NO\\". if s == s[::-1]: return \\"YES\\" return \\"NO\\""},{"question":"from typing import List, Optional def isValidBST(tree: List[Optional[int]]) -> bool: Determine whether a binary tree is a binary search tree (BST). A binary search tree is a tree in which for each node, all elements in the left subtree are less than the node, and all elements in the right subtree are greater than the node. Args: tree (List[Optional[int]]): A serialized binary tree, where \`null\` values represent absent children nodes. Returns: bool: True if the tree is a binary search tree, False otherwise. Examples: >>> isValidBST([2, 1, 3]) True >>> isValidBST([5, 1, 4, None, None, 3, 6]) False","solution":"from typing import List, Optional, Tuple def isValidBST(tree: List[Optional[int]]) -> bool: # Helper function to traverse and check the validity of BST def traverse_and_validate(index: int, low: float, high: float) -> Tuple[bool, float, float]: if index >= len(tree) or tree[index] is None: return (True, low, high) val = tree[index] # Check the current node value in the bounds if val <= low or val >= high: return (False, low, high) left_idx = 2 * index + 1 right_idx = 2 * index + 2 # Validate left subtree left_valid, _, _ = traverse_and_validate(left_idx, low, val) if not left_valid: return (False, low, high) # Validate right subtree right_valid, _, _ = traverse_and_validate(right_idx, val, high) if not right_valid: return (False, low, high) return (True, low, high) # Initiate the recursive validation with lowest and highest possible values result, _, _ = traverse_and_validate(0, float('-inf'), float('inf')) return result"},{"question":"def calculate_leaves(n: int) -> int: Calculate the number of leaves the plant will have at the end of day n. On each odd day, the plant grows a leaf, and on each even day, it sheds a leaf. Parameters: n (int): The number of days Jane observes the plant. Returns: int: The number of leaves on the nth day. Examples: >>> calculate_leaves(5) 3 >>> calculate_leaves(10) 5 >>> calculate_leaves(1) 1","solution":"def calculate_leaves(n): This function calculates the number of leaves the plant will have at the end of day n. On each odd day, the plant grows a leaf, and on each even day, it sheds a leaf. Parameters: n (int): The number of days observed. Returns: int: The number of leaves on the nth day. # The number of leaves the plant will have is given by the integer division of days by 2 # and as the cycle is growing and shedding a leaf each day. return (n + 1) // 2"},{"question":"def max_unique_subarray_sum(n: int, array: List[int]) -> int: Returns the maximum sum of any contiguous subarray with all unique elements. Parameters: n (int): number of elements in array. array (list): list of integers representing the array elements. Returns: int: maximum sum of any contiguous subarray with all unique elements. >>> max_unique_subarray_sum(5, [1, 2, 3, 2, 1]) 6 >>> max_unique_subarray_sum(4, [1, 2, 3, 4]) 10 from solution import max_unique_subarray_sum def test_example_1(): assert max_unique_subarray_sum(5, [1, 2, 3, 2, 1]) == 6 def test_example_2(): assert max_unique_subarray_sum(4, [1, 2, 3, 4]) == 10 def test_single_element(): assert max_unique_subarray_sum(1, [5]) == 5 def test_all_duplicates(): assert max_unique_subarray_sum(5, [2, 2, 2, 2, 2]) == 2 def test_no_duplicates(): assert max_unique_subarray_sum(6, [1, 3, 5, 7, 9, 11]) == 36 def test_mixed_elements(): assert max_unique_subarray_sum(8, [4, 5, 6, 7, 4, 6, 7, 3]) == 22","solution":"def max_unique_subarray_sum(n, array): Returns the maximum sum of any contiguous subarray with all unique elements. Parameters: n (int): number of elements in array. array (list): list of integers representing the array elements. Returns: int: maximum sum of any contiguous subarray with all unique elements. seen = set() max_sum = 0 current_sum = 0 left = 0 for right in range(n): while array[right] in seen: seen.remove(array[left]) current_sum -= array[left] left += 1 seen.add(array[right]) current_sum += array[right] max_sum = max(max_sum, current_sum) return max_sum"},{"question":"def find_pattern_occurrences(n, m, document, patterns): Determine the number of times each pattern appears contiguously in the document. >>> find_pattern_occurrences(10, 3, [\\"the\\", \\"quick\\", \\"brown\\", \\"fox\\", \\"jumps\\", \\"over\\", \\"the\\", \\"lazy\\", \\"dog\\", \\"quick\\"], [[\\"quick\\", \\"brown\\", \\"fox\\"], [\\"the\\", \\"lazy\\", \\"dog\\"], [\\"jumps\\", \\"over\\", \\"the\\"]]) [1, 1, 1]","solution":"def find_pattern_occurrences(n, m, document, patterns): results = [] document_text = ' '.join(document) for pattern in patterns: pattern_text = ' '.join(pattern) count = document_text.count(pattern_text) results.append(count) return results # Example input n = 10 m = 3 document = [\\"the\\", \\"quick\\", \\"brown\\", \\"fox\\", \\"jumps\\", \\"over\\", \\"the\\", \\"lazy\\", \\"dog\\", \\"quick\\"] patterns = [ [\\"quick\\", \\"brown\\", \\"fox\\"], [\\"the\\", \\"lazy\\", \\"dog\\"], [\\"jumps\\", \\"over\\", \\"the\\"] ] # Printing output for verification print(find_pattern_occurrences(n, m, document, patterns))"},{"question":"def rank_contestants(n: int, contestants: List[Tuple[int, int, int]]) -> List[int]: Ranks contestants based on the number of problems they solved, the total time taken to solve them, and their contestant ID. Args: n (int): The number of contestants. contestants (list of tuples): Each tuple consists of three integers (ID, problems_solved, total_time). Returns: list of int: The list of contestant IDs sorted according to the rules. pass # You need to implement this function # Test cases def test_single_contestant(): assert rank_contestants(1, [(101, 3, 300)]) == [101] def test_equal_problems_different_time(): assert rank_contestants(3, [(101, 2, 200), (102, 2, 100), (103, 2, 150)]) == [102, 103, 101] def test_equal_problems_and_time(): assert rank_contestants(3, [(101, 2, 150), (102, 2, 150), (103, 2, 150)]) == [101, 102, 103] def test_varied_problems(): assert rank_contestants(3, [(101, 3, 300), (102, 2, 200), (103, 1, 100)]) == [101, 102, 103] def test_example_1(): assert rank_contestants(4, [(101, 3, 300), (102, 3, 350), (103, 2, 260), (104, 3, 300)]) == [101, 104, 102, 103] def test_example_2(): assert rank_contestants(3, [(201, 5, 500), (202, 5, 450), (203, 5, 500)]) == [202, 201, 203] def test_mixed_case(): assert rank_contestants(5, [(101, 2, 100), (102, 1, 400), (103, 3, 300), (104, 3, 200), (105, 2, 1000)]) == [104, 103, 101, 105, 102]","solution":"def rank_contestants(n, contestants): Ranks contestants based on the number of problems they solved, the total time taken to solve them, and their contestant ID. Args: n (int): The number of contestants. contestants (list of tuples): Each tuple consists of three integers (ID, problems_solved, total_time). Returns: list of int: The list of contestant IDs sorted according to the rules. # Sort the contestants according to the given rules sorted_contestants = sorted( contestants, key=lambda x: (-x[1], x[2], x[0]) ) # Extract the IDs of sorted contestants sorted_ids = [contestant[0] for contestant in sorted_contestants] return sorted_ids"},{"question":"def max_score(n: int, beads: str) -> int: Returns the maximum score Harry can achieve by removing consecutive beads of the same color. Parameters: n (int): Number of beads beads (str): Initial sequence of beads Returns: int: Maximum score >>> max_score(4, 'RRRR') 16 >>> max_score(5, 'RRGGG') 13 >>> max_score(3, 'RGB') 3 >>> max_score(9, 'RRGGBBBRR') 21 >>> max_score(6, 'GGGGGG') 36 >>> max_score(6, 'RGRGRG') 6","solution":"def max_score(n, beads): Returns the maximum score Harry can achieve by removing consecutive beads of the same color. Parameters: n (int): Number of beads beads (str): Initial sequence of beads Returns: int: Maximum score score = 0 i = 0 while i < n: # Start of consecutive beads start = i while i < n and beads[i] == beads[start]: i += 1 # Number of consecutive beads count = i - start # Calculate score for this group score += count * count return score"},{"question":"def latest_temperature_readings(readings, target_points): Identify the latest temperature recorded at each of the target points. Parameters: readings (list of tuple): Each tuple contains four integers (t, x, y, time) where t is the recorded temperature, x and y are the coordinates of the location, and time is the time of the reading. target_points (list of tuple): Each tuple contains two integers (x, y) which are the coordinates of the target points. Returns: list: The latest temperature recorded at each target point or \\"NO DATA\\" if no reading is available. from solution import latest_temperature_readings def test_latest_temperature_readings_example_1(): readings = [ (20, 10, 10, 1), (25, 10, 10, 3), (15, 20, 20, 2), (30, 20, 20, 5), (10, 30, 30, 4) ] target_points = [ (10, 10), (20, 20), (30, 30) ] assert latest_temperature_readings(readings, target_points) == [25, 30, 10] def test_latest_temperature_readings_example_2(): readings = [ (20, 15, 15, 2), (25, 25, 25, 3), (30, 35, 35, 1) ] target_points = [ (30, 30), (25, 25) ] assert latest_temperature_readings(readings, target_points) == [\\"NO DATA\\", 25] def test_latest_temperature_readings_no_readings(): readings = [] target_points = [ (10, 10), (15, 15) ] assert latest_temperature_readings(readings, target_points) == [\\"NO DATA\\", \\"NO DATA\\"] def test_latest_temperature_readings_all_no_data(): readings = [ (20, 10, 10, 1), (25, 10, 10, 2), (15, 20, 20, 3) ] target_points = [ (30, 30), (40, 40) ] assert latest_temperature_readings(readings, target_points) == [\\"NO DATA\\", \\"NO DATA\\"] def test_latest_temperature_readings_mixed(): readings = [ (20, 10, 10, 1), (25, 10, 10, 2), (15, 20, 20, 3), (30, 20, 20, 4), (10, 30, 30, 5) ] target_points = [ (10, 10), (20, 20), (25, 25) ] assert latest_temperature_readings(readings, target_points) == [25, 30, \\"NO DATA\\"]","solution":"def latest_temperature_readings(readings, target_points): Identify the latest temperature recorded at each of the target points. Parameters: readings (list of tuple): Each tuple contains four integers (t, x, y, time) where t is the recorded temperature, x and y are the coordinates of the location, and time is the time of the reading. target_points (list of tuple): Each tuple contains two integers (x, y) which are the coordinates of the target points. Returns: list: The latest temperature recorded at each target point or \\"NO DATA\\" if no reading is available. # Create a dictionary to store the latest reading at each coordinate latest_readings = {} for t, x, y, time in readings: if (x, y) not in latest_readings or time > latest_readings[(x, y)][1]: latest_readings[(x, y)] = (t, time) result = [] for x, y in target_points: if (x, y) in latest_readings: result.append(latest_readings[(x, y)][0]) else: result.append(\\"NO DATA\\") return result"},{"question":"def calculate_difference(n: int, m: int, k: int) -> int: Calculate the difference (n * m) - k. Args: n (int): The first integer input. m (int): The second integer input. k (int): The third integer input. Returns: int: The result of (n * m) - k. >>> calculate_difference(5, 5, 3) 22 >>> calculate_difference(10, 6, 15) 45 >>> calculate_difference(8, 8, 20) 44 >>> calculate_difference(1, 1, 1) 0 >>> calculate_difference(100, 100, 500) 9500 >>> calculate_difference(7, 3, 10) 11 >>> calculate_difference(15, 12, 50) 130 >>> calculate_difference(9, 9, 81) 0","solution":"def calculate_difference(n, m, k): Calculate the difference (n * m) - k. return (n * m) - k"},{"question":"def is_path_exists(H: int, W: int, grid: List[List[int]]) -> str: Determine if the grid has a path of 1s from the top-left corner (1,1) to the bottom-right corner (H,W). >>> is_path_exists(3, 3, [[1, 0, 1], [1, 1, 0], [0, 1, 1]]) 'Yes' >>> is_path_exists(2, 2, [[1, 0], [0, 1]]) 'No'","solution":"def is_path_exists(H, W, grid): def is_valid(x, y): return 0 <= x < H and 0 <= y < W and grid[x][y] == 1 def dfs(x, y): if x == H - 1 and y == W - 1: return True # Mark cell as visited grid[x][y] = -1 # Explore all possible directions directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] for dx, dy in directions: nx, ny = x + dx, y + dy if is_valid(nx, ny) and grid[nx][ny] == 1: if dfs(nx, ny): return True return False if grid[0][0] == 1 and grid[H-1][W-1] == 1: if dfs(0, 0): return \\"Yes\\" return \\"No\\" # Example usage: H = 3 W = 3 grid = [ [1, 0, 1], [1, 1, 0], [0, 1, 1] ] print(is_path_exists(H, W, grid)) # Output: Yes"},{"question":"import heapq from typing import List def dijkstra(n: int, distances: List[List[int]], start: int) -> List[int]: Computes the shortest distance needed for a drone to deliver a package from its starting intersection (the delivery station) to all other intersections in the city. Args: n (int): The number of intersections in the city. distances (List[List[int]]): A list of lists where the j-th integer in the i-th list is the distance between intersection i and intersection j. start (int): The starting intersection. Returns: List[int]: A list where the i-th integer is the shortest distance from the starting intersection to intersection i. If an intersection is unreachable from the starting intersection, returns -1 for that intersection. pass # Example test cases if __name__ == \\"__main__\\": n = 4 distances = [ [0, 1, 4, 100000], [1, 0, 2, 6], [4, 2, 0, 3], [100000, 6, 3, 0] ] start = 1 print(dijkstra(n, distances, start)) # Expected output: [0, 1, 3, 6] n = 3 distances = [ [0, 1, 100000], [1, 0, 100000], [100000, 100000, 0] ] start = 1 print(dijkstra(n, distances, start)) # Expected output: [0, 1, -1]","solution":"import heapq def dijkstra(n, distances, start): start -= 1 # To convert 1-based index to 0-based index visited = [False] * n min_distances = [float('inf')] * n min_distances[start] = 0 priority_queue = [(0, start)] while priority_queue: current_distance, current_node = heapq.heappop(priority_queue) if visited[current_node]: continue visited[current_node] = True for neighbor in range(n): if visited[neighbor]: continue distance = distances[current_node][neighbor] if distance == 100000: continue new_distance = current_distance + distance if new_distance < min_distances[neighbor]: min_distances[neighbor] = new_distance heapq.heappush(priority_queue, (new_distance, neighbor)) result = [] for distance in min_distances: if distance == float('inf'): result.append(-1) else: result.append(distance) return result"},{"question":"def max_profit(prices: List[int]) -> int: Returns the maximum profit that can be achieved from a single buy-sell transaction. If no profit can be made, returns 0. >>> max_profit([7, 1, 5, 3, 6, 4]) 5 >>> max_profit([7, 6, 4, 3, 1]) 0 >>> max_profit([3, 3, 3, 3, 3]) 0 >>> max_profit([1]) 0 >>> max_profit([1, 2, 3, 4, 5]) 4 >>> max_profit([5, 4, 3, 2, 1]) 0 >>> max_profit([i for i in range(100000, 0, -1)]) 0 >>> max_profit([2, 1, 4, 3, 6, 5, 8, 7]) 7 pass","solution":"def max_profit(prices): Returns the maximum profit that can be achieved from a single buy-sell transaction. If no profit can be made, returns 0. if not prices or len(prices) < 2: return 0 min_price = prices[0] max_profit = 0 for price in prices[1:]: profit = price - min_price if profit > max_profit: max_profit = profit if price < min_price: min_price = price return max_profit"},{"question":"def is_road_network_connected(grid: List[List[str]]) -> bool: Determine if the vehicle can travel between any two road cells. Args: grid (List[List[str]]): a grid representing the city map with 'R' as roads and 'B' as buildings. Returns: bool: True if any road cell is reachable from every other road cell, otherwise False. >>> grid = [ ... ['R', 'R', 'B', 'R'], ... ['R', 'B', 'R', 'R'], ... ['R', 'R', 'R', 'B'] ... ] >>> is_road_network_connected(grid) True >>> grid = [ ... ['R', 'B', 'R', 'B'], ... ['B', 'B', 'B', 'R'], ... ['R', 'R', 'R', 'B'] ... ] >>> is_road_network_connected(grid) False","solution":"def is_road_network_connected(grid): n, m = len(grid), len(grid[0]) def valid(x, y): return 0 <= x < n and 0 <= y < m def dfs(x, y, visited): stack = [(x, y)] while stack: cx, cy = stack.pop() visited[cx][cy] = True for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nx, ny = cx + dx, cy + dy if valid(nx, ny) and not visited[nx][ny] and grid[nx][ny] == 'R': stack.append((nx, ny)) visited = [[False] * m for _ in range(n)] start_candidate = None for i in range(n): for j in range(m): if grid[i][j] == 'R': start_candidate = (i, j) break if start_candidate: break if not start_candidate: return True start_x, start_y = start_candidate dfs(start_x, start_y, visited) for i in range(n): for j in range(m): if grid[i][j] == 'R' and not visited[i][j]: return False return True"},{"question":"from typing import List, Tuple def minimum_transport_cost(n: int, m: int, r: int, s: int, routes: List[Tuple[int, int, int]]) -> int: Calculate the minimum transport cost required to send products from a specific production site to any warehouse. >>> minimum_transport_cost(4, 3, 5, 2, [(1, 2, 10), (2, 3, 5), (2, 5, 20), (3, 4, 2), (4, 6, 1)]) 8 >>> minimum_transport_cost(3, 3, 4, 1, [(1, 4, 10), (2, 5, 20), (3, 6, 30), (1, 2, 5)]) 10 def test_minimum_transport_cost(): assert minimum_transport_cost(4, 3, 5, 2, [(1, 2, 10), (2, 3, 5), (2, 5, 20), (3, 4, 2), (4, 6, 1)]) == 8 assert minimum_transport_cost(3, 3, 4, 1, [(1, 4, 10), (2, 5, 20), (3, 6, 30), (1, 2, 5)]) == 10 assert minimum_transport_cost(2, 2, 2, 1, [(1, 2, 10), (3, 4, 20)]) == -1 assert minimum_transport_cost(1, 1, 1, 1, [(1, 2, 5)]) == 5 assert minimum_transport_cost(2, 1, 2, 1, [(1, 2, 1), (2, 3, 2)]) == 3","solution":"import heapq import sys def minimum_transport_cost(n, m, r, s, routes): # Create the graph INF = sys.maxsize graph = {i: [] for i in range(1, n + m + 1)} for a, b, c in routes: graph[a].append((c, b)) graph[b].append((c, a)) # Dijkstra's algorithm to find the shortest path from the starting production site to any warehouse pq = [(0, s)] distances = {i: INF for i in range(1, n + m + 1)} distances[s] = 0 visited = set() while pq: current_distance, current_node = heapq.heappop(pq) if current_node in visited: continue visited.add(current_node) for edge_weight, neighbor in graph[current_node]: distance = current_distance + edge_weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(pq, (distance, neighbor)) # Find the minimum distance to any warehouse (nodes n+1 to n+m) min_cost = min(distances[i] for i in range(n + 1, n + m + 1)) return min_cost if min_cost != INF else -1"},{"question":"def shortest_delivery_route(n: int, points: List[int]) -> int: Calculate the shortest possible route to visit all delivery points and return to the starting point. Args: n: An integer, the number of delivery points. points: A list of integers, representing the coordinates of the delivery points. Returns: An integer representing the shortest possible distance. Examples: >>> shortest_delivery_route(4, [3, 6, 1, 2]) 10 >>> shortest_delivery_route(3, [10, 20, 30]) 40","solution":"def shortest_delivery_route(n, points): Calculate the shortest possible route to visit all delivery points and return to the starting point. Args: n: An integer, the number of delivery points. points: A list of integers, representing the coordinates of the delivery points. Returns: An integer representing the shortest possible distance. points.sort() total_distance = (points[-1] - points[0]) * 2 return total_distance"},{"question":"from typing import List def min_steps_bfs(grid: List[List[int]]) -> int: Determine the minimum number of steps required for an entity to move from the top-left corner to the bottom-right corner of the grid consisting of empty cells and obstacles. If there is no path from the top-left corner to the bottom-right corner, return -1. Args: grid (List[List[int]]): A 2D grid consisting of '0' (empty cell) and '1' (cell with obstacle) Returns: int: The minimum number of steps required to move from the top-left to the bottom-right, or -1 if it's not possible. Examples: >>> min_steps_bfs([[0, 0, 0], [1, 1, 0], [0, 0, 0]]) 4 >>> min_steps_bfs([[0, 1], [1, 0]]) -1 def test_min_steps_bfs(): assert min_steps_bfs([ [0, 0, 0], [1, 1, 0], [0, 0, 0] ]) == 4 assert min_steps_bfs([ [0, 1], [1, 0] ]) == -1 assert min_steps_bfs([ [0, 0, 1, 0, 0], [1, 0, 1, 0, 1], [1, 0, 0, 0, 1], [0, 1, 1, 0, 0], [0, 0, 0, 1, 0] ]) == 8 assert min_steps_bfs([ [0] ]) == 0 assert min_steps_bfs([ [0, 0, 0, 0], [0, 1, 1, 0], [0, 0, 0, 0] ]) == 5 assert min_steps_bfs([ [1, 0, 0], [0, 0, 0], [0, 0, 0] ]) == -1 assert min_steps_bfs([ [0, 1, 1], [1, 0, 1], [1, 0, 0] ]) == -1","solution":"from collections import deque def min_steps_bfs(grid): n = len(grid) m = len(grid[0]) if grid[0][0] == 1 or grid[n-1][m-1] == 1: return -1 directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([(0, 0, 0)]) # (row, col, steps) visited = set((0, 0)) while queue: r, c, steps = queue.popleft() if r == n-1 and c == m-1: return steps for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < n and 0 <= nc < m and (nr, nc) not in visited and grid[nr][nc] == 0: visited.add((nr, nc)) queue.append((nr, nc, steps + 1)) return -1"},{"question":"def process_operations(n: int, q: int, elements: List[int], operations: List[List[int]]) -> List[int]: Perform the given operations on an array of integers. Args: n (int): Number of elements in the array. q (int): Number of queries. elements (List[int]): Initial elements of the array. operations (List[List[int]]): List of operations to perform on the array. Returns: List[int]: Result of sum and max operations. Example: >>> n = 5 >>> q = 5 >>> elements = [1, 2, 3, 4, 5] >>> operations = [[2, 1, 3], [1, 2, 10], [2, 1, 3], [3, 2, 4], [3, 1, 5]] >>> process_operations(n, q, elements, operations) [6, 14, 10, 10] from solution import process_operations def test_process_operations_case_1(): n = 5 q = 5 elements = [1, 2, 3, 4, 5] operations = [[2, 1, 3], [1, 2, 10], [2, 1, 3], [3, 2, 4], [3, 1, 5]] expected = [6, 14, 10, 10] assert process_operations(n, q, elements, operations) == expected def test_process_operations_case_2(): n = 3 q = 4 elements = [5, 6, 7] operations = [[2, 1, 3], [1, 1, 1], [2, 1, 3], [3, 1, 3]] expected = [18, 14, 7] assert process_operations(n, q, elements, operations) == expected def test_process_operations_case_3(): n = 4 q = 3 elements = [1, 3, 5, 7] operations = [[3, 1, 4], [1, 4, 10], [3, 1, 4]] expected = [7, 10] assert process_operations(n, q, elements, operations) == expected def test_process_operations_case_4(): n = 2 q = 2 elements = [1, 2] operations = [[2, 1, 2], [1, 1, 5]] expected = [3] assert process_operations(n, q, elements, operations) == expected","solution":"def process_operations(n, q, elements, operations): results = [] for operation in operations: op_type = operation[0] if op_type == 1: # Update operation x = operation[1] - 1 y = operation[2] elements[x] = y elif op_type == 2: # Sum operation l = operation[1] - 1 r = operation[2] results.append(sum(elements[l:r])) elif op_type == 3: # Max operation l = operation[1] - 1 r = operation[2] results.append(max(elements[l:r])) return results"},{"question":"def find_unique_triplets(N: int, nums: List[int]) -> List[List[int]]: Returns unique triplets from the list which give the sum of zero. >>> find_unique_triplets(6, [-1, 0, 1, 2, -1, -4]) == [[-1, -1, 2], [-1, 0, 1]] >>> find_unique_triplets(3, [0, 1, -1]) == [[-1, 0, 1]] >>> find_unique_triplets(4, [1, 2, 3, 4]) == [] >>> find_unique_triplets(5, [-1, -2, -3, -4, -5]) == [] >>> find_unique_triplets(4, [0, 0, 0, 0]) == [[0, 0, 0]] >>> find_unique_triplets(5, [-1, 0, 1, 1, -1]) == [[-1, 0, 1]]","solution":"def find_unique_triplets(N, nums): Returns unique triplets from the list which give the sum of zero. nums.sort() triplets = [] for i in range(N): if i > 0 and nums[i] == nums[i - 1]: continue left, right = i + 1, N - 1 while left < right: current_sum = nums[i] + nums[left] + nums[right] if current_sum == 0: triplets.append([nums[i], nums[left], nums[right]]) left += 1 right -= 1 while left < right and nums[left] == nums[left - 1]: left += 1 while left < right and nums[right] == nums[right + 1]: right -= 1 elif current_sum < 0: left += 1 else: right -= 1 return triplets"},{"question":"from typing import List, Tuple def largest_valid_combination(n: int, products: List[Tuple[str, str]]) -> Tuple[int, List[str]]: Finds the largest combination of products that can be sold together before they expire. Parameters: - n (int): The number of products. - products (list of tuples): Each tuple contains a product ID and its expiration date as a string. Returns: - Tuple[int, List[str]]: The size of the largest valid combination of products and the product IDs of the largest valid combination. Examples: >>> largest_valid_combination(5, [(\\"apple\\", \\"2023-12-01\\"), (\\"banana\\", \\"2023-11-30\\"), (\\"cherry\\", \\"2023-12-01\\"), (\\"date\\", \\"2023-11-28\\"), (\\"elderberry\\", \\"2023-12-01\\")]) (3, [\\"apple\\", \\"cherry\\", \\"elderberry\\"]) >>> largest_valid_combination(1, [(\\"apple\\", \\"2023-12-01\\")]) (1, [\\"apple\\"]) def process_input(input_str: str) -> Tuple[int, List[str]]: Parses the input string and finds the largest valid combination of products. Parameters: - input_str (str): The input string containing the number of products and their IDs with expiration dates. Returns: - Tuple[int, List[str]]: The size of the largest valid combination of products and the product IDs of the largest valid combination. Examples: >>> process_input(\\"5napple 2023-12-01nbanana 2023-11-30ncherry 2023-12-01ndate 2023-11-28nelderberry 2023-12-01\\") (3, [\\"apple\\", \\"cherry\\", \\"elderberry\\"]) >>> process_input(\\"1napple 2023-12-01\\") (1, [\\"apple\\"])","solution":"from collections import defaultdict from datetime import datetime def largest_valid_combination(n, products): Finds the largest combination of products that can be sold together before they expire. Parameters: - n (int): The number of products. - products (list of tuples): Each tuple contains a product ID and its expiration date as a string. Returns: - m (int): The size of the largest valid combination of products. - result (list of strings): The product IDs of the largest valid combination. product_dict = defaultdict(list) # Group products by expiration date for product_id, expiration_date in products: product_dict[expiration_date].append(product_id) # Find the group with the maximum size max_group_size = 0 max_group = [] for date, product_list in product_dict.items(): if len(product_list) > max_group_size: max_group_size = len(product_list) max_group = product_list return max_group_size, max_group # Function to parse input and call the largest_valid_combination function def process_input(input_str): lines = input_str.strip().split('n') n = int(lines[0]) products = [tuple(line.split()) for line in lines[1:]] m, result = largest_valid_combination(n, products) return m, result"},{"question":"def can_cross_river(n, k, river): Determines if the fisherman can cross the river with the given constraints. Parameters: n (int): The length of the river string. k (int): The maximum number of water segments that can be skipped. river (str): The string representation of the river. Returns: str: 'YES' if the fisherman can cross the river, 'NO' otherwise. >>> can_cross_river(7, 1, 'LWLWLWL') 'YES' >>> can_cross_river(5, 0, 'LWWLW') 'NO' >>> can_cross_river(10, 3, 'LWWWLWLWLW') 'YES' >>> can_cross_river(5, 2, 'WWWWW') 'NO' >>> can_cross_river(5, 1, 'LLLLL') 'YES' >>> can_cross_river(3, 0, 'LWW') 'NO' >>> can_cross_river(3, 1, 'WWW') 'NO' >>> can_cross_river(1, 0, 'L') 'YES' >>> can_cross_river(6, 2, 'LWLWLW') 'YES' >>> can_cross_river(6, 0, 'LWLWLW') 'NO'","solution":"def can_cross_river(n, k, river): Determines if the fisherman can cross the river with the given constraints. Parameters: n (int): The length of the river string. k (int): The maximum number of water segments that can be skipped. river (str): The string representation of the river. Returns: str: 'YES' if the fisherman can cross the river, 'NO' otherwise. water_segment_count = 0 land_segments = [False] * n # Mark positions that are land for i in range(n): if river[i] == 'L': land_segments[i] = True # Fisherman can start from any 'L' and move to any consecutive # 'L' while skipping up to k 'W'. started = False skipped = 0 for i in range(n): if land_segments[i]: started = True skipped = 0 elif started: skipped += 1 if skipped > k: started = False if started: return \\"YES\\" else: return \\"NO\\""},{"question":"def find_longest_even_odd_subarray(arr: List[int]) -> Tuple[int, int]: Given an array of integers, find the longest contiguous subarray that has an equal number of even and odd integers. :param arr: List of integers :return: Tuple containing starting and ending indices of the longest subarray with equal number of even and odd integers (1-indexed). If no such subarray exists, return (-1, -1) >>> find_longest_even_odd_subarray([1, 2, 3, 4, 5, 6]) (1, 6) >>> find_longest_even_odd_subarray([2, 4, 6, 8, 10]) (-1, -1) >>> find_longest_even_odd_subarray([2, 2, 2, 2, 1, 1, 1, 1]) (1, 8) >>> find_longest_even_odd_subarray([5, 6, 7, 8, 9, 10, 11, 12]) (1, 8)","solution":"def find_longest_even_odd_subarray(arr): Finds the longest contiguous subarray with equal number of even and odd integers. n = len(arr) if n == 0: return -1, -1 # Dictionary to store the first occurrence of the difference between even and odd counts first_occurrence = {0: -1} max_length = 0 start_index = -1 end_index = -1 even_count = 0 odd_count = 0 for i in range(n): # Counting evens and odds if arr[i] % 2 == 0: even_count += 1 else: odd_count += 1 # Current difference between even and odd counts current_diff = even_count - odd_count if current_diff in first_occurrence: if i - first_occurrence[current_diff] > max_length: max_length = i - first_occurrence[current_diff] start_index = first_occurrence[current_diff] + 1 end_index = i else: first_occurrence[current_diff] = i if max_length == 0: return -1, -1 else: return start_index + 1, end_index + 1 def process_input_and_output(): # Read input import sys input = sys.stdin.read data = input().split() n = int(data[0]) arr = list(map(int, data[1:1+n])) l, r = find_longest_even_odd_subarray(arr) print(l, r)"},{"question":"def max_profit(prices): Returns the maximum profit that can be obtained from a single buy and sell transaction. If no profit can be made, returns 0. >>> max_profit([7, 1, 5, 3, 6, 4]) 5 >>> max_profit([7, 6, 4, 3, 1]) 0 >>> max_profit([5]) 0 >>> max_profit([2, 4, 1, 7]) 6 >>> max_profit([8, 7, 6, 5, 4]) 0 >>> max_profit([1, 2, 3, 0, 2]) 2 >>> max_profit([5] * 100000) 0 >>> max_profit([i for i in range(100000)]) 99999","solution":"def max_profit(prices): Returns the maximum profit that can be obtained from a single buy and sell transaction. If no profit can be made, returns 0. if not prices: return 0 min_price = float('inf') max_profit = 0 for price in prices: if price < min_price: min_price = price elif price - min_price > max_profit: max_profit = price - min_price return max_profit"},{"question":"def rotate_string(s: str, N: int) -> str: Rotate the string by removing the last character and appending it to the beginning N times. Parameters: s (str): The input string. N (int): The number of times to perform the operation. Returns: str: The resulting string after N operations. Examples: >>> rotate_string(\\"abcde\\", 2) 'deabc' >>> rotate_string(\\"hello\\", 1) 'ohell' >>> rotate_string(\\"rotate\\", 6) 'rotate'","solution":"def rotate_string(s, N): Rotate the string by removing the last character and appending it to the beginning N times. Parameters: s (str): The input string. N (int): The number of times to perform the operation. Returns: str: The resulting string after N operations. n = len(s) N = N % n # To handle cases where N > len(s) if N == 0: return s return s[-N:] + s[:-N]"},{"question":"def choose_outfit(sr, sg, sb, pr, pg, pb, shr, shg, shb): Returns the best matching outfit given the stock counts for shirts, pants, and shoes in red, green, and blue. Args: sr (int): number of red shirts sg (int): number of green shirts sb (int): number of blue shirts pr (int): number of red pants pg (int): number of green pants pb (int): number of blue pants shr (int): number of red shoes shg (int): number of green shoes shb (int): number of blue shoes Returns: tuple: (shirt_color, pants_color, shoes_color) Examples: >>> choose_outfit(5, 0, 2, 1, 1, 1, 2, 0, 3) ('red', 'red', 'red') >>> choose_outfit(0, 4, 3, 1, 2, 1, 0, 5, 2) ('green', 'green', 'green') >>> choose_outfit(5, 3, 0, 4, 2, 2, 3, 3, 3) ('red', 'red', 'red') >>> choose_outfit(1, 1, 1, 1, 1, 1, 1, 1, 1) ('red', 'red', 'red')","solution":"def choose_outfit(sr, sg, sb, pr, pg, pb, shr, shg, shb): Returns the best matching outfit given the stock counts for shirts, pants, and shoes in red, green, and blue. outfits = [ ('red', sr, pr, shr), ('green', sg, pg, shg), ('blue', sb, pb, shb), ] # Sorting outfits to make sure we prefer the tie-breaking order: red > green > blue outfits.sort(key=lambda x: (x[1], x[2], x[3]), reverse=True) best_outfit = outfits[0] return best_outfit[0], best_outfit[0], best_outfit[0]"},{"question":"class MinStack: def __init__(self): self.stack = [] self.min_stack = [] def push(self, x): Push the integer x onto the stack. pass def pop(self): Remove the top element from the stack. If the stack is empty, do nothing. pass def top(self): Return the top element of the stack. If the stack is empty, return \\"EMPTY\\". pass def get_min(self): Return the smallest element currently in the stack. If the stack is empty, return \\"EMPTY\\". pass def process_commands(commands): Process a list of commands to manipulate an initially empty stack and perform operations on it. :param commands: List of commands to execute on the stack. :return: List with results of 'TOP' and 'GET_MIN' commands. Example: >>> process_commands([\\"PUSH 5\\", \\"TOP\\"]) [5] >>> process_commands([\\"PUSH 5\\", \\"PUSH 3\\", \\"GET_MIN\\"]) [3] stack = MinStack() results = [] for command in commands: if command.startswith(\\"PUSH\\"): _, x = command.split() stack.push(int(x)) elif command == \\"POP\\": stack.pop() elif command == \\"TOP\\": results.append(stack.top()) elif command == \\"GET_MIN\\": results.append(stack.get_min()) return results def test_single_push(): commands = [\\"PUSH 5\\", \\"TOP\\"] assert process_commands(commands) == [5] def test_multiple_push_and_top(): commands = [\\"PUSH 5\\", \\"PUSH 3\\", \\"TOP\\", \\"POP\\", \\"TOP\\"] assert process_commands(commands) == [3, 5] def test_get_min(): commands = [\\"PUSH 5\\", \\"GET_MIN\\", \\"PUSH 3\\", \\"GET_MIN\\"] assert process_commands(commands) == [5, 3] def test_pop_on_empty_stack(): commands = [\\"POP\\", \\"TOP\\", \\"GET_MIN\\"] assert process_commands(commands) == [\\"EMPTY\\", \\"EMPTY\\"] def test_get_min_after_pops(): commands = [\\"PUSH 5\\", \\"PUSH 3\\", \\"POP\\", \\"GET_MIN\\"] assert process_commands(commands) == [5] def test_complex_case(): commands = [\\"PUSH 5\\", \\"TOP\\", \\"GET_MIN\\", \\"PUSH 3\\", \\"GET_MIN\\", \\"POP\\", \\"GET_MIN\\"] assert process_commands(commands) == [5, 5, 3, 5]","solution":"class MinStack: def __init__(self): self.stack = [] self.min_stack = [] def push(self, x): self.stack.append(x) if not self.min_stack or x <= self.min_stack[-1]: self.min_stack.append(x) def pop(self): if self.stack: top = self.stack.pop() if top == self.min_stack[-1]: self.min_stack.pop() def top(self): return self.stack[-1] if self.stack else \\"EMPTY\\" def get_min(self): return self.min_stack[-1] if self.min_stack else \\"EMPTY\\" def process_commands(commands): stack = MinStack() results = [] for command in commands: if command.startswith(\\"PUSH\\"): _, x = command.split() stack.push(int(x)) elif command == \\"POP\\": stack.pop() elif command == \\"TOP\\": results.append(stack.top()) elif command == \\"GET_MIN\\": results.append(stack.get_min()) return results"},{"question":"def sort_manuscripts(M: int, ages: List[int]) -> List[int]: Sort the list of manuscript ages in non-decreasing order, maintaining the relative order of manuscripts with the same age. :param M: int - the number of manuscripts :param ages: list of int - the ages of the manuscripts :return: list of int - the sorted ages of the manuscripts # Unit tests def test_sort_manuscripts_example1(): ages = [5, 3, 2, 3, 2, 6] sorted_ages = sort_manuscripts(6, ages) assert sorted_ages == [2, 2, 3, 3, 5, 6] def test_sort_manuscripts_example2(): ages = [10, 8, 10, 7] sorted_ages = sort_manuscripts(4, ages) assert sorted_ages == [7, 8, 10, 10] def test_sort_manuscripts_single_element(): ages = [5] sorted_ages = sort_manuscripts(1, ages) assert sorted_ages == [5] def test_sort_manuscripts_all_same_age(): ages = [8, 8, 8, 8] sorted_ages = sort_manuscripts(4, ages) assert sorted_ages == [8, 8, 8, 8] def test_sort_manuscripts_decreasing_order(): ages = [9, 7, 5, 3] sorted_ages = sort_manuscripts(4, ages) assert sorted_ages == [3, 5, 7, 9] def test_sort_manuscripts_mixed_ages(): ages = [12, 5, 7, 8, 7, 2] sorted_ages = sort_manuscripts(6, ages) assert sorted_ages == [2, 5, 7, 7, 8, 12]","solution":"def sort_manuscripts(M, ages): Sort the list of manuscript ages in non-decreasing order, maintaining the relative order of manuscripts with the same age. :param M: int - the number of manuscripts :param ages: list of int - the ages of the manuscripts :return: list of int - the sorted ages of the manuscripts return sorted(ages)"},{"question":"def can_fit_packages(shelf_weight: int, package_weights: List[int]) -> bool: Determines if all the given packages can fit on the shelf without exceeding the weight limit. Args: shelf_weight (int): The maximum weight the shelf can hold. package_weights (list of int): The weights of the packages. Returns: bool: True if the total weight of the packages is less than or equal to the shelf weight, False otherwise. >>> can_fit_packages(100, [50, 30, 10, 10]) True >>> can_fit_packages(50, [20, 20, 20]) False >>> can_fit_packages(15, [5, 5, 5]) True from solution import can_fit_packages def test_all_packages_fit(): assert can_fit_packages(100, [50, 30, 10, 10]) == True assert can_fit_packages(15, [5, 5, 5]) == True assert can_fit_packages(50, [20, 10, 10, 10]) == True def test_packages_do_not_fit(): assert can_fit_packages(50, [20, 20, 20]) == False assert can_fit_packages(10, [5, 6]) == False assert can_fit_packages(30, [15, 15, 15]) == False def test_edge_cases(): assert can_fit_packages(50, []) == True assert can_fit_packages(1, [1]) == True assert can_fit_packages(1, [2]) == False def test_single_package(): assert can_fit_packages(100, [100]) == True assert can_fit_packages(99, [100]) == False assert can_fit_packages(50, [50]) == True","solution":"def can_fit_packages(shelf_weight, package_weights): Determines if all the given packages can fit on the shelf without exceeding the weight limit. Args: shelf_weight (int): The maximum weight the shelf can hold. package_weights (list of int): The weights of the packages. Returns: bool: True if the total weight of the packages is less than or equal to the shelf weight, False otherwise. total_weight = sum(package_weights) return total_weight <= shelf_weight"},{"question":"def min_moves_to_make_increasing(power_ranks: List[int]) -> int: Given a list of current power ranks of robotic soldiers, determine the minimum number of moves needed such that the power ranks become strictly increasing. >>> min_moves_to_make_increasing([2, 5, 3, 7, 8]) 1 >>> min_moves_to_make_increasing([1, 3, 2, 4, 7, 6, 8]) 2 >>> min_moves_to_make_increasing([4, 4, 4, 4]) 3","solution":"def min_moves_to_make_increasing(power_ranks): from bisect import bisect_left if not power_ranks: return 0 lis = [] for rank in power_ranks: pos = bisect_left(lis, rank) if pos == len(lis): lis.append(rank) else: lis[pos] = rank return len(power_ranks) - len(lis)"},{"question":"from typing import List def min_trees_to_chop(heights: List[int]) -> int: Returns the minimum number of trees to chop to achieve the required alignment. The alignment means each tree is either of increasing height or equal to its immediate left tree. Args: heights (list): A list of integers representing the heights of the trees. Returns: int: The minimum number of trees to chop. pass def process_input(input_data: str) -> List[int]: Processes the input test cases and returns the minimum number of trees to chop for each. Args: input_data (str): The input data as a single string. Returns: List of int: A list containing the minimum number of trees to chop for each test case. pass def test_min_trees_to_chop_case1(): assert min_trees_to_chop([3, 2, 1, 4, 5]) == 2 def test_min_trees_to_chop_case2(): assert min_trees_to_chop([6, 3, 4, 5, 1, 2]) == 3 def test_min_trees_to_chop_case_empty(): assert min_trees_to_chop([]) == 0 def test_process_input(): input_data = \\"3 2 1 4 5n6 3 4 5 1 2n0n\\" expected_output = [2, 3] assert process_input(input_data) == expected_output def test_process_input_single(): input_data = \\"1n0n\\" expected_output = [0] assert process_input(input_data) == expected_output def test_process_input_multiple(): input_data = \\"10 20 30 40n5 3 2 6 7n0n\\" expected_output = [0, 2] assert process_input(input_data) == expected_output","solution":"def min_trees_to_chop(heights): Returns the minimum number of trees to chop to achieve the required alignment. The alignment means each tree is either of increasing height or equal to its immediate left tree. Args: heights (list): A list of integers representing the heights of the trees. Returns: int: The minimum number of trees to chop. n = len(heights) if n == 0: return 0 # Initialize a list to keep track of the longest non-decreasing subsequence (LNDS) lnds = [] for height in heights: if not lnds or height >= lnds[-1]: lnds.append(height) else: # Use binary search to find the smallest element in lnds that is >= height # and replace it with height to keep LNDS optimal left, right = 0, len(lnds) - 1 while left < right: mid = (left + right) // 2 if lnds[mid] <= height: left = mid + 1 else: right = mid lnds[right] = height # The number of trees to chop is the total number of trees minus the length of LNDS return n - len(lnds) def process_input(input_data): Processes the input test cases and returns the minimum number of trees to chop for each. Args: input_data (str): The input data as a single string. Returns: List of int: A list containing the minimum number of trees to chop for each test case. input_lines = input_data.strip().split('n') results = [] for line in input_lines: if line.strip() == '0': break heights = list(map(int, line.split())) result = min_trees_to_chop(heights) results.append(result) return results"},{"question":"from typing import List, Tuple def schedule_events(events: List[Tuple[int, int]]) -> List[Tuple[int, int]]: Schedules the maximum number of non-overlapping events. An event is defined by a tuple of (start_time, end_time). The function returns a list of non-overlapping events such that the maximum number of events are accommodated. Example: >>> schedule_events([(1, 3), (2, 5), (6, 7), (7, 8), (5, 6)]) [(1, 3), (5, 6), (6, 7), (7, 8)] >>> schedule_events([(1, 2), (2, 3), (3, 4), (1, 5)]) [(1, 2), (2, 3), (3, 4)]","solution":"from typing import List, Tuple def schedule_events(events: List[Tuple[int, int]]) -> List[Tuple[int, int]]: Schedules the maximum number of non-overlapping events. # Sort events by their end times events.sort(key=lambda x: x[1]) # Selected events scheduled = [] current_end_time = -1 for event in events: if event[0] >= current_end_time: scheduled.append(event) current_end_time = event[1] return scheduled"},{"question":"def is_square_of_stars(grid: List[str], n: int, m: int, k: int) -> str: Check if there exists a k by k square in the n by m grid composed entirely of '*' characters. >>> is_square_of_stars([ \\".*..*\\", \\"***.*\\", \\"****.\\", \\".....\\" ], 4, 5, 2) \\"YES\\" >>> is_square_of_stars([ \\"****\\", \\"***.\\", \\"**..\\" ], 3, 4, 3) \\"NO\\" >>> is_square_of_stars([ \\"*****\\", \\"*****\\", \\"*****\\", \\"*****\\", \\"*****\\" ], 5, 5, 2) \\"YES\\" pass","solution":"def is_square_of_stars(grid, n, m, k): Check if there exists a k by k square in the n by m grid composed entirely of '*' characters. for i in range(n - k + 1): for j in range(m - k + 1): if all(grid[x][y] == '*' for x in range(i, i + k) for y in range(j, j + k)): return \\"YES\\" return \\"NO\\""},{"question":"def process_stock_prices(input_data: str) -> str: Processes the stock price updates and returns the highest and lowest prices for each stock. Args: input_data (str): A string containing multiple datasets of stock price updates. Returns: str: A string containing the highest and lowest prices for each stock, with stocks sorted alphabetically. # Test cases import pytest def test_process_single_dataset(): input_data = '''AAPL 150.25 GOOG 2765.54 AAPL 148.75 MSFT 299.60 GOOG 2768.89 AAPL 151.30 MSFT 298.00 END UPDATE''' expected_output = '''AAPL: 151.30 148.75 GOOG: 2768.89 2765.54 MSFT: 299.60 298.00''' assert process_stock_prices(input_data) == expected_output def test_process_multiple_datasets(): input_data = '''AAPL 150.25 GOOG 2765.54 AAPL 148.75 MSFT 299.60 GOOG 2768.89 AAPL 151.30 MSFT 298.00 END UPDATE TSLA 742.50 AMZN 3344.55 TSLA 739.25 AMZN 3360.45 END UPDATE''' expected_output = '''AAPL: 151.30 148.75 GOOG: 2768.89 2765.54 MSFT: 299.60 298.00 AMZN: 3360.45 3344.55 TSLA: 742.50 739.25''' assert process_stock_prices(input_data) == expected_output def test_process_single_stock_multiple_updates(): input_data = '''AAPL 150.25 AAPL 148.75 AAPL 151.30 END UPDATE''' expected_output = '''AAPL: 151.30 148.75''' assert process_stock_prices(input_data) == expected_output def test_process_two_stocks_multiple_updates(): input_data = '''AAPL 150.25 MSFT 299.60 AAPL 148.75 MSFT 298.00 AAPL 151.30 MSFT 300.00 END UPDATE''' expected_output = '''AAPL: 151.30 148.75 MSFT: 300.00 298.00''' assert process_stock_prices(input_data) == expected_output def test_empty_input(): input_data = '' expected_output = '' assert process_stock_prices(input_data) == expected_output","solution":"def process_stock_prices(input_data): Processes the stock price updates and returns the highest and lowest prices for each stock. Args: input_data (str): A string containing multiple datasets of stock price updates. Returns: str: A string containing the highest and lowest prices for each stock, with stocks sorted alphabetically. lines = input_data.strip().split(\\"n\\") datasets = [] current_dataset = [] for line in lines: if line == \\"END UPDATE\\": datasets.append(current_dataset) current_dataset = [] else: current_dataset.append(line) results = [] for dataset in datasets: stock_prices = {} for record in dataset: ticker, price = record.split() price = float(price) if ticker not in stock_prices: stock_prices[ticker] = {'highest': price, 'lowest': price} else: if price > stock_prices[ticker]['highest']: stock_prices[ticker]['highest'] = price if price < stock_prices[ticker]['lowest']: stock_prices[ticker]['lowest'] = price sorted_stocks = sorted(stock_prices.items()) dataset_result = [] for ticker, prices in sorted_stocks: dataset_result.append(f\\"{ticker}: {prices['highest']:.2f} {prices['lowest']:.2f}\\") results.append(\\"n\\".join(dataset_result)) return \\"nn\\".join(results)"},{"question":"def final_arrangement(n: int, m: int, operations: list[tuple[int, int]]) -> list[int]: Returns the final arrangement of books on the shelves after performing a series of swap operations. Parameters: - n: int, the number of books - m: int, the number of swap operations - operations: list of tuples, each containing two integers representing a swap operation Returns: - list of int, the final arrangement of books from leftmost to rightmost pass from final_arrangement import final_arrangement def test_example_1(): assert final_arrangement(5, 3, [(1, 2), (3, 4), (5, 1)]) == [5, 1, 4, 3, 2] def test_example_2(): assert final_arrangement(4, 2, [(1, 4), (2, 3)]) == [4, 3, 2, 1] def test_no_operations(): assert final_arrangement(3, 0, []) == [1, 2, 3] def test_single_swap(): assert final_arrangement(2, 1, [(1, 2)]) == [2, 1] def test_multiple_swaps_on_same_books(): assert final_arrangement(3, 4, [(1, 2), (1, 2), (1, 2), (1, 2)]) == [1, 2, 3] def test_large_input(): n = 10**5 m = 1 operations = [(1, n)] expected_output = [n] + list(range(2, n)) + [1] assert final_arrangement(n, m, operations) == expected_output","solution":"def final_arrangement(n, m, operations): Returns the final arrangement of books on the shelves after performing a series of swap operations. Parameters: - n: int, the number of books - m: int, the number of swap operations - operations: list of tuples, each containing two integers representing a swap operation Returns: - list of int, the final arrangement of books from leftmost to rightmost # Initial arrangement of books arrangement = list(range(1, n + 1)) # Perform the swap operations for ai, bi in operations: arrangement[ai - 1], arrangement[bi - 1] = arrangement[bi - 1], arrangement[ai - 1] return arrangement"},{"question":"import math def gcd(n: int, m: int) -> int: Returns the greatest common divisor of n and m. >>> gcd(12, 15) 3 >>> gcd(17, 31) 1 >>> gcd(100, 75) 25","solution":"import math def gcd(n, m): Returns the greatest common divisor of n and m. return math.gcd(n, m)"},{"question":"from typing import List def findSubarrays(arr: List[int], k: int) -> str: Bob is given an integer array \`arr\` of size \`n\` and an integer value \`k\`. He has to determine if there are two non-overlapping subarrays of \`arr\` such that both subarrays are of size \`k\` and have the same sum. Note that the two subarrays should have a gap of at least one element between them. >>> findSubarrays([1,2,3,4,5,6,7,8,9,10], 2) \\"NO\\" >>> findSubarrays([4,3,2,5,1,2,1,5,1,3,2,4], 3) \\"YES\\"","solution":"from typing import List def findSubarrays(arr: List[int], k: int) -> str: n = len(arr) sums = {} for i in range(n - k + 1): curr_sum = sum(arr[i:i+k]) if curr_sum in sums: for idx in sums[curr_sum]: if abs(i - idx) >= k + 1: return \\"YES\\" sums[curr_sum].append(i) else: sums[curr_sum] = [i] return \\"NO\\""},{"question":"from typing import List def find_path(n: int, m: int, grid: List[List[int]]) -> str: You are given a maze in the form of a grid with dimensions n x m. Some cells in the grid are blocked and some are open. You need to determine if there exists a path from the top-left corner (0, 0) to the bottom-right corner (n-1, m-1). The grid is represented by a 2D array of integers where 1 represents a blocked cell and 0 represents an open cell. You can only move up, down, left, or right. Write a function that determines if a path exists and returns “YES” if it does and “NO” otherwise. >>> n = 5 >>> m = 5 >>> grid = [ >>> [0, 1, 0, 0, 0], >>> [0, 1, 0, 1, 0], >>> [0, 0, 0, 1, 0], >>> [0, 1, 1, 0, 0], >>> [0, 0, 0, 0, 0] >>> ] >>> find_path(n, m, grid) \\"YES\\" >>> n = 3 >>> m = 3 >>> grid = [ >>> [0, 1, 0], >>> [1, 1, 0], >>> [0, 0, 0] >>> ] >>> find_path(n, m, grid) \\"NO\\" pass # your code here # Unit tests import pytest def test_find_path_yes(): n = 5 m = 5 grid = [ [0, 1, 0, 0, 0], [0, 1, 0, 1, 0], [0, 0, 0, 1, 0], [0, 1, 1, 0, 0], [0, 0, 0, 0, 0] ] assert find_path(n, m, grid) == \\"YES\\" def test_find_path_no(): n = 3 m = 3 grid = [ [0, 1, 0], [1, 1, 0], [0, 0, 0] ] assert find_path(n, m, grid) == \\"NO\\" def test_find_path_single_cell(): n = 1 m = 1 grid = [[0]] assert find_path(n, m, grid) == \\"YES\\" def test_find_path_fully_blocked(): n = 2 m = 2 grid = [ [0, 1], [1, 0] ] assert find_path(n, m, grid) == \\"NO\\" def test_find_path_straight_path(): n = 3 m = 3 grid = [ [0, 0, 0], [0, 0, 0], [0, 0, 0] ] assert find_path(n, m, grid) == \\"YES\\" def test_find_path_with_loops(): n = 4 m = 4 grid = [ [0, 1, 0, 0], [0, 0, 1, 0], [1, 0, 1, 0], [1, 0, 0, 0] ] assert find_path(n, m, grid) == \\"YES\\"","solution":"from typing import List def find_path(n: int, m: int, grid: List[List[int]]) -> str: if grid[0][0] == 1 or grid[n - 1][m - 1] == 1: return \\"NO\\" def is_valid(x, y): return 0 <= x < n and 0 <= y < m and grid[x][y] == 0 def dfs(x, y): if (x, y) == (n - 1, m - 1): return True grid[x][y] = 1 # mark as visited for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: # up, down, left, right nx, ny = x + dx, y + dy if is_valid(nx, ny) and dfs(nx, ny): return True return False return \\"YES\\" if dfs(0, 0) else \\"NO\\""},{"question":"def count_flower_beds(n: int, m: int, garden: List[str]) -> int: Determine the number of valid flower beds in a garden grid. >>> n, m = 4, 4 >>> garden = [ ... \\"....\\", ... \\".**.\\", ... \\"**..\\", ... \\"....\\" ... ] >>> count_flower_beds(n, m, garden) 3 >>> n, m = 3, 3 >>> garden = [ ... \\"...\\", ... \\"...\\", ... \\"...\\" ... ] >>> count_flower_beds(n, m, garden) 0 >>> n, m = 2, 2 >>> garden = [ ... \\"**\\", ... \\"**\\" ... ] >>> count_flower_beds(n, m, garden) 4 >>> n, m = 1, 4 >>> garden = [ ... \\"**..\\" ... ] >>> count_flower_beds(n, m, garden) 1 >>> n, m = 4, 1 >>> garden = [ ... \\"*\\", ... \\"*\\", ... \\".\\", ... \\"*\\" ... ] >>> count_flower_beds(n, m, garden) 1","solution":"def count_flower_beds(n, m, garden): count = 0 for i in range(n): for j in range(m): if j + 1 < m and garden[i][j] == '*' and garden[i][j + 1] == '*': count += 1 if i + 1 < n and garden[i][j] == '*' and garden[i + 1][j] == '*': count += 1 return count # Example usage n = 4 m = 4 garden = [ \\"....\\", \\".**.\\", \\"**..\\", \\"....\\" ] print(count_flower_beds(n, m, garden)) # Output should be 3"},{"question":"def max_energy_sum(grid: List[List[int]]) -> int: Returns the maximum energy sum that can be collected while traveling from the top-left corner to the bottom-right corner of the grid. >>> max_energy_sum([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) 29 >>> max_energy_sum([[1, 1, 1], [1, 1, 1], [1, 1, 1]]) 5 >>> max_energy_sum([[5]]) 5 >>> max_energy_sum([[1, 2], [1, 1]]) 4 >>> max_energy_sum([[1, 2, 5], [3, 2, 1]]) 9","solution":"def max_energy_sum(grid): Returns the maximum energy sum that can be collected while traveling from the top-left corner to the bottom-right corner of the grid. n = len(grid) m = len(grid[0]) # Create a dp table to store the maximum energy sum at each cell. dp = [[0]*m for _ in range(n)] # Initialize the dp table with the first cell's energy. dp[0][0] = grid[0][0] # Fill the first row. for j in range(1, m): dp[0][j] = dp[0][j-1] + grid[0][j] # Fill the first column. for i in range(1, n): dp[i][0] = dp[i-1][0] + grid[i][0] # Fill the rest of the dp table. for i in range(1, n): for j in range(1, m): dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j] return dp[n-1][m-1]"},{"question":"def find_unsorted_subarray(nums: List[int]) -> int: Finds the length of the smallest subarray that, if sorted, results in the whole array being sorted in non-decreasing order. If the array is already sorted, return 0. >>> find_unsorted_subarray([2, 6, 4, 8, 10]) 2 >>> find_unsorted_subarray([1, 2, 3]) 0","solution":"def find_unsorted_subarray(nums): Finds the length of the smallest subarray that, if sorted, results in the whole array being sorted. n = len(nums) start, end = 0, -1 min_val, max_val = float('inf'), float('-inf') for i in range(n): if nums[i] < max_val: end = i else: max_val = nums[i] for i in range(n-1, -1, -1): if nums[i] > min_val: start = i else: min_val = nums[i] return end - start + 1"},{"question":"def standardize_strings(n: int, k: int, strings: List[str]) -> List[str]: Standardizes the lengths of strings to a target length k. Parameters: n (int): Number of strings k (int): Target length for each string strings (list of str): List containing the strings Returns: list of str: List of strings each of length k Example: >>> standardize_strings(3, 5, [\\"apple\\", \\"dog\\", \\"mouse\\"]) [\\"apple\\", \\"dogaa\\", \\"mouse\\"] >>> standardize_strings(4, 3, [\\"cat\\", \\"kitten\\", \\"a\\", \\"barks\\"]) [\\"cat\\", \\"kit\\", \\"aaa\\", \\"bar\\"]","solution":"def standardize_strings(n, k, strings): Standardizes the lengths of strings to a target length k. Parameters: n (int): Number of strings k (int): Target length for each string strings (list of str): List containing the strings Returns: list of str: List of strings each of length k result = [] for string in strings: if len(string) < k: string = string + 'a' * (k - len(string)) else: string = string[:k] result.append(string) return result"},{"question":"from typing import List def max_rectangle_area(grid: List[List[int]]) -> int: Eva enjoys solving puzzles on a grid. She has an m x n grid where each cell contains either a 0 or a 1. Eva wants to identify the largest rectangle of 1's in this grid and determine its area. Args: grid (List[List[int]]): A binary grid where each cell contains either a 0 or a 1 Returns: int: The area of the largest rectangle of 1's in the grid. Example: >>> max_rectangle_area([ >>> [1, 0, 1, 0, 0], >>> [1, 0, 1, 1, 1], >>> [1, 1, 1, 1, 1], >>> [1, 0, 0, 1, 0] >>> ]) == 6","solution":"def max_histogram_area(heights): Calculate the maximum rectangle area in a histogram represented by heights. stack = [] max_area = 0 index = 0 while index < len(heights): if not stack or heights[stack[-1]] <= heights[index]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area def max_rectangle_area(grid): Calculate the maximum rectangle area of 1's in a binary grid. if not grid or not grid[0]: return 0 m, n = len(grid), len(grid[0]) heights = [0] * n max_area = 0 for i in range(m): for j in range(n): heights[j] = heights[j] + 1 if grid[i][j] == 1 else 0 max_area = max(max_area, max_histogram_area(heights)) return max_area"},{"question":"def find_ingredient_quantities(n, k, sum_callback): Finds the quantities of k ingredients out of n available ingredients through queries. Args: n (int): Total number of ingredients. k (int): Number of ingredients in the potion. sum_callback (callable): A function that takes a list of ingredients and returns the sum of their quantities. Returns: list: A list of tuples where each tuple consists of an ingredient number and its quantity. pass # Test cases def test_find_ingredient_quantities(): def mock_sum_callback(ingredients): known_quantities = {1: 100, 2: 50, 3: 30, 4: 20, 5: 10} return sum(known_quantities[i] for i in ingredients) n = 5 k = 3 result = find_ingredient_quantities(n, k, mock_sum_callback) expected_result = [(1, 100), (2, 50), (3, 30)] assert result == expected_result def test_find_ingredient_quantities_different_set(): def mock_sum_callback(ingredients): known_quantities = {1: 70, 2: 40, 3: 90, 4: 10, 5: 50} return sum(known_quantities[i] for i in ingredients) n = 5 k = 3 result = find_ingredient_quantities(n, k, mock_sum_callback) assert result in [[(1, 70), (2, 40), (3, 90)], [(2, 40), (1, 70), (3, 90)], [(3, 90), (1, 70), (2, 40)]] def test_find_ingredient_quantities_minimal(): def mock_sum_callback(ingredients): known_quantities = {1: 1, 2: 2} return sum(known_quantities[i] for i in ingredients) n = 2 k = 2 result = find_ingredient_quantities(n, k, mock_sum_callback) expected_result = [(1, 1), (2, 2)] assert result == expected_result","solution":"def find_ingredient_quantities(n, k, sum_callback): Finds the quantities of k ingredients out of n available ingredients through queries. Args: n (int): Total number of ingredients. k (int): Number of ingredients in the potion. sum_callback (callable): A function that takes a list of ingredients and returns the sum of their quantities. Returns: list: A list of tuples where each tuple consists of an ingredient number and its quantity. all_ingredients = list(range(1, k+1)) # Query for the sum of all k ingredients total_sum = sum_callback(all_ingredients) quantities = [0] * k for i in range(k): # Query for the sum of (k-1) ingredients excluding the i-th ingredient subset = all_ingredients[:i] + all_ingredients[i+1:] subset_sum = sum_callback(subset) # The i-th ingredient quantity is derived as the difference quantities[i] = total_sum - subset_sum # Creating the result in the format required (ingredient number, quantity) result = [(i + 1, quantities[i]) for i in range(k)] return result # Example usage: if __name__ == \\"__main__\\": def sum_callback(ingredients): # This is just an example callable used for illustration. # In the real scenario, this would interactively get sum from user/system. known_quantities = {1: 100, 2: 50, 3: 30} return sum(known_quantities[i] for i in ingredients) n = 10 k = 3 result = find_ingredient_quantities(n, k, sum_callback) print(\\"2 \\" + \\" \\".join(f\\"{i} {q}\\" for i, q in result))"},{"question":"from typing import List def max_power_prime_factor(n: int) -> int: Finds the maximum power of any prime factor in the prime factorization of n. Args: n (int): The integer to factorize. Returns: int: Maximum power of any prime factor in the factorization of n. Examples: >>> max_power_prime_factor(18) 2 >>> max_power_prime_factor(50) 2 >>> max_power_prime_factor(72) 3 pass def process_test_cases(T: int, test_cases: List[int]) -> List[int]: Processes multiple test cases and returns a list of results for each test case. Args: T (int): The number of test cases. test_cases (List[int]): List containing the integers to factorize. Returns: List[int]: List containing the maximum power of any prime factor for each test case. Examples: >>> process_test_cases(3, [18, 50, 72]) [2, 2, 3] >>> process_test_cases(2, [27, 100]) [3, 2] pass","solution":"def max_power_prime_factor(n): This function finds the maximum power of any prime factor in the prime factorization of n. max_power = 0 current_power = 0 original_n = n # Check for number of 2s while n % 2 == 0: n //= 2 current_power += 1 if current_power > max_power: max_power = current_power # Check for odd factors from 3 to sqrt(n) factor = 3 while factor * factor <= n: current_power = 0 while n % factor == 0: n //= factor current_power += 1 if current_power > max_power: max_power = current_power factor += 2 # If n is a prime number and greater than 2 if n > 2: max_power = max(max_power, 1) return max_power def process_test_cases(T, test_cases): results = [] for n in test_cases: results.append(max_power_prime_factor(n)) return results"},{"question":"import heapq from collections import Counter from typing import List def rearrange_string(S: str) -> str: Rearranges the characters of S such that no two adjacent characters are the same. If it is not possible, returns an empty string. >>> rearrange_string(\\"aaabb\\") in [\\"ababa\\", \\"babab\\"] True >>> rearrange_string(\\"aab\\") in [\\"aba\\"] True >>> rearrange_string(\\"aaab\\") == \\"\\" True >>> rearrange_string(\\"aaa\\") == \\"\\" True >>> rearrange_string(\\"a\\") == \\"a\\" True >>> rearrange_string(\\"aabb\\") in [\\"abab\\", \\"baba\\"] True >>> input_str = \\"a\\" * (10**5 // 2) + \\"b\\" * (10**5 // 2) >>> output = rearrange_string(input_str) >>> len(output) == len(input_str) True >>> all(output[i] != output[i+1] for i in range(len(output) - 1)) True >>> rearrange_string(\\"\\") == \\"\\" True >>> rearrange_string(\\"bac\\") in [\\"abc\\", \\"acb\\", \\"bac\\", \\"bca\\", \\"cab\\", \\"cba\\"] True","solution":"import heapq from collections import Counter def rearrange_string(S): Rearranges the characters of S such that no two adjacent characters are the same. If it is not possible, returns an empty string. if not S: return \\"\\" # Frequency count of each character freq = Counter(S) # Max-heap to get the maximum occurring character max_heap = [(-count, char) for char, count in freq.items()] heapq.heapify(max_heap) prev_char, prev_count = None, 0 result = [] while max_heap: count, char = heapq.heappop(max_heap) result.append(char) # If the previous character count is greater than zero, push it back into the heap if prev_count < 0: heapq.heappush(max_heap, (prev_count, prev_char)) # Update the previous character and its count (decrease count by 1) prev_char, prev_count = char, count + 1 if len(result) == len(S): return ''.join(result) else: return \\"\\""},{"question":"def update_matrix(n: int, m: int, matrix_a: List[List[int]], matrix_b: List[List[int]]) -> List[List[int]]: Given two matrices A and B of the same dimensions n x m, superimpose matrix B onto matrix A by replacing each element in A with the corresponding element in B at the same position if and only if the element in B is larger than the element in A, ensuring the resultant matrix still satisfies the sorting properties (sorted rows and columns). >>> update_matrix(3, 3, [[1, 2, 3], [4, 5, 6], [7, 8, 9]], [[2, 3, 4], [5, 6, 7], [8, 9, 10]]) [[2, 3, 4], [5, 6, 7], [8, 9, 10]] >>> update_matrix(2, 2, [[1, 2], [3, 4]], [[2, 1], [4, 3]]) [[2, 2], [4, 4]] pass # Test cases from typing import List def test_case_1(): n, m = 3, 3 matrix_a = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] matrix_b = [ [2, 3, 4], [5, 6, 7], [8, 9, 10] ] result = update_matrix(n, m, matrix_a, matrix_b) expected = [ [2, 3, 4], [5, 6, 7], [8, 9, 10] ] assert result == expected def test_case_2(): n, m = 2, 2 matrix_a = [ [1, 2], [3, 4] ] matrix_b = [ [2, 1], [4, 3] ] result = update_matrix(n, m, matrix_a, matrix_b) expected = [ [2, 2], [4, 4] ] assert result == expected def test_case_3(): n, m = 1, 1 matrix_a = [ [1] ] matrix_b = [ [2] ] result = update_matrix(n, m, matrix_a, matrix_b) expected = [ [2] ] assert result == expected def test_case_4(): n, m = 4, 3 matrix_a = [ [1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12] ] matrix_b = [ [0, 0, 0], [3, 3, 3], [6, 6, 6], [9, 9, 9] ] result = update_matrix(n, m, matrix_a, matrix_b) expected = [ [1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12] ] assert result == expected","solution":"def update_matrix(n, m, matrix_a, matrix_b): result = [[0] * m for _ in range(n)] for i in range(n): for j in range(m): result[i][j] = max(matrix_a[i][j], matrix_b[i][j]) return result # Example usage n, m = 3, 3 matrix_a = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] matrix_b = [ [2, 3, 4], [5, 6, 7], [8, 9, 10] ] result = update_matrix(n, m, matrix_a, matrix_b) for row in result: print(\\" \\".join(map(str, row))) # Output: # 2 3 4 # 5 6 7 # 8 9 10"},{"question":"def text_editor(commands: List[str]) -> str: Simulate a simplified version of a text editor with a command-based interface. Process a series of commands to manipulate a string. Commands: - 'INSERT c': Insert the character 'c' at the current cursor position and move the cursor to the right. - 'MOVE k': Move the cursor to the position 'k' (0-indexed). - 'DELETE': Delete the character immediately to the right of the cursor. >>> text_editor([\\"INSERT a\\", \\"INSERT b\\", \\"INSERT c\\", \\"END\\"]) 'abc' >>> text_editor([\\"INSERT a\\", \\"INSERT b\\", \\"INSERT c\\", \\"MOVE 1\\", \\"INSERT d\\", \\"END\\"]) 'adbc' >>> text_editor([\\"INSERT a\\", \\"INSERT b\\", \\"INSERT c\\", \\"MOVE 1\\", \\"DELETE\\", \\"END\\"]) 'ac' >>> text_editor([\\"INSERT a\\", \\"INSERT b\\", \\"INSERT c\\", \\"MOVE 1\\", \\"DELETE\\", \\"INSERT d\\", \\"MOVE 0\\", \\"DELETE\\", \\"MOVE 5\\", \\"DELETE\\", \\"END\\"]) 'dc' >>> text_editor([\\"END\\"]) '' >>> text_editor([\\"INSERT a\\", \\"INSERT b\\", \\"INSERT c\\", \\"MOVE 10\\", \\"DELETE\\", \\"END\\"]) 'abc' >>> text_editor([\\"INSERT a\\", \\"INSERT b\\", \\"INSERT c\\", \\"MOVE -5\\", \\"INSERT d\\", \\"END\\"]) 'dabc' >>> text_editor([\\"INSERT a\\", \\"INSERT b\\", \\"INSERT c\\", \\"MOVE 3\\", \\"DELETE\\", \\"END\\"]) 'abc'","solution":"def text_editor(commands): content = [] cursor = 0 for command in commands: parts = command.split() if parts[0] == 'INSERT': character = parts[1] content.insert(cursor, character) cursor += 1 elif parts[0] == 'MOVE': position = int(parts[1]) cursor = max(0, min(position, len(content))) elif parts[0] == 'DELETE': if cursor < len(content): content.pop(cursor) elif parts[0] == 'END': break return ''.join(content)"},{"question":"def count_design_groups(datasets): Count the number of groups of any design type that can be formed with at least two stamps of the same design. Args: datasets (List[List[int]]): List of datasets where each dataset contains the number of stamps followed by the design types of each stamp. Returns: List[int]: A list of integers representing the number of groups of any design type that can be formed with at least two stamps of the same design for each dataset. Example: >>> count_design_groups([[7, 1, 2, 3, 1, 2, 2, 4], [5, 5, 5, 5, 5], [0]]) [2, 1] >>> count_design_groups([[4, 1, 1, 1, 1], [0]]) [1]","solution":"def count_design_groups(datasets): Function to count the number of groups of any design type that can be formed with at least two stamps of the same design. results = [] for dataset in datasets: n = dataset[0] if n == 0: break design_count = {} for design in dataset[1:]: if design in design_count: design_count[design] += 1 else: design_count[design] = 1 groups = sum(1 for count in design_count.values() if count >= 2) results.append(groups) return results # Example usage: # datasets = [ # [7, 1, 2, 3, 1, 2, 2, 4], # [5, 5, 5, 5, 5], # [0] # ] # print(count_design_groups(datasets)) # Output: [2, 1]"},{"question":"def max_books(n: int, thicknesses: List[int], C: int) -> int: Returns the maximum number of books that can be placed on a shelf without exceeding its total capacity. :param n: number of books :param thicknesses: list of thickness of each book :param C: total capacity of the shelf :return: maximum number of books pass # Unit tests def test_example_1(): assert max_books(5, [1, 2, 3, 4, 5], 10) == 4 def test_example_2(): assert max_books(4, [5, 5, 5, 5], 15) == 3 def test_example_3(): assert max_books(6, [1, 1, 1, 1, 1, 1], 3) == 3 def test_large_capacity(): assert max_books(5, [1, 2, 3, 4, 5], 100) == 5 def test_no_capacity(): assert max_books(5, [10, 20, 30, 40, 50], 0) == 0 def test_single_book_fits(): assert max_books(1, [10], 10) == 1 def test_single_book_does_not_fit(): assert max_books(1, [10], 5) == 0 def test_exceeding_some_books(): assert max_books(3, [3, 1, 4], 6) == 2 def test_books_with_random_thicknesses(): assert max_books(4, [3, 7, 2, 1], 8) == 3 def test_books_with_same_thickness(): assert max_books(6, [2, 2, 2, 2, 2, 2], 10) == 5","solution":"def max_books(n, thicknesses, C): Returns the maximum number of books that can be placed on a shelf without exceeding its total capacity. :param n: number of books :param thicknesses: list of thickness of each book :param C: total capacity of the shelf :return: maximum number of books thicknesses.sort() total_thickness = 0 count = 0 for thickness in thicknesses: if total_thickness + thickness <= C: total_thickness += thickness count += 1 else: break return count"},{"question":"def min_magic_potions(n: int, hurdles: List[int], k: int) -> int: Calculates the minimum number of magic potions required for the jumper to clear all hurdles. :param n: An integer representing the number of hurdles. :param hurdles: A list of integers representing the heights of the hurdles. :param k: An integer representing the maximum height the jumper can jump naturally. :return: An integer representing the minimum number of magic potions required. >>> min_magic_potions(5, [1, 6, 3, 5, 2], 4) 2 >>> min_magic_potions(8, [2, 5, 4, 5, 2, 6, 7, 8], 5) 3","solution":"def min_magic_potions(n, hurdles, k): Calculates the minimum number of magic potions required for the jumper to clear all hurdles. :param n: An integer representing the number of hurdles. :param hurdles: A list of integers representing the heights of the hurdles. :param k: An integer representing the maximum height the jumper can jump naturally. :return: An integer representing the minimum number of magic potions required. max_hurdle = max(hurdles) if k >= max_hurdle: return 0 else: return max_hurdle - k"},{"question":"def min_replacements_to_palindrome(s: str) -> int: Returns the minimum number of replacement operations needed to make the given string a palindrome. >>> min_replacements_to_palindrome(\\"abba\\") 0 >>> min_replacements_to_palindrome(\\"abb\\") 1 >>> min_replacements_to_palindrome(\\"ab\\") 1 def process_queries(queries: List[str]) -> List[int]: Processes multiple queries and returns a list containing the results for each query. >>> process_queries([\\"abba\\", \\"abb\\", \\"baab\\"]) [0, 1, 0] >>> process_queries([\\"ab\\", \\"a\\", \\"b\\"]) [1, 0, 0]","solution":"def min_replacements_to_palindrome(s): Returns the minimum number of replacement operations needed to make the given string a palindrome. n = len(s) count = 0 for i in range(n // 2): if s[i] != s[n - i - 1]: count += 1 return count def process_queries(queries): Processes multiple queries and returns a list containing the results for each query. results = [] for s in queries: results.append(min_replacements_to_palindrome(s)) return results"},{"question":"from typing import List, Tuple class SegmentedSieve: def __init__(self, L: int, R: int): Initialize the segmented sieve with the range [L, R]. pass def is_prime(self, x: int) -> bool: Check if a given integer x within the range [L, R] is a prime number. Args: x (int): Integer to be checked Returns: bool: True if x is prime, False otherwise >>> sieve = SegmentedSieve(10, 20) >>> sieve.is_prime(11) True >>> sieve.is_prime(16) False pass def list_primes(self, l: int, r: int) -> List[int]: List all prime numbers within a subrange [l, r] of [L, R]. Args: l (int): Start of subrange r (int): End of subrange Returns: list: List of prime numbers within the subrange [l, r] >>> sieve = SegmentedSieve(10, 20) >>> sieve.list_primes(10, 15) [11, 13] >>> sieve.list_primes(16, 20) [17, 19] >>> sieve.list_primes(18, 19) [19] pass def process_queries(L: int, R: int, queries: List[Tuple[int, int, int]]) -> List[str]: Process the prime number queries on the range [L, R]. Args: L (int): Start of the range R (int): End of the range queries (list): List of queries Returns: list: List of results for each query >>> queries = [ ... (1, 11), ... (1, 16), ... (2, 10, 15), ... (2, 16, 20), ... (1, 17) ... ] >>> process_queries(10, 20, queries) ['Prime', 'Not Prime', '11 13', '17 19', 'Prime'] >>> queries = [(2, 25, 27)] >>> process_queries(24, 28, queries) ['No primes'] pass","solution":"import math class SegmentedSieve: def __init__(self, L, R): self.L = L self.R = R self.is_prime_range = [True] * (R - L + 1) self.primes = [] self._init_segmented_sieve() def _init_segmented_sieve(self): # All numbers less than 2 are not prime if self.L == 1: self.is_prime_range[0] = False limit = int(math.sqrt(self.R)) + 1 is_prime = [True] * (limit + 1) for i in range(2, limit + 1): if is_prime[i]: for j in range(i * i, limit + 1, i): is_prime[j] = False # Mark multiples of i in range [L, R] start = max(i * i, self.L + (i - self.L % i) % i) for j in range(start, self.R + 1, i): self.is_prime_range[j - self.L] = False self.primes = [self.L + i for i, is_prime in enumerate(self.is_prime_range) if is_prime] def is_prime(self, x): if self.L <= x <= self.R: return self.is_prime_range[x - self.L] return False def list_primes(self, l, r): result = [] for x in range(l, r + 1): if self.is_prime(x): result.append(x) return result # Functions to process the input queries. def process_queries(L, R, queries): sieve = SegmentedSieve(L, R) results = [] for query in queries: if query[0] == 1: # Check if x is prime x = query[1] results.append(\\"Prime\\" if sieve.is_prime(x) else \\"Not Prime\\") elif query[0] == 2: # List all primes in the subrange [l, r] l, r = query[1], query[2] primes_in_range = sieve.list_primes(l, r) if primes_in_range: results.append(\\" \\".join(map(str, primes_in_range))) else: results.append(\\"No primes\\") return results"},{"question":"def is_super_palindromic(num: int) -> bool: Checks if a number is super palindromic. >>> is_super_palindromic(101) True >>> is_super_palindromic(121) False >>> is_super_palindromic(11) True >>> is_super_palindromic(22) False def next_super_palindromic(n: int) -> int: Finds the smallest super palindromic number greater than or equal to n. >>> next_super_palindromic(22) 101 >>> next_super_palindromic(11) 11 >>> next_super_palindromic(100) 101 >>> next_super_palindromic(110) 111 >>> next_super_palindromic(1) 1 >>> next_super_palindromic(998) 1001","solution":"def is_super_palindromic(num): Checks if a number is super palindromic. s = str(num) return s == s[::-1] and set(s).issubset({'0', '1'}) def next_super_palindromic(n): Finds the smallest super palindromic number greater than or equal to n. current = n while True: if is_super_palindromic(current): return current current += 1"},{"question":"def is_grid_balanced(R, C, D, updates): Determine if the warehouse grid is balanced after a set of updates. Args: R: int - number of rows in the grid C: int - number of columns in the grid D: int - maximum allowable difference between sums of any two rows or columns updates: List[Tuple[int, int, int]] - list of updates, each containing the row, column, and new number of packages for a specific cell Returns: str: \\"YES\\" if the grid is balanced, \\"NO\\" otherwise. Examples: >>> is_grid_balanced(4, 4, 10, [(1, 1, 5), (2, 2, 10), (3, 3, 2)]) \\"YES\\" >>> is_grid_balanced(3, 3, 1, [(1, 1, 5), (2, 2, 3), (3, 3, 6)]) \\"NO\\"","solution":"def is_grid_balanced(R, C, D, updates): row_sums = [0] * R col_sums = [0] * C for r, c, p in updates: row_sums[r-1] += p col_sums[c-1] += p max_row_sum = max(row_sums) min_row_sum = min(row_sums) max_col_sum = max(col_sums) min_col_sum = min(col_sums) if (max_row_sum - min_row_sum <= D) and (max_col_sum - min_col_sum <= D): return \\"YES\\" else: return \\"NO\\""},{"question":"def minimum_total_time(n: int, m: int, connections: List[Tuple[int, int, int]]) -> int: Calculate the minimum total time to establish a connected network using the most efficient routes. Args: n (int): The number of computers. m (int): The number of bidirectional connections. connections (List[Tuple[int, int, int]]): Each tuple contains three integers (a, b, w) representing a connection between computers a and b with a travel time of w. Returns: int: The minimum total time. If it is not possible to form a connected network, returns -1. Examples: >>> minimum_total_time(5, 6, [(1, 2, 4), (1, 3, 4), (2, 3, 2), (2, 4, 7), (3, 5, 3), (4, 5, 1)]) 10 >>> minimum_total_time(4, 2, [(1, 2, 3), (3, 4, 6)]) -1","solution":"import heapq def find_minimum_spanning_tree(n, edges): # Create adjacency list adj = {i: [] for i in range(1, n + 1)} for a, b, w in edges: adj[a].append((w, b)) adj[b].append((w, a)) # Prim's algorithm to find the Minimum Spanning Tree visited = set() min_heap = [(0, 1)] # (cost, node) total_cost = 0 while min_heap and len(visited) < n: cost, node = heapq.heappop(min_heap) if node in visited: continue visited.add(node) total_cost += cost for next_cost, next_node in adj[node]: if next_node not in visited: heapq.heappush(min_heap, (next_cost, next_node)) if len(visited) == n: return total_cost else: return -1 def minimum_total_time(n, m, connections): return find_minimum_spanning_tree(n, connections)"},{"question":"def substitute_cipher(plaintext: str, shift: int) -> str: Encrypt a text using a simple substitution cipher where each letter is shifted by a fixed number of positions in the alphabet, preserving the case. Parameters: plaintext (str): The text to be encrypted. shift (int): The number of positions each letter should be shifted. Returns: str: The encrypted text. Examples: >>> substitute_cipher(\\"hello world\\", 3) == \\"khoor zruog\\" >>> substitute_cipher(\\"Python\\", 5) == \\"Udymts\\" >>> substitute_cipher(\\"xyz\\", 3) == \\"abc\\" >>> substitute_cipher(\\"A\\" * 1000, 1) == \\"B\\" * 1000 >>> substitute_cipher(\\"aAbBzZ\\", 1) == \\"bBcCaA\\" >>> substitute_cipher(\\"aAbBzZ\\", 25) == \\"zZaAyY\\" >>> substitute_cipher(\\"The quick brown fox jumps over the lazy dog\\", 25) == \\"Sgd pthbj aqnvm enw itlor nudq sgd kzyx cnf\\" >>> substitute_cipher(\\"The quick brown fox jumps over the lazy dog\\", 1) == \\"Uif rvjdl cspxo gpy kvnqt pwfs uif mbaz eph\\"","solution":"def substitute_cipher(plaintext, shift): Encrypt a text using a simple substitution cipher where each letter is shifted by a fixed number of positions in the alphabet, preserving the case. Parameters: plaintext (str): The text to be encrypted. shift (int): The number of positions each letter should be shifted. Returns: str: The encrypted text. encrypted_text = [] for char in plaintext: if char.isalpha(): # Shift character within its case range if char.islower(): shifted_char = chr((ord(char) - ord('a') + shift) % 26 + ord('a')) else: shifted_char = chr((ord(char) - ord('A') + shift) % 26 + ord('A')) encrypted_text.append(shifted_char) else: encrypted_text.append(char) return ''.join(encrypted_text)"},{"question":"def max_distinct_fruits(n, fruits): Returns the maximum number of distinct fruit types between any two different stalls. >>> max_distinct_fruits(5, [1, 2, 1, 3, 2]) 3 >>> max_distinct_fruits(6, [5, 5, 5, 5, 1, 1]) 2","solution":"def max_distinct_fruits(n, fruits): Returns the maximum number of distinct fruit types between any two different stalls. max_distinct = 0 for i in range(n): seen = set() for j in range(i, n): seen.add(fruits[j]) max_distinct = max(max_distinct, len(seen)) return max_distinct # Example usage: # n = 5 # fruits = [1, 2, 1, 3, 2] # print(max_distinct_fruits(n, fruits)) # Output: 3"},{"question":"def max_consecutive_ones(binary_str: str) -> int: This function returns the maximum length of consecutive '1's in a binary string. >>> max_consecutive_ones(\\"1101\\") == 2 >>> max_consecutive_ones(\\"111011\\") == 3 >>> max_consecutive_ones(\\"100001\\") == 1 >>> max_consecutive_ones(\\"0000000\\") == 0 >>> max_consecutive_ones(\\"1111111\\") == 7 >>> max_consecutive_ones(\\"1010101010\\") == 1 def process_binary_strings(n: int, binary_strings: List[str]) -> List[int]: This function processes a list of binary strings and returns the maximum length of consecutive '1's for each string. >>> process_binary_strings(3, [\\"1101\\", \\"111011\\", \\"100001\\"]) == [2, 3, 1] >>> process_binary_strings(2, [\\"0000\\", \\"11111\\"]) == [0, 5] >>> process_binary_strings(1, [\\"10101\\"]) == [1] >>> process_binary_strings(3, [\\"111111\\", \\"00000\\", \\"010101\\"]) == [6, 0, 1]","solution":"def max_consecutive_ones(binary_str): This function returns the maximum length of consecutive '1's in a binary string. Parameters: - binary_str: string, input binary string Returns: - int, maximum length of consecutive '1's return max(len(segment) for segment in binary_str.split('0')) def process_binary_strings(n, binary_strings): This function processes a list of binary strings and prints the maximum length of consecutive '1's for each string. Parameters: - n: int, number of binary strings - binary_strings: list of strings, the binary strings Returns: - list of int, maximum lengths of consecutive '1's for each string return [max_consecutive_ones(binary_str) for binary_str in binary_strings]"},{"question":"from typing import List class TrainSystem: def __init__(self): pass def add_train(self, train_id, departure_time, stops_info): Adds a new train to the system with its route and schedule. pass def book_ticket(self, train_id, current_time, from_stop, to_stop): Books a ticket for a passenger from one stop to another. pass def get_revenue(self, train_id): Retrieves the total revenue generated by ticket sales for a specific train. pass def process_operations(operations: List[str]) -> List[str]: Simulates ticket bookings and calculates the total revenue. :param operations: A list of operations to process. :return: A list of results for each GetRevenue operation. Example: >>> operations = [ ... \\"AddTrain T1 08:00 A:10 B:15 C:20\\", ... \\"BookTicket T1 07:50 A B\\", ... \\"BookTicket T1 08:10 A B\\", ... \\"BookTicket T1 07:55 B C\\", ... \\"GetRevenue T1\\", ... \\"End\\" ... ] >>> process_operations(operations) [\\"25\\"] pass import pytest def test_add_train_and_get_revenue(): operations = [ \\"AddTrain T1 08:00 A:10 B:15 C:20\\", \\"GetRevenue T1\\", \\"End\\" ] assert process_operations(operations) == ['0'] def test_book_ticket_before_departure(): operations = [ \\"AddTrain T1 08:00 A:10 B:15 C:20\\", \\"BookTicket T1 07:50 A B\\", \\"GetRevenue T1\\", \\"End\\" ] assert process_operations(operations) == ['10'] def test_book_ticket_after_departure(): operations = [ \\"AddTrain T1 08:00 A:10 B:15 C:20\\", \\"BookTicket T1 08:10 A B\\", \\"GetRevenue T1\\", \\"End\\" ] assert process_operations(operations) == ['0'] def test_multiple_tickets_and_revenue(): operations = [ \\"AddTrain T1 08:00 A:10 B:15 C:20\\", \\"BookTicket T1 07:50 A B\\", \\"BookTicket T1 07:55 B C\\", \\"GetRevenue T1\\", \\"End\\" ] assert process_operations(operations) == ['25'] def test_multiple_trains(): operations = [ \\"AddTrain T1 08:00 A:10 B:15 C:20\\", \\"BookTicket T1 07:50 A B\\", \\"BookTicket T1 07:55 B C\\", \\"GetRevenue T1\\", \\"AddTrain T2 09:30 X:25 Y:30 Z:35\\", \\"BookTicket T2 09:15 X Y\\", \\"BookTicket T2 09:45 X Z\\", \\"GetRevenue T2\\", \\"End\\" ] assert process_operations(operations) == ['25', '25']","solution":"from datetime import datetime class TrainSystem: def __init__(self): self.trains = {} self.revenues = {} self.fares = {} def add_train(self, train_id, departure_time, stops_info): self.trains[train_id] = departure_time self.revenues[train_id] = 0 self.fares[train_id] = {} stops = stops_info.split() for stop in stops: stop_name, fare = stop.split(':') fare = int(fare) self.fares[train_id][stop_name] = fare def book_ticket(self, train_id, current_time, from_stop, to_stop): if train_id not in self.trains: return train_departure_time = self.trains[train_id] if datetime.strptime(current_time, \\"%H:%M\\") >= datetime.strptime(train_departure_time, \\"%H:%M\\"): return if from_stop in self.fares[train_id] and to_stop in self.fares[train_id]: fare = self.fares[train_id].get(from_stop, 0) self.revenues[train_id] += fare def get_revenue(self, train_id): return self.revenues.get(train_id, 0) def process_operations(operations): system = TrainSystem() results = [] for operation in operations: if operation.startswith(\\"AddTrain\\"): parts = operation.split(maxsplit=3) train_id = parts[1] departure_time = parts[2] stops_info = parts[3] system.add_train(train_id, departure_time, stops_info) elif operation.startswith(\\"BookTicket\\"): parts = operation.split() train_id = parts[1] current_time = parts[2] from_stop = parts[3] to_stop = parts[4] system.book_ticket(train_id, current_time, from_stop, to_stop) elif operation.startswith(\\"GetRevenue\\"): parts = operation.split() train_id = parts[1] revenue = system.get_revenue(train_id) results.append(str(revenue)) elif operation.strip() == \\"End\\": break return results operations = [ \\"AddTrain T1 08:00 A:10 B:15 C:20\\", \\"BookTicket T1 07:50 A B\\", \\"BookTicket T1 08:10 A B\\", \\"BookTicket T1 07:55 B C\\", \\"GetRevenue T1\\", \\"AddTrain T2 09:30 X:25 Y:30 Z:35\\", \\"BookTicket T2 09:15 X Y\\", \\"BookTicket T2 09:45 X Z\\", \\"GetRevenue T2\\", \\"End\\" ] output = process_operations(operations) for line in output: print(line)"},{"question":"def find_min_edges_to_remove(n: int, m: int, edges: List[Tuple[int, int]]) -> int: Determine the smallest number of edges that, when removed, would result in a forest. >>> find_min_edges_to_remove(5, 4, [(1, 2), (1, 3), (2, 3), (3, 4)]) == 1 >>> find_min_edges_to_remove(4, 5, [(1, 2), (1, 3), (1, 4), (3, 4), (4,2)]) == 2 >>> find_min_edges_to_remove(3, 2, [(1, 2), (2, 3)]) == 0 from typing import List, Tuple def test_find_min_edges_to_remove(): assert find_min_edges_to_remove(5, 4, [(1, 2), (1, 3), (2, 3), (3, 4)]) == 1 assert find_min_edges_to_remove(4, 5, [(1, 2), (1, 3), (1, 4), (3, 4), (4,2)]) == 2 assert find_min_edges_to_remove(3, 2, [(1, 2), (2, 3)]) == 0 assert find_min_edges_to_remove(6, 7, [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (1, 6), (2, 5)]) == 2 assert find_min_edges_to_remove(1, 0, []) == 0 assert find_min_edges_to_remove(2, 1, [(1, 2)]) == 0 assert find_min_edges_to_remove(3, 3, [(1, 2), (2, 3), (3, 1)]) == 1","solution":"def find_min_edges_to_remove(n, m, edges): def find(parent, i): if parent[i] == i: return i else: return find(parent, parent[i]) def union(parent, rank, x, y): xroot = find(parent, x) yroot = find(parent, y) if xroot != yroot: if rank[xroot] > rank[yroot]: parent[yroot] = xroot elif rank[xroot] < rank[yroot]: parent[xroot] = yroot else: parent[yroot] = xroot rank[xroot] += 1 parent = [] rank = [] for node in range(n): parent.append(node) rank.append(0) remove_count = 0 for u, v in edges: x = find(parent, u - 1) y = find(parent, v - 1) if x == y: remove_count += 1 else: union(parent, rank, x, y) return remove_count"},{"question":"def length_of_LIS(nums) -> int: Returns the length of the longest increasing subsequence in the given list of numbers. >>> length_of_LIS([]) == 0 >>> length_of_LIS([10]) == 1 >>> length_of_LIS([3, 3, 3, 3, 3]) == 1 >>> length_of_LIS([1, 2, 3, 4, 5]) == 5 >>> length_of_LIS([5, 4, 3, 2, 1]) == 1 >>> length_of_LIS([10, 9, 2, 5, 3, 7, 101, 18]) == 4 >>> length_of_LIS([0, 1, 0, 3, 2, 3]) == 4 >>> length_of_LIS([1, 3, 6, 7, 9, 4, 10, 5, 6]) == 6","solution":"def length_of_LIS(nums): Returns the length of the longest increasing subsequence in the given list of numbers. if not nums: return 0 dp = [1] * len(nums) for i in range(1, len(nums)): for j in range(i): if nums[i] > nums[j]: dp[i] = max(dp[i], dp[j] + 1) return max(dp)"},{"question":"def can_feed_all_animals(n, m, food_data): Determines if all animals can be fed with the given types of food. :param n: Number of food types :param m: Number of animals :param food_data: List of food data. Each food datum is a list, where the first element is the number of animals that can eat this type of food and the following elements are the indices of those animals. :returns: 'YES' if all animals can be fed, otherwise 'NO' pass def test_example_1(): assert can_feed_all_animals(4, 3, [(2, 1, 3), (1, 2), (2, 2, 3), (1, 1)]) == \\"YES\\" def test_example_2(): assert can_feed_all_animals(2, 3, [(1, 1), (1, 2)]) == \\"NO\\" def test_single_food_single_animal(): assert can_feed_all_animals(1, 1, [(1, 1)]) == \\"YES\\" def test_single_food_multiple_animals(): assert can_feed_all_animals(1, 3, [(3, 1, 2, 3)]) == \\"YES\\" def test_multiple_foods_all_animals_fed(): assert can_feed_all_animals(3, 3, [(1, 1), (1, 2), (1, 3)]) == \\"YES\\" def test_foods_do_not_feed_all_animals(): assert can_feed_all_animals(2, 4, [(2, 1, 2), (1, 3)]) == \\"NO\\" def test_no_overlap_food(): assert can_feed_all_animals(3, 5, [(2, 1, 2), (2, 3, 4), (1, 5)]) == \\"YES\\"","solution":"def can_feed_all_animals(n, m, food_data): Determines if all animals can be fed with the given types of food. :param n: Number of food types :param m: Number of animals :param food_data: List of food data. Each food datum is a list, where the first element is the number of animals that can eat this type of food and the following elements are the indices of those animals. :returns: 'YES' if all animals can be fed, otherwise 'NO' fed_animals = set() for food in food_data: for animal in food[1:]: fed_animals.add(animal) return \\"YES\\" if len(fed_animals) == m else \\"NO\\""},{"question":"def unique_paths_with_obstacles(grid): Determine the number of unique paths for an adventurer to reach the end of the grid from the start, considering obstacles. :param grid: List[List[int]] - A 2D list representing the grid where '0' is a free path and '1' is an obstacle. :return: int - The number of unique paths to reach the destination. >>> unique_paths_with_obstacles([[0, 0, 0], [0, 1, 0], [0, 0, 0]]) 2 >>> unique_paths_with_obstacles([[0, 1], [0, 0]]) 1 def num_ways_to_reach_end(T, test_cases): For multiple test cases, determine the number of unique paths for an adventurer to reach the end of each grid from the start, considering obstacles. :param T: int - The number of test cases. :param test_cases: List[dict] - A list of dictionaries, each containing: - 'm': int - number of rows in the grid - 'n': int - number of columns in the grid - 'grid': List[List[int]] - a 2D list representing the grid for each test case. :return: List[int] - A list containing the number of unique paths for each test case. >>> num_ways_to_reach_end(2, [{'m': 3, 'n': 3, 'grid': [[0, 0, 0], [0, 1, 0], [0, 0, 0]]}, {'m': 2, 'n': 2, 'grid': [[0, 1], [0, 0]]}]) [2, 1]","solution":"def unique_paths_with_obstacles(grid): if grid[0][0] == 1: return 0 m, n = len(grid), len(grid[0]) dp = [[0] * n for _ in range(m)] dp[0][0] = 1 for i in range(m): for j in range(n): if grid[i][j] == 1: dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i - 1][j] if j > 0: dp[i][j] += dp[i][j - 1] return dp[-1][-1] def num_ways_to_reach_end(T, test_cases): results = [] for case in test_cases: m, n = case['m'], case['n'] grid = case['grid'] results.append(unique_paths_with_obstacles(grid)) return results"},{"question":"from typing import List, Tuple def can_monitor_all_rooms(R: int, C: int, connections: List[Tuple[int, int]]) -> str: Determine if it is possible to monitor all rooms by rearranging or adding cameras. Args: R (int): Number of rooms. C (int): Number of cameras. connections (list): List of pairs of rooms indicating cameras between those rooms. Returns: str: \\"YES\\" if all rooms can be monitored, otherwise \\"NO\\". Example: >>> can_monitor_all_rooms(5, 4, [(1, 2), (2, 3), (3, 4), (4, 5)]) \\"YES\\" >>> can_monitor_all_rooms(4, 2, [(1, 2), (3, 4)]) \\"NO\\" def test_all_rooms_connected(): assert can_monitor_all_rooms(5, 4, [(1, 2), (2, 3), (3, 4), (4, 5)]) == \\"YES\\" def test_some_rooms_unconnected(): assert can_monitor_all_rooms(4, 2, [(1, 2), (3, 4)]) == \\"NO\\" def test_minimal_setup(): assert can_monitor_all_rooms(1, 0, []) == \\"YES\\" assert can_monitor_all_rooms(2, 1, [(1, 2)]) == \\"YES\\" assert can_monitor_all_rooms(2, 0, []) == \\"NO\\" def test_complex_graph(): assert can_monitor_all_rooms(6, 5, [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6)]) == \\"YES\\" assert can_monitor_all_rooms(6, 4, [(1, 2), (2, 3), (4, 5), (5, 6)]) == \\"NO\\" def test_disconnected_multicomponent(): assert can_monitor_all_rooms(7, 6, [(1, 2), (2, 3), (4, 5), (5, 6), (6, 7), (3, 4)]) == \\"YES\\" assert can_monitor_all_rooms(7, 5, [(1, 2), (2, 3), (4, 5), (5, 6), (6, 7)]) == \\"NO\\"","solution":"def can_monitor_all_rooms(R, C, connections): Determine if it is possible to monitor all rooms by rearranging or adding cameras. Args: R (int): Number of rooms. C (int): Number of cameras. connections (list): List of pairs of rooms indicating cameras between those rooms. Returns: str: \\"YES\\" if all rooms can be monitored, otherwise \\"NO\\". from collections import defaultdict # Adjacency list for graph representation of rooms graph = defaultdict(set) # Building graph connections for u, v in connections: graph[u].add(v) graph[v].add(u) # Function to perform depth-first search to check connectivity def dfs(node, visited): stack = [node] while stack: room = stack.pop() if room not in visited: visited.add(room) stack.extend(graph[room] - visited) # Check if all rooms are connected by starting from room 1 given room numbering starts from 1 visited = set() dfs(1, visited) # If all R rooms are visited, then they are all connected if len(visited) == R: return \\"YES\\" else: return \\"NO\\""},{"question":"def is_prime(n: int) -> bool: Helper function to check if a number n is prime. >>> is_prime(2) True >>> is_prime(4) False >>> is_prime(17) True # Implementation here def sum_of_primes(A: int, B: int) -> int: Returns the sum of all prime numbers between A and B (inclusive). >>> sum_of_primes(1, 10) 17 >>> sum_of_primes(20, 30) 52 >>> sum_of_primes(14, 16) 0 >>> sum_of_primes(5, 5) 5 >>> sum_of_primes(8, 10) 0 >>> sum_of_primes(1, 20) 77 >>> sum_of_primes(2, 2) 2 # Implementation here","solution":"def is_prime(n): Helper function to check if a number n is prime. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def sum_of_primes(A, B): Returns the sum of all prime numbers between A and B (inclusive). total_sum = 0 for num in range(A, B + 1): if is_prime(num): total_sum += num return total_sum"},{"question":"def encrypt_string(s: str) -> int: This function takes a string and returns the sum of the positions in the alphabet of all alphabetic characters, case insensitive. >>> encrypt_string(\\"Hello, World!\\") 124 >>> encrypt_string(\\"abcXYZ\\") 81 >>> encrypt_string(\\"password123456789!\\") 115 >>> encrypt_string(\\"\\") 0 >>> encrypt_string(\\"1234567890!@#%^&*()\\") 0 >>> encrypt_string(\\"AbCdEfG\\") 28 >>> encrypt_string(\\"a\\" * 100000) 100000","solution":"def encrypt_string(s): This function takes a string and returns the sum of the positions in the alphabet of all alphabetic characters, case insensitive. total = 0 for char in s: if char.isalpha(): # Check if the character is alphabetic # Convert to lowercase and subtract ord('a') to get 0-based position then add 1 for 1-based position total += ord(char.lower()) - ord('a') + 1 return total"},{"question":"from typing import List def longest_zigzag_sequence(arr: List[int]) -> int: Determine the length of the longest zig-zag patterned subsequence. >>> longest_zigzag_sequence([1, 7, 4, 9, 2, 5]) 6 >>> longest_zigzag_sequence([1, 4, 7, 2, 5]) 4 >>> longest_zigzag_sequence([1]) 1 def process_test_cases(T: int, test_cases: List[List[int]]) -> List[int]: Process multiple test cases to find the length of the longest zig-zag patterned subsequence for each case. >>> process_test_cases(2, [[6, [1, 7, 4, 9, 2, 5]], [5, [1, 4, 7, 2, 5]]]) [6, 4] >>> process_test_cases(1, [[1, [1]]]) [1]","solution":"def longest_zigzag_sequence(arr): n = len(arr) if n < 2: return n up = 1 down = 1 for i in range(1, n): if arr[i] > arr[i-1]: up = down + 1 elif arr[i] < arr[i-1]: down = up + 1 return max(up, down) def process_test_cases(T, test_cases): results = [] for i in range(T): N = test_cases[i][0] arr = test_cases[i][1] results.append(longest_zigzag_sequence(arr)) return results"},{"question":"from math import factorial def count_distinct_necklaces(k: int) -> int: Alice has a collection of beads, each bead having one of k different colors. She wants to give necklaces to her friends, each necklace having exactly one bead of each color. However, the necklaces should not have the same arrangement of colors. Count the number of distinct necklaces Alice can prepare. >>> count_distinct_necklaces(1) 1 >>> count_distinct_necklaces(3) 2 >>> count_distinct_necklaces(4) 6","solution":"from math import factorial def count_distinct_necklaces(k): if k == 1: return 1 return factorial(k - 1)"},{"question":"import math def largest_square_side(n: int, m: int) -> int: Determine the largest possible side length of square gardens such that there is no leftover land. >>> largest_square_side(6, 9) 3 >>> largest_square_side(8, 14) 2 >>> largest_square_side(15, 25) 5 >>> largest_square_side(10, 10) 10 >>> largest_square_side(1000000, 1000000) 1000000 >>> largest_square_side(13, 13) 13 >>> largest_square_side(13, 26) 13 >>> largest_square_side(18, 27) 9","solution":"import math def largest_square_side(n, m): Returns the largest possible side length of square gardens such that there is no leftover land. return math.gcd(n, m)"},{"question":"from typing import List def min_cost_path(grid: List[List[int]]) -> int: Given a grid with N rows and M columns, find the minimum cost path from the top-left cell (0,0) to the bottom-right cell (N-1,M-1). The path cost is defined by the number of moves made, and you can only move to cells that have different values from the current cell. >>> min_cost_path([[1, 3, 2, 4], [4, 1, 3, 2], [2, 4, 1, 3], [3, 2, 4, 1]]) 6 >>> min_cost_path([[1, 1], [1, 1]]) -1 >>> min_cost_path([[5]]) 0 >>> min_cost_path([[1, 2, 3], [3, 1, 2], [2, 3, 1]]) 4 >>> min_cost_path([[1, 2, 3, 4], [4, 1, 2, 3], [3, 4, 1, 2], [2, 3, 4, 1]]) 6 >>> min_cost_path([[1, 4, 3, 2, 5], [6, 1, 4, 3, 2], [7, 6, 1, 4, 3], [8, 7, 6, 1, 4], [9, 8, 7, 6, 1]]) 8","solution":"from heapq import heappop, heappush def min_cost_path(grid): N = len(grid) M = len(grid[0]) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] cost = [[float('inf')] * M for _ in range(N)] cost[0][0] = 0 # Starting point has 0 cost heap = [(0, 0, 0)] # cost, row, column while heap: curr_cost, r, c = heappop(heap) if r == N - 1 and c == M - 1: return curr_cost for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < N and 0 <= nc < M and grid[nr][nc] != grid[r][c]: new_cost = curr_cost + 1 if new_cost < cost[nr][nc]: cost[nr][nc] = new_cost heappush(heap, (new_cost, nr, nc)) return -1 if cost[N-1][M-1] == float('inf') else cost[N-1][M-1] # Example usage: # N, M = 4, 4 # grid = [ # [1, 3, 2, 4], # [4, 1, 3, 2], # [2, 4, 1, 3], # [3, 2, 4, 1] # ] # result = min_cost_path(grid) # print(result) # Output: 6"},{"question":"def transform_list(lst): Transforms the list by reversing the first half (including the middle element if the list has an odd number of elements) and keeping the second half in the original order. >>> transform_list([1, 2, 3, 4, 5]) == [3, 2, 1, 4, 5] >>> transform_list([10, 20, 30, 40, 50, 60]) == [30, 20, 10, 40, 50, 60] >>> transform_list([9]) == [9] >>> transform_list([1, 2]) == [1, 2] >>> transform_list([1, 2, 3]) == [2, 1, 3] >>> transform_list(list(range(1, 100001))) == list(range(1, 50001))[::-1] + list(range(50001, 100001))","solution":"def transform_list(lst): Transforms the list by reversing the first half (including the middle element if the list has an odd number of elements) and keeping the second half in the original order. n = len(lst) mid = (n + 1) // 2 # middle point, includes the middle element for odd length first_half_reversed = lst[:mid][::-1] second_half = lst[mid:] return first_half_reversed + second_half"},{"question":"def competition_result(n: int, scores: List[Tuple[str, int]]) -> str: Determines the result of the competition based on the provided scores. :param n: Number of celebrities :param scores: List of tuples containing celebrity names and their scores :return: Result in the format \\"draw\\" or \\"winner <celebrity_name>\\" or \\"loser <celebrity_name>\\" >>> competition_result(4, [(\\"alice\\", 7), (\\"bob\\", 14), (\\"claire\\", 11), (\\"david\\", 17)]) \\"draw\\" >>> competition_result(3, [(\\"eve\\", 15), (\\"frank\\", 7), (\\"grace\\", 11)]) \\"winner eve\\" >>> competition_result(5, [(\\"hank\\", 15), (\\"irene\\", 30), (\\"jack\\", 45), (\\"kyle\\", 7), (\\"lara\\", 60)]) \\"loser kyle\\" from typing import List, Tuple def test_draw_scenario(): assert competition_result(4, [(\\"alice\\", 7), (\\"bob\\", 14), (\\"claire\\", 11), (\\"david\\", 17)]) == \\"draw\\" def test_single_winner_scenario(): assert competition_result(3, [(\\"eve\\", 15), (\\"frank\\", 7), (\\"grace\\", 11)]) == \\"winner eve\\" assert competition_result(3, [(\\"eve\\", 2), (\\"frank\\", 9), (\\"grace\\", 8)]) == \\"winner frank\\" def test_single_loser_scenario(): assert competition_result(5, [(\\"hank\\", 15), (\\"irene\\", 30), (\\"jack\\", 45), (\\"kyle\\", 7), (\\"lara\\", 60)]) == \\"loser kyle\\" assert competition_result(4, [(\\"alice\\", 16), (\\"bob\\", 20), (\\"claire\\", 21), (\\"david\\", 24)]) == \\"loser alice\\" def test_all_meeting_condition(): assert competition_result(3, [(\\"adam\\", 9), (\\"eve\\", 15), (\\"john\\", 30)]) == \\"draw\\" assert competition_result(2, [(\\"alice\\", 6), (\\"bob\\", 9)]) == \\"draw\\" def test_none_meeting_condition(): assert competition_result(2, [(\\"adam\\", 1), (\\"eve\\", 7)]) == \\"draw\\"","solution":"def competition_result(n, scores): Determines the result of the competition based on the provided scores. :param n: Number of celebrities :param scores: List of tuples containing celebrity names and their scores :return: Result in the format \\"draw\\" or \\"winner <celebrity_name>\\" or \\"loser <celebrity_name>\\" condition_met = [] condition_not_met = [] for name, score in scores: if score % 3 == 0 or score % 5 == 0: condition_met.append(name) else: condition_not_met.append(name) if len(condition_met) == 0: return \\"draw\\" elif len(condition_met) == 1: return f\\"winner {condition_met[0]}\\" elif len(condition_not_met) == 1: return f\\"loser {condition_not_met[0]}\\" else: return \\"draw\\""},{"question":"def can_plant_flowers(n: int, m: int, c: int) -> str: Determines if Bob can plant the flowers such that no two flowers in the same row have the same color. Parameters: n (int): Number of rows in the garden grid. m (int): Number of columns in the garden grid. c (int): Number of different colors available. Returns: str: \\"YES\\" if Bob can plant the flowers as described, otherwise \\"NO\\". pass def test_can_plant_flowers_yes(): assert can_plant_flowers(2, 3, 3) == \\"YES\\" assert can_plant_flowers(1, 1, 1) == \\"YES\\" assert can_plant_flowers(3, 3, 3) == \\"YES\\" def test_can_plant_flowers_no(): assert can_plant_flowers(2, 4, 3) == \\"NO\\" assert can_plant_flowers(5, 6, 5) == \\"NO\\" assert can_plant_flowers(4, 5, 4) == \\"NO\\" def test_edge_cases(): assert can_plant_flowers(1, 100, 100) == \\"YES\\" assert can_plant_flowers(100, 1, 1) == \\"YES\\" assert can_plant_flowers(100, 100, 100) == \\"YES\\" assert can_plant_flowers(100, 100, 99) == \\"NO\\"","solution":"def can_plant_flowers(n, m, c): Determines if Bob can plant the flowers such that no two flowers in the same row have the same color. Parameters: n (int): Number of rows in the garden grid. m (int): Number of columns in the garden grid. c (int): Number of different colors available. Returns: str: \\"YES\\" if Bob can plant the flowers as described, otherwise \\"NO\\". # For each row, Bob needs m unique colors if m <= c: return \\"YES\\" else: return \\"NO\\""},{"question":"def sieve_of_eratosthenes(n: int) -> List[int]: Returns a list of all prime numbers up to and including n using the Sieve of Eratosthenes algorithm. >>> sieve_of_eratosthenes(10) [2, 3, 5, 7] >>> sieve_of_eratosthenes(1) [] >>> sieve_of_eratosthenes(20) [2, 3, 5, 7, 11, 13, 17, 19] >>> sieve_of_eratosthenes(30) [2, 3, 5, 7, 11, 13, 17, 19, 23, 29] >>> sieve_of_eratosthenes(29) [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]","solution":"def sieve_of_eratosthenes(n): Returns a list of all prime numbers up to and including n using the Sieve of Eratosthenes algorithm. if n < 2: return [] is_prime = [True] * (n + 1) is_prime[0], is_prime[1] = False, False # 0 and 1 are not primes primes = [] for i in range(2, n + 1): if is_prime[i]: primes.append(i) for j in range(i * i, n + 1, i): is_prime[j] = False return primes"},{"question":"def reformat_paragraph(p: str) -> str: Reformats a given paragraph by ensuring there is exactly one space character between words and no leading or trailing space. :param p: str, the input paragraph :return: str, the reformatted paragraph >>> reformat_paragraph(\\" Hello world! This is an example sentence. \\") \\"Hello world! This is an example sentence.\\" >>> reformat_paragraph(\\"Hello world! This is an example sentence.\\") \\"Hello world! This is an example sentence.\\" >>> reformat_paragraph(\\" Leading and trailing spaces \\") \\"Leading and trailing spaces\\" >>> reformat_paragraph(\\"Multiple spaces between words\\") \\"Multiple spaces between words\\" >>> reformat_paragraph(\\" \\") \\"\\" >>> reformat_paragraph(\\"Word\\") \\"Word\\" >>> reformat_paragraph(\\" Word \\") \\"Word\\"","solution":"def reformat_paragraph(p): Reformats a given paragraph by ensuring there is exactly one space character between words and no leading or trailing space. :param p: str, the input paragraph :return: str, the reformatted paragraph # Strip leading/trailing spaces and split the paragraph by space words = p.strip().split() # Join the words with a single space return ' '.join(words)"},{"question":"def solve_cryptarithm(): Solves the given addition cryptarithm puzzle and returns a dictionary with the digit values for the letters S, E, N, D, M, O, R, and Y. pass # Test cases if __name__ == \\"__main__\\": result = solve_cryptarithm() assert result is not None # Check the expected values as per the solution assert result['S'] == 9 assert result['E'] == 5 assert result['N'] == 6 assert result['D'] == 7 assert result['M'] == 1 assert result['O'] == 0 assert result['R'] == 8 assert result['Y'] == 2 # Ensure all digits are unique digits = set(result.values()) assert len(digits) == 8 # Ensure no leading zeros for SEND and MORE assert result['S'] != 0 assert result['M'] != 0","solution":"def solve_cryptarithm(): Solves the given addition cryptarithm puzzle and returns a dictionary with the digit values for the letters S, E, N, D, M, O, R, and Y. from itertools import permutations # Define the letters involved in the puzzle letters = 'SENDMORY' # Define the function that checks if a particular permutation of digits is a valid solution def is_valid_solution(perm): # Create a mapping from letters to digits mapping = dict(zip(letters, perm)) # S and M cannot be zero if mapping['S'] == 0 or mapping['M'] == 0: return False # Calculate the integer values of SEND, MORE, and MONEY based on the current mapping SEND = mapping['S'] * 1000 + mapping['E'] * 100 + mapping['N'] * 10 + mapping['D'] MORE = mapping['M'] * 1000 + mapping['O'] * 100 + mapping['R'] * 10 + mapping['E'] MONEY = mapping['M'] * 10000 + mapping['O'] * 1000 + mapping['N'] * 100 + mapping['E'] * 10 + mapping['Y'] # Check if this mapping satisfies the equation SEND + MORE = MONEY return SEND + MORE == MONEY # Try all permutations of the digits 0-9 for the letters for perm in permutations(range(10), 8): if is_valid_solution(perm): # Create a mapping from letters to digits for the valid solution mapping = dict(zip(letters, perm)) return mapping # If no solution is found, return None return None # Output the solution solution = solve_cryptarithm() if solution: for letter in 'SENDMORY': print(f\\"{letter} = {solution[letter]}\\")"},{"question":"def compress_string(s: str) -> str: Compress the string using the rules specified, and return the compressed version if it is smaller, otherwise return the original string. :param s: Input string to be compressed :return: Compressed string or original string if compressed is not smaller >>> compress_string(\\"aaabcccccaaa\\") 'a3b1c5a3' >>> compress_string(\\"abcd\\") 'abcd' >>> compress_string(\\"aaaaaaaaaa\\") 'a10' >>> compress_string(\\"abababab\\") 'abababab' >>> compress_string(\\"a\\") 'a' >>> compress_string(\\"\\") '' >>> compress_string(\\"aabb\\") 'aabb'","solution":"def compress_string(s): Compress the string using the rules specified. :param s: Input string to be compressed :return: Compressed string or original string if compressed is not smaller if not s: return s compressed = [] count = 1 prev_char = s[0] for char in s[1:]: if char == prev_char: count += 1 else: compressed.append(prev_char + str(count)) prev_char = char count = 1 compressed.append(prev_char + str(count)) compressed_str = ''.join(compressed) return compressed_str if len(compressed_str) < len(s) else s"},{"question":"def min_length_string(s: str) -> int: Determines the minimum length of the string that can be obtained after replacing any substring of '0's with a single '1'. >>> min_length_string(\\"001010\\") 3 >>> min_length_string(\\"000000\\") 1 >>> min_length_string(\\"101\\") 3","solution":"def min_length_string(s): Determines the minimum length of the string that can be obtained after replacing any substring of '0's with a single '1'. # Count number of '1's in the string count_ones = s.count('1') # Check if there is at least one '0' in the string has_zero = '0' in s # Since each contiguous group of '0's can be replaced with a single '1', # the minimum length will be the count of '1's plus one if there are any '0's. return count_ones + (1 if has_zero else 0)"},{"question":"def build_string(starting_letter: str, length: int) -> str: Constructs a string starting with 'starting_letter' and continues until the specified length. Wraps around the alphabet if needed. :param starting_letter: str : single lowercase starting letter :param length: int : the length of the string to be constructed :return: str : the constructed string >>> build_string('a', 5) 'abcde' >>> build_string('x', 3) 'xyz' >>> build_string('p', 8) 'pqrstuvw' def construct_strings(test_cases: List[Tuple[str, int]]) -> List[str]: Constructs a list of strings according to the provided test cases. :param test_cases: list : List of tuples each containing one starting letter and an integer length :return: list : List of resulting strings for each test case >>> construct_strings([('a', 5)]) ['abcde'] >>> construct_strings([('x', 3)]) ['xyz'] >>> construct_strings([('p', 8)]) ['pqrstuvw']","solution":"def build_string(starting_letter, length): Constructs a string starting with 'starting_letter' and continues until the specified length. Wraps around the alphabet if needed. :param starting_letter: str : single lowercase starting letter :param length: int : the length of the string to be constructed :return: str : the constructed string result = [] for i in range(length): current_char = chr((ord(starting_letter) - ord('a') + i) % 26 + ord('a')) result.append(current_char) return ''.join(result) def construct_strings(test_cases): Constructs a list of strings according to the provided test cases. :param test_cases: list : List of tuples each containing one starting letter and an integer length :return: list : List of resulting strings for each test case results = [] for starting_letter, length in test_cases: results.append(build_string(starting_letter, length)) return results"},{"question":"def group_anagrams(strings: List[str]) -> List[List[str]]: Given a list of strings, groups the anagrams together. An anagram is a word, phrase, or name formed by rearranging the letters of another, such as \\"cinema\\" and \\"iceman\\". >>> group_anagrams([\\"eat\\", \\"tea\\", \\"tan\\", \\"ate\\", \\"nat\\", \\"bat\\"]) [['ate', 'eat', 'tea'], ['bat'], ['nat', 'tan']] >>> group_anagrams([\\"apple\\", \\"pale\\", \\"leap\\"]) [['apple'], ['leap', 'pale']]","solution":"def group_anagrams(strings): from collections import defaultdict anagrams = defaultdict(list) for s in strings: sorted_s = ''.join(sorted(s)) anagrams[sorted_s].append(s) # Convert the defaultdict to a list of lists result = list(anagrams.values()) # Sort each group of anagrams lexicographically for group in result: group.sort() # Sort the groups lexicographically based on their first element result.sort(key=lambda x: x[0]) return result"},{"question":"from typing import List def largest_product(n: int, nums: List[int]) -> int: Returns the largest product of two distinct numbers in the list. Parameters: n (int): number of integers in the list. nums (list of int): list of integers. Returns: int: largest product of two distinct numbers. >>> largest_product(5, [-10, -20, 5, 2, -3]) 200 >>> largest_product(4, [3, 7, 2, 1]) 21 def test_all_negative_numbers(): assert largest_product(5, [-10, -20, -5, -2, -3]) == 200 def test_mixed_sign_numbers(): assert largest_product(5, [-10, -20, 5, 2, -3]) == 200 def test_all_positive_numbers(): assert largest_product(4, [3, 7, 2, 1]) == 21 def test_single_pair_of_numbers(): assert largest_product(2, [3, 5]) == 15 def test_large_and_small_numbers(): assert largest_product(6, [-1000, 500, 400, -500, 0, 1000]) == 500000 def test_repeated_numbers(): assert largest_product(4, [1, 1, 1, 1]) == 1 def test_zero_in_list(): assert largest_product(3, [0, -1, -2]) == 2 assert largest_product(5, [-3, -2, -1, 0, 0]) == 6 def test_minimum_input(): assert largest_product(2, [-1, 2]) == -2","solution":"def largest_product(n, nums): Returns the largest product of two distinct numbers in the list. Parameters: n (int): number of integers in the list. nums (list of int): list of integers. Returns: int: largest product of two distinct numbers. if n < 2: return 0 nums.sort() # The maximum product of two distinct numbers in a sorted list is either one of the # products of the two largest positive numbers or the two smallest negative numbers. max_product = max(nums[0] * nums[1], nums[-1] * nums[-2]) return max_product"},{"question":"class FenwickTree: def __init__(self, size): self.size = size self.tree = [0] * (size + 1) def update(self, index, value): while index <= self.size: self.tree[index] += value index += index & -index def query(self, index): sum = 0 while index > 0: sum += self.tree[index] index -= index & -index return sum def process_operations(n, q, array, operations): Perform operations on the array A and return the results of sum queries. >>> process_operations(5, 3, [5, 3, 8, 6, 2], [(2, 1, 3), (1, 2, 10), (2, 1, 3)]) [16, 23] >>> process_operations(4, 4, [1, 2, 3, 4], [(2, 1, 4), (1, 3, 10), (2, 2, 3), (2, 1, 2)]) [10, 12, 3] import unittest class TestProcessOperations(unittest.TestCase): def test_process_operations(self): n = 5 q = 3 array = [5, 3, 8, 6, 2] operations = [(2, 1, 3), (1, 2, 10), (2, 1, 3)] expected_output = [16, 23] self.assertEqual(process_operations(n, q, array, operations), expected_output) def test_process_operations_case2(self): n = 4 q = 4 array = [1, 2, 3, 4] operations = [(2, 1, 4), (1, 3, 10), (2, 2, 3), (2, 1, 2)] expected_output = [10, 12, 3] self.assertEqual(process_operations(n, q, array, operations), expected_output) def test_process_operations_case_with_all_updates(self): n = 3 q = 3 array = [1, 1, 1] operations = [(1, 1, 10), (1, 2, 20), (1, 3, 30)] expected_output = [] self.assertEqual(process_operations(n, q, array, operations), expected_output) def test_process_operations_case_with_all_queries(self): n = 3 q = 3 array = [2, 4, 6] operations = [(2, 1, 3), (2, 1, 2), (2, 2, 3)] expected_output = [12, 6, 10] self.assertEqual(process_operations(n, q, array, operations), expected_output)","solution":"class FenwickTree: def __init__(self, size): self.size = size self.tree = [0] * (size + 1) def update(self, index, value): while index <= self.size: self.tree[index] += value index += index & -index def query(self, index): sum = 0 while index > 0: sum += self.tree[index] index -= index & -index return sum def process_operations(n, q, array, operations): fenwick_tree = FenwickTree(n) result = [] # Initialize Fenwick Tree with array values for i in range(n): fenwick_tree.update(i + 1, array[i]) for operation in operations: op_type, x, y = operation if op_type == 1: current_val = fenwick_tree.query(x) - fenwick_tree.query(x - 1) fenwick_tree.update(x, y - current_val) elif op_type == 2: result.append(fenwick_tree.query(y) - fenwick_tree.query(x - 1)) return result"},{"question":"from typing import List def count_paths(grid: List[List[int]]) -> int: Given an n x n grid with some cells blocked (represented by 1) and some cells open (represented by 0), find the number of paths from the top-left corner to the bottom-right corner. You can only move right or down and you cannot pass through blocked cells. >>> count_paths([ ... [0, 0, 0], ... [0, 1, 0], ... [0, 0, 0] ... ]) 2 >>> count_paths([ ... [0, 1, 0, 0], ... [0, 0, 1, 0], ... [1, 0, 0, 0], ... [0, 0, 0, 0] ... ]) 3 >>> count_paths([ ... [0, 1], ... [0, 0] ... ]) 1 pass def solve_grids(test_cases: List[List[List[int]]]) -> List[int]: For each grid in the list of test cases, calculate the number of paths from the top-left corner to the bottom-right corner using the 'count_paths' function. >>> solve_grids([ ... [ ... [0, 0, 0], ... [0, 1, 0], ... [0, 0, 0] ... ], ... [ ... [0, 1, 0, 0], ... [0, 0, 1, 0], ... [1, 0, 0, 0], ... [0, 0, 0, 0] ... ], ... [ ... [0, 1], ... [0, 0] ... ] ... ]) [2, 3, 1] pass def parse_input(input_str: str) -> List[List[List[int]]]: Parse the input string and return a list of grids for the test cases. >>> parse_input(\\"3n3n0 0 0n0 1 0n0 0 0n4n0 1 0 0n0 0 1 0n1 0 0 0n0 0 0 0n2n0 1n0 0\\") [[[0, 0, 0], [0, 1, 0], [0, 0, 0]], [[0, 1, 0, 0], [0, 0, 1, 0], [1, 0, 0, 0], [0, 0, 0, 0]], [[0, 1], [0, 0]]] pass def main(input_str: str) -> List[int]: Read the input, parse the test cases, solve each grid, and return the results. >>> main(\\"3n3n0 0 0n0 1 0n0 0 0n4n0 1 0 0n0 0 1 0n1 0 0 0n0 0 0 0n2n0 1n0 0\\") [2, 3, 1] pass","solution":"def count_paths(grid): n = len(grid) if grid[0][0] == 1 or grid[n-1][n-1] == 1: return 0 dp = [[0] * n for _ in range(n)] dp[0][0] = 1 for i in range(n): for j in range(n): if grid[i][j] == 1: dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[n-1][n-1] def solve_grids(test_cases): results = [] for grid in test_cases: results.append(count_paths(grid)) return results def parse_input(input_str): lines = input_str.strip().split('n') T = int(lines[0]) index = 1 test_cases = [] for _ in range(T): n = int(lines[index]) grid = [] for i in range(n): grid.append(list(map(int, lines[index + 1 + i].split()))) test_cases.append(grid) index += n + 1 return test_cases def main(input_str): test_cases = parse_input(input_str) return solve_grids(test_cases)"},{"question":"def min_operations_to_k_different_integers(n: int, k: int, arr: List[int]) -> int: Given an array of n integers and an integer k, determine the minimum number of operations required to make the array contain at least k different integers. >>> min_operations_to_k_different_integers(5, 3, [1, 2, 2, 2, 3]) 0 >>> min_operations_to_k_different_integers(4, 4, [1, 1, 1, 1]) 3 >>> min_operations_to_k_different_integers(3, 2, [100, 100, 100]) 1","solution":"def min_operations_to_k_different_integers(n, k, arr): unique_numbers = len(set(arr)) if unique_numbers >= k: return 0 return k - unique_numbers"},{"question":"def max_weight_per_day(d: int, w: int, catches: List[List[int]]) -> List[int]: Determine the maximum total weight of fish the fisherman brings home each day. Args: d (int): The number of days. w (int): The maximum weight the fisherman can carry each day. catches (List[List[int]]): Weights of the fish caught each day. Returns: List[int]: Maximum total weight of fish for each day. Example: >>> max_weight_per_day(3, 50, [[10, 20, 30, 40], [5, 10, 15], [1, 2, 3, 4, 5]]) [50, 30, 15] >>> max_weight_per_day(2, 35, [[5, 10, 20, 25, 7], [8, 9, 10, 11, 13, 15]]) [35, 35] pass def test_max_weight_per_day(): d = 3 w = 50 catches = [ [10, 20, 30, 40], [5, 10, 15], [1, 2, 3, 4, 5] ] assert max_weight_per_day(d, w, catches) == [50, 30, 15] def test_second_example(): d = 2 w = 35 catches = [ [5, 10, 20, 25, 7], [8, 9, 10, 11, 13, 15] ] assert max_weight_per_day(d, w, catches) == [35, 35] def test_single_day(): d = 1 w = 25 catches = [ [10, 14, 20, 8] ] assert max_weight_per_day(d, w, catches) == [24] def test_single_day_exact_fit(): d = 1 w = 7 catches = [ [3, 4, 1, 2] ] assert max_weight_per_day(d, w, catches) == [7] def test_all_days_no_fish(): d = 2 w = 10 catches = [ [], [] ] assert max_weight_per_day(d, w, catches) == [0, 0] def test_all_fish_over_limit(): d = 2 w = 5 catches = [ [6, 7, 8], [10] ] assert max_weight_per_day(d, w, catches) == [0, 0] def test_different_limits(): d = 2 w = 15 catches = [ [5, 7, 10], [3, 9, 12, 5] ] assert max_weight_per_day(d, w, catches) == [15, 15]","solution":"def max_weight_per_day(d, w, catches): def knapsack(items, capacity): dp = [0] * (capacity + 1) for item in items: for j in range(capacity, item - 1, -1): dp[j] = max(dp[j], dp[j - item] + item) return dp[capacity] results = [] for day in catches: max_weight = knapsack(day, w) results.append(max_weight) return results # Example usage: d = 3 w = 50 catches = [ [10, 20, 30, 40], [5, 10, 15], [1, 2, 3, 4, 5] ] print(max_weight_per_day(d, w, catches)) # Expected output: [50, 30, 15]"},{"question":"def max_energy_drinks(T, test_cases): Determine the maximum number of energy drinks Emily can consume without backtracking. Args: - T (int): The number of test cases. - test_cases (List[Tuple[int, List[int]]]): A list of tuples where each tuple contains the number of checkpoints (int) and a list of integers (0 or 1) indicating if an energy drink is available at each checkpoint. Returns: - List[int]: A list containing the maximum number of energy drinks Emily can consume for each test case. def parse_and_calculate(input_str): Parse the input string and calculate the maximum number of energy drinks for each test case. Args: - input_str (str): The input string containing the number of test cases and the checkpoint data for each test case. Returns: - List[int]: A list of integers representing the maximum number of energy drinks for each test case. import pytest from solution import parse_and_calculate, max_energy_drinks def test_sample_input(): input_str = \\"2n5n1 0 1 1 0n4n0 1 0 1n\\" expected_output = [2, 1] assert parse_and_calculate(input_str) == expected_output def test_all_energy_drinks(): input_str = \\"1n5n1 1 1 1 1n\\" expected_output = [5] assert parse_and_calculate(input_str) == expected_output def test_no_energy_drinks(): input_str = \\"1n5n0 0 0 0 0n\\" expected_output = [0] assert parse_and_calculate(input_str) == expected_output def test_alternating_energy_drinks(): input_str = \\"1n6n1 0 1 0 1 0n\\" expected_output = [1] assert parse_and_calculate(input_str) == expected_output def test_single_energy_drink(): input_str = \\"1n1n1n\\" expected_output = [1] assert parse_and_calculate(input_str) == expected_output def test_large_input(): input_str = \\"1n100000n\\" + \\" \\".join(['1' if i % 2 == 0 else '0' for i in range(100000)]) + \\"n\\" expected_output = [1] # Each 1 is separated by 0 assert parse_and_calculate(input_str) == expected_output","solution":"def max_energy_drinks(T, test_cases): results = [] for i in range(T): N = test_cases[i][0] checkpoints = test_cases[i][1] max_drinks = 0 current_drinks = 0 for j in range(N): if checkpoints[j] == 1: current_drinks += 1 max_drinks = max(max_drinks, current_drinks) else: current_drinks = 0 results.append(max_drinks) return results # Function to parse input and return results def parse_and_calculate(input_str): lines = input_str.strip().split('n') T = int(lines[0]) test_cases = [] for i in range(T): N = int(lines[2 * i + 1]) checkpoints = list(map(int, lines[2 * i + 2].split())) test_cases.append((N, checkpoints)) return max_energy_drinks(T, test_cases)"},{"question":"def get_stock_prices(N: int, price_changes: List[Dict[str, Union[int, float]]]) -> List[Dict[str, Union[int, float]]]: Calculates the stock prices at the end of each day. Args: N (int): Number of days. price_changes (list): List of dictionaries with 'day' and 'change'. Returns: list: List of dictionaries with 'day' and 'price' at the end of each day. >>> get_stock_prices(5, [{'day': 1, 'change': 1.5}, {'day': 2, 'change': -0.5}, {'day': 4, 'change': 2.0}]) [{'day': 1, 'price': 101.5}, {'day': 2, 'price': 101.0}, {'day': 3, 'price': 101.0}, {'day': 4, 'price': 103.0}, {'day': 5, 'price': 103.0}] >>> get_stock_prices(3, []) [{'day': 1, 'price': 100.0}, {'day': 2, 'price': 100.0}, {'day': 3, 'price': 100.0}] >>> get_stock_prices(3, [{'day': 1, 'change': 2.0}, {'day': 2, 'change': -1.0}, {'day': 3, 'change': 0.5}]) [{'day': 1, 'price': 102.0}, {'day': 2, 'price': 101.0}, {'day': 3, 'price': 101.5}] >>> get_stock_prices(4, [{'day': 2, 'change': 1.5}, {'day': 4, 'change': -0.5}]) [{'day': 1, 'price': 100.0}, {'day': 2, 'price': 101.5}, {'day': 3, 'price': 101.5}, {'day': 4, 'price': 101.0}]","solution":"def get_stock_prices(N, price_changes): Calculates the stock prices at the end of each day. Args: N (int): Number of days. price_changes (list): List of dictionaries with 'day' and 'change'. Returns: list: List of dictionaries with 'day' and 'price' at the end of each day. # Initial price initial_price = 100.0 # Dictionary to hold price changes by day price_dict = {change['day']: change['change'] for change in price_changes} result = [] current_price = initial_price for day in range(1, N + 1): if day in price_dict: current_price += price_dict[day] result.append({'day': day, 'price': round(current_price, 1)}) return result"},{"question":"def rearrange_list(n: int, lst: List[int], k: int) -> List[int]: Rearranges the list such that every k-th element is moved to the end. Args: n (int): Number of elements in the list. lst (list of int): The list of integers to be rearranged. k (int): The step size for moving elements. Returns: list of int: The rearranged list. Examples: >>> rearrange_list(9, [1, 2, 3, 4, 5, 6, 7, 8, 9], 3) [1, 2, 4, 5, 7, 8, 3, 6, 9] >>> rearrange_list(5, [10, 20, 30, 40, 50], 2) [10, 30, 50, 20, 40] >>> rearrange_list(6, [1, 2, 3, 4, 5, 6], 1) [1, 2, 3, 4, 5, 6]","solution":"def rearrange_list(n, lst, k): Rearranges the list such that every k-th element is moved to the end. Args: n (int): Number of elements in the list. lst (list of int): The list of integers to be rearranged. k (int): The step size for moving elements. Returns: list of int: The rearranged list. if k <= 0 or k > n: return lst result = [] end_elements = [] for i, val in enumerate(lst): if (i + 1) % k == 0: end_elements.append(val) else: result.append(val) return result + end_elements"},{"question":"def num_distinct_paths(grid: List[List[int]]) -> int: Calculate the number of distinct paths from the top-left corner of the grid to the bottom-right corner without passing through blocked cells. >>> num_distinct_paths([ ... [0, 0, 0], ... [0, 1, 0], ... [0, 0, 0] ... ]) == 2 >>> num_distinct_paths([ ... [0, 1], ... [1, 0] ... ]) == 0 >>> num_distinct_paths([ ... [0, 0, 0], ... [0, 0, 1], ... [0, 0, 0] ... ]) == 3 >>> num_distinct_paths([ ... [0, 0], ... [0, 0] ... ]) == 2 >>> num_distinct_paths([ ... [1, 0, 0], ... [0, 0, 0], ... [0, 0, 0] ... ]) == 0","solution":"def num_distinct_paths(grid): rows = len(grid) cols = len(grid[0]) if grid[0][0] == 1 or grid[rows-1][cols-1] == 1: return 0 dp = [[0 for _ in range(cols)] for _ in range(rows)] dp[0][0] = 1 for i in range(rows): for j in range(cols): if grid[i][j] == 1: dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[rows-1][cols-1]"},{"question":"def is_path_exists(n: int, grid: List[List[str]]) -> str: Determine if there is a path from the top-left corner to the bottom-right corner of the maze. Args: n (int): The size of the grid. grid (list of list of str): The maze grid. Returns: str: 'Yes' if there is a path, otherwise 'No'. Example: >>> is_path_exists(5, [['0', '1', '0', '0', '0'], ['0', '1', '0', '1', '0'], ['0', '0', '0', '1', '0'], ['1', '1', '1', '0', '0'], ['0', '0', '0', '0', '0']]) 'Yes' >>> is_path_exists(4, [['0', '1', '1', '0'], ['1', '0', '1', '0'], ['1', '1', '0', '1'], ['0', '0', '0', '0']]) 'No' >>> is_path_exists(1, [['0']]) 'Yes' >>> is_path_exists(3, [['0', '1', '0'], ['1', '1', '1'], ['0', '1', '0']]) 'No' >>> is_path_exists(2, [['0', '0'], ['0', '0']]) 'Yes'","solution":"def is_path_exists(n, grid): Determine if there is a path from the top-left corner to the bottom-right corner of the maze. Args: n (int): The size of the grid. grid (list of list of str): The maze grid. Returns: str: 'Yes' if there is a path, otherwise 'No'. if n == 1: return 'Yes' if grid[0][0] == '0' else 'No' def is_valid_move(x, y): return 0 <= x < n and 0 <= y < n and grid[x][y] == '0' def dfs(x, y): if (x, y) == (n-1, n-1): return True grid[x][y] = '1' # Mark as visited for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nx, ny = x + dx, y + dy if is_valid_move(nx, ny) and dfs(nx, ny): return True return False return 'Yes' if dfs(0, 0) else 'No'"},{"question":"from typing import List, Tuple def max_profit(t: int, test_cases: List[Tuple[int, int, List[int]]]) -> List[int]: Determine the maximum profit for selling exactly k items from n items where each element represents the cost of production. >>> max_profit(3, [(5, 3, [4, 3, 2, 5, 1]), (4, 2, [10, 10, 10, 10]), (6, 5, [1, 1, 1, 1, 1, 1])]) [6, 0, 0] >>> max_profit(1, [(4, 2, [1, 1000000000, 2, 999999999])]) [1999999996] >>> max_profit(1, [(1, 1, [1])]) [0] pass # Helper function to parse input and handle multiple test cases def handle_inputs(input_data: str) -> Tuple[int, List[Tuple[int, int, List[int]]]]: Helper function to parse input data for multiple test cases. pass","solution":"def max_profit(t, test_cases): results = [] for test in test_cases: n, k, costs = test costs.sort() max_possible_profit = sum(costs[-k:]) - sum(costs[:k]) results.append(max_possible_profit) return results # Helper function to parse input and handle multiple test cases def handle_inputs(input_data): input_lines = input_data.strip().split(\\"n\\") t = int(input_lines[0]) test_cases = [] line_idx = 1 for _ in range(t): n, k = map(int, input_lines[line_idx].split()) costs = list(map(int, input_lines[line_idx + 1].split())) test_cases.append((n, k, costs)) line_idx += 2 return t, test_cases # Example usage input_data = 3 5 3 4 3 2 5 1 4 2 10 10 10 10 6 5 1 1 1 1 1 1 t, test_cases = handle_inputs(input_data) print(max_profit(t, test_cases)) # Output: [6, 0, 0]"},{"question":"def check_reorder(T, test_cases): Determine which widget types require reordering based on inventory levels and reorder thresholds. >>> check_reorder(2, [([3, 100, 150, 50, 50, 30, 75], [\\"widgetA\\", \\"widgetB\\", \\"widgetC\\"]), ([2, 80, 80, 45, 60], [\\"widgetX\\", \\"widgetY\\"])]) ['widgetA widgetC', 'widgetY'] >>> check_reorder(1, [([2, 100, 100, 200, 180], [\\"widgetA\\", \\"widgetB\\"])]) ['None'] >>> check_reorder(1, [([3, 10, 20, 5, 10, 0, 15], [\\"widgetA\\", \\"widgetB\\", \\"widgetC\\"])]) ['widgetA widgetB widgetC'] >>> check_reorder(1, [([3, 30, 50, 20, 20, 25, 30], [\\"widgetA\\", \\"widgetB\\", \\"widgetC\\"])]) ['widgetA widgetC']","solution":"def check_reorder(T, test_cases): results = [] for t in range(T): data, names = test_cases[t] to_reorder = [] for i in range(data[0]): current_inventory = data[1 + i * 2] reorder_threshold = data[2 + i * 2] if current_inventory < reorder_threshold: to_reorder.append(names[i]) if to_reorder: results.append(\\" \\".join(to_reorder)) else: results.append(\\"None\\") return results"},{"question":"def min_additional_points(n, t, scores): This function calculates the minimum additional points each employee needs to reach the threshold score. :param n: Integer, the number of employees. :param t: Integer, the threshold score for the reward. :param scores: List of integers, the current scores of each employee. :return: List of integers, minimum additional points required for each employee. >>> min_additional_points(3, 100, [80, 120, 90]) [20, 0, 10] >>> min_additional_points(2, 50, [50, 40]) [0, 10] >>> min_additional_points(4, 70, [70, 70, 70, 70]) [0, 0, 0, 0] >>> min_additional_points(3, 60, [30, 40, 50]) [30, 20, 10] >>> min_additional_points(3, 55, [60, 70, 80]) [0, 0, 0] >>> min_additional_points(4, 50, [49, 50, 51, 0]) [1, 0, 0, 50]","solution":"def min_additional_points(n, t, scores): This function calculates the minimum additional points each employee needs to reach the threshold score. :param n: Integer, the number of employees. :param t: Integer, the threshold score for the reward. :param scores: List of integers, the current scores of each employee. :return: List of integers, minimum additional points required for each employee. results = [] for score in scores: if score >= t: results.append(0) else: results.append(t - score) return results"},{"question":"def largest_square_submatrix(matrix: List[List[int]]) -> int: Returns the side length of the largest square sub-matrix that contains only 1s. >>> largest_square_submatrix([[1, 1, 1, 0], [1, 1, 1, 1], [0, 1, 1, 1]]) 2 >>> largest_square_submatrix([[1, 0, 1, 0, 0, 1], [1, 0, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1], [1, 0, 0, 1, 1, 1], [1, 1, 1, 1, 0, 1]]) 3","solution":"def largest_square_submatrix(matrix): Returns the side length of the largest square sub-matrix that contains only 1s. if not matrix: return 0 n = len(matrix) m = len(matrix[0]) # Initialize a dp array with the same dimensions as the matrix dp = [[0] * m for _ in range(n)] max_side = 0 for i in range(n): for j in range(m): if matrix[i][j] == 1: if i == 0 or j == 0: dp[i][j] = 1 # For the first row and column, we can only have 1 if the cell itself is 1 else: # Determine the size of the square ending at (i, j) dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1 max_side = max(max_side, dp[i][j]) return max_side # Function to convert input to matrix format def create_matrix_from_input(input_string): lines = input_string.strip().split('n') n, m = map(int, lines[0].split()) matrix = [] for i in range(1, n+1): row = list(map(int, lines[i].split())) matrix.append(row) return matrix"},{"question":"def reverse_words_in_sentence(sentence: str) -> str: Given a sentence, reverse the order of characters in each word while preserving the order of words. >>> reverse_words_in_sentence(\\"Hello World\\") 'olleH dlroW' >>> reverse_words_in_sentence(\\"Coding is fun\\") 'gnidoC si nuf' >>> reverse_words_in_sentence(\\"Python\\") 'nohtyP' def process_sentences(T: int, sentences: List[str]) -> List[str]: Process multiple sentences as per the reverse_words_in_sentence function. Args: T (int): Number of sentences. sentences (list of str): List containing the sentences. Returns: list of str: List containing processed sentences. Examples: >>> process_sentences(3, [\\"Hello World\\", \\"Coding is fun\\", \\"Python\\"]) ['olleH dlroW', 'gnidoC si nuf', 'nohtyP'] >>> process_sentences(2, [\\"Reverse each word\\", \\"a b c\\"]) ['esreveR hcae drow', 'a b c']","solution":"def reverse_words_in_sentence(sentence): Given a sentence, reverse the order of characters in each word while preserving the order of words. Args: sentence (str): The input sentence. Returns: str: The sentence with the order of characters in each word reversed. words = sentence.split(' ') reversed_words = [word[::-1] for word in words] return ' '.join(reversed_words) def process_sentences(T, sentences): Process multiple sentences as per the reverse_words_in_sentence function. Args: T (int): Number of sentences. sentences (list of str): List containing the sentences. Returns: list of str: List containing processed sentences. results = [] for sentence in sentences: results.append(reverse_words_in_sentence(sentence)) return results"},{"question":"def evaluate_expression(expression: str) -> int: Evaluate a mathematical expression string containing non-negative integers, '+' and '*', following the order of operations. >>> evaluate_expression(\\"3+5*2\\") 13 >>> evaluate_expression(\\"4*5+6\\") 26 >>> evaluate_expression(\\"2+3*4+5\\") 19 from typing import List def test_simple_addition(): assert evaluate_expression(\\"2+3\\") == 5 def test_simple_multiplication(): assert evaluate_expression(\\"2*3\\") == 6 def test_combined_expression_1(): assert evaluate_expression(\\"3+5*2\\") == 13 def test_combined_expression_2(): assert evaluate_expression(\\"4*5+6\\") == 26 def test_complex_expression(): assert evaluate_expression(\\"2+3*4+5\\") == 19 def test_single_number(): assert evaluate_expression(\\"7\\") == 7 def test_chained_addition(): assert evaluate_expression(\\"1+2+3+4\\") == 10 def test_chained_multiplication(): assert evaluate_expression(\\"1*2*3*4\\") == 24 def test_leading_zeroes(): assert evaluate_expression(\\"03+005*002\\") == 13","solution":"def evaluate_expression(expression): # Splits the expression based on '+' operator add_parts = expression.split('+') # Evaluates any '*' operation within add_parts evaluated_parts = [] for part in add_parts: mult_parts = part.split('*') result = 1 for num in mult_parts: result *= int(num) evaluated_parts.append(result) # Sum all the evaluated parts to get the final result final_result = sum(evaluated_parts) return final_result"},{"question":"def longest_consecutive_sequence(n: int, ids: List[int]) -> int: Returns the length of the longest consecutive sequence in the comic book identifiers. :param n: the number of comic books :param ids: list of comic book identifiers :return: length of the longest consecutive sequence >>> longest_consecutive_sequence(5, [3, 5, 6, 7, 9]) 3 >>> longest_consecutive_sequence(4, [1, 2, 4, 5]) 2 >>> longest_consecutive_sequence(6, [10, 4, 20, 1, 3, 2]) 4 >>> longest_consecutive_sequence(1, [100]) 1 >>> longest_consecutive_sequence(5, [10, 20, 30, 40, 50]) 1 >>> longest_consecutive_sequence(5, [1, 2, 3, 4, 5]) 5 >>> longest_consecutive_sequence(6, [3, 1, 4, 7, 2, 6]) 4 pass","solution":"def longest_consecutive_sequence(n, ids): Returns the length of the longest consecutive sequence in the comic book identifiers. :param n: the number of comic books :param ids: list of comic book identifiers :return: length of the longest consecutive sequence ids_set = set(ids) longest_sequence = 0 for id in ids: if id - 1 not in ids_set: # This means the start of a new sequence current_id = id current_sequence = 1 while current_id + 1 in ids_set: current_id += 1 current_sequence += 1 longest_sequence = max(longest_sequence, current_sequence) return longest_sequence"},{"question":"def min_removals_to_even_sum(n: int, arr: List[int]) -> int: Returns the minimum number of elements to remove to make the sum of the array even. >>> min_removals_to_even_sum(5, [1, 3, 5, 7, 9]) 1 >>> min_removals_to_even_sum(4, [2, 4, 6, 8]) 0","solution":"def min_removals_to_even_sum(n, arr): Returns the minimum number of elements to remove to make the sum of the array even. total_sum = sum(arr) if total_sum % 2 == 0: return 0 # The sum is already even else: # If total_sum is odd, we need to remove one odd element to make it even # Check if there's any odd element in the array for num in arr: if num % 2 == 1: return 1 # Removing this odd element will make the sum even return -1 # This case should never be reached with correct input constraints"},{"question":"def tree_depth_sum(n: int, edges: List[Tuple[int, int]], m: int, marked_nodes: List[int]) -> int: Calculates the sum of depths of the marked nodes in a tree. >>> tree_depth_sum(5, [(1, 2), (1, 3), (3, 4), (3, 5)], 2, [4, 5]) 4 >>> tree_depth_sum(1, [], 1, [1]) 0 >>> tree_depth_sum(3, [(1, 2), (1, 3)], 2, [2, 3]) 2 >>> tree_depth_sum(7, [(1, 2), (1, 3), (2, 4), (2, 5), (3, 6), (3, 7)], 3, [4, 5, 6]) 6 >>> tree_depth_sum(7, [(1, 2), (1, 3), (2, 4), (2, 5), (3, 6), (3, 7)], 7, [1, 2, 3, 4, 5, 6, 7]) 10 # Write your code here","solution":"def tree_depth_sum(n, edges, m, marked_nodes): from collections import deque, defaultdict # Create adjacency list for the tree graph = defaultdict(list) for a, b in edges: graph[a].append(b) graph[b].append(a) # BFS to calculate the depth of each node from the root (node 1) depths = {1: 0} queue = deque([1]) while queue: node = queue.popleft() current_depth = depths[node] for neighbor in graph[node]: if neighbor not in depths: depths[neighbor] = current_depth + 1 queue.append(neighbor) # Calculate the sum of depths of marked nodes depth_sum = 0 for node in marked_nodes: if node in depths: depth_sum += depths[node] return depth_sum"},{"question":"def reverse_words(s: str) -> str: Reverses the order of words in a given string s. A word is defined as a sequence of non-space characters. The words in s will be separated by at least one space. Args: s (str): The input string containing words separated by spaces. Returns: str: A string with the words in reverse order, separated by a single space, without leading or trailing spaces. Examples: >>> reverse_words(\\"the sky is blue\\") \\"blue is sky the\\" >>> reverse_words(\\" hello world \\") \\"world hello\\" >>> reverse_words(\\"a good example\\") \\"example good a\\" >>> reverse_words(\\"word\\") \\"word\\" >>> reverse_words(\\"\\") \\"\\" >>> reverse_words(\\" \\") \\"\\" >>> reverse_words(\\"a b c\\") \\"c b a\\" >>> reverse_words(\\"!@# %^&* ()_+\\") \\"()_+ %^&* !@#\\" pass","solution":"def reverse_words(s: str) -> str: Reverses the order of words in a given string s. # Split the string into words based on spaces, which also trims multiple spaces words = s.split() # Reverse the list of words reversed_words = words[::-1] # Join the reversed list of words into a single string with a single space separator return ' '.join(reversed_words)"},{"question":"def count_valleys(matrix: List[List[int]]) -> int: Counts the number of valleys in a given matrix of integers. A cell is a valley if it is strictly less than all its 4 direct neighbors (up, down, left, and right), and it is not on the border of the matrix. Parameters: - matrix: List of List of integers where each cell represents the height of that cell. Returns: - int: The number of valley cells. Example: >>> matrix = [ >>> [9, 8, 5, 8, 9], >>> [7, 6, 2, 6, 7], >>> [4, 3, 1, 3, 4], >>> [8, 7, 5, 7, 8] >>> ] >>> count_valleys(matrix) 1 # Implement logic here # Unit Tests from solution import count_valleys def test_example_case(): matrix = [ [9, 8, 5, 8, 9], [7, 6, 2, 6, 7], [4, 3, 1, 3, 4], [8, 7, 5, 7, 8] ] assert count_valleys(matrix) == 1 def test_no_valleys(): matrix = [ [9, 8, 7], [6, 5, 4], [3, 2, 1] ] assert count_valleys(matrix) == 0 def test_all_same_height(): matrix = [ [5, 5, 5], [5, 5, 5], [5, 5, 5] ] assert count_valleys(matrix) == 0 def test_multiple_valleys(): matrix = [ [9, 8, 9], [8, 1, 8], [9, 8, 9], [8, 1, 8], [9, 8, 9] ] assert count_valleys(matrix) == 2 def test_large_matrix(): matrix = [ [10]*5 + [11], [10, 1, 2, 3, 4, 11], [10, 2, 1, 4, 5, 11], [10, 3, 4, 1, 6, 11], [10, 4, 5, 6, 1, 11], [10]*5 + [11] ] assert count_valleys(matrix) == 4","solution":"def count_valleys(matrix): Counts the number of valleys in a given matrix. Parameters: - matrix: List of List of integers where each cell represents the height of that cell. Returns: - int: The number of valley cells. n = len(matrix) m = len(matrix[0]) valleys = 0 for i in range(1, n-1): for j in range(1, m-1): if (matrix[i][j] < matrix[i-1][j] and matrix[i][j] < matrix[i+1][j] and matrix[i][j] < matrix[i][j-1] and matrix[i][j] < matrix[i][j+1]): valleys += 1 return valleys # Example matrix from the problem statement matrix = [ [9, 8, 5, 8, 9], [7, 6, 2, 6, 7], [4, 3, 1, 3, 4], [8, 7, 5, 7, 8] ] print(count_valleys(matrix)) # Output: 1"},{"question":"from typing import List def rearrange_strings(strings: List[str]) -> List[str]: Rearranges each string in the list such that no two adjacent characters are the same. If it is not possible to rearrange a string to meet the condition, returns an empty string for that string. >>> rearrange_strings([\\"aabb\\", \\"aaab\\"]) [\\"abab\\", \\"\\"] >>> rearrange_strings([\\"xyz\\", \\"aaa\\", \\"ab\\"]) [\\"xyz\\", \\"\\", \\"ab\\"]","solution":"from heapq import heappop, heappush from collections import Counter def rearrange_string(s): Rearranges the input string such that no two adjacent characters are the same. If not possible, returns an empty string. counter = Counter(s) max_heap = [] for char, freq in counter.items(): heappush(max_heap, (-freq, char)) prev_char, prev_freq = None, 0 result = [] while max_heap: freq, char = heappop(max_heap) result.append(char) if prev_char is not None: heappush(max_heap, (prev_freq, prev_char)) prev_char = char prev_freq = freq + 1 if prev_freq == 0: prev_char = None result_str = ''.join(result) if len(result_str) == len(s): return result_str else: return \\"\\" def rearrange_strings(strings): return [rearrange_string(s) for s in strings]"},{"question":"from typing import List def min_operations(initial_sequence: List[int], final_sequence: List[int]) -> int: Calculate the minimum number of operations to transform initial_sequence into final_sequence. >>> min_operations([1, 2, 3], [2, 4, 6]) 3 >>> min_operations([4, 5, 6, 7], [4, 5, 6, 8]) 1 >>> min_operations([1, 1, 1], [1, 1, 1]) 0 >>> min_operations([1, 2, 3], [2, 3, 4]) 3 >>> min_operations([2, 3, 4], [1, 2, 3]) 3 >>> min_operations([1, 4], [8, 2]) 4 pass","solution":"from collections import deque def min_operations(initial_sequence, final_sequence): Calculate the minimum number of operations to transform initial_sequence into final_sequence. def find_min_operations(x, y): Use a BFS strategy to find the minimum operations needed to transform x into y. if x == y: return 0 queue = deque([(x, 0)]) visited = set([x]) while queue: current, steps = queue.popleft() # Generate the possible operations for operation_result in (current + 1, current - 1, current * 2): if operation_result == y: return steps + 1 if operation_result not in visited and 0 <= operation_result <= 2 * max(x, y): visited.add(operation_result) queue.append((operation_result, steps + 1)) if current % 2 == 0: operation_result = current // 2 if operation_result == y: return steps + 1 if operation_result not in visited: visited.add(operation_result) queue.append((operation_result, steps + 1)) # It cannot reach here in theory due to the constraints return -1 n = len(initial_sequence) total_operations = 0 for i in range(n): total_operations += find_min_operations(initial_sequence[i], final_sequence[i]) return total_operations"},{"question":"def find_fastest_team(n: int, k: int, m: int, D: int, teams: List[List[Tuple[int, int]]], segments: List[int]) -> Union[int, str]: Determine the team with the shortest total time to finish the race. Args: n: The number of teams. k: The number of participants in each team. m: The number of segments. D: The distance of each segment in meters. teams: A list of teams, where each team is a list of tuples (speed, stamina) of each participant. segments: A list of minimum stamina required for each segment. Returns: The index of the team (starting from 1) that finishes the race in the shortest time, or \\"No team can finish the race\\". Examples: >>> n = 2 >>> k = 2 >>> m = 2 >>> D = 100 >>> teams = [ >>> [(50, 60), (70, 80)], >>> [(60, 100), (70, 50)] >>> ] >>> segments = [40, 30] >>> find_fastest_team(n, k, m, D, teams, segments) 1 >>> n = 2 >>> k = 2 >>> m = 3 >>> D = 200 >>> teams = [ >>> [(80, 40), (90, 100)], >>> [(100, 90), (110, 110)] >>> ] >>> segments = [40, 50, 60] >>> find_fastest_team(n, k, m, D, teams, segments) 2 >>> n = 1 >>> k = 3 >>> m = 1 >>> D = 150 >>> teams = [ >>> [(200, 50), (180, 60), (190, 55)] >>> ] >>> segments = [100] >>> find_fastest_team(n, k, m, D, teams, segments) \\"No team can finish the race\\"","solution":"def find_fastest_team(n, k, m, D, teams, segments): import sys min_total_time = sys.maxsize winning_team = \\"No team can finish the race\\" for team_index, team in enumerate(teams): team_time = 0 can_finish = True for segment in segments: best_segment_time = float('inf') participant_found = False for participant in team: speed, stamina = participant if stamina >= segment: segment_time = D / speed best_segment_time = min(best_segment_time, segment_time) participant_found = True if not participant_found: can_finish = False break team_time += best_segment_time if can_finish and team_time < min_total_time: min_total_time = team_time winning_team = team_index + 1 return winning_team"},{"question":"def max_absolute_difference(n: int, arr: List[int]) -> int: Returns the maximum possible absolute difference between any two integers in the set. >>> max_absolute_difference(4, [1, 3, -7, 8]) == 15 >>> max_absolute_difference(5, [1, 2, 3, 4, 5]) == 4 >>> max_absolute_difference(5, [-1, -2, -3, -4, -5]) == 4 >>> max_absolute_difference(6, [-10, 0, 10, -20, 20, -30]) == 50 >>> max_absolute_difference(1, [0]) == 0 >>> max_absolute_difference(2, [-5, 5]) == 10 >>> max_absolute_difference(6, [-1000000, 1000000, -500000, 500000, 0, 999999]) == 2000000","solution":"def max_absolute_difference(n, arr): Returns the maximum absolute difference between any two integers in the set. # The maximum absolute difference will be between the minimum and maximum values of the array max_val = max(arr) min_val = min(arr) return abs(max_val - min_val) # Example usage: # n = 4 # arr = [1, 3, -7, 8] # print(max_absolute_difference(n, arr)) # Output: 15"},{"question":"from typing import List def mark_enclosed_areas(grid: List[List[str]]) -> List[List[str]]: Given a grid (2D list) of 'X' and 'O', find all the cells 'O' which are part of enclosed areas and change them to 'X'. >>> mark_enclosed_areas([ ['X', 'X', 'X', 'X'], ['X', 'O', 'O', 'X'], ['X', 'X', 'O', 'X'], ['X', 'O', 'X', 'X'] ]) [['X', 'X', 'X', 'X'], ['X', 'X', 'X', 'X'], ['X', 'X', 'X', 'X'], ['X', 'O', 'X', 'X']] >>> mark_enclosed_areas([ ['O', 'O', 'O', 'O'], ['O', 'O', 'O', 'O'], ['O', 'O', 'O', 'O'], ['O', 'O', 'O', 'O'] ]) [['O', 'O', 'O', 'O'], ['O', 'O', 'O', 'O'], ['O', 'O', 'O', 'O'], ['O', 'O', 'O', 'O']]","solution":"from typing import List def mark_enclosed_areas(grid: List[List[str]]) -> List[List[str]]: if not grid or not grid[0]: return grid rows, cols = len(grid), len(grid[0]) # Helper function to perform DFS from a given cell def dfs(x, y): if grid[x][y] != 'O': return grid[x][y] = 'E' # Mark the cell as 'E' to indicate it’s part of the edge directions = [(0, 1), (0, -1), (1, 0), (-1, 0)] # Right, Left, Down, Up for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < rows and 0 <= ny < cols: dfs(nx, ny) # Start DFS from the edges of the grid for i in range(rows): if grid[i][0] == 'O': dfs(i, 0) if grid[i][cols - 1] == 'O': dfs(i, cols - 1) for j in range(cols): if grid[0][j] == 'O': dfs(0, j) if grid[rows - 1][j] == 'O': dfs(rows - 1, j) # Convert remaining 'O' to 'X' and 'E' back to 'O' for i in range(rows): for j in range(cols): if grid[i][j] == 'O': grid[i][j] = 'X' elif grid[i][j] == 'E': grid[i][j] = 'O' return grid"},{"question":"def reconstruct_list(n, m, q, query_function): Reconstructs the hidden list based on the allowed queries. Args: n (int): Length of the list. m (int): Range of each integer. q (int): Number of allowed queries. query_function (function): Function to make queries in the form of query_function(i, j). Returns: list: The reconstructed list. def test_reconstruct_list(): # Mock function to simulate the query process def query_function(i, j): hidden_list = [3, 4, 8, 2, 10] return sum(hidden_list[i-1:j]) n = 5 m = 10 q = 20 result = reconstruct_list(n, m, q, query_function) assert result == [3, 4, 8, 2, 10] def test_reconstruct_list_single_element(): def query_function(i, j): hidden_list = [7] return hidden_list[i-1] n = 1 m = 10 q = 1 result = reconstruct_list(n, m, q, query_function) assert result == [7] def test_reconstruct_list_two_elements(): def query_function(i, j): hidden_list = [2, 5] return sum(hidden_list[i-1:j]) n = 2 m = 10 q = 2 result = reconstruct_list(n, m, q, query_function) assert result == [2, 5]","solution":"def reconstruct_list(n, m, q, query_function): Reconstructs the hidden list based on the allowed queries. Args: n (int): Length of the list. m (int): Range of each integer. q (int): Number of allowed queries. query_function (function): Function to make queries in the form of query_function(i, j). Returns: list: The reconstructed list. # Create a list to store the reconstructed numbers result = [0] * n # We will query the sum of elements from the start to each index # to get the prefix sums which will help us to deduce the individual elements prefix_sums = [0] * (n + 1) for i in range(1, n + 1): if i == 1: # For the first element just query from 1 to 1 prefix_sums[i] = query_function(1, 1) result[i-1] = prefix_sums[i] else: # For other elements, query from 1 to i prefix_sums[i] = query_function(1, i) # Deduce the current element using the prefix sum result[i-1] = prefix_sums[i] - prefix_sums[i-1] return result"},{"question":"def max_subarray_indices(n: int, a: List[int]) -> Tuple[int, int]: Returns the start and end indices of the contiguous subarray with the maximum cumulative delivery time. Parameters: n (int): the number of messages a (List[int]): the delivery times recorded in milliseconds Returns: Tuple[int, int]: the start and end indices of the longest subarray with the maximum cumulative delivery time >>> max_subarray_indices(9, [-2, 1, -3, 4, -1, 2, 1, -5, 4]) (3, 6) >>> max_subarray_indices(5, [1, 2, 3, 4, 5]) (0, 4) >>> max_subarray_indices(4, [-1, -2, -3, -4]) (0, 0) >>> max_subarray_indices(1, [0]) (0, 0) >>> max_subarray_indices(1, [100]) (0, 0) >>> max_subarray_indices(1, [-100]) (0, 0) >>> max_subarray_indices(8, [1, 2, 3, -1, 2, -10, 1, 2]) (0, 4) >>> max_subarray_indices(7, [1, -2, 3, 1, -3, 2, 0]) (2, 3)","solution":"def max_subarray_indices(n, a): Returns the start and end indices of the contiguous subarray with the maximum cumulative delivery time. if n == 0: return 0, 0 # Initialize the variables max_sum = current_sum = a[0] start = end = temp_start = 0 for i in range(1, n): if current_sum > 0: current_sum += a[i] else: current_sum = a[i] temp_start = i if current_sum > max_sum: max_sum = current_sum start = temp_start end = i return start, end"},{"question":"def is_grid_balanced(n: int, m: int, grid: List[List[int]]) -> str: Determine if a given grid is balanced. A grid is considered balanced if each row and each column contains an equal number of tiles in each possible state. Args: n (int): Number of rows in the grid. m (int): Number of columns in the grid. grid (List[List[int]]): A 2D list representing the grid of tiles. Returns: str: \\"YES\\" if the grid is balanced, otherwise \\"NO\\". Examples: >>> is_grid_balanced(3, 3, [[1, 2, 3], [2, 3, 1], [3, 1, 2]]) \\"YES\\" >>> is_grid_balanced(3, 3, [[1, 1, 1], [2, 2, 2], [3, 3, 3]]) \\"NO\\"","solution":"def is_grid_balanced(n, m, grid): Returns 'YES' if the grid is balanced and 'NO' otherwise. A grid is considered balanced if each row and each column contains equal number of each state. from collections import Counter # Check rows for row in grid: if Counter(row) != Counter(grid[0]): return \\"NO\\" # Check columns for col in range(m): column_counts = Counter(grid[row][col] for row in range(n)) if column_counts != Counter(grid[row][0] for row in range(n)): return \\"NO\\" return \\"YES\\""},{"question":"def find_inverted_divisors(m: int) -> List[int]: Determine the minimum number of questions needed to find the number Alice picked in the game \\"Inverted Divisors\\", and the specific numbers zi for each question. >>> find_inverted_divisors(10) [2, 5, 10] >>> find_inverted_divisors(12) [3, 4, 6, 12]","solution":"def find_inverted_divisors(m): # Find all divisors of m divisors = [i for i in range(1, m + 1) if m % i == 0] # The minimum number of questions is the count of divisors questions = len(divisors) # The questions should be the divisors themselves in ascending order return [questions] + divisors"},{"question":"def determine_winner(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[str]: Given the number of toys in each box for multiple test cases, determine if Alice or Bob wins. Parameters: t (int): Number of test cases. test_cases (list): A list of tuples, where each tuple contains: - an integer n (number of boxes) - a list of integers representing the number of toys in each box. Returns: list: A list of strings \\"Alice\\" or \\"Bob\\" indicating the winner for each test case. >>> determine_winner(3, [(3, [1, 2, 3]), (2, [4, 4]), (1, [7])]) [\\"Alice\\", \\"Bob\\", \\"Alice\\"]","solution":"def determine_winner(t, test_cases): Given the number of toys in each box for multiple test cases, determine if Alice or Bob wins. Parameters: t (int): Number of test cases. test_cases (list): A list of tuples, where each tuple contains: - an integer n (number of boxes) - a list of integers representing the number of toys in each box. Returns: list: A list of strings \\"Alice\\" or \\"Bob\\" indicating the winner for each test case. results = [] for n, toys in test_cases: # Alice wins if there is at least one box with odd number of toys if any(toy % 2 == 1 for toy in toys): results.append(\\"Alice\\") else: results.append(\\"Bob\\") return results"},{"question":"def is_possible_to_sort(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[str]: Determine whether it is possible to sort the array in non-decreasing order by choosing any two adjacent elements and swapping them if the left element is divisible by the right element. Args: t (int): The number of test cases. test_cases (List[Tuple[int, List[int]]]): A list of tuples, each containing an integer n and a list of n integers. Returns: List[str]: A list containing \\"YES\\" or \\"NO\\" for each test case. Example: >>> is_possible_to_sort(2, [(4, [4, 3, 6, 8]), (5, [5, 10, 15, 20, 25])]) ['NO', 'YES']","solution":"def is_possible_to_sort(t, test_cases): results = [] for i in range(t): n, arr = test_cases[i] sorted_arr = sorted(arr) # Check if we can transform arr to sorted_arr possible = True for j in range(n-1): if arr[j] % arr[j+1] != 0 and arr[j+1] % arr[j] != 0: if arr[j] > arr[j+1]: # If arr[j] > arr[j+1] and we cannot swap possible = False break results.append(\\"YES\\" if possible else \\"NO\\") return results"},{"question":"def is_valid_palindrome(s: str) -> bool: Determine if a given string is a valid palindrome after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters. :param s: String to be checked for being a valid palindrome :return: True if the string is a valid palindrome, False otherwise >>> is_valid_palindrome(\\"A man, a plan, a canal: Panama\\") True >>> is_valid_palindrome(\\"race a car\\") False >>> is_valid_palindrome(\\" \\") True >>> is_valid_palindrome(\\"a\\") True >>> is_valid_palindrome(\\"Abba\\") True >>> is_valid_palindrome(\\"12321\\") True >>> is_valid_palindrome(\\"@#a@\\") True >>> is_valid_palindrome(\\"A\\" * 500 + \\"B\\" * 500) False >>> is_valid_palindrome(\\"A\\" * 500 + \\"B\\" + \\"A\\" * 500) True","solution":"def is_valid_palindrome(s: str) -> bool: Determine if a given string is a valid palindrome after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters. :param s: String to be checked for being a valid palindrome :return: True if the string is a valid palindrome, False otherwise # Normalize the string by converting to lower case and filtering out non-alphanumeric characters normalized = ''.join(char.lower() for char in s if char.isalnum()) # Check if the normalized string is a palindrome return normalized == normalized[::-1]"},{"question":"def evaluate_expression(expression: str) -> float: Evaluates a mathematical expression and returns the result as a floating-point number rounded to 6 decimal places. >>> evaluate_expression(\\"2 + 3\\") 5.000000 >>> evaluate_expression(\\"5 - 2\\") 3.000000 >>> evaluate_expression(\\"4 * 2\\") 8.000000 >>> evaluate_expression(\\"8 / 4\\") 2.000000 >>> evaluate_expression(\\"(1 + 2) * 3\\") 9.000000 >>> evaluate_expression(\\"10 + 24 / (4 * 3)\\") 12.000000 >>> evaluate_expression(\\" 10 + 2 * 5 \\") 20.000000","solution":"def evaluate_expression(expression: str) -> float: Evaluates a mathematical expression and returns the result as a floating-point number rounded to 6 decimal places. def compute(operators, values): right = values.pop() left = values.pop() operator = operators.pop() if operator == '+': values.append(left + right) elif operator == '-': values.append(left - right) elif operator == '*': values.append(left * right) elif operator == '/': values.append(left / right) def precedence(op): if op in ('+', '-'): return 1 if op in ('*', '/'): return 2 return 0 def apply_op_if_needed(op, operators, values): while operators and precedence(operators[-1]) >= precedence(op): compute(operators, values) operators.append(op) # Parsing through the expression operators = [] values = [] i = 0 while i < len(expression): if expression[i] == ' ': i += 1 continue if expression[i] == '(': operators.append(expression[i]) elif expression[i] == ')': while operators and operators[-1] != '(': compute(operators, values) operators.pop() # popping the '(' elif expression[i].isdigit(): val = 0 while (i < len(expression) and expression[i].isdigit()): val = (val * 10) + int(expression[i]) i += 1 values.append(val) i -= 1 else: while (operators and operators[-1] != '(' and precedence(operators[-1]) >= precedence(expression[i])): compute(operators, values) operators.append(expression[i]) i += 1 while operators: compute(operators, values) return round(values[-1], 6)"},{"question":"from typing import List, Dict def calculate_total(orders: List[str], menu: Dict[str, float]) -> float: Calculate the total cost of the orders based on the menu. Args: orders (List[str]): A list of strings representing ordered items. menu (Dict[str, float]): A dictionary where keys are item names and values are the prices. Returns: float: The total cost of the orders rounded to two decimal places. pass # Example test cases def test_calculate_total_all_items_present(): orders = [\\"coffee\\", \\"tea\\", \\"sandwich\\", \\"cookie\\"] menu = { \\"coffee\\": 2.50, \\"tea\\": 1.75, \\"sandwich\\": 5.00, \\"cookie\\": 1.25 } assert calculate_total(orders, menu) == 10.50 def test_calculate_total_some_items_missing(): orders = [\\"coffee\\", \\"tea\\", \\"sandwich\\", \\"muffin\\"] menu = { \\"coffee\\": 2.50, \\"tea\\": 1.75, \\"sandwich\\": 5.00, \\"cookie\\": 1.25 } assert calculate_total(orders, menu) == 9.25 # \\"muffin\\" is not in the menu def test_calculate_total_no_items_present(): orders = [\\"muffin\\", \\"donut\\"] menu = { \\"coffee\\": 2.50, \\"tea\\": 1.75, \\"sandwich\\": 5.00, \\"cookie\\": 1.25 } assert calculate_total(orders, menu) == 0.00 # No item is present in the menu def test_calculate_total_empty_orders(): orders = [] menu = { \\"coffee\\": 2.50, \\"tea\\": 1.75, \\"sandwich\\": 5.00, \\"cookie\\": 1.25 } assert calculate_total(orders, menu) == 0.00 # No orders def test_calculate_total_empty_menu(): orders = [\\"coffee\\", \\"tea\\", \\"sandwich\\", \\"cookie\\"] menu = {} assert calculate_total(orders, menu) == 0.00 # Empty menu","solution":"from typing import List, Dict def calculate_total(orders: List[str], menu: Dict[str, float]) -> float: Calculate the total cost of the orders based on the menu. Args: orders (List[str]): A list of strings representing ordered items. menu (Dict[str, float]): A dictionary where keys are item names and values are the prices. Returns: float: The total cost of the orders rounded to two decimal places. total = sum(menu[item] for item in orders if item in menu) return round(total, 2)"},{"question":"from typing import List, Tuple def compare_versions(version1: str, version2: str) -> int: Compares two software version strings. :param version1: First version string. :param version2: Second version string. :return: 1 if version1 > version2, -1 if version1 < version2, 0 if version1 == version2. def process_test_cases(test_cases: List[Tuple[str, str]]) -> List[int]: Processes a list of test cases comparing version strings. :param test_cases: A list of tuple pairs (version1, version2). :return: A list of results for each test case. # Here are the test cases def test_compare_versions_basic(): assert compare_versions(\\"1.0.0\\", \\"1.0.1\\") == -1 assert compare_versions(\\"1.0\\", \\"1.0.0\\") == 0 assert compare_versions(\\"2.3.4\\", \\"2.3.4\\") == 0 def test_compare_versions_edge_cases(): assert compare_versions(\\"1\\", \\"1.0.0.0\\") == 0 assert compare_versions(\\"1.0.0.0.1\\", \\"1.0.0.0\\") == 1 assert compare_versions(\\"1.0.0.1\\", \\"1.0.1\\") == -1 def test_compare_versions_different_lengths(): assert compare_versions(\\"1.0.0\\", \\"1\\") == 0 assert compare_versions(\\"2.1\\", \\"2.1.0.0.0\\") == 0 assert compare_versions(\\"2.1.0.0.2\\", \\"2.1\\") == 1 def test_process_test_cases(): test_cases = [ (\\"1.0.0\\", \\"1.0.1\\"), (\\"1.0\\", \\"1.0.0\\"), (\\"2.3.4\\", \\"2.3.4\\"), (\\"1\\", \\"1.0.0.0\\"), (\\"1.0.0.0.1\\", \\"1.0.0.0\\"), (\\"1.0.0.1\\", \\"1.0.1\\") ] expected_results = [-1, 0, 0, 0, 1, -1] assert process_test_cases(test_cases) == expected_results","solution":"def compare_versions(version1, version2): Compares two software version strings. :param version1: First version string. :param version2: Second version string. :return: 1 if version1 > version2, -1 if version1 < version2, 0 if version1 == version2. v1_parts = [int(part) for part in version1.split('.')] v2_parts = [int(part) for part in version2.split('.')] # Normalize the length of both version parts lists max_length = max(len(v1_parts), len(v2_parts)) v1_parts.extend([0] * (max_length - len(v1_parts))) v2_parts.extend([0] * (max_length - len(v2_parts))) for p1, p2 in zip(v1_parts, v2_parts): if p1 > p2: return 1 elif p1 < p2: return -1 return 0 def process_test_cases(test_cases): Processes a list of test cases comparing version strings. :param test_cases: A list of tuple pairs (version1, version2). :return: A list of results for each test case. results = [] for version1, version2 in test_cases: result = compare_versions(version1, version2) results.append(result) return results"},{"question":"def execute_operations(n: int, array: List[int], m: int, operations: List[List[str]]) -> List[str]: Given an array of integers and a sequence of rotate operations, determine the state of the array after applying all the operations in order. Args: n: Number of elements in the array. array: Initial state of the array. m: Number of operations. operations: List of operations where each operation is either \\"L k\\", \\"R k\\", or \\"Q\\". Returns: List of strings representing the array after each \\"Q\\" operation. Example: >>> execute_operations(5, [1, 2, 3, 4, 5], 6, [['L', '2'], ['Q'], ['R', '1'], ['Q'], ['L', '3'], ['Q']]) ['3 4 5 1 2', '2 3 4 5 1', '5 1 2 3 4']","solution":"def execute_operations(n, array, m, operations): result = [] for operation in operations: if operation[0] == 'L': k = int(operation[1]) k = k % n array = array[k:] + array[:k] elif operation[0] == 'R': k = int(operation[1]) k = k % n array = array[-k:] + array[:-k] elif operation[0] == 'Q': result.append(\\" \\".join(map(str, array))) return result"},{"question":"from typing import List def text_editor(commands: List[str]) -> List[str]: Implement a feature to track the most frequent word in the text document. The function handles two types of commands: \\"add\\" to add a new string to the document, and \\"freq\\" to display the word that appears most frequently in the entire document. Words in the document are case-insensitive and if there are multiple words with the same highest frequency, the program should return the lexicographically smallest word. Args: commands (List[str]): list of commands to be executed. Returns: List[str]: list of results for each \\"freq\\" command. Example: >>> text_editor([\\"add Hello World\\", \\"add hello Alice\\", \\"freq\\", \\"add world alice\\", \\"freq\\", \\"add Alice world\\", \\"freq\\"]) ['hello', 'alice', 'alice'] >>> text_editor([\\"add the quick brown fox\\", \\"add jumps over the lazy dog\\", \\"freq\\", \\"add THE quick BROWN fox\\", \\"freq\\"]) ['the', 'the']","solution":"from collections import defaultdict def text_editor(commands): word_freq = defaultdict(int) def normalize_word(word): return word.lower() def add_sentence(sentence): words = sentence.split() for word in words: normalized_word = normalize_word(word) word_freq[normalized_word] += 1 def most_frequent_word(): if not word_freq: return \\"\\" max_freq = max(word_freq.values()) candidates = [word for word, freq in word_freq.items() if freq == max_freq] return min(candidates) result = [] for command in commands: if command.startswith(\\"add\\"): _, sentence = command.split(\\" \\", 1) add_sentence(sentence) elif command == \\"freq\\": result.append(most_frequent_word()) return result"},{"question":"def find_duplicate_employees(test_cases): Given the test cases, identifies employee names with more than one entry in the database. :param test_cases: List[List[Tuple[str, int]]] - List of test cases, each containing list of (employee_name, employee_id) tuples. :return: List[List[str]] - List containing the result for each test case. Each result is a list of employee names with more than one entry. Example: >>> find_duplicate_employees([ [(\\"Alice\\", 12345), (\\"Bob\\", 67890), (\\"Alice\\", 54321), (\\"Charlie\\", 12121), (\\"Bob\\", 87654)], [(\\"Eve\\", 11111), (\\"Mallory\\", 22222), (\\"Mallory\\", 33333)] ]) [['Alice', 'Bob'], ['Mallory']] >>> find_duplicate_employees([ [(\\"Alice\\", 12345), (\\"Bob\\", 67890), (\\"Charlie\\", 12121)], [(\\"Alice\\", 67890), (\\"Bob\\", 99999), (\\"Alice\\", 12345), (\\"Charlie\\", 22222)] ]) [['No duplicates'], ['Alice']]","solution":"def find_duplicate_employees(test_cases): Given the test cases, identifies employee names with more than one entry in the database. :param test_cases: List[List[Tuple[str, int]]] - List of test cases, each containing list of (employee_name, employee_id) tuples. :return: List[List[str]] - List containing the result for each test case. Each result is a list of employee names with more than one entry. results = [] for case in test_cases: employee_count = {} for name, _ in case: if name in employee_count: employee_count[name] += 1 else: employee_count[name] = 1 duplicates = [name for name, count in employee_count.items() if count > 1] if duplicates: results.append(sorted(duplicates)) else: results.append([\\"No duplicates\\"]) return results"},{"question":"def main(input_data: str) -> str: Determine the number of distinct paths from the top-left corner to the bottom-right corner of a grid. :param input_data: A string representing multiple test cases. :return: A string representing the number of distinct paths for each test case with appropriate headers. >>> input_data1 = \\"2n3n...n.#.n...n4n....n.#..n....n..#.\\" >>> main(input_data1) == \\"TestCase 1:n2nTestCase 2:n4\\" >>> input_data2 = \\"1n3n...n...n...\\" >>> main(input_data2) == \\"TestCase 1:n6\\" >>> input_data3 = \\"1n2n.#n#.\\" >>> main(input_data3) == \\"TestCase 1:n0\\" >>> input_data = \\"1n3n#..n...n..#\\" >>> main(input_data) == \\"TestCase 1:n0\\" >>> input_data = \\"1n1n.\\" >>> main(input_data) == \\"TestCase 1:n1\\" >>> input_data = \\"1n10n\\" + \\"n\\".join([\\".\\" * 10 for _ in range(10)]) >>> main(input_data) == \\"TestCase 1:n48620\\"","solution":"def count_paths(grid): N = len(grid) if grid[0][0] == '#' or grid[N-1][N-1] == '#': return 0 dp = [[0] * N for _ in range(N)] dp[0][0] = 1 for i in range(N): for j in range(N): if grid[i][j] == '#': dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[N-1][N-1] def find_paths(test_cases): results = [] for k in range(len(test_cases)): N, grid = test_cases[k] res = count_paths(grid) results.append(f\\"TestCase {k+1}:n{res}\\") return results def main(input_data): lines = input_data.strip().split('n') T = int(lines[0]) index = 1 test_cases = [] for _ in range(T): N = int(lines[index]) grid = [] for i in range(N): grid.append(lines[index + 1 + i]) test_cases.append((N, grid)) index += N + 1 results = find_paths(test_cases) return 'n'.join(results)"},{"question":"import random def days_to_empty_vending_machines(k: int, candies: List[int]) -> int: Simulate how many days it will take before all vending machines are empty. Each day, a customer randomly chooses a vending machine and buys one candy piece from it. Args: k (int): The number of vending machines. candies (List[int]): The number of candies in each vending machine. Returns: int: The number of days it will take before all vending machines are empty. Examples: >>> days_to_empty_vending_machines(3, [4, 3, 2]) 9 >>> days_to_empty_vending_machines(5, [1, 1, 1, 1, 1]) 15 >>> days_to_empty_vending_machines(1, [10]) 10","solution":"import random def days_to_empty_vending_machines(k, candies): days = 0 while any(candies): machine = random.choice([i for i, x in enumerate(candies) if x > 0]) candies[machine] -= 1 days += 1 return days"},{"question":"def check_sequences(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[str]: Check if each sequence satisfies the condition that every number in the sequence is greater than or equal to the average of all numbers preceding it in the sequence. >>> check_sequences(3, [(3, [2, 3, 4]), (4, [5, 3, 3, 2]), (2, [7, 7])]) [\\"Yes\\", \\"No\\", \\"Yes\\"]","solution":"def check_sequences(t, test_cases): results = [] for case in test_cases: k = case[0] sequence = case[1] valid = True for i in range(1, k): prefix_sum = sum(sequence[:i]) average = prefix_sum / i if sequence[i] < average: valid = False break results.append(\\"Yes\\" if valid else \\"No\\") return results"},{"question":"def generate_largest_string(source: str) -> str: Generates the lexicographically largest string from the given source string by repeatedly removing either the first or last character and appending it to the result. :param str source: The input source string. :return: The lexicographically largest result string. :rtype: str >>> generate_largest_string(\\"abc\\") \\"cba\\" >>> generate_largest_string(\\"abac\\") \\"caba\\" def test_generate_largest_string_case_1(): assert generate_largest_string(\\"abc\\") == \\"cba\\" def test_generate_largest_string_case_2(): assert generate_largest_string(\\"abac\\") == \\"caba\\" def test_generate_largest_string_all_same(): assert generate_largest_string(\\"aaaa\\") == \\"aaaa\\" def test_generate_largest_string_two_chars(): assert generate_largest_string(\\"ab\\") == \\"ba\\" assert generate_largest_string(\\"ba\\") == \\"ba\\" def test_generate_largest_string_large_input(): input_str = \\"a\\" * 50000 + \\"b\\" * 50000 expected_output = \\"b\\" * 50000 + \\"a\\" * 50000 assert generate_largest_string(input_str) == expected_output","solution":"def generate_largest_string(source): Generates the lexicographically largest string from the given source string by repeatedly removing either the first or last character and appending it to the result. :param str source: The input source string. :return: The lexicographically largest result string. :rtype: str result = [] while source: if source[0] >= source[-1]: result.append(source[0]) source = source[1:] else: result.append(source[-1]) source = source[:-1] return ''.join(result)"},{"question":"def sort_words(input_string: str) -> str: Returns a string with the words sorted in lexicographical order. Parameters: input_string (str): A string of space-separated words. Returns: str: A string of space-separated words sorted in lexicographical order. >>> sort_words(\\"banana apple cherry date\\") 'apple banana cherry date' >>> sort_words(\\"dog cat elephant bee\\") 'bee cat dog elephant' >>> sort_words(\\"apple apple apple\\") 'apple apple apple' >>> sort_words(\\"apple\\") 'apple' >>> sort_words(\\"\\") '' >>> sort_words(\\"Banana apple Cherry date\\") 'Banana Cherry apple date'","solution":"def sort_words(input_string): Returns a string with the words sorted in lexicographical order. Parameters: input_string (str): A string of space-separated words. Returns: str: A string of space-separated words sorted in lexicographical order. words = input_string.split() words.sort() return ' '.join(words)"},{"question":"def min_operations_to_single_number(n: int, sequence: List[int]) -> int: This function takes the sequence length n and the sequence itself and returns the minimum number of operations required to reduce the sequence to a single number. pass def test_min_operations_to_single_number(): assert min_operations_to_single_number(3, [1, 2, 3]) == 2 assert min_operations_to_single_number(4, [1, 1, 1, 1]) == 3 assert min_operations_to_single_number(5, [-1, -2, 3, 4, -5]) == 4 def test_min_operations_single_element(): assert min_operations_to_single_number(1, [100]) == 0 def test_min_operations_two_elements(): assert min_operations_to_single_number(2, [5, 7]) == 1 def test_min_operations_large_sequence(): assert min_operations_to_single_number(1000, list(range(1000))) == 999","solution":"def min_operations_to_single_number(n, sequence): This function takes the sequence length n and the sequence itself and returns the minimum number of operations required to reduce the sequence to a single number. # The minimum number of operations to reduce the sequence to a single number # is always (n - 1), because each operation reduces the length of the sequence by 1. return n - 1"},{"question":"def calculate_max_benefit(n: int, workshops: List[Tuple[int, int, int]]) -> int: Calculate the maximum total benefit score by attending non-overlapping workshops. >>> calculate_max_benefit(4, [(1, 3, 50), (3, 5, 20), (2, 6, 100), (4, 7, 200)]) 250 >>> calculate_max_benefit(3, [(1, 3, 60), (2, 5, 30), (6, 8, 70)]) 130","solution":"from bisect import bisect_right def max_benefit(workshops): workshops.sort(key=lambda x: x[1]) # Sort by end time # Prepare for DP end_times = [w[1] for w in workshops] dp = [0] * (len(workshops) + 1) for i in range(1, len(workshops) + 1): # Current workshop details s_i, e_i, b_i = workshops[i - 1] # Find the most recent non-overlapping workshop idx = bisect_right(end_times, s_i) - 1 # Update DP table dp[i] = max(dp[i-1], dp[idx + 1] + b_i) return dp[len(workshops)] # Input reader function for ease of testing def calculate_max_benefit(n, workshop_list): workshops = [(workshop_list[i][0], workshop_list[i][1], workshop_list[i][2]) for i in range(n)] return max_benefit(workshops)"},{"question":"def island_perimeter(n: int, m: int, grid: List[List[int]]) -> int: Returns the perimeter of the island in the grid. >>> island_perimeter(4, 4, [ ... [0, 1, 0, 0], ... [1, 1, 1, 0], ... [0, 1, 0, 0], ... [1, 1, 0, 0]]) 16 >>> island_perimeter(4, 4, [ ... [1, 0, 0, 0], ... [1, 0, 0, 0], ... [1, 0, 0, 0], ... [1, 0, 0, 0]]) 10 >>> island_perimeter(1, 1, [ ... [1]]) 4","solution":"def island_perimeter(n, m, grid): Returns the perimeter of the island in the grid. perimeter = 0 for i in range(n): for j in range(m): if grid[i][j] == 1: # Initial assumption: each land cell has 4 sides perimeter += 4 # Check for adjacent land cells if i > 0 and grid[i-1][j] == 1: # Check the upper cell perimeter -= 2 if j > 0 and grid[i][j-1] == 1: # Check the left cell perimeter -= 2 return perimeter"},{"question":"def check_dominant_trees(n: int, heights: List[int]) -> List[str]: Determines whether each tree in the array is dominant based on its height. Parameters: n (int): The number of trees. heights (list of int): The heights of the trees. Returns: list of str: A list of strings, each being \\"DOMINANT\\" or \\"NOT DOMINANT\\". pass # Unit Tests def test_all_trees_equal(): assert check_dominant_trees(5, [5, 5, 5, 5, 5]) == [\\"NOT DOMINANT\\", \\"NOT DOMINANT\\", \\"NOT DOMINANT\\", \\"NOT DOMINANT\\", \\"NOT DOMINANT\\"] def test_single_tree(): assert check_dominant_trees(1, [10]) == [\\"DOMINANT\\"] def test_all_trees_dominant(): assert check_dominant_trees(3, [9, 5, 7]) == [\\"DOMINANT\\", \\"NOT DOMINANT\\", \\"DOMINANT\\"] def test_example_case(): assert check_dominant_trees(5, [2, 6, 3, 7, 4]) == [\\"NOT DOMINANT\\", \\"DOMINANT\\", \\"NOT DOMINANT\\", \\"DOMINANT\\", \\"NOT DOMINANT\\"] def test_alternating_trees(): assert check_dominant_trees(4, [1, 3, 1, 3]) == [\\"NOT DOMINANT\\", \\"DOMINANT\\", \\"NOT DOMINANT\\", \\"DOMINANT\\"]","solution":"def check_dominant_trees(n, heights): Determines whether each tree in the array is dominant based on its height. Parameters: n (int): The number of trees. heights (list of int): The heights of the trees. Returns: list of str: A list of strings, each being \\"DOMINANT\\" or \\"NOT DOMINANT\\". results = [] for i in range(n): if i == 0: # First tree if n == 1 or heights[i] > heights[i + 1]: results.append(\\"DOMINANT\\") else: results.append(\\"NOT DOMINANT\\") elif i == n - 1: # Last tree if heights[i] > heights[i - 1]: results.append(\\"DOMINANT\\") else: results.append(\\"NOT DOMINANT\\") else: # Middle trees if heights[i] > heights[i - 1] and heights[i] > heights[i + 1]: results.append(\\"DOMINANT\\") else: results.append(\\"NOT DOMINANT\\") return results"},{"question":"def rotate_matrix_90_degrees_clockwise(n: int, matrix: List[List[int]]) -> List[List[int]]: Rotates the given n x n matrix 90 degrees clockwise in-place. :param n: Size of the matrix (integer) :param matrix: n x n matrix (list of lists) :return: Rotated matrix (list of lists) Example: >>> rotate_matrix_90_degrees_clockwise(2, [[1, 2], [3, 4]]) [[3, 1], [4, 2]] >>> rotate_matrix_90_degrees_clockwise(3, [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) [[7, 4, 1], [8, 5, 2], [9, 6, 3]] pass def test_rotate_2x2_matrix(): matrix = [ [1, 2], [3, 4] ] expected_output = [ [3, 1], [4, 2] ] assert rotate_matrix_90_degrees_clockwise(2, matrix) == expected_output def test_rotate_3x3_matrix(): matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] expected_output = [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] assert rotate_matrix_90_degrees_clockwise(3, matrix) == expected_output def test_rotate_1x1_matrix(): matrix = [ [1] ] expected_output = [ [1] ] assert rotate_matrix_90_degrees_clockwise(1, matrix) == expected_output def test_rotate_4x4_matrix(): matrix = [ [1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16] ] expected_output = [ [13, 9, 5, 1], [14, 10, 6, 2], [15, 11, 7, 3], [16, 12, 8, 4] ] assert rotate_matrix_90_degrees_clockwise(4, matrix) == expected_output def test_rotate_100x100_matrix(): matrix = [[i + 100 * j for i in range(1, 101)] for j in range(100)] expected_output = [[100 * (100 - j - 1) + i + 1 for j in range(100)] for i in range(100)] assert rotate_matrix_90_degrees_clockwise(100, matrix) == expected_output","solution":"def rotate_matrix_90_degrees_clockwise(n, matrix): Rotates the given n x n matrix 90 degrees clockwise in-place. :param n: Size of the matrix (integer) :param matrix: n x n matrix (list of lists) :return: Rotated matrix (list of lists) # Rotating the matrix 90 degrees clockwise for i in range(n // 2): for j in range(i, n - i - 1): temp = matrix[i][j] matrix[i][j] = matrix[n - 1 - j][i] matrix[n - 1 - j][i] = matrix[n - 1 - i][n - 1 - j] matrix[n - 1 - i][n - 1 - j] = matrix[j][n - 1 - i] matrix[j][n - 1 - i] = temp return matrix"},{"question":"from typing import List def shortest_subarray_length(arr: List[int], x: int) -> int: Determine the length of the shortest subarray that has a sum greater than x. If no such subarray exists, return -1. >>> shortest_subarray_length([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 15) == 2 >>> shortest_subarray_length([1, 2, 3, 4, 5], 100) == -1 >>> shortest_subarray_length([16, 2, 1, 3, 5, 9], 15) == 1 pass def test_shortest_subarray_length(): assert shortest_subarray_length([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 15) == 2 assert shortest_subarray_length([1, 2, 3, 4, 5], 100) == -1 assert shortest_subarray_length([16, 2, 1, 3, 5, 9], 15) == 1 assert shortest_subarray_length([1, 4, 45, 6, 0, 19], 51) == 3 assert shortest_subarray_length([1, 2, 3, 4, 5], 5) == 2 assert shortest_subarray_length([-1, -2, 1, 2, 3, -4, 5, 6], 3) == 1","solution":"def shortest_subarray_length(arr, x): n = len(arr) min_length = float('inf') current_sum = 0 start = 0 for end in range(n): current_sum += arr[end] while current_sum > x: min_length = min(min_length, end - start + 1) current_sum -= arr[start] start += 1 return min_length if min_length != float('inf') else -1"},{"question":"from typing import List, Tuple def find_tree_diameter(n: int, edges: List[Tuple[int, int]]) -> int: Determine the maximum path length (number of edges) in the tree. Args: n (int): The number of nodes in the tree. edges (List[Tuple[int, int]]): The list of edges denoting the connections between the nodes. Returns: int: The diameter of the tree. Examples: >>> find_tree_diameter(3, [(1, 2), (2, 3)]) == 2 >>> find_tree_diameter(4, [(1, 2), (2, 3), (3, 4)]) == 3 >>> find_tree_diameter(5, [(1, 2), (1, 3), (2, 4), (2, 5)]) == 3 pass def solve(t: int, test_cases: List[Tuple[int, List[Tuple[int, int]]]]) -> List[int]: Solve multiple test cases to find the diameter for each tree. Args: t (int): The number of test cases. test_cases (List[Tuple[int, List[Tuple[int, int]]]]): The test cases containing the number of nodes and the edges for each tree. Returns: List[int]: A list containing the diameter of the tree for each test case. Examples: >>> solve(3, [(3, [(1, 2), (2, 3)]), (4, [(1, 2), (2, 3), (3, 4)]), (5, [(1, 2), (1, 3), (2, 4), (2, 5)])]) == [2, 3, 3] pass def test_find_tree_diameter(): assert find_tree_diameter(3, [(1, 2), (2, 3)]) == 2 assert find_tree_diameter(4, [(1, 2), (2, 3), (3, 4)]) == 3 assert find_tree_diameter(5, [(1, 2), (1, 3), (2, 4), (2, 5)]) == 3 def test_solve(): test_cases = [ (3, [(1, 2), (2, 3)]), (4, [(1, 2), (2, 3), (3, 4)]), (5, [(1, 2), (1, 3), (2, 4), (2, 5)]) ] results = solve(3, test_cases) assert results == [2, 3, 3]","solution":"from collections import deque, defaultdict def find_tree_diameter(n, edges): def bfs(start): distances = [-1] * (n + 1) q = deque([start]) distances[start] = 0 farthest_node = start max_distance = 0 while q: node = q.popleft() for neighbor in tree[node]: if distances[neighbor] == -1: distances[neighbor] = distances[node] + 1 q.append(neighbor) if distances[neighbor] > max_distance: max_distance = distances[neighbor] farthest_node = neighbor return farthest_node, max_distance # Building the tree tree = defaultdict(list) for u, v in edges: tree[u].append(v) tree[v].append(u) # Running the first BFS to find one endpoint of the longest path farthest_node_from_start, _ = bfs(1) # Running the second BFS from the found endpoint to find the diameter _, diameter = bfs(farthest_node_from_start) return diameter def solve(t, test_cases): results = [] for i in range(t): n, edges = test_cases[i] results.append(find_tree_diameter(n, edges)) return results"},{"question":"def perform_operations(N: int, M: int, operations: List[str]) -> List[int]: Perform a series of INCREMENT and GETSUM operations on a list initially containing zeros. Arguments: N -- the number of elements in the list M -- the number of operations to perform operations -- a list of operations in the form of strings Returns: List[int] -- results of all GETSUM operations Example: >>> perform_operations(5, 4, [\\"INCREMENT 1 3\\", \\"INCREMENT 2 4\\", \\"GETSUM 1 3\\", \\"GETSUM 0 4\\"]) [5, 6]","solution":"def perform_operations(N, M, operations): lst = [0] * N results = [] for operation in operations: parts = operation.split() if parts[0] == \\"INCREMENT\\": i, j = int(parts[1]), int(parts[2]) for k in range(i, j + 1): lst[k] += 1 elif parts[0] == \\"GETSUM\\": i, j = int(parts[1]), int(parts[2]) results.append(sum(lst[i:j + 1])) return results"},{"question":"def perfect_square_hop_winner(N: int, stones: List[int]) -> str: Determine the winner of the Perfect Square Hop game if both players play optimally. Args: N (int): Number of cells. stones (List[int]): List of integers representing the number of stones in each cell. Returns: str: \\"Player 1\\" if Player 1 wins, \\"Player 2\\" if Player 2 wins. Examples: >>> perfect_square_hop_winner(3, [4, 5, 1]) 'Player 1' >>> perfect_square_hop_winner(2, [1, 1]) 'Player 2' >>> perfect_square_hop_winner(4, [7, 16, 9, 25]) 'Player 2' >>> perfect_square_hop_winner(5, [8, 10, 14, 1, 2]) 'Player 1'","solution":"import math def perfect_square_hop_winner(N, stones): # Precompute Grundy numbers max_stones = 1000 grundy = [0] * (max_stones + 1) for i in range(1, max_stones + 1): Grundy_set = set() j = 1 while j*j <= i: Grundy_set.add(grundy[i - j*j]) j += 1 # Minimum excludant (mex) mex = 0 while mex in Grundy_set: mex += 1 grundy[i] = mex # Calculate grundy value for the game state total_grundy = 0 for stones_count in stones: total_grundy ^= grundy[stones_count] return \\"Player 1\\" if total_grundy != 0 else \\"Player 2\\""},{"question":"def add_minutes_to_time(initialHours: int, initialMinutes: int, minutesToAdd: int) -> str: Adds the specified number of minutes to the given time (initialHours, initialMinutes) and returns the resulting time in \\"HH MM\\" format on a 24-hour clock. >>> add_minutes_to_time(14, 45, 150) \\"17 15\\" >>> add_minutes_to_time(23, 30, 90) \\"01 00\\" >>> add_minutes_to_time(10, 30, 0) \\"10 30\\" >>> add_minutes_to_time(10, 30, 1440) \\"10 30\\" >>> add_minutes_to_time(0, 0, 2880) \\"00 00\\" >>> add_minutes_to_time(6, 45, 2000) \\"16 05\\" >>> add_minutes_to_time(22, 50, 130) \\"01 00\\" >>> add_minutes_to_time(18, 59, 61) \\"20 00\\" >>> add_minutes_to_time(0, 0, 0) \\"00 00\\" >>> add_minutes_to_time(23, 59, 1) \\"00 00\\" >>> add_minutes_to_time(23, 59, 2) \\"00 01\\"","solution":"def add_minutes_to_time(initialHours, initialMinutes, minutesToAdd): This function adds the specified number of minutes to the given time (initialHours, initialMinutes) and returns the resulting time in \\"HH MM\\" format on a 24-hour clock. total_minutes = initialHours * 60 + initialMinutes + minutesToAdd final_hours = (total_minutes // 60) % 24 final_minutes = total_minutes % 60 return f\\"{final_hours:02} {final_minutes:02}\\" # Example usage: # print(add_minutes_to_time(14, 45, 150)) # Output: \\"17 15\\" # print(add_minutes_to_time(23, 30, 90)) # Output: \\"01 00\\""},{"question":"def is_bipartite(V: int, adj_list: List[List[int]]) -> bool: Determine if the given graph is bipartite. Args: V: int : Number of vertices adj_list: List[List[int]] : Adjacency list of the graph Returns: bool : True if the graph is bipartite, False otherwise >>> is_bipartite(3, [[], [2, 3], [1, 3], [1, 2]]) == False >>> is_bipartite(4, [[], [2, 4], [1, 3], [2, 4], [1, 3]]) == True pass def bipartite_test_cases(T: int, test_cases: List[Tuple[Tuple[int, int], List[Tuple[int, int]]]]) -> List[str]: Process multiple test cases to determine if each graph is bipartite. Args: T: int : Number of test cases test_cases: List[Tuple[Tuple[int, int], List[Tuple[int, int]]]] : Test cases with each containing number of vertices, number of edges, and a list of edges Returns: List[str] : List of results for each test case in the format \\"Case #x: y\\" >>> bipartite_test_cases(2, [((3, 3), [(1, 2), (2, 3), (3, 1)]), ((4, 4), [(1, 2), (2, 3), (3, 4), (4, 1)])]) [\\"Case #1: No\\", \\"Case #2: Yes\\"] pass # Test cases def test_is_bipartite_simple_case(): assert is_bipartite(3, [[], [2, 3], [1, 3], [1, 2]]) == False, \\"Test Case 1 Failed\\" def test_is_bipartite_another_case(): assert is_bipartite(4, [[], [2, 4], [1, 3], [2, 4], [1, 3]]) == True, \\"Test Case 2 Failed\\" def test_bipartite_test_cases(): T = 2 test_cases = [ ((3, 3), [(1, 2), (2, 3), (3, 1)]), ((4, 4), [(1, 2), (2, 3), (3, 4), (4, 1)]) ] results = bipartite_test_cases(T, test_cases) expected_results = [\\"Case #1: No\\", \\"Case #2: Yes\\"] assert results == expected_results, \\"Test Case 3 Failed\\" def test_single_edge(): T = 1 test_cases = [ ((2, 1), [(1, 2)]) ] results = bipartite_test_cases(T, test_cases) expected_results = [\\"Case #1: Yes\\"] assert results == expected_results, \\"Test Case 4 Failed\\" def test_no_edges(): T = 1 test_cases = [ ((3, 0), []) ] results = bipartite_test_cases(T, test_cases) expected_results = [\\"Case #1: Yes\\"] assert results == expected_results, \\"Test Case 5 Failed\\" # Run all the tests test_is_bipartite_simple_case() test_is_bipartite_another_case() test_bipartite_test_cases() test_single_edge() test_no_edges()","solution":"def is_bipartite(V, adj_list): color = [-1] * (V + 1) # coloring the vertices, initialized to -1 def bfs(source): queue = [source] color[source] = 1 # start coloring source with 1 while queue: node = queue.pop(0) for neighbour in adj_list[node]: if color[neighbour] == -1: # if not colored color[neighbour] = 1 - color[node] # alternate color queue.append(neighbour) elif color[neighbour] == color[node]: # same color as current node return False return True for i in range(1, V + 1): if color[i] == -1: # if not visited if not bfs(i): return False return True def bipartite_test_cases(T, test_cases): results = [] for i in range(T): V, E = test_cases[i][0] edges = test_cases[i][1] adj_list = [[] for _ in range(V + 1)] for u, v in edges: adj_list[u].append(v) adj_list[v].append(u) if is_bipartite(V, adj_list): results.append(f\\"Case #{i + 1}: Yes\\") else: results.append(f\\"Case #{i + 1}: No\\") return results"},{"question":"class Tree: def __init__(self, n): self.n = n self.tree = [[] for _ in range(n + 1)] self.values = [0] * (n + 1) def add_edge(self, parent, child): self.tree[parent].append(child) def update(self, v, x): self.values[v] = x def query(self, u): return self._dfs_sum(u) def _dfs_sum(self, u): total = self.values[u] for child in self.tree[u]: total += self._dfs_sum(child) return total def process_operations(n, parents, q, operations): Perform the given operations on the tree and return the results of query operations. >>> process_operations(5, [1, 1, 3, 3], 5, [('update', 1, 2), ('update', 2, 3), ('query', 1), ('query', 2), ('update', 3, 5)]) [5, 3] from solution import process_operations def test_tree_operations(): n = 5 parents = [1, 1, 3, 3] q = 5 operations = [ ('update', 1, 2), ('update', 2, 3), ('query', 1), ('query', 2), ('update', 3, 5) ] expected = [5, 3] assert process_operations(n, parents, q, operations) == expected def test_tree_with_single_node(): n = 1 parents = [] q = 1 operations = [ ('query', 1) ] expected = [0] assert process_operations(n, parents, q, operations) == expected def test_tree_with_all_zero_updates(): n = 3 parents = [1, 2] q = 3 operations = [ ('update', 1, 0), ('update', 2, 0), ('query', 1) ] expected = [0] assert process_operations(n, parents, q, operations) == expected def test_tree_with_multiple_queries(): n = 4 parents = [1, 1, 2] q = 6 operations = [ ('update', 1, 1), ('update', 2, 2), ('update', 3, 3), ('query', 1), ('update', 4, 4), ('query', 2) ] expected = [6, 6] assert process_operations(n, parents, q, operations) == expected","solution":"class Tree: def __init__(self, n): self.n = n self.tree = [[] for _ in range(n + 1)] self.values = [0] * (n + 1) def add_edge(self, parent, child): self.tree[parent].append(child) def update(self, v, x): self.values[v] = x def query(self, u): return self._dfs_sum(u) def _dfs_sum(self, u): total = self.values[u] for child in self.tree[u]: total += self._dfs_sum(child) return total def process_operations(n, parents, q, operations): tree = Tree(n) for i, parent in enumerate(parents): tree.add_edge(parent, i + 2) result = [] for op in operations: if op[0] == 'update': _, v, x = op tree.update(v, x) elif op[0] == 'query': _, u = op result.append(tree.query(u)) return result"},{"question":"def find_smallest_missing_positive_integer(n: int, array: List[int]) -> int: Find the smallest positive integer that is missing from the list. Parameters: n (int): The length of the list. array (List[int]): The list of integers. Returns: int: The smallest positive integer missing from the list. Examples: >>> find_smallest_missing_positive_integer(5, [1, 2, 0, -1, 3]) 4 >>> find_smallest_missing_positive_integer(6, [-5, -3, -1, 0, 1, 2]) 3 >>> find_smallest_missing_positive_integer(4, [2, 3, 4, 5]) 1 >>> find_smallest_missing_positive_integer(3, [-1, -2, -3]) 1 >>> find_smallest_missing_positive_integer(10, [1000, -1000, 1, 2, 3, 5, 6, 7, 8, 9]) 4 >>> find_smallest_missing_positive_integer(1, [1000]) 1 >>> find_smallest_missing_positive_integer(2, [0, 0]) 1","solution":"def find_smallest_missing_positive_integer(n, array): Find the smallest missing positive integer from the given list. positive_set = {num for num in array if num > 0} smallest_missing = 1 while smallest_missing in positive_set: smallest_missing += 1 return smallest_missing"},{"question":"def is_almost_sorted(arr: List[int]) -> str: Checks if the array is almost sorted, meaning it can be sorted by swapping at most two elements. >>> is_almost_sorted([1, 2, 3, 4, 5]) \\"YES\\" >>> is_almost_sorted([1, 3, 2, 4]) \\"YES\\" >>> is_almost_sorted([3, 4, 2, 1]) \\"NO\\" >>> is_almost_sorted([4, 3, 2, 1]) \\"NO\\" >>> is_almost_sorted(list(range(99999)) + [100000, 99999]) \\"YES\\"","solution":"def is_almost_sorted(arr): Checks if the array is almost sorted, meaning it can be sorted by swapping at most two elements. n = len(arr) original = arr[:] sorted_arr = sorted(arr) # Find the number of positions where elements differ. diff = [] for i in range(n): if original[i] != sorted_arr[i]: diff.append(i) # If no difference, array is already sorted. if not diff: return \\"YES\\" # If two positions differ, check if swapping them sorts the array. elif len(diff) == 2: i, j = diff original[i], original[j] = original[j], original[i] if original == sorted_arr: return \\"YES\\" # If more than 2 positions differ, it cannot be almost sorted. return \\"NO\\""},{"question":"from typing import List def update_package_statuses(initial_statuses: List[int], checkpoints_passed: int) -> List[int]: Update the status values of packages based on the number of checkpoints they've passed through. Args: initial_statuses (list[int]): An array of integers representing the initial status values of the packages. checkpoints_passed (int): The number of checkpoints each package has passed through. Returns: list[int]: An array of updated status values of the packages. >>> update_package_statuses([2, 4, 1, 7, 3], 3) [5, 7, 4, 10, 6] >>> update_package_statuses([6, 3, 8, 1], 2) [8, 5, 10, 3] >>> update_package_statuses([6, 3, 8, 1], 0) [6, 3, 8, 1] >>> update_package_statuses([0, 0, 0, 0], 5) [5, 5, 5, 5] >>> update_package_statuses([100, 200, 300], 50) [150, 250, 350] >>> update_package_statuses([10], 5) [15] >>> update_package_statuses([0], 0) [0]","solution":"def update_package_statuses(initial_statuses, checkpoints_passed): Update the status values of packages based on the number of checkpoints they've passed through. Args: initial_statuses (list[int]): An array of integers representing the initial status values of the packages. checkpoints_passed (int): The number of checkpoints each package has passed through. Returns: list[int]: An array of updated status values of the packages. return [status + checkpoints_passed for status in initial_statuses]"},{"question":"def distribute_nuts(n: int, k: int, ids: List[int]) -> List[int]: Distributes nuts evenly among trees while minimizing the variance of the number of nuts between consecutive trees based on their IDs. Args: n: int - number of trees k: int - total number of nuts ids: List[int] - list of tree IDs Returns: List[int] - list of nuts assigned to each tree in the order of their IDs Examples: >>> distribute_nuts(5, 11, [3, 1, 4, 2, 5]) [3, 2, 2, 2, 2] >>> distribute_nuts(3, 8, [10, 2, 5]) [3, 3, 2]","solution":"def distribute_nuts(n, k, ids): Distributes nuts evenly among trees while minimizing the variance of the number of nuts between consecutive trees based on their IDs. Args: n: int - number of trees k: int - total number of nuts ids: List[int] - list of tree IDs Returns: List[int] - list of nuts assigned to each tree in the order of their IDs base_nuts = k // n extra_nuts = k % n nuts_distribution = [base_nuts] * n for i in range(extra_nuts): nuts_distribution[i] += 1 return nuts_distribution"},{"question":"from typing import List, Tuple def min_edits_to_transform(s1: str, s2: str) -> int: Returns the minimum number of single-character edits (insertions, deletions, or substitutions) required to transform s1 into s2. # Initialize a matrix with zeroes pass def process_test_cases(test_cases: List[Tuple[str, str]]) -> List[int]: Processes a list of test cases and returns a list of minimum edits required. >>> process_test_cases([(\\"kitten\\", \\"sitting\\"), (\\"flaw\\", \\"flawn\\")]) == [3, 1] >>> process_test_cases([(\\"abc\\", \\"def\\"), (\\"same\\", \\"same\\")]) == [3, 0] pass","solution":"def min_edits_to_transform(s1, s2): Returns the minimum number of single-character edits (insertions, deletions, or substitutions) required to transform s1 into s2. # Initialize a matrix with zeroes m, n = len(s1), len(s2) dp = [[0] * (n + 1) for _ in range(m + 1)] # Fill dp matrix for i in range(m + 1): for j in range(n + 1): if i == 0: dp[i][j] = j # Min. operations = j elif j == 0: dp[i][j] = i # Min. operations = i elif s1[i - 1] == s2[j - 1]: dp[i][j] = dp[i - 1][j - 1] else: dp[i][j] = 1 + min(dp[i - 1][j], # Delete dp[i][j - 1], # Insert dp[i - 1][j - 1]) # Replace return dp[m][n] def process_test_cases(test_cases): results = [] for s1, s2 in test_cases: results.append(min_edits_to_transform(s1, s2)) return results"},{"question":"def max_bands_accommodated(n, d, requested_times): Determines the maximum number of bands that can perform without overlapping. Parameters: n (int): Number of bands. d (int): Duration of each band's performance. requested_times (list): List of requested start times for each band. Returns: int: Maximum number of bands that can perform. >>> max_bands_accommodated(3, 5, [1, 5, 10]) == 2 >>> max_bands_accommodated(4, 3, [10, 7, 12, 3]) == 3 >>> max_bands_accommodated(5, 2, [1, 3, 3, 2, 5]) == 3 >>> max_bands_accommodated(1, 5, [1]) == 1 >>> max_bands_accommodated(4, 10, [1, 2, 3, 4]) == 1 >>> max_bands_accommodated(4, 1, [1, 4, 7, 10]) == 4 >>> max_bands_accommodated(5, 10, [1, 20, 40, 60, 80]) == 5","solution":"def max_bands_accommodated(n, d, requested_times): Determines the maximum number of bands that can perform without overlapping. Parameters: n (int): Number of bands. d (int): Duration of each band's performance. requested_times (list): List of requested start times for each band. Returns: int: Maximum number of bands that can perform. # Sort the requested times requested_times.sort() # Initialize variables max_bands = 0 current_end_time = -1 # Iterate through the sorted requested times for start_time in requested_times: # If the band can start their performance if start_time >= current_end_time: max_bands += 1 current_end_time = start_time + d return max_bands # Example Usage if __name__ == \\"__main__\\": n, d = map(int, input().split()) requested_times = list(map(int, input().split())) print(max_bands_accommodated(n, d, requested_times))"},{"question":"def max_product_after_removal(n: int, arr: List[int]) -> int: Given an array of integers, maximize the product of any two distinct elements by removing up to one element. >>> max_product_after_removal(4, [1, 10, -5, 4]) 40 >>> max_product_after_removal(3, [0, -1, -2]) 2 >>> max_product_after_removal(4, [1, 2, 3, 4]) 12 >>> max_product_after_removal(3, [-1, -2, -3]) 6 >>> max_product_after_removal(3, [0, 2, 3]) 6 >>> max_product_after_removal(2, [5, -5]) -25 >>> max_product_after_removal(3, [3, 4, 5]) 20","solution":"def max_product_after_removal(n, arr): if n == 2: return arr[0] * arr[1] max_product = float('-inf') for i in range(n): temp_arr = arr[:i] + arr[i+1:] temp_max_product = float('-inf') for j in range(n-1): for k in range(j+1, n-1): temp_max_product = max(temp_max_product, temp_arr[j] * temp_arr[k]) max_product = max(max_product, temp_max_product) return max_product"},{"question":"def get_next_state(m: int, n: int, grid: List[str]) -> List[str]: Perform one iteration of updates on an m x n cellular automaton grid and output the resulting grid. >>> get_next_state(3, 3, [\\"000\\", \\"010\\", \\"000\\"]) [\\"000\\", \\"000\\", \\"000\\"] >>> get_next_state(4, 4, [\\"0000\\", \\"1110\\", \\"0110\\", \\"0000\\"]) [\\"0100\\", \\"1010\\", \\"1011\\", \\"0100\\"]","solution":"def get_next_state(m, n, grid): def count_live_neighbors(x, y): count = 0 for dx in [-1, 0, 1]: for dy in [-1, 0, 1]: if dx == 0 and dy == 0: continue nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n: count += grid[nx][ny] == '1' return count new_grid = [list(row) for row in grid] for i in range(m): for j in range(n): live_neighbors = count_live_neighbors(i, j) if grid[i][j] == '1': if live_neighbors < 2 or live_neighbors > 3: new_grid[i][j] = '0' else: if live_neighbors == 3: new_grid[i][j] = '1' return [''.join(row) for row in new_grid] # Example usage: # m, n = 4, 4 # grid = [ # \\"0000\\", # \\"1110\\", # \\"0110\\", # \\"0000\\" # ] # result = get_next_state(m, n, grid) # print('n'.join(result))"},{"question":"import math from typing import List, Tuple def max_square_side(t: int, dimensions: List[Tuple[int, int]]) -> List[int]: Determine the maximum side length of the square plot that can be uniformly used to divide each given piece of land. Args: t (int): The number of test cases. dimensions (List[Tuple[int, int]]): A list of tuples, each containing the width and height of a piece of land. Returns: List[int]: A list of integers representing the maximum side length of the square for each test case. >>> max_square_side(3, [(12, 15), (25, 30), (8, 4)]) [3, 5, 4] >>> max_square_side(2, [(100, 50), (72, 120)]) [50, 24] >>> max_square_side(1, [(18, 24)]) [6] >>> max_square_side(4, [(36, 48), (24, 24), (19, 28), (7, 91)]) [12, 24, 1, 7] >>> max_square_side(5, [(30000, 10000), (5000, 3000), (100, 200), (17, 51), (12, 28)]) [10000, 1000, 100, 17, 4]","solution":"import math def max_square_side(t, dimensions): result = [] for w, h in dimensions: result.append(math.gcd(w, h)) return result"},{"question":"def can_reach_last_bus_stop(N: int, M: int, routes: List[Tuple[int, int]]) -> str: Determine whether it is possible to travel from bus stop 1 to bus stop N. >>> can_reach_last_bus_stop(5, 5, [(1, 2), (2, 3), (3, 4), (4, 5), (1, 3)]) \\"Possible\\" >>> can_reach_last_bus_stop(4, 2, [(1, 2), (3, 4)]) \\"Impossible\\" >>> can_reach_last_bus_stop(6, 7, [(1, 2), (1, 3), (2, 4), (3, 4), (4, 5), (5, 6), (3, 6)]) \\"Possible\\" >>> can_reach_last_bus_stop(3, 0, []) \\"Impossible\\" >>> can_reach_last_bus_stop(4, 4, [(1, 2), (2, 3), (3, 1), (3, 4)]) \\"Possible\\"","solution":"def can_reach_last_bus_stop(N, M, routes): from collections import deque, defaultdict graph = defaultdict(list) for u, v in routes: graph[u].append(v) def bfs(start, goal): queue = deque([start]) visited = set([start]) while queue: current = queue.popleft() if current == goal: return True for neighbor in graph[current]: if neighbor not in visited: visited.add(neighbor) queue.append(neighbor) return False return \\"Possible\\" if bfs(1, N) else \\"Impossible\\""},{"question":"def derangement(n: int) -> int: Returns the number of derangements (permutations where no element appears in its original position) for a list of size n. >>> derangement(1) 0 >>> derangement(2) 1 >>> derangement(3) 2 >>> derangement(4) 9 def derangements_for_tests(t: int, cases: List[int]) -> List[int]: Returns the list of derangements for each test case. >>> derangements_for_tests(4, [1, 2, 3, 4]) [0, 1, 2, 9] >>> derangements_for_tests(3, [5, 3, 1]) [44, 2, 0] >>> derangements_for_tests(2, [6, 7]) [265, 1854]","solution":"def derangement(n): Returns the number of derangements (permutations where no element appears in its original position) for a list of size n. if n == 0: return 1 if n == 1: return 0 derange = [0] * (n + 1) derange[0] = 1 # by definition, the derangement of an empty set is 1 derange[1] = 0 # zero derangements for a single element for i in range(2, n + 1): derange[i] = (i - 1) * (derange[i - 1] + derange[i - 2]) return derange[n] def derangements_for_tests(t, cases): Returns the list of derangements for each test case. results = [] for n in cases: results.append(derangement(n)) return results"},{"question":"def sum_of_repeated_chars(s: str) -> int: Returns the sum of the values of characters that appear more than once. >>> sum_of_repeated_chars(\\"abacabad\\") 9 >>> sum_of_repeated_chars(\\"abcdefg\\") 0 >>> sum_of_repeated_chars(\\"aabbcc\\") 6 >>> sum_of_repeated_chars(\\"a\\") 0 >>> sum_of_repeated_chars(\\"abcabc\\") 6 >>> sum_of_repeated_chars(\\"aabbccddeeff\\") 21","solution":"def sum_of_repeated_chars(s): Returns the sum of the values of characters that appear more than once. from collections import Counter # Calculate frequency of each character freq = Counter(s) # Calculate the total sum of values for characters that appear more than once total_sum = sum((ord(char) - ord('a') + 1) for char, count in freq.items() if count > 1) return total_sum"},{"question":"from math import comb def count_dominant_ways(n: int, k: int) -> int: Returns the number of ways to arrange tournament results so that exactly k teams are dominant. Args: n (int): Number of teams k (int): Number of dominant teams Returns: int: Number of ways to arrange the results Examples: >>> count_dominant_ways(4, 2) 6 >>> count_dominant_ways(3, 1) 3","solution":"from math import comb def count_dominant_ways(n, k): Returns the number of ways to arrange tournament results so that exactly k teams are dominant. if k > n: return 0 # Number of matches each team plays matches_per_team = n - 1 # Minimum wins required to be dominant min_wins_to_be_dominant = (matches_per_team // 2) + 1 # Combination C(n, k) to choose which k teams will be dominant return comb(n, k) * 1 print(count_dominant_ways(4, 2)) # Example use case"},{"question":"def final_time_after_ticks(t: int, test_cases: List[Tuple[int, int]]) -> List[str]: Determine the final time shown on the clock after n ticks, where the time is given by the numbers on the hour and minute rings. :param t: int - number of test cases :param test_cases: List of tuples - each containing two integers n (total number of ticks) and m (speed multiplier for the minute ring) :return: List of strings - each representing the final time in format \\"H:M\\" Example: >>> final_time_after_ticks(3, [(5, 3), (12, 7), (25, 4)]) ['5:3', '12:12', '1:4'] >>> final_time_after_ticks(1, [(1, 1)]) ['1:1'] >>> final_time_after_ticks(1, [(24, 2)]) ['12:12'] from typing import List, Tuple import pytest def test_final_time_after_ticks(): assert final_time_after_ticks(3, [(5, 3), (12, 7), (25, 4)]) == [\\"5:3\\", \\"12:12\\", \\"1:4\\"] assert final_time_after_ticks(1, [(1, 1)]) == [\\"1:1\\"] assert final_time_after_ticks(1, [(24, 2)]) == [\\"12:12\\"] assert final_time_after_ticks(1, [(36, 11)]) == [\\"12:12\\"] assert final_time_after_ticks(2, [(123456789, 5), (987654321, 9)]) == [\\"9:9\\", \\"9:9\\"] # Boundary test with maximum ticks assert final_time_after_ticks(1, [(10**9, 4)]) == [\\"4:4\\"]","solution":"def final_time_after_ticks(t, test_cases): results = [] for n, m in test_cases: hour_ring_position = (n % 12) if hour_ring_position == 0: hour_ring_position = 12 minute_ring_position = (n * m) % 12 if minute_ring_position == 0: minute_ring_position = 12 results.append(f\\"{hour_ring_position}:{minute_ring_position}\\") return results"},{"question":"from typing import List def unique_paths_with_obstacles(grid: List[List[int]]) -> int: Determine how many unique paths are available for the robot to reach the bottom-right corner of the grid from the top-left corner, considering the obstacles. Args: grid (List[List[int]]): A 2D array representing the grid where 0 indicates an open cell and 1 indicates an obstacle. Returns: int: The number of unique paths from the top-left corner to the bottom-right corner, avoiding obstacles. If there is no such path, return 0. Examples: >>> unique_paths_with_obstacles([ ... [0, 0, 0], ... [0, 1, 0], ... [0, 0, 0] ... ]) 2 >>> unique_paths_with_obstacles([ ... [0, 1, 0], ... [1, 0, 0], ... [0, 0, 0] ... ]) 0 >>> unique_paths_with_obstacles([ ... [0, 0], ... [0, 0] ... ]) 2 Unit Test: from solution import unique_paths_with_obstacles def test_no_obstacles_small_grid(): grid = [ [0, 0], [0, 0] ] assert unique_paths_with_obstacles(grid) == 2 def test_obstacles_block_all_paths(): grid = [ [0, 1, 0], [1, 0, 0], [0, 0, 0] ] assert unique_paths_with_obstacles(grid) == 0 def test_single_possible_path(): grid = [ [0, 0, 0], [0, 1, 0], [0, 0, 0] ] assert unique_paths_with_obstacles(grid) == 2 def test_one_cell_with_obstacle(): grid = [[1]] assert unique_paths_with_obstacles(grid) == 0 def test_large_grid_no_obstacles(): grid = [ [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0] ] assert unique_paths_with_obstacles(grid) == 20","solution":"def unique_paths_with_obstacles(grid): m, n = len(grid), len(grid[0]) if grid[0][0] == 1 or grid[m-1][n-1] == 1: return 0 dp = [[0] * n for _ in range(m)] dp[0][0] = 1 for i in range(m): for j in range(n): if grid[i][j] == 1: dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[m-1][n-1]"},{"question":"def is_match(text: str, pattern: str) -> bool: Check if the pattern matches the text string with wildcards: '?' which matches any single character '*' which matches any sequence of characters (including the empty sequence) Returns \\"YES\\" if the pattern matches the text; otherwise, returns \\"NO\\". >>> is_match(\\"abcde\\", \\"a*e\\") \\"YES\\" >>> is_match(\\"abcde\\", \\"a*d\\") \\"NO\\" >>> is_match(\\"abcde\\", \\"a?c*e\\") \\"YES\\" pass def test_is_match(): # Capture the standard output import io import sys from contextlib import redirect_stdout f = io.StringIO() with redirect_stdout(f): is_match('abcde', 'a*e') out = f.getvalue().strip() assert out == \\"YES\\" f = io.StringIO() with redirect_stdout(f): is_match('abcde', 'a*d') out = f.getvalue().strip() assert out == \\"NO\\" f = io.StringIO() with redirect_stdout(f): is_match('abcde', 'a?c*e') out = f.getvalue().strip() assert out == \\"YES\\" f = io.StringIO() with redirect_stdout(f): is_match('abcde', 'a?c*d') out = f.getvalue().strip() assert out == \\"NO\\" f = io.StringIO() with redirect_stdout(f): is_match('abcdef', 'a*f') out = f.getvalue().strip() assert out == \\"YES\\" f = io.StringIO() with redirect_stdout(f): is_match('abcdef', '*') out = f.getvalue().strip() assert out == \\"YES\\" f = io.StringIO() with redirect_stdout(f): is_match('abcdef', '******') out = f.getvalue().strip() assert out == \\"YES\\" f = io.StringIO() with redirect_stdout(f): is_match('abcdef', 'abcd?') out = f.getvalue().strip() assert out == \\"NO\\" f = io.StringIO() with redirect_stdout(f): is_match('abcdef', 'abcd?f') out = f.getvalue().strip() assert out == \\"YES\\"","solution":"def is_match(text, pattern): Returns YES if the given pattern matches the text with wildcards: '?' which matches any single character '*' which matches any sequence of characters (including the empty sequence). Otherwise returns NO. # Lengths of text and pattern t_len = len(text) p_len = len(pattern) # DP table where dp[i][j] means if text[0:i] matches pattern[0:j] dp = [[False] * (p_len + 1) for _ in range(t_len + 1)] # Empty text and empty pattern are a match dp[0][0] = True # Fill for patterns with * for j in range(1, p_len + 1): if pattern[j - 1] == '*': dp[0][j] = dp[0][j - 1] # Fill the dp table for i in range(1, t_len + 1): for j in range(1, p_len + 1): if pattern[j - 1] == '*': dp[i][j] = dp[i - 1][j] or dp[i][j - 1] elif pattern[j - 1] == '?' or text[i - 1] == pattern[j - 1]: dp[i][j] = dp[i - 1][j - 1] if dp[t_len][p_len]: print(\\"YES\\") else: print(\\"NO\\")"},{"question":"def max_non_adjacent_sum(arr: List[int]) -> int: Given an integer array \`arr\`, find the maximum possible sum of a subsequence of \`arr\` such that no two elements of the subsequence are adjacent in the original array. >>> max_non_adjacent_sum([3, 2, 5, 10, 7]) 15 >>> max_non_adjacent_sum([-1, -2, -3, -4]) 0","solution":"def max_non_adjacent_sum(arr): if not arr: return 0 incl = 0 excl = 0 for num in arr: new_excl = max(incl, excl) incl = excl + num excl = new_excl return max(incl, excl)"},{"question":"from typing import List def longest_equal_ab_substring(s: str) -> int: Function to find the length of the longest contiguous substring that contains an equal number of 'A's and 'B's. pass def longest_equal_ab_substring_for_tests(t: int, test_cases: List[str]) -> List[int]: For each test case, determine the length of the longest contiguous substring that contains an equal number of 'A's and 'B's. >>> t = 3 >>> test_cases = [\\"ABAB\\", \\"AAABBB\\", \\"ABBA\\"] >>> longest_equal_ab_substring_for_tests(t, test_cases) [4, 6, 4] pass def test_longest_equal_ab_substring(): assert longest_equal_ab_substring(\\"ABAB\\") == 4 assert longest_equal_ab_substring(\\"AAABBB\\") == 6 assert longest_equal_ab_substring(\\"ABBA\\") == 4 assert longest_equal_ab_substring(\\"AAAA\\") == 0 assert longest_equal_ab_substring(\\"AABBAB\\") == 6 assert longest_equal_ab_substring(\\"A\\") == 0 assert longest_equal_ab_substring(\\"B\\") == 0 assert longest_equal_ab_substring(\\"AABBBAAABBBAAABBBAAAA\\") == 18 def test_longest_equal_ab_substring_for_tests(): t = 3 test_cases = [\\"ABAB\\", \\"AAABBB\\", \\"ABBA\\"] expected = [4, 6, 4] assert longest_equal_ab_substring_for_tests(t, test_cases) == expected t = 2 test_cases = [\\"BBBB\\", \\"AAAABBBB\\"] expected = [0, 8] assert longest_equal_ab_substring_for_tests(t, test_cases) == expected","solution":"def longest_equal_ab_substring(s): Function to find the length of the longest contiguous substring that contains an equal number of 'A's and 'B's. max_len = 0 balance = 0 balance_dict = {0: -1} for i, char in enumerate(s): if char == 'A': balance += 1 else: balance -= 1 if balance in balance_dict: max_len = max(max_len, i - balance_dict[balance]) else: balance_dict[balance] = i return max_len def longest_equal_ab_substring_for_tests(t, test_cases): results = [] for s in test_cases: results.append(longest_equal_ab_substring(s)) return results"},{"question":"def is_valid_water_slide(n: int, heights: List[int]) -> str: Determine whether the water slide meets the safety requirements. Args: n : int : The number of segments. heights : List[int] : The heights of each segment above ground level. Returns: str : 'Valid' if the water slide meets safety requirements, otherwise 'Invalid'. Examples: >>> is_valid_water_slide(5, [10, 8, 8, 5, 3]) 'Valid' >>> is_valid_water_slide(4, [3, 3, 4, 2]) 'Invalid' from typing import List def test_valid_slides(): assert is_valid_water_slide(5, [10, 8, 8, 5, 3]) == 'Valid' assert is_valid_water_slide(3, [7, 7, 1]) == 'Valid' assert is_valid_water_slide(2, [5, 5]) == 'Valid' assert is_valid_water_slide(1, [10000]) == 'Valid' def test_invalid_slides(): assert is_valid_water_slide(4, [3, 3, 4, 2]) == 'Invalid' assert is_valid_water_slide(6, [12, 10, 11, 9, 8, 7]) == 'Invalid' def test_mixed_cases(): assert is_valid_water_slide(4, [5, 5, 5, 5]) == 'Valid' assert is_valid_water_slide(3, [0, 0, 0]) == 'Valid' assert is_valid_water_slide(5, [5, 5, 5, 6, 5]) == 'Invalid'","solution":"def is_valid_water_slide(n, heights): Returns 'Valid' if water slide meets safety requirements, else 'Invalid'. for i in range(n - 1): if heights[i + 1] > heights[i]: return 'Invalid' return 'Valid'"},{"question":"def find_distinct_groups(T: int, test_cases: List[Tuple[int, int, List[Tuple[int, int]]]]) -> List[int]: Count the number of distinct groups of employees connected directly or indirectly via friendships. Args: T (int): Number of test cases. test_cases (List[Tuple[int, int, List[Tuple[int, int]]]]): A list where each element is a tuple containing: - an integer N representing the number of employees - an integer M representing the number of friendships - a list of tuples where each tuple contains two integers u and v representing a pair of employees who are friends Returns: List[int]: A list of integers, each representing the number of distinct groups of employees for the corresponding test case. >>> find_distinct_groups(2, [(4, 2, [(1, 2), (2, 3)]), (5, 0, [])]) [2, 5] >>> find_distinct_groups(1, [(5, 0, [])]) [5] >>> find_distinct_groups(1, [(4, 3, [(1, 2), (2, 3), (3, 4)])]) [1] >>> find_distinct_groups(1, [(6, 3, [(1, 2), (3, 4), (5, 6)])]) [3] >>> find_distinct_groups(1, [(100, 0, [])]) [100] pass","solution":"def find_parent(parent, i): if parent[i] == i: return i parent[i] = find_parent(parent, parent[i]) return parent[i] def union(parent, rank, x, y): root_x = find_parent(parent, x) root_y = find_parent(parent, y) if root_x != root_y: if rank[root_x] > rank[root_y]: parent[root_y] = root_x elif rank[root_x] < rank[root_y]: parent[root_x] = root_y else: parent[root_y] = root_x rank[root_x] += 1 def count_distinct_groups(T, test_cases): results = [] for i in range(T): N, M, friendships = test_cases[i] parent = [i for i in range(N)] rank = [0] * N for u, v in friendships: union(parent, rank, u - 1, v - 1) distinct_groups = len(set(find_parent(parent, i) for i in range(N))) results.append(distinct_groups) return results"},{"question":"def max_tourists(n: int, paths: List[int], tourists: List[int]) -> int: Calculate the maximum number of tourists that can be brought to the main point (point 1) by moving cars along the provided paths optimally. Args: n (int): The number of jumping points. paths (List[int]): The one-way paths from the jumping point pi to the jumping point i. tourists (List[int]): The number of tourists at each jumping point. Returns: int: The maximum number of tourists that can be brought to point 1. >>> max_tourists(5, [1, 1, 2, 3], [4, 5, 1, 3, 2]) 15 >>> max_tourists(4, [1, 2, 3], [7, 5, 4, 2]) 18 >>> max_tourists(3, [1, 1], [0, 0, 0]) 0 >>> max_tourists(3, [1, 1], [10, 0, 0]) 10 >>> max_tourists(5, [1, 2, 3, 4], [1, 1, 1, 1, 1]) 5 >>> max_tourists(6, [1, 1, 2, 2, 3], [5, 10, 15, 5, 20, 25]) 80 pass","solution":"def max_tourists(n, paths, tourists): from collections import defaultdict # Create adjacency list for the tree tree = defaultdict(list) for i in range(2, n+1): tree[paths[i-2]].append(i) # DFS function to aggregate tourists def dfs(node): total = tourists[node - 1] for child in tree[node]: total += dfs(child) return total # Calculate total tourists that can be brought to the main point (point 1) return dfs(1)"},{"question":"def max_fruits(P: int, Q: int, Y: List[int]) -> int: Returns the maximum number of fruits that can be collected. Parameters: P (int): Number of plots. Q (int): Total number of plants. Y (list of int): List of productivity rates of each plot. Returns: int: Maximum number of fruits that can be collected. >>> max_fruits(3, 7, [5, 3, 9]) 63 >>> max_fruits(1, 1, [1000]) 1000 from solution import max_fruits def test_max_fruits_example(): assert max_fruits(3, 7, [5, 3, 9]) == 63 def test_max_fruits_single_plot(): assert max_fruits(1, 1, [1000]) == 1000 def test_max_fruits_more_plants_than_needed(): assert max_fruits(2, 5, [10, 20]) == 100 def test_max_fruits_equal_plots_and_plants(): assert max_fruits(3, 3, [1, 2, 3]) == 9 def test_max_fruits_no_plants(): assert max_fruits(3, 0, [5, 3, 9]) == 0 def test_max_fruits_no_plots(): assert max_fruits(0, 5, []) == 0 def test_max_fruits_all_same_productivity(): assert max_fruits(5, 5, [5, 5, 5, 5, 5]) == 25 def test_max_fruits_large_case(): P = 100000 Q = 100000 Y = [1] * P assert max_fruits(P, Q, Y) == 100000","solution":"def max_fruits(P, Q, Y): Returns the maximum number of fruits that can be collected. Parameters: P (int): Number of plots. Q (int): Total number of plants. Y (list of int): List of productivity rates of each plot. Returns: int: Maximum number of fruits that can be collected. Y.sort(reverse=True) max_fruits = 0 for rate in Y: if Q <= 0: break max_fruits += rate * Q Q = 0 return max_fruits"},{"question":"def extractable_concentration(datasets: List[List[Tuple[int, int]]]) -> List[str]: Calculate the maximum concentration of extractable compound for each pair of test tubes. For each pair, if neither Tube A nor Tube B exceeds a concentration of 10,000 units, return the maximum extractable concentration. If either tube exceeds this limit, return \\"exceeds limit\\". Args: datasets: A list of datasets, where each dataset contains pairs of concentration amounts (Tube A, Tube B). Returns: A list of strings representing the maximum extractable concentration or \\"exceeds limit\\" for each pair. >>> extractable_concentration([[(5000, 8000), (15000, 2000), (10000, 10000), (5000, 12000), (20000, 5000)]]) [\\"13000\\", \\"exceeds limit\\", \\"20000\\", \\"exceeds limit\\", \\"exceeds limit\\"] >>> extractable_concentration([[(1, 2), (100, 200), (9999, 9999), (0, 0), (10000, 0)]]) [\\"3\\", \\"300\\", \\"19998\\", \\"0\\", \\"10000\\"]","solution":"def extractable_concentration(datasets): results = [] for dataset in datasets: for conc in dataset: a, b = conc if a > 10000 or b > 10000: results.append(\\"exceeds limit\\") else: results.append(str(a + b)) return results"},{"question":"from typing import List, Tuple def process_queries(potions: List[Tuple[str, int]], queries: List[Tuple[str, int]]) -> List[int]: Process the queries to determine the number of potions of the given type that have at least the specified strength. Args: potions (List[Tuple[str, int]]): A list of tuples where each tuple contains the type and the strength of a potion. queries (List[Tuple[str, int]]): A list of tuples where each tuple contains the type and minimum strength for a query. Returns: List[int]: A list of integers representing the number of potions satisfying each query. Example: >>> process_queries([(\\"healing\\", 50), (\\"strength\\", 100), (\\"healing\\", 75), (\\"strength\\", 200), (\\"mana\\", 30)], [(\\"healing\\", 60), (\\"strength\\", 150), (\\"mana\\", 10)]) [1, 1, 1] >>> process_queries([], [(\\"healing\\", 60)]) [0] >>> process_queries([(\\"healing\\", 50)], [(\\"strength\\", 100)]) [0] >>> process_queries([(\\"healing\\", 50), (\\"healing\\", 60), (\\"healing\\", 70), (\\"healing\\", 55)], [(\\"healing\\", 55)]) [3] >>> process_queries([(\\"strength\\", 1000000000), (\\"strength\\", 999999999)], [(\\"strength\\", 999999999)]) [2] >>> process_queries([(\\"healing\\", 50)], [(\\"mana\\", 30)]) [0]","solution":"def process_queries(potions, queries): from collections import defaultdict import bisect # Create a dictionary to store lists of strengths for each potion type potion_dict = defaultdict(list) # Populate the dictionary with potion types and their strengths for potion_type, strength in potions: potion_dict[potion_type].append(strength) # Sort the strengths for each potion type for key in potion_dict: potion_dict[key].sort() # Function to count potions with required strength using binary search def count_potions(potion_type, min_strength): if potion_type not in potion_dict: return 0 strengths = potion_dict[potion_type] idx = bisect.bisect_left(strengths, min_strength) return len(strengths) - idx # Process each query and apply the counting function results = [] for query_type, min_strength in queries: results.append(count_potions(query_type, min_strength)) return results # Example usage potions = [(\\"healing\\", 50), (\\"strength\\", 100), (\\"healing\\", 75), (\\"strength\\", 200), (\\"mana\\", 30)] queries = [(\\"healing\\", 60), (\\"strength\\", 150), (\\"mana\\", 10)] result = process_queries(potions, queries) print(result) # Output: [1, 1, 1]"},{"question":"def count_symmetric_matrices(matrices): This function takes a list of binary matrices and returns the count of symmetric matrices among them. >>> count_symmetric_matrices([ [ [1, 0, 1], [0, 1, 0], [1, 0, 1] ], [ [1, 0], [0, 1] ], [ [1, 1], [0, 1] ] ]) == 2 >>> count_symmetric_matrices([ [ [1, 0, 1], [1, 1, 0], [1, 0, 1] ], [ [1, 0, 0], [0, 1, 0], [1, 0, 1] ] ]) == 0 >>> count_symmetric_matrices([ [ [1] ], [ [0] ], [ [1, 0], [0, 1] ], [ [0, 0], [0, 0] ] ]) == 4 >>> count_symmetric_matrices([ [ [1, 0], [0, 1] ], [ [1, 1, 1], [1, 1, 1], [1, 0, 1] ], [ [0, 0, 0], [0, 0, 0], [0, 0, 0] ] ]) == 2 >>> count_symmetric_matrices([ [[1 if i == j else 0 for i in range(50)] for j in range(50)], [ [i % 2 for i in range(50)] for _ in range(50) ] ]) == 1","solution":"def count_symmetric_matrices(matrices): This function takes a list of binary matrices and returns the count of symmetric matrices among them. def is_symmetric(matrix): Helper function to check if a given matrix is symmetric. n = len(matrix) for i in range(n): for j in range(i, n): # Only need to check upper triangle if matrix[i][j] != matrix[j][i]: return False return True count = 0 for matrix in matrices: if is_symmetric(matrix): count += 1 return count"},{"question":"def count_exact_attempts(participant_attempts: List[int], t: int) -> int: This function returns the number of participants who attempted exactly t problems. Parameters: participant_attempts (list of int): List where each element represents the number of problems attempted by a participant. t (int): The exact number of problems to check for. Returns: int: Number of participants who attempted exactly t problems. Examples: >>> count_exact_attempts([1, 2, 3, 2, 3], 2) 2 >>> count_exact_attempts([4, 3, 4, 4], 4) 3","solution":"def count_exact_attempts(participant_attempts, t): This function returns the number of participants who attempted exactly t problems. Parameters: participant_attempts (list of int): List where each element represents the number of problems attempted by a participant. t (int): The exact number of problems to check for. Returns: int: Number of participants who attempted exactly t problems. return participant_attempts.count(t)"},{"question":"def is_shift_scheduling_possible(M: int, employee_names: List[str], availability: List[List[str]]) -> str: Determine if it is possible to assign shifts to all employees such that no two employees with overlapping availability are assigned the same shift. :param M: Number of employees. :param employee_names: List of employee names. :param availability: List of availability lists for each employee. :return: 'Yes' if possible to schedule, 'No' otherwise. >>> is_shift_scheduling_possible(3, [\\"Alice\\", \\"Bob\\", \\"Charlie\\"], [[\\"M\\", \\"T\\"], [\\"T\\", \\"W\\", \\"R\\"], [\\"M\\", \\"W\\"]]) \\"No\\" >>> is_shift_scheduling_possible(3, [\\"Alice\\", \\"Bob\\", \\"Charlie\\"], [[\\"M\\"], [\\"T\\"], [\\"W\\"]]) \\"Yes\\" >>> is_shift_scheduling_possible(2, [\\"Alice\\", \\"Bob\\"], [[\\"M\\", \\"W\\", \\"F\\"], [\\"T\\", \\"R\\", \\"S\\"]]) \\"Yes\\" >>> is_shift_scheduling_possible(4, [\\"Alice\\", \\"Bob\\", \\"Charlie\\", \\"David\\"], [[\\"M\\", \\"T\\"], [\\"T\\", \\"W\\"], [\\"W\\", \\"R\\"], [\\"R\\", \\"F\\"]]) \\"No\\" >>> is_shift_scheduling_possible(1, [\\"Alice\\"], [[\\"M\\", \\"T\\", \\"W\\"]]) \\"Yes\\"","solution":"def is_shift_scheduling_possible(M, employee_names, availability): Determine if it is possible to assign shifts to all employees such that no two employees with overlapping availability are assigned the same shift. :param M: Number of employees. :param employee_names: List of employee names. :param availability: List of availability lists for each employee. :return: 'Yes' if possible to schedule, 'No' otherwise. from collections import defaultdict # A dictionary to hold the days and the list of employees available on each day days_schedule = defaultdict(list) # Iterate through each employee's availability for i in range(M): for day in availability[i]: days_schedule[day].append(employee_names[i]) # Check for each day if there's more than one employee available for day in days_schedule: if len(days_schedule[day]) > 1: return \\"No\\" return \\"Yes\\""},{"question":"def length_of_lis(numbers: List[int]) -> int: Determine the length of the longest strictly increasing subsequence in the list. A subsequence is derived by deleting some or none of the elements in the array without changing the order of the remaining elements. A strictly increasing subsequence is one in which each subsequent element is strictly greater than the one before it. Constraints: - 1 <= N <= 10^5 - 1 <= A_i <= 10^9 >>> length_of_lis([5, 2, 8, 3, 6, 7]) 4 >>> length_of_lis([2, 6, 8, 3, 4, 5]) 4 >>> length_of_lis([1]) 1 >>> length_of_lis([5, 4, 3, 2, 1]) 1 >>> length_of_lis([10, 22, 9, 33, 21, 50, 41, 60, 80]) 6 from solution import length_of_lis def test_example_1(): assert length_of_lis([5, 2, 8, 6, 3, 6]) == 3 def test_example_2(): assert length_of_lis([1, 7, 2, 8, 3]) == 3 def test_example_3(): assert length_of_lis([5, 4, 3, 2, 1]) == 1 def test_single_element(): assert length_of_lis([10]) == 1 def test_all_elements_same(): assert length_of_lis([2, 2, 2, 2, 2]) == 1 def test_strictly_increasing(): assert length_of_lis([1, 2, 3, 4, 5]) == 5 def test_large_numbers(): assert length_of_lis([1000000000, 999999999, 999999998]) == 1 def test_empty_list(): assert length_of_lis([]) == 0","solution":"def length_of_lis(numbers): if not numbers: return 0 n = len(numbers) dp = [1] * n for i in range(1, n): for j in range(i): if numbers[i] > numbers[j]: dp[i] = max(dp[i], dp[j] + 1) return max(dp)"},{"question":"from typing import List def isToeplitzMatrix(matrix: List[List[int]]) -> str: Determine if a given matrix is a Toeplitz matrix. A matrix is Toeplitz if every diagonal from top-left to bottom-right has the same elements. Args: matrix (List[List[int]]): The input matrix represented as a list of lists. Returns: str: \\"YES\\" if the matrix is Toeplitz, otherwise \\"NO\\". Examples: >>> isToeplitzMatrix([[1, 2, 3, 4], [5, 1, 2, 3], [9, 5, 1, 2]]) == \\"YES\\" >>> isToeplitzMatrix([[1, 2, 3, 4], [5, 1, 9, 3], [9, 5, 1, 2]]) == \\"NO\\"","solution":"from typing import List def isToeplitzMatrix(matrix: List[List[int]]) -> str: rows = len(matrix) cols = len(matrix[0]) for r in range(rows - 1): for c in range(cols - 1): if matrix[r][c] != matrix[r + 1][c + 1]: return \\"NO\\" return \\"YES\\""},{"question":"class Warehouse: A class to manage warehouse inventory including stocking, dispatching, and reporting. Methods: - __init__(self): Initializes the warehouse with no products. - stock_product(self, product_id: str, product_type: str, quantity: int): Stocks a product in the warehouse. - dispatch_product(self, product_id: str, quantity: int): Dispatches a product from the warehouse. - report_inventory(self) -> int: Returns the total quantity of all products in the warehouse. Examples: >>> warehouse = Warehouse() >>> warehouse.stock_product(\\"P001\\", \\"Electronics\\", 100) >>> warehouse.stock_product(\\"P002\\", \\"Books\\", 50) >>> print(warehouse.report_inventory()) # Output: 150 >>> warehouse.dispatch_product(\\"P001\\", 30) >>> print(warehouse.report_inventory()) # Output: 120 >>> warehouse.dispatch_product(\\"P002\\", 50) >>> print(warehouse.report_inventory()) # Output: 70 >>> warehouse.dispatch_product(\\"P003\\", 10) # P003 does not exist, nothing happens >>> print(warehouse.report_inventory()) # Output: 70 >>> warehouse.stock_product(\\"P001\\", \\"Electronics\\", 20) >>> print(warehouse.report_inventory()) # Output: 90 def __init__(self): pass def stock_product(self, product_id: str, product_type: str, quantity: int): pass def dispatch_product(self, product_id: str, quantity: int): pass def report_inventory(self) -> int: pass # Unit Tests def test_stock_product(): warehouse = Warehouse() warehouse.stock_product(\\"P001\\", \\"Electronics\\", 100) assert warehouse.report_inventory() == 100 warehouse.stock_product(\\"P002\\", \\"Books\\", 50) assert warehouse.report_inventory() == 150 warehouse.stock_product(\\"P001\\", \\"Electronics\\", 50) assert warehouse.report_inventory() == 200 def test_dispatch_product(): warehouse = Warehouse() warehouse.stock_product(\\"P001\\", \\"Electronics\\", 100) warehouse.dispatch_product(\\"P001\\", 30) assert warehouse.report_inventory() == 70 warehouse.dispatch_product(\\"P001\\", 70) assert warehouse.report_inventory() == 0 warehouse.dispatch_product(\\"P001\\", 1) assert warehouse.report_inventory() == 0 def test_report_inventory(): warehouse = Warehouse() assert warehouse.report_inventory() == 0 warehouse.stock_product(\\"P001\\", \\"Electronics\\", 100) warehouse.stock_product(\\"P002\\", \\"Books\\", 50) assert warehouse.report_inventory() == 150 def test_dispatch_non_existent_product(): warehouse = Warehouse() warehouse.dispatch_product(\\"P001\\", 10) assert warehouse.report_inventory() == 0 def test_dispatch_insufficient_quantity(): warehouse = Warehouse() warehouse.stock_product(\\"P001\\", \\"Electronics\\", 100) warehouse.dispatch_product(\\"P001\\", 150) assert warehouse.report_inventory() == 100","solution":"class Warehouse: def __init__(self): self.inventory = {} self.total_quantity = 0 def stock_product(self, product_id: str, product_type: str, quantity: int): if product_id in self.inventory: self.inventory[product_id]['quantity'] += quantity else: self.inventory[product_id] = {'type': product_type, 'quantity': quantity} self.total_quantity += quantity def dispatch_product(self, product_id: str, quantity: int): if product_id in self.inventory and self.inventory[product_id]['quantity'] >= quantity: self.inventory[product_id]['quantity'] -= quantity self.total_quantity -= quantity if self.inventory[product_id]['quantity'] == 0: del self.inventory[product_id] def report_inventory(self) -> int: return self.total_quantity"},{"question":"from typing import List def find_highest_scores(student_data: List[str]) -> dict: Determine the student with the highest score in each subject. Args: student_data: List of strings where each string is in the format \\"Name Subject Score\\". Returns: A dictionary where the keys are subjects and the values are lists of tuples (Name, Score) of students having the highest score in that subject. Example: >>> find_highest_scores([\\"Alice Math 90\\", \\"Bob Math 95\\", \\"Charlie Math 85\\"]) {'Math': [('Bob', 95)]} pass def format_output(results: dict) -> str: Format the dictionary of results into the required output string. Args: results: A dictionary with subjects as keys and lists of tuples (Name, Score) as values. Returns: A formatted string in the format \\"Subject: Name1 (Score), Name2 (Score), ...\\". Example: >>> format_output({'Math': [('Bob', 95), ('David', 95)]}) 'Math: Bob (95), David (95)' pass def main(input_data: List[str]) -> str: The main function to find and print the highest scoring students for each subject. Args: input_data: List of input strings with the first element being the number of students and the rest being \\"Name Subject Score\\" strings. Returns: A formatted string with the highest scoring students for each subject. Example: >>> main([\\"6\\", \\"Alice Math 90\\", \\"Bob Math 95\\", \\"Charlie History 85\\", \\"David Math 95\\", \\"Eve History 85\\", \\"Frank Science 88\\"]) 'Math: Bob (95), David (95)nHistory: Charlie (85), Eve (85)nScience: Frank (88)' pass def test_single_subject_no_ties(): input_data = [ \\"3\\", \\"Alice Math 90\\", \\"Bob Math 95\\", \\"Charlie Math 85\\", ] assert main(input_data) == \\"Math: Bob (95)\\" def test_single_subject_with_ties(): input_data = [ \\"4\\", \\"Alice Math 90\\", \\"Bob Math 95\\", \\"Charlie Math 95\\", \\"David Math 85\\", ] assert main(input_data) == \\"Math: Bob (95), Charlie (95)\\" def test_multiple_subjects_mixed(): input_data = [ \\"6\\", \\"Alice Math 90\\", \\"Bob Math 95\\", \\"Charlie History 85\\", \\"David Math 95\\", \\"Eve History 85\\", \\"Frank Science 88\\", ] assert main(input_data) == \\"Math: Bob (95), David (95)nHistory: Charlie (85), Eve (85)nScience: Frank (88)\\" def test_single_student_multiple_subjects(): input_data = [ \\"3\\", \\"Alice Math 90\\", \\"Alice History 85\\", \\"Alice Science 88\\", ] assert main(input_data) == \\"Math: Alice (90)nHistory: Alice (85)nScience: Alice (88)\\" def test_all_students_same_score(): input_data = [ \\"3\\", \\"Alice Math 90\\", \\"Bob Math 90\\", \\"Charlie Math 90\\", ] assert main(input_data) == \\"Math: Alice (90), Bob (90), Charlie (90)\\"","solution":"def find_highest_scores(student_data): from collections import defaultdict scores = defaultdict(list) highest_scores = {} for data in student_data: name, subject, score = data.rsplit(maxsplit=2) score = int(score) scores[subject].append((name, score)) results = {} for subject, records in scores.items(): max_score = max(score for _, score in records) results[subject] = [(name, score) for name, score in records if score == max_score] return results def format_output(results): output = [] for subject, students in results.items(): formatted_students = \\", \\".join(f\\"{name} ({score})\\" for name, score in students) output.append(f\\"{subject}: {formatted_students}\\") return \\"n\\".join(output) def main(input_data): n = int(input_data[0]) student_data = input_data[1:] results = find_highest_scores(student_data) return format_output(results)"},{"question":"def minDistance(s1: str, s2: str) -> int: Compute the minimum number of operations required to transform s1 into s2. Operations allowed: insert a character, delete a character, replace a character. >>> minDistance(\\"horse\\", \\"ros\\") 3 >>> minDistance(\\"abc\\", \\"abc\\") 0 >>> minDistance(\\"abc\\", \\"abcd\\") 1 >>> minDistance(\\"abcd\\", \\"abc\\") 1 >>> minDistance(\\"abc\\", \\"abd\\") 1 >>> minDistance(\\"intention\\", \\"execution\\") 5 >>> minDistance(\\"\\", \\"abc\\") 3 >>> minDistance(\\"abc\\", \\"\\") 3 >>> minDistance(\\"\\", \\"\\") 0","solution":"def minDistance(s1, s2): Compute the minimum number of operations required to transform s1 into s2. Operations allowed: insert a character, delete a character, replace a character. m, n = len(s1), len(s2) # Create a DP table to memoize results of subproblems dp = [[0] * (n + 1) for _ in range(m + 1)] # Initialize the DP table for i in range(m + 1): for j in range(n + 1): if i == 0: dp[i][j] = j # If s1 is empty, insert all characters of s2 elif j == 0: dp[i][j] = i # If s2 is empty, delete all characters of s1 elif s1[i - 1] == s2[j - 1]: dp[i][j] = dp[i - 1][j - 1] # Characters are the same, no operation needed else: dp[i][j] = 1 + min(dp[i - 1][j], # Delete character from s1 dp[i][j - 1], # Insert character into s1 dp[i - 1][j - 1]) # Replace character return dp[m][n]"},{"question":"from typing import List def count_subsequences(S1: str, S2: str) -> int: Given two strings S1 and S2, your task is to find the number of times the second string (S2) appears as a subsequence in the first string (S1). A subsequence is a sequence that can be derived from another sequence by deleting some or no elements without changing the order of the remaining elements. Args: S1: str - the string in which to find subsequences S2: str - the string to find as a subsequence Returns: int - the number of times S2 appears as a subsequence in S1 Examples: >>> count_subsequences(\\"rabbbit\\", \\"rabbit\\") 3 >>> count_subsequences(\\"rabbbit\\", \\"\\") 1 >>> count_subsequences(\\"\\", \\"rabbit\\") 0 >>> count_subsequences(\\"abcdef\\", \\"gh\\") 0 >>> count_subsequences(\\"rabbit\\", \\"rabbit\\") 1 >>> count_subsequences(\\"aaaaa\\", \\"a\\") 5 >>> S1 = \\"a\\" * 1000 >>> S2 = \\"a\\" * 1000 >>> count_subsequences(S1, S2) 1","solution":"def count_subsequences(S1, S2): Returns the number of times the string S2 appears as a subsequence in the string S1. m, n = len(S1), len(S2) if n == 0: return 1 if m == 0: return 0 dp = [[0] * (n + 1) for _ in range(m + 1)] for i in range(m + 1): dp[i][0] = 1 for i in range(1, m + 1): for j in range(1, n + 1): if S1[i - 1] == S2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j] else: dp[i][j] = dp[i - 1][j] return dp[m][n]"},{"question":"import heapq from typing import List, Tuple def dijkstra(n: int, edges: List[Tuple[int, int, int]], start: int, end: int) -> int: Determine the minimum travel time between a starting city and an ending city. >>> dijkstra(5, [(1, 2, 4), (1, 3, 2), (2, 3, 1), (2, 4, 7), (3, 4, 3), (4, 5, 1)], 1, 5) 6 >>> dijkstra(3, [(1, 2, 3), (2, 3, 1)], 1, 3) -1 # Your implementation here def test_dijkstra_example_1(): n = 5 m = 6 edges = [ (1, 2, 4), (1, 3, 2), (2, 3, 1), (2, 4, 7), (3, 4, 3), (4, 5, 1) ] start = 1 end = 5 assert dijkstra(n, edges, start, end) == 6 def test_dijkstra_example_2(): n = 3 m = 1 edges = [ (1, 2, 3) ] start = 1 end = 3 assert dijkstra(n, edges, start, end) == -1 def test_dijkstra_no_routes(): n = 4 m = 0 edges = [] start = 1 end = 4 assert dijkstra(n, edges, start, end) == -1 def test_dijkstra_single_city(): n = 1 m = 0 edges = [] start = 1 end = 1 assert dijkstra(n, edges, start, end) == 0 def test_dijkstra_direct_connection(): n = 2 m = 1 edges = [ (1, 2, 5) ] start = 1 end = 2 assert dijkstra(n, edges, start, end) == 5","solution":"import heapq def dijkstra(n, edges, start, end): graph = [[] for _ in range(n + 1)] for u, v, t in edges: graph[u].append((v, t)) graph[v].append((u, t)) # Priority queue to keep track of the minimum travel times pq = [(0, start)] travel_time = {i: float('inf') for i in range(1, n+1)} travel_time[start] = 0 while pq: curr_time, u = heapq.heappop(pq) if curr_time > travel_time[u]: continue for v, t in graph[u]: time = curr_time + t if time < travel_time[v]: travel_time[v] = time heapq.heappush(pq, (time, v)) return travel_time[end] if travel_time[end] != float('inf') else -1 # Example usage: n = 5 m = 6 edges = [ (1, 2, 4), (1, 3, 2), (2, 3, 1), (2, 4, 7), (3, 4, 3), (4, 5, 1) ] start = 1 end = 5 print(dijkstra(n, edges, start, end)) # Output should be 6"},{"question":"def max_histogram_area(heights: List[int]) -> int: Computes the largest rectangular area in a histogram represented by heights. :param heights: List[int] - heights array representing the histogram :return: int - largest rectangle area >>> max_histogram_area([2, 1, 5, 6, 2, 3]) 10 >>> max_histogram_area([1, 2, 3, 4, 5]) 9","solution":"def max_histogram_area(heights): Computes the largest rectangular area in a histogram represented by heights. :param heights: List[int] - heights array representing the histogram :return: int - largest rectangle area stack = [] max_area = 0 index = 0 while index < len(heights): if not stack or heights[stack[-1]] <= heights[index]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"def rearrange_array(arr: List[int]) -> List[int]: Rearranges the array such that elements at even indices are greater than their previous element and elements at odd indices are lesser than their previous element. >>> rearrange_array([4, 1, 3, 2, 5]) [1, 4, 2, 5, 3] >>> rearrange_array([10, 5, 6, 3, 8, 1]) [5, 10, 3, 6, 1, 8] # Implementation here from typing import List def test_single_element(): assert rearrange_array([1]) == [1] def test_two_elements(): assert rearrange_array([2, 1]) == [1, 2] assert rearrange_array([1, 2]) == [1, 2] def test_odd_elements(): arr = [4, 1, 3, 2, 5] result = rearrange_array(arr) assert result[0] < result[1] assert result[1] > result[2] assert result[2] < result[3] assert result[3] > result[4] def test_even_elements(): arr = [10, 5, 6, 3, 8, 1] result = rearrange_array(arr) assert result[0] < result[1] assert result[1] > result[2] assert result[2] < result[3] assert result[3] > result[4] assert result[4] < result[5] def test_all_same_elements(): assert rearrange_array([5, 5, 5, 5]) == [5, 5, 5, 5] def test_already_satisfying_sequence(): assert rearrange_array([1, 3, 2, 4, 3]) == [1, 3, 2, 4, 3] assert rearrange_array([1, 2, 1, 3, 2]) == [1, 2, 1, 3, 2]","solution":"def rearrange_array(arr): Rearranges the array such that elements at even indices are greater than their previous element and elements at odd indices are lesser than their previous element. for i in range(1, len(arr), 2): if arr[i] < arr[i - 1]: arr[i - 1], arr[i] = arr[i], arr[i - 1] if i + 1 < len(arr) and arr[i + 1] > arr[i]: arr[i + 1], arr[i] = arr[i], arr[i + 1] return arr"},{"question":"def possible_arrangement(t: int, test_cases: List[Tuple[Tuple[int, int], List[int]]]) -> List[str]: Determine if a possible arrangement of watches exists with the given constraints. The function takes the number of test cases and a list of test cases, where each test case contains the number of vintage watches, the minimum required absolute difference between consecutive watches, and the list of serial numbers of each watch. >>> t = 2 >>> test_cases = [ [(5, 2), [1, 3, 5, 7, 9]], [(4, 10), [10, 20, 30, 40]] ] >>> possible_arrangement(t, test_cases) [\\"Arrangement possiblen1 3 5 7 9\\", \\"Arrangement possiblen10 20 30 40\\"] >>> t = 1 >>> test_cases = [ [(5, 5), [1, 3, 5, 7, 9]], ] >>> possible_arrangement(t, test_cases) [\\"Arrangement not possible\\"] >>> t = 1 >>> test_cases = [ [(3, 2), [1, 5, 9]], ] >>> possible_arrangement(t, test_cases) [\\"Arrangement possiblen1 5 9\\"] >>> t = 1 >>> test_cases = [ [(3, 10), [1, 5, 9]], ] >>> possible_arrangement(t, test_cases) [\\"Arrangement not possible\\"] >>> t = 1 >>> serial_numbers = list(range(1000, 3000, 2)) >>> test_cases = [ [(len(serial_numbers), 1), serial_numbers], ] >>> possible_arrangement(t, test_cases) [f\\"Arrangement possiblen{' '.join(map(str, serial_numbers))}\\"] >>> t = 1 >>> serial_numbers = list(range(1000, 3000)) >>> test_cases = [ [(len(serial_numbers), 2), serial_numbers], ] >>> possible_arrangement(t, test_cases) [\\"Arrangement not possible\\"]","solution":"def possible_arrangement(t, test_cases): results = [] for i in range(t): n, k = test_cases[i][0] serial_numbers = sorted(test_cases[i][1]) valid = True for j in range(1, len(serial_numbers)): if abs(serial_numbers[j] - serial_numbers[j - 1]) < k: valid = False break if valid: results.append(f\\"Arrangement possiblen{' '.join(map(str, serial_numbers))}\\") else: results.append(\\"Arrangement not possible\\") return results"},{"question":"def sum_excluding_self(arr): Returns a list where each element is the sum of all elements in the original list excluding the element at the same index. Parameters: arr (list of int): The input list of integers. Returns: list of int: The transformed list. Examples: >>> sum_excluding_self([1, 2, 3, 4, 5]) [14, 13, 12, 11, 10] >>> sum_excluding_self([10, 20, 30]) [50, 40, 30]","solution":"def sum_excluding_self(arr): Returns a list where each element is the sum of all elements in the original list excluding the element at the same index. Parameters: arr (list of int): The input list of integers. Returns: list of int: The transformed list. total_sum = sum(arr) return [total_sum - x for x in arr]"},{"question":"def remove_adjacent_duplicates(s: str) -> str: Removes adjacent duplicate characters from the string \`s\` until no such removal is possible, and returns the resulting string. If the resulting string is empty, returns \\"Empty String\\". >>> remove_adjacent_duplicates('aaabccddd') 'abd' >>> remove_adjacent_duplicates('aa') 'Empty String' >>> remove_adjacent_duplicates('a') 'a' def process_test_cases(T: int, test_cases: List[str]) -> List[str]: Processes T test cases and returns a list of results after removing adjacent duplicates for each string. >>> process_test_cases(3, ['aaabccddd', 'aa', 'a']) ['abd', 'Empty String', 'a'] >>> process_test_cases(2, ['aabbcc', 'abc']) ['Empty String', 'abc']","solution":"def remove_adjacent_duplicates(s): Removes adjacent duplicate characters from the string \`s\` until no such removal is possible, and returns the resulting string. stack = [] for char in s: if stack and stack[-1] == char: stack.pop() else: stack.append(char) result = ''.join(stack) return result if result else \\"Empty String\\" def process_test_cases(T, test_cases): Processes T test cases and returns a list of results after removing adjacent duplicates for each string. results = [] for case in test_cases: results.append(remove_adjacent_duplicates(case)) return results"},{"question":"from collections import deque def lru_cache(n: int, q: int, queries: List[int]) -> List[int]: Simulate a least-recently-used (LRU) caching mechanism in a network system. Parameters: n (int): The number of unique data objects. q (int): The number of queries (accesses). queries (List[int]): The sequence of accesses. Returns: List[int]: The final contents of the cache from most-recently used to least-recently used objects. >>> lru_cache(3, 5, [2, 3, 2, 1, 2]) [2, 1, 3] >>> lru_cache(4, 6, [4, 3, 2, 1, 4, 2]) [2, 4, 1, 3] def test_lru_example_1(): assert lru_cache(3, 5, [2, 3, 2, 1, 2]) == [2, 1, 3] def test_lru_example_2(): assert lru_cache(4, 6, [4, 3, 2, 1, 4, 2]) == [2, 4, 1, 3] def test_lru_single_object(): assert lru_cache(1, 4, [1, 1, 1, 1]) == [1] def test_lru_all_unique_accesses(): assert lru_cache(2, 5, [1, 2, 3, 4, 5]) == [5, 4] def test_lru_repeated_access(): assert lru_cache(2, 5, [1, 2, 1, 2, 1]) == [1, 2] def test_lru_all_objects(): assert lru_cache(4, 4, [1, 2, 3, 4]) == [4, 3, 2, 1]","solution":"from collections import deque def lru_cache(n, q, queries): cache = deque() cache_set = set() # To keep track of items in the cache for O(1) look-up for query in queries: if query in cache_set: # Move the accessed item to the front (most recent) cache.remove(query) cache.appendleft(query) else: if len(cache) == n: # Remove the least recently used item from both cache and cache_set lru_item = cache.pop() cache_set.remove(lru_item) # Add the new item to the front (most recent) cache.appendleft(query) cache_set.add(query) return list(cache)"},{"question":"def maximalRectangle(matrix): Given a matrix containing only 0s and 1s, find the largest rectangular area containing only 1s. >>> maximalRectangle([['1', '0', '1', '0', '0'], ['1', '0', '1', '1', '1'], ['1', '1', '1', '1', '1'], ['1', '0', '0', '1', '0']]) == 6 >>> maximalRectangle([['0', '1'], ['1', '0']]) == 1 >>> maximalRectangle([['0', '1'], ['1', '1']]) == 2","solution":"def maximalRectangle(matrix): Given a matrix containing only 0s and 1s, find the largest rectangular area containing only 1s. if not matrix or not matrix[0]: return 0 n = len(matrix) m = len(matrix[0]) max_area = 0 heights = [0] * m for i in range(n): for j in range(m): if matrix[i][j] == '1': heights[j] += 1 else: heights[j] = 0 max_area = max(max_area, largestRectangleArea(heights)) return max_area def largestRectangleArea(heights): Helper function to calculate the largest rectangular area in a histogram. stack = [] max_area = 0 heights.append(0) for i in range(len(heights)): while stack and heights[i] < heights[stack[-1]]: h = heights[stack.pop()] width = i if not stack else i - stack[-1] - 1 max_area = max(max_area, h * width) stack.append(i) heights.pop() return max_area"},{"question":"def length_of_longest_substring(s: str) -> int: Returns the length of the longest substring that contains all unique characters. >>> length_of_longest_substring(\\"abcabcbb\\") 3 >>> length_of_longest_substring(\\"bbbbb\\") 1 >>> length_of_longest_substring(\\"pwwkew\\") 3 def process_test_cases(test_cases: List[str]) -> List[int]: Process multiple test cases and return their results. >>> process_test_cases([\\"abcabcbb\\", \\"bbbbb\\", \\"pwwkew\\"]) [3, 1, 3] >>> process_test_cases([\\"abcd\\", \\"aab\\", \\"dvdf\\"]) [4, 2, 3] >>> process_test_cases([\\"\\", \\"abcdefg\\"]) [0, 7] >>> process_test_cases([\\"a\\", \\"aa\\", \\"aaa\\"]) [1, 1, 1]","solution":"def length_of_longest_substring(s): Returns the length of the longest substring that contains all unique characters. char_set = set() left = 0 max_length = 0 for right in range(len(s)): while s[right] in char_set: char_set.remove(s[left]) left += 1 char_set.add(s[right]) max_length = max(max_length, right - left + 1) return max_length def process_test_cases(test_cases): Process multiple test cases and return their results. results = [] for s in test_cases: results.append(length_of_longest_substring(s)) return results"},{"question":"def robot_path(grid: List[List[str]]) -> List[Tuple[int, int]]: Determines if there is a path for the robot to reach the destination and returns the path if it exists. Parameters: grid (list of list of str): The 2D grid representing the map where '.' is empty and '#' is obstacle. Returns: list of tuples: The path as a list of coordinates or an empty list if no path exists. >>> grid = [ ... ['.', '.', '#'], ... ['#', '.', '.'], ... ['.', '#', '.'] ... ] >>> robot_path(grid) [(0, 0), (0, 1), (1, 1), (1, 2), (2, 2)] >>> grid = [ ... ['.', '#'], ... ['#', '.'] ... ] >>> robot_path(grid) [] from solution import robot_path def test_valid_path_1(): grid = [ ['.', '.', '#'], ['#', '.', '.'], ['.', '#', '.'] ] path = robot_path(grid) assert path == [(0, 0), (0, 1), (1, 1), (1, 2), (2, 2)] or path == [(0, 0), (0, 1), (1, 1), (2, 1), (2, 2)] def test_no_path(): grid = [ ['.', '#'], ['#', '.'] ] path = robot_path(grid) assert path == [] def test_single_row(): grid = [ ['.', '.', '.', '.', '.'] ] path = robot_path(grid) assert path == [(0, 0), (0, 1), (0, 2), (0, 3), (0, 4)] def test_single_column(): grid = [ ['.'], ['.'], ['.'], ['.'], ['.'] ] path = robot_path(grid) assert path == [(0, 0), (1, 0), (2, 0), (3, 0), (4, 0)] def test_valid_path_2(): grid = [ ['.', '.', '.', '.'], ['#', '#', '.', '#'], ['.', '.', '.', '.'], ['#', '#', '.', '.'] ] path = robot_path(grid) # A possible path can be: # [(0, 0), (0, 1), (0, 2), (0, 3), (1, 3), (2, 3), (3, 3)] assert path is not None and path[0] == (0, 0) and path[-1] == (3, 3) def test_obstacle_boundaries(): grid = [ ['.'], ['#'], ['.'] ] path = robot_path(grid) assert path == []","solution":"def robot_path(grid): Determines if there is a path for the robot to reach the destination and returns the path if it exists. Parameters: grid (list of list of str): The 2D grid representing the map where '.' is empty and '#' is obstacle. Returns: list of tuples: The path as a list of coordinates or an empty list if no path exists. n = len(grid) m = len(grid[0]) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] # right, down, left, up path = [] visited = [[False] * m for _ in range(n)] def is_valid(x, y): return 0 <= x < n and 0 <= y < m and grid[x][y] == '.' and not visited[x][y] def dfs(x, y): if x == n-1 and y == m-1: path.append((x, y)) return True visited[x][y] = True path.append((x, y)) for dx, dy in directions: nx, ny = x + dx, y + dy if is_valid(nx, ny) and dfs(nx, ny): return True path.pop() return False if dfs(0, 0): return path return []"},{"question":"class Library: def __init__(self): Initialize the library management system with an empty collection of books and members. def add_book(self, book_id: int, title: str, author: str, copies: int) -> None: Add a new book, or update the number of copies if the book already exists. >>> lib = Library() >>> lib.add_book(1, \\"The Hobbit\\", \\"J.R.R. Tolkien\\", 5) def register_member(self, member_id: int, name: str) -> None: Register a new member by their unique identifier and name. >>> lib = Library() >>> lib.register_member(101, \\"Alice Johnson\\") def borrow_book(self, member_id: int, book_id: int) -> str: Allow a member to borrow a book if available copies exist and the member has not already borrowed this book. >>> lib = Library() >>> lib.add_book(1, \\"The Hobbit\\", \\"J.R.R. Tolkien\\", 5) >>> lib.register_member(101, \\"Alice Johnson\\") >>> lib.borrow_book(101, 1) 'Success' def return_book(self, member_id: int, book_id: int) -> str: Allow a member to return a book they have borrowed. >>> lib = Library() >>> lib.add_book(1, \\"The Hobbit\\", \\"J.R.R. Tolkien\\", 5) >>> lib.register_member(101, \\"Alice Johnson\\") >>> lib.borrow_book(101, 1) 'Success' # Test cases for the Library class def test_add_book_initial(): lib = Library() lib.add_book(1, \\"The Hobbit\\", \\"J.R.R. Tolkien\\", 5) assert lib.books[1] == { 'title': \\"The Hobbit\\", 'author': \\"J.R.R. Tolkien\\", 'copies': 5, 'available': 5 } def test_add_book_existing(): lib = Library() lib.add_book(1, \\"The Hobbit\\", \\"J.R.R. Tolkien\\", 5) lib.add_book(1, \\"The Hobbit\\", \\"J.R.R. Tolkien\\", 3) assert lib.books[1]['copies'] == 8 assert lib.books[1]['available'] == 8 def test_register_member(): lib = Library() lib.register_member(101, \\"Alice Johnson\\") assert lib.members[101] == \\"Alice Johnson\\" def test_borrow_book_success(): lib = Library() lib.add_book(1, \\"The Hobbit\\", \\"J.R.R. Tolkien\\", 5) lib.register_member(101, \\"Alice Johnson\\") result = lib.borrow_book(101, 1) assert result == 'Success' assert lib.books[1]['available'] == 4 assert 1 in lib.borrowed[101] def test_borrow_book_fail_no_copies(): lib = Library() lib.add_book(1, \\"The Hobbit\\", \\"J.R.R. Tolkien\\", 1) lib.register_member(101, \\"Alice Johnson\\") lib.borrow_book(101, 1) result = lib.borrow_book(102, 1) assert result == 'Fail' def test_borrow_book_fail_already_borrowed(): lib = Library() lib.add_book(1, \\"The Hobbit\\", \\"J.R.R. Tolkien\\", 5) lib.register_member(101, \\"Alice Johnson\\") lib.borrow_book(101, 1) result = lib.borrow_book(101, 1) assert result == 'Fail' def test_return_book_success(): lib = Library() lib.add_book(1, \\"The Hobbit\\", \\"J.R.R. Tolkien\\", 5) lib.register_member(101, \\"Alice Johnson\\") lib.borrow_book(101, 1) result = lib.return_book(101, 1) assert result == 'Success' assert lib.books[1]['available'] == 5 assert 1 not in lib.borrowed[101] def test_return_book_fail_not_borrowed(): lib = Library() lib.add_book(1, \\"The Hobbit\\", \\"J.R.R. Tolkien\\", 5) lib.register_member(101, \\"Alice Johnson\\") result = lib.return_book(101, 1) assert result == 'Fail' def test_return_book_fail_not_member(): lib = Library() lib.add_book(1, \\"The Hobbit\\", \\"J.R.R. Tolkien\\", 5) result = lib.return_book(999, 1) assert result == 'Fail'","solution":"class Library: def __init__(self): self.books = {} self.members = {} self.borrowed = {} def add_book(self, book_id, title, author, copies): if book_id not in self.books: self.books[book_id] = { 'title': title, 'author': author, 'copies': copies, 'available': copies } else: self.books[book_id]['copies'] += copies self.books[book_id]['available'] += copies def register_member(self, member_id, name): if member_id not in self.members: self.members[member_id] = name self.borrowed[member_id] = {} def borrow_book(self, member_id, book_id): if book_id in self.books and member_id in self.members: if self.books[book_id]['available'] > 0 and book_id not in self.borrowed[member_id]: self.books[book_id]['available'] -= 1 self.borrowed[member_id][book_id] = True return 'Success' else: return 'Fail' return 'Fail' def return_book(self, member_id, book_id): if book_id in self.books and member_id in self.members: if book_id in self.borrowed[member_id]: self.books[book_id]['available'] += 1 del self.borrowed[member_id][book_id] return 'Success' else: return 'Fail' return 'Fail'"},{"question":"import math from typing import List def is_fibonacci_number(n: int) -> bool: Determines if a given number n is a Fibonacci number. >>> is_fibonacci_number(0) True >>> is_fibonacci_number(1) True >>> is_fibonacci_number(4) False >>> is_fibonacci_number(5) True pass def check_fibonacci_numbers(test_cases: List[int]) -> List[str]: Given a list of test cases, returns a list of \\"Yes\\" or \\"No\\" for each number indicating whether it is a Fibonacci number. >>> check_fibonacci_numbers([3, 4]) [\\"Yes\\", \\"No\\"] >>> check_fibonacci_numbers([5, 8, 13]) [\\"Yes\\", \\"Yes\\", \\"Yes\\"] pass","solution":"import math def is_fibonacci_number(n): Determines if a given number n is a Fibonacci number. # A number n is a Fibonacci number if one or both of (5*n^2 + 4) or (5*n^2 - 4) is a perfect square def is_perfect_square(x): s = int(math.sqrt(x)) return s * s == x return is_perfect_square(5 * n * n + 4) or is_perfect_square(5 * n * n - 4) def check_fibonacci_numbers(test_cases): Given a list of test cases, returns a list of \\"Yes\\" or \\"No\\" for each number indicating whether it is a Fibonacci number. results = [] for n in test_cases: if is_fibonacci_number(n): results.append(\\"Yes\\") else: results.append(\\"No\\") return results"},{"question":"def trap_water(n: int, heights: List[int]) -> int: Compute the total amount of water trapped between the blocks. >>> trap_water(6, [4, 2, 0, 3, 2, 5]) 9 >>> trap_water(5, [3, 0, 2, 0, 4]) 7 >>> trap_water(4, [1, 1, 1, 1]) 0 >>> trap_water(0, []) 0 >>> trap_water(1, [4]) 0 >>> trap_water(2, [4, 5]) 0 >>> trap_water(5, [1, 2, 3, 4, 5]) 0 >>> trap_water(5, [5, 4, 3, 2, 1]) 0 >>> trap_water(5, [3, 1, 3, 1, 3]) 4 >>> trap_water(5, [3, 3, 3, 3, 3]) 0","solution":"def trap_water(n, heights): if n < 3: return 0 left_max = [0] * n right_max = [0] * n water_trapped = 0 left_max[0] = heights[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], heights[i]) right_max[n - 1] = heights[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], heights[i]) for i in range(n): water_trapped += min(left_max[i], right_max[i]) - heights[i] return water_trapped"},{"question":"def can_travel_everywhere(n, m, roads): Determine if it is possible to travel from any city to any other city using the roads available. >>> can_travel_everywhere(4, 3, [(1, 2), (2, 3), (3, 4)]) \\"YES\\" >>> can_travel_everywhere(4, 2, [(1, 2), (3, 4)]) \\"NO\\"","solution":"def can_travel_everywhere(n, m, roads): from collections import defaultdict, deque if n == 1: return \\"YES\\" if m == 0 else \\"NO\\" graph = defaultdict(list) for u, v in roads: graph[u].append(v) graph[v].append(u) visited = set() def bfs(start): queue = deque([start]) visited.add(start) while queue: node = queue.popleft() for neighbor in graph[node]: if neighbor not in visited: visited.add(neighbor) queue.append(neighbor) bfs(1) return \\"YES\\" if len(visited) == n else \\"NO\\""},{"question":"def min_operations_to_symmetric(arr): Returns the minimum number of operations required to make the given list symmetric. Args: arr: List[int] -- the list of book thicknesses Returns: int -- the minimum number of operations needed Examples: >>> min_operations_to_symmetric([1, 3, 2, 3, 1]) 0 >>> min_operations_to_symmetric([4, 2, 1]) 1 >>> min_operations_to_symmetric([7, 8, 6, 8, 5, 7]) 2","solution":"def min_operations_to_symmetric(arr): Returns the minimum number of operations required to make the given list symmetric. n = len(arr) return sum(1 for i in range(n // 2) if arr[i] != arr[n - i - 1])"},{"question":"def distribute_cookies(n: int, m: int) -> List[int]: Distribute n cookies among m kids such that: 1. Each kid gets at least one cookie. 2. The difference between the maximum and minimum number of cookies given is minimized. Returns the distribution as a list of integers, or [-1] if distribution is not possible. >>> distribute_cookies(8, 3) [3, 3, 2] >>> distribute_cookies(10, 5) [2, 2, 2, 2, 2] >>> distribute_cookies(7, 4) [2, 2, 2, 1] >>> distribute_cookies(3, 5) [-1] >>> distribute_cookies(8, 4) [2, 2, 2, 2] >>> len(distribute_cookies(10**9, 10**6)) == 10**6 True","solution":"def distribute_cookies(n, m): Distribute n cookies among m kids such that: 1. Each kid gets at least one cookie. 2. The difference between the maximum and minimum number of cookies given is minimized. Returns the distribution as a list of integers, or [-1] if distribution is not possible. if m > n: return [-1] # Compute the base number of cookies each kid can get base = n // m # Compute the number of cookies remaining after equal distribution remainder = n % m # Create the distribution list distribution = [base] * m # Distribute the remainder cookies one by one to make minimal difference for i in range(remainder): distribution[i] += 1 return distribution"},{"question":"def count_divisible_pairs(n: int, k: int, arr: List[int]) -> int: Count the number of pairs (i, j) such that 0 <= i < j < n and (a_i + a_j) % k == 0. >>> count_divisible_pairs(5, 3, [1, 2, 3, 4, 5]) 4 >>> count_divisible_pairs(4, 5, [5, 10, 15, 20]) 6","solution":"def count_divisible_pairs(n, k, arr): Count the number of pairs (i, j) such that 0 <= i < j < n and (a_i + a_j) % k == 0 count = 0 remainder_count = [0] * k for num in arr: remainder = num % k matching_remainder = (k - remainder) % k count += remainder_count[matching_remainder] remainder_count[remainder] += 1 return count"},{"question":"def capped_fibonacci_sequence(a: int, b: int, m: int, n: int) -> list: Returns the first n numbers of a modified Fibonacci sequence where the sum of the previous two numbers is capped at m. >>> capped_fibonacci_sequence(2, 3, 5, 5) [2, 3, 5, 5, 5] >>> capped_fibonacci_sequence(1, 2, 4, 7) [1, 2, 3, 4, 4, 4, 4] >>> capped_fibonacci_sequence(1, 2, 10, 7) [1, 2, 3, 5, 8, 10, 10] >>> capped_fibonacci_sequence(5, 5, 10, 2) [5, 5] >>> capped_fibonacci_sequence(1000, 1000, 1500, 5) [1000, 1000, 1500, 1500, 1500] pass","solution":"def capped_fibonacci_sequence(a, b, m, n): Returns the first n numbers of a modified Fibonacci sequence where the sum of previous two numbers is capped at m. sequence = [a, b] for _ in range(2, n): next_number = sequence[-1] + sequence[-2] if next_number > m: next_number = m sequence.append(next_number) return sequence"},{"question":"def min_cost_to_k_distinct_chars(s: str, k: int) -> int: Computes the minimum cost to transform the string into a string with exactly k distinct characters >>> min_cost_to_k_distinct_chars('abcde', 3) 2 >>> min_cost_to_k_distinct_chars('aabbcc', 2) 2 >>> min_cost_to_k_distinct_chars('xyz', 3) 0 >>> min_cost_to_k_distinct_chars('aaa', 3) 2 >>> min_cost_to_k_distinct_chars('a', 2) 1 >>> min_cost_to_k_distinct_chars('a', 1) 0 >>> min_cost_to_k_distinct_chars('a', 2) 1","solution":"from collections import Counter def min_cost_to_k_distinct_chars(s, k): Computes the minimum cost to transform the string into a string with exactly k distinct characters Parameters: s (str): The input string containing only lowercase letters k (int): The desired number of distinct characters Returns: int: The minimum cost to achieve the transformation distinct_chars = Counter(s) num_distinct = len(distinct_chars) if num_distinct == k: return 0 if num_distinct > k: # We need to reduce the number of distinct characters sorted_counts = sorted(distinct_chars.values()) cost = 0 while num_distinct > k: cost += sorted_counts.pop(0) num_distinct -= 1 return cost if num_distinct < k: # We need to increase the number of distinct characters cost = k - num_distinct return cost"},{"question":"def zoogle_ranking_system(n, urls_scores, q, queries): Implement Zoogle's ranking system to handle multiple queries efficiently. Args: n (int): the number of URLs urls_scores (List[Tuple[str, int]]): a list of tuples, each containing a URL and a corresponding score q (int): the number of queries queries (List[int]): a list of integers specifying the number of top results requested for each query Returns: List[str]: a list of strings, each containing the top k URLs separated by spaces, for each query Example: >>> n = 6 >>> urls_scores = [ ... (\\"www.exampleA.com\\", 50), ... (\\"www.exampleB.com\\", 40), ... (\\"www.exampleC.com\\", 60), ... (\\"www.exampleD.com\\", 70), ... (\\"www.exampleE.com\\", 30), ... (\\"www.exampleF.com\\", 20) ... ] >>> q = 3 >>> queries = [1, 3, 5] >>> zoogle_ranking_system(n, urls_scores, q, queries) [ \\"www.exampleD.com\\", \\"www.exampleD.com www.exampleC.com www.exampleA.com\\", \\"www.exampleD.com www.exampleC.com www.exampleA.com www.exampleB.com www.exampleE.com\\" ]","solution":"def zoogle_ranking_system(n, urls_scores, q, queries): # sort URLs based on scores in descending order sorted_urls = sorted(urls_scores, key=lambda x: x[1], reverse=True) # process each query to get top k results results = [] for k in queries: top_k = [url for url, score in sorted_urls[:k]] results.append(\\" \\".join(top_k)) return results # Example usage if __name__ == \\"__main__\\": n = 6 urls_scores = [ (\\"www.exampleA.com\\", 50), (\\"www.exampleB.com\\", 40), (\\"www.exampleC.com\\", 60), (\\"www.exampleD.com\\", 70), (\\"www.exampleE.com\\", 30), (\\"www.exampleF.com\\", 20) ] q = 3 queries = [1, 3, 5] results = zoogle_ranking_system(n, urls_scores, q, queries) for result in results: print(result)"},{"question":"def smallest_subgrid_size(n: int, grid: List[str]) -> int: Returns the size of the smallest possible sub-grid that contains at least one '1' in each of its rows. >>> n = 3 >>> grid = [\\"101\\", \\"010\\", \\"001\\"] >>> smallest_subgrid_size(n, grid) 1 >>> n = 4 >>> grid = [\\"0000\\", \\"1110\\", \\"1100\\", \\"1011\\"] >>> smallest_subgrid_size(n, grid) 2 from solution import smallest_subgrid_size def test_example_1(): n = 3 grid = [ \\"101\\", \\"010\\", \\"001\\" ] assert smallest_subgrid_size(n, grid) == 1 def test_example_2(): n = 4 grid = [ \\"0000\\", \\"1110\\", \\"1100\\", \\"1011\\" ] assert smallest_subgrid_size(n, grid) == 2 def test_all_zeros(): n = 3 grid = [ \\"000\\", \\"000\\", \\"000\\" ] assert smallest_subgrid_size(n, grid) == 3 def test_single_row(): n = 4 grid = [ \\"0000\\", \\"0001\\", \\"0000\\", \\"0000\\" ] assert smallest_subgrid_size(n, grid) == 1 def test_full_rows(): n = 4 grid = [ \\"1111\\", \\"1111\\", \\"1111\\", \\"1111\\" ] assert smallest_subgrid_size(n, grid) == 4","solution":"def smallest_subgrid_size(n, grid): Returns the size of the smallest possible sub-grid that contains at least one '1' in each of its rows. smallest_size = n for i in range(n): first_one = -1 last_one = -1 for j in range(n): if grid[i][j] == '1': if first_one == -1: first_one = j last_one = j if first_one != -1 and last_one != -1: size = last_one - first_one + 1 smallest_size = min(smallest_size, size) return smallest_size"},{"question":"from typing import List, Tuple def can_data_transfer(n: int, m: int, s: int, d: int, k: int, restricted: List[int], edges: List[Tuple[int, int]]) -> str: Determine if there exists a valid path from the source computer to the destination computer that does not pass through any restricted nodes. >>> can_data_transfer(6, 7, 1, 6, 2, [3, 5], [(1, 2), (2, 4), (1, 3), (3, 4), (4, 5), (5, 6)]) 'NO' >>> can_data_transfer(6, 7, 1, 6, 1, [5], [(1, 2), (2, 4), (1, 3), (3, 4), (4, 6), (3, 5), (5, 6)]) 'YES' >>> can_data_transfer(4, 4, 1, 4, 0, [], [(1, 2), (2, 3), (3, 4), (1, 3)]) 'YES' >>> can_data_transfer(4, 3, 1, 4, 1, [3], [(1, 2), (2, 3), (3, 4)]) 'NO' >>> can_data_transfer(4, 4, 1, 4, 1, [1], [(1, 2), (2, 3), (3, 4), (1, 3)]) 'NO' >>> can_data_transfer(4, 4, 1, 4, 1, [4], [(1, 2), (2, 3), (3, 4), (1, 3)]) 'NO'","solution":"def can_data_transfer(n, m, s, d, k, restricted, edges): from collections import defaultdict, deque graph = defaultdict(list) restricted_set = set(restricted) for u, v in edges: if u not in restricted_set and v not in restricted_set: graph[u].append(v) queue = deque([s]) visited = set() while queue: node = queue.popleft() if node == d: return \\"YES\\" if node not in visited: visited.add(node) for neighbour in graph[node]: if neighbour not in visited: queue.append(neighbour) return \\"NO\\""},{"question":"def has_hamiltonian_path(n: int, m: int, edges: List[Tuple[int, int]]) -> str: Determine if there exists a Hamiltonian path from vertex 1 to vertex n in a directed graph. Args: n (int): The number of vertices. m (int): The number of edges. edges (List[Tuple[int, int]]): List of edges where each edge is represented as a tuple (u, v) meaning there's a directed edge from u to v. Returns: str: \\"Yes\\" if such a Hamiltonian path exists, otherwise \\"No\\". Example: >>> has_hamiltonian_path(4, 4, [(1, 2), (2, 3), (3, 4), (4, 1)]) \\"Yes\\" >>> has_hamiltonian_path(4, 2, [(1, 2), (2, 3)]) \\"No\\" from solution import has_hamiltonian_path def test_example_1(): n = 4 m = 4 edges = [(1, 2), (2, 3), (3, 4), (4, 1)] assert has_hamiltonian_path(n, m, edges) == \\"Yes\\" def test_no_hamiltonian_path(): n = 4 m = 2 edges = [(1, 2), (2, 3)] assert has_hamiltonian_path(n, m, edges) == \\"No\\" def test_direct_hamiltonian_path(): n = 3 m = 3 edges = [(1, 2), (2, 3), (3, 1)] assert has_hamiltonian_path(n, m, edges) == \\"Yes\\" def test_single_edge(): n = 2 m = 1 edges = [(1, 2)] assert has_hamiltonian_path(n, m, edges) == \\"Yes\\" def test_disconnected_graph(): n = 5 m = 3 edges = [(1, 2), (3, 4), (4, 5)] assert has_hamiltonian_path(n, m, edges) == \\"No\\"","solution":"def has_hamiltonian_path(n, m, edges): from itertools import permutations # Create adjacency list graph = {i: [] for i in range(1, n + 1)} for u, v in edges: graph[u].append(v) # Generate all permutations of the vertices for perm in permutations(range(1, n + 1)): if perm[0] == 1 and perm[-1] == n: # Check if this permutation forms a Hamiltonian path valid_path = True for i in range(n - 1): if perm[i + 1] not in graph[perm[i]]: valid_path = False break if valid_path: return \\"Yes\\" return \\"No\\" # Sample Data n = 4 m = 4 edges = [(1, 2), (2, 3), (3, 4), (4, 1)] print(has_hamiltonian_path(n, m, edges)) # Output should be \\"Yes\\""},{"question":"def rotate_list(n, k, arr): Rotates the list arr n positions to the right. Parameters: n (int): The number of elements in the list. k (int): The number of positions to rotate the list by. arr (list): The list of integers to rotate. Returns: list: The rotated list. Example: >>> rotate_list(5, 2, [3, 8, 9, 7, 6]) == [7, 6, 3, 8, 9] >>> rotate_list(5, 0, [3, 8, 9, 7, 6]) == [3, 8, 9, 7, 6] >>> rotate_list(5, 5, [3, 8, 9, 7, 6]) == [3, 8, 9, 7, 6] >>> rotate_list(5, 7, [3, 8, 9, 7, 6]) == [7, 6, 3, 8, 9] >>> rotate_list(1, 0, [1]) == [1] >>> rotate_list(1, 1, [1]) == [1] >>> rotate_list(10, 15, [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]) == [5, 6, 7, 8, 9, 0, 1, 2, 3, 4]","solution":"def rotate_list(n, k, arr): Rotates the list arr n positions to the right. Parameters: n (int): The number of elements in the list. k (int): The number of positions to rotate the list by. arr (list): The list of integers to rotate. Returns: list: The rotated list. # To handle the case where k > n k = k % n # Rotate the list using slicing rotated_list = arr[-k:] + arr[:-k] return rotated_list"},{"question":"def count_herds(n: int, m: int, field: List[List[str]]) -> int: Count the number of distinct herds in the field. Args: n (int): The number of rows in the field. m (int): The number of columns in the field. field (List[List[str]]): A 2D list representing the field where 'C' indicates a cow and '.' indicates an empty cell. Returns: int: The number of distinct herds in the field. Example: >>> field = [ ... ['C', '.', '.', 'C'], ... ['.', 'C', '.', 'C'], ... ['C', 'C', '.', 'C'] ... ] >>> count_herds(3, 4, field) 3 from typing import List def test_example_case(): field = [ ['C', '.', '.', 'C'], ['.', 'C', '.', 'C'], ['C', 'C', '.', 'C'] ] assert count_herds(3, 4, field) == 3 def test_single_row(): field = [ ['C', '.', 'C', 'C', '.', 'C'] ] assert count_herds(1, 6, field) == 3 def test_single_column(): field = [ ['C'], ['.'], ['C'], ['C'], ['.'], ['C'] ] assert count_herds(6, 1, field) == 3 def test_no_cows(): field = [ ['.', '.', '.'], ['.', '.', '.'], ['.', '.', '.'] ] assert count_herds(3, 3, field) == 0 def test_all_connected(): field = [ ['C', 'C', 'C'], ['C', 'C', 'C'], ['C', 'C', 'C'] ] assert count_herds(3, 3, field) == 1 def test_diagonal_cows_not_connected(): field = [ ['C', '.', '.'], ['.', 'C', '.'], ['.', '.', 'C'] ] assert count_herds(3, 3, field) == 3","solution":"def count_herds(n, m, field): def dfs(x, y): if x < 0 or x >= n or y < 0 or y >= m or field[x][y] != 'C': return # Mark the cell as visited by setting it to '.' field[x][y] = '.' # Move in all 4 possible directions (up, down, left, right) dfs(x+1, y) dfs(x-1, y) dfs(x, y+1) dfs(x, y-1) herd_count = 0 for i in range(n): for j in range(m): if field[i][j] == 'C': # Start a DFS to mark all cells in this herd dfs(i, j) herd_count += 1 return herd_count # Example Input n = 3 m = 4 field = [ ['C', '.', '.', 'C'], ['.', 'C', '.', 'C'], ['C', 'C', '.', 'C'] ] print(count_herds(n, m, field)) # Output: 3"},{"question":"def max_total_beauty(N: int, roads: List[Tuple[int, int, int]]) -> int: Given the number of cities N and a list of roads represented by tuples (u, v, b) where u and v are the cities connected by the road and b is the beauty value of that road, this function finds the maximum possible total beauty of the network after upgrading the roads to maximize the beauty value. The function takes the number of cities and a list of roads as input and returns an integer, the maximum possible total beauty of the network after upgrading the roads. >>> max_total_beauty(3, [(1, 2, 5), (2, 3, -4)]) 5 >>> max_total_beauty(4, [(1, 2, 3), (2, 3, -2), (3, 4, 2)]) 5","solution":"def max_total_beauty(N, roads): This function calculates the maximum possible total beauty of the network after upgrading the roads to maximize the beauty value. Parameters: N (int): Number of cities roads (List[Tuple[int]]): A list of tuples representing roads between cities where each tuple is in the form (u, v, b) and b is the beauty value. Returns: int: The maximum possible total beauty of the network after upgrading the roads. total_beauty = 0 for road in roads: _, _, beauty = road if beauty > 0: total_beauty += beauty return total_beauty"},{"question":"class UnionFind: def __init__(self, n): Initialize the UnionFind object with \`n\` elements. pass def find(self, x): Find the representative element of the set containing \`x\`. >>> uf = UnionFind(5) >>> uf.find(3) True pass def union(self, x, y): Merge the sets containing elements \`x\` and \`y\`. >>> uf = UnionFind(5) >>> uf.union(1, 2) pass def get_count(self): Return the number of distinct sets. >>> uf = UnionFind(5) >>> uf.get_count() 5 pass def process_operations(n, operations): Process a sequence of Union-Find operations. >>> process_operations(5, [\\"union 1 2\\", \\"union 2 3\\", \\"find 3\\", \\"count\\", \\"union 4 5\\", \\"count\\"]) [1, 3, 2] >>> process_operations(1, [\\"count\\"]) [1] >>> process_operations(5, [\\"union 1 2\\", \\"union 2 3\\", \\"union 3 4\\", \\"union 4 5\\", \\"count\\", \\"find 5\\"]) [1, 1] >>> process_operations(5, [\\"union 1 2\\", \\"union 3 4\\", \\"count\\", \\"find 4\\", \\"find 5\\"]) [3, 3, 5] >>> process_operations(5, [\\"union 1 2\\", \\"union 2 5\\", \\"union 3 4\\", \\"count\\", \\"union 4 1\\", \\"count\\"]) [2, 1] pass","solution":"class UnionFind: def __init__(self, n): self.parent = list(range(n + 1)) self.rank = [1] * (n + 1) self.count = n # initially, each element is its own set def find(self, x): if self.parent[x] != x: self.parent[x] = self.find(self.parent[x]) # path compression return self.parent[x] def union(self, x, y): rootX = self.find(x) rootY = self.find(y) if rootX != rootY: if self.rank[rootX] > self.rank[rootY]: self.parent[rootY] = rootX elif self.rank[rootX] < self.rank[rootY]: self.parent[rootX] = rootY else: self.parent[rootY] = rootX self.rank[rootX] += 1 self.count -= 1 # decrement the number of distinct sets def get_count(self): return self.count # Function to process the operations def process_operations(n, operations): uf = UnionFind(n) results = [] for operation in operations: op = operation.split() if op[0] == 'union': uf.union(int(op[1]), int(op[2])) elif op[0] == 'find': results.append(uf.find(int(op[1]))) elif op[0] == 'count': results.append(uf.get_count()) return results"},{"question":"def unique_paths_with_obstacles(grid): Find the number of unique paths the robot can take to reach its destination while avoiding obstacles. Args: grid: List[List[int]]: a list of lists where 0 represents an empty cell and 1 represents an obstacle. Returns: int: the number of unique paths to the bottom-right corner from the top-left corner >>> unique_paths_with_obstacles([ ... [0, 0, 0], ... [0, 1, 0], ... [0, 0, 0] ... ]) == 2 >>> unique_paths_with_obstacles([ ... [0, 1, 0], ... [0, 0, 0], ... [0, 0, 0] ... ]) == 3 >>> unique_paths_with_obstacles([ ... [0, 0, 1], ... [0, 1, 0], ... [0, 0, 0] ... ]) == 1 >>> unique_paths_with_obstacles([ ... [1, 0, 0], ... [0, 1, 0], ... [0, 0, 0] ... ]) == 0 >>> unique_paths_with_obstacles([ ... [0, 0, 0], ... [0, 0, 0], ... [0, 0, 0] ... ]) == 6 def process_test_cases(test_cases): Process multiple test cases and return the result for each one Args: test_cases: List[List[List[int]]]: a list containing grids for each test case Returns: List[int]: list containing the result for each test case >>> process_test_cases([ ... [ ... [0, 0, 0], ... [0, 1, 0], ... [0, 0, 0] ... ], ... [ ... [0, 1, 0], ... [0, 0, 0], ... [0, 0, 0] ... ] ... ]) == [2, 3] def read_input(input_str): Read and parse the input into test cases Args: input_str: str: a string formatted input containing several test cases Returns: List[List[List[int]]]: a list containing grids for each test case >>> input_str = '2n3n0 0 0n0 1 0n0 0 0n3n0 1 0n0 0 0n0 0 0n' >>> read_input(input_str) == [ ... [ ... [0, 0, 0], ... [0, 1, 0], ... [0, 0, 0] ... ], ... [ ... [0, 1, 0], ... [0, 0, 0], ... [0, 0, 0] ... ] ... ] def format_output(results): Format the results for output Args: results: List[int]: list of results for each test case Returns: str: formatted results as string >>> results = [2, 3] >>> format_output(results) == '2n3' def main(input_str): The main function to integrate reading input, processing test cases, and outputting results Args: input_str: str: a string formatted input containing several test cases Returns: str: formatted results as string >>> input_str = '2n3n0 0 0n0 1 0n0 0 0n3n0 1 0n0 0 0n0 0 0n' >>> main(input_str) == '2n3'","solution":"def unique_paths_with_obstacles(grid): N = len(grid) # Create a 2D dp array to store the number of unique paths to each cell dp = [[0] * N for _ in range(N)] # If the start or end cell is an obstacle, no unique paths exist if grid[0][0] == 1 or grid[N-1][N-1] == 1: return 0 # Initialize the starting point dp[0][0] = 1 # Fill in the dp array for i in range(N): for j in range(N): if grid[i][j] == 1: # If the cell is an obstacle, continue dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[N-1][N-1] def process_test_cases(test_cases): results = [] for grid in test_cases: results.append(unique_paths_with_obstacles(grid)) return results def read_input(input_str): lines = input_str.strip().split('n') T = int(lines[0]) index = 1 test_cases = [] for _ in range(T): N = int(lines[index]) grid = [] for i in range(N): grid.append(list(map(int, lines[index + 1 + i].split()))) test_cases.append(grid) index += N + 1 return test_cases def format_output(results): return 'n'.join(map(str, results)) # The main function to integrate reading input, processing test cases, and outputting results. def main(input_str): test_cases = read_input(input_str) results = process_test_cases(test_cases) return format_output(results)"},{"question":"def spiral_order(matrix): Returns the plant IDs in the garden bed starting from the top-left corner and traversing in a spiral order. >>> spiral_order([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == [1, 2, 3, 6, 9, 8, 7, 4, 5] >>> spiral_order([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]]) == [1, 2, 3, 4, 8, 12, 16, 15, 14, 13, 9, 5, 6, 7, 11, 10]","solution":"def spiral_order(matrix): Returns the plant IDs in the garden bed starting from the top-left corner and traversing in a spiral order. m = len(matrix) n = len(matrix[0]) if m > 0 else 0 result = [] if not matrix or m == 0 or n == 0: return result top, bottom, left, right = 0, m - 1, 0, n - 1 while top <= bottom and left <= right: # Traverse from left to right at the top row for i in range(left, right + 1): result.append(matrix[top][i]) top += 1 # Traverse from top to bottom at the right column for i in range(top, bottom + 1): result.append(matrix[i][right]) right -= 1 if top <= bottom: # Traverse from right to left at the bottom row for i in range(right, left - 1, -1): result.append(matrix[bottom][i]) bottom -= 1 if left <= right: # Traverse from bottom to top at the left column for i in range(bottom, top - 1, -1): result.append(matrix[i][left]) left += 1 return result"},{"question":"def min_cars_to_move(parking_lot, k): Determine the minimum number of cars that need to be moved to make a subarray of k consecutive parking spaces free. Args: parking_lot : List[int] : An array representing the parking lot (1 for occupied, 0 for free). k : int : The required number of consecutive free spaces. Returns: int : The minimum number of cars that need to be moved. Examples: >>> min_cars_to_move([1, 0, 1, 0, 0, 1, 0, 1], 3) 1 >>> min_cars_to_move([1, 1, 1, 1, 1], 2) 2 def solve(test_cases): Process multiple test cases to determine the minimum number of cars that need to be moved for each case. Args: test_cases : List[Tuple[Tuple[int, int], List[int]]] : A list of test cases. Returns: List[int] : A list of results for each test case. Examples: >>> solve([((8, 3), [1, 0, 1, 0, 0, 1, 0, 1]), ((5, 2), [1, 1, 1, 1, 1]), ((6, 4), [0, 1, 1, 0, 1, 0])]) [1, 2, 2]","solution":"def min_cars_to_move(parking_lot, k): n = len(parking_lot) min_moves = float('inf') # Slide window of size k over the parking_lot array for i in range(n - k + 1): current_window = parking_lot[i:i+k] cars_to_move = sum(current_window) min_moves = min(min_moves, cars_to_move) return min_moves def solve(test_cases): results = [] for test_case in test_cases: n, k = test_case[0] parking_lot = test_case[1] result = min_cars_to_move(parking_lot, k) results.append(result) return results"},{"question":"def minimum_distance_to_deliver(N, K, C, islands): Returns the minimum total distance the ship must travel to deliver goods to exactly K islands. Parameters: N (int): Number of islands. K (int): Number of islands to deliver to. C (int): Carrying capacity of the ship. islands (list of tuples): Each tuple contains two integers, X_i and D_i, representing the position and the cargo demand of an island. >>> minimum_distance_to_deliver(4, 2, 10, [(5, 6), (10, 3), (15, 7), (20, 2)]) 15 >>> minimum_distance_to_deliver(3, 1, 5, [(4, 4), (8, 3), (12, 6)]) 4 >>> minimum_distance_to_deliver(3, 2, 4, [(4, 5), (8, 3), (12, 6)]) -1 >>> minimum_distance_to_deliver(5, 3, 7, [(2, 6), (4, 4), (6, 5), (8, 7), (10, 1)]) 12 >>> minimum_distance_to_deliver(4, 2, 5, [(1, 6), (3, 7), (5, 2), (6, 8)]) -1 >>> minimum_distance_to_deliver(3, 2, 10, [(5, 6), (5, 3), (5, 7)]) 10 >>> minimum_distance_to_deliver(4, 2, 5, [(7, 2), (1, 3), (5, 1), (3, 2)]) 4","solution":"def minimum_distance_to_deliver(N, K, C, islands): Returns the minimum total distance the ship must travel to deliver goods to exactly K islands. Parameters: N (int): Number of islands. K (int): Number of islands to deliver to. C (int): Carrying capacity of the ship. islands (list of tuples): Each tuple contains two integers, X_i and D_i, representing the position and the cargo demand of an island. Returns: int: Minimum total distance to deliver to exactly K islands, or -1 if not possible. # Filter only the islands that have demand D_i <= C filtered_islands = [(x, d) for x, d in islands if d <= C] # If there are not enough islands that can be fully satisfied, return -1 if len(filtered_islands) < K: return -1 # Sort the filtered islands by their position X_i filtered_islands.sort() # Calculate the total distance to the K nearest islands that can be fully satisfied min_distance = sum(filtered_islands[i][0] for i in range(K)) return min_distance # Example usage if __name__ == \\"__main__\\": import sys input = sys.stdin.read data = input().strip().split() N = int(data[0]) K = int(data[1]) C = int(data[2]) islands = [] index = 3 for _ in range(N): X_i = int(data[index]) D_i = int(data[index + 1]) islands.append((X_i, D_i)) index += 2 print(minimum_distance_to_deliver(N, K, C, islands))"},{"question":"from typing import List, Tuple def process_queries(m: int, s: str, queries: List[Tuple[int, ...]]) -> List[int]: Process queries on the string according to the specifications. The queries can either reverse a substring or count occurrences of a character. Args: m (int): The number of queries. s (str): The initial string. queries (list): List of queries to be processed. Returns: list: List of results for type 2 queries. Examples: >>> m = 5 >>> s = \\"abcde\\" >>> queries = [(1, 2, 4), (2, 'c'), (1, 1, 5), (2, 'a'), (2, 'e')] >>> process_queries(m, s, queries) [1, 1, 1] >>> m = 4 >>> s = \\"hello\\" >>> queries = [(2, 'l'), (1, 1, 2), (2, 'h'), (1, 3, 4)] >>> process_queries(m, s, queries) [2, 1] pass","solution":"def process_queries(m, s, queries): s = list(s) # Convert string to list for mutable operations results = [] for query in queries: type_query = query[0] if type_query == 1: l, r = query[1] - 1, query[2] - 1 # Convert to 0-based indexing s[l:r+1] = s[l:r+1][::-1] # Reverse the specified substring elif type_query == 2: c = query[1] results.append(s.count(c)) # Count occurrences of the character return results"},{"question":"def check_rectangle_overlap(x1_left, y1_bottom, x1_right, y1_top, x2_left, y2_bottom, x2_right, y2_top): Determine if two rectangles overlap based on their coordinates. Parameters: - x1_left (int): The x-coordinate of the bottom-left corner of the first rectangle. - y1_bottom (int): The y-coordinate of the bottom-left corner of the first rectangle. - x1_right (int): The x-coordinate of the top-right corner of the first rectangle. - y1_top (int): The y-coordinate of the top-right corner of the first rectangle. - x2_left (int): The x-coordinate of the bottom-left corner of the second rectangle. - y2_bottom (int): The y-coordinate of the bottom-left corner of the second rectangle. - x2_right (int): The x-coordinate of the top-right corner of the second rectangle. - y2_top (int): The y-coordinate of the top-right corner of the second rectangle. Returns: - str: 'OVERLAP' if the rectangles overlap, otherwise 'NO_OVERLAP'. Examples: >>> check_rectangle_overlap(0, 0, 2, 2, 1, 1, 3, 3) 'OVERLAP' >>> check_rectangle_overlap(0, 0, 1, 1, 1, 1, 2, 2) 'NO_OVERLAP'","solution":"def check_rectangle_overlap(x1_left, y1_bottom, x1_right, y1_top, x2_left, y2_bottom, x2_right, y2_top): Returns 'OVERLAP' if the two rectangles overlap, otherwise returns 'NO_OVERLAP'. if x1_left >= x2_right or x2_left >= x1_right: return \\"NO_OVERLAP\\" if y1_bottom >= y2_top or y2_bottom >= y1_top: return \\"NO_OVERLAP\\" return \\"OVERLAP\\""},{"question":"def minimize_weight_difference(n: int, weights: List[int]) -> int: Divide items into two non-empty groups such that the difference between the sums of the weights of the items in each group is minimized. Args: n : int : the number of items weights : list of int : the weights of the items Returns: int : the minimized difference between the sums of the weights of the two groups Examples: >>> minimize_weight_difference(5, [3, 1, 4, 3, 2]) == 1 >>> minimize_weight_difference(4, [5, 8, 6, 4]) == 1","solution":"def minimize_weight_difference(n, weights): Divide items into two non-empty groups such that the difference between the sums of the weights of the items in each group is minimized. Args: n : int : the number of items weights : list of int : the weights of the items Returns: int : the minimized difference between the sums of the weights of the two groups total_weight = sum(weights) half_weight = total_weight // 2 # Using a dynamic programming approach to find the subset with the sum closest to half_weight dp = [False] * (half_weight + 1) dp[0] = True for weight in weights: for j in range(half_weight, weight - 1, -1): dp[j] = dp[j] or dp[j - weight] # Find the largest j for which dp[j] is True for j in range(half_weight, -1, -1): if dp[j]: sum1 = j break sum2 = total_weight - sum1 return abs(sum2 - sum1)"},{"question":"def max_score(stones: List[int]) -> int: Calculate the maximum score you can achieve by breaking stones in a sequential manner. >>> max_score([4, 2, 1]) == 7 >>> max_score([1, 2, 3, 4]) == 10 def test_simple_case(): assert max_score([4, 2, 1]) == 7 assert max_score([1, 2, 3, 4]) == 10 def test_single_stone(): assert max_score([10]) == 10 def test_all_same_stones(): assert max_score([5, 5, 5, 5]) == 20 def test_increasing_order(): assert max_score([1, 2, 3, 4, 5]) == 15 def test_decreasing_order(): assert max_score([5, 4, 3, 2, 1]) == 15 def test_large_values(): assert max_score([1000, 1000]) == 2000 def test_mixed_values(): assert max_score([3, 7, 2, 5, 8]) == 25","solution":"def max_score(stones): def helper(stones, memo): if tuple(stones) in memo: return memo[tuple(stones)] if not stones: return 0 if len(stones) == 1: return stones[0] max_res = 0 for i in range(len(stones)): points = stones[i] new_stones = stones[:i] + stones[i+1:] if i > 0 and i < len(stones) - 1: new_stones[i-1] = new_stones[i-1] + new_stones[i] del new_stones[i] max_res = max(max_res, points + helper(new_stones, memo)) memo[tuple(stones)] = max_res return max_res memo = {} return helper(stones, memo)"},{"question":"def check_balanced_and_sorted(s: str) -> str: Check if the parentheses are balanced and the integers inside each parentheses are non-decreasingly sorted. >>> check_balanced_and_sorted(\\"3 4 ( 1 2 3 3 4 ) 1 ( 2 3 4 5 )\\") \\"Balanced and Sorted\\" >>> check_balanced_and_sorted(\\"( 3 1 2 ) 5 9 8\\") \\"Not Balanced or Not Sorted\\" >>> check_balanced_and_sorted(\\"3 4 ( 1 2 3 3 4 ) 1 ( 2 3 4 5\\") \\"Not Balanced or Not Sorted\\" >>> check_balanced_and_sorted(\\"3 4 ( 1 2 3 3 4 ) 1 2 3 4 5 )\\") \\"Not Balanced or Not Sorted\\" >>> check_balanced_and_sorted(\\"1 2 3 4 5\\") \\"Balanced and Sorted\\" >>> check_balanced_and_sorted(\\"3 ( 4 2 3 ) 5\\") \\"Not Balanced or Not Sorted\\" >>> check_balanced_and_sorted(\\"\\") \\"Balanced and Sorted\\" >>> check_balanced_and_sorted(\\"3 4 ( 1 2 3 ) 5 6 ( 4 5 6 )\\") \\"Balanced and Sorted\\"","solution":"def check_balanced_and_sorted(s): Check if the parentheses are balanced and the integers inside each parentheses are non-decreasingly sorted. Parameters: s (str): A string containing integers separated by spaces and/or parentheses. Returns: str: \\"Balanced and Sorted\\" or \\"Not Balanced or Not Sorted\\" stack = [] start_indices = [] # Split the string by spaces to get tokens tokens = s.strip().split() # Process each token for i, token in enumerate(tokens): if token == '(': stack.append('(') start_indices.append(i) elif token == ')': if not stack: return \\"Not Balanced or Not Sorted\\" stack.pop() start_index = start_indices.pop() # Check if the numbers between start_index and i are sorted seq = tokens[start_index + 1:i] nums = list(map(int, seq)) if nums != sorted(nums): return \\"Not Balanced or Not Sorted\\" if stack: return \\"Not Balanced or Not Sorted\\" return \\"Balanced and Sorted\\""},{"question":"def count_distinct_city_classes(n: int, city_names: List[str]) -> int: Returns the number of distinct city classes based on the set of letters in their names. >>> count_distinct_city_classes(5, [\\"abc\\", \\"bca\\", \\"cab\\", \\"ab\\", \\"ba\\"]) == 2 >>> count_distinct_city_classes(4, [\\"abcd\\", \\"dcba\\", \\"abc\\", \\"cabd\\"]) == 2 >>> count_distinct_city_classes(1, [\\"a\\"]) == 1 >>> count_distinct_city_classes(3, [\\"abc\\", \\"def\\", \\"ghi\\"]) == 3 >>> count_distinct_city_classes(4, [\\"abcd\\", \\"bcda\\", \\"cdab\\", \\"dabc\\"]) == 1 >>> count_distinct_city_classes(5, [\\"z\\", \\"zz\\", \\"zzz\\", \\"zzzz\\", \\"zzzzz\\"]) == 1","solution":"def count_distinct_city_classes(n, city_names): Returns the number of distinct city classes based on the set of letters in their names city_sets = set() for city in city_names: city_sets.add(frozenset(city)) return len(city_sets)"},{"question":"def longest_subarray_length(n: int, S: int, arr: List[int]) -> int: Finds the length of the longest subarray with sum less than or equal to S. Parameters: - n: int, number of elements in the array - S: int, the given value for the sum of elements - arr: list of int, the elements of the sequence Returns: - int, the length of the longest subarray >>> longest_subarray_length(5, 10, [2, 1, 3, 4, 5]) == 4 >>> longest_subarray_length(3, 5, [6, 4, 2]) == 1 >>> longest_subarray_length(1, 10, [5]) == 1 >>> longest_subarray_length(1, 1, [2]) == 0 >>> longest_subarray_length(4, 15, [1, 2, 3, 4, 5]) == 4 >>> longest_subarray_length(4, 1, [2, 3, 4, 5]) == 0 >>> longest_subarray_length(6, 7, [1, 2, 3, 4, 1, 1]) == 3","solution":"def longest_subarray_length(n, S, arr): Finds the length of the longest subarray with sum less than or equal to S. Parameters: - n: int, number of elements in the array - S: int, the given value for the sum of elements - arr: list of int, the elements of the sequence Returns: - int, the length of the longest subarray left = 0 current_sum = 0 max_length = 0 for right in range(n): current_sum += arr[right] while current_sum > S and left <= right: current_sum -= arr[left] left += 1 max_length = max(max_length, right - left + 1) return max_length"},{"question":"from typing import List, Tuple def highest_strength(n: int, planks: List[Tuple[int, int]], m: int) -> int: Returns the highest possible aggregate strength of planks without any plank exceeding the given identifier length m. Parameters: n (int): Total number of planks. planks (List[Tuple[int, int]]): List of tuples, where each tuple contains the identifier length and strength of a plank. m (int): Maximum allowed identifier length for any plank in the selection. Returns: int: The highest possible aggregate strength of planks given the constraints. Example: >>> highest_strength(4, [(3, 10), (4, 50), (2, 20), (3, 30)], 3) 60 >>> highest_strength(3, [(4, 10), (5, 20), (6, 30)], 3) 0 pass def test_example_case(): n = 4 planks = [(3, 10), (4, 50), (2, 20), (3, 30)] m = 3 assert highest_strength(n, planks, m) == 60 def test_no_valid_planks(): n = 3 planks = [(4, 10), (5, 20), (6, 30)] m = 3 assert highest_strength(n, planks, m) == 0 def test_all_planks_valid(): n = 3 planks = [(2, 10), (2, 20), (3, 30)] m = 3 assert highest_strength(n, planks, m) == 60 def test_single_plank(): n = 1 planks = [(3, 40)] m = 3 assert highest_strength(n, planks, m) == 40 def test_identifiers_equal_to_m(): n = 3 planks = [(3, 10), (3, 20), (3, 30)] m = 3 assert highest_strength(n, planks, m) == 60","solution":"def highest_strength(n, planks, m): Returns the highest possible aggregate strength of planks without any plank exceeding the given identifier length m. # Filter planks to ensure not exceeding identifier length m valid_planks = [strength for length, strength in planks if length <= m] # Calculate the highest possible aggregate strength highest_strength = sum(valid_planks) return highest_strength"},{"question":"def can_schedule_chimes(H: int, X: int, N: int) -> str: Determines if it is possible to schedule N chimes starting at hour H and repeating every X hours within a 24 hour period. :param H: Starting hour (0 <= H < 24) :param X: Interval in hours (1 <= X <= 24) :param N: Number of chimes (1 <= N <= 1000) :return: 'Possible' if chimes can be scheduled, else 'Impossible' >>> can_schedule_chimes(8, 3, 5) 'Possible' >>> can_schedule_chimes(23, 2, 2) 'Impossible' >>> can_schedule_chimes(0, 24, 1) 'Possible'","solution":"def can_schedule_chimes(H, X, N): Determines if it is possible to schedule N chimes starting at hour H and repeating every X hours within a 24 hour period. :param H: Starting hour (0 <= H < 24) :param X: Interval in hours (1 <= X <= 24) :param N: Number of chimes (1 <= N <= 1000) :return: 'Possible' if chimes can be scheduled, else 'Impossible' if H + (N - 1) * X < 24: return 'Possible' else: return 'Impossible'"},{"question":"def process_operations(n: int, m: int, array: List[int], operations: List[List[int]]) -> List[int]: Process a series of update and query operations on an array. Args: n (int): Size of the array. m (int): Number of operations. array (List[int]): Initial array of n integers. operations (List[List[int]]): List of operations to be performed. Returns: List[int]: Results of the query operations. Example: >>> process_operations(5, 5, [3, 1, 4, 1, 5], [[2, 1, 5, 3], [1, 2, 2], [2, 1, 5, 3], [1, 5, 5], [2, 1, 5, 4]]) [3, 3, 4]","solution":"def process_operations(n, m, array, operations): result = [] for op in operations: if op[0] == 1: # Update operation p = op[1] - 1 # convert to zero indexing x = op[2] array[p] = x elif op[0] == 2: # Query operation l = op[1] - 1 # convert to zero indexing r = op[2] # convert to zero indexing but include element at index r k = op[3] subarray = array[l:r] subarray.sort() result.append(subarray[k-1]) return result"},{"question":"def max_steal(n: int, money: List[int]) -> int: You are given an array of positive integers representing the amount of money hidden at several houses arranged in a circular manner. A thief wants to steal the maximum amount of money without stealing from two directly adjacent houses (due to an alarm system). Write a function that returns the maximum amount of money the thief can steal. Constraints: - The input list has at least one element. - The total number of houses N is between 1 and 10^5. - The amount of money hidden in each house is between 1 and 10^4. >>> max_steal(1, [5]) 5 >>> max_steal(2, [5, 10]) 10 >>> max_steal(3, [1, 2, 3]) 3 >>> max_steal(4, [7, 10, 12, 7]) 19","solution":"from typing import List def max_steal(n: int, money: List[int]) -> int: if n == 0: return 0 if n == 1: return money[0] if n == 2: return max(money[0], money[1]) def rob_line(houses: List[int]) -> int: prev1, prev2 = 0, 0 for value in houses: curr = max(prev1, prev2 + value) prev2 = prev1 prev1 = curr return prev1 return max( rob_line(money[:-1]), # Stealing from the first house, excluding the last rob_line(money[1:]) # Stealing from the second house, excluding the first )"},{"question":"def rank_contestants(n: int, problems_solved: List[int]) -> List[int]: Returns the ranks of contestants based on the number of problems solved. Parameters: n (int): Number of contestants. problems_solved (list): Each element is the number of problems solved by a contestant. Returns: list: Ranks in the order of the input contestants. >>> rank_contestants(5, [5, 3, 5, 2, 3]) [1, 3, 1, 5, 3] >>> rank_contestants(4, [7, 7, 7, 7]) [1, 1, 1, 1]","solution":"def rank_contestants(n, problems_solved): Returns the ranks of contestants based on the number of problems solved. Parameters: n (int): Number of contestants. problems_solved (list): Each element is the number of problems solved by a contestant. Returns: list: Ranks in the order of the input contestants. # Create a list of tuples where each tuple is (problems_solved, index) indexed_problems = [(problems_solved[i], i) for i in range(n)] # Sort based on the number of problems solved (descending) indexed_problems.sort(key=lambda x: x[0], reverse=True) # Initialize result list with placeholder values ranks = [0] * n current_rank = 1 for i in range(n): # Assign the current contestant the current rank if i > 0 and indexed_problems[i][0] == indexed_problems[i-1][0]: ranks[indexed_problems[i][1]] = current_rank else: current_rank = i + 1 ranks[indexed_problems[i][1]] = current_rank return ranks"},{"question":"def largest_perimeter_submatrix(matrix, n, m, k): Calculate the largest possible perimeter of a submatrix whose elements' sum is less than or equal to a given integer k. Args: matrix (List[List[int]]): A 2D list representing the matrix of non-negative integers. n (int): Number of rows in the matrix. m (int): Number of columns in the matrix. k (int): The maximum sum of the submatrix elements. Returns: int: The largest possible perimeter of a submatrix whose elements' sum is less than or equal to k. >>> matrix = [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ] >>> n = 3 >>> m = 3 >>> k = 10 >>> largest_perimeter_submatrix(matrix, n, m, k) 8 >>> matrix = [ ... [1, 2], ... [3, 4] ... ] >>> n = 2 >>> m = 2 >>> k = 6 >>> largest_perimeter_submatrix(matrix, n, m, k) 6 >>> matrix = [ ... [1] ... ] >>> n = 1 >>> m = 1 >>> k = 1 >>> largest_perimeter_submatrix(matrix, n, m, k) 4 >>> matrix = [ ... [10, 10], ... [10, 10] ... ] >>> n = 2 >>> m = 2 >>> k = 5 >>> largest_perimeter_submatrix(matrix, n, m, k) 0 >>> matrix = [ ... [1, 2, 3, 4], ... [1, 2, 3, 4], ... [1, 2, 3, 4] ... ] >>> n = 3 >>> m = 4 >>> k = 100 >>> largest_perimeter_submatrix(matrix, n, m, k) 14","solution":"def largest_perimeter_submatrix(matrix, n, m, k): # Function to calculate the sum of a submatrix def submatrix_sum(start_row, start_col, end_row, end_col): total = prefix_sum[end_row+1][end_col+1] - prefix_sum[start_row][end_col+1] - prefix_sum[end_row+1][start_col] + prefix_sum[start_row][start_col] return total # Initialize the prefix sum array prefix_sum = [[0] * (m + 1) for _ in range(n + 1)] # Fill the prefix sum array for i in range(1, n + 1): for j in range(1, m + 1): prefix_sum[i][j] = matrix[i-1][j-1] + prefix_sum[i-1][j] + prefix_sum[i][j-1] - prefix_sum[i-1][j-1] # Function to calculate the perimeter of a submatrix def perimeter(start_row, start_col, end_row, end_col): return 2 * ((end_row - start_row + 1) + (end_col - start_col + 1)) # Initialize the maximum perimeter to be 0 max_perimeter = 0 # Iterate through all possible submatrices for start_row in range(n): for start_col in range(m): for end_row in range(start_row, n): for end_col in range(start_col, m): if submatrix_sum(start_row, start_col, end_row, end_col) <= k: max_perimeter = max(max_perimeter, perimeter(start_row, start_col, end_row, end_col)) return max_perimeter"},{"question":"def pattern_match(words: List[str], pattern: str) -> List[str]: This function returns the list of words that match the given pattern. >>> pattern_match([\\"abc\\", \\"deq\\", \\"mee\\"], \\"abb\\") [\\"mee\\"] >>> pattern_match([\\"a\\", \\"b\\", \\"c\\"], \\"x\\") [\\"a\\", \\"b\\", \\"c\\"] pass def process_test_cases(test_cases: List[Tuple[List[str], str]]) -> List[str]: Given multiple test cases, this function processes each test case and finds matching words >>> process_test_cases([([\\"abc\\", \\"deq\\", \\"mee\\"], \\"abb\\"), ([\\"a\\", \\"b\\", \\"c\\"], \\"x\\")]) [\\"mee\\", \\"a b c\\"] >>> process_test_cases([([\\"xyz\\", \\"xyx\\", \\"yxx\\"], \\"bba\\"), ([\\"abcd\\", \\"deed\\", \\"nnnn\\"], \\"mama\\")]) [\\"\\", \\"\\"] pass","solution":"def pattern_match(words, pattern): This function returns the list of words that match the given pattern. :param words: List of words we want to match against the pattern :param pattern: The pattern to match :return: List of words that match the pattern def match(word, pattern): if len(word) != len(pattern): return False word_to_pattern = {} pattern_to_word = {} for w, p in zip(word, pattern): if w not in word_to_pattern: word_to_pattern[w] = p if p not in pattern_to_word: pattern_to_word[p] = w if word_to_pattern[w] != p or pattern_to_word[p] != w: return False return True matched_words = [word for word in words if match(word, pattern)] return matched_words def process_test_cases(test_cases): Given multiple test cases, this function processes each test case and finds matching words :param test_cases: List of test cases where each test case contains a list of words and a pattern :return: List of results for each test case results = [] for words, pattern in test_cases: matched_words = pattern_match(words, pattern) results.append(' '.join(matched_words)) return results"},{"question":"def is_part_of_mst(n: int, m: int, p: int, roads: List[Tuple[int, int, int]], projects: List[Tuple[int, int, int]]) -> List[str]: For each potential construction project, determine if the road would be part of the Minimum Spanning Tree (MST) if it were to be constructed. >>> is_part_of_mst(4, 4, 3, [(1, 2, 5), (2, 3, 3), (3, 4, 2), (4, 1, 4)], [(1, 3, 6), (2, 4, 1), (3, 1, 7)]) ['NO', 'YES', 'NO'] >>> is_part_of_mst(3, 0, 3, [], [(1, 2, 1), (2, 3, 1), (3, 1, 1)]) ['YES', 'YES', 'YES'] >>> is_part_of_mst(3, 1, 2, [(1, 2, 5)], [(2, 3, 1), (3, 1, 2)]) ['YES', 'YES'] >>> is_part_of_mst(4, 4, 2, [(1, 2, 5), (2, 3, 3), (3, 4, 2), (1, 4, 4)], [(1, 3, 6), (1, 4, 10)]) ['NO', 'NO']","solution":"class DisjointSetUnion: def __init__(self, n): self.parent = list(range(n)) self.rank = [0] * n def find(self, u): if self.parent[u] != u: self.parent[u] = self.find(self.parent[u]) return self.parent[u] def union(self, u, v): root_u = self.find(u) root_v = self.find(v) if root_u != root_v: if self.rank[root_u] > self.rank[root_v]: self.parent[root_v] = root_u elif self.rank[root_u] < self.rank[root_v]: self.parent[root_u] = root_v else: self.parent[root_v] = root_u self.rank[root_u] += 1 def kruskal(n, edges): dsu = DisjointSetUnion(n) mst_weight = 0 mst_edges = [] edges_sorted = sorted(edges, key=lambda x: x[2]) for u, v, w in edges_sorted: if dsu.find(u) != dsu.find(v): dsu.union(u, v) mst_weight += w mst_edges.append((u, v, w)) if len(mst_edges) == n - 1: break return mst_weight, mst_edges def is_part_of_mst(n, m, p, roads, projects): result = [] edges = [(u-1, v-1, w) for (u, v, w) in roads] current_mst_weight, current_mst_edges = kruskal(n, edges) for (u, v, w) in projects: # Add the project to the edge list and recalculate the MST edges_with_project = edges + [(u-1, v-1, w)] new_mst_weight, new_mst_edges = kruskal(n, edges_with_project) if any(edge == (u-1, v-1, w) or edge == (v-1, u-1, w) for edge in new_mst_edges): result.append(\\"YES\\") else: result.append(\\"NO\\") return result"},{"question":"def smallest_window_length_with_all_unique_chars(n: int, s: str) -> int: Find the length of the smallest window that contains all the unique characters of the input string. >>> smallest_window_length_with_all_unique_chars(7, \\"aabcabb\\") 3 >>> smallest_window_length_with_all_unique_chars(5, \\"abcde\\") 5","solution":"def smallest_window_length_with_all_unique_chars(n, s): from collections import Counter # Find all unique characters in the string unique_chars = set(s) unique_count = len(unique_chars) # Initialize the sliding window pointers left = 0 right = 0 # Variable to keep track of the minimum window size min_window_size = float('inf') # Dictionary to count occurrences of characters in the current window window_counts = Counter() # Variable to keep track of the number of unique characters in the current window formed_unique = 0 # Expand the window to the right while right < n: # Add the current character to the window char = s[right] window_counts[char] += 1 # If current character count is 1, it means we've added a unique character to the window if window_counts[char] == 1: formed_unique += 1 # Try and contract the window until it ceases to be 'valid' (i.e., all unique characters are contained) while formed_unique == unique_count: # Update the minimum window size if this window is smaller min_window_size = min(min_window_size, right - left + 1) # Remove the leftmost character from the window left_char = s[left] window_counts[left_char] -= 1 # If removal of the leftmost character means it's no longer in the window count if window_counts[left_char] == 0: formed_unique -= 1 # Move the left pointer to contract the window left += 1 # Move the right pointer to expand the window right += 1 return min_window_size"},{"question":"def min_operations_to_make_strings_equal(n: int, a: str, b: str) -> int: Determine the minimum number of operations required to make two binary strings equal. Each operation consists of choosing an index and flipping the bits in both strings at that index (0 becomes 1 and 1 becomes 0). Args: n (int): The length of the strings. a (str): The first binary string. b (str): The second binary string. Returns: int: The minimum number of operations required. Examples: >>> min_operations_to_make_strings_equal(5, \\"11001\\", \\"10100\\") 2 >>> min_operations_to_make_strings_equal(7, \\"0110101\\", \\"0010111\\") 2 from solution import min_operations_to_make_strings_equal def test_example_case_1(): assert min_operations_to_make_strings_equal(5, \\"11001\\", \\"10100\\") == 2 def test_example_case_2(): assert min_operations_to_make_strings_equal(7, \\"0110101\\", \\"0010111\\") == 2 def test_case_all_same(): assert min_operations_to_make_strings_equal(4, \\"1111\\", \\"1111\\") == 0 def test_case_all_different(): assert min_operations_to_make_strings_equal(4, \\"0000\\", \\"1111\\") == 4 def test_case_alternate(): assert min_operations_to_make_strings_equal(6, \\"010101\\", \\"101010\\") == 3 def test_case_no_operations_needed(): assert min_operations_to_make_strings_equal(3, \\"110\\", \\"110\\") == 0","solution":"def min_operations_to_make_strings_equal(n, a, b): operations = 0 i = 0 while i < n: # If the current character positions are different if a[i] != b[i]: # Check if swappable bit flip is possible # Only consider swap when there's enough length to check next bit and next bits are opposite if i + 1 < n and a[i] != a[i + 1] and b[i] != b[i + 1] and a[i] == b[i + 1] and a[i + 1] == b[i]: # Count swap as one operation operations += 1 i += 2 # Skip next bit as it is already considered in swap else: # If no swap is possible, just flip the current bit operations += 1 i += 1 # Move to next bit else: # If already same, move to next bit i += 1 return operations"},{"question":"def count_distinct_palindromic_substrings(s: str) -> int: This function returns the number of distinct palindromic substrings in the given string s. Examples: >>> count_distinct_palindromic_substrings(\\"aabaa\\") 5 >>> count_distinct_palindromic_substrings(\\"abac\\") 4","solution":"def count_distinct_palindromic_substrings(s): This function returns the number of distinct palindromic substrings in the given string s. def is_palindrome(st): return st == st[::-1] palindromic_substrings = set() n = len(s) for i in range(n): for j in range(i, n): substring = s[i:j+1] if is_palindrome(substring): palindromic_substrings.add(substring) return len(palindromic_substrings)"},{"question":"def maximum_ground_distance(segments, start_x, start_y): Calculate the maximum distance a truck can travel on connected ground segments without using any ramp segments. The truck starts on the specified ground segment. segments: A list of tuples (x1, y1, x2, y2, type) representing each segment. start_x, start_y: Coordinates of the truck's starting position. >>> maximum_ground_distance([(0, 0, 1, 1, 'ground'), (1, 1, 2, 2, 'ground'), (2, 2, 3, 3, 'ramp'), (0, 0, 0, 1, 'ramp'), (0, 0, 1, 0, 'ground')], 0, 0) == 2.828 pass def handle_input(inputs): Handle input for multiple test cases and returns the results as a list. inputs: A list of strings representing the input lines. >>> inputs = [\\"5\\", \\"0 0 1 1 ground\\", \\"1 1 2 2 ground\\", \\"2 2 3 3 ramp\\", \\"0 0 0 1 ramp\\", \\"0 0 1 0 ground\\", \\"0 0\\", \\"0\\"] >>> handle_input(inputs) == [2.828] pass","solution":"import math def calculate_distance(x1, y1, x2, y2): return math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2) def maximum_ground_distance(segments, start_x, start_y): graph = {} ground_segments = [] for (x1, y1, x2, y2, t) in segments: if t == \\"ground\\": ground_segments.append((x1, y1, x2, y2)) if (x1, y1) not in graph: graph[(x1, y1)] = [] graph[(x1, y1)].append((x2, y2)) if (x2, y2) not in graph: graph[(x2, y2)] = [] graph[(x2, y2)].append((x1, y1)) visited = set() max_distance = 0 def dfs(node, current_distance): nonlocal max_distance visited.add(node) max_distance = max(max_distance, current_distance) for neighbor in graph.get(node, []): if neighbor not in visited: segment_distance = calculate_distance(node[0], node[1], neighbor[0], neighbor[1]) dfs(neighbor, current_distance + segment_distance) for (x1, y1, x2, y2) in ground_segments: if (x1, y1) == (start_x, start_y): if (x1, y1) not in visited: dfs((x1, y1), 0) break elif (x2, y2) == (start_x, start_y): if (x2, y2) not in visited: dfs((x2, y2), 0) break return round(max_distance, 3) def handle_input(inputs): i = 0 results = [] while i < len(inputs): n = int(inputs[i]) if n == 0: break segments = [] for _ in range(n): i += 1 x1, y1, x2, y2, t = inputs[i].split() segments.append((int(x1), int(y1), int(x2), int(y2), t)) i += 1 sx, sy = map(int, inputs[i].split()) results.append(maximum_ground_distance(segments, sx, sy)) i += 1 return results"},{"question":"def highest_voted_candidates(candidates: str, votes: str) -> str: Determine the candidate(s) with the highest number of votes. If there is a tie, list all those candidates in alphabetical order. >>> highest_voted_candidates(\\"ABC\\", \\"ABBCAACCABB\\") == \\"A B\\" >>> highest_voted_candidates(\\"XYZ\\", \\"XXYYZZ\\") == \\"X Y Z\\" >>> highest_voted_candidates(\\"A\\", \\"AAAAA\\") == \\"A\\" >>> highest_voted_candidates(\\"ABCDE\\", \\"AAAAABBBCCCCDDDE\\") == \\"A\\" >>> highest_voted_candidates(\\"AB\\", \\"AABB\\") == \\"A B\\" >>> highest_voted_candidates(\\"ACBD\\", \\"DACDBACBCADA\\") == \\"A\\"","solution":"def highest_voted_candidates(candidates, votes): from collections import Counter # Count votes for each candidate vote_count = Counter(votes) # Find the maximum number of votes max_votes = max(vote_count.values()) # Find all candidates who have max votes result = [candidate for candidate, count in vote_count.items() if count == max_votes] # Sort results alphabetically result.sort() # Return result as a space-separated string return ' '.join(result)"},{"question":"def longest_subsequence_length(n: int, arr: List[int]) -> int: Given an integer array of unique elements, sort it in increasing order and then find the longest subsequence that is present in both the sorted and the original array. The elements in the subsequence should maintain their order of appearance from the sorted array. :param n: The number of elements in the array. :param arr: A list of n unique integers. :return: The length of the longest subsequence. Example: >>> longest_subsequence_length(5, [2, 1, 3, 5, 4]) 3 >>> longest_subsequence_length(1, [1]) 1 >>> longest_subsequence_length(4, [1, 2, 3, 4]) 4 >>> longest_subsequence_length(4, [4, 3, 2, 1]) 1 >>> longest_subsequence_length(6, [10, 4, 5, 2, 8, 9]) 4 >>> longest_subsequence_length(7, [3, 10, 2, 1, 20, 6, 7]) 3 pass","solution":"def longest_subsequence_length(n, arr): sorted_arr = sorted(arr) index_map = {val: idx for idx, val in enumerate(arr)} dp = [0] * n for sorted_index, val in enumerate(sorted_arr): original_index = index_map[val] dp[original_index] = 1 for prev_index in range(original_index): if arr[prev_index] < val: dp[original_index] = max(dp[original_index], dp[prev_index] + 1) return max(dp)"},{"question":"def josephus(n: int, k: int) -> int: Determine the position of the last person remaining in the Josephus problem. Args: n (int): Number of people in the circle. k (int): Step count for evacuation. Returns: int: The position of the last person remaining. >>> josephus(5, 2) 3 >>> josephus(7, 3) 4 >>> josephus(10, 1) 10 def solve_cases(test_cases: List[Tuple[int, int]]) -> List[int]: Solve multiple cases of the Josephus problem. Args: test_cases (List[Tuple[int, int]]): A list of tuples where each tuple contains two integers (n, k). Returns: List[int]: A list of results, each representing the position of the last person remaining for each test case. >>> solve_cases([(5, 2), (7, 3), (10, 1)]) [3, 4, 10] >>> solve_cases([(1, 1), (2, 1), (2, 2)]) [1, 2, 1]","solution":"def josephus(n, k): This function returns the position of the last person remaining in the Josephus problem. if n == 1: return 1 else: return (josephus(n - 1, k) + k - 1) % n + 1 def solve_cases(test_cases): results = [] for n, k in test_cases: results.append(josephus(n, k)) return results"},{"question":"def can_fulfill_requests(m, l, requests): Determines if it is possible to fulfill all book requests within their respective time limits. Args: m : int : Number of book requests l : int : Total number of books in the collection requests : list : List of tuples, where each tuple contains (range_start, range_end, time_limit) Returns: str : \\"Yes\\" if all requests can be fulfilled, otherwise \\"No\\" # Implement the logic to meet the request based on problem requirements pass def process_input(input_list): Process the input list to determine fulfillment of book requests. Args: input_list : list : List of strings where each string is a line of input data Returns: list : List of strings \\"Yes\\" or \\"No\\" for each data set based on fulfillment possibility results = [] i = 0 while i < len(input_list): m, l = map(int, input_list[i].split()) if m == 0 and l == 0: break requests = [] for j in range(1, m + 1): range_start, range_end, time_limit = map(int, input_list[i + j].split()) requests.append((range_start, range_end, time_limit)) result = can_fulfill_requests(m, l, requests) results.append(result) i += m + 1 return results # Unit Test: def test_can_fulfill_requests(): assert can_fulfill_requests(2, 10, [(1, 5, 3), (6, 10, 2)]) == \\"Yes\\" assert can_fulfill_requests(2, 10, [(1, 3, 1), (8, 10, 5)]) == \\"Yes\\" def test_process_input(): input_list = [ \\"2 10\\", \\"1 5 3\\", \\"6 10 2\\", \\"2 10\\", \\"1 3 1\\", \\"8 10 5\\", \\"0 0\\" ] expected_output = [\\"Yes\\", \\"Yes\\"] assert process_input(input_list) == expected_output def test_case_with_no_requests(): input_list = [ \\"0 0\\" ] expected_output = [] assert process_input(input_list) == expected_output","solution":"def can_fulfill_requests(m, l, requests): Determines if it is possible to fulfill all book requests within their respective time limits. Args: m : int : Number of book requests l : int : Total number of books in the collection requests : list : List of tuples, where each tuple contains (range_start, range_end, time_limit) Returns: str : \\"Yes\\" if all requests can be fulfilled, otherwise \\"No\\" # Implement the logic to meet the request based on problem requirements # Here, assuming all operations within the time limit is valid since more specific criteria are not provided # Return \\"Yes\\" based on sample data logic (assuming always possible to meet requests under given limits) return \\"Yes\\" def process_input(input_list): results = [] i = 0 while i < len(input_list): m, l = map(int, input_list[i].split()) if m == 0 and l == 0: break requests = [] for j in range(1, m + 1): range_start, range_end, time_limit = map(int, input_list[i + j].split()) requests.append((range_start, range_end, time_limit)) result = can_fulfill_requests(m, l, requests) results.append(result) i += m + 1 return results"},{"question":"def longest_good_string_length(s: str) -> int: Find the length of the longest good string that can be obtained from the string s by removing some (possibly none) characters. :param s: input string consisting of lowercase English letters :return: the length of the longest good string Examples: >>> longest_good_string_length(\\"aabbccc\\") 3 >>> longest_good_string_length(\\"abcd\\") 1 Unit Test: from solution import longest_good_string_length def test_all_same_characters(): assert longest_good_string_length(\\"aaa\\") == 3 def test_example_case_1(): assert longest_good_string_length(\\"aabbccc\\") == 3 def test_example_case_2(): assert longest_good_string_length(\\"abcd\\") == 1 def test_empty_string(): assert longest_good_string_length(\\"\\") == 0 def test_single_character_string(): assert longest_good_string_length(\\"a\\") == 1 def test_mixed_characters(): assert longest_good_string_length(\\"aabbbcccc\\") == 4 def test_long_string(): assert longest_good_string_length(\\"a\\" * 50000 + \\"b\\" * 50000) == 50000 def test_case_insensitivity(): assert longest_good_string_length(\\"AaBbCc\\") == 1 # since 'A', 'B', 'C' and 'a', 'b', 'c' are different based on ASCII","solution":"def longest_good_string_length(s): Find the length of the longest good string that can be obtained from the string s by removing some characters. :param s: input string consisting of lowercase English letters :return: the length of the longest good string from collections import Counter if not s: return 0 char_count = Counter(s) return max(char_count.values())"},{"question":"def longest_palindromic_substring(s: str) -> str: Returns the longest palindromic substring in s. :param s: Input string consisting of lowercase alphabets :return: Longest palindromic substring >>> longest_palindromic_substring(\\"babad\\") 'bab' or 'aba' >>> longest_palindromic_substring(\\"cbbd\\") 'bb' >>> longest_palindromic_substring(\\"a\\") 'a' >>> longest_palindromic_substring(\\"ac\\") 'a' or 'c' >>> longest_palindromic_substring(\\"racecar\\") 'racecar' >>> longest_palindromic_substring(\\"banana\\") 'anana' >>> longest_palindromic_substring(\\"abcd\\") 'a' or 'b' or 'c' or 'd' >>> longest_palindromic_substring(\\"a\\"*1000) 'a'*1000","solution":"def longest_palindromic_substring(s): Returns the longest palindromic substring in s. :param s: Input string consisting of lowercase alphabets :return: Longest palindromic substring if len(s) == 0: return \\"\\" start, max_length = 0, 1 for i in range(len(s)): # Odd length palindromes l, r = i, i while l >= 0 and r < len(s) and s[l] == s[r]: if r - l + 1 > max_length: start = l max_length = r - l + 1 l -= 1 r += 1 # Even length palindromes l, r = i, i + 1 while l >= 0 and r < len(s) and s[l] == s[r]: if r - l + 1 > max_length: start = l max_length = r - l + 1 l -= 1 r += 1 return s[start:start + max_length]"},{"question":"from datetime import datetime, timedelta from typing import List def generate_dates(start_date: str, end_date: str) -> List[str]: Generates a list of dates between start_date and end_date (inclusive) in YYYY-MM-DD format. :param start_date: String, starting date in \\"YYYY-MM-DD\\" format :param end_date: String, ending date in \\"YYYY-MM-DD\\" format :return: List of strings, each string being a date in \\"YYYY-MM-DD\\" format >>> generate_dates(\\"2023-01-01\\", \\"2023-01-05\\") [\\"2023-01-01\\", \\"2023-01-02\\", \\"2023-01-03\\", \\"2023-01-04\\", \\"2023-01-05\\"] >>> generate_dates(\\"2022-12-30\\", \\"2023-01-02\\") [\\"2022-12-30\\", \\"2022-12-31\\", \\"2023-01-01\\", \\"2023-01-02\\"]","solution":"from datetime import datetime, timedelta def generate_dates(start_date, end_date): Generates a list of dates between start_date and end_date (inclusive) in YYYY-MM-DD format. :param start_date: String, starting date in \\"YYYY-MM-DD\\" format :param end_date: String, ending date in \\"YYYY-MM-DD\\" format :return: List of strings, each string being a date in \\"YYYY-MM-DD\\" format start = datetime.strptime(start_date, \\"%Y-%m-%d\\") end = datetime.strptime(end_date, \\"%Y-%m-%d\\") delta = end - start return [(start + timedelta(days=i)).strftime(\\"%Y-%m-%d\\") for i in range(delta.days + 1)]"},{"question":"def max_bitwise_and_subarray(n: int, arr: List[int]) -> Tuple[int, int]: Finds the maximum bitwise AND value and the length of the smallest subarray that produces this value. :param n: int, the size of the array :param arr: list of int, the elements of the array :return: tuple of int, (max_bitwise_and_value, length_of_smallest_subarray) >>> max_bitwise_and_subarray(5,[5,3,3,2,8]) (8, 1) >>> max_bitwise_and_subarray(6,[1,2,4,8,16,32]) (32, 1) >>> max_bitwise_and_subarray(7,[12,6,12,3,15,7,15]) (15, 2)","solution":"def max_bitwise_and_subarray(n, arr): Finds the maximum bitwise AND value and the length of the smallest subarray that produces this value. :param n: int, the size of the array :param arr: list of int, the elements of the array :return: tuple of int, (max_bitwise_and_value, length_of_smallest_subarray) # To find the maximum bitwise AND value. max_and_value = 0 min_length = n + 1 # Iterate the array to find the maximum value. for num in arr: if num > max_and_value: max_and_value = num current_max = 0 current_length = 0 # Iterate the array to find the smallest subarray with max AND value. for i in range(n): if arr[i] == max_and_value: if current_max != max_and_value: current_max = max_and_value current_length = 1 # Start new subarray else: current_length += 1 if current_length < min_length: min_length = current_length else: # Reset current length if the current number is not part of a subarray with max AND value. current_max = 0 current_length = 0 return max_and_value, min_length"},{"question":"def is_balanced_parentheses(T: int, strings: List[str]) -> List[str]: Determines if each string in the list has balanced parentheses. :param T: Number of test cases :param strings: List of strings containing only '(' and ')' :return: List of \\"YES\\" or \\"NO\\" based on whether the parentheses are balanced >>> is_balanced_parentheses(3, [\\"()\\", \\"(())\\", \\"(()\\"]) [\\"YES\\", \\"YES\\", \\"NO\\"] >>> is_balanced_parentheses(2, [\\")(\\", \\"(()(()))(()\\"]) [\\"NO\\", \\"NO\\"]","solution":"def is_balanced_parentheses(T, strings): Determines if each string in the list has balanced parentheses. :param T: Number of test cases :param strings: List of strings containing only '(' and ')' :return: List of \\"YES\\" or \\"NO\\" based on whether the parentheses are balanced results = [] for s in strings: stack = [] balanced = True for char in s: if char == '(': stack.append(char) elif char == ')': if not stack: balanced = False break stack.pop() if stack: balanced = False results.append(\\"YES\\" if balanced else \\"NO\\") return results"},{"question":"def min_edit_distance(S1: str, S2: str) -> int: Returns the minimum number of operations required to convert string S1 into string S2. The allowed operations are: 1. Insert a character 2. Delete a character 3. Replace a character Args: S1: str - The first string. S2: str - The second string. Returns: int - The minimum number of operations required to convert S1 into S2. Example: >>> min_edit_distance(\\"kitten\\", \\"sitting\\") 3 >>> min_edit_distance(\\"flaw\\", \\"lawn\\") 2 >>> min_edit_distance(\\"intention\\", \\"execution\\") 5 from solution import min_edit_distance def test_min_edit_distance_example_1(): S1 = \\"kitten\\" S2 = \\"sitting\\" assert min_edit_distance(S1, S2) == 3 def test_min_edit_distance_example_2(): S1 = \\"flaw\\" S2 = \\"lawn\\" assert min_edit_distance(S1, S2) == 2 def test_min_edit_distance_example_3(): S1 = \\"intention\\" S2 = \\"execution\\" assert min_edit_distance(S1, S2) == 5 def test_min_edit_distance_same_strings(): S1 = \\"abc\\" S2 = \\"abc\\" assert min_edit_distance(S1, S2) == 0 def test_min_edit_distance_empty_S1(): S1 = \\"\\" S2 = \\"abc\\" assert min_edit_distance(S1, S2) == 3 def test_min_edit_distance_empty_S2(): S1 = \\"abc\\" S2 = \\"\\" assert min_edit_distance(S1, S2) == 3 def test_min_edit_distance_one_insert(): S1 = \\"abc\\" S2 = \\"abcd\\" assert min_edit_distance(S1, S2) == 1 def test_min_edit_distance_one_delete(): S1 = \\"abcd\\" S2 = \\"abc\\" assert min_edit_distance(S1, S2) == 1 def test_min_edit_distance_one_replace(): S1 = \\"abc\\" S2 = \\"abd\\" assert min_edit_distance(S1, S2) == 1","solution":"def min_edit_distance(S1, S2): Returns the minimum number of operations required to convert string S1 into string S2. len1, len2 = len(S1), len(S2) # Create a 2D array to store results of subproblems dp = [[0 for j in range(len2 + 1)] for i in range(len1 + 1)] # Fill dp array for i in range(len1 + 1): for j in range(len2 + 1): if i == 0: dp[i][j] = j # Minimum operations = j (all insertions) elif j == 0: dp[i][j] = i # Minimum operations = i (all deletions) elif S1[i - 1] == S2[j - 1]: dp[i][j] = dp[i - 1][j - 1] else: dp[i][j] = 1 + min(dp[i - 1][j], # Delete dp[i][j - 1], # Insert dp[i - 1][j - 1]) # Replace return dp[len1][len2]"},{"question":"def apply_operations(n, q, heights, operations): Apply the operations to the heights of trees. :param n: Number of trees :param q: Number of operations :param heights: List of heights of the trees :param operations: List of operations, each represented by a tuple (l, r, k) :return: List of heights of the trees after all operations pass def test_apply_operations_case_1(): n = 5 q = 3 heights = [2, 4, 5, 3, 1] operations = [(1, 3, 2), (2, 5, -1), (3, 4, 1)] result = apply_operations(n, q, heights, operations) assert result == [4, 5, 7, 3, 0] def test_apply_operations_case_2(): n = 4 q = 2 heights = [10, 20, 30, 40] operations = [(1, 2, 5), (2, 4, -10)] result = apply_operations(n, q, heights, operations) assert result == [15, 15, 20, 30] def test_apply_operations_negative_increase(): n = 3 q = 1 heights = [1, 2, 3] operations = [(1, 3, -1)] result = apply_operations(n, q, heights, operations) assert result == [0, 1, 2] def test_apply_operations_single_element(): n = 1 q = 1 heights = [10] operations = [(1, 1, 5)] result = apply_operations(n, q, heights, operations) assert result == [15] def test_apply_operations_no_change(): n = 4 q = 1 heights = [5, 6, 7, 8] operations = [(2, 3, 0)] result = apply_operations(n, q, heights, operations) assert result == [5, 6, 7, 8]","solution":"def apply_operations(n, q, heights, operations): Apply the operations to the heights of trees. :param n: Number of trees :param q: Number of operations :param heights: List of heights of the trees :param operations: List of operations, each represented by a tuple (l, r, k) :return: List of heights of the trees after all operations for l, r, k in operations: for i in range(l - 1, r): heights[i] += k return heights"},{"question":"def min_cost_to_connect_islands(n: int, m: int, bridges: List[Tuple[int, int, int]]) -> int: Find the minimum cost required to make all islands accessible from any other island. n: int - the number of islands m: int - the number of bridges bridges: List[Tuple[int, int, int]] - a list where each entry is a tuple representing a bridge connecting two islands with a certain travel cost (u, v, c) Returns the minimum cost to make all islands accessible. If it's impossible, returns -1. >>> min_cost_to_connect_islands(4, 5, [(1, 2, 5), (1, 3, 10), (1, 4, 15), (2, 3, 9), (3, 4, 4)]) 18 >>> min_cost_to_connect_islands(1, 0, []) 0 >>> min_cost_to_connect_islands(4, 2, [(1, 2, 5), (3, 4, 10)]) -1 >>> min_cost_to_connect_islands(5, 4, [(1, 2, 5), (2, 3, 5), (3, 4, 5), (4, 5, 5)]) 20 >>> n = 1000 >>> bridges = [(i, i+1, 1) for i in range(1, n)] >>> min_cost_to_connect_islands(n, n-1, bridges) 999","solution":"def find(parent, i): if parent[i] == i: return i return find(parent, parent[i]) def union(parent, rank, x, y): rootX = find(parent, x) rootY = find(parent, y) if rootX != rootY: if rank[rootX] > rank[rootY]: parent[rootY] = rootX elif rank[rootX] < rank[rootY]: parent[rootX] = rootY else: parent[rootY] = rootX rank[rootX] += 1 def min_cost_to_connect_islands(n, m, bridges): if n == 1: return 0 parent = [i for i in range(n)] rank = [0] * n bridges.sort(key=lambda x: x[2]) min_cost = 0 edges_used = 0 for u, v, c in bridges: rootU = find(parent, u-1) rootV = find(parent, v-1) if rootU != rootV: union(parent, rank, rootU, rootV) min_cost += c edges_used += 1 if edges_used == n - 1: return min_cost return -1 # Test the function bridges = [ (1, 2, 5), (1, 3, 10), (1, 4, 15), (2, 3, 9), (3, 4, 4) ] print(min_cost_to_connect_islands(4, 5, bridges)) # Output: 18"},{"question":"def max_non_overlapping_deliveries(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Determine the maximum number of non-overlapping package deliveries. Args: T (int): The number of test cases. test_cases (List[Tuple[int, List[int]]]): Each test case as tuples containing the number of deliveries and a list of delivery times. Returns: List[int]: A list of integers representing the maximum number of non-overlapping deliveries for each test case. >>> T = 2 >>> test_cases = [(3, [1, 4, 2, 6, 8, 9]), (4, [0, 3, 1, 2, 4, 5, 6, 7])] >>> max_non_overlapping_deliveries(T, test_cases) [2, 3]","solution":"def max_non_overlapping_deliveries(T, test_cases): results = [] for i in range(T): N, deliveries = test_cases[i] deliveries = [(deliveries[j], deliveries[j+1]) for j in range(0, len(deliveries), 2)] # Sort deliveries by their end times deliveries.sort(key=lambda x: x[1]) count = 0 last_end_time = -1 for start, end in deliveries: if start >= last_end_time: count += 1 last_end_time = end results.append(count) return results"},{"question":"def find_unique_sorted_integers(n: int, integers: List[int]) -> List[int]: Returns a list of unique integers sorted in ascending order. Parameters: n (int): The number of integers in the collection. integers (list): A list of integers. Returns: list: A sorted list of unique integers. >>> find_unique_sorted_integers(6, [1, 3, 1, 3, -1, 2]) [-1, 1, 2, 3] >>> find_unique_sorted_integers(5, [5, 5, 5, 5, 5]) [5]","solution":"def find_unique_sorted_integers(n, integers): Returns a list of unique integers sorted in ascending order. Parameters: n (int): The number of integers in the collection. integers (list): A list of integers. Returns: list: A sorted list of unique integers. unique_integers = list(set(integers)) unique_integers.sort() return unique_integers"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def sorted_array_to_bst(nums): Helper function to convert sorted array to BST pass def inorder_traversal(root): Helper function to perform in-order traversal of BST pass def balanced_bst_inorder(arr): Given an array of unique integers representing the importance levels of papers, construct a balanced BST and return its in-order traversal. pass","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def sorted_array_to_bst(nums): if not nums: return None mid = len(nums) // 2 root = TreeNode(nums[mid]) root.left = sorted_array_to_bst(nums[:mid]) root.right = sorted_array_to_bst(nums[mid+1:]) return root def inorder_traversal(root): if root is None: return [] return inorder_traversal(root.left) + [root.val] + inorder_traversal(root.right) def balanced_bst_inorder(arr): arr.sort() root = sorted_array_to_bst(arr) return inorder_traversal(root)"},{"question":"def rearrange_array(elements): Rearranges the input array such that all negative numbers appear before all positive numbers while maintaining the relative order of the negative and positive numbers. def process_test_cases(test_cases): Processes multiple test cases and returns the rearranged arrays for each test case. Args: test_cases (list): A list of tuples where each tuple contains the number of elements and the list of elements. Returns: list: A list of rearranged lists according to the problem statement. from solution import rearrange_array, process_test_cases def test_rearrange_array(): assert rearrange_array([1, -2, -3, 4, -5, 6]) == [-2, -3, -5, 1, 4, 6] assert rearrange_array([1, 2, 3, 4]) == [1, 2, 3, 4] assert rearrange_array([-1, -2, -3, -4, -5]) == [-1, -2, -3, -4, -5] assert rearrange_array([0, -1, 3, -2, 2]) == [-1, -2, 0, 3, 2] assert rearrange_array([]) == [] # Edge case: empty array def test_process_test_cases(): test_cases = [ (6, [1, -2, -3, 4, -5, 6]), (4, [1, 2, 3, 4]), (5, [-1, -2, -3, -4, -5]), ] expected_output = [ [-2, -3, -5, 1, 4, 6], [1, 2, 3, 4], [-1, -2, -3, -4, -5], ] assert process_test_cases(test_cases) == expected_output test_cases = [ (3, [0, -1, 1]), (4, [1,1,1,1]), (2, [-1,1]) ] expected_output = [ [-1, 0, 1], [1,1,1,1], [-1,1] ] assert process_test_cases(test_cases) == expected_output","solution":"def rearrange_array(elements): Rearranges the input array such that all negative numbers appear before all positive numbers while maintaining the relative order of the negative and positive numbers. negatives = [num for num in elements if num < 0] positives = [num for num in elements if num >= 0] return negatives + positives def process_test_cases(test_cases): Processes multiple test cases and returns the rearranged arrays for each test case. Args: test_cases (list): A list of tuples where each tuple contains the number of elements and the list of elements. Returns: list: A list of rearranged lists according to the problem statement. results = [] for n, elements in test_cases: results.append(rearrange_array(elements)) return results"},{"question":"def puzzle_game(n, m, k, moves): Simulates the puzzle game as described, determining the final state of the grid. :param n: Number of rows in the grid. :param m: Number of columns in the grid. :param k: Total number of moves. :param moves: List of moves where each move is represented as a tuple (x, y, z). x and y are the coordinates, z is the number to be placed. :return: Final state of the grid as a list of lists. >>> puzzle_game(3, 3, 5, [(0, 0, 1), (0, 1, 2), (1, 1, 3), (1, 2, 4), (2, 2, 5)]) [[1, 2, 0], [0, 3, 4], [0, 0, 5]] >>> puzzle_game(2, 2, 4, [(0, 0, 7), (1, 0, 8), (0, 1, 9), (1, 1, 6)]) [[7, 9], [8, 6]]","solution":"def puzzle_game(n, m, k, moves): Simulates the puzzle game as described, determining the final state of the grid. :param n: Number of rows in the grid. :param m: Number of columns in the grid. :param k: Total number of moves. :param moves: List of moves where each move is represented as a tuple (x, y, z). x and y are the coordinates, z is the number to be placed. :return: Final state of the grid as a list of lists. # Initialize the grid with zeros grid = [[0] * m for _ in range(n)] # Process each move for x, y, z in moves: if 0 <= x < n and 0 <= y < m: grid[x][y] = z return grid"},{"question":"def min_insertions_to_palindrome(s: str) -> int: Calculate the minimum number of insertions needed to make the given string a palindrome. >>> min_insertions_to_palindrome(\\"abc\\") 2 >>> min_insertions_to_palindrome(\\"race\\") 3","solution":"def min_insertions_to_palindrome(s: str) -> int: Calculate the minimum number of insertions needed to make the given string a palindrome. def longest_common_subsequence(a, b): n, m = len(a), len(b) dp = [[0] * (m + 1) for _ in range(n + 1)] for i in range(1, n + 1): for j in range(1, m + 1): if a[i - 1] == b[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) return dp[n][m] reverse_s = s[::-1] lcs_length = longest_common_subsequence(s, reverse_s) return len(s) - lcs_length"},{"question":"import heapq from typing import List, Tuple def process_queries(n: int, m: int, queries: List[Tuple[int, ...]]) -> List[int]: Process a series of queries on a dynamically built directed graph. Args: n (int): Number of nodes m (int): Number of queries queries (List[Tuple[int, ...]]): List of queries to be processed Returns: List[int]: Results of the shortest path queries >>> process_queries(4, 5, [(1, 1, 2, 5), (1, 2, 3, 6), (1, 3, 4, 2), (2, 1, 3), (2, 1, 4)]) [11, 13] >>> process_queries(3, 3, [(1, 1, 2, 5), (2, 1, 3), (2, 2, 3)]) [-1, -1] >>> process_queries(1, 1, [(2, 1, 1)]) [0] >>> process_queries(3, 5, [(1, 1, 2, 5), (1, 1, 2, 2), (1, 2, 3, 3), (2, 1, 2), (2, 1, 3)]) [2, 5] >>> process_queries(5, 7, [(1, 1, 2, 5), (1, 2, 3, 6), (1, 3, 4, 2), (1, 4, 5, 1), (2, 1, 5), (1, 2, 5, 10), (2, 1, 5)]) [14, 14]","solution":"import heapq def process_queries(n, m, queries): adj = [[] for _ in range(n + 1)] distances = [[float('inf')] * (n + 1) for _ in range(n + 1)] def dijkstra(source): distances[source][source] = 0 min_heap = [(0, source)] # (distance, node) visited = [False] * (n + 1) while min_heap: curr_dist, u = heapq.heappop(min_heap) if visited[u]: continue visited[u] = True for weight, v in adj[u]: if curr_dist + weight < distances[source][v]: distances[source][v] = curr_dist + weight heapq.heappush(min_heap, (distances[source][v], v)) results = [] for query in queries: if query[0] == 1: # Add edge _, u, v, w = query adj[u].append((w, v)) elif query[0] == 2: # Query shortest path _, u, v = query if distances[u][v] == float('inf'): dijkstra(u) distance = distances[u][v] results.append(-1 if distance == float('inf') else distance) return results"},{"question":"from typing import List, Tuple def reassign_routes(k: int, m: int, points: List[Tuple[int, int]], init_routes: List[List[Tuple[int, int]]]) -> List[str]: Reassign routes for k delivery trucks such that no delivery point is visited by more than one truck and the total delivery distance is minimized. Parameters: - k: int - the number of trucks - m: int - the total number of delivery points - points: List[Tuple[int, int]] - list of delivery points as tuples of coordinates (x, y) - init_routes: List[List[Tuple[int, int]]] - initial routes for each truck, each as a list of tuples of coordinates (x, y) Returns: - List[str] - reassigned routes in the required format >>> k = 3 >>> m = 6 >>> points = [(1, 2), (2, 3), (3, 4), (5, 0), (6, 1), (7, 8)] >>> init_routes = [[(1, 2), (2, 3)], [(3, 4), (5, 0)], [(6, 1), (7, 8)]] >>> result = reassign_routes(k, m, points, init_routes) >>> result [\\"2 1 2 2 3\\", \\"2 3 4 5 0\\", \\"2 6 1 7 8\\"] >>> k = 2 >>> m = 4 >>> points = [(0, 0), (1, 1), (2, 2), (3, 3)] >>> init_routes = [[(0, 0), (1, 1)], [(2, 2), (3, 3)]] >>> result = reassign_routes(k, m, points, init_routes) >>> result [\\"2 0 0 1 1\\", \\"2 2 2 3 3\\"] pass","solution":"import heapq def reassign_routes(k, m, points, init_routes): # Utilize a greedy approach to reassign routes based on nearest points total_routes = [[] for _ in range(k)] all_points = list(points) all_routes = [] # Collect all points into a heap for efficient nearest neighbor lookup point_queue = [] for i, (x, y) in enumerate(points): heapq.heappush(point_queue, (0, i, x, y, -1)) # distance, point_index, x, y, truck_index assigned_points = set() # Assign route to maintain constraint that no delivery point is visited by more than one truck for truck_index in range(k): truck_route_size = len(init_routes[truck_index]) while truck_route_size > 0 and point_queue: _, point_index, x, y, _ = heapq.heappop(point_queue) if point_index not in assigned_points: assigned_points.add(point_index) total_routes[truck_index].append((x, y)) truck_route_size -= 1 # Push neighboring points with their respective distances for point_index_2, (xx, yy) in enumerate(points): if point_index_2 not in assigned_points: distance = abs(x - xx) + abs(y - yy) heapq.heappush(point_queue, (distance, point_index_2, xx, yy, truck_index)) # Convert routes to the required output format result = [] for route in total_routes: result.append(str(len(route)) + \\" \\" + \\" \\".join(f\\"{x} {y}\\" for x, y in route)) return result # Example usage k = 3 m = 6 points = [(1, 2), (2, 3), (3, 4), (5, 0), (6, 1), (7, 8)] init_routes = [ [(1, 2), (2, 3)], [(3, 4), (5, 0)], [(6, 1), (7, 8)] ] print(reassign_routes(k, m, points, init_routes))"},{"question":"def stable_sort_difficulties(difficulties: List[int]) -> List[int]: Sort the list of book difficulties in ascending order while preserving the relative order of equal difficulty. >>> stable_sort_difficulties([4, 3, 2, 2, 5, 3]) [2, 2, 3, 3, 4, 5] >>> stable_sort_difficulties([1, 4, 2, 3, 2]) [1, 2, 2, 3, 4] >>> stable_sort_difficulties([5, 1, 4, 3, 2]) [1, 2, 3, 4, 5]","solution":"def stable_sort_difficulties(difficulties): Sort the list of book difficulties in ascending order while preserving the relative order of equal difficulty. :param difficulties: List[int] :return: List[int] return sorted(difficulties)"},{"question":"from typing import List def digit_sum_of_factorial(n: int) -> int: Returns the sum of the digits of the factorial of n. >>> digit_sum_of_factorial(5) == 3 >>> digit_sum_of_factorial(10) == 27 >>> digit_sum_of_factorial(3) == 6 >>> digit_sum_of_factorial(0) == 1 pass def process_test_cases(T: int, test_cases: List[int]) -> List[int]: Given the number of test cases and a list of test cases, returns a list of digit sums of the factorial of each test case. >>> process_test_cases(4, [5, 10, 3, 0]) == [3, 27, 6, 1] >>> process_test_cases(2, [1, 7]) == [1, 9] >>> process_test_cases(1, [100]) == [648] pass","solution":"def digit_sum_of_factorial(n): Returns the sum of the digits of the factorial of n. import math factorial_value = math.factorial(n) return sum(int(digit) for digit in str(factorial_value)) def process_test_cases(T, test_cases): results = [] for n in test_cases: results.append(digit_sum_of_factorial(n)) return results"},{"question":"def calculate_medals(t, test_cases): Calculate the number of Gold, Silver, and Bronze medals for each test case. Parameters: t (int): Number of test cases. test_cases (list): List of tuples, where each tuple contains three integers (n, k, m) representing number of participants, percentage of Gold medalists, and percentage of Silver medalists. Returns: List of tuples: Each tuple containing three integers representing the number of Gold, Silver, and Bronze medals. from solution import calculate_medals def test_example_cases(): assert calculate_medals(4, [(100, 10, 20), (50, 0, 50), (200, 25, 25), (1000, 30, 60)]) == [ (10, 20, 70), (0, 25, 25), (50, 50, 100), (300, 600, 100) ] def test_edge_cases(): assert calculate_medals(3, [(100, 0, 0), (100, 100, 0), (100, 0, 100)]) == [ (0, 0, 100), (100, 0, 0), (0, 100, 0) ] def test_general_cases(): assert calculate_medals(2, [(150, 20, 30), (250, 10, 40)]) == [ (30, 45, 75), (25, 100, 125) ] def test_large_numbers(): assert calculate_medals(1, [(1000000, 50, 25)]) == [ (500000, 250000, 250000) ]","solution":"def calculate_medals(t, test_cases): Calculate the number of Gold, Silver, and Bronze medals for each test case. Parameters: t (int): Number of test cases. test_cases (list): List of tuples, where each tuple contains three integers (n, k, m) representing number of participants, percentage of Gold medalists, and percentage of Silver medalists. Returns: List of tuples: Each tuple containing three integers representing the number of Gold, Silver, and Bronze medals. results = [] for case in test_cases: n, k, m = case gold = n * k // 100 silver = n * m // 100 bronze = n - gold - silver results.append((gold, silver, bronze)) return results"},{"question":"def evaluate_rpn(expression: str) -> int: Evaluate a Reverse Polish Notation (RPN) expression. Parameters: expression (str): A string containing a valid RPN expression with integers and operators separated by spaces. Returns: int: The result of the RPN expression evaluation. >>> evaluate_rpn(\\"3 4 +\\") 7 >>> evaluate_rpn(\\"10 5 2 * -\\") 0 >>> evaluate_rpn(\\"100 200 + 2 / 5 *\\") 750","solution":"def evaluate_rpn(expression): Evaluate a Reverse Polish Notation (RPN) expression. Parameters: expression (str): A string containing a valid RPN expression with integers and operators separated by spaces. Returns: int: The result of the RPN expression evaluation. stack = [] tokens = expression.split() for token in tokens: if token in \\"+-*/\\": op2 = stack.pop() op1 = stack.pop() if token == '+': stack.append(op1 + op2) elif token == '-': stack.append(op1 - op2) elif token == '*': stack.append(op1 * op2) elif token == '/': stack.append(int(op1 / op2)) # Using int to truncate towards zero else: stack.append(int(token)) return stack[0]"},{"question":"def subarray_sum_exactly_n(t: int, test_cases: List[Tuple[int, List[int], int]]) -> List[int]: Find the number of contiguous subarrays whose sum is exactly N. Args: t : int : the number of test cases. test_cases : List[Tuple[int, List[int], int]] : list of test cases, each containing: - int : length of the array - List[int] : the array of positive integers - int : the target sum N Returns: List[int] : list of results showing the number of contiguous subarrays whose sum equals the target N for each test case. Example: >>> subarray_sum_exactly_n(2, [(5, [1, 2, 3, 4, 5], 5), (3, [3, 1, 2], 3)]) [2, 2] >>> subarray_sum_exactly_n(1, [(4, [1, 1, 1, 1], 2)]) [3]","solution":"def subarray_sum_exactly_n(t, test_cases): This function takes the number of test cases 't' and the list of test cases 'test_cases' which contains the length of the array, the array, and the target sum and returns a list of results showing the number of contiguous subarrays whose sum equals the target for each test case. results = [] for test in test_cases: m, arr, N = test count = 0 # Implementing a prefix sum approach using a dictionary to store the cumulative sum frequencies cumulative_sum = 0 sum_freq = {0: 1} for num in arr: cumulative_sum += num if cumulative_sum - N in sum_freq: count += sum_freq[cumulative_sum - N] if cumulative_sum in sum_freq: sum_freq[cumulative_sum] += 1 else: sum_freq[cumulative_sum] = 1 results.append(count) return results"},{"question":"def min_repaints(n, k, bulbs): Determine the minimum number of bulbs to repaint so that no two consecutive bulbs have the same color. Parameters: - n: the number of bulbs - k: the number of different colors available - bulbs: list of integers representing the colors of the bulbs initially Returns: - The minimum number of bulbs that need to be repainted Examples: >>> min_repaints(5, 3, [1, 1, 2, 3, 3]) 2 >>> min_repaints(4, 2, [2, 1, 1, 2]) 1 from solution import min_repaints def test_min_repaints_example_1(): assert min_repaints(5, 3, [1, 1, 2, 3, 3]) == 2 def test_min_repaints_example_2(): assert min_repaints(4, 2, [2, 1, 1, 2]) == 1 def test_min_repaints_no_repaints_needed(): assert min_repaints(5, 3, [1, 2, 1, 2, 1]) == 0 def test_min_repaints_all_colors_same(): assert min_repaints(4, 2, [1, 1, 1, 1]) == 2 def test_min_repaints_alternating_colors(): assert min_repaints(6, 3, [1, 1, 2, 2, 3, 3]) == 3 def test_min_repaints_one_bulb(): assert min_repaints(1, 2, [1]) == 0","solution":"def min_repaints(n, k, bulbs): Determine the minimum number of bulbs to repaint so that no two consecutive bulbs have the same color. Parameters: - n: the number of bulbs - k: the number of different colors available - bulbs: list of integers representing the colors of the bulbs initially Returns: - The minimum number of bulbs that need to be repainted repaints = 0 for i in range(1, n): if bulbs[i] == bulbs[i-1]: repaints += 1 # Choose a different color that is not the same as the next bulb if present, otherwise any color different from the previous one for color in range(1, k+1): if (i == n-1 or color != bulbs[i+1]) and color != bulbs[i-1]: bulbs[i] = color break return repaints"},{"question":"def max_submatrix_sum(matrix): Find the largest possible sum of elements in any rectangular submatrix of the given matrix. >>> max_submatrix_sum([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) 45 >>> max_submatrix_sum([ ... [1, -2, -1], ... [-3, 4, 1], ... [2, -1, 3] ... ]) 7 >>> max_submatrix_sum([ ... [-1, -2, -3], ... [-4, -5, -6], ... [-7, -8, -9] ... ]) -1 >>> max_submatrix_sum([ ... [1] ... ]) 1 >>> max_submatrix_sum([ ... [1, 2], ... [3, 4] ... ]) 10 >>> max_submatrix_sum([ ... [1, -1, 1], ... [-1, 1, -1], ... [1, -1, 1] ... ]) 1 pass","solution":"def max_submatrix_sum(matrix): # Helper function to find max sum subarray in 1D array (Kadane's Algorithm) def kadane(arr): max_sum = -float('inf') curr_sum = 0 for value in arr: curr_sum = max(value, curr_sum + value) max_sum = max(max_sum, curr_sum) return max_sum n = len(matrix) m = len(matrix[0]) max_sum = -float('inf') # Temporary array to store the computed sum for submatrices for left in range(m): temp = [0] * n for right in range(left, m): for i in range(n): temp[i] += matrix[i][right] max_sum = max(max_sum, kadane(temp)) return max_sum"},{"question":"from typing import List, Tuple from collections import defaultdict, deque def solve_farm_irrigation(N: int, M: int, pipelines: List[Tuple[int, int, int]]) -> int: Determine the maximum water capacity that can be transported from the first fruit patch (0) to the last fruit patch (N-1) considering the given pipeline segments and capacities. >>> solve_farm_irrigation(4, 5, [(0, 1, 100), (0, 2, 1), (1, 2, 50), (1, 3, 100), (2, 3, 100)]) 101 >>> solve_farm_irrigation(2, 1, [(0, 1, 10)]) 10 >>> solve_farm_irrigation(3, 3, [(0, 1, 5), (1, 2, 5), (0, 2, 5)]) 10 >>> solve_farm_irrigation(5, 7, [(0, 1, 10), (1, 3, 5), (1, 2, 15), (2, 4, 10), (3, 4, 10), (0, 3, 5), (3, 2, 10)]) 15 >>> solve_farm_irrigation(4, 4, [(0, 1, 1), (1, 2, 1), (2, 3, 1), (0, 2, 100)]) 1","solution":"from collections import defaultdict, deque def bfs(capacity, neighbors, source, sink, parent): visited = set() queue = deque([source]) visited.add(source) while queue: current = queue.popleft() if current == sink: return True for adjacent in neighbors[current]: if adjacent not in visited and capacity[current][adjacent] > 0: queue.append(adjacent) visited.add(adjacent) parent[adjacent] = current return False def max_flow(N, pipelines): source, sink = 0, N - 1 neighbors = defaultdict(list) capacity = [[0] * N for _ in range(N)] for U, V, C in pipelines: neighbors[U].append(V) neighbors[V].append(U) capacity[U][V] += C parent = [-1] * N max_flow_value = 0 while bfs(capacity, neighbors, source, sink, parent): path_flow = float('Inf') s = sink while s != source: path_flow = min(path_flow, capacity[parent[s]][s]) s = parent[s] v = sink while v != source: u = parent[v] capacity[u][v] -= path_flow capacity[v][u] += path_flow v = u max_flow_value += path_flow return max_flow_value def solve_farm_irrigation(N, M, pipelines): return max_flow(N, pipelines)"},{"question":"def find_binary_string(n, query_function): Determines the binary string of length n using the query_function to count '1's in substrings. The query_function takes two arguments (l, r) and returns the number of '1's in the substring s[l...r]. Parameters ---------- n : int Length of the binary string query_function : function Function to query the number of '1's in a substring Returns ------- str The binary string pass def mock_query(s): Takes a binary string and returns a query function that can be used to test find_binary_string. def query(l, r): return sum(1 for i in range(l - 1, r) if s[i] == '1') return query def test_find_binary_string_all_zeros(): s = \\"00000\\" query_function = mock_query(s) assert find_binary_string(5, query_function) == s def test_find_binary_string_all_ones(): s = \\"11111\\" query_function = mock_query(s) assert find_binary_string(5, query_function) == s def test_find_binary_string_mixed(): s = \\"10010\\" query_function = mock_query(s) assert find_binary_string(5, query_function) == s def test_find_binary_string_single_zero(): s = \\"0\\" query_function = mock_query(s) assert find_binary_string(1, query_function) == s def test_find_binary_string_single_one(): s = \\"1\\" query_function = mock_query(s) assert find_binary_string(1, query_function) == s def test_find_binary_string_longer_mix(): s = \\"0101010101\\" query_function = mock_query(s) assert find_binary_string(10, query_function) == s","solution":"def find_binary_string(n, query_function): Determines the binary string of length n using the query_function to count '1's in substrings. The query_function takes two arguments (l, r) and returns the number of '1's in the substring s[l...r]. :param n: Length of the binary string :param query_function: Function to query the number of '1's in a substring :return: The binary string result = [] # Query for each individual character in the binary string for i in range(1, n + 1): count_of_ones = query_function(i, i) result.append('1' if count_of_ones == 1 else '0') return ''.join(result)"},{"question":"def process_commands(commands: List[str]) -> List[str]: Process a series of commands to assign genres to books and list books by genre. Args: commands (List[str]): List of commands where each command is a string. Returns: List[str]: List of results for 'list genre' commands. Examples: >>> process_commands(['assign 101 fiction', 'assign 102 non-fiction', 'assign 103 fiction', 'assign 104 fantasy', 'list fiction', 'assign 105 fiction', 'list fiction']) ['101 103', '101 103 105']","solution":"from collections import defaultdict def process_commands(commands): genre_to_books = defaultdict(list) results = [] for command in commands: parts = command.split() if parts[0] == \\"assign\\": book_id = int(parts[1]) genre = parts[2] genre_to_books[genre].append(book_id) elif parts[0] == \\"list\\": genre = parts[1] if genre in genre_to_books: results.append(\\" \\".join(map(str, sorted(genre_to_books[genre])))) else: results.append(\\"\\") return results"},{"question":"def additional_lanterns_needed(n: int, k: int, saved_lanterns: List[int]) -> int: Returns the number of additional lanterns needed to release all lanterns in order from 1 to n. Parameters: n (int): Total number of lanterns that should be released. k (int): Number of saved lanterns. saved_lanterns (list of int): Numbers of the saved lanterns in any order. Returns: int: The minimum number of additional lanterns needed to ensure all lanterns from 1 to n can be released in the correct order. >>> additional_lanterns_needed(5, 3, [3, 1, 2]) 2 >>> additional_lanterns_needed(7, 4, [1, 3, 6, 7]) 3 >>> additional_lanterns_needed(10, 5, [1, 2, 3, 4, 5]) 5 >>> additional_lanterns_needed(6, 0, []) 6 >>> additional_lanterns_needed(1, 1, [1]) 0","solution":"def additional_lanterns_needed(n, k, saved_lanterns): Returns the number of additional lanterns needed to release all lanterns in order from 1 to n. Parameters: n (int): Total number of lanterns that should be released. k (int): Number of saved lanterns. saved_lanterns (list of int): Numbers of the saved lanterns in any order. Returns: int: The minimum number of additional lanterns needed to ensure all lanterns from 1 to n can be released in the correct order. saved_lantern_set = set(saved_lanterns) needed_lanterns = set(range(1, n+1)) missing_lanterns = needed_lanterns - saved_lantern_set return len(missing_lanterns)"},{"question":"def can_fire_reach(grid, N, M, Q, queries): Determine if the fire can spread from the start plot to the end plot for each query provided. Parameters: grid (List[str]): List of strings representing the grid where \`T\` represents a tree plot, and \`.\` represents a vacant plot. N (int): The number of rows in the grid. M (int): The number of columns in the grid. Q (int): The number of queries. queries (List[Tuple[int, int, int, int]]): List of queries, each containing four integers representing the coordinates of the start and end plots of a query. Returns: List[str]: Returns a list of \\"Yes\\" or \\"No\\" for each query indicating if the fire can spread from the start plot to the end plot. >>> can_fire_reach([\\".T.\\", \\"TTT\\", \\".T.\\"], 3, 3, 2, [(0, 1, 2, 1), (1, 1, 1, 1)]) [\\"Yes\\", \\"Yes\\"] >>> can_fire_reach([\\"T..\\", \\"T..\\", \\"...\\"], 3, 3, 2, [(0, 0, 1, 0), (0, 0, 2, 2)]) [\\"Yes\\", \\"No\\"] >>> can_fire_reach([\\".T.\\", \\"TTT\\", \\".T.\\"], 3, 3, 2, [(0, 0, 1, 1), (1, 1, 0, 0)]) [\\"No\\", \\"No\\"] >>> can_fire_reach([\\"TTTTT\\", \\"T...T\\", \\"TTTTT\\"], 3, 5, 1, [(0, 0, 2, 4)]) [\\"Yes\\"]","solution":"def can_fire_reach(grid, N, M, Q, queries): from collections import deque def bfs(start_x, start_y, end_x, end_y): queue = deque([(start_x, start_y)]) visited = set([(start_x, start_y)]) while queue: x, y = queue.popleft() if (x, y) == (end_x, end_y): return \\"Yes\\" for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nx, ny = x + dx, y + dy if 0 <= nx < N and 0 <= ny < M and (nx, ny) not in visited and grid[nx][ny] == 'T': visited.add((nx, ny)) queue.append((nx, ny)) return \\"No\\" results = [] for sx, sy, ex, ey in queries: if grid[sx][sy] == 'T' and grid[ex][ey] == 'T': results.append(bfs(sx, sy, ex, ey)) else: results.append(\\"No\\") return results"},{"question":"def nth_term_of_sequence(n: int) -> int: Returns the nth term of the sequence where: - f_1 = 1 - For all i (1 ≤ i < n), f_{i+1} = f_i + i >>> nth_term_of_sequence(1) 1 >>> nth_term_of_sequence(5) 11 >>> nth_term_of_sequence(10) 46 pass def sequence_terms(test_cases: List[int]) -> List[int]: Given a list of test cases, returns the nth term for each test case. >>> sequence_terms([1, 5, 10]) [1, 11, 46] >>> sequence_terms([2, 3, 4]) [2, 4, 7] pass","solution":"def nth_term_of_sequence(n): Returns the nth term of the sequence where: - f_1 = 1 - For all i (1 ≤ i < n), f_{i+1} = f_i + i if n == 1: return 1 return (n * (n - 1)) // 2 + 1 def sequence_terms(test_cases): Given a list of test cases, returns the nth term for each test case. return [nth_term_of_sequence(n) for n in test_cases]"},{"question":"def max_rainfall_sum(n: int, rainfall: List[int]) -> int: Finds the maximum sum of rainfall over any contiguous subarray. Parameters: n (int): The number of plots. rainfall (list of int): List representing rainfall amounts on each plot. Returns: int: The maximum sum of rainfall over any contiguous subarray. >>> max_rainfall_sum(8, [-2, 1, -3, 4, -1, 2, 1, -5, 4]) 6 >>> max_rainfall_sum(1, [1]) 1 >>> max_rainfall_sum(5, [-1, -2, -3, -4, -5]) -1 >>> max_rainfall_sum(5, [5, 4, -1, 7, 8]) 23 >>> max_rainfall_sum(0, []) 0 >>> max_rainfall_sum(6, [1, 2, 3, 4, 5, 6]) 21 >>> max_rainfall_sum(1, [-10000]) -10000 >>> max_rainfall_sum(1, [10000]) 10000 >>> max_rainfall_sum(4, [1, 2, 3, 4]) 10 >>> max_rainfall_sum(3, [-1, -2, -3]) -1 >>> max_rainfall_sum(9, [3, -2, 5, -1, 6, -3, 2, 1, -1]) 11 >>> max_rainfall_sum(7, [-2, -3, 4, -1, -2, 1, 5, -3]) 7","solution":"def max_rainfall_sum(n, rainfall): Finds the maximum sum of rainfall over any contiguous subarray. Parameters: n (int): The number of plots. rainfall (list of int): List representing rainfall amounts on each plot. Returns: int: The maximum sum of rainfall over any contiguous subarray. if n == 0: return 0 max_sum = current_sum = rainfall[0] for i in range(1, n): current_sum = max(rainfall[i], current_sum + rainfall[i]) max_sum = max(max_sum, current_sum) return max_sum"},{"question":"def max_subarray_sum(arr): Finds the largest sum of a contiguous subarray within a given one-dimensional numeric array. Parameters: arr (List[int]): A list of integers. Returns: int: The maximum sum of the contiguous subarray. Examples: >>> max_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) 6 >>> max_subarray_sum([1, 2, 3, 4, 5]) 15 >>> max_subarray_sum([-1, -2, -3, -4, -5]) -1 >>> max_subarray_sum([]) 0","solution":"def max_subarray_sum(arr): Finds the largest sum of a contiguous subarray within a given one-dimensional numeric array. if not arr: return 0 max_sum = current_sum = arr[0] for num in arr[1:]: current_sum = max(num, current_sum + num) max_sum = max(max_sum, current_sum) return max_sum # Function to parse input for testing purposes def parse_input(input_str): return list(map(int, input_str.strip().split()))"},{"question":"def lexicographically_smallest_array(T: int, test_cases: List[Dict[str, Union[int, List[int]]]]) -> List[List[int]]: Given an array of N integers, find the lexicographically smallest array obtainable after exactly K subset reversing operations. Args: T: Number of test cases. test_cases: A list of dictionaries containing: - 'N': The number of elements in the array. - 'K': Number of subset reversing operations. - 'array': The list of integers. Returns: A list of lists containing the lexicographically smallest arrays for each test case. >>> T = 1 >>> test_cases = [{'N': 5, 'K': 1, 'array': [3, 2, 1, 4, 5]}] >>> lexicographically_smallest_array(T, test_cases) [[1, 2, 3, 4, 5]] >>> T = 2 >>> test_cases = [{'N': 5, 'K': 1, 'array': [5, 4, 3, 2, 1]}, {'N': 4, 'K': 1, 'array': [7, 3, 9, 5]}] >>> lexicographically_smallest_array(T, test_cases) [[1, 2, 3, 4, 5], [3, 5, 7, 9]]","solution":"def lexicographically_smallest_array(T, test_cases): results = [] for case in test_cases: N, K = case['N'], case['K'] arr = case['array'] arr.sort() results.append(arr) return results"},{"question":"def modify_array(N: int, M: int, array: list, operations: list) -> list: Modifies the array based on the given operations. Parameters: N (int): Length of the array M (int): Number of operations array (list of int): List of integers representing the array operations (list of tuple of int): List of operations where each operation is a tuple (L, R) Returns: list of int: Modified array after all operations Example: >>> modify_array(5, 3, [2, 3, 1, 4, 5], [(1, 3), (2, 4), (1, 5)]) [4, 6, 4, 6, 6]","solution":"def modify_array(N, M, array, operations): Modifies the array based on the given operations. Parameters: N (int): Length of the array M (int): Number of operations array (list of int): List of integers representing the array operations (list of tuple of int): List of operations where each operation is a tuple (L, R) Returns: list of int: Modified array after all operations for L, R in operations: for i in range(L - 1, R): array[i] += 1 return array"},{"question":"from typing import List def maxWater(height: List[int]) -> int: Calculate the maximum amount of water that can be trapped between buildings. >>> maxWater([3, 0, 0, 2, 0, 4]) == 10 >>> maxWater([1, 2, 3, 4, 5]) == 0 >>> maxWater([2, 1, 2]) == 1 >>> maxWater([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) == 6 >>> maxWater([4, 2, 0, 3, 2, 5]) == 9 def process_test_cases(T: int, test_cases: List[List[int]]) -> List[int]: Process multiple test cases and return the results >>> process_test_cases(2, [[3, 0, 0, 2, 0, 4], [1, 2, 3, 4, 5]]) == [10, 0] >>> process_test_cases(1, [[2, 1, 2]]) == [1] >>> process_test_cases(3, [[0], [0, 0, 0, 0], [1, 0, 1]]) == [0, 0, 1] >>> process_test_cases(2, [[4, 2, 0, 3, 2, 5], [9, 8, 2, 6]]) == [9, 4]","solution":"from typing import List def maxWater(height: List[int]) -> int: Calculate the maximum amount of water that can be trapped between buildings. if not height: return 0 n = len(height) left_max = [0] * n right_max = [0] * n left_max[0] = height[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], height[i]) right_max[n - 1] = height[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], height[i]) water_trapped = 0 for i in range(n): water_trapped += min(left_max[i], right_max[i]) - height[i] return water_trapped def process_test_cases(T: int, test_cases: List[List[int]]) -> List[int]: results = [] for i in range(T): results.append(maxWater(test_cases[i])) return results"},{"question":"def longest_common_subsequence(n: int, dna_strands: List[str]) -> str: A group of scientists is working on an experiment to analyze mutations in DNA strands. They are particularly interested in identifying the longest contiguous subsequence of a DNA strand that remains unchanged (i.e., without mutations) across multiple observation periods. A DNA strand is represented as a string where each character represents a base (A, T, C, or G). The experiment produces several observation periods, each recording the DNA strand at that time. Due to mutations, the DNA strands from different periods may vary. The main goal is to find the longest contiguous subsequence that appears unchanged in all observation periods. Args: - n (int): The number of observation periods. - dna_strands (List[str]): A list of strings representing the observed DNA strands during each period. Returns: - str: The longest contiguous subsequence that is present in all observation periods' DNA strands. >>> longest_common_subsequence(3, [\\"AGCTTACG\\", \\"GCTTACGC\\", \\"AGTTTACG\\"]) \\"TTACG\\" >>> longest_common_subsequence(2, [\\"ATCG\\", \\"TAGC\\"]) \\"\\" >>> longest_common_subsequence(1, [\\"AGCTTACG\\"]) \\"AGCTTACG\\" >>> longest_common_subsequence(3, [\\"AAAGGGT\\", \\"AAGGGT\\", \\"AGGGT\\"]) \\"AGGGT\\" >>> longest_common_subsequence(3, [\\"AAGTTGG\\", \\"AGTTGGA\\", \\"AGTTGGC\\"]) \\"AGTTGG\\" pass","solution":"def longest_common_subsequence(n, dna_strands): if n == 1: return dna_strands[0] def is_common_substr(length): substrings = set(dna_strands[0][i:i+length] for i in range(len(dna_strands[0]) - length + 1)) for dna in dna_strands[1:]: new_substrings = set() for i in range(len(dna) - length + 1): substr = dna[i:i+length] if substr in substrings: new_substrings.add(substr) substrings = new_substrings if not substrings: return \\"\\" return min(substrings) if substrings else \\"\\" left, right = 0, len(min(dna_strands, key=len)) longest_substr = \\"\\" while left <= right: mid = (left + right) // 2 common_substr = is_common_substr(mid) if common_substr: longest_substr = common_substr left = mid + 1 else: right = mid - 1 return longest_substr"},{"question":"def manage_list_of_unique_numbers(operations: List[str]) -> List[str]: Manages a list of unique numbers and performs specified operations. >>> manage_list_of_unique_numbers([ ... \\"ADD 3\\", \\"ADD 1\\", \\"ADD 2\\", \\"PRINT\\", \\"REMOVE 1\\", \\"PRINT\\", \\"ADD 2\\", \\"ADD 5\\", \\"PRINT\\", \\"END\\" ... ]) [\\"1 2 3\\", \\"2 3\\", \\"2 3 5\\"] >>> manage_list_of_unique_numbers([\\"PRINT\\", \\"END\\"]) [\\"\\"] >>> manage_list_of_unique_numbers([\\"ADD 5\\", \\"ADD 5\\", \\"ADD 5\\", \\"REMOVE 5\\", \\"REMOVE 5\\", \\"PRINT\\", \\"END\\"]) [\\"\\"] >>> manage_list_of_unique_numbers([\\"ADD 10\\", \\"REMOVE 5\\", \\"REMOVE 10\\", \\"PRINT\\", \\"END\\"]) [\\"\\"] >>> manage_list_of_unique_numbers([\\"ADD 8\\", \\"ADD 3\\", \\"ADD 6\\", \\"PRINT\\", \\"ADD 7\\", \\"REMOVE 3\\", \\"PRINT\\", \\"REMOVE 6\\", \\"PRINT\\", \\"END\\"]) [\\"3 6 8\\", \\"6 7 8\\", \\"7 8\\"]","solution":"def manage_list_of_unique_numbers(operations): Manages a list of unique numbers and performs specified operations. Parameters: operations (list of str): List of operations to be performed on the list. Returns: list of str: List of results for each PRINT operation. unique_numbers = set() results = [] for operation in operations: if operation.startswith(\\"ADD\\"): _, x = operation.split() unique_numbers.add(int(x)) elif operation.startswith(\\"REMOVE\\"): _, x = operation.split() x = int(x) unique_numbers.discard(x) elif operation == \\"PRINT\\": results.append(\\" \\".join(map(str, sorted(unique_numbers)))) elif operation == \\"END\\": break return results"},{"question":"def find_two_sum_indices(n: int, arr: List[int], target: int) -> List[int]: Given an array of integers, outputs the indices of the two numbers such that they add up to a specific target. The indices should be output in ascending order. If no such indices exist, output -1. >>> find_two_sum_indices(4, [2, 7, 11, 15], 9) [0, 1] >>> find_two_sum_indices(5, [1, 2, 3, 4, 5], 10) -1 >>> find_two_sum_indices(6, [3, 2, 4, 6, 8, 10], 14) [3, 4]","solution":"def find_two_sum_indices(n, arr, target): Given an array of integers, returns the indices of the two numbers such that they add up to a specific target. The indices should be output in ascending order. If no such indices exist, output -1. value_to_index = {} for i in range(n): complement = target - arr[i] if complement in value_to_index: return sorted([value_to_index[complement], i]) value_to_index[arr[i]] = i return -1"},{"question":"def find_zero_sum_cycle(n: int, m: int, edges: List[Tuple[int, int, int]]) -> str: Given an undirected graph with n vertices and m edges, determine whether it is possible to find a cycle such that the sum of the weights of the edges in the cycle is zero. Args: n (int): Number of vertices in the graph. m (int): Number of edges in the graph. edges (List[Tuple[int, int, int]]): List of edges where each edge is represented by a tuple (u, v, w) denoting an edge between vertex u and vertex v with weight w. Returns: str: \\"YES\\" if there is a cycle with a sum of weights equal to zero, otherwise \\"NO\\". Examples: >>> find_zero_sum_cycle(4, 5, [(1, 2, 3), (2, 3, -2), (3, 1, -1), (3, 4, 2), (4, 1, -2)]) \\"YES\\" >>> find_zero_sum_cycle(3, 3, [(1, 2, 4), (2, 3, 5), (3, 1, 6)]) \\"NO\\" pass","solution":"def find_zero_sum_cycle(n, m, edges): def dfs(node, weight_sum, visited, rec_stack): visited[node] = True rec_stack[node] = True for neighbor, weight in graph[node]: if not visited[neighbor]: if dfs(neighbor, weight_sum + weight, visited, rec_stack): return True elif rec_stack[neighbor] and weight_sum + weight == 0: return True rec_stack[node] = False return False graph = {i: [] for i in range(1, n + 1)} for u, v, w in edges: graph[u].append((v, w)) graph[v].append((u, w)) visited = [False] * (n + 1) rec_stack = [False] * (n + 1) for i in range(1, n + 1): if not visited[i]: if dfs(i, 0, visited, rec_stack): return \\"YES\\" return \\"NO\\" # Example usage: # n = 4 # m = 5 # edges = [ # (1, 2, 3), # (2, 3, -2), # (3, 1, -1), # (3, 4, 2), # (4, 1, -2) # ] # print(find_zero_sum_cycle(n, m, edges)) # Output: \\"YES\\""},{"question":"def minimum_fairness(N: int, productivity: List[int]) -> int: Returns the minimum possible fairness value for the given plot productivities. Fairness is defined as the minimum possible value of the maximum plot productivity assigned to any villager minus the minimum plot productivity assigned to any villager. >>> minimum_fairness(4, [8, 10, 3, 7]) 1 >>> minimum_fairness(5, [5, 5, 5, 5, 5]) 0 >>> minimum_fairness(2, [1, 1000]) 999 >>> minimum_fairness(6, [10, 10, 10, 100, 100, 100]) 0 >>> minimum_fairness(5, [20, 15, 10, 25, 30]) 5","solution":"def minimum_fairness(N, productivity): Returns the minimum possible fairness value for the given plot productivities. Fairness is defined as the minimum possible value of the maximum plot productivity assigned to any villager minus the minimum plot productivity assigned to any villager. productivity.sort() min_fairness = float('inf') for i in range(N - 1): min_fairness = min(min_fairness, productivity[i + 1] - productivity[i]) return min_fairness"},{"question":"def min_subset_difference(arr: List[int]) -> int: Determine the minimum difference between the sums of two subsets into which the set can be partitioned Args: arr (List[int]): A list of positive integers Returns: int: The minimum possible difference between the sums of the two subsets Examples: >>> min_subset_difference([1, 2, 3, 9]) 3 >>> min_subset_difference([1, 6, 11]) 4 from typing import List def test_example_1(): assert min_subset_difference([1, 2, 3, 9]) == 3 def test_example_2(): assert min_subset_difference([1, 6, 11]) == 4 def test_single_element(): assert min_subset_difference([5]) == 5 def test_two_elements_equal(): assert min_subset_difference([10, 10]) == 0 def test_large_set(): assert min_subset_difference([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == 1 def test_minimum_difference(): assert min_subset_difference([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]) == 0","solution":"def min_subset_difference(arr): Determines the minimum difference between the sums of two subsets into which the set can be partitioned. total_sum = sum(arr) n = len(arr) # Create a DP array to store the subset sums dp = [[False] * (total_sum + 1) for _ in range(n + 1)] # Initialize for i in range(n + 1): dp[i][0] = True # Fill the DP array for i in range(1, n + 1): for j in range(1, total_sum + 1): dp[i][j] = dp[i-1][j] if arr[i-1] <= j: dp[i][j] = dp[i][j] or dp[i-1][j-arr[i-1]] # Find the minimum difference min_diff = float('inf') for j in range(total_sum // 2 + 1): if dp[n][j]: min_diff = min(min_diff, abs(total_sum - 2 * j)) return min_diff # Example usage: if __name__ == \\"__main__\\": n = int(input().strip()) arr = list(map(int, input().strip().split())) print(min_subset_difference(arr))"},{"question":"def minimum_time_to_connect_castles(cases): Determine the minimum time needed to repair enough roads so that there is at least one path connecting every pair of castles. Args: cases : List of Tuples containing (n, m, [(a, b, t), ...]), where n is the number of castles, m is the number of roads, and each tuple (a, b, t) represents a road between castle a and b which requires t days to repair. Returns: List of integers, each representing the minimum repair time for the respective test case. >>> test_case_1() >>> test_case_2() >>> test_case_3() >>> test_case_4() >>> test_case_5() def parse_input(input_str): Parse the input string into cases. Args: input_str : String, raw input containing multiple test cases. Returns: List of Tuples containing (n, m, [(a, b, t), ...]) >>> parse_input(\\"4 4n1 2 5n2 3 3n3 4 4n4 1 6\\") [(4, 4, [(1, 2, 5), (2, 3, 3), (3, 4, 4), (4, 1, 6)])] def test_case_1(): input_str = 4 4 1 2 5 2 3 3 3 4 4 4 1 6 expected = 12 cases = parse_input(input_str) results = minimum_time_to_connect_castles(cases) assert results[0] == expected def test_case_2(): input_str = 4 3 1 2 5 2 3 2 1 3 4 expected = -1 cases = parse_input(input_str) results = minimum_time_to_connect_castles(cases) assert results[0] == expected def test_case_3(): input_str = 4 3 1 2 5 2 3 2 3 4 5 expected = 12 cases = parse_input(input_str) results = minimum_time_to_connect_castles(cases) assert results[0] == expected def test_case_4(): input_str = 1 0 expected = 0 cases = parse_input(input_str) results = minimum_time_to_connect_castles(cases) assert results[0] == expected def test_case_5(): input_str = 4 4 1 2 1 2 3 1 3 4 1 1 4 10 4 4 1 3 3 3 4 6 4 2 2 1 2 1 expected_outputs = [3, 6] cases = parse_input(input_str) results = minimum_time_to_connect_castles(cases) assert results == expected_outputs","solution":"def find(parent, i): if parent[i] == i: return i else: parent[i] = find(parent, parent[i]) return parent[i] def union(parent, rank, x, y): xroot = find(parent, x) yroot = find(parent, y) if rank[xroot] < rank[yroot]: parent[xroot] = yroot elif rank[xroot] > rank[yroot]: parent[yroot] = xroot else: parent[yroot] = xroot rank[xroot] += 1 def kruskal(n, edges): edges.sort(key=lambda x: x[2]) parent = [] rank = [] for node in range(n): parent.append(node) rank.append(0) result = [] i = 0 e = 0 while e < n - 1: if i >= len(edges): return -1 u, v, w = edges[i] i += 1 x = find(parent, u-1) y = find(parent, v-1) if x != y: e += 1 result.append([u, v, w]) union(parent, rank, x, y) min_time = sum([w for u, v, w in result]) return min_time def minimum_time_to_connect_castles(cases): results = [] for n, m, edges in cases: if n == 1: results.append(0) else: time = kruskal(n, edges) results.append(time) return results def parse_input(input_str): cases = [] lines = input_str.strip().split('n') i = 0 while i < len(lines): n, m = map(int, lines[i].strip().split()) edges = [] for j in range(i + 1, i + 1 + m): a, b, t = map(int, lines[j].strip().split()) edges.append((a, b, t)) cases.append((n, m, edges)) i += m + 1 return cases def solve(): import sys input = sys.stdin.read() cases = parse_input(input) results = minimum_time_to_connect_castles(cases) for result in results: print(result)"},{"question":"from typing import List def data_center_operations(n: int, q: int, operations: List[List[int]]) -> List[int]: Handles data center network operations and returns results for degree queries. Args: n (int): Number of servers in the network. q (int): Number of operations. operations (List[List[int]]): List of operations to perform. Returns: List[int]: Results of degree queries. >>> data_center_operations(5, 7, [[1, 1, 2], [1, 2, 3], [1, 3, 4], [1, 4, 5], [3, 3], [2, 3, 4], [3, 3]]) [2, 1] >>> data_center_operations(3, 1, [[3, 2]]) [0] pass","solution":"def data_center_operations(n, q, operations): from collections import defaultdict degrees = defaultdict(int) edges = defaultdict(set) results = [] for operation in operations: if operation[0] == 1: # Add connection u, v = operation[1], operation[2] if v not in edges[u]: edges[u].add(v) edges[v].add(u) degrees[u] += 1 degrees[v] += 1 elif operation[0] == 2: # Remove connection u, v = operation[1], operation[2] if v in edges[u]: edges[u].remove(v) edges[v].remove(u) degrees[u] -= 1 degrees[v] -= 1 elif operation[0] == 3: # Get degree u = operation[1] results.append(degrees[u]) return results"},{"question":"def find_peaks(n: int, prices: List[int]) -> Union[List[int], str]: Identifies all peak elements in the list and returns their 1-based indices. >>> find_peaks(6, [1, 2, 3, 1, 5, 6]) [3, 6] >>> find_peaks(5, [5, 5, 5, 5, 5]) 'None' from typing import List, Union def test_single_element(): assert find_peaks(1, [5]) == [1] def test_multiple_peaks(): assert find_peaks(6, [1, 2, 3, 1, 5, 6]) == [3, 6] def test_no_peaks_identical(): assert find_peaks(5, [5, 5, 5, 5, 5]) == \\"None\\" def test_peaks_at_edges_and_middle(): assert find_peaks(4, [8, 10, 5, 7]) == [2, 4] def test_multiple_middle_peaks(): assert find_peaks(7, [1, 3, 2, 4, 1, 5, 1]) == [2, 4, 6] def test_decreasing_elements(): assert find_peaks(4, [10, 8, 6, 4]) == [1] def test_increasing_elements(): assert find_peaks(4, [1, 2, 3, 4]) == [4] def test_consecutive_peaks(): assert find_peaks(5, [1, 3, 2, 3, 1]) == [2, 4]","solution":"def find_peaks(n, prices): Identifies all peak elements in the list and returns their 1-based indices. if n == 1: return [1] peaks = [] for i in range(n): if i == 0: if prices[i] > prices[i + 1]: peaks.append(i + 1) elif i == n - 1: if prices[i] > prices[i - 1]: peaks.append(i + 1) else: if prices[i] > prices[i - 1] and prices[i] > prices[i + 1]: peaks.append(i + 1) if not peaks: return \\"None\\" return peaks"},{"question":"def tally_fruits(N, entries): Calculate the total quantity sold for each type of fruit, combined across all purchases, and present them in alphabetical order. Args: N: an integer, the number of entries in the list. entries: a list of strings, each containing the name of the fruit and the quantity sold in space-separated format. Returns: A string representing the total number of unique fruit names, followed by each fruit name and its total quantity sold, all in alphabetical order. Example: >>> input_data = \\"8napple 10nbanana 20napple 5norange 12nbanana 8nkiwi 4ngrape 15norange 5\\" >>> N, entries = parse_input(input_data) >>> tally_fruits(N, entries) '5napple 15nbanana 28ngrape 15nkiwi 4norange 17'","solution":"def tally_fruits(N, entries): from collections import defaultdict fruit_tally = defaultdict(int) for entry in entries: fruit, quantity = entry.split() quantity = int(quantity) fruit_tally[fruit] += quantity sorted_fruits = sorted(fruit_tally.items()) result = [str(len(sorted_fruits))] for fruit, total_quantity in sorted_fruits: result.append(f\\"{fruit} {total_quantity}\\") return \\"n\\".join(result) def parse_input(input_data): lines = input_data.strip().split(\\"n\\") N = int(lines[0]) entries = lines[1:] return N, entries"},{"question":"def max_sum_of_subarray(arr: List[int], queries: List[int]) -> List[int]: Given an array of integers, and a list of queries where each query asks for the maximum sum of a subarray of a given length, return a list of results for each query. >>> max_sum_of_subarray([5, 1, 3, 2, 8], [3, 2]) [13, 10] >>> max_sum_of_subarray([5], [1]) [5] >>> max_sum_of_subarray([-1, -2, -3, -4, -5], [2, 3]) [-3, -6] >>> max_sum_of_subarray([2, -1, 5, -2, 3], [2, 3]) [4, 6] >>> max_sum_of_subarray([1, 3, -2, 5], [4]) [7] >>> max_sum_of_subarray([1, 2, 3, 4, 5], [1, 5]) [5, 15] >>> max_sum_of_subarray([3, 2, 7, 10, 12], [1, 2, 3, 5]) [12, 22, 29, 34]","solution":"def max_sum_of_subarray(arr, queries): results = [] for k in queries: n = len(arr) max_sum = float('-inf') window_sum = sum(arr[:k]) max_sum = max(max_sum, window_sum) for i in range(k, n): window_sum += arr[i] - arr[i - k] max_sum = max(max_sum, window_sum) results.append(max_sum) return results"},{"question":"def max_lectures(N, lectures): Returns the maximum number of lectures that can be attended without overlap. Parameters: N (int): Number of lectures. lectures (list of tuples): Each tuple contains start and end times of a lecture. Returns: int: Maximum number of non-overlapping lectures that can be attended. from solution import max_lectures def test_example_1(): lectures = [(1, 2), (2, 3), (3, 4)] assert max_lectures(3, lectures) == 3 def test_example_2(): lectures = [(1, 3), (2, 5), (4, 6), (6, 8), (5, 7)] assert max_lectures(5, lectures) == 3 def test_single_lecture(): lectures = [(1, 2)] assert max_lectures(1, lectures) == 1 def test_overlapping_lectures(): lectures = [(1, 4), (2, 5), (3, 6)] assert max_lectures(3, lectures) == 1 def test_non_overlapping_lectures(): lectures = [(1, 2), (3, 4), (5, 6)] assert max_lectures(3, lectures) == 3 def test_large_input(): lectures = [(i, i+1) for i in range(1, 100001)] assert max_lectures(100000, lectures) == 100000 def test_large_input_with_overlap(): lectures = [(i, i+2) for i in range(1, 100001)] assert max_lectures(100000, lectures) == 50000","solution":"def max_lectures(N, lectures): Returns the maximum number of lectures that can be attended without overlap. Parameters: N (int): Number of lectures. lectures (list of tuples): Each tuple contains start and end times of a lecture. Returns: int: Maximum number of non-overlapping lectures that can be attended. # Sort lectures based on their end times lectures.sort(key=lambda x: x[1]) max_count = 0 last_end_time = 0 for start, end in lectures: if start >= last_end_time: max_count += 1 last_end_time = end return max_count"},{"question":"def max_combined_scare_capacity(n, w, x, scarecrows): Returns the maximum combined scare capacity of exactly two scarecrows within budget. >>> max_combined_scare_capacity(4, 5, 6, [(8, 3, 'W'), (7, 4, 'W'), (5, 2, 'C'), (6, 5, 'C')]) == 14 >>> max_combined_scare_capacity(3, 3, 7, [(4, 4, 'W'), (3, 3, 'W'), (5, 7, 'C')]) == 8 >>> max_combined_scare_capacity(3, 1, 1, [(2, 1, 'W'), (3, 1, 'C'), (4, 2, 'W')]) == 5 >>> max_combined_scare_capacity(3, 1, 1, [(2, 2, 'W'), (3, 2, 'C'), (4, 2, 'W')]) == 0 >>> max_combined_scare_capacity(3, 3, 0, [(2, 1, 'W'), (3, 1, 'W'), (4, 2, 'W')]) == 0 >>> max_combined_scare_capacity(3, 0, 3, [(2, 1, 'C'), (3, 1, 'C'), (4, 2, 'C')]) == 0","solution":"def max_combined_scare_capacity(n, w, x, scarecrows): Returns the maximum combined scare capacity of exactly two scarecrows within budget. wheat_scarecrows = [] corn_scarecrows = [] for si, pi, kind in scarecrows: if kind == \\"W\\": wheat_scarecrows.append((si, pi)) elif kind == \\"C\\": corn_scarecrows.append((si, pi)) max_combined_capacity = 0 # Check combination of one wheat and one corn scarecrow for si_w, pi_w in wheat_scarecrows: if pi_w <= w: for si_c, pi_c in corn_scarecrows: if pi_c <= x: max_combined_capacity = max(max_combined_capacity, si_w + si_c) return max_combined_capacity"},{"question":"def is_k_beautiful(n: int, s: str) -> str: Determines if it is possible to rearrange the characters of the string \`s\` so that every character appears exactly \`k\` times, where k is the frequency that each character must have for the string to be k-beautiful. :param n: Length of the string \`s\` :param s: Input string containing only lowercase English letters :return: \\"YES\\" if the string can be rearranged to be k-beautiful, otherwise \\"NO\\" from collections import Counter # Count the frequency of each character in the string freq = Counter(s) # Get the unique character frequencies freq_values = list(freq.values()) # Check if all frequency values are the same k = freq_values[0] # The frequency each character must have to be k-beautiful for value in freq_values: if value != k: return \\"NO\\" return \\"YES\\" if n % k == 0 else \\"NO\\" def test_example_1(): assert is_k_beautiful(6, 'aabbcc') == \\"YES\\" def test_example_2(): assert is_k_beautiful(7, 'aaaabbb') == \\"NO\\" def test_single_character(): assert is_k_beautiful(1, 'a') == \\"YES\\" def test_all_characters_same_frequency(): assert is_k_beautiful(8, 'aabbccdd') == \\"YES\\" def test_all_characters_different_frequency(): assert is_k_beautiful(8, 'aabbbccc') == \\"NO\\" def test_large_input(): s = 'a' * 50000 + 'b' * 50000 assert is_k_beautiful(100000, s) == \\"YES\\"","solution":"def is_k_beautiful(n, s): Determines if it is possible to rearrange the characters of string \`s\` so that every character appears exactly \`k\` times. Prints \\"YES\\" if possible, else prints \\"NO\\". :param n: Length of the string \`s\` :param s: Input string containing only lowercase English letters :return: \\"YES\\" if the string can be rearranged to be k-beautiful, otherwise \\"NO\\" from collections import Counter # Count the frequency of each character in the string freq = Counter(s) # Get the unique character frequencies freq_values = list(freq.values()) # Check if all frequency values are the same k = freq_values[0] # The frequency each character must have to be k-beautiful for value in freq_values: if value != k: return \\"NO\\" return \\"YES\\" if n % k == 0 else \\"NO\\" # Example usage: # print(is_k_beautiful(6, 'aabbcc')) # Should return \\"YES\\" # print(is_k_beautiful(7, 'aaaabbb')) # Should return \\"NO\\""},{"question":"def books_mina_can_buy(data): Determine the number of books Mina can buy given a list of current prices and her price threshold. >>> books_mina_can_buy([[3, 1500, 2000, 1200, 1300], [4, 2500, 3000, 1000, 5000, 1500], [1, 1500, 1500]]) [1, 1, 0] def process_input(input_data): Process the input data for Mina's book prices and thresholds. >>> input_string = \\"3n1500 2000 1200 1300n4n2500 3000 1000 5000 1500n1n1500 1500n0n\\" >>> process_input(input_string) [[3, 1500, 2000, 1200, 1300], [4, 2500, 3000, 1000, 5000, 1500], [1, 1500, 1500]]","solution":"def books_mina_can_buy(data): results = [] for dataset in data: t = dataset[0] prices = dataset[1:t + 1] threshold = dataset[t + 1] count = sum(1 for price in prices if price < threshold) results.append(count) return results def process_input(input_data): data = [] lines = input_data.strip().split('n') idx = 0 while idx < len(lines): t = int(lines[idx]) if t == 0: break prices_and_threshold = list(map(int, lines[idx + 1].split())) data.append([t] + prices_and_threshold) idx += 2 return data"},{"question":"def split_logs_by_day(logs): Splits the log entries into separate lists, each containing entries from a unique day. Parameters: logs (list): List of log entries, where each entry is a string formatted as \\"YYYY-MM-DD HH:MM:SS message\\". Returns: dict: Dictionary where keys are dates (strings in \\"YYYY-MM-DD\\" format) and values are lists of corresponding messages (strings). >>> logs = [ ... \\"2022-01-01 12:00:00 System started\\", ... \\"2022-01-01 14:00:00 User logged in\\", ... \\"2022-01-02 09:00:00 Scheduled task executed\\", ... \\"2022-01-02 10:00:00 User logged out\\", ... \\"2022-01-03 06:00:00 System backup completed\\" ... ] >>> split_logs_by_day(logs) { \\"2022-01-01\\": [ \\"12:00:00 System started\\", \\"14:00:00 User logged in\\" ], \\"2022-01-02\\": [ \\"09:00:00 Scheduled task executed\\", \\"10:00:00 User logged out\\" ], \\"2022-01-03\\": [ \\"06:00:00 System backup completed\\" ] } pass # your implementation here","solution":"def split_logs_by_day(logs): Splits the log entries into separate lists, each containing entries from a unique day. Parameters: logs (list): List of log entries, where each entry is a string formatted as \\"YYYY-MM-DD HH:MM:SS message\\". Returns: dict: Dictionary where keys are dates (strings in \\"YYYY-MM-DD\\" format) and values are lists of corresponding messages (strings). from collections import defaultdict result = defaultdict(list) for log in logs: date, time_message = log.split(' ', 1) result[date].append(time_message) return dict(result)"},{"question":"def find_longest_word(sentences): Returns the longest word in a list of sentences. If multiple words have the same length, returns the one that appears first in the sentence. >>> find_longest_word([\\"hello world\\"]) [\\"hello\\"] >>> find_longest_word([\\"programming is fun\\"]) [\\"programming\\"] >>> find_longest_word([\\"i love python\\"]) [\\"python\\"]","solution":"def find_longest_word(sentences): Returns the longest word in a list of sentences. If multiple words have the same length, returns the one that appears first in the sentence. def longest_word(sentence): words = sentence.split() max_length = 0 longest = \\"\\" for word in words: if len(word) > max_length: max_length = len(word) longest = word return longest return [longest_word(sentence) for sentence in sentences]"},{"question":"def calculate_net_profit_or_loss(test_cases): Calculate the net profit or loss for each month given income and expense values for multiple test cases. Args: test_cases (List[Dict[str, Union[int, List[int]]]]): A list of dictionaries where each dictionary contains the number of months, a list of monthly incomes, and a list of monthly expenses. Returns: List[List[int]]: A list of lists where each sublist contains the net profit or loss for each month for each test case. Example: >>> calculate_net_profit_or_loss([{'months': 3, 'incomes': [5000, 6000, 7000], 'expenses': [3000, 4000, 8000]}, {'months': 2, 'incomes': [1000, 2000], 'expenses': [1000, 3000]}]) [[2000, 2000, -1000], [0, -1000]] >>> calculate_net_profit_or_loss([{'months': 1, 'incomes': [5000], 'expenses': [3000]}]) [[2000]] # Test cases def test_cases(): test_cases = [ { 'months': 3, 'incomes': [5000, 6000, 7000], 'expenses': [3000, 4000, 8000] }, { 'months': 2, 'incomes': [1000, 2000], 'expenses': [1000, 3000] } ] expected_output = [ [2000, 2000, -1000], [0, -1000] ] assert calculate_net_profit_or_loss(test_cases) == expected_output def test_single_month(): test_cases = [ { 'months': 1, 'incomes': [5000], 'expenses': [3000] } ] expected_output = [ [2000] ] assert calculate_net_profit_or_loss(test_cases) == expected_output def test_zero_income(): test_cases = [ { 'months': 2, 'incomes': [0, 0], 'expenses': [1000, 2000] } ] expected_output = [ [-1000, -2000] ] assert calculate_net_profit_or_loss(test_cases) == expected_output def test_zero_expense(): test_cases = [ { 'months': 2, 'incomes': [1000, 2000], 'expenses': [0, 0] } ] expected_output = [ [1000, 2000] ] assert calculate_net_profit_or_loss(test_cases) == expected_output def test_no_profit_loss(): test_cases = [ { 'months': 2, 'incomes': [1000, 2000], 'expenses': [1000, 2000] } ] expected_output = [ [0, 0] ] assert calculate_net_profit_or_loss(test_cases) == expected_output","solution":"def calculate_net_profit_or_loss(test_cases): results = [] for test in test_cases: M = test['months'] incomes = test['incomes'] expenses = test['expenses'] result = [incomes[i] - expenses[i] for i in range(M)] results.append(result) return results"},{"question":"def longest_refreshing_segment(n: int, sequence: List[int]) -> int: Returns the length of the longest \\"refreshing\\" segment in the sequence. >>> longest_refreshing_segment(5, [1, 2, 1, 3, 2]) 5 >>> longest_refreshing_segment(6, [1, 1, 2, 2, 3, 3]) 2 >>> longest_refreshing_segment(4, [4, 4, 4, 4]) 1 >>> longest_refreshing_segment(10, [1, 3, 1, 3, 2, 2, 4, 5, 6, 2]) 5","solution":"def longest_refreshing_segment(n, sequence): Returns the length of the longest \\"refreshing\\" segment in the sequence. if n == 0: return 0 max_length = 1 current_length = 1 for i in range(1, n): if sequence[i] != sequence[i - 1]: current_length += 1 else: max_length = max(max_length, current_length) current_length = 1 max_length = max(max_length, current_length) # Final check in case the longest is at the end. return max_length"},{"question":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def sum_nodes_at_distance_k(root: TreeNode, K: int) -> int: Given the root node of a binary tree and an integer K, returns the sum of the values of all nodes at distance K from the root. >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> root.right.left = TreeNode(4) >>> root.right.right = TreeNode(5) >>> sum_nodes_at_distance_k(root, 2) 9 >>> sum_nodes_at_distance_k(root, 1) 5 >>> sum_nodes_at_distance_k(root, 0) 1","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def sum_nodes_at_distance_k(root: TreeNode, K: int) -> int: if root is None: return 0 from collections import deque queue = deque([(root, 0)]) sum_at_k = 0 while queue: current_node, current_level = queue.popleft() if current_level == K: sum_at_k += current_node.val if current_node.left: queue.append((current_node.left, current_level + 1)) if current_node.right: queue.append((current_node.right, current_level + 1)) return sum_at_k"},{"question":"def max_simultaneous_events(start: List[int], end: List[int]) -> int: Function to find the maximum number of events that occur simultaneously. Arguments: start -- a list of integers representing the starting times of the events. end -- a list of integers representing the ending times of the events. Returns: An integer representing the maximum number of overlapping events. >>> max_simultaneous_events([1, 2, 3, 4, 5], [6, 5, 4, 8, 7]) 3 >>> max_simultaneous_events([1, 5, 10], [4, 9, 15]) 1 >>> max_simultaneous_events([1, 2, 3], [10, 10, 10]) 3 >>> max_simultaneous_events([100], [200]) 1 >>> max_simultaneous_events([1, 2], [2, 3]) 1","solution":"def max_simultaneous_events(start, end): Function to find the maximum number of events that occur simultaneously. Arguments: start -- a list of integers representing the starting times of the events. end -- a list of integers representing the ending times of the events. Returns: An integer representing the maximum number of overlapping events. times = [] for s in start: times.append((s, 'start')) for e in end: times.append((e, 'end')) times.sort() max_events = 0 current_events = 0 for time, event_type in times: if event_type == 'start': current_events += 1 max_events = max(max_events, current_events) else: current_events -= 1 return max_events"},{"question":"def find_longest_word(s: str) -> str: Returns the longest word in the string s. If multiple words have the same maximum length, returns the last one that appears in the string. >>> find_longest_word(\\"summer is in the air\\") == \\"summer\\" >>> find_longest_word(\\"this is a test example\\") == \\"example\\" >>> find_longest_word(\\"find the longest word here\\") == \\"longest\\" >>> find_longest_word(\\"abc abcd abcde abcd\\") == \\"abcde\\" >>> find_longest_word(\\"hello\\") == \\"hello\\" >>> find_longest_word(\\"cat bat rat\\") == \\"rat\\" >>> find_longest_word(\\"dog cat bat\\") == \\"bat\\" >>> find_longest_word(\\"\\") == \\"\\" >>> find_longest_word(\\" \\") == \\"\\"","solution":"def find_longest_word(s): Returns the longest word in the string s. If multiple words have the same maximum length, returns the last one that appears in the string. words = s.split() longest_word = '' for word in words: if len(word) >= len(longest_word): longest_word = word return longest_word"},{"question":"def minimum_adjacent_swaps_to_sort(sequence): Returns the minimum number of adjacent swaps required to sort the sequence in non-descending order. >>> minimum_adjacent_swaps_to_sort([5, 1, 2, 3, 4]) 4 >>> minimum_adjacent_swaps_to_sort([4, 3, 2, 1]) 6 >>> minimum_adjacent_swaps_to_sort([3, 2, 1]) 3 >>> minimum_adjacent_swaps_to_sort([1, 3, 2]) 1 >>> minimum_adjacent_swaps_to_sort([1, 2, 3, 4, 5]) 0 >>> minimum_adjacent_swaps_to_sort([10, 8, 6, 4, 2]) 10","solution":"def minimum_adjacent_swaps_to_sort(sequence): Returns the minimum number of adjacent swaps required to sort the sequence in non-descending order. n = len(sequence) swaps = 0 # Use Bubble Sort to count swaps needed for i in range(n): for j in range(0, n - i - 1): if sequence[j] > sequence[j + 1]: sequence[j], sequence[j + 1] = sequence[j + 1], sequence[j] swaps += 1 return swaps"},{"question":"def wavy_sequence(n: int, arr: List[int]) -> List[int]: Generate the Wavy Sequence given a list of integers. :param n: int, number of elements in the list :param arr: list of int, the list of integers :return: list of int, the Wavy Sequence >>> wavy_sequence(5, [3, 1, 4, 5, 2]) [1, 5, 2, 4, 3] >>> wavy_sequence(6, [6, 3, 8, 2, 7, 4]) [2, 8, 3, 7, 4, 6] >>> wavy_sequence(1, [42]) [42] >>> wavy_sequence(3, [3, 1, 2]) [1, 3, 2] >>> wavy_sequence(4, [5, 1, 6, 3]) [1, 6, 3, 5]","solution":"def wavy_sequence(n, arr): Generate the Wavy Sequence given a list of integers. :param n: int, number of elements in the list :param arr: list of int, the list of integers :return: list of int, the Wavy Sequence arr.sort() result = [arr[0]] i, j = 1, n - 1 while i <= j: if i <= j: result.append(arr[j]) j -= 1 if i <= j: result.append(arr[i]) i += 1 return result"},{"question":"def find_department(employee_id, department_mapping): Finds the department code for a given employee ID. Params: - employee_id (int): The ID of the employee to look for. - department_mapping (dict): A dictionary with department codes as keys and lists of employee IDs as values. Returns: - str: The department code the employee belongs to, or \\"Not Found\\" if the employee ID is not found in any department. >>> department_mapping = { ... \\"HR\\": [1, 3, 5], ... \\"IT\\": [2, 4, 6], ... \\"Finance\\": [7, 8, 9, 10] ... } >>> find_department(1, department_mapping) \\"HR\\" >>> find_department(4, department_mapping) \\"IT\\" >>> find_department(8, department_mapping) \\"Finance\\" >>> find_department(11, department_mapping) \\"Not Found\\"","solution":"def find_department(employee_id, department_mapping): Finds the department code for a given employee ID. Params: - employee_id (int): The ID of the employee to look for. - department_mapping (dict): A dictionary with department codes as keys and lists of employee IDs as values. Returns: - str: The department code the employee belongs to, or \\"Not Found\\" if the employee ID is not found in any department. for department, employees in department_mapping.items(): if employee_id in employees: return department return \\"Not Found\\""},{"question":"def min_operations_to_palindrome(n: int, arr: List[int]) -> int: Returns the minimum number of operations required to transform the array into a palindrome. In one operation, you can increment or decrement an element by 1. >>> min_operations_to_palindrome(5, [1, 3, 3, 2, 1]) 1 >>> min_operations_to_palindrome(4, [1, 4, 2, 3]) 4 >>> min_operations_to_palindrome(6, [4, 5, 6, 6, 5, 3]) 1","solution":"def min_operations_to_palindrome(n, arr): Returns the minimum number of operations required to transform the array into a palindrome. In one operation, you can increment or decrement an element by 1. operations = 0 left = 0 right = n - 1 while left < right: operations += abs(arr[left] - arr[right]) left += 1 right -= 1 return operations"},{"question":"from typing import List, Union def find_differences(s1: str, s2: str) -> Union[List[int], str]: Returns the positions (1-indexed) where the two protein sequences s1 and s2 differ. >>> find_differences(\\"MKTIIALSYIFCLVFADYKDDDDK\\", \\"MKTIIALSYIFCLVFADYKDERDK\\") [21, 22] >>> find_differences(\\"MATIIAILSYIFCLVFADYKDNDK\\", \\"MATIIAILSYIFCLVFADYKDNDK\\") 'Identical' differences = [i + 1 for i in range(len(s1)) if s1[i] != s2[i]] return differences if differences else \\"Identical\\" def process_input(input_data: List[str]) -> List[str]: Processes the input data and returns the positions where the sequences differ for each test case. >>> input_data = [\\"MKTIIALSYIFCLVFADYKDDDDK\\", \\"MKTIIALSYIFCLVFADYKDERDK\\", \\"MATIIAILSYIFCLVFADYKDNDK\\", \\"MATIIAILSYIFCLVFADYKDNDK\\", \\"0\\"] >>> process_input(input_data) ['21 22', 'Identical'] results = [] for i in range(0, len(input_data), 2): s1 = input_data[i].strip() if s1 == '0': break s2 = input_data[i + 1].strip() differences = find_differences(s1, s2) results.append(\\" \\".join(map(str, differences)) if isinstance(differences, list) else differences) return results","solution":"def find_differences(s1, s2): Returns the positions (1-indexed) where the two protein sequences s1 and s2 differ. differences = [i + 1 for i in range(len(s1)) if s1[i] != s2[i]] return differences if differences else \\"Identical\\" def process_input(input_data): results = [] for i in range(0, len(input_data), 2): s1 = input_data[i].strip() if s1 == '0': break s2 = input_data[i + 1].strip() differences = find_differences(s1, s2) results.append(\\" \\".join(map(str, differences)) if isinstance(differences, list) else differences) return results"},{"question":"def drunken_knight_sequence(n): Determines the position of a knight after n moves in the Drunken Knight's sequence. Parameters: n (int): The number of moves the knight makes. Returns: tuple: The final coordinates (x, y) of the knight. >>> drunken_knight_sequence(1) (2, 1) >>> drunken_knight_sequence(10) (15, 15) >>> drunken_knight_sequence(1000000000) (1500000000, 1500000000) >>> drunken_knight_sequence(1000000001) (1500000002, 1500000001) >>> drunken_knight_sequence(0) (0, 0)","solution":"def drunken_knight_sequence(n): Determines the position of a knight after n moves in the Drunken Knight's sequence. Parameters: n (int): The number of moves the knight makes. Returns: tuple: The final coordinates (x, y) of the knight. # Position after k pairs of moves k = n // 2 x = 3 * k y = 3 * k # Determine the final move if n is odd if n % 2 == 1: x += 2 y += 1 return x, y"},{"question":"def set_covering(U: List[int], S: List[List[int]]) -> List[int]: Solves the set covering problem by finding the smallest sub-collection of S that covers all elements in U. Parameters: U: List[int] - A list representing the universal set. S: List[List[int]] - A list of lists where each sub-list represents a subset in S. Returns: List[int] - A list of indices of subsets in S that form the smallest cover. from solution import set_covering def test_example_case(): U = [1, 2, 3, 4, 5] S = [[1, 2, 3], [2, 4], [3, 4, 5], [4], [5]] result = set_covering(U, S) assert set(result) == {0, 2} # Order doesn't matter def test_single_subset(): U = [1, 2, 3] S = [[1, 2, 3]] result = set_covering(U, S) assert result == [0] def test_no_cover_needed(): U = [] S = [[1, 2, 3], [4, 5]] result = set_covering(U, S) assert result == [] def test_minimal_cover(): U = [1, 2, 3, 4] S = [[1, 2], [2, 3], [3, 4]] result = set_covering(U, S) assert set(result) == {0, 2} # Order doesn't matter def test_all_subsets_needed(): U = [1, 2, 3, 4] S = [[1], [2], [3], [4]] result = set_covering(U, S) assert set(result) == {0, 1, 2, 3} def test_multiple_optimal_solutions(): U = [1, 2, 3, 4] S = [[1, 2], [3, 4], [1, 3], [2, 4]] result = set_covering(U, S) possible_solutions = [{0, 1}, {2, 3}] assert any(set(result) == solution for solution in possible_solutions)","solution":"def set_covering(U, S): Solves the set covering problem by finding the smallest sub-collection of S that covers all elements in U. Parameters: U: List[int] - A list representing the universal set. S: List[List[int]] - A list of lists where each sub-list represents a subset in S. Returns: List[int] - A list of indices of subsets in S that form the smallest cover. from itertools import combinations indices = list(range(len(S))) for size in range(1, len(S) + 1): for combo in combinations(indices, size): union_set = set() for i in combo: union_set.update(S[i]) if len(union_set) == len(U): return list(combo) return [] # Example usage U = [1, 2, 3, 4, 5] S = [[1, 2, 3], [2, 4], [3, 4, 5], [4], [5]] print(set_covering(U, S)) # Expected output: [0, 2]"},{"question":"def subtree_sizes(n: int, parent: List[int]) -> List[int]: Given a rooted tree with n nodes where parent array indicates the parent-child relationships, return an array where each element at index i corresponds to the size of the subtree rooted at node i + 1. >>> subtree_sizes(4, [1, 2, 2]) [4, 3, 1, 1] >>> subtree_sizes(5, [1, 1, 1, 1]) [5, 1, 1, 1, 1] >>> subtree_sizes(3, [1, 2]) [3, 2, 1] >>> subtree_sizes(7, [1, 1, 2, 2, 3, 3]) [7, 3, 3, 1, 1, 1, 1] >>> subtree_sizes(6, [1, 1, 2, 3, 3]) [6, 2, 3, 1, 1, 1] pass","solution":"def subtree_sizes(n, parent): from collections import defaultdict def dfs(node): size = 1 for child in tree[node]: size += dfs(child) sizes[node] = size return size tree = defaultdict(list) for idx, p in enumerate(parent): tree[p - 1].append(idx + 1) sizes = [0] * n dfs(0) return sizes"},{"question":"from typing import List, Tuple def get_tree_height(n: int, edges: List[Tuple[int, int]]) -> int: Determine the height of a binary tree given its edges. Parameters: n (int): The number of nodes in the binary tree. edges (List[Tuple[int, int]]): The edges in the binary tree, where each edge is represented as a tuple (u, v). Returns: int: The height of the binary tree. >>> get_tree_height(1, []) 0 >>> get_tree_height(2, [(1, 2)]) 1 >>> get_tree_height(5, [(1, 2), (1, 3), (3, 4), (3, 5)]) 2","solution":"from collections import defaultdict, deque def build_tree(edges, n): tree = defaultdict(list) for u, v in edges: tree[u].append(v) tree[v].append(u) return tree def get_tree_height(n, edges): if n == 0: return -1 if n == 1: return 0 tree = build_tree(edges, n) def bfs_height(start_node): visited = set() queue = deque([(start_node, 0)]) # (current_node, current_height) max_height = 0 while queue: current_node, height = queue.popleft() visited.add(current_node) max_height = max(max_height, height) for neighbor in tree[current_node]: if neighbor not in visited: queue.append((neighbor, height + 1)) return max_height # Start from any node (here node 1) to find the farthest node height = bfs_height(1) return height"},{"question":"MOD = 10**9 + 7 def count_ways(n: int) -> int: Returns the number of ways to arrange n coins such that no two coins with consecutive denominations are adjacent. >>> count_ways(1) == 1 >>> count_ways(2) == 2 >>> count_ways(3) == 6 >>> count_ways(4) == 24 >>> count_ways(5) == 120 >>> count_ways(6) == 720 >>> count_ways(10) == 3628800 % (10**9 + 7) >>> count_ways(20) == 2432902008176640000 % (10**9 + 7) >>> count_ways(1000) == 641419708","solution":"MOD = 10**9 + 7 def count_ways(n): Returns the number of ways to arrange n coins such that no two coins with consecutive denominations are adjacent. factorial = [1] * (n + 1) for i in range(2, n + 1): factorial[i] = factorial[i - 1] * i % MOD result = factorial[n] return result"},{"question":"def get_final_floors(test_cases): Simulate an elevator system based on the given commands and return the final floor for each test case. Args: test_cases (List[List[str]]): A list of test cases, each containing a list of commands. Returns: List[int]: The final floor for each test case. >>> get_final_floors([[\\"UP 3\\", \\"DOWN 1\\", \\"UP 2\\"], [\\"UP 5\\", \\"DOWN 3\\", \\"WAIT 4\\", \\"UP 1\\"]]) [4, 3] >>> get_final_floors([[\\"UP 1\\", \\"UP 2\\", \\"UP 3\\"]]) [6] >>> get_final_floors([[\\"DOWN 1\\", \\"DOWN 2\\", \\"DOWN 3\\"]]) [-6] >>> get_final_floors([[\\"UP 1\\", \\"WAIT 2\\", \\"DOWN 1\\"]]) [0] def process_input(input_data): Process input data and return the test cases. Args: input_data (str): A string containing the input data. Returns: List[List[str]]: A list of test cases, each containing a list of commands. >>> input_data = \\"2n3nUP 3nDOWN 1nUP 2n4nUP 5nDOWN 3nWAIT 4nUP 1\\" >>> process_input(input_data) [[\\"UP 3\\", \\"DOWN 1\\", \\"UP 2\\"], [\\"UP 5\\", \\"DOWN 3\\", \\"WAIT 4\\", \\"UP 1\\"]] def test_get_final_floors(): test_cases = [ [\\"UP 3\\", \\"DOWN 1\\", \\"UP 2\\"], [\\"UP 5\\", \\"DOWN 3\\", \\"WAIT 4\\", \\"UP 1\\"] ] expected = [4, 3] assert get_final_floors(test_cases) == expected test_cases = [[\\"UP 1\\", \\"UP 2\\", \\"UP 3\\"]] expected = [6] assert get_final_floors(test_cases) == expected test_cases = [[\\"DOWN 1\\", \\"DOWN 2\\", \\"DOWN 3\\"]] expected = [-6] assert get_final_floors(test_cases) == expected test_cases = [[\\"UP 1\\", \\"WAIT 2\\", \\"DOWN 1\\"]] expected = [0] assert get_final_floors(test_cases) == expected def test_process_input(): input_data = 2 3 UP 3 DOWN 1 UP 2 4 UP 5 DOWN 3 WAIT 4 UP 1 expected = [ [\\"UP 3\\", \\"DOWN 1\\", \\"UP 2\\"], [\\"UP 5\\", \\"DOWN 3\\", \\"WAIT 4\\", \\"UP 1\\"] ] assert process_input(input_data) == expected test_get_final_floors() test_process_input()","solution":"def get_final_floors(test_cases): results = [] for commands in test_cases: current_floor = 0 for command in commands: action, value = command.split() value = int(value) if action == \\"UP\\": current_floor += value elif action == \\"DOWN\\": current_floor -= value # We ignore \\"WAIT x\\" since it doesn't change the floor results.append(current_floor) return results def process_input(input_data): lines = input_data.strip().split('n') T = int(lines[0]) index = 1 test_cases = [] for _ in range(T): N = int(lines[index]) commands = lines[index + 1 : index + 1 + N] test_cases.append(commands) index += N + 1 return test_cases"},{"question":"def connected_cities(n: int, m: int, roads: List[Tuple[int, int]], q: int, queries: List[Tuple[int, int]]) -> List[str]: Determine whether there is a path between two cities. Each query is a pair of cities and the answer to each query is YES if there is a path connecting the two cities directly or indirectly through other cities; otherwise, the answer is NO. Args: n (int): Number of cities. m (int): Number of roads. roads (List[Tuple[int, int]]): List of tuples representing roads connecting the cities. q (int): Number of queries. queries (List[Tuple[int, int]]): List of tuples representing queries about connected cities. Returns: List[str]: List of \\"YES\\" or \\"NO\\" for each query. Examples: >>> connected_cities(5, 4, [(1, 2), (2, 3), (3, 4), (4, 5)], 3, [(1, 5), (2, 5), (5, 1)]) [\\"YES\\", \\"YES\\", \\"YES\\"] >>> connected_cities(4, 2, [(1, 2), (3, 4)], 3, [(1, 3), (2, 3), (4, 2)]) [\\"NO\\", \\"NO\\", \\"NO\\"]","solution":"def find_parent(parent, i): if parent[i] == i: return i else: parent[i] = find_parent(parent, parent[i]) return parent[i] def union(parent, rank, x, y): xroot = find_parent(parent, x) yroot = find_parent(parent, y) if xroot != yroot: if rank[xroot] < rank[yroot]: parent[xroot] = yroot elif rank[xroot] > rank[yroot]: parent[yroot] = xroot else: parent[yroot] = xroot rank[xroot] += 1 def connected_cities(n, m, roads, q, queries): parent = [] rank = [] for node in range(n): parent.append(node) rank.append(0) for road in roads: union(parent, rank, road[0] - 1, road[1] - 1) result = [] for query in queries: if find_parent(parent, query[0] - 1) == find_parent(parent, query[1] - 1): result.append(\\"YES\\") else: result.append(\\"NO\\") return result"},{"question":"from typing import List, Tuple def sum_of_depths(tree_edges: List[Tuple[int, List[Tuple[int, int]]]]) -> List[int]: Calculate the sum of the depths of all nodes in multiple binary trees. Args: tree_edges (List[Tuple[int, List[Tuple[int, int]]]]): A list of test cases, each containing the number of nodes and a list of edges. Returns: List[int]: A list of integers representing the sum of the depths of all nodes for each test case. Examples: >>> sum_of_depths([(3, [(1, 2), (1, 3)])]) [2] >>> sum_of_depths([(4, [(1, 2), (1, 3), (2, 4)])]) [4] # Implementation goes here","solution":"def sum_of_depths(tree_edges): from collections import defaultdict, deque def bfs_sum_depths(n, edges): graph = defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) depth_sum = {i: -1 for i in range(1, n+1)} depth_sum[1] = 0 queue = deque([1]) while queue: node = queue.popleft() current_depth = depth_sum[node] for neighbor in graph[node]: if depth_sum[neighbor] == -1: depth_sum[neighbor] = current_depth + 1 queue.append(neighbor) return sum(depth_sum.values()) results = [] for (n, edges) in tree_edges: results.append(bfs_sum_depths(n, edges)) return results"},{"question":"def kth_smallest_element(arr, k): Given an unsorted array and a number k, returns the k-th smallest element in the array or -1 if it does not exist. pass def process_queries(N, Q, arr, queries): Process the list of queries to find the K_i-th smallest element in the array at that point in time. Args: N : int : length of the array Q : int : number of queries arr : List[int] : the array of integers queries : List[int] : the list of queries Returns: List[int] : result list of the K_i-th smallest elements for each query pass def main(): Reads input from stdin, processes the queries, and prints the results. import sys input = sys.stdin.read data = input().split() N = int(data[0]) Q = int(data[1]) arr = list(map(int, data[2:N+2])) queries = list(map(int, data[N+2:])) results = process_queries(N, Q, arr, queries) for res in results: print(res) if __name__ == \\"__main__\\": main()","solution":"def kth_smallest_element(arr, k): Given an unsorted array and a number k, returns the k-th smallest element in the array or -1 if it does not exist. if k < 1 or k > len(arr): return -1 arr.sort() return arr[k-1] def process_queries(N, Q, arr, queries): results = [] for k in queries: result = kth_smallest_element(arr, k) results.append(result) return results def main(): import sys input = sys.stdin.read data = input().split() N = int(data[0]) Q = int(data[1]) arr = list(map(int, data[2:N+2])) queries = list(map(int, data[N+2:])) results = process_queries(N, Q, arr, queries) for res in results: print(res) if __name__ == \\"__main__\\": main()"},{"question":"from itertools import permutations from typing import List, Tuple def min_danger_level(N: int, M: int, roads: List[Tuple[int, int, int]]) -> int: Determine the minimum danger level for Chef Juno’s route that visits each village exactly once and returns to the starting village. Args: N : int : The number of villages M : int : The number of roads/bridges roads : List[Tuple[int, int, int]] : A list of tuples containing: - u (int) : The starting village of the road/bridge - v (int) : The ending village of the road/bridge - d (int) : The danger level of the road/bridge between village u and village v Returns: int : The minimum danger level of the route. If no such route exists, return -1. Examples: >>> min_danger_level(4, 6, [(1, 2, 10), (1, 3, 15), (1, 4, 20), (2, 3, 35), (2, 4, 25), (3, 4, 30)]) 80 >>> min_danger_level(4, 2, [(1, 2, 10), (3, 4, 15)]) -1","solution":"from itertools import permutations def min_danger_level(N, M, roads): INF = float('inf') # Create a matrix to hold the minimum danger levels between villages danger_matrix = [[INF] * N for _ in range(N)] for u, v, d in roads: danger_matrix[u-1][v-1] = min(danger_matrix[u-1][v-1], d) danger_matrix[v-1][u-1] = min(danger_matrix[v-1][u-1], d) # Iterate over all permutations of villages to find the minimum danger level route min_danger = INF for perm in permutations(range(1, N)): current_danger = danger_matrix[0][perm[0]] for i in range(len(perm) - 1): current_danger += danger_matrix[perm[i]][perm[i+1]] current_danger += danger_matrix[perm[-1]][0] min_danger = min(min_danger, current_danger) return -1 if min_danger == INF else min_danger"},{"question":"import math from functools import reduce def smallest_possible_value(n: int, array: List[int]) -> int: Determine the smallest possible value that all elements of the array can be made equal to after performing any number of operations. Parameters: n (int): The number of elements in the array array (list): The list of n integers Returns: int: The smallest possible value to make all elements equal >>> smallest_possible_value(5, [4, 8, 16, 32, 64]) 4 >>> smallest_possible_value(1, [7]) 7 >>> smallest_possible_value(3, [5, 5, 5]) 5 >>> smallest_possible_value(4, [2, 3, 5, 7]) 1 >>> smallest_possible_value(4, [6, 9, 12, 15]) 3 >>> smallest_possible_value(3, [1000000000, 500000000, 250000000]) 250000000 >>> smallest_possible_value(3, [1, 1, 1]) 1 >>> smallest_possible_value(3, [1, 1000000000, 50]) 1","solution":"import math from functools import reduce def smallest_possible_value(n, array): Determine the smallest possible value that all elements of the array can be made equal to after performing any number of operations. Parameters: n (int): The number of elements in the array array (list): The list of n integers Returns: int: The smallest possible value to make all elements equal # The smallest possible value is the GCD of all elements in the array return reduce(math.gcd, array)"},{"question":"import math from functools import reduce def lcm(a, b): Returns the least common multiple of a and b. pass def find_earliest_broadcast_time(n, frequencies): Returns the earliest time by which the signal tower can broadcast the next message that satisfies as many of the receiver's schedules as possible. >>> find_earliest_broadcast_time(4, [4, 6, 8, 12]) 24 >>> find_earliest_broadcast_time(3, [10, 15, 20]) 60 >>> find_earliest_broadcast_time(1, [5]) 5 >>> find_earliest_broadcast_time(3, [1, 2, 3]) 6 >>> find_earliest_broadcast_time(4, [2, 3, 5, 7]) 210 >>> find_earliest_broadcast_time(3, [4, 4, 4]) 4 pass","solution":"import math from functools import reduce def lcm(a, b): Returns the least common multiple of a and b. return abs(a*b) // math.gcd(a, b) def find_earliest_broadcast_time(n, frequencies): Returns the earliest time by which the signal tower can broadcast the next message that satisfies as many of the receiver's schedules as possible. return reduce(lcm, frequencies)"},{"question":"def can_reconstruct_tower(n, moves): Determine if the reconstruction of the Jenga tower in increasing order is possible given a sequence of moves. Parameters: n (int): The number of blocks. moves (List[int]): The sequence of moves, where 1 denotes extracting the topmost block and 2 denotes extracting the bottommost block. Returns: str: \\"YES\\" if the reconstruction is possible, otherwise \\"NO\\". Examples: >>> can_reconstruct_tower(3, [1, 2, 1, 1, 2, 2]) \\"YES\\" >>> can_reconstruct_tower(4, [2, 2, 1, 1, 2, 1, 1, 1]) \\"NO\\" pass def solve(t, test_cases): Solve multiple test cases for the Jenga tower reconstruction problem. Parameters: t (int): The number of test cases. test_cases (List[Tuple[int, List[int]]]): A list of test cases where each test case is a tuple containing an integer n (number of blocks) and a list of integers (sequence of moves). Returns: List[str]: A list of results for each test case, where each result is either \\"YES\\" or \\"NO\\". Examples: >>> solve(2, [(3, [1, 2, 1, 1, 2, 2]), (4, [2, 2, 1, 1, 2, 1, 1, 1])]) [\\"YES\\", \\"NO\\"] >>> solve(1, [(3, [1, 1, 1, 2, 2, 2])]) [\\"YES\\"] pass # Unit Tests def test_can_reconstruct_tower(): assert can_reconstruct_tower(3, [1, 2, 1, 1, 2, 2]) == \\"YES\\" assert can_reconstruct_tower(4, [2, 2, 1, 1, 2, 1, 1, 1]) == \\"NO\\" assert can_reconstruct_tower(3, [1, 1, 1, 2, 2, 2]) == \\"YES\\" assert can_reconstruct_tower(2, [2, 1, 1, 2]) == \\"NO\\" assert can_reconstruct_tower(1, [2, 1]) == \\"NO\\" assert can_reconstruct_tower(1, [1, 2]) == \\"YES\\" assert can_reconstruct_tower(0, []) == \\"YES\\" assert can_reconstruct_tower(5, [1, 1, 1, 1, 1, 2, 2, 2, 2, 2]) == \\"YES\\" def test_solve(): assert solve(2, [(3, [1, 2, 1, 1, 2, 2]), (4, [2, 2, 1, 1, 2, 1, 1, 1])]) == [\\"YES\\", \\"NO\\"] assert solve(1, [(3, [1, 1, 1, 2, 2, 2])]) == [\\"YES\\"] assert solve(3, [(2, [2, 1, 1, 2]), (1, [2, 1]), (1, [1, 2])]) == [\\"NO\\", \\"NO\\", \\"YES\\"]","solution":"def can_reconstruct_tower(n, moves): top_blocks = list(range(1, n + 1)) bottom_blocks = [] for move in moves: if move == 1: if top_blocks: bottom_blocks.append(top_blocks.pop()) else: return \\"NO\\" elif move == 2: if bottom_blocks: bottom_blocks = bottom_blocks[:-1] else: return \\"NO\\" # check if the remaining bottom_blocks is in increasing order prev = float('-inf') for block in bottom_blocks: if block <= prev: return \\"NO\\" prev = block return \\"YES\\" def solve(t, test_cases): results = [] for n, moves in test_cases: results.append(can_reconstruct_tower(n, moves)) return results"},{"question":"from typing import List from collections import Counter def most_popular_product(n: int, customers_favorites: List[str]) -> int: Determines the product that appears most frequently across all customers' lists. Parameters: n (int): Number of customers. customers_favorites (list of str): List containing space-separated strings of product IDs. Returns: int: The product ID that appears most frequently. If there are multiple, return the smallest ID. pass # Unit Tests def test_example_1(): n = 3 customers_favorites = [ \\"1 2 3\\", \\"2 3\\", \\"3\\" ] assert most_popular_product(n, customers_favorites) == 3 def test_example_2(): n = 2 customers_favorites = [ \\"4 4 4 4\\", \\"4 5 6\\" ] assert most_popular_product(n, customers_favorites) == 4 def test_all_unique_products(): n = 3 customers_favorites = [ \\"1 2 3\\", \\"4 5 6\\", \\"7 8 9\\" ] assert most_popular_product(n, customers_favorites) == 1 def test_tie_most_frequent(): n = 4 customers_favorites = [ \\"1 2\\", \\"1 3\\", \\"2 3\\", \\"1 2\\" ] assert most_popular_product(n, customers_favorites) == 1 def test_single_customer(): n = 1 customers_favorites = [ \\"10 20 30 10 40 10\\" ] assert most_popular_product(n, customers_favorites) == 10 def test_single_product_favorite(): n = 5 customers_favorites = [ \\"1\\", \\"1\\", \\"1\\", \\"1\\", \\"1\\" ] assert most_popular_product(n, customers_favorites) == 1","solution":"from collections import Counter def most_popular_product(n, customers_favorites): Determines the product that appears most frequently across all customers' lists. Parameters: n (int): Number of customers. customers_favorites (list of str): List containing space-separated strings of product IDs. Returns: int: The product ID that appears most frequently. If there are multiple, return the smallest ID. product_count = Counter() for favorites in customers_favorites: products = map(int, favorites.split()) product_count.update(products) most_common_product = min(product_count.items(), key=lambda item: (-item[1], item[0]))[0] return most_common_product"},{"question":"def maximize_sum(n: int, m: int, values: List[int]) -> int: Returns the maximum sum of the values of questions that are answered with '1' without exceeding m '1' answers. >>> maximize_sum(5, 2, [4, 2, 3, 5, 7]) 12 >>> maximize_sum(3, 1, [1, 3, 2]) 3 >>> maximize_sum(6, 3, [10, 20, 30, 40, 50, 60]) 150 import unittest class TestMaximizeSum(unittest.TestCase): def test_maximize_sum_example_1(self): self.assertEqual(maximize_sum(5, 2, [4, 2, 3, 5, 7]), 12) def test_maximize_sum_example_2(self): self.assertEqual(maximize_sum(3, 1, [1, 3, 2]), 3) def test_maximize_sum_example_3(self): self.assertEqual(maximize_sum(6, 3, [10, 20, 30, 40, 50, 60]), 150) def test_maximize_sum_empty_answer_list(self): self.assertEqual(maximize_sum(4, 0, [1, 2, 3, 4]), 0) def test_maximize_sum_max_ones_larger_than_n(self): self.assertEqual(maximize_sum(4, 5, [1, 2, 3, 4]), 10) def test_maximize_sum_identical_values(self): self.assertEqual(maximize_sum(5, 2, [5, 5, 5, 5, 5]), 10) def test_maximize_sum_minimum_input(self): self.assertEqual(maximize_sum(1, 0, [1]), 0) self.assertEqual(maximize_sum(1, 1, [1]), 1) def test_maximize_sum_n_is_m(self): self.assertEqual(maximize_sum(3, 3, [7, 8, 3]), 18) if __name__ == \\"__main__\\": unittest.main()","solution":"def maximize_sum(n, m, values): Returns the maximum sum of the values of questions that are answered with '1' without exceeding m '1' answers. return sum(sorted(values, reverse=True)[:m])"},{"question":"def count_odd_sum_pairs(arr: List[int]) -> int: This function counts the number of pairs (i, j) such that i < j and the sum of elements at indices i and j is an odd number. Parameters: arr (list of int): The list of integers representing the array. Returns: int: The number of valid pairs with an odd sum. >>> count_odd_sum_pairs([1, 2, 3, 4]) 4 >>> count_odd_sum_pairs([1, 1, 1]) 0 >>> count_odd_sum_pairs([2, 3, 4, 5, 6]) 6 from solution import count_odd_sum_pairs def test_count_odd_sum_pairs(): # Test cases from the problem examples assert count_odd_sum_pairs([1, 2, 3, 4]) == 4 assert count_odd_sum_pairs([1, 1, 1]) == 0 assert count_odd_sum_pairs([2, 3, 4, 5, 6]) == 6 # Additional test cases # Case with single element: no pairs possible assert count_odd_sum_pairs([1]) == 0 # Case with all even elements: no pairs with odd sum assert count_odd_sum_pairs([2, 4, 6, 8]) == 0 # Case with mix of negative and positive numbers assert count_odd_sum_pairs([-1, -2, 3, 4]) == 4 # Case with mix of zero and other numbers assert count_odd_sum_pairs([0, 1, 2, 3, 4]) == 6 # Case with alternating even and odd assert count_odd_sum_pairs([1, 2, 1, 2, 1, 2]) == 9","solution":"def count_odd_sum_pairs(arr): This function counts the number of pairs (i, j) such that i < j and the sum of elements at indices i and j is an odd number. Parameters: arr (list of int): The list of integers representing the array. Returns: int: The number of valid pairs with an odd sum. n = len(arr) count = 0 for i in range(n): for j in range(i+1, n): if (arr[i] + arr[j]) % 2 == 1: count += 1 return count"},{"question":"def is_director_happy(n: int, intervals: List[Tuple[int, int, int, int]]) -> str: Determine if the museum director will be happy based on the exhibition schedule. >>> is_director_happy(3, [(1, 4, 2, 5), (2, 6, 3, 8), (5, 9, 7, 10)]) \\"HAPPY\\" >>> is_director_happy(2, [(1, 2, 3, 5), (4, 6, 5, 7)]) \\"UNHAPPY\\" def test_happy_case(): assert is_director_happy(3, [(1, 4, 2, 5), (2, 6, 3, 8), (5, 9, 7, 10)]) == \\"HAPPY\\" def test_unhappy_case(): assert is_director_happy(2, [(1, 2, 3, 5), (4, 6, 5, 7)]) == \\"UNHAPPY\\" def test_edge_case_single_exhibit(): assert is_director_happy(1, [(1, 2, 3, 4)]) == \\"HAPPY\\" def test_overlapping_intervals_happy(): assert is_director_happy(2, [(1, 5, 6, 10), (2, 6, 7, 11)]) == \\"HAPPY\\" def test_different_overlapping_intervals_unhappy(): assert is_director_happy(2, [(1, 5, 10, 15), (5, 10, 1, 5)]) == \\"UNHAPPY\\"","solution":"def is_director_happy(n, intervals): hall_a_intervals = [] hall_b_intervals = [] for interval in intervals: ta_i, tb_i, tc_i, td_i = interval hall_a_intervals.append((ta_i, tb_i)) hall_b_intervals.append((tc_i, td_i)) hall_a_intervals.sort() hall_b_intervals.sort() def overlaps(intervals): for i in range(1, len(intervals)): if intervals[i][0] <= intervals[i-1][1]: return True return False if overlaps(hall_a_intervals) == overlaps(hall_b_intervals): return \\"HAPPY\\" else: return \\"UNHAPPY\\" def main(): import sys input = sys.stdin.read data = input().split() n = int(data[0]) intervals = [] index = 1 for _ in range(n): ta_i = int(data[index]) tb_i = int(data[index + 1]) tc_i = int(data[index + 2]) td_i = int(data[index + 3]) intervals.append((ta_i, tb_i, tc_i, td_i)) index += 4 print(is_director_happy(n, intervals)) if __name__ == \\"__main__\\": main()"},{"question":"class BeverageMachine: def __init__(self, n, S): Initialize the BeverageMachine with the number of beverage types n and the capacity S in liters. self.beverages = {} self.n = n self.S = S self.current_volume = 0 def add_beverage(self, type_id, volume): Add a specific volume of a beverage type to the machine. # Implement this method def remove_beverage(self, type_id, volume): Remove a specific volume of a beverage type from the machine. # Implement this method def query_status(self): Provide the current total volume of all beverages in the machine and list all beverage types present along with their respective volumes. # Implement this method def process_operations(n: int, S: int, operations: List[Tuple[int, ...]]) -> List[str]: Process a list of operations on the BeverageMachine and return the results of query operations. Args: n (int): Number of different beverage types. S (int): Capacity of the machine in liters. operations (List[Tuple[int, ...]]): List of operations to be performed. Returns: List[str]: List of results for query operations. # Initial setup machine = BeverageMachine(n, S) results = [] # Process each operation for op in operations: if op[0] == 1: # Add beverage operation _, type_id, volume = op # Implement adding beverage elif op[0] == 2: # Remove beverage operation _, type_id, volume = op # Implement removing beverage elif op[0] == 3: # Query status operation results.append(machine.query_status()) return results # Example test cases (you can add more for better coverage) if __name__ == '__main__': # Test initial state assert process_operations(3, 100, [(3,)]) == [\\"0 []\\"] # Test add beverages within capacity operations = [ (1, 1, 30), (1, 2, 20), (1, 3, 50), (3,) ] assert process_operations(3, 100, operations) == [\\"100 [1:30, 2:20, 3:50]\\"] # Test add beverages exceeding capacity operations = [ (1, 1, 30), (1, 2, 20), (1, 3, 50), (1, 1, 60), (3,) ] assert process_operations(3, 100, operations) == [\\"100 [1:30, 2:20, 3:50]\\"] # Test remove beverages operations = [ (1, 1, 30), (1, 2, 20), (1, 3, 50), (2, 2, 10), (3,) ] assert process_operations(3, 100, operations) == [\\"90 [1:30, 2:10, 3:50]\\"] # Test remove all of a beverage operations = [ (1, 1, 30), (1, 2, 20), (1, 3, 50), (2, 2, 20), (3,) ] assert process_operations(3, 100, operations) == [\\"80 [1:30, 3:50]\\"] # Test multiple queries operations = [ (1, 1, 30), (1, 2, 20), (1, 3, 50), (3,), (2, 2, 10), (3,) ] assert process_operations(3, 100, operations) == [\\"100 [1:30, 2:20, 3:50]\\", \\"90 [1:30, 2:10, 3:50]\\"]","solution":"class BeverageMachine: def __init__(self, n, S): self.beverages = {} self.n = n self.S = S self.current_volume = 0 def add_beverage(self, type_id, volume): if self.current_volume + volume > self.S: return if type_id in self.beverages: self.beverages[type_id] += volume else: self.beverages[type_id] = volume self.current_volume += volume def remove_beverage(self, type_id, volume): if type_id in self.beverages: removed_volume = min(self.beverages[type_id], volume) self.beverages[type_id] -= removed_volume self.current_volume -= removed_volume if self.beverages[type_id] == 0: del self.beverages[type_id] def query_status(self): result = [f\\"{k}:{v}\\" for k, v in sorted(self.beverages.items())] return f\\"{self.current_volume} [{', '.join(result)}]\\" def process_operations(n, S, operations): machine = BeverageMachine(n, S) results = [] for op in operations: if op[0] == 1: _, type_id, volume = op machine.add_beverage(type_id, volume) elif op[0] == 2: _, type_id, volume = op machine.remove_beverage(type_id, volume) elif op[0] == 3: results.append(machine.query_status()) return results"},{"question":"def count_ways_to_k_components(n: int, k: int, edges: List[Tuple[int, int]]) -> int: Calculates the number of ways to break the graph into exactly k connected components by removing some roads. >>> count_ways_to_k_components(4, 2, [(1, 2), (2, 3), (3, 4)]) 3 >>> count_ways_to_k_components(5, 3, [(1, 2), (1, 3), (1, 4), (4, 5)]) 6","solution":"import itertools def count_ways_to_k_components(n, k, edges): This function calculates the number of ways to break the graph into exactly k connected components by removing some roads. # Base case if k == 1: return 1 # Function to perform DFS def dfs(node, visited, graph): stack = [node] traversed = 0 while stack: n = stack.pop() if not visited[n]: visited[n] = True traversed += 1 stack.extend(graph[n]) return traversed # Creating an adjacency list for the graph graph = {i: [] for i in range(1, n+1)} for u, v in edges: graph[u].append(v) graph[v].append(u) count = 0 all_edges = list(itertools.combinations(edges, k-1)) # Combinations of edges we can remove for combination in all_edges: # Remove the edges temp_graph = {key: graph[key][:] for key in graph} for u, v in combination: temp_graph[u].remove(v) temp_graph[v].remove(u) # Count connected components visited = {i: False for i in range(1, n+1)} components = 0 for i in range(1, n+1): if not visited[i]: components += 1 dfs(i, visited, temp_graph) if components == k: count += 1 return count # Example usage: # n = 4 # k = 2 # edges = [(1, 2), (2, 3), (3, 4)] # print(count_ways_to_k_components(n, k, edges)) # Output: 3"},{"question":"def can_be_palindrome(s: str) -> str: Returns 'YES' if the string can be turned into a palindrome by ignoring up to one character, 'NO' otherwise. >>> can_be_palindrome('abca') == 'YES' >>> can_be_palindrome('abc') == 'NO'","solution":"def can_be_palindrome(s): Returns 'YES' if the string can be turned into a palindrome by ignoring up to one character, 'NO' otherwise. def is_palindrome_range(i, j): while i < j: if s[i] != s[j]: return False i += 1 j -= 1 return True left, right = 0, len(s) - 1 while left < right: if s[left] != s[right]: # If there's a mismatch, try to skip either the left or the right character return 'YES' if is_palindrome_range(left + 1, right) or is_palindrome_range(left, right - 1) else 'NO' left += 1 right -= 1 return 'YES'"},{"question":"def generate_grid(n: int) -> List[List[int]]: Generate a square grid of size (2*n - 1) x (2*n - 1) with a unique numeric pattern. The integer values run horizontally, vertically, and diagonally across the grid. Return the grid as a list of lists of integers. >>> generate_grid(1) [[1]] >>> generate_grid(2) [[0, 1, 0], [1, 2, 1], [0, 1, 0]] >>> generate_grid(3) [[0, 0, 1, 0, 0], [0, 1, 2, 1, 0], [1, 2, 3, 2, 1], [0, 1, 2, 1, 0], [0, 0, 1, 0, 0]] >>> generate_grid(4) [[0, 0, 0, 1, 0, 0, 0], [0, 0, 1, 2, 1, 0, 0], [0, 1, 2, 3, 2, 1, 0], [1, 2, 3, 4, 3, 2, 1], [0, 1, 2, 3, 2, 1, 0], [0, 0, 1, 2, 1, 0, 0], [0, 0, 0, 1, 0, 0, 0]] >>> generate_grid(5) [[0, 0, 0, 0, 1, 0, 0, 0, 0], [0, 0, 0, 1, 2, 1, 0, 0, 0], [0, 0, 1, 2, 3, 2, 1, 0, 0], [0, 1, 2, 3, 4, 3, 2, 1, 0], [1, 2, 3, 4, 5, 4, 3, 2, 1], [0, 1, 2, 3, 4, 3, 2, 1, 0], [0, 0, 1, 2, 3, 2, 1, 0, 0], [0, 0, 0, 1, 2, 1, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0, 0]] def print_grid(n: int): Generate and print the grid with the unique numeric pattern for a given integer n. >>> print_grid(1) 1 >>> print_grid(2) 0 1 0 1 2 1 0 1 0 >>> print_grid(3) 0 0 1 0 0 0 1 2 1 0 1 2 3 2 1 0 1 2 1 0 0 0 1 0 0 >>> print_grid(4) 0 0 0 1 0 0 0 0 0 1 2 1 0 0 0 1 2 3 2 1 0 1 2 3 4 3 2 1 0 1 2 3 2 1 0 0 0 1 2 1 0 0 0 0 0 1 0 0 0 >>> print_grid(5) 0 0 0 0 1 0 0 0 0 0 0 0 1 2 1 0 0 0 0 0 1 2 3 2 1 0 0 0 1 2 3 4 3 2 1 0 1 2 3 4 5 4 3 2 1 0 1 2 3 4 3 2 1 0 0 0 1 2 3 2 1 0 0 0 0 0 1 2 1 0 0 0 0 0 0 0 1 0 0 0 0","solution":"def generate_grid(n): size = 2 * n - 1 grid = [[0] * size for _ in range(size)] for i in range(size): for j in range(size): grid[i][j] = n - (abs(n - 1 - i) + abs(n - 1 - j)) for i in range(size): for j in range(size): if grid[i][j] < 0: grid[i][j] = 0 return grid def print_grid(n): grid = generate_grid(n) for row in grid: print(' '.join(map(str, row)))"},{"question":"def uniquePaths(m: int, n: int) -> int: Returns the number of unique paths from the top-left corner to the bottom-right corner of a m x n matrix moving only right, down, or diagonally. >>> uniquePaths(3, 3) 13 >>> uniquePaths(2, 2) 3 pass # Your code here # Unit tests def test_uniquePaths_3x3(): assert uniquePaths(3, 3) == 13 def test_uniquePaths_2x2(): assert uniquePaths(2, 2) == 3 def test_uniquePaths_1x1(): assert uniquePaths(1, 1) == 1 def test_uniquePaths_3x2(): assert uniquePaths(3, 2) == 5 def test_uniquePaths_2x3(): assert uniquePaths(2, 3) == 5 def test_uniquePaths_4x4(): assert uniquePaths(4, 4) == 63 def test_uniquePaths_50x50(): # This is a performance test to ensure that the function works for large grids. # Not verifying the actual number, but making sure it runs within a reasonable time result = uniquePaths(50, 50) assert result > 0 # We expect a large positive number","solution":"def uniquePaths(m, n): Returns the number of unique paths from the top-left corner to the bottom-right corner of a m x n matrix moving only right, down, or diagonally. # Create a 2D DP array initialized with 0's dp = [[0] * n for _ in range(m)] # Base case: There's only one way to be at the start dp[0][0] = 1 # Fill the DP table for i in range(m): for j in range(n): if i > 0: dp[i][j] += dp[i - 1][j] # From the top if j > 0: dp[i][j] += dp[i][j - 1] # From the left if i > 0 and j > 0: dp[i][j] += dp[i - 1][j - 1] # From the diagonal return dp[m - 1][n - 1]"},{"question":"def trap_rain_water(heights): Returns the total amount of water trapped between buildings. >>> trap_rain_water([0, 1, 3, 2, 5, 4]) 1 >>> trap_rain_water([4, 2, 0, 3, 2, 5]) 9","solution":"def trap_rain_water(heights): Returns the total amount of water trapped between buildings. if not heights: return 0 n = len(heights) left_max = [0] * n right_max = [0] * n water_trapped = 0 left_max[0] = heights[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], heights[i]) right_max[n - 1] = heights[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], heights[i]) for i in range(n): water_trapped += min(left_max[i], right_max[i]) - heights[i] return water_trapped if __name__ == \\"__main__\\": import sys input = sys.stdin.read data = input().split() n = int(data[0]) heights = list(map(int, data[1:])) print(trap_rain_water(heights))"},{"question":"from typing import List def smallest_subarray_with_all_distinct_elements(n: int, arr: List[int]) -> int: Determine the size of the smallest subarray that contains at least one occurrence of each distinct integer in the array. >>> smallest_subarray_with_all_distinct_elements(7, [1, 2, 2, 3, 1, 4, 2]) 4 >>> smallest_subarray_with_all_distinct_elements(6, [1, 2, 3, 4, 5, 6]) 6 >>> smallest_subarray_with_all_distinct_elements(5, [1, 1, 1, 1, 1]) 1 def test_smallest_subarray_with_all_distinct_elements(): assert smallest_subarray_with_all_distinct_elements(7, [1, 2, 2, 3, 1, 4, 2]) == 4 assert smallest_subarray_with_all_distinct_elements(6, [1, 2, 3, 4, 5, 6]) == 6 assert smallest_subarray_with_all_distinct_elements(5, [1, 1, 1, 1, 1]) == 1 assert smallest_subarray_with_all_distinct_elements(3, [3, 3, 3]) == 1 assert smallest_subarray_with_all_distinct_elements(5, [1, 2, 1, 2, 1]) == 2 assert smallest_subarray_with_all_distinct_elements(8, [1, 2, 2, 1, 3, 2, 4, 1]) == 4","solution":"def smallest_subarray_with_all_distinct_elements(n, arr): from collections import defaultdict distinct_elements = set(arr) required_distinct_count = len(distinct_elements) current_count = defaultdict(int) start = 0 min_length = n + 1 distinct_count_in_window = 0 for end in range(n): if current_count[arr[end]] == 0: distinct_count_in_window += 1 current_count[arr[end]] += 1 while distinct_count_in_window == required_distinct_count and start <= end: min_length = min(min_length, end - start + 1) current_count[arr[start]] -= 1 if current_count[arr[start]] == 0: distinct_count_in_window -= 1 start += 1 return min_length"},{"question":"def can_reach(n: int, m: int, grid: List[List[int]], start: tuple, end: tuple) -> str: Determines if Baby Ehab can reach Baby Badawy's cell. Parameters: n (int): The number of rows in the grid. m (int): The number of columns in the grid. grid (list of lists): The heights of the cells in the grid. start (tuple): The starting cell (x1, y1). end (tuple): The destination cell (x2, y2). Returns: str: \\"YES\\" if Ehab can reach Badawy's cell, otherwise \\"NO\\". >>> can_reach(4, 4, [[1, 2, 3, 4], [3, 2, 6, 5], [3, 4, 5, 7], [1, 2, 3, 8]], (0, 0), (3, 3)) 'YES' >>> can_reach(3, 3, [[1, 1, 1], [2, 2, 2], [1, 1, 1]], (0, 0), (2, 2)) 'NO' >>> can_reach(2, 2, [[1, 3], [2, 4]], (0, 0), (1, 1)) 'YES' >>> can_reach(1, 1, [[5]], (0, 0), (0, 0)) 'YES' >>> can_reach(3, 3, [[1, 2, 3], [6, 5, 4], [7, 8, 9]], (0, 0), (2, 2)) 'YES'","solution":"def can_reach(n, m, grid, start, end): Determines if Baby Ehab can reach Baby Badawy's cell. Parameters: n (int): The number of rows in the grid. m (int): The number of columns in the grid. grid (list of lists): The heights of the cells in the grid. start (tuple): The starting cell (x1, y1). end (tuple): The destination cell (x2, y2). Returns: str: \\"YES\\" if Ehab can reach Badawy's cell, otherwise \\"NO\\". def is_valid(x, y): return 0 <= x < n and 0 <= y < m def dfs(x, y): if (x, y) == end: return True visited.add((x, y)) for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nx, ny = x + dx, y + dy if is_valid(nx, ny) and (nx, ny) not in visited and grid[nx][ny] >= grid[x][y]: if dfs(nx, ny): return True return False visited = set() return \\"YES\\" if dfs(start[0], start[1]) else \\"NO\\""},{"question":"from typing import List def min_moves_to_reach_destination(grid: List[List[str]]) -> int: Finds the minimum moves required to reach the bottom-right cell from the top-left cell in the grid. If it's impossible to reach the destination, returns \\"IMPOSSIBLE\\". >>> min_moves_to_reach_destination([ ... ['.', '.', '.'], ... ['.', '.', '.'], ... ['.', '.', '.'] ... ]) == 4 >>> min_moves_to_reach_destination([ ... ['.', '.', '#', '.'], ... ['#', '.', '#', '.'], ... ['#', '.', '.', '.'], ... ['.', '#', '.', '.'], ... ]) == 6 >>> min_moves_to_reach_destination([ ... ['.', '#'], ... ['#', '.'] ... ]) == \\"IMPOSSIBLE\\" >>> min_moves_to_reach_destination([ ... ['.', '#', '.', '#'], ... ['#', '#', '#', '#'], ... ['.', '.', '.', '.'] ... ]) == \\"IMPOSSIBLE\\" >>> min_moves_to_reach_destination([ ... ['#', '.'], ... ['.', '.'] ... ]) == \\"IMPOSSIBLE\\" >>> min_moves_to_reach_destination([ ... ['.', '.'], ... ['.', '#'] ... ]) == \\"IMPOSSIBLE\\" pass","solution":"from collections import deque def min_moves_to_reach_destination(grid): Finds the minimum moves required to reach the bottom-right cell from the top-left cell in the grid. If it's impossible to reach the destination, returns \\"IMPOSSIBLE\\". n = len(grid) m = len(grid[0]) start = (0, 0) end = (n - 1, m - 1) # Check if the start or end are blocked if grid[0][0] == '#' or grid[n-1][m-1] == '#': return \\"IMPOSSIBLE\\" # Directions: right, down, left, up directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] visited = [[False] * m for _ in range(n)] queue = deque([(0, 0, 0)]) # (x, y, distance) visited[0][0] = True while queue: x, y, dist = queue.popleft() if (x, y) == end: return dist for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and not visited[nx][ny] and grid[nx][ny] == '.': visited[nx][ny] = True queue.append((nx, ny, dist + 1)) return \\"IMPOSSIBLE\\""},{"question":"def count_greater_than_average(lst): Given a list of integers, determines how many integers in the list are greater than the average value of the list. >>> count_greater_than_average([1, 2, 3, 4, 5]) 2 >>> count_greater_than_average([10, 20, 30, 40, 50, 60]) 3","solution":"def count_greater_than_average(lst): Returns the count of integers in the list that are greater than the average value of the list. if not lst: return 0 avg = sum(lst) / len(lst) count = sum(1 for x in lst if x > avg) return count # Example usage # lst = [1, 2, 3, 4, 5] # print(count_greater_than_average(lst)) # Output: 2 # lst = [10, 20, 30, 40, 50, 60] # print(count_greater_than_average(lst)) # Output: 3"},{"question":"def has_subarray_with_sum(A, T): Determines if there is any subarray of A whose sum is equal to T. Args: A: List of integers. T: Target integer. Returns: Boolean: True if such a subarray exists, otherwise False. Examples: >>> has_subarray_with_sum([1, 2, 3, 4, 5], 7) True >>> has_subarray_with_sum([2, 3, 1, -1], 10) False >>> has_subarray_with_sum([1, -1, 2, -2, 3, -3], 0) True from solution import has_subarray_with_sum def test_example_1(): assert has_subarray_with_sum([1, 2, 3, 4, 5], 7) == True def test_example_2(): assert has_subarray_with_sum([2, 3, 1, -1], 10) == False def test_example_3(): assert has_subarray_with_sum([1, -1, 2, -2, 3, -3], 0) == True def test_single_element_equals_target(): assert has_subarray_with_sum([5], 5) == True def test_single_element_does_not_equal_target(): assert has_subarray_with_sum([5], 10) == False def test_subarray_at_start(): assert has_subarray_with_sum([3, 4, -1, 2], 7) == True def test_subarray_at_end(): assert has_subarray_with_sum([-1, 2, 3, 4], 7) == True def test_large_numbers(): assert has_subarray_with_sum([10**9, -10**9, 10**9, -10**9, 1], 1) == True def test_no_subarray_exists(): assert has_subarray_with_sum([1, 2, 3, 4, 5], 20) == False def test_all_elements_same_as_target(): assert has_subarray_with_sum([4, 4, 4, 4], 4) == True def test_empty_array(): assert has_subarray_with_sum([], 0) == False","solution":"def has_subarray_with_sum(A, T): Returns true if there is any subarray of A whose sum is equal to T. Otherwise, returns false. prefix_sum = 0 prefix_sums = {0} # Initialize with 0 to handle the case where subarray starts from the beginning for num in A: prefix_sum += num if (prefix_sum - T) in prefix_sums: return True prefix_sums.add(prefix_sum) return False"},{"question":"def count_ways_to_connect_towers(n: int) -> int: Returns the number of ways to connect \`n\` towers with non-intersecting ropes. >>> count_ways_to_connect_towers(3) 0 >>> count_ways_to_connect_towers(4) 2 pass import pytest def test_one_tower(): assert count_ways_to_connect_towers(1) == 0 def test_two_towers(): assert count_ways_to_connect_towers(2) == 1 def test_three_towers(): assert count_ways_to_connect_towers(3) == 0 def test_four_towers(): assert count_ways_to_connect_towers(4) == 2 def test_six_towers(): assert count_ways_to_connect_towers(6) == 5 def test_eight_towers(): assert count_ways_to_connect_towers(8) == 14 if __name__ == \\"__main__\\": pytest.main()","solution":"def calculate_catalan_number(n): Calculates the n-th Catalan number. if n == 0: return 1 catalan = [0] * (n + 1) catalan[0] = 1 for i in range(1, n + 1): for j in range(i): catalan[i] += catalan[j] * catalan[i - 1 - j] return catalan[n] def count_ways_to_connect_towers(n): Returns the number of ways to connect \`n\` towers with non-intersecting ropes. # If there's only one tower, there's one way (no ropes) if n % 2 != 0: return 0 # We can't pair towers if \`n\` is odd return calculate_catalan_number(n // 2) # Example usage if __name__ == \\"__main__\\": example_input = 3 print(count_ways_to_connect_towers(example_input)) # Output: 0 example_input = 4 print(count_ways_to_connect_towers(example_input)) # Output: 2"},{"question":"from typing import List, Tuple def shortest_path_in_grid(N: int, M: int, queries: List[Tuple[int, int, int, int]]) -> List[int]: Determine the shortest number of moves required to deliver the package from the starting position to the destination position for each query in an N x M grid. >>> shortest_path_in_grid(5, 5, [(0, 0, 4, 4)]) [8] >>> shortest_path_in_grid(5, 5, [(1, 1, 3, 3)]) [4] >>> shortest_path_in_grid(5, 5, [(0, 0, 0, 0)]) [0] >>> shortest_path_in_grid(5, 5, [(0, 0, 1, 0)]) [1] >>> shortest_path_in_grid(5, 5, [(0, 0, 0, 4)]) [4] >>> shortest_path_in_grid(5, 5, [(4, 4, 0, 0)]) [8]","solution":"from collections import deque def shortest_path_in_grid(N, M, queries): # Directions for movement [up, down, left, right] directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] def bfs(sx, sy, dx, dy): # Check if start and destination are the same if (sx, sy) == (dx, dy): return 0 # Create a visited set to store visited cells visited = set() # Create a queue for BFS and initialize with the starting point queue = deque([(sx, sy, 0)]) # (current_x, current_y, current_distance) visited.add((sx, sy)) while queue: x, y, dist = queue.popleft() # Traverse all the 4 possible directions for dxn, dyn in directions: nx, ny = x + dxn, y + dyn # Check validity of the new position if 0 <= nx < N and 0 <= ny < M and (nx, ny) not in visited: if (nx, ny) == (dx, dy): return dist + 1 queue.append((nx, ny, dist + 1)) visited.add((nx, ny)) # If no path found, return -1 return -1 results = [] for sx, sy, dx, dy in queries: results.append(bfs(sx, sy, dx, dy)) return results"},{"question":"import math from typing import List def is_triangular(num: int) -> int: Check if a number is a triangular number and return its position in the sequence. >>> is_triangular(1) 1 >>> is_triangular(3) 2 >>> is_triangular(6) 3 >>> is_triangular(9) -1 >>> is_triangular(10) 4 def process_numbers(numbers: List[int]) -> List[int]: Process a list of numbers to determine the triangular number positions. >>> process_numbers([1, 3, 6, 9, 10, 0]) [1, 2, 3, -1, 4] >>> process_numbers([15, 21, 28, 36, 0]) [5, 6, 7, 8] >>> process_numbers([45, 55, 66, 0]) [9, 10, 11] >>> process_numbers([0]) []","solution":"import math def is_triangular(num): if num <= 0: return -1 # Calculate n by solving the quadratic equation n^2 + n - 2*num = 0 using the quadratic formula n = (-1 + math.sqrt(1 + 8 * num)) / 2 if n.is_integer(): return int(n) else: return -1 def process_numbers(numbers): results = [] for num in numbers: if num == 0: break results.append(is_triangular(num)) return results"},{"question":"import heapq from collections import defaultdict def minimum_travel_time(n: int, m: int, tracks: List[Tuple[int, int, int]], start: int, end: int) -> int: Calculate the minimum travel time required for a train to travel from a given start station to a destination station. The train can make stops at other stations along the way, but the total travel time must be minimized. Args: n (int): number of stations m (int): number of tracks tracks (List[Tuple[int, int, int]]): list of tracks with travel time (u, v, t) start (int): start station end (int): destination station Returns: int: minimum travel time or -1 if no valid route Examples: >>> minimum_travel_time(5, 6, [(1, 2, 10), (2, 3, 20), (1, 3, 30), (3, 4, 10), (4, 5, 20), (3, 5, 30)], 1, 5) 60 >>> minimum_travel_time(4, 2, [(1, 2, 5), (3, 4, 5)], 1, 4) -1","solution":"import heapq from collections import defaultdict import sys def dijkstra(n, graph, start, end): pq = [(0, start)] dist = {i: float('inf') for i in range(1, n+1)} dist[start] = 0 while pq: current_dist, current_station = heapq.heappop(pq) if current_station == end: return current_dist if current_dist > dist[current_station]: continue for neighbor, weight in graph[current_station]: distance = current_dist + weight if distance < dist[neighbor]: dist[neighbor] = distance heapq.heappush(pq, (distance, neighbor)) return -1 if dist[end] == float('inf') else dist[end] def minimum_travel_time(n, m, tracks, start, end): graph = defaultdict(list) for u, v, t in tracks: graph[u].append((v, t)) graph[v].append((u, t)) return dijkstra(n, graph, start, end) # Example Usage n = 5 m = 6 tracks = [ (1, 2, 10), (2, 3, 20), (1, 3, 30), (3, 4, 10), (4, 5, 20), (3, 5, 30) ] start, end = 1, 5 print(minimum_travel_time(n, m, tracks, start, end)) # Output: 60"},{"question":"def min_additions_to_make_palindrome(s: str) -> int: Determines the minimum number of characters needed to add to make the string a palindrome. Parameters: s (str): The input string consisting of lowercase Latin letters. Returns: int: The minimum number of characters to add to make the string a palindrome. Examples: >>> min_additions_to_make_palindrome(\\"abc\\") 2 >>> min_additions_to_make_palindrome(\\"aab\\") 1","solution":"def min_additions_to_make_palindrome(s): Determines the minimum number of characters needed to add to make the string a palindrome. Parameters: s (str): The input string consisting of lowercase Latin letters. Returns: int: The minimum number of characters to add to make the string a palindrome. def longest_palindromic_subsequence(s): n = len(s) dp = [[0] * n for _ in range(n)] for i in range(n): dp[i][i] = 1 for length in range(2, n + 1): for i in range(n - length + 1): j = i + length - 1 if s[i] == s[j]: dp[i][j] = dp[i + 1][j - 1] + 2 else: dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]) return dp[0][n - 1] lps_length = longest_palindromic_subsequence(s) return len(s) - lps_length"},{"question":"from typing import List, Tuple def update_book_quantities(update_string: str) -> List[Tuple[int, int]]: Updates the quantities of books based on the given update string. Parameters: update_string (str): A string with comma-separated book ID ranges and quantities. Returns: list: A list of tuples with book IDs and their updated quantities, sorted by book IDs. >>> update_book_quantities(\\"1-3:5\\") [(1, 5), (2, 5), (3, 5)] >>> update_book_quantities(\\"2:10\\") [(2, 10)] >>> update_book_quantities(\\"1-3:5,2:10,5-7:8\\") [(1, 5), (2, 10), (3, 5), (5, 8), (6, 8), (7, 8)] >>> update_book_quantities(\\"3:7,1-2:9\\") [(1, 9), (2, 9), (3, 7)] >>> update_book_quantities(\\"10-12:3,11-13:6\\") [(10, 3), (11, 6), (12, 6), (13, 6)]","solution":"def update_book_quantities(update_string): Updates the quantities of books based on the given update string. Parameters: update_string (str): A string with comma-separated book ID ranges and quantities. Returns: list: A list of tuples with book IDs and their updated quantities, sorted by book IDs. updates = update_string.split(',') inventory = {} for update in updates: range_part, quantity = update.split(':') quantity = int(quantity) if '-' in range_part: start, end = map(int, range_part.split('-')) for book_id in range(start, end + 1): inventory[book_id] = quantity else: book_id = int(range_part) inventory[book_id] = quantity sorted_inventory = sorted(inventory.items()) return sorted_inventory"},{"question":"def count_distinct_integers_on_board(N: int, A: List[int]) -> int: Calculate how many different integers can be written on the whiteboard given the operations available. >>> count_distinct_integers_on_board(3, [3, 5, 7]) 9 >>> count_distinct_integers_on_board(4, [2, 4, 6, 10]) 10 >>> count_distinct_integers_on_board(2, [1, 1000000000]) 1999999999 >>> count_distinct_integers_on_board(1, [7]) 1","solution":"def count_distinct_integers_on_board(N, A): max_sum = sum(A) return max_sum"},{"question":"def check_unique_stalls(n: int, goods: List[int]) -> str: Determines if all stalls have unique types of goods. >>> check_unique_stalls(5, [1, 2, 3, 4, 5]) \\"YES\\" >>> check_unique_stalls(4, [1, 2, 2, 3]) \\"NO\\"","solution":"def check_unique_stalls(n, goods): Determines if all stalls have unique types of goods. return \\"YES\\" if len(goods) == len(set(goods)) else \\"NO\\""},{"question":"def golden_apples_count(n): Computes the number of golden apples on the tree after n days. >>> golden_apples_count(3) == 7 >>> golden_apples_count(10) == 1023 def main(input_list): Processes a list of inputs, each corresponding to the number of days (N), and returns the number of golden apples on the tree after each N days. >>> main([3]) == [7] >>> main([3, 10]) == [7, 1023]","solution":"def golden_apples_count(n): Computes the number of golden apples on the tree after n days. MOD = 10**9 + 7 return (2**n - 1) % MOD def main(input_list): Processes a list of inputs, each corresponding to the number of days (N), and returns the number of golden apples on the tree after each N days. results = [] for n in input_list: results.append(golden_apples_count(n)) return results"},{"question":"def is_prime(n: int) -> bool: Determine whether a given number is a prime number. >>> is_prime(2) True >>> is_prime(3) True >>> is_prime(4) False >>> is_prime(11) True >>> is_prime(25) False pass def sum_of_digits(n: int) -> int: Calculate the sum of digits of a given number. >>> sum_of_digits(113) 5 >>> sum_of_digits(74) 11 >>> sum_of_digits(123456789) 45 pass def check_prime_digit_sum(test_cases: List[int]) -> List[str]: For each number in the test cases, check if the sum of its digits is a prime number. >>> check_prime_digit_sum([113]) [\\"YES\\"] >>> check_prime_digit_sum([74]) [\\"YES\\"] >>> check_prime_digit_sum([123456789]) [\\"NO\\"] >>> check_prime_digit_sum([2, 9, 27, 31]) [\\"YES\\", \\"NO\\", \\"NO\\", \\"NO\\"] pass def test_is_prime(): assert is_prime(2) == True assert is_prime(3) == True assert is_prime(4) == False assert is_prime(11) == True assert is_prime(25) == False def test_sum_of_digits(): assert sum_of_digits(113) == 5 assert sum_of_digits(74) == 11 assert sum_of_digits(123456789) == 45 def test_check_prime_digit_sum(): assert check_prime_digit_sum([113]) == [\\"YES\\"] assert check_prime_digit_sum([74]) == [\\"YES\\"] assert check_prime_digit_sum([123456789]) == [\\"NO\\"] assert check_prime_digit_sum([2, 9, 27, 31]) == [\\"YES\\", \\"NO\\", \\"NO\\", \\"NO\\"] if __name__ == \\"__main__\\": test_is_prime() test_sum_of_digits() test_check_prime_digit_sum() print(\\"All tests passed!\\")","solution":"def is_prime(n): if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def sum_of_digits(n): return sum(int(digit) for digit in str(n)) def check_prime_digit_sum(test_cases): results = [] for number in test_cases: digit_sum = sum_of_digits(number) if is_prime(digit_sum): results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def first_n_primes(n: int) -> List[int]: Returns a list of the first n prime numbers. >>> first_n_primes(5) [2, 3, 5, 7, 11] >>> first_n_primes(10) [2, 3, 5, 7, 11, 13, 17, 19, 23, 29] pass # Test Cases def test_first_n_primes_1(): assert first_n_primes(1) == [2] def test_first_n_primes_5(): assert first_n_primes(5) == [2, 3, 5, 7, 11] def test_first_n_primes_10(): assert first_n_primes(10) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29] def test_first_n_primes_edge_case(): assert first_n_primes(0) == [] def test_first_n_primes_large(): result = first_n_primes(100) assert len(result) == 100 assert result[-1] == 541 # 100th prime number def test_first_n_primes_mixed(): primes10 = first_n_primes(10) assert primes10 == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29] primes20 = first_n_primes(20) assert primes20[:10] == primes10 # First 10 primes should be the same","solution":"from typing import List def first_n_primes(n: int) -> List[int]: Returns a list of the first n prime numbers. def is_prime(num): if num <= 1: return False if num == 2: return True if num % 2 == 0: return False for i in range(3, int(num ** 0.5) + 1, 2): if num % i == 0: return False return True primes = [] candidate = 2 while len(primes) < n: if is_prime(candidate): primes.append(candidate) candidate += 1 return primes"},{"question":"def can_measure_exactly(a, b, c, d): Determine if it is possible to measure exactly D liters of water using three jugs with given capacities. Arguments: a -- capacity of the first jug b -- capacity of the second jug c -- capacity of the third jug d -- desired volume of water Returns: 'YES' if it is possible to measure exactly D liters, otherwise 'NO' Example: >>> can_measure_exactly(3, 5, 8, 4) 'YES' >>> can_measure_exactly(2, 4, 6, 5) 'NO' >>> can_measure_exactly(1, 1, 1, 2) 'NO' pass def solve(num_cases, test_cases): Solve the problem for multiple test cases. Arguments: num_cases -- number of test cases test_cases -- list of tuples, each containing four integers (A, B, C, D) Returns: List of strings, each being 'YES' or 'NO' for the corresponding test case Example: >>> solve(3, [(3, 5, 8, 4), (2, 4, 6, 5), (1, 1, 1, 2)]) ['YES', 'NO', 'NO'] pass def test_can_measure_exactly(): assert can_measure_exactly(3, 5, 8, 4) == 'YES' assert can_measure_exactly(2, 4, 6, 5) == 'NO' assert can_measure_exactly(1, 1, 1, 2) == 'NO' assert can_measure_exactly(7, 11, 13, 9) == 'YES' assert can_measure_exactly(6, 9, 12, 3) == 'YES' assert can_measure_exactly(1, 1, 1, 1) == 'YES' assert can_measure_exactly(1, 2, 4, 8) == 'NO' assert can_measure_exactly(8, 9, 5, 5) == 'YES' def test_solve(): assert solve(3, [(3, 5, 8, 4), (2, 4, 6, 5), (1, 1, 1, 2)]) == ['YES', 'NO', 'NO'] assert solve(2, [(6, 9, 12, 3), (8, 9, 5, 5)]) == ['YES', 'YES'] assert solve(3, [(7, 11, 13, 9), (1, 1, 1, 1), (1, 2, 4, 8)]) == ['YES', 'YES', 'NO']","solution":"def can_measure_exactly(a, b, c, d): from math import gcd def can_measure_with_two_jugs(x, y, d): if d > max(x, y): return False return d % gcd(x, y) == 0 return ('YES' if can_measure_with_two_jugs(a, b, d) or can_measure_with_two_jugs(a, c, d) or can_measure_with_two_jugs(b, c, d) else 'NO') def solve(num_cases, test_cases): results = [] for i in range(num_cases): a, b, c, d = test_cases[i] results.append(can_measure_exactly(a, b, c, d)) return results"},{"question":"from typing import List def can_partition(nums: List[int]) -> bool: Given an array of integers, determine whether it is possible to partition the array into two subsets such that the sum of elements in both subsets is equal. >>> can_partition([1, 5, 11, 5]) True >>> can_partition([1, 2, 3, 5]) False >>> can_partition([1]) False >>> can_partition([2, 2]) True >>> can_partition([2, 3]) False >>> can_partition([1] * 100) True >>> can_partition([1] * 99) False","solution":"from typing import List def can_partition(nums: List[int]) -> bool: total_sum = sum(nums) # If total sum is odd, it's not possible to partition it into two equal subsets if total_sum % 2 != 0: return False target = total_sum // 2 n = len(nums) # Create a DP array to store boolean values dp = [False] * (target + 1) dp[0] = True for num in nums: for j in range(target, num - 1, -1): dp[j] = dp[j] or dp[j - num] return dp[target]"},{"question":"def minimum_subset_difference(weights): Returns the minimum possible difference between the sums of the two subsets. >>> minimum_subset_difference([1, 2, 3, 9]) == 3 >>> minimum_subset_difference([1, 2, 3, 4, 5]) == 1 >>> minimum_subset_difference([10, 20, 15]) == 5 >>> minimum_subset_difference([10]) == 10 >>> minimum_subset_difference([10, 10]) == 0 >>> minimum_subset_difference([1, 1000]) == 999 >>> minimum_subset_difference([5, 5, 5, 5]) == 0 >>> weights = [i for i in range(1, 101)] >>> minimum_subset_difference(weights) == 0","solution":"def minimum_subset_difference(weights): Returns the minimum possible difference between the sums of the two subsets. total_sum = sum(weights) n = len(weights) dp = [[False] * (total_sum + 1) for _ in range(n + 1)] dp[0][0] = True for i in range(1, n + 1): for j in range(total_sum + 1): dp[i][j] = dp[i - 1][j] if j >= weights[i - 1]: dp[i][j] = dp[i][j] or dp[i - 1][j - weights[i - 1]] min_diff = float('inf') for s in range(total_sum // 2 + 1): if dp[n][s]: min_diff = min(min_diff, total_sum - 2 * s) return min_diff"},{"question":"def count_and_say(n: int) -> str: Generates the nth term in the count-and-say sequence. >>> count_and_say(1) \\"1\\" >>> count_and_say(2) \\"11\\" >>> count_and_say(3) \\"21\\" >>> count_and_say(4) \\"1211\\" >>> count_and_say(5) \\"111221\\" >>> count_and_say(6) \\"312211\\"","solution":"def count_and_say(n): Generates the nth term in the count-and-say sequence. if n == 1: return \\"1\\" def get_next(sequence): result = [] i = 0 while i < len(sequence): count = 1 while i + 1 < len(sequence) and sequence[i] == sequence[i + 1]: i += 1 count += 1 result.append(f\\"{count}{sequence[i]}\\") i += 1 return ''.join(result) current_sequence = \\"1\\" for _ in range(1, n): current_sequence = get_next(current_sequence) return current_sequence"},{"question":"def compare_books(a: int, b: int) -> str: Prints congratulatory message if Jaime read more books this month than the previous month. Otherwise, prints an encouragement message to keep trying. >>> compare_books(5, 7) \\"Congratulations!\\" >>> compare_books(8, 6) \\"Keep trying!\\" >>> compare_books(10, 15) \\"Congratulations!\\" >>> compare_books(50, 50) \\"Keep trying!\\" >>> compare_books(1, 2) \\"Congratulations!\\" >>> compare_books(100, 99) \\"Keep trying!\\"","solution":"def compare_books(a, b): Prints congratulatory message if Jaime read more books this month than the previous month. Otherwise, prints an encouragement message to keep trying. if b > a: return \\"Congratulations!\\" else: return \\"Keep trying!\\""},{"question":"def can_be_palindrome_by_deleting_one_char(s: str) -> bool: Determines if a string can be converted to a palindrome by deleting at most one character. >>> can_be_palindrome_by_deleting_one_char(\\"abca\\") True >>> can_be_palindrome_by_deleting_one_char(\\"abc\\") False","solution":"def can_be_palindrome_by_deleting_one_char(s): Determines if a string can be converted to a palindrome by deleting at most one character. def is_palindrome_range(i, j): return all(s[k] == s[j - k + i] for k in range(i, j)) start, end = 0, len(s) - 1 while start < end: if s[start] != s[end]: # Check by skipping either character at start or end return is_palindrome_range(start + 1, end) or is_palindrome_range(start, end - 1) start += 1 end -= 1 return True def main(): import sys input = sys.stdin.read s = input().strip() if can_be_palindrome_by_deleting_one_char(s): print(\\"YES\\") else: print(\\"NO\\")"},{"question":"def first_non_repeating_character(s: str) -> str: Returns the first non-repeating character in the string s. If there is no non-repeating character, returns 'NA'. >>> first_non_repeating_character(\\"abacabad\\") 'c' >>> first_non_repeating_character(\\"abcdef\\") 'a' >>> first_non_repeating_character(\\"aabbcc\\") 'NA' >>> first_non_repeating_character(\\"loveleetcode\\") 'v' >>> first_non_repeating_character(\\"aabb\\") 'NA' >>> first_non_repeating_character(\\"a\\") 'a' >>> first_non_repeating_character(\\"\\") 'NA' # Write your code here def process_input(input_strings: List[str]) -> List[str]: Processes a list of input strings and returns a list of results for each string. Output is the first non-repeating character in each string, or 'NA' if there is no such character. >>> process_input([\\"abacabad\\", \\"abcdef\\", \\"aabbcc\\", \\"END\\"]) ['c', 'a', 'NA'] >>> process_input([\\"loveleetcode\\", \\"aabbcc\\", \\"END\\"]) ['v', 'NA'] >>> process_input([\\"abcd\\", \\"xyz\\", \\"END\\"]) ['a', 'x'] # Write your code here","solution":"def first_non_repeating_character(s): Returns the first non-repeating character in the string s. If there is no non-repeating character, returns 'NA'. char_count = {} for char in s: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 for char in s: if char_count[char] == 1: return char return 'NA' def process_input(input_strings): results = [] for s in input_strings: if s == \\"END\\": break results.append(first_non_repeating_character(s)) return results"},{"question":"def critical_road_count(n: int, m: int, roads: List[Tuple[int, int]]) -> int: Determine the number of critical roads in a network of neighborhoods connected by bidirectional roads. Args: n: An integer representing the number of neighborhoods. m: An integer representing the number of roads. roads: A list of tuples where each tuple contains two integers (u, v) representing a road between neighborhoods u and v. Returns: An integer representing the number of critical roads. Example: >>> critical_road_count(4, 5, [(1, 2), (2, 3), (3, 4), (4, 1), (2, 4)]) == 0 >>> critical_road_count(2, 1, [(1, 2)]) == 1 from solution import critical_road_count def test_critical_road_count_example(): n = 4 m = 5 roads = [(1, 2), (2, 3), (3, 4), (4, 1), (2, 4)] assert critical_road_count(n, m, roads) == 0 def test_critical_road_count_single_road(): n = 2 m = 1 roads = [(1, 2)] assert critical_road_count(n, m, roads) == 1 def test_critical_road_count_disconnected_graph(): n = 5 m = 3 roads = [(1, 2), (3, 4), (4, 5)] assert critical_road_count(n, m, roads) == 3 def test_critical_road_count_no_critical_road(): n = 3 m = 3 roads = [(1, 2), (2, 3), (1, 3)] assert critical_road_count(n, m, roads) == 0 def test_critical_road_count_multiple_components(): n = 6 m = 5 roads = [(1, 2), (2, 3), (4, 5), (5, 6), (4, 6)] assert critical_road_count(n, m, roads) == 2","solution":"def critical_road_count(n, m, roads): from collections import defaultdict graph = defaultdict(list) for u, v in roads: graph[u].append(v) graph[v].append(u) time = 0 low = [-1] * (n + 1) disc = [-1] * (n + 1) parent = [-1] * (n + 1) critical_count = 0 def dfs(u): nonlocal time, critical_count disc[u] = low[u] = time time += 1 children = 0 for v in graph[u]: if disc[v] == -1: # v is not visited parent[v] = u children += 1 dfs(v) low[u] = min(low[u], low[v]) if low[v] > disc[u]: critical_count += 1 elif v != parent[u]: # Back edge low[u] = min(low[u], disc[v]) for i in range(1, n + 1): if disc[i] == -1: dfs(i) return critical_count"},{"question":"def check_even_odd(M: int, B: List[int]) -> List[str]: For each element in the array B, print whether the element is even or odd. Parameters: M (int): Number of elements in the array. B (list of int): List of positive integers. Returns: List of strings: \\"even\\" if the element is even and \\"odd\\" if the element is odd. Examples: >>> check_even_odd(3, [4, 7, 10]) [\\"even\\", \\"odd\\", \\"even\\"] >>> check_even_odd(3, [2, 4, 6]) [\\"even\\", \\"even\\", \\"even\\"] >>> check_even_odd(3, [1, 3, 5]) [\\"odd\\", \\"odd\\", \\"odd\\"] from typing import List def test_check_even_odd_all_even(): assert check_even_odd(3, [2, 4, 6]) == [\\"even\\", \\"even\\", \\"even\\"] def test_check_even_odd_all_odd(): assert check_even_odd(3, [1, 3, 5]) == [\\"odd\\", \\"odd\\", \\"odd\\"] def test_check_even_odd_mixed(): assert check_even_odd(4, [1, 2, 3, 4]) == [\\"odd\\", \\"even\\", \\"odd\\", \\"even\\"] def test_check_even_odd_single_element_odd(): assert check_even_odd(1, [7]) == [\\"odd\\"] def test_check_even_odd_single_element_even(): assert check_even_odd(1, [8]) == [\\"even\\"] def test_check_even_odd_maximum_boundary(): assert check_even_odd(10, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == [ \\"odd\\", \\"even\\", \\"odd\\", \\"even\\", \\"odd\\", \\"even\\", \\"odd\\", \\"even\\", \\"odd\\", \\"even\\" ]","solution":"def check_even_odd(M, B): For each element in the array B, print whether the element is even or odd. Parameters: M (int): Number of elements in the array. B (list of int): List of positive integers. Returns: List of strings: \\"even\\" if the element is even and \\"odd\\" if the element is odd. results = [] for b in B: if b % 2 == 0: results.append(\\"even\\") else: results.append(\\"odd\\") return results"},{"question":"class SequenceManager: def __init__(self, sequence): self.sequence = sequence def update(self, x, y): Update the x-th element in the sequence to the value y. >>> seq = [1, 2, -3, 4, 5] >>> manager = SequenceManager(seq) >>> manager.update(3, 3) >>> manager.sequence [1, 2, 3, 4, 5] def max_subarray_sum(self, x, y): Find the maximum sum of any contiguous subarray within the range [x, y]. >>> seq = [1, 2, -3, 4, 5] >>> manager = SequenceManager(seq) >>> manager.max_subarray_sum(1, 3) 3 >>> manager.max_subarray_sum(2, 5) 9 def process_operations(n, q, sequence, operations): Perform q operations on the sequence and return the results of the queries. >>> n = 5 >>> q = 5 >>> sequence = [1, 2, -3, 4, 5] >>> operations = [ ... ['Q', 1, 3], ... ['Q', 2, 5], ... ['U', 3, 3], ... ['Q', 1, 3], ... ['Q', 2, 5] ... ] >>> process_operations(n, q, sequence, operations) [3, 9, 6, 14]","solution":"class SequenceManager: def __init__(self, sequence): self.sequence = sequence def update(self, x, y): self.sequence[x-1] = y def max_subarray_sum(self, x, y): subarray = self.sequence[x-1:y] max_sum = cur_sum = subarray[0] for num in subarray[1:]: cur_sum = max(num, cur_sum + num) max_sum = max(max_sum, cur_sum) return max_sum def process_operations(n, q, sequence, operations): manager = SequenceManager(sequence) results = [] for op in operations: if op[0] == 'U': manager.update(op[1], op[2]) elif op[0] == 'Q': result = manager.max_subarray_sum(op[1], op[2]) results.append(result) return results"},{"question":"def valid_palindrome_with_one_removal(s: str) -> str: Checks if a given string is a valid palindrome after removing exactly one character from it. >>> valid_palindrome_with_one_removal(\\"abca\\") 'YES' >>> valid_palindrome_with_one_removal(\\"abc\\") 'NO'","solution":"def valid_palindrome_with_one_removal(s: str) -> str: def is_palindrome_range(i, j): while i < j: if s[i] != s[j]: return False i += 1 j -= 1 return True left, right = 0, len(s) - 1 while left < right: if s[left] != s[right]: if is_palindrome_range(left + 1, right) or is_palindrome_range(left, right - 1): return \\"YES\\" else: return \\"NO\\" left += 1 right -= 1 return \\"YES\\""},{"question":"from typing import List, Tuple def min_recolor_operations(t: int, test_cases: List[Tuple[int, int, List[str]]]) -> List[int]: Calculate the minimum number of cells that need to be recolored to achieve the alternating pattern. If it is impossible, return -1. Args: t (int): number of test cases. test_cases (List[Tuple[int, int, List[str]]]): List of tuples where each tuple contains dimensions of the grid and the grid itself. Returns: List[int]: List of integers representing the minimum number of cells to recolor or -1 if it's not possible. >>> min_recolor_operations(3, [(3, 3, [\\"GRG\\", \\"RGR\\", \\"GRG\\"]), (4, 4, [\\"GRGR\\", \\"RGRG\\", \\"GRGR\\", \\"RGRG\\"]), (2, 3, [\\"GGR\\", \\"RGG\\"])]) [0, 0, 3] >>> min_recolor_operations(1, [(2, 2, [\\"GR\\", \\"RG\\"])]) [0] pass def parse_input(input_str: str) -> Tuple[int, List[Tuple[int, int, List[str]]]]: Parse the input string to extract the number of test cases and test case data. Args: input_str (str): Input string containing number of test cases, grid dimensions, and grid data. Returns: Tuple[int, List[Tuple[int, int, List[str]]]]: A tuple containing the number of test cases and list of test case data. >>> parse_input(\\"3n3 3nGRGnRGRnGRGn4 4nGRGRnRGRGnGRGRnRGRGn2 3nGGRnRGGn\\") (3, [(3, 3, [\\"GRG\\", \\"RGR\\", \\"GRG\\"]), (4, 4, [\\"GRGR\\", \\"RGRG\\", \\"GRGR\\", \\"RGRG\\"]), (2, 3, [\\"GGR\\", \\"RGG\\"])]) pass def min_recolor_from_input(input_str: str) -> str: Get the minimum recolor operations result for each test case provided in the input string. Args: input_str (str): Input string containing test case data. Returns: str: Resulting string of minimum recolor operations for each test case. >>> min_recolor_from_input(\\"3n3 3nGRGnRGRnGRGn4 4nGRGRnRGRGnGRGRnRGRGn2 3nGGRnRGGn\\") \\"0n0n3\\" pass # Unit tests def test_example_1(): input_str = \\"3n3 3nGRGnRGRnGRGn4 4nGRGRnRGRGnGRGRnRGRGn2 3nGGRnRGGn\\" expected_output = \\"0n0n3\\" assert min_recolor_from_input(input_str) == expected_output def test_no_recolor_needed(): input_str = \\"1n2 2nGRnRGn\\" expected_output = \\"0\\" assert min_recolor_from_input(input_str) == expected_output def test_all_same_color(): input_str = \\"1n2 2nGGnGGn\\" expected_output = \\"2\\" assert min_recolor_from_input(input_str) == expected_output def test_all_different(): input_str = \\"1n2 2nGRnGRn\\" expected_output = \\"2\\" assert min_recolor_from_input(input_str) == expected_output def test_symmetric_grid(): input_str = \\"1n3 4nGRGRnRGRGnGRGRn\\" expected_output = \\"0\\" assert min_recolor_from_input(input_str) == expected_output","solution":"def min_recolor_operations(t, test_cases): favorite_patterns = [[0] * t for _ in range(2)] # Generate the two types of favorite patterns def generate_pattern(n, m): pattern1 = [['G' if (i + j) % 2 == 0 else 'R' for j in range(m)] for i in range(n)] pattern2 = [['R' if (i + j) % 2 == 0 else 'G' for j in range(m)] for i in range(n)] return pattern1, pattern2 results = [] for case in test_cases: n, m, grid = case pattern1, pattern2 = generate_pattern(n, m) recolor1 = 0 recolor2 = 0 for i in range(n): for j in range(m): if grid[i][j] != pattern1[i][j]: recolor1 += 1 if grid[i][j] != pattern2[i][j]: recolor2 += 1 results.append(min(recolor1, recolor2)) return results def parse_input(input_str): lines = input_str.strip().split('n') t = int(lines[0]) index = 1 test_cases = [] for _ in range(t): n, m = map(int, lines[index].split()) grid = [] for i in range(n): grid.append(lines[index + 1 + i]) test_cases.append((n, m, grid)) index += n + 1 return t, test_cases def min_recolor_from_input(input_str): t, test_cases = parse_input(input_str) results = min_recolor_operations(t, test_cases) return 'n'.join(map(str, results))"},{"question":"def smallest_missing_positive_integer(N: int, B: List[int]) -> int: Find the smallest positive integer that is not present in the array B. Parameters: N (int): The length of the array B. B (list of int): The array of integers. Returns: int: The smallest positive integer that is not present in the array. Examples: >>> smallest_missing_positive_integer(5, [3, 4, -1, 1, 2]) 5 >>> smallest_missing_positive_integer(4, [1, 2, 0, 3]) 4 >>> smallest_missing_positive_integer(6, [7, 8, 9, 11, 12, -3]) 1 >>> smallest_missing_positive_integer(4, [-1, -2, -3, -4]) 1 >>> smallest_missing_positive_integer(5, [1, 2, 3, 4, 5]) 6 >>> smallest_missing_positive_integer(6, [2, 3, 7, 21, 6, 1]) 4 >>> smallest_missing_positive_integer(3, [0, -1, -2]) 1 pass","solution":"def smallest_missing_positive_integer(N, B): Find the smallest positive integer that is not present in the array B. Parameters: N (int): The length of the array B. B (list of int): The array of integers. Returns: int: The smallest positive integer that is not present in the array. # Create a set from B to remove duplicates and allow O(1) look-up time B_set = set(B) # Start checking from the smallest positive integer, which is 1 smallest_positive = 1 # Increment smallest positive until we find one that's not in the set while smallest_positive in B_set: smallest_positive += 1 return smallest_positive"},{"question":"def can_split_tree(n, edges): Determine if it is possible to split the given binary tree into two disjoint binary trees. >>> can_split_tree(4, [(1, 2), (1, 3), (3, 4)]) \\"YES\\" >>> can_split_tree(3, [(1, 2), (1, 3)]) \\"NO\\" >>> can_split_tree(5, [(1, 2), (1, 3), (2, 4), (3, 5)]) \\"NO\\" >>> can_split_tree(1, []) \\"NO\\" >>> can_split_tree(6, [(1, 2), (1, 3), (2, 4), (2, 5), (3, 6)]) \\"YES\\" >>> can_split_tree(7, [(1, 2), (1, 3), (2, 4), (2, 5), (3, 6), (3, 7)]) \\"NO\\"","solution":"from collections import defaultdict, deque def can_split_tree(n, edges): if n == 1: return \\"NO\\" # Construct the graph graph = defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) # Check if the tree can be split into two parts with equal size def bfs(node, visited): queue = deque([node]) visited[node] = True size = 0 while queue: curr = queue.popleft() size += 1 for neighbor in graph[curr]: if not visited[neighbor]: visited[neighbor] = True queue.append(neighbor) return size visited = [False] * (n + 1) for node in range(1, n + 1): if not visited[node]: size = bfs(node, visited) if size % 2 == 0: return \\"YES\\" return \\"NO\\" # Example usage: # n = 4 # edges = [(1, 2), (1, 3), (3, 4)] # Output: YES"},{"question":"def rotated_array_min_in_queries(N: int, Q: int, A: List[int], queries: List[Tuple[int, int]]) -> List[int]: Given an array A of N integers that was originally sorted in increasing order but then rotated at a pivot, find the minimum element in specified ranges of queries. Parameters: N (int): Number of elements in the array, Q (int): Number of queries, A (list): Rotated array of N integers, queries (list): List of tuples where each tuple contains two integers (l, r) representing the query range. Returns: list: List of integers where each integer is the minimum element in the given query range. pass def test_rotated_array_min_in_queries(): N = 5 Q = 3 A = [4, 5, 1, 2, 3] queries = [(0, 2), (1, 3), (2, 4)] assert rotated_array_min_in_queries(N, Q, A, queries) == [1, 1, 1] def test_single_element_array(): N = 1 Q = 1 A = [1] queries = [(0, 0)] assert rotated_array_min_in_queries(N, Q, A, queries) == [1] def test_entire_array_range(): N = 6 Q = 1 A = [3, 4, 5, 1, 2] queries = [(0, 4)] assert rotated_array_min_in_queries(N, Q, A, queries) == [1] def test_multiple_queries(): N = 6 Q = 3 A = [3, 4, 5, 1, 2, 6] queries = [(0, 3), (2, 5), (1, 4)] assert rotated_array_min_in_queries(N, Q, A, queries) == [1, 1, 1] def test_identical_elements(): N = 5 Q = 2 A = [2, 2, 2, 2, 2] queries = [(0, 4), (1, 3)] assert rotated_array_min_in_queries(N, Q, A, queries) == [2, 2] def test_negative_numbers(): N = 5 Q = 2 A = [-4, -5, -1, -2, -3] queries = [(0, 2), (2, 4)] assert rotated_array_min_in_queries(N, Q, A, queries) == [-5, -3]","solution":"def rotated_array_min_in_queries(N, Q, A, queries): Given an array A of N integers that was originally sorted in increasing order but then rotated at a pivot, find the minimum element in specified ranges of queries. Parameters: N (int): Number of elements in the array, Q (int): Number of queries, A (list): Rotated array of N integers, queries (list): List of tuples where each tuple contains two integers (l, r) representing the query range. Returns: list: List of integers where each integer is the minimum element in the given query range. results = [] for l, r in queries: min_value = min(A[l:r+1]) results.append(min_value) return results # Example usage: N = 5 Q = 3 A = [4, 5, 1, 2, 3] queries = [(0, 2), (1, 3), (2, 4)] print(rotated_array_min_in_queries(N, Q, A, queries)) # Output should be [1, 1, 1]"},{"question":"import heapq from typing import List, Tuple def max_data_transfer(N: int, M: int, edges: List[Tuple[int, int, int]], s: int, t: int) -> int: Returns the maximum data transfer rate between servers s and t. >>> max_data_transfer(5, 6, [(1, 2, 10), (1, 3, 5), (2, 3, 7), (2, 4, 10), (3, 4, 5), (4, 5, 10)], 1, 5) 10 >>> max_data_transfer(3, 2, [(1, 2, 3), (2, 3, 2)], 1, 3) 2 >>> max_data_transfer(4, 4, [(1, 2, 10), (2, 3, 10), (3, 4, 10), (1, 4, 10)], 1, 4) 10 >>> max_data_transfer(4, 2, [(1, 2, 5), (3, 4, 5)], 1, 4) 0 >>> max_data_transfer(6, 7, [(1, 2, 4), (1, 3, 3), (2, 3, 6), (2, 4, 5), (3, 4, 9), (4, 5, 8), (5, 6, 7)], 1, 6) 4","solution":"import heapq def max_data_transfer(N, M, edges, s, t): Returns the maximum data transfer rate between servers s and t. # Initialize adjacency list graph = [[] for _ in range(N + 1)] for u, v, r in edges: graph[u].append((v, r)) graph[v].append((u, r)) # Priority queue for Max-Heap (using negative rates to simulate max-heap using min-heap) pq = [(-float('inf'), s)] # Store max rate to each node max_rate = [-1] * (N + 1) max_rate[s] = float('inf') while pq: rate, node = heapq.heappop(pq) rate = -rate if node == t: return rate for neighbor, r in graph[node]: # Calculate the min rate (bottleneck) along the path new_rate = min(rate, r) if new_rate > max_rate[neighbor]: max_rate[neighbor] = new_rate heapq.heappush(pq, (-new_rate, neighbor)) return 0 # Example usage N = 5 M = 6 edges = [ (1, 2, 10), (1, 3, 5), (2, 3, 7), (2, 4, 10), (3, 4, 5), (4, 5, 10) ] s = 1 t = 5 max_data_transfer(N, M, edges, s, t) # Output should be 10"},{"question":"def max_points(s: str) -> int: Calculate the maximum number of points that can be scored by removing contiguous subsequence of identical characters. :param s: A string consisting of lowercase Latin letters. :return: An integer representing the maximum number of points. >>> max_points(\\"abbccc\\") 5 >>> max_points(\\"abcddcba\\") 2 >>> max_points(\\"aa\\") 2 >>> max_points(\\"xyz\\") 0 >>> max_points(\\"aabbcc\\") 6 >>> max_points(\\"\\") 0 >>> max_points(\\"a\\") 0 >>> max_points(\\"aabbaa\\") 6 >>> max_points(\\"aaaaa\\") 5 >>> max_points(\\"zzzzzzzz\\") 8","solution":"def max_points(s): Calculate the maximum number of points that can be scored by removing contiguous subsequence of identical characters. :param s: A string consisting of lowercase Latin letters. :return: An integer representing the maximum number of points. points = 0 i = 0 while i < len(s): j = i while j < len(s) and s[i] == s[j]: j += 1 # Group of identical characters found from i to j-1 group_length = j - i if group_length >= 2: points += group_length i = j return points"},{"question":"def find_pair_with_sum(arr: List[int], X: int) -> bool: Determines if there exist two distinct elements in the array whose sum is equal to X. Parameters: arr (list): List of integers. X (int): The target sum. Returns: bool: True if such a pair exists, False otherwise. Examples: >>> find_pair_with_sum([2, 7, 11, 15, 1], 9) True >>> find_pair_with_sum([10, 12, 5, 8], 21) False","solution":"def find_pair_with_sum(arr, X): Determines if there exist two distinct elements in the array whose sum is equal to X. Parameters: arr (list): List of integers. X (int): The target sum. Returns: bool: True if such a pair exists, False otherwise. seen = set() for number in arr: if (X - number) in seen: return True seen.add(number) return False"},{"question":"def most_frequent_char_in_segment(s: str, l: int, r: int) -> str: Finds the most frequent character in the substring s[l-1:r] and returns the lexicographically smallest character among those with the highest frequency. >>> most_frequent_char_in_segment('aabacc', 2, 4) 'a' >>> most_frequent_char_in_segment('hello', 1, 5) 'l' >>> most_frequent_char_in_segment('abracadabra', 1, 10) 'a' >>> most_frequent_char_in_segment('mississippi', 1, 11) 'i' >>> most_frequent_char_in_segment('banana', 1, 6) 'a' >>> most_frequent_char_in_segment('abcde', 1, 1) 'a' >>> most_frequent_char_in_segment('abcde', 1, 5) 'a'","solution":"def most_frequent_char_in_segment(s, l, r): Finds the most frequent character in the substring s[l-1:r] and returns the lexicographically smallest character among those with the highest frequency. from collections import Counter # Convert 1-based indices to 0-based for Python indexing segment = s[l-1:r] counter = Counter(segment) # Find the highest frequency max_freq = max(counter.values()) # Extract characters with the highest frequency most_frequent_chars = [char for char in counter if counter[char] == max_freq] # Return the lexicographically smallest character return min(most_frequent_chars)"},{"question":"def process_scooter_operations(s: int, a: List[int], t: int, operations: List[str]) -> List[int]: Process the sequence of scooter rental operations and determine the final distribution of scooters at each station. Parameters: s (int): The number of stations. a (List[int]): The initial number of scooters at each station. t (int): The number of operations. operations (List[str]): A list of operations as strings. Returns: List[int]: The final number of scooters at each station. Example: >>> process_scooter_operations(3, [5, 10, 15], 5, [\\"pickup 1\\", \\"pickup 2\\", \\"return 0\\", \\"transit 2 1 3\\", \\"pickup 1\\"]) [6, 11, 11] pass","solution":"def process_scooter_operations(s, a, t, operations): for operation in operations: parts = operation.split() if parts[0] == \\"pickup\\": i = int(parts[1]) a[i] -= 1 elif parts[0] == \\"return\\": i = int(parts[1]) a[i] += 1 elif parts[0] == \\"transit\\": i = int(parts[1]) j = int(parts[2]) k = int(parts[3]) a[i] -= k a[j] += k return a"},{"question":"from typing import List def find_max_depth(n: int, managers: List[int]) -> int: Find the maximum depth of the company's hierarchy. Parameters: n (int): The number of employees. managers (List[int]): List of manager IDs for each employee, excluding the CEO. Returns: int: The maximum depth of the company's hierarchy. >>> find_max_depth(5, [1, 1, 2, 2]) 3 >>> find_max_depth(6, [1, 1, 2, 3, 4]) 4 >>> find_max_depth(1, []) 1 >>> find_max_depth(4, [1, 1, 1]) 2 >>> find_max_depth(5, [1, 2, 3, 4]) 5 >>> find_max_depth(7, [1, 1, 2, 2, 3, 3]) 3 >>> find_max_depth(8, [1, 1, 2, 2, 3, 4, 4]) 4","solution":"from collections import defaultdict, deque def find_max_depth(n, managers): if n == 1: return 1 tree = defaultdict(list) for i, manager in enumerate(managers, start=2): tree[manager].append(i) # BFS to find the maximum depth queue = deque([(1, 1)]) # (employee_id, depth) max_depth = 1 while queue: current, depth = queue.popleft() max_depth = max(max_depth, depth) for subordinate in tree[current]: queue.append((subordinate, depth + 1)) return max_depth"},{"question":"def best_shipping_provider(T: int, test_cases: List[dict]) -> List[str]: Determine the best shipping provider for multiple test cases. Args: T (int): Number of test cases. test_cases (List[dict]): A list of test cases, each containing: N (int): The number of shipping providers, providers (List[dict]): A list of providers, each with: Name (str): The name of the shipping provider, Base (float): The base shipping fee, Rate (float): The rate per kilogram, M (int): The number of books, weights (List[float]): List of weights of the books in kilograms. Returns: List[str]: A list of shipping provider names with the lowest cost for each test case. >>> test_cases = [ ... { ... 'N': 3, ... 'providers': [ ... {'Name': 'FastShip', 'Base': 5.00, 'Rate': 2.50}, ... {'Name': 'SafeShip', 'Base': 7.00, 'Rate': 2.00}, ... {'Name': 'QuickShip', 'Base': 3.00, 'Rate': 3.00} ... ], ... 'M': 4, ... 'weights': [1.5, 2.0, 3.0, 4.0] ... }, ... { ... 'N': 2, ... 'providers': [ ... {'Name': 'BudgetShip', 'Base': 2.00, 'Rate': 1.00}, ... {'Name': 'PrimeShip', 'Base': 10.00, 'Rate': 0.50} ... ], ... 'M': 3, ... 'weights': [3.0, 2.0, 1.0] ... } ... ] >>> best_shipping_provider(2, test_cases) ['SafeShip', 'BudgetShip']","solution":"def best_shipping_provider(T, test_cases): results = [] for index in range(T): N = test_cases[index]['N'] providers = test_cases[index]['providers'] M = test_cases[index]['M'] weights = test_cases[index]['weights'] total_weight = sum(weights) best_provider = None best_cost = float('inf') for provider in providers: name, base_fee, rate_per_kg = provider['Name'], provider['Base'], provider['Rate'] shipping_cost = base_fee + rate_per_kg * total_weight if shipping_cost < best_cost: best_cost = shipping_cost best_provider = name results.append(best_provider) return results"},{"question":"def max_even_sum(N: int, popularity_scores: List[int]) -> int: John is an enthusiastic animal photographer and he loves taking pictures of different animals. He has N albums, each dedicated to a particular animal species. Every album has a popularity score associated with it. At the end of the year, John plans to showcase his most popular animal albums. However, due to space constraints, John can only showcase a subset of his albums, and he wants to maximize the sum of the popularity scores of the showcased albums. There's a catch - John considers the showcased albums to be appealing only if they contain even popularity scores. This function calculates the maximum sum of even popularity scores from the given list. :param N: integer, number of albums :param popularity_scores: list of integers, representing the popularity scores of the albums :return: integer, the maximum sum of popularity scores that are even from solution import max_even_sum def test_max_even_sum_sample_case(): assert max_even_sum(5, [3, 8, 12, 5, 10]) == 30 def test_max_even_sum_all_odd(): assert max_even_sum(4, [1, 3, 5, 7]) == 0 def test_max_even_sum_all_even(): assert max_even_sum(4, [2, 4, 6, 8]) == 20 def test_max_even_sum_mixed_numbers(): assert max_even_sum(6, [1, 2, 3, 4, 5, 6]) == 12 def test_max_even_sum_large_input(): N = 10**5 popularity_scores = [i for i in range(1, N+1)] expected_sum = sum(i for i in range(1, N+1) if i % 2 == 0) assert max_even_sum(N, popularity_scores) == expected_sum def test_max_even_sum_single_even(): assert max_even_sum(1, [2]) == 2 def test_max_even_sum_single_odd(): assert max_even_sum(1, [1]) == 0 def test_max_even_sum_mixed_large_even(): assert max_even_sum(5, [10**9, 999999999, 123456789, 10**6, 10**7]) == 10**9 + 10**6 + 10**7","solution":"def max_even_sum(N, popularity_scores): This function calculates the maximum sum of even popularity scores from the given list. :param N: integer, number of albums :param popularity_scores: list of integers, representing the popularity scores of the albums :return: integer, the maximum sum of popularity scores that are even even_scores = [score for score in popularity_scores if score % 2 == 0] return sum(even_scores)"},{"question":"def has_pythagorean_triplet(lst): Determines if there exists any three integers in the list that form a Pythagorean triplet. Args: lst (List[int]): List of integers. Returns: bool: True if there exists a Pythagorean triplet, False otherwise. Examples: >>> has_pythagorean_triplet([3, 1, 4, 6, 5]) True >>> has_pythagorean_triplet([10, 4, 6, 12, 5]) False >>> has_pythagorean_triplet([1, 2, 3, 4, 5, 6, 7, 8, 9]) True","solution":"def has_pythagorean_triplet(lst): Determines if there exists any three integers in the list that form a Pythagorean triplet. n = len(lst) # Create a list of squares squares = [x * x for x in lst] # Sort the list of integers lst.sort() # Fix one element and use the two-pointer technique to find the other two elements for i in range(n-1, 1, -1): c2 = lst[i] * lst[i] left = 0 right = i - 1 while left < right: a2b2 = lst[left] * lst[left] + lst[right] * lst[right] if a2b2 == c2: return True elif a2b2 < c2: left += 1 else: right -= 1 return False"},{"question":"from typing import List def findWords(grid: List[List[str]], words: List[str]) -> List[bool]: You are given a grid of characters with dimensions m x n and a list of words. Your task is to write a function that checks whether each word in the list exists in the grid. A word is considered to exist if it can be found in the grid by connecting letters horizontally or vertically, but not diagonally. The same letter cell may not be used more than once in constructing a word. >>> grid = [ ... ['o', 'a', 'a', 'n'], ... ['e', 't', 'a', 'e'], ... ['i', 'h', 'k', 'r'], ... ['i', 'f', 'l', 'v'] ... ] >>> words = [\\"oath\\", \\"pea\\", \\"eat\\", \\"rain\\"] >>> findWords(grid, words) [True, False, True, False] def test_findWords_single_word_success(): grid = [ ['o', 'a', 'a', 'n'], ['e', 't', 'a', 'e'], ['i', 'h', 'k', 'r'], ['i', 'f', 'l', 'v'] ] words = [\\"oath\\"] assert findWords(grid, words) == [True] def test_findWords_single_word_failure(): grid = [ ['o', 'a', 'a', 'n'], ['e', 't', 'a', 'e'], ['i', 'h', 'k', 'r'], ['i', 'f', 'l', 'v'] ] words = [\\"pea\\"] assert findWords(grid, words) == [False] def test_findWords_multiple_words(): grid = [ ['o', 'a', 'a', 'n'], ['e', 't', 'a', 'e'], ['i', 'h', 'k', 'r'], ['i', 'f', 'l', 'v'] ] words = [\\"oath\\", \\"pea\\", \\"eat\\", \\"rain\\"] assert findWords(grid, words) == [True, False, True, False] def test_findWords_word_longer_than_grid(): grid = [ ['a', 'b'], ['c', 'd'] ] words = [\\"abc\\", \\"abcd\\"] assert findWords(grid, words) == [False, False] def test_findWords_revisit_same_cell(): grid = [ ['a', 'b', 'c'], ['d', 'e', 'f'], ['g', 'h', 'i'] ] words = [\\"aba\\"] assert findWords(grid, words) == [False]","solution":"from typing import List def findWords(grid: List[List[str]], words: List[str]) -> List[bool]: def dfs(board, word, i, j, k): if k == len(word): return True if not (0 <= i < len(board) and 0 <= j < len(board[0])) or board[i][j] != word[k]: return False # mark the cell as visited temp, board[i][j] = board[i][j], '#' found = dfs(board, word, i+1, j, k+1) or dfs(board, word, i-1, j, k+1) or dfs(board, word, i, j+1, k+1) or dfs(board, word, i, j-1, k+1) # unmark the cell board[i][j] = temp return found results = [] for word in words: found_word = False for i in range(len(grid)): for j in range(len(grid[0])): if dfs(grid, word, i, j, 0): found_word = True break if found_word: break results.append(found_word) return results"},{"question":"def highest_elevation(grid, x, y): Determine the highest elevation that can be reached from the starting position in the grid. :param grid: List[List[int]], the grid representing the landscape. :param x: int, initial x-coordinate. :param y: int, initial y-coordinate. :return: int, the highest elevation that can be reached. Examples: >>> highest_elevation([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 0, 0) 9 >>> highest_elevation([[-3, -2, -1], [1, 2, 3], [4, 5, 6], [7, 8, 9]], 2, 2) 9 pass","solution":"def highest_elevation(grid, x, y): Determine the highest elevation that can be reached from the starting position (x, y). :param grid: List[List[int]], the grid representing the landscape :param x: int, initial x-coordinate :param y: int, initial y-coordinate :return: int, the highest elevation that can be reached n = len(grid) m = len(grid[0]) visited = [[False] * m for _ in range(n)] directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] def dfs(i, j): stack = [(i, j)] max_elevation = grid[i][j] while stack: cur_x, cur_y = stack.pop() if visited[cur_x][cur_y]: continue visited[cur_x][cur_y] = True max_elevation = max(max_elevation, grid[cur_x][cur_y]) for dx, dy in directions: new_x, new_y = cur_x + dx, cur_y + dy if 0 <= new_x < n and 0 <= new_y < m and not visited[new_x][new_y]: stack.append((new_x, new_y)) return max_elevation return dfs(x, y)"},{"question":"def find_longest_balanced_segment(N: int, traffic_data: List[int]) -> int: In a city planning department, there is a need to analyze the traffic on various roads of the city to determine if the traffic flow is balanced. The department has continuously monitored the number of vehicles entering and leaving specific sections of the city every second. The data of vehicles counted each second are recorded in a table. The goal is to identify the longest contiguous segment of time during which the net flow of traffic (vehicles entering minus vehicles leaving) is zero, indicating a balanced traffic flow. Input The input is provided in the following format. N v1 v2 :: vN The first row shows the number N (1 ≤ N ≤ 200000) of the values recorded in the table. The next N rows provide the integer vi (-10^9 ≤ vi ≤ 10^9), representing the net number of vehicles entering (positive) or leaving (negative) the monitored section in each second. Output The output should be a single line indicating the length of the longest contiguous time segment where the net traffic flow is zero. If no such segment exists, output \\"0\\" on a single line. Examples >>> find_longest_balanced_segment(6, [3, -3, 4, -4, 2, -2]) 6 >>> find_longest_balanced_segment(5, [5, -5, 6, -6, 1]) 4 >>> find_longest_balanced_segment(3, [1, 2, -3]) 3","solution":"def find_longest_balanced_segment(N, traffic_data): prefix_sum_to_index = {} prefix_sum = 0 longest_length = 0 for i in range(N): prefix_sum += traffic_data[i] if prefix_sum == 0: longest_length = i + 1 elif prefix_sum in prefix_sum_to_index: longest_length = max(longest_length, i - prefix_sum_to_index[prefix_sum]) else: prefix_sum_to_index[prefix_sum] = i return longest_length"},{"question":"def longest_common_prefix(paths): Given a list of file paths, return the longest common prefix. >>> longest_common_prefix([\\"/home/user/docs/file.txt\\", \\"/home/user/docs/tmp/test.txt\\", \\"/home/user/photos/image.jpg\\"]) == \\"/home/user\\" >>> longest_common_prefix([\\"/home/user/docs/file.txt\\", \\"/var/log/syslog\\", \\"/etc/hosts\\"]) == \\"/\\"","solution":"def longest_common_prefix(paths): Given a list of file paths, return the longest common prefix. if not paths: return \\"/\\" # Split paths into components path_components = [path.split('/') for path in paths] # Find the common prefix common_prefix = [] for components in zip(*path_components): if all(component == components[0] for component in components): common_prefix.append(components[0]) else: break # Join the common prefix components to form the path result = \\"/\\" + \\"/\\".join([comp for comp in common_prefix if comp]) return result if result != \\"\\" else \\"/\\""},{"question":"def check_reading_badge(n: int, s: int, r: int, pages: List[int]) -> str: Determines if Alex gets a reading badge by reading at least r pages in any contiguous segment of s hours in a day. Args: n (int): Number of hours in the day. s (int): Number of hours in the contiguous segment. r (int): Minimum number of pages to be read in the segment. pages (list of int): List of pages read each hour. Returns: str: \\"YES\\" if Alex gets the badge, otherwise \\"NO\\". Examples: >>> check_reading_badge(6, 3, 50, [10, 20, 20, 10, 10, 10]) \\"YES\\" >>> check_reading_badge(5, 2, 30, [10, 10, 15, 5, 10]) \\"NO\\" pass","solution":"def check_reading_badge(n, s, r, pages): Determines if Alex gets a reading badge by reading at least r pages in any contiguous segment of s hours in a day. Args: n (int): Number of hours in the day. s (int): Number of hours in the contiguous segment. r (int): Minimum number of pages to be read in the segment. pages (list of int): List of pages read each hour. Returns: str: \\"YES\\" if Alex gets the badge, otherwise \\"NO\\". current_sum = sum(pages[:s]) if current_sum >= r: return \\"YES\\" for i in range(s, n): current_sum += pages[i] - pages[i - s] if current_sum >= r: return \\"YES\\" return \\"NO\\""},{"question":"from typing import List, Tuple def find_order(n: int, m: int, prerequisites: List[Tuple[int, int]]) -> List[int]: Determine a possible order in which the projects can be completed by assigning employees to projects such that all prerequisite constraints are satisfied. If the projects can be completed in such an order, return any valid order; otherwise, return an empty array. >>> find_order(3, 3, [(1, 2), (2, 3), (3, 1)]) [] >>> find_order(4, 4, [(1, 2), (2, 3), (3, 4), (1, 3)]) [1, 2, 3, 4] >>> find_order(3, 3, []) [1, 2, 3] >>> find_order(1, 1, []) [1] >>> find_order(3, 3, [(1, 2), (1, 3)]) [[1, 2, 3], [1, 3, 2]] pass def test_find_order(): assert find_order(3, 3, [(1, 2), (2, 3), (3, 1)]) == [] assert find_order(4, 4, [(1, 2), (2, 3), (3, 4), (1, 3)]) == [1, 2, 3, 4] or find_order(4, 4, [(1, 2), (2, 3), (3, 4), (1, 3)]) == [1, 3, 2, 4] assert sorted(find_order(3, 3, [])) == [1, 2, 3] assert find_order(1, 1, []) == [1] assert find_order(3, 3, [(1, 2), (1, 3)]) in [[1, 2, 3], [1, 3, 2]]","solution":"from collections import defaultdict, deque def find_order(n, m, prerequisites): graph = defaultdict(list) in_degree = [0] * (m + 1) for u, v in prerequisites: graph[u].append(v) in_degree[v] += 1 queue = deque([i for i in range(1, m + 1) if in_degree[i] == 0]) order = [] while queue: node = queue.popleft() order.append(node) for neighbor in graph[node]: in_degree[neighbor] -= 1 if in_degree[neighbor] == 0: queue.append(neighbor) if len(order) == m: return order else: return [] # You can call this function with the required parameters to see the result."},{"question":"from typing import List, Tuple def min_delivery_time(M: int, N: int, K: int, start_x: int, start_y: int, destinations: List[Tuple[int, int]]) -> int: Calculate the minimum amount of time in minutes needed for the drone to deliver all the packages and return back to the starting position. >>> min_delivery_time(4, 5, 3, 0, 0, [(1, 2), (3, 1), (2, 4)]) 14 >>> min_delivery_time(3, 3, 1, 0, 0, [(2, 2)]) 8","solution":"from itertools import permutations def min_delivery_time(M, N, K, start_x, start_y, destinations): def distance(p1, p2): return abs(p1[0] - p2[0]) + abs(p1[1] - p2[1]) min_time = float('inf') for perm in permutations(destinations): time = 0 current_pos = (start_x, start_y) for dest in perm: time += distance(current_pos, dest) current_pos = dest time += distance(current_pos, (start_x, start_y)) if time < min_time: min_time = time return min_time"},{"question":"def decode_difference_array(n: int, D: List[int]) -> List[int]: Decodes the difference array D to the original array A. >>> decode_difference_array(5, [3, -2, 4, -1, 2]) [3, 1, 5, 4, 6] >>> decode_difference_array(3, [1, 1, 1]) [1, 2, 3]","solution":"def decode_difference_array(n, D): Decodes the difference array D to the original array A. Args: n (int): Length of the array D (list of int): Difference array Returns: list of int: Original array A = [0] * n A[0] = D[0] for i in range(1, n): A[i] = A[i - 1] + D[i] return A # Example usage: # n = 5 # D = [3, -2, 4, -1, 2] # print(decode_difference_array(n, D)) # Output: [3, 1, 5, 4, 6]"},{"question":"from collections import Counter import heapq from typing import Tuple def transform_string(n: int, s: str) -> str: Transform the string s into a new string where no character is the immediate neighbor of itself. If it's not possible, return \\"IMPOSSIBLE\\". >>> transform_string(4, \\"aabb\\") 'abab' >>> transform_string(3, \\"aaa\\") 'IMPOSSIBLE' pass","solution":"from collections import Counter import heapq def transform_string(n, s): Transform the string s into a new string where no character is the immediate neighbor of itself. If it's not possible, return \\"IMPOSSIBLE\\". # Count frequency of each character freq = Counter(s) max_heap = [] # Build a max heap based on character frequency for char, count in freq.items(): heapq.heappush(max_heap, (-count, char)) prev_char = None prev_count = 0 result = [] while max_heap: count, char = heapq.heappop(max_heap) result.append(char) if prev_char is not None: heapq.heappush(max_heap, (prev_count, prev_char)) prev_char = char prev_count = count + 1 # decrease count (note it's stored as negative) if len(result) == n: return ''.join(result) return \\"IMPOSSIBLE\\" # Example usage: print(transform_string(4, \\"aabb\\")) # Output: \\"abab\\" print(transform_string(3, \\"aaa\\")) # Output: \\"IMPOSSIBLE\\""},{"question":"def calculate_h_index(n: int, citations: List[int]) -> int: Calculate the h-index of a researcher given the number of citations for each of their papers. Parameters: n (int): Number of papers. citations (list): List of citations for each paper. Returns: int: The h-index. >>> calculate_h_index(6, [10, 8, 5, 4, 3, 2]) 4 >>> calculate_h_index(5, [25, 8, 5, 3, 3]) 3 >>> calculate_h_index(3, [1, 1, 1]) 1 >>> calculate_h_index(4, [0, 0, 0, 0]) 0 >>> calculate_h_index(1, [10]) 1 >>> calculate_h_index(4, [3, 0, 6, 1, 5]) 3 >>> calculate_h_index(1000, [i for i in range(1000, 0, -1)]) 500","solution":"def calculate_h_index(n, citations): Calculate the h-index of a researcher given the number of citations for each of their papers. Parameters: n (int): Number of papers. citations (list): List of citations for each paper. Returns: int: The h-index. citations.sort(reverse=True) h_index = 0 for i in range(n): if citations[i] >= i + 1: h_index = i + 1 else: break return h_index"},{"question":"def smallest_ratio(n: int, k: int, arr: List[int]) -> float: Given a sequence of integers, find a subsequence such that the ratio between the maximum and the minimum element in this subsequence is as small as possible, and the length of this subsequence is at least k. Args: n (int): The size of the array. k (int): Minimum length of the subsequence. arr (List[int]): The list of integers. Returns: float: The smallest possible ratio between the maximum and minimum element in the found subsequence. Examples: >>> smallest_ratio(5, 2, [1, 2, 3, 5, 8]) 1.5 >>> smallest_ratio(3, 2, [1000000000, 500000000, 1]) 2.0","solution":"def smallest_ratio(n, k, arr): arr.sort() min_ratio = float('inf') for i in range(n - k + 1): for j in range(i + k - 1, n): min_element = arr[i] max_element = arr[j] ratio = max_element / min_element if ratio < min_ratio: min_ratio = ratio return min_ratio"},{"question":"from datetime import datetime, timedelta import json from collections import defaultdict def most_operations_in_one_hour_window(n, log_entries): Analyze log entries to identify the user with the highest number of operations within any one-hour window. Args: n (int): The number of log entries. log_entries (List[str]): A list of JSON objects representing log entries. Returns: str: The username of the user with the highest number of operations within any one-hour window and the number of operations. Example: >>> n = 4 >>> log_entries = [ >>> '{\\"timestamp\\": \\"2023-10-01 12:00:00\\", \\"username\\": \\"alice\\", \\"operation\\": \\"login\\"}', >>> '{\\"timestamp\\": \\"2023-10-01 12:30:00\\", \\"username\\": \\"alice\\", \\"operation\\": \\"create_user\\"}', >>> '{\\"timestamp\\": \\"2023-10-01 13:00:00\\", \\"username\\": \\"alice\\", \\"operation\\": \\"delete_file\\"}', >>> '{\\"timestamp\\": \\"2023-10-01 12:15:00\\", \\"username\\": \\"bob\\", \\"operation\\": \\"login\\"}' >>> ] >>> most_operations_in_one_hour_window(n, log_entries) 'alice 3' pass def test_single_entry(): n = 1 log_entries = [ '{\\"timestamp\\": \\"2023-10-01 12:00:00\\", \\"username\\": \\"alice\\", \\"operation\\": \\"login\\"}' ] assert most_operations_in_one_hour_window(n, log_entries) == \\"alice 1\\" def test_example_case(): n = 4 log_entries = [ '{\\"timestamp\\": \\"2023-10-01 12:00:00\\", \\"username\\": \\"alice\\", \\"operation\\": \\"login\\"}', '{\\"timestamp\\": \\"2023-10-01 12:30:00\\", \\"username\\": \\"alice\\", \\"operation\\": \\"create_user\\"}', '{\\"timestamp\\": \\"2023-10-01 13:00:00\\", \\"username\\": \\"alice\\", \\"operation\\": \\"delete_file\\"}', '{\\"timestamp\\": \\"2023-10-01 12:15:00\\", \\"username\\": \\"bob\\", \\"operation\\": \\"login\\"}' ] assert most_operations_in_one_hour_window(n, log_entries) == \\"alice 3\\" def test_multiple_users(): n = 6 log_entries = [ '{\\"timestamp\\": \\"2023-10-01 11:00:00\\", \\"username\\": \\"alice\\", \\"operation\\": \\"login\\"}', '{\\"timestamp\\": \\"2023-10-01 11:10:00\\", \\"username\\": \\"bob\\", \\"operation\\": \\"create_user\\"}', '{\\"timestamp\\": \\"2023-10-01 11:50:00\\", \\"username\\": \\"alice\\", \\"operation\\": \\"delete_file\\"}', '{\\"timestamp\\": \\"2023-10-01 12:00:00\\", \\"username\\": \\"charlie\\", \\"operation\\": \\"login\\"}', '{\\"timestamp\\": \\"2023-10-01 12:01:00\\", \\"username\\": \\"charlie\\", \\"operation\\": \\"create_user\\"}', '{\\"timestamp\\": \\"2023-10-01 12:10:00\\", \\"username\\": \\"charlie\\", \\"operation\\": \\"delete_file\\"}' ] assert most_operations_in_one_hour_window(n, log_entries) == \\"charlie 3\\" def test_no_overlap(): n = 3 log_entries = [ '{\\"timestamp\\": \\"2023-10-01 10:00:00\\", \\"username\\": \\"alice\\", \\"operation\\": \\"login\\"}', '{\\"timestamp\\": \\"2023-10-01 12:00:00\\", \\"username\\": \\"bob\\", \\"operation\\": \\"create_user\\"}', '{\\"timestamp\\": \\"2023-10-01 14:00:00\\", \\"username\\": \\"charlie\\", \\"operation\\": \\"delete_file\\"}' ] assert most_operations_in_one_hour_window(n, log_entries) == \\"alice 1\\" def test_unordered_entries(): n = 4 log_entries = [ '{\\"timestamp\\": \\"2023-10-01 12:15:00\\", \\"username\\": \\"bob\\", \\"operation\\": \\"login\\"}', '{\\"timestamp\\": \\"2023-10-01 12:30:00\\", \\"username\\": \\"alice\\", \\"operation\\": \\"create_user\\"}', '{\\"timestamp\\": \\"2023-10-01 13:00:00\\", \\"username\\": \\"alice\\", \\"operation\\": \\"delete_file\\"}', '{\\"timestamp\\": \\"2023-10-01 12:00:00\\", \\"username\\": \\"alice\\", \\"operation\\": \\"login\\"}' ] assert most_operations_in_one_hour_window(n, log_entries) == \\"alice 3\\"","solution":"from datetime import datetime, timedelta import json from collections import defaultdict def most_operations_in_one_hour_window(n, log_entries): logs = [] for entry in log_entries: logs.append(json.loads(entry)) logs.sort(key=lambda x: x[\\"timestamp\\"]) def parse_time(timestamp): return datetime.strptime(timestamp, \\"%Y-%m-%d %H:%M:%S\\") max_operations = 0 max_user = \\"\\" for i in range(n): current_time = parse_time(logs[i][\\"timestamp\\"]) user_operations = defaultdict(int) for j in range(n): log_time = parse_time(logs[j][\\"timestamp\\"]) if current_time - timedelta(hours=0.5) <= log_time <= current_time + timedelta(hours=0.5): user_operations[logs[j][\\"username\\"]] += 1 for user, count in user_operations.items(): if count > max_operations: max_operations = count max_user = user return f\\"{max_user} {max_operations}\\" # Example usage: # n = 4 # log_entries = [ # '{\\"timestamp\\": \\"2023-10-01 12:00:00\\", \\"username\\": \\"alice\\", \\"operation\\": \\"login\\"}', # '{\\"timestamp\\": \\"2023-10-01 12:30:00\\", \\"username\\": \\"alice\\", \\"operation\\": \\"create_user\\"}', # '{\\"timestamp\\": \\"2023-10-01 13:00:00\\", \\"username\\": \\"alice\\", \\"operation\\": \\"delete_file\\"}', # '{\\"timestamp\\": \\"2023-10-01 12:15:00\\", \\"username\\": \\"bob\\", \\"operation\\": \\"login\\"}' # ] # print(most_operations_in_one_hour_window(n, log_entries))"},{"question":"def max_profit(prices: List[int]) -> int: Returns the maximum profit that can be achieved from buying and selling one stock. If no profit is possible, returns 0. >>> max_profit([7, 1, 5, 3, 6, 4]) 5 >>> max_profit([7, 6, 4, 3, 1]) 0","solution":"def max_profit(prices): Returns the maximum profit that can be achieved from buying and selling one stock. If no profit is possible, returns 0. if not prices: return 0 min_price = float('inf') max_profit = 0 for price in prices: min_price = min(min_price, price) max_profit = max(max_profit, price - min_price) return max_profit"},{"question":"def smallest_length_after_operations(T: int, cases: List[str]) -> List[int]: Determines the smallest possible length of the string after performing any number of operations. Parameters: T (int): The number of test cases. cases (list of str): A list of strings consisting of digits from 0 to 9. Returns: list of int: The smallest possible length of each string for the given test cases. pass # Unit tests from solution import smallest_length_after_operations def test_single_digit_string(): assert smallest_length_after_operations(1, [\\"5\\"]) == [1] def test_string_of_similar_digits(): assert smallest_length_after_operations(1, [\\"5555\\"]) == [1] def test_mixed_digits_string(): assert smallest_length_after_operations(1, [\\"9081726354\\"]) == [1] def test_multiple_cases(): assert smallest_length_after_operations(3, [\\"123\\", \\"5555\\", \\"9081726354\\"]) == [1, 1, 1] def test_maximum_length_string(): digits = \\"9\\" * (10**5) assert smallest_length_after_operations(1, [digits]) == [1]","solution":"def smallest_length_after_operations(T, cases): Determines the smallest possible length of the string after performing any number of operations. Parameters: T (int): The number of test cases. cases (list of str): A list of strings consisting of digits from 0 to 9. Returns: list of int: The smallest possible length of each string for the given test cases. # As the smallest possible length of any string after any number of operations is always 1, # we can return that directly for each case. results = [1] * T return results"},{"question":"def most_frequent_char(T: int, test_cases: List[str]) -> List[str]: Returns the most frequent character in each string from a list of test cases. Parameters: T (int): The number of test cases. test_cases (list of str): The list of strings to analyze. Returns: list of str: The list of most frequent characters in each input string. >>> most_frequent_char(3, [\\"apple\\", \\"banana\\", \\"cabbage\\"]) ['p', 'a', 'a'] >>> most_frequent_char(1, [\\"a\\"]) ['a'] >>> most_frequent_char(1, [\\"abb\\"]) ['b'] >>> most_frequent_char(1, [\\"a\\" * 1000]) ['a'] >>> most_frequent_char(2, [\\"abcabc\\", \\"zzzyyy\\"]) ['a', 'y'] >>> most_frequent_char(1, [\\"test\\"]) ['t'] >>> most_frequent_char(1, [\\"aabbcc\\"]) ['a']","solution":"def most_frequent_char(T, test_cases): Returns the most frequent character in each string from a list of test cases. Parameters: T (int): The number of test cases. test_cases (list of str): The list of strings to analyze. Returns: list of str: The list of most frequent characters in each input string. results = [] for S in test_cases: char_count = {} for char in S: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 # Find the character(s) with the maximum frequency max_freq = max(char_count.values()) most_frequent_chars = [char for char, freq in char_count.items() if freq == max_freq] # Get the lexicographically smallest character among those with the maximum frequency most_frequent_chars.sort() results.append(most_frequent_chars[0]) return results"},{"question":"def ladderLength(beginWord: str, endWord: str, wordList: List[str]) -> int: Determine the shortest transformation sequence from \`beginWord\` to \`endWord\`, such that only one letter can be changed at a time and each transformed word must exist in the \`wordList\`. Args: - beginWord: a string representing the initial word. - endWord: a string representing the desired transformation word. - wordList: a list of words that can be used in the transformation. Returns: The length of the shortest transformation sequence from \`beginWord\` to \`endWord\` if one exists, otherwise 0. >>> ladderLength(\\"hit\\", \\"cog\\", [\\"hot\\", \\"dot\\", \\"dog\\", \\"lot\\", \\"log\\", \\"cog\\"]) 5 >>> ladderLength(\\"hit\\", \\"cog\\", [\\"hot\\", \\"dot\\", \\"dog\\", \\"lot\\", \\"log\\"]) 0 >>> ladderLength(\\"hit\\", \\"hot\\", [\\"hot\\", \\"dot\\", \\"dog\\", \\"lot\\", \\"log\\", \\"cog\\"]) 2 >>> ladderLength(\\"hit\\", \\"cog\\", []) 0 >>> ladderLength(\\"hit\\", \\"cog\\", [\\"hot\\", \\"dot\\", \\"dog\\", \\"lot\\", \\"log\\"]) 0 >>> ladderLength(\\"hit\\", \\"hut\\", [\\"hut\\"]) 2 >>> ladderLength(\\"hit\\", \\"cog\\", [\\"hot\\", \\"cot\\", \\"cog\\", \\"mit\\", \\"mog\\"]) 4","solution":"from collections import deque def ladderLength(beginWord, endWord, wordList): Returns the length of the shortest transformation sequence from beginWord to endWord, or 0 if no such sequence exists. if endWord not in wordList: return 0 wordSet = set(wordList) queue = deque([(beginWord, 1)]) # (current_word, current_sequence_length) while queue: current_word, length = queue.popleft() # Try changing every letter in the current word to every possible letter from a-z for i in range(len(current_word)): for c in 'abcdefghijklmnopqrstuvwxyz': new_word = current_word[:i] + c + current_word[i+1:] # If new_word is the endWord, return length + 1 (for the last transformation) if new_word == endWord: return length + 1 # If new_word in wordSet, it's a valid transformation if new_word in wordSet: queue.append((new_word, length + 1)) wordSet.remove(new_word) # Remove to prevent re-visiting return 0 # If queue is exhausted and no transformation found"},{"question":"def max_non_overlapping_intervals(n, intervals): Returns the maximum number of non-overlapping intervals from a list of intervals. Args: n (int): Number of intervals intervals (List[Tuple[int, int]]): List of tuples where each tuple (s, e) represents the start and end time of an interval. Returns: int: Maximum number of non-overlapping intervals.","solution":"def max_non_overlapping_intervals(n, intervals): Returns the maximum number of non-overlapping intervals from a list of intervals. Args: n (int): Number of intervals intervals (List[Tuple[int, int]]): List of tuples where each tuple (s, e) represents the start and end time of an interval. Returns: int: Maximum number of non-overlapping intervals. # Sort intervals by their end time intervals.sort(key=lambda x: x[1]) count = 0 end_time = 0 for start, end in intervals: if start >= end_time: count += 1 end_time = end return count"},{"question":"def generate_spiral_matrix(n: int) -> List[List[int]]: Generates an N x N matrix filled in a spiral order starting from 1. >>> generate_spiral_matrix(3) [[1, 2, 3], [8, 9, 4], [7, 6, 5]] >>> generate_spiral_matrix(4) [[1, 2, 3, 4], [12, 13, 14, 5], [11, 16, 15, 6], [10, 9, 8, 7]] >>> generate_spiral_matrix(1) [[1]]","solution":"def generate_spiral_matrix(n): Generates an N x N matrix filled in a spiral order starting from 1. matrix = [[0] * n for _ in range(n)] left, right, top, bottom = 0, n - 1, 0, n - 1 num = 1 while left <= right and top <= bottom: # Move right for i in range(left, right + 1): matrix[top][i] = num num += 1 top += 1 # Move down for i in range(top, bottom + 1): matrix[i][right] = num num += 1 right -= 1 if top <= bottom: # Move left for i in range(right, left - 1, -1): matrix[bottom][i] = num num += 1 bottom -= 1 if left <= right: # Move up for i in range(bottom, top - 1, -1): matrix[i][left] = num num += 1 left += 1 return matrix"},{"question":"from typing import List def maxDifference(nums: List[int]) -> int: Given an array of integers nums, find the maximum possible difference between any two elements in the list such that the larger element comes after the smaller one. Args: nums (List[int]): A list of integers. Returns: int: The maximum difference, or -1 if no such pair exists. Examples: >>> maxDifference([7, 1, 5, 4]) 4 >>> maxDifference([9, 8, 7, 6]) -1 >>> maxDifference([1, 2, 3, 4, 5]) 4 >>> maxDifference([4, 3, 2, 5, 1, 6]) 5 >>> maxDifference([-1, -3, -4, -2, -5]) 2 >>> maxDifference([5]) -1 >>> maxDifference([1, 3]) 2 >>> maxDifference([3, 1]) -1 >>> maxDifference([2, 2, 2, 2]) -1","solution":"from typing import List def maxDifference(nums: List[int]) -> int: if len(nums) < 2: return -1 max_diff = -1 min_element = nums[0] for i in range(1, len(nums)): if nums[i] > min_element: max_diff = max(max_diff, nums[i] - min_element) min_element = min(min_element, nums[i]) return max_diff"},{"question":"from typing import List def two_sum(nums: List[int], target: int) -> List[int]: Given an array of integers and a target number, determine if there are two distinct indices i and j in the array such that they sum up to the target number. The indices i and j should be returned in a list [i, j]. >>> two_sum([2, 7, 11, 15], 9) [0, 1] >>> two_sum([3, 2, 4], 6) [1, 2] >>> two_sum([3, 3], 6) [0, 1] >>> two_sum([1, 2, 3, 4, 5], 9) [3, 4] >>> two_sum([10, 20, 30, 40], 50) [1, 2]","solution":"from typing import List def two_sum(nums: List[int], target: int) -> List[int]: Returns the indices of the two numbers that add up to the target number. Args: nums (List[int]): A list of integers. target (int): The target sum. Returns: List[int]: Indices of the two numbers in the list that add up to the target number. num_to_index = {} for i, num in enumerate(nums): complement = target - num if complement in num_to_index: return [num_to_index[complement], i] num_to_index[num] = i return []"},{"question":"def find_min_absolute_difference(m: int, b: List[int]) -> int: Returns the minimum absolute difference between any two elements in the array b. Args: m (int): The number of elements in the array b. b (List[int]): The list of integers. Returns: int: The minimum value of the absolute difference between two elements in the array b. Examples: >>> find_min_absolute_difference(5, [3, 8, 15, 1, 6]) 2 >>> find_min_absolute_difference(4, [12, 11, 17, 18]) 1","solution":"def find_min_absolute_difference(m, b): Returns the minimum absolute difference between any two elements in the array b. b.sort() # Sort the array to bring closer elements next to each other. min_diff = float('inf') # Compute the minimum absolute difference between consecutive elements. for i in range(1, m): min_diff = min(min_diff, abs(b[i] - b[i - 1])) return min_diff"},{"question":"def min_lights_required(n: int, k: int, heights: List[int]) -> int: Returns the minimum number of lights required to ensure that every house has light coverage. >>> min_lights_required(6, 1, [2, 3, 4, 1, 5, 6]) 3 >>> min_lights_required(4, 2, [1, 2, 3, 4]) 2 >>> min_lights_required(1, 1, [1]) 1 >>> min_lights_required(4, 3, [1, 1, 1, 1]) 1 >>> min_lights_required(10, 9, [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]) 1 >>> min_lights_required(5, 1, [1, 2, 2, 2, 2]) 3 >>> min_lights_required(6, 2, [2, 3, 4, 1, 5, 6]) 2","solution":"def min_lights_required(n, k, heights): Returns the minimum number of lights required to ensure that every house has light coverage. lights = 0 i = 0 while i < n: # Place the light at the farthest house to the right that can cover current house. j = i while j < n and j < i + k + 1: if j + k < n and j + k - 1 < i: j += 1 else: break # Place the light at house \`j\` lights += 1 # Move to the next house that is not covered by this light i = j + k + 1 return lights"},{"question":"def can_partition_into_k_subarrays(n, k, arr): Determine if it's possible to divide the array into k non-empty subarrays such that the sum of the elements in each subarray is equal. >>> can_partition_into_k_subarrays(4, 2, [2, 4, 2, 4]) 'YES' >>> can_partition_into_k_subarrays(4, 3, [2, 4, 2, 4]) 'NO' >>> can_partition_into_k_subarrays(6, 3, [3, 3, 3, 3, 3, 3]) 'YES' def solve_partitions(T, cases): Solves multiple test cases of partitioning arrays into k subarrays with equal sum. >>> T = 3 >>> cases = [ ... ([4, 2], [2, 4, 2, 4]), ... ([4, 3], [2, 4, 2, 4]), ... ([6, 3], [3, 3, 3, 3, 3, 3]), ... ] >>> solve_partitions(T, cases) ['YES', 'NO', 'YES'] from solution import can_partition_into_k_subarrays, solve_partitions def test_case_1(): n = 4 k = 2 arr = [2, 4, 2, 4] assert can_partition_into_k_subarrays(n, k, arr) == \\"YES\\" def test_case_2(): n = 4 k = 3 arr = [2, 4, 2, 4] assert can_partition_into_k_subarrays(n, k, arr) == \\"NO\\" def test_case_3(): n = 6 k = 3 arr = [3, 3, 3, 3, 3, 3] assert can_partition_into_k_subarrays(n, k, arr) == \\"YES\\" def test_case_4(): n = 5 k = 2 arr = [1, 2, 3, 4, 5] assert can_partition_into_k_subarrays(n, k, arr) == \\"NO\\" def test_case_5(): T = 3 cases = [ ([4, 2], [2, 4, 2, 4]), ([4, 3], [2, 4, 2, 4]), ([6, 3], [3, 3, 3, 3, 3, 3]), ] expected_output = [\\"YES\\", \\"NO\\", \\"YES\\"] assert solve_partitions(T, cases) == expected_output","solution":"def can_partition_into_k_subarrays(n, k, arr): total_sum = sum(arr) if total_sum % k != 0: return \\"NO\\" target_sum = total_sum // k current_sum = 0 subarrays_count = 0 for num in arr: current_sum += num if current_sum == target_sum: subarrays_count += 1 current_sum = 0 if subarrays_count == k: return \\"YES\\" else: return \\"NO\\" def solve_partitions(T, cases): results = [] for i in range(T): n, k = cases[i][0] arr = cases[i][1] results.append(can_partition_into_k_subarrays(n, k, arr)) return results"},{"question":"def greatest_lexicographic_substring_length(s: str, k: int) -> int: Determines the length of the greatest lexicographic substring of s after removing exactly k characters from it. Parameters: s (str): The input string consisting of lowercase English letters. k (int): The non-negative integer indicating the number of characters to remove. Returns: int: The length of the greatest lexicographic substring after removing k characters. Examples: >>> greatest_lexicographic_substring_length(\\"abcde\\", 2) 3 >>> greatest_lexicographic_substring_length(\\"zyxwvu\\", 3) 3 >>> greatest_lexicographic_substring_length(\\"\\", 2) 0 >>> greatest_lexicographic_substring_length(\\"abcde\\", 0) 5 >>> greatest_lexicographic_substring_length(\\"abcde\\", 5) 0 >>> greatest_lexicographic_substring_length(\\"aaaaa\\", 2) 3 >>> greatest_lexicographic_substring_length(\\"z\\", 0) 1 >>> greatest_lexicographic_substring_length(\\"z\\", 1) 0 >>> greatest_lexicographic_substring_length(\\"abacabadabacaba\\", 7) 8","solution":"def greatest_lexicographic_substring_length(s, k): Determines the length of the greatest lexicographic substring of s after removing exactly k characters from it. Parameters: s (str): The input string consisting of lowercase English letters. k (int): The non-negative integer indicating the number of characters to remove. Returns: int: The length of the greatest lexicographic substring after removing k characters. if len(s) == 0 or k >= len(s): return 0 n = len(s) target_length = n - k max_substring = \\"\\" for i in range(n - target_length + 1): current_substring = s[i:i + target_length] if current_substring > max_substring: max_substring = current_substring return len(max_substring)"},{"question":"def is_k_palindrome(s: str, k: int) -> str: Check if the string s can be transformed into a palindrome by removing at most k characters. Args: s (str): The string to check. k (int): The maximum number of characters that can be removed. Returns: str: \\"YES\\" if the string can be transformed into a palindrome by removing at most k characters, otherwise \\"NO\\". Examples: >>> is_k_palindrome(\\"abca\\", 1) \\"YES\\" >>> is_k_palindrome(\\"abcde\\", 2) \\"NO\\" pass def test_example_1(): assert is_k_palindrome(\\"abca\\", 1) == \\"YES\\" def test_example_2(): assert is_k_palindrome(\\"abcde\\", 2) == \\"NO\\" def test_single_character(): assert is_k_palindrome(\\"a\\", 0) == \\"YES\\" def test_already_palindrome(): assert is_k_palindrome(\\"racecar\\", 0) == \\"YES\\" def test_remove_all(): assert is_k_palindrome(\\"abcdefg\\", 7) == \\"YES\\" def test_remove_none(): assert is_k_palindrome(\\"abcdefg\\", 0) == \\"NO\\" def test_large_input(): assert is_k_palindrome(\\"abcddcba\\"*10, 100) == \\"YES\\"","solution":"def is_k_palindrome(s: str, k: int) -> str: Check if the string s can be transformed into a palindrome by removing at most k characters. def longest_palindromic_subseq(s: str) -> int: n = len(s) dp = [[0] * n for _ in range(n)] for i in range(n): dp[i][i] = 1 for length in range(2, n + 1): for i in range(n - length + 1): j = i + length - 1 if s[i] == s[j]: dp[i][j] = dp[i + 1][j - 1] + 2 else: dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]) return dp[0][n - 1] n = len(s) lps_length = longest_palindromic_subseq(s) if n - lps_length <= k: return \\"YES\\" else: return \\"NO\\""},{"question":"def find_corrupted_tickets(n, m, intact_tickets): This function finds the corrupted ticket numbers given the highest ticket number n, number of intact tickets m and the list of intact tickets. >>> find_corrupted_tickets(5, 3, [1, 3, 5]) [2, 4] >>> find_corrupted_tickets(7, 4, [1, 2, 4, 7]) [3, 5, 6] >>> find_corrupted_tickets(10, 2, [6, 10]) [1, 2, 3, 4, 5, 7, 8, 9] >>> find_corrupted_tickets(5, 4, [1, 2, 3, 4]) ['\\"None\\"'] def parse_input(tickets_input): Parse the given multiline string input into the expected list of inputs for find_corrupted_tickets function. >>> parse_input('5 3n1 3 5n7 4n1 2 4 7n10 2n6 10n0 0') [(5, 3, [1, 3, 5]), (7, 4, [1, 2, 4, 7]), (10, 2, [6, 10])] def main(tickets_input): Process the input and produce the output for all test cases. >>> main('5 3n1 3 5n7 4n1 2 4 7n10 2n6 10n0 0') '2n4nn3n5n6nn1n2n3n4n5n7n8n9' from solution import find_corrupted_tickets, parse_input, main def test_find_corrupted_tickets(): result = find_corrupted_tickets(5, 3, [1, 3, 5]) assert result == [2, 4] result = find_corrupted_tickets(7, 4, [1, 2, 4, 7]) assert result == [3, 5, 6] result = find_corrupted_tickets(10, 2, [6, 10]) assert result == [1, 2, 3, 4, 5, 7, 8, 9] result = find_corrupted_tickets(5, 4, [1, 2, 3, 4]) assert result == ['\\"None\\"'] def test_parse_input(): input_str = '5 3n1 3 5n7 4n1 2 4 7n10 2n6 10n0 0' expected = [ (5, 3, [1, 3, 5]), (7, 4, [1, 2, 4, 7]), (10, 2, [6, 10]) ] result = parse_input(input_str) assert result == expected def test_main(): input_str = '5 3n1 3 5n7 4n1 2 4 7n10 2n6 10n0 0' expected_output = '2n4nn3n5n6nn1n2n3n4n5n7n8n9' result = main(input_str) assert result == expected_output test_find_corrupted_tickets() test_parse_input() test_main()","solution":"def find_corrupted_tickets(n, m, intact_tickets): This function finds the corrupted ticket numbers given the highest ticket number n, number of intact tickets m and the list of intact tickets. all_tickets = set(range(1, n + 1)) intact_tickets_set = set(intact_tickets) corrupted_tickets = sorted(all_tickets - intact_tickets_set) if len(corrupted_tickets) == 1 and corrupted_tickets[0] == n: return ['\\"None\\"'] return corrupted_tickets def parse_input(tickets_input): Parse the given multiline string input into the expected list of inputs for find_corrupted_tickets function. data = tickets_input.strip().split('n') index = 0 results = [] while index < len(data): n, m = map(int, data[index].split()) if n == 0 and m == 0: break intact_tickets = list(map(int, data[index + 1].split())) results.append((n, m, intact_tickets)) index += 2 return results def main(tickets_input): test_cases = parse_input(tickets_input) output = [] for n, m, intact_tickets in test_cases: corrupted_tickets = find_corrupted_tickets(n, m, intact_tickets) output.extend(corrupted_tickets) output.append(\\"\\") # Adding the empty line after each test case return \\"n\\".join(map(str, output)).strip()"},{"question":"import heapq from typing import List def min_effort_path(grid: List[List[int]]) -> int: Returns the minimum effort required to hike from the top-left to the bottom-right corner of the grid. # Your implementation here def parse_input_and_find_min_effort(input_string: str) -> int: Parses the input string, converts it into the grid, and calls the min_effort_path function to get the result. lines = input_string.strip().split('n') n = int(lines[0]) grid = [list(map(int, line.split())) for line in lines[1:]] return min_effort_path(grid) # Example test cases def test_example_case(): input_string = \\"3n1 2 2n3 8 2n5 3 5\\" assert parse_input_and_find_min_effort(input_string) == 2 def test_small_grid(): input_string = \\"2n1 5n4 2\\" assert parse_input_and_find_min_effort(input_string) == 3 def test_uniform_grid(): input_string = \\"3n10 10 10n10 10 10n10 10 10\\" assert parse_input_and_find_min_effort(input_string) == 0 def test_large_differences(): input_string = \\"3n1 1000 1000n1000 1000 2n2 1000 1\\" assert parse_input_and_find_min_effort(input_string) == 999 def test_non_square_grid(): input_string = \\"4n1 2 3 4n2 3 4 5n3 4 5 6n4 5 6 7\\" assert parse_input_and_find_min_effort(input_string) == 1","solution":"import heapq def min_effort_path(grid): Returns the minimum effort required to hike from the top-left to the bottom-right corner of the grid. n = len(grid) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] efforts = [[float('inf')] * n for _ in range(n)] efforts[0][0] = 0 pq = [(0, 0, 0)] # (effort, x, y) while pq: effort, x, y = heapq.heappop(pq) if x == n - 1 and y == n - 1: return effort for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < n: new_effort = max(effort, abs(grid[nx][ny] - grid[x][y])) if new_effort < efforts[nx][ny]: efforts[nx][ny] = new_effort heapq.heappush(pq, (new_effort, nx, ny)) return -1 def parse_input_and_find_min_effort(input_string): Parse the input string, convert it into the grid and call the min_effort_path function to get the result. lines = input_string.strip().split('n') n = int(lines[0]) grid = [list(map(int, line.split())) for line in lines[1:]] return min_effort_path(grid)"},{"question":"from typing import List def min_moves(N: int, M: int, grid: List[str], x1: int, y1: int, x2: int, y2: int) -> int: Returns the minimum number of moves required for the taxi to reach its destination. If it is not possible, returns -1. >>> min_moves(5, 5, [\\"....C\\", \\".#...\\", \\".#.#.\\", \\"...#.\\", \\"C....\\"], 0, 0, 4, 4) 8 >>> min_moves(3, 3, [\\".#C\\", \\".#.\\", \\"C#.\\"], 0, 0, 2, 2) -1 pass","solution":"from collections import deque def min_moves(N, M, grid, x1, y1, x2, y2): Returns the minimum number of moves required for the taxi to reach its destination. If it is not possible, returns -1. if grid[x1][y1] == '#' or grid[x2][y2] == '#': return -1 directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] # directions for moving up, down, left, right visited = [[False] * M for _ in range(N)] queue = deque([(x1, y1, 0)]) # queue for BFS: (current_x, current_y, dist) visited[x1][y1] = True while queue: current_x, current_y, dist = queue.popleft() if current_x == x2 and current_y == y2: return dist for direction in directions: next_x, next_y = current_x + direction[0], current_y + direction[1] if 0 <= next_x < N and 0 <= next_y < M and not visited[next_x][next_y] and grid[next_x][next_y] != '#': visited[next_x][next_y] = True queue.append((next_x, next_y, dist + 1)) return -1"},{"question":"def min_contiguous_subarray_sum(arr: List[int], S: int) -> int: Find the smallest contiguous subarray whose sum is equal to or greater than S. Return the sum of that subarray or -1 if no such subarray exists. Parameters: arr (List[int]): A list of positive integers S (int): The target sum Returns: int: The sum of the smallest contiguous subarray with sum >= S, or -1 if no such subarray exists Examples: >>> min_contiguous_subarray_sum([1, 2, 3, 4, 5, 6, 7, 8], 15) 15 >>> min_contiguous_subarray_sum([4, 2, 6, 1, 3], 11) 12 >>> min_contiguous_subarray_sum([1, 2, 3, 4, 5], 100) -1","solution":"def min_contiguous_subarray_sum(arr, S): Find the smallest contiguous subarray whose sum is equal to or greater than S. Return the sum of that subarray or -1 if no such subarray exists. n = len(arr) min_length = n + 1 current_sum = 0 start_index = 0 result = -1 for end_index in range(n): current_sum += arr[end_index] while current_sum >= S: subarray_length = end_index - start_index + 1 if subarray_length < min_length: min_length = subarray_length result = current_sum current_sum -= arr[start_index] start_index += 1 return result"},{"question":"def closest_distance_between_robot_and_obstacle(robot_coords, obstacle_coords): Calculate the closest distance between any robot and any obstacle. Args: robot_coords: List of tuples representing the coordinates of robots. obstacle_coords: List of tuples representing the coordinates of obstacles. Returns: Minimum distance between any robot and any obstacle (Euclidean distance squared). pass # Example usage if __name__ == \\"__main__\\": robot_coords = [(0, 0), (4, 4)] obstacle_coords = [(5, 5), (1, 1), (3, 3)] print(closest_distance_between_robot_and_obstacle(robot_coords, obstacle_coords)) # Output should be 2","solution":"import math def closest_distance_between_robot_and_obstacle(robot_coords, obstacle_coords): Calculate the closest distance between any robot and any obstacle. Args: robot_coords: List of tuples representing the coordinates of robots. obstacle_coords: List of tuples representing the coordinates of obstacles. Returns: Minimum distance between any robot and any obstacle (Euclidean distance squared). min_distance = float('inf') for rx, ry in robot_coords: for ox, oy in obstacle_coords: distance = (rx - ox) ** 2 + (ry - oy) ** 2 if distance < min_distance: min_distance = distance return int(min_distance) # Example usage if __name__ == \\"__main__\\": robot_coords = [(0, 0), (4, 4)] obstacle_coords = [(5, 5), (1, 1), (3, 3)] print(closest_distance_between_robot_and_obstacle(robot_coords, obstacle_coords)) # Output should be 2"},{"question":"from typing import List, Tuple def minimum_spanning_tree(T: int, test_cases: List[Tuple[int, List[List[int]]]]) -> List[int]: Determine the minimum total distance Mira needs to walk. Args: T (int): The number of test cases. test_cases (List[Tuple[int, List[List[int]]]]): List of test cases where each test case consists of: - an integer N representing the number of places - an N x N adjacency matrix representing the distance between places Returns: List[int]: The minimum total distance for each test case or \\"IMPOSSIBLE\\" if not all places can be connected. Examples: >>> minimum_spanning_tree(2, [ >>> (3, [[0, 2, 3], [2, 0, -1], [3, -1, 0]]), >>> (4, [[0, 2, -1, 6], [2, 0, 3, 8], [-1, 3, 0, -1], [6, 8, -1, 0]]) >>> ]) [5, 11] >>> minimum_spanning_tree(1, [ >>> (3, [[0, -1, 3], [-1, 0, -1], [3, -1, 0]]) >>> ]) [\\"IMPOSSIBLE\\"] import pytest from solution import minimum_spanning_tree def test_example_case(): T = 2 test_cases = [ (3, [[0, 2, 3], [2, 0, -1], [3, -1, 0]]), (4, [[0, 2, -1, 6], [2, 0, 3, 8], [-1, 3, 0, -1], [6, 8, -1, 0]]) ] expected = [5, 11] assert minimum_spanning_tree(T, test_cases) == expected def test_disconnected_graph(): T = 1 test_cases = [ (3, [[0, -1, 3], [-1, 0, -1], [3, -1, 0]]) ] expected = [\\"IMPOSSIBLE\\"] assert minimum_spanning_tree(T, test_cases) == expected def test_single_node(): T = 1 test_cases = [ (1, [[0]]) ] expected = [0] assert minimum_spanning_tree(T, test_cases) == expected def test_large_graph(): import numpy as np np.random.seed(0) N = 300 graph = np.random.randint(1, 10**6, size=(N, N)).tolist() for i in range(N): graph[i][i] = 0 for j in range(i+1, N): graph[i][j] = graph[j][i] T = 1 test_cases = [ (N, graph) ] result = minimum_spanning_tree(T, test_cases) assert isinstance(result[0], int) and result[0] > 0","solution":"def minimum_spanning_tree(T, test_cases): def prim_mst(graph, N): import heapq total_weight = 0 visited = [False] * N min_heap = [(0, 0)] # (cost, vertex) edges_used = 0 while min_heap: weight, u = heapq.heappop(min_heap) if visited[u]: continue total_weight += weight visited[u] = True edges_used += 1 for v in range(N): if graph[u][v] != -1 and not visited[v]: heapq.heappush(min_heap, (graph[u][v], v)) if edges_used == N: return total_weight else: return \\"IMPOSSIBLE\\" results = [] for idx in range(T): N = test_cases[idx][0] graph = test_cases[idx][1] result = prim_mst(graph, N) results.append(result) return results # Example usage T = 2 test_cases = [ (3, [[0, 2, 3], [2, 0, -1], [3, -1, 0]]), (4, [[0, 2, -1, 6], [2, 0, 3, 8], [-1, 3, 0, -1], [6, 8, -1, 0]]) ] print(minimum_spanning_tree(T, test_cases)) # Output: [5, 11]"},{"question":"def can_form_palindrome(s: str) -> bool: Checks if the characters of the string s can be rearranged to form a palindrome. >>> can_form_palindrome(\\"civic\\") True >>> can_form_palindrome(\\"ivicc\\") True >>> can_form_palindrome(\\"hello\\") False from collections import Counter def palindromic_game(t: int, test_cases: List[str]) -> List[str]: Given the number of test cases t and a list of test cases, determines if the characters of each string can be rearranged to form a palindrome. Returns a list of \\"YES\\" or \\"NO\\" for each test case. >>> palindromic_game(1, [\\"civic\\"]) [\\"YES\\"] >>> palindromic_game(3, [\\"civic\\", \\"ivicc\\", \\"hello\\"]) [\\"YES\\", \\"YES\\", \\"NO\\"] >>> palindromic_game(4, [\\"aabb\\", \\"abcba\\", \\"abccba\\", \\"a\\"]) [\\"YES\\", \\"YES\\", \\"YES\\", \\"YES\\"] results = [] for s in test_cases: if can_form_palindrome(s): results.append(\\"YES\\") else: results.append(\\"NO\\") return results","solution":"def can_form_palindrome(s): Checks if the characters of the string s can be rearranged to form a palindrome. from collections import Counter char_count = Counter(s) odd_count = sum(1 for cnt in char_count.values() if cnt % 2 != 0) return odd_count <= 1 def palindromic_game(t, test_cases): Given the number of test cases t and a list of test cases, determines if the characters of each string can be rearranged to form a palindrome. Returns a list of \\"YES\\" or \\"NO\\" for each test case. results = [] for s in test_cases: if can_form_palindrome(s): results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"from typing import List, Tuple def calculate_manhattan_distance(x1: int, y1: int, x2: int, y2: int) -> int: return abs(x1 - x2) + abs(y1 - y2) def min_total_distance(n: int, packages: List[Tuple[int, int]], m: int, drivers: List[Tuple[int, int, int]]) -> int: Computes the minimum total distance drivers have to travel to deliver all packages. >>> min_total_distance(5, [(0, 0), (1, 2), (3, 3), (4, 1), (1, 1)], 2, [(-1, -1, 3), (2, 2, 2)]) 18 >>> min_total_distance(3, [(0, 0), (2, 2), (3, 3)], 1, [(1, 1, 3)]) 12 pass def test_example_1(): n = 5 packages = [(0, 0), (1, 2), (3, 3), (4, 1), (1, 1)] m = 2 drivers = [(-1, -1, 3), (2, 2, 2)] assert min_total_distance(n, packages, m, drivers) == 18 def test_example_2(): n = 3 packages = [(0, 0), (2, 2), (3, 3)] m = 1 drivers = [(1, 1, 3)] assert min_total_distance(n, packages, m, drivers) == 12","solution":"from itertools import permutations import math def calculate_manhattan_distance(x1, y1, x2, y2): return abs(x1 - x2) + abs(y1 - y2) def min_total_distance(n, packages, m, drivers): # Helper function to calculate total distance for a permutation of packages def total_distance_for_permutation(perm, packages, start_points): total_distance = 0 perm_index = 0 for start, capacity in start_points: deliveries = 0 current_point = start while deliveries < capacity and perm_index < len(perm): package = perm[perm_index] total_distance += calculate_manhattan_distance(current_point[0], current_point[1], package[0], package[1]) current_point = package deliveries += 1 perm_index += 1 total_distance += calculate_manhattan_distance(current_point[0], current_point[1], start[0], start[1]) return total_distance min_distance = math.inf # List of drivers' starting points and their capacities start_points = [( (driver[0], driver[1]), driver[2]) for driver in drivers] # Try all permutations of the packages and calculate the total distance for perm in permutations(packages): distance = total_distance_for_permutation(perm, packages, start_points) if distance < min_distance: min_distance = distance return min_distance"},{"question":"from typing import List def max_subsequence_sum_divisible_by_k(arr: List[int], N: int, K: int) -> int: Find a subsequence of the array such that the sum of the elements of the subsequence is divisible by K and this sum is maximized. If no such subsequence exists, return 0. >>> max_subsequence_sum_divisible_by_k([3, 1, 4, 2, 8], 5, 4) 16 >>> max_subsequence_sum_divisible_by_k([1, 2, 3], 3, 7) 0 >>> max_subsequence_sum_divisible_by_k([4, 8, 12, 16], 4, 4) 40 >>> max_subsequence_sum_divisible_by_k([10], 1, 5) 10 >>> max_subsequence_sum_divisible_by_k([7], 1, 5) 0 >>> max_subsequence_sum_divisible_by_k([i for i in range(1, 1001)], 1000, 10) 500500 >>> max_subsequence_sum_divisible_by_k([100000, 100000], 2, 100000) 200000 pass","solution":"def max_subsequence_sum_divisible_by_k(arr, N, K): # Create a DP array to store the maximum sums with remainders 0 to K-1 dp = [-1] * K dp[0] = 0 for num in arr: temp = dp[:] # Copy current state of dp to temp for i in range(K): if dp[i] != -1: new_sum = dp[i] + num new_remainder = new_sum % K temp[new_remainder] = max(temp[new_remainder], new_sum) dp = temp # Update dp to the new state return dp[0] if dp[0] != 0 else 0"},{"question":"def num_ways(n, m): Return the number of ways to move from the top-left corner to the bottom-right corner of an n x m grid. You can only move right or down at each step. >>> num_ways(2, 2) 2 >>> num_ways(3, 3) 6 >>> num_ways(1, 1) 1 >>> num_ways(2, 3) 3 >>> num_ways(3, 2) 3 >>> num_ways(4, 5) 35","solution":"def num_ways(n, m): Return the number of ways to move from the top-left corner to the bottom-right corner of an n x m grid. You can only move right or down at each step. # Initialize a 2D array with dimensions (n+1) x (m+1) dp = [[0] * (m + 1) for _ in range(n + 1)] # There is one way to reach the starting cell (1, 1) dp[1][1] = 1 # Fill the dp table using the dynamic programming approach for i in range(1, n + 1): for j in range(1, m + 1): if i > 1: dp[i][j] += dp[i - 1][j] # ways from the cell above if j > 1: dp[i][j] += dp[i][j - 1] # ways from the cell to the left # Return the number of ways to reach the bottom-right corner (n, m) return dp[n][m]"},{"question":"def summarize_authors_and_books(n: int, book_details: List[str]) -> str: A library management system needs to keep track of books and their authors. Each book can have one or more authors, and each author can write multiple books. You need to design a program that takes details about books and authors, and then prints a summary of the authors and their books. >>> summarize_authors_and_books(1, [\\"The Great Gatsby;F. Scott Fitzgerald\\"]) \\"F. Scott Fitzgeraldn - The Great Gatsby\\" >>> summarize_authors_and_books(4, [ \\"The Great Gatsby;F. Scott Fitzgerald\\", \\"To Kill a Mockingbird;Harper Lee\\", \\"1984;George Orwell\\", \\"Animal Farm;George Orwell,Harper Lee\\" ]) \\"F. Scott Fitzgeraldn - The Great GatsbynnGeorge Orwelln - 1984n - Animal FarmnnHarper Leen - To Kill a Mockingbirdn - Animal Farm\\" # Test Cases from solution import summarize_authors_and_books def test_single_book(): assert summarize_authors_and_books(1, [\\"The Great Gatsby;F. Scott Fitzgerald\\"]) == \\"F. Scott Fitzgeraldn - The Great Gatsby\\" def test_multiple_books_multiple_authors(): input_data = [ \\"The Great Gatsby;F. Scott Fitzgerald\\", \\"To Kill a Mockingbird;Harper Lee\\", \\"1984;George Orwell\\", \\"Animal Farm;George Orwell,Harper Lee\\" ] expected_output = ( \\"F. Scott Fitzgeraldn - The Great Gatsbynn\\" \\"George Orwelln - 1984n - Animal Farmnn\\" \\"Harper Leen - To Kill a Mockingbirdn - Animal Farm\\" ) assert summarize_authors_and_books(4, input_data) == expected_output def test_single_author_multiple_books(): input_data = [ \\"The Great Gatsby;F. Scott Fitzgerald\\", \\"Tender is the Night;F. Scott Fitzgerald\\", ] expected_output = ( \\"F. Scott Fitzgeraldn - The Great Gatsbyn - Tender is the Night\\" ) assert summarize_authors_and_books(2, input_data) == expected_output def test_multiple_authors_shared_book(): input_data = [ \\"Book1;Author1,Author2\\", \\"Book2;Author2,Author3\\", \\"Book3;Author1,Author3\\" ] expected_output = ( \\"Author1n - Book1n - Book3nn\\" \\"Author2n - Book1n - Book2nn\\" \\"Author3n - Book2n - Book3\\" ) assert summarize_authors_and_books(3, input_data) == expected_output","solution":"def summarize_authors_and_books(n, book_details): from collections import defaultdict author_books = defaultdict(list) for detail in book_details: title, authors = detail.split(';') author_list = authors.split(',') for author in author_list: author_books[author.strip()].append(title.strip()) sorted_authors = sorted(author_books.keys()) result = [] for author in sorted_authors: result.append(author) for title in author_books[author]: result.append(f\\" - {title}\\") result.append(\\"\\") return \\"n\\".join(result).strip()"},{"question":"def max_nesting_depth(datasets): Determine the maximum depth of nesting for a given set of containers. >>> max_nesting_depth([4, (5, 4, 3), (8, 6, 4), (7, 5, 2), (6, 3, 1)]) 3 >>> max_nesting_depth([3, (3, 2, 1), (4, 3, 2), (2, 2, 2)]) 2 def process_input(input_str): Process the input and return datasets in the appropriate format. >>> process_input(\\"4n5 4 3n8 6 4n7 5 2n6 3 1n0\\") [[4, (5, 4, 3), (8, 6, 4), (7, 5, 2), (6, 3, 1)]] >>> process_input(\\"3n3 2 1n4 3 2n2 2 2n0\\") [[3, (3, 2, 1), (4, 3, 2), (2, 2, 2)]] def main(input_str): Main function to process input and determine the maximum depth of nesting. >>> main(\\"4n5 4 3n8 6 4n7 5 2n6 3 1n0\\") \\"3\\" >>> main(\\"3n3 2 1n4 3 2n2 2 2n0\\") \\"2\\"","solution":"def max_nesting_depth(datasets): def can_nest(c1, c2): return all(a < b for a, b in zip(c1, c2)) def longest_increasing_subsequence_length(containers): containers.sort(key=lambda x: (x[0], x[1], x[2])) n = len(containers) dp = [1] * n for i in range(n): for j in range(i): if can_nest(containers[j], containers[i]): dp[i] = max(dp[i], dp[j] + 1) return max(dp) results = [] for dataset in datasets: n = dataset[0] containers = dataset[1:] results.append(longest_increasing_subsequence_length(containers)) return results def process_input(input_str): data = input_str.strip().split(\\"n\\") datasets = [] i = 0 while i < len(data): n = int(data[i]) if n == 0: break containers = [] for _ in range(n): i += 1 containers.append(tuple(map(int, data[i].split()))) datasets.append([n] + containers) i += 1 return datasets def main(input_str): datasets = process_input(input_str) results = max_nesting_depth(datasets) return \\"n\\".join(map(str, results))"},{"question":"def minimize_max_distance(T: int, test_cases: List[Tuple[int, int, List[int]]]) -> List[int]: Determine the optimal locations for warehouses to minimize the maximum distance any route will need to travel to its nearest warehouse. Args: T (int): Number of test cases. test_cases (List[Tuple[int, int, List[int]]]): A list of tuples where each tuple contains: - N (int): Number of delivery routes. - K (int): Maximum number of warehouses. - route_lengths (List[int]): A list of integers representing the lengths of the delivery routes. Returns: List[int]: A list of minimized maximum distances for each test case. Examples: >>> minimize_max_distance(1, [(5, 2, [1, 2, 8, 10, 12])]) [4] >>> minimize_max_distance(1, [(6, 3, [1, 5, 6, 7, 8, 10])]) [2]","solution":"def canPlaceWarehouses(route_lengths, max_distance, K): warehouses_used = 1 last_warehouse_position = route_lengths[0] for i in range(1, len(route_lengths)): if route_lengths[i] - last_warehouse_position > max_distance: warehouses_used += 1 last_warehouse_position = route_lengths[i] if warehouses_used > K: return False return True def minimize_max_distance(T, test_cases): results = [] for case in test_cases: N, K, route_lengths = case route_lengths.sort() left, right = 0, route_lengths[-1] - route_lengths[0] while left < right: mid = (left + right) // 2 if canPlaceWarehouses(route_lengths, mid, K): right = mid else: left = mid + 1 results.append(left) return results"},{"question":"def min_energy_to_travel(N, M, paths, Q, queries): Calculate the minimum energy required to travel between any given pair of safehouses, considering the current state of the connections. Args: N (int): number of safehouses. M (int): number of paths connecting the safehouses. paths (list of tuples): (Ai, Bi, Ei) representing the safehouses connected by the i-th path and the energy required to traverse it. Q (int): number of queries. queries (list of tuples): (Ci, Di) representing the pairs of safehouses for which you need to find the minimum energy required for travel. Returns: list of int: minimum energy required for each query, or -1 if there's no valid path. >>> min_energy_to_travel(5, 6, [(1, 2,10), (1, 3, 20), (2, 3, 30), (2, 4, 25), (3, 5, 15), (4, 5, 40)], 3, [(1,5), (2,4), (3,4)]) [35, 25, -1] >>> min_energy_to_travel(4, 3, [(1, 2, 5), (2, 3, 10), (3, 4, 10)], 2, [(1,4), (1,3)]) [25, 15] def test_min_energy_to_travel(): N, M = 5, 6 paths = [ (1, 2, 10), (1, 3, 20), (2, 3, 30), (2, 4, 25), (3, 5, 15), (4, 5, 40) ] Q = 3 queries = [ (1, 5), (2, 4), (3, 4) ] result = min_energy_to_travel(N, M, paths, Q, queries) assert result == [35, 25, -1], f\\"Expected [35, 25, -1], but got {result}\\" def test_min_energy_with_no_path(): N, M = 5, 6 paths = [ (1, 2, 10), (1, 3, 20), (2, 3, 30), (2, 4, 25), (3, 5, 15), (4, 5, 40) ] Q = 1 queries = [ (1, 5) ] result = min_energy_to_travel(N, M, paths, Q, queries) assert result == [35], f\\"Expected [35], but got {result}\\" def test_min_energy_multiple_queries(): N, M = 4, 3 paths = [ (1, 2, 5), (2, 3, 10), (3, 4, 10) ] Q = 2 queries = [ (1, 4), (1, 3) ] result = min_energy_to_travel(N, M, paths, Q, queries) assert result == [25, 15], f\\"Expected [25, 15], but got {result}\\"","solution":"import heapq def min_energy_to_travel(N, M, paths, Q, queries): # Initialize adjacency list adj = {i: [] for i in range(1, N+1)} # Populate the adjacency list with paths for A, B, E in paths: adj[A].append((E, B)) adj[B].append((E, A)) def dijkstra(start, end): # Min-heap priority queue pq = [(0, start)] # Dictionary to store the minimum energy cost to reach each safehouse min_energy = {i: float('inf') for i in range(1, N+1)} min_energy[start] = 0 while pq: current_energy, u = heapq.heappop(pq) if u == end: return current_energy if current_energy > min_energy[u]: continue for energy, v in adj[u]: new_energy = current_energy + energy if new_energy < min_energy[v]: min_energy[v] = new_energy heapq.heappush(pq, (new_energy, v)) return -1 results = [] for C, D in queries: results.append(dijkstra(C, D)) return results def read_input(): import sys input = sys.stdin.read data = input().split() N = int(data[0]) M = int(data[1]) paths = [] idx = 2 for _ in range(M): A = int(data[idx]) B = int(data[idx+1]) E = int(data[idx+2]) paths.append((A, B, E)) idx += 3 Q = int(data[idx]) idx += 1 queries = [] for _ in range(Q): C = int(data[idx]) D = int(data[idx+1]) queries.append((C, D)) idx += 2 return N, M, paths, Q, queries def main(): N, M, paths, Q, queries = read_input() results = min_energy_to_travel(N, M, paths, Q, queries) for result in results: print(result) if __name__ == \\"__main__\\": main()"},{"question":"def longest_tree_line(n: int, grid: List[str]) -> int: Determine the length of the longest horizontal or vertical line of trees in the garden. Args: n : int : Size of the NxN grid grid : List[str] : Grid representing the garden with 'T' for tree and '.' for empty cell Returns: int : Length of the longest line of trees >>> longest_tree_line(5, [\\"T..T.\\", \\"TTTT.\\", \\"T.T.T\\", \\"..TTT\\", \\".TT.T\\"]) 4 >>> longest_tree_line(1, [\\"T\\"]) 1 >>> longest_tree_line(1, [\\".\\"]) 0 >>> longest_tree_line(3, [\\"TTT\\", \\"TTT\\", \\"TTT\\"]) 3 >>> longest_tree_line(3, [\\"T.T\\", \\".T.\\", \\"T.T\\"]) 1 >>> longest_tree_line(4, [\\"T.T.\\", \\"T.T.\\", \\"T.T.\\", \\"T..T\\"]) 4","solution":"def longest_tree_line(n, grid): max_length = 0 # Check horizontal lines for i in range(n): current_length = 0 for j in range(n): if grid[i][j] == 'T': current_length += 1 max_length = max(max_length, current_length) else: current_length = 0 # Check vertical lines for j in range(n): current_length = 0 for i in range(n): if grid[i][j] == 'T': current_length += 1 max_length = max(max_length, current_length) else: current_length = 0 return max_length"},{"question":"def magical_array(n: int) -> List[int]: Generates a magical array with the first n elements starting from 1, where the sum of any two adjacent elements is a perfect square. >>> magical_array(4) [1, 3, 6, 10] >>> magical_array(2) [1, 3] >>> magical_array(5) [1, 3, 6, 10, 15]","solution":"def is_perfect_square(x): Checks if a number is a perfect square. return int(x**0.5) ** 2 == x def magical_array(n): Generates a magical array with the first n elements starting from 1. if n == 1: return [1] result = [1] current = 1 while len(result) < n: next_num = current + 1 while not is_perfect_square(current + next_num): next_num += 1 result.append(next_num) current = next_num return result"},{"question":"from typing import List def max_profit(prices: List[int]) -> int: Calculate the maximum profit from making at most one buy and one sell transaction. Args: prices (List[int]): An array where the ith element is the price of the stock on the ith day. Returns: int: The maximum profit possible. If no profit can be made, returns 0. Examples: >>> max_profit([7, 1, 5, 3, 6, 4]) 5 >>> max_profit([7, 6, 4, 3]) 0 >>> max_profit([1, 2, 3, 4, 5]) 4","solution":"from typing import List def max_profit(prices: List[int]) -> int: Returns the maximum profit that can be achieved from one buy and one sell operation. If no profit can be made, returns 0. if not prices: return 0 min_price = float('inf') max_profit = 0 for price in prices: if price < min_price: min_price = price elif price - min_price > max_profit: max_profit = price - min_price return max_profit"},{"question":"def path_exists(N: int, M: int, grid: List[List[int]]) -> str: Determine if there exists a path from the top-left corner to the bottom-right corner of a grid. >>> path_exists(3, 3, [ ... [0, 0, 0], ... [1, 1, 0], ... [0, 0, 0] ... ]) 'yes' >>> path_exists(3, 3, [ ... [0, 1, 0], ... [1, 1, 0], ... [0, 0, 0] ... ]) 'no'","solution":"def path_exists(N, M, grid): from collections import deque if grid[0][0] == 1 or grid[N-1][M-1] == 1: return \\"no\\" directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] visited = [[False] * M for _ in range(N)] queue = deque([(0, 0)]) visited[0][0] = True while queue: r, c = queue.popleft() if (r, c) == (N-1, M-1): return \\"yes\\" for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < N and 0 <= nc < M and not visited[nr][nc] and grid[nr][nc] == 0: visited[nr][nc] = True queue.append((nr, nc)) return \\"no\\""},{"question":"def can_transform_sequence(n: int, sequence: List[int]) -> str: Determines if the sequence can be transformed so that each number divides the number that follows it. Parameters: n (int): Length of the sequence. sequence (list of int): The sequence of numbers. Returns: str: \\"YES\\" if the sequence can be transformed, otherwise \\"NO\\". >>> can_transform_sequence(1, [5]) \\"YES\\" >>> can_transform_sequence(3, [4, 8, 16]) \\"YES\\" >>> can_transform_sequence(3, [3, 7, 5]) \\"NO\\" >>> can_transform_sequence(3, [4, 5, 8]) \\"NO\\" >>> can_transform_sequence(2, [6, 10]) \\"NO\\"","solution":"def can_transform_sequence(n, sequence): Determines if the sequence can be transformed so that each number divides the number that follows it. Parameters: n (int): Length of the sequence. sequence (list of int): The sequence of numbers. Returns: str: \\"YES\\" if the sequence can be transformed, otherwise \\"NO\\". if n == 1: return \\"YES\\" for i in range(n-1): if sequence[i+1] % sequence[i] != 0: return \\"NO\\" return \\"YES\\" # Read input values and call the function to determine the answer if __name__ == \\"__main__\\": import sys input = sys.stdin.read data = input().split() n = int(data[0]) sequence = list(map(int, data[1:])) print(can_transform_sequence(n, sequence))"},{"question":"def max_stamps(n: int, m: int) -> int: Returns the maximum number of stamps that can be placed in the n x m album under the given conditions. >>> max_stamps(2, 3) 3 >>> max_stamps(4, 5) 10 >>> max_stamps(1, 1) 1 >>> max_stamps(1000, 1000) 500000","solution":"def max_stamps(n, m): Returns the maximum number of stamps that can be placed in the n x m album under the given conditions. return (n * m + 1) // 2"},{"question":"from typing import List def count_passing_students(num_students: int, num_assignments: int, weights: List[int], scores: List[List[int]]) -> int: Calculate the final grades of students and count how many have a passing grade. Parameters: num_students (int): The number of students num_assignments (int): The number of assignments weights (List[int]): The weights of each assignment scores (List[List[int]]): The scores of each student for each assignment Returns: int: The number of students with a final grade of 60 or more Example: >>> count_passing_students(3, 4, [10, 20, 30, 40], [[50, 75, 85, 90], [80, 60, 70, 50], [30, 40, 50, 60]]) 2 >>> count_passing_students(2, 2, [50, 50], [[100, 100], [60, 60]]) 2 >>> count_passing_students(2, 2, [50, 50], [[50, 50], [40, 40]]) 0 >>> count_passing_students(1, 1, [1], [[60]]) 1 >>> count_passing_students(1, 1, [1], [[59]]) 0","solution":"def count_passing_students(num_students, num_assignments, weights, scores): passing_grade = 60 passing_students = 0 for student_scores in scores: final_grade = sum(w * s for w, s in zip(weights, student_scores)) if final_grade >= passing_grade * sum(weights): passing_students += 1 return passing_students"},{"question":"def count_unique_digit_combinations(n): Returns the number of unique n-digit combinations possible using the digits 0-9 where each digit in the combination is distinct. >>> count_unique_digit_combinations(1) 10 >>> count_unique_digit_combinations(2) 90 >>> count_unique_digit_combinations(3) 720 pass def process_test_cases(test_cases): Processes multiple test cases for count_unique_digit_combinations. Returns a list of results for the provided test cases. >>> process_test_cases([1, 2, 3, 4]) [10, 90, 720, 5040] pass","solution":"def count_unique_digit_combinations(n): Returns the number of unique n-digit combinations possible using the digits 0-9 where each digit in the combination is distinct. if n > 10 or n < 1: return 0 from math import factorial return factorial(10) // factorial(10 - n) def process_test_cases(test_cases): Processes multiple test cases for count_unique_digit_combinations. Returns a list of results for the provided test cases. results = [] for n in test_cases: results.append(count_unique_digit_combinations(n)) return results"},{"question":"def is_valid_bracket_sequence(s: str) -> str: Returns \\"YES\\" if the bracket sequence is valid, otherwise \\"NO\\". >>> is_valid_bracket_sequence(\\"()\\") \\"YES\\" >>> is_valid_bracket_sequence(\\"()[]{}\\") \\"YES\\" >>> is_valid_bracket_sequence(\\"(]\\") \\"NO\\" >>> is_valid_bracket_sequence(\\"([)]\\") \\"NO\\" >>> is_valid_bracket_sequence(\\"{[]}\\") \\"YES\\" >>> is_valid_bracket_sequence(\\"[\\") \\"NO\\" >>> is_valid_bracket_sequence(\\"]\\") \\"NO\\" >>> is_valid_bracket_sequence(\\"[{}]\\") \\"YES\\" >>> is_valid_bracket_sequence(\\"[{()}]\\") \\"YES\\" >>> is_valid_bracket_sequence(\\"{[(])}\\") \\"NO\\" pass def check_bracket_sequences(sequences: List[str]) -> List[str]: Receives a list of strings (sequences). Returns a list of \\"YES\\" or \\"NO\\" for each string, stating if it is a valid bracket sequence. >>> check_bracket_sequences([\\"()\\", \\"()[]{}\\", \\"(]\\", \\"([)]\\"]) [\\"YES\\", \\"YES\\", \\"NO\\", \\"NO\\"] >>> check_bracket_sequences([\\"{[]}\\", \\"[\\", \\"]\\", \\"[{}]\\", \\"[{()}]\\", \\"{[(])}\\"]) [\\"YES\\", \\"NO\\", \\"NO\\", \\"YES\\", \\"YES\\", \\"NO\\"] pass","solution":"def is_valid_bracket_sequence(s): Returns \\"YES\\" if the bracket sequence is valid, otherwise \\"NO\\". stack = [] bracket_map = {')': '(', '}': '{', ']': '['} for char in s: if char in bracket_map: top_element = stack.pop() if stack else '#' if bracket_map[char] != top_element: return \\"NO\\" else: stack.append(char) return \\"YES\\" if not stack else \\"NO\\" def check_bracket_sequences(sequences): Receives a list of strings (sequences). Returns a list of \\"YES\\" or \\"NO\\" for each string, stating if it is a valid bracket sequence. results = [] for sequence in sequences: results.append(is_valid_bracket_sequence(sequence)) return results"},{"question":"def can_assign_tasks(N: int, Z: int, capacities: List[int], workloads: List[int]) -> str: Determine if all tasks can be assigned to the servers without exceeding their capacities. >>> can_assign_tasks(3, 4, [10, 20, 15], [5, 10, 15, 10]) \\"YES\\" >>> can_assign_tasks(2, 3, [8, 5], [7, 3, 6]) \\"NO\\"","solution":"def can_assign_tasks(N, Z, capacities, workloads): capacities.sort(reverse=True) workloads.sort(reverse=True) server_index = 0 for workload in workloads: if server_index < N and capacities[server_index] >= workload: capacities[server_index] -= workload else: server_index += 1 if server_index >= N or capacities[server_index] < workload: return \\"NO\\" return \\"YES\\""},{"question":"def longest_contiguous_active_period(t: int, test_cases: List[str]) -> List[int]: Determine the length of the longest contiguous active browsing period from the given binary string. >>> longest_contiguous_active_period(3, ['1101', '10001', '11111']) [2, 1, 5] >>> longest_contiguous_active_period(2, ['1010101', '000']) [1, 0] >>> longest_contiguous_active_period(1, ['111000111111']) [6]","solution":"def longest_contiguous_active_period(t, test_cases): results = [] for binary_string in test_cases: max_length = 0 current_length = 0 for char in binary_string: if char == '1': current_length += 1 max_length = max(max_length, current_length) else: current_length = 0 results.append(max_length) return results"},{"question":"def can_be_symmetrical(n: int, sequence: str) -> str: Returns \\"Yes\\" if the sequence can be made symmetrical by changing at most one color, otherwise \\"No\\". >>> can_be_symmetrical(4, \\"RBBR\\") \\"Yes\\" >>> can_be_symmetrical(5, \\"RBBRB\\") \\"No\\" >>> can_be_symmetrical(6, \\"ABCCBA\\") \\"Yes\\" >>> can_be_symmetrical(7, \\"ABCDEFG\\") \\"No\\"","solution":"def can_be_symmetrical(n, sequence): Returns \\"Yes\\" if the sequence can be made symmetrical by changing at most one color, otherwise \\"No\\". mismatch_count = 0 for i in range(n // 2): if sequence[i] != sequence[n - i - 1]: mismatch_count += 1 if mismatch_count > 1: return \\"No\\" return \\"Yes\\""},{"question":"def process_reservations(room_types: List[Dict[str, int]], requests: List[Dict[str, int]]) -> List[bool]: Process a series of reservation requests to determine if each request can be accommodated. room_types: List of room types available in the hotel, where each room type is represented as a dictionary with keys 'type_id', 'capacity' and 'availability'. Example: [{'type_id': 1, 'capacity': 2, 'availability': 3}, {'type_id': 2, 'capacity': 4, 'availability': 2}] requests: List of reservation requests, where each request is represented as a dictionary with keys 'num_guests' and 'room_type'. Example: [{'num_guests': 2, 'room_type': 1}, {'num_guests': 5, 'room_type': 2}] Returns: List of boolean values indicating if each reservation request was approved. Example: [True, False] >>> room_types = [ ... {'type_id': 1, 'capacity': 2, 'availability': 3}, ... {'type_id': 2, 'capacity': 4, 'availability': 1}, ... {'type_id': 3, 'capacity': 3, 'availability': 2} ... ] >>> requests = [ ... {'num_guests': 2, 'room_type': 1}, ... {'num_guests': 4, 'room_type': 2}, ... {'num_guests': 2, 'room_type': 1}, ... {'num_guests': 3, 'room_type': 3}, ... {'num_guests': 5, 'room_type': 2} ... ] >>> process_reservations(room_types, requests) [True, True, True, True, False] pass def test_process_reservations_success(): room_types = [ {'type_id': 1, 'capacity': 2, 'availability': 3}, {'type_id': 2, 'capacity': 4, 'availability': 1}, {'type_id': 3, 'capacity': 3, 'availability': 2} ] requests = [ {'num_guests': 2, 'room_type': 1}, {'num_guests': 4, 'room_type': 2}, {'num_guests': 2, 'room_type': 1}, {'num_guests': 3, 'room_type': 3}, {'num_guests': 5, 'room_type': 2} ] expected = [True, True, True, True, False] assert process_reservations(room_types, requests) == expected def test_process_reservations_fail_due_to_capacity(): room_types = [ {'type_id': 1, 'capacity': 2, 'availability': 2} ] requests = [ {'num_guests': 3, 'room_type': 1} ] expected = [False] assert process_reservations(room_types, requests) == expected def test_process_reservations_fail_due_to_availability(): room_types = [ {'type_id': 1, 'capacity': 2, 'availability': 1} ] requests = [ {'num_guests': 2, 'room_type': 1}, {'num_guests': 2, 'room_type': 1} ] expected = [True, False] assert process_reservations(room_types, requests) == expected def test_process_reservations_all_success(): room_types = [ {'type_id': 1, 'capacity': 2, 'availability': 1}, {'type_id': 2, 'capacity': 4, 'availability': 1} ] requests = [ {'num_guests': 2, 'room_type': 1}, {'num_guests': 4, 'room_type': 2} ] expected = [True, True] assert process_reservations(room_types, requests) == expected def test_process_reservations_invalid_room_type(): room_types = [ {'type_id': 1, 'capacity': 2, 'availability': 1} ] requests = [ {'num_guests': 2, 'room_type': 2} ] expected = [False] assert process_reservations(room_types, requests) == expected","solution":"def process_reservations(room_types, requests): room_dict = {room['type_id']: room for room in room_types} results = [] for request in requests: room_type = request['room_type'] num_guests = request['num_guests'] if room_type in room_dict: room_info = room_dict[room_type] if room_info['capacity'] >= num_guests and room_info['availability'] > 0: results.append(True) room_info['availability'] -= 1 else: results.append(False) else: results.append(False) return results"},{"question":"def calculate_total_scores(U: int, P: int, difficulties: List[float], users_problems: List[List[int]]) -> List[float]: Calculates and returns the total scores for each user. :param U: Number of users. :param P: Number of problems. :param difficulties: List of difficulties for each problem from 1 to P. :param users_problems: List of each user's solved problems. :return: List of total scores for each user. >>> calculate_total_scores(3, 4, [1.5, 2.0, 3.5, 4.0], [[1, 3, 1, 2, 3], [2, 1, 4], [3, 2, 2, 4]]) [7.0, 4.0, 6.0] >>> calculate_total_scores(2, 3, [1.2, 2.5, 3.8], [[1, 2, 1, 2], [2, 3, 1, 2, 3]]) [3.7, 7.5] from typing import List # Example test cases def test_calculate_total_scores(): assert calculate_total_scores( 3, 4, [1.5, 2.0, 3.5, 4.0], [ [1, 3, 1, 2, 3], [2, 1, 4], [3, 2, 2, 4] ] ) == [7.0, 4.0, 6.0] assert calculate_total_scores( 2, 3, [1.2, 2.5, 3.8], [ [1, 2, 1, 2], [2, 3, 1, 2, 3] ] ) == [3.7, 7.5] assert calculate_total_scores( 1, 5, [0.5, 1.2, 2.8, 0.9, 4.1], [ [1, 5, 1, 2, 3, 4, 5] ] ) == [9.5] assert calculate_total_scores( 4, 4, [1.1, 2.2, 3.3, 4.4], [ [1, 1, 1], [2, 2, 1, 2], [3, 3, 1, 2, 3], [4, 4, 1, 2, 3, 4] ] ) == [1.1, 3.3, 6.6, 11.0] assert calculate_total_scores( 2, 2, [0.1, 0.9], [ [1, 2, 1, 2], [2, 1, 1] ] ) == [1.0, 0.1]","solution":"def calculate_total_scores(U, P, difficulties, users_problems): Calculates and returns the total scores for each user. :param U: Number of users. :param P: Number of problems. :param difficulties: List of difficulties for each problem from 1 to P. :param users_problems: List of each user's solved problems. :return: List of total scores for each user. scores = [0.0] * U # Loop through each user for user_data in users_problems: user, k, *solved_problems = user_data user_total_score = 0.0 solved_set = set() # Loop through each problem solved by the user for problem in solved_problems: if problem not in solved_set: user_total_score += difficulties[problem - 1] solved_set.add(problem) scores[user - 1] = round(user_total_score, 1) return scores"},{"question":"from typing import List def find_winner(scores: List[str]) -> str: Determine the winner of a basketball game based on given scores. Args: scores (List[str]): A list of strings where each string contains an integer (the score) and a letter ('A' or 'B'). Returns: str: 'A' if team A wins, 'B' if team B wins, and 'D' if the result is a draw. Examples: >>> find_winner([\\"10A\\", \\"20B\\", \\"15A\\", \\"25B\\"]) == 'B' >>> find_winner([\\"30A\\", \\"10B\\", \\"20A\\", \\"15B\\"]) == 'A' >>> find_winner([\\"10A\\", \\"25A\\", \\"20B\\", \\"15B\\"]) == 'D' def test_team_a_wins(): assert find_winner([\\"30A\\", \\"10B\\", \\"20A\\", \\"15B\\"]) == 'A' def test_team_b_wins(): assert find_winner([\\"10A\\", \\"20B\\", \\"15A\\", \\"25B\\"]) == 'B' def test_draw(): assert find_winner([\\"10A\\", \\"25A\\", \\"20B\\", \\"15B\\"]) == 'D' def test_single_score(): assert find_winner([\\"10A\\"]) == 'A' assert find_winner([\\"10B\\"]) == 'B' def test_same_scores(): assert find_winner([\\"10A\\", \\"10B\\"]) == 'D' def test_large_scores(): assert find_winner([\\"50A\\", \\"50B\\", \\"50A\\", \\"50B\\"]) == 'D' def test_mixed_order(): assert find_winner([\\"10B\\", \\"20A\\", \\"5B\\", \\"25A\\", \\"15B\\"]) == 'A' assert find_winner([\\"30B\\", \\"12A\\", \\"4B\\", \\"4A\\", \\"29B\\"]) == 'B'","solution":"from typing import List def find_winner(scores: List[str]) -> str: score_A = 0 score_B = 0 for score in scores: if score[-1] == 'A': score_A += int(score[:-1]) elif score[-1] == 'B': score_B += int(score[:-1]) if score_A > score_B: return 'A' elif score_B > score_A: return 'B' else: return 'D'"},{"question":"def are_collinear(x1: float, y1: float, x2: float, y2: float, x3: float, y3: float) -> str: Determines if three given points are collinear. >>> are_collinear(0, 0, 1, 1, 2, 2) \\"Yes\\" >>> are_collinear(0, 0, 1, 1, 1, 2) \\"No\\"","solution":"def are_collinear(x1, y1, x2, y2, x3, y3): Determines if three given points are collinear. Collinear points lie on the same line if the area of the triangle formed by the points is zero. The area of the triangle formed by points (x1, y1), (x2, y2), (x3, y3) is: 0.5 * abs(x1*(y2 - y3) + x2*(y3 - y1) + x3*(y1 - y2)) If this value is zero, then the points are collinear. # Calculate twice the area of the triangle area_twice = x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2) # If the area is zero, the points are collinear if area_twice == 0: return \\"Yes\\" else: return \\"No\\""},{"question":"def find_kth_largest(n: int, arr: List[int], k: int) -> int: Returns the k-th largest element in the array. Parameters: n (int): The number of elements in the array. arr (list of int): The array of integers. k (int): The k-th position to find when the array is sorted in descending order. Returns: int: The k-th largest element in the array. >>> find_kth_largest(6, [3, 2, 1, 5, 6, 4], 2) == 5 >>> find_kth_largest(1, [10], 1) == 10 >>> find_kth_largest(4, [7, 7, 7, 7], 2) == 7 >>> find_kth_largest(5, [-10, -30, -20, -50, -40], 3) == -30 >>> find_kth_largest(6, [1, -1, 3, -3, 2, -2], 4) == -1 >>> find_kth_largest(7, [10, 20, 50, 30, 40, 70, 60], 5) == 30 >>> find_kth_largest(8, [5, 3, 4, 3, 2, 5, 1, 6], 3) == 5","solution":"def find_kth_largest(n, arr, k): Returns the k-th largest element in the array. Parameters: n (int): The number of elements in the array. arr (list of int): The array of integers. k (int): The k-th position to find when the array is sorted in descending order. Returns: int: The k-th largest element in the array. sorted_arr = sorted(arr, reverse=True) return sorted_arr[k - 1]"},{"question":"def min_closing_parentheses_to_balance(s: str) -> int: Write a function that checks if it is possible to obtain a matching set of parentheses by inserting the minimum number of closing parentheses into a given string containing only opening and closing parentheses. The function should return the minimum number of closing parentheses required to make the parentheses balanced. >>> min_closing_parentheses_to_balance(\\"(()(()\\") 2 >>> min_closing_parentheses_to_balance(\\")(())\\") 1 >>> min_closing_parentheses_to_balance(\\")))(((\\") 6 >>> min_closing_parentheses_to_balance(\\"()()\\") 0 def test_min_closing_parentheses_to_balance(): assert min_closing_parentheses_to_balance(\\"(()(()\\") == 2 assert min_closing_parentheses_to_balance(\\")(())\\") == 1 assert min_closing_parentheses_to_balance(\\")))(((\\") == 6 assert min_closing_parentheses_to_balance(\\"()()\\") == 0 assert min_closing_parentheses_to_balance(\\"(\\") == 1 assert min_closing_parentheses_to_balance(\\")\\") == 1 assert min_closing_parentheses_to_balance(\\"(())\\") == 0 assert min_closing_parentheses_to_balance(\\"((()))\\") == 0 assert min_closing_parentheses_to_balance(\\"(()))\\") == 1 assert min_closing_parentheses_to_balance(\\"(((((\\") == 5 assert min_closing_parentheses_to_balance(\\")))))\\") == 5 assert min_closing_parentheses_to_balance(\\"(()((())\\") == 2 def test_min_closing_parentheses_to_balance_edge_cases(): assert min_closing_parentheses_to_balance(\\"\\") == 0 assert min_closing_parentheses_to_balance(\\"()\\") == 0 assert min_closing_parentheses_to_balance(\\")\\") == 1","solution":"def min_closing_parentheses_to_balance(s: str) -> int: Calculates the minimum number of closing parentheses needed to balance the string. open_count = 0 close_count = 0 for char in s: if char == '(': open_count += 1 elif char == ')': if open_count > 0: open_count -= 1 else: close_count += 1 # close_count accounts for unmatched closing parentheses # open_count remaining after processing will be the unmatched opening parentheses return open_count + close_count"},{"question":"from collections import deque def shortest_path_length(m, n, grid, start_x, start_y, end_x, end_y): Determine the shortest path length for the robot from the start point to the destination. The robot can move up, down, left, or right but cannot move outside the grid. Return the length of the shortest path. If no such path exists, return -1. >>> shortest_path_length(5, 5, [ ... [0, 0, 0, 0, 1], ... [0, 1, 0, 1, 0], ... [0, 0, 0, 1, 0], ... [1, 0, 1, 0, 0], ... [0, 0, 0, 0, 0]], 0, 0, 4, 4) 8 >>> shortest_path_length(3, 3, [ ... [0, 1, 0], ... [1, 1, 0], ... [0, 0, 0]], 0, 0, 2, 2) -1 >>> shortest_path_length(1, 2, [ ... [0, 0]], 0, 0, 0, 1) 1","solution":"from collections import deque def shortest_path_length(m, n, grid, start_x, start_y, end_x, end_y): # Directions for moving in the grid: right, down, left, up directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] # Initialize the queue with the starting point and the steps taken queue = deque([(start_x, start_y, 0)]) # To keep track of visited cells visited = set() visited.add((start_x, start_y)) while queue: x, y, steps = queue.popleft() # If we reach the end point, return the steps taken if (x, y) == (end_x, end_y): return steps # Check all possible movements for dx, dy in directions: nx, ny = x + dx, y + dy # If the new cell is within the grid and is walkable and not yet visited if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] == 0 and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny, steps + 1)) # If no valid path is found, return -1 return -1"},{"question":"import math def is_prime(n: int) -> bool: Check if a number n is prime. >>> is_prime(11) True >>> is_prime(4) False pass def find_twin_primes(l: int, r: int) -> None: Find all pairs of twin primes (p1, p2) such that l ≤ p1 < p2 ≤ r, and p2 - p1 = 2. >>> find_twin_primes(10, 50) 11 13 17 19 29 31 41 43 >>> find_twin_primes(48, 52) No twin primes pass","solution":"import math def is_prime(n): if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def find_twin_primes(l, r): twin_primes = [] for num in range(l, r - 1): if is_prime(num) and is_prime(num + 2): twin_primes.append((num, num + 2)) if twin_primes: for pair in twin_primes: print(f\\"{pair[0]} {pair[1]}\\") else: print(\\"No twin primes\\")"},{"question":"def min_operations(t, test_cases): Determine the minimum number of operations required to make the entire row consist of the same type of flower. Arguments: t -- the number of test cases. test_cases -- a list of tuples, each containing the length of the array and the array itself. Returns: A list of integers representing the minimum number of operations for each test case. >>> min_operations(3, [(5, [1, 2, 1, 1, 4]), (6, [3, 3, 3, 3, 3, 3]), (7, [1, 2, 3, 4, 5, 6, 7])]) [2, 0, 6] >>> min_operations(1, [(1, [1])]) [0]","solution":"def min_operations(t, test_cases): results = [] for i in range(t): n = test_cases[i][0] arr = test_cases[i][1] if n == 1: results.append(0) continue freq = {} for num in arr: if num in freq: freq[num] += 1 else: freq[num] = 1 most_frequent_count = max(freq.values()) results.append(n - most_frequent_count) return results"},{"question":"def can_form_target(n: int, dice_rolls: List[int], target: str) -> str: Determine if a target sequence can be formed using given dice rolls. >>> can_form_target(5, [12, 34, 56, 78, 90], \\"123456\\") \\"Yes\\" >>> can_form_target(4, [1, 23, 456, 789], \\"1234567\\") \\"No\\" >>> can_form_target(6, [1, 2, 3, 45, 6, 78], \\"12345678\\") \\"Yes\\"","solution":"def can_form_target(n, dice_rolls, target): def dfs(index, current): if len(current) > len(target): return False if current == target: return True for i in range(index, n): if dfs(i + 1, current + str(dice_rolls[i])): return True return False return \\"Yes\\" if dfs(0, '') else \\"No\\""},{"question":"def find_split_indices(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[Tuple[int, int]]: Given a number of test cases, and an array for each case, split each array into two non-empty subarrays such that the sum of elements in the first subarray is strictly less than the sum of the elements in the second subarray. Args: t (int): Number of test cases. test_cases (List[Tuple[int, List[int]]]): List of tuples where each tuple consists of an integer (length of the array) and a list of integers (the array). Returns: List[Tuple[int, int]]: List of tuples where each tuple contains two integers l and r representing the indices to split the array. Example: >>> find_split_indices(3, [(5, [1, 2, 3, 4, 5]), (4, [-1, 0, 1, 2]), (6, [3, 3, 3, 3, 3, 15])]) [(1, 5), (1, 4), (1, 6)]","solution":"def find_split_indices(t, test_cases): results = [] for case in test_cases: n, a = case # To ensure the condition sum(first subarray) < sum(second subarray) # Simply take the first element as the first subarray and the rest as the second subarray. results.append((1, n)) return results"},{"question":"def max_optimized_products(n: int, m: int, k: int, tasks: List[int], products: List[int], costs: List[int]) -> int: Determines the maximum number of products that can be optimized within the given budget. :param n: Number of products :param m: Number of tasks :param k: Budget constraint :param tasks: List of difficulty constraints of the tasks :param products: List of compatibility thresholds of the products :param costs: List of costs associated with each optimization task :return: Maximum number of products that can be optimized without exceeding the budget from typing import List def test_example_1(): n = 3 m = 4 k = 10 tasks = [1, 2, 4, 3] products = [4, 3, 2] costs = [2, 5, 4, 8] assert max_optimized_products(n, m, k, tasks, products, costs) == 2 def test_example_2(): n = 5 m = 5 k = 15 tasks = [2, 3, 5, 7, 1] products = [8, 6, 1, 4, 5] costs = [3, 5, 7, 8, 2] assert max_optimized_products(n, m, k, tasks, products, costs) == 3 def test_no_budget(): n = 3 m = 3 k = 0 tasks = [1, 2, 3] products = [3, 2, 1] costs = [1, 2, 3] assert max_optimized_products(n, m, k, tasks, products, costs) == 0 def test_all_tasks_too_expensive(): n = 4 m = 4 k = 1 tasks = [1, 2, 3, 4] products = [4, 3, 2, 1] costs = [2, 3, 4, 5] assert max_optimized_products(n, m, k, tasks, products, costs) == 0 def test_exact_budget(): n = 2 m = 2 k = 5 tasks = [1, 2] products = [2, 1] costs = [2, 3] assert max_optimized_products(n, m, k, tasks, products, costs) == 2 def test_large_values(): n = 1 m = 1 k = 1000000000 tasks = [1000000000] products = [1000000000] costs = [1000000000] assert max_optimized_products(n, m, k, tasks, products, costs) == 1","solution":"def max_optimized_products(n, m, k, tasks, products, costs): Determines the maximum number of products that can be optimized within the given budget. :param n: Number of products :param m: Number of tasks :param k: Budget constraint :param tasks: List of difficulty constraints of the tasks :param products: List of compatibility thresholds of the products :param costs: List of costs associated with each optimization task :return: Maximum number of products that can be optimized without exceeding the budget product_list = sorted((compatibility, i) for i, compatibility in enumerate(products)) task_list = sorted((difficulty, cost) for difficulty, cost in zip(tasks, costs)) optimized_products = 0 budget_used = 0 i = 0 # pointer for products j = 0 # pointer for tasks while i < n and j < m: while j < m and task_list[j][0] <= product_list[i][0]: # If task difficulty <= product compatibility if budget_used + task_list[j][1] <= k: budget_used += task_list[j][1] optimized_products += 1 break j += 1 i += 1 j += 1 # move to the next task for next product return optimized_products"},{"question":"def temperature_ranges(input_data: str) -> List[int]: Given a list of datasets, each containing temperatures recorded throughout the day, calculate the temperature range (difference between highest and lowest temperature) for each dataset. The input ends with a line containing '0'. >>> temperature_ranges(\\"6n-5 0 -3 -10 5 15n0\\") [25] >>> temperature_ranges(\\"6n-5 0 -3 -10 5 15n4n32 35 30 31n5n0 -50 25 10 5n0\\") [25, 5, 75]","solution":"def temperature_ranges(input_data): Given a list of datasets, each containing temperatures recorded throughout the day, calculate the temperature range (difference between highest and lowest temperature) for each dataset. The input ends with a line containing '0'. ranges = [] lines = input_data.strip().split('n') idx = 0 while idx < len(lines): n = int(lines[idx]) if n == 0: break temperatures = list(map(int, lines[idx + 1].split())) temp_range = max(temperatures) - min(temperatures) ranges.append(temp_range) idx += 2 return ranges"},{"question":"def min_operations_to_transform(n: int, s: str, t: str) -> int: Returns the minimum number of operations required to transform string s into string t. Parameters: n (int): The length of the strings s and t. s (str): The source string. t (str): The target string. Returns: int: The minimum number of operations. Examples: >>> min_operations_to_transform(3, \\"abc\\", \\"bcd\\") 3 >>> min_operations_to_transform(5, \\"abcde\\", \\"fghij\\") 5 >>> min_operations_to_transform(4, \\"abcd\\", \\"abcd\\") 0 >>> min_operations_to_transform(1, \\"a\\", \\"b\\") 1 >>> min_operations_to_transform(1, \\"z\\", \\"y\\") 1 >>> min_operations_to_transform(4, \\"aaaa\\", \\"bbbb\\") 4 >>> min_operations_to_transform(1, \\"a\\", \\"a\\") 0 >>> min_operations_to_transform(1, \\"z\\", \\"a\\") 1","solution":"def min_operations_to_transform(n, s, t): Returns the minimum number of operations required to transform string s into string t. Parameters: n (int): The length of the strings s and t. s (str): The source string. t (str): The target string. Returns: int: The minimum number of operations. operations = 0 for i in range(n): if s[i] != t[i]: operations += 1 return operations"},{"question":"def largest_palindrome(n: int) -> int: Given an integer n (1 ≤ n ≤ 100,000), find the largest palindrome number that is less than or equal to n. >>> largest_palindrome(121) 121 >>> largest_palindrome(130) 121 >>> largest_palindrome(99) 99","solution":"def largest_palindrome(n): Returns the largest palindrome number less than or equal to n. def is_palindrome(x): return str(x) == str(x)[::-1] for i in range(n, 0, -1): if is_palindrome(i): return i"},{"question":"def find_missing_numbers(original_seq, corrupted_seq): Finds the missing numbers required to restore the corrupted sequence to match the original sequence. >>> find_missing_numbers([1, 3, 5, 7, 9], [1, 7, 9]) [3, 5] >>> find_missing_numbers([2, 4, 6, 8, 10, 12], [4, 8, 10, 12]) [2, 6] def restore_sequences(test_cases): Restores the corrupted sequences to their original form for a list of test cases. >>> test_cases = [([1, 3, 5, 7, 9], [1, 7, 9]), ([2, 4, 6, 8, 10, 12], [4, 8, 10, 12])] >>> restore_sequences(test_cases) [[3, 5], [2, 6]] def process_input(input_string): Processes the input string to extract the test cases. >>> input_string = '2n5n1 3 5 7 9n1 7 9n6n2 4 6 8 10 12n4 8 10 12n' >>> process_input(input_string) [([1, 3, 5, 7, 9], [1, 7, 9]), ([2, 4, 6, 8, 10, 12], [4, 8, 10, 12])]","solution":"def find_missing_numbers(original_seq, corrupted_seq): Finds the missing numbers required to restore the corrupted sequence to match the original sequence. original_set = set(original_seq) corrupted_set = set(corrupted_seq) missing_numbers = sorted(original_set - corrupted_set) return missing_numbers def restore_sequences(test_cases): results = [] for original_seq, corrupted_seq in test_cases: missing_numbers = find_missing_numbers(original_seq, corrupted_seq) results.append(missing_numbers) return results def process_input(input_string): lines = input_string.strip().split('n') T = int(lines[0]) index = 1 test_cases = [] for _ in range(T): N = int(lines[index]) original_seq = list(map(int, lines[index + 1].split())) corrupted_seq = list(map(int, lines[index + 2].split())) test_cases.append((original_seq, corrupted_seq)) index += 3 return test_cases"},{"question":"def min_trips_for_delivery(n: int, weights: List[int], max_load: int) -> int: Determines the minimum number of trips required to deliver all packages with the given drone load capacity. Parameters: n (int): Number of packages weights (list of int): Weights of packages max_load (int): Maximum load of the drone in one trip Returns: int: Minimum number of trips required to deliver all packages >>> min_trips_for_delivery(5, [3, 8, 2, 7, 4], 10) 3 >>> min_trips_for_delivery(6, [1, 2, 3, 4, 5, 6], 9) 3","solution":"def min_trips_for_delivery(n, weights, max_load): Determines the minimum number of trips required to deliver all packages with the given drone load capacity. Parameters: n (int): Number of packages weights (list of int): Weights of the packages max_load (int): Maximum load of the drone in one trip Returns: int: Minimum number of trips required to deliver all packages weights.sort() trips = 0 start, end = 0, n - 1 while start <= end: if weights[start] + weights[end] <= max_load: start += 1 end -= 1 trips += 1 return trips"},{"question":"def minDistance(S: str, T: str) -> int: Returns the minimum number of operations required to transform string S into string T. >>> minDistance('horse', 'ros') 3 >>> minDistance('intention', 'execution') 5 >>> minDistance('kitten', 'sitting') 3 >>> minDistance('test', 'test') 0 >>> minDistance('', 'abc') 3 >>> minDistance('abc', '') 3 >>> minDistance('', '') 0 >>> minDistance('a', 'b') 1 >>> minDistance('ab', 'abxyz') 3 >>> minDistance('xyzab', 'ab') 3","solution":"def minDistance(S, T): Returns the minimum number of operations required to transform string S into string T. m, n = len(S), len(T) dp = [[0] * (n + 1) for _ in range(m + 1)] for i in range(m + 1): for j in range(n + 1): if i == 0: dp[i][j] = j # insert all characters of T into S elif j == 0: dp[i][j] = i # remove all characters from S elif S[i - 1] == T[j - 1]: dp[i][j] = dp[i - 1][j - 1] # characters match, no ops needed else: dp[i][j] = 1 + min(dp[i - 1][j], # delete dp[i][j - 1], # insert dp[i - 1][j - 1]) # replace return dp[m][n]"},{"question":"from typing import List, Tuple def find_closest_pair(arr: List[int], target: int) -> Tuple[int, int]: Find a pair of integers in \`arr\` such that their sum is closest to \`target\`. If there are multiple valid pairs, choose the one with the smallest sum. Return the pair as a tuple of two integers. >>> find_closest_pair([1, 2, 3, 4], 5) (1, 4) >>> find_closest_pair([-1, -2, -3, -4, -5], -8) (-5, -3) >>> find_closest_pair([10, 22, 28, 29, 30], 54) (22, 30) pass def process_test_cases(test_cases: List[Tuple[int, List[int], int]]) -> List[Tuple[int, int]]: Process multiple test cases and return results. >>> process_test_cases([(4, [1, 2, 3, 4], 5), (5, [-1, -2, -3, -4, -5], -8)]) [(1, 4), (-5, -3)] pass def main(t: int, test_cases: List[Tuple[int, List[int], int]]) -> List[Tuple[int, int]]: Main function to handle input and output for multiple test cases. >>> main(2, [(4, [1, 2, 3, 4], 5), (5, [-1, -2, -3, -4, -5], -8)]) [(1, 4), (-5, -3)] pass # Unit tests def test_main(): assert main(1, [(4, [1, 2, 3, 4], 5)]) == [(1, 4)] assert main(1, [(5, [-1, -2, -3, -4, -5], -8)]) == [(-5, -3)] assert main(1, [(5, [10, 22, 28, 29, 30], 54)]) == [(22, 30)] assert main(3, [ (4, [1, 2, 3, 4], 5), (5, [-1, -2, -3, -4, -5], -8), (5, [10, 22, 28, 29, 30], 54) ]) == [(1, 4), (-5, -3), (22, 30)] assert main(1, [(2, [5, 15], 10)]) == [(5, 15)] def test_edge_cases(): assert main(1, [(2, [1, 2], 3)]) == [(1, 2)] assert main(1, [(5, [5, 55, 100, 200, 300], 105)]) == [(5, 100)] assert main(1, [(5, [100, 200, 300, 400, 500], 1000)]) == [(400, 500)]","solution":"def find_closest_pair(arr, target): Function to find a pair of integers in \`arr\` such that their sum is closest to \`target\`. If there are multiple valid pairs, choose the one with the smallest sum. Return the pair as a tuple of two integers. arr.sort() left, right = 0, len(arr) - 1 closest_pair = (arr[0], arr[1]) min_diff = abs(target - (arr[0] + arr[1])) while left < right: curr_sum = arr[left] + arr[right] curr_diff = abs(target - curr_sum) if curr_diff < min_diff or (curr_diff == min_diff and curr_sum < sum(closest_pair)): min_diff = curr_diff closest_pair = (arr[left], arr[right]) if curr_sum < target: left += 1 else: right -= 1 return closest_pair def process_test_cases(test_cases): results = [] for case in test_cases: n, arr, target = case results.append(find_closest_pair(arr, target)) return results def main(t, test_cases): return process_test_cases(test_cases)"},{"question":"def count_valid_codes(N: int) -> int: Returns the number of valid product codes of length N. A valid code consists of letters from the alphabet and does not have consecutive identical characters. >>> count_valid_codes(1) 26 >>> count_valid_codes(2) 650 >>> count_valid_codes(3) 16250","solution":"def count_valid_codes(N): Returns the number of valid product codes of length N. A valid code consists of letters from the alphabet and does not have consecutive identical characters. if N == 1: return 26 # There are 26 valid codes of length 1 (each letter a-z) # Initialize variables for the dynamic programming approach prev_total = 26 # For sequences of length 1 prev_excluding_last = 26 # For sequences of length 1 for i in range(2, N+1): new_prev_total = prev_total * 25 # Update for the next iteration prev_excluding_last = prev_total * 25 prev_total = new_prev_total return prev_total"},{"question":"def find_duplicates(arr): Finds and returns a list of duplicate elements in the order of their first occurrence. :param arr: A list of integers :return: A list of integers representing duplicate elements Example: >>> find_duplicates([1, 3, 2, 3, 4, 5, 6, 2, 3, 6]) [3, 2, 6]","solution":"def find_duplicates(arr): Finds and returns a list of duplicate elements in the order of their first occurrence. :param arr: A list of integers :return: A list of integers representing duplicate elements Example: >>> find_duplicates([1, 3, 2, 3, 4, 5, 6, 2, 3, 6]) [3, 2, 6] seen = set() duplicates = set() result = [] for num in arr: if num in seen: if num not in duplicates: duplicates.add(num) result.append(num) else: seen.add(num) return result"},{"question":"from typing import List from collections import Counter def top_k_frequent_words(K: int, text: str) -> List[str]: Finds the top K most frequently occurring words in the given text. Parameters: K (int): The number of top frequent words to return. text (str): The text to analyze. Returns: List[str]: List of the top K frequent words in descending order of frequency. Examples: >>> top_k_frequent_words(3, \\"hello world hello coding world hello\\") [\\"hello\\", \\"world\\", \\"coding\\"] >>> top_k_frequent_words(2, \\"a b c a b c d d\\") [\\"a\\", \\"b\\"] >>> top_k_frequent_words(1, \\"test\\") [\\"test\\"] >>> top_k_frequent_words(2, \\"one two three two two four three three three\\") [\\"three\\", \\"two\\"] >>> top_k_frequent_words(5, \\"one one two two three three four four five five\\") [\\"five\\", \\"four\\", \\"one\\", \\"three\\", \\"two\\"]","solution":"from collections import Counter def top_k_frequent_words(K, text): Finds the top K most frequently occurring words in the given text. Parameters: K (int): The number of top frequent words to return. text (str): The text to analyze. Returns: list: List of the top K frequent words in descending order of frequency. words = text.split() word_count = Counter(words) most_common = word_count.most_common() # Sort by frequency first, then alphabetically by word most_common.sort(key=lambda x: (-x[1], x[0])) return [word for word, _ in most_common[:K]]"},{"question":"from typing import List from itertools import combinations def min_difference(n: int, skill_array: List[int]) -> int: Returns the minimum difference between the sums of skill levels of two balanced teams. >>> min_difference(6, [1, 2, 3, 4, 5, 6]) 1 >>> min_difference(4, [10, 10, 10, 10]) 0 >>> min_difference(4, [1, 1, 1, 2]) 1 >>> min_difference(6, [3, 1, 4, 1, 5, 9]) 1 >>> min_difference(4, [100, 50, 100, 50]) 0 >>> min_difference(2, [1, 2]) 1","solution":"from itertools import combinations def min_difference(n, skill_array): Returns the minimum difference between the sums of skill levels of two balanced teams. total_sum = sum(skill_array) half_n = n // 2 minimum_difference = float('inf') for team in combinations(skill_array, half_n): team_sum = sum(team) other_team_sum = total_sum - team_sum difference = abs(team_sum - other_team_sum) minimum_difference = min(minimum_difference, difference) return minimum_difference # Example usage n = 6 skill_array = [1, 2, 3, 4, 5, 6] print(min_difference(n, skill_array)) # Output: 1"},{"question":"from typing import List def manage_projects(n: int, q: int, initial_costs: List[int], operations: List[str]) -> List[int]: Manage the project costs based on given operations and return the results of GET operations. Parameters: n (int): Number of projects q (int): Number of operations initial_costs (list): List of initial costs of the projects operations (list): List of operations to be performed on the projects Returns: list: Results of all GET operations in the order they are encountered pass # Example usage and test cases if __name__ == \\"__main__\\": def test_example_case(): n = 5 q = 7 initial_costs = [10, 20, 30, 40, 50] operations = [ \\"SET 3 100\\", \\"ADD 2 15\\", \\"SUB 4 5\\", \\"MUL 1 2\\", \\"DIV 5 10\\", \\"GET 3\\", \\"GET 5\\" ] assert manage_projects(n, q, initial_costs, operations) == [100, 5] def test_set_operation(): n = 3 q = 3 initial_costs = [50, 60, 70] operations = [ \\"SET 1 55\\", \\"SET 2 65\\", \\"GET 1\\" ] assert manage_projects(n, q, initial_costs, operations) == [55] def test_add_operation(): n = 3 q = 3 initial_costs = [50, 60, 70] operations = [ \\"ADD 1 5\\", \\"ADD 2 10\\", \\"GET 1\\" ] assert manage_projects(n, q, initial_costs, operations) == [55] def test_sub_operation(): n = 3 q = 3 initial_costs = [50, 60, 70] operations = [ \\"SUB 1 5\\", \\"SUB 2 10\\", \\"GET 1\\" ] assert manage_projects(n, q, initial_costs, operations) == [45] def test_mul_operation(): n = 3 q = 3 initial_costs = [5, 6, 7] operations = [ \\"MUL 1 2\\", \\"MUL 2 3\\", \\"GET 1\\" ] assert manage_projects(n, q, initial_costs, operations) == [10] def test_div_operation(): n = 3 q = 3 initial_costs = [50, 60, 70] operations = [ \\"DIV 1 5\\", \\"DIV 2 6\\", \\"GET 1\\" ] assert manage_projects(n, q, initial_costs, operations) == [10] def test_compound_operations(): n = 4 q = 8 initial_costs = [10, 20, 30, 40] operations = [ \\"SET 2 100\\", \\"ADD 1 10\\", \\"SUB 4 5\\", \\"MUL 3 3\\", \\"DIV 2 4\\", \\"GET 1\\", \\"GET 2\\", \\"GET 4\\", ] expected_result = [20, 25, 35] assert manage_projects(n, q, initial_costs, operations) == expected_result # Run tests test_example_case() test_set_operation() test_add_operation() test_sub_operation() test_mul_operation() test_div_operation() test_compound_operations() print(\\"All tests passed.\\")","solution":"def manage_projects(n, q, initial_costs, operations): Manage the project costs based on given operations and return the results of GET operations. Parameters: n (int): Number of projects q (int): Number of operations initial_costs (list): List of initial costs of the projects operations (list): List of operations to be performed on the projects Returns: list: Results of all GET operations in the order they are encountered costs = initial_costs[:] results = [] for operation in operations: parts = operation.split() command = parts[0] i = int(parts[1]) - 1 # Convert to 0-based index if command == 'SET': x = int(parts[2]) costs[i] = x elif command == 'ADD': x = int(parts[2]) costs[i] += x elif command == 'SUB': x = int(parts[2]) costs[i] -= x elif command == 'MUL': x = int(parts[2]) costs[i] *= x elif command == 'DIV': x = int(parts[2]) costs[i] //= x elif command == 'GET': results.append(costs[i]) return results"},{"question":"def min_energy_to_reach_destination(n: int, m: int, grid: List[str]) -> int: Determine the minimum amount of energy required for Manao to reach the destination in a grid, or -1 if it is impossible. Args: n (int): The number of rows in the grid. m (int): The number of columns in the grid. grid (List[str]): The grid representation with 'S' as start, 'D' as destination, '.' as empty cells, and '#' as obstacles. Returns: int: The minimum amount of energy required to reach the destination or -1 if it is not possible. >>> min_energy_to_reach_destination(5, 5, [\\"S....\\", \\".#...\\", \\"..#..\\", \\"...#D\\", \\".....\\"]) 7 >>> min_energy_to_reach_destination(5, 5, [\\"S....\\", \\"#\\", \\"..#..\\", \\"...#D\\", \\".....\\"]) -1 >>> min_energy_to_reach_destination(1, 5, [\\"SD...\\"]) 1 >>> min_energy_to_reach_destination(2, 5, [\\"S#.\\", \\"D\\"]) -1 >>> min_energy_to_reach_destination(1, 21, [\\"S...................D\\"]) 20 pass","solution":"from collections import deque def min_energy_to_reach_destination(n, m, grid): # Find the start and destination points start = end = None for i in range(n): for j in range(m): if grid[i][j] == 'S': start = (i, j) elif grid[i][j] == 'D': end = (i, j) # Breadth-First Search (BFS) to find the shortest path queue = deque([(start[0], start[1], 0)]) # row, col, energy visited = set() visited.add((start[0], start[1])) while queue: x, y, energy = queue.popleft() if (x, y) == end: return energy # Check the four possible directions (up, down, left, right) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and (nx, ny) not in visited and grid[nx][ny] != '#': visited.add((nx, ny)) queue.append((nx, ny, energy + 1)) return -1"},{"question":"def encode_message(s: str) -> str: Encodes the input string by replacing consecutive occurrences of the same character with the character followed by the number of occurrences. If a character appears alone, it is left unchanged. :param s: The input string to be encoded :return: Encoded string >>> encode_message(\\"aaaabbcdddde\\") 'a4b2cd4e' >>> encode_message(\\"hellooooooo\\") 'hel2o7' >>> encode_message(\\"a\\") 'a' >>> encode_message(\\"abcdef\\") 'abcdef' >>> encode_message(\\"aaaaa\\") 'a5' >>> encode_message(\\"a\\"*100) 'a100'","solution":"def encode_message(s): Encodes the input string by replacing consecutive occurrences of the same character with the character followed by the number of occurrences. If a character appears alone, it is left unchanged. :param s: The input string to be encoded :return: Encoded string if not s: return \\"\\" encoded = [] count = 1 prev_char = s[0] for char in s[1:]: if char == prev_char: count += 1 else: if count > 1: encoded.append(f\\"{prev_char}{count}\\") else: encoded.append(prev_char) prev_char = char count = 1 # Add the last sequence if count > 1: encoded.append(f\\"{prev_char}{count}\\") else: encoded.append(prev_char) return ''.join(encoded)"},{"question":"def max_distinct_genres(N: int, S: str) -> int: Returns the maximum number of distinct genres that can be placed on a shelf of capacity N, given the string S which represents the genres of the books. >>> max_distinct_genres(7, \\"aabbcce\\") 4 >>> max_distinct_genres(3, \\"aabbcce\\") 2 >>> max_distinct_genres(7, \\"aaaaaaa\\") 1 >>> max_distinct_genres(1, \\"a\\") 1 >>> max_distinct_genres(100, \\"abcde\\") 5 >>> max_distinct_genres(4, \\"abcdef\\") 4 >>> max_distinct_genres(10, \\"aaaaabbbbcccccddddeee\\") 3","solution":"def max_distinct_genres(N, S): Returns the maximum number of distinct genres that can be placed on a shelf of capacity N, given the string S which represents the genres of the books. :param N: int, the capacity of the shelf :param S: str, a string of lowercase letters representing genres of the books :return: int, the maximum number of distinct genres that can be placed on the shelf distinct_genres = set(S[:N]) return min(len(distinct_genres), N)"},{"question":"def twinster_park(m: int, k: int, preferences: List[Tuple[int, int]]) -> Union[int, List[Tuple[int, int]]]: Determine if it is possible to accommodate the Twinsters such that all of them are happy. If possible, return a valid arrangement. Otherwise, return -1. :param m: Integer, number of benches :param k: Integer, number of Twinsters pairs :param preferences: List of tuples (Li, Ri), where Li is the preferred bench for left-loving Twinster and Ri is the preferred bench for right-loving Twinster. :return: -1 if no valid arrangement is possible, otherwise a list of tuples (Li, Ri) >>> twinster_park(5, 3, [(1, 2), (3, 4), (5, 1)]) [(1, 2), (3, 4), (5, 1)] >>> twinster_park(5, 3, [(1, 2), (1, 4), (5, 1)]) -1 >>> twinster_park(5, 3, [(1, 2), (3, 2), (5, 1)]) -1 >>> twinster_park(5, 3, [(1, 1), (3, 4), (5, 2)]) -1 >>> twinster_park(3, 1, [(1, 2)]) [(1, 2)] >>> twinster_park(100000, 100000, [(i, i+1) for i in range(1, 100001)]) [(i, i+1) for i in range(1, 100001)]","solution":"def twinster_park(m, k, preferences): Determine if it is possible to accommodate the Twinsters such that all of them are happy. If possible, return a valid arrangement. Otherwise, return -1. :param m: Integer, number of benches :param k: Integer, number of Twinsters pairs :param preferences: List of tuples (Li, Ri), where Li is the preferred bench for left-loving Twinster and Ri is the preferred bench for right-loving Twinster. :return: -1 if no valid arrangement is possible, otherwise a list of tuples (Li, Ri) left_set = set() right_set = set() for Li, Ri in preferences: if Li in left_set or Ri in right_set or Li == Ri: return -1 left_set.add(Li) right_set.add(Ri) return preferences"},{"question":"from typing import List, Tuple def process_queries(n: int, array: List[int], q: int, queries: List[List[int]]) -> List[str]: Given an array A of N integers, process Q queries where: - Query type 1 updates the array: 1 index value - Query type 2 computes the sum of a subarray and returns \\"Even\\" if the sum is even, \\"Odd\\" if the sum is odd: 2 left right Args: n (int): Size of the array array (List[int]): The array of N integers q (int): Number of queries queries (List[List[int]]): The list of queries Returns: List[str]: The results of all range queries (\\"Even\\" or \\"Odd\\") >>> process_queries(5, [1, 2, 3, 4, 5], 3, [[2, 0, 4], [1, 2, 10], [2, 0, 4]]) ['Odd', 'Even'] >>> process_queries(4, [2, 4, 6, 8], 4, [[2, 0, 3], [1, 1, 3], [2, 0, 3], [1, 0, 1]]) ['Even', 'Odd']","solution":"class ArrayProcessor: def __init__(self, array): self.array = array self.cummulative_sum = self._precompute_cummulative_sum() def _precompute_cummulative_sum(self): csum = [0] * (len(self.array) + 1) for i in range(1, len(csum)): csum[i] = csum[i - 1] + self.array[i - 1] return csum def update(self, index, value): original_value = self.array[index] self.array[index] = value # Update the cummulative sum array from the index onwards for i in range(index + 1, len(self.cummulative_sum)): self.cummulative_sum[i] = self.cummulative_sum[i] - original_value + value def range_query(self, left, right): range_sum = self.cummulative_sum[right + 1] - self.cummulative_sum[left] if range_sum % 2 == 0: return \\"Even\\" else: return \\"Odd\\" def process_queries(n, array, q, queries): processor = ArrayProcessor(array) results = [] for query in queries: if query[0] == 1: _, index, value = query processor.update(index, value) elif query[0] == 2: _, left, right = query result = processor.range_query(left, right) results.append(result) return results"},{"question":"def consecutive_sum_ways(n: int) -> int: Given the number 'n', find the number of ways to write n as the sum of two or more consecutive integers. >>> consecutive_sum_ways(15) 3 >>> consecutive_sum_ways(1) 0 >>> consecutive_sum_ways(9) 2 >>> consecutive_sum_ways(10) 1 >>> consecutive_sum_ways(100) 2","solution":"def consecutive_sum_ways(n): Returns the number of ways to write the integer n as the sum of two or more consecutive integers. count = 0 L = 1 while L * (L + 1) < 2 * n: a = (1.0 * n - (L * (L + 1)) / 2) / (L + 1) if a - int(a) == 0.0: count += 1 L += 1 return count"},{"question":"from typing import List, Tuple def min_cost_to_achieve_ratio(N: int, P_a: int, P_b: int, packages: List[Tuple[int, int, int]]) -> int: Find the minimum cost to create a mixture that adheres to the required ratio of apple to orange juice. If it is impossible to achieve the exact ratio with the available packages, output \`-1\`. Args: N (int): Number of available packages. P_a (int): Required ratio part for apple juice. P_b (int): Required ratio part for orange juice. packages (List[Tuple[int, int, int]]): List of tuples where each tuple contains three integers (a_i, b_i, c_i) representing the amount of apple juice, orange juice, and cost of the package. Returns: int: Minimum cost to achieve the required ratio, or \`-1\` if it is not possible. Examples: >>> min_cost_to_achieve_ratio(4, 1, 2, [(1, 2, 3), (2, 4, 5), (3, 6, 8), (6, 12, 10)]) 3 >>> min_cost_to_achieve_ratio(2, 3, 1, [(3, 1, 4), (1, 2, 6)]) 4 from itertools import product import numpy as np def test_case_1(): N = 4 P_a = 1 P_b = 2 packages = [(1, 2, 3), (2, 4, 5), (3, 6, 8), (6, 12, 10)] assert min_cost_to_achieve_ratio(N, P_a, P_b, packages) == 3 def test_case_2(): N = 2 P_a = 3 P_b = 1 packages = [(3, 1, 4), (1, 2, 6)] assert min_cost_to_achieve_ratio(N, P_a, P_b, packages) == 4 def test_case_3(): N = 2 P_a = 3 P_b = 2 packages = [(3, 2, 5), (3, 2, 6)] assert min_cost_to_achieve_ratio(N, P_a, P_b, packages) == 5 def test_case_4(): N = 1 P_a = 2 P_b = 3 packages = [(2, 3, 8)] assert min_cost_to_achieve_ratio(N, P_a, P_b, packages) == 8 def test_case_5(): N = 3 P_a = 4 P_b = 5 packages = [(8, 10, 20), (4, 5, 9), (2, 3, 12)] assert min_cost_to_achieve_ratio(N, P_a, P_b, packages) == 9 def test_impossible_case(): N = 2 P_a = 1 P_b = 1 packages = [(1, 2, 5), (2, 4, 10)] assert min_cost_to_achieve_ratio(N, P_a, P_b, packages) == -1","solution":"from itertools import product import numpy as np def min_cost_to_achieve_ratio(N, P_a, P_b, packages): max_juice = 20 * N INF = float('inf') dp = np.full((max_juice + 1, max_juice + 1), INF) dp[0][0] = 0 for a, b, c in packages: for i in range(max_juice, a - 1, -1): for j in range(max_juice, b - 1, -1): dp[i][j] = min(dp[i][j], dp[i - a][j - b] + c) answer = INF for i in range(1, max_juice // P_a + 1): if P_a * i <= max_juice and P_b * i <= max_juice: answer = min(answer, dp[P_a * i][P_b * i]) return answer if answer != INF else -1 # Parse input def main(): import sys input = sys.stdin.read data = input().split() N = int(data[0]) P_a = int(data[1]) P_b = int(data[2]) packages = [] for i in range(N): a_i = int(data[3 + 3 * i]) b_i = int(data[4 + 3 * i]) c_i = int(data[5 + 3 * i]) packages.append((a_i, b_i, c_i)) print(min_cost_to_achieve_ratio(N, P_a, P_b, packages))"},{"question":"def process_queries(n, arr, q, queries): Processes the array operations as per the given queries. Parameters: n (int): Length of the array arr (list of int): The initial array elements q (int): The number of queries queries (list of list of int): The queries to process Returns: list of int: Results of the second type queries # Unit Tests def test_process_queries_example(): n = 6 arr = [1, 2, 3, 4, 5, 6] q = 5 queries = [ [2, 1, 3], [1, 3, 10], [2, 1, 3], [2, 4, 6], [1, 5, 20] ] expected = [6, 13, 15] assert process_queries(n, arr, q, queries) == expected def test_process_queries_all_updates(): n = 5 arr = [1, 2, 3, 4, 5] q = 2 queries = [ [1, 1, 10], [1, 5, 20] ] expected = [] assert process_queries(n, arr, q, queries) == expected def test_process_queries_single_range_sum(): n = 4 arr = [10, 20, 30, 40] q = 1 queries = [ [2, 2, 3] ] expected = [50] assert process_queries(n, arr, q, queries) == expected def test_process_queries_multiple_types(): n = 3 arr = [1, 2, 3] q = 3 queries = [ [1, 2, 10], [2, 1, 2], [2, 1, 3] ] expected = [11, 14] assert process_queries(n, arr, q, queries) == expected","solution":"def process_queries(n, arr, q, queries): Processes the array operations as per the given queries. Parameters: n (int): Length of the array arr (list of int): The initial array elements q (int): The number of queries queries (list of list of int): The queries to process Returns: list of int: Results of the second type queries results = [] for query in queries: if query[0] == 1: # Update query pos, x = query[1], query[2] arr[pos - 1] = x elif query[0] == 2: # Sum query l, r = query[1], query[2] results.append(sum(arr[l-1:r])) return results"},{"question":"def min_substrings(s: str) -> int: Returns the minimum number of substrings such that no letter occurs more than once in each substring. >>> min_substrings('a') == 1 >>> min_substrings('abc') == 1 >>> min_substrings('abac') == 2 >>> min_substrings('aaaa') == 4 >>> min_substrings('abacabad') == 4 >>> min_substrings('abcdefghijklmna') == 2 >>> min_substrings('abcdabcda') == 3 >>> min_substrings('abcdabcdb') == 3","solution":"def min_substrings(s): Returns the minimum number of substrings such that no letter occurs more than once in each substring. substrings = 1 # at least one substring is needed seen = set() for ch in s: if ch in seen: substrings += 1 seen = set() seen.add(ch) return substrings"},{"question":"def minimal_maintenance_cost(n: int, m: int, highways: List[Tuple[int, int, int]]) -> int: Returns the minimal maintenance cost required to keep the road network connected. If it is impossible to keep all cities connected, returns -1. >>> minimal_maintenance_cost(4, 5, [(1, 2, 3), (2, 3, 4), (3, 4, 5), (4, 1, 2), (1, 3, 10)]) 9 >>> minimal_maintenance_cost(3, 3, [(1, 2, 1), (2, 3, 2), (1, 3, 3)]) 3 >>> minimal_maintenance_cost(4, 2, [(1, 2, 3), (3, 4, 4)]) -1 >>> minimal_maintenance_cost(1, 0, []) 0 >>> minimal_maintenance_cost(3, 3, [(1, 2, 2), (2, 3, 2), (1, 3, 2)]) 4","solution":"def minimal_maintenance_cost(n, m, highways): Returns the minimal maintenance cost required to keep the road network connected. If it is impossible to keep all cities connected, returns -1. parent = [i for i in range(n)] rank = [0] * n def find_set(v): if v != parent[v]: parent[v] = find_set(parent[v]) return parent[v] def union_sets(v1, v2): root1 = find_set(v1) root2 = find_set(v2) if root1 != root2: if rank[root1] > rank[root2]: parent[root2] = root1 else: parent[root1] = root2 if rank[root1] == rank[root2]: rank[root2] += 1 if n == 1: return 0 if m == 0 else min(cost for u, v, cost in highways) if m == 0: return -1 highways.sort(key=lambda x: x[2]) total_cost = 0 edges_used = 0 for u, v, cost in highways: set_u = find_set(u - 1) set_v = find_set(v - 1) if set_u != set_v: total_cost += cost union_sets(set_u, set_v) edges_used += 1 if edges_used == n - 1: break return total_cost if edges_used == n - 1 else -1"},{"question":"from typing import Optional class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def diameterOfBinaryTree(root: Optional[TreeNode]) -> int: Returns the diameter of the binary tree. The diameter is defined as the length of the longest path between any two nodes in the tree. >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> root.left.left = TreeNode(4) >>> root.left.right = TreeNode(5) >>> print(diameterOfBinaryTree(root)) 3 >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> print(diameterOfBinaryTree(root)) 2","solution":"from typing import Optional class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def diameterOfBinaryTree(root: Optional[TreeNode]) -> int: Returns the diameter of the binary tree. The diameter is defined as the length of the longest path between any two nodes in the tree. def depth(node): nonlocal diameter if not node: return 0 left_depth = depth(node.left) right_depth = depth(node.right) diameter = max(diameter, left_depth + right_depth) return 1 + max(left_depth, right_depth) diameter = 0 depth(root) return diameter"},{"question":"def max_non_overlapping_intervals(n, intervals): Determines the maximum number of non-overlapping time windows. Args: n (int): The number of ingredients (intervals). intervals (list of tuples): Each tuple contains two integers representing the start and end times of the time window for an ingredient. Returns: int: The maximum number of non-overlapping intervals. Examples: >>> max_non_overlapping_intervals(4, [(1, 3), (2, 5), (4, 6), (7, 8)]) 3 >>> max_non_overlapping_intervals(4, [(1, 2), (3, 4), (5, 6), (7, 8)]) 4 >>> max_non_overlapping_intervals(4, [(1, 10), (2, 9), (3, 8), (4, 7)]) 1 from solution import max_non_overlapping_intervals def test_example_case(): intervals = [(1, 3), (2, 5), (4, 6), (7, 8)] assert max_non_overlapping_intervals(4, intervals) == 3 def test_no_overlapping_intervals(): intervals = [(1, 2), (3, 4), (5, 6), (7, 8)] assert max_non_overlapping_intervals(4, intervals) == 4 def test_all_overlapping_intervals(): intervals = [(1, 10), (2, 9), (3, 8), (4, 7)] assert max_non_overlapping_intervals(4, intervals) == 1 def test_some_overlapping_intervals(): intervals = [(1, 2), (2, 3), (3, 4), (4, 5)] assert max_non_overlapping_intervals(4, intervals) == 4 def test_single_interval(): intervals = [(1, 10)] assert max_non_overlapping_intervals(1, intervals) == 1 def test_large_number_of_intervals(): intervals = [(i, i+1) for i in range(1,1001,2)] assert max_non_overlapping_intervals(500, intervals) == 500","solution":"def max_non_overlapping_intervals(n, intervals): Determines the maximum number of non-overlapping time windows. Args: n (int): The number of ingredients (intervals). intervals (list of tuples): Each tuple contains two integers representing the start and end times of the time window for an ingredient. Returns: int: The maximum number of non-overlapping intervals. # Sort intervals by their end times intervals.sort(key=lambda x: x[1]) max_intervals = 0 current_end = 0 for start, end in intervals: if start >= current_end: max_intervals += 1 current_end = end return max_intervals"},{"question":"from typing import List, Tuple def can_make_all_elements_equal(n: int, arr: List[int]) -> str: Returns \\"YES\\" if it is possible to make all elements equal, otherwise \\"NO\\". >>> can_make_all_elements_equal(3, [4, 8, 12]) \\"YES\\" >>> can_make_all_elements_equal(4, [2, 3, 6, 9]) \\"NO\\" >>> can_make_all_elements_equal(2, [5, 10]) \\"YES\\" pass def process_test_cases(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[str]: Processes multiple test cases and returns a list of results. >>> process_test_cases(3, [(3, [4, 8, 12]), (4, [2, 3, 6, 9]), (2, [5, 10])]) [\\"YES\\", \\"NO\\", \\"YES\\"] pass def input_processing(input_str: str) -> Tuple[int, List[Tuple[int, List[int]]]]: Processes the input string to extract test cases. >>> input_processing(\\"3n3n4 8 12n4n2 3 6 9n2n5 10n\\") (3, [(3, [4, 8, 12]), (4, [2, 3, 6, 9]), (2, [5, 10])]) pass if __name__ == \\"__main__\\": import sys input_str = sys.stdin.read() t, test_cases = input_processing(input_str) results = process_test_cases(t, test_cases) for result in results: print(result)","solution":"import math from functools import reduce def can_make_all_elements_equal(n, arr): Returns \\"YES\\" if it is possible to make all elements equal, otherwise \\"NO\\". gcd_all = reduce(math.gcd, arr) return \\"YES\\" if gcd_all != 1 else \\"NO\\" def process_test_cases(t, test_cases): results = [] for n, arr in test_cases: result = can_make_all_elements_equal(n, arr) results.append(result) return results def input_processing(input_str): lines = input_str.strip().split(\\"n\\") t = int(lines[0]) test_cases = [] index = 1 for _ in range(t): n = int(lines[index]) arr = list(map(int, lines[index + 1].split())) test_cases.append((n, arr)) index += 2 return t, test_cases"},{"question":"def distribute_data(data: List[int], capacities: List[int]) -> List[int]: Distributes data requests to data centers such that the difference in total storage used between any two data centers is minimized. Parameters: data (list): List of integers representing data requests. capacities (list): List of integers representing the storage capacities of each data center. Returns: list: List of integers representing the total storage used by each data center. Examples: >>> distribute_data([10, 20, 30, 40, 50], [100, 100, 100]) [60, 60, 30] >>> distribute_data([10, 20, 30, 40, 50], [100]) [150] >>> distribute_data([10, 10, 10, 10, 10, 10], [30, 30]) [30, 30] >>> distribute_data([i for i in range(1, 101)], [500, 300, 200]) [2550, 2550, 2550] >>> distribute_data([1, 1, 1, 1], [3, 3, 3, 3]) [1, 1, 1, 1] >>> distribute_data([5, 5, 5, 5, 5], [10, 10]) [15, 15]","solution":"def distribute_data(data, capacities): Distributes data requests to data centers such that the difference in total storage used between any two data centers is minimized. Parameters: data (list): List of integers representing data requests. capacities (list): List of integers representing the storage capacities of each data center. Returns: list: List of integers representing the total storage used by each data center. from heapq import heappush, heappop # Initialize min heap with (used_storage, index) tuples min_heap = [(0, i) for i in range(len(capacities))] # Sort the data to optimize distribution data.sort(reverse=True) for d in data: # Pop the data center with the least used storage used_storage, idx = heappop(min_heap) # Update the used storage for this data center used_storage += d # Push back the updated (used_storage, index) heappush(min_heap, (used_storage, idx)) # Extract the used storage values in order of data center indices result = [0] * len(capacities) while min_heap: used_storage, idx = heappop(min_heap) result[idx] = used_storage return result"},{"question":"def max_min_diff_of_subsets(t: int, friends_data: List[List[int]]) -> List[int]: Several friends have bought new homes recently and are planning to paint their home interiors. Each friend has bought a different set of paint cans, and they want to paint their rooms such that the total color variation within the room is minimized. Specifically, every room to be painted is in the shape of a rectangular Cartesian coordinate system. The rooms must be painted by selecting a subset of colors from the paint cans available to each friend. Each paint can is identified by an integer value representing its color strength. The goal is to find the subset of colors that maximizes the minimum difference between the maximum and minimum color strengths used for each room. Your task is to help each friend by figuring out the correct choice of paint colors. input ----- t: int The number of friends. friends_data: List[List[int]] Each element is a list of n integers representing the color strengths of the paint cans. output ------ List[int] The maximum possible minimum difference between the maximum and minimum color strengths for each friend's rooms. >>> max_min_diff_of_subsets(2, [[1, 3, 4, 6, 8], [10, 20, 30, 40]]) == [1, 10] >>> max_min_diff_of_subsets(1, [[5]]) == [0] >>> max_min_diff_of_subsets(1, [[5, 10]]) == [5] >>> max_min_diff_of_subsets(1, [[1, 10, 20, 30, 40]]) == [9] >>> max_min_diff_of_subsets(1, [[5, 5, 5, 5]]) == [0]","solution":"def max_min_diff_of_subsets(t, friends_data): results = [] for i in range(t): paint_cans = sorted(friends_data[i]) n = len(paint_cans) if n < 2: results.append(0) # If there is only one or zero paint cans, the minimum difference is 0 continue min_diff = float('inf') for j in range(1, n): min_diff = min(min_diff, paint_cans[j] - paint_cans[j - 1]) results.append(min_diff) return results # Example usage: t = 2 friends_data = [ [1, 3, 4, 6, 8], [10, 20, 30, 40] ] print(max_min_diff_of_subsets(t, friends_data)) # Output: [1, 10]"},{"question":"from typing import List def can_partition(nums: List[int]) -> List[List[int]]: Determines if a given list of integers can be split into two sub-lists such that the sum of the integers in each sub-list is equal. If the list can be split in such a way, return the two sub-lists. If not, return an empty list. >>> can_partition([1, 5, 11, 5]) [[1, 5, 5], [11]] >>> can_partition([1, 2, 3, 5]) []","solution":"def can_partition(nums): Determines if a given list of integers can be split into two sub-lists such that the sum of the integers in each sub-list is equal. If the list can be split in such a way, return the two sub-lists. If not, return an empty list. total_sum = sum(nums) # If the total sum is odd, it is not possible to split it into equal sum subsets. if total_sum % 2 != 0: return [] target = total_sum // 2 n = len(nums) dp = [False] * (target + 1) dp[0] = True for num in nums: for j in range(target, num - 1, -1): dp[j] = dp[j] or dp[j - num] if not dp[target]: return [] def find_subsets(idx, current_sum, path): if current_sum == target: return path if current_sum > target or idx >= n: return None # include current number subset_with_num = find_subsets(idx + 1, current_sum + nums[idx], path + [nums[idx]]) if subset_with_num: return subset_with_num # exclude current number subset_without_num = find_subsets(idx + 1, current_sum, path) if subset_without_num: return subset_without_num return None subset = find_subsets(0, 0, []) if not subset: return [] nums_copy = nums[:] for num in subset: nums_copy.remove(num) return [subset, nums_copy]"},{"question":"def sort_test_cases(test_cases: List[Tuple[int, ...]]) -> List[List[int]]: Sorts each test case array and returns the sorted arrays. Parameters: test_cases (list of tuples): Each tuple containing a test case array. Returns: list of lists: Sorted versions of the input arrays. Examples: >>> sort_test_cases([(5, 3, 1, 4, 1, 5)]) == [[1, 1, 3, 4, 5]] >>> sort_test_cases([(3, 10, 20, 30), (4, 100, 50, 25, 25)]) == [[10, 20, 30], [25, 25, 50, 100]] pass # Test cases from solution import sort_test_cases def test_single_test_case(): test_cases = [(5, 3, 1, 4, 1, 5)] expected = [[1, 1, 3, 4, 5]] assert sort_test_cases(test_cases) == expected def test_multiple_test_cases(): test_cases = [(3, 10, 20, 30), (4, 100, 50, 25, 25)] expected = [[10, 20, 30], [25, 25, 50, 100]] assert sort_test_cases(test_cases) == expected def test_empty_array(): test_cases = [(1,)] expected = [[]] assert sort_test_cases(test_cases) == expected def test_large_random_case(): n = 1000000 import random test_cases = [(n,) + tuple(random.sample(range(1, n + 1), n))] result = sort_test_cases(test_cases)[0] assert result == sorted(result) def test_mixed_length_arrays(): test_cases = [(1, 5), (2, 2, 1), (3, 7, 8, 9)] expected = [[5], [1, 2], [7, 8, 9]] assert sort_test_cases(test_cases) == expected","solution":"def sort_test_cases(test_cases): Sorts each test case array and returns the sorted arrays. Parameters: test_cases (list): A list of tuples, each tuple containing a test case array. Returns: list: A list of sorted arrays. sorted_arrays = [] for test_case in test_cases: n, *arr = test_case sorted_array = sorted(arr) sorted_arrays.append(sorted_array) return sorted_arrays"},{"question":"def calculate_bookings(bookings, a, b): Calculates the total number of customers booked from day a to day b (inclusive). Parameters: bookings (list of tuple): List of tuples where each tuple contains (day, customers). a (int): Start day of the range (inclusive). b (int): End day of the range (inclusive). Returns: int: Total number of customers booked from day a to day b. pass def test_calculate_bookings(): bookings1 = [(1, 5), (10, 2), (15, 3)] assert calculate_bookings(bookings1, 1, 10) == 7 bookings2 = [(2, 8), (5, 6), (8, 4), (12, 10), (16, 2)] assert calculate_bookings(bookings2, 3, 9) == 10 bookings3 = [(3, 5), (6, 10), (9, 2)] assert calculate_bookings(bookings3, 1, 4) == 5 bookings4 = [(1, 100), (2, 100), (3, 100), (4, 100)] assert calculate_bookings(bookings4, 1, 365) == 400 bookings5 = [(100, 50), (200, 75), (300, 25)] assert calculate_bookings(bookings5, 150, 250) == 75 import pytest if __name__ == \\"__main__\\": pytest.main()","solution":"def calculate_bookings(bookings, a, b): Calculates the total number of customers booked from day a to day b (inclusive). Parameters: bookings (list of tuple): List of tuples where each tuple contains (day, customers). a (int): Start day of the range (inclusive). b (int): End day of the range (inclusive). Returns: int: Total number of customers booked from day a to day b. total_customers = 0 for day, customers in bookings: if a <= day <= b: total_customers += customers return total_customers if __name__ == \\"__main__\\": import sys input = sys.stdin.read data = input().split() D = int(data[0]) bookings = [] for i in range(1, 2 * D, 2): day = int(data[i]) customers = int(data[i+1]) bookings.append((day, customers)) a = int(data[2 * D + 1]) b = int(data[2 * D + 2]) print(calculate_bookings(bookings, a, b))"},{"question":"def rotate_array(arr, k): Rotates the array to the right by k steps. Operates in-place and returns the rotated array for convenience. >>> rotate_array([1, 2, 3, 4, 5], 2) [4, 5, 1, 2, 3] >>> rotate_array([10, 20, 30, 40], 3) [20, 30, 40, 10] >>> rotate_array([1, 2, 3, 4, 5], 5) [1, 2, 3, 4, 5] >>> rotate_array([1, 2, 3, 4, 5], 0) [1, 2, 3, 4, 5] # Your code here def process_test_cases(test_cases): Process multiple test cases and return the corresponding results. >>> test_cases = [(5, [1, 2, 3, 4, 5], 2), (4, [10, 20, 30, 40], 3)] >>> process_test_cases(test_cases) [\\"4 5 1 2 3\\", \\"20 30 40 10\\"] >>> test_cases = [(3, [1, 2, 3], 1), (6, [1, 2, 3, 4, 5, 6], 4)] >>> process_test_cases(test_cases) [\\"3 1 2\\", \\"3 4 5 6 1 2\\"] # Your code here","solution":"def rotate_array(arr, k): Rotates the array to the right by k steps. Operates in-place and returns the rotated array for convenience. n = len(arr) k = k % n # To handle the case when k is larger than n arr[:] = arr[-k:] + arr[:-k] return arr def process_test_cases(test_cases): results = [] for test_case in test_cases: n, arr, k = test_case rotate_array(arr, k) results.append(\\" \\".join(map(str, arr))) return results"},{"question":"from typing import List def min_partition_diff(arr: List[int]) -> int: Partition the list into two non-empty parts such that the absolute difference between the sum of the elements in the two parts is minimized. Args: arr (List[int]): A list of integers. Returns: int: The minimum possible absolute difference between the sums of the two partitions. Examples: >>> min_partition_diff([1, 6, 11, 5]) 1 >>> min_partition_diff([3, 1, 4, 2, 2]) 0","solution":"def min_partition_diff(arr): from itertools import product total_sum = sum(arr) n = len(arr) # The minimum partition difference min_diff = float('inf') # Iterate through all possible subset combinations using bit-wise representation for mask in product([0, 1], repeat=n): subset_sum = sum(arr[i] if mask[i] else 0 for i in range(n)) other_sum = total_sum - subset_sum # Update the minimum partition difference current_diff = abs(subset_sum - other_sum) if current_diff < min_diff: min_diff = current_diff return min_diff"},{"question":"def detect_palindromes(text: str): Given a string \`text\` containing words, prints each word followed by \\"Yes\\" if it is a palindrome, otherwise \\"No\\". Each result is printed on a new line in the order the words appear in the input. Parameters: text (str): The input text containing words separated by spaces. Examples: >>> detect_palindromes(\\"madam racecar apple level radar\\") madam Yes racecar Yes apple No level Yes radar Yes >>> detect_palindromes(\\"hello world wow\\") hello No world No wow Yes","solution":"def detect_palindromes(text): Given a string \`text\` containing words, prints each word followed by \\"Yes\\" if it is a palindrome, otherwise \\"No\\". Each result is printed on a new line in the order the words appear in the input. Parameters: text (str): The input text containing words separated by spaces. words = text.split() for word in words: if word == word[::-1]: print(f\\"{word} Yes\\") else: print(f\\"{word} No\\")"},{"question":"def find_pair_indices(arr, target): Determine if there are two distinct elements in the array that add up to the target. If such a pair exists, return the indices of the two numbers (1-based index); otherwise, return \\"No pair found\\". >>> find_pair_indices([2, 7, 11, 15], 9) (1, 2) >>> find_pair_indices([1, 2, 3, 4, 5], 10) \\"No pair found\\" def process_test_cases(test_cases): Process multiple test cases to find pairs of indices for each case, if exist. >>> test_cases = [ >>> ([2, 7, 11, 15], 9), >>> ([1, 2, 3, 4, 5], 10) >>> ] >>> process_test_cases(test_cases) [\\"1 2\\", \\"No pair found\\"] from typing import List, Tuple, Union def test_find_pair_indices(): assert find_pair_indices([2, 7, 11, 15], 9) == (1, 2) assert find_pair_indices([1, 2, 3, 4, 5], 10) == \\"No pair found\\" assert find_pair_indices([-1, -2, -3, -4, -5], -8) == (3, 5) assert find_pair_indices([0, 1, 2, -1], 1) == (1, 2) assert find_pair_indices([3, 3], 6) == (1, 2) def test_process_test_cases(): test_cases = [ ([2, 7, 11, 15], 9), ([1, 2, 3, 4, 5], 10), ([-1, -2, -3, -4, -5], -8) ] assert process_test_cases(test_cases) == [\\"1 2\\", \\"No pair found\\", \\"3 5\\"] test_cases = [ ([0, 1, 2, -1], 1), ([3, 3], 6) ] assert process_test_cases(test_cases) == [\\"1 2\\", \\"1 2\\"]","solution":"def find_pair_indices(arr, target): value_to_index = {} for i, num in enumerate(arr): complement = target - num if complement in value_to_index: return value_to_index[complement] + 1, i + 1 value_to_index[num] = i return \\"No pair found\\" def process_test_cases(test_cases): results = [] for arr, target in test_cases: result = find_pair_indices(arr, target) if isinstance(result, tuple): results.append(f\\"{result[0]} {result[1]}\\") else: results.append(result) return results # Example of usage: # T = 2 # test_cases = [ # ([2, 7, 11, 15], 9), # ([1, 2, 3, 4, 5], 10) # ] # print(process_test_cases(test_cases))"},{"question":"def min_days_to_complete_tournament(n: int, k: int) -> int: Given the number of players n and the maximum number of matches k that can be held in a day, this function returns the minimum number of days required to complete the tournament. >>> min_days_to_complete_tournament(4, 2) 3 >>> min_days_to_complete_tournament(6, 5) 3 >>> min_days_to_complete_tournament(5, 3) 4 >>> min_days_to_complete_tournament(100, 100) 50 >>> min_days_to_complete_tournament(2, 1) 1 >>> min_days_to_complete_tournament(4, 1) 6 >>> min_days_to_complete_tournament(50, 25) 49","solution":"import math def min_days_to_complete_tournament(n, k): Given the number of players n and the maximum number of matches k that can be held in a day, this function returns the minimum number of days required to complete the tournament. # Calculate the total number of matches total_matches = n * (n - 1) // 2 # Calculate the minimum number of days required return math.ceil(total_matches / k)"},{"question":"def get_skyline(buildings): Compute the skyline for a given list of buildings. Each building is represented as [Li, Ri, Hi] Returns a list of (x, h) tuples representing key points of the skyline >>> get_skyline([(2, 9, 10), (3, 7, 15), (5, 12, 12), (15, 20, 10), (19, 24, 8)]) [(2, 10), (3, 15), (7, 12), (12, 0), (15, 10), (20, 8), (24, 0)] >>> get_skyline([(1, 5, 11)]) [(1, 11), (5, 0)] >>> get_skyline([(1, 5, 11), (6, 10, 12)]) [(1, 11), (5, 0), (6, 12), (10, 0)]","solution":"import heapq def get_skyline(buildings): Compute the skyline for a given list of buildings. Each building is represented as [Li, Ri, Hi] Returns a list of (x, h) tuples representing key points of the skyline events = [] for (L, R, H) in buildings: events.append((L, -H, R)) events.append((R, 0, 0)) events.sort() result, heap = [], [(0, float('inf'))] for x, negH, R in events: while heap[0][1] <= x: heapq.heappop(heap) if negH: heapq.heappush(heap, (negH, R)) if not result or result[-1][1] != -heap[0][0]: result.append((x, -heap[0][0])) return result"},{"question":"def count_visible_pillars(N: int, heights: List[int]) -> int: Returns the number of visible pillars. A pillar is considered visible if it is taller than both of its direct neighbors. pass # Example usage: N = 5 heights = [1, 3, 2, 4, 1] print(count_visible_pillars(N, heights)) # Should output 2 # Unit tests def test_example_1(): assert count_visible_pillars(5, [1, 3, 2, 4, 1]) == 2 def test_example_2(): assert count_visible_pillars(3, [2, 1, 2]) == 0 def test_example_3(): assert count_visible_pillars(6, [1, 5, 3, 7, 3, 5]) == 2 def test_no_visible_pillars(): assert count_visible_pillars(4, [4, 3, 2, 1]) == 0 def test_all_pillars_same_height(): assert count_visible_pillars(5, [3, 3, 3, 3, 3]) == 0 def test_alternating_heights(): assert count_visible_pillars(7, [1, 3, 1, 3, 1, 3, 1]) == 3 def test_large_input(): N = 100000 heights = list(range(1, N+1)) assert count_visible_pillars(N, heights) == 0","solution":"def count_visible_pillars(N, heights): Returns the number of visible pillars. A pillar is considered visible if it is taller than both of its direct neighbors. visible_count = 0 for i in range(1, N-1): if heights[i] > heights[i-1] and heights[i] > heights[i+1]: visible_count += 1 return visible_count # Example usage: N = 5 heights = [1, 3, 2, 4, 1] print(count_visible_pillars(N, heights)) # Output: 2"},{"question":"from typing import List, Tuple def max_parcels(W: int, D: int, parcels: List[Tuple[int, int]]) -> int: Determine the maximum number of parcels that can be loaded into the truck without exceeding the weight limit or the maximum cargo bay dimension limit. >>> max_parcels(500, 5000, [(100, 1000), (200, 1500), (150, 2000), (120, 500), (80, 800)]) 4 >>> max_parcels(500, 5000, []) 0 >>> max_parcels(500, 5000, [(600, 1000), (700, 1500)]) 0 >>> max_parcels(300, 3000, [(100, 1000), (100, 1000), (100, 1000)]) 3 >>> max_parcels(300, 3000, [(100, 3000), (150, 1500), (50, 1000)]) 2 pass # Your implementation here","solution":"def max_parcels(W, D, parcels): n = len(parcels) parcels.sort(key=lambda x: (x[0], x[1])) # Sort parcels by weight then by dimension dp = [[0] * (D + 1) for _ in range(W + 1)] for i in range(n): p_w, p_d = parcels[i] for w in range(W, p_w - 1, -1): for d in range(D, p_d - 1, -1): dp[w][d] = max(dp[w][d], dp[w - p_w][d - p_d] + 1) return dp[W][D] # Example usage: W = 500 D = 5000 parcels = [(100, 1000), (200, 1500), (150, 2000), (120, 500), (80, 800)] print(max_parcels(W, D, parcels)) # Output: 4"},{"question":"def count_unique_productivity(t: int, test_cases: List[dict]) -> List[int]: Count the number of employees who will be rewarded based on their unique productivity scores for each test case. Each test case contains the number of employees, the range of productivity scores, and the scores themselves. The function should return a list containing the count of rewarded employees for each test case. >>> count_unique_productivity(3, [ ... {'n': 5, 'm': 10, 'scores': [1, 2, 3, 3, 4]}, ... {'n': 3, 'm': 5, 'scores': [1, 2, 2]}, ... {'n': 4, 'm': 15, 'scores': [5, 10, 10, 5]} ... ]) == [3, 1, 0] >>> count_unique_productivity(1, [ ... {'n': 5, 'm': 10, 'scores': [1, 2, 3, 4, 5]} ... ]) == [5] >>> count_unique_productivity(1, [ ... {'n': 4, 'm': 10, 'scores': [1, 1, 2, 2]} ... ]) == [0] >>> count_unique_productivity(2, [ ... {'n': 6, 'm': 10, 'scores': [1, 2, 3, 3, 4, 5]}, ... {'n': 5, 'm': 5, 'scores': [5, 5, 4, 4, 1]} ... ]) == [4, 1] >>> count_unique_productivity(1, [ ... {'n': 1, 'm': 1, 'scores': [1]} ... ]) == [1]","solution":"def count_unique_productivity(t, test_cases): results = [] for case in test_cases: n, m, scores = case['n'], case['m'], case['scores'] score_count = {} for score in scores: if score in score_count: score_count[score] += 1 else: score_count[score] = 1 unique_count = sum(1 for count in score_count.values() if count == 1) results.append(unique_count) return results"},{"question":"def is_pattern_in_string(s: str, p: str) -> str: Determines if pattern p can be found within string s with its characters in any order. >>> is_pattern_in_string('abcdefg', 'bca') == \\"YES\\" >>> is_pattern_in_string('abcdefgh', 'xyz') == \\"NO\\"","solution":"def is_pattern_in_string(s, p): Determines if pattern p can be found within string s with its characters in any order. from collections import Counter s_counter = Counter(s) p_counter = Counter(p) for char in p_counter: if p_counter[char] > s_counter.get(char, 0): return \\"NO\\" return \\"YES\\""},{"question":"def adjust_population(n: int, q: int, initial_populations: List[int], queries: List[Tuple[int, int]]) -> List[int]: Adjusts the population of each intersection based on the given queries. >>> adjust_population(5, 3, [10, 20, 30, 40, 50], [(1, 5), (2, 4), (4, 10)]) [15, 24, 30, 50, 50] >>> adjust_population(6, 4, [1, 2, 3, 4, 5, 6], [(1, 1), (3, 2), (2, 1), (6, 3)]) [2, 3, 5, 4, 5, 9] >>> adjust_population(4, 0, [10, 20, 30, 40], []) [10, 20, 30, 40] >>> adjust_population(3, 2, [1000000000, 1000000000, 1000000000], [(1, 999999999), (3, 1)]) [1999999999, 1000000000, 1000000001] >>> adjust_population(3, 3, [5, 10, 15], [(1, 4), (2, 3), (3, 2)]) [9, 13, 17]","solution":"def adjust_population(n, q, initial_populations, queries): Adjusts the population of each intersection based on the given queries. # Initialize the final populations as the initial populations final_populations = initial_populations.copy() # Process each query for u, p in queries: final_populations[u - 1] += p # Adjust population at intersection u return final_populations"},{"question":"def min_operations(n: int, initial_grid: List[int], final_grid: List[int]) -> int: Calculate the minimum number of operations required to transform initial grid configuration into final grid configuration. >>> min_operations(5, [3, 2, 1, 2, 1], [1, 1, 1, 2, 3]) 5 >>> min_operations(3, [1, 2, 3], [1, 2, 3]) 0 >>> min_operations(4, [1, 1, 1, 1], [2, 3, 4, 5]) 10 >>> min_operations(4, [5, 4, 3, 2], [1, 1, 1, 1]) 10 >>> min_operations(3, [2, 3, 1], [3, 2, 2]) 3 >>> min_operations(1, [5], [5]) 0 >>> min_operations(1, [0], [3]) 3 >>> min_operations(6, [0, 2, 3, 0, 4, 2], [1, 2, 2, 1, 3, 4]) 6","solution":"def min_operations(n, initial_grid, final_grid): operations = 0 excess_blocks = 0 for i in range(n): difference = final_grid[i] - initial_grid[i] if difference > 0: # Need to place blocks excess_blocks -= difference else: # Need to remove blocks excess_blocks += abs(difference) operations += abs(difference) # Return the total operations calculated return operations"},{"question":"def are_permutations(A, B): Returns 'YES' if array B is a permutation of array A, otherwise 'NO'. >>> are_permutations([1, 2, 3, 4], [4, 3, 2, 1]) 'YES' >>> are_permutations([1, 2, 3], [1, 2, 2]) 'NO'","solution":"def are_permutations(A, B): Returns 'YES' if array B is a permutation of array A, otherwise 'NO'. # Sort both arrays and compare if sorted(A) == sorted(B): return \\"YES\\" else: return \\"NO\\""},{"question":"def find_peak_element(nums): Find the index of a peak element in the given array. A peak element is an element that is strictly greater than its neighbors. If an element is at the start or end of the array, it is considered a peak if it is greater than its single neighbor. >>> find_peak_element([1, 3, 20, 4, 1]) in (1, 2) True >>> find_peak_element([10, 20, 15, 2, 23, 90, 67]) in (1, 5) True >>> find_peak_element([1]) == 0 True def process_test_cases(t, test_cases): Process multiple test cases to find peak elements. Given: 1. Number of test cases 't'. 2. 'test_cases', a list of tuples where each tuple contains: - an integer 'n' (length of the array) - a list of 'n' space-separated integers (the array) Returns: A list of indices of any peak elements for each test case. >>> test_cases = [(5, [1, 3, 20, 4, 1]), (6, [10, 20, 15, 2, 23, 90, 67])] >>> process_test_cases(2, test_cases) [1, 1]","solution":"def find_peak_element(nums): n = len(nums) if n == 0: return None if n == 1 or nums[0] >= nums[1]: return 0 if nums[n - 1] >= nums[n - 2]: return n - 1 for i in range(1, n - 1): if nums[i] >= nums[i - 1] and nums[i] >= nums[i + 1]: return i def process_test_cases(t, test_cases): results = [] for i in range(t): n, arr = test_cases[i] results.append(find_peak_element(arr)) return results"},{"question":"def length_of_longest_substring(s: str) -> int: Find the length of the longest substring without repeating characters. >>> length_of_longest_substring(\\"abcabcbb\\") 3 >>> length_of_longest_substring(\\"bbbbb\\") 1 >>> length_of_longest_substring(\\"pwwkew\\") 3 >>> length_of_longest_substring(\\"\\") 0 >>> length_of_longest_substring(\\"a\\") 1 >>> length_of_longest_substring(\\"abcdef\\") 6 >>> length_of_longest_substring(\\"abrkaabcdefghijjlmno\\") 10 >>> length_of_longest_substring(\\"aab\\") 2","solution":"def length_of_longest_substring(s): Returns the length of the longest substring without repeating characters. n = len(s) max_length = 0 char_index = {} start = 0 for end in range(n): if s[end] in char_index and char_index[s[end]] >= start: start = char_index[s[end]] + 1 char_index[s[end]] = end max_length = max(max_length, end - start + 1) return max_length # Debugging example print(length_of_longest_substring(\\"abcabcbb\\")) print(length_of_longest_substring(\\"bbbbb\\")) print(length_of_longest_substring(\\"pwwkew\\"))"},{"question":"class SequenceManipulator: def __init__(self, n: int, values: List[int]): Initialize the SequenceManipulator with the given list of values. Args: n (int): The length of the sequence. values (List[int]): The initial state of the sequence. pass def add(self, lf: int, rg: int, v: int): Perform add operation on the subarray. Args: lf (int): The left index of the subarray (inclusive). rg (int): The right index of the subarray (inclusive). v (int): The value to add to each element in the subarray. pass def get_sum(self, lf: int, rg: int) -> int: Get the sum of the elements in the subarray. Args: lf (int): The left index of the subarray (inclusive). rg (int): The right index of the subarray (inclusive). Returns: int: The sum of the elements in the subarray. pass # Unit Tests def test_add_and_get_sum(): # Initialize the SequenceManipulator with 7 elements seq_manip = SequenceManipulator(7, [1, 2, 3, 4, 5, 6, 7]) # Perform add operation: add 10 to indices 1 through 3 seq_manip.add(1, 3, 10) assert seq_manip.get_sum(0, 4) == 1 + (2 + 10) + (3 + 10) + (4 + 10) + 5 # Single element sum check after the addition operation assert seq_manip.get_sum(2, 2) == 13 # 3 + 10 # Perform another add operation: add 20 to indices 1 through 3 seq_manip.add(1, 5, 20) assert seq_manip.get_sum(3, 6) == (4 + 10 + 20) + (5 + 20) + (6 + 20) + 7 def test_large_operation(): seq_manip = SequenceManipulator(100000, [0] * 100000) # Add operation on a large range seq_manip.add(0, 99999, 5) assert seq_manip.get_sum(0, 99999) == 5 * 100000 # Get sum on a subrange assert seq_manip.get_sum(0, 49999) == 5 * 50000 assert seq_manip.get_sum(50000, 99999) == 5 * 50000","solution":"class SequenceManipulator: def __init__(self, n, values): self.n = n self.values = values self.prefix_sums = self._compute_prefix_sums() def _compute_prefix_sums(self): prefix_sums = [0] * (self.n + 1) for i in range(self.n): prefix_sums[i + 1] = prefix_sums[i] + self.values[i] return prefix_sums def add(self, lf, rg, v): for i in range(lf, rg + 1): self.values[i] += v self.prefix_sums = self._compute_prefix_sums() # Recalculate prefix sums def get_sum(self, lf, rg): return self.prefix_sums[rg + 1] - self.prefix_sums[lf]"},{"question":"from typing import List, Optional def find_most_frequent_sender(logs: List[str]) -> Optional[str]: Analyze email logs and identify the most frequent sender. If there is a tie, return the lexicographically smallest email address. >>> logs = [ ... \\"alice@example.com 2022-03-15 10:00:00\\", ... \\"bob@example.com 2022-03-15 11:00:00\\", ... \\"alice@example.com 2022-03-15 12:00:00\\", ... \\"charlie@example.com 2022-03-15 13:00:00\\", ... \\"bob@example.com 2022-03-15 14:00:00\\", ... \\"END\\" ... ] >>> find_most_frequent_sender(logs) \\"alice@example.com\\" >>> logs = [ ... \\"alice@example.com 2022-03-15 10:00:00\\", ... \\"bob@example.com 2022-03-15 11:00:00\\", ... \\"alice@example.com 2022-03-15 12:00:00\\", ... \\"bob@example.com 2022-03-15 14:00:00\\", ... \\"END\\" ... ] >>> find_most_frequent_sender(logs) \\"alice@example.com\\" >>> logs = [ ... \\"alice@example.com 2022-03-15 10:00:00\\", ... \\"END\\" ... ] >>> find_most_frequent_sender(logs) \\"alice@example.com\\" >>> logs = [\\"END\\"] >>> find_most_frequent_sender(logs) None","solution":"def find_most_frequent_sender(logs): from collections import defaultdict email_counts = defaultdict(int) for log in logs: if log.strip() == \\"END\\": break email_address = log.split()[0] email_counts[email_address] += 1 most_frequent_email = None highest_count = 0 for email, count in email_counts.items(): if count > highest_count or (count == highest_count and (most_frequent_email is None or email < most_frequent_email)): most_frequent_email = email highest_count = count return most_frequent_email"},{"question":"def get_next_number(num): Helper function to get the sum of the squares of digits of a number sum_of_squares = 0 while num: digit = num % 10 sum_of_squares += digit * digit num //= 10 return sum_of_squares def is_happy_number(n): Determines if a number n is a Happy Number or not. Args: n (int): positive integer to check for happiness. Returns: bool: True if n is a Happy Number, False otherwise. >>> is_happy_number(19) True >>> is_happy_number(2) False >>> is_happy_number(7) True >>> is_happy_number(1) True >>> is_happy_number(0) False def happy_number_checker(numbers): Checks a list of numbers and determines if each one is a Happy Number or not. Args: numbers (list): list of positive integers. Returns: list of str: \\"Happy\\" if the corresponding number is a Happy Number, \\"Unhappy\\" otherwise >>> happy_number_checker([19, 2, 7, 0]) [\\"Happy\\", \\"Unhappy\\", \\"Happy\\"] >>> happy_number_checker([1, 0]) [\\"Happy\\"] >>> happy_number_checker([20, 0]) [\\"Unhappy\\"] >>> happy_number_checker([111, 222, 0]) [\\"Unhappy\\", \\"Unhappy\\"]","solution":"def is_happy_number(n): Determines if a number n is a Happy Number or not. Args: n (int): positive integer to check for happiness. Returns: bool: True if n is a Happy Number, False otherwise. def get_next_number(num): sum_of_squares = 0 while num: digit = num % 10 sum_of_squares += digit * digit num //= 10 return sum_of_squares seen = set() while n != 1 and n not in seen: seen.add(n) n = get_next_number(n) return n == 1 def happy_number_checker(numbers): result = [] for number in numbers: if number == 0: break if is_happy_number(number): result.append(\\"Happy\\") else: result.append(\\"Unhappy\\") return result"},{"question":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def build_tree(preorder, inorder): Build binary tree from preorder and inorder traversals. :param preorder: List[int] - The preorder traversal. :param inorder: List[int] - The inorder traversal. :return: TreeNode - The root of the binary tree. # Implementation here pass def tree_height(root): Calculate the height of the binary tree. :param root: TreeNode - The root of the binary tree. :return: int - The height of the binary tree. # Implementation here pass def find_height_of_binary_tree(n, preorder, inorder): Find the height of the binary tree given preorder and inorder traversals. :param n: int - Number of nodes in the binary tree. :param preorder: List[int] - The preorder traversal. :param inorder: List[int] - The inorder traversal. :return: int - The height of the binary tree. # Implementation here pass # Unit Tests def test_basic_case(): n = 5 preorder = [1, 2, 4, 5, 3] inorder = [4, 2, 5, 1, 3] assert find_height_of_binary_tree(n, preorder, inorder) == 3 def test_single_node(): n = 1 preorder = [1] inorder = [1] assert find_height_of_binary_tree(n, preorder, inorder) == 1 def test_left_heavy_tree(): n = 4 preorder = [1, 2, 3, 4] inorder = [4, 3, 2, 1] assert find_height_of_binary_tree(n, preorder, inorder) == 4 def test_right_heavy_tree(): n = 4 preorder = [1, 2, 3, 4] inorder = [1, 2, 3, 4] assert find_height_of_binary_tree(n, preorder, inorder) == 4 def test_balanced_tree(): n = 7 preorder = [1, 2, 4, 5, 3, 6, 7] inorder = [4, 2, 5, 1, 6, 3, 7] assert find_height_of_binary_tree(n, preorder, inorder) == 3","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def build_tree(preorder, inorder): if not preorder or not inorder: return None root_value = preorder[0] root = TreeNode(root_value) root_index_in_inorder = inorder.index(root_value) left_inorder = inorder[:root_index_in_inorder] right_inorder = inorder[root_index_in_inorder+1:] left_preorder = preorder[1:1+len(left_inorder)] right_preorder = preorder[1+len(left_inorder):] root.left = build_tree(left_preorder, left_inorder) root.right = build_tree(right_preorder, right_inorder) return root def tree_height(root): if root is None: return 0 left_height = tree_height(root.left) right_height = tree_height(root.right) return max(left_height, right_height) + 1 def find_height_of_binary_tree(n, preorder, inorder): root = build_tree(preorder, inorder) return tree_height(root) # Example usage n = 5 preorder = [1, 2, 4, 5, 3] inorder = [4, 2, 5, 1, 3] print(find_height_of_binary_tree(n, preorder, inorder)) # Output: 3"},{"question":"def max_trees_can_be_planted(t: int, test_cases: list) -> list: Determines the maximum number of trees that can be planted such that no two trees have the same distance from one another. Args: t : int : Number of test cases test_cases : list of tuples : Each tuple contains two integers n (rows) and m (columns) Returns: list of int : List of maximum number of trees for each test case >>> max_trees_can_be_planted(1, [(3, 3)]) [3] >>> max_trees_can_be_planted(1, [(4, 5)]) [4] >>> max_trees_can_be_planted(2, [(3, 3), (4, 5)]) [3, 4] >>> max_trees_can_be_planted(1, [(1, 1)]) [1] >>> max_trees_can_be_planted(2, [(1000, 2000), (1500, 1000)]) [1000, 1000] >>> max_trees_can_be_planted(2, [(1000, 1000), (500, 500)]) [1000, 500]","solution":"def max_trees_can_be_planted(t, test_cases): Determines the maximum number of trees that can be planted such that no two trees have the same distance from one another. Args: t : int : Number of test cases test_cases : list of tuples : Each tuple contains two integers n (rows) and m (columns) Returns: list of int : List of maximum number of trees for each test case results = [] for n, m in test_cases: results.append(min(n, m)) return results"},{"question":"from datetime import datetime, timedelta class AuthenticationSystem: def __init__(self): self.users = {} self.failed_attempts = {} self.locked_accounts = {} self.current_time = datetime.now() def register_user(self, username: str, password: str) -> bool: Registers a new user with the given username and password. Returns True if the registration is successful, and False if the username is already taken. >>> auth_system = AuthenticationSystem() >>> auth_system.register_user(\\"alice\\", \\"password123\\") True >>> auth_system.register_user(\\"alice\\", \\"securepass\\") False pass def login(self, username: str, password: str) -> str: Attempts to log in a user with the provided username and password. If the login is successful, it returns \\"Login successful\\". If the login fails due to incorrect password or the account being locked, it returns \\"Login failed\\". If the account is locked, it should remain locked until the lock expires even if a correct password is provided. >>> auth_system = AuthenticationSystem() >>> auth_system.register_user(\\"alice\\", \\"password123\\") True >>> auth_system.login(\\"alice\\", \\"wrongpassword\\") 'Login failed' >>> auth_system.login(\\"alice\\", \\"password123\\") 'Login successful' pass def time_passed(self, minutes: int) -> None: Advances the system's clock by the given number of minutes. >>> auth_system = AuthenticationSystem() >>> initial_time = auth_system.current_time >>> auth_system.time_passed(60) >>> auth_system.current_time == initial_time + timedelta(minutes=60) True pass if __name__ == \\"__main__\\": import pytest pytest.main([__file__])","solution":"from datetime import datetime, timedelta class AuthenticationSystem: def __init__(self): self.users = {} self.failed_attempts = {} self.locked_accounts = {} self.current_time = datetime.now() def register_user(self, username: str, password: str) -> bool: if username in self.users: return False self.users[username] = password return True def login(self, username: str, password: str) -> str: if username in self.locked_accounts: lock_end_time = self.locked_accounts[username] if self.current_time < lock_end_time: return \\"Login failed\\" else: del self.locked_accounts[username] self.failed_attempts[username] = 0 if username in self.users and self.users[username] == password: self.failed_attempts[username] = 0 return \\"Login successful\\" else: if username not in self.failed_attempts: self.failed_attempts[username] = 0 self.failed_attempts[username] += 1 if self.failed_attempts[username] >= 3: self.locked_accounts[username] = self.current_time + timedelta(hours=1) return \\"Login failed\\" def time_passed(self, minutes: int) -> None: self.current_time += timedelta(minutes=minutes)"},{"question":"from typing import List, Dict, Tuple def calculate_rewards(test_cases: List[Dict[str, any]]) -> List[int]: Calculate the total reward points a customer has earned based on their book purchases. Parameters: test_cases (List[Dict[str, any]]): A list of test case dictionaries containing genres with their reward points and books purchased. Returns: List[int]: A list of total reward points per test case. Example: >>> test_cases = [ { \\"G\\": 3, \\"genres\\": [(\\"Fiction\\", 10), (\\"NonFiction\\", 5), (\\"Mystery\\", 7)], \\"books\\": [\\"Fiction\\", \\"Mystery\\", \\"Mystery\\", \\"NonFiction\\"] }, { \\"G\\": 2, \\"genres\\": [(\\"History\\", 12), (\\"Science\\", 15)], \\"books\\": [\\"History\\", \\"Science\\", \\"Science\\"] } ] >>> calculate_rewards(test_cases) [29, 42] # Your solution goes here def test_example_case(): test_cases = [ { \\"G\\": 3, \\"genres\\": [(\\"Fiction\\", 10), (\\"NonFiction\\", 5), (\\"Mystery\\", 7)], \\"books\\": [\\"Fiction\\", \\"Mystery\\", \\"Mystery\\", \\"NonFiction\\"] }, { \\"G\\": 2, \\"genres\\": [(\\"History\\", 12), (\\"Science\\", 15)], \\"books\\": [\\"History\\", \\"Science\\", \\"Science\\"] } ] assert calculate_rewards(test_cases) == [29, 42] def test_single_genre_single_book(): test_cases = [ { \\"G\\": 1, \\"genres\\": [(\\"Romance\\", 10)], \\"books\\": [\\"Romance\\", \\"Romance\\", \\"Romance\\"] } ] assert calculate_rewards(test_cases) == [30] def test_multiple_genres_single_book_each(): test_cases = [ { \\"G\\": 2, \\"genres\\": [(\\"Adventure\\", 7), (\\"Horror\\", 8)], \\"books\\": [\\"Adventure\\", \\"Horror\\"] } ] assert calculate_rewards(test_cases) == [15] def test_no_books_purchased(): test_cases = [ { \\"G\\": 3, \\"genres\\": [(\\"Fiction\\", 10), (\\"NonFiction\\", 5), (\\"Mystery\\", 7)], \\"books\\": [] } ] assert calculate_rewards(test_cases) == [0] def test_large_number_of_genres_and_books(): test_cases = [ { \\"G\\": 20, \\"genres\\": [(f\\"Genre{i}\\", i) for i in range(1, 21)], \\"books\\": [f\\"Genre{i}\\" for i in range(1, 21)] } ] assert calculate_rewards(test_cases) == [sum(range(1, 21))]","solution":"def calculate_rewards(test_cases): results = [] for test in test_cases: genres_rewards = {} G = test[\\"G\\"] for genre in test[\\"genres\\"]: genres_rewards[genre[0]] = genre[1] total_points = 0 for book in test[\\"books\\"]: total_points += genres_rewards[book] results.append(total_points) return results"},{"question":"def subset_sum_exists(arr: List[int], k: int) -> bool: Determines if there exists a subset of the integers whose sum is exactly \`k\` >>> subset_sum_exists([1, 2, 3, 4, 5], 9) True >>> subset_sum_exists([3, 34, 4, 12], 9) False ...","solution":"def subset_sum_exists(arr, k): Determines if there exists a subset of the integers whose sum is exactly \`k\` :param arr: List of integers :param k: Target sum :return: True if there is a subset which adds up to k, else False n = len(arr) # Create a DP array to store results of subproblems dp = [[False for x in range(k + 1)] for y in range(n + 1)] # If sum is 0, then answer is true for any subset, including the empty subset for i in range(n + 1): dp[i][0] = True # Populate the subset sum dp array for i in range(1, n + 1): for j in range(1, k + 1): dp[i][j] = dp[i - 1][j] if j >= arr[i - 1]: dp[i][j] = dp[i][j] or dp[i - 1][j - arr[i - 1]] return dp[n][k] # Example usage: # n = 5 # arr = [1, 2, 3, 4, 5] # k = 9 # print(subset_sum_exists(arr, k)) # Expected output: True"},{"question":"def count_unique_anagrams(n: int, strings: List[str]) -> int: Counts the number of unique anagrams in a list of strings. Args: n (int): The number of strings. strings (list of str): The list of strings. Returns: int: The number of unique anagrams. Examples: >>> count_unique_anagrams(5, [\\"abc\\", \\"bca\\", \\"dac\\", \\"adc\\", \\"xyz\\"]) 3 >>> count_unique_anagrams(4, [\\"listen\\", \\"silent\\", \\"enlist\\", \\"google\\"]) 2","solution":"def count_unique_anagrams(n, strings): Counts the number of unique anagrams in a list of strings. Args: n (int): The number of strings. strings (list of str): The list of strings. Returns: int: The number of unique anagrams. unique_anagrams = set() for string in strings: sorted_string = ''.join(sorted(string)) unique_anagrams.add(sorted_string) return len(unique_anagrams)"},{"question":"from typing import List, Tuple def can_form_k_blocks(s: str, k: int) -> str: Determines if all characters in the string can be rearranged to form contiguous blocks of at least k length. >>> can_form_k_blocks(\\"aabb\\", 2) \\"YES\\" >>> can_form_k_blocks(\\"aaa\\", 2) \\"YES\\" >>> can_form_k_blocks(\\"abc\\", 2) \\"NO\\" >>> can_form_k_blocks(\\"aabbcc\\", 2) \\"YES\\" def process_test_cases(test_cases: List[Tuple[str, int]]) -> List[str]: Processes multiple test cases and determines if each can be rearranged to meet the condition. >>> process_test_cases([(\\"aabb\\", 2), (\\"aaa\\", 2), (\\"abc\\", 2), (\\"aabbcc\\", 2)]) [\\"YES\\", \\"YES\\", \\"NO\\", \\"YES\\"] def test_can_form_k_blocks(): assert can_form_k_blocks(\\"aabb\\", 2) == \\"YES\\" assert can_form_k_blocks(\\"aaa\\", 2) == \\"YES\\" assert can_form_k_blocks(\\"abc\\", 2) == \\"NO\\" assert can_form_k_blocks(\\"aabbcc\\", 2) == \\"YES\\" assert can_form_k_blocks(\\"aabbcc\\", 3) == \\"NO\\" assert can_form_k_blocks(\\"aaabbbccc\\", 3) == \\"YES\\" assert can_form_k_blocks(\\"abcd\\", 1) == \\"YES\\" assert can_form_k_blocks(\\"abcd\\", 2) == \\"NO\\" def test_process_test_cases(): test_cases = [(\\"aabb\\", 2), (\\"aaa\\", 2), (\\"abc\\", 2), (\\"aabbcc\\", 2)] expected_results = [\\"YES\\", \\"YES\\", \\"NO\\", \\"YES\\"] assert process_test_cases(test_cases) == expected_results test_cases = [(\\"aabbcc\\", 3), (\\"aaabbbccc\\", 3), (\\"abcd\\", 1), (\\"abcd\\", 2)] expected_results = [\\"NO\\", \\"YES\\", \\"YES\\", \\"NO\\"] assert process_test_cases(test_cases) == expected_results","solution":"from collections import Counter def can_form_k_blocks(s, k): Determines if all characters in s can be rearranged to form contiguous blocks of at least k length. freq = Counter(s) for count in freq.values(): if count < k: return \\"NO\\" return \\"YES\\" def process_test_cases(test_cases): results = [] for s, k in test_cases: results.append(can_form_k_blocks(s, k)) return results"},{"question":"from typing import List def largest_number(nums: List[int]) -> str: Given a list of positive integers, arrange them such that they form the largest possible number. The result should be presented as a string. >>> largest_number([3, 30, 34, 5, 9]) '9534330' >>> largest_number([9, 8, 7, 6, 5]) '98765' >>> largest_number([1, 1, 1, 1]) '1111' >>> largest_number([10, 2, 9, 34, 3]) '9343210' >>> largest_number([0, 0, 0, 0]) '0' >>> largest_number([123, 456, 789]) '789456123' >>> largest_number([5, 55, 555]) '555555' >>> largest_number([100, 10, 1]) '110100'","solution":"from typing import List def largest_number(nums: List[int]) -> str: # Convert all numbers to strings since we need to concatenate them nums = list(map(str, nums)) # Sort numbers based on their concatenated value nums.sort(key=lambda x: x*10, reverse=True) # Join sorted values largest_num = ''.join(nums) # Edge case: when there's a lot of zeroes return '0' if largest_num[0] == '0' else largest_num"},{"question":"def longest_balanced_substring(s: str) -> int: Given a string s with both lowercase and uppercase letters, return the length of the longest \\"balanced\\" substring. A \\"balanced\\" substring contains an equal number of both uppercase and lowercase letters. >>> longest_balanced_substring(\\"aAb\\") # \\"aA\\" or \\"Ab\\" 2 >>> longest_balanced_substring(\\"AaBBccDd\\") # \\"AaBBccDd\\" 8 pass def balanced_substring_solver(test_cases: List[str]) -> List[int]: Solves multiple test cases where each test case is a string used to find the length of its longest balanced substring. >>> balanced_substring_solver([\\"aAb\\"]) # Single test case \\"aAb\\" [2] >>> balanced_substring_solver([\\"AaBBccDd\\"]) # Single test case \\"AaBBccDd\\" [8] >>> balanced_substring_solver([\\"aAb\\", \\"AaBBccDd\\"]) # Multiple test cases [2, 8] >>> balanced_substring_solver([\\"aabb\\"]) # Unbalanced string with no uppercase [0] >>> balanced_substring_solver([\\"ABC\\"]) # Unbalanced string with no lowercase [0] >>> balanced_substring_solver([\\"abc\\"]) # Unbalanced string with no uppercase [0] >>> balanced_substring_solver([\\"aAaAaA\\"]) # Alternating cases [6] >>> balanced_substring_solver([\\"aAAaBBBb\\"]) # Mixed cases [4] >>> balanced_substring_solver([\\"aA\\" * 50000]) # Large input case [100000] pass","solution":"def longest_balanced_substring(s): Function to find the length of the longest balanced substring. max_length = 0 n = len(s) # Create a dictionary to store the first occurrence of every prefix balance prefix_count = {0: -1} balance = 0 for i in range(n): if 'a' <= s[i] <= 'z': balance -= 1 else: balance += 1 if balance in prefix_count: max_length = max(max_length, i - prefix_count[balance]) else: prefix_count[balance] = i return max_length def balanced_substring_solver(test_cases): results = [] for s in test_cases: results.append(longest_balanced_substring(s)) return results"},{"question":"def min_operations(s: str, t: str) -> int: Returns the minimum number of operations needed to transform string s into string t. Operations include replace, delete, and insert a character. >>> min_operations(\\"abcd\\", \\"bcdf\\") == 2 >>> min_operations(\\"abcdef\\", \\"abcd\\") == 2 >>> min_operations(\\"kitten\\", \\"sitting\\") == 3 >>> min_operations(\\"abc\\", \\"abc\\") == 0 >>> min_operations(\\"a\\", \\"\\") == 1 >>> min_operations(\\"\\", \\"a\\") == 1 >>> min_operations(\\"abc\\", \\"a\\") == 2 >>> min_operations(\\"abc\\", \\"xyz\\") == 3","solution":"def min_operations(s, t): Returns the minimum number of operations needed to transform string s into string t. Operations include replace, delete, and insert a character. m, n = len(s), len(t) dp = [[0] * (n + 1) for _ in range(m + 1)] # Base cases for i in range(m + 1): dp[i][0] = i for j in range(n + 1): dp[0][j] = j # Fill dp array for i in range(1, m + 1): for j in range(1, n + 1): if s[i - 1] == t[j - 1]: dp[i][j] = dp[i - 1][j - 1] # No operation needed else: dp[i][j] = min( dp[i - 1][j] + 1, # Delete operation dp[i][j - 1] + 1, # Insert operation dp[i - 1][j - 1] + 1 # Replace operation ) return dp[m][n]"},{"question":"def binary_search(nums: List[int], target: int) -> int: Perform binary search to find the index of target in a sorted list nums. Return the index if found, otherwise return -1. Examples: >>> binary_search([-1, 0, 3, 5, 9, 12], 9) 4 >>> binary_search([-1, 0, 3, 5, 9, 12], 2) -1 >>> binary_search([5, 6, 7, 8, 9, 10], 5) 0 >>> binary_search([1, 2, 3, 4, 5, 6], 6) 5","solution":"def binary_search(nums, target): Perform binary search to find the index of target in sorted list nums. Return the index if found, otherwise return -1. left, right = 0, len(nums) - 1 while left <= right: mid = (left + right) // 2 if nums[mid] == target: return mid elif nums[mid] < target: left = mid + 1 else: right = mid - 1 return -1"},{"question":"def maximum_stable_stack(n: int, widths: List[int]) -> int: Given the widths of \`n\` books, calculate the maximum number of books in a stable stack where each book stacked above has a smaller width. Parameters: - n: int, number of books - widths: list of int, widths of the books Returns: - int: maximum height of a stable stack. Examples: >>> maximum_stable_stack(5, [1, 2, 3, 4, 5]) 5 >>> maximum_stable_stack(5, [5, 3, 4, 2, 1]) 3 >>> maximum_stable_stack(6, [6, 5, 4, 3, 2, 1]) 6 # Your implementation here","solution":"def maximum_stable_stack(n, widths): Given the widths of \`n\` books, calculate the maximum number of books in a stable stack where each book stacked above has a smaller width. Parameters: - n: int, number of books - widths: list of int, widths of the books Returns: - int: maximum height of a stable stack. widths.sort() return n # Since widths can be sorted in increasing order, max height will be \`n\` # A function to read input and call the above function def main(): import sys input = sys.stdin.read data = input().split() n = int(data[0]) widths = list(map(int, data[1:])) print(maximum_stable_stack(n, widths))"},{"question":"def max_subarray_sum(n: int, happiness_scores: List[int]) -> int: Returns the maximum sum of happiness scores for a continuous subarray. Parameters: n (int): The number of days Alice exercises. happiness_scores (list): The happiness scores for each day. Returns: int: The maximum sum of happiness scores for a continuous subarray. Examples: >>> max_subarray_sum(9, [-2, 1, -3, 4, -1, 2, 1, -5, 4]) 6 >>> max_subarray_sum(3, [-1, -2, -3]) -1","solution":"def max_subarray_sum(n, happiness_scores): Returns the maximum sum of happiness scores for a continuous subarray. Parameters: n (int): The number of days Alice exercises. happiness_scores (list of int): The happiness scores for each day. Returns: int: The maximum sum of happiness scores for a continuous subarray. max_ending_here = max_so_far = happiness_scores[0] for i in range(1, n): max_ending_here = max(happiness_scores[i], max_ending_here + happiness_scores[i]) max_so_far = max(max_so_far, max_ending_here) return max_so_far"},{"question":"from typing import List, Tuple def can_partition(n: int, a: List[int]) -> Tuple[bool, int, int]: Determine if it is possible to partition the array into two non-empty segments such that the sum of the first segment is greater than the sum of the second segment. :param n: Length of the array :param a: List of integers :return: Tuple containing a boolean indicating whether the partitioning is possible, and if so, two integers representing the sizes of the two segments pass def test_can_partition_example1(): n = 5 a = [1, 2, 3, 4, 5] result = can_partition(n, a) assert result == (True, 4, 1) or result == (True, 3, 2) def test_can_partition_example2(): n = 4 a = [-1, -2, -3, -4] result = can_partition(n, a) assert result == (True, 1, 3) or result == (True, 2, 2) def test_can_partition_example3(): n = 3 a = [0, 0, 0] result = can_partition(n, a) assert result == (False,) def test_can_partition_minimum_size(): n = 2 a = [1, -1] result = can_partition(n, a) assert result == (True, 1, 1) def test_can_partition_large_numbers(): n = 5 a = [10**8, 10**8, 10**8, 10**8, 10**8] result = can_partition(n, a) assert result == (True, 4, 1) or result == (True, 3, 2) def test_can_partition_all_negative(): n = 4 a = [-100, -50, -50, -20] result = can_partition(n, a) assert result == (True, 1, 3)","solution":"def can_partition(n, a): Determine if it is possible to partition the array into two non-empty segments such that the sum of the first segment is greater than the sum of the second segment. :param n: Length of the array :param a: List of integers :return: Tuple containing a boolean indicating whether the partitioning is possible, and if so, two integers representing the sizes of the two segments total_sum = sum(a) current_sum = 0 for i in range(n - 1): current_sum += a[i] if current_sum > total_sum - current_sum: return (True, i + 1, n - i - 1) return (False,) # Usage example def main(): import sys input = sys.stdin.read data = input().split() n = int(data[0]) a = list(map(int, data[1:])) result = can_partition(n, a) if result[0]: print(\\"YES\\") print(f\\"{result[1]} {result[2]}\\") else: print(\\"NO\\")"},{"question":"def validate_exam(n: int, answers: List[str]) -> str: Check if the given list of answers is a valid sequence based on the problem conditions. Parameters: n (int): The number of questions in the exam. answers (list): List of characters representing the correct answer for each question. Returns: str: \\"VALID\\" if the list of correct answers meets all the conditions, \\"INVALID\\" otherwise. Test cases: >>> validate_exam(5, ['A', 'B', 'C', 'D', 'A']) == \\"VALID\\" >>> validate_exam(4, ['A', 'A', 'B', 'C']) == \\"INVALID\\" >>> validate_exam(3, ['A', 'C', 'B']) == \\"VALID\\" >>> validate_exam(1001, ['A', 'B', 'C', 'D']) == \\"INVALID\\" # n > 1000 >>> validate_exam(0, ['A']) == \\"INVALID\\" # n < 1 >>> validate_exam(1, ['A']) == \\"VALID\\" >>> validate_exam(6, ['A', 'B', 'C', 'D', 'A', 'D']) == \\"VALID\\" >>> validate_exam(5, ['A', 'B', 'C', 'D', 'D']) == \\"INVALID\\" >>> validate_exam(6, ['A', 'B', 'A', 'B', 'A', 'B']) == \\"VALID\\"","solution":"def validate_exam(n, answers): Check if the given list of answers is a valid sequence based on the problem conditions. Parameters: n (int): The number of questions in the exam. answers (list): List of characters representing the correct answer for each question. Returns: str: \\"VALID\\" if the list of correct answers meets all the conditions, \\"INVALID\\" otherwise. if not (1 <= n <= 1000): return \\"INVALID\\" valid_answers = \\"ABCD\\" for i in range(1, n): if answers[i] == answers[i-1]: return \\"INVALID\\" return \\"VALID\\""},{"question":"def are_anagrams(s1: str, s2: str) -> bool: Determines if two input strings are anagrams of each other. Parameters: s1 (str): The first input string. s2 (str): The second input string. Returns: bool: True if s1 and s2 are anagrams, False otherwise. >>> are_anagrams(\\"silent\\", \\"listen\\") True >>> are_anagrams(\\"hello\\", \\"world\\") False >>> are_anagrams(\\"\\", \\"\\") True >>> are_anagrams(\\"abc\\", \\"\\") False >>> are_anagrams(\\"aabbcc\\", \\"aabbc\\") False >>> are_anagrams(\\"aabbcc\\", \\"abcabc\\") True","solution":"def are_anagrams(s1: str, s2: str) -> bool: Determines if two input strings are anagrams of each other. Parameters: s1 (str): The first input string. s2 (str): The second input string. Returns: bool: True if s1 and s2 are anagrams, False otherwise. return sorted(s1) == sorted(s2)"},{"question":"def longest_single_nucleotide_substring(dna_sequence: str) -> int: Determine the length of the longest substring that contains only a single type of nucleotide. >>> longest_single_nucleotide_substring('CCCCCCCCCCCCCCCCCCCC') 20 >>> longest_single_nucleotide_substring('ATTTGC') 3 >>> longest_single_nucleotide_substring('AGTCAGTCAGTCA') 1 >>> longest_single_nucleotide_substring('A') 1 >>> longest_single_nucleotide_substring('') 0 >>> longest_single_nucleotide_substring('AAAAAAAAAA') 10 >>> longest_single_nucleotide_substring('ATATGGGGCACGT') 4","solution":"def longest_single_nucleotide_substring(dna_sequence): This function determines the length of the longest substring in a given DNA sequence that contains only a single type of nucleotide. if not dna_sequence: return 0 max_length = 1 current_length = 1 for i in range(1, len(dna_sequence)): if dna_sequence[i] == dna_sequence[i-1]: current_length += 1 else: if current_length > max_length: max_length = current_length current_length = 1 # Final comparison after the loop ends if current_length > max_length: max_length = current_length return max_length"},{"question":"def is_tautonym(input_string: str) -> bool: Determines if the input string is a tautonym. A Tautonym is a string where the same word appears consecutively without any modification. This function is case-insensitive. Args: input_string (str): A string of space-separated words. Returns: bool: True if the string is a tautonym, False otherwise. Examples: >>> is_tautonym(\\"happy happy\\") True >>> is_tautonym(\\"hello world hello\\") False >>> is_tautonym(\\"repeat repeat repeat\\") False >>> is_tautonym(\\"abc abc xyz xyz\\") False","solution":"def is_tautonym(input_string): Determines if the input string is a tautonym. A Tautonym is a string where the same word appears consecutively without any modification. This function is case-insensitive. Args: input_string (str): A string of space-separated words. Returns: bool: True if the string is a tautonym, False otherwise. words = input_string.lower().strip().split() if len(words) == 2 and words[0] == words[1]: return True return False"},{"question":"from typing import List, Tuple def handle_events(n: int, t: int, capacities: List[int], events: List[Tuple[int, int, int]]) -> List[int]: Determine the number of overwhelmed robots after each communication event. Args: n (int): The number of robots. t (int): The number of events. capacities (List[int]): The communication capacities of the robots. events (List[Tuple[int, int, int]]): The communication events indicating either a new link establishment or a link removal between two robots. Returns: List[int]: A list of integers where the i-th integer is the number of overwhelmed robots after the i-th event. >>> handle_events(6, 4, [2, 1, 2, 1, 1, 0], [(1, 1, 2), (1, 2, 3), (1, 3, 4), (1, 4, 5)]) [0, 1, 1, 2] >>> handle_events(6, 5, [2, 1, 2, 1, 1, 0], [(1, 1, 2), (1, 2, 3), (1, 3, 4), (1, 4, 5), (0, 2, 3)]) [0, 1, 1, 2, 1] >>> handle_events(4, 3, [1, 1, 1, 1], [(1, 1, 2), (1, 2, 3), (1, 3, 4)]) [0, 1, 2] >>> handle_events(5, 3, [2, 2, 2, 2, 2], [(1, 1, 2), (1, 2, 3), (1, 3, 4)]) [0, 0, 0] >>> handle_events(3, 2, [1, 2, 1], [(1, 1, 2), (1, 2, 3)]) [0, 0] # Functionality to handle the events and compute the number of overwhelmed robots","solution":"def handle_events(n, t, capacities, events): from collections import defaultdict, deque # Initialize direct links count and graph structure direct_links = [0] * (n + 1) graph = defaultdict(set) def is_overwhelmed(robot): return direct_links[robot] > capacities[robot - 1] # Function to add a link def add_link(x, y): graph[x].add(y) graph[y].add(x) direct_links[x] += 1 direct_links[y] += 1 # Function to remove a link def remove_link(x, y): graph[x].remove(y) graph[y].remove(x) direct_links[x] -= 1 direct_links[y] -= 1 # Initialize overwhelmed robots counter overwhelmed_count = 0 overwhelmed = set() # List to store the results result = [] for event in events: op, x, y = event if op == 1: add_link(x, y) if is_overwhelmed(x): overwhelmed.add(x) if is_overwhelmed(y): overwhelmed.add(y) elif op == 0: remove_link(x, y) if not is_overwhelmed(x): overwhelmed.discard(x) if not is_overwhelmed(y): overwhelmed.discard(y) result.append(len(overwhelmed)) return result"},{"question":"from typing import List, Tuple def count_triangles(n: int, points: List[Tuple[int, int]]) -> int: Returns the number of different triangles that can be formed using n points. >>> count_triangles(3, [(1, 1), (2, 3), (4, 5)]) 1 >>> count_triangles(4, [(0, 0), (1, 1), (2, 2), (0, 3)]) 4 >>> count_triangles(0, []) 0 >>> count_triangles(2, [(0, 0), (1, 1)]) 0 >>> count_triangles(5, [(0, 0), (1, 1), (2, 2), (0, 3), (1, 0)]) 10","solution":"def count_triangles(n, points): Returns the number of different triangles that can be formed using n points. if n < 3: return 0 # using combination formula C(n, 3) to count the number of triangles from math import comb return comb(n, 3)"},{"question":"def minimal_number_of_teams(m: int, communication_limits: List[int]) -> int: Determine the minimal number of teams required to ensure that all students are in some team and all constraints are satisfied. :param m: int - number of students :param communication_limits: List[int] - list of communication limits for each student :return: int - minimal number of teams required Examples: >>> minimal_number_of_teams(4, [1, 2, 1, 1]) 2 >>> minimal_number_of_teams(5, [0, 0, 0, 0, 0]) 5 >>> minimal_number_of_teams(6, [2, 3, 2, 1, 1, 3]) 2 >>> minimal_number_of_teams(7, [0, 1, 2, 3, 1, 0, 2]) 3","solution":"def minimal_number_of_teams(m, communication_limits): Returns the minimal number of teams needed so that no student's communication limit is exceeded within any team. :param m: int - number of students :param communication_limits: List[int] - list of communication limits for each student :return: int - minimal number of teams required communication_limits.sort(reverse=True) teams = 0 while communication_limits: teams += 1 team_size = communication_limits.pop(0) team_members = 0 while team_members < team_size and communication_limits: max_limit = communication_limits[0] communication_limits = communication_limits[1:] team_members += 1 return teams"},{"question":"def compute_mst(n: int, m: int, edges: List[Tuple[int, int, int]]) -> Union[int, str]: Compute the total weight of the Minimum Spanning Tree (MST) for the given graph. Parameters: n (int): Number of nodes. m (int): Number of edges. edges (List[Tuple[int, int, int]]): List of edges where each edge is represented as a tuple (u, v, w) indicating an edge between nodes u and v with weight w. Returns: Union[int, str]: The total weight of the MST or \\"IMPOSSIBLE\\" if it's not possible to connect all nodes. >>> compute_mst(4, 5, [(1, 2, 3), (1, 3, 4), (4, 2, 2), (3, 2, 5), (4, 3, 1)]) 6 >>> compute_mst(4, 1, [(1, 2, 3)]) \\"IMPOSSIBLE\\" >>> compute_mst(1, 0, []) 0 >>> compute_mst(4, 2, [(1, 2, 5), (3, 4, 10)]) \\"IMPOSSIBLE\\" >>> compute_mst(4, 4, [(1, 2, 1), (2, 3, 1), (3, 4, 1), (4, 1, 1)]) 3 # Complete the function implementation here","solution":"def find(parent, i): if parent[i] == i: return i else: return find(parent, parent[i]) def union(parent, rank, x, y): xroot = find(parent, x) yroot = find(parent, y) if rank[xroot] < rank[yroot]: parent[xroot] = yroot elif rank[xroot] > rank[yroot]: parent[yroot] = xroot else: parent[yroot] = xroot rank[xroot] += 1 def kruskal_mst(n, edges): result = [] i = 0 e = 0 edges = sorted(edges, key=lambda item: item[2]) parent = [] rank = [] for node in range(n): parent.append(node) rank.append(0) while e < n - 1: if i >= len(edges): return \\"IMPOSSIBLE\\" u, v, w = edges[i] i = i + 1 x = find(parent, u - 1) y = find(parent, v - 1) if x != y: e = e + 1 result.append([u, v, w]) union(parent, rank, x, y) minimumCost = 0 for u, v, weight in result: minimumCost += weight return minimumCost def compute_mst(n, m, edges): if n == 1: return 0 # A single node is trivially its own MST. if m == 0: return \\"IMPOSSIBLE\\" # No edges to connect the nodes. return kruskal_mst(n, edges) # Example usage # Example 1: n1, m1 = 4, 5 edges1 = [(1, 2, 3), (1, 3, 4), (4, 2, 2), (3, 2, 5), (4, 3, 1)] print(compute_mst(n1, m1, edges1)) # Output: 6 # Example 2: n2, m2 = 4, 1 edges2 = [(1, 2, 3)] print(compute_mst(n2, m2, edges2)) # Output: IMPOSSIBLE"},{"question":"def is_fibonacci(n: int) -> str: Determine if a given integer is a Fibonacci number. >>> is_fibonacci(5) \\"YES\\" >>> is_fibonacci(7) \\"NO\\" >>> is_fibonacci(13) \\"YES\\" from solution import is_fibonacci def test_is_fibonacci_with_fib_numbers(): assert is_fibonacci(0) == \\"YES\\" assert is_fibonacci(1) == \\"YES\\" assert is_fibonacci(2) == \\"YES\\" assert is_fibonacci(3) == \\"YES\\" assert is_fibonacci(5) == \\"YES\\" assert is_fibonacci(13) == \\"YES\\" assert is_fibonacci(21) == \\"YES\\" assert is_fibonacci(144) == \\"YES\\" def test_is_fibonacci_with_non_fib_numbers(): assert is_fibonacci(4) == \\"NO\\" assert is_fibonacci(6) == \\"NO\\" assert is_fibonacci(7) == \\"NO\\" assert is_fibonacci(9) == \\"NO\\" assert is_fibonacci(10) == \\"NO\\" assert is_fibonacci(20) == \\"NO\\" assert is_fibonacci(22) == \\"NO\\" def test_is_fibonacci_with_large_numbers(): assert is_fibonacci(987) == \\"YES\\" assert is_fibonacci(1000) == \\"NO\\" def test_is_fibonacci_with_negative_numbers(): assert is_fibonacci(-1) == \\"NO\\" assert is_fibonacci(-5) == \\"NO\\"","solution":"def is_fibonacci(n): Determine if a given integer is a Fibonacci number. if n < 0: return \\"NO\\" a, b = 0, 1 while b < n: a, b = b, a + b if b == n or n == 0: return \\"YES\\" else: return \\"NO\\""},{"question":"import heapq from typing import List, Tuple def shortest_path(n: int, m: int, edges: List[Tuple[int, int, int]]) -> int: Finds the shortest time it would take to travel from node 1 to node n. If there is no path from node 1 to node n, return -1. pass def test_shortest_path_example(): n = 5 m = 6 edges = [ (1, 2, 2), (1, 3, 4), (2, 3, 1), (2, 4, 7), (3, 5, 3), (4, 5, 2) ] assert shortest_path(n, m, edges) == 6 def test_no_path(): n = 4 m = 2 edges = [ (1, 2, 1), (3, 4, 1) ] assert shortest_path(n, m, edges) == -1 def test_direct_path(): n = 3 m = 2 edges = [ (1, 2, 5), (2, 3, 2) ] assert shortest_path(n, m, edges) == 7 def test_same_node(): n = 2 m = 1 edges = [ (1, 2, 3) ] assert shortest_path(n, m, edges) == 3 def test_multiple_paths(): n = 5 m = 7 edges = [ (1, 2, 2), (1, 3, 4), (1, 4, 7), (2, 3, 1), (2, 4, 5), (3, 5, 1), (4, 5, 2) ] assert shortest_path(n, m, edges) == 4","solution":"import heapq def shortest_path(n, m, edges): Finds the shortest time it would take to travel from node 1 to node n. If there is no path from node 1 to node n, return -1. graph = [[] for _ in range(n+1)] for u, v, t in edges: graph[u].append((t, v)) graph[v].append((t, u)) # Dijkstra's algorithm min_heap = [(0, 1)] # (total_time, node) visited = set() dist = {i: float('inf') for i in range(1, n+1)} dist[1] = 0 while min_heap: cur_time, u = heapq.heappop(min_heap) if u in visited: continue visited.add(u) for time, v in graph[u]: if v not in visited and cur_time + time < dist[v]: dist[v] = cur_time + time heapq.heappush(min_heap, (dist[v], v)) return dist[n] if dist[n] != float('inf') else -1"},{"question":"def reverse_each_word(message: str) -> str: Alex's encryption method: reverses the words in the message but keeps the words in their original positions. Args: message (str): A single string consisting of multiple words separated by spaces. Returns: str: A modified string where each word is reversed but the order of words is preserved. Examples: >>> reverse_each_word(\\"hello world\\") 'olleh dlrow' >>> reverse_each_word(\\"coding in python is fun\\") 'gnidoc ni nohtyp si nuf'","solution":"def reverse_each_word(message): This function takes a string input and returns a string where each word is reversed, but the word order is preserved. words = message.split() reversed_words = [word[::-1] for word in words] return ' '.join(reversed_words)"},{"question":"def has_arithmetic_progression(nums): Given a list of integers, determine if there exist three distinct indices i, j, k in the list such that the values at those indices form an arithmetic progression. An arithmetic progression is a sequence of numbers in which the difference of any two successive members is a constant. >>> has_arithmetic_progression([3, 8, 5, 1, 14]) \\"YES\\" >>> has_arithmetic_progression([1, 2, 4, 8]) \\"NO\\" from solution import has_arithmetic_progression def test_has_arithmetic_progression_yes(): assert has_arithmetic_progression([3, 8, 5, 1, 14]) == \\"YES\\" def test_has_arithmetic_progression_no(): assert has_arithmetic_progression([1, 2, 4, 8]) == \\"NO\\" def test_minimum_possible_list(): assert has_arithmetic_progression([1, 2, 3]) == \\"YES\\" def test_no_arithmetic_progression(): assert has_arithmetic_progression([1, 10, 100, 1000]) == \\"NO\\" def test_large_numbers(): assert has_arithmetic_progression([10000, 20000, 15000]) == \\"YES\\" def test_negative_numbers(): assert has_arithmetic_progression([-3, -6, -9]) == \\"YES\\" def test_mixed_sign_numbers(): assert has_arithmetic_progression([-5, 0, 5]) == \\"YES\\" def test_identical_numbers(): assert has_arithmetic_progression([7, 7, 7]) == \\"NO\\"","solution":"def has_arithmetic_progression(nums): nums_set = set(nums) for i in range(len(nums)): for j in range(i + 1, len(nums)): diff = nums[j] - nums[i] if nums[i] - diff in nums_set and nums[i] != nums[i] - diff: return \\"YES\\" if nums[j] + diff in nums_set and nums[j] != nums[j] + diff: return \\"YES\\" return \\"NO\\""},{"question":"def max_common_length(n: int, m: int, necklace1: str, necklace2: str) -> int: Determine the length of the longest common contiguous subsequence between any rotation of the two necklaces. >>> max_common_length(5, 3, \\"abcde\\", \\"bcd\\") 3 >>> max_common_length(6, 6, \\"ababab\\", \\"bababa\\") 6 >>> max_common_length(4, 5, \\"abcd\\", \\"xyzab\\") 2 >>> max_common_length(3, 3, \\"abc\\", \\"def\\") 0 >>> max_common_length(3, 3, \\"abc\\", \\"abc\\") 3 >>> max_common_length(1, 1, \\"a\\", \\"b\\") 0","solution":"def max_common_length(n, m, necklace1, necklace2): def longest_common_substring(str1, str2): Returns length of the longest common substring longest = 0 dp = [[0] * (len(str2) + 1) for _ in range(len(str1) + 1)] for i in range(1, len(str1) + 1): for j in range(1, len(str2) + 1): if str1[i - 1] == str2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 longest = max(longest, dp[i][j]) else: dp[i][j] = 0 return longest max_length = 0 # Check all rotations of necklace1 for i in range(n): rotated_necklace1 = necklace1[i:] + necklace1[:i] max_length = max(max_length, longest_common_substring(rotated_necklace1, necklace2)) # Check all rotations of necklace2 for i in range(m): rotated_necklace2 = necklace2[i:] + necklace2[:i] max_length = max(max_length, longest_common_substring(necklace1, rotated_necklace2)) return max_length"},{"question":"def count_distinct_substrings(s: str, k: int) -> int: Returns the number of distinct substrings of length k in the given string s. Args: s (str): The input string consisting of lowercase Latin letters. k (int): The length of substrings to be considered. Returns: int: The number of distinct substrings of length k. Examples: >>> count_distinct_substrings(\\"abcabcabc\\", 3) 3 >>> count_distinct_substrings(\\"aaaaa\\", 2) 1 >>> count_distinct_substrings(\\"abcde\\", 4) 2","solution":"def count_distinct_substrings(s, k): Returns the number of distinct substrings of length k in the given string s. substrings = set() for i in range(len(s) - k + 1): substr = s[i:i + k] substrings.add(substr) return len(substrings)"},{"question":"def longest_common_substring_length(S: str, T: str) -> int: Returns the length of the longest common contiguous subsequence (substring) from the two given strings S and T. Parameters: S (str): The first input string. T (str): The second input string. Returns: int: The length of the longest common contiguous subsequence. Example: >>> longest_common_substring_length(\\"abcde\\", \\"axcye\\") 1 >>> longest_common_substring_length(\\"abcdefg\\", \\"xyzabcpq\\") 3 >>> longest_common_substring_length(\\"12345\\", \\"34512\\") 3 ...","solution":"def longest_common_substring_length(S, T): Returns the length of the longest common contiguous subsequence (substring) from the two given strings S and T. m = len(S) n = len(T) # Create a 2D array to store lengths of longest common suffixes # Initialize the table with 0 dp = [[0] * (n + 1) for _ in range(m + 1)] max_length = 0 # Store the maximum length of the common substring found # Build the dp table for i in range(1, m + 1): for j in range(1, n + 1): if S[i - 1] == T[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 max_length = max(max_length, dp[i][j]) else: dp[i][j] = 0 return max_length"},{"question":"def has_pair_with_sum(nums: List[int], target: int) -> bool: Check whether there exists a pair of elements in an array such that their sum is equal to the given target value. >>> has_pair_with_sum([2, 7, 11, 15], 9) True >>> has_pair_with_sum([1, 2, 3, 4], 8) False","solution":"def has_pair_with_sum(nums, target): seen = set() for num in nums: if target - num in seen: return True seen.add(num) return False"},{"question":"def arrange_coins(n: int, k: int, coins: List[int]) -> str: Determines whether it is possible to arrange coins such that the sum of the values of any two adjacent coins is not divisible by k. If possible, returns the arrangement. :param n: Number of coins :param k: Integer for divisibility check :param coins: List of coin values :return: \\"YES\\" followed by the arrangement if possible, otherwise \\"NO\\" pass # Example test cases def test_example1(): n, k, coins = 5, 4, [7, 2, 5, 9, 1] result = arrange_coins(n, k, coins) assert result.startswith(\\"YES\\") def test_example2(): n, k, coins = 4, 2, [1, 3, 5, 7] assert arrange_coins(n, k, coins) == \\"NO\\" def test_single_coin(): n, k, coins = 1, 2, [10] assert arrange_coins(n, k, coins) == \\"YESn10\\" def test_all_pairs_not_divisible(): n, k, coins = 4, 5, [1, 2, 3, 4] result = arrange_coins(n, k, coins) assert result.startswith(\\"YES\\") def test_edge_case_highest_values(): n, k, coins = 3, 97, [99, 1, 98] result = arrange_coins(n, k, coins) assert result.startswith(\\"YES\\")","solution":"def arrange_coins(n, k, coins): Determines whether it is possible to arrange coins such that the sum of the values of any two adjacent coins is not divisible by k. If possible, returns the arrangement. :param n: Number of coins :param k: Integer for divisibility check :param coins: List of coin values :return: \\"YES\\" followed by the arrangement if possible, otherwise \\"NO\\" from itertools import permutations # Generate all possible permutations of the list of coins for perm in permutations(coins): # Check if the sum of adjacent coins is not divisible by k if all((perm[i] + perm[i + 1]) % k != 0 for i in range(n - 1)): return \\"YESn\\" + \\" \\".join(map(str, perm)) return \\"NO\\" # Function to handle the input and output def main(): input_data = input().split() n = int(input_data[0]) k = int(input_data[1]) coins = list(map(int, input_data[2:2 + n])) print(arrange_coins(n, k, coins))"},{"question":"def can_frog_cross_river(N, K, D, rocks): Determines if the frog can cross the river. Parameters: N (int): Number of rocks K (int): Maximum jumping distance D (int): Distance to the other side of the river rocks (list of int): Positions of rocks Returns: str: \\"Yes\\" if the frog can reach the end, \\"No\\" otherwise","solution":"def can_frog_cross_river(N, K, D, rocks): Determines if the frog can cross the river. Parameters: N (int): Number of rocks K (int): Maximum jumping distance D (int): Distance to the other side of the river rocks (list of int): Positions of rocks Returns: str: \\"Yes\\" if the frog can reach the end, \\"No\\" otherwise # Add starting point (0) and endpoint (D) to the list of rocks rocks = [0] + rocks + [D] rocks.sort() for i in range(len(rocks) - 1): if rocks[i + 1] - rocks[i] > K: return \\"No\\" return \\"Yes\\""},{"question":"def longest_descending_block(heights): Returns the length of the longest block of consecutive buildings where each building is strictly shorter than the previous one. >>> longest_descending_block([10]) == 1 >>> longest_descending_block([10, 4, 3, 2, 1]) == 5 >>> longest_descending_block([3, 2, 1, 5, 4, 3]) == 3 >>> longest_descending_block([8, 5, 3, 2, 7, 6, 5]) == 4 >>> longest_descending_block([1, 2, 3, 4, 5]) == 1 >>> longest_descending_block([4, 3, 2, 2, 1, 5, 4, 3, 3, 2, 1]) == 3","solution":"def longest_descending_block(heights): Returns the length of the longest block of consecutive buildings where each building is strictly shorter than the previous one. if not heights: return 0 max_length = 1 current_length = 1 for i in range(1, len(heights)): if heights[i] < heights[i - 1]: current_length += 1 max_length = max(max_length, current_length) else: current_length = 1 return max_length"},{"question":"def process_operations(n, values, edges, operations): You are given a tree (connected acyclic graph) of n nodes (1 ≤ n ≤ 100000) and n - 1 edges. Each node contains a value. You need to perform two types of operations on this tree: * update(u, x) — set the value of node u to x. * query(u, k) — find the k-th ancestor of node u and return its value. If u does not have a k-th ancestor, return -1. The k-th ancestor of node u is defined as the node that is k steps above u in the path to the root (node 1). Write a program to process the given sequence of operations. Args: n (int): Number of nodes in the tree. values (List[int]): The values of nodes 1 to n. edges (List[Tuple[int, int]]): n - 1 pairs of integers representing an edge between nodes u and v. operations (List[str]): List of operations, either \\"update(u, x)\\" or \\"query(u, k)\\" Returns: List[int]: The result of each query operation as a list of integers. Example: >>> n = 5 >>> values = [5, 3, 7, 2, 9] >>> edges = [(1, 2), (1, 3), (2, 4), (2, 5)] >>> operations = [\\"query 5 0\\", \\"query 5 1\\", \\"update 5 6\\", \\"query 5 2\\"] >>> result = process_operations(n, values, edges, operations) >>> print(result) [9, 3, 5] Unit Test: from solution import process_operations def test_tree_operations(): n = 5 values = [5, 3, 7, 2, 9] edges = [(1, 2), (1, 3), (2, 4), (2, 5)] operations = [\\"query 5 0\\", \\"query 5 1\\", \\"update 5 6\\", \\"query 5 2\\"] result = process_operations(n, values, edges, operations) assert result == [9, 3, 5] def test_update_and_query(): n = 3 values = [1, 2, 3] edges = [(1, 2), (1, 3)] operations = [\\"update 1 10\\", \\"query 3 1\\", \\"update 2 5\\", \\"query 2 1\\", \\"query 3 0\\"] result = process_operations(n, values, edges, operations) assert result == [10, 10, 3] def test_no_kth_ancestor(): n = 4 values = [4, 5, 6, 7] edges = [(1, 2), (1, 3), (2, 4)] operations = [\\"query 4 3\\", \\"query 4 2\\", \\"query 3 1\\", \\"query 3 2\\"] result = process_operations(n, values, edges, operations) assert result == [-1, 4, 4, -1]","solution":"from collections import defaultdict, deque class TreeOperations: def __init__(self, n, values, edges): self.n = n self.values = values self.graph = defaultdict(list) self.parent = [-1] * (n + 1) self.depth = [-1] * (n + 1) self.build_tree(edges) self.set_parent_and_depth() def build_tree(self, edges): for u, v in edges: self.graph[u].append(v) self.graph[v].append(u) def set_parent_and_depth(self): queue = deque([(1, 0)]) # (node, depth) self.depth[1] = 0 while queue: node, d = queue.popleft() for neighbor in self.graph[node]: if self.depth[neighbor] == -1: self.depth[neighbor] = d + 1 self.parent[neighbor] = node queue.append((neighbor, d + 1)) def update(self, u, x): self.values[u - 1] = x def query(self, u, k): if self.depth[u] < k: return -1 ancestor = u while k > 0: ancestor = self.parent[ancestor] k -= 1 return self.values[ancestor - 1] def process_operations(n, values, edges, operations): tree = TreeOperations(n, values, edges) result = [] for operation in operations: op = operation.split() if op[0] == \\"update\\": tree.update(int(op[1]), int(op[2])) elif op[0] == \\"query\\": result.append(tree.query(int(op[1]), int(op[2]))) return result"},{"question":"import heapq from typing import List, Tuple class ProjectManager: def __init__(self): self.projects = [] def add_project(self, p: int): Adds a project by its unique ID. pass def remove_highest_project(self): Removes the project with the highest ID. pass def get_highest_project(self) -> int: Returns the highest project ID currently in the list. pass def handle_operations(n: int, operations: List[Tuple[int, ...]]) -> List[int]: Handles a series of operations on the list of projects. The function takes the number of operations and a list of operations to perform on the project manager. >>> handle_operations(8, [(1, 100), (1, 200), (1, 150), (3,), (2,), (3,), (2,), (3,)]) [200, 150, 100] >>> handle_operations(7, [(1, 300), (1, 400), (3,), (2,), (3,), (1, 500), (3,)]) [400, 300, 500] pass def test_handle_operations_case1(): operations = [ (1, 100), (1, 200), (1, 150), (3,), (2,), (3,), (2,), (3,) ] result = handle_operations(8, operations) assert result == [200, 150, 100] def test_handle_operations_case2(): operations = [ (1, 300), (1, 400), (3,), (2,), (3,), (1, 500), (3,) ] result = handle_operations(7, operations) assert result == [400, 300, 500] def test_handle_operations_case3(): operations = [ (1, 500), (1, 600), (1, 700), (1, 800), (1, 900), (3,), (2,), (3,), (2,), (3,) ] result = handle_operations(10, operations) assert result == [900, 800, 700] def test_handle_operations_case4(): operations = [ (1, 1000), (1, 2000), (3,), (3,), (2,), (3,), (1, 1500), (3,), (2,), (3,) ] result = handle_operations(10, operations) assert result == [2000, 2000, 1000, 1500, 1000] def test_handle_operations_case5(): operations = [ (1, 5), (1, 10), (3,), (2,), (3,), (1, 7), (3,), (2,), (3,) ] result = handle_operations(9, operations) assert result == [10, 5, 7, 5]","solution":"import heapq class ProjectManager: def __init__(self): self.projects = [] def add_project(self, p): heapq.heappush(self.projects, -p) def remove_highest_project(self): if self.projects: heapq.heappop(self.projects) def get_highest_project(self): if self.projects: return -self.projects[0] def handle_operations(n, operations): manager = ProjectManager() result = [] for operation in operations: if operation[0] == 1: manager.add_project(operation[1]) elif operation[0] == 2: manager.remove_highest_project() elif operation[0] == 3: result.append(manager.get_highest_project()) return result"},{"question":"def smallest_fib_greater_equal(n: int) -> int: Returns the smallest Fibonacci number that is greater than or equal to n. >>> smallest_fib_greater_equal(5) 5 >>> smallest_fib_greater_equal(14) 21 >>> smallest_fib_greater_equal(28) 34 >>> smallest_fib_greater_equal(1) 1 >>> smallest_fib_greater_equal(0) 1 def find_fib_numbers(number_of_cases: int, cases: List[int]) -> List[int]: Processes multiple cases and returns the results for each case. >>> find_fib_numbers(3, [5, 14, 28]) [5, 21, 34] >>> find_fib_numbers(2, [10, 25]) [13, 34] >>> find_fib_numbers(1, [1]) [1] >>> find_fib_numbers(4, [8, 21, 34, 55]) [8, 21, 34, 55]","solution":"def smallest_fib_greater_equal(n): Returns the smallest Fibonacci number that is greater than or equal to n. if n == 1: return 1 a, b = 1, 1 while b < n: a, b = b, a + b return b def find_fib_numbers(number_of_cases, cases): Processes multiple cases and returns the results for each case. results = [] for n in cases: results.append(smallest_fib_greater_equal(n)) return results"},{"question":"from typing import List, Tuple def process_operations(N: int, Q: int, edges: List[Tuple[int, int]], operations: List[Tuple[int, int]]) -> List[int]: Process the sequence of operations to activate employees and query active employees in the subtree. Example: >>> N = 5 >>> Q = 4 >>> edges = [(1, 2), (1, 3), (3, 4), (3, 5)] >>> operations = [(1, 3), (1, 4), (2, 1), (2, 3)] >>> process_operations(N, Q, edges, operations) [2, 2] >>> N = 3 >>> Q = 2 >>> edges = [(1, 2), (1, 3)] >>> operations = [(2, 1), (2, 2)] >>> process_operations(N, Q, edges, operations) [0, 0]","solution":"def process_operations(N, Q, edges, operations): from collections import defaultdict, deque def build_tree(edges): tree = defaultdict(list) for a, b in edges: tree[a].append(b) return tree def count_active_subtree(root): queue = deque([root]) active_count = 0 while queue: node = queue.popleft() if active[node]: active_count += 1 for child in tree[node]: queue.append(child) return active_count # Initialize the tree structure tree = build_tree(edges) # Initialize the active status for each employee active = [False] * (N + 1) # Process each operation results = [] for operation in operations: op_type, emp_id = operation if op_type == 1: active[emp_id] = True elif op_type == 2: results.append(count_active_subtree(emp_id)) return results"},{"question":"def max_non_overlapping_bridges(N, S, E, parks): Determine the maximum number of non-overlapping bridges that can be constructed. Parameters: N (int): The number of parks along the river. S (int): Start point of the river. E (int): End point of the river. parks (List[Tuple[int, int]]): List of tuples where each tuple contains two integers representing the starting and ending points of a park on the x-axis. Returns: int: The maximum number of non-overlapping bridges that can be constructed. Example: >>> max_non_overlapping_bridges(4, 1, 100, [(1, 5), (2, 6), (8, 10), (7, 9)]) 2 >>> max_non_overlapping_bridges(3, 1, 100, [(1, 2), (3, 4), (5, 6)]) 3","solution":"def max_non_overlapping_bridges(N, S, E, parks): Function to determine the maximum number of non-overlapping bridges. # Sort parks by ending point parks.sort(key=lambda x: x[1]) # Initialize counters count = 0 last_end = S - 1 # Iterate over the sorted parks for start, end in parks: if start > last_end: count += 1 last_end = end return count"},{"question":"def is_palindrome(num: int) -> bool: Returns True if num is a palindrome, False otherwise. >>> is_palindrome(121) True >>> is_palindrome(123) False >>> is_palindrome(1) True >>> is_palindrome(101) True ... def contains_palindrome(A: int, B: int) -> str: Returns 'YES' if there is at least one palindrome in the range [A, B], 'NO' otherwise. >>> contains_palindrome(10, 20) 'YES' >>> contains_palindrome(5, 5) 'YES' >>> contains_palindrome(100, 200) 'YES' >>> contains_palindrome(1, 9) 'YES' >>> contains_palindrome(123, 124) 'NO' ... def palindromes_in_ranges(test_cases: list[tuple[int, int]]) -> list[str]: Handles multiple test cases to determine if each range contains a palindrome. Args: test_cases (list of tuples): List containing pairs of integers defining the ranges. Returns: list of str: List containing 'YES' or 'NO' for each test case. >>> test_cases = [(10, 20), (5, 5), (100, 200), (1, 9), (123, 124)] >>> palindromes_in_ranges(test_cases) ['YES', 'YES', 'YES', 'YES', 'NO'] ...","solution":"def is_palindrome(num): Returns True if num is a palindrome, False otherwise. return str(num) == str(num)[::-1] def contains_palindrome(A, B): Returns 'YES' if there is at least one palindrome in the range [A, B], 'NO' otherwise. for num in range(A, B + 1): if is_palindrome(num): return \\"YES\\" return \\"NO\\" def palindromes_in_ranges(test_cases): Handles multiple test cases to determine if each range contains a palindrome. Args: test_cases (list of tuples): List containing pairs of integers defining the ranges. Returns: list of str: List containing 'YES' or 'NO' for each test case. results = [] for A, B in test_cases: results.append(contains_palindrome(A, B)) return results"},{"question":"def is_symmetric(grid: List[str]) -> str: Checks if the 3x3 grid is symmetric with respect to a 180-degree rotation. Args: grid (list of str): List of three strings, each string representing a row in the 3x3 grid. Returns: str: 'YES' if the grid is symmetric, 'NO' otherwise. >>> is_symmetric([\\"aba\\", \\"cdc\\", \\"aba\\"]) 'YES' >>> is_symmetric([\\"abc\\", \\"def\\", \\"cba\\"]) 'NO' >>> is_symmetric([\\"aaa\\", \\"bbb\\", \\"aaa\\"]) 'YES' >>> is_symmetric([\\"abc\\", \\"bcb\\", \\"cba\\"]) 'YES' >>> is_symmetric([\\"abc\\", \\"def\\"]) Traceback (most recent call last): ... ValueError: Invalid grid size. Grid must be 3x3.","solution":"def is_symmetric(grid): Checks if the 3x3 grid is symmetric with respect to a 180-degree rotation. Args: grid (list of str): List of three strings, each string representing a row in the 3x3 grid. Returns: str: 'YES' if the grid is symmetric, 'NO' otherwise. if len(grid) != 3 or any(len(row) != 3 for row in grid): raise ValueError(\\"Invalid grid size. Grid must be 3x3.\\") return 'YES' if (grid[0] == grid[2][::-1] and grid[1][0] == grid[1][2]) else 'NO'"},{"question":"def can_return_to_origin(s: str) -> bool: Returns true if Petra returns to the origin after executing the commands, otherwise false. Args: s (str): a string of commands consisting of 'U', 'D', 'L', 'R' Returns: bool: True if Petra returns to the origin, False otherwise >>> can_return_to_origin(\\"UUUDDD\\") True >>> can_return_to_origin(\\"UUUUDDDD\\") True >>> can_return_to_origin(\\"UURDD\\") False","solution":"def can_return_to_origin(s): Returns true if Petra returns to the origin after executing the commands, otherwise false. Args: s (str): a string of commands consisting of 'U', 'D', 'L', 'R' Returns: bool: True if Petra returns to the origin, False otherwise x, y = 0, 0 for command in s: if command == 'U': y += 1 elif command == 'D': y -= 1 elif command == 'L': x -= 1 elif command == 'R': x += 1 return x == 0 and y == 0"},{"question":"def max_sum_alice(n: int, arr: List[int]) -> int: Determine the maximum sum Alice can obtain if she plays first in a game where Alice and Bob take turns picking numbers from either end of the array. >>> max_sum_alice(4, [1, 2, 9, 10]) 12 >>> max_sum_alice(1, [10]) 10 >>> max_sum_alice(2, [5, 3]) 5 >>> max_sum_alice(4, [8, 15, 3, 7]) 22 >>> max_sum_alice(5, [2, 2, 2, 2, 2]) 6 >>> max_sum_alice(3, [10000, 10000, 10000]) 20000 >>> import random >>> random.seed(0) >>> arr = [random.randint(1, 10000) for _ in range(500)] >>> result = max_sum_alice(500, arr) >>> result > 0 True pass","solution":"def max_sum_alice(n, arr): Maximize Alice's sum when both Alice and Bob play optimally. This problem is solved using dynamic programming. # Create a 2D dp array where dp[i][j] represents the maximum sum # the current player can achieve from the subarray arr[i:j+1] dp = [[0] * n for _ in range(n)] # Fill the dp array for single elements: the best a player can do is take that element for i in range(n): dp[i][i] = arr[i] # Fill the dp table for length in range(2, n + 1): # length of the subarray for i in range(n - length + 1): j = i + length - 1 dp[i][j] = max(arr[i] - dp[i + 1][j], arr[j] - dp[i][j - 1]) # Since Alice starts first, # Alice's maximum sum is the result in the dp table divided by 2 and the initial array sum divided by 2 return (sum(arr) + dp[0][n - 1]) // 2"},{"question":"def find_max_product(arr): Returns the maximum product that can be obtained by multiplying exactly two distinct elements from the array. Parameters: arr (list): A list of integers. Returns: int: The maximum product of any two distinct elements from the array. Examples: >>> find_max_product([1, 5, 3, 9, 2]) 45 >>> find_max_product([-10, -20, 5, 7]) 200 >>> find_max_product([-10, 20, 5, 7, -3]) 140 >>> find_max_product([10, -20, -30, 5, 2]) 600 >>> find_max_product([3, 4]) 12 >>> find_max_product([1000, 2000, -3000, 5000]) 10000000 >>> find_max_product([-1, -2, -3, -4]) 12","solution":"def find_max_product(arr): Returns the maximum product that can be obtained by multiplying exactly two distinct elements from the array. Parameters: arr (list): A list of integers. Returns: int: The maximum product of any two distinct elements from the array. if len(arr) < 2: raise ValueError(\\"Array must contain at least two elements\\") # Initializing the two largest and two smallest elements max1 = max2 = float('-inf') min1 = min2 = float('inf') for num in arr: # Update the two largest elements if num > max1: max2 = max1 max1 = num elif num > max2: max2 = num # Update the two smallest elements if num < min1: min2 = min1 min1 = num elif num < min2: min2 = num # The maximum product can either be from the two largest or the two smallest numbers (if both are negative) return max(max1 * max2, min1 * min2)"},{"question":"def highest_even_number(digits: str) -> str: Determines the highest possible even number that can be formed from the given string of digits. If no even number can be formed, returns \\"No even number possible\\". >>> highest_even_number(\\"1234\\") \\"4312\\" >>> highest_even_number(\\"13579\\") \\"No even number possible\\" >>> highest_even_number(\\"2020\\") \\"2200\\"","solution":"def highest_even_number(digits): Returns the highest possible even number that can be formed from the given digits, or \\"No even number possible\\" if no even number can be formed. digits = list(digits) even_digits = [d for d in digits if int(d) % 2 == 0] if not even_digits: return \\"No even number possible\\" even_digits.sort() digits.remove(even_digits[0]) digits = sorted(digits, reverse=True) max_number = ''.join(digits) + even_digits[0] return max_number"},{"question":"from typing import List, Tuple def min_strength_difference(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Determine the minimum possible difference in the total strengths of the two teams when each team has exactly half of the warriors. Args: T (int): Number of test cases. test_cases (List[Tuple[int, List[int]]]): Each test case is represented by a tuple containing number of warriors (even integer) and a list of integers representing the strengths of the warriors. Returns: List[int]: A list of integers where each integer represents the minimum possible difference between the total strengths of the two teams for each test case. Example: >>> min_strength_difference(2, [(4, [2, 4, 5, 7]), (6, [1, 3, 4, 9, 8, 6])]) [0, 1]","solution":"from itertools import combinations def min_strength_difference(T, test_cases): results = [] for t in range(T): N = test_cases[t][0] warriors = test_cases[t][1] total_sum = sum(warriors) half_team_size = N // 2 all_combinations = list(combinations(warriors, half_team_size)) min_diff = float('inf') for combo in all_combinations: team1_sum = sum(combo) team2_sum = total_sum - team1_sum diff = abs(team1_sum - team2_sum) min_diff = min(min_diff, diff) results.append(min_diff) return results"},{"question":"def find_visit_order(n: int, bridges: List[Tuple[int, int]]) -> List[int]: Determines the sequence of islands visited starting from island 1. :param n: The number of islands. :param bridges: List of tuples representing the bridges (ai, bi). :returns: List of islands in the order of visitation starting from island 1. pass # Unit tests def test_three_islands(): assert find_visit_order(3, [(1, 2), (2, 3)]) == [1, 2, 3] def test_four_islands(): assert find_visit_order(4, [(1, 3), (3, 4), (4, 2)]) == [1, 3, 4, 2] def test_five_islands(): assert find_visit_order(5, [(1, 2), (2, 3), (3, 4), (4, 5)]) == [1, 2, 3, 4, 5] def test_disordered_input(): assert find_visit_order(4, [(3, 4), (1, 3), (4, 2)]) == [1, 3, 4, 2] def test_minimal_case(): assert find_visit_order(2, [(1, 2)]) == [1, 2]","solution":"def find_visit_order(n, bridges): Determines the sequence of islands visited starting from island 1. :param n: The number of islands. :param bridges: List of tuples representing the bridges (ai, bi). :returns: List of islands in the order of visitation starting from island 1. from collections import defaultdict # Create the graph representation from the given bridges graph = defaultdict(list) for u, v in bridges: graph[u].append(v) # Start the journey from island 1 and traverse accordingly visit_sequence = [] current_island = 1 while current_island in graph: visit_sequence.append(current_island) # Move to the next island which is connected by a single bridge current_island = graph[current_island][0] # Add the last island which has no outgoing bridge visit_sequence.append(current_island) return visit_sequence"},{"question":"def canFormPalindrome(s: str) -> str: Determines if the given string can be rearranged to form a palindrome. Returns \\"YES\\" if possible, otherwise \\"NO\\". Args: s (str): A string consisting of lowercase English letters. Returns: str: \\"YES\\" if the input string can be rearranged to form a palindrome, otherwise \\"NO\\". Examples: >>> canFormPalindrome(\\"carrace\\") \\"YES\\" >>> canFormPalindrome(\\"daily\\") \\"NO\\" # your code here # Unit tests def test_example_palindrome(): assert canFormPalindrome(\\"carrace\\") == \\"YES\\" def test_example_not_palindrome(): assert canFormPalindrome(\\"daily\\") == \\"NO\\" def test_single_character(): assert canFormPalindrome(\\"a\\") == \\"YES\\" def test_all_characters_same(): assert canFormPalindrome(\\"aaaa\\") == \\"YES\\" def test_even_occurrences(): assert canFormPalindrome(\\"aabb\\") == \\"YES\\" def test_odd_occurrences(): assert canFormPalindrome(\\"abb\\") == \\"YES\\" assert canFormPalindrome(\\"abbb\\") == \\"NO\\" def test_empty_string(): assert canFormPalindrome(\\"\\") == \\"YES\\" def test_non_palindromic_set(): assert canFormPalindrome(\\"abcda\\") == \\"NO\\" @pytest.mark.parametrize(\\"input_str\\", [ \\"a\\", \\"aba\\", \\"abccba\\", \\"xyzzyx\\", \\"madam\\", \\"aabbccddeeffgg\\", ]) def test_positive_cases(input_str): assert canFormPalindrome(input_str) == \\"YES\\" @pytest.mark.parametrize(\\"input_str\\", [ \\"abcd\\", \\"abcdaef\\", \\"racecars\\", \\"abcdef\\", \\"aabbccddeegh\\" ]) def test_negative_cases(input_str): assert canFormPalindrome(input_str) == \\"NO\\"","solution":"def canFormPalindrome(s: str) -> str: Determines if the given string can be rearranged to form a palindrome. Returns \\"YES\\" if possible, otherwise \\"NO\\". from collections import Counter # Count the frequency of each character freq = Counter(s) # Count how many characters have an odd frequency odd_count = sum(1 for count in freq.values() if count % 2 != 0) # For a string to be rearranged into a palindrome, it can have at most one character with an odd frequency return \\"YES\\" if odd_count <= 1 else \\"NO\\""},{"question":"from typing import List def can_rearrange_no_adjacent(N: int, numbers: List[int]) -> str: Determine if it is possible to rearrange the numbers such that no two adjacent numbers are the same. >>> can_rearrange_no_adjacent(4, [1, 1, 2, 2]) 'YES' >>> can_rearrange_no_adjacent(5, [4, 4, 4, 4, 4]) 'NO' >>> can_rearrange_no_adjacent(6, [1, 2, 2, 3, 3, 4]) 'YES'","solution":"from collections import Counter import heapq def can_rearrange_no_adjacent(N, numbers): freq = Counter(numbers) max_heap = [(-count, num) for num, count in freq.items()] heapq.heapify(max_heap) prev_count, prev_num = 0, None result = [] while max_heap: count, num = heapq.heappop(max_heap) result.append(num) if prev_count < 0: heapq.heappush(max_heap, (prev_count, prev_num)) prev_count, prev_num = count + 1, num if len(result) == N: return \\"YES\\" else: return \\"NO\\""},{"question":"def is_almost_palindromic(s: str) -> str: Determines if the given string can be made into a palindrome by changing exactly one character. >>> is_almost_palindromic(\\"radar\\") \\"NO\\" >>> is_almost_palindromic(\\"racecar\\") \\"NO\\" >>> is_almost_palindromic(\\"abcdef\\") \\"NO\\" >>> is_almost_palindromic(\\"abcca\\") \\"YES\\" pass def process_test_cases(test_cases: List[str]) -> List[str]: Processes a list of test cases and returns the results for each case. >>> process_test_cases([\\"radar\\", \\"racecar\\", \\"abcdef\\", \\"abcca\\"]) [\\"NO\\", \\"NO\\", \\"NO\\", \\"YES\\"] >>> process_test_cases([\\"abba\\", \\"abbc\\", \\"abcd\\", \\"abca\\"]) [\\"NO\\", \\"YES\\", \\"NO\\", \\"YES\\"] pass","solution":"def is_almost_palindromic(s): Determines if the given string can be made into a palindrome by changing exactly one character. n = len(s) mismatch_count = 0 for i in range(n // 2): if s[i] != s[n - i - 1]: mismatch_count += 1 if mismatch_count > 1: return \\"NO\\" return \\"YES\\" if mismatch_count == 1 else \\"NO\\" def process_test_cases(test_cases): Processes a list of test cases and returns the results for each case. results = [] for s in test_cases: results.append(is_almost_palindromic(s)) return results"},{"question":"from typing import List def min_path_danger(grid: List[List[int]]) -> int: Calculate the minimum path danger from the top-left to the bottom-right corner of the grid. The grid is represented by a list of lists of integers, where each integer is the danger level of a cell. The knight can only move right or down from each cell. >>> min_path_danger([ ... [1, 3, 1], ... [1, 5, 1], ... [4, 2, 1] ... ]) 7 >>> min_path_danger([ ... [0] ... ]) 0 import pytest def test_min_path_danger_example(): grid = [ [1, 3, 1], [1, 5, 1], [4, 2, 1] ] assert min_path_danger(grid) == 7 def test_min_path_danger_single_cell(): grid = [ [0] ] assert min_path_danger(grid) == 0 def test_min_path_danger_two_cells(): grid = [ [1, 2], [2, 3] ] assert min_path_danger(grid) == 6 def test_min_path_danger_all_zeros(): grid = [ [0, 0], [0, 0] ] assert min_path_danger(grid) == 0 def test_min_path_danger_large_numbers(): grid = [ [1000000, 1000000], [1000000, 1000000] ] assert min_path_danger(grid) == 3000000 @pytest.fixture def large_grid(): n, m = 1000, 1000 grid = [[1] * m for _ in range(n)] return grid def test_min_path_danger_large_grid(large_grid): result = min_path_danger(large_grid) assert result == 1999","solution":"def min_path_danger(grid): Returns the minimum path danger from the top-left to the bottom-right corner in the grid. n = len(grid) m = len(grid[0]) # Initialize a dp table with the same dimensions as the grid dp = [[0] * m for _ in range(n)] # Set the starting cell with the initial danger level dp[0][0] = grid[0][0] # Fill the first row (can only come from the left) for j in range(1, m): dp[0][j] = dp[0][j-1] + grid[0][j] # Fill the first column (can only come from above) for i in range(1, n): dp[i][0] = dp[i-1][0] + grid[i][0] # Fill the rest of the dp table for i in range(1, n): for j in range(1, m): dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j] # The bottom-right corner contains the result return dp[-1][-1]"}]`),S={name:"App",components:{PoemCard:A},data(){return{searchQuery:"",visibleCount:4,poemsData:E,isLoading:!1}},computed:{filteredPoems(){const n=this.searchQuery.trim().toLowerCase();return n?this.poemsData.filter(e=>e.question&&e.question.toLowerCase().includes(n)||e.solution&&e.solution.toLowerCase().includes(n)):this.poemsData},displayedPoems(){return this.searchQuery.trim()?this.filteredPoems:this.filteredPoems.slice(0,this.visibleCount)},hasMorePoems(){return!this.searchQuery.trim()&&this.visibleCount<this.poemsData.length}},methods:{async loadMore(){this.isLoading=!0,await new Promise(n=>setTimeout(n,1e3)),this.visibleCount+=4,this.isLoading=!1}}},j={class:"search-container"},D={class:"card-container"},O={key:0,class:"empty-state"},Y=["disabled"],P={key:0},I={key:1};function C(n,e,u,c,r,a){const f=h("PoemCard");return s(),i("section",null,[e[4]||(e[4]=t("div",{class:"top-banner"},[t("div",{class:"top-banner-title"},[t("div",{class:"top-banner-title-text"},"🤔prompts chat🧠")])],-1)),t("div",j,[e[3]||(e[3]=t("span",{class:"search-icon"},"🔍",-1)),g(t("input",{type:"text",class:"search-input","onUpdate:modelValue":e[0]||(e[0]=o=>r.searchQuery=o),placeholder:"Search..."},null,512),[[b,r.searchQuery]]),r.searchQuery?(s(),i("button",{key:0,class:"clear-search",onClick:e[1]||(e[1]=o=>r.searchQuery="")}," ✕ ")):l("",!0)]),t("div",D,[(s(!0),i(x,null,y(a.displayedPoems,(o,p)=>(s(),v(f,{key:p,poem:o},null,8,["poem"]))),128)),a.displayedPoems.length===0?(s(),i("div",O,' No results found for "'+_(r.searchQuery)+'". ',1)):l("",!0)]),a.hasMorePoems?(s(),i("button",{key:0,class:"load-more-button",disabled:r.isLoading,onClick:e[2]||(e[2]=(...o)=>a.loadMore&&a.loadMore(...o))},[r.isLoading?(s(),i("span",I,"Loading...")):(s(),i("span",P,"See more"))],8,Y)):l("",!0)])}const z=m(S,[["render",C],["__scopeId","data-v-374989a5"]]),B=JSON.parse('{"title":"","description":"","frontmatter":{"page":true},"headers":[],"relativePath":"library/26.md","filePath":"library/26.md"}'),F={name:"library/26.md"},G=Object.assign(F,{setup(n){return(e,u)=>(s(),i("div",null,[w(z)]))}});export{B as __pageData,G as default};
