import{_ as m,o as n,c as r,a as t,m as d,t as h,C as p,M as _,U as b,f as l,F as y,p as w,e as v,q as x}from"./chunks/framework.B1z0IdBH.js";const k={name:"PoemCard",props:{poem:{type:Object,required:!0}}},q={class:"poem-container"},T={class:"review"},j={class:"review-title"},R={class:"review-content"};function I(i,e,u,c,s,a){return n(),r("div",q,[t("div",T,[t("div",j,[e[0]||(e[0]=t("span",{class:"icon"},"question:",-1)),d(h(u.poem.question),1)]),e[2]||(e[2]=t("div",{class:"divider"},null,-1)),t("p",R,[e[1]||(e[1]=t("span",{class:"icon"},"answer:",-1)),d(h(u.poem.solution),1)])])])}const Y=m(k,[["render",I],["__scopeId","data-v-2061af46"]]),A=JSON.parse('[{"question":"You are given a list of strings `words` where each string consists of lowercase letters. A **word ladder** is a sequence of words `w1, w2, ..., wk` such that each word in the sequence has exactly one letter different from the previous word. The first word `w1` is provided, and the final word `wk` is the target word to find. Return the length of the shortest transformation sequence from the start word to the target word. If no such sequence exists, return 0.","solution":"from collections import deque def word_ladder_length(start: str, target: str, words: list) -> int: Returns the length of the shortest transformation sequence from start to target word. If no such sequence exists, return 0. if target not in words: return 0 word_set = set(words) queue = deque([(start, 1)]) # Each element in the queue is a tuple (current_word, current_length) while queue: current_word, current_length = queue.popleft() if current_word == target: return current_length # Try changing each character in the current word to every possible lowercase letter for i in range(len(current_word)): for c in \'abcdefghijklmnopqrstuvwxyz\': next_word = current_word[:i] + c + current_word[i+1:] if next_word in word_set: word_set.remove(next_word) queue.append((next_word, current_length + 1)) return 0"},{"question":"A company\'s finance department needs a program to manage and monitor transactions. You are given an integer array `transactions` where `transactions[i]` represents an amount deposited or withdrawn. Implement a system where you can perform the following operations: - `TransactionSystem(int[] transactions)`: Initializes the system with the given list of transactions. - `void addTransaction(int amount)`: Adds a new transaction to the end of the transactions list. - `int currentBalance()`: Returns the current balance which is the sum of all transactions in the list. - `int maxTransaction()`: Returns the maximum transaction amount recorded. Design and implement the `TransactionSystem` class accordingly.","solution":"class TransactionSystem: def __init__(self, transactions): Initializes the system with the given list of transactions. self.transactions = transactions def addTransaction(self, amount): Adds a new transaction to the end of the transactions list. self.transactions.append(amount) def currentBalance(self): Returns the current balance which is the sum of all transactions in the list. return sum(self.transactions) def maxTransaction(self): Returns the maximum transaction amount recorded. return max(self.transactions)"},{"question":"You are given an array of integers representing the number of tokens you can collect in a game. Each token grants you a certain number of points. You can perform one of two actions on a token: 1. You can spend a token at position `i` to gain `points[i]` points. 2. You can discard a token at position `i` to move to the next token at position `i + 1`. However, there is a constraint: once you discard a token, you must discard at least one of the following tokens before you can spend another token. For example, if you discard the token at position `i`, you must also discard the token at position `i + 1` before you can spend the token at position `i + 2`. Write a function that calculates the maximum number of points you can accumulate by optimally choosing to spend or discard tokens according to the given rules. **Input:** - An array of integers `points` where `points[i]` represents the points gained from spending the token at position `i`. **Output:** - An integer representing the maximum points that can be accumulated.","solution":"def max_points(points): n = len(points) if n == 0: return 0 elif n == 1: return points[0] dp = [0] * n dp[0] = points[0] if n > 1: dp[1] = max(points[0], points[1]) for i in range(2, n): dp[i] = max(dp[i - 1], points[i] + dp[i - 2]) return dp[-1]"},{"question":"Given a matrix `mat` where each row is sorted in non-decreasing order, return the **smallest common element** in all rows. If there is no common element, return `-1`. For example, if `mat` is: ``` [ [1, 2, 3, 4, 5], [2, 4, 5, 8, 10], [3, 5, 7, 9, 11], [1, 3, 5, 7, 9] ] ``` The smallest common element in all rows is `5`. If no such element exists, return `-1`.","solution":"def smallest_common_element(mat): Finds the smallest common element in all rows of the matrix. If no such element exists, returns -1. from collections import Counter # Flatten the matrix and count the occurrences of each element count = Counter() for row in mat: count.update(set(row)) # Use set to avoid counting duplicate elements in a single row # Find the smallest element that appears in all rows num_rows = len(mat) common_elements = [elem for elem, freq in count.items() if freq == num_rows] return min(common_elements) if common_elements else -1"},{"question":"Given an integer array `nums` and an integer `k`, modify the array in the following way: Choose an index `i` and increment `nums[i]` by `1`, but you can only perform this operation at most `k` times. Return the **maximum** possible element in the array after performing the operation at most `k` times. Implement the function `maximizeElement(nums: List[int], k: int) -> int`. Example: ``` Input: nums = [1, 2, 4], k = 2 Output: 6 Explanation: Increment the last element twice to get [1, 2, 6]. The maximum element is 6. ```","solution":"from typing import List def maximizeElement(nums: List[int], k: int) -> int: nums.sort() nums[-1] += k return nums[-1]"},{"question":"You are given an integer array `heights` where `heights[i]` is the height of the `ith` building. A building `i` can see another building `j` if `i < j` and `heights[i] > heights[j]`, and there are no buildings of equal or greater height between building `i` and building `j`. A building with height `h` is considered exposed if there are no buildings taller than `h` to its right. Return the total number of exposed buildings.","solution":"def count_exposed_buildings(heights): Returns the number of exposed buildings in the given list of building heights. A building is considered exposed if there are no buildings taller than it to its right. Parameters: heights (List[int]): A list of integers representing the heights of buildings. Returns: int: The count of exposed buildings. n = len(heights) if n == 0: return 0 exposed_count = 0 max_right = 0 for i in range(n-1, -1, -1): if heights[i] > max_right: exposed_count += 1 max_right = heights[i] return exposed_count"},{"question":"You are given an array `arr` of integers and another integer `k`. You can perform the following operation exactly once: choose any subarray of `arr` and reverse it. Return the maximum possible sum of any `k` consecutive elements of the array after performing the operation. If it is not possible to achieve a sequence of `k` consecutive elements, return `-1`.","solution":"def max_sum_after_reverse(arr, k): if len(arr) < k: return -1 def max_subarray_sum(arr, k): max_sum = float(\'-inf\') current_sum = sum(arr[:k]) max_sum = max(max_sum, current_sum) for i in range(k, len(arr)): current_sum += arr[i] - arr[i-k] max_sum = max(max_sum, current_sum) return max_sum max_sum = max_subarray_sum(arr, k) for start in range(len(arr)): for end in range(start + 1, len(arr) + 1): reversed_arr = arr[:start] + arr[start:end][::-1] + arr[end:] max_sum = max(max_sum, max_subarray_sum(reversed_arr, k)) return max_sum"},{"question":"You are given a list of `n` strings, where each string is composed of lowercase letters. Your task is to group the strings that are **anagrams** of each other. An anagram is a word formed by rearranging the letters of another word. Return the list of groups of anagrams, where each group contains strings that are anagrams of each other, sorted in alphabetical order. Each group should also be sorted alphabetically. For example, given `[\\"eat\\", \\"tea\\", \\"tan\\", \\"ate\\", \\"nat\\", \\"bat\\"]`, your function should return `[[\\"ate\\", \\"eat\\", \\"tea\\"], [\\"bat\\"], [\\"nat\\", \\"tan\\"]]`.","solution":"def group_anagrams(strings): Groups the given list of strings into anagrams. Parameters: strings (List[str]): A list of strings. Returns: List[List[str]]: A list of groups, each containing anagrams sorted alphabetically. from collections import defaultdict anagrams = defaultdict(list) for string in strings: sorted_string = \'\'.join(sorted(string)) anagrams[sorted_string].append(string) result = [] for group in anagrams.values(): result.append(sorted(group)) return sorted(result, key=lambda x: x[0])"},{"question":"Given a string `s` and a dictionary of words `dict`, find all the starting indices of `dict`\'s words in `s`. Return the starting indices in an array in ascending order. You may assume a word\'s length is greater than `0` and no words in `dict` are substrings of another word in `dict`.","solution":"def find_word_indices(s, dict): Returns a list of starting indices of each word from the dictionary in the string s. indices = [] for word in dict: start = 0 while True: start = s.find(word, start) if start == -1: break indices.append(start) start += 1 # Move past the last found word\'s start position return sorted(indices)"},{"question":"Given a 2D binary matrix filled with 0\'s and 1\'s, find the largest rectangle containing only 1\'s and return its area. A rectangle is defined as a group of contiguous cells arranged in a rectangular shape, where each cell contains a 1. The matrix is represented as a list of lists, where each inner list is a row of the matrix. Each element in the matrix is either 0 or 1. You need to implement a function `int maximalRectangle(vector<vector<int>>& matrix)` that takes the matrix as input and returns the area of the largest rectangle filled with only 1\'s.","solution":"def maximalRectangle(matrix): Given a 2D binary matrix filled with 0\'s and 1\'s, find the largest rectangle containing only 1\'s and return its area. if not matrix or not matrix[0]: return 0 max_area = 0 num_cols = len(matrix[0]) heights = [0] * num_cols for row in matrix: for j in range(num_cols): heights[j] = heights[j] + 1 if row[j] == 1 else 0 max_area = max(max_area, largestRectangleArea(heights)) return max_area def largestRectangleArea(heights): Helper function to compute the largest rectangle area in a histogram. stack = [] max_area = 0 heights.append(0) for i in range(len(heights)): while stack and heights[i] < heights[stack[-1]]: h = heights[stack.pop()] w = i if not stack else i - stack[-1] - 1 max_area = max(max_area, h * w) stack.append(i) heights.pop() return max_area"},{"question":"You are given a string `sequence` and a string `word`. Count the maximum number of times that `word` can be repeated in the `sequence` such that `word` is a contiguous substring in `sequence`. If the `word` can be repeated `k` times such that it forms a contiguous substring in `sequence`, then return `k`.","solution":"def max_repeating(sequence, word): Returns the maximum number of times that `word` can be repeated in `sequence` such that `word` is a contiguous substring in `sequence`. k = 0 while word * (k + 1) in sequence: k += 1 return k"},{"question":"You are given a 2D grid `grid` representing a map where each cell can be either water (`0`) or land (`1`). - An island is a maximal group of connected land cells, where each cell is connected horizontally or vertically. - A lake is a group of connected water cells that are completely surrounded by land cells. Write a function to determine the number of lakes in the given grid. You may assume that the grid has at least one cell and that it is completely surrounded by land cells. Return _the number of lakes_ in the `grid`.","solution":"def num_lakes(grid): Returns the number of lakes in the given grid. A lake is defined as a group of connected water cells that are completely surrounded by land cells. def dfs(grid, i, j): if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or grid[i][j] != 0: return grid[i][j] = -1 # Mark the cell as visited for x, y in [(0, 1), (1, 0), (0, -1), (-1, 0)]: dfs(grid, i + x, j + y) lakes = 0 for i in range(1, len(grid) - 1): for j in range(1, len(grid[0]) - 1): if grid[i][j] == 0: # check if surrounding are all lands or not is_lake = all(grid[i+di][j+dj] == 1 or grid[i+di][j+dj] == -1 for di, dj in [(-1,0),(1,0),(0,-1),(0,1)]) if is_lake: dfs(grid, i, j) lakes += 1 return lakes"},{"question":"You are given an undirected graph with `n` nodes labeled from `0` to `n-1` and an array `edges` where `edges[i] = [a, b]` indicates that there is an undirected edge between nodes `a` and `b`. A graph is considered a tree if it is connected and acyclic. Return whether the given graph is a valid tree using this definition.","solution":"def valid_tree(n, edges): from collections import defaultdict, deque if len(edges) != n - 1: return False graph = defaultdict(list) for a, b in edges: graph[a].append(b) graph[b].append(a) visited = set() queue = deque([0]) while queue: node = queue.popleft() if node in visited: continue visited.add(node) for neighbor in graph[node]: if neighbor not in visited: queue.append(neighbor) return len(visited) == n"},{"question":"You are given an array of integers `heights` representing the heights of buildings in a skyline. The width of each building is `1`. The skyline view is blocked when a taller or equal building is in front of a shorter one from left to right. Return the number of buildings that can see the sunset if they look to the right. A building can see the sunset if it is taller than all the buildings to its right.","solution":"def count_buildings_with_sunset_view(heights): Returns the number of buildings that can see the sunset. count = 0 max_height_so_far = 0 # Traverse the heights from right to left for height in reversed(heights): if height > max_height_so_far: count += 1 max_height_so_far = height return count"},{"question":"You are given a matrix `m` of dimensions `n x n` consisting of non-negative integers. Find the length of the longest path in the matrix where each step in the path increases the value of the previous step. You can move up, down, left, or right from a cell. Return the length of the longest path found.","solution":"def longest_increasing_path(matrix): Finds the length of the longest path in the matrix where each step increases the value of the previous step. You can move up, down, left, or right from a cell. :param matrix: List[List[int]] :return: int if not matrix or not matrix[0]: return 0 n = len(matrix) m = len(matrix[0]) dp = [[-1 for _ in range(m)] for _ in range(n)] def dfs(i, j): if dp[i][j] != -1: return dp[i][j] directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] max_length = 1 for di, dj in directions: ni, nj = i + di, j + dj if 0 <= ni < n and 0 <= nj < m and matrix[ni][nj] > matrix[i][j]: max_length = max(max_length, 1 + dfs(ni, nj)) dp[i][j] = max_length return dp[i][j] longest_path = 0 for i in range(n): for j in range(m): longest_path = max(longest_path, dfs(i, j)) return longest_path"},{"question":"Given a `2D` grid of size `m x n` and a list of `q` queries, each containing the coordinates of the top-left and bottom-right corners of a sub-grid, implement a function to return the sum of integers in each sub-grid for every query. You may assume that each integer in the grid is non-negative.","solution":"def preprocess_grid(grid): Preprocess the grid to calculate the prefix sum matrix. m = len(grid) n = len(grid[0]) prefix_sum = [[0] * (n + 1) for _ in range(m + 1)] for i in range(1, m + 1): for j in range(1, n + 1): prefix_sum[i][j] = grid[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1] return prefix_sum def sum_subgrid(prefix_sum, top_left, bottom_right): Calculate the sum of integers in the sub-grid defined by the top-left and bottom-right corners. r1, c1 = top_left r2, c2 = bottom_right return prefix_sum[r2 + 1][c2 + 1] - prefix_sum[r1][c2 + 1] - prefix_sum[r2 + 1][c1] + prefix_sum[r1][c1] def grid_queries(grid, queries): Return the sum of integers in each sub-grid specified by the queries. prefix_sum = preprocess_grid(grid) results = [] for top_left, bottom_right in queries: results.append(sum_subgrid(prefix_sum, top_left, bottom_right)) return results"},{"question":"Consider you own a small robot which can be represented on a 2D grid. The robot has four possible movements: `U` (up), `D` (down), `L` (left), and `R` (right). The initial position of the robot is at the origin (0, 0). You are given a string `instructions` which represents the movement sequence of the robot. Write a function that returns `True` if the robot returns to the origin after executing all the given movements, otherwise return `False`.","solution":"def is_back_to_origin(instructions): Returns True if the robot returns to the origin after executing all the given movements, otherwise returns False. Parameters: instructions (str): a string of movements where \'U\' means up, \'D\' means down, \'L\' means left, and \'R\' means right. Returns: bool: True if the robot returns to the origin, otherwise False. x, y = 0, 0 for move in instructions: if move == \'U\': y += 1 elif move == \'D\': y -= 1 elif move == \'L\': x -= 1 elif move == \'R\': x += 1 return x == 0 and y == 0"},{"question":"Given a string of lowercase characters, return the number of distinct substrings of the given string. A substring is defined as any contiguous sequence of characters within the string. Implement the `distinctSubstrings` function: * `int distinctSubstrings(String s)` - Returns the number of distinct substrings of the string `s`.","solution":"def distinctSubstrings(s): Returns the number of distinct substrings of the given string. Parameters: s (str): A string of lowercase characters Returns: int: The number of distinct substrings in the string n = len(s) substrings = set() for i in range(n): for j in range(i + 1, n + 1): substrings.add(s[i:j]) return len(substrings)"},{"question":"You are given a string `s` consisting of lowercase English letters and an integer `k`. You need to remove the minimum number of characters from the string so that the frequency of each distinct character in the resulting string is at most `k`. Return _the **minimum** number of characters you need to remove to achieve this_. # Note The frequency of a character in a string is the number of times it appears in the string.","solution":"from collections import Counter def min_removals_to_limit_frequency(s, k): Returns the minimum number of characters to remove from the string `s` so that the frequency of each distinct character is at most `k`. freq = Counter(s) removals = 0 for char, count in freq.items(): if count > k: removals += count - k return removals"},{"question":"You are given a string `s` consisting of lowercase letters and an integer `n`. In one operation, you can choose any character in the string and change it to any lowercase letter. Your goal is to make the string\'s length `n` by either deleting characters (if `s` is longer than `n`) or appending characters (if `s` is shorter than `n`). Return _the minimum number of operations needed to achieve a string of length `n` where the string consists of alternating characters \'a\' and \'b\' starting with \'a\'._","solution":"def min_operations_to_alternating(s, n): Returns the minimum number of operations needed to achieve a string of length `n` where the string consists of alternating characters \'a\' and \'b\' starting with \'a\'. # Generate the target pattern of length n. target = \'\'.join(\'a\' if i % 2 == 0 else \'b\' for i in range(n)) # Calculate the number of operations needed to adjust the length of the input string. if len(s) < n: operations = n - len(s) else: operations = len(s) - n # Compute the number of operations needed to match the target pattern. s = s[:n] # Trim the string to the length n if it is longer than n for i in range(min(len(s), n)): if s[i] != target[i]: operations += 1 return operations"},{"question":"Given an array of integers `height` representing the height of terrain at various points along a line, you are tasked to calculate the amount of water trapped after a rainfall. Each element in the `height` array represents the height at that point. You must determine the total volume of water that can be trapped between the peaks. For example, given an elevation map `height = [0,1,0,2,1,0,1,3,2,1,2,1]`, your function should return `6`, representing the total units of water that can be trapped between the elevations. Write a function that takes in this array and returns the total volume of trapped water.","solution":"def trap(height): Calculate the amount of water trapped after rainfall. :param height: List[int] - the heights of the terrains :return: int - total volume of water trapped if not height: return 0 left, right = 0, len(height) - 1 left_max, right_max = height[left], height[right] water_trapped = 0 while left < right: if height[left] < height[right]: if height[left] >= left_max: left_max = height[left] else: water_trapped += left_max - height[left] left += 1 else: if height[right] >= right_max: right_max = height[right] else: water_trapped += right_max - height[right] right -= 1 return water_trapped"},{"question":"You are given a string `s` and a list of words `words`, each of which is a prefix of `s`. Return _the longest string from the list `words` that is a prefix of `s`_. If there is a tie, return _the string that appears earlier in the list_.","solution":"def longest_prefix(s, words): Returns the longest string from the list words that is a prefix of s. If there is a tie, returns the string that appears earlier in words. :param s: The main string. :param words: A list of words which are prefixes of s. :return: The longest prefix from words that is a prefix of s. longest = \\"\\" for word in words: if s.startswith(word): if len(word) > len(longest): longest = word return longest"},{"question":"You are given a string `s` and an array of strings `words`. Write a function to determine if `s` is a **prefix string** of any string in `words`. A **prefix string** of a string in an array is a non-empty substring that appears at the beginning of at least one of the strings in the array. Return `true` if `s` is a prefix string of any string in `words`, or `false` otherwise.","solution":"def is_prefix_string(s, words): Determines if s is a prefix string of any string in words. Args: s (str): The potential prefix string. words (list of str): The list of strings to check against. Returns: bool: True if s is a prefix string of any string in words, False otherwise. if not s or not words: return False for word in words: if word.startswith(s): return True return False"},{"question":"You are given an integer array `nums` that contains `n` integers, where each integer represents a different color, numbered from 1 to `n`. Each color appears exactly once in the array. You are also given a list `pairs` of pairs of positions `(a, b)` where `1 <= a < b <= n`. Your task is to determine if it\'s possible to reorder the `nums` array such that for each pair `(a, b)` in `pairs`, `nums[a-1]` is less than `nums[b-1]`. Return _`true`_ if it\'s possible to reorder the array to satisfy all pairs, otherwise return _`false`_. Make sure to provide a clear and comprehensive solution that explains the approach and algorithms used to solve the problem.","solution":"def can_reorder(nums, pairs): Determines if it\'s possible to reorder the nums array such that for each pair (a, b) in pairs, nums[a-1] is less than nums[b-1]. Args: nums : List[int] The array containing n different integers representing colors. pairs : List[Tuple[int, int]] List of pairs (a, b) where 1 <= a < b <= n. Returns: bool True if it\'s possible to reorder the array to satisfy all pairs, otherwise False. from collections import defaultdict # Build adjacency list for pairs adj = defaultdict(list) in_degree = {num: 0 for num in nums} for a, b in pairs: adj[nums[a-1]].append(nums[b-1]) in_degree[nums[b-1]] += 1 # Topological sort using Kahn\'s algorithm queue = [num for num in nums if in_degree[num] == 0] sorted_order = [] while queue: node = queue.pop(0) sorted_order.append(node) for neighbor in adj[node]: in_degree[neighbor] -= 1 if in_degree[neighbor] == 0: queue.append(neighbor) # If topological sort includes all elements, return True, else False return len(sorted_order) == len(nums)"},{"question":"Given a string `s` consisting of \'(\' and \')\' characters, you need to determine if the given string is valid. A string is considered valid if the parentheses are properly matched and nested. Specifically, pay attention to the following rules: * Each open parenthesis \'(\' must have a corresponding close parenthesis \')\'. * Open parenthesis \'(\' must be closed in the correct order. * An empty string is considered valid. Return `true` if the given string is valid, and `false` otherwise.","solution":"def is_valid_parentheses(s): Determine if the given string of parentheses is valid. A string is valid if: - Each open parenthesis \'(\' has a corresponding close parenthesis \')\'. - Open parenthesis \'(\' must be closed in the correct order. :param s: String consisting of \'(\' and \')\' characters. :return: Boolean indicating if the string is valid. stack = [] for char in s: if char == \'(\': stack.append(char) elif char == \')\': if not stack: return False stack.pop() return not stack"},{"question":"Given a binary search tree (BST) with `n` nodes, write a function to determine if the tree is height-balanced. A binary tree is height-balanced if for every node in the tree, the height difference between the left and right subtree is no more than one. The height of a node is the number of edges on the longest downward path between that node and a leaf. Return `true` if the tree is height-balanced or `false` if it is not.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_balanced(root): Determine if the BST is height-balanced. def check_height(node): if not node: return 0, True left_height, left_balanced = check_height(node.left) right_height, right_balanced = check_height(node.right) if not left_balanced or not right_balanced: return 0, False if abs(left_height - right_height) > 1: return 0, False return max(left_height, right_height) + 1, True _, balanced = check_height(root) return balanced"},{"question":"Write a function that takes an array of integers and a target integer as input, and returns _whether there are two distinct numbers in the array that add up to the target integer_. The function should return `true` if such a pair exists, and `false` otherwise. The same element cannot be used twice. You can assume that all input numbers are positive and the array will contain at least two elements. The output should be a boolean value.","solution":"def has_pair_with_sum(arr, target): Returns whether there are two distinct numbers in the array that add up to the target integer. seen_numbers = set() for num in arr: complement = target - num if complement in seen_numbers: return True seen_numbers.add(num) return False"},{"question":"You are given a **connected** undirected graph with `n` nodes labeled from `0` to `n-1` and an integer `k`. The `graph` is represented by a 2D integer array `edges`, where `edges[i] = [ui, vi]` denotes an undirected edge between node `ui` and node `vi`. Return _the number of **connected components** formed after removing exactly `k` edges from the graph. If it is not possible to remove `k` edges, return `-1`_.","solution":"def count_connected_components(n, edges, k): Return the number of connected components formed after removing exactly k edges from the graph. If it is not possible to remove k edges, return -1. from collections import defaultdict from itertools import combinations # Helper function to find the connected components using DFS def dfs(node, visited, graph): stack = [node] while stack: current = stack.pop() for neighbor in graph[current]: if not visited[neighbor]: visited[neighbor] = True stack.append(neighbor) # Check if k edges can be removed if k > len(edges): return -1 components_cnt = [] # Try removing all possible k edges combinations for remove_edges in combinations(edges, k): # Create a new graph without the removed edges new_graph = defaultdict(list) for u, v in edges: if [u, v] not in remove_edges and [v, u] not in remove_edges: new_graph[u].append(v) new_graph[v].append(u) # Using DFS to count components visited = [False] * n subcomponents = 0 for node in range(n): if not visited[node]: visited[node] = True dfs(node, visited, new_graph) subcomponents += 1 components_cnt.append(subcomponents) return min(components_cnt) if components_cnt else -1"},{"question":"You are given an array of positive integers `nums` and an integer `target`. Write a function that checks if there exists a contiguous subarray whose sum is equal to `target`. If such a subarray exists, return `true`; otherwise, return `false`. A subarray is a contiguous part of an array. * For example, given the array `[1, 2, 3, 7, 5]` and target `12`, there exists a subarray `[5, 7]` which sums to `12`, so the output should be `true`. * Given the array `[1, 2, 3, 7, 5]` and target `9`, no such subarray exists, so the output should be `false`.","solution":"def has_continuous_subarray_with_sum(nums, target): Determines if there is a contiguous subarray in nums that sums up to target. :param nums: List of positive integers :param target: Integer target sum :return: True if such a subarray exists, False otherwise current_sum = 0 start = 0 for end in range(len(nums)): current_sum += nums[end] # If current_sum exceeds target, reduce it by removing elements from the start while current_sum > target and start <= end: current_sum -= nums[start] start += 1 # Check if the current subarray sum is equal to target if current_sum == target: return True return False"},{"question":"You are given an integer array `nums` and an integer `k`. Find the `k` most frequent elements in the array. Return these `k` elements as an array sorted in **descending** order of frequency. In case of a tie in frequency, the larger element should appear first.","solution":"from collections import Counter def topKFrequent(nums, k): Returns the k most frequent elements in the array nums. If multiple elements have the same frequency, the larger element appears first. count = Counter(nums) # Sorting by frequency descending, if there\'s a tie, sort by the element descending sorted_elements = sorted(count.keys(), key=lambda x: (-count[x], -x)) return sorted_elements[:k]"},{"question":"Given an array of integers `arr`, you can perform a \\"flip\\" operation which reverses the order of the first `k` elements of the array (1-indexed, where 1 ≤ k ≤ arr.length). Your goal is to sort the array in ascending order using only these flip operations. Return the sequence of flip operations needed to sort the array. If there are multiple solutions, return any one of them.","solution":"def pancakeSort(arr): def flip(arr, k): arr[:k] = arr[:k][::-1] n = len(arr) result = [] for size in range(n, 1, -1): max_idx = arr.index(max(arr[:size])) if max_idx != size - 1: if max_idx != 0: flip(arr, max_idx + 1) result.append(max_idx + 1) flip(arr, size) result.append(size) return result"},{"question":"You are given a string `s` consisting of lowercase English letters and a pattern `p` also consisting of lowercase English letters. You want to rearrange the characters of the string `s` such that the pattern `p` appears as a substring in the rearranged string. Return `true` if it is possible to rearrange `s` to contain `p` as a substring and `false` otherwise.","solution":"def can_form_pattern(s, p): Determines if it\'s possible to rearrange the characters of \'s\' such that \'p\' appears as a substring in the rearranged string. :param s: string consisting of lowercase English letters :param p: pattern string consisting of lowercase English letters :return: True if it\'s possible to rearrange \'s\' to contain \'p\' as a substring, False otherwise from collections import Counter s_counter = Counter(s) p_counter = Counter(p) for char, count in p_counter.items(): if s_counter[char] < count: return False return True"},{"question":"Given a string `s` consisting of lowercase English letters, you need to delete the minimum number of characters from `s` so that any two consecutive characters are not the same. Implement a function `minDeletions(s)` that returns the minimum number of deletions required. For example: - For `s = \\"aabbcc\\"`, the function should return `3` because removing one \'a\', one \'b\', and one \'c\' results in \\"abc\\". - For `s = \\"ababab\\"`, the function should return `0` because there are no consecutive characters that are the same. Your solution should aim for optimal efficiency.","solution":"def minDeletions(s): Returns the minimum number of deletions required so that no two consecutive characters in s are the same. deletions = 0 for i in range(1, len(s)): if s[i] == s[i - 1]: deletions += 1 return deletions"},{"question":"Given a linked list, remove the `nth` node from the end of the list and return its head. The linked list is defined as follows: * Each node contains an integer value and a pointer to the next node. * If `n` is greater than the length of the list, remove the first node. You need to implement the removal in one pass through the list. Note that if the linked list is empty, return an empty list.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def remove_nth_from_end(head, n): Removes the nth node from the end of the list and returns its head. if not head: return None dummy = ListNode(0) dummy.next = head first = second = dummy # Advance first pointer by n+1 steps to maintain the gap for _ in range(n + 1): if first: first = first.next # Move both pointers until first reaches the end while first: first = first.next second = second.next # Remove the nth node from end if second.next: second.next = second.next.next return dummy.next"},{"question":"Given the head of a singly linked list, return the list after sorting it in **ascending order**. Use **O(n log n)** time complexity and **O(1)** space complexity.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def merge_sort_list(head): if not head or not head.next: return head # Helper function to find the middle of the linked list def find_middle(node): slow = fast = node prev = None while fast and fast.next: prev = slow slow = slow.next fast = fast.next.next if prev: prev.next = None # Split the list into two halves return slow # Helper function to merge two sorted linked list def merge(l1, l2): dummy = ListNode() tail = dummy while l1 and l2: if l1.val < l2.val: tail.next = l1 l1 = l1.next else: tail.next = l2 l2 = l2.next tail = tail.next tail.next = l1 if l1 else l2 return dummy.next middle = find_middle(head) left = merge_sort_list(head) right = merge_sort_list(middle) return merge(left, right)"},{"question":"You are given a string `s` containing only lowercase alphabetic characters. An operation is defined as selecting any substring of `s` and replacing all occurrences of one character with another character. Return _the minimum number of operations required to make the string `s` consist of only one unique character_.","solution":"def min_operations_to_unique_char(s): Returns the minimum number of operations required to make the string `s` consist of only one unique character. from collections import Counter # Count the frequency of each character in the string char_counts = Counter(s) # Find the maximum count of any single character max_count = max(char_counts.values()) # The minimum operations required is the length of the string # minus the number of occurrences of the most frequent character. return len(s) - max_count"},{"question":"Given a file system represented by a list of paths, where each path is a string representing directories separated by the Unix-style forward slash `\'/\'`, design a system to maintain and retrieve the file system structure. Each directory in the path is composed of lowercase alphabets. Implement the `DirectorySystem` class: * `DirectorySystem()` Initializes the directory system object. * `void createPath(String path)` Creates a new path in the file system. If a directory already exists in the path, it should not be created again. * `boolean isPathExist(String path)` Checks if a given path exists in the file system. **Note:** * You can assume that all `createPath` calls will be for either creating a new directory structure or creating at least one segment of a new structure. * The paths provided to the `createPath` function will always be valid, i.e., no trailing slashes and no intermediate empty segments (like `\\"/a//b\\"`).","solution":"class DirectorySystem: def __init__(self): self.paths = set() def createPath(self, path): Create a new directory path in the file system. If a directory already exists in the path, it should not be created again. directories = path.split(\'/\') for i in range(1, len(directories) + 1): self.paths.add(\'/\'.join(directories[:i])) def isPathExist(self, path): Check if a given path exists in the file system. return path in self.paths"},{"question":"You are given a 2D integer array `events` where each `events[i] = [starti, endi]` represents the starting and ending days of the `ith` event. You can attend an event if you are present on any day between the start and end days inclusive. Your task is to return _the maximum number of non-overlapping events you can attend_. Non-overlapping events are defined as events that do not share any common days.","solution":"def maxNonOverlappingEvents(events): Returns the maximum number of non-overlapping events that can be attended. Parameters: events (List[List[int]]): A list of events where each event is represented as [start, end]. Returns: int: The maximum number of non-overlapping events. events.sort(key=lambda x: x[1]) count = 0 last_end_day = float(\'-inf\') for start, end in events: if start > last_end_day: count += 1 last_end_day = end return count"},{"question":"You are given an integer `num`. Your task is to **reverse** the digits of `num` and return the reversed integer. If reversing `num` causes the value to go outside the signed 32-bit integer range `[-2^31, 2^31 - 1]`, then return `0`. Assume the environment does not allow you to store 64-bit integers (signed or unsigned).","solution":"def reverse_integer(num): Reverses the digits of the input integer num. If the reversed integer is outside the 32-bit signed integer range [-2^31, 2^31 - 1], returns 0. INT_MIN, INT_MAX = -2**31, 2**31 - 1 # Handle negative numbers negative = num < 0 num = abs(num) # Reverse the digits reversed_num = 0 while num != 0: digit = num % 10 num //= 10 # Check for overflow before multiplication if reversed_num > (INT_MAX - digit) // 10: return 0 reversed_num = reversed_num * 10 + digit return -reversed_num if negative else reversed_num"},{"question":"Given a string `s` consisting of alphabetic characters and the question mark character `?`, replace every question mark with a lower-case letter (\'a\' to \'z\') such that no two adjacent characters are the same. Return the final string after all replacements. If there are multiple valid strings possible, return any of them.","solution":"def replace_question_marks(s): Replaces every question mark in the string `s` such that no two adjacent characters are the same. :param s: string containing alphabetic characters and question marks :return: modified string with question marks replaced and no two adjacent characters being the same n = len(s) s = list(s) # Convert string to a list for easier mutation for i in range(n): if s[i] == \'?\': for c in \'abcdefghijklmnopqrstuvwxyz\': if (i > 0 and s[i-1] == c) or (i < n - 1 and s[i+1] == c): continue s[i] = c break return \'\'.join(s)"},{"question":"Implement a data structure called `MedianFinder` that maintains a collection of integers and supports the following operations: - `MedianFinder()`: Initializes the `MedianFinder` object. - `void addNum(int num)`: Adds the integer `num` to the data structure. - `double findMedian()`: Returns the median of all elements so far. The median is the middle element if the number of elements is odd, or the average of the two middle elements if the number of elements is even. The `MedianFinder` class should efficiently handle the dynamic addition of numbers and retrieval of the median value.","solution":"import heapq class MedianFinder: def __init__(self): Initialize two heaps. self.max_heap = [] # max-heap for the lower half self.min_heap = [] # min-heap for the upper half def addNum(self, num: int) -> None: Adds the integer `num` to the data structure. heapq.heappush(self.max_heap, -num) if self.max_heap and self.min_heap and (-self.max_heap[0] > self.min_heap[0]): val = -heapq.heappop(self.max_heap) heapq.heappush(self.min_heap, val) if len(self.max_heap) > len(self.min_heap) + 1: val = -heapq.heappop(self.max_heap) heapq.heappush(self.min_heap, val) if len(self.min_heap) > len(self.max_heap): val = heapq.heappop(self.min_heap) heapq.heappush(self.max_heap, -val) def findMedian(self) -> float: Returns the median of all elements so far. if len(self.max_heap) > len(self.min_heap): return -self.max_heap[0] return (-self.max_heap[0] + self.min_heap[0]) / 2.0"},{"question":"Given an array of integers `nums` and an integer `k`, rotate the array to the right by `k` steps, where `k` is non-negative. The rotation should be done **in-place**, meaning you cannot use extra space for another array. Return the _modified array_ after performing the rotation.","solution":"def rotate(nums, k): Rotates the array to the right by k steps. Parameters: nums (list): The list of integers to be rotated. k (int): The number of steps to rotate the array. Returns: list: The rotated list. n = len(nums) k = k % n # Handle cases where k is greater than the length of nums nums[:] = nums[-k:] + nums[:-k] return nums"},{"question":"Given an array of integers `arr`, find the length of the longest subarray containing **alternating even and odd** numbers. An **alternating subarray** is defined as a subarray where each element has a different parity (even/odd) compared to its adjacent elements. Return _the length of the longest alternating subarray_.","solution":"def longest_alternating_subarray(arr): Finds the length of the longest subarray with alternating even and odd numbers. Parameters: arr (list): A list of integers. Returns: int: The length of the longest alternating subarray. if not arr: return 0 max_length = 1 current_length = 1 for i in range(1, len(arr)): if (arr[i] % 2 == 0 and arr[i-1] % 2 != 0) or (arr[i] % 2 != 0 and arr[i-1] % 2 == 0): current_length += 1 max_length = max(max_length, current_length) else: current_length = 1 return max_length"},{"question":"You are given a **0-indexed** integer array `heights` representing the heights of students standing in a line. The task is to form a new line of students in such a way that each student is taller than the student in front of them. For instance, given an array `heights = [5, 1, 2, 3, 4]`, one possible way to reorder the students to meet the requirement is `[1, 2, 3, 4, 5]`. Return the **minimum number of students** that need to be moved to form a new line where each student is taller than the one in front. **Note**: You cannot change the relative positions of the students that you choose to keep in the same place.","solution":"def min_students_to_move(heights): Returns the minimum number of students that need to be moved to form a new line where each student is taller than the one in front. # Function to find the length of longest increasing subsequence def length_of_LIS(heights): if not heights: return 0 dp = [] for height in heights: idx = binary_search(dp, height) if idx == len(dp): dp.append(height) else: dp[idx] = height return len(dp) # Binary search helper function def binary_search(dp, height): lo, hi = 0, len(dp) while lo < hi: mid = (lo + hi) // 2 if dp[mid] < height: lo = mid + 1 else: hi = mid return lo # Longest increasing subsequence length lis_length = length_of_LIS(heights) # Minimum moves are the number of students minus length of LIS return len(heights) - lis_length"},{"question":"You are given a string s containing only lowercase letters. A \\"duplicate removal\\" consists of choosing two adjacent and equal letters and removing them. For example, in the string \\"abbaca\\", we could remove \\"bb\\" since they are adjacent and equal, resulting in the string \\"aaca\\". Continuing with this process, we then remove \\"aa\\" to obtain the final string \\"ca\\". Your task is to repeatedly remove duplicates from the string until no adjacent equal letters are present, and return the final string. Implement the following function: `def removeDuplicates(s: str) -> str` **Example 1:** Input: s = \\"abbaca\\" Output: \\"ca\\" **Example 2:** Input: s = \\"azxxzy\\" Output: \\"ay\\" **Constraints:** - `1 <= s.length <= 10^5` - `s` consists of lowercase English letters only.","solution":"def removeDuplicates(s: str) -> str: Repeatedly remove adjacent duplicates from the string until no such duplicates exist. stack = [] for char in s: if stack and stack[-1] == char: stack.pop() else: stack.append(char) return \'\'.join(stack)"},{"question":"Given an `m x n` integer matrix `heights` representing the height of each unit cell in a 2D grid, return *the length of the longest increasing path* in the matrix. From each cell, you can either move in four directions: left, right, up, or down. You **may not** move diagonally or move outside the boundary (i.e., wrap-around is not allowed). Each move must be to an adjacent cell with strictly increasing values.","solution":"def longestIncreasingPath(matrix): if not matrix or not matrix[0]: return 0 rows, cols = len(matrix), len(matrix[0]) dp = [[-1] * cols for _ in range(rows)] def dfs(r, c): if dp[r][c] != -1: return dp[r][c] directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] max_length = 1 for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < rows and 0 <= nc < cols and matrix[nr][nc] > matrix[r][c]: max_length = max(max_length, 1 + dfs(nr, nc)) dp[r][c] = max_length return max_length longest_path = 0 for r in range(rows): for c in range(cols): longest_path = max(longest_path, dfs(r, c)) return longest_path"},{"question":"Given an array of strings `words` and an integer `m`, find the **mth** most frequent string in `words`. If there are multiple strings with the same frequency, return the one which comes first lexicographically. If `m` exceeds the number of distinct strings, return an empty string. The frequency of a string is the number of times it appears in the array. The input string array may contain duplicates and the strings are case sensitive. Return the **mth** most frequent string according to the rules outlined.","solution":"from collections import Counter def mth_most_frequent(words, m): Returns the mth most frequent string in words. If there are multiple strings with the same frequency, return the one which comes first lexicographically. If m exceeds the number of distinct strings, return an empty string. # Count the frequencies of each word frequency = Counter(words) # Create a sorted list of tuples (-frequency, word) to sort first by frequency descending, then lexicographically freq_sorted = sorted(frequency.items(), key=lambda x: (-x[1], x[0])) # Check if m exceeds the number of distinct strings if m > len(freq_sorted): return \\"\\" else: return freq_sorted[m-1][0]"},{"question":"You are given an array of positive integers `arr` where each element represents the amount of water a bucket can hold. You are also given an integer `L` which represents a water level to be reached. You need to find the minimum number of buckets needed to reach or exceed the water level `L`. Each bucket can be used only once and buckets can be filled to their full capacity only. If it is not possible to reach the water level `L` with the given buckets, return `-1`. Return _the minimum number of buckets needed to reach or exceed the water level `L`_.","solution":"def min_buckets_to_reach_level(arr, L): Returns the minimum number of buckets needed to reach or exceed the water level L. arr.sort(reverse=True) total = 0 count = 0 for bucket in arr: total += bucket count += 1 if total >= L: return count return -1 # If not possible to reach level L"},{"question":"You are given an integer array `arr` of length `n`. Write a function that returns the **smallest positive integer** that is **missing** from the `arr`. The `arr` can have duplicate values and the elements may not be sorted. Aim to achieve a solution with linear time complexity.","solution":"def find_smallest_missing_positive(arr): Returns the smallest positive integer that is missing from the array. n = len(arr) for i in range(n): while 1 <= arr[i] <= n and arr[arr[i] - 1] != arr[i]: arr[arr[i] - 1], arr[i] = arr[i], arr[arr[i] - 1] for i in range(n): if arr[i] != i + 1: return i + 1 return n + 1"},{"question":"You are given a string `s` that consists of lowercase English letters. You can perform the following operation any number of times: choose a letter from the string and add it to a list, but you cannot add the same letter more than once. After constructing the list, concatenate its elements to form a new string. Your task is to determine the lexicographically smallest possible string that can be constructed using the aforementioned operation. Return the resulting string.","solution":"def smallest_lexicographical_string(s): Returns the lexicographically smallest string that can be constructed by choosing each character at most once from the input string `s`. # Create a sorted set of characters from the input string unique_sorted_chars = sorted(set(s)) # Join the characters to form the resulting string return \'\'.join(unique_sorted_chars)"},{"question":"You are given a list of unique words `words`, where each word consists of lowercase English letters. Define the `similarity` between two words as the number of positions where they have the same character. For example, the similarity between \\"abc\\" and \\"abd\\" is `2` (since the first two characters \'a\' and \'b\' match). Find the pair of words with the highest similarity and return that similarity value. If there are multiple pairs with the same highest similarity, return the similarity for any one of those pairs.","solution":"def highest_similarity(words): Find the pair of words with the highest similarity and return that similarity value. :param words: List of unique words :type words: List[str] :return: Highest similarity value :rtype: int def similarity(word1, word2): Calculate the similarity between two words. :param word1: First word :param word2: Second word :return: Similarity value return sum(1 for a, b in zip(word1, word2) if a == b) max_similarity = 0 for i in range(len(words)): for j in range(i + 1, len(words)): max_similarity = max(max_similarity, similarity(words[i], words[j])) return max_similarity"},{"question":"You are given a 2D grid of characters `board` representing a Boggle board and a list of strings `words`. The goal is to find all the words from the list that can be formed by a sequence of adjacent letters on the board. Words must be constructed from letters of sequentially adjacent cells, where \\"adjacent\\" cells are those horizontally, vertically, or diagonally neighboring. The same letter cell may not be used more than once in a word. Return the words in any order. * For example, given: ``` board = [ [\'o\', \'a\', \'a\', \'n\'], [\'e\', \'t\', \'a\', \'e\'], [\'i\', \'h\', \'k\', \'r\'], [\'i\', \'f\', \'l\', \'v\'] ] words = [\\"oath\\", \\"pea\\", \\"eat\\", \\"rain\\"] ``` The output should be `[\\"oath\\", \\"eat\\"]`.","solution":"def findWords(board, words): def backtrack(x, y, word, path): if not word: return True if x < 0 or y < 0 or x >= len(board) or y >= len(board[0]): return False if (x, y) in path or board[x][y] != word[0]: return False path.add((x, y)) res = False for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1), (-1, 1), (1, 1), (-1, -1), (1, -1)]: res = backtrack(x + dx, y + dy, word[1:], path) if res: break path.remove((x, y)) return res found_words = [] for word in words: if any(backtrack(x, y, word, set()) for x in range(len(board)) for y in range(len(board[0]))): found_words.append(word) return found_words"},{"question":"You are given a list of integers `arr` and an integer `target`. Your task is to determine if there are three distinct integers in `arr` such that their sum is equal to `target`. Return `true` if such a combination exists, otherwise return `false`. **Note**: - The integers in `arr` and `target` can be positive, negative, or zero. - The same integer may appear multiple times in the list but cannot be used more than once in the combination.","solution":"def three_sum(arr, target): Determines if there are three distinct integers in arr such that their sum equals target. Parameters: arr (list): List of integers. target (int): Target sum. Returns: bool: True if a combination exists, otherwise False. arr.sort() n = len(arr) for i in range(n-2): left = i + 1 right = n - 1 while left < right: total = arr[i] + arr[left] + arr[right] if total == target: return True elif total < target: left += 1 else: right -= 1 return False"},{"question":"You are given an array of `n` integers. You need to perform two types of operations on it: 1. **Add** an integer `x` to all elements in the subarray defined by `[l, r]`. 2. **Find** the maximum element in the subarray defined by `[l, r]`. Implement the `RangeArray` class: * `RangeArray(int[] nums)` Initializes the object with the integer array `nums`. * `void addRange(int l, int r, int x)` Adds the integer `x` to all elements in the subarray defined by `[l, r]` (0-indexed). * `int maxRange(int l, int r)` Returns the maximum element in the subarray defined by `[l, r]` (0-indexed).","solution":"class RangeArray: def __init__(self, nums): Initializes the object with the integer array nums. self.nums = nums def addRange(self, l, r, x): Adds the integer x to all elements in the subarray defined by [l, r]. for i in range(l, r + 1): self.nums[i] += x def maxRange(self, l, r): Returns the maximum element in the subarray defined by [l, r]. return max(self.nums[l:r + 1])"},{"question":"You are given a binary tree rooted at `root`, where each node contains a unique integer value. A node `X` is considered to have a **good view** if the value of `X` is greater than or equal to all the node values in the path from the root to `X`. Return _the number of nodes that have a **good view** from the root._ Note: The binary tree is represented using the level order traversal where `null` denotes the absence of a node.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def good_view_count(root): Returns the count of nodes that have a good view from the root. def dfs(node, max_val): if not node: return 0 # A node is considered having a good view if its value is >= max value seen so far good_view = 1 if node.val >= max_val else 0 # Update the max value seen so far max_val = max(max_val, node.val) # Explore left and right children good_view += dfs(node.left, max_val) good_view += dfs(node.right, max_val) return good_view return dfs(root, root.val) if root else 0"},{"question":"You are given a list of integers `heights` representing the heights of buildings in a skyline. Each building from left to right is represented by an integer corresponding to its height. You need to calculate the area of the largest rectangle that can be formed in the skyline. Return the maximum rectangle area possible. The rectangle must span only between the buildings (inclusive), and it should consist of contiguous buildings.","solution":"def largest_rectangle_area(heights): Calculates the area of the largest rectangle that can be formed in the skyline. :param heights: List[int] - A list of integers representing the heights of buildings. :return: int - The maximum rectangle area possible. # Initialize stack and max_area stack = [] max_area = 0 index = 0 while index < len(heights): if not stack or heights[stack[-1]] <= heights[index]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"You are given a string `s` representing a sentence, where each word is separated by a single space. Every word consists of lowercase and uppercase English letters. Rearrange the words in the sentence such that all uppercase words come before all lowercase words, maintaining the original relative order of the words within each group. Return the transformed sentence as a single string. For example, given `s = \\"Hello world This is an Example\\"`, return `\\"Hello This Example world is an\\"`.","solution":"def rearrange_sentence(s): Rearranges the words in the sentence such that all uppercase words come before all lowercase words. Maintains the original relative order of the words within each group. Parameters: s (str): The input sentence as a string. Returns: str: The rearranged sentence as a single string. words = s.split() upper_case_words = [word for word in words if word[0].isupper()] lower_case_words = [word for word in words if word[0].islower()] rearranged_words = upper_case_words + lower_case_words return \' \'.join(rearranged_words)"},{"question":"You are managing a list of tasks where each task has a specific duration and a specific deadline by which it must be completed. You are given a list of `n` tasks, where each task is represented by two integers `duration` and `deadline`. Your goal is to find if it is possible to complete all tasks without any task exceeding its deadline. You start at time `0` and can complete the tasks in any order you choose. Write a function that takes an array `tasks` where `tasks[i] = [duration_i, deadline_i]` and returns a boolean indicating whether it is possible to complete all tasks without any task exceeding its deadline. For example: - Input: `tasks = [[3, 9], [2, 5], [1, 6]]` - Output: `True`","solution":"def can_complete_tasks(tasks): Determines if it is possible to complete all tasks without any task exceeding its deadline. :param tasks: List of tasks, where each task is represented by [duration, deadline] :return: Boolean, True if all tasks can be completed within their deadlines, False otherwise. # Sort tasks by their deadlines tasks.sort(key=lambda x: x[1]) current_time = 0 for duration, deadline in tasks: current_time += duration if current_time > deadline: return False return True"},{"question":"You are given a list of `n` integers, each integer being either `0` or `1`. You need to segment this list into contiguous subarrays such that the difference between the number of `1`s and `0`s in each subarray is at most `k`. Write a function that returns the maximum number of such subarrays.","solution":"def max_subarrays(nums, k): Returns the maximum number of contiguous subarrays such that the difference between the number of `1`s and `0`s in each subarray is at most `k`. n = len(nums) count1 = 0 count0 = 0 max_subarrays_count = 0 start = 0 # Starting index of current subarray for end in range(n): if nums[end] == 1: count1 += 1 elif nums[end] == 0: count0 += 1 # If the current subarray difference exceeds k, move the start forward while abs(count1 - count0) > k: if nums[start] == 1: count1 -= 1 elif nums[start] == 0: count0 -= 1 start += 1 # We found a subarray with the difference within k max_subarrays_count += 1 return max_subarrays_count"},{"question":"Given a grid represented as a 2D matrix of characters (a grid of \'0\'s and \'1\'s), where \'1\' represents land and \'0\' represents water, you need to find the number of distinct islands in the grid. An island is formed by connecting \'1\'s horizontally or vertically and is completely surrounded by water (or the edges of the grid). Write a function `int numIslands(char[][] grid)` that returns the number of distinct islands in the given grid.","solution":"def numIslands(grid): if not grid: return 0 rows = len(grid) cols = len(grid[0]) islands_count = 0 def dfs(x, y): if x < 0 or y < 0 or x >= rows or y >= cols or grid[x][y] != \'1\': return grid[x][y] = \'0\' dfs(x + 1, y) dfs(x - 1, y) dfs(x, y + 1) dfs(x, y - 1) for i in range(rows): for j in range(cols): if grid[i][j] == \'1\': islands_count += 1 dfs(i, j) return islands_count"},{"question":"You are given an array `times` where `times[i]` denotes the time taken to complete the `i-th` task. You also have a positive integer `n` representing the number of machines available. All machines work in parallel and can perform only one task at a time. Each machine must complete its current task before starting a new one. Return _the minimum possible time required to complete all the tasks in_ `times`. **Note:** The tasks can be assigned to machines in any order, but once a task is assigned to a machine, it must be completed without interruption.","solution":"import heapq def min_time_to_complete_tasks(times, n): Returns the minimum possible time required to complete all tasks using n machines. :param times: List[int] - List of times taken to complete each task. :param n: int - Number of available machines. :return: int - Minimum time required to complete all tasks. if not times: return 0 # Initialize a priority queue to keep track of each machine\'s end time. machines = [0] * n for task_time in times: # Assign the task to the machine that gets freed the earliest (min-heap). machines[0] += task_time # Reorder the heap after adding the task time heapq.heapify(machines) # The answer is the maximum end time among all machines. return max(machines)"},{"question":"You are given two strings `s1` and `s2`, each consisting of lowercase English letters. Find the length of the longest subsequence which is a common substring of both `s1` and `s2`. A subsequence is a sequence derived from another sequence by deleting some or no elements without changing the order of the remaining elements. A substring is a contiguous sequence of characters within a string. Return _the length of the longest common subsequence that is also a substring._","solution":"def longest_common_subsequence_substring(s1, s2): Returns the length of the longest subsequence which is a common substring of both s1 and s2. n = len(s1) m = len(s2) dp = [[0] * (m + 1) for _ in range(n + 1)] result = 0 for i in range(1, n + 1): for j in range(1, m + 1): if s1[i - 1] == s2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 result = max(result, dp[i][j]) else: dp[i][j] = 0 return result"},{"question":"Given an `n x n` 2D matrix `matrix`, you need to rotate the matrix by 90 degrees (clockwise). You have to rotate the matrix in-place, which means you have to modify the input matrix directly. Do not allocate another 2D matrix and do the rotation. Return the modified matrix after rotation.","solution":"def rotate(matrix): Rotates the given n x n 2D matrix by 90 degrees clockwise in-place. :param matrix: List[List[int]] - a 2D list representing the matrix :return: List[List[int]] - the rotated matrix n = len(matrix) # Step 1: Transpose the matrix (swap rows and columns) for i in range(n): for j in range(i, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Step 2: Reverse each row to get the rotated matrix for i in range(n): matrix[i].reverse() return matrix"},{"question":"You are given a list of non-negative integers representing the heights of each stack in a number of horizontal stacks. The goal is to determine how many stacks need to be removed to make the rest of the stacks have the same height. You can only remove entire stacks and cannot alter the height of any stacks. Return the minimum number of stacks that need to be removed to achieve this. Example: ```python Input: stacks = [5, 3, 4, 2, 1, 3] Output: 4 Explanation: Removing stacks of heights 5, 4, 2, and 1 will leave two stacks of height 3. ```","solution":"def min_stacks_to_remove(stacks): Returns the minimum number of stacks that need to be removed to make the rest of the stacks have the same height. Parameters: stacks (list of int): A list of non-negative integers representing the heights of the stacks. Returns: int: Minimum number of stacks to remove. from collections import Counter if not stacks: return 0 height_count = Counter(stacks) max_freq = max(height_count.values()) return len(stacks) - max_freq"},{"question":"You are given a list of pairs `edges` representing an undirected graph, where each pair `(u, v)` indicates that there is an edge between nodes `u` and `v`. You need to determine if this graph is a valid tree. A valid tree has to satisfy the following conditions: 1. The graph is connected, meaning there is a path between every pair of nodes. 2. The graph has no cycles, meaning it is acyclic. Return `true` if the graph is a valid tree, otherwise, return `false`.","solution":"def valid_tree(n, edges): Determines if the given graph is a valid tree. Parameters: - n (int): The number of nodes. - edges (List[Tuple[int, int]]): The edges of the graph. Returns: - bool: True if the graph is a valid tree, otherwise False. if len(edges) != n - 1: return False parent = list(range(n)) def find(x): if parent[x] != x: parent[x] = find(parent[x]) return parent[x] def union(x, y): rootX = find(x) rootY = find(y) if rootX != rootY: parent[rootY] = rootX for u, v in edges: union(u, v) root = find(0) for i in range(1, n): if find(i) != root: return False return True"},{"question":"You are given a list of `tasks`, where each task is represented by an integer indicating the time it takes to complete that task. Additionally, you are given an integer `k` representing the number of workers. Each worker can work on exactly one task at a time, but as soon as a worker is finished with a task, they can start on another task immediately if available. Your goal is to allocate the tasks to the workers in such a way that the time to complete all tasks is minimized. Write a function `minTimeToCompleteTasks(tasks, k)` that takes in the list of tasks and the integer `k`, and returns the minimum amount of time required to complete all the tasks.","solution":"def minTimeToCompleteTasks(tasks, k): Returns the minimum amount of time required to complete all the tasks with k workers. from heapq import heapify, heappop, heappush if not tasks: return 0 if k >= len(tasks): return max(tasks) tasks.sort(reverse=True) heap = [0] * k # represents time each worker has worked for task in tasks: heappush(heap, heappop(heap) + task) return max(heap)"},{"question":"Given a list of `n` integers, write a function to find the maximum product of any three numbers in the list. The function should return this maximum product value. For example, given the list `nums = [-10, -10, 5, 2]`, the function should return `500`, which is the product of `-10`, `-10`, and `5`. Make sure your solution works efficiently even for large values of `n`.","solution":"def maximum_product_of_three(nums): Returns the maximum product of any three numbers in the list. nums.sort() # The maximum product can either be: # 1. The product of the three largest numbers # 2. The product of the two smallest numbers (which can be negative) and the largest number return max(nums[-1] * nums[-2] * nums[-3], nums[0] * nums[1] * nums[-1])"},{"question":"You are given a **0-indexed** string `s` of length `n` consisting of only lowercase English letters. You can select **two consecutive** characters of the string `s` and replace them with a single character that appears **between them** in alphabetical order (the replacement character can be one of the two consecutive characters but not necessarily between them). You want to reduce the string to the shortest possible length. Return the lexicographically smallest string that can be obtained by performing the operation any number of times (even zero operations). Note that you must perform the operations to reduce the length **minimally** and the final string should have the smallest lexicographical order among all possible outcomes.","solution":"def reduce_string(s): Reduces the string `s` to the shortest possible length such that the final string is lexicographically smallest among all possible outcomes. while len(s) > 1: min_pair_index = 0 min_pair_value = s[min_pair_index] + s[min_pair_index+1] for i in range(1, len(s) - 1): current_pair_value = s[i] + s[i+1] if current_pair_value < min_pair_value: min_pair_value = current_pair_value min_pair_index = i min_pair_char = min(s[min_pair_index], s[min_pair_index + 1]) s = s[:min_pair_index] + min_pair_char + s[min_pair_index + 2:] return s"},{"question":"Given a collection of integers which might contain duplicates, `nums`, return _all possible unique permutations_ in any order. Each permutation must not repeat any integer set from the original collection, even if the integers are in a different order. This means that for any given number of duplicates for each element in the collection, all permutations must be unique sets. Note: You can assume that `1 <= nums.length <= 8` and `-10 <= nums[i] <= 10`.","solution":"from itertools import permutations def unique_permutations(nums): Returns all unique permutations of the given list of numbers. perms = set(permutations(nums)) return list(perms)"},{"question":"You are given an array `tasks` where `tasks[i]` represents the amount of time it takes to complete the `i-th` task. There are `k` workers available, and each worker can handle only one task at a time. The workers will be assigned tasks such that the total time taken to complete all tasks is minimized. Return the _minimum possible time required to complete all tasks_ by the `k` workers. Note: - Each worker can either remain idle or perform exactly one task at a time. - Once a worker finishes a task, they can immediately start working on another available task. - All workers start simultaneously at time `0`.","solution":"def minTimeRequired(tasks, k): Returns the minimum possible time required to complete all tasks by k workers. def canFinishInTime(tasks, k, max_time): workers = [0] * k for task in tasks: workers.sort() if workers[0] + task > max_time: return False workers[0] += task return True tasks.sort(reverse=True) left, right = max(tasks), sum(tasks) while left < right: mid = (left + right) // 2 if canFinishInTime(tasks, k, mid): right = mid else: left = mid + 1 return left"},{"question":"You are given an unsorted integer array `arr` and an integer `k`. Your task is to return _the k-th largest element_ using a max-heap or any other efficient method. Implement an algorithm that accomplishes this with an optimal time complexity given the constraints.","solution":"import heapq def find_kth_largest(arr, k): Returns the k-th largest element in the given array using a min-heap. :param arr: List[int] - the list of integers :param k: int - the k-th largest element to find :return: int - the k-th largest element if k > len(arr): raise ValueError(\\"k should be less than or equal to the length of the array.\\") # Using a min-heap to keep track of the k largest elements min_heap = arr[:k] heapq.heapify(min_heap) for num in arr[k:]: if num > min_heap[0]: heapq.heappop(min_heap) heapq.heappush(min_heap, num) return min_heap[0]"},{"question":"[Question] 4: You are given a binary tree where each node contains an integer value. Calculate the sum of values of all nodes with even-valued grandparents. A node\'s grandparent is the parent of its parent, if it exists. Return the sum of all node values with an even-valued grandparent.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def sumEvenGrandparent(root: TreeNode) -> int: Returns the sum of values of all nodes with even-valued grandparents. def dfs(node, parent, grandparent): if not node: return 0 grandparent_val = grandparent.val if grandparent else 1 parent_val = parent.val if parent else 1 left_sum = dfs(node.left, node, parent) right_sum = dfs(node.right, node, parent) # If grandparent\'s value is even, add the current node\'s value to the sum total = left_sum + right_sum if grandparent_val % 2 == 0: total += node.val return total return dfs(root, None, None)"},{"question":"Given an array of integers `nums`, find and return the length of the shortest subarray that, if sorted in ascending order, would result in the entire array being sorted in ascending order. If the array is already sorted, return `0`. The function should have a linear time complexity and use a constant amount of extra space.","solution":"def findUnsortedSubarray(nums): Returns the length of the shortest subarray that if sorted, the entire array becomes sorted. n = len(nums) start, end = -1, -2 # Initialize start and end pointers min_num, max_num = nums[-1], nums[0] for i in range(1, n): max_num = max(max_num, nums[i]) min_num = min(min_num, nums[n - 1 - i]) if nums[i] < max_num: end = i if nums[n - 1 - i] > min_num: start = n - 1 - i return end - start + 1"},{"question":"A company operates several cargo ships for delivering goods internationally, and they need to determine the most efficient routes. A route is defined by a sequence of ports the cargo ship will visit. Each port is represented as a tuple of integers `(xi, yi)` indicating its coordinates on a 2D map. Due to some constrained budgets, the company wants its cargo ships to follow paths that minimize the total travel distance while visiting all ports exactly once before returning to the starting port (a round-trip). Given an array `ports` where `ports[i] = [xi, yi]` represents the coordinates of the ith port, return _the minimum total travel distance for a cargo ship to visit every port exactly once and return to the starting port_. Your answer should be exact and not an approximation.","solution":"from itertools import permutations import math def calculate_distance(port1, port2): Calculate the Euclidean distance between two ports. return math.sqrt((port1[0] - port2[0])**2 + (port1[1] - port2[1])**2) def total_distance(route): Calculate the total distance of a given route including returning to the starting port. distance = 0 for i in range(1, len(route)): distance += calculate_distance(route[i - 1], route[i]) distance += calculate_distance(route[-1], route[0]) # returning to the start port return distance def minimum_travel_distance(ports): Find the route with the minimum travel distance to visit all ports exactly once and return to the start. if not ports: return 0 min_distance = float(\'inf\') best_route = None for perm in permutations(ports): current_distance = total_distance(perm) if current_distance < min_distance: min_distance = current_distance best_route = perm # This is optional to store if we also want to know the optimal route return min_distance"},{"question":"You are given a string `s` consisting of lowercase English letters. A duplicated character is defined as a character that appears more than once in the string. Write a function to remove all duplicate characters and return the resulting string such that each character appears only once. The order of characters in the resulting string should be the same as their first occurrence in `s`. Return the resulting string.","solution":"def remove_duplicates(s): Removes all duplicate characters such that each character only appears once in the order of their first occurrence in the string. :param s: Input string consisting of lowercase English letters. :return: Resulting string with duplicate characters removed. seen = set() result = [] for char in s: if char not in seen: seen.add(char) result.append(char) return \'\'.join(result)"},{"question":"Given an integer array `nums` representing a series of heights, determine whether a selection of `2` or more of these heights can form a polygon. To form a valid polygon, the sum of the lengths of any `2` sides must be **greater** than the length of the remaining side. Return whether such a selection is possible _as a boolean value_.","solution":"def can_form_polygon(nums): Determines if a selection of 2 or more heights can form a polygon. Args: nums (list of ints): The heights/side lengths. Returns: bool: True if a selection can form a polygon, otherwise False. n = len(nums) if n < 3: return False nums.sort() for i in range(n - 2): if nums[i] + nums[i + 1] > nums[i + 2]: return True return False"},{"question":"Write a function that takes a binary tree and returns its boundary value. The boundary value includes all the nodes in the left boundary, right boundary, and leaf nodes but excluding the duplicate leaf nodes that have been already included in either left or right boundary. The left boundary is defined as the path from the root to the leftmost node. Similarly, the right boundary is defined as the path from the root to the rightmost node. Leaf nodes are the nodes which do not have any children nodes. Return the boundary values as an array, listing the values starting from the root node, followed by left boundary nodes, followed by leaf nodes, and ending with the right boundary nodes in reverse order. Note: - The tree is a binary tree. - The root node will always be present in the boundary.","solution":"class TreeNode: Definition for a binary tree node. def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def boundaryOfBinaryTree(root): if not root: return [] def left_boundary(node): boundary = [] while node: if node.left or node.right: boundary.append(node.val) if node.left: node = node.left else: node = node.right return boundary def right_boundary(node): boundary = [] while node: if node.left or node.right: boundary.append(node.val) if node.right: node = node.right else: node = node.left return boundary[::-1] # reverse for right boundary def leaves(node): if not node: return [] if not node.left and not node.right: return [node.val] return leaves(node.left) + leaves(node.right) boundary = [root.val] if root.left: boundary += left_boundary(root.left) boundary += leaves(root.left) if root.right: boundary += leaves(root.right) boundary += right_boundary(root.right) return boundary"},{"question":"You are given an array of integers `arr` and an integer `k`, where `k` is a target sum. Return _the smallest length of a contiguous subarray in_ `arr` _with a sum greater than or equal to_ `k`. _If there isn\'t one, return_ `-1`.","solution":"def min_subarray_len(arr, k): Returns the smallest length of a contiguous subarray with a sum greater than or equal to k. If no such subarray exists, returns -1. n = len(arr) min_len = float(\'inf\') current_sum = 0 start = 0 for end in range(n): current_sum += arr[end] while current_sum >= k: min_len = min(min_len, end - start + 1) current_sum -= arr[start] start += 1 return min_len if min_len != float(\'inf\') else -1"},{"question":"Given a string `s` consisting of lowercase English letters, you need to remove the minimum number of characters from the string such that the remaining string does not contain any consecutive repeating characters. Return the resultant string after performing the removal operation. For example, given `s = \\"aabbcc\\"`, the output should be `\\"abc\\"`, and for `s = \\"aaabbb\\"`, the output should be `\\"ab\\"`.","solution":"def remove_consecutive_characters(s): Removes the minimum number of characters from the string s such that the remaining string does not contain any consecutive repeating characters. Args: s (str): Input string consisting of lowercase English letters. Returns: str: A resultant string after performing the removal operation. if not s: # If the input string is empty, return an empty string. return \\"\\" result = [s[0]] # Initialize the result list with the first character. for i in range(1, len(s)): if s[i] != s[i - 1]: # Only add the character if it\'s not the same as the previous one. result.append(s[i]) return \\"\\".join(result) # Join the list into a string and return."},{"question":"Given an integer array `arr`, find a minimum-length subarray that, when sorted, makes the whole array `arr` sorted in non-decreasing order. Return the minimum length of such a subarray. If the array is already sorted, return 0.","solution":"def find_unsorted_subarray(arr): Returns the minimum length of the subarray that needs to be sorted in place so that the whole array becomes sorted in non-decreasing order. n = len(arr) start, end = -1, -2 # Initialize to -1, -2 to handle already sorted array case. min_val, max_val = arr[-1], arr[0] for i in range(1, n): max_val = max(max_val, arr[i]) min_val = min(min_val, arr[n-1-i]) if arr[i] < max_val: end = i if arr[n-1-i] > min_val: start = n-1-i return end - start + 1"},{"question":"You are given a string `s` that consists of only digits and by removing exactly one digit from the string, you must make the string the largest possible number. Return the resulting largest string after removing exactly one digit. If there are multiple solutions, return the smallest lexicographically.","solution":"def remove_digit_to_maximize(s: str) -> str: Removes exactly one digit from the string to make the largest possible number. If there are multiple solutions, returns the smallest lexicographically. max_num = \\"\\" for i in range(len(s)): temp_num = s[:i] + s[i+1:] if temp_num > max_num: max_num = temp_num return max_num"},{"question":"Given an array of integers `nums`, return the **length of the longest** continuous subarray with an equal number of `1`s and `0`s. For example, given the array `[0,1,0,0,1,0,1,1]`, the longest subarray with equal numbers of `1`s and `0`s is `[0,1,0,0,1,0,1,1]` which has a length of `8`. If no such subarray exists, return `0`.","solution":"def findMaxLength(nums): Returns the length of the longest continuous subarray with equal number of 1s and 0s. max_length = 0 count = 0 count_index_map = {0: -1} for i, num in enumerate(nums): count += 1 if num == 1 else -1 if count in count_index_map: max_length = max(max_length, i - count_index_map[count]) else: count_index_map[count] = i return max_length"},{"question":"You are given a string `word` containing only lowercase alphabetic characters. Your task is to return a new string where each character in the original string is replaced by its next character in the English alphabet. Note that for character `\'z\'`, the next character is `\'a\'`. For example, given the string `word = \\"abcdz\\"`, the function should return `\\"bcdea\\"`.","solution":"def shift_letters(word): Returns a new string where each character in the original string is replaced by its next character in the English alphabet. The next character after \'z\' is \'a\'. shifted_word = \\"\\" for char in word: if char == \'z\': shifted_word += \'a\' else: shifted_word += chr(ord(char) + 1) return shifted_word"},{"question":"You are given a `2D` grid of `m` rows and `n` columns filled with non-negative integers representing the height of each cell in a landscape. The grid cells adjacent horizontally and vertically are considered neighbors. The **water level** in each cell is initially zero. When it rains, water can flow from a cell to any of its neighbors with a height equal to or lower than the current cell until it cannot flow further. Return _the **total amount of water** that will be trapped_ after it rains.","solution":"import heapq def trapRainWater(heightMap): if not heightMap or not heightMap[0]: return 0 m, n = len(heightMap), len(heightMap[0]) visited = [[False] * n for _ in range(m)] min_heap = [] # Add all the boundary cells to the heap for i in range(m): heapq.heappush(min_heap, (heightMap[i][0], i, 0)) heapq.heappush(min_heap, (heightMap[i][n-1], i, n-1)) visited[i][0] = True visited[i][n-1] = True for j in range(n): heapq.heappush(min_heap, (heightMap[0][j], 0, j)) heapq.heappush(min_heap, (heightMap[m-1][j], m-1, j)) visited[0][j] = True visited[m-1][j] = True water_trapped = 0 directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] while min_heap: height, x, y = heapq.heappop(min_heap) for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and not visited[nx][ny]: visited[nx][ny] = True water_trapped += max(0, height - heightMap[nx][ny]) heapq.heappush(min_heap, (max(height, heightMap[nx][ny]), nx, ny)) return water_trapped"},{"question":"You are given a string `s` consisting of only lowercase English letters and an integer `x`. You need to partition the string into a sequence of substrings such that the sum of the lengths of the substrings is minimized under the condition that each substring must contain no more than `x` distinct characters. Return the minimum sum of lengths of all the substrings. Note that the input string `s` is non-empty and contains at least one character.","solution":"def min_sum_of_lengths(s, x): Returns the minimum sum of lengths of all the substrings such that each substring contains no more than x distinct characters. n = len(s) i = 0 min_sum = 0 while i < n: distinct_chars = set() start = i while i < n and (len(distinct_chars) < x or (len(distinct_chars) == x and s[i] in distinct_chars)): distinct_chars.add(s[i]) i += 1 min_sum += (i - start) return min_sum"},{"question":"You are given a matrix `grid` containing `n` rows and `m` columns. The cells of this grid can either be empty (denoted by 0) or occupied (denoted by 1). A cell is considered a neighbor of another cell if it is horizontally or vertically adjacent. Write a function `largestGroupOfOnes` which returns the size of the largest connected group of occupied cells (1s). Implement the `Solution` class: * `Solution(grid: List[List[int]])` * Initializes the state with the given grid. * `int largestGroupOfOnes()` * Returns the size of the largest connected group of occupied cells in the grid.","solution":"from typing import List class Solution: def __init__(self, grid: List[List[int]]): self.grid = grid self.rows = len(grid) self.cols = len(grid[0]) if self.rows > 0 else 0 def largestGroupOfOnes(self) -> int: def dfs(i, j): if i < 0 or i >= self.rows or j < 0 or j >= self.cols or self.grid[i][j] == 0: return 0 # Mark the cell as visited self.grid[i][j] = 0 size = 1 # Explore all four possible directions: up, down, left, right size += dfs(i - 1, j) size += dfs(i + 1, j) size += dfs(i, j - 1) size += dfs(i, j + 1) return size max_size = 0 for i in range(self.rows): for j in range(self.cols): if self.grid[i][j] == 1: max_size = max(max_size, dfs(i, j)) return max_size"},{"question":": A company needs to ensure that its team of engineers logs their working hours correctly. Each engineer logs their working hours as a list of intervals where each interval is represented as a tuple `(start, end)`. The company needs a function that, given these intervals, merges any overlapping intervals and returns the list of merged intervals. For instance, given the intervals `[(9, 12), (11, 13), (14, 16), (15, 18)]`, the function should return `[(9, 13), (14, 18)]` because the intervals `(9, 12)` and `(11, 13)` overlap and are merged into `(9, 13)`, and intervals `(14, 16)` and `(15, 18)` overlap and are merged into `(14, 18)`. Write a function `merge_intervals(intervals: List[Tuple[int, int]]) -> List[Tuple[int, int]]` that accomplishes this.","solution":"from typing import List, Tuple def merge_intervals(intervals: List[Tuple[int, int]]) -> List[Tuple[int, int]]: Merges a list of intervals where each interval is represented as a tuple (start, end). Parameters: intervals (List[Tuple[int, int]]): A list of tuples representing intervals. Returns: List[Tuple[int, int]]: A list of merged intervals. if not intervals: return [] # Sort intervals based on the start time intervals.sort(key=lambda x: x[0]) merged_intervals = [intervals[0]] for current in intervals: last_merged = merged_intervals[-1] # If the current interval overlaps with the last merged interval if current[0] <= last_merged[1]: # Merge the intervals merged_intervals[-1] = (last_merged[0], max(last_merged[1], current[1])) else: # No overlap, add the interval to the result merged_intervals.append(current) return merged_intervals"},{"question":"Given a linked list, rotate the list to the right by `k` places, where `k` is a non-negative integer. Implement a function that modifies the list in-place and returns the new head of the list after rotation.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def rotateRight(head, k): if not head or not head.next or k == 0: return head # Find the length of the list length = 1 current = head while current.next: current = current.next length += 1 # Connect the last node to the head, making it a circular list current.next = head # Find the new head after rotation k = k % length steps_to_new_head = length - k new_tail = head for _ in range(steps_to_new_head - 1): new_tail = new_tail.next new_head = new_tail.next new_tail.next = None return new_head"},{"question":"Given an array of integers `arr` and an integer `k`, write a function that returns the maximum sum of any contiguous subarray of size exactly `k`. If `k` is greater than the length of the array, return 0. For example, given the array `arr = [2, 1, 5, 1, 3, 2]` and `k = 3`, the function should return `9` (as the subarray `[5, 1, 3]` has the maximum sum of `9`). To solve this problem, you can use a sliding window approach to find the sum of every possible contiguous subarray of size `k` and keep track of the maximum sum found.","solution":"def max_sum_subarray(arr, k): Returns the maximum sum of any contiguous subarray of size exactly `k`. If `k` is greater than the length of the array, returns 0. n = len(arr) if k > n: return 0 # Calculate the sum of the first `k` elements max_sum = current_sum = sum(arr[:k]) # Slide the window over the array by subtracting the element that goes out of the window # and adding the element that comes into the window for i in range(k, n): current_sum += arr[i] - arr[i - k] max_sum = max(max_sum, current_sum) return max_sum"},{"question":"A company is planning to launch a new feature, and they need to test multiple user scenarios to ensure the feature works correctly. They represent each scenario as a directed graph where each node represents a feature component and a directed edge from node `u` to node `v` signifies that component `u` must be tested before component `v`. Each node is identified by a unique integer. You are given an integer `n` representing the total number of feature components (nodes) and a list of directed edges `edges` where each edge is represented as a pair of integers `[u, v]` indicating that component `u` should be tested before component `v`. Return _a list of integers_ representing a valid order in which to test all the components such that all prerequisites are satisfied. If there are multiple valid orders, return any of them. If it\'s impossible to test all components due to a cycle in the graph, return an empty list.","solution":"from collections import deque, defaultdict def find_test_order(n, edges): Returns a list representing a valid order to test all feature components. If the graph has a cycle, return an empty list. :param n: int - Total number of feature components (nodes). :param edges: List[List[int]] - Directed edges representing dependencies. :return: List[int] - Valid order for testing components, empty list if impossible. # Initialize the graph and in-degrees graph = defaultdict(list) in_degrees = [0] * n # Building the graph and in-degrees array for u, v in edges: graph[u].append(v) in_degrees[v] += 1 # Queue for nodes with no incoming edges (in-degree 0) queue = deque([i for i in range(n) if in_degrees[i] == 0]) test_order = [] # Process the graph using Kahn\'s Algorithm while queue: node = queue.popleft() test_order.append(node) for neighbor in graph[node]: in_degrees[neighbor] -= 1 if in_degrees[neighbor] == 0: queue.append(neighbor) # If we processed all nodes, return the test order, else return empty list return test_order if len(test_order) == n else []"},{"question":"Given a binary tree, implement an algorithm to find the maximum depth (or height) of the tree. The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node. The tree is represented by the root node, and the tree node has attributes `val` (integer), `left` (TreeNode), and `right` (TreeNode).","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def max_depth(root): Returns the maximum depth of the binary tree rooted at \'root\'. if root is None: return 0 else: left_depth = max_depth(root.left) right_depth = max_depth(root.right) return max(left_depth, right_depth) + 1"},{"question":"Given an integer array `arr`, find the length of the shortest contiguous subarray, that when sorted, makes the array non-decreasing. The input array may contain duplicates, and you need to return the length of the shortest such subarray. For example, given the input `arr = [2, 6, 4, 8, 10, 9, 15]`, the output should be `5` because sorting the subarray `[6, 4, 8, 10, 9]` makes the whole array `[2, 4, 6, 8, 9, 10, 15]` non-decreasing.","solution":"def find_unsorted_subarray(arr): n = len(arr) if n <= 1: return 0 start, end = -1, -1 max_seen = -float(\'inf\') min_seen = float(\'inf\') for i in range(n): max_seen = max(max_seen, arr[i]) if arr[i] < max_seen: end = i for i in range(n-1, -1, -1): min_seen = min(min_seen, arr[i]) if arr[i] > min_seen: start = i if start == -1 or end == -1: return 0 return end - start + 1"},{"question":"You are given an array of integers `nums` and an integer `k`. We call an element in the array a **k-dominator** if it appears more than `k // 2` times. The array might contain multiple k-dominators. Your task is to find all the distinct k-dominators in the array and return them in a list. If there are no k-dominators, return an empty list. You may return the answer in **any order**.","solution":"from collections import Counter def k_dominators(nums, k): Returns a list of elements in nums that appear more than k // 2 times. threshold = k // 2 counts = Counter(nums) return [num for num, count in counts.items() if count > threshold]"},{"question":"You are given a string `s` containing only characters \'a\', \'b\', and \'c\'. In one move, you can choose any two adjacent characters of the string and remove them if they are different. Your task is to determine the length of the final string after performing any number of such moves. Return the length of the string that remains.","solution":"def final_string_length(s): Determine the length of the final string after performing any number of moves where we can remove any two adjacent characters if they are different. Parameters: s (str): The input string containing characters \'a\', \'b\', and \'c\'. Returns: int: The length of the final string. stack = [] for char in s: if stack and stack[-1] != char: stack.pop() # remove the adjacent different character else: stack.append(char) return len(stack)"},{"question":"Given a non-empty array of digits representing a non-negative integer, increment one to the integer. The digits are stored such that the most significant digit is at the head of the list, and each element in the array contains a single digit. You may assume the integer does not contain any leading zero, except the number 0 itself. Return the resulting array of digits.","solution":"def plus_one(digits): Given a list of digits representing a non-negative integer, increment one to the integer. n = len(digits) for i in range(n-1, -1, -1): if digits[i] == 9: digits[i] = 0 else: digits[i] += 1 return digits digits.insert(0, 1) return digits"},{"question":"Write a function that takes an array of integers and an integer `k`, and rotates the array to the right by `k` steps. For example, given the array `[1,2,3,4,5,6,7]` and `k = 3`, your function should return `[5,6,7,1,2,3,4]`.","solution":"def rotate_array(arr, k): Rotates the array to the right by k steps. Parameters: arr (list): The array of integers to be rotated. k (int): The number of steps to rotate the array. Returns: list: The rotated array. if not arr: return arr k = k % len(arr) # To handle cases where k is larger than the length of the array return arr[-k:] + arr[:-k] # Slicing to get the rotated array"},{"question":"You are given a string `s` consisting of lowercase English letters. You can perform the following operation any number of times: choose a character and remove all instances of this character from the string. Your goal is to determine the minimum number of operations needed to make `s` a string with at most one distinct character. Return the minimum number of operations required to achieve this goal.","solution":"def min_operations_to_single_distinct_char(s): Returns the minimum number of operations needed to make the string `s` have at most one distinct character. from collections import Counter character_count = Counter(s) max_freq = max(character_count.values()) return len(s) - max_freq"},{"question":"Given a binary search tree (BST) root and an integer k, return _the kth smallest element in the BST_. Note that it is guaranteed that `k` is a valid integer for the given BST.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def kth_smallest(root, k): Returns the kth smallest element in the BST. # Helper function to perform in-order traversal def in_order_traversal(node): if not node: return yield from in_order_traversal(node.left) yield node.val yield from in_order_traversal(node.right) generator = in_order_traversal(root) for _ in range(k - 1): next(generator) return next(generator)"},{"question":"Given a 2D array `grid` representing an N x N grid filled with 0s and 1s, where 1 represents land and 0 represents water, find the largest island that can be formed by flipping exactly one 0 to 1. An island is considered to be formed by connected `1`s horizontally or vertically. You may assume that there is at least one 0 in the grid. Return the size of the largest island that can be formed.","solution":"def largest_island(grid): from collections import defaultdict, deque def get_neighbors(x, y): for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nx, ny = x + dx, y + dy if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]): yield nx, ny def bfs(x, y, island_idx): queue = deque([(x, y)]) grid[x][y] = island_idx size = 1 while queue: cx, cy = queue.popleft() for nx, ny in get_neighbors(cx, cy): if grid[nx][ny] == 1: grid[nx][ny] = island_idx queue.append((nx, ny)) size += 1 return size n = len(grid) island_sizes = defaultdict(int) island_index = 2 # Find all islands and mark them with index > 1 for i in range(n): for j in range(n): if grid[i][j] == 1: island_sizes[island_index] = bfs(i, j, island_index) island_index += 1 if not island_sizes: return 1 max_island_size = max(island_sizes.values()) # Try flipping each 0 and calculate the size of the resulting island for i in range(n): for j in range(n): if grid[i][j] == 0: seen_islands = set() possible_size = 1 # the flipped 0 itself for nx, ny in get_neighbors(i, j): if grid[nx][ny] > 1 and grid[nx][ny] not in seen_islands: seen_islands.add(grid[nx][ny]) possible_size += island_sizes[grid[nx][ny]] max_island_size = max(max_island_size, possible_size) return max_island_size"},{"question":"You are given a zero-indexed integer array `arr` containing `n` integers. A subarray is called a peak subarray if the value of each element in the subarray is greater than the value of its adjacent elements outside the subarray. More formally, a subarray `arr[l...r]` is a peak subarray if and only if (`arr[l-1] < arr[l]`) and (`arr[r] > arr[r+1]`), where `l` and `r` are the starting and ending indices of the subarray, respectively, and elements outside the bounds of the array are considered to be `-∞`. Return the length of the longest peak subarray in `arr`.","solution":"def longest_peak_subarray(arr): Returns the length of the longest peak subarray in arr. if not arr: return 0 n = len(arr) max_len = 0 for i in range(1, n - 1): # Check if arr[i] is a peak if arr[i - 1] < arr[i] > arr[i + 1]: # Initialize left and right pointers to find the extent of the peak left, right = i - 1, i + 1 # Move left pointer to the left as long as the current number is greater than the next one while left > 0 and arr[left - 1] < arr[left]: left -= 1 # Move right pointer to the right as long as the current number is greater than the previous one while right < n - 1 and arr[right] > arr[right + 1]: right += 1 # Calculate the length of the peak subarray max_len = max(max_len, right - left + 1) return max_len"},{"question":"Write a program that takes in a list of words and returns the list of words grouped by their anagrams. The order of the output does not matter. Each group of anagrams should be represented as a list of words, and the list of groups should be represented as a list of lists. Each input word consists of lowercase English letters only.","solution":"from collections import defaultdict def group_anagrams(words): Groups words by their anagrams. Parameters: words (list): A list of words (strings). Returns: list: A list of lists where each sublist contains words that are anagrams of each other. anagrams = defaultdict(list) for word in words: sorted_word = \'\'.join(sorted(word)) anagrams[sorted_word].append(word) return list(anagrams.values())"},{"question":"You are given an array `height` of size `n`, where `height[i]` represents the height of the `i-th` person. Calculate the minimum number of steps required to sort this array in non-decreasing order. In a single step, you can select any person and move them to any position in the array (possibly the same position). Return an integer representing the minimum number of such moves needed to sort the array.","solution":"def min_moves_to_sort(height): Returns the minimum number of moves required to sort the array in non-decreasing order. n = len(height) # Create a sorted version of the array sorted_height = sorted(height) # Find the length of the longest subsequence that is already in order dp = [0] * n for i in range(n): for j in range(i): if height[i] >= height[j]: dp[i] = max(dp[i], dp[j] + 1) dp[i] = max(dp[i], 1) longest_subsequence = max(dp) # The minimum number of moves required is the total number of elements minus the length of this subsequence return n - longest_subsequence"},{"question":"Given a string `s` containing lower case alphabets and an integer `k`, convert the string such that the first `k` characters of the string are moved to the end. If `k` is greater than the length of the string, the resultant string should be the same as the original string. Write a function that returns the transformed string.","solution":"def transform_string(s, k): Converts the string such that the first k characters are moved to the end. If k is greater than the length of the string, the resultant string is the same as the original string. :param s: The original string :param k: The number of characters to move from the start to the end :return: Transformed string if k > len(s): return s return s[k:] + s[:k]"},{"question":"Given a directed graph represented as an adjacency list, determine if the graph contains a cycle. The graph nodes are numbered from 0 to `n-1`. Implement a function `isCyclic` that returns `true` if there is a cycle in the graph, and `false` otherwise. **Definition of isCyclic:** ```python def isCyclic(graph: List[List[int]]) -> bool: ``` **Parameters:** - `graph` is a list of lists, where `graph[i]` contains the list of nodes that node `i` points to. **Example:** ``` graph = [[1, 2], [2], [0, 3], [4], []] isCyclic(graph) => true graph = [[1], [2], [3], []] isCyclic(graph) => false ``` **Note:** - The graph may be disconnected. - The function should handle an empty graph. - The number of nodes in the graph is `n`, where `1 <= n <= 10^4` and the number of edges is `m`, where `0 <= m <= 10^4`. - Aim for an efficient algorithm with reasonable time complexity.","solution":"from typing import List def isCyclic(graph: List[List[int]]) -> bool: def dfs(v): if visited[v] == 2: # Processed return False if visited[v] == 1: # In current path return True visited[v] = 1 # Mark the current node as visited for neighbor in graph[v]: if dfs(neighbor): return True visited[v] = 2 # Mark the current node as processed return False n = len(graph) visited = [0] * n # 0: not visited, 1: in current path, 2: processed for i in range(n): if not visited[i]: # If not visited yet if dfs(i): return True return False"},{"question":"You are given a string `s` representing a sentence containing words and spaces. A word is defined as a sequence of non-space characters. Remove the spaces between the words such that all words are concatenated into a single string without spaces. Return the resulting concatenated string.","solution":"def concatenate_words(s): Removes the spaces between the words in the given string s and concatenates all words into a single string. Parameters: s (str): The input string containing words separated by spaces. Returns: str: The concatenated string without spaces. return \'\'.join(s.split())"},{"question":"You are given an integer `x` and an array of integers `numbers`. Determine if there exist two distinct elements in the array such that their sum is equal to `x`. If such a pair exists, return `true`; otherwise, return `false`. Note that the array may contain both positive and negative integers.","solution":"def has_pair_with_sum(numbers, x): Determines if there exist two distinct elements in the array such that their sum is equal to x. :param numbers: List of integers :param x: Integer, target sum :return: Boolean, True if there exist two numbers whose sum is x, else False seen_numbers = set() for number in numbers: required = x - number if required in seen_numbers: return True seen_numbers.add(number) return False"},{"question":"Given a string `s`, partition `s` into as few strings as possible such that each string is a palindrome. Return _the **minimum** number of substring partitions needed_. A **palindrome** is a string that reads the same forward and backward. **For example:** - For the input \\"aab\\", the minimum number of palindrome partitions is 1, because the string can be partitioned as [\\"aa\\", \\"b\\"]. - For the input \\"a\\", the minimum number of palindrome partitions is 0 because the single character \\"a\\" is already a palindrome.","solution":"def min_palindrome_partitions(s): Returns the minimum number of palindrome partitions needed. n = len(s) if n == 0: return 0 # Initialize dp and palindrome matrix dp = [0] * (n + 1) dp[0] = -1 is_palindrome = [[False] * n for _ in range(n)] for end in range(n): for start in range(end + 1): if s[start] == s[end] and (end - start <= 2 or is_palindrome[start + 1][end - 1]): is_palindrome[start][end] = True for i in range(1, n + 1): min_cuts = float(\'inf\') for j in range(i): if is_palindrome[j][i - 1]: min_cuts = min(min_cuts, dp[j] + 1) dp[i] = min_cuts return dp[n]"},{"question":"You are given a list of strings `log_entries` where each entry represents a log message. The log message consists of an identifier and the log content, separated by a space. Identifiers are alphanumeric strings while the content consists of words and/or digits. Your task is to reorder these logs such that all the logs with purely alphabetical content come before any logs with numerical content. The alphabetical logs should be ordered lexicographically by content, and in case of ties, by their identifiers. Numerical logs should be kept in their original relative order. Return _the reordered list of log entries._","solution":"def reorder_log_entries(log_entries): Reorders the log entries such that alphabetical content logs come before numerical content logs. Alphabetical logs are ordered lexicographically by content, and by their identifiers in case of ties. Numerical logs maintain their original order. alpha_logs = [] num_logs = [] for log in log_entries: identifier, content = log.split(\\" \\", 1) if content.replace(\\" \\", \\"\\").isnumeric(): num_logs.append(log) else: alpha_logs.append((content, identifier, log)) # Sort alphabetic logs by content and identifier alpha_logs.sort(key=lambda x: (x[0], x[1])) # Extract the ordered logs ordered_logs = [log[2] for log in alpha_logs] + num_logs return ordered_logs"},{"question":"You are given a linked list, `head`, where each node contains an integer value. Your task is to reverse the nodes of the linked list `k` at a time and return its modified list. If the number of nodes is not a multiple of `k` then leave the last nodes as they are. You may not alter the values in the nodes, only the nodes themselves may be changed. Return _the modified linked list_ after reversing the nodes `k` at a time.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverseKGroup(head, k): def reverse(start, end): prev, curr = None, start while curr != end: temp = curr.next curr.next = prev prev = curr curr = temp return prev dummy = ListNode(0) dummy.next = head prev_group_end = dummy while True: k_node = prev_group_end for _ in range(k): k_node = k_node.next if not k_node: return dummy.next next_group_start = k_node.next start, end = prev_group_end.next, k_node.next reversed_head = reverse(start, end) prev_group_end.next = reversed_head start.next = next_group_start prev_group_end = start return dummy.next"},{"question":"Given an array of integers `nums`, you need to construct a binary tree from it using the following algorithm: 1. Create a root node with the maximum value in `nums`. 2. Recursively construct the left subtree with the elements to the left of the maximum value. 3. Recursively construct the right subtree with the elements to the right of the maximum value. Return the root of the constructed binary tree. The function signature is: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def constructMaximumBinaryTree(nums: List[int]) -> TreeNode: pass ```","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def constructMaximumBinaryTree(nums): if not nums: return None max_value = max(nums) max_index = nums.index(max_value) root = TreeNode(val=max_value) root.left = constructMaximumBinaryTree(nums[:max_index]) root.right = constructMaximumBinaryTree(nums[max_index + 1:]) return root"},{"question":"You are given an integer array `nums` consisting of `n` positive integers and an integer `difference`. If `nums[i] + difference` is present in the array for every `nums[i]`, it forms an arithmetic sequence. Return _the length of the longest arithmetic sequence that can be formed from any `nums` starting element with a common difference of `difference`._","solution":"def longest_arith_seq_length(nums, difference): Returns the length of the longest arithmetic sequence that can be formed with a given common difference. :param nums: List of positive integers :param difference: Integer, the common difference :return: Integer, length of the longest arithmetic sequence if not nums: return 0 dp = {} max_length = 0 for num in nums: if num - difference in dp: dp[num] = dp[num - difference] + 1 else: dp[num] = 1 max_length = max(max_length, dp[num]) return max_length"},{"question":"You are given a **0-indexed** array `arr` of `n` integers. A **_good pair_** is defined as two indices **(i, j)** where `0 <= i < j < n` and `arr[i] == arr[j]`. Return _the number of **good pairs** in_ `arr`.","solution":"def count_good_pairs(arr): Returns the number of good pairs in the array. A good pair is defined as two indices (i, j) where 0 <= i < j < n and arr[i] == arr[j]. Params: arr (list): A list of integers Returns: int: The number of good pairs in the list from collections import defaultdict count = 0 freq = defaultdict(int) for num in arr: count += freq[num] freq[num] += 1 return count"},{"question":"Given an array of integers `heights` representing the heights of students in a class and an integer `k`, write a function to determine the k-th smallest distance between any two distinct heights in the array. The distance between two heights is defined as their absolute difference. Return the k-th smallest distance.","solution":"def kth_smallest_distance(heights, k): Returns the k-th smallest distance between any two distinct heights in the array. The distance is defined as the absolute difference between two heights. from itertools import combinations import heapq # Generate all unique pair distances distances = [] for a, b in combinations(heights, 2): distances.append(abs(a - b)) # Use a min-heap to get the k-th smallest element return heapq.nsmallest(k, distances)[-1]"},{"question":"You are given a list of integers `nums` representing cooldown times of spells a sorcerer can cast. The sorcerer can cast any spell at any time, but each spell cast incurs a cooldown before it can be cast again. The cooldown time varies for each spell. You need to determine the minimum amount of time required to cast each spell in `nums` exactly once, assuming the sorcerer uses an optimal strategy. Specifically, given the cooldown times in `nums`, return the minimum total time required to cast all spells exactly once while adhering to their respective cooldowns.","solution":"def min_cast_time(nums): Returns the minimum total time required to cast all spells exactly once while adhering to their respective cooldowns. Args: nums: List[int] - A list of integers representing cooldown times of spells Returns: int - Minimum total time required to cast all spells if not nums: return 0 nums_sorted = sorted(nums, reverse=True) total_time = 0 current_time = 0 for cooldown in nums_sorted: current_time += cooldown total_time = max(total_time, current_time) return total_time"},{"question":"You are given a list of `n` tasks labeled from `0` to `n-1`, and an integer array `arr` of length `m` where for each element in index `i` (0 <= i < m), `arr[i]` represents a prerequisite pair `[a, b]` which means task `a` needs to be completed before task `b`. Determine if you can finish all tasks. If yes, return the order in which the tasks can be finished without violating the prerequisites. If not, return an empty list.","solution":"from collections import defaultdict, deque def can_finish_tasks(num_tasks, prerequisites): Determine if you can finish all tasks given the list of prerequisites. :param num_tasks: Number of tasks (labeled from 0 to n-1) :param prerequisites: List of pairs [a, b] meaning task a should be completed before task b. :return: List of tasks in the order they can be completed or empty list if not possible. graph = defaultdict(list) in_degree = [0] * num_tasks for dest, src in prerequisites: graph[src].append(dest) in_degree[dest] += 1 queue = deque([i for i in range(num_tasks) if in_degree[i] == 0]) order = [] while queue: node = queue.popleft() order.append(node) for neigh in graph[node]: in_degree[neigh] -= 1 if in_degree[neigh] == 0: queue.append(neigh) if len(order) == num_tasks: return order else: return []"},{"question":"You are given a weighted, **undirected** graph represented by an integer `n` which is the number of nodes (from `0` to `n-1`), and an array `edges` where each `edges[i] = [node1, node2, weight]` represents an edge between `node1` and `node2` with a given `weight`. Additionally, you are given an integer `x`. You can increase the weight of existing edges by `x` units. Return the **minimum possible total weight** of a **spanning tree** for the graph after the optimal increase in weights for the edges. A **spanning tree** of a graph is a connected subgraph that includes all the nodes of the original graph and has no cycles.","solution":"import heapq from collections import defaultdict def min_spanning_tree(n, edges, x): def increase_weights(edges, x): return [(w + x, u, v) for u, v, w in edges] def kruskal(n, edges): parent = list(range(n)) rank = [0] * n def find(u): if parent[u] != u: parent[u] = find(parent[u]) return parent[u] def union(u, v): root_u = find(u) root_v = find(v) if root_u != root_v: if rank[root_u] > rank[root_v]: parent[root_v] = root_u elif rank[root_u] < rank[root_v]: parent[root_u] = root_v else: parent[root_v] = root_u rank[root_u] += 1 return True return False edges_sorted = sorted(edges) weight_sum = 0 size = 0 for w, u, v in edges_sorted: if union(u, v): weight_sum += w size += 1 if size == n - 1: break return weight_sum increased_edges = increase_weights(edges, x) return kruskal(n, increased_edges)"},{"question":"You are given a string `s` consisting of lowercase English letters. A **substring** is defined as a contiguous sequence of characters within `s`. You are to find the longest substring that consists of a single, repeating character. Return the length of that longest substring. For example, given the string `s = \\"aaabbccddeeee\\"`, the longest substring of repeating characters is `\\"eeee\\"`, and its length is 4.","solution":"def longest_repeating_substring(s): Returns the length of the longest substring consisting of a single, repeating character. if not s: return 0 max_length = 1 current_length = 1 for i in range(1, len(s)): if s[i] == s[i - 1]: current_length += 1 max_length = max(max_length, current_length) else: current_length = 1 return max_length"},{"question":"You are given a **0-indexed** 2D integer array `matrix` consisting of `m` rows and `n` columns, where each cell represents a certain value. Additionally, you are given an array `queries`, where `queries[i] = [x1, y1, x2, y2]`. For each query, calculate the sum of the integers in the submatrix defined by its top-left corner `(x1, y1)` and bottom-right corner `(x2, y2)` (inclusive). The result for each query should be appended to a list. Return the list of results for all the queries.","solution":"def sum_submatrix(matrix, queries): Returns a list of sums of integers in the submatrices defined by the queries. Parameters: matrix (List[List[int]]): 2D array of integers queries (List[List[int]]): List of queries, each query is of the form [x1, y1, x2, y2] Returns: List[int]: List of sums for each query results = [] for x1, y1, x2, y2 in queries: submatrix_sum = 0 for i in range(x1, x2 + 1): for j in range(y1, y2 + 1): submatrix_sum += matrix[i][j] results.append(submatrix_sum) return results"},{"question":"A **rotated array** is an array that is initially sorted in ascending order, but then each element is shifted some number of positions to the right. For example, `[0,1,2,4,5,6,7]` might become `[4,5,6,7,0,1,2]`. Given an integer array `nums` and an integer `target`, return the index of `target` if it exists in the array, or `-1` if it does not. You must write an algorithm with `O(log n)` runtime complexity.","solution":"def search_rotated_array(nums, target): Search for the target in a rotated array and return its index, or -1 if it does not exist. if not nums: return -1 left, right = 0, len(nums) - 1 while left <= right: mid = left + (right - left) // 2 if nums[mid] == target: return mid # Check if the left side is sorted if nums[left] <= nums[mid]: if nums[left] <= target < nums[mid]: right = mid - 1 else: left = mid + 1 # Otherwise, the right side must be sorted else: if nums[mid] < target <= nums[right]: left = mid + 1 else: right = mid - 1 return -1"},{"question":"Given a **2D grid** of size `m x n` representing a map where `1` represents land and `0` represents water, write a function to find the size of the largest island. An island is a group of adjacent lands connected vertically or horizontally. You may assume all four edges of the grid are all surrounded by water. Return the size of the largest island.","solution":"def largest_island(grid): def dfs(i, j): if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or grid[i][j] == 0: return 0 grid[i][j] = 0 # Mark the land as visited by setting it to water size = 1 size += dfs(i + 1, j) size += dfs(i - 1, j) size += dfs(i, j + 1) size += dfs(i, j - 1) return size max_size = 0 for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == 1: max_size = max(max_size, dfs(i, j)) return max_size"},{"question":"**[Question 4]:** Given an integer array `nums` and an integer `k`, return the number of unique pairs `(i, j)` where `i != j` such that `nums[i] + nums[j] == k`. A pair is considered unique if there are no duplicate pairs with the same elements regardless of their positions. For example, given `nums = [1, 2, 3, 4, 3]` and `k = 6`, the return value should be 2 since there are two unique pairs `(2, 4)` and `(3, 3)` that add up to 6.","solution":"def count_unique_pairs(nums, k): Returns the number of unique pairs (i, j) where i != j and nums[i] + nums[j] == k. seen = set() pair_set = set() for num in nums: complement = k - num if complement in seen: pair = tuple(sorted((num, complement))) pair_set.add(pair) seen.add(num) return len(pair_set)"},{"question":"Given a 2D matrix `matrix` and an integer `k`, your task is to find the `k`-th smallest element in the matrix. Note that each row and column of the matrix is sorted in ascending order. Return the `k`-th smallest element as an integer. The matrix dimensions are `rows x cols`, where `rows` and `cols` are the number of rows and columns in the matrix, respectively.","solution":"import heapq def kthSmallest(matrix, k): Returns the k-th smallest element in a sorted matrix. Parameters: matrix (List[List[int]]): 2D matrix where each row and column is sorted in ascending order. k (int): The k-th position. Returns: int: The k-th smallest element in the matrix. # heap to store (element, row, col) and initialize with the first element of each row min_heap = [(matrix[row][0], row, 0) for row in range(min(len(matrix), k))] heapq.heapify(min_heap) while k: element, row, col = heapq.heappop(min_heap) if col + 1 < len(matrix[0]): heapq.heappush(min_heap, (matrix[row][col + 1], row, col + 1)) k -= 1 return element"},{"question":"You are given a 2D matrix representing rows of soldiers and civilians. The soldiers are represented by `1`s and the civilians by `0`s. Each row in the matrix is sorted in non-decreasing order, meaning that all the `1`s will appear to the left of all the `0`s in any row. A row `i` is weaker than a row `j` if the number of soldiers in row `i` is less than the number of soldiers in row `j`. If two rows have the same number of soldiers, then the row with the smaller index is considered weaker. Return the index of the `k` weakest rows in the matrix ordered from the weakest to the strongest.","solution":"def kWeakestRows(matrix, k): Returns the indices of the k weakest rows in the matrix ordered from the weakest to the strongest. # Calculate the number of soldiers in each row soldier_count = [(sum(row), index) for index, row in enumerate(matrix)] # Sort the rows by number of soldiers, and by index if there is a tie sorted_rows = sorted(soldier_count) # Extract the indices of the k weakest rows weakest_indices = [sorted_rows[i][1] for i in range(k)] return weakest_indices"},{"question":"You are given two strings `s` and `t`. You want to convert string `s` into string `t` by deleting characters from `s` without changing the order of the characters in `t`. To accomplish this, you need to determine the **minimum number of deletions** required. Return the minimum number of deletions needed to convert string `s` into string `t`. If it\'s impossible to do so, return `-1`.","solution":"def min_deletions(s, t): Returns the minimum number of deletions needed to convert string s into string t. If it\'s impossible to do so, returns -1. m, n = len(s), len(t) i, j = 0, 0 while i < m and j < n: if s[i] == t[j]: j += 1 i += 1 if j == n: return m - n else: return -1"},{"question":"You are given a **0-indexed** integer array `nums` of length `n` and an integer `target`. You need to determine the number of non-empty continuous subarrays whose sum is equal to `target`. A subarray is a contiguous part of an array. Implement a function `int subarraySum(int[] nums, int target)` that returns the number of continuous subarrays whose sum is equal to `target`.","solution":"def subarray_sum(nums, target): Returns the number of continuous subarrays whose sum equals to the target. total_count = 0 prefix_sum = 0 prefix_sum_counts = {0: 1} for num in nums: prefix_sum += num if prefix_sum - target in prefix_sum_counts: total_count += prefix_sum_counts[prefix_sum - target] if prefix_sum in prefix_sum_counts: prefix_sum_counts[prefix_sum] += 1 else: prefix_sum_counts[prefix_sum] = 1 return total_count"},{"question":"You are given an array of integers `arr` and an integer `x`. Determine if there are two distinct indices `i` and `j` in the array such that the absolute difference between `arr[i]` and `arr[j]` is less than or equal to `x` and `j` is greater than `i`. If such indices exist, return `True`; otherwise, return `False`.","solution":"def has_pair_with_difference(arr, x): Determines if there are two distinct indices i and j such that the absolute difference between arr[i] and arr[j] is less than or equal to x and j > i. :param arr: List of integers :param x: Integer threshold for the absolute difference :return: Boolean indicating if such a pair exists n = len(arr) for i in range(n): for j in range(i + 1, n): if abs(arr[i] - arr[j]) <= x: return True return False"},{"question":"A **Zigzag Conversion** of a string \\"PAYPALISHIRING\\" written in a zigzag pattern on a given number of rows is as follows: `P A H N` `A P L S I I G` `Y I R` Write the code that will take a string and make this conversion given a number of rows. You will be given a string `s` and an integer `numRows`. Return the string that is read line by line: `\\"PAHNAPLSIIGYIR\\"`. Example 1: Input: s = \\"PAYPALISHIRING\\", numRows = 3 Output: \\"PAHNAPLSIIGYIR\\" Example 2: Input: s = \\"PAYPALISHIRING\\", numRows = 4 Output: \\"PINALSIGYAHRPI\\" Explanation: `P I N` `A L S I G` `Y A H R` `P I` Example 3: Input: s = \\"A\\", numRows = 1 Output: \\"A\\"","solution":"def convert(s, numRows): if numRows == 1 or numRows >= len(s): return s rows = [\'\'] * numRows direction = -1 row = 0 for char in s: rows[row] += char if row == 0 or row == numRows - 1: direction *= -1 row += direction return \'\'.join(rows)"},{"question":"You are given a list of `n` non-negative integers representing the amount of water stored in vertical bars of different heights. The width of each bar is 1. Find the maximum area of water that can be trapped between two bars after raining. [Question 4]: Given `heights` list of integers where each element represents the height of a vertical bar, return the maximum amount of water that can be trapped after raining. The width of each bar is 1.","solution":"def max_water_trapped(heights): Calculate the maximum area of water that can be trapped between vertical bars. :param heights: List of non-negative integers representing heights of vertical bars. :return: Maximum amount of trapped water. if not heights or len(heights) < 3: return 0 left, right = 0, len(heights) - 1 max_water = 0 while left < right: height = min(heights[left], heights[right]) width = right - left max_water = max(max_water, height * width) if heights[left] < heights[right]: left += 1 else: right -= 1 return max_water"},{"question":"You are given an array of integers `nums` and an integer `k`. You are tasked with finding the `k-th` smallest number in the array after performing the following operation exactly once: choose any contiguous subarray and reverse its order. Given this constraint, return the `k-th` smallest number post-reversal that can be achieved in any possible way. Ensure your solution works efficiently for larger arrays.","solution":"def kth_smallest_after_reverse(nums, k): Find the k-th smallest number possible after reversing a contiguous subarray. Args: nums: List of integers. k: The k-th position smallest number to find. Returns: int: The k-th smallest number in any possible post-reversal array. n = len(nums) if n == 0 or k <= 0 or k > n: raise ValueError(\\"Invalid input values\\") # If we can reverse any sub-array, the list of achievable numbers is # determined by sorting the entire input list. sorted_nums = sorted(nums) return sorted_nums[k-1]"},{"question":"You are given an integer array `nums` containing **n** unique elements, where each element is an integer between `1` and `n` (inclusive). Construct a new array `result` such that `result[i]` is equal to the number of elements in `nums` that are greater than `nums[i]`. Return the `result` array.","solution":"def count_greater_elements(nums): Given an array \'nums\' containing n unique elements with integers between 1 to n, this function returns a new array such that each element in the new array represents the count of elements in \'nums\' that are greater than the corresponding element in \'nums\'. n = len(nums) result = [0] * n for i in range(n): count = 0 for j in range(n): if nums[j] > nums[i]: count += 1 result[i] = count return result"},{"question":"Create a function that takes a string `s` as input and returns the count of distinct palindromic substrings in the string. A **palindromic substring** is a substring that reads the same forward and backward. For example, given the string `\\"ababa\\"`, the palindromic substrings are `\\"a\\"`, `\\"b\\"`, `\\"aba\\"`, `\\"bab\\"`, and `\\"ababa\\"`, so the function should return `5`.","solution":"def count_distinct_palindromic_substrings(s): Returns the count of distinct palindromic substrings in the given string. :param s: input string :type s: str :return: count of distinct palindromic substrings :rtype: int unique_palindromes = set() n = len(s) # Function to expand around center and add palindromes to the set def expand_around_center(left, right): while left >= 0 and right < n and s[left] == s[right]: unique_palindromes.add(s[left:right+1]) left -= 1 right += 1 for i in range(n): # Odd length palindromes expand_around_center(i, i) # Even length palindromes expand_around_center(i, i + 1) return len(unique_palindromes)"},{"question":"You are given an integer array `nums` of length `n` and two integers `target` and `k`. A **valid subsequence** of `nums` is a subsequence of `nums` where the sum of the elements is equal to `target` and the number of elements in the subsequence is exactly `k`. Return _the number of **distinct** valid subsequences of_ `nums`. **Note** that: * A **subsequence** is derived from an array by deleting some or no elements without changing the order of the remaining elements. * Two subsequences are considered **distinct** if they have different sets of indices in `nums` even if they contain the same elements.","solution":"from itertools import combinations def count_valid_subsequences(nums, target, k): Returns the number of distinct valid subsequences of length k in nums that sum up to target. Args: nums (list of int): List of integers. target (int): The target sum of the subsequence. k (int): The length of the subsequence. Returns: int: The number of distinct valid subsequences. # Generate all combinations of nums of length k subsequences = combinations(nums, k) # Count those that sum to target valid_count = sum(1 for subseq in subsequences if sum(subseq) == target) return valid_count"},{"question":"You are given a 2D integer array `grid` which represents a grid of cells where `grid[i][j]` is the number of gold in the cell located at `(i, j)`. You start in any cell and can move to any of the adjacent cells (left, right, up, or down) from your current cell. The goal is to collect the maximum amount of gold and return to the starting cell. You are not allowed to visit the same cell more than once during your collection trip, then you must return to your starting cell for the collection to be valid. Return _the maximum amount of gold you can collect during this trip_. If no gold can be collected, return `0`.","solution":"def get_maximum_gold(grid): Returns the maximum amount of gold that can be collected from the grid. You start at any cell and can move to any of the adjacent cells (left, right, up, or down). You cannot visit the same cell more than once in a collection trip. :param grid: List[List[int]] - 2D list of integers representing the grid :return: int - Maximum amount of gold that can be collected rows, cols = len(grid), len(grid[0]) if grid else 0 def dfs(x, y): if x < 0 or x >= rows or y < 0 or y >= cols or grid[x][y] == 0: return 0 current_gold = grid[x][y] grid[x][y] = 0 # Mark this cell as visited max_gold = 0 # Explore all 4 possible directions for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: new_x, new_y = x + dx, y + dy max_gold = max(max_gold, dfs(new_x, new_y)) grid[x][y] = current_gold # Unmark this cell (backtrack) return current_gold + max_gold max_gold_collected = 0 for i in range(rows): for j in range(cols): if grid[i][j] != 0: max_gold_collected = max(max_gold_collected, dfs(i, j)) return max_gold_collected"},{"question":"You are given a string `s` and an integer array `indices` of the same length. The string `s` is randomly shuffled such that the character at the `i`-th position of `s` was originally at the position specified by `indices[i]` in the original string. Write a function to restore the string to its original order and return it.","solution":"def restore_string(s, indices): Restores the given string \'s\' to its original order based on the indices array. :param s: A shuffled string. :param indices: A list of indices indicating the original positions of the characters in \'s\'. :return: The original string in the correct order. n = len(s) restored = [\'\'] * n for i, index in enumerate(indices): restored[index] = s[i] return \'\'.join(restored)"},{"question":"You are given a string `s` containing only characters \'a\' and \'b\'. Your task is to determine the **maximum length** of a **substring** that contains an **equal number of \'a\' and \'b\'**. If the string does not contain any such substring, return `0`. For example, if `s = \\"aabb\\"` then the longest substring with equal numbers of \'a\' and \'b\' is `\\"aabb\\"` which has length `4`. If `s = \\"aabbb\\"` then the longest substring with equal numbers of \'a\' and \'b\' is `\\"aabb\\"` which has length `4`. Given the string `s`, return the maximum length of such a substring.","solution":"def find_max_equal_substring_length(s): Finds the maximum length of a substring that contains an equal number of \'a\' and \'b\'. Parameters: s (str): The input string containing only \'a\' and \'b\' characters. Returns: int: The length of the longest substring with equal number of \'a\' and \'b\', or 0 if no such substring exists. max_length = 0 count_map = {0: -1} # Dictionary to store the first occurrence of each balance balance = 0 # Current balance of \'a\' and \'b\' for i, char in enumerate(s): if char == \'a\': balance += 1 elif char == \'b\': balance -= 1 if balance in count_map: max_length = max(max_length, i - count_map[balance]) else: count_map[balance] = i return max_length"},{"question":"You are given an array of `n` integers, `nums`, and an integer `target`. Write a function to determine if there are two distinct indices `i` and `j` in the array such that `nums[i] * nums[j] == target`. Return `true` if such indices exist, and `false` otherwise.","solution":"def has_product_pair(nums, target): Determines if there are two distinct indices i and j in the array such that nums[i] * nums[j] == target. Args: nums: List[int] - List of integers. target: int - The target product. Returns: bool - True if a pair exists, False otherwise. if target == 0: # Check if there are at least two zeros in the list return nums.count(0) > 1 nums_map = {} for i, num in enumerate(nums): if num == 0: continue if target % num == 0: complement = target // num if complement in nums_map: return True nums_map[num] = i return False"},{"question":"Given two strings `s` and `t`, determine if `s` can be transformed into `t` by performing zero or more operations. In each operation, you can either: 1. Insert any character at any position in `s`. 2. Delete any character from `s`. 3. Replace any character in `s` with any character. Return _the minimum number of operations required to transform_ `s` _into_ `t`.","solution":"def min_operations_to_transform(s, t): Returns the minimum number of operations required to transform string s into string t. The allowed operations are insertions, deletions, and replacements. :param s: The input string to be transformed :param t: The target string :return: Minimum number of operations m, n = len(s), len(t) # Creating a 2D array to store the minimum operations for each substring transformation. dp = [[0] * (n + 1) for _ in range(m + 1)] # Base cases: transforming empty string to t and vice versa for i in range(m + 1): dp[i][0] = i for j in range(n + 1): dp[0][j] = j for i in range(1, m + 1): for j in range(1, n + 1): if s[i-1] == t[j-1]: dp[i][j] = dp[i-1][j-1] else: # Minimum of replace, delete or insert operation dp[i][j] = 1 + min(dp[i-1][j-1], dp[i-1][j], dp[i][j-1]) return dp[m][n]"},{"question":"You are given a 2D grid of integers where each cell represents an elevation map where `1` represents land and `0` represents water. You are allowed to perform exactly one operation where you can change a `0` to `1` to build a bridge. Return _the size of the largest island possible after performing _exactly one_ operation_. An island is a group of `1`s connected vertically or horizontally.","solution":"def largest_island(grid): Returns the size of the largest island possible after performing exactly one operation to convert a 0 to a 1. def dfs(grid, i, j, visited, identifier): if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or grid[i][j] != 1 or visited[i][j]: return 0 visited[i][j] = True grid[i][j] = identifier return 1 + dfs(grid, i+1, j, visited, identifier) + dfs(grid, i-1, j, visited, identifier) + dfs(grid, i, j+1, visited, identifier) + dfs(grid, i, j-1, visited, identifier) n, m = len(grid), len(grid[0]) visited = [[False]*m for _ in range(n)] identifier = 2 island_size = {} # Step 1: Mark different islands with different identifiers and calculate their sizes. for i in range(n): for j in range(m): if grid[i][j] == 1 and not visited[i][j]: island_size[identifier] = dfs(grid, i, j, visited, identifier) identifier += 1 max_size = max(island_size.values(), default=0) # Step 2: Try converting each 0 to 1 and calculate potential island size. for i in range(n): for j in range(m): if grid[i][j] == 0: seen = set() potential_size = 1 # Changing this 0 to 1 for x, y in [(i+1, j), (i-1, j), (i, j+1), (i, j-1)]: if 0 <= x < n and 0 <= y < m and grid[x][y] > 1: seen.add(grid[x][y]) for id in seen: potential_size += island_size[id] max_size = max(max_size, potential_size) return max_size"},{"question":"You are given an array of integers `arr` and an integer `m`. Your task is to count the number of contiguous subarrays of `arr` that have a sum equal to `m`. A contiguous subarray is defined as a sequence of elements within the array that are adjacent to one another. Return _the number of such subarrays_.","solution":"def count_subarrays_with_sum(arr, m): Returns the number of contiguous subarrays whose sum equals m. :param arr: List[int] - list of integers :param m: int - the target sum for the subarrays :return: int - number of contiguous subarrays with sum equal to m count = 0 prefix_sum = 0 prefix_sum_counts = {0: 1} for num in arr: prefix_sum += num if prefix_sum - m in prefix_sum_counts: count += prefix_sum_counts[prefix_sum - m] if prefix_sum in prefix_sum_counts: prefix_sum_counts[prefix_sum] += 1 else: prefix_sum_counts[prefix_sum] = 1 return count"},{"question":"You are given an array of integers `nums` and an integer `k`. An element `x` from the array is said to be a \\"k-frequent element\\" if it appears at least `k` times in the array. Return _an array of all the unique \\"k-frequent elements\\"_. If there are no \\"k-frequent elements\\", return an empty array. The output array should be sorted in ascending order.","solution":"from collections import Counter def k_frequent_elements(nums, k): Returns an array of all unique k-frequent elements. # Count the frequency of each element in the array frequency = Counter(nums) # Collect elements that have a frequency of at least k k_frequent = [element for element, count in frequency.items() if count >= k] # Return the sorted list of k-frequent elements return sorted(k_frequent)"},{"question":"You are given an array of positive integers `nums` representing the quantities of different items, and an integer `k`. Your goal is to maximize the number of unique items chosen such that the total number of items chosen does not exceed `k`. Return _the maximum number of unique items_ you can choose. If it is not possible to choose any items, return `0`.","solution":"def max_unique_items(nums, k): Returns the maximum number of unique items you can choose such that the total number of items chosen does not exceed k. Parameters: nums (List[int]): A list of positive integers representing the quantities of different items. k (int): The maximum total number of items that can be chosen. Returns: int: The maximum number of unique items that can be chosen without exceeding the total number k. # Sort the quantities in ascending order to pick the smallest first nums.sort() total_items = 0 unique_items = 0 for qty in nums: if total_items + qty <= k: total_items += qty unique_items += 1 else: break return unique_items"},{"question":"Given an unsorted array `arr` of integers, find the length of the longest sequence of consecutive elements. In other words, identify the length of the longest subarray where each element is one greater than the previous element. Elements in the sequence do not need to be contiguous in the array. _For instance, if `arr = [100, 4, 200, 1, 3, 2]`, the longest sequence of consecutive elements is `[1, 2, 3, 4]`, and the function should return its length, which is `4`._ **Note**: Your solution should have a time complexity of O(n).","solution":"def longest_consecutive_sequence(arr): Finds the length of the longest sequence of consecutive elements in an array. :param arr: List[int] :return: int if not arr: return 0 nums_set = set(arr) max_length = 0 for num in nums_set: # Check if it\'s the start of a sequence if num - 1 not in nums_set: current_num = num length = 1 while current_num + 1 in nums_set: current_num += 1 length += 1 max_length = max(max_length, length) return max_length"},{"question":"You are given a list of `n` meetings represented by their start and end times. Each meeting is represented as a pair of integers `[start, end]`. Your task is to find the maximum number of meetings that can be attended without overlaps. Return _the maximum number of meetings that can be attended_.","solution":"def max_meetings(meetings): Returns the maximum number of meetings that can be attended without overlaps. Parameters: meetings (list of lists): A list of meetings where each meeting is represented by a list of two integers [start, end]. Returns: int: Maximum number of non-overlapping meetings that can be attended. # Sort meetings by their end times meetings.sort(key=lambda x: x[1]) last_end_time = float(\'-inf\') count = 0 for meeting in meetings: if meeting[0] > last_end_time: count += 1 last_end_time = meeting[1] return count"},{"question":"You are given an integer array `arr` of length `n` and an integer `d`. Your task is to check if there are two indices `i` and `j` (0 <= i < j < n) such that `arr[i] - arr[j]` is divisible by `d`. Return `true` if there exist such indices, otherwise return `false`.","solution":"def check_divisible_difference(arr, d): Checks if there are two indices i and j (0 <= i < j < n) in the array `arr` such that the difference between arr[i] and arr[j] is divisible by `d`. Parameters: arr (list[int]): A list of integers. d (int): An integer value to check divisibility. Returns: bool: True if there are such indices, otherwise False. n = len(arr) for i in range(n): for j in range(i + 1, n): if (arr[i] - arr[j]) % d == 0: return True return False"},{"question":"Given a string `s` representing a sentence, create a function to convert the sentence into a \\"Goat Latin\\" sentence. The rules of Goat Latin are as follows: 1. If a word begins with a vowel (`a`, `e`, `i`, `o`, `u`), append \\"ma\\" to the end of the word. 2. If a word begins with a consonant, remove the first letter and append it to the end, then add \\"ma\\". 3. Add one letter `a` to the end of each word per its word index in the sentence, starting with 1. For example, the first word gets \\"a\\" added to the end, the second word gets \\"aa\\" added to the end, and so on. Return the final sentence formatted in Goat Latin.","solution":"def to_goat_latin(sentence): Convert a sentence to Goat Latin. Args: sentence (str): The sentence to convert. Returns: str: The sentence in Goat Latin. vowels = {\'a\', \'e\', \'i\', \'o\', \'u\'} words = sentence.split() goat_latin_words = [] for i, word in enumerate(words): if word[0].lower() in vowels: goat_word = word + \\"ma\\" else: goat_word = word[1:] + word[0] + \\"ma\\" goat_word += \\"a\\" * (i + 1) goat_latin_words.append(goat_word) return \\" \\".join(goat_latin_words)"},{"question":"You are given an array of integers `prices` where `prices[i]` is the price of a given stock on the `i`-th day. You want to maximize your profit by completing at most one transaction (i.e., buy one and sell one share of the stock). However, you must sell the stock within the window of `k` days from the day you bought it. In other words, if you buy the stock on day `i`, you must sell it by day `i+k` at the latest. Return the maximum profit you can achieve under these conditions. If it\'s not possible to achieve any profit, return 0.","solution":"def maxProfit(prices, k): Returns the maximum profit by completing at most one transaction within a window of k days from the day of purchase. If no profit can be achieved, returns 0. n = len(prices) if n == 0 or k <= 0: return 0 max_profit = 0 for i in range(n): for j in range(i + 1, min(i + k + 1, n)): profit = prices[j] - prices[i] if profit > max_profit: max_profit = profit return max_profit"},{"question":"You are given an integer array `nums` and an integer `k`. A **subarray** is a contiguous part of an array. The **beauty** of a subarray is defined as the number of elements in the subarray that are **less than** or **equal to** `k`. Return _the maximum beauty value among all possible subarrays of `nums`._","solution":"def max_beauty(nums, k): Returns the maximum beauty value among all possible subarrays of nums. The beauty is defined as the number of elements in the subarray that are less than or equal to k. max_beauty_val = 0 for i in range(len(nums)): current_beauty = 0 for j in range(i, len(nums)): if nums[j] <= k: current_beauty += 1 max_beauty_val = max(max_beauty_val, current_beauty) return max_beauty_val"},{"question":"You are given an array of integers `arr` representing the heights of columns where the width of each column is `1`. A column and its neighbors can form a container that can hold water. Find _the maximum amount of water that can be trapped after raining_ by the columns in `arr`. The amount of water trapped between two columns is defined as the area of the gap between them, with the height being the shorter of the two columns, and the width being the number of columns between them.","solution":"def max_water_trapped(arr): Find the maximum amount of water that can be trapped between columns in arr. :param arr: List[int] - heights of columns. :return: int - maximum amount of water that can be trapped. if not arr or len(arr) == 0: return 0 left = 0 right = len(arr) - 1 max_water = 0 while left < right: height = min(arr[left], arr[right]) width = right - left current_water = height * width max_water = max(max_water, current_water) if arr[left] < arr[right]: left += 1 else: right -= 1 return max_water"},{"question":"You are given a matrix `grid` of `m x n` size filled with non-negative integers. A move consists of choosing any row or column and toggling every value in that row or column (changing all 0s to 1s and all 1s to 0s). Finding the maximum number of rows that have all values equal after any number of moves.","solution":"def max_equal_rows_after_moves(grid): Returns the maximum number of rows that have all values equal after any number of moves. from collections import Counter row_patterns = [] for row in grid: pattern = tuple(row) inverted_pattern = tuple(1 - cell for cell in row) row_patterns.append(pattern) row_patterns.append(inverted_pattern) counter = Counter(row_patterns) return max(counter.values())"},{"question":"You are given a list of integers `edges` where `edges[i]` represents the number of incoming edges to the `i-th` node in a directed graph. A node `i` with no incoming edges is termed a \\"source node\\". Your task is to return the list of all source nodes in ascending order. A source node `i` is a node where `edges[i] == 0`.","solution":"def find_source_nodes(edges): Returns the list of source nodes in ascending order. :param edges: List[int] -- list of integers where edges[i] represents the number of incoming edges to the i-th node. :return: List[int] -- list of source nodes in ascending order. source_nodes = [i for i, edge_count in enumerate(edges) if edge_count == 0] return sorted(source_nodes)"},{"question":"Given an array of integers `arr` and an integer `k`, you need to form a subarray of `arr` of length `k` such that its sum is as large as possible. Return the sum of this subarray. If there is more than one subarray with the maximum sum, return the sum of the subarray which starts first in the array.","solution":"def max_sum_subarray(arr, k): Returns the maximum sum of a subarray of length k. If there are multiple subarrays with the same maximum sum, the sum of the subarray that appears first is returned. :param arr: List[int] - List of integers :param k: int - Length of the subarray :return: int - Maximum sum of subarray of length k if not arr or k <= 0 or k > len(arr): return 0 max_sum = current_sum = sum(arr[:k]) for i in range(k, len(arr)): current_sum = current_sum - arr[i - k] + arr[i] max_sum = max(max_sum, current_sum) return max_sum"},{"question":"You are given a list of `n` non-negative integers representing the amount of money of each house situated along a street. You are a thief planning to rob houses along this street. However, you cannot rob two adjacent houses because the police will be alerted. Implement a function `rob(nums: List[int]) -> int` that returns the maximum amount of money you can rob tonight without alerting the police. You must consider all possible combinations of houses to rob, excluding any two adjacent houses.","solution":"from typing import List def rob(nums: List[int]) -> int: n = len(nums) if n == 0: return 0 if n == 1: return nums[0] dp = [0] * n dp[0] = nums[0] dp[1] = max(nums[0], nums[1]) for i in range(2, n): dp[i] = max(dp[i-1], dp[i-2] + nums[i]) return dp[-1]"},{"question":"You are given a list of integers `scores` where `scores[i]` represents the score of the `i-th` student. Additionally, you are given an integer `k`, representing the number of students who will receive a reward. Rewards are given to students with the highest scores. If there are students with the same score and they happen to be at the boundary of the top `k` scores, they should all receive the reward. Return _the list of indices of the students who will receive the reward_, sorted in **ascending order**. The indices should be based on the original list of scores.","solution":"def reward_students(scores, k): Determines the list of indices of students who will receive rewards. Parameters: scores (list of int): List of scores of the students. k (int): Number of students who will receive a reward. Returns: list of int: List of indices of students who will receive the reward, sorted in ascending order. # Get a list of tuples containing scores and original indices indexed_scores = list(enumerate(scores)) # Sort by scores in descending order, and by indices in ascending order in case of ties indexed_scores.sort(key=lambda x: (-x[1], x[0])) # Identify the score threshold for rewards threshold_score = indexed_scores[k-1][1] # Collect all indices of students whose scores are above or equal to the threshold result_indices = [index for index, score in indexed_scores if score >= threshold_score] # Sort the indices of students who will receive the reward in ascending order result_indices.sort() return result_indices"},{"question":"You are given an array of integers `nums`. Your task is to find all the unique triplets in the array that sum up to zero (0). A triplet is defined as a set of three distinct indices `(i, j, k)` such that `nums[i] + nums[j] + nums[k] == 0`. Ensure that the set of triplets returned does not contain any duplicate triplets. Return an array of arrays, where each inner array represents a triplet `[a, b, c]` with the mentioned properties.","solution":"def three_sum(nums): Given an array of integers, finds all unique triplets in the array that sum up to zero. Args: nums: List[int] - A list of integers Returns: List[List[int]] - A list of lists, where each inner list represents a unique triplet that sums to zero. nums.sort() res = [] n = len(nums) for i in range(n - 2): if i > 0 and nums[i] == nums[i - 1]: # skip same element to avoid duplicate triplets continue l, r = i + 1, n - 1 while l < r: total = nums[i] + nums[l] + nums[r] if total == 0: res.append([nums[i], nums[l], nums[r]]) while l < r and nums[l] == nums[l + 1]: l += 1 while l < r and nums[r] == nums[r - 1]: r -= 1 l += 1 r -= 1 elif total < 0: l += 1 else: r -= 1 return res"},{"question":"Given an array of `n` integers `arr`, write a function to find out the longest increasing subsequence (LIS) present in the array. The LIS is the longest subsequence of `arr` where each element is strictly greater than the previous element. Return the length of the longest increasing subsequence. Example: `Input: arr = [10, 9, 2, 5, 3, 7, 101, 18]` `Output: 4` Explanation: The longest increasing subsequence is `[2, 3, 7, 101]`, therefore the length is `4`.","solution":"def length_of_LIS(arr): Returns the length of the longest increasing subsequence in arr. if not arr: return 0 n = len(arr) lis = [1] * n for i in range(1, n): for j in range(i): if arr[i] > arr[j]: lis[i] = max(lis[i], lis[j] + 1) return max(lis)"},{"question":"Given a string `s` containing only lowercase letters, return the character that appears the most frequently. If there are multiple characters with the same maximum frequency, return the character that appears first in the string. If the string is empty, return an empty string.","solution":"def most_frequent_char(s): Returns the character that appears the most frequently in the string s. If there are multiple characters with the same maximum frequency, returns the character that appears first in the string. If the string is empty, returns an empty string. if not s: return \'\' # Create a dictionary to count the frequency of each character frequency = {} for char in s: if char in frequency: frequency[char] += 1 else: frequency[char] = 1 # Find the character with the maximum frequency max_char = s[0] max_count = frequency[max_char] for char in s: if frequency[char] > max_count or (frequency[char] == max_count and s.index(char) < s.index(max_char)): max_char = char max_count = frequency[char] return max_char"},{"question":"Implement a function `findAllRoutes` that, given a directed acyclic graph (DAG) represented by an adjacency list, finds all possible routes from a specified start node to an end node. The function should return a list of these routes, with each route represented as a list of nodes. Your solution should ensure that the routes are returned in lexicographical order based on the sequence of node labels. You can assume that the graph does not contain any cycles and all nodes have unique labels.","solution":"def findAllRoutes(graph, start, end): def dfs(current, path): if current == end: routes.append(path) return for neighbor in sorted(graph.get(current, [])): dfs(neighbor, path + [neighbor]) routes = [] dfs(start, [start]) return routes"},{"question":"You are given two integer arrays `nums1` and `nums2` sorted in non-decreasing order and two integers `m` and `n`, representing the number of elements in `nums1` and `nums2` respectively. The arrays `nums1` and `nums2` are to be merged into a single sorted array in non-decreasing order. The final sorted array should not be returned by the function but should be stored inside the array `nums1`. Given the constraints of the array `nums1` being of size `m + n` where the first `m` elements denote the size of the initial number of elements stored in `nums1` and the rest `n` elements are filled with 0, merge the elements of `nums2` into `nums1` in such a way. Populate `nums1` with the merged output when `nums1` and `nums2` are merged.","solution":"def merge(nums1, m, nums2, n): Merges two sorted arrays into one sorted array in-place. Args: nums1 (List[int]): First sorted array with a size of m + n, where the first m elements are initialized, and the rest are 0. m (int): Number of initialized elements in nums1. nums2 (List[int]): Second sorted array with n elements. n (int): Number of elements in nums2. Returns: None: The result is stored in nums1. # Last index of nums1 to start merging from last = m + n - 1 # Merge in reverse order while m > 0 and n > 0: if nums1[m - 1] > nums2[n - 1]: nums1[last] = nums1[m - 1] m -= 1 else: nums1[last] = nums2[n - 1] n -= 1 last -= 1 # Fill nums1 with remaining elements from nums2 if any while n > 0: nums1[last] = nums2[n - 1] n -= 1 last -= 1"},{"question":"Given an array of integers `nums` representing the number of consonants in each segment of text, find the maximum number of segments in which consonants count forms an increasing sequence. A sequence of segments is said to be increasing if for every segment `i` in the sequence, the consonants count in segment `i` is less than the consonants count in segment `i+1`. Return the length of the longest increasing sequence of segments. For example, given the array `[1, 2, 3, 1, 2, 3, 4]`, the longest increasing sequence of segments with increasing consonant counts is `[1, 2, 3, 4]` and its length is `4`. **Input Format:** - `nums`: An array of integers representing the number of consonants in each segment of text. **Output Format:** - An integer representing the length of the longest increasing sequence of segments with increasing consonant counts.","solution":"def longest_increasing_sequence(nums): Returns the length of the longest increasing sequence of segments with increasing consonant counts. if not nums: return 0 n = len(nums) lis = [1] * n # Initialize LIS values for all indexes as 1 # Compute optimized LIS values in bottom-up manner for i in range(1, n): for j in range(0, i): if nums[i] > nums[j] and lis[i] < lis[j] + 1: lis[i] = lis[j] + 1 # Return maximum value in lis return max(lis)"},{"question":"Given an array of integers `arr` of length `n` and an integer `k`, write a function to determine the number of unique elements in each subarray of length `k` of `arr`. A subarray is defined as a contiguous segment of the array. Return _an array_ `result` _of length_ `n - k + 1` _where_ `result[i]` _stores the number of unique elements in the subarray starting at index_ `i`.","solution":"def count_unique_elements(arr, k): Returns an array where each element is the number of unique elements in the subarray of length k starting at that index. from collections import defaultdict n = len(arr) if k > n: return [] result = [] current_count_map = defaultdict(int) unique_count = 0 # Initialize the first window for i in range(k): if current_count_map[arr[i]] == 0: unique_count += 1 current_count_map[arr[i]] += 1 result.append(unique_count) # Slide the window for i in range(k, n): # remove the exiting element from the window element_to_remove = arr[i - k] current_count_map[element_to_remove] -= 1 if current_count_map[element_to_remove] == 0: unique_count -= 1 # add the new element to the window new_element = arr[i] if current_count_map[new_element] == 0: unique_count += 1 current_count_map[new_element] += 1 result.append(unique_count) return result"},{"question":"Implement a function `findDuplicateSubtrees` that takes the root of a binary tree and returns all **duplicate** subtrees. For each duplicate subtree, you only need to return the root node of any one of them. Two trees are duplicate if they have the same structure with the same node values. A subtree is a tree consisting of a node and all of its descendants. The given binary tree will have no more than 5000 nodes. Write a function with the following signature: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right class Solution: def findDuplicateSubtrees(self, root: TreeNode) -> List[TreeNode]: pass ``` The function should return a list of `TreeNode` objects representing the root nodes of the duplicate subtrees.","solution":"from typing import List, Optional from collections import defaultdict class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right class Solution: def findDuplicateSubtrees(self, root: TreeNode) -> List[TreeNode]: def traverse(node): if not node: return \'#\' serial = \\"{},{},{}\\".format(node.val, traverse(node.left), traverse(node.right)) trees[serial].append(node) return serial trees = defaultdict(list) traverse(root) return [nodes[0] for nodes in trees.values() if len(nodes) > 1]"},{"question":"You are given an array of integers representing the heights of consecutive buildings on a street, where the width of each building is 1 unit. Implement a function that calculates the maximum amount of water that can be trapped between the buildings after it rains. Each integer in the array represents the height of the building at that position. Return the total volume of trapped water.","solution":"def trap(height): Calculate the maximum amount of water that can be trapped between buildings represented by height array. if not height: return 0 n = len(height) left_max = [0] * n right_max = [0] * n water_trapped = 0 # Calculate left max for each building left_max[0] = height[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], height[i]) # Calculate right max for each building right_max[n - 1] = height[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], height[i]) # Calculate the trapped water for i in range(n): water_trapped += min(left_max[i], right_max[i]) - height[i] return water_trapped"},{"question":"You are given an integer array `nums` and an integer `k`. Partition the array into pairs such that the sum of each pair is divisible by `k`. Return `true` if such a partitioning is possible; otherwise, return `false`.","solution":"def canArrange(nums, k): Determine if we can partition the array into pairs such that the sum of each pair is divisible by k. Args: nums: List of integers. k: Integer. Returns: bool: True if partitioning is possible, False otherwise. # Calculate frequency of remainders when nums elements are divided by k remainder_counts = [0] * k for num in nums: remainder = num % k remainder_counts[remainder] += 1 # Check pairs from both sides of the remainder array if remainder_counts[0] % 2 != 0: return False for i in range(1, k // 2 + 1): if remainder_counts[i] != remainder_counts[k - i]: return False return True"},{"question":"Given a list of non-negative integers `nums`, you are tasked with finding the maximum sum of a subarray with the constraint that the subarray should not contain any consecutive elements from the original list. Return the maximum sum of such a subarray. **Example:** ```python Input: nums = [3, 2, 5, 10, 7] Output: 15 Explanation: The subarray with the maximum sum is [3, 10], which yields the sum 3 + 10 = 15. ```","solution":"def max_non_consecutive_sum(nums): Returns the maximum sum of non-consecutive elements in the list `nums`. if not nums: return 0 include = 0 exclude = 0 for num in nums: # Current number is included, previous excluded new_include = exclude + num # Current number is excluded, take the maximum of the previous include and exclude exclude = max(include, exclude) include = new_include # Return the maximum of including or excluding last element return max(include, exclude)"},{"question":"You are given a string `s` consisting of lowercase English letters, and an integer `k`. Your task is to determine the maximum number of distinct characters that can be obtained by deleting exactly `k` characters from the string `s`. Return _this maximum count_. Note that the order of the remaining characters can be rearranged to form the maximum distinct count.","solution":"from collections import Counter def max_distinct_characters(s, k): Returns the maximum number of distinct characters after deleting exactly k characters from the string s. # Calculate the frequency of each character frequency = Counter(s) # Sort character counts in ascending order frequencies_sorted = sorted(frequency.values()) # Initialize the number of deletions and distinct characters deletions = 0 distinct_chars = len(frequencies_sorted) # Remove the k characters by reducing the lowest frequency characters first for freq in frequencies_sorted: if deletions + freq <= k: deletions += freq distinct_chars -= 1 else: break return distinct_chars"},{"question":"You are given an array `points` where `points[i] = [xi, yi]` represents a point on a 2D plane. A point is **a critical point** if its `x` coordinate is greater than the `x` coordinate of the previous point and less than the `x` coordinate of the next point, and the absolute difference in `y` coordinates between this point and the next or previous point is greater than a given threshold `d`. Return _the maximum number of critical points possible_.","solution":"def max_critical_points(points, d): Returns the maximum number of critical points possible in the given list of points. Parameters: points (list of list of int): A list where each element is a list of two integers representing x and y coordinates of a point. d (int): The threshold for the absolute difference in y coordinates. Returns: int: The maximum number of critical points. num_points = len(points) if num_points < 3: return 0 critical_points = 0 for i in range(1, num_points - 1): prev_x, prev_y = points[i - 1] curr_x, curr_y = points[i] next_x, next_y = points[i + 1] if prev_x < curr_x < next_x and (abs(curr_y - prev_y) > d or abs(curr_y - next_y) > d): critical_points += 1 return critical_points"},{"question":"Given a string `s` and an integer `k`, your task is to find the `k`-th lexicographically smallest palindrome string that can be obtained by rearranging the characters of `s`. If it is not possible to form such a palindrome, return an empty string. A palindrome is a string that reads the same backward as forward. For example, “radar” and “level” are palindromes. The characters in the string `s` can be rearranged to form multiple palindromes. Return the `k`-th smallest palindrome among them as per lexicographical order, or an empty string if it\'s impossible.","solution":"from itertools import permutations def is_palindrome(s): return s == s[::-1] def kth_lexicographical_palindrome(s, k): Returns the k-th lexicographically smallest palindrome that can be formed by rearranging the characters of s, or an empty string if it\'s not possible. unique_perms = sorted(set(\'\'.join(p) for p in permutations(s))) palindromes = [p for p in unique_perms if is_palindrome(p)] if k <= len(palindromes): return palindromes[k-1] else: return \\"\\""},{"question":"Given an integer array `arr` consisting of `n` distinct integers, and an integer `x`, determine if there exist three elements in `arr` such that their sum is equal to `x`. Return _a list_ of exactly three integers from `arr` whose sum equals `x`. If there are multiple valid answers, return **any of them**. If no such elements exist, return _an empty list_.","solution":"def three_sum(arr, x): Determines if there exist three elements in `arr` such that their sum is equal to `x`. Returns a list of exactly three integers whose sum equals `x`, or an empty list if no such elements exist. arr.sort() n = len(arr) for i in range(n - 2): left, right = i + 1, n - 1 while left < right: current_sum = arr[i] + arr[left] + arr[right] if current_sum == x: return [arr[i], arr[left], arr[right]] elif current_sum < x: left += 1 else: right -= 1 return []"},{"question":"You are given a list of words `words` and a string `pattern`. Return _a list of words from the given list that match the given pattern_. A word matches the pattern if there exists a permutation of letters `p` so that after replacing every letter `x` in the pattern with `p(x)`, we get the original word. You may return the answer in any order.","solution":"def find_and_replace_pattern(words, pattern): Returns a list of words from the given list that match the given pattern. def matches(word, pattern): if len(word) != len(pattern): return False char_map = {} used_chars = set() for w, p in zip(word, pattern): if p not in char_map: if w in used_chars: return False char_map[p] = w used_chars.add(w) elif char_map[p] != w: return False return True return [word for word in words if matches(word, pattern)]"},{"question":"You are given a list of strings `words` and a string `target`. Write an efficient algorithm to calculate the minimum number of operations required to convert any string in the `words` list into the `target` string. The only allowed operation is changing one character to another. If it is not possible to convert any string in `words` to `target`, return -1.","solution":"def min_operations_to_convert(words, target): Calculate the minimum number of operations required to convert any string in the words list into the target string. The operation allowed is changing one character to another. If it is not possible to convert any string in words to target, returns -1. :param words: List of strings :param target: The target string :return: Minimum number of operations or -1 if conversion is not possible def operations_count(word, target): Calculate the number of operations to convert word to target. :param word: Source word :param target: Target word :return: Number of operations or -1 if lengths differ if len(word) != len(target): return -1 return sum(1 for w_char, t_char in zip(word, target) if w_char != t_char) min_operations = float(\'inf\') for word in words: ops = operations_count(word, target) if ops != -1: min_operations = min(min_operations, ops) return min_operations if min_operations != float(\'inf\') else -1"},{"question":"Given a binary tree, write a function that connects all nodes at the same level from left to right using next pointers. Each node in the tree has a `next` pointer, initially set to `NULL`. You need to populate the `next` pointers to point to their next right node. If there is no next node on the same level, the next pointer should be set to `NULL`. The binary tree should be represented using a `Node` class which has the following structure: ```python class Node: def __init__(self, val=0, left=None, right=None, next=None): self.val = val self.left = left self.right = right self.next = next ``` Write a function: ```python def connect(root: \'Node\') -> \'Node\': # Your code here ``` You may assume that the tree is a perfect binary tree (i.e., all leaves are at the same level, and every parent has two children). Your function should return the root node after connecting the next pointers. The algorithm should run in O(n) time complexity and use constant extra space.","solution":"class Node: def __init__(self, val=0, left=None, right=None, next=None): self.val = val self.left = left self.right = right self.next = next def connect(root: \'Node\') -> \'Node\': if not root: return root leftmost = root while leftmost.left: head = leftmost while head: head.left.next = head.right if head.next: head.right.next = head.next.left head = head.next leftmost = leftmost.left return root"},{"question":"You are given an unsorted array of integers `nums` and an integer `k`. Your task is to find the `k`-th smallest element in the array. Note that it is the k-th smallest element in the sorted order, not the k-th distinct element. You are required to solve this problem with an algorithm that has an average-case time complexity of O(n). Return the `k`-th smallest element of the provided array.","solution":"import random def partition(nums, left, right, pivot_index): pivot_value = nums[pivot_index] nums[pivot_index], nums[right] = nums[right], nums[pivot_index] # Move pivot to end store_index = left for i in range(left, right): if nums[i] < pivot_value: nums[store_index], nums[i] = nums[i], nums[store_index] store_index += 1 nums[right], nums[store_index] = nums[store_index], nums[right] # Move pivot to its final place return store_index def quickselect(nums, left, right, k): if left == right: # If the list contains only one element return nums[left] pivot_index = random.randint(left, right) pivot_index = partition(nums, left, right, pivot_index) if k == pivot_index: return nums[k] elif k < pivot_index: return quickselect(nums, left, pivot_index - 1, k) else: return quickselect(nums, pivot_index + 1, right, k) def find_kth_smallest(nums, k): Return the k-th smallest element in the array. return quickselect(nums, 0, len(nums) - 1, k - 1)"},{"question":"Given a string `s` containing only the characters `\'a\'` and `\'b\'`, you can delete any number of characters in `s` to create a new string. Return the length of the longest string you can obtain that has no three consecutive same characters (i.e., no `\'aaa\'` or `\'bbb\'` substrings). For example, given `s = \\"aaabbb\\"`, you can form the string `\\"aabb\\"` with length 4.","solution":"def longest_valid_string_length(s): Given a string s containing only the characters \'a\' and \'b\', this function returns the length of the longest string that can be formed by deleting characters such that no three consecutive characters are the same. Parameters: s (str): Input string containing only \'a\' and \'b\' Returns: int: Length of the longest valid string if not s: return 0 count = 1 prev_char = s[0] result = 1 for i in range(1, len(s)): if s[i] == prev_char: count += 1 if count <= 2: result += 1 else: count = 1 result += 1 prev_char = s[i] return result"},{"question":"You are given an integer array `nums` which contains `2n` integers, where each integer is between `1` and `n`, inclusive. Each integer appears exactly twice in the array. You need to determine if the array can be divided into `n` pairs such that for each pair `(a, b)`, neither of the integers in the pair are equal, and the sum of the integers in each pair matches the sum of the integers in every other pair. Return _a boolean indicating whether such a partitioning is possible_.","solution":"def can_partition_into_equal_sum_pairs(nums): Determine if the array can be partitioned into pairs with equal sums. Args: nums (list): list of integers where each integer appears exactly twice. Returns: bool: True if such partitioning is possible, False otherwise. import collections count = collections.Counter(nums) # Check if we can form pairs if any(v % 2 != 0 for v in count.values()): return False # Each element appears exactly twice, so we can form n pairs where each pair # has identical elements. They all will have sum 2*x, where x is any element in range [1, n]. return True"},{"question":"A library system manages a list of book borrowings. Each borrowing record consists of a unique user ID, a book ID, and timestamps for when the book was borrowed and returned. Implement the `LibrarySystem` class: * `void borrowBook(int userId, int bookId, int borrowTime)` * Logs that a user with ID `userId` borrowed a book with ID `bookId` at time `borrowTime`. * `void returnBook(int userId, int bookId, int returnTime)` * Logs that a user with ID `userId` returned a book with ID `bookId` at time `returnTime`. * `double getAverageBorrowTime(int bookId)` * Returns the average time a book with ID `bookId` is borrowed, computed from all the previous borrowings of that book. The system guarantees that all borrowings and returns are logged in chronological order and that a book is not borrowed by the same user more than once at the same time.","solution":"class LibrarySystem: def __init__(self): self.borrow_records = {} self.return_records = {} self.total_borrow_times = {} self.borrow_counts = {} def borrowBook(self, userId, bookId, borrowTime): if bookId not in self.borrow_records: self.borrow_records[bookId] = {} self.borrow_records[bookId][userId] = borrowTime def returnBook(self, userId, bookId, returnTime): if bookId in self.borrow_records and userId in self.borrow_records[bookId]: borrowTime = self.borrow_records[bookId][userId] borrow_duration = returnTime - borrowTime if bookId not in self.total_borrow_times: self.total_borrow_times[bookId] = 0 self.borrow_counts[bookId] = 0 self.total_borrow_times[bookId] += borrow_duration self.borrow_counts[bookId] += 1 del self.borrow_records[bookId][userId] def getAverageBorrowTime(self, bookId): if bookId in self.total_borrow_times and self.borrow_counts[bookId] > 0: return self.total_borrow_times[bookId] / self.borrow_counts[bookId] return 0.0"},{"question":"You are given a list of strings `logs` where each string represents a log entry. Each log entry consists of a unique identifier followed by a space and then a sequence of words or numbers. The goal is to reorder the logs so that all the letter-logs come before any digit-log. The letter-logs are logs where the content after the identifier consists of words (only lowercase letters), and the digit-logs are logs where the content after the identifier consists of numbers. The letter-logs should be sorted lexicographically by their content, and within content by their identifiers if the content is the same. The digit-logs should maintain their relative ordering. Implement the function `reorderLogFiles(logs: List[str]) -> List[str]` that takes a list of log entries and returns a list of reordered log entries according to the described rules.","solution":"from typing import List def reorderLogFiles(logs: List[str]) -> List[str]: def get_key(log: str): identifier, content = log.split(\' \', 1) if content[0].isdigit(): return (1,) else: return (0, content, identifier) return sorted(logs, key=get_key)"},{"question":"You are given an integer array `arr` and a target integer `target`. Write a function that returns _an array of four distinct indices_ `[i, j, k, l]` such that `arr[i] + arr[j] + arr[k] + arr[l] == target`. The indices `i`, `j`, `k`, and `l` must be sorted in ascending order and satisfy `0 <= i < j < k < l < arr.length`. If no such indices exist, return _an empty array_.","solution":"def four_sum_indices(arr, target): length = len(arr) if length < 4: return [] # Dictionary to keep track of pairs and indices pairs = {} for i in range(length - 1): for j in range(i + 1): current_sum = arr[i] + arr[j] if current_sum not in pairs: pairs[current_sum] = [] pairs[current_sum].append((i, j)) for i in range(length - 1): for j in range(i + 1, length): current_sum = arr[i] + arr[j] complement = target - current_sum if complement in pairs: for p in pairs[complement]: if p[1] < i: return [p[0], p[1], i, j] return []"},{"question":"Given an integer array `height` of length `n`, return the maximum amount of water a container can store. You may assume that the array elements represent the height of vertical lines drawn on the x-axis, and the distance between any two vertical lines is 1 unit. Two lines together with the x-axis form a container. The container with the most water can store is defined by the lines that together can enclose the maximum area.","solution":"def max_area(height): Returns the maximum area of water a container can store given an array of heights. :param height: list of integers representing heights of vertical lines :return: integer representing maximum amount of water the container can store max_water = 0 left = 0 right = len(height) - 1 while left < right: # Calculate area with the current left and right lines width = right - left current_height = min(height[left], height[right]) current_area = width * current_height # Update max_water if current_area is larger max_water = max(max_water, current_area) # Move the pointer that\'s at the shorter line if height[left] < height[right]: left += 1 else: right -= 1 return max_water"},{"question":"Implement a class `WordDictionary` to support the addition of new words and the search for a word in the data structure. You should design the `WordDictionary` class such that the following operations are efficient: * `WordDictionary()` Initializes the object. * `void addWord(String word)` Adds a word to the data structure. * `boolean search(String word)` Returns `true` if the word is in the data structure. Additionally, `.` means any one letter. A word could contain the dot character `.` which can represent any one letter. Example: * `addWord(\\"bad\\")` * `addWord(\\"dad\\")` * `addWord(\\"mad\\")` * `search(\\"pad\\")` -> returns `false` * `search(\\"bad\\")` -> returns `true` * `search(\\".ad\\")` -> returns `true` * `search(\\"b..\\")` -> returns `true`","solution":"class WordDictionary: def __init__(self): self.words = [] def addWord(self, word: str) -> None: self.words.append(word) def search(self, word: str) -> bool: import re for w in self.words: if re.fullmatch(word, w): return True return False"},{"question":"Given an integer array `nums` of length `n` and an integer `x`, consider a new array `new_nums` where each element is the absolute difference between consecutive elements in `nums`. Return _the minimum number of elements in `new_nums` that need to be changed to make all elements of `new_nums` less than or equal to_ `x`.","solution":"def min_changes(nums, x): Returns the minimum number of elements in new_nums that need to be changed to make all elements of new_nums less than or equal to x where new_nums[i] is the absolute difference between consecutive elements in nums. new_nums = [abs(nums[i] - nums[i + 1]) for i in range(len(nums) - 1)] changes = 0 for num in new_nums: if num > x: changes += 1 return changes"},{"question":"You are given a 2D grid of size `m x n` where each cell represents a plot of land that can either be farmland (`1`) or water (`0`). A **farm** is a maximal group of connected farmland plots. All cells in a farm are either horizontally or vertically connected to each other and are surrounded by water or the edge of the grid. A farm does not include any water cells. Write a function that returns the list of coordinates that represent the top-left and bottom-right corners of each farm in the 2D grid. Sort the farms by the coordinates of their top-left corners in the order of their appearance in the grid.","solution":"def find_farms(grid): Returns the list of coordinates representing the top-left and bottom-right corners of each farm in the given 2D grid. def dfs(x, y): stack = [(x, y)] top_left = (x, y) bottom_right = (x, y) while stack: cx, cy = stack.pop() if (cx, cy) not in visited: visited.add((cx, cy)) top_left = (min(top_left[0], cx), min(top_left[1], cy)) bottom_right = (max(bottom_right[0], cx), max(bottom_right[1], cy)) for dx, dy in [(0, 1), (1, 0), (0, -1), (-1, 0)]: nx, ny = cx + dx, cy + dy if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] == 1 and (nx, ny) not in visited: stack.append((nx, ny)) return top_left, bottom_right m, n = len(grid), len(grid[0]) visited = set() farms = [] for i in range(m): for j in range(n): if grid[i][j] == 1 and (i, j) not in visited: top_left, bottom_right = dfs(i, j) farms.append([list(top_left), list(bottom_right)]) return farms"},{"question":"Implement an algorithm to find the longest increasing path in a matrix. You are given an `m x n` matrix of integers where each cell has a certain value. From each cell, you can either move in four directions: left, right, up, or down. You may not move diagonally or move outside the boundary (i.e., only move to adjacent cells). Find the length of the longest path where each successive cell has a strictly greater value than the preceding one. **Note:** You may start from any cell in the matrix. [Question] 5:","solution":"def longestIncreasingPath(matrix): if not matrix or not matrix[0]: return 0 rows, cols = len(matrix), len(matrix[0]) dp = [[-1 for _ in range(cols)] for _ in range(rows)] def dfs(r, c): if dp[r][c] != -1: return dp[r][c] directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] max_len = 1 for dr, dc in directions: rr, cc = r + dr, c + dc if 0 <= rr < rows and 0 <= cc < cols and matrix[rr][cc] > matrix[r][c]: path_len = 1 + dfs(rr, cc) max_len = max(max_len, path_len) dp[r][c] = max_len return max_len longest_path = 0 for r in range(rows): for c in range(cols): longest_path = max(longest_path, dfs(r, c)) return longest_path"},{"question":"You are given a list of strings `phrases`, where each string represents a phrase consisting of words separated by spaces. A string is considered **well-formed** if it meets the following conditions: - Every word in the string contains only lowercase letters (`\'a\'` to `\'z\'`). - Words are separated by exactly one space (`\' \'`). - There are no leading or trailing spaces. Write a function that takes in the list `phrases` and returns the number of well-formed phrases in the list. Example: ``` Input: phrases = [\\"hello world\\", \\" leading space\\", \\"trailing space \\", \\"well formed\\", \\"not well\\"] Output: 2 ``` Explanation: - \\"hello world\\" and \\"well formed\\" are well-formed phrases. - \\" leading space\\" has leading spaces. - \\"trailing space \\" has trailing spaces. - \\"not well\\" has multiple spaces between words.","solution":"def count_well_formed_phrases(phrases): def is_well_formed(phrase): if phrase.startswith(\' \') or phrase.endswith(\' \'): return False words = phrase.split(\' \') return all(word.islower() and word.isalpha() for word in words) return sum(1 for phrase in phrases if is_well_formed(phrase))"},{"question":"You are given an m x n integer matrix `mat` representing a grid. You are also given `k` which represents the maximum number of allowed operations. In one operation, you can add any positive integer to an element of the matrix. The target is to have all elements of the matrix be equal to a given integer `target`. Implement the class `MatrixModifier`: * `MatrixModifier(int[][] mat, int k, int target)` Initializes the object with the integer matrix `mat`, maximum number of allowed operations `k`, and the target integer `target`. * `boolean isPossible()` Returns `true` if it is possible to make all elements of `mat` equal to `target` with at most `k` operations, otherwise returns `false`.","solution":"class MatrixModifier: def __init__(self, mat, k, target): self.mat = mat self.k = k self.target = target def isPossible(self): operations_needed = 0 for row in self.mat: for elem in row: if elem < self.target: operations_needed += (self.target - elem) if operations_needed > self.k: return False return True"},{"question":"You are given an array of integers `nums` and an integer `k`. The array `nums` contains both positive and negative integers, and it is not necessarily sorted. Your task is to find the sum of the `k` largest elements in the array `nums`. Return an integer representing the sum.","solution":"def sum_k_largest(nums, k): Returns the sum of the k largest elements in the array nums. return sum(sorted(nums, reverse=True)[:k])"},{"question":"Given an integer array `arr` consisting of `n` integers and an integer `k`, rearrange the elements of `arr` in such a way that the sum of every `k` consecutive elements is maximized. If there are multiple possible rearrangements, return the lexicographically smallest one. Note: The lexicographical order compares the elements from left to right, and the first positional element with a difference determines the order.","solution":"def rearrange_array(arr, k): Rearrange the elements of arr in such a way that the sum of every k consecutive elements is maximized. If there are multiple possible rearrangements, return the lexicographically smallest one. Parameters: arr (list of int): The array of integers to rearrange. k (int): The number of consecutive elements to consider for sum maximization. Returns: list of int: The rearranged array. # Sort the array in decreasing order to maximize the sum of consecutive k elements arr.sort(reverse=True) return arr"},{"question":"You are given a binary tree rooted at `root`, and an integer `target`. Return the length of the shortest path from the root to any leaf node such that all the values along the path sum up to `target`. If no such path exists, return `-1`. A leaf node is a node that has no children.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def shortest_path_sum(root, target): from collections import deque if not root: return -1 queue = deque([(root, root.val, 1)]) # (node, current_sum, path_length) while queue: node, current_sum, path_length = queue.popleft() # Check if it\'s a leaf node if not node.left and not node.right: if current_sum == target: return path_length # Traverse the left and right children if node.left: queue.append((node.left, current_sum + node.left.val, path_length + 1)) if node.right: queue.append((node.right, current_sum + node.right.val, path_length + 1)) return -1"},{"question":"You are given a list of unique integers `nums` that contains elements ranging from `1` to `n` (both inclusive) in random order. Your task is to **reorder** the elements in `nums` such that all even-indexed positions (`0, 2, 4, ...`) contain even integers and all odd-indexed positions (`1, 3, 5, ...`) contain odd integers. If there are multiple ways to achieve this, return any valid reordering. Assume the input list will always have an equal number of even and odd integers. Return the list after reordering.","solution":"def reorder_even_odd(nums): Reorder the elements in nums such that all even-indexed positions (0, 2, 4, ...) contain even integers and all odd-indexed positions (1, 3, 5, ...) contain odd integers. even_nums = [num for num in nums if num % 2 == 0] odd_nums = [num for num in nums if num % 2 != 0] result = [] even_index, odd_index = 0, 0 for i in range(len(nums)): if i % 2 == 0: result.append(even_nums[even_index]) even_index += 1 else: result.append(odd_nums[odd_index]) odd_index += 1 return result"},{"question":"You are given a rectangular matrix `mat` of dimensions `m x n`. Each cell in the matrix contains either a `0` or a `1`. A cell is called a **special** if: - The value of the cell is `1`, and - The value in all the cells in the corresponding row and all the cells in the corresponding column is `0`. Implement a function `int numSpecial(int[][] mat)` that returns the count of special cells in the given matrix.","solution":"def numSpecial(mat): Returns the count of special cells in the matrix. A special cell is defined as a cell where the value is 1, and all other cells in its row and column are 0. :param List[List[int]] mat: a 2D list of integers (matrix) :return int: count of special cells special_count = 0 # Calculate the number of 1\'s in each row and each column row_count = [sum(row) for row in mat] col_count = [sum(col) for col in zip(*mat)] # Find the special positions for i in range(len(mat)): for j in range(len(mat[i])): if mat[i][j] == 1 and row_count[i] == 1 and col_count[j] == 1: special_count += 1 return special_count"},{"question":"You are given an array of integers `arr` and an integer `window_size`. You need to return a new list where the `i-th` element represents the maximum value of the subarray of `arr` that starts at the `i-th` index and has length `window_size`. If the window_size exceeds the boundaries of the array for any starting index, it should be considered only up to the last element of the array. The input will guarantee that `window_size` is at least 1 and `window_size` is not larger than the length of `arr`.","solution":"def max_in_windows(arr, window_size): Returns a list where the i-th element is the maximum value of the subarray of `arr` that starts at the i-th index and has length `window_size`. If the `window_size` exceeds the boundaries of the array for any starting index, it is considered only up to the last element of the array. Parameters: - arr: List[int] : List of integers. - window_size: int : Size of the window. Returns: - List[int] : List of maximum values for each subarray of size `window_size`. result = [] for i in range(len(arr) - window_size + 1): max_value = max(arr[i:i + window_size]) result.append(max_value) return result"},{"question":"You are given a string `s` consisting of lowercase letters and an integer `k`. You need to rearrange the string such that the maximum number of distinct substrings of length `k` is obtained. Return the maximum number of distinct substrings of length `k` that can be achieved. Example: - Input: `s = \\"abababab\\", k = 2` - Output: `2` Explanation: One possible rearrangement is \\"aabbabab\\" where the distinct substrings of length 2 are \\"aa\\", \\"ab\\", and \\"ba\\". However, the maximum number of distinct substrings that can be achieved is 2, such as \\"ab\\" and \\"ba\\" being unique within the rearranged string. Note: Assume `s` always contains at least `k` characters.","solution":"from collections import Counter def max_distinct_substrings(s, k): Returns the maximum number of distinct substrings of length k that can be achieved by rearranging the string s. if k > len(s): return 0 # Count the frequency of each character in the input string char_count = Counter(s) # The maximum number of distinct substrings of length k we can achieve is limited by two factors: # 1. The number of unique characters in the string # 2. The length of the string divided by k (as each substring of length k must be unique) unique_chars = len(char_count) max_possible_substrings = len(s) // k # The result is the minimum of these two values: result = min(unique_chars, max_possible_substrings) return result"},{"question":"You are given two strings `s1` and `s2`, both representing sequence of moves in a 2D plane where each move is one of the characters: \'U\' (up), \'D\' (down), \'L\' (left), \'R\' (right). Starting from the origin point (0, 0), determine if it is possible for these two sequences to make you end up at the same final position on the plane. Both sequences are guaranteed to be non-empty. Return `true` if they end up at the same position, otherwise return `false`.","solution":"def final_position(s): Calculates the final position after performing the moves in s. x, y = 0, 0 for move in s: if move == \'U\': y += 1 elif move == \'D\': y -= 1 elif move == \'L\': x -= 1 elif move == \'R\': x += 1 return (x, y) def same_final_position(s1, s2): Determines if two sequences of moves s1 and s2 end up at the same final position. return final_position(s1) == final_position(s2)"},{"question":"You are given a 2D integer array `tasks` where `tasks[i] = [difficultyi, durationi]` represents a task with a specific difficulty level and its corresponding duration. You need to assign these tasks to a list of workers represented by an integer array `skills`, where `skills[j]` indicates the skill level of the `j-th` worker. A worker can only complete a task if their skill level is greater than or equal to the task\'s difficulty level. Each worker can complete at most one task. Return the maximum number of tasks that can be completed by assigning them to the workers based on the given constraints.","solution":"def max_tasks_completed(tasks, skills): Returns the maximum number of tasks that can be completed by assigning them to the workers. Args: tasks: List[List[int]] - A List where each element is a list representing [difficulty, duration] of a task. skills: List[int] - A List representing the skill level of each worker. Returns: int - The maximum number of tasks that can be completed. # Sort tasks based on their difficulty in ascending order tasks.sort(key=lambda x: x[0]) # Sort workers based on their skill levels in ascending order skills.sort() task_idx = 0 completed_tasks = 0 # Iterate over each skill level for skill in skills: # Find the first task which can be completed by the current worker while task_idx < len(tasks) and tasks[task_idx][0] <= skill: completed_tasks += 1 task_idx += 1 break # Since each worker can do at most one task return completed_tasks"},{"question":"Given a list of non-negative integers `nums`, calculate the maximum value you can obtain by summing non-adjacent elements of `nums`. In other words, you cannot select two elements that are next to each other in the original list. Return this maximum sum. If the list is empty, return 0.","solution":"def max_non_adjacent_sum(nums): Returns the maximum sum of non-adjacent elements in the list nums. if not nums: return 0 incl = 0 excl = 0 for num in nums: # Current max excluding i (previous inclusive sum) new_excl = max(incl, excl) # Current max including i incl = excl + num excl = new_excl # Return max of incl and excl return max(incl, excl)"},{"question":"Given an `m x n` integer matrix, define the distance between two cells `(i1, j1)` and `(i2, j2)` as the absolute difference in their values. Find the maximum distance you can achieve between any two distinct cells in the matrix such that the value in the first cell is greater than the value in the second cell. Return the maximum distance. Note: You may assume that the matrix contains at least two cells.","solution":"def max_distance(matrix): Finds the maximum distance between any two distinct cells in the matrix such that the value in the first cell is greater than the value in the second cell. Distance is defined as the absolute difference between two cell values. Parameters: matrix (list of list of ints): The m x n integer matrix. Returns: int: The maximum distance achievable. max_val = float(\'-inf\') min_val = float(\'inf\') for row in matrix: for val in row: if val > max_val: max_val = val if val < min_val: min_val = val return max_val - min_val"},{"question":"You are given a string `s` containing a mix of lowercase letters and special characters. A special character is defined as any character that is not a letter. Write a function to sort the string such that all the special characters retain their original positions, and the letters appear in ascending order while keeping the relative positions of the special characters unchanged. Return _the modified string_ after sorting the letters accordingly. **Example:** Given: `s = \\"ac#b\\"` Return: `\\"ab#c\\"`","solution":"def sort_string(s): Sorts the letters in the string s while retaining the positions of special characters. letters = [char for char in s if char.isalpha()] letters.sort() result = [] letter_idx = 0 for char in s: if char.isalpha(): result.append(letters[letter_idx]) letter_idx += 1 else: result.append(char) return \'\'.join(result)"},{"question":"There is a grid of size `m x n` filled with integers, where each cell contains either a `0` or a `1`. You are given this grid as a 2D integer array `matrix`. You need to find the size of the largest square containing all `1`\'s and return its area. For example: ``` Input: matrix = [ [\\"1\\", \\"0\\", \\"1\\", \\"0\\", \\"0\\"], [\\"1\\", \\"0\\", \\"1\\", \\"1\\", \\"1\\"], [\\"1\\", \\"1\\", \\"1\\", \\"1\\", \\"1\\"], [\\"1\\", \\"0\\", \\"0\\", \\"1\\", \\"0\\"] ] Output: 4 ```","solution":"def maximal_square(matrix): if not matrix: return 0 m, n = len(matrix), len(matrix[0]) dp = [[0] * (n + 1) for _ in range(m + 1)] max_side = 0 for i in range(1, m + 1): for j in range(1, n + 1): if matrix[i - 1][j - 1] == \'1\': dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1 max_side = max(max_side, dp[i][j]) return max_side * max_side"},{"question":"You are given a non-empty string containing only lowercase alphabetic characters. Write a function to return the length of the longest substring of the given string that contains at most two distinct characters. The substring must be contiguous and may involve any combination of the two characters.","solution":"def length_of_longest_substring_two_distinct(s): Returns the length of the longest substring containing at most two distinct characters. if len(s) < 3: return len(s) left = 0 right = 0 max_length = 2 char_map = {} while right < len(s): char_map[s[right]] = right right += 1 if len(char_map) > 2: del_idx = min(char_map.values()) del char_map[s[del_idx]] left = del_idx + 1 max_length = max(max_length, right - left) return max_length"},{"question":"You are given an array of integers `arr` of length `n`, representing the heights of students standing in a line. Each student has a height `arr[i]`. A pair of students (i, j) is said to be a low-high pair if i < j and arr[i] < arr[j]. Calculate the total number of low-high pairs in the array.","solution":"def count_low_high_pairs(arr): Returns the count of low-high pairs in the given array. A pair (i, j) is defined as low-high if i < j and arr[i] < arr[j]. n = len(arr) count = 0 for i in range(n - 1): for j in range(i + 1, n): if arr[i] < arr[j]: count += 1 return count"},{"question":"You are given an `hours` array, where `hours[i]` represents the number of hours a worker has worked on the `i-th` day. A worker is considered to have a \\"good day\\" if they work more than `8` hours in a day. You need to calculate the longest duration of consecutive good days in the given array. Return the length of this longest duration.","solution":"def longest_good_days(hours): Returns the length of the longest duration of consecutive good days. A good day is when hours worked is more than 8. Parameters: hours (list of int): List representing hours worked each day. Returns: int: The length of the longest duration of consecutive good days. max_length = 0 current_length = 0 for hour in hours: if hour > 8: current_length += 1 max_length = max(max_length, current_length) else: current_length = 0 return max_length"},{"question":"You are given an `n` x `n` grid representing a maze, where `0` represents an empty space and `1` represents a wall. There is exactly one entrance and one exit in the maze. You need to determine if there is a path from the entrance to the exit, where you can only move up, down, left, or right and cannot move through walls. Write a function that returns a boolean value indicating whether such a path exists. Function Signature: `def can_reach_exit(maze: List[List[int]], entrance: Tuple[int, int], exit: Tuple[int, int]) -> bool:`","solution":"from typing import List, Tuple def can_reach_exit(maze: List[List[int]], entrance: Tuple[int, int], exit: Tuple[int, int]) -> bool: rows, cols = len(maze), len(maze[0]) visited = [[False] * cols for _ in range(rows)] def dfs(r, c): if (r, c) == exit: return True if r < 0 or r >= rows or c < 0 or c >= cols or maze[r][c] == 1 or visited[r][c]: return False visited[r][c] = True # Explore neighbors: up, down, left, right if dfs(r - 1, c) or dfs(r + 1, c) or dfs(r, c - 1) or dfs(r, c + 1): return True return False return dfs(entrance[0], entrance[1])"},{"question":"You are given a list of strings `words` where each word is a concatenation of lowercase English letters. You need to find the longest string `s` that can be formed by any permutation of strings from a subset of `words` satisfying the condition that characters in `s` do not repeat consecutively. Return the length of the longest possible string `s`. If it is not possible to form such a string, return `-1`.","solution":"def longest_non_repeating_concat(words): from collections import Counter # Count frequency of each character char_counter = Counter(\'\'.join(words)) # Max frequency of any character max_freq = max(char_counter.values()) # Total length of all words combined total_length = sum(char_counter.values()) # If the max frequency character appears more than (total_length + 1) // 2 times, # it\'s not possible to arrange without repeating if max_freq > (total_length + 1) // 2: return -1 return total_length"},{"question":"You are given an array of integers `arr` and an integer `k`. A subarray is defined as a non-empty contiguous sequence of elements in the array. Your task is to find the length of the longest subarray where the difference between the largest and the smallest elements is less than or equal to `k`. Return the length of that subarray. If no such subarray exists, return 0.","solution":"def longest_subarray_with_diff(arr, k): Returns the length of the longest subarray where the difference between the largest and the smallest elements is less than or equal to k. from collections import deque max_len = 0 min_queue = deque() # Deque to store indices of elements in increasing order max_queue = deque() # Deque to store indices of elements in decreasing order left = 0 for right in range(len(arr)): while min_queue and arr[min_queue[-1]] >= arr[right]: min_queue.pop() while max_queue and arr[max_queue[-1]] <= arr[right]: max_queue.pop() min_queue.append(right) max_queue.append(right) while arr[max_queue[0]] - arr[min_queue[0]] > k: left += 1 if min_queue[0] < left: min_queue.popleft() if max_queue[0] < left: max_queue.popleft() max_len = max(max_len, right - left + 1) return max_len"},{"question":"Write a function that takes a list of integers `nums` and an integer `k`. The function should rotate the list to the right by `k` steps, where `k` is non-negative. This rotation means that each element in the list will be moved `k` positions to the right, and elements that are shifted beyond the last position will wrap around to the beginning of the list. Return the list after rotating.","solution":"def rotate(nums, k): Rotates the list nums to the right by k steps. Parameters: nums (list of int): The list of integers to rotate. k (int): The number of steps to rotate the list. Returns: list of int: The rotated list. n = len(nums) k = k % n # Handle cases where k is greater than the size of the list return nums[-k:] + nums[:-k]"},{"question":"You are given a list of integers `heights` representing the heights of buildings arranged consecutively. The rainwater trapped between the buildings can be calculated as follows: for each building, the amount of water trapped above it is the smaller of the maximum height of the buildings to its left and to its right, minus its own height, as long as this value is positive. Compute the total amount of rainwater trapped between the buildings. Return the total amount of trapped rainwater.","solution":"def trap_rainwater(heights): if not heights: return 0 n = len(heights) left_max = [0] * n right_max = [0] * n left_max[0] = heights[0] for i in range(1, n): left_max[i] = max(left_max[i-1], heights[i]) right_max[n-1] = heights[n-1] for i in range(n-2, -1, -1): right_max[i] = max(right_max[i+1], heights[i]) water_trapped = 0 for i in range(n): water_trapped += max(0, min(left_max[i], right_max[i]) - heights[i]) return water_trapped"},{"question":"Given an array `nums` of integers, partition it into two (possibly empty) subsequences such that the sum of the first subsequence is strictly less than the sum of the second subsequence. Return the minimum possible difference between the sums of the two subsequences. Each element in the array must be included in exactly one of the subsequences. For example, given `nums = [2, 1, 5, 6]`, one possible partition is `[2, 1]` and `[5, 6]` with sums `3` and `11`, having a difference of `8`. Another partition is `[2, 5]` and `[1, 6]` with sums `7` and `7`, having a difference of `0`. If the array is empty, return `0`.","solution":"from itertools import product def min_difference_partition(nums): if not nums: return 0 total_sum = sum(nums) n = len(nums) half_sum = total_sum // 2 possible_sums = {0} for num in nums: new_sums = {x + num for x in possible_sums} possible_sums = possible_sums.union(new_sums) min_diff = float(\'inf\') for s in possible_sums: if s <= half_sum: min_diff = min(min_diff, abs(total_sum - 2 * s)) return min_diff"},{"question":"You are given a **0-indexed** integer array `arr`. A subarray is called \\"balanced\\" if the sum of its elements to the left of the middle element is equal to the sum of its elements to the right of the middle element. Note that for a subarray with an even length, the element just to the right of the middle must be considered as the balancing point. Return the **length** of the longest balanced subarray. If no balanced subarray exists, return `-1`.","solution":"def longest_balanced_subarray(arr): Returns the length of the longest balanced subarray. If no balanced subarray exists, returns -1. n = len(arr) if n == 0: return -1 max_length = -1 def is_balanced(sub): sub_len = len(sub) mid = sub_len // 2 if sub_len % 2 == 0: left_sum = sum(sub[:mid]) right_sum = sum(sub[mid:]) else: left_sum = sum(sub[:mid]) right_sum = sum(sub[mid+1:]) return left_sum == right_sum for length in range(2, n + 1): for start in range(n - length + 1): sub = arr[start:start + length] if is_balanced(sub): max_length = max(max_length, length) return max_length"},{"question":"You are given a list of `n` activities where each activity has a start time and an end time represented by two **0-indexed** integer arrays `start` and `end` respectively. An activity `i` starts at `start[i]` and ends at `end[i]`. You have a single slot of time starting from `time` of duration `duration`. Find the maximum number of activities you can fully complete within this slot. An activity `i` is considered complete if it starts and ends within the slot `[time, time + duration]`. Return the count of such activities.","solution":"def max_activities_within_slot(start, end, time, duration): Returns the maximum number of activities that can be fully completed within the given time slot. :param start: List of start times of activities. :param end: List of end times of activities. :param time: The starting time of the slot. :param duration: The duration of the slot. :return: Maximum number of activities that can be fully completed within the slot. count = 0 slot_end = time + duration for s, e in zip(start, end): if time <= s and e <= slot_end: count += 1 return count"},{"question":"Given a list of `courses` where a prerequisite is represented as `courses[i] = [a, b]`, indicating you must take course `b` before course `a`. All the courses are labeled as `0, 1, 2, ..., n-1`. Write a function to find if it is possible to finish all courses given the prerequisites. Return `true` if it is possible to finish all courses, otherwise return `false`. You may assume that there are no duplicate prerequisites in the input.","solution":"from collections import defaultdict, deque def can_finish_courses(num_courses, courses): Determines if it is possible to finish all courses given the prerequisites. Parameters: num_courses (int): Total number of courses labeled from 0 to num_courses-1. courses (List[List[int]]): List where each entry is [a, b] indicating b is a prerequisite for a. Returns: bool: True if all courses can be finished, otherwise False. # Create an adjacency list for the graph representation graph = defaultdict(list) # Array to keep track of in-degrees of nodes in_degree = [0] * num_courses # Build the graph for course, prereq in courses: graph[prereq].append(course) in_degree[course] += 1 # Queue for holding courses with no prerequisites queue = deque([i for i in range(num_courses) if in_degree[i] == 0]) visited_courses = 0 while queue: current = queue.popleft() visited_courses += 1 for neighbor in graph[current]: in_degree[neighbor] -= 1 if in_degree[neighbor] == 0: queue.append(neighbor) # If we\'ve visited all courses, then it means we can finish all courses return visited_courses == num_courses"},{"question":"Given a string `s` that consists of only digits, return the number of unique ways to decode it. In decoding, `1` maps to `\'A\'`, `2` maps to `\'B\'`, ..., `26` maps to `\'Z\'`. A character can only be decoded if it forms a valid single digit or two-digit number within this range. For example, given the string `\\"12\\"`, it can be decoded as `\\"AB\\"` (i.e., `1 2`) or `\\"L\\"` (i.e., `12`). Return the total number of ways to decode the string. (Note: Leading zeros are not allowed in the encoding, so for example, `06` cannot be mapped and should return 0 for such cases.)","solution":"def num_decodings(s): if not s: return 0 n = len(s) dp = [0] * (n + 1) dp[0] = 1 dp[1] = 1 if s[0] != \'0\' else 0 for i in range(2, n + 1): one_digit = int(s[i - 1:i]) two_digits = int(s[i - 2:i]) if 1 <= one_digit <= 9: dp[i] += dp[i - 1] if 10 <= two_digits <= 26: dp[i] += dp[i - 2] return dp[n]"},{"question":"You are given an integer array `nums` and an integer `k`. Your task is to find the maximum possible sum of exactly `k` elements from the array. If there are less than `k` elements in the array, return `-1`. The array may contain both positive and negative integers. Return the sum as an integer.","solution":"def max_sum_of_k_elements(nums, k): Finds the maximum possible sum of exactly k elements from the array nums. If there are less than k elements in the array, return -1. Parameters: nums (list of int): The input array of integers. k (int): The number of elements to sum. Returns: int: The maximum sum of exactly k elements or -1 if not possible. if len(nums) < k: return -1 nums.sort(reverse=True) return sum(nums[:k])"},{"question":"You are given a list of non-negative integers representing the amount of money of each house in a street. Adjacent houses in the list cannot be robbed on the same night due to security alarms connecting directly between each pair of neighboring houses. Calculate the maximum amount of money you can rob tonight without alerting the security system. Given a list of integers `houses` where each element represents the amount of money at each house, return the maximum amount of money you can rob without robbing two adjacent houses. **Example**: ``` Input: houses = [2, 7, 9, 3, 1] Output: 12 Explanation: Rob house 1 (money = 2), rob house 3 (money = 9), and rob house 5 (money = 1). Total amount you can rob = 2 + 9 + 1 = 12. ``` Create an efficient algorithm to solve this problem.","solution":"def rob(houses): Calculate the maximum amount of money you can rob without robbing two adjacent houses. Parameters: houses (list): A list of non-negative integers representing the amount of money at each house. Returns: int: The maximum amount of money you can rob. n = len(houses) if n == 0: return 0 if n == 1: return houses[0] if n == 2: return max(houses) # Use dynamic programming to track the maximum money we can rob up to each house dp = [0] * n dp[0] = houses[0] dp[1] = max(houses[0], houses[1]) for i in range(2, n): dp[i] = max(dp[i-1], dp[i-2] + houses[i]) return dp[-1]"},{"question":"You are given a **binary tree** in the form of an integer array `nodes`, where each element represents a node in the tree in level order traversal. The value `-1` represents a `null` node (i.e., no child). You are also given two node values `node1` and `node2` that are guaranteed to be present in the tree. Return _the lowest common ancestor (LCA) of the given nodes_. The LCA is defined as the deepest node that has both `node1` and `node2` as its descendants (where we allow a node to be a descendant of itself).","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def build_tree(nodes): if not nodes: return None root = TreeNode(nodes[0]) queue = [root] idx = 1 while queue and idx < len(nodes): node = queue.pop(0) if nodes[idx] != -1: node.left = TreeNode(nodes[idx]) queue.append(node.left) idx += 1 if idx < len(nodes) and nodes[idx] != -1: node.right = TreeNode(nodes[idx]) queue.append(node.right) idx += 1 return root def find_lca(root, node1, node2): if not root: return None if root.val == node1 or root.val == node2: return root left = find_lca(root.left, node1, node2) right = find_lca(root.right, node1, node2) if left and right: return root return left if left else right def lowest_common_ancestor(nodes, node1, node2): root = build_tree(nodes) lca_node = find_lca(root, node1, node2) return lca_node.val"},{"question":"You are given two **non-negative** integers `num1` and `num2`. Write a function to return `true` if `num1` can be converted to `num2` by flipping exactly one bit, and `false` otherwise. **Flipping a bit** means changing a `0` to a `1` or a `1` to a `0`. For example, the binary representation of `n1 = 14` is `1110`, and flipping the last bit gives `1111`, which is the binary representation of `n2 = 15`. Return the result as a boolean value.","solution":"def one_bit_flip(num1, num2): Returns true if num1 can be converted to num2 by flipping exactly one bit, false otherwise. Arguments: num1: int -- the first input non-negative integer num2: int -- the second input non-negative integer Returns: bool # XOR the numbers to find the differing bits xor_result = num1 ^ num2 # Return True if the xor result is a power of 2 (only one bit is different) return xor_result != 0 and (xor_result & (xor_result - 1)) == 0"},{"question":"Given a string `s` consisting of lowercase English letters and parentheses, remove the minimum number of parentheses (either \'(\' or \')\', in any positions) so that the resulting parentheses string is valid and return any valid string. A string is considered valid if it is empty or if every open parenthesis \'(\' has a corresponding close parenthesis \')\'.","solution":"def min_remove_to_make_valid(s): Removes the minimum number of parentheses to make the string valid. A string is considered valid if every open parenthesis \'(\' has a corresponding close parenthesis \')\'. stack = [] to_remove = set() for i, char in enumerate(s): if char == \'(\': stack.append(i) elif char == \')\': if not stack: to_remove.add(i) else: stack.pop() to_remove.update(stack) result = [] for i, char in enumerate(s): if i not in to_remove: result.append(char) return \'\'.join(result)"},{"question":"You are given a binary tree in which each node contains an integer value. Design an algorithm to perform a **vertical order traversal** of the binary tree. The vertical order traversal proceeds column-by-column, from left to right, and within each column, from top to bottom. If two nodes are in the same row and column, they should be listed in the order they appear in the level-order traversal of the tree. Return _a list of lists_, where each list contains the values of the nodes in that column.","solution":"from collections import defaultdict, deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def verticalOrderTraversal(root): if not root: return [] column_table = defaultdict(list) min_column = max_column = 0 queue = deque([(root, 0, 0)]) while queue: node, row, column = queue.popleft() if node is not None: column_table[column].append((row, node.val)) min_column = min(min_column, column) max_column = max(max_column, column) queue.append((node.left, row + 1, column - 1)) queue.append((node.right, row + 1, column + 1)) result = [] for column in range(min_column, max_column + 1): result.append([val for row, val in sorted(column_table[column])]) return result"},{"question":"Given two strings `word1` and `word2`, return the minimum number of operations required to convert `word1` to `word2`. You have the following three operations permitted on a word: * Insert a character * Delete a character * Replace a character Implement the function `minDistance` such that: ```python def minDistance(word1: str, word2: str) -> int: # your code here ```","solution":"def minDistance(word1: str, word2: str) -> int: Returns the minimum number of operations required to convert word1 to word2. Allowed operations: - Insert a character - Delete a character - Replace a character m, n = len(word1), len(word2) dp = [[0] * (n + 1) for _ in range(m + 1)] for i in range(m + 1): for j in range(n + 1): if i == 0: dp[i][j] = j elif j == 0: dp[i][j] = i elif word1[i - 1] == word2[j - 1]: dp[i][j] = dp[i - 1][j - 1] else: dp[i][j] = 1 + min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) return dp[m][n]"},{"question":"You are given an array of integers `arr` and an integer `k`. Your task is to divide the array into contiguous subarrays such that each subarray has exactly `k` distinct elements. Return the maximum number of subarrays that can be formed. If it is not possible to divide the array in such a way, return `0`.","solution":"from collections import defaultdict def max_subarrays_with_k_distinct(arr, k): Return the maximum number of subarrays with exactly k distinct elements. If it\'s not possible, return 0. if not arr or k <= 0: return 0 n = len(arr) left = 0 right = 0 distinct_count = 0 freq_map = defaultdict(int) subarrays_count = 0 for right in range(n): if freq_map[arr[right]] == 0: distinct_count += 1 freq_map[arr[right]] += 1 while distinct_count > k: freq_map[arr[left]] -= 1 if freq_map[arr[left]] == 0: distinct_count -= 1 left += 1 if distinct_count == k: temp_right = right + 1 while temp_right < n and arr[temp_right] in freq_map and freq_map[arr[temp_right]] > 0: temp_right += 1 subarrays_count += temp_right - right return subarrays_count"},{"question":"You are given a 2D grid `obstacleGrid` of size `m x n` representing an obstacle course where `0` represents an empty space and `1` represents an obstacle. Find the number of unique paths from the top-left corner to the bottom-right corner which only allow moving right or down while avoiding obstacles. _If there is no path possible, return `0`_.","solution":"def uniquePathsWithObstacles(obstacleGrid): Finds the number of unique paths from the top-left corner to the bottom-right corner in a 2D grid with obstacles. :param obstacleGrid: 2D list of integers where 0 represents an empty space and 1 represents an obstacle. :return: The number of unique paths from the top-left to the bottom-right corner. if not obstacleGrid or obstacleGrid[0][0] == 1: return 0 m, n = len(obstacleGrid), len(obstacleGrid[0]) dp = [[0] * n for _ in range(m)] dp[0][0] = 1 for i in range(m): for j in range(n): if obstacleGrid[i][j] == 1: dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[m-1][n-1]"},{"question":"Given a string `str`, return the length of the longest substring without repeating characters. The substring must be contiguous and consist of distinct characters.","solution":"def length_of_longest_substring(s: str) -> int: Returns the length of the longest substring without repeating characters. n = len(s) seen = {} max_len = 0 start = 0 for end in range(n): if s[end] in seen: start = max(start, seen[s[end]] + 1) seen[s[end]] = end max_len = max(max_len, end - start + 1) return max_len"},{"question":"Given an unsorted array of integers, find the **longest consecutive elements sequence**. You need to implement the `LongestConsecutiveSequence` class that supports: * `LongestConsecutiveSequence(int[] nums)` Constructs an instance of the class with the given array of integers `nums`. * `int findLongestConsecutive()` Returns the length of the longest consecutive elements sequence. The sequence does not necessarily need to be in the same order as they appear in the array, but the elements must follow each other consecutively without any gaps.","solution":"class LongestConsecutiveSequence: def __init__(self, nums): self.nums = nums def findLongestConsecutive(self): if not self.nums: return 0 num_set = set(self.nums) longest_streak = 0 for num in self.nums: if num - 1 not in num_set: # indicates it\'s the start of a sequence current_num = num current_streak = 1 while current_num + 1 in num_set: current_num += 1 current_streak += 1 longest_streak = max(longest_streak, current_streak) return longest_streak"},{"question":"You are given a **0-indexed** integer array `nums` consisting of `n` elements, and an integer `k`. Your task is to maximize the sum of the minimum values among all subarrays of length `k`. More formally, find all possible subarrays of length `k` from the array `nums` and calculate the minimum value of each subarray. Then return the sum of all those minimum values. Note that a subarray is a contiguous part of the array.","solution":"def max_sum_of_mins(nums, k): Returns the sum of the minimum values among all subarrays of length k. n = len(nums) if k > n: return 0 min_sum = 0 for i in range(n - k + 1): min_sum += min(nums[i:i + k]) return min_sum"},{"question":"You are given a **0-indexed** integer array `numbers` containing `n` unique integers, and an integer `target`. You need to find a pair of indices `(i, j)` such that `numbers[i] + numbers[j]` is equal to `target`. Return the indices of this pair as a tuple `(i, j)`, where `i < j`. If there are multiple solutions, return any of them. If no such pair exists, return `(-1, -1)`. The solution should have a time complexity better than O(n^2).","solution":"def two_sum(numbers, target): Returns a tuple of two indices (i, j) such that numbers[i] + numbers[j] == target. If no such pair exists, return (-1, -1). number_to_index = {} for i, number in enumerate(numbers): complement = target - number if complement in number_to_index: return (number_to_index[complement], i) number_to_index[number] = i return (-1, -1)"},{"question":"Given a positive integer `n`, generate and return an array of the first `n` rows of Pascal\'s Triangle. In Pascal\'s Triangle, each number is the sum of the two numbers directly above it.","solution":"def generate_pascals_triangle(n): Generates the first n rows of Pascal\'s Triangle. :param n: A positive integer representing the number of rows to generate :return: A list of lists representing the first n rows of Pascal\'s Triangle if n <= 0: return [] triangle = [[1]] for i in range(1, n): row = [1] for j in range(1, i): row.append(triangle[i-1][j-1] + triangle[i-1][j]) row.append(1) triangle.append(row) return triangle"},{"question":"You are given an array of integers `nums` and an integer `target`. You have to determine if there exist two distinct indices `i` and `j` in the array such that the absolute difference between `nums[i]` and `nums[j]` is at most `target` and the indices `i` and `j` themselves are separated by less than or equal to `k` positions. Write a function that returns a boolean value indicating whether such indices exist in the array.","solution":"def contains_close_numbers(nums, k, target): Returns True if there exist two distinct indices i and j in the array such that: 1. The absolute difference between nums[i] and nums[j] is at most \'target\'. 2. The indices i and j themselves are separated by less than or equal to \'k\' positions. :param nums: List of integers :param k: Integer, maximum allowed distance between indices i and j :param target: Integer, maximum allowed absolute difference between nums[i] and nums[j] :return: Boolean, True if such indices exist, else False if not nums: return False n = len(nums) for i in range(n): for j in range(i + 1, min(i + k + 1, n)): if abs(nums[i] - nums[j]) <= target: return True return False"},{"question":"Given a list of integers `heights` representing the heights of buildings along a street, return _the **largest rectangular area** that can be formed by any contiguous subarray of the buildings_. Each building\'s width is 1 unit. Example: - Input: heights = [2, 1, 5, 6, 2, 3] - Output: 10 # Explanation: The largest rectangle can be formed between the third and fourth buildings with heights 5 and 6, respectively. This gives an area of 5 * 2 = 10.","solution":"def largestRectangleArea(heights): Returns the largest rectangle area that can be formed by any contiguous subarray of the buildings. stack = [] max_area = 0 index = 0 while index < len(heights): if not stack or heights[stack[-1]] <= heights[index]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"You are given two strings `s` and `t` of the same length consisting of lowercase English letters. You are allowed to replace any character in `s` with another lowercase English letter at most once. Your task is to determine if it is possible to make `s` equal to `t` by performing the operation at most once. Return _a boolean value **true** if it is possible and **false** otherwise_.","solution":"def can_transform(s, t): Returns true if it\'s possible to make string s equal to string t by replacing at most one character in s with another lowercase English letter, otherwise false. :param s: str - the original string :param t: str - the target string :return: bool - whether it\'s possible to transform s into t with at most one replacement if len(s) != len(t): return False # Count the number of differences diff_count = 0 for sc, tc in zip(s, t): if sc != tc: diff_count += 1 if diff_count > 1: return False # If there is 0 or 1 difference, it\'s possible; otherwise, it\'s not return diff_count <= 1"},{"question":"You are given two strings `s` and `t`. You want to covert `s` into `t` by using the minimum number of operations. There are three types of operations allowed on `s`: 1. Insert a character 2. Delete a character 3. Replace a character Given `s` and `t`, return the minimum number of operations required to convert `s` to `t`.","solution":"def min_operations(s, t): Returns the minimum number of operations required to convert string s to string t. Args: s: Source string to be transformed. t: Target string after transformation. Returns: int: Minimum number of operations. m, n = len(s), len(t) # Create a DP table of size (m+1) x (n+1) dp = [[0] * (n + 1) for _ in range(m + 1)] # Initialize the DP table for i in range(m + 1): dp[i][0] = i # If t is empty, remove all characters of s for j in range(n + 1): dp[0][j] = j # If s is empty, insert all characters of t # Fill the DP table for i in range(1, m + 1): for j in range(1, n + 1): if s[i - 1] == t[j - 1]: dp[i][j] = dp[i - 1][j - 1] # Characters match, no operation needed else: dp[i][j] = 1 + min(dp[i - 1][j], # Delete dp[i][j - 1], # Insert dp[i - 1][j - 1]) # Replace return dp[m][n]"},{"question":"You are given a **0-indexed** integer array `weights` of length `n` where `weights[i]` represents the weight of the `i-th` item. You are also given an integer `maxCapacity` which represents the maximum capacity a bag can hold. You can pick any subset of items to put in the bag as long as their total weight does not exceed `maxCapacity`. Your goal is to maximize the total weight of the items in the bag without exceeding the `maxCapacity`. Return _the **maximum** total weight that can be achieved with the given constraints._","solution":"def knapsack(weights, maxCapacity): n = len(weights) # DP array to store the maximum weight that can be achieved without exceeding the capacity i dp = [0] * (maxCapacity + 1) # Iterate through each weight for weight in weights: # Update the dp array from back to front to avoid overwriting for capacity in range(maxCapacity, weight - 1, -1): dp[capacity] = max(dp[capacity], dp[capacity - weight] + weight) return dp[maxCapacity]"},{"question":"Given a list of `n` pairs of integers where each pair represents the start and end time of a meeting, determine the minimum number of conference rooms required to accommodate all meetings. Each pair `[start, end]` is such that `start < end`. Return the minimum number of conference rooms required. You may assume no two meetings will start at the same time.","solution":"import heapq def min_meeting_rooms(intervals): Given a list of intervals where each interval is a pair of start and end time of a meeting, determines the minimum number of conference rooms required. if not intervals: return 0 # Sort the intervals by the start time intervals.sort(key=lambda x: x[0]) # Use a min heap to track the end time of meetings heap = [] # Add the end time of the first meeting heapq.heappush(heap, intervals[0][1]) for i in range(1, len(intervals)): # If the current meeting starts after the earliest ending meeting ends if intervals[i][0] >= heap[0]: # Reuse the room, remove the earliest ending meeting heapq.heappop(heap) # Allocate a new room (push the current meeting\'s end time) heapq.heappush(heap, intervals[i][1]) # The size of the heap is the number of rooms required return len(heap)"},{"question":"You are given an integer array `arr` of length `n` containing only `0`s and `1`s. An operation involves picking any element at index `i` and flipping its value (i.e., turning a `0` to `1` or a `1` to `0`). You need to perform a series of operations so that no two adjacent elements in the array are the same. Return the **minimum number** of operations required to achieve this arrangement.","solution":"def min_operations_to_alternate(arr): Returns the minimum number of operations required to make the array alternate. Parameters: arr (list): A list of integers containing only 0s and 1s. Returns: int: The minimum number of operations required. n = len(arr) # Pattern 1: starting with 0 -> [0, 1, 0, 1, ...] pattern1_count = 0 for i in range(n): if arr[i] != i % 2: pattern1_count += 1 # Pattern 2: starting with 1 -> [1, 0, 1, 0, ...] pattern2_count = 0 for i in range(n): if arr[i] != (i + 1) % 2: pattern2_count += 1 return min(pattern1_count, pattern2_count)"},{"question":"Given two strings `s1` and `s2`, return the length of the longest subsequence that is repeated between them. A subsequence of a string is a new string generated from the original string with some characters(can be none) deleted without changing the relative order of the remaining characters. Note that a repeated subsequence has to be repeated at least twice in the original string. For example, the longest repeated subsequence of `\\"aabb\\"` is `\\"ab\\"`. If there\'s no such subsequence, return 0.","solution":"def longest_repeated_subsequence_length(s1, s2): Find the length of the longest repeated subsequence between two strings. Parameters: s1 (str): The first string. s2 (str): The second string. Returns: int: The length of the longest repeated subsequence. n, m = len(s1), len(s2) # Create and initialize the DP array dp = [[0] * (m + 1) for _ in range(n + 1)] # Fill dp array for i in range(1, n + 1): for j in range(1, m + 1): if s1[i - 1] == s2[j - 1] and i != j: dp[i][j] = 1 + dp[i - 1][j - 1] else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) return dp[n][m]"},{"question":"Given a list of `meetingTimeRanges` represented by intervals where `meetingTimeRanges[i] = [start_i, end_i]`, return the minimum number of meeting rooms required to accommodate all the meetings. Each interval `[start_i, end_i]` includes `start_i` but excludes `end_i`. Note: You may assume that the list of intervals is not empty.","solution":"def minMeetingRooms(meetingTimeRanges): Returns the minimum number of meeting rooms required to accommodate all the meetings. if not meetingTimeRanges: return 0 starts = sorted([i[0] for i in meetingTimeRanges]) ends = sorted([i[1] for i in meetingTimeRanges]) start_pointer, end_pointer = 0, 0 used_rooms = 0 max_rooms = 0 while start_pointer < len(meetingTimeRanges): if starts[start_pointer] < ends[end_pointer]: used_rooms += 1 start_pointer += 1 else: used_rooms -= 1 end_pointer += 1 max_rooms = max(max_rooms, used_rooms) return max_rooms"},{"question":"You are given an `n x n` grid representing a field of flowers and weeds, where `field[i][j] == 1` represents a flower and `field[i][j] == 0` represents a weed. A flower has a tendency to grow and spread, and each flower cell can grow to a neighboring **4-directionally** adjacent weed cell. You are tasked to place barriers to prevent flowers from growing indefinitely. Every day, you can place barriers around one flower cell to completely stop its growth, while other flowers continue to grow. Return _the number of days required to completely stop the growth of all flowers_ by placing barriers around them.","solution":"from collections import deque def days_to_stop_growth(field): n = len(field) visited = [[False] * n for _ in range(n)] directions = [(0,1), (1,0), (0,-1), (-1,0)] def bfs(i, j): queue = deque([(i, j)]) visited[i][j] = True region = [] while queue: x, y = queue.popleft() region.append((x, y)) for dx, dy in directions: nx, ny = x+dx, y+dy if 0 <= nx < n and 0 <= ny < n and not visited[nx][ny]: if field[nx][ny] == 1: visited[nx][ny] = True queue.append((nx, ny)) return region flowers = [] for i in range(n): for j in range(n): if field[i][j] == 1 and not visited[i][j]: flowers.append(bfs(i, j)) return len(flowers)"},{"question":"Given an integer array `nums`, rotate the array to the right by `k` steps, where `k` is non-negative. Implement a function that achieves the rotation with minimal space usage.","solution":"def rotate(nums, k): Rotates the array `nums` to the right by `k` steps. n = len(nums) k = k % n # in case k is larger than n # Helper function to reverse elements in the array from start to end def reverse(start, end): while start < end: nums[start], nums[end] = nums[end], nums[start] start, end = start + 1, end - 1 # Reverse the entire array reverse(0, n - 1) # Reverse the first k elements reverse(0, k - 1) # Reverse the remaining elements reverse(k, n - 1)"},{"question":"You are given a list of strings `wordDict` and a string `sentence`. You need to partition `sentence` into individual words using the strings from `wordDict` such that all the words in the sentence are present in `wordDict`. Return `true` if the entire sentence can be segmented into valid words, otherwise return `false`. Each word in the dictionary can be used multiple times in the segmentation. Keep in mind that the input sentence does not contain any punctuation and is a single lower-case word (no spaces).","solution":"def word_break(wordDict, sentence): Determine if the entire sentence can be segmented into valid words. Parameters: wordDict (list): List of valid words. sentence (str): The sentence to be segmented. Returns: bool: True if the sentence can be segmented, False otherwise. word_set = set(wordDict) n = len(sentence) dp = [False] * (n + 1) dp[0] = True for i in range(1, n + 1): for j in range(i): if dp[j] and sentence[j:i] in word_set: dp[i] = True break return dp[n]"},{"question":"You are given a **0-indexed** array `heights` representing the heights of buildings along a street. Two workers are trying to repair the building facades following specific rules. Both workers start at the beginning of the street (index `0`) and need to reach the end (index `n-1`), but worker 1 can only move to the next building (i.e., from index `i` to index `i+1`), whereas worker 2 can jump to any farther building as long as the height difference between the buildings is less than or equal to a given threshold `k`. Worker 1 collects points equal to the height of the building they just moved to, and these points are then reset to `0` (i.e., that section of the facade is repaired). After worker 1 completes their route, worker 2 tries to maximize their points by jumping from building to building according to the rules. Assume both workers play optimally: worker 1 aims to minimize worker 2\'s potential points, and worker 2 aims to maximize the points collected. Return _the maximum points that can be collected by worker 2_.","solution":"def maximize_worker2_points(heights, k): Returns the maximum points that worker 2 can collect. :param heights: List[int]: List of building heights. :param k: int: Maximum height difference worker 2 can jump. :return: int: Maximum points worker 2 can collect. if not heights: return 0 n = len(heights) # Worker 1 will move from start to end, modifying heights array for i in range(n): heights[i] = 0 # Worker 2 will try to maximize points starting from each building def worker2_collects_points(start_idx): max_points = 0 points = 0 for i in range(start_idx, n): points += heights[i] max_points = max(max_points, points) for j in range(i + 1, n): if abs(heights[i] - heights[j]) <= k: max_points = max(max_points, points + worker2_collects_points(j)) return max_points return worker2_collects_points(0)"},{"question":"Given a list of integers `arr` that forms a singly linked list where each element points to the next element in the list (the last element points to `null`), and an integer `k`, reverse the linked list in groups of `k` and return the modified list. If there are fewer than `k` elements remaining in the group, leave them as they are. For example, given `arr = [1, 2, 3, 4, 5]` and `k = 2`, the modified list should be `[2, 1, 4, 3, 5]`. And for `arr = [1, 2, 3, 4, 5, 6, 7]` with `k = 3`, the modified list should be `[3, 2, 1, 6, 5, 4, 7]`. Implement a function `reverseKGroup(arr: List[int], k: int) -> List[int]` which takes the list and the integer as input and returns the modified list.","solution":"def reverseKGroup(arr, k): Reverses the given list in groups of k elements. If there are fewer than k elements remaining, they are left as they are. if k <= 1 or not arr: return arr result = [] length = len(arr) for i in range(0, length, k): if i + k <= length: result.extend(arr[i:i+k][::-1]) else: result.extend(arr[i:]) return result"},{"question":"You are given a **0-indexed** array `temps` representing the daily temperatures recorded over a month. A **heatwave** is defined as a period of at least three consecutive days where the temperature on each day is higher than the previous day. Your task is to identify the length of the longest heatwave. If no heatwave is present, return `0`. Return _the **maximum** length of any heatwave in the array_.","solution":"def longest_heatwave(temps): Finds the length of the longest heatwave in the given list of temperatures. A heatwave is a period of at least three consecutive days where the temperature on each day is higher than the previous day. Parameters: temps (list of int): List of daily temperatures. Returns: int: Length of the longest heatwave. Returns 0 if no heatwave is present. n = len(temps) if n < 3: return 0 max_length = 0 current_length = 1 for i in range(1, n): if temps[i] > temps[i - 1]: current_length += 1 if current_length >= 3: max_length = max(max_length, current_length) else: current_length = 1 return max_length"},{"question":"You are given an array of integers `arr` and an integer `x`. Rearrange the elements of `arr` such that all elements less than `x` come before elements greater than or equal to `x`. The relative order of the elements in each partition should be preserved. Return the rearranged array.","solution":"def rearrange_array(arr, x): Rearranges the elements of arr such that all elements less than x come before elements greater than or equal to x, while preserving the relative order of the elements in each partition. less_than_x = [el for el in arr if el < x] greater_or_equal_x = [el for el in arr if el >= x] return less_than_x + greater_or_equal_x"},{"question":"You are given a list of non-negative integers `nums` which represents the maximum subarray sum for any subarray that starts at index 0 and ends at index `i`. Your task is to reconstruct the original array `arr` such that `arr` starts from index 0. Return `arr`. Guarantee: At least one solution exists. **Example**: If `nums = [2, 5, 6, 10]`, the possible original `arr` can be `[2, 3, 1, 4]`, because: - The subarray sum for the subarray starting at index 0 and ending at index 0 is `2`. - The subarray sum for the subarray starting at index 0 and ending at index 1 is `2 + 3 = 5`. - The subarray sum for the subarray starting at index 0 and ending at index 2 is `2 + 3 + 1 = 6`. - The subarray sum for the subarray starting at index 0 and ending at index 3 is `2 + 3 + 1 + 4 = 10`.","solution":"def reconstruct_array(nums): Reconstruct the original array based on the given subarray sums. Args: nums (List[int]): A list representing the maximum subarray sum for any subarray that starts at index 0 and ends at each index `i`. Returns: List[int]: The reconstructed original array. arr = [nums[0]] for i in range(1, len(nums)): arr.append(nums[i] - nums[i - 1]) return arr"},{"question":"Create a function that takes a list of `n` integers representing daily stock prices and returns the maximum profit that can be achieved by buying and selling the stock at most twice. You need to buy before you can sell, and you cannot engage in multiple transactions simultaneously (i.e., you must sell the stock before buying again). The function should return an integer representing the maximum profit.","solution":"def maxProfit(prices): if not prices: return 0 n = len(prices) # Initialize the buy1, sell1, buy2, sell2 variables buy1 = buy2 = float(\'-inf\') sell1 = sell2 = 0 for price in prices: # The maximum profit if only one transaction is allowed buy1 = max(buy1, -price) sell1 = max(sell1, buy1 + price) # The maximum profit if two transactions are allowed buy2 = max(buy2, sell1 - price) sell2 = max(sell2, buy2 + price) return sell2"},{"question":"Given a collection of `logs`, each log contains three fields: `serverId`, `timestamp`, and `action`. The `action` field can be either \\"start\\" or \\"end\\". Each server can start and end multiple tasks, identified by the `timestamp`. Write a function that determines the total active time for each server. The active time for a server is defined as the sum of all time periods during which the server is processing tasks, which is the difference between corresponding \\"end\\" and \\"start\\" timestamps. Return a list of tuples `(serverId, totalActiveTime)` sorted by `serverId` in ascending order.","solution":"from collections import defaultdict def server_active_time(logs): Calculate the total active time for each server from the logs. Args: logs (list of tuples): A list of logs where each log is a tuple (serverId, timestamp, action). Returns: list of tuples: A list of tuples where each tuple contains (serverId, totalActiveTime) sorted by serverId. active_times = defaultdict(int) # Dictionary to hold total active time for each server start_times = {} # Dictionary to hold the most recent start time for each server for serverId, timestamp, action in logs: if action == \'start\': start_times[serverId] = timestamp elif action == \'end\' and serverId in start_times: active_times[serverId] += (timestamp - start_times[serverId]) del start_times[serverId] result = sorted(active_times.items()) return result"},{"question":"You are given a list of `logs` where each log is represented as a tuple `(timestamp, id)` indicating an event that occurred at a specific timestamp for a particular id. The `id` represents different entities and timestamps are ordered in non-decreasing order. An event interval is defined as the time between the first and last occurrences of an event for a particular `id`. Return a dictionary where the key is the `id` and the value is the event interval for that `id`. If an `id` appears only once, the event interval should be 0.","solution":"def compute_event_intervals(logs): Returns a dictionary where the key is the id and the value is the event interval for that id. intervals = {} for timestamp, id_ in logs: if id_ in intervals: intervals[id_][\'end\'] = timestamp else: intervals[id_] = {\'start\': timestamp, \'end\': timestamp} result = {id_: v[\'end\'] - v[\'start\'] for id_, v in intervals.items()} return result"},{"question":"You are given a string `s` consisting of lowercase English letters, and you need to perform operations to determine the number of **distinct** characters present in the string after each operation. You have two types of operations: 1. **Insert**: Insert a character `c` at a particular position `i` in the string. Both the character and position will be provided. 2. **Delete**: Delete the character at a particular position `i` in the string. Implement the `StringModifier` class: * `StringModifier(string s)` Initializes a `StringModifier` object with the string `s`. * `void insert(int i, char c)` Inserts the character `c` at the position `i` in the string. * `void delete(int i)` Deletes the character at the position `i` in the string. * `int distinct_count()` Returns the number of distinct characters currently present in the string. For the operations, assume valid input where `i` is always within the bounds of the current string length for both insert and delete operations.","solution":"class StringModifier: def __init__(self, s: str): self.string = list(s) self.char_set = set(s) def insert(self, i: int, c: str): self.string.insert(i, c) self.char_set = set(self.string) def delete(self, i: int): del self.string[i] self.char_set = set(self.string) def distinct_count(self) -> int: return len(self.char_set)"},{"question":"Given a string `s` consisting of lowercase English letters and an integer `k`, determine whether you can remove exactly `k` indices from `s` so that the remaining string is a palindrome. A palindrome is a string that reads the same forwards and backwards. Return `true` if it is possible to remove exactly `k` indices to make the string a palindrome; otherwise, return `false`.","solution":"def can_form_palindrome(s, k): Determine whether you can remove exactly k indices from s to make the remaining string a palindrome. def is_palindrome(string): return string == string[::-1] def can_remove_to_form_palindrome(s, k): if is_palindrome(s): return k % 2 == 0 if k == 0: return is_palindrome(s) for i in range(len(s)): if can_remove_to_form_palindrome(s[:i] + s[i+1:], k-1): return True return False return can_remove_to_form_palindrome(s, k)"},{"question":"You are given a list of integers `height` representing the heights of stones in a row. In one operation, you can pick any stone and increase or decrease its height by 1. However, you can only perform this operation a maximum of `m` times across the entire list. The goal is to make all the stones have the same height. Return _the minimum number of operations required to make all the stones have the same height if it\'s possible within `m` operations. If it\'s not possible, return_ `-1`.","solution":"def min_operations_to_equalize_height(heights, m): Returns the minimum number of operations required to make all stones have the same height, or -1 if it\'s not possible within m operations. max_height = max(heights) min_height = min(heights) while min_height <= max_height: mid_height = (min_height + max_height) // 2 operations_required = sum(abs(height - mid_height) for height in heights) if operations_required <= m: return operations_required elif operations_required < m: min_height = mid_height + 1 else: max_height = mid_height - 1 return -1"},{"question":"Given a sorted array `arr` of `n` integers and a target integer `x`, write a function that finds the number of occurrences of `x` in the array. If `x` is not present in the array, return `0`. Make sure that your solution runs in O(log n) time.","solution":"from bisect import bisect_left, bisect_right def count_occurrences(arr, x): Returns the number of occurrences of x in the sorted array arr. If x is not present in the array, returns 0. The solution runs in O(log n) time. left_index = bisect_left(arr, x) right_index = bisect_right(arr, x) return right_index - left_index"},{"question":"Given a binary tree, each node has a value representing the cost associated with that node. Starting from the root, you need to reach a leaf node (a node with no children). You can only move from a node to one of its children in each step. The **path cost** from the root to a leaf is defined as the sum of the costs of the nodes along that path. Return _the minimum path cost of all possible paths from the root to any leaf_.","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def min_path_cost(root): Calculate the minimum path cost from root to leaf in a binary tree. if not root: return float(\'inf\') # If tree is empty, return infinity (no path exists) if not root.left and not root.right: return root.value # If it\'s a leaf node, return its value # Recursively find the minimum cost path for the left and right subtree left_cost = min_path_cost(root.left) right_cost = min_path_cost(root.right) # Return the current node value plus the minimum cost of both subtrees return root.value + min(left_cost, right_cost)"},{"question":"Given an integer array `arr` and a positive integer `d`, you can jump from index `i` to index `j` (where `i < j`) if the following conditions are met: - `j - i <= d`, and - `arr[i] > arr[j]` You can also jump backwards from index `i` to index `j` (where `i > j`) if both of these conditions hold: - `i - j <= d`, and - `arr[i] > arr[j]` Return _the maximum number of indices you can visit starting from any index._","solution":"def max_jumps(arr, d): def dfs(i): if dp[i] != -1: return dp[i] res = 1 for j in range(i+1, min(i+d+1, n)): if arr[i] > arr[j]: res = max(res, 1 + dfs(j)) else: break for j in range(i-1, max(i-d-1, -1), -1): if arr[i] > arr[j]: res = max(res, 1 + dfs(j)) else: break dp[i] = res return res n = len(arr) dp = [-1] * n max_visits = 1 for i in range(n): max_visits = max(max_visits, dfs(i)) return max_visits"},{"question":"You are given a string `s` and you need to reorganize the string such that no two adjacent characters are the same. If it is possible to reorganize the string in this way, return the reorganized string. Otherwise, return an empty string. For example, given `s = \\"aab\\"`, one possible reorganization is `\\"aba\\"`. If it is not possible to reorganize the string so that no two adjacent characters are the same, the function should return an empty string.","solution":"import heapq from collections import Counter def reorganize_string(s): Reorganize a string so that no two adjacent characters are the same. If it is not possible to reorganize, return an empty string. counter = Counter(s) max_heap = [(-count, char) for char, count in counter.items()] heapq.heapify(max_heap) prev_count, prev_char = 0, \'\' result = [] while max_heap: count, char = heapq.heappop(max_heap) result.append(char) if prev_count < 0: heapq.heappush(max_heap, (prev_count, prev_char)) prev_count, prev_char = count + 1, char reorganized_string = \'\'.join(result) if len(reorganized_string) != len(s): return \\"\\" return reorganized_string"},{"question":"A **palindromic** string is a string that reads the same backward as forward. Given a string `s` consisting of lowercase English letters and an integer `k`, return `true` if it is possible to rearrange the characters in `s` such that the length of the longest palindromic subsequence is at least `k`. Otherwise, return `false`. Note that the subsequence does not need to be contiguous.","solution":"from collections import Counter def can_form_palindrome_with_k_length(s, k): Determines if the characters of string s can be rearranged to form a palindromic subsequence of length at least k. Parameters: s (str): The input string consisting of lowercase English letters. k (int): The required length of the longest palindromic subsequence. Returns: bool: True if it is possible to rearrange to form such a subsequence, False otherwise. char_count = Counter(s) odd_count = sum(count % 2 for count in char_count.values()) # Length of the longest palindromic subsequence is the total length minus the number of odd occurrences + 1 if any odd exists max_palindrome_length = len(s) - odd_count + (1 if odd_count > 0 else 0) return max_palindrome_length >= k"},{"question":"Given an integer array `arr` of size `n`, you need to find all the **unique** triplets `(arr[i], arr[j], arr[k])` such that `i != j != k` and `i < j < k`, and the sum of the three integers is zero. Return an array of all the unique triplets. The solution set must not contain duplicate triplets. Make sure the triplets are sorted in ascending order.","solution":"def three_sum(arr): Returns a list of all unique triplets in the array that sum up to zero. Each triplet must be sorted in ascending order, and the list should not contain duplicate triplets. arr.sort() n = len(arr) triplets = [] for i in range(n-2): if i > 0 and arr[i] == arr[i-1]: continue left, right = i + 1, n - 1 while left < right: total = arr[i] + arr[left] + arr[right] if total == 0: triplet = [arr[i], arr[left], arr[right]] triplets.append(triplet) while left < right and arr[left] == triplet[1]: left += 1 while left < right and arr[right] == triplet[2]: right -= 1 elif total < 0: left += 1 else: right -= 1 return triplets"},{"question":"You are given an integer array `arr` and an integer `sum`. Find all unique combinations in the array where the sum of the numbers equals `sum`. Each number in `arr` can only be used once in the combination. Return _all possible unique combinations in any order_. Note: The solution set must not contain duplicate combinations.","solution":"def find_combinations(arr, target_sum): Finds all unique combinations in arr where the sum of the numbers equals target_sum. Each number in arr can only be used once in the combination. :param arr: List of integers :param target_sum: Target sum for the combinations :return: List of unique combinations where the sum equals target_sum arr.sort() results = [] def backtrack(start, path, remaining_sum): if remaining_sum == 0: results.append(path[:]) return for i in range(start, len(arr)): if i > start and arr[i] == arr[i - 1]: continue # skip duplicates if arr[i] > remaining_sum: break # no need to continue if the number is greater than the remaining sum path.append(arr[i]) backtrack(i + 1, path, remaining_sum - arr[i]) path.pop() backtrack(0, [], target_sum) return results"},{"question":"Given two sorted arrays `arr1` and `arr2` of size `m` and `n` respectively, return a new sorted array that is the result of merging `arr1` and `arr2`. You should not use any built-in sorting functions but instead merge them manually to maintain the sorted order.","solution":"def merge_sorted_arrays(arr1, arr2): Merges two sorted arrays into a single sorted array. Args: arr1 (list of int): The first sorted array. arr2 (list of int): The second sorted array. Returns: list of int: A new sorted array that is the result of merging arr1 and arr2. merged_array = [] i, j = 0, 0 # Use two-pointers to merge the arrays while i < len(arr1) and j < len(arr2): if arr1[i] < arr2[j]: merged_array.append(arr1[i]) i += 1 else: merged_array.append(arr2[j]) j += 1 # If there are remaining elements in arr1 or arr2, add them to merged array while i < len(arr1): merged_array.append(arr1[i]) i += 1 while j < len(arr2): merged_array.append(arr2[j]) j += 1 return merged_array"},{"question":"Implement a data structure that supports the following operations: `insert`, `delete`, and `get_random_element`. The `insert` operation inserts a value into the data structure, the `delete` operation removes a value, and the `get_random_element` operation returns a random element from the current set of elements (each element should have an equal probability of being returned). You should optimize for the average time complexity of these operations. - `void insert(int val)` Inserts an integer value into the data structure. - `bool delete(int val)` Removes an integer value from the data structure, returns `true` if the value was present and removed, otherwise returns `false`. - `int get_random_element()` Returns a random element from the data structure.","solution":"import random class RandomizedSet: def __init__(self): Initialize your data structure here. self.data_map = {} self.data_list = [] def insert(self, val: int) -> None: Inserts a value into the data structure. if val not in self.data_map: self.data_map[val] = len(self.data_list) self.data_list.append(val) def delete(self, val: int) -> bool: Removes a value from the data structure, returns true if the value was present and removed, otherwise returns false. if val in self.data_map: last_element = self.data_list[-1] idx_to_delete = self.data_map[val] # Move the last element to the place of the element to delete self.data_list[idx_to_delete] = last_element self.data_map[last_element] = idx_to_delete # Remove the last element self.data_list.pop() del self.data_map[val] return True return False def get_random_element(self) -> int: Returns a random element from the data structure. return random.choice(self.data_list)"},{"question":"You are given a list of non-negative integers `candies` where each integer represents the number of candies in a pile. In one move, you can choose any pile and remove one candy from it. After making the move, if the pile becomes empty, you must remove the pile from the list. You want to divide the candies into two groups such that the difference in total number of candies between the two groups is minimized. Return the minimum possible difference between the sums of the two groups after dividing the candies.","solution":"def min_difference_candies(candies): Returns the minimum possible difference between the sums of two groups after dividing the candies. total_candies = sum(candies) target = total_candies // 2 dp = [0] * (target + 1) for candy in candies: for j in range(target, candy - 1, -1): dp[j] = max(dp[j], dp[j - candy] + candy) group1 = dp[target] group2 = total_candies - group1 return abs(group1 - group2)"},{"question":"Given an integer array `heights` representing the height of each person in a queue, return the minimum number of groups needed so that each group is sorted in non-decreasing order and no person is taller than anyone in front of them in their group. A group can have any number of people, and you must use all the people in the given order.","solution":"def min_number_of_groups(heights): Returns the minimum number of groups needed so that each group is sorted in non-decreasing order and no person is taller than anyone in front of them in their group. Parameters: heights (list): A list of integers representing the heights of people in the queue. Returns: int: The minimum number of groups needed. if not heights: # If the list is empty, no groups are needed. return 0 # The first group will start with the first person in line. groups = [[heights[0]]] for height in heights[1:]: placed = False for group in groups: # Place the person in the first group they can join. if height >= group[-1]: group.append(height) placed = True break if not placed: # If they can\'t fit in any existing group, start a new group. groups.append([height]) return len(groups)"},{"question":"Given an integer `n`, return _the number of **prime numbers** that are **strictly less than**_ `n`_. For this problem, a prime number is defined as a number greater than 1 that has no positive divisors other than 1 and itself. Write a function that computes this efficiently._","solution":"def count_primes(n): Returns the number of prime numbers strictly less than n. if n <= 2: return 0 # Initialize a list to keep track of prime numbers is_prime = [True] * n is_prime[0] = is_prime[1] = False # 0 and 1 are not prime numbers # Implement the Sieve of Eratosthenes for i in range(2, int(n**0.5) + 1): if is_prime[i]: for j in range(i * i, n, i): is_prime[j] = False # Count the number of primes return sum(is_prime)"},{"question":"Given a binary tree, write a function to perform a level-order traversal. Each level of the tree should be printed in a new line. For example, given the binary tree [3, 9, 20, null, null, 15, 7], the output should be: ``` 3 9 20 15 7 ``` Note that nodes with `null` values should not be included in the output.","solution":"from collections import deque class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def levelOrder(root): if not root: return \\"\\" queue = deque([root]) result = [] while queue: level_size = len(queue) current_level = [] for _ in range(level_size): node = queue.popleft() if node: current_level.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) if current_level: result.append(\\" \\".join(map(str, current_level))) return \\"n\\".join(result)"},{"question":"You are given an integer array `nums` of length `n` which contains elements in the range `[1, n]`. Each integer appears exactly once except for two elements which appear twice, making two other integers missing from the array. Find the two numbers that are missing from the array and the two numbers that appear twice. Return a list of four integers `[dup1, dup2, missing1, missing2]`, where `dup1` and `dup2` are the duplicate numbers and `missing1` and `missing2` are the missing numbers. Ensure that `dup1` and `dup2` appear in the order they are found in the array, and `missing1` and `missing2` can be in any order.","solution":"def find_duplicates_and_missing(nums): Finds the two numbers that are missing and the two numbers that appear twice in the given array nums which has elements in the range [1, n] and length n. Args: nums: List[int] - an array of integers with two duplicates and two missing numbers Returns: List[int] - a list of four integers [dup1, dup2, missing1, missing2] n = len(nums) num_count = [0] * (n + 1) for num in nums: num_count[num] += 1 duplicates = [] missing = [] for i in range(1, n + 1): if num_count[i] == 0: missing.append(i) elif num_count[i] == 2: duplicates.append(i) return duplicates + missing"},{"question":"Given an array of integers `arr`, a **partition** is a way to split the array into two non-empty subsets (subarrays). The difference between the two subsets is defined as the absolute difference of their sums. Write a function that returns the minimum possible difference between the sums of the two subsets after partitioning the array. You are required to return the integer value representing this minimal possible difference.","solution":"def min_subset_difference(arr): Returns the minimal possible difference between the sums of the two subsets after partitioning the array. total_sum = sum(arr) n = len(arr) dp = [[False] * (total_sum + 1) for _ in range(n + 1)] for i in range(n + 1): dp[i][0] = True for i in range(1, n + 1): for j in range(1, total_sum + 1): if arr[i - 1] <= j: dp[i][j] = dp[i - 1][j] or dp[i - 1][j - arr[i - 1]] else: dp[i][j] = dp[i - 1][j] diff = float(\'inf\') for j in range(total_sum // 2, -1, -1): if dp[n][j]: diff = total_sum - (2 * j) break return diff"},{"question":"You are given an integer array `arr` of size `n`. Your task is to find the number of triplets `(i, j, k)` such that `0 <= i < j < k < n` and `arr[i] + arr[j] + arr[k]` is divisible by a given integer `d`. Return the count of such triplets. As the number of triplets can be large, the answer should be computed **modulo** `109 + 7`.","solution":"def count_divisible_triplets(arr, n, d): MOD = 10**9 + 7 count = 0 for i in range(n-2): for j in range(i+1, n-1): for k in range(j+1, n): if (arr[i] + arr[j] + arr[k]) % d == 0: count = (count + 1) % MOD return count"},{"question":"You are given a list of non-negative integers representing the amount of rainwater trapped between buildings of different heights. Each integer represents the height of a building at that position in a 2D elevation map. Write an algorithm to calculate how much rainwater can be trapped after it rains. For instance, given the list `[4, 2, 0, 3, 2, 5]`, the amount of trapped rainwater would be `9`. Implement the function `int trapRainWater(List<Integer> height)` that returns the total amount of rainwater trapped.","solution":"def trapRainWater(height): Calculate the total amount of rainwater trapped between buildings of different heights. Args: height (List[int]): a list of non-negative integers representing the height of buildings. Returns: int: total amount of trapped rainwater. if not height: return 0 n = len(height) left_max = [0] * n # Array to store the maximum height to the left of the current position right_max = [0] * n # Array to store the maximum height to the right of the current position # Fill the left_max array left_max[0] = height[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], height[i]) # Fill the right_max array right_max[n - 1] = height[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], height[i]) # Calculate the total trapped rainwater total_water = 0 for i in range(n): total_water += min(left_max[i], right_max[i]) - height[i] return total_water"},{"question":"You are given an array of integers `arr` consisting of `n` elements. Your task is to modify the array such that no two adjacent elements have the same value. If the original array already meets this criterion, return the array itself. If it is not possible to achieve this, return an empty array. Otherwise, return any one of the modified arrays that meet the condition. Modify the function `modifyArrayNoAdjacentSame(arr)` to accomplish this task.","solution":"def modifyArrayNoAdjacentSame(arr): Modify the array such that no two adjacent elements have the same value. :param arr: List[int] - The input array :return: List[int] - Modified array or empty array if not possible from collections import Counter import heapq if not arr: return [] count = Counter(arr) max_count = max(count.values()) half = (len(arr) + 1) // 2 if max_count > half: return [] max_heap = [(-value, key) for key, value in count.items()] heapq.heapify(max_heap) prev_value, prev_key = 0, \'\' result = [] while max_heap: value, key = heapq.heappop(max_heap) result.append(key) if prev_value < 0: heapq.heappush(max_heap, (prev_value, prev_key)) prev_value = value + 1 prev_key = key return result"},{"question":"You are given a matrix represented as a 2D list `grid` of dimensions `m x n`. You need to find the number of distinct islands in the grid. An island is defined as a group of `1`s (land) connected `4-directionally` (horizontal or vertical). You may assume that all four edges of the grid are surrounded by water (0s). Two islands are considered distinct if and only if one island is not equal to another when translated (i.e., the shape itself must be different). Implement the `NumberOfIslands` class: * `NumberOfIslands(int[][] grid)` Initializes the object with the given `grid`. * `int countDistinctIslands()` Returns the number of distinct islands in the grid.","solution":"class NumberOfIslands: def __init__(self, grid): self.grid = grid self.rows = len(grid) self.cols = len(grid[0]) if self.rows > 0 else 0 self.visited = set() def countDistinctIslands(self): distinct_islands = set() for r in range(self.rows): for c in range(self.cols): if self.grid[r][c] == 1 and (r, c) not in self.visited: island_shape = [] self.dfs(r, c, r, c, island_shape) island_shape = tuple(island_shape) distinct_islands.add(island_shape) return len(distinct_islands) def dfs(self, r, c, orig_r, orig_c, island_shape): self.visited.add((r, c)) island_shape.append((r - orig_r, c - orig_c)) for dr, dc in [(0, 1), (1, 0), (0, -1), (-1, 0)]: nr, nc = r + dr, c + dc if 0 <= nr < self.rows and 0 <= nc < self.cols and self.grid[nr][nc] == 1 and (nr, nc) not in self.visited: self.dfs(nr, nc, orig_r, orig_c, island_shape)"},{"question":"You are given an undirected graph with `n` nodes labeled from `0` to `n-1` and an integer `k`. The graph is represented by a list of `edges` where `edges[i] = [u, v]` indicates there is an edge between nodes `u` and `v`. Your task is to determine if there exist two distinct nodes in the graph such that the shortest path between them is exactly `k` edges. Return _true_ if such a pair of nodes exists and _false_ otherwise.","solution":"from collections import deque def shortest_path_length(n, edges, k): # Create adjacency list graph = {i: [] for i in range(n)} for u, v in edges: graph[u].append(v) graph[v].append(u) # BFS helper function to find shortest path lengths from a starting node def bfs(start): distances = [-1] * n distances[start] = 0 queue = deque([start]) while queue: node = queue.popleft() distance = distances[node] for neighbor in graph[node]: if distances[neighbor] == -1: # not visited distances[neighbor] = distance + 1 queue.append(neighbor) return distances # Check all pairs of nodes for i in range(n): distances = bfs(i) if k in distances: return True return False"},{"question":"You are given a 2D grid representing a binary matrix where `0` represents water and `1` represents land. An island is a group of connected `1`s (horizontal or vertical) surrounded by water. The grid is completely surrounded by water, and there is exactly one island in the grid, which means there is exactly one group of `1`s. You must cover the entire island with water by flipping all \'1\'s to \'0\'s. Write a function to find a list of coordinates (row, col) of all the `1`s in the island before it is flipped. You can return the coordinates in any order.","solution":"def get_island_coordinates(grid): Returns the list of coordinates of all \'1\'s in the island. def dfs(r, c): if r < 0 or r >= len(grid) or c < 0 or c >= len(grid[0]) or grid[r][c] == 0: return grid[r][c] = 0 # Mark as visited coordinates.append((r, c)) dfs(r + 1, c) dfs(r - 1, c) dfs(r, c + 1) dfs(r, c - 1) coordinates = [] found_island = False for i in range(len(grid)): if found_island: break for j in range(len(grid[0])): if grid[i][j] == 1: dfs(i, j) found_island = True break return coordinates"},{"question":"You are given a **0-indexed** integer array `arr` containing `n` distinct integers. For each integer `x` in the array, find the greatest element that is smaller than `x` and the smallest element that is greater than `x`. If no such element exists for either condition, specify it as `null`. Return an array of tuples where each tuple contains the integer from the original array, followed by the greatest smaller element and the least greater element, respectively.","solution":"def find_adjacent_elements(arr): Finds the greatest smaller and least greater elements for each element in the array. Args: arr (list): A list of distinct integers. Returns: list: A list of tuples where each tuple contains (element, greatest_smaller, least_greater). sorted_arr = sorted(arr) result = [] n = len(arr) for x in arr: idx = sorted_arr.index(x) # Greatest element smaller than x if idx > 0: greatest_smaller = sorted_arr[idx - 1] else: greatest_smaller = None # Least element greater than x if idx < n - 1: least_greater = sorted_arr[idx + 1] else: least_greater = None result.append((x, greatest_smaller, least_greater)) return result"},{"question":"You are given an array of integers `arr` representing the size of each file in a system. A file system can only hold a certain number of files (`maxFiles`) or accommodate files until a maximum capacity (`maxSize`) is reached, whichever comes first. Your task is to calculate how many files can be fully loaded into the system without exceeding either the file count or the maximum size capacity. Return the maximum number of files that can be loaded into the system.","solution":"def max_files_loaded(arr, maxFiles, maxSize): Returns the maximum number of files that can be loaded into the system without exceeding the maximum file count or the maximum size capacity. :param arr: List of integers representing the sizes of each file. :param maxFiles: Integer representing the maximum number of files that can be loaded. :param maxSize: Integer representing the maximum size capacity of the system. :return: Integer representing the maximum number of files that can be loaded. arr.sort() file_count = 0 current_size = 0 for size in arr: if file_count < maxFiles and current_size + size <= maxSize: file_count += 1 current_size += size else: break return file_count"},{"question":"Given a linked list, reverse the nodes of the list `k` at a time, where `k` is a positive integer and `k` is less than or equal to the length of the list. The function should return the modified list after reversing every `k` nodes. If the number of nodes is not a multiple of `k`, then the remaining nodes at the end should remain as is. Note that you may **not** alter the values in the nodes, only the nodes themselves may be changed.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverseKGroup(head, k): def reverseLinkedList(head, k): prev, curr = None, head while k: next_node, curr.next = curr.next, prev prev, curr = curr, next_node k -= 1 return prev count, node = 0, head while node and count < k: node = node.next count += 1 if count == k: reversed_head = reverseLinkedList(head, k) head.next = reverseKGroup(node, k) return reversed_head return head"},{"question":"You are given a string `document` and an array of integers `to_delete` such that `to_delete[i]` denotes the position (0-indexed) of the character in `document` to be removed. The positions in `to_delete` are given in non-decreasing order. What is the resulting string after all specified deletions have been applied? Return the resulting string.","solution":"def delete_chars(document, to_delete): Returns a string after removing characters at the specified positions in `to_delete`. Parameters: document (str): The original string from which characters are to be removed. to_delete (list of int): The indices of characters in `document` that need to be removed. Returns: str: The resulting string after deletion. # Convert document to a list because string is immutable document_list = list(document) # Iterate over the indices in reverse order to keep indices consistent for index in reversed(to_delete): if 0 <= index < len(document_list): del document_list[index] # Join the list back into a string return \'\'.join(document_list)"},{"question":"You are given a **0-indexed** integer array `questions` where `questions[i]` represents the time required to solve the `ith` question in a coding competition. You are also given an integer array `bonuses` of the same length, where `bonuses[i]` represents the bonus points awarded for solving the `ith` question. You have a total time `totalTime` to spend solving questions. Your goal is to maximize your score within the given `totalTime`. Return _the **maximum** score you can achieve within the allotted_ `totalTime_`.","solution":"def maximize_score(questions, bonuses, totalTime): Returns the maximum score that can be achieved within the given totalTime. Each question[i] takes a certain amount of time, and each gives a certain bonus[i]. :param questions: List[int] - Time to solve each question. :param bonuses: List[int] - Bonus points from solving each question. :param totalTime: int - Total time available to solve questions. :return: int - Maximum score achievable. n = len(questions) dp = [[0] * (totalTime + 1) for _ in range(n + 1)] for i in range(1, n + 1): time = questions[i-1] bonus = bonuses[i-1] for t in range(totalTime + 1): if t >= time: dp[i][t] = max(dp[i - 1][t], dp[i - 1][t - time] + bonus) else: dp[i][t] = dp[i - 1][t] return dp[n][totalTime]"},{"question":"You are given a list of integers `arr` and a positive integer `target`. Your task is to find the **minimum** number of elements you need to create a sum that is greater than or equal to `target`. If it is not possible to meet the target sum with any subset of the given list, return -1.","solution":"def min_elements_to_target(arr, target): Find the minimum number of elements in the list `arr` required to create a sum greater than or equal to `target`. If it is not possible, return -1. arr.sort(reverse=True) sum_so_far = 0 count = 0 for num in arr: sum_so_far += num count += 1 if sum_so_far >= target: return count return -1"},{"question":"You are given a list of `n` integers representing the heights of columns in a histogram where the width of each column is 1. Write a function to find the area of the largest rectangle that can be formed within the histogram. The rectangle must be made up of contiguous bars. The function should return this maximum area. Write the function `largestRectangleArea(heights: List[int]) -> int` that takes the list of heights and returns the maximum rectangle area.","solution":"def largestRectangleArea(heights): Returns the area of the largest rectangle that can be formed within the histogram. stack = [] max_area = 0 index = 0 while index < len(heights): if not stack or heights[stack[-1]] <= heights[index]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"You are given an array of integers `heights` where `heights[i]` is the height of the `i-th` building standing in a line. The rainwater that can be trapped between the buildings depends on the height of the buildings and the gaps between them. Compute and return the total amount of rainwater that can be trapped after raining. Note: You are not allowed to use additional space larger than a fixed number of variables (i.e., constant space complexity is required). For example, given the array `heights = [0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]`, the amount of trapped water is `6`.","solution":"def trap_rain_water(heights): Computes the total amount of rainwater that can be trapped given the heights of the buildings. :param heights: List[int] - An array where each element represents the height of a building. :return: int - The total amount of trapped rainwater. if not heights: return 0 left = 0 right = len(heights) - 1 left_max = heights[left] right_max = heights[right] trapped_water = 0 while left < right: if left_max < right_max: left += 1 left_max = max(left_max, heights[left]) trapped_water += left_max - heights[left] else: right -= 1 right_max = max(right_max, heights[right]) trapped_water += right_max - heights[right] return trapped_water"},{"question":"You are given a list of integers `arr` representing the heights of skyscrapers in a city. A building can receive sunlight if there are no taller buildings to its left. Return a list of integers where each element represents the height of the first building (from the left) that blocks the sunlight for the corresponding skyscraper. If a skyscraper receives sunlight, its corresponding value should be `-1`. For each skyscraper, consider only the heights of the buildings to its left.","solution":"def first_blocker(arr): Return a list where each element represents the height of the first building from the left that blocks the sunlight for the corresponding skyscraper in the list. If a skyscraper receives sunlight, its corresponding value should be -1. result = [] for i in range(len(arr)): blocker = -1 for j in range(i-1, -1, -1): if arr[j] > arr[i]: blocker = arr[j] break result.append(blocker) return result"},{"question":"You are given two strings `s` and `t` consisting of lowercase English letters. You can perform the following operation on `s` any number of times: choose valid indices `i` and `j` (1 <= i <= j <= len(s)) and reverse the substring `s[i...j]`. Determine if it is possible to transform `s` into `t` using this operation. Return `true` if you can transform `s` into `t` and `false` otherwise.","solution":"def can_transform(s, t): Determines if string s can be transformed into string t by reversing substrings. return sorted(s) == sorted(t)"},{"question":"You are given a list of `n` tasks, where each task is represented by a pair `[start, end]` denoting the start and end times of the task. The goal is to find the maximum number of non-overlapping tasks that can be completed. Two tasks are considered non-overlapping if the end time of one task is less than or equal to the start time of the next task. Implement the `TaskScheduler` class: * `TaskScheduler(int[][] tasks)` Initializes the object with the `tasks` array. * `int maxNonOverlappingTasks()` Returns the maximum number of non-overlapping tasks that can be completed.","solution":"class TaskScheduler: def __init__(self, tasks): Initializes the object with the list of tasks. Each task is a list [start, end]. self.tasks = tasks def maxNonOverlappingTasks(self): Returns the maximum number of non-overlapping tasks that can be completed. # Sort tasks by their end time sorted_tasks = sorted(self.tasks, key=lambda x: x[1]) count = 0 last_end_time = float(\'-inf\') for task in sorted_tasks: if task[0] >= last_end_time: count += 1 last_end_time = task[1] return count"},{"question":"Given two integers `n` and `k`, where `n` represents the total number of digits in a password and `k` represents the number of distinct digits that can be used to create the password, return the total number of distinct passwords of length `n` that can be formed under the condition that no two adjacent digits in the password are the same.","solution":"def count_passwords(n, k): Returns the total number of distinct passwords of length `n` that can be formed using `k` distinct digits with no two adjacent digits being the same. if n == 1: return k dp = [0] * n dp[0] = k dp[1] = k * (k - 1) for i in range(2, n): dp[i] = (k - 1) * dp[i - 1] return dp[-1]"},{"question":"You are given a list of non-negative integers representing the amount of rainwater trapped above each bar in a histogram where the width of each bar is 1. The height of each bar is given by the integers in the list. Write a function to determine the amount of water that can be trapped after raining. Return the total units of trapped rainwater.","solution":"def trap_rainwater(height): Calculate the total amount of rainwater trapped. if not height: return 0 n = len(height) left_max = [0] * n right_max = [0] * n water_trapped = 0 # Fill left_max array left_max[0] = height[0] for i in range(1, n): left_max[i] = max(left_max[i-1], height[i]) # Fill right_max array right_max[n-1] = height[n-1] for i in range(n-2, -1, -1): right_max[i] = max(right_max[i+1], height[i]) # Calculate the accumulated water for i in range(n): water_trapped += min(left_max[i], right_max[i]) - height[i] return water_trapped"},{"question":"Given a string `s` consisting of lowercase English letters, we want to partition this string into as many parts as possible so that each letter appears in at most one part. Return a list of integers representing the size of these parts. To achieve this, follow these steps: 1. Determine the last occurrence of each character in the string. 2. Traverse the string while keeping track of the end of the current partition. 3. If the current index matches the end of the current partition, update the partition end and start a new partition. For example, given the string `ababcbacadefegdehijhklij`, we can partition it into `ababcbaca`, `defegde`, `hijhklij`. The sizes of these parts are 9, 7, and 8, respectively, so the output would be `[9, 7, 8]`.","solution":"def partition_labels(s): Partitions the given string `s` into as many parts as possible so that each letter appears in at most one part. Returns a list of integers representing the size of these parts. # Step 1: Determine the last occurrence of each character in the string last_occurrence = {char: idx for idx, char in enumerate(s)} # Step 2 & 3: Traverse the string and partition it into the desired components partitions = [] current_partition_start = 0 current_partition_end = 0 for idx, char in enumerate(s): current_partition_end = max(current_partition_end, last_occurrence[char]) if idx == current_partition_end: partitions.append(current_partition_end - current_partition_start + 1) current_partition_start = idx + 1 return partitions"},{"question":"Given a **binary tree**, return the **maximum width** of the binary tree. The **maximum width** of a tree is the maximum width among all levels. The width of one level is defined as the length between the end-nodes (the leftmost and rightmost non-null nodes), where the `null` nodes between the end-nodes are also counted into the length calculation. A node is defined as: - class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right The tree is represented as a `TreeNode`. Return the maximum width of the binary tree.","solution":"from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def widthOfBinaryTree(root): if not root: return 0 maxWidth = 0 queue = deque([(root, 0)]) while queue: level_length = len(queue) _, first_index = queue[0] for i in range(level_length): node, index = queue.popleft() if node.left: queue.append((node.left, 2 * index)) if node.right: queue.append((node.right, 2 * index + 1)) _, last_index = queue[-1] if queue else (None, 0) maxWidth = max(maxWidth, last_index - first_index + 1) return maxWidth"},{"question":"Given a string `s` and an integer `k`, you need to rearrange the characters in the string such that the same characters are at least `k` distance apart. Return the rearranged string. If it is not possible to rearrange the string, return an empty string `\\"\\"`.","solution":"from collections import Counter from heapq import heappop, heappush def rearrange_string(s, k): Rearrange the characters in the string such that the same characters are at least k distance apart. If it is not possible to rearrange the string, return an empty string \\"\\". :param s: Input string :param k: Minimum distance between the same characters if k == 0: return s counter = Counter(s) max_heap = [] # Create a max heap based on character frequency for char, freq in counter.items(): heappush(max_heap, (-freq, char)) result = [] wait_queue = [] while max_heap or wait_queue: if wait_queue and wait_queue[0][1] == len(result): freq, _, char = wait_queue.pop(0) heappush(max_heap, (freq, char)) if not max_heap: return \\"\\" freq, char = heappop(max_heap) result.append(char) if -freq > 1: wait_queue.append((freq + 1, len(result) + k - 1, char)) return \\"\\".join(result)"},{"question":"You are given two strings `s` and `t`. You are allowed to perform any number of operations on `s` where in each operation you can swap any two characters within `s`. Return `true` if you can make `s` equal to `t` after performing the operations, and `false` otherwise.","solution":"def can_make_equal(s, t): Determines if string s can be made equal to string t by swapping any two characters within s. Parameters: s (str): The initial string. t (str): The target string. Returns: bool: True if s can be made equal to t, False otherwise. # If lengths are different, they can\'t be made equal by any number of swaps if len(s) != len(t): return False # If both strings have the same character counts, they can be made equal return sorted(s) == sorted(t)"},{"question":"You are given a string `s` and an integer `n`. Return the lexicographically smallest string that can be achieved by applying at most `n` swap operations on the characters of `s`. Each swap involves exchanging the characters of two different positions in the string.","solution":"from heapq import heappop, heappush def smallestStringWithSwaps(s, n): Return the lexicographically smallest string that can be achieved by applying at most n swap operations. :param s: Input string :param n: Maximum number of swap operations :return: Lexicographically smallest string possible with at most n swaps. if n == 0 or not s: return s # We use a min heap to get the smallest characters first min_heap = [] for char in s: heappush(min_heap, char) result = [] count = 0 for i in range(len(s)): smallest_char = heappop(min_heap) if s[i] != smallest_char and count < n: count += 1 result.append(smallest_char) return \'\'.join(result)"},{"question":"Given a binary tree where each node contains a value. You are also given a list of target sums. Your task is to determine for each target sum whether there is a path in the tree that starts at the root and ends at any leaf, such that the sum of the values along that path is equal to the target sum. A path does not need to include all nodes on a level, and there is no limit to the number of nodes in the path, as long as the nodes form a valid sequence from the root to a leaf. Return an array answers where answer[i] is true if the binary tree contains a path with the sum equal to the ith target sum, otherwise false.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def hasPathSum(root, targetSum): if not root: return False if not root.left and not root.right and root.val == targetSum: return True return hasPathSum(root.left, targetSum - root.val) or hasPathSum(root.right, targetSum - root.val) def checkTargetSums(root, targetSums): results = [] for target in targetSums: results.append(hasPathSum(root, target)) return results"},{"question":"You are given an integer array `nums` where each element is either a `1` (representing a person) or a `0` (representing an empty seat). A person is considered **lonely** if they are the only `1` in a contiguous segment of at most length `k`. Return _the total number of lonely people_ in the array `nums` for the given value of `k`.","solution":"def count_lonely_people(nums, k): Returns the total number of lonely people in the array nums for the given value of k. total_lonely_people = 0 n = len(nums) i = 0 while i < n: if nums[i] == 1: left_bound = max(0, i - k) right_bound = min(n - 1, i + k) if (left_bound == i or nums[left_bound:i].count(1) == 0) and (right_bound == i or nums[i+1:right_bound+1].count(1) == 0): total_lonely_people += 1 i = right_bound + 1 else: i += 1 return total_lonely_people"},{"question":"You are given a list of `n` strings `words` where each word consists of lowercase English letters and has the same length. You want to form a target string `target` from these words in the following way: You must select exactly one character from each word to form the target string such that the selected characters from each word are placed in the same position as they appear in the target string. Return _the number of distinct ways_ you can form the target string using the given words. Since the answer may be large, return it modulo `10^9 + 7`.","solution":"def num_ways_to_form_target(words, target): Returns the number of distinct ways to form the target string using the given words. Args: words (List[str]): The list of strings to use to form the target. target (str): The target string to form. Returns: int: The number of distinct ways to form the target string modulo 10^9 + 7. MOD = 10**9 + 7 m = len(words[0]) n = len(target) # Precompute the frequency of each character at each position freq = [[0] * 26 for _ in range(m)] for word in words: for i, char in enumerate(word): freq[i][ord(char) - ord(\'a\')] += 1 # Initialize dp array dp = [0] * (n + 1) dp[0] = 1 # Compute number of ways to form the target for j in range(1, m + 1): for i in range(n, 0, -1): if i <= j: dp[i] = (dp[i] + dp[i - 1] * freq[j - 1][ord(target[i - 1]) - ord(\'a\')]) % MOD return dp[n]"},{"question":"Write a function that, given two integers `numRows` and `numCols`, along with a list of integers `heights` representing the heights of skyscrapers in a city skyline from left to right, returns the maximum area of a rectangle formed by contiguous skyscrapers. The width of each skyscraper is 1. The area of a rectangle is calculated as the minimum height among the selected skyscrapers multiplied by the number of skyscrapers in that range.","solution":"def maximum_rectangle_area(heights): Given a list of integers heights representing the heights of skyscrapers in a city skyline, returns the maximum area of a rectangle formed by contiguous skyscrapers. stack = [] max_area = 0 index = 0 while index < len(heights): # Append the current building to the stack if it is taller than the last one in the stack if not stack or heights[stack[-1]] <= heights[index]: stack.append(index) index += 1 else: # Calculate the area with the height of the building at the top of the stack top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"Given a string `s` containing only digits, return _the number of ways to decode it into letters given the mapping: \'1\' -> \'A\', \'2\' -> \'B\', ..., \'26\' -> \'Z\'_. A valid decode means you can treat each `1` or `2` as a part of a two digit number if followed by a valid digit, or as a single digit. The function should return `0` if the string cannot be decoded in any way. Note that the digits `0` and any number greater than `26` are not valid encodings, unless part of a larger number in the context of the string as described.","solution":"def numDecodings(s): Returns the number of ways to decode a string s containing only digits. if not s or s[0] == \'0\': return 0 n = len(s) dp = [0] * (n + 1) dp[0], dp[1] = 1, 1 # Base cases for i in range(2, n + 1): single_digit = int(s[i - 1]) double_digit = int(s[i - 2:i]) if 1 <= single_digit <= 9: dp[i] += dp[i - 1] if 10 <= double_digit <= 26: dp[i] += dp[i - 2] return dp[n]"},{"question":"You are given a string `text` and an array of strings `words`. For each word in `words`, determine if it is a **subsequence** of `text`. Return an array of booleans, where the `i-th` boolean is `true` if `words[i]` is a subsequence of `text`, and `false` otherwise. A subsequence is a sequence that can be derived from another sequence by deleting some or no elements without changing the order of the remaining elements.","solution":"def is_subsequence(text, word): Helper function to check if a word is a subsequence of text. it = iter(text) return all(char in it for char in word) def subsequences_check(text, words): For each word in words, determine if it is a subsequence of text. Args: text (str): The main text string. words (list of str): List of words to check. Returns: list of bool: List of booleans where each boolean indicates if the corresponding word is a subsequence of text. return [is_subsequence(text, word) for word in words]"},{"question":"You are given an unsorted list of integers `nums` and an integer `k`. Return the smallest difference between the highest and lowest of the `k` consecutive integers that you can find in the list. For example, given the list `nums = [3, 11, 22, 1, 5, 7, 10]` and `k = 3`, the smallest difference between the highest and lowest of 3 consecutive integers in any part of the list is `4`, corresponding to the slice `[3, 5, 7]`. If it is not possible to find `k` consecutive integers in the list, return `-1`.","solution":"def smallest_difference_subarray(nums, k): Returns the smallest difference between the highest and lowest of the k consecutive integers that you can find in the list nums. If it is not possible to find k consecutive integers in the list, return -1. if len(nums) < k: return -1 nums_sorted = sorted(nums) min_diff = float(\'inf\') for i in range(len(nums_sorted) - k + 1): diff = nums_sorted[i + k - 1] - nums_sorted[i] if diff < min_diff: min_diff = diff return min_diff"},{"question":"You are given two integers `x` and `y` which represent the coordinates of a point on a 2D grid. Your task is to return the number of distinct paths from the point `(0, 0)` to the point `(x, y)` using only steps that move right or up. Note: You can use dynamic programming to compute the number of paths efficiently. For example, if `x = 2` and `y = 3`, the function would return `10` since there are 10 distinct paths to reach the point `(2, 3)` from `(0, 0)`.","solution":"def unique_paths(x, y): Returns the number of distinct paths from (0, 0) to (x, y) using only steps that move right or up. # Create a 2D table to store results of subproblems dp = [[0]*(y+1) for _ in range(x+1)] # There is only one way to reach any cell in the first row or first column for i in range(x+1): dp[i][0] = 1 for j in range(y+1): dp[0][j] = 1 # Fill the dp table for i in range(1, x+1): for j in range(1, y+1): dp[i][j] = dp[i-1][j] + dp[i][j-1] return dp[x][y]"},{"question":"Given an array `nums` of `n` integers, return an array of all the unique triplets `[nums[i], nums[j], nums[k]]` such that `i != j`, `i != k`, and `j != k`, and `nums[i] + nums[j] + nums[k] == 0`. The solution set must not contain duplicate triplets. For example, given array `nums = [-1, 0, 1, 2, -1, -4]`, the unique triplets are `[[-1, 0, 1], [-1, -1, 2]]`. Implement a function `List<List<Integer>> threeSum(int[] nums)` that returns the list of unique triplets.","solution":"def three_sum(nums): Given an array of n integers, return an array of all the unique triplets such that they sum to zero. Args: nums : List[int] List of integers Returns: List[List[int]] List of unique triplets Example: >>> three_sum([-1, 0, 1, 2, -1, -4]) [[-1, -1, 2], [-1, 0, 1]] nums.sort() # Sort the array to use two-pointer approach result = [] n = len(nums) for i in range(n): if i > 0 and nums[i] == nums[i - 1]: continue # Skip the duplicate values for the first number of the triplet left, right = i + 1, n - 1 while left < right: total = nums[i] + nums[left] + nums[right] if total == 0: result.append([nums[i], nums[left], nums[right]]) while left < right and nums[left] == nums[left + 1]: left += 1 # Skip duplicates for the second number of the triplet while left < right and nums[right] == nums[right - 1]: right -= 1 # Skip duplicates for the third number of the triplet left += 1 right -= 1 elif total < 0: left += 1 else: right -= 1 return result"},{"question":"Given a string `s` which represents the serialization of a binary tree, return the number of nodes in the tree that have exactly one child. The serialization format of the binary tree is level-order traversal where empty nodes are represented by the character `\'#\'`.","solution":"def count_nodes_with_one_child(s): Counts the number of nodes with exactly one child in a binary tree serialized as a level-order traversal string. nodes = s.split() if not nodes or nodes[0] == \'#\': return 0 queue = [] index = 0 count = 0 queue.append(nodes[index]) index += 1 while queue and index < len(nodes): current = queue.pop(0) left_child = nodes[index] if index < len(nodes) else \'#\' index += 1 right_child = nodes[index] if index < len(nodes) else \'#\' index += 1 # Check if the current node has exactly one child if (left_child == \'#\' and right_child != \'#\') or (left_child != \'#\' and right_child == \'#\'): count += 1 if left_child != \'#\': queue.append(left_child) if right_child != \'#\': queue.append(right_child) return count"},{"question":"You are given a 2D grid of size `m x n` where each cell is either a `0` representing an empty cell or a `1` representing an obstacle. You are also given an integer `k`, the maximum number of obstacles you can remove. You want to find the shortest path from the top-left corner (0,0) to the bottom-right corner (m-1,n-1) if you are allowed to remove at most `k` obstacles. The path can only be formed by moving up, down, left, or right. Return _the length of the shortest such path_. If there is no valid path, return `-1`.","solution":"from collections import deque def shortestPath(grid, k): Returns the length of the shortest path from (0, 0) to (m-1, n-1) allowing at most k obstacles to be removed. If no such path exists, return -1. m, n = len(grid), len(grid[0]) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] if m == 1 and n == 1: return 0 queue = deque([(0, 0, 0)]) # (x, y, obstacles_removed) visited = {(0, 0, 0)} steps = 0 while queue: steps += 1 for _ in range(len(queue)): x, y, removed = queue.popleft() for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n: new_removed = removed + grid[nx][ny] if new_removed <= k and (nx, ny, new_removed) not in visited: if nx == m - 1 and ny == n - 1: return steps queue.append((nx, ny, new_removed)) visited.add((nx, ny, new_removed)) return -1"},{"question":"You are given an integer array `heights` representing the heights of buildings, where the `i`-th building has a height `heights[i]`. The city skyline is defined as a list of critical points representing the key intersections of the skyline. A critical point is defined as one with a change in height, i.e., where the skyline silhouette changes up or down. Return the skyline as a list of critical points in the format `[[x1, y1], [x2, y2], ...]`, where `x` is the x-coordinate of the critical point and `y` is the height at that point. For the purpose of this problem: * The leftmost edge of the skyline starts at x = 0. * Assume that the heights array represents the left-to-right positions of the buildings. Note: The skyline should not include redundant critical points.","solution":"def get_skyline(heights): Returns the skyline as a list of critical points. if not heights: return [] skyline = [] prev_height = 0 for i, height in enumerate(heights): if height != prev_height: skyline.append([i, height]) prev_height = height skyline.append([len(heights), 0]) # End of the last building return skyline"},{"question":"You are given an unsorted array of integers `nums` and an integer `n`. Your task is to determine whether there exist two distinct indices `i` and `j` in the array such that the absolute difference between `nums[i]` and `nums[j]` is exactly `n` (i.e., `|nums[i] - nums[j]| = n`). Return `true` if such a pair exists, otherwise return `false`.","solution":"def has_pair_with_difference(nums, n): Determines if there exist two distinct indices i and j in the array such that the absolute difference between nums[i] and nums[j] is exactly n. :param nums: List of integers :param n: Integer :return: Boolean value indicating the existence of such a pair num_set = set(nums) for num in nums: if (num + n in num_set) or (num - n in num_set): return True return False"},{"question":"Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police. The constraint is that you cannot rob two adjacent houses. Implement the `HouseRobber` class: * `HouseRobber(int[] houses)` Initializes the object with an array `houses` representing the amount of money at each house. * `int rob()` Returns the maximum amount of money you can rob without robbing two adjacent houses.","solution":"class HouseRobber: def __init__(self, houses): self.houses = houses def rob(self): if not self.houses: return 0 n = len(self.houses) if n == 1: return self.houses[0] dp = [0] * n dp[0] = self.houses[0] if n > 1: dp[1] = max(self.houses[0], self.houses[1]) for i in range(2, n): dp[i] = max(dp[i-1], dp[i-2] + self.houses[i]) return dp[-1]"},{"question":"Given a string `s` containing a sequence of words separated by spaces, reverse the order of the words. A word is defined as a sequence of non-space characters. The reversed words should be joined by a single space. For example, if `s = \\"the sky is blue\\"`, return `\\"blue is sky the\\"`. Try to implement an in-place solution without using extra space if possible. If `s` contains leading or trailing spaces, they should be removed in the result.","solution":"def reverse_words(s): Reverses the order of words in a given string, removing leading and trailing spaces. # Strip leading and trailing spaces and split the words by spaces words = s.strip().split() # Reverse the list of words and join them with a single space return \' \'.join(reversed(words))"},{"question":"Given a linked list, return the node where the cycle begins. If there is no cycle, return `null`. To represent a cycle in the given linked list, we use an integer `pos` which represents the position (0-indexed) in the linked list where tail connects to. If `pos` is `-1`, then there is no cycle in the linked list. Note that `pos` is not passed as a parameter. Use the Floyd\'s Tortoise and Hare algorithm to solve this problem.","solution":"class ListNode: def __init__(self, x): self.val = x self.next = None def detectCycle(head: ListNode) -> ListNode: Detect the start node of the cycle in a linked list using Floyd\'s Tortoise and Hare algorithm. Args: head: ListNode - The head of the linked list. Returns: ListNode - The node where the cycle begins or `None` if there is no cycle. if not head or not head.next: return None slow, fast = head, head while fast and fast.next: slow = slow.next fast = fast.next.next # If there is a cycle if slow == fast: slow = head while slow != fast: slow = slow.next fast = fast.next return slow return None"},{"question":"Given a linked list, determine if it has a cycle in it. A cycle is defined as a situation where a node’s next pointer points back to a previous node, creating a loop. Return _a boolean indicating whether there is a cycle in the given linked list_.","solution":"class ListNode: def __init__(self, x): self.val = x self.next = None def has_cycle(head): Returns True if there is a cycle in the linked list, otherwise returns False. slow = head fast = head while fast is not None and fast.next is not None: slow = slow.next fast = fast.next.next if slow == fast: return True return False"},{"question":"You are given a list of integers `nums` representing the amount of money in each house along a street. An experienced thief is planning to rob the houses, but he knows that if two adjacent houses are robbed on the same night, the security system will alert the police. Calculate the maximum amount of money the thief can rob without triggering the alarm. You are to return this maximum amount.","solution":"def rob(nums): Calculate the maximum amount of money the thief can rob without triggering the alarm. :param nums: List[int] - A list of integers representing the amount of money in each house along a street. :return: int - The maximum amount of money that can be robbed. if not nums: return 0 if len(nums) == 1: return nums[0] prev1, prev2 = 0, 0 for num in nums: temp = prev1 prev1 = max(prev2 + num, prev1) prev2 = temp return prev1"},{"question":"You are given a **0-indexed** integer array `nums` of length `n`. A subarray is a contiguous non-empty sequence of elements within an array. Define the **width** of a subarray as the difference between the maximum and minimum element in that subarray. Return the **maximum width** of any subarray of `nums` that meets the following condition: the subarray\'s width **must not exceed** a given integer `limit`. Your solution should run in `O(n log n)` time.","solution":"from collections import deque def longest_subarray_with_limit(nums, limit): Finds the length of the longest subarray where the difference between the maximum and minimum elements is less than or equal to a given limit. min_deque = deque() max_deque = deque() left = 0 max_len = 0 for right in range(len(nums)): while min_deque and nums[right] < nums[min_deque[-1]]: min_deque.pop() while max_deque and nums[right] > nums[max_deque[-1]]: max_deque.pop() min_deque.append(right) max_deque.append(right) while nums[max_deque[0]] - nums[min_deque[0]] > limit: left += 1 if min_deque[0] < left: min_deque.popleft() if max_deque[0] < left: max_deque.popleft() max_len = max(max_len, right - left + 1) return max_len"},{"question":"You are given an array `houses` where `houses[i]` represents the position of the `i-th` house on a number line. You are also given an integer `k` representing the number of heaters. Place exactly `k` heaters on the number line such that the maximum distance any house has to a heater is minimized. Return _the minimized maximum distance_ from any house to a heater.","solution":"def min_max_distance_to_heater(houses, k): This function finds the minimized maximum distance that any house has to a heater. Parameters: - houses: List[int], an list of positions of the houses on a number line. - k: int, the number of heaters to be placed. Returns: - int: the minimized maximum distance from any house to a heater. houses.sort() def can_place_heaters(dist): heaters = 1 last_heater = houses[0] for i in range(1, len(houses)): if houses[i] - last_heater > dist * 2: heaters += 1 last_heater = houses[i] if heaters > k: return False return True left, right = 0, (houses[-1] - houses[0]) // 2 + 1 while left < right: mid = (left + right) // 2 if can_place_heaters(mid): right = mid else: left = mid + 1 return left"},{"question":"Given an array of strings `words`, return _an array of the same length where each element at index `i` is the length of the longest word in `words` that can be made by deleting some characters of the word at index `i`._ **Note**: you cannot reorder the characters in `words[i]`.","solution":"def longest_subword_length(words): Returns an array of the same length where each element at index `i` is the length of the longest word in `words` that can be made by deleting some characters of the word at index `i`. def is_subsequence(small, large): Check if `small` is a subsequence of `large`. it = iter(large) return all(c in it for c in small) result = [] for word in words: max_length = 0 for other_word in words: if is_subsequence(word, other_word): max_length = max(max_length, len(other_word)) result.append(max_length) return result"},{"question":"You are given a `string s` consisting of letters \'a\' and \'b\' only. A string with letters \'a\' and \'b\' is considered balanced if it contains an equal number of \'a\'s and \'b\'s. The task is to split the given string into the maximum number of balanced strings. Return the number of balanced strings you can obtain. For example, if the input is `s = \\"aabbab\\"`, the output should be `2`, since the string can be split into \\"aabb\\" and \\"ab\\", with each individual string containing an equal number of \'a\'s and \'b\'s.","solution":"def max_balanced_substrings(s): Returns the maximum number of balanced substrings that can be obtained from the input string. Parameters: s (str): The input string consisting of letters \'a\' and \'b\' only. Returns: int: The maximum number of balanced substrings. countA = 0 countB = 0 balanced_count = 0 for char in s: if char == \'a\': countA += 1 elif char == \'b\': countB += 1 if countA == countB: balanced_count += 1 countA = 0 countB = 0 return balanced_count"},{"question":"Given a list of integers, `nums`, determine if the list contains any duplicates. If any value appears at least twice in the list, return `true`. If every element is distinct, return `false`.","solution":"def contains_duplicates(nums): Returns True if any value appears at least twice in the list, otherwise False. return len(nums) != len(set(nums))"},{"question":"You are given an array `ratings` of `n` integers representing the ratings of `n` employees. All employees are standing in a line and can be rewarded with candies using the following rules: - Each employee must have at least one candy. - Employees with a higher rating get more candies than their neighbors. Your task is to determine the minimum number of candies needed to distribute according to these rules. Return the minimum number of candies required.","solution":"def min_candies(ratings): Returns the minimum number of candies required to distribute foreach employee such that the higher rated employee gets more candies than his immediate neighbors. :param ratings: List[int] :return: int n = len(ratings) # Initialize candies list candies = [1] * n # First pass, left to right for i in range(1, n): if ratings[i] > ratings[i - 1]: candies[i] = candies[i - 1] + 1 # Second pass, right to left for i in range(n - 2, -1, -1): if ratings[i] > ratings[i + 1]: candies[i] = max(candies[i], candies[i + 1] + 1) return sum(candies)"},{"question":"You are given an unsorted array of integers. Write a function that determines if there exists a pair of distinct indices `i` and `j` in the array such that the sum of the elements at these indices is equal to a given target number. Return true if such a pair exists, and false otherwise. Your function should have an average time complexity of O(n).","solution":"def has_pair_with_sum(arr, target): Determines if there exists a pair of distinct indices (i, j) in the array such that arr[i] + arr[j] == target. Args: arr (list of int): The input array of integers. target (int): The target sum. Returns: bool: True if such a pair exists, otherwise False. seen_numbers = set() for num in arr: if (target - num) in seen_numbers: return True seen_numbers.add(num) return False"},{"question":"You are given an integer array `heights` representing the heights of buildings in a row. Determine the maximum rectangular area that can be formed using contiguous buildings. The width of each building is 1 unit. Return the maximum rectangular area.","solution":"def maximum_area_histogram(heights): Returns the maximum rectangular area that can be formed using contiguous buildings. :param heights: List[int] :return: int stack = [] max_area = 0 index = 0 while index < len(heights): # If this building is higher than the one on the stack, push it to the stack if not stack or heights[index] >= heights[stack[-1]]: stack.append(index) index += 1 else: # Pop the top top_of_stack = stack.pop() # Calculate the area with heights[top_of_stack] as the smallest (or minimum height) bar \'h\' area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) # Update max_area, if needed max_area = max(max_area, area) # Now pop the remaining buildings from stack and calculate area with every popped stack while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"A fitness tracker records the number of steps taken each day in an array `steps`. The user wants to know the longest sequence of consecutive days where the number of steps taken increases each day. Given an array `steps` where each element represents the number of steps taken on a particular day, return _the length of the longest increasing sequence of consecutive days_. A sequence of consecutive days is defined as a subarray in which each subsequent day has a higher number of steps than the previous day.","solution":"def longest_increasing_sequence(steps): Returns the length of the longest increasing sequence of consecutive days. :param steps: List[int] - A list of integers representing steps taken each day. :return: int - The length of the longest increasing sequence of consecutive days. if not steps: return 0 max_length = 1 current_length = 1 for i in range(1, len(steps)): if steps[i] > steps[i - 1]: current_length += 1 max_length = max(max_length, current_length) else: current_length = 1 return max_length"},{"question":"In a certain language, we can encode characters using a special encoding scheme in which each character is represented by its order of appearance followed by shifting each character position by one. Given an original string \\"s\\" which contains only lowercase letters, write a function to return the encoded string. The encoded string for an original string \\"s\\" can be obtained by finding: 1. The position index of each character in the string. 2. Shifting each index obtained by one position to the right. For example, if the original string is \\"abc\\", it should be encoded as \\"123\\". If the string is \\"xyz\\", it should be encoded as \\"242526\\". Write a function `encode_string` which takes the original string `s` as an input and returns the encoded string.","solution":"def encode_string(s): Encodes the input string by replacing each character with its 1-based index in the alphabet. :param s: The original string with only lowercase letters. :return: The encoded string. encoded = [] for char in s: # Calculate the 1-based index of each character (a -> 1, b -> 2, ..., z -> 26) position = ord(char) - ord(\'a\') + 1 encoded.append(str(position)) return \'\'.join(encoded)"},{"question":"You are given two strings `s1` and `s2` of the same length consisting of lowercase English letters. You are allowed to swap any two characters in `s1` any number of times. Return _a boolean value_ indicating whether you can make `s1` equal to `s2` after any number of swaps.","solution":"def can_make_equal(s1, s2): Returns True if s1 can be made equal to s2 after any number of swaps, else False. return sorted(s1) == sorted(s2)"},{"question":"You are given a string containing only lowercase alphabetical characters. Your task is to find the number of distinct palindromic substrings in the given string. Two substrings are considered different if their start and end positions are different. A palindromic string reads the same backward as forward. Return the total number of distinct palindromic substrings. The input string will have a length of up to 1000 characters.","solution":"def count_distinct_palindromic_substrings(s): Returns the count of distinct palindromic substrings in the given string s. def is_palindrome(sub): return sub == sub[::-1] n = len(s) palindromic_substrings = set() for i in range(n): for j in range(i + 1, n + 1): substring = s[i:j] if is_palindrome(substring): palindromic_substrings.add(substring) return len(palindromic_substrings)"},{"question":"You are given a list of events in a calendar, where each event is represented by a tuple (start, end) signifying the start and end times of the event. You need to create a data structure, `MyCalendar`, that can store these events and check for conflicts. The `MyCalendar` class should have the following methods: * `MyCalendar()`: Initializes the calendar object. * `bool book(int start, int end)`: Attempts to book an event from `start` to `end` (exclusive). Returns `true` if the event can be added to the calendar without causing a double booking; otherwise, returns `false`. A double booking happens when two events have some non-empty intersection (i.e., there is some time that is common to both events, except if one event ends at the same time another event starts). Implement the `MyCalendar` class such that each function works in O(log n) time complexity where n is the number of events in the calendar.","solution":"class MyCalendar: def __init__(self): self.events = [] def book(self, start, end): for s, e in self.events: if start < e and end > s: # Check for overlapping events return False self.events.append((start, end)) return True"},{"question":"Given two strings `word1` and `word2`, return the minimum number of operations required to convert `word1` to `word2`. You have the following three operations permitted on a word: - Insert a character - Delete a character - Replace a character For example, given `word1 = \\"horse\\"` and `word2 = \\"ros\\"`, the algorithm should return `3` since the following operations are needed: 1. Replace `\'h\'` with `\'r\'` 2. Remove `\'o\'` 3. Remove `\'e\'` Implement a function `minDistance` that calculates and returns the minimum number of operations required.","solution":"def minDistance(word1, word2): Returns the minimum number of operations required to convert word1 to word2. m, n = len(word1), len(word2) # Initialize a (m+1) x (n+1) matrix dp where dp[i][j] represents the minimum distance dp = [[0] * (n+1) for _ in range(m+1)] # Fill the base cases for i in range(1, m+1): dp[i][0] = i for j in range(1, n+1): dp[0][j] = j # Fill the dp matrix for i in range(1, m+1): for j in range(1, n+1): if word1[i-1] == word2[j-1]: dp[i][j] = dp[i-1][j-1] else: dp[i][j] = 1 + min(dp[i-1][j], # Delete dp[i][j-1], # Insert dp[i-1][j-1]) # Replace return dp[m][n]"},{"question":"You are given an array of integers `heights` representing the heights of buildings in a row. You are also given an integer `k`, denoting the maximum number of steps you can jump from one building to another. Your task is to find out if it is possible to jump from the first building (at index `0`) to the last building (at index `n-1`), given that you can only jump to buildings that are equal to or shorter than the height of the current building and within the distance `k`. Return `true` if it is possible to reach the last building, otherwise, return `false`.","solution":"def can_reach_last_building(heights, k): Determine if it\'s possible to reach the last building from the first building. Parameters: heights (List[int]): List of integers representing the heights of buildings. k (int): Maximum number of steps you can jump. Returns: bool: True if it\'s possible to reach the last building, False otherwise. n = len(heights) if n == 1: return True reachable = [False] * n reachable[0] = True for i in range(n): if reachable[i]: for j in range(1, k+1): if i + j < n and heights[i + j] <= heights[i]: reachable[i + j] = True return reachable[-1]"},{"question":"You are given a binary tree root and an integer k. Return the sum of all nodes that are at distance k from the root. The distance between a node and the root is defined as the number of edges in the shortest path connecting them. If there are no nodes at distance k, return 0.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def sum_at_distance_k(root, k): Returns the sum of all nodes that are at distance k from the root. :param root: TreeNode - the root of the binary tree :param k: int - the distance from the root :return: int - the sum of all nodes at distance k if root is None: return 0 if k == 0: return root.val left_sum = sum_at_distance_k(root.left, k - 1) right_sum = sum_at_distance_k(root.right, k - 1) return left_sum + right_sum"},{"question":"You are given an integer array `nums` sorted in non-decreasing order. Determine if the array could become non-decreasing by modifying at most one element. Return `true` if it is possible, otherwise return `false`.","solution":"def checkPossibility(nums): Determine if the array could become non-decreasing by modifying at most one element. Parameters: nums (list of int): The input integer array in non-decreasing order. Returns: bool: True if it\'s possible to make the array non-decreasing by modifying at most one element, otherwise False. count_decrease = 0 for i in range(1, len(nums)): if nums[i] < nums[i - 1]: count_decrease += 1 if count_decrease > 1: return False if i == 1 or nums[i - 2] <= nums[i]: nums[i - 1] = nums[i] else: nums[i] = nums[i - 1] return True"},{"question":"You are given an array `heights` representing the heights of `n` buildings. Your task is to determine the amount of rainwater that can be trapped between the buildings after it rains. The array `heights` contains non-negative integers where each integer represents the height of a building at that position. Return the total amount of rainwater trapped. For example, given the array `heights = [0,1,0,2,1,0,1,3,2,1,2,1]`, the output should be `6`. Note: - `n` is a non-negative integer. - The height of buildings is also represented by non-negative integers.","solution":"def trap_rainwater(heights): if not heights: return 0 n = len(heights) left_max = [0] * n right_max = [0] * n left_max[0] = heights[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], heights[i]) right_max[n - 1] = heights[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], heights[i]) trapped_water = 0 for i in range(n): trapped_water += max(min(left_max[i], right_max[i]) - heights[i], 0) return trapped_water"},{"question":"Given a list of positive integers `distances`, each representing the distance of a checkpoint along a race track, you are tasked to partition these checkpoints into exactly two groups such that the absolute difference between the sum of distances in the two groups is minimized. Return _the minimum possible absolute difference_. Ensure that each checkpoint is assigned to exactly one group.","solution":"def minimize_difference(distances): Given a list of positive integers `distances`, partition these checkpoints into exactly two groups such that the absolute difference between the sum of distances in the two groups is minimized. Return the minimum possible absolute difference. total_sum = sum(distances) n = len(distances) target = total_sum // 2 # dp[i] will be True if sum i can be achieved, otherwise False dp = [False] * (target + 1) dp[0] = True for distance in distances: for j in range(target, distance - 1, -1): dp[j] = dp[j] or dp[j - distance] for i in range(target, -1, -1): if dp[i]: sum1 = i break sum2 = total_sum - sum1 return abs(sum1 - sum2)"},{"question":"Given the `head` of a singly linked list, reverse the list and return the reversed list. Write a function to reverse the list that works in-place.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverse_list(head): Reverses a singly linked list in-place. :param head: ListNode - The head of the singly linked list. :return: ListNode - The new head of the reversed singly linked list. prev = None current = head while current: next_node = current.next current.next = prev prev = current current = next_node return prev"},{"question":"Given a string `s` consisting solely of characters `a`, `b`, and `c`, you need to move all the characters `a` to the left, all characters `c` to the right, and keep the characters `b` in the middle. Implement a function that returns the modified string after rearranging the characters as described.","solution":"def rearrange_string(s): Rearranges the string such that all \'a\' characters are moved to the left, all \'c\' characters are moved to the right, and all \'b\' characters are in the middle. :param s: A string consisting of characters \'a\', \'b\', and \'c\' :return: The rearranged string a_count = s.count(\'a\') b_count = s.count(\'b\') c_count = s.count(\'c\') return \'a\' * a_count + \'b\' * b_count + \'c\' * c_count"},{"question":"Given a string `s` and an integer `n`, return the number of substrings of `s` whose length is exactly `n` and contains at most one distinct character. A substring is a contiguous sequence of characters within a string. The test cases are generated such that the answer fits in a 32-bit integer.","solution":"def count_substrings(s, n): Returns the number of substrings of length n with at most one distinct character. :param s: Input string :param n: Length of the desired substrings :return: Number of substrings meeting the criteria count = 0 length = len(s) for i in range(length - n + 1): substring = s[i:i+n] distinct_chars = set(substring) if len(distinct_chars) <= 1: count += 1 return count"},{"question":"You are given a 2D grid representing a maze of dimensions `m x n`, where each cell can either be an empty space `\'0\'` or a wall `\'1\'`. You need to move from the top-left corner of the maze to the bottom-right corner. However, you can break at most one wall to make a path from the start to the destination. You can only move up, down, left, or right from a cell to its adjacent cell. Write a function `int shortestPathWithOneBreak(int[][] maze)` which returns the length of the shortest path from the start to the destination. If there is no path, return `-1`. Note that the start and destination cells are always empty spaces.","solution":"from collections import deque def shortestPathWithOneBreak(maze): Returns the length of the shortest path from the start to the destination, where one wall can be broken to aid in creating the path. If there is no path, returns -1. if not maze or not maze[0]: return -1 m, n = len(maze), len(maze[0]) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] # BFS queue: (x, y, wall_breaks, path_length) queue = deque([(0, 0, 0, 1)]) # Visited array with wall breaking state visited = [[[False]*2 for _ in range(n)] for _ in range(m)] visited[0][0][0] = True while queue: x, y, wall_breaks, path_length = queue.popleft() if x == m-1 and y == n-1: return path_length for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n: # If encountered wall and wall breaking still available if maze[nx][ny] == 1 and wall_breaks == 0 and not visited[nx][ny][1]: visited[nx][ny][1] = True queue.append((nx, ny, 1, path_length + 1)) # If encountered empty space elif maze[nx][ny] == 0 and not visited[nx][ny][wall_breaks]: visited[nx][ny][wall_breaks] = True queue.append((nx, ny, wall_breaks, path_length + 1)) return -1"},{"question":"You are given a singly linked list where each node contains an additional random pointer which could point to any node in the list or null. Construct a deep copy of the list. Your code should return the head of the copied linked list. To represent the linked list, each node is defined as: ``` class Node { int val; Node next; Node random; public Node(int val) { this.val = val; this.next = null; this.random = null; } } ``` Write a function: ``` Node copyRandomList(Node head) ``` that takes the `head` of the linked list and returns the head of the deep copied list. The deep copy should have all the nodes in the original list duplicated such that the `next` and `random` pointers in the copied list mirror those in the original list.","solution":"class Node: def __init__(self, val, next=None, random=None): self.val = val self.next = next self.random = random def copyRandomList(head): if not head: return None # Step 1: Create a new node for each original node and insert it right after the original node. current = head while current: new_node = Node(current.val, current.next) current.next = new_node current = new_node.next # Step 2: Set the random pointers for the new nodes. current = head while current: if current.random: current.next.random = current.random.next current = current.next.next # Step 3: Restore the original list and extract the copy list. current = head copy_head = head.next while current: copy = current.next current.next = copy.next if copy.next: copy.next = copy.next.next current = current.next return copy_head"},{"question":"You are given a string `s` and an integer `n`. Your task is to split the string into `n` contiguous substrings such that the length of each substring is maximized and each substring is lexicographically smallest possible. If it is not possible to split the string into `n` substrings, return `-1`. Otherwise, return the list of substrings.","solution":"def split_string(s, n): Splits the given string `s` into `n` contiguous substrings such that the length of each substring is maximized and each substring is lexicographically smallest possible. Parameters: s (str): The input string. n (int): The number of desired substrings. Returns: List[str] or int: A list of `n` substrings if possible, otherwise -1. if n <= 0 or len(s) < n: return -1 # The length of each segment base_len = len(s) // n extra = len(s) % n substrings = [] start = 0 for i in range(n): # Calculate the length of the current segment length = base_len + (1 if i < extra else 0) substring = s[start:start + length] substrings.append(substring) start += length return substrings"},{"question":"You are given an **integer array** `arr` of length `n` where each element represents the number of chocolates in a box. You can eat chocolates from the boxes, but there is a catch: if you eat chocolates from the ith box, you must eat all the chocolates from that box, and then that box becomes empty. Additionally, after eating from a box, you cannot eat from any directly adjacent boxes (the boxes immediately to the left and right of the current box). Determine the maximum number of chocolates you can eat from the array.","solution":"def max_chocolates(arr): Returns the maximum number of chocolates that can be eaten from non-adjacent boxes. n = len(arr) if n == 0: return 0 if n == 1: return arr[0] # dp[i] will store the maximum chocolates that can be eaten from 0 to i dp = [0] * n # base cases dp[0] = arr[0] if n > 1: dp[1] = max(arr[0], arr[1]) # fill the dp array for i in range(2, n): dp[i] = max(dp[i-1], arr[i] + dp[i-2]) return dp[-1]"},{"question":"Given an array of integers `arr`, return a list of the number of smaller numbers that appear after each element. **Notice:** The output list should have the same length as the input array, where the i-th element represents the count of elements that are smaller than `arr[i]` and come after it.","solution":"def count_smaller_numbers_after_self(arr): Returns an array of counts of smaller numbers after each element in the given array. Args: arr (List[int]): input list of integers. Returns: List[int]: a list of counts of smaller numbers after each element in the input list. result = [] for i in range(len(arr)): count = 0 for j in range(i + 1, len(arr)): if arr[j] < arr[i]: count += 1 result.append(count) return result"},{"question":"Given an array of integers `arr`, find and return the length of the longest subarray such that the difference between the maximum and minimum values in this subarray is less than or equal to `d`. A **subarray** is defined as a contiguous non-empty sequence of elements in an array.","solution":"def longest_subarray_with_limit(arr, d): Returns the length of the longest subarray where the difference between the maximum and minimum values in the subarray is less than or equal to d. Parameters: arr (list of int): The input array d (int): The maximum allowed difference between the maximum and minimum values of the subarray Returns: int: The length of the longest subarray from collections import deque max_deque = deque() min_deque = deque() start = 0 longest = 0 for end in range(len(arr)): while max_deque and arr[max_deque[-1]] < arr[end]: max_deque.pop() while min_deque and arr[min_deque[-1]] > arr[end]: min_deque.pop() max_deque.append(end) min_deque.append(end) while arr[max_deque[0]] - arr[min_deque[0]] > d: start += 1 if max_deque[0] < start: max_deque.popleft() if min_deque[0] < start: min_deque.popleft() longest = max(longest, end - start + 1) return longest"},{"question":"You are given a list of `n` strings, each representing a binary number. Your task is to find two distinct binary numbers from the list that, when converted to decimal, have the maximum sum. Return the decimal sum of these two binary numbers. If there are multiple pairs with the same sum, just return the sum once. The input list of strings will always have at least two elements and each string will contain only \'0\'s and \'1\'s.","solution":"def max_sum_of_binaries(binary_list): Given a list of binary strings, find and return the maximum sum of two distinct binary numbers when converted to decimals. Parameters: binary_list (list): A list of binary string numbers. Returns: int: The maximum decimal sum of two distinct binary numbers. # Convert the binary strings to decimal integers decimal_numbers = [int(b, 2) for b in binary_list] # Sort the decimal numbers in descending order decimal_numbers.sort(reverse=True) # The maximum sum will be the sum of the two largest distinct numbers return decimal_numbers[0] + decimal_numbers[1] # Take the top two numbers and sum them"},{"question":"You are given a string `s` and a character `c` that occurs in `s` frequently. For each character in `s`, find the shortest distance to the character `c` and return an array of these distances. If the character `c` does not appear at least once in `s`, return an empty array.","solution":"def shortest_distance_to_char(s, c): Returns an array of shortest distances from each character in s to the character c. if c not in s: return [] prev = float(\'-inf\') result = [] # First pass to find the shortest distance to previous occurrences of c for i in range(len(s)): if s[i] == c: prev = i result.append(i - prev) prev = float(\'inf\') # Second pass to find the shortest distance to next occurrences of c for i in range(len(s) - 1, -1, -1): if s[i] == c: prev = i result[i] = min(result[i], prev - i) return result"},{"question":"Given a list of unique integers `nums`, find all pairs of numbers that sum up to a given target `k`. Each pair should be represented as an array of the two integers in non-descending order. The solution should not contain duplicate pairs. Return a list of the pairs in any order.","solution":"def find_pairs_with_sum(nums, k): nums_dict = {} pairs = set() for num in nums: complement = k - num if complement in nums_dict: pairs.add(tuple(sorted((num, complement)))) nums_dict[num] = True return [list(pair) for pair in pairs]"},{"question":"Given a linked list, return the linked list after reversing every group of `k` nodes. `k` is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of `k`, leave the last remaining nodes as they are. Implement a function `ListNode* reverseKGroup(ListNode* head, int k)` that takes the head of the linked list and the integer `k`, and returns the head of the modified linked list.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverseKGroup(head: ListNode, k: int) -> ListNode: def reverseLinkedList(head: ListNode, k: int) -> ListNode: new_head, ptr = None, head while k: next_node = ptr.next ptr.next = new_head new_head = ptr ptr = next_node k -= 1 return new_head count = 0 ptr = head # Count k nodes in the linked list while count < k and ptr: ptr = ptr.next count += 1 # If we counted k nodes, then we reverse them if count == k: reversedHead = reverseLinkedList(head, k) # Next, we recursively call function on remaining list if ptr: head.next = reverseKGroup(ptr, k) return reversedHead # If we don\'t have k nodes, return head as it is return head"},{"question":"You are given an array of integers representing the number of books a person wants to borrow over consecutive days. Each person can only borrow books if the number of books requested on day `i` is greater than or equal to the number of books requested on day `i-1`. Write a function to find the longest continuous segment of days where this condition holds true. Return the length of this segment. **Example:** ``` Input: books = [1, 2, 2, 3, 1, 2, 4, 1] Output: 4 Explanation: The longest segment is [1, 2, 2, 3] ```","solution":"def longest_borrow_segment(books): Returns the length of the longest continuous segment of days where the number of books borrowed on day i is greater than or equal to the number of books borrowed on day i-1. Args: books (list of int): The array of integers representing the number of books borrowed. Returns: int: The length of the longest continuous segment. if not books: return 0 max_length = 1 current_length = 1 for i in range(1, len(books)): if books[i] >= books[i-1]: current_length += 1 else: if current_length > max_length: max_length = current_length current_length = 1 return max(max_length, current_length)"},{"question":"You are given an array of integers `arr` and an integer `k`. Write a function to find the `k` most frequent elements in the array. Your function should return the elements sorted by their frequency in descending order. If multiple elements have the same frequency, they should be sorted by their natural order (i.e., numerically or lexicographically). The function should have linearithmic time complexity.","solution":"from collections import Counter from heapq import nlargest def top_k_frequent_elements(arr, k): Returns the k most frequent elements in the array sorted by their frequency in descending order. Parameters: arr (list): The input list of integers. k (int): Number of top frequent elements to return. Returns: list: The k most frequent elements sorted by frequency, and by natural order if frequencies are equal. if k == 0: return [] # Count the frequencies of elements in the array counter = Counter(arr) # Use heap to find the k most frequent elements top_k_elements = nlargest(k, counter.items(), key=lambda x: (x[1], -x[0])) # Return only the elements, sorted by frequency in descending order return [element for element, frequency in top_k_elements]"},{"question":"Given a `matrix` of `m x n` 0s and 1s, identify the largest square containing only 1s and return its area. The square must be completely filled with 1s, and you are to return the area of this square. The area is defined as the side length of the square squared.","solution":"def maximalSquare(matrix): Given a matrix of m x n containing only 0s and 1s, finds the largest square containing only 1s and returns its area. :param matrix: List[List[int]] :return: int if not matrix or not matrix[0]: return 0 rows, cols = len(matrix), len(matrix[0]) # Create a dp matrix with dimensions (rows+1) x (cols+1) initialized to 0 dp = [[0] * (cols + 1) for _ in range(rows + 1)] max_side = 0 for i in range(1, rows + 1): for j in range(1, cols + 1): if matrix[i-1][j-1] == \'1\': dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1 max_side = max(max_side, dp[i][j]) return max_side * max_side"},{"question":"Given a **0-indexed** integer array `heights` representing the heights of students in a line, return _a **list** of integers representing the positions of students that need to move such that each student\'s height is taller than the student in front of them after rearrangement_. Assume that the goal is to keep as many students in their original positions as possible. If the line is already arranged in non-decreasing order, return an **empty list**. The order that the positions are returned in does **not** matter.","solution":"def students_to_move(heights): Returns a list of indices of students that need to move to achieve non-decreasing arrangement. result = [] for i in range(1, len(heights)): if heights[i] < heights[i - 1]: result.append(i) return result"},{"question":"Given a list of integers `nums`, return _the **length of the longest subsequence** such that every pair of consecutive elements in the subsequence has an **absolute difference** of at most `1`_. A **subsequence** is a sequence that can be derived from another sequence by deleting some or no elements without changing the order of the remaining elements.","solution":"def longest_subsequence(nums): if not nums: return 0 counts = {} max_length = 0 for num in nums: if num in counts: counts[num] += 1 else: counts[num] = 1 for num in counts: length = counts[num] if num - 1 in counts: length += counts[num - 1] if num + 1 in counts: length += counts[num + 1] max_length = max(max_length, length) return max_length"},{"question":"You are given an array of integers `arr` and an integer `n`. Your task is to construct a new array of length `n` such that the new array contains unique elements from `arr` in the same relative order. If the new array cannot be constructed with the unique elements from `arr`, fill the remaining positions with `-1`. Additionally, if there are multiple such new arrays that can be constructed, return the lexicographically smallest one. Note that an array is lexicographically smaller than another array if in the first position where they differ, the first array has a smaller element than the corresponding element in the second array. Return the new array.","solution":"def construct_unique_array(arr, n): Constructs a new array of length n with unique elements from arr in the same relative order. If it cannot be constructed, fills remaining positions with -1. unique_elements = [] seen = set() for num in arr: if num not in seen: unique_elements.append(num) seen.add(num) if len(unique_elements) >= n: return unique_elements[:n] # If unique_elements are less than n, fill the remaining positions with -1 result = unique_elements + [-1] * (n - len(unique_elements)) return result"},{"question":"Given a binary tree, we define the **level-order traversal** of the tree as a list of the values of the nodes traversed level by level from left to right. Implement the function `levelOrderTraversal(root)` that returns the level-order traversal of the given binary tree. Each node is defined as: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` Write the function `levelOrderTraversal` that takes the root of a binary tree and returns a list of lists, where each inner list contains the nodes at each corresponding level in the tree.","solution":"from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def levelOrderTraversal(root): Performs a level-order traversal (breadth-first search) of a binary tree. if not root: return [] result = [] queue = deque([root]) while queue: level_size = len(queue) level_values = [] for _ in range(level_size): node = queue.popleft() level_values.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.append(level_values) return result"},{"question":"Given a list of positive integers, `candidates`, and a target positive integer, `target`, return a list of all unique combinations of `candidates` where the chosen numbers sum to `target`. Each number in `candidates` may only be used once in each combination. Numbers in each combination must be in non-decreasing order, and the combinations themselves must be sorted in lexicographic order.","solution":"def combination_sum2(candidates, target): Given a list of positive integers, `candidates`, and a target positive integer, `target`, return a list of all unique combinations of `candidates` where the chosen numbers sum to `target`. Each number in `candidates` may only be used once in each combination. Numbers in each combination must be in non-decreasing order, and the combinations themselves must be sorted in lexicographic order. candidates.sort() result = [] def backtrack(start, path, target): if target == 0: result.append(path) return if target < 0: return for i in range(start, len(candidates)): if i > start and candidates[i] == candidates[i - 1]: continue backtrack(i + 1, path + [candidates[i]], target - candidates[i]) backtrack(0, [], target) return result"},{"question":"You are given an `n x n` matrix `mat` where each of the integers in the matrix is either 1 or 0. A row and column of the matrix is said to be **wealthy** if it contains at least one `1`. Your task is to determine the number of rows and columns that are **wealthy**. Write a function that returns an integer representing the count of such rows and columns.","solution":"def count_wealthy_rows_and_columns(mat): Returns the count of rows and columns that contain at least one 1. n = len(mat) wealthy_rows = 0 wealthy_columns = 0 # Counting wealthy rows for row in mat: if 1 in row: wealthy_rows += 1 # Counting wealthy columns for col in range(n): for row in range(n): if mat[row][col] == 1: wealthy_columns += 1 break return wealthy_rows + wealthy_columns"},{"question":"You are given a **0-indexed** `n x n` binary matrix `grid` representing an image, where `0` represents a pixel of color white and `1` represents a pixel of color black. You need to find the smallest sub-rectangle that contains all the black pixels. The sub-rectangle should be aligned with the matrix edges. Return an integer array `[r1, c1, r2, c2]` such that `(r1, c1)` is the coordinate of the top-left corner of the rectangle and `(r2, c2)` is the coordinate of the bottom-right corner of the rectangle. If there are no black pixels in the image, return an empty array. To implement this, you can follow these steps: 1. Identify the rows and columns that contain at least one black pixel. 2. Determine the minimum and maximum indices for these rows and columns to form the rectangle. 3. Construct the result array with these indices. Your result should capture the smallest bounding rectangle that encompasses all the black pixels in the given `grid`.","solution":"def smallest_rectangle_containing_black_pixels(grid): Given a binary matrix grid, finds the smallest sub-rectangle that contains all the black pixels. Args: grid (List[List[int]]): 0-indexed n x n binary matrix representing an image. Returns: List[int]: A list [r1, c1, r2, c2], the coordinates of the smallest sub-rectangle containing all black pixels. n = len(grid) min_row, min_col = n, n max_row, max_col = -1, -1 for r in range(n): for c in range(n): if grid[r][c] == 1: min_row = min(min_row, r) max_row = max(max_row, r) min_col = min(min_col, c) max_col = max(max_col, c) if min_row == n: return [] return [min_row, min_col, max_row, max_col]"},{"question":"You are given an integer array `widgets` where `widgets[i]` is the production efficiency of the `ith` widget production machine in an assembly line. Each machine can produce widgets continuously without interruption. However, due to maintenance, each machine must rest for a specific cooldown period after being utilized once. You have another integer `cooldown` which represents the minimum number of periods a machine must rest before it can be used again. Return _the maximum number of widgets that can be produced in a given period_ `t` considering the cooldown constraints. You need to determine an optimal schedule for using these machines to maximize production. The period `t` is large enough such that the total production is determined more by the machine\'s efficiency and the cooldown period than by the period\'s length itself.","solution":"def max_widgets(widgets, cooldown): Returns the maximum number of widgets that can be produced considering the cooldown constraints. Parameters: widgets (List[int]): List of production efficiencies of the machines. cooldown (int): Cooldown period after each use of a machine. Returns: int: Maximum number of widgets that can be produced. if cooldown < 0: raise ValueError(\\"Cooldown period must be non-negative.\\") # The best way to solve this is to use each machine once and then follow the cooldown period. # Since t is large, we are focusing on the pattern and not the exact value of t. # The sum of widgets produced in a cycle of (cooldown + 1) periods where each machine is used once in each cycle. total_widgets = sum(widgets) # In each cycle of `cooldown + 1` periods, each machine will be used once to produce their widgets. return total_widgets # Example usage: # widgets = [3, 5, 7] # cooldown = 2 # print(max_widgets(widgets, cooldown)) # Expected output: 15"},{"question":"You are organizing a music festival and want to automate the process of assigning performance slots to the bands. Each band has a preferred time slot and a duration for their performance. Given a list of bands where each band is represented as a tuple (start, end) indicating their preferred start and end times, and a duration for the festival, return _the maximum number of bands that can perform without any overlaps._ The time slots are inclusive, meaning if one band\'s end time is the same as another\'s start time, they cannot perform consecutively.","solution":"def max_bands(bands, duration): Find the maximum number of non-overlapping bands that can perform in the given duration. :param bands: List of tuples where each tuple contains (start, end) time. :param duration: Total duration of the festival. :return: Maximum number of non-overlapping bands. # Sort the bands based on their end times bands.sort(key=lambda x: x[1]) # Initialize variables to track the end time of the last selected band and the count of bands last_end_time = -1 count = 0 # Iterate through the sorted bands list for start, end in bands: # If the current band\'s start time is after the last selected band\'s end time if start > last_end_time and end <= duration: # Select this band last_end_time = end count += 1 return count"},{"question":"You are given a list of non-negative integers representing heights of buildings in a cityscape, where each building is represented by its height and is aligned to the left with some width of 1. The goal is to find the largest rectangular area that can be formed within this cityscape. Return the maximum rectangular area possible in the cityscape, given the list of building heights.","solution":"def largestRectangleArea(heights): Calculate the largest rectangular area in a histogram. :param heights: List of heights of the histogram\'s bars. :type heights: List[int] :return: The largest rectangular area. :rtype: int stack = [] max_area = 0 index = 0 while index < len(heights): if not stack or heights[stack[-1]] <= heights[index]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index) max_area = max(max_area, area) return max_area"},{"question":"You are given a linked list where each node contains an integer value. Write a function to sort this linked list using a merge sort algorithm. Return the head node of the sorted linked list. For example, if the input linked list is `4 -> 2 -> 1 -> 3`, the return value should be the head of the sorted linked list `1 -> 2 -> 3 -> 4`.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def merge_sort(head): if not head or not head.next: return head # Split the linked list into halves def split(head): slow = head fast = head.next while fast and fast.next: slow = slow.next fast = fast.next.next mid = slow.next slow.next = None return head, mid # Merge two sorted linked lists def merge(l1, l2): dummy = ListNode() current = dummy while l1 and l2: if l1.val < l2.val: current.next = l1 l1 = l1.next else: current.next = l2 l2 = l2.next current = current.next current.next = l1 if l1 else l2 return dummy.next left, right = split(head) left = merge_sort(left) right = merge_sort(right) return merge(left, right)"},{"question":"You are given a binary tree where each node contains an integer value. Implement a function `int sumOfLeavesAtMinDepth(TreeNode* root)` that returns the sum of all leaf nodes that are at the minimum depth of the tree. The minimum depth is defined as the shortest distance from the root node to any leaf node. A leaf node is a node with no children. Classes and methods are defined as follows: ```cpp class TreeNode { public: int val; TreeNode* left; TreeNode* right; TreeNode() : val(0), left(nullptr), right(nullptr) {} TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} TreeNode(int x, TreeNode* left, TreeNode* right) : val(x), left(left), right(right) {} }; ``` The function `sumOfLeavesAtMinDepth` takes the root of the tree as input and returns the sum of all leaf nodes at the minimum depth.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def sumOfLeavesAtMinDepth(root): if not root: return 0 from collections import deque queue = deque([(root, 0)]) min_depth = float(\'inf\') sum_leaves = 0 while queue: node, depth = queue.popleft() if not node.left and not node.right: if depth < min_depth: min_depth = depth sum_leaves = node.val elif depth == min_depth: sum_leaves += node.val if node.left: queue.append((node.left, depth + 1)) if node.right: queue.append((node.right, depth + 1)) return sum_leaves"},{"question":"Write a function that takes a string consisting of space-separated words and returns the length of the longest word. If there are multiple words of the same maximum length, return the length of the first such word encountered. You may assume the input string is non-empty and contains only alphabetic characters and spaces.","solution":"def length_of_longest_word(s): Returns the length of the longest word in a space-separated string. Parameters: s (str): The input string consisting of space-separated words. Returns: int: The length of the longest word. words = s.split() longest_length = max(len(word) for word in words) return longest_length"},{"question":"You are given a string `s` composed of lowercase English letters, and an integer `k`. An operation is defined as selecting a substring containing at most one distinct character and removing it from `s`. Return _the minimum number of operations required to make the string empty_. For example, given `s = \\"aaabbb\\"` and `k = 2`, you can perform the following operations: remove \\"aaa\\" (k = 1) and then remove \\"bbb\\" (k = 2).","solution":"def min_operations_to_empty_string(s, k): Returns the minimum number of operations required to make the string empty by removing substrings containing at most one distinct character. current_char = \'\' count = 0 operations = 0 for char in s: if char == current_char: count += 1 else: # Increment operations for the previous substring if count > 0: operations += (count + k - 1) // k current_char = char count = 1 # Add operations for the last substring if count > 0: operations += (count + k - 1) // k return operations"},{"question":"You are given an array of integers `arr` representing a sequence of numbers. Your task is to partition the array into three contiguous subarrays such that each subarray has an equal sum. If this is achievable, return `true`; otherwise, return `false`. A valid partition requires the sum of the elements in each subarray to be the same.","solution":"def can_partition_into_three_equal_sum_subarrays(arr): Determines if the array can be partitioned into three contiguous subarrays with equal sum. Parameters: arr (list): The input array of integers. Returns: bool: True if the array can be partitioned into three equal sum subarrays, False otherwise. total_sum = sum(arr) if total_sum % 3 != 0: return False target_sum = total_sum // 3 subarray_sum = 0 count = 0 for num in arr: subarray_sum += num if subarray_sum == target_sum: count += 1 subarray_sum = 0 return count >= 3"},{"question":"Given a string `s` that consists of only digits, return the number of ways to decode it assuming the following mapping: `\'1\' -> \'A\'`, `\'2\' -> \'B\'`, ..., `\'26\' -> \'Z\'`. For instance, the string `\'12\'` can be decoded as `\'AB\'` (1 2) or `\'L\'` (12). Note that the input string `\'0\'` does not represent any valid character and should be handled accordingly.","solution":"def num_decodings(s): Returns the number of ways to decode a string of digits with the given mapping. if not s or s[0] == \'0\': return 0 n = len(s) dp = [0] * (n + 1) dp[0] = dp[1] = 1 for i in range(2, n + 1): one_digit = int(s[i-1]) two_digits = int(s[i-2:i]) if 1 <= one_digit <= 9: dp[i] += dp[i-1] if 10 <= two_digits <= 26: dp[i] += dp[i-2] return dp[n]"},{"question":"You are given a string `s`, and you need to perform the following operations: 1. Divide the string into the minimal number of substrings such that each substring contains exactly one unique character. 2. For each substring, replace that substring with the character and the number of times it appears consecutively within that substring. 3. Concatenate these values in order to form the new string. Return the transformed string after performing the above operations. For example, given the string `\\"aaabccddd\\"`, the transformation will be: - Substrings: `\\"aaa\\"`, `\\"b\\"`, `\\"cc\\"`, `\\"ddd\\"` - Replacements: `\\"a3\\"`, `\\"b1\\"`, `\\"c2\\"`, `\\"d3\\"` - Resulting string: `\\"a3b1c2d3\\"`","solution":"def transform_string(s): Transform the input string by dividing into minimal substrings with unique characters, replacing each substring with the character and count of its occurrence. if not s: return \\"\\" result = [] count = 1 for i in range(1, len(s)): if s[i] == s[i - 1]: count += 1 else: result.append(f\\"{s[i - 1]}{count}\\") count = 1 result.append(f\\"{s[-1]}{count}\\") return \\"\\".join(result)"},{"question":"You are given a string `s` consisting of only lowercase English letters. Your task is to group the characters of the string based on their frequency and then return the characters in each frequency group in lexicographical order. Specifically, you will output a list of lists, where each sublist contains characters that have the same frequency, ordered from highest frequency to lowest frequency. Within each sublist, the characters should be in lexicographical order. If two characters have the same frequency, the character with a smaller ASCII value should appear first. For example, for the input `s = \\"tree\\"`, the output should be `[[\\"e\\"], [\\"r\\", \\"t\\"]]` as \'e\' appears twice, and both \'r\' and \'t\' appear once.","solution":"from collections import Counter def group_characters_by_frequency(s): Groups characters of the string by their frequency and returns them in the specified order. Parameters: s (str): A string consisting of only lowercase English letters. Returns: List[List[str]]: A list of lists where each sublist contains characters that have the same frequency, ordered from highest frequency to lowest frequency. Within each sublist, characters are in lexicographical order. frequency = Counter(s) # Count the frequency of each character freq_map = {} # Create a mapping from frequency to characters with that frequency for char, freq in frequency.items(): if freq not in freq_map: freq_map[freq] = [] freq_map[freq].append(char) # Sort each frequency group lexicographically for freq in freq_map: freq_map[freq].sort() # Sort the frequencies in descending order sorted_frequencies = sorted(freq_map.keys(), reverse=True) # Create the result based on the sorted frequencies result = [freq_map[freq] for freq in sorted_frequencies] return result"},{"question":"You are given an array of integers `arr` representing the heights of buildings. A building with a height `h` will get sunlight if there are no taller buildings to its left. In other words, building `i` will get sunlight if for all `j < i`, `arr[j] < arr[i]`. Return the number of buildings that will get sunlight. For instance, if `arr = [3, 2, 5, 4, 6]`, a building is said to get sunlight if its height is greater than all the heights of buildings to its left. Here, the buildings with heights [3, 5, 6] will get sunlight. Hence, the output should be 3.","solution":"def count_buildings_with_sunlight(arr): Returns the number of buildings that will get sunlight. :param arr: List of integers representing the heights of buildings. :return: Integer representing the count of buildings receiving sunlight. if not arr: return 0 max_height = arr[0] count = 1 for height in arr[1:]: if height > max_height: count += 1 max_height = height return count"},{"question":"You are given a binary tree in which each node contains an integer value. Design an algorithm to find the sum of values of its deepest leaves. The deepest leaves of the binary tree are the nodes at the maximum depth from the root. Return the sum as an integer value. Each node in the binary tree is defined by the TreeNode class, which contains three attributes: `val`, `left`, and `right`.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def deepest_leaves_sum(root): if not root: return 0 from collections import deque queue = deque([root]) while queue: level_sum = 0 for _ in range(len(queue)): node = queue.popleft() level_sum += node.val if node.left: queue.append(node.left) if node.right: queue.append(node.right) return level_sum"},{"question":"You are given an array of integers `arr` representing the number of votes each candidate received in an election. Assume that the total number of votes is the sum of all elements in `arr`. Return the index of the candidate with more than half of the total votes if such a candidate exists. If no candidate has more than half of the votes, return -1.","solution":"def majority_vote(arr): Returns the index of the candidate with more than half of the votes or -1 if no such candidate exists. total_votes = sum(arr) majority_threshold = total_votes / 2 for index, votes in enumerate(arr): if votes > majority_threshold: return index return -1"},{"question":"Given a binary tree, implement a function that returns the **right side view** of the tree. The right side view of a binary tree is the set of nodes visible when the tree is viewed from the right side. The input will be the root node of a binary tree, and the output should be a list of values seen when looking from the right side of the tree.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def rightSideView(root): Given the root of a binary tree, returns the right side view of the tree. if not root: return [] right_view = [] queue = [(root, 0)] while queue: node, level = queue.pop(0) if len(right_view) == level: right_view.append(node.val) else: right_view[level] = node.val if node.left: queue.append((node.left, level + 1)) if node.right: queue.append((node.right, level + 1)) return right_view"},{"question":"You are given a list of integers `nums` representing a permutation of the numbers in the range `[1, n]`. We define a permutation\'s **inversion count** as the number of pairs `(i, j)` such that `i < j` and `nums[i] > nums[j]`. Write a function to compute the inversion count for the given permutation and return it.","solution":"def count_inversions(nums): Returns the number of inversions in the list nums. def merge_and_count(arr, temp_arr, left, mid, right): i = left # Starting index for left subarray j = mid + 1 # Starting index for right subarray k = left # Starting index to be sorted inv_count = 0 # Conditions are checked to ensure that i doesn\'t exceed mid and j doesn\'t exceed right while i <= mid and j <= right: if arr[i] <= arr[j]: temp_arr[k] = arr[i] i += 1 else: # There are mid - i inversions because all elements left to i in the left subarray # are greater than arr[j] temp_arr[k] = arr[j] inv_count += (mid-i + 1) j += 1 k += 1 # Copy the remaining elements of left subarray, if any while i <= mid: temp_arr[k] = arr[i] i += 1 k += 1 # Copy the remaining elements of right subarray, if any while j <= right: temp_arr[k] = arr[j] j += 1 k += 1 # Copy the sorted subarray into Original array for i in range(left, right + 1): arr[i] = temp_arr[i] return inv_count def merge_sort_and_count(arr, temp_arr, left, right): inv_count = 0 if left < right: mid = (left + right)//2 inv_count += merge_sort_and_count(arr, temp_arr, left, mid) inv_count += merge_sort_and_count(arr, temp_arr, mid + 1, right) inv_count += merge_and_count(arr, temp_arr, left, mid, right) return inv_count return merge_sort_and_count(nums, [0]*len(nums), 0, len(nums)-1)"},{"question":"Given an arithmetic progression (AP) defined by its first term `a` and common difference `d`, and an integer `N`, write a function that returns the `N`th term of the AP. The function should handle large values of `N` efficiently.","solution":"def nth_term_of_ap(a, d, N): Returns the Nth term of an arithmetic progression (AP) defined by its first term \'a\' and common difference \'d\'. Parameters: a (int): The first term of the AP. d (int): The common difference of the AP. N (int): The position of the term to be found. Returns: int: The Nth term of the AP. return a + (N - 1) * d"},{"question":"We define a tree traversal sequence as the order in which nodes are visited during a traversal of a binary tree. Given the `preorder` and `inorder` traversal sequences of a binary tree, reconstruct the binary tree and return its root. Each value in the traversal sequences is unique to ensure there\'s only one possible binary tree that can be constructed from the given traversal sequences.","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def buildTree(preorder, inorder): Reconstructs a binary tree from its preorder and inorder traversal sequences. :param preorder: List[int] - The preorder traversal sequence :param inorder: List[int] - The inorder traversal sequence :return: TreeNode - The root of the reconstructed binary tree if not preorder or not inorder: return None # Build a map of value -> index for inorder sequence for quick lookup inorder_index_map = {value: index for index, value in enumerate(inorder)} # Recursive helper function to construct the tree def helper(pre_left, pre_right, in_left, in_right): if pre_left > pre_right or in_left > in_right: return None # Root value is the first element in the current preorder segment root_value = preorder[pre_left] root = TreeNode(root_value) # Index of the root value in the inorder sequence in_root_index = inorder_index_map[root_value] # Number of nodes in the left subtree left_subtree_size = in_root_index - in_left # Construct left and right subtrees root.left = helper(pre_left + 1, pre_left + left_subtree_size, in_left, in_root_index - 1) root.right = helper(pre_left + left_subtree_size + 1, pre_right, in_root_index + 1, in_right) return root return helper(0, len(preorder) - 1, 0, len(inorder) - 1)"},{"question":"You are given a 2D integer grid of size `m x n` representing a map of a battle game. An enemy unit is represented by \'1\' and an empty space is represented by \'0\'. An effective attack involves using the least number of bombs required to destroy all enemy units. A bomb can be placed at any empty cell and will eliminate all adjacent enemy units horizontally and vertically. Write a function that returns the minimum number of bombs needed to destroy all the enemies on the map. Implement the following function: ```python def minimumBombs(grid: List[List[int]]) -> int: pass ```","solution":"def minimumBombs(grid): from collections import deque def bfs(r, c): directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] queue = deque([(r, c)]) visited.add((r, c)) while queue: x, y = queue.popleft() for dr, dc in directions: nr, nc = x + dr, y + dc if 0 <= nr < len(grid) and 0 <= nc < len(grid[0]) and (nr, nc) not in visited and grid[nr][nc] == 1: visited.add((nr, nc)) queue.append((nr, nc)) visited = set() bombs = 0 for r in range(len(grid)): for c in range(len(grid[0])): if grid[r][c] == 1 and (r, c) not in visited: bombs += 1 bfs(r, c) return bombs"},{"question":"Given a list of non-negative integers `nums`, you are tasked with finding a **contiguous subarray** that has the maximum possible **bitwise AND** value. The bitwise AND of a subarray is defined as the result of performing a bitwise AND operation on all elements in that subarray. A subarray is a contiguous part of the original array. _Return the maximum bitwise AND value that can be obtained from any subarray of `nums`._","solution":"def max_bitwise_and(nums): Returns the maximum bitwise AND value of any contiguous subarray of nums. if not nums: return 0 max_and = 0 for i in range(len(nums)): current_and = nums[i] max_and = max(max_and, current_and) for j in range(i + 1, len(nums)): current_and &= nums[j] max_and = max(max_and, current_and) if current_and == 0: break return max_and"},{"question":"You are given a string `s` and an integer `k`. The string `s` can be manipulated in the following ways: * Choose any substring of `s` and rotate it such that the last character of the substring moves to the front, and all other characters shift one position to the right. Return _the lexicographically smallest string that can be obtained by performing this operation at most `k` times_.","solution":"def lexicographically_smallest_string(s, k): Returns the lexicographically smallest string that can be obtained by performing the rotation operation at most k times. if k == 1: smallest_string = s for i in range(len(s)): rotated_string = s[i:] + s[:i] if rotated_string < smallest_string: smallest_string = rotated_string return smallest_string else: return \'\'.join(sorted(s))"},{"question":"You are given a string `s` of length `n` consisting of characters \'(\', \')\' and \'*\'. The \'*\' character can be treated as either a \'(\' or \')\' or an empty string. Write a function that returns `true` if the string is **valid** and `false` otherwise. A string is considered valid if it follows the rules of a balanced parenthesis string.","solution":"def is_valid_string(s: str) -> bool: Checks if the input string s is a valid string for balanced parentheses considering \'*\' as \'(\', \')\' or empty string. Args: s (str): The input string containing \'(\', \')\' and \'*\'. Returns: bool: True if the string is valid, False otherwise. min_open = 0 # Minimum possible \'(\' considering \'*\' as \')\', \'(\' or \'\' max_open = 0 # Maximum possible \'(\' considering \'*\' as empty string, \'(\' or \')\' for char in s: if char == \'(\': min_open += 1 max_open += 1 elif char == \')\': min_open -= 1 max_open -= 1 elif char == \'*\': min_open -= 1 max_open += 1 if max_open < 0: return False min_open = max(min_open, 0) return min_open == 0"},{"question":"Design a class `ExamRoom` that manages the seating arrangement in an exam room with `N` seats in a single row. The seating arrangement must ensure that when a new student arrives, they sit as far away as possible from the closest student already seated. If multiple seats are at the same distance, choose the seat with the smallest number. Implement the following functions: * `ExamRoom(int N)`: Initializes an exam room with `N` seats, all initially empty. * `int seat()`: Seat a student in the position that maximizes the distance to the nearest student, and return that seat number. * `void leave(int p)`: The student seated at seat number `p` leaves the room. It is guaranteed that there will be a student sitting at seat `p`. The exam room seats are represented by a list of integers from `0` to `N-1`.","solution":"class ExamRoom: def __init__(self, N: int): Initializes an exam room with N seats, all initially empty. self.N = N self.seats = [] def seat(self) -> int: Seat a student in the position that maximizes the distance to the nearest student, and returns that seat number. if not self.seats: student_seat = 0 else: max_distance = self.seats[0] student_seat = 0 for i in range(1, len(self.seats)): prev_seat = self.seats[i - 1] next_seat = self.seats[i] distance = (next_seat - prev_seat) // 2 if distance > max_distance: max_distance = distance student_seat = prev_seat + distance if self.N - 1 - self.seats[-1] > max_distance: student_seat = self.N - 1 self.seats.append(student_seat) self.seats.sort() return student_seat def leave(self, p: int) -> None: The student seated at seat number p leaves the room. self.seats.remove(p)"},{"question":"You are given a **0-indexed** integer array `nums` representing the number of stones in `n` piles, where `n` is even. Alice and Bob play a game in which they take turns removing stones from one particular pile. Alice always goes first. Each turn, a player must remove a positive number of stones from the pile and may remove any number of stones present in that pile. The game continues until there is no stones left to remove. The player who removes the last stone wins the game. Both players play optimally. Return _`true` if Alice wins the game and `false` if Bob wins the game_.","solution":"def aliceWins(nums): Determine if Alice wins the game given the initial piles of stones. Parameters: nums (list): A list of integers representing the number of stones in each pile. Returns: bool: True if Alice wins, False if Bob wins. # Since n is even and Alice always goes first, Alice can always force a win by # mirroring Bob\'s moves. Essentially the strategy involves always taking stones # from the same piles Bob takes stones from in the last round. # The result is always determined by the fact that n is even and Alice starts. return True"},{"question":"You are given an array of strings `words` and a string `s`. Each string in `words` can be thought of as a key, where the string `s` is created by concatenating exactly one or more keys from `words` in any order. Return _the minimum number of keys needed to form the string `s` using elements from `words`. If it is not possible to form `s` from `words`, return `-1.`","solution":"def min_keys_to_form_string(words, s): from collections import Counter import sys def dp(target): if target in memo: return memo[target] target_count = Counter(target) ans = sys.maxsize for word in words: if all(target_count[char] >= count for char, count in Counter(word).items()): new_target = \'\' for char, count in target_count.items(): if count > Counter(word)[char]: new_target += char * (count - Counter(word)[char]) ans = min(ans, dp(new_target) + 1) memo[target] = ans return ans # Memoization dictionary memo = {} memo[\'\'] = 0 result = dp(s) return result if result != sys.maxsize else -1"},{"question":"You are given an integer array `nums` with exactly `n + 1` elements where each element is an integer from `1` to `n` (inclusive). This means that there is exactly one duplicate number in the array but it might appear more than once. Your task is to find and return the duplicate number. Note that you must do this by modifying the array in-place with O(1) extra space.","solution":"def find_duplicate(nums): Finds and returns the duplicate number in the list nums. Args: nums (list): A list of integers with n+1 elements where each element is an integer from 1 to n. Returns: int: The duplicate integer in the list. slow = nums[0] fast = nums[0] # Phase 1: Finding the intersection point of two runners. while True: slow = nums[slow] fast = nums[nums[fast]] if slow == fast: break # Phase 2: Finding the entrance to the cycle. slow = nums[0] while slow != fast: slow = nums[slow] fast = nums[fast] return slow"},{"question":"Given a string of words separated by spaces, return the longest word in the string. If there are multiple words with the same maximum length, return the first one that appears in the string.","solution":"def longest_word(s): Given a string of words separated by spaces, returns the longest word in the string. If there are multiple words with the same maximum length, returns the first one that appears in the string. words = s.split() longest = \\"\\" for word in words: if len(word) > len(longest): longest = word return longest"},{"question":"You are given an integer array `nums` where each element represents a position on a number line. Imagine a player starting at position `nums[0]` and moving to the next position in the array sequentially until they reach `nums[nums.length - 1]`. The player can make the following type of move at each step: The player can jump from position `i` to any position `j` where `i < j < nums.length` and `(j - i) <= nums[i]`. Your goal is to determine the minimum number of jumps needed for the player to reach the last position starting from the first position, or return -1 if it\'s not possible.","solution":"def min_jumps(nums): Determine the minimum number of jumps needed to reach the last position starting from the first position in the array. if not nums or len(nums) == 1: return 0 n = len(nums) jumps = 0 current_end = 0 farthest = 0 for i in range(n - 1): farthest = max(farthest, i + nums[i]) if i == current_end: jumps += 1 current_end = farthest if current_end >= n - 1: return jumps return -1 if current_end < n - 1 else jumps"},{"question":"You are given a list of integers `nums` where `nums[i]` represents the number of unique distinct elements in the subarray starting at index `i` and ending at any index `j` (`i ≤ j`). Write a function to return an array containing the maximum number of unique distinct elements for every possible subarray of `nums`. The function should return an array such that the value at each index `i` represents the maximum number of distinct elements found in any subarray starting at `i`.","solution":"def max_unique_distinct_elements(nums): n = len(nums) max_distinct_so_far = 0 result = [0] * n for i in range(n - 1, -1, -1): max_distinct_so_far = max(max_distinct_so_far, nums[i]) result[i] = max_distinct_so_far return result"},{"question":"Imagine a streaming platform with a system to keep track of active users and their watching session durations in real-time. Whenever a user starts watching a new movie, their session should start being tracked; when they stop, their session should stop being tracked. Design a class `UserWatchTracker` to manage the users\' watching sessions. Implement the `UserWatchTracker` class: * `UserWatchTracker()` Initializes an empty `UserWatchTracker` object. * `void startSession(String username, int startTime)` Records the start of a watching session for the `username` at the specified `startTime`. * `void endSession(String username, int endTime)` Records the end of a watching session for the `username` at the specified `endTime`. This will only be called after a corresponding startSession call for the same `username`. * `int getTotalWatchTime(String username)` Returns the total watch time for the given `username` across all their sessions up to the current moment. **Requirements:** * Each `username` can have multiple non-overlapping sessions. * `getTotalWatchTime()` should aggregate the durations of all sessions for the given username.","solution":"class UserWatchTracker: def __init__(self): self.sessions = {} self.active_sessions = {} def startSession(self, username, startTime): if username not in self.active_sessions: self.active_sessions[username] = startTime def endSession(self, username, endTime): if username in self.active_sessions: if username not in self.sessions: self.sessions[username] = 0 self.sessions[username] += endTime - self.active_sessions[username] del self.active_sessions[username] def getTotalWatchTime(self, username): if username in self.sessions: return self.sessions[username] return 0"},{"question":"You are given an array of integers `arr`. A **run** is defined as a contiguous subsequence of the same number appearing multiple times in sequence. A **run-boundary** is the index position where a new run starts. For instance, in the array `[1, 2, 2, 3, 3, 3, 2]`, the run-boundaries are at indices `[0, 1, 3, 6]`. Write a function to return the length of the longest run and the list of run-boundaries._","solution":"def find_longest_run_and_boundaries(arr): Finds the length of the longest run and the list of run-boundaries in the given array. A run is defined as a contiguous subsequence of the same number appearing multiple times in sequence. A run-boundary is the index position where a new run starts. Parameters: arr (List[int]): The input array of integers. Returns: tuple: A tuple containing the length of the longest run and the list of run-boundaries. if not arr: return 0, [] max_length = 1 current_length = 1 boundaries = [0] for i in range(1, len(arr)): if arr[i] == arr[i-1]: current_length += 1 else: if current_length > max_length: max_length = current_length current_length = 1 boundaries.append(i) if current_length > max_length: max_length = current_length return max_length, boundaries"},{"question":"Given a binary tree where each node contains an integer value, implement a class `BinaryTree` with the following methods: * `BinaryTree(TreeNode root)` - Initializes the object with the given root of the binary tree. * `int getMaxDepth()` - Returns the maximum depth of the binary tree. * `int getMinDepth()` - Returns the minimum depth of the binary tree. * `List<Integer> getLeafNodes()` - Returns a list of the values of all leaf nodes in the binary tree. A binary tree\'s depth is the number of nodes along the longest path from the root node down to the farthest leaf node. The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node. A leaf is a node with no children.","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right class BinaryTree: def __init__(self, root): self.root = root def getMaxDepth(self): def maxDepth(node): if not node: return 0 left_depth = maxDepth(node.left) right_depth = maxDepth(node.right) return max(left_depth, right_depth) + 1 return maxDepth(self.root) def getMinDepth(self): def minDepth(node): if not node: return 0 if not node.left: return minDepth(node.right) + 1 if not node.right: return minDepth(node.left) + 1 return min(minDepth(node.left), minDepth(node.right)) + 1 return minDepth(self.root) def getLeafNodes(self): def leafNodes(node): if not node: return [] if not node.left and not node.right: return [node.value] return leafNodes(node.left) + leafNodes(node.right) return leafNodes(self.root)"},{"question":"You are given a **0-indexed** integer array `nums` of length `n`, and an integer `k`. You want to split the array into exactly `k` non-empty subarrays, and compute the **sum of the maximum element** from each subarray. Return _the **maximum** possible value of the sum_. A **subarray** is a contiguous portion of an array.","solution":"def max_sum_of_k_subarrays(nums, k): Returns the maximum possible value of the sum of the maximum element from each subarray when split into exactly k subarrays. n = len(nums) # Special case: If k equals the length of the list if k == n: return sum(nums) # Use dynamic programming to keep track of the max values dp = [[0] * (k + 1) for _ in range(n)] for i in range(n): dp[i][1] = max(nums[:i+1]) for subarray_count in range(2, k + 1): for i in range(subarray_count - 1, n): current_max, max_sum = float(\'-inf\'), float(\'-inf\') for j in range(i, subarray_count - 2, -1): current_max = max(current_max, nums[j]) max_sum = max(max_sum, (dp[j-1][subarray_count-1] if j > 0 else 0) + current_max) dp[i][subarray_count] = max_sum return dp[n-1][k]"},{"question":"Given an integer array `nums` and an integer `target`, return _the number of non-empty **subsequences** of `nums` that sum to `target`_. A subsequence is a sequence that can be derived from an array by deleting some or no elements without changing the order of the remaining elements. For example, given `nums = [1, 2, 3]` and `target = 3`, the subsequences that sum to 3 are `[1, 2]` and `[3]`, so the output would be `2`. Write a function that returns the count of such subsequences.","solution":"from itertools import combinations def count_subsequences(nums, target): Returns the number of non-empty subsequences of nums that sum to target. :param nums: List[int] :param target: int :returns: int count = 0 n = len(nums) # Check all subsequences of all lengths for r in range(1, n+1): for combo in combinations(nums, r): if sum(combo) == target: count += 1 return count"},{"question":"You are given a string `s` representing a sentence consisting of words separated by spaces. Each word can be reassigned a unique integer value based on its length, with the smallest word assigned to 1, the next smallest to 2, and so on. However, if multiple words have the same length, they all receive the same value. Your task is to return the sum of the values of all the words in the sentence. For example, given the sentence \\"this is a test\\", the word \\"a\\" would have a value of 1 because it is the shortest, while \\"is\\" would have a value of 2, and \\"this\\" and \\"test\\" would share a value of 3 as they are the longest words in the sentence. The total sum would be 1 + 2 + 3 + 3 = 9. Write a function to calculate this sum.","solution":"def calculate_word_values_sum(s): Calculate the sum of word values based on their lengths in the sentence. # Split the sentence into words words = s.split() # Sort the words by their length sorted_words = sorted(words, key=len) # Assign values to each word word_lengths = {} current_length_value = 0 last_length = -1 for word in sorted_words: word_length = len(word) if word_length != last_length: current_length_value += 1 last_length = word_length word_lengths[word] = current_length_value # Calculate the sum of values for all words result_sum = sum(word_lengths[word] for word in words) return result_sum"},{"question":"Given a string `s` which consists of lowercase English letters and brackets. The string aims to encode a nested mathematical expression where the characters represent variables and brackets represent the scope of expressions. You need to find the maximum depth of the nested brackets in the string `s`. The depth of brackets refers to the maximum number of nested pairs of brackets. Return the maximum depth of nested brackets in `s`.","solution":"def max_depth(s): Returns the maximum depth of nested brackets in the string s. max_depth = 0 current_depth = 0 for char in s: if char == \'(\': current_depth += 1 if current_depth > max_depth: max_depth = current_depth elif char == \')\': current_depth -= 1 return max_depth"},{"question":"Given a non-negative integer `n`, generate a list of all **self-dividing numbers** between 1 and `n` (inclusive). A **self-dividing number** is a number that is divisible by every digit it contains. For example, 128 is a self-dividing number because 128 % 1 == 0, 128 % 2 == 0, and 128 % 8 == 0. Note that `0` is not a self-dividing number. Return the list of self-dividing numbers in ascending order.","solution":"def is_self_dividing(num): Check if a number is self-dividing. original_num = num while num > 0: digit = num % 10 if digit == 0 or original_num % digit != 0: return False num //= 10 return True def self_dividing_numbers(n): Generate a list of all self-dividing numbers between 1 and n (inclusive). result = [] for i in range(1, n + 1): if is_self_dividing(i): result.append(i) return result"},{"question":"You are given an unsorted array `nums` of `n` integers, where `n > 1`. Return _the length of the longest increasing subsequence_. A **subsequence** is a sequence that can be derived from another sequence by deleting some or no elements without changing the order of the remaining elements. For example, given the input `nums = [10, 9, 2, 5, 3, 7, 101, 18]`, the longest increasing subsequence is `[2, 3, 7, 101]`, so the length is `4`.","solution":"def length_of_lis(nums): Returns the length of the longest increasing subsequence in the given list. if not nums: return 0 n = len(nums) dp = [1] * n for i in range(1, n): for j in range(i): if nums[i] > nums[j]: dp[i] = max(dp[i], dp[j] + 1) return max(dp)"},{"question":"Given an integer array `arr` and an integer `d`, you can perform the following operation on the array at most once: choose any subarray of `arr` and increment each element of that subarray by 1. Return the maximum possible sum of the array that can be obtained by performing this operation. If no operation is performed, return the sum of the original array.","solution":"def max_sum_with_operation(arr, d): Returns maximum possible sum of the array after optionally incrementing a subarray\'s elements by `d`. Parameters: arr (list of int): The array of integers. d (int): The increment value. Returns: int: The maximum possible sum of the array. n = len(arr) current_sum = sum(arr) if d <= 0: return current_sum max_increment = 0 for start in range(n): increment_sum = 0 for end in range(start, n): increment_sum += d max_increment = max(max_increment, increment_sum) return current_sum + max_increment"},{"question":"Design a class that allows the addition of a stream of integers and calculates the median of all integers seen so far. Implement the `MedianFinder` class: * `MedianFinder()` initializes the data structure. * `void addNum(int num)` adds the integer `num` to the data stream. * `double findMedian()` returns the median of all integers added so far.","solution":"import heapq class MedianFinder: def __init__(self): Initializes the MedianFinder object. # max heap to store the smaller half of the numbers self.small = [] # min heap to store the larger half of the numbers self.large = [] def addNum(self, num: int): Adds an integer num to the data stream. # Add to max heap (largest of the small half) heapq.heappush(self.small, -num) # Balance the heaps by ensuring that every number in the large heap # is greater than every number in the small heap if self.small and self.large and (-self.small[0] > self.large[0]): heapq.heappush(self.large, -heapq.heappop(self.small)) # Balance the sizes of the two heaps if len(self.small) > len(self.large) + 1: heapq.heappush(self.large, -heapq.heappop(self.small)) if len(self.large) > len(self.small): heapq.heappush(self.small, -heapq.heappop(self.large)) def findMedian(self) -> float: Finds and returns the median of all integers added so far. # If both heaps are of equal size, the median is the average of the two middle elements if len(self.small) == len(self.large): return (-self.small[0] + self.large[0]) / 2.0 # If the heaps are of unequal size, the median is the middle element else: return -self.small[0]"},{"question":"You are given an integer array `arr` and an integer `target`. Your task is to find if there are three distinct elements in `arr` whose sum is equal to `target`. Write a function that returns `true` if there exist three such numbers, otherwise return `false`. The function should aim to have a time complexity better than O(n^3). For example, given `arr = [1, 2, 3, 4, 5]` and `target = 9`, the function will return `true` because the numbers `[1, 3, 5]` sum up to `9`.","solution":"def three_sum(arr, target): Checks whether there are three distinct elements in arr whose sum equals target. arr.sort() n = len(arr) for i in range(n-2): left = i + 1 right = n - 1 while left < right: s = arr[i] + arr[left] + arr[right] if s == target: return True elif s < target: left += 1 else: right -= 1 return False"},{"question":"Implement the `CustomQueue` class that simulates a queue-like structure while supporting range sum queries. The class should support the following operations: * `CustomQueue(int capacity)` - Initializes the queue with a fixed capacity. * `void enqueue(int value)` - Adds the `value` to the end of the queue if it is not full. If the queue is full, the operation is ignored. * `int dequeue()` - Removes the element from the front of the queue and returns it. If the queue is empty, return `-1`. * `int rangeSum(int start, int end)` - Returns the sum of the elements in the queue from index `start` to index `end` inclusive. If the indices are out of range, return `-1`. For example, if the queue has a capacity of 3, after enqueuing the elements `[1, 2, 3]`, `rangeSum(0, 2)` should return `6`, and `dequeue()` should return `1`.","solution":"class CustomQueue: def __init__(self, capacity): self.capacity = capacity self.queue = [] def enqueue(self, value): if len(self.queue) < self.capacity: self.queue.append(value) def dequeue(self): if self.queue: return self.queue.pop(0) return -1 def rangeSum(self, start, end): if 0 <= start <= end < len(self.queue): return sum(self.queue[start:end+1]) return -1"},{"question":"Given a string `s` consisting of only the characters \'a\' and \'b\', you are allowed to remove any number of characters from the string. Construct the lexicographically smallest string possible by removing characters. Return the resultant string after making the optimal removals.","solution":"def lexicographically_smallest_string(s): Returns the lexicographically smallest string by removing any number of characters from the input string. # Only keep \'a\', as \'a\' is smaller than \'b\'. return \'\'.join(char for char in s if char == \'a\')"},{"question":"You are tasked with creating a function that simulates a simple file system. Implement a class `FileSystem` that initially has a single directory `/`. The class should support the following methods: - `void createPath(String path, int value)`: Creates a new path and assigns a value to it. You can assume that the path is valid and doesn\'t exist yet, and that the parent path already exists. - `int get(String path)`: Returns the value associated with the given path, or -1 if the path doesn\'t exist. Example: - `fs.createPath(\\"/a\\", 1)` - Creates a path \\"/a\\" and assigns it the value 1. - `fs.get(\\"/a\\")` - Returns 1. - `fs.get(\\"/b\\")` - Returns -1. Implement the `FileSystem` class and its methods to provide the described functionality.","solution":"class FileSystem: def __init__(self): self.paths = {\'/\': -1} # Initialize the root directory with value -1 def createPath(self, path: str, value: int): # Ensure the parent path exists and doesn\'t end with a slash parent = \'/\'.join(path.split(\'/\')[:-1]) if parent == \'\': parent = \'/\' if parent in self.paths: self.paths[path] = value def get(self, path: str) -> int: return self.paths.get(path, -1)"},{"question":"You are given a circular **n-indexed** integer array `nums` where the index starts from `0` and ends at `n-1`. The circular aspect means the array wraps around, so the element following the last element is the first element again. Your task is to identify the length of the longest subarray where the sum of the subarray is strictly less than a given integer `k`. Return _the length of the longest subarray with the sum less than_ `k`. If no such subarray exists, return `0`.","solution":"def longest_subarray(nums, k): Returns the length of the longest subarray where the sum is strictly less than k. n = len(nums) max_length = 0 for start in range(n): current_sum = 0 for length in range(1, n+1): current_sum += nums[(start + length - 1) % n] if current_sum >= k: break max_length = max(max_length, length) return max_length"},{"question":"You are given a 2D grid of size `m x n` representing a map where `1` represents land and `0` represents water. You are also given an integer `k`. You must place `k` bridges on the grid. Each bridge can be placed between any two adjacent land cells (horizontally or vertically) to connect them. A bridge can also connect a land cell with water, turning the water cell into land. Return _the maximum number of land cells you can obtain on the grid after placing exactly `k` bridges._","solution":"def max_land_cells(grid, k): Returns the maximum number of land cells after placing k bridges. m, n = len(grid), len(grid[0]) def dfs(x, y): if x < 0 or x >= m or y < 0 or y >= n or visited[x][y] or grid[x][y] == 0: return 0 visited[x][y] = True land = 1 land += dfs(x + 1, y) land += dfs(x - 1, y) land += dfs(x, y + 1) land += dfs(x, y - 1) return land # Find all land cells initially connected and their sizes visited = [[False for _ in range(n)] for _ in range(m)] land_sizes = [] for i in range(m): for j in range(n): if grid[i][j] == 1 and not visited[i][j]: size = dfs(i, j) land_sizes.append(size) # Sort the land size in descending order land_sizes.sort(reverse=True) # Calculate the initial number of land cells initial_land_cells = sum(land_sizes) # Add k to the initial land areas max_land = initial_land_cells + k return min(max_land, m * n)"},{"question":"You are given an array of integers `nums` and an integer `k`. In one move, you can select any element of `nums` and increase or decrease it by 1. Return the minimum number of moves required to make all the elements of `nums` equal, provided that you can perform at most `k` moves on any single element.","solution":"def min_moves(nums, k): Returns the minimum number of moves required to make all the elements of nums equal, with the constraint that we can perform at most k moves on any single element. # Find the median of the sorted array nums_sorted = sorted(nums) median = nums_sorted[len(nums_sorted) // 2] # Calculate the move count by the difference with the median move_count = sum(abs(num - median) for num in nums_sorted) # Ensure we do not exceed the individual move limit `k` if move_count > k * len(nums): return -1 return move_count"},{"question":"Given an integer array `nums` of length `n`, where `n` is always even, partition the array into two subsets such that the difference of their sums is as small as possible. Each element in `nums` must be included in exactly one of the two subsets. Return _the minimum possible difference of the sums of the two subsets_.","solution":"from itertools import combinations def minimum_difference(nums): Given a list of integers \'nums\' with even length, partition the list into two subsets such that the difference of their sums is as small as possible and return the minimum possible difference of the sums of the two subsets. total_sum = sum(nums) n = len(nums) // 2 all_combinations = combinations(nums, n) min_diff = float(\'inf\') for comb in all_combinations: subset_sum = sum(comb) other_subset_sum = total_sum - subset_sum diff = abs(subset_sum - other_subset_sum) min_diff = min(min_diff, diff) return min_diff"},{"question":"Given a binary tree, return the **leftmost value** in the last row of the tree. The leftmost value is defined as the value of the leftmost node at the bottom row of the tree. If there are multiple nodes at the last row, return the value of the leftmost one. The tree is non-empty and each node in the tree has an integer value.","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def find_bottom_left_value(root): Find the leftmost value in the last row of the binary tree. if not root: return None from collections import deque queue = deque([root]) leftmost_value = root.val while queue: num_nodes = len(queue) for i in range(num_nodes): node = queue.popleft() if i == 0: leftmost_value = node.val if node.left: queue.append(node.left) if node.right: queue.append(node.right) return leftmost_value"},{"question":"You are given an array of integers `nums` where each integer appears exactly twice, except for one integer which appears exactly once. Implement a function to find the integer that appears only once in the array. The solution should have a linear runtime complexity and use only constant extra space. Return _the integer that appears only once_. **Example:** ``` Input: nums = [4, 1, 2, 1, 2] Output: 4 ``` **Constraints:** * `1 <= nums.length <= 10^5` * `-3 * 10^4 <= nums[i] <= 3 * 10^4` * Each element appears twice except for one element which appears only once.","solution":"def singleNumber(nums): Returns the integer that appears exactly once in the list nums. unique_number = 0 for num in nums: unique_number ^= num return unique_number"},{"question":"A cylindrical container has a height `h` and a circular base with a radius `r`. You are tasked with creating a function that calculates the remaining volume of liquid in the container when it is tilted at an angle `θ` from its upright position. The function should take three arguments: `h` (height), `r` (radius), and `θ` (tilt angle in degrees). The volume of liquid is initially equal to the volume of the container when it is upright and fully filled. Return the remaining volume of liquid in the container when it is tilted by `θ` degrees. You can assume the density of the liquid is uniform, and the container is large enough so that the liquid won\'t spill out when tilted.","solution":"import math def remaining_volume(h, r, theta): Calculate the remaining volume of liquid in a cylindrical container when it is tilted. Parameters: h (float): Height of the cylinder r (float): Radius of the cylinder base theta (float): Tilt angle in degrees Returns: float: Remaining volume of liquid in the container # Calculate the volume of the cylinder volume = math.pi * r * r * h return volume"},{"question":"You are given a string `s` representing a list of words separated by spaces. All the words in the string are in lower case and are at least one character long. Write a function to return the word with the highest frequency. In case of a tie, return the lexicographically smallest word.","solution":"def most_frequent_word(s): Returns the most frequent word in the string s. In case of a tie, returns the lexicographically smallest word. words = s.split() word_count = {} for word in words: if word in word_count: word_count[word] += 1 else: word_count[word] = 1 # Find the word with the highest frequency max_frequency = max(word_count.values()) # Filter words by max frequency and return the lexicographically smallest one candidates = [word for word, count in word_count.items() if count == max_frequency] return min(candidates)"},{"question":"You are working on a function to handle reservations for a conference room. Implement the `ConferenceRoom` class which supports two operations: * `ConferenceRoom()` Initializes the reservation system. * `boolean reserve(int start, int end)` Reserves the conference room for a meeting from `start` time to `end` time (half-open interval `[start, end)`). Returns `true` if the room can be reserved without any conflicts during the requested time interval. Otherwise, return `false` without making the reservation. Note that two meetings cannot use the room at the same time.","solution":"class ConferenceRoom: def __init__(self): Initializes the reservation system. self.reservations = [] def reserve(self, start, end): Reserves the conference room for a meeting from start time to end time (half-open interval [start, end]). Returns True if the room can be reserved without any conflicts, otherwise returns False. for reserved_start, reserved_end in self.reservations: if not (end <= reserved_start or start >= reserved_end): return False self.reservations.append((start, end)) return True"},{"question":"Given a matrix `mat` of size `n x m` consisting of non-negative integers, return the maximum sum of a submatrix with a size of `k x k`. If such submatrix does not exist, return 0. Implement the function `maxSumSubmatrix` which takes in the matrix `mat`, and the integer `k`, and returns the maximum sum of the specified submatrix size.","solution":"def maxSumSubmatrix(mat, k): Returns the maximum sum of a k x k submatrix within the given matrix \'mat\'. If such submatrix does not exist, return 0. n = len(mat) if n == 0: return 0 m = len(mat[0]) if k > n or k > m: return 0 max_sum = 0 for i in range(n - k + 1): for j in range(m - k + 1): current_sum = 0 for p in range(i, i + k): for q in range(j, j + k): current_sum += mat[p][q] max_sum = max(max_sum, current_sum) return max_sum"},{"question":"You are given a singly linked list where each node contains a single digit from 0 to 9. The digits are stored such that the most significant digit is at the head of the list. Write a function to add two such linked lists and return the resulting singly linked list, where the most significant digit is again at the head of the list. The function should return the sum of the two numbers as a linked list in the same format.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def add_two_numbers(l1, l2): # Helper function to reverse a LinkedList def reverse_list(head): prev = None current = head while current: next_node = current.next current.next = prev prev = current current = next_node return prev # Helper function to add two reversed linked lists def add_reversed_lists(l1, l2): dummy_head = ListNode(0) current = dummy_head carry = 0 while l1 or l2 or carry: val1 = l1.val if l1 else 0 val2 = l2.val if l2 else 0 sum_val = val1 + val2 + carry carry = sum_val // 10 new_node = ListNode(sum_val % 10) current.next = new_node current = new_node if l1: l1 = l1.next if l2: l2 = l2.next return dummy_head.next # Reverse both lists to simplify addition l1_reversed = reverse_list(l1) l2_reversed = reverse_list(l2) # Add reversed lists result_reversed = add_reversed_lists(l1_reversed, l2_reversed) # Reverse the result back to correct order result = reverse_list(result_reversed) return result"},{"question":"You are given a list of **tasks** represented by strings, where each string corresponds to the name of a task. You are also given a positive integer `n` that represents the cooling interval between two same tasks. Each task must wait for `n` intervals before being executed again. The intervals can be used to execute other tasks or remain idle. Return _the minimum number of intervals needed to execute all tasks_. Example: Input: tasks = [\\"A\\", \\"A\\", \\"A\\", \\"B\\", \\"B\\", \\"C\\"], n = 2 Output: 7 Explanation: One possible order of execution is: \\"A\\", \\"B\\", \\"C\\", \\"A\\", \\"B\\", \\"idle\\", \\"A\\". Implement the `TaskScheduler` class: * `TaskScheduler()` Initializes the object with the list of tasks and the cooling interval `n`. * `int leastInterval()` Returns the minimum number of intervals needed to execute all tasks.","solution":"from collections import Counter class TaskScheduler: def __init__(self, tasks, n): Initializes the TaskScheduler with tasks and cooling interval n. Args: tasks: List of strings where each string is a task. n: Integer representing the cooling interval. self.tasks = tasks self.n = n def leastInterval(self): Returns the minimum number of intervals needed to execute all tasks. task_counts = Counter(self.tasks) max_count = max(task_counts.values()) max_count_tasks = sum(1 for count in task_counts.values() if count == max_count) part_count = max_count - 1 part_length = self.n - (max_count_tasks - 1) empty_slots = part_count * part_length available_tasks = len(self.tasks) - (max_count * max_count_tasks) idles = max(0, empty_slots - available_tasks) return len(self.tasks) + idles"},{"question":"You are given a list of `n` tasks, numbered from `0` to `n-1`, represented by a list of their durations `tasks` where `tasks[i]` is the duration of the `i-th` task. You are also given an integer `k`, which is the number of workers available to complete these tasks. Each worker can work on exactly one task at a time and the tasks take their respective durations to finish. Return the minimum time required to complete all tasks if you can assign each of the `k` workers to any of the tasks optimally.","solution":"import heapq def min_time_to_complete_tasks(tasks, k): Returns the minimum time required to complete all tasks with k workers. :param tasks: List of task durations. :param k: Number of workers. :return: Minimum time required to complete all tasks. if k == 0: raise ValueError(\\"Number of workers must be greater than 0.\\") workers = [0] * k heapq.heapify(workers) for task in tasks: min_worker = heapq.heappop(workers) min_worker += task heapq.heappush(workers, min_worker) return max(workers)"},{"question":"You are given a string `s` consisting of lower case English letters that you need to encrypt. The encryption process involves rearranging each letter in the string such that no two adjacent letters are the same. If it is impossible to rearrange the string in such a way, return an empty string. Otherwise, return the rearranged string.","solution":"import heapq from collections import Counter def rearrange_string(s): counter = Counter(s) max_heap = [(-count, char) for char, count in counter.items()] heapq.heapify(max_heap) prev_count, prev_char = 0, \'\' result = [] while max_heap: count, char = heapq.heappop(max_heap) result.append(char) if prev_count < 0: heapq.heappush(max_heap, (prev_count, prev_char)) prev_count, prev_char = count + 1, char if len(result) != len(s): return \\"\\" return \\"\\".join(result)"},{"question":"You are given a matrix `grid` of size `m x n` consisting of only non-negative integers and an integer `k`. You are allowed to perform a series of operations to `grid` where in each operation you can increment any element of `grid` by `1`. Return _the **minimum** number of operations required to make every element of `grid` divisible by `k`_.","solution":"def min_operations_to_divisible(grid, k): m, n = len(grid), len(grid[0]) operations = 0 for i in range(m): for j in range(n): remainder = grid[i][j] % k if remainder != 0: operations += min(remainder, k - remainder) return operations"},{"question":"You are given an array of integers `nums` sorted in non-decreasing order, and an integer `target`. Return _the **index** of the first occurrence of_ `target` _in_ `nums`. _If_ `target` _is not present, return_ `-1`.","solution":"def find_first_occurrence(nums, target): Returns the index of the first occurrence of target in nums. If target is not present, returns -1. left, right = 0, len(nums) - 1 while left <= right: mid = (left + right) // 2 if nums[mid] < target: left = mid + 1 elif nums[mid] > target: right = mid - 1 else: if mid == 0 or nums[mid - 1] != target: return mid right = mid - 1 return -1"},{"question":"Given a 2-dimensional integer matrix where each element represents the cost of a cell in a grid, you are initially positioned at the top-left corner of the grid. You can only move right or down from a cell. Write a function to return the minimum cost path sum to reach the bottom-right corner of the grid.","solution":"def min_cost_path(matrix): Returns the minimum cost path sum to reach the bottom-right corner of the grid. Parameters: matrix (list of list of int): 2D grid where each element represents the cost of a cell Returns: int: Minimum cost path sum if not matrix or not matrix[0]: return 0 rows = len(matrix) cols = len(matrix[0]) dp = [[0 for _ in range(cols)] for _ in range(rows)] dp[0][0] = matrix[0][0] for i in range(1, rows): dp[i][0] = dp[i-1][0] + matrix[i][0] for j in range(1, cols): dp[0][j] = dp[0][j-1] + matrix[0][j] for i in range(1, rows): for j in range(1, cols): dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + matrix[i][j] return dp[rows-1][cols-1]"},{"question":"Given an integer array `arr` consisting of `n` positive integers and an integer `d`, find the number of distinct pairs `(i, j)` (where `i < j`) such that the absolute difference between `arr[i]` and `arr[j]` is equal to `d`. Return the total count of such pairs.","solution":"def count_pairs_with_difference(arr, d): Returns the count of distinct pairs (i, j) such that the absolute difference between arr[i] and arr[j] is equal to d. n = len(arr) count = 0 seen = {} for num in arr: count += seen.get(num - d, 0) + seen.get(num + d, 0) seen[num] = seen.get(num, 0) + 1 return count"},{"question":"You are given a grid of size `m x n` consisting of non-negative integers where `grid[i][j]` represents the height of the structure at that point `(i, j)`. You are also given an integer `k`. A path from the top-left to the bottom-right corner of the grid is defined as a sequence of points `[(0, 0), (1,0), ..., (m-1, n-1)]` where you can move either downwards or rightwards. The cost of a path is defined as the largest height difference between two consecutive points along the path. Return _the minimum possible path cost to reach the bottom-right corner from the top-left corner with the given constraint `k`_, where you can remove up to `k` barriers (change the height of `k` points to 0) to minimize the path cost.","solution":"from heapq import heappop, heappush def min_path_cost_with_removal(grid, k): Returns the minimum possible path cost to reach bottom-right corner from top-left corner with the ability to remove up to k barriers. m, n = len(grid), len(grid[0]) directions = [(0, 1), (1, 0)] # Priority queue: (current max height difference, x, y, barriers removed) pq = [(0, 0, 0, 0)] visited = {(0, 0): 0} while pq: current_cost, x, y, barriers_removed = heappop(pq) if x == m - 1 and y == n - 1: return current_cost for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n: new_cost = max(current_cost, abs(grid[nx][ny] - grid[x][y])) if barriers_removed < k: if (nx, ny) not in visited or visited[(nx, ny)] > barriers_removed + 1: visited[(nx, ny)] = barriers_removed + 1 heappush(pq, (current_cost, nx, ny, barriers_removed + 1)) if (nx, ny) not in visited or visited[(nx, ny)] > barriers_removed: visited[(nx, ny)] = barriers_removed heappush(pq, (new_cost, nx, ny, barriers_removed)) return float(\'inf\') # In case there is no valid path"},{"question":"You are given an array of integers `nums` and a target integer `target`. An array is called a **good segment** if the sum of its elements is less than or equal to `target`. Your task is to find the number of **good segments** in the array. A **segment** is defined as a contiguous subarray of `nums` of any length. Return the number of good segments in `nums`.","solution":"def count_good_segments(nums, target): Returns the number of good segments in the array nums such that the sum of elements in the segment is less than or equal to target. count = 0 for start in range(len(nums)): current_sum = 0 for end in range(start, len(nums)): current_sum += nums[end] if current_sum <= target: count += 1 else: break return count"},{"question":"Given an integer array `arr` representing the state of `n` bulbs, where `arr[i] = 1` means the `i`-th bulb is on and `arr[i] = 0` means the `i`-th bulb is off, you are tasked to perform a sequence of operations to toggle the state of the bulbs. The operations are defined as follows: - You have a **button** which, when pressed, toggles the state of every `k`-th bulb (i.e., bulbs at indices `k, 2k, 3k, ...`). Note that the indices start from `1`. Given the initial state of the bulbs and the value of `k`, return _the final state of the bulbs after pressing the button exactly once_. For example, given `arr = [0, 1, 0, 1, 1]` and `k = 2`, pressing the button once will toggle the 2nd, 4th, and so on bulbs\' state, resulting in `[0, 0, 0, 0, 1]`. Return the array representing the final state of the bulbs.","solution":"def toggle_bulbs(arr, k): Toggles the state of every k-th bulb in the array. Args: - arr (list of int): The initial state of the bulbs. - k (int): The step size for toggling bulbs. Returns: - list of int: The final state of the bulbs. # Create a copy of the array to avoid modifying the original array final_state = arr.copy() # Toggle every k-th bulb\'s state for i in range(k - 1, len(arr), k): final_state[i] = 0 if final_state[i] == 1 else 1 return final_state"},{"question":"You are given a string `s` consisting of lowercase English letters. A **partition** of `s` is a split in which `s` is divided into several substrings. A partition is called **valid** if each substring has all its characters the same. Return _the minimum number of cuts needed to partition `s` into valid substrings_.","solution":"def min_cuts_for_valid_partition(s): Returns the minimum number of cuts needed to partition s into valid substrings. n = len(s) if n == 0: return 0 cuts = 0 i = 0 while i < n: j = i + 1 # Find the extent of the valid substring with same characters while j < n and s[j] == s[i]: j = j + 1 cuts += 1 # Add a cut after the valid substring i = j # Move to the next part of the string return cuts - 1 # Cuts will be one more than needed partitions"},{"question":"Given an integer array `arr` of length `n` and an integer `d`, you need to perform the following operation exactly `d` times: select any element at an even index, swap it with the element immediately next to it (which would be at an odd index). If there is no element next to the even index element (i.e., if it is the last element in the array and its index is even), avoid making a move. Return _the lexicographically smallest array possible_ after performing the operation exactly `d` times. (Note: An array `a` is lexicographically smaller than an array `b` if at the first position `i` where `a` and `b` differ, array `a` has a smaller element than the corresponding element in array `b`.)","solution":"def lexicographically_smallest_array(arr, d): n = len(arr) def perform_swap(): for i in range(0, n - 1, 2): if arr[i] > arr[i + 1]: arr[i], arr[i + 1] = arr[i + 1], arr[i] # Perform the swap operation exactly `d` times for _ in range(d): perform_swap() return arr"},{"question":"Imagine you are designing a **document management system** where each `Document` is a collection of **pages** and each `page` is represented by a **string** of characters. You need to implement the `DocumentManager` class to handle multiple documents, where each document can be of variable length. The `DocumentManager` class should support the following operations: * `int createDocument(String[] pages)`: This method creates a new document with the given pages. Each page in the document is a string of characters. Return the `documentId` associated with the newly created document. Document IDs should be assigned starting from `0` and increment sequentially. * `void deleteDocument(int documentId)`: This method deletes the document associated with the `documentId`. If the `documentId` does not exist, do nothing. * `String getPage(int documentId, int pageIndex)`: This method returns the page at the specified `pageIndex` from the document associated with `documentId`. If the `documentId` or `pageIndex` is invalid, return `null`. * `boolean updatePage(int documentId, int pageIndex, String newPageContent)`: This method updates the content of the specified page in the document associated with `documentId` to `newPageContent`. If the update is successful, return `true`; otherwise, return `false`. * `int getDocumentLength(int documentId)`: This method returns the number of pages in the document associated with `documentId`. If the `documentId` does not exist, return `-1`.","solution":"class DocumentManager: def __init__(self): self.documents = {} self.next_document_id = 0 def createDocument(self, pages): document_id = self.next_document_id self.documents[document_id] = pages self.next_document_id += 1 return document_id def deleteDocument(self, documentId): if documentId in self.documents: del self.documents[documentId] def getPage(self, documentId, pageIndex): if documentId in self.documents and 0 <= pageIndex < len(self.documents[documentId]): return self.documents[documentId][pageIndex] return None def updatePage(self, documentId, pageIndex, newPageContent): if documentId in self.documents and 0 <= pageIndex < len(self.documents[documentId]): self.documents[documentId][pageIndex] = newPageContent return True return False def getDocumentLength(self, documentId): if documentId in self.documents: return len(self.documents[documentId]) return -1"},{"question":"You are given an array of integers `nums` and an integer `k`. In one operation you can remove the last element of the array and add it to the beginning, or remove the first element and add it to the end. Your goal is to make the array sorted in non-decreasing order using exactly `k` or fewer operations. Return `true` if it is possible to achieve this, and `false` otherwise.","solution":"def can_be_sorted_with_k_operations(nums, k): Determines if the array can be sorted in non-decreasing order with exactly k or fewer operations. n = len(nums) # Check if already sorted if nums == sorted(nums): return True # Generate all possible rotations for i in range(n): rotated = nums[-i:] + nums[:-i] if rotated == sorted(nums): return True if i <= k else False return False"},{"question":"You are given a string `s` and an integer `k`. You need to split the string into **k** contiguous strings such that the length of the longest string is minimized. Return _the length of the minimized longest string after splitting_. For example, if `s = \\"abcdefghij\\"` and `k = 3`, one possible way to split it is into `[\\"abc\\", \\"def\\", \\"ghij\\"]`, making the length of the longest string `4`.","solution":"def minimize_longest_split_length(s, k): Splits the string `s` into `k` contiguous strings such that the length of the longest string is minimized. Args: s (str): The input string to be split. k (int): The number of splits. Returns: int: The length of the minimized longest string after splitting. def can_split(mid): count = 1 current_length = 0 for char in s: if current_length + 1 > mid: count += 1 current_length = 0 current_length += 1 return count <= k left, right = max(len(s) // k, len(s) % k), len(s) while left < right: mid = (left + right) // 2 if can_split(mid): right = mid else: left = mid + 1 return left"},{"question":"You are given a 2D integer matrix `mat` where each cell contains either a `0` or a `1`. A square submatrix is a contiguous submatrix of size `k x k` for any integer `k`. Return the size `k` of the largest square submatrix of `1`s present in the given matrix. If no such submatrix exists, return `0`.","solution":"def largest_square_submatrix(mat): if not mat or not mat[0]: return 0 rows, cols = len(mat), len(mat[0]) dp = [[0] * cols for _ in range(rows)] max_size = 0 for i in range(rows): for j in range(cols): if mat[i][j] == 1: if i == 0 or j == 0: dp[i][j] = 1 else: dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1 max_size = max(max_size, dp[i][j]) return max_size"},{"question":"Create a data structure that simulates an express queue system in a movie theater. Customers are served based on the order they arrive, but VIPs can jump to the front of the queue. Implement the `ExpressQueue` class: * `ExpressQueue()` Initializes the object with an empty queue. * `void joinQueue(int customerId)` Adds a customer with the specified `customerId` to the end of the queue. * `void joinVIPQueue(int customerId)` Adds a VIP customer with the specified `customerId` to the front of the queue, but behind any existing VIP customers. * `int serveNext()` Serves the next customer and returns the `customerId`. If no customers are in the queue, return `-1`. * `int[] queueStatus()` Returns a list of all customers currently in the queue, ordered from front to back.","solution":"from collections import deque class ExpressQueue: def __init__(self): self.queue = deque() self.vip_count = 0 def joinQueue(self, customerId): self.queue.append(customerId) def joinVIPQueue(self, customerId): self.queue.insert(self.vip_count, customerId) self.vip_count += 1 def serveNext(self): if not self.queue: return -1 customer_id = self.queue.popleft() if self.vip_count > 0: self.vip_count -= 1 return customer_id def queueStatus(self): return list(self.queue)"},{"question":"Given a string `s` and an integer `k`, such that the string can be partitioned into exactly `k` non-empty substrings, return _the maximum possible sum of the lengths of distinct characters in each substring_. If it is not possible to partition the string into `k` substrings, return `-1`.","solution":"def max_distinct_chars_sum(s, k): Returns the maximum possible sum of the lengths of distinct characters in each substring after partitioning the input string `s` into `k` non-empty substrings. If it is not possible to partition the string into `k` substrings, return -1. n = len(s) if n < k: return -1 # Initialize the distinct character counts for each possible partition partitions = [0] * k distinct_chars = set() # Count distinct characters in the entire string for char in s: distinct_chars.add(char) if len(distinct_chars) < k: return -1 # Initialize a list to hold distinct characters for each partition partition_chars = [set() for _ in range(k)] index = 0 for char in s: while char in partition_chars[index]: index = (index + 1) % k partition_chars[index].add(char) # Sum up the lengths of distinct characters in each partition max_sum = sum(len(part) for part in partition_chars) return max_sum"},{"question":"You are given an integer array `arr` and an integer `k`. Your task is to find the `k`-th distinct element in the array, considering elements are taken in the order they appear in the array. If there are fewer than `k` distinct elements, return `-1`.","solution":"def kth_distinct(arr, k): Returns the k-th distinct element in the array. If there are fewer than k distinct elements, return -1. from collections import OrderedDict # Create an ordered dictionary to maintain the order of elements count = OrderedDict() # Count occurrences of each element for num in arr: if num in count: count[num] += 1 else: count[num] = 1 # Filter distinct elements and create a list with their order distinct_elements = [num for num, cnt in count.items() if cnt == 1] # Return the k-th distinct element if it exists if k-1 < len(distinct_elements): return distinct_elements[k-1] else: return -1"},{"question":"You are tasked with implementing a data structure that efficiently handles a dynamic list of strings, providing operations to add, retrieve, and search for strings by a given prefix. Implement the `StringList` class: * `StringList()` Initializes an empty list of strings. * `void add(String word)` Adds the given `word` to the end of the list. * `List<String> getAll()` Returns a list containing all strings in the order they were added. * `List<String> searchByPrefix(String prefix)` Returns a list of all strings that start with the given `prefix`. The order of strings in the result list should preserve their order in the original list. Design the class and its methods to provide efficient performance for the listed operations.","solution":"class StringList: def __init__(self): self.strings = [] def add(self, word): self.strings.append(word) def getAll(self): return self.strings.copy() def searchByPrefix(self, prefix): return [s for s in self.strings if s.startswith(prefix)]"},{"question":"Given a list of integers `nums`, return a _new list containing only one occurrence of each integer, preserving the order of their first appearance in_ `nums`.","solution":"def remove_duplicates(nums): Returns a new list containing only one occurrence of each integer, preserving the order of their first appearance in nums. seen = set() result = [] for num in nums: if num not in seen: seen.add(num) result.append(num) return result"},{"question":"Given an integer array `arr`, return _the smallest positive integer that is **missing** from the array_. The array can contain duplicates and negative numbers as well. For example, given `arr = [3, 4, -1, 1]`, the function should return `2` because `1` is present in the array, but `2` is missing.","solution":"def find_missing_positive(arr): Returns the smallest positive integer missing from the array. n = len(arr) # First, segregate positive and non-positive numbers j = 0 for i in range(n): if arr[i] <= 0: arr[i], arr[j] = arr[j], arr[i] j += 1 # Now, only positive numbers remain from arr[j:n] pos_arr = arr[j:] pos_len = len(pos_arr) # Use the index (0 to pos_len-1) as a marker for i in range(pos_len): val = abs(pos_arr[i]) if val - 1 < pos_len and pos_arr[val - 1] > 0: pos_arr[val - 1] = -pos_arr[val - 1] # Finding the first positive index for i in range(pos_len): if pos_arr[i] > 0: return i + 1 return pos_len + 1"},{"question":"Given an array of integers `nums` of size `n` and an integer `k`, return the _k-th largest element in_ `nums`. You may assume that k is always valid, 1 ≤ k ≤ n.","solution":"import heapq def find_kth_largest(nums, k): Returns the k-th largest element in the array nums. return heapq.nlargest(k, nums)[-1]"},{"question":"Given an array of integers `nums`, you need to determine if it is possible to split the array into three contiguous subarrays such that the sum of each subarray is equal. If possible, return `true`; otherwise, return `false`. Note that each subarray must contain at least one element.","solution":"def can_split_into_three_equal_sum_subarrays(nums): Determines if it\'s possible to split the array into three contiguous subarrays such that the sum of each subarray is equal. total_sum = sum(nums) # If total sum is not divisible by 3, we can\'t split into 3 equal parts if total_sum % 3 != 0: return False target_sum = total_sum // 3 current_sum = 0 count = 0 for num in nums: current_sum += num if current_sum == target_sum: count += 1 current_sum = 0 if count == 3: return True return count == 3"},{"question":"Given a list of unsorted integers, write a function to find the length of the longest consecutive elements sequence. Implement the function `findLongestConsecutiveSequence` which accepts a list of integers and returns the length of the longest consecutive elements sequence. A consecutive sequence is a sequence of numbers where each number is one more than the previous number in the sequence. For example, in the list `[100, 4, 200, 1, 3, 2]`, the longest consecutive sequence is `[1, 2, 3, 4]` which has a length of 4. The algorithm should run in `O(n)` time complexity.","solution":"def findLongestConsecutiveSequence(nums): Returns the length of the longest consecutive elements sequence in the list nums. if not nums: return 0 num_set = set(nums) longest_streak = 0 for num in nums: if num - 1 not in num_set: current_num = num current_streak = 1 while current_num + 1 in num_set: current_num += 1 current_streak += 1 longest_streak = max(longest_streak, current_streak) return longest_streak"},{"question":"You are given an array of integers `nums`. An operation consists of removing any three consecutive elements from the array. Your task is to determine whether you can reduce the array to a single element by repeatedly performing this operation. Return `true` if it is possible to reduce the array to a single element, otherwise return `false`.","solution":"def can_reduce_to_one_element(nums): Determine if the array can be reduced to a single element by repeatedly removing any three consecutive elements. # Check if the length of the array is 1 or not divisible by 2 return len(nums) % 2 == 1"},{"question":"You are given an array of integers `arr` and an integer `x`. Your task is to count the number of contiguous subarrays that have a sum equal to `x`. A subarray is a contiguous part of an array, and it can be of any length (including length zero). For instance, if `arr = [1, 2, 3, 4, 5]` and `x = 5`, then the subarrays that sum to `5` are `[2, 3]` and `[5]`. Return the count of such subarrays.","solution":"def count_subarrays_with_sum(arr, x): Returns the count of contiguous subarrays that sum to x. :param arr: List of integers. :param x: The target sum. :return: Integer count of subarrays whose sum is equal to x. count = 0 current_sum = 0 sum_dict = {0: 1} # Dictionary to store sum frequencies for num in arr: current_sum += num if current_sum - x in sum_dict: count += sum_dict[current_sum - x] if current_sum in sum_dict: sum_dict[current_sum] += 1 else: sum_dict[current_sum] = 1 return count"},{"question":"In a **0-indexed** integer array `arr` of length `n`, an element `arr[i]` is said to be a **peak** if it is greater than or equal to its neighbors. Given a **rotated sorted array** `arr`, find one **peak** element. The array can be rotated any number of times. An array is considered rotated if it is possible to obtain it by rotating a sorted array any number of times (including zero times). A single rotation operation moves the last element of the array to the first position. Return _**one** peak element in the given rotated sorted array_.","solution":"def find_peak(arr): Find one peak element in the given rotated sorted array. if len(arr) == 1: return arr[0] n = len(arr) for i in range(n): prev = arr[i-1] if i > 0 else float(\'-inf\') next_ = arr[i+1] if i < n-1 else float(\'-inf\') if arr[i] >= prev and arr[i] >= next_: return arr[i] return None # This case should never be hit in a valid rotated sorted array # Example usage: # arr = [6, 7, 1, 2, 3] # print(find_peak(arr)) # Output might be 7"},{"question":"Given an array of integers that represent a series of temperature readings, return an array where, for each day in the input, the corresponding output value is the number of days until a warmer temperature. If there is no future day for which this is possible, put `0` in the corresponding output value. Implement the function `dailyTemperatures(int[] temperatures)` that returns an integer array. For example, given `temperatures = [73, 74, 75, 71, 69, 72, 76, 73]`, your function should return `[1, 1, 4, 2, 1, 1, 0, 0]`.","solution":"def dailyTemperatures(temperatures): Returns an array where each position indicates the number of days until a warmer temperature. If there is no future day with a warmer temperature, the position contains 0. n = len(temperatures) answer = [0] * n stack = [] # This will store indices for current_day in range(n): # Keep processing until we find a warmer temperature while stack and temperatures[current_day] > temperatures[stack[-1]]: previous_day = stack.pop() answer[previous_day] = current_day - previous_day stack.append(current_day) return answer"},{"question":"Design a Library Management System where users can **borrow**, **return**, and **get the current status** of books. Implement the `Library` class: * `Library()` Initializes the object. * `void addBook(int bookId, String title)` Adds a book with the given `bookId` and `title` to the library. * `void borrowBook(int userId, int bookId)` Allows a user with the given `userId` to borrow the book with the specified `bookId`. The book can be borrowed only if it is available (i.e., not already borrowed by someone else). * `void returnBook(int userId, int bookId)` Marks the book with the given `bookId` as returned by the user with the specified `userId`. * `String getBookStatus(int bookId)` Returns a string representing the current status of the book with the specified `bookId`. The possible statuses are \\"available\\" if the book is not borrowed by anyone, or \\"borrowed by User {userId}\\" if the book is currently borrowed by the user with id `userId`.","solution":"class Library: def __init__(self): self.books = {} self.borrowed_books = {} def addBook(self, bookId, title): Adds a book with the given bookId and title to the library. self.books[bookId] = title def borrowBook(self, userId, bookId): Allows a user with the given userId to borrow the book with the specified bookId. The book can be borrowed only if it is available. if bookId in self.books and bookId not in self.borrowed_books: self.borrowed_books[bookId] = userId def returnBook(self, userId, bookId): Marks the book with the given bookId as returned by the user with the specified userId. if bookId in self.borrowed_books and self.borrowed_books[bookId] == userId: del self.borrowed_books[bookId] def getBookStatus(self, bookId): Returns a string representing the current status of the book with the specified bookId. The possible statuses are \\"available\\" or \\"borrowed by User {userId}\\". if bookId not in self.books: return \\"book not found\\" if bookId in self.borrowed_books: return f\\"borrowed by User {self.borrowed_books[bookId]}\\" return \\"available\\""},{"question":"You are given a string containing digits from `2` to `9` inclusive. Each digit maps to a set of letters as follows: * `2` -> \\"abc\\" * `3` -> \\"def\\" * `4` -> \\"ghi\\" * `5` -> \\"jkl\\" * `6` -> \\"mno\\" * `7` -> \\"pqrs\\" * `8` -> \\"tuv\\" * `9` -> \\"wxyz\\" Return all possible letter combinations that the number could represent. You can return the answer in **any order**. Example: Given input `digits = \\"23\\"`, the output will be: [\\"ad\\", \\"ae\\", \\"af\\", \\"bd\\", \\"be\\", \\"bf\\", \\"cd\\", \\"ce\\", \\"cf\\"] Note that the input `digits` string contains only digits `2-9` and the length will be no more than 4 characters.","solution":"from typing import List def letter_combinations(digits: str) -> List[str]: Given a string of digits from 2-9, return all possible letter combinations the number could represent. if not digits: return [] phone_mapping = { \'2\': \'abc\', \'3\': \'def\', \'4\': \'ghi\', \'5\': \'jkl\', \'6\': \'mno\', \'7\': \'pqrs\', \'8\': \'tuv\', \'9\': \'wxyz\' } def backtrack(current_combination, next_digits): if not next_digits: combinations.append(current_combination) else: for letter in phone_mapping[next_digits[0]]: backtrack(current_combination + letter, next_digits[1:]) combinations = [] backtrack(\\"\\", digits) return combinations"},{"question":"You are given a list of `n` jobs represented by an array `jobs` where `jobs[i]` is the time it takes to complete the `i`-th job. You are also given an integer `k` that represents the number of workers available to perform these jobs. Each worker can be assigned any number of jobs, but each job must be assigned to exactly one worker. Your goal is to find the minimum possible maximum working time of any worker if it is possible to assign the jobs such that no two workers have overlapping time. Return _the minimum possible **maximum** working time of any worker_.","solution":"def minimum_time_required(jobs, k): def can_assign(jobs, k, max_time): workers_time = [0] * k def dfs(index): if index == len(jobs): return True for i in range(k): if workers_time[i] + jobs[index] <= max_time: workers_time[i] += jobs[index] if dfs(index + 1): return True workers_time[i] -= jobs[index] if workers_time[i] == 0: break return False return dfs(0) jobs.sort(reverse=True) left, right = max(jobs), sum(jobs) result = right while left <= right: mid = (left + right) // 2 if can_assign(jobs, k, mid): result = mid right = mid - 1 else: left = mid + 1 return result"},{"question":"You are given a `1-indexed` array of integers `nums`. A `triplet` `(i, j, k)` is a valid if the value in each of the three distinct indices is an odd integer and `1 <= i < j < k <= nums.length`. Return the total number of valid triplets in the array.","solution":"def count_valid_triplets(nums): Count the total number of valid triplets (i, j, k) where the values at indices i, j, k are odd and 1 <= i < j < k <= len(nums). Args: nums (list of int): 1-indexed list of integers Returns: int: Total number of valid triplets odd_indices = [index for index, value in enumerate(nums, 1) if value % 2 == 1] n = len(odd_indices) # Calculate the number of combinations of 3 items from n (n choose 3) if n < 3: return 0 return (n * (n - 1) * (n - 2)) // 6"},{"question":"Given an integer array `nums` of length `n`, where all elements are in the range from 1 to `n` inclusive, and some elements appear twice while others appear once, return an array of all the integers from 1 to `n` that do not appear in `nums`.","solution":"def find_disappeared_numbers(nums): Returns an array of all the integers from 1 to n that do not appear in nums. n = len(nums) all_nums = set(range(1, n+1)) nums_set = set(nums) return list(all_nums - nums_set)"},{"question":"Given an array of integers `nums`, you need to find two indices `i` and `j` such that the absolute difference between `nums[i]` and `nums[j]` is minimized, and `i != j`. Return the minimized absolute difference. If there are multiple pairs with the same minimized absolute difference, any one of them can be returned.","solution":"def minimized_absolute_difference(nums): Returns the minimized absolute difference between any two elements in nums. if len(nums) < 2: return None nums = sorted(nums) min_diff = float(\'inf\') for i in range(len(nums) - 1): diff = abs(nums[i] - nums[i + 1]) if diff < min_diff: min_diff = diff return min_diff"},{"question":"Given the `root` of a binary tree, each node in the tree has a `value`, and the path sum of a path in the tree is defined as the sum of the node values from the root to any leaf node. Return the **minimum** path sum from the root to a leaf. A leaf is a node with no children.","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def min_path_sum(root: TreeNode) -> int: Find the minimum path sum from root to leaf in a binary tree. :param root: TreeNode, root of the binary tree :return: int, minimum path sum from root to a leaf node if root is None: return float(\'inf\') # If it\'s a leaf node if root.left is None and root.right is None: return root.value # Recursively find the minimum path sum of both subtrees left_sum = min_path_sum(root.left) right_sum = min_path_sum(root.right) # Take the minimum of the two paths and add the current node\'s value return root.value + min(left_sum, right_sum)"},{"question":"You are given a binary string `s` of length `n`. You need to partition the string into the **minimum number** of substrings such that each substring is a palindrome. A string is a palindrome if it reads the same forward and backward. Return _the **minimum number** of substrings in the partition_. If `s` is already a palindrome, the answer is `1`. For example, given `s = \\"aab\\"`, the minimum number of partitions is `1` for the substring `\\"aa\\"` and `1` for the substring `\\"b\\"`, totaling to `2`.","solution":"def min_palindrome_partitions(s: str) -> int: Returns the minimum number of substrings a given binary string `s` can be partitioned such that each substring is a palindrome. n = len(s) # DP table to track minimum partitions dp = [0] * n # table to check if s[i...j] is a palindrome palindrome = [[False] * n for _ in range(n)] # Every single character is a palindrome by itself for i in range(n): palindrome[i][i] = True # Fill the palindrome table for length in range(2, n + 1): # substring lengths from 2 to n for start in range(n - length + 1): end = start + length - 1 if length == 2: palindrome[start][end] = (s[start] == s[end]) else: palindrome[start][end] = (s[start] == s[end] and palindrome[start+1][end-1]) # Build the dp table with minimum partitions for i in range(n): if palindrome[0][i]: dp[i] = 0 else: dp[i] = float(\'inf\') for j in range(i): if palindrome[j+1][i] and dp[j] + 1 < dp[i]: dp[i] = dp[j] + 1 return dp[n-1] + 1"},{"question":"A gardener is planning a flower garden and needs to lay down flower beds in the garden. The garden is represented by a 1-dimensional array `garden` of length `n`, where each element is either `0` (indicating an empty plot) or `1` (indicating a plot that already contains a flower). A flower bed is defined as a segment of contiguous empty plots where flowers can be planted. Given an integer `k` representing the minimum number of flowers that the gardener needs to plant, determine if it is possible to plant exactly `k` flowers in the garden such that no two flowers are adjacent. You cannot plant flowers in an already occupied plot. Implement a function that returns `True` if it is possible to plant exactly `k` flowers, or `False` otherwise. Note: You can assume that you have an infinite supply of flowers to plant.","solution":"def can_place_flowers(garden, k): Determines if it is possible to plant exactly k flowers in the garden such that no two flowers are adjacent. Args: garden (list): A list of integers (0 or 1) representing the garden. k (int): An integer representing the number of flowers to plant. Returns: bool: True if it is possible to plant exactly k flowers, False otherwise. count = 0 length = len(garden) for i in range(length): if garden[i] == 0: prev = (i == 0) or (garden[i - 1] == 0) next = (i == length - 1) or (garden[i + 1] == 0) if prev and next: garden[i] = 1 count += 1 if count == k: return True return count >= k"},{"question":"You are given an array of `n` integers `arr` where each element represents the number of candies in a box. You also have a positive integer `m`, representing the maximum number of students available to distribute the candies. You need to determine if it\'s possible to distribute all the candies in such a way that each student receives the same number of candies. If it is possible, return the number of candies each student would receive; otherwise, return `-1`.","solution":"def candies_distribution(arr, m): Determines if it\'s possible to distribute all candies such that each student gets the same number of candies. Parameters: arr (list of int): List representing the number of candies in each box m (int): Maximum number of students Returns: int: The number of candies each student would get if distribution is possible, else -1. total_candies = sum(arr) if total_candies % m == 0: return total_candies // m else: return -1"},{"question":"You are given two integers `start` and `end` representing a range of numbers. Your task is to find the sum of all integers within this range (inclusive) that are divisible by either 3 or 5. If `start` is greater than `end`, return 0. Return _the sum of all integers in the specified range that are divisible by 3 or 5_.","solution":"def sum_divisible_by_3_or_5(start, end): Returns the sum of all integers between start and end (inclusive) that are divisible by 3 or 5. If start is greater than end, return 0. if start > end: return 0 total_sum = 0 for num in range(start, end + 1): if num % 3 == 0 or num % 5 == 0: total_sum += num return total_sum"},{"question":"You are given a **0-indexed** array `arr` containing `n` integers. Your task is to determine if there are three **distinct** indices `i`, `j`, and `k` in the array such that the sum of the elements at those indices is zero. Return `true` if such indices exist, otherwise return `false`.","solution":"def find_triplets(arr): Determines if there are three distinct indices i, j, and k in the array such that the sum of the elements at those indices is zero. Parameters: arr (list of int): The input list of integers. Returns: bool: True if such indices exist, False otherwise. n = len(arr) # Sort the array to use two-pointer technique arr.sort() for i in range(n - 2): # Left pointer after the current element left = i + 1 # Right pointer at the end of the array right = n - 1 while left < right: total_sum = arr[i] + arr[left] + arr[right] if total_sum == 0: return True elif total_sum < 0: left += 1 else: right -= 1 return False"},{"question":"You are given an array of integers `heights` representing the height of people standing in a line. Each person i can see the person in front of them if all the people between i and the person they\'re looking at are shorter than them. Return the number of people who can see at least one person in front of them.","solution":"def number_of_people_who_can_see(heights): Returns the number of people who can see at least one person in front of them. Parameters: heights (list of int): A list of integers representing the heights of people standing in a line. Returns: int: Number of people who can see at least one person in front of them. if not heights: return 0 count = 0 max_height = heights[-1] for i in range(len(heights) - 2, -1, -1): if heights[i] > max_height: max_height = heights[i] else: count += 1 return count"},{"question":"Implement a data structure called `MinStack` that supports the following operations in constant time: 1. `push(int x)` - Pushes element `x` onto the stack. 2. `pop()` - Removes the element on the top of the stack. 3. `top()` - Returns the element on the top of the stack. 4. `getMin()` - Retrieves the minimum element in the stack. Ensure that all these operations are performed in constant time.","solution":"class MinStack: def __init__(self): Initialize your data structure here. self.stack = [] self.min_stack = [] def push(self, x: int): Push element x onto stack. self.stack.append(x) if not self.min_stack or x <= self.min_stack[-1]: self.min_stack.append(x) def pop(self): Removes the element on the top of the stack. if self.stack: top_element = self.stack.pop() if top_element == self.min_stack[-1]: self.min_stack.pop() def top(self): Get the top element. if self.stack: return self.stack[-1] def getMin(self): Retrieve the minimum element in the stack. if self.min_stack: return self.min_stack[-1]"},{"question":"You are given an array of `n` integers `heights` representing the heights of buildings in a city. You are also given an integer `bricks` and an integer `ladders`. You start at the first building and want to move to the last building by jumping from one building to the next. You can use a ladder to jump to a taller building or, alternatively, you can use some bricks equal to the difference in height between two buildings. You want to reach the last building using the least number of resources. Return _the maximum number of buildings you can visit by using the given bricks and ladders optimally_.","solution":"from heapq import heappush, heappop def max_buildings(heights, bricks, ladders): Return the maximum number of buildings that can be visited using given bricks and ladders optimally. min_heap = [] n = len(heights) for i in range(1, n): jump = heights[i] - heights[i-1] if jump > 0: heappush(min_heap, jump) if len(min_heap) > ladders: bricks -= heappop(min_heap) if bricks < 0: return i - 1 return n - 1"},{"question":"Given an array of integers `nums`, you need to find two elements that, when swapped, make the array sorted in non-decreasing order. If more than one such pair of elements exists, find the pair where the first element has the smallest index. If no such pair exists, return `[-1, -1]`. The sorting should be achieved by performing a single swap. Return the indices of the elements to be swapped.","solution":"def find_swap_indices(nums): Given an array of integers \'nums\', this function finds a pair of indices such that swapping the elements at these indices would result in the array being sorted in non-decreasing order. If more than one pair exists, the pair with the smallest first index is returned. If no such pair exists, the function returns [-1, -1]. n = len(nums) if n < 2: return [-1, -1] # Let\'s find the indices i and j to swap for i in range(n - 1): if nums[i] > nums[i + 1]: for j in range(i + 1, n): if nums[j] < nums[i]: # Temporarily swap the elements nums[i], nums[j] = nums[j], nums[i] # Check if the list is sorted now if nums == sorted(nums): return [i, j] # Swap them back if not sorted nums[i], nums[j] = nums[j], nums[i] break return [-1, -1]"},{"question":"You are given a `n x n` **binary matrix** representing an **image**, where each element is either `0` (black) or `1` (white). You are tasked with finding the largest **square** containing only `1`s and returning its area. A square is defined by having sides of the same length and being filled completely with `1`s. Implement a function `int largestSquare(int[][] matrix)` that takes the binary matrix as input and returns the area of the largest square containing only `1`s.","solution":"def largest_square(matrix): Returns the area of the largest square containing only 1s in the given binary matrix. if not matrix or not matrix[0]: return 0 n = len(matrix) m = len(matrix[0]) max_side = 0 dp = [[0] * m for _ in range(n)] for i in range(n): for j in range(m): if matrix[i][j] == 1: if i == 0 or j == 0: dp[i][j] = 1 else: dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1 max_side = max(max_side, dp[i][j]) return max_side * max_side"},{"question":"You are given an array `nums` of integers. A contiguous subarray is a sequence of elements within `nums` that are contiguous in their original order. Find the contiguous subarray within an array (containing at least one number) which has the largest product. Return the product of the largest contiguous subarray.","solution":"def max_product_subarray(nums): Returns the product of the largest contiguous subarray within an array `nums`. if not nums: return 0 max_product = min_product = result = nums[0] for num in nums[1:]: # If num is negative, max and min product should be swapped if num < 0: max_product, min_product = min_product, max_product max_product = max(num, max_product * num) min_product = min(num, min_product * num) result = max(result, max_product) return result"},{"question":"Given an array `nums` containing `n` distinct numbers in the range `[0, n]`, find and return the only number that is missing from the array. **Note:** - You should implement an algorithm that runs in linear runtime complexity and uses only constant extra space.","solution":"def find_missing_number(nums): Given an array nums containing n distinct numbers in the range [0, n], find and return the only number that is missing from the array. n = len(nums) # The sum of numbers from 0 to n is n*(n+1)//2 expected_sum = n * (n + 1) // 2 # The sum of the numbers in the array actual_sum = sum(nums) # The missing number is the difference between the expected sum and actual sum return expected_sum - actual_sum"},{"question":"You are given a **directed acyclic graph (DAG)** represented by an integer `n` (the number of nodes) and a list of edges where `edges[i] = [u_i, v_i]` indicates there is a directed edge from node `u_i` to node `v_i`. The nodes are labeled from `0` to `n-1`. Return _an array of the labels of nodes in a **topological order**._ If there are multiple valid topological orderings, return _**any**_ of them.","solution":"from collections import deque, defaultdict def topological_sort(n, edges): Returns a topological ordering of the nodes in the graph. Parameters: n (int): Number of nodes edges (List[List[int]]): Directed edges in the graph Returns: List[int]: Topological ordering of the nodes # Initialize adjacency list and in-degree count adj_list = defaultdict(list) in_degree = [0] * n # Build the graph for u, v in edges: adj_list[u].append(v) in_degree[v] += 1 # Find all nodes with in-degree 0 queue = deque([i for i in range(n) if in_degree[i] == 0]) topo_order = [] while queue: node = queue.popleft() topo_order.append(node) # Decrease in-degree of adjacent nodes for neighbor in adj_list[node]: in_degree[neighbor] -= 1 if in_degree[neighbor] == 0: queue.append(neighbor) # If topological sort includes all nodes, return result if len(topo_order) == n: return topo_order else: # If a cycle is detected return []"},{"question":"You are given an array of non-negative integers `heights` representing the heights of buildings in a line. The width of each building is `1`. The problem is to find the area of the largest rectangle that can be formed by contiguous buildings. Suppose you have to select a range of buildings such that their heights form at least a rectangle of height equal to the minimum height within that range and width equal to the range of buildings. Return the maximum area of such a rectangle. You need to implement the following function: * `int largestRectangleArea(vector<int>& heights)`: Takes a vector of non-negative integers representing building heights and returns the area of the largest rectangle that can be formed by contiguous buildings. Example: ``` Input: heights = [2,1,5,6,2,3] Output: 10 Explanation: The largest rectangle has height 2 and width 5, for an area of 2*5 = 10. ```","solution":"def largestRectangleArea(heights): Returns the area of the largest rectangle that can be formed by contiguous buildings. :param heights: List[int] :return: int stack = [] max_area = 0 index = 0 while index < len(heights): if not stack or heights[stack[-1]] <= heights[index]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"You are given a string `s` containing lowercase English letters and an integer `k`, you need to perform the following operation exactly `k` times: 1. Choose any character from the string `s` and remove it. Your task is to return the lexicographically smallest string you can obtain by applying the above operation `k` times. # Example _Input_: s = \\"abcde\\", k = 2 _Output_: \\"abc\\" # Function Signature ```python def smallestStringAfterKRemovals(s: str, k: int) -> str: # your code here ```","solution":"def smallestStringAfterKRemovals(s: str, k: int) -> str: Return the lexicographically smallest string by removing exactly k characters. Parameters: s (str): Input string. k (int): Number of characters to remove. Returns: str: The lexicographically smallest string possible after removal. # Edge case: if k is greater than or equal to the length of the string, return an empty string if k >= len(s): return \\"\\" stack = [] for char in s: while k > 0 and stack and stack[-1] > char: stack.pop() k -= 1 stack.append(char) # If there are still removals left, do it from the end of the result final_result = \'\'.join(stack[:len(stack) - k]) return final_result"},{"question":"Given an integer array `nums`, find the longest subarray containing no more than two distinct numbers. Return the length of this subarray.","solution":"def longest_subarray_with_two_distinct(nums): Finds the length of the longest subarray containing no more than two distinct numbers. if not nums: return 0 max_length = 0 left = 0 num_dict = {} for right in range(len(nums)): if nums[right] in num_dict: num_dict[nums[right]] += 1 else: num_dict[nums[right]] = 1 while len(num_dict) > 2: num_dict[nums[left]] -= 1 if num_dict[nums[left]] == 0: del num_dict[nums[left]] left += 1 max_length = max(max_length, right - left + 1) return max_length"},{"question":"A binary string is a string that only contains `0`s and `1`s. You are given a binary string `s` consisting of `n` characters. A subsequence is derived by deleting some or no characters of `s` without changing the order of the remaining characters. The binary string `s` is **balanced** if the number of `0`s is equal to the number of `1`s in the string. Return the length of the **longest balanced subsequence** in `s`. If no balanced subsequence exists, return `0`.","solution":"def longest_balanced_subsequence(s): Returns the length of the longest balanced subsequence in the binary string s. A balanced binary string has an equal number of \'0\'s and \'1\'s. count_0 = s.count(\'0\') count_1 = s.count(\'1\') # The length of the longest balanced subsequence will be twice the minimum count of \'0\' and \'1\' return 2 * min(count_0, count_1)"},{"question":"Given a list of integers, `arr`, representing the monthly earnings of a certain company for `n` months, write a function that finds the longest subarray where the earnings are non-decreasing. Return _the length of the longest non-decreasing subarray_. The earnings in the subarray are considered non-decreasing if for every pair of consecutive months, the earnings of the later month are greater than or equal to that of the previous month.","solution":"def longest_non_decreasing_subarray(arr): Returns the length of the longest non-decreasing subarray. Parameters: arr (list): A list of integers representing the monthly earnings of a company. Returns: int: The length of the longest non-decreasing subarray. if not arr: return 0 n = len(arr) max_len = 1 current_len = 1 for i in range(1, n): if arr[i] >= arr[i-1]: current_len += 1 else: max_len = max(max_len, current_len) current_len = 1 max_len = max(max_len, current_len) return max_len"},{"question":"You are given a string `text` and a `pattern`. You must find the first occurrence of `pattern` in `text`, and return the index of the first character of the pattern within `text`. If the `pattern` does not exist in `text`, return `-1`. Note that the search should be case-sensitive, and single characters count as substrings. Aim for an efficient solution rather than a brute force approach.","solution":"def find_pattern(text, pattern): Returns the index of the first occurrence of pattern in text. If the pattern is not found, returns -1. # Use the inbuilt find method for efficient search return text.find(pattern)"},{"question":"You are tasked with developing an autocomplete feature for a search engine. Given a list of `dictionary` containing different words and a string `searchWord`, return all words from the dictionary that start with the `searchWord`. The output list should be sorted in lexicographical order. If no words match the searchWord in the list, return an empty list.","solution":"def autocomplete(dictionary, searchWord): This function returns a list of words from the dictionary that start with the given searchWord. The output list is sorted in lexicographical order. :param dictionary: List of strings (words) :param searchWord: String :return: List of strings result = [word for word in dictionary if word.startswith(searchWord)] return sorted(result)"},{"question":"You are given an array of integers `nums` where each integer represents the number of seconds it takes to complete a task. Your goal is to schedule these tasks on two processors such that the difference between their total completion times is minimized. Write a function `minimizeTimeDifference(nums)` that returns the minimum possible difference between the total times taken by the two processors. You may assume that the length of `nums` is even and that there is at least one task in `nums`. *Example:* ```python minimizeTimeDifference([2, 4, 6, 8]) # returns 0 ```","solution":"def minimizeTimeDifference(nums): Function to minimize the difference of total times taken by two processors. total = sum(nums) n = len(nums) half_total = total // 2 # dp[i] will be the maximum sum we can achieve with a total that\'s at most i. dp = [0] * (half_total + 1) for num in nums: for i in range(half_total, num - 1, -1): dp[i] = max(dp[i], dp[i - num] + num) s1 = dp[half_total] s2 = total - s1 return abs(s2 - s1)"},{"question":"Given a list of integers `heights` representing the heights of students in a row, sort the students in non-decreasing order by height. However, if two students have the same height, their original order should be preserved. Return the sorted list of heights maintaining their relative order for duplicates (i.e., perform a stable sort).","solution":"def sort_students_by_height(heights): Sorts the students\' heights in non-decreasing order while maintaining the relative order for duplicates. :param heights: List of integers representing the heights of students. :return: List of integers sorted in non-decreasing order while preserving the relative order of duplicates. return sorted(heights, key=lambda x: x)"},{"question":"You are given two strings `str1` and `str2`. Your task is to determine if one string can be obtained by rotating the other string any number of times. Return `true` if one string is a rotation of the other, and `false` otherwise. For example, \\"abcde\\" can be rotated to \\"cdeab\\" or \\"eabcd\\", but \\"abcde\\" cannot be rotated to \\"abced\\".","solution":"def is_rotation(str1, str2): Check if one string is rotation of another string. Args: str1 (str): The first string. str2 (str): The second string. Returns: bool: True if one string is a rotation of the other, False otherwise. # Check if both strings are of same length if len(str1) != len(str2): return False # Check if str2 is a substring of str1 concatenated with str1 return str2 in (str1 + str1)"},{"question":"Given an integer `n`, generate all structurally unique **BST\'s** (Binary Search Trees) that store values `1 ... n`. For each generated BST, return its preorder traversal. Note that the preorder traversal is a process of visiting the root node first, then recursively visiting the left subtree, and finally the right subtree. Return the list of all preorder traversals for the unique BSTs.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def generate_preorder(node): return [node.val] + generate_preorder(node.left) + generate_preorder(node.right) if node else [] def generate_trees(start, end): if start > end: return [None] all_trees = [] for i in range(start, end+1): left_trees = generate_trees(start, i-1) right_trees = generate_trees(i+1, end) for l in left_trees: for r in right_trees: current_tree = TreeNode(i) current_tree.left = l current_tree.right = r all_trees.append(current_tree) return all_trees def generate_all_bst_preorders(n): if n == 0: return [] all_trees = generate_trees(1, n) return [generate_preorder(tree) for tree in all_trees]"},{"question":"You are given an integer array `nums`. You need to find the **maximum length** of a subarray that contains **at most two distinct** integers. A subarray is a contiguous part of an array. Return the length of the longest such subarray.","solution":"def max_subarray_with_two_distinct(nums): Returns the maximum length of a subarray that contains at most two distinct integers. if not nums: return 0 left = 0 max_length = 0 counts = {} for right in range(len(nums)): if nums[right] in counts: counts[nums[right]] += 1 else: counts[nums[right]] = 1 while len(counts) > 2: counts[nums[left]] -= 1 if counts[nums[left]] == 0: del counts[nums[left]] left += 1 max_length = max(max_length, right - left + 1) return max_length"},{"question":"You are given a list of `n` unique integers representing the heights of trees in a forest. Your task is to cut the trees such that the difference in height between any two adjacent trees is minimized. After cutting, the heights of the trees should be reflected in a new list of the same `n` integers. Return the new list of tree heights where the height difference between any two adjacent trees is minimized. If there are multiple solutions, return any one of them.","solution":"def minimize_tree_height_difference(heights): Returns the list of tree heights where the difference between any two adjacent trees is minimized. # Sort the list of heights heights.sort() return heights"},{"question":"You are given a binary tree where each node contains an integer value. Return _the maximum path sum of any path_. A path in a binary tree is defined as any sequence of nodes starting from any node and ending at any node, where the sequence follows parent-child connections. The path must contain at least one node and does not need to go through the root. The test cases are generated such that the maximum path sum fits in a **32-bit** integer.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def maxPathSum(root): Return the maximum path sum of any path in the binary tree. def helper(node): nonlocal max_sum if not node: return 0 # Compute the maximum path sum with or without crossing the node left_max = max(helper(node.left), 0) right_max = max(helper(node.right), 0) # Path through the current node current_max = node.val + left_max + right_max # Update the global maximum path sum max_sum = max(max_sum, current_max) # Return the max gained by including this node and one of its subtrees return node.val + max(left_max, right_max) max_sum = float(\'-inf\') helper(root) return max_sum"},{"question":"Given a list of non-negative integers `nums`, arrange the numbers such that they form the largest possible number. You should concatenate the integers together and return the resulting string. For example, given `nums = [3, 30, 34, 5, 9]`, the largest formed number would be `9534330`. Return _the largest number you can form by arranging the integers in the list_.","solution":"from functools import cmp_to_key def largest_number(nums): Arrange numbers to form the largest possible number. Args: nums: List of non-negative integers. Returns: String representing the largest formed number. if not nums: return \\"\\" # Convert each integer to string for easy comparison nums_str = list(map(str, nums)) # Comparison function for sorting def compare(x, y): if x + y > y + x: return -1 elif x + y < y + x: return 1 else: return 0 # Sort using the custom comparison function nums_str.sort(key=cmp_to_key(compare)) # If the largest number is 0, just return \'0\' if nums_str[0] == \'0\': return \'0\' # Join and return the numbers as a single string return \'\'.join(nums_str)"},{"question":"Given an array `arr` of positive integers, you can perform the following operation any number of times: choose any two elements `arr[i]` and `arr[j]` (with `i != j`), and decrease `arr[i]` by `arr[j]`. The goal is to make all the elements of the array **equal**. If it is possible to make all elements equal, return the smallest non-negative integer `k` such that after at most `k` operations all elements of the array are equal; otherwise, return `-1`.","solution":"from math import gcd from functools import reduce def min_operations_to_make_equal(arr): Return the number of operations needed to make all elements of arr equal, or -1 if it is not possible. if not arr: return -1 # Not possible to make an empty array\'s elements equal # Find the GCD of all elements in the array overall_gcd = reduce(gcd, arr) # If the GCD of all elements is greater than 1, we can make all elements equal if overall_gcd != 1: return overall_gcd else: # If the GCD is 1, return the number of elements as the operations required return len(arr) - 1"},{"question":"You are given two strings `s1` and `s2` of equal length consisting only of lowercase alphabets. You want to transform `s1` into `s2` by rearranging its characters. In each step, you can only choose a contiguous substring of `s1`, remove it, and then insert it back in any position of the string. Return the minimum number of such operations required to transform `s1` into `s2`.","solution":"def min_operations_to_transform(s1, s2): Returns the minimum number of operations required to transform s1 into s2. def longest_common_subsequence(X, Y): Helper function to find the length of the longest common subsequence between two strings X and Y. m = len(X) n = len(Y) # Create a 2D table to store lengths of longest common subsequence. L = [[0] * (n + 1) for _ in range(m + 1)] # Build the table in bottom-up fashion. for i in range(m + 1): for j in range(n + 1): if i == 0 or j == 0: L[i][j] = 0 elif X[i-1] == Y[j-1]: L[i][j] = L[i-1][j-1] + 1 else: L[i][j] = max(L[i-1][j], L[i][j-1]) return L[m][n] lcs_length = longest_common_subsequence(s1, s2) # The minimum number of operations required is the difference in length # minus the length of the longest common subsequence min_operations = len(s1) - lcs_length return min_operations"},{"question":"You are given an array `points` where `points[i] = [xi, yi]` represents a point on the 2D plane. A line is defined by two points on this plane, and its **slope** is calculated as `(yi - yj) / (xi - xj)` for two points `[xi, yi]` and `[xj, yj]`. Your task is to find out the **maximum number of points that lie on the same straight line**. Return this maximum number of points.","solution":"def max_points_on_line(points): def gcd(a, b): while b: a, b = b, a % b return a from collections import defaultdict n = len(points) if n < 3: return n max_points = 0 for i in range(n): slopes = defaultdict(int) same_point = 1 for j in range(n): if i != j: if points[i] == points[j]: same_point += 1 else: dx = points[j][0] - points[i][0] dy = points[j][1] - points[i][1] g = gcd(dx, dy) slope = (dx // g, dy // g) slopes[slope] += 1 current_max = same_point for count in slopes.values(): current_max = max(current_max, count + same_point) max_points = max(max_points, current_max) return max_points"},{"question":"You are given a binary tree where each node has a value associated with it. Implement a function `longestConsecutiveSequence(TreeNode* root)` that returns the length of the longest consecutive sequence path in the binary tree. A consecutive sequence path is defined as a path where the values of the nodes are incrementing by 1. Note that the path can either be from parent to child (down the tree) or from child to parent (up the tree), but it cannot change direction. For example, in the following binary tree: ``` 1 3 / 2 4 5 ``` The longest consecutive sequence path is `3-4-5`, so the function should return `3`.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def longestConsecutiveSequence(root): def dfs(node, parent, length): if not node: return length if parent and node.val == parent.val + 1: length += 1 else: length = 1 left_length = dfs(node.left, node, length) right_length = dfs(node.right, node, length) return max(length, left_length, right_length) return dfs(root, None, 0)"},{"question":"You are given a list of `tickets` where `tickets[i] = [fromi, toi]` represents a one-way flight from city `fromi` to city `toi`. Return _the itinerary in which you visit all the cities once starting from the city \'JFK\'_. If there are multiple valid itineraries, return the itinerary which has the smallest lexical order when read as a single string. * For example, the itinerary `[\\"JFK\\", \\"A\\", \\"B\\"]` is smaller than `[\\"JFK\\", \\"B\\", \\"A\\"]` because `\'A\'` is smaller than `\'B\'` in lexical order. You may assume that all tickets form at least one valid itinerary starting from \'JFK\'.","solution":"def findItinerary(tickets): from collections import defaultdict import heapq # Build the graph graph = defaultdict(list) for src, dst in tickets: heapq.heappush(graph[src], dst) # Perform Hierholzer\'s algorithm for Eulerian Path itinerary = [] def visit(airport): while graph[airport]: visit(heapq.heappop(graph[airport])) itinerary.append(airport) visit(\'JFK\') return itinerary[::-1]"},{"question":"You are given a list of `n` tasks represented by an integer array `tasks`, where `tasks[i]` represents the time required to complete the `i-th` task. A server can handle exactly two tasks simultaneously, but the same task cannot be paired with itself. The objective is to maximize the number of tasks that can be completed in pairs such that the total time taken by each pair to complete does not exceed a given limit `t`. Write a function that returns the maximum number of task pairs that can be completed following this criteria.","solution":"def max_task_pairs(tasks, t): Returns the maximum number of task pairs that can be completed according to the given criteria. Parameters: - tasks: List[int] - a list of integers representing task durations - t: int - the maximum time limit for a pair of tasks Returns: int - the maximum number of task pairs # Sort the tasks to be able to use two-pointers technique tasks.sort() left = 0 right = len(tasks) - 1 pairs = 0 while left < right: if tasks[left] + tasks[right] <= t: pairs += 1 left += 1 right -= 1 else: right -= 1 return pairs"},{"question":"You are given a list of flight connections represented as an array of strings `flights`, where each element is in the format `\\"CityA-CityB\\"` indicating a direct flight from `CityA` to `CityB`. You are also given the name of a `startCity` and a `destinationCity`. You must determine the fewest number of flights required to travel from the `startCity` to the `destinationCity`. If it is not possible to reach the `destinationCity` from the `startCity`, return `-1`.","solution":"from collections import deque, defaultdict def fewest_flights(flights, startCity, destinationCity): Finds the fewest number of flights required to travel from startCity to destinationCity. Parameters: flights (list of str): List of direct flight connections in the format \\"CityA-CityB\\". startCity (str): The starting city. destinationCity (str): The destination city. Returns: int: The fewest number of flights required, or -1 if not possible. # Build the adjacency list from the flight connections adjacency_list = defaultdict(list) for flight in flights: cityA, cityB = flight.split(\'-\') adjacency_list[cityA].append(cityB) # Perform BFS to find the shortest path queue = deque([(startCity, 0)]) # (current city, number of flights so far) visited = set() while queue: current_city, flights_so_far = queue.popleft() if current_city == destinationCity: return flights_so_far if current_city not in visited: visited.add(current_city) for neighbor in adjacency_list[current_city]: if neighbor not in visited: queue.append((neighbor, flights_so_far + 1)) return -1"},{"question":"You are given two strings `s1` and `s2` of equal length consisting of lowercase English letters. Determine whether it is possible to transform `s1` into `s2` using the following operation any number of times: - Choose a **non-empty** substring of `s1` and reverse its order. Return _a boolean value indicating whether_ `s2` _can be obtained from_ `s1` _by performing the above operation any number of times_.","solution":"def can_transform_with_substring_operations(s1, s2): Determine if s2 can be obtained from s1 by reversing any non-empty sub-strings any number of times. The problem reduces to checking if s1 and s2 are anagram of each other because reversing any substring retains characters but changes their order. Parameters: s1 (str): The source string. s2 (str): The target string. Returns: bool: True if s2 can be obtained from s1 by any number of substring reversals, False otherwise. return sorted(s1) == sorted(s2)"},{"question":"Given a list of unique integers `nums` sorted in ascending order, write a function that constructs a balanced binary search tree (BST) from the integers in the list. The function should return the root node of the BST. A balanced binary search tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than one.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left = None self.right = right def sortedArrayToBST(nums): Constructs a balanced BST from the sorted array nums. def convertListToBST(left, right): if left > right: return None # Always choose middle element to maintain balance mid = (left + right) // 2 node = TreeNode(nums[mid]) node.left = convertListToBST(left, mid - 1) node.right = convertListToBST(mid + 1, right) return node return convertListToBST(0, len(nums) - 1)"},{"question":"Given a string `word`, return the same string with all the vowels removed. The vowels are `a`, `e`, `i`, `o`, and `u`, and they may appear in both lowercase and uppercase. Ensure that the relative order of the characters in the output string remains the same as in the input string.","solution":"def remove_vowels(word): Removes all vowels from the given string. :param word: str, input string from which vowels are to be removed :return: str, string with all vowels removed vowels = \\"aeiouAEIOU\\" return \'\'.join([char for char in word if char not in vowels])"},{"question":"Given an array of integers `nums` of size `n`, you are required to determine the smallest window (contiguous subarray) that can be sorted in-place so that the entire array becomes sorted (non-decreasing order). If the array is already sorted, return `0`. Otherwise, return the length of the smallest window. For example, given `nums = [2, 6, 4, 8, 10, 9, 15]`, the smallest window that needs to be sorted in-place is `[6, 4, 8, 10, 9]`, which implies the answer is `5`.","solution":"def findUnsortedSubarray(nums): Returns the length of the shortest subarray that, when sorted, results in the entire array being sorted. If the array is already sorted, returns 0. n = len(nums) start, end = -1, -1 max_seen, min_seen = -float(\'inf\'), float(\'inf\') for i in range(n): max_seen = max(max_seen, nums[i]) if nums[i] < max_seen: end = i for i in range(n-1, -1, -1): min_seen = min(min_seen, nums[i]) if nums[i] > min_seen: start = i if start == -1 and end == -1: return 0 return end - start + 1"},{"question":"Given an unsorted array of integers `arr`, you are allowed to perform only one operation which is to remove exactly one element from the array. Write a function that returns the length of the longest subarray with consecutive elements that can be obtained after removing one element. Note that the elements do not need to be in a sorted order in the original array, and the consecutive sequence can start from any integer.","solution":"def longest_subarray_with_removal(arr): Returns the length of the longest subarray with consecutive elements that can be obtained after removing one element. if len(arr) <= 1: return len(arr) num_set = set(arr) max_length = 0 for num in arr: num_set.remove(num) # simulate removal of the element current_length = 0 visited = set() # Check for consecutive sequence containing num for n in range(num - 1, num + 2): # only need to check around the removed element if n in num_set and n not in visited: length = 1 visited.add(n) # Check left left = n - 1 while left in num_set: length += 1 visited.add(left) left -= 1 # Check right right = n + 1 while right in num_set: length += 1 visited.add(right) right += 1 current_length = max(current_length, length) max_length = max(max_length, current_length) num_set.add(num) # add the element back return max_length"},{"question":"You are given an integer array `nums`, and you need to sort the array according to the frequency of the values. If multiple values have the same frequency, sort them in increasing order. Return the sorted array. Implement a function to achieve this: ```python def frequencySort(nums: List[int]) -> List[int]: # Your implementation here ``` For example, given the input `nums = [1,1,2,2,2,3]`, the output should be `[3,1,1,2,2,2]` since `1` appears twice, `2` appears three times, and `3` appears once. The frequency of numbers in increasing order is 3, 1, and 2 respectively.","solution":"from collections import Counter from typing import List def frequencySort(nums: List[int]) -> List[int]: Sort the array according to the frequency of the values. If multiple values have the same frequency, sort them in increasing order. count = Counter(nums) sorted_nums = sorted(nums, key=lambda x: (count[x], x)) return sorted_nums"},{"question":"You are given an integer array `nums` containing `n` distinct numbers in the range `[0, n]`. This means that exactly one number in this range is missing. Return the missing number.","solution":"def missing_number(nums): Returns the missing number in the array. n = len(nums) expected_sum = n * (n + 1) // 2 actual_sum = sum(nums) return expected_sum - actual_sum"},{"question":"You are given a **0-indexed** integer array `weights` representing weights of items and an integer `limit`. You need to split the array into `k` non-empty subsequences, each with a sum of weights not exceeding `limit`. Return _the minimum number_ `k` _needed to accomplish this task_. If it is not possible to split the array even with the maximum allowed number of subsequences, return `-1`.","solution":"def min_subsequences(weights, limit): Returns the minimum number of non-empty subsequences needed such that the sum of weights in each subsequence does not exceed the limit. if any(weight > limit for weight in weights): return -1 weights.sort(reverse=True) subsequences = 0 while weights: current_subsequence = 0 for i in range(len(weights) - 1, -1, -1): if current_subsequence + weights[i] <= limit: current_subsequence += weights.pop(i) subsequences += 1 return subsequences"},{"question":"Write a function that takes a string `s` consisting of lowercase English letters and returns the length of the longest substring with all unique characters. If there are multiple substrings with the same length, return the length of the first one encountered. The function should efficiently handle larger input strings with a time complexity better than O(n^2).","solution":"def length_of_longest_substring(s): Returns the length of the longest substring with all unique characters. n = len(s) if n == 0: return 0 char_index_map = {} max_length = 0 start = 0 for end in range(n): if s[end] in char_index_map and char_index_map[s[end]] >= start: start = char_index_map[s[end]] + 1 char_index_map[s[end]] = end max_length = max(max_length, end - start + 1) return max_length"},{"question":"A **happy string** is a string where no two adjacent characters are the same. You are given two integers `n` and `k`. You need to return the k-th lexicographically smallest happy string of length `n`. If there are no such strings, return an empty string. The strings consist of only the lowercase letters \'a\', \'b\', and \'c\'. For example, the strings \\"ab\\", \\"ac\\", \\"ba\\", etc., are all happy strings, while the string \\"aa\\", \\"bb\\", \\"cc\\" are not happy strings.","solution":"def get_happy_string(n, k): def generate_happy_strings(n, prefix, happy_strings): if len(prefix) == n: happy_strings.append(prefix) return for char in \\"abc\\": if not prefix or prefix[-1] != char: generate_happy_strings(n, prefix + char, happy_strings) happy_strings = [] generate_happy_strings(n, \\"\\", happy_strings) if k > len(happy_strings): return \\"\\" return happy_strings[k - 1]"},{"question":"You are given a `n x n` matrix `grid` where each cell `grid[i][j]` represents the elevation at that point. You need to determine the minimum effort path from the top-left corner `(0, 0)` to the bottom-right corner `(n-1, n-1)` such that the maximum difference in elevation between adjacent cells on the path is minimized. Return the minimum effort required to travel from the top-left to the bottom-right of the matrix. Two cells are considered adjacent if they share a side.","solution":"import heapq def minimum_effort_path(grid): Returns the minimum effort required to travel from the top-left to the bottom-right of the matrix. The effort of a path is defined as the maximum difference in elevation between adjacent cells of the path. :param grid: List[List[int]], 2D list representing the elevation matrix. :return: int, minimum effort required. def neighbors(x, y): for nx, ny in ((x-1, y), (x+1, y), (x, y-1), (x, y+1)): if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]): yield nx, ny rows, cols = len(grid), len(grid[0]) efforts = [[float(\'inf\')] * cols for _ in range(rows)] efforts[0][0] = 0 min_heap = [(0, 0, 0)] # (effort, x, y) while min_heap: effort, x, y = heapq.heappop(min_heap) if (x, y) == (rows-1, cols-1): return effort for nx, ny in neighbors(x, y): new_effort = max(effort, abs(grid[nx][ny] - grid[x][y])) if new_effort < efforts[nx][ny]: efforts[nx][ny] = new_effort heapq.heappush(min_heap, (new_effort, nx, ny))"},{"question":"You are given an array of integers `nums` which represents the number of hours one can work consecutively for `n` days. However, to avoid burnout, you cannot work consecutively for more than `k` hours in a single day. You need to find the maximum number of productive hours you can achieve by optimally distributing work each day. If it is not possible to work all given hours with the constraint, return `-1`. Given an integer array `nums` where `nums[i]` represents the work hours on the `ith` day and an integer `k` representing the maximum allowed consecutive work hours in a day, return _the **maximum** number of productive hours you can achieve without exceeding the limit_. If it’s not possible to work all given hours without violating the constraint, return `-1`.","solution":"def max_productive_hours(nums, k): Returns the maximum number of productive hours one can achieve without exceeding the limit of k hours to work consecutively on any single day. If it is not possible to work all given hours under the constraints, returns -1. total_hours = 0 for hours in nums: if hours > k: return -1 total_hours += hours return total_hours"},{"question":"A warehouse robot needs to move boxes from one side of the warehouse to the other. The warehouse is represented as a grid of size `m x n`, where each cell is either empty (denoted as `0`) or contains an obstacle (denoted as `1`). The robot can only move either right or down at any point in time. The robot starts at the top-left corner of the grid (cell `(0, 0)`) and needs to reach the bottom-right corner of the grid (cell `(m-1, n-1)`). Write a function that computes the number of unique paths that the robot can take to reach its destination. If there is no valid path from the start to the destination, return `0`.","solution":"def unique_paths_with_obstacles(obstacle_grid): Calculates the number of unique paths in a grid with obstacles from the top-left to the bottom-right corner. :param obstacle_grid: List[List[int]], 2D grid where 0 is an empty cell and 1 is an obstacle. :return: int, the number of unique paths from (0, 0) to (m-1, n-1) if not obstacle_grid or obstacle_grid[0][0] == 1 or obstacle_grid[-1][-1] == 1: return 0 m, n = len(obstacle_grid), len(obstacle_grid[0]) dp = [[0] * n for _ in range(m)] # Create a 2D list to store number of paths # Initialize the starting point dp[0][0] = 1 # Fill the dp array for i in range(m): for j in range(n): if obstacle_grid[i][j] == 1: dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[-1][-1]"},{"question":"Given the head of a singly linked list, write a function to reorder the list as follows: Reorder it so that the first element is followed by the last element, followed by the second element, followed by the second-to-last element, and so on. The reordering should be done in place without modifying the nodes\' values, and your algorithm should run in `O(n)` time and use `O(1)` extra space. Return the head of the reordered list.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reorderList(head): Reorders the given linked list as specified. :param head: ListNode, the head of the singly linked list. :return: ListNode, the head of the reordered singly linked list. if not head or not head.next or not head.next.next: return head # Find the middle of the linked list using the slow-fast pointer technique slow, fast = head, head while fast and fast.next: slow = slow.next fast = fast.next.next # Reverse the second half of the linked list prev, curr = None, slow.next slow.next = None # Cut the list into two halves while curr: temp = curr.next curr.next = prev prev = curr curr = temp # Merge the two halves together first, second = head, prev while second: temp1, temp2 = first.next, second.next first.next = second second.next = temp1 first, second = temp1, temp2 return head def printList(head): result = [] while head: result.append(head.val) head = head.next return result"},{"question":"You are given two strings `s1` and `s2` that are the same length, consisting of lowercase letters. A string swap is defined as taking any two indices `i` and `j` (0-based) in one string and swapping the characters at these positions. Return _`True`_ if it is possible to make both strings equal by performing **at most one string swap** on exactly one of the strings. Otherwise, return _`False`_.","solution":"def can_be_equal_with_one_swap(s1, s2): Determines if two strings of the same length can be made equal by performing at most one string swap on exactly one of the strings. if s1 == s2: return True # Finding the indices where s1 and s2 differ diff_indices = [i for i in range(len(s1)) if s1[i] != s2[i]] # If there are exactly two differing indices, check if swapping them would make the strings equal if len(diff_indices) == 2: i, j = diff_indices return s1[i] == s2[j] and s1[j] == s2[i] # If no differing index or more than two differing indices return False"},{"question":"You are given a **0-indexed** array `nums` consisting of `n` integers. In one move, you can select any two adjacent integers and either increase or decrease both of them by `1`. Return the minimum number of moves required to make all the integers in the array equal. If it is not possible, return `-1`.","solution":"def min_moves_to_make_equal(nums): Returns the minimum number of moves required to make all the integers in the array equal. If it is not possible, returns -1. # Check if making all elements the same is possible parity = nums[0] % 2 for num in nums: if num % 2 != parity: return -1 # Calculate the minimum number of moves target = min(nums) # any other value will produce the same result moves = 0 for num in nums: moves += (num - target) // 2 # (num - target) is always even since all nums have the same parity return moves"},{"question":"You are given two strings, `s1` and `s2`. Your task is to determine if you can transform `s1` into `s2` by replacing exactly one character in `s1` with a different character. The replacement should occur exactly once. If it is possible, return `true`; otherwise, return `false`. Both strings are of equal length.","solution":"def can_transform_by_one_replacement(s1, s2): Determines if you can transform s1 into s2 by replacing exactly one character in s1 with a different character. if len(s1) != len(s2): return False # Count the number of differing characters diff_count = 0 for c1, c2 in zip(s1, s2): if c1 != c2: diff_count += 1 if diff_count > 1: return False # Exactly one replacement means we must have exactly one differing character return diff_count == 1"},{"question":"Given a string `s` consisting of lowercase English letters, return _the first non-repeating character in `s`_. If there is no such character, return an empty string \\"\\".","solution":"def first_non_repeating_character(s): Returns the first non-repeating character in the string s. If all characters repeat or string is empty, returns an empty string. # Dictionary to count occurrences of each character char_count = {} # First pass to count all characters for char in s: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 # Second pass to find first non-repeating character for char in s: if char_count[char] == 1: return char # If no non-repeating character is found, return an empty string return \\"\\""},{"question":"You are given an integer array `heights` representing the heights of a series of towers. Each tower can be reduced in height by exactly one unit in a single operation, and you may perform any number of such operations on any of the towers. Your goal is to make the height of every tower exactly `n`, where `n` is the height of the shortest tower, by only reducing the height of towers. Return _the total number of operations required to achieve this goal_.","solution":"def min_operations_to_equalize(heights): Returns the total number of operations required to make the height of every tower exactly the height of the shortest tower by only reducing the height of towers. :param heights: List[int], list of integers representing the heights of the towers. :return: int, the total number of operations required. if not heights: return 0 min_height = min(heights) operations = 0 for height in heights: operations += height - min_height return operations"},{"question":"You are given a **0-indexed** integer array `price` of length `n` where `price[i]` is the price per pound of the `i-th` fruit. You are also given a **0-indexed** integer array `target` of length `n` where `target[i]` is the target weight in pounds for the `i-th` fruit. Each day you can choose to buy a pound of any fruit to try and reach the target weight for as many fruits as possible. Your goal is to minimize the **total cost** to reach the target weights for all fruits. Return _the **minimum cost** to buy the target weights for all fruits_. # Example: ```python # Example 1: price = [1, 2, 3] target = [2, 3, 4] # Output: 20 # Explanation: Buy 2 pounds of the first fruit (total cost = 1*2 = 2), # 3 pounds of the second fruit (total cost = 2*3 = 6) and # 4 pounds of the third fruit (total cost = 3*4 = 12). # Total cost is 2 + 6 + 12 = 20. # Example 2: price = [4, 5] target = [1, 3] # Output: 19 # Explanation: Buy 1 pound of the first fruit (total cost = 4*1 = 4) and # 3 pounds of the second fruit (total cost = 5*3 = 15). # Total cost is 4 + 15 = 19. ```","solution":"def min_cost_to_reach_targets(price, target): Returns the minimum cost to buy the target weights for all fruits. total_cost = 0 for p, t in zip(price, target): total_cost += p * t return total_cost"},{"question":"Given an array of integers `nums` and an integer `k`, return the number of unique pairs `(a, b)` where `a` and `b` are distinct elements from the array and `a + b = k`. A pair `(a, b)` and `(b, a)` is considered the same.","solution":"def count_pairs_with_sum(nums, k): Returns the number of unique pairs (a, b) where a and b are distinct elements from the array and a + b = k. seen = set() unique_pairs = set() count = 0 for num in nums: target = k - num if target in seen and (min(num, target), max(num, target)) not in unique_pairs: unique_pairs.add((min(num, target), max(num, target))) count += 1 seen.add(num) return count"},{"question":"Given a string `s`, determine the minimum number of characters you need to insert to make `s` a palindrome. You may assume that the input string only contains lowercase English letters. The test cases are generated in such a way that the result fits within the range of a 32-bit signed integer.","solution":"def min_insertions_to_palindrome(s): Determine the minimum number of characters needed to insert to make s a palindrome. :param s: input string :return: minimum number of insertions n = len(s) # create a table to store results of subproblems dp = [[0] * n for _ in range(n)] # fill the table for length in range(2, n + 1): for i in range(n - length + 1): j = i + length - 1 if s[i] == s[j]: dp[i][j] = dp[i + 1][j - 1] else: dp[i][j] = min(dp[i][j - 1], dp[i + 1][j]) + 1 return dp[0][n - 1]"},{"question":"You are given an n-ary tree and an integer `k`. The root of the n-ary tree is a node `root` of type `Node`, where each node contains an integer value and a list of its children nodes. Return the sum of all node values in the k-th level of the tree, where the root is considered level `0`. If there are no nodes at level `k`, return `0`. The definition for the `Node` class is as follows: ```python class Node: def __init__(self, val=None, children=None): self.val = val self.children = children if children is not None else [] ```","solution":"class Node: def __init__(self, val=None, children=None): self.val = val self.children = children if children is not None else [] def sum_at_kth_level(root, k): Returns the sum of all node values at the k-th level of the tree. if root is None: return 0 level = 0 current_level_nodes = [root] while current_level_nodes: if level == k: return sum(node.val for node in current_level_nodes) next_level_nodes = [] for node in current_level_nodes: next_level_nodes.extend(node.children) current_level_nodes = next_level_nodes level += 1 return 0"},{"question":"You are given a list of integers representing the heights of students in a class. A photograph needs to be taken where the students are arranged in a single line. Each student can either face forward or face backward. A student facing forward should have a higher height than the student in front of them, and a student facing backward should be shorter than the student in front of them. Implement a function `canTakePhoto` that takes a list of integers `heights` and returns a boolean indicating whether it is possible to arrange the students as per the given conditions. A student cannot face both forward and backward at the same time, and their relative order in the list must remain unchanged. For example, given the list `[5,3,4,2]`, it is possible to rearrange and have some students facing forward and others backward to meet the condition.","solution":"def canTakePhoto(heights): Determines if it is possible to arrange students as per the given conditions. Args: heights (list): List of integers representing the heights of students. Returns: bool: True if it is possible to arrange the students as per the given conditions, False otherwise. n = len(heights) dp_forward = [1] * n dp_backward = [1] * n # Determine the length of the longest increasing subsequence ending at each position for i in range(1, n): if heights[i] > heights[i-1]: dp_forward[i] = dp_forward[i-1] + 1 # Determine the length of the longest decreasing subsequence ending at each position for i in range(1, n): if heights[i] < heights[i-1]: dp_backward[i] = dp_backward[i-1] + 1 # Check if there\'s a valid configuration of forward and backward facing students for i in range(n): if dp_forward[i] > 1 or dp_backward[i] > 1: return True return False"},{"question":"Given a string `s`, write a function to determine if it is a **palindrome**. A palindrome is a word, phrase, number, or other sequence of characters that reads the same forward and backward (ignoring spaces, punctuation, and capitalization). Return `true` if the input string is a palindrome and `false` otherwise.","solution":"def is_palindrome(s): Determines if the input string s is a palindrome. Ignores spaces, punctuation, and capitalization. Parameters: s (str): The input string. Returns: bool: True if s is a palindrome, False otherwise. # Remove non-alphanumeric characters and convert to lowercase cleaned = \'\'.join(char.lower() for char in s if char.isalnum()) # Check if cleaned string is equal to its reverse return cleaned == cleaned[::-1]"},{"question":"Given a string `s`, you need to sort the characters in the string by the frequency of their occurrences. Return _the sorted string such that the characters with the highest frequency come first_. If multiple characters have the same frequency, they should appear in their original order. **Note**: Assume the input string only contains lowercase English letters.","solution":"from collections import Counter def frequency_sort(s): Sort the characters of the string `s` by the frequency of their occurrences. Parameters: s (str): input string containing only lowercase English letters. Returns: str: sorted string such that characters with the highest frequency come first. freq = Counter(s) sorted_characters = sorted(s, key=lambda x: (-freq[x], s.index(x))) return \'\'.join(sorted_characters)"},{"question":"You are given an array of integers `nums` and an integer `target`. You need to determine if there exist two distinct indices `i` and `j` in the array such that `nums[i] + nums[j] == target`. Return true if such indices exist, otherwise return false. Your function should have the following signature: ```python def two_sum(nums: List[int], target: int) -> bool: ``` Example: ``` Input: nums = [2, 7, 11, 15], target = 9 Output: true Explanation: Because nums[0] + nums[1] = 2 + 7 = 9. ```","solution":"def two_sum(nums, target): Determines if there are two distinct indices i and j in the array such that nums[i] + nums[j] == target. Params: nums - List of integers. target - Target sum. Returns: True if such indices exist, False otherwise. seen = {} for i, num in enumerate(nums): complement = target - num if complement in seen: return True seen[num] = i return False"},{"question":"You are given a 2D list `grid` representing a rectangular grid of positive integers. You start at the top-left corner of the grid and can only move right or down. Each move adds the value of the current cell to your score. Your goal is to determine the maximum score you can obtain when you reach the bottom-right corner of the grid. Return _the maximum score_ you can achieve on this path.","solution":"def max_path_sum(grid): Given a 2D list `grid`, find the maximum score you can obtain by starting from the top-left corner and moving only right or down to reach the bottom-right corner of the grid. Each move adds the value of the current cell to your score. if not grid or not grid[0]: return 0 rows, cols = len(grid), len(grid[0]) dp = [[0] * cols for _ in range(rows)] # Initialize the start point dp[0][0] = grid[0][0] # Initialize the first column for r in range(1, rows): dp[r][0] = dp[r-1][0] + grid[r][0] # Initialize the first row for c in range(1, cols): dp[0][c] = dp[0][c-1] + grid[0][c] # Fill in the dp table for r in range(1, rows): for c in range(1, cols): dp[r][c] = max(dp[r-1][c], dp[r][c-1]) + grid[r][c] return dp[rows-1][cols-1]"},{"question":"Given a binary tree, implement the following methods: - `__init__`(self, root)`: This function initializes the binary tree with the given `root`, which is an instance of `TreeNode`. - `find(target)`: Given an integer `target`, this function returns the number of times the `target` value appears in the binary tree. - `delete(target)`: Given an integer `target`, this function deletes **one** occurrence of the `target` value from the binary tree if it exists. - `get_max()`: This function returns the maximum value present in the binary tree. If the tree is empty, return `None`.","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right class BinaryTree: def __init__(self, root=None): self.root = root def find(self, target): Returns the number of times the target value appears in the binary tree. return self._find_recursive(self.root, target) def _find_recursive(self, node, target): if not node: return 0 count = 1 if node.value == target else 0 return count + self._find_recursive(node.left, target) + self._find_recursive(node.right, target) def delete(self, target): Deletes one occurrence of the target value from the binary tree if it exists. self.root, _ = self._delete_recursive(self.root, target) def _delete_recursive(self, node, target): if not node: return node, None if node.value == target: if not node.left: return node.right, node.value if not node.right: return node.left, node.value min_larger_node = self._get_min(node.right) node.value = min_larger_node.value node.right, _ = self._delete_recursive(node.right, min_larger_node.value) return node, target elif target < node.value: node.left, _ = self._delete_recursive(node.left, target) return node, None else: node.right, _ = self._delete_recursive(node.right, target) return node, None def _get_min(self, node): while node.left: node = node.left return node def get_max(self): Returns the maximum value present in the binary tree. If the tree is empty, return None. if not self.root: return None current = self.root while current.right: current = current.right return current.value"},{"question":"You are given an integer array `arr` representing the ages of a group of people. You are to organize a birthday party and must decide how many cakes to order. Each cake can be shared by exactly four people. Your task is to return the minimum number of cakes needed, while ensuring that everyone at the party gets a fair share (i.e., no person is left without a cake). If it is not possible to accommodate a fair distribution such that each cake is shared by exactly four people, return `-1`.","solution":"def number_of_cakes(arr): if len(arr) % 4 != 0: return -1 return len(arr) // 4"},{"question":"Given a string `s`, implement an algorithm to determine if it is a valid **palindrome**, considering only alphanumeric characters and ignoring cases. A palindrome is a word, phrase, number, or other sequence of characters that reads the same forward and backward (ignoring spaces, punctuation, and capitalization). Implement the `Solution` class: * `Solution(String s)` initializes the object with the string `s`. * `boolean isValidPalindrome()` returns `true` if `s` is a valid palindrome; otherwise, it returns `false`.","solution":"class Solution: def __init__(self, s: str): self.s = s def isValidPalindrome(self) -> bool: # Filter out non-alphanumeric characters and convert to lowercase filtered_chars = [c.lower() for c in self.s if c.isalnum()] # Check if the filtered list of characters reads the same forward and backward return filtered_chars == filtered_chars[::-1]"},{"question":"Given a binary tree, determine if it is a **balanced binary tree**. A balanced binary tree is defined as a binary tree in which the left and right subtrees of every node differ in height by no more than 1. Return `true` if the tree is balanced and `false` otherwise.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_balanced(root: TreeNode) -> bool: def height_and_balance(node): if not node: return 0, True left_height, left_balance = height_and_balance(node.left) right_height, right_balance = height_and_balance(node.right) current_balance = left_balance and right_balance and abs(left_height - right_height) <= 1 return max(left_height, right_height) + 1, current_balance _, is_bal = height_and_balance(root) return is_bal"},{"question":"You are given a 0-indexed integer array `arr` of length `n`. An array element is said to be a **peak** if it is not smaller than its neighbors. For an element at index `i`, this means `arr[i] >= arr[i-1]` (if `i-1 >= 0`) and `arr[i] >= arr[i+1]` (if `i+1 < n`). An array is called **mountain-shaped** if it consists of exactly one peak and values strictly increase upto the peak and then strictly decrease after the peak. Find the peak element in the array and return its index. If the array does not form a mountain shape, return `-1`.","solution":"def find_peak(arr): Returns the index of the peak element if the array is mountain-shaped. If the array does not form a mountain shape return -1. n = len(arr) if n < 3: return -1 peak_index = -1 # Find the peak for i in range(1, n-1): if arr[i] > arr[i-1] and arr[i] > arr[i+1]: if peak_index != -1: return -1 # more than one peak peak_index = i if peak_index == -1: return -1 # no peak found # Check for strictly increasing sequence before the peak for i in range(1, peak_index): if arr[i] <= arr[i-1]: return -1 # Check for strictly decreasing sequence after the peak for i in range(peak_index + 1, n): if arr[i] >= arr[i-1]: return -1 return peak_index"},{"question":"You are given an integer array `nums` where each element is unique. Find the maximum length of a subarray with contiguous elements in ascending order. The subarray elements must appear in the original order from `nums`. Return the length of the longest such subarray.","solution":"def max_length_ascending_subarray(nums): Returns the length of the longest subarray with contiguous elements in ascending order. if not nums: return 0 max_len = 1 curr_len = 1 for i in range(1, len(nums)): if nums[i] > nums[i-1]: curr_len += 1 max_len = max(max_len, curr_len) else: curr_len = 1 return max_len"},{"question":"You are given two integer arrays `startTime` and `endTime`, and an integer `queryTime`. The `i-th` student started doing their homework at the time `startTime[i]` and finished it at time `endTime[i]`. Both `startTime[i]` and `endTime[i]` are inclusive. Write a function that returns the number of students doing their homework at the `queryTime`. For example, if `startTime = [1, 2, 3]`, `endTime = [3, 2, 7]`, and `queryTime = 4`, the function should return 1, as only the third student is doing their homework at queryTime 4.","solution":"def busy_student(startTime, endTime, queryTime): Returns the number of students doing their homework at the queryTime. :param startTime: List[int], start times of students\' homework :param endTime: List[int], end times of students\' homework :param queryTime: int, time to check :return: int, number of students doing homework at queryTime count = 0 for start, end in zip(startTime, endTime): if start <= queryTime <= end: count += 1 return count"},{"question":"You are given a string `s` consisting of lowercase alphabets and an integer `k`. You need to perform the following operations in order to form a palindrome: - You can change any character `s[i]` to any other lowercase alphabet. Return the **minimum number of changes** required to make `s` a palindrome with **at most** `k` changes. If it is not possible to achieve this within the `k` changes, return `-1`.","solution":"def min_changes_to_palindrome(s, k): Returns the minimum number of changes required to make s a palindrome with at most k changes. If it is not possible, returns -1. n = len(s) changes_needed = 0 # First pass to determine the number of changes needed without limit for i in range(n // 2): if s[i] != s[n - i - 1]: changes_needed += 1 if changes_needed > k: return -1 return changes_needed"},{"question":"You are given a **0-indexed** array `nums` consisting of integers, and an integer `k`. Your goal is to find the **maximum** possible sum of a contiguous subarray of length `k`. If the length of the array is less than `k`, return `-1`. Given `nums` and `k`, return the maximum possible sum of any contiguous subarray of length `k`. Create a function that efficiently computes the result, considering time complexity and edge cases.","solution":"def max_sum_subarray(nums, k): Returns the maximum possible sum of any contiguous subarray of length k. If the length of the array is less than k, return -1. n = len(nums) if n < k: return -1 # Compute the sum of the first subarray of length k current_sum = sum(nums[:k]) max_sum = current_sum # Slide the window over the array for i in range(k, n): current_sum += nums[i] - nums[i - k] if current_sum > max_sum: max_sum = current_sum return max_sum"},{"question":"Given a non-empty string `s` representing the n-value encoded sequence of a run-length encoding (RLE) where the input pattern follows the standard format: <count><char>, decode it and return the expanded string. Note that there will be no white spaces in the input, and for each <count>, the character <char> occurs exactly <count> times. Each <count> is a positive integer. Example: ``` Input: s = \\"3a2b4c\\" Output: \\"aaabbcccc\\" ```","solution":"def decode_rle(s): Decodes a run-length encoded string. :param s: Encoded string in the format <count><char>. :return: Decoded string. decoded_string = \\"\\" i = 0 while i < len(s): count = 0 # Extract the number while s[i].isdigit(): count = count * 10 + int(s[i]) i += 1 # Append the character \'count\' number of times if i < len(s): decoded_string += s[i] * count i += 1 return decoded_string"},{"question":"You are given an array of integers `arr` and an integer `k`. You can perform the following operations any number of times: * Operation 1: Choose any subarray of length `k` and reverse it. * Operation 2: Increase any element of the array by 1. Return _the minimum number of operations needed to make all elements of the array equal_.","solution":"def min_operations_to_equal_elements(arr, k): Returns the minimum number of operations needed to make all elements of the array equal. max_element = max(arr) operations = 0 for elem in arr: operations += (max_element - elem) return operations"},{"question":"You are given an array of positive integers `nums` representing the values of coins in a line. You have two players, Alice and Bob, who take turns picking coins from either end of the line. Alice always goes first. The player who collects the coins of the maximum total value wins. Assume both players play optimally. Write a function that determines if Alice will win given her starting turn. The function should return a boolean value: `true` if Alice will win, and `false` if Bob will win.","solution":"def stoneGame(piles): Determines if Alice will win the stone game given her starting turn. :param piles: List[int], the values of the coins in the line :return: bool, True if Alice will win, False if Bob will win # Since the number of coins is even and both players are playing optimally, # Alice will always win if she picks first. return True"},{"question":"You are given an array of `n` integers and an integer `k`. Your task is to determine if there exists a contiguous subarray within the array whose sum equals `k`. If such a subarray exists, return `true`, otherwise return `false`. The subarray must include at least one element. Implement the function `bool hasSubarraySum(int[] arr, int k)` which takes two arguments: - `arr` is an array of `n` integers. - `k` is the target sum. The function should return a boolean value indicating whether any contiguous subarray of `arr` sums up to `k`.","solution":"def hasSubarraySum(arr, k): Determine if there exists a contiguous subarray within the array whose sum equals k. Parameters: arr (list): An array of n integers. k (int): The target sum. Returns: bool: True if such a subarray exists, otherwise False. current_sum = 0 sum_set = set() for num in arr: current_sum += num if current_sum == k: return True if (current_sum - k) in sum_set: return True sum_set.add(current_sum) return False"},{"question":"You are given a string `s` consisting of lowercase English letters and a 2D list `pairs` of integers where `pairs[i] = [a, b]` indicates that you can swap the characters at index `a` and index `b` of the string. You can swap the characters at any pair of indices in `pairs` as many times as you want. Return _the **lexicographically smallest** string that `s` can be converted to_ after applying the swaps in `pairs` as many times as you want.","solution":"def find(parent, x): if parent[x] != x: parent[x] = find(parent, parent[x]) return parent[x] def union(parent, x, y): rootX = find(parent, x) rootY = find(parent, y) if rootX != rootY: parent[rootY] = rootX def smallestStringWithSwaps(s, pairs): n = len(s) parent = list(range(n)) for a, b in pairs: union(parent, a, b) from collections import defaultdict components = defaultdict(list) for index in range(n): root = find(parent, index) components[root].append(index) s = list(s) for indices in components.values(): chars = sorted(s[index] for index in indices) for i, index in enumerate(sorted(indices)): s[index] = chars[i] return \\"\\".join(s)"},{"question":"Given a binary tree, return the **leftmost** value in the last row of the tree. Write an efficient algorithm to find this value in **O(n)** time complexity, where `n` is the number of nodes in the tree. Assume the tree is represented by a `TreeNode` class with `int val`, `TreeNode left`, and `TreeNode right` attributes.","solution":"from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def find_bottom_left_value(root): This function returns the leftmost value in the last row of the binary tree. We use a level-order traversal (BFS) to ensure we visit all nodes level-by-level. if not root: return None queue = deque([root]) leftmost_value = 0 while queue: num_nodes = len(queue) for i in range(num_nodes): node = queue.popleft() if i == 0: leftmost_value = node.val if node.left: queue.append(node.left) if node.right: queue.append(node.right) return leftmost_value"},{"question":"Given an array of integers representing stock prices on consecutive days, design an algorithm to determine the maximum profit you could achieve by making at most two trades. A trade consists of buying on one day and selling on another later day. Implement the `StockProfit` class: * `StockProfit(int[] prices)` Initializes the object with the array of stock prices. * `int maxProfit()` Returns the maximum profit achievable with at most two trades.","solution":"class StockProfit: def __init__(self, prices): Initializes the object with the array of stock prices. self.prices = prices def maxProfit(self): Returns the maximum profit achievable with at most two trades. if not self.prices or len(self.prices) < 2: return 0 # Create DP tables to store profits n = len(self.prices) profit = [[0 for _ in range(n)] for _ in range(3)] for k in range(1, 3): max_so_far = float(\'-inf\') for i in range(1, n): max_so_far = max(max_so_far, profit[k-1][i-1] - self.prices[i-1]) profit[k][i] = max(profit[k][i-1], self.prices[i] + max_so_far) return profit[2][-1]"},{"question":"A **monotonic array** is an array that is either entirely non-increasing or entirely non-decreasing. Given an integer array `arr`, return `true` if and only if the array is monotonic. An array `arr` is monotonic if for all `i <= j`, `arr[i] <= arr[j]` or for all `i <= j`, `arr[i] >= arr[j]`.","solution":"def is_monotonic(arr): Checks if the array is monotonic (either entirely non-increasing or non-decreasing). if len(arr) <= 1: return True increasing = decreasing = True for i in range(1, len(arr)): if arr[i] > arr[i - 1]: decreasing = False if arr[i] < arr[i - 1]: increasing = False if not increasing and not decreasing: return False return increasing or decreasing"},{"question":"Given an `m x n` matrix `mat` containing `0`s and `1`s, find the largest square containing only `1`s and return _its area_.","solution":"def maximalSquare(matrix): Given an m x n binary matrix filled with 0\'s and 1\'s, find the largest square containing only 1\'s and return its area. if not matrix or not matrix[0]: return 0 m, n = len(matrix), len(matrix[0]) dp = [[0] * n for _ in range(m)] max_side = 0 for i in range(m): for j in range(n): if matrix[i][j] == \'1\': # note: matrix contains \'0\' and \'1\' as characters if i == 0 or j == 0: dp[i][j] = 1 else: dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1 max_side = max(max_side, dp[i][j]) return max_side * max_side"},{"question":"You are given a string `s` consisting only of characters `\'a\'`, `\'b\'`, and `\'c\'`. You can perform several operations on this string where each operation is defined as follows: choose a non-empty substring of `s` and delete it if it is of the form `aabbcc`. You are required to determine whether you can remove all the characters in the string by performing this operation any number of times. Return `true` if it is possible to remove all the characters of the string, otherwise return `false`.","solution":"def can_remove_all_chars(s): Check if it is possible to remove all characters from the string by repeatedly removing \'aabbcc\'. Parameters: s (str): Input string Returns: bool: True if all characters can be removed, False otherwise while \'aabbcc\' in s: s = s.replace(\'aabbcc\', \'\') return not s"},{"question":"You are given a `root` node of a binary tree. Each node in the binary tree has a unique value. Implement a function that returns a list of the values of the nodes you encounter during an in-order traversal. In-order traversal involves visiting the left subtree, then the root node, and finally the right subtree. Return the resulting list of values. Example input: ``` 1 2 / 3 ``` Example output: `[1, 3, 2]`","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def in_order_traversal(root): Returns the list of values for the nodes encountered during an in-order traversal of the binary tree. result = [] def helper(node): if not node: return helper(node.left) result.append(node.value) helper(node.right) helper(root) return result"},{"question":"You are given a 0-indexed integer array `nums` of even length, and an integer `k`. Your task is to split the array into exactly `k` non-empty contiguous subarrays. Then, for each subarray, calculate the sum of its elements and find the maximum sum among all subarrays. Return the minimum possible value of this maximum sum.","solution":"def splitArray(nums, k): Split the array into exactly k non-empty contiguous subarrays such that the maximum sum among these subarrays is minimized. Args: nums: List[int] - The input array of integers. k: int - The number of subarrays to split into. Returns: int - The minimum possible value of the maximum sum of the subarrays. def can_split(nums, k, max_sum_limit): current_sum = 0 splits_required = 1 for num in nums: if current_sum + num > max_sum_limit: splits_required += 1 current_sum = num if splits_required > k: return False else: current_sum += num return True left, right = max(nums), sum(nums) while left < right: mid = (left + right) // 2 if can_split(nums, k, mid): right = mid else: left = mid + 1 return left"},{"question":"Design a LRU (Least Recently Used) Cache which supports the following operations: **get** and **put**. Implement the `LRUCache` class: * `LRUCache(int capacity)` Initializes the LRU cache with a positive size capacity. * `int get(int key)` Return the value of the `key` if the key exists, otherwise return -1. * `void put(int key, int value)` Update the value of the `key` if the `key` exists. Otherwise, add the `key-value` pair to the cache. If the number of keys exceeds the capacity from this operation, evict the least recently used key. The cache should maintain the order of usage in such a way that the most recently used keys come to the front of the cache and the least recently used keys are at the end. **Example:** ``` LRUCache cache = new LRUCache(2); cache.put(1, 1); cache.put(2, 2); cache.get(1); // returns 1 cache.put(3, 3); // evicts key 2 cache.get(2); // returns -1 (not found) cache.put(4, 4); // evicts key 1 cache.get(1); // returns -1 (not found) cache.get(3); // returns 3 cache.get(4); // returns 4 ```","solution":"class ListNode: A node in a doubly linked list def __init__(self, key=None, value=None): self.key = key self.value = value self.prev = None self.next = None class LRUCache: def __init__(self, capacity: int): self.cache = {} self.capacity = capacity self.head = ListNode() # dummy head self.tail = ListNode() # dummy tail self.head.next = self.tail self.tail.prev = self.head def _add_node(self, node): Add the new node right after head node.prev = self.head node.next = self.head.next self.head.next.prev = node self.head.next = node def _remove_node(self, node): Remove an existing node from the linked list prev = node.prev new = node.next prev.next = new new.prev = prev def _move_to_head(self, node): Move certain node in between to the head self._remove_node(node) self._add_node(node) def _pop_tail(self): Pop the current tail res = self.tail.prev self._remove_node(res) return res def get(self, key: int) -> int: node = self.cache.get(key, None) if not node: return -1 # move the accessed node to the head self._move_to_head(node) return node.value def put(self, key: int, value: int) -> None: node = self.cache.get(key) if not node: newNode = ListNode(key, value) self.cache[key] = newNode self._add_node(newNode) if len(self.cache) > self.capacity: # pop the tail tail = self._pop_tail() del self.cache[tail.key] else: # update the value node.value = value self._move_to_head(node)"},{"question":"You are given a string `s` consisting of lowercase English letters, where each letter can be duplicated multiple times. Your task is to return the **minimum number of deletions** required so that any character does not appear more than a specified `m` times consecutively. More formally, no letter in the resulting string should appear more than `m` times in a row. Return the integer denoting the minimum number of deletions needed.","solution":"def min_deletions_to_avoid_repeating_chars(s, m): deletions = 0 i = 0 while i < len(s): count = 1 while i + 1 < len(s) and s[i] == s[i + 1]: count += 1 i += 1 if count > m: deletions += count - m i += 1 return deletions"},{"question":"A company has `n` employees represented by unique IDs from `0` to `n-1`. The company hierarchy is given as a **tree** structure where the CEO is represented by the root node `0`. You are given a **0-indexed** integer array `manager`, where `manager[i]` is the direct manager of employee `i`. For the root node (CEO), `manager[0] == -1`. Each employee has specific monthly performance scores recorded in a **0-indexed** integer array `performance`, where `performance[i]` is the performance score for employee `i`. You are tasked with implementing a function that returns an array `best_performer` of length `n` such that `best_performer[i]` contains the ID of the employee in the subtree rooted at `i` (including `i` itself) who has the highest performance score. The subtree rooted at an employee `x` contains `x` and all of its descendant nodes in the hierarchy. If there is a tie for the highest performance score, return the ID of the employee with the smallest ID. **Note**: - The company has at least one employee. - It is guaranteed that the input forms a valid tree. ```python def best_performer_in_subtree(manager: List[int], performance: List[int]) -> List[int]: # Function implementation here ``` **Example:** ```text Input: manager = [-1, 0, 0, 1, 1, 2, 2], performance = [5, 3, 3, 2, 4, 1, 6] Output: [6, 4, 6, 3, 4, 5, 6] ```","solution":"from typing import List import collections def best_performer_in_subtree(manager: List[int], performance: List[int]) -> List[int]: n = len(manager) tree = collections.defaultdict(list) # Build the tree for i in range(1, n): tree[manager[i]].append(i) def dfs(node): best = node # Traverse all children for child in tree[node]: candidate = dfs(child) if (performance[candidate] > performance[best]) or (performance[candidate] == performance[best] and candidate < best): best = candidate result[node] = best return best result = [0] * n dfs(0) return result"},{"question":"You are given a `binary tree` with `root` node. Implement a function to serialize the binary tree to a string and then deserialize that string back to a binary tree. Serialization is converting a tree to a single string, and deserialization is converting the string back to a tree. You may serialize the tree to a pre-order traversal string where empty nodes are represented by `null`. For example, given the binary tree: 1 / 2 3 / 4 5 The pre-order traversal serialization could be `1,2,null,null,3,4,null,null,5,null,null`. Create functions `serialize` and `deserialize` where: - `serialize(root: TreeNode) -> str`: Serializes a tree to a single string. - `deserialize(data: str) -> TreeNode`: Deserializes a single string to a tree. Return the root of the tree after deserialization.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def serialize(root): Encodes a tree to a single string. def preorder(node): if not node: vals.append(\\"null\\") return vals.append(str(node.val)) preorder(node.left) preorder(node.right) vals = [] preorder(root) return \',\'.join(vals) def deserialize(data): Decodes your encoded data to tree. def build(): val = next(vals) if val == \\"null\\": return None node = TreeNode(int(val)) node.left = build() node.right = build() return node vals = iter(data.split(\',\')) return build()"},{"question":"Given an **m x n** integer matrix `heights` representing the height of each cell, you need to find the maximum height difference between any two adjacent cells in the matrix. Two cells are considered adjacent if they share a common edge. Return the maximum height difference found in the matrix.","solution":"def max_adjacent_height_difference(heights): Returns the maximum height difference between any two adjacent cells in the matrix heights. if not heights or not heights[0]: return 0 m, n = len(heights), len(heights[0]) max_diff = 0 for i in range(m): for j in range(n): if i > 0: max_diff = max(max_diff, abs(heights[i][j] - heights[i-1][j])) if i < m - 1: max_diff = max(max_diff, abs(heights[i][j] - heights[i+1][j])) if j > 0: max_diff = max(max_diff, abs(heights[i][j] - heights[i][j-1])) if j < n - 1: max_diff = max(max_diff, abs(heights[i][j] - heights[i][j+1])) return max_diff"},{"question":"You are given an undirected graph described by an integer `n`, the number of nodes, and an array `edges`, where each `edges[i] = [ui, vi]` indicates that there is an edge between `ui` and `vi`. Return `true` if the graph is bipartite, otherwise return `false`. A graph is bipartite if the set of nodes can be partitioned into two subsets such that no two nodes within the same subset are connected by an edge. The input guarantees that all node values `0 ≤ ui, vi < n` and there are no self-loops or repeated edges.","solution":"def is_bipartite(n, edges): Checks if the graph is bipartite. n: Number of nodes in the graph. edges: List of edges where each edge is a tuple (ui, vi). Returns True if the graph is bipartite, otherwise False. from collections import deque # Create adjacency list adj_list = [[] for _ in range(n)] for u, v in edges: adj_list[u].append(v) adj_list[v].append(u) # -1 indicates no color is assigned, 0 and 1 are two different colors colors = [-1] * n def bfs(start_node): queue = deque([start_node]) colors[start_node] = 0 # Start coloring with 0 while queue: node = queue.popleft() current_color = colors[node] next_color = 1 - current_color for neighbor in adj_list[node]: if colors[neighbor] == -1: # Not colored yet colors[neighbor] = next_color queue.append(neighbor) elif colors[neighbor] == current_color: # Conflict in coloring return False return True for i in range(n): if colors[i] == -1: # Check unvisited node if not bfs(i): return False return True"},{"question":"You are given two strings `word1` and `word2`. You want to construct the longest string `s` such that `s` is a subsequence of both `word1` and `word2`. A subsequence of a string is obtained by deleting some (possibly none) characters from the string without changing the order of the remaining characters. Return the length of the longest common subsequence of `word1` and `word2`.","solution":"def longest_common_subsequence(word1, word2): Returns the length of the longest common subsequence between word1 and word2. m, n = len(word1), len(word2) # Create a 2D array to store lengths of longest common subsequence. dp = [[0] * (n + 1) for _ in range(m + 1)] # Build the dp array from bottom up. for i in range(1, m + 1): for j in range(1, n + 1): if word1[i - 1] == word2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) return dp[m][n]"},{"question":"Consider a grid of size `m x n` where `m` is the number of rows and `n` is the number of columns. Each cell in the grid has a value representing the cost of stepping on that cell. You are initially at the top-left corner of the grid (position `(0, 0)`) and you need to reach the bottom-right corner of the grid (position `(m-1, n-1)`). In one step, you can move from a cell `(i, j)` to `(i+1, j)` (down) or `(i, j+1)` (right). Your task is to compute the minimum cost to reach the bottom-right corner from the top-left corner.","solution":"def min_path_sum(grid): Given a 2D grid, find the minimum cost path from top-left to bottom-right. You can only move down or right at any point in time. :param grid: List[List[int]], a 2D list representing the grid :return: int, the minimum cost to reach the bottom-right corner if not grid or not grid[0]: return 0 m, n = len(grid), len(grid[0]) # Initialize the cost grid with the same dimensions as the input grid. cost = [[0] * n for _ in range(m)] # Initial cell cost[0][0] = grid[0][0] # Initialize the first column of the cost grid. for i in range(1, m): cost[i][0] = cost[i-1][0] + grid[i][0] # Initialize the first row of the cost grid. for j in range(1, n): cost[0][j] = cost[0][j-1] + grid[0][j] # Fill in the remaining cells of the cost grid. for i in range(1, m): for j in range(1, n): cost[i][j] = min(cost[i-1][j], cost[i][j-1]) + grid[i][j] return cost[m-1][n-1]"},{"question":"You are given a string `s` consisting only of characters \'a\' and \'b\'. You can delete any two adjacent characters if they are different. For example, if the string is \\"ab\\" or \\"ba\\", you can delete both characters in one move and the string will become empty. Given this operation, return the length of the shortest possible string that can be obtained. ```python def min_length(s: str) -> int: # Write your code here ```","solution":"def min_length(s: str) -> int: Returns the length of the shortest possible string after performing the delete operation on any two adjacent characters if they are different. stack = [] for char in s: if stack and stack[-1] != char: stack.pop() else: stack.append(char) return len(stack)"},{"question":"Given an array of non-negative integers `nums`, you are tasked to implement the `SparseVector` class to efficiently handle vector operations for large sparse vectors. The class should support the following operations: * `SparseVector(vector<int> &nums)` initializes the object with the integer array `nums`. * `int dotProduct(SparseVector &vec)` returns the dot product of the current vector and the specified `SparseVector`. The dot product is defined as the sum of the products of the corresponding elements of the two vectors. Implement the `SparseVector` class to optimize space and time complexities for sparse vectors, where most of the elements are zeros.","solution":"class SparseVector: def __init__(self, nums): Initialize the SparseVector with an array of integers. Instead of storing 0\'s, only store non-zero elements in a dictionary. self.non_zero_elements = {i: num for i, num in enumerate(nums) if num != 0} def dotProduct(self, vec): Return the dot product of two sparse vectors. Dot product is the sum of products of corresponding elements. result = 0 for idx, value in self.non_zero_elements.items(): if idx in vec.non_zero_elements: result += value * vec.non_zero_elements[idx] return result"},{"question":"Given a graph represented by an adjacency list, each node in the graph represents a course, and each directed edge represents a prerequisite relationship. You need to find if it is possible to finish all courses by checking whether there are any cycles in the graph. Return _true_ if it is possible to finish all courses (i.e., there are no cycles), and _false_ otherwise.","solution":"def can_finish_courses(num_courses, prerequisites): Determines if all courses can be finished by checking for cycles in the graph. :param num_courses: The number of courses :param prerequisites: List of prerequisite pairs :return: True if all courses can be finished, False otherwise from collections import defaultdict, deque # Create adjacency list graph = defaultdict(list) in_degree = {i: 0 for i in range(num_courses)} for prereq in prerequisites: next_course, prev_course = prereq graph[prev_course].append(next_course) in_degree[next_course] += 1 # Initialize queue with courses having no prerequisites queue = deque([k for k in in_degree if in_degree[k] == 0]) # Count of visited courses visited_count = 0 while queue: current = queue.popleft() visited_count += 1 for neighbor in graph[current]: in_degree[neighbor] -= 1 if in_degree[neighbor] == 0: queue.append(neighbor) # If visited count is equal to number of courses, no cycle detected return visited_count == num_courses"},{"question":"A company has a hierarchical department structure represented as an `n`-ary tree, where each node represents a department and has a unique ID. The root node represents the top-most department. Each node has a list of its immediate sub-departments. Given the root of this tree, find the lowest common manager (LCM) between two given department IDs `id1` and `id2`. The LCM is the lowest node in the tree that has both `id1` and `id2` as descendants (where we allow a node to be a descendant of itself). Return the ID of the LCM.","solution":"class TreeNode: def __init__(self, id): self.id = id self.children = [] def find_lcm(root, id1, id2): if not root: return None if root.id == id1 or root.id == id2: return root count = 0 temp = None for child in root.children: res = find_lcm(child, id1, id2) if res: count += 1 temp = res if count == 2: return root return temp"},{"question":"Given an array of `arrival` and `departure` times for `N` trains, determine the minimum number of platforms required at the railway station so that no train waits. Each element in the `arrival` array represents the arrival time of a train, and the corresponding element in the `departure` array represents the departure time of that train. Each train needs one platform for its entire duration from arrival to departure. Arrival and departure times are given in the 24-hour format (e.g., `1430` for 2:30 PM).","solution":"def find_minimum_platforms(arrival, departure): Returns the minimum number of platforms required for the given arrival and departure times. # Sort both the arrays arrival.sort() departure.sort() n = len(arrival) platform_needed = 1 result = 1 i = 1 # Pointer to the next arrival event j = 0 # Pointer to the next departure event while i < n and j < n: # If next event in the sorted order is arrival, increment count of platforms needed if arrival[i] <= departure[j]: platform_needed += 1 i += 1 # Else decrement count of platforms needed else: platform_needed -= 1 j += 1 # Update result if needed if platform_needed > result: result = platform_needed return result"},{"question":"Given a string `s` and an array of pairs of indices in the string `pairs` where pairs[i] = [a, b] represents a swap operation that can be performed on the characters at indices `a` and `b`, return the lexicographically smallest string that `s` can be transformed into after using the swap operations any number of times. **Example:** * Input: `s = \\"dcab\\", pairs = [[0,3],[1,2]]` * Output: `\\"bacd\\"` **Example:** * Input: `s = \\"dcab\\", pairs = [[0,3],[1,2],[0,2]]` * Output: `\\"abcd\\"` **Constraints:** * `1 <= s.length <= 1000` * `0 <= pairs.length <= 1000` * `0 <= pairs[i][0], pairs[i][1] < s.length` * `s` consists of lower-case English letters.","solution":"def smallestStringWithSwaps(s, pairs): from collections import defaultdict parent = list(range(len(s))) def find(x): if parent[x] != x: parent[x] = find(parent[x]) return parent[x] def union(x, y): rootX = find(x) rootY = find(y) if rootX != rootY: parent[rootY] = rootX for a, b in pairs: union(a, b) components = defaultdict(list) for i, p in enumerate(parent): components[find(p)].append(i) res = list(s) for indices in components.values(): chars = sorted(res[i] for i in indices) for idx, char in zip(sorted(indices), chars): res[idx] = char return \'\'.join(res)"},{"question":"Given a binary tree, return the **level order traversal** of its nodes\' values. (i.e., from left to right, level by level). The tree is represented as an array where `array[i]` gives the value of the ith node in a breadth-first order. Return the traversal as a list of lists, where each list contains the node values at each level.","solution":"from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def build_tree_from_list(values): Helper function to build a tree from a list representation. if not values: return None root = TreeNode(values[0]) queue = deque([root]) i = 1 while i < len(values): node = queue.popleft() if values[i] is not None: node.left = TreeNode(values[i]) queue.append(node.left) i += 1 if i < len(values) and values[i] is not None: node.right = TreeNode(values[i]) queue.append(node.right) i += 1 return root def level_order_traversal(root): Returns the level order traversal of a binary tree as a list of lists. if not root: return [] result = [] queue = deque([root]) while queue: level_size = len(queue) level_nodes = [] for _ in range(level_size): node = queue.popleft() level_nodes.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.append(level_nodes) return result"},{"question":"You are given an array `events` where `events[i] = [startDayi, endDayi]` represents an event that starts at `startDayi` and ends at `endDayi`. You can attend an event `i` at any day between `startDayi` and `endDayi` (inclusive). Note that you can only attend one event per day. Find the maximum number of events you can attend.","solution":"def maxEvents(events): Returns the maximum number of events one can attend from a given list of events. :param events: List of lists, where each sublist contains two integers [startDayi, endDayi] representing the start and end day of an event. :return: Maximum number of events that can be attended if only one event can be attended per day. events.sort(key=lambda x: x[1]) # Sort events by their end days attended_days = set() max_events = 0 for start, end in events: for day in range(start, end + 1): if day not in attended_days: attended_days.add(day) max_events += 1 break return max_events"},{"question":"You are given a matrix `grid` of `n x m` size, where each element is either `0` or `1`. A *closed island* is surrounded by `1`s on all four sides (including diagonals) and can only contain `0`s inside. Any `0` on the border of the grid is not considered an island. Return the number of closed islands in the given matrix `grid`. For example, given the matrix `grid` as follows: ``` 110111 100101 111101 110111 ``` In this matrix, there is one closed island (the one formed by the single 0 in the middle).","solution":"def closed_island(grid): Returns the number of closed islands in the given matrix grid. A closed island is surrounded by 1\'s on all four sides and can only contain 0\'s inside. def dfs(i, j): if i < 0 or j < 0 or i >= len(grid) or j >= len(grid[0]): return False # This means we reached the border (not a closed island) if grid[i][j] == 1: return True # This means this part is surrounded # Mark the part of the grid as visited by changing 0 to 1 grid[i][j] = 1 # Check in all four directions top = dfs(i-1, j) bottom = dfs(i+1, j) left = dfs(i, j-1) right = dfs(i, j+1) # If all four directions are surrounded then it\'s a closed island return top and bottom and left and right closed_islands_count = 0 # Iterate through the grid for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == 0: # Start a DFS if it\'s part of an island if dfs(i, j): # If it\'s a closed island increment the count closed_islands_count += 1 return closed_islands_count"},{"question":"Given a binary tree, write a function to check whether it is a mirror of itself (i.e., symmetric around its center). Implement the function `bool isSymmetric(TreeNode* root)` where: - `TreeNode` is a structure with the following attributes: - `int val` - the value of the node - `TreeNode* left` - a pointer to the left child node - `TreeNode* right` - a pointer to the right child node The function should return `true` if the binary tree is symmetric, and `false` otherwise.","solution":"# Definition for a binary tree node. class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def isSymmetric(root: TreeNode) -> bool: Check whether the binary tree is symmetric around its center. def isMirror(t1: TreeNode, t2: TreeNode) -> bool: if t1 is None and t2 is None: return True if t1 is None or t2 is None: return False return (t1.val == t2.val) and isMirror(t1.right, t2.left) and isMirror(t1.left, t2.right) return isMirror(root, root)"},{"question":"Determine if a given string containing only the characters `\'(\'` and `\')\'` is a valid parentheses string (VPS). A valid parentheses string is defined as follows: - An empty string is a valid parentheses string. - If `A` is a valid parentheses string, then `(` + `A` + `)` is a valid parentheses string. - If `A` and `B` are valid parentheses strings, then `A` + `B` is a valid parentheses string. Given a string `s`, return `True` if it is a valid parentheses string and `False` otherwise.","solution":"def is_valid_parentheses(s): Returns True if s is a valid parentheses string, otherwise False. balance = 0 for char in s: if char == \'(\': balance += 1 elif char == \')\': balance -= 1 if balance < 0: return False return balance == 0"},{"question":"You are given a list of `n` integers `nums` where each integer is in the range from 1 to `n`. Each integer appears exactly once except for one integer which appears twice and one integer which is missing. Find and return the duplicated integer and the missing integer as a list in the form `[duplicate, missing]`.","solution":"def find_error_nums(nums): Finds the duplicated and missing numbers in the list. Args: nums (List[int]): List of integers where one integer appears twice and one is missing. Returns: List[int]: A list containing the duplicate number and the missing number in the form [duplicate, missing]. n = len(nums) expected_sum = n * (n + 1) // 2 expected_sum_squared = n * (n + 1) * (2 * n + 1) // 6 actual_sum = sum(nums) actual_sum_squared = sum(x * x for x in nums) diff_sum = expected_sum - actual_sum diff_sum_squared = expected_sum_squared - actual_sum_squared missing = (diff_sum + diff_sum_squared // diff_sum) // 2 duplicate = missing - diff_sum return [duplicate, missing]"},{"question":"Given a string `sequence` and an array of strings `words`, find the length of the longest string in `words` that is a subsequence of `sequence`. A subsequence is a sequence that can be derived from another sequence by deleting some elements without changing the order of the remaining elements. Implement a function that returns this length. If no word in `words` is a subsequence of `sequence`, return `0`.","solution":"def is_subsequence(seq, word): Helper function to check if \'word\' is a subsequence of \'seq\'. it = iter(seq) return all(char in it for char in word) def longest_subsequence_length(sequence, words): Returns the length of the longest string in \'words\' that is a subsequence of \'sequence\'. If no word is a subsequence of \'sequence\', returns 0. max_length = 0 for word in words: if is_subsequence(sequence, word): max_length = max(max_length, len(word)) return max_length"},{"question":"Given an integer array `nums` of size `n`, return _an array of size `n` where the value at each index `i` is equal to the product of all elements in the input array except_ `nums[i]`. You must write an algorithm that runs in _O(n)_ time and uses only _O(1)_ extra space (excluding the output array). The division operation is not allowed.","solution":"def product_except_self(nums): Returns an array where each element at index i is the product of all elements in the input array except nums[i]. The function runs in O(n) time and uses O(1) extra space (excluding the output array). Division is not used in this solution. n = len(nums) result = [1] * n # Traverse from left to right left_product = 1 for i in range(n): result[i] = left_product left_product *= nums[i] # Traverse from right to left right_product = 1 for i in reversed(range(n)): result[i] *= right_product right_product *= nums[i] return result"},{"question":"Given a list of integers `numbers`, write a function to find a continuous subarray that is non-empty and has the greatest possible sum, and return its sum. A subarray is a contiguous part of the array. The function should have the signature: `int maximumSubarraySum(vector<int> numbers)`. For example, if `numbers = [-2, 1, -3, 4, -1, 2, 1, -5, 4]`, the function should return `6`, as the subarray `[4, -1, 2, 1]` has the largest sum of `6`.","solution":"def maximum_subarray_sum(numbers): Finds the contiguous subarray within a one-dimensional numeric array which has the largest sum. :param numbers: List of integers :return: The largest sum of the contiguous subarray if not numbers: return 0 max_current = max_global = numbers[0] for num in numbers[1:]: max_current = max(num, max_current + num) if max_current > max_global: max_global = max_current return max_global"},{"question":"You are given two integer arrays `start` and `end` each of length `n` representing the starting and ending times of `n` children playing with toys in a playground. The playground can only accommodate one child playing at a time. You need to determine the minimum number of playgrounds required such that no child\'s playtime overlaps with another. Return the minimum number of playgrounds needed.","solution":"def min_playgrounds(start, end): Determine the minimum number of playgrounds required such that no child\'s playtime overlaps with another. Parameters: start (List[int]): Start times of the children. end (List[int]): End times of the children. Returns: int: Minimum number of playgrounds required. events = [] for s in start: events.append((s, 1)) # 1 indicates a start event for e in end: events.append((e, -1)) # -1 indicates an end event events.sort() # Sort events primarily by time max_playgrounds = 0 current_playgrounds = 0 for event in events: current_playgrounds += event[1] max_playgrounds = max(max_playgrounds, current_playgrounds) return max_playgrounds"},{"question":"You are given an integer array `packages` where `packages[i]` represents the weight of the `i-th` package. You have a shipping truck that has a weight capacity `capacity`. You want to load some packages into the truck such that their total weight is **as large as possible** but does not exceed the truck\'s capacity. Return _the **total weight** of the packages that can be loaded onto the truck without exceeding the truck\'s capacity_. You must use each package **at most once**.","solution":"def max_load(packages, capacity): Returns the maximum total weight of the packages that can be loaded onto the truck without exceeding the truck\'s capacity. Args: packages (list of int): List of package weights. capacity (int): The maximum capacity of the truck. Returns: int: The maximum total weight of the packages that can be loaded onto the truck without exceeding the capacity. # Sort the packages to try and fit the heaviest packages first packages.sort(reverse=True) total_weight = 0 for weight in packages: if total_weight + weight <= capacity: total_weight += weight return total_weight"},{"question":"You are given an array of integers `temperature`, where `temperature[i]` represents the temperature on the `i-th` day. Define a \\"warm period\\" as a consecutive sequence of days where the temperature only increases. Find the longest warm period, and return the number of days in this period. If there are multiple warm periods with the same length, return the earliest period in terms of starting day. Return _the length of the longest warm period_.","solution":"def longest_warm_period(temperature): Returns the length of the longest warm period. if not temperature: return 0 max_length = 0 current_length = 1 for i in range(1, len(temperature)): if temperature[i] > temperature[i - 1]: current_length += 1 else: if current_length > max_length: max_length = current_length current_length = 1 if current_length > max_length: max_length = current_length return max_length"},{"question":"You are given a **0-indexed** string `s` of length `n` consisting of only the characters `\'a\'`, `\'b\'`, and `\'c\'`. You are allowed to remove **at most one** character from the string. Your task is to determine whether it is possible to rearrange the string after removing at most one character so that no two adjacent characters are the same. Return `true` if it is possible, otherwise return `false`.","solution":"def can_rearrange_without_adjacent(s): Determines if it is possible to rearrange the string after removing at most one character so that no two adjacent characters are the same. :param s: a string of length n consisting of characters \'a\', \'b\', and \'c\'. :return: True if possible, otherwise False. from collections import Counter # Count the frequency of each character count = Counter(s) # Find the most common character frequency max_freq = max(count.values()) # If the most frequent character occurs more times than half the string\'s # length (rounded up), then it\'s impossible to arrange without two adjacent # characters being the same, even after removing one character if max_freq > (len(s) + 1) // 2: return False return True"},{"question":"You are given a string `input` representing a mathematical expression that may contain integers and operators `+`, `-`, `*`, and `/`. The expression does not contain any parentheses. Implement a function that evaluates the expression and returns the result as an integer. All intermediate results and the final result should be rounded towards zero if they are floating-point numbers. For example, `\\"14-3/2\\"` should return `13` because `3/2` equals `1.5`, which is rounded towards zero to `1`.","solution":"def evaluate_expression(expression): def apply_operator(operators, values): operator = operators.pop() right = values.pop() left = values.pop() if operator == \'+\': values.append(left + right) elif operator == \'-\': values.append(left - right) elif operator == \'*\': values.append(left * right) elif operator == \'/\': # Using integer division to automatically truncate towards zero values.append(int(left / right)) def precedence(op): if op == \'+\' or op == \'-\': return 1 if op == \'*\' or op == \'/\': return 2 return 0 values = [] operators = [] i = 0 while i < len(expression): if expression[i] == \' \': i += 1 continue if expression[i] >= \'0\' and expression[i] <= \'9\': val = 0 while (i < len(expression) and expression[i] >= \'0\' and expression[i] <= \'9\'): val = val * 10 + int(expression[i]) i += 1 values.append(val) i -= 1 else: while (len(operators) != 0 and precedence(operators[-1]) >= precedence(expression[i])): apply_operator(operators, values) operators.append(expression[i]) i += 1 while len(operators) != 0: apply_operator(operators, values) return values[-1]"},{"question":"You are given a string `s` containing only digits and an integer `n`. You need to split the string `s` into exactly `n` segments such that each segment represents a valid English word (e.g., \\"one\\", \\"two\\", \\"three\\"). Return _whether it is possible to split the string in such a manner_. Note that the same word can be used multiple times in different segments, and each digit must belong to exactly one segment.","solution":"def is_valid_word_segment(s, n): digit_word_map = { \\"0\\": \\"zero\\", \\"1\\": \\"one\\", \\"2\\": \\"two\\", \\"3\\": \\"three\\", \\"4\\": \\"four\\", \\"5\\": \\"five\\", \\"6\\": \\"six\\", \\"7\\": \\"seven\\", \\"8\\": \\"eight\\", \\"9\\": \\"nine\\" } def can_form_words(s, n): if n == 0: return s == \\"\\" for length in range(1, len(s) + 1): if s[:length] in digit_word_map.values() and can_form_words(s[length:], n - 1): return True return False return can_form_words(s, n)"},{"question":"Given a matrix `mat` of size `m x n` consisting of non-negative integers, return `a list of integers` where each integer represents the sum of the elements in each row of the matrix. The matrix is guaranteed to have at least one row and one column.","solution":"def sum_of_rows(mat): Returns a list of integers where each integer represents the sum of the elements in each row of the matrix. Parameters: mat (list of list of int): The input matrix. Matrix should contain non-negative integers. Returns: list of int: A list containing the sum of elements for each row. return [sum(row) for row in mat]"},{"question":"You are given a string `s` consisting of lowercase English letters and a list of operations. Each operation is represented as a pair of integers `(i, j)` and requires you to swap the characters at position `i` and `j` in the string. You need to perform all the operations in the given order and then return the resulting string. If there are multiple possible results after performing the swaps due to operations being cyclic or having no effect, return any valid result. Return the final string after performing all the given operations.","solution":"def perform_operations(s, operations): Given a string s and a list of operations, perform the swapping of characters at given positions and return the resulting string. Parameters: s (str): The input string. operations (list): A list of tuples where each tuple contains two indices for swap operation. Returns: str: The resulting string after performing all swap operations. s = list(s) for i, j in operations: s[i], s[j] = s[j], s[i] return \'\'.join(s)"},{"question":"You are given two strings `s` and `p`, where `s` is the main string and `p` is the pattern string. You need to design a function that finds all the start indices of `p`\'s anagrams in `s`. The output should be an array of all the starting indices. An Anagram of a string is a string that contains the same characters, only the order of characters can be different. *Example:* ```plaintext Input: s = \\"cbaebabacd\\", p = \\"abc\\" Output: [0, 6] Explanation: The substring with start index = 0 is \\"cba\\", which is an anagram of \\"abc\\". The substring with start index = 6 is \\"bac\\", which is an anagram of \\"abc\\". ``` Return _an array of all the start indices of `p`\'s anagrams in `s`._","solution":"from collections import Counter def find_anagrams(s, p): Finds all start indices of p\'s anagrams in s. Parameters: s (str): The main string. p (str): The pattern string. Returns: list: A list of starting indices of anagrams of p in s. p_counter = Counter(p) s_counter = Counter(s[:len(p) - 1]) result = [] for i in range(len(p) - 1, len(s)): start_index = i - len(p) + 1 s_counter[s[i]] += 1 if s_counter == p_counter: result.append(start_index) s_counter[s[start_index]] -= 1 if s_counter[s[start_index]] == 0: del s_counter[s[start_index]] return result"},{"question":"You are given a list of non-negative integers `arr`, representing the number of stones in each pile of stones. Every turn, you can take any number of stones from any single pile, but you must take at least one stone. The player who cannot make a move loses. Return _True_ if the first player to move has a winning strategy, otherwise return _False_. Assume both players play optimally.","solution":"def nim_game(arr): Returns True if the first player has a winning strategy in the Nim game, otherwise returns False. xor_sum = 0 for pile in arr: xor_sum ^= pile return xor_sum != 0"},{"question":"Given the head of a sorted linked list, remove all nodes that have duplicate numbers, leaving only distinct numbers from the original list. Return the linked list **sorted** as well. Example: ``` Input: head = [1,2,3,3,4,4,5] Output: [1,2,5] ```","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def delete_duplicates(head): Remove all nodes that have duplicate numbers from a sorted linked list, leaving only distinct numbers from the original list. dummy = ListNode(0) dummy.next = head prev = dummy while head: if head.next and head.val == head.next.val: while head.next and head.val == head.next.val: head = head.next prev.next = head.next else: prev = prev.next head = head.next return dummy.next def list_to_linkedlist(elements): dummy = ListNode(0) current = dummy for element in elements: current.next = ListNode(element) current = current.next return dummy.next def linkedlist_to_list(head): elements = [] while head: elements.append(head.val) head = head.next return elements"},{"question":"You are given a string consisting of only the characters \'a\', \'b\', and \'c\'. Remove the minimum number of characters so that the string does not contain any three consecutive identical characters (i.e., \\"aaa\\", \\"bbb\\", or \\"ccc\\"). Return _the length of the string after removal_.","solution":"def remove_minimum_characters(s): Removes the minimum number of characters from the string s so that it does not contain any three consecutive identical characters. Returns the length of the string after removal. if not s: return 0 result = [] for char in s: if len(result) >= 2 and result[-1] == result[-2] == char: continue result.append(char) return len(result)"},{"question":"Given a 2D grid of size `m x n` and an integer `k`, each cell represents an elevation map where `grid[i][j]` is the height at location `(i, j)`. You are currently at the top-left corner `(0, 0)` and you want to move to the bottom-right corner `(m-1, n-1)`. You can move up, down, left, or right, and you can only pass through cells with an elevation difference of no more than `k` from the current cell. Return the minimum path length to get from the top-left to the bottom-right corner. If it\'s not possible to reach the destination, return -1.","solution":"from collections import deque def min_path_length(grid, k): Returns the minimum path length to get from the top-left to the bottom-right corner in the grid with elevation constraints. If it\'s not possible, return -1. m, n = len(grid), len(grid[0]) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] visited = set((0, 0)) queue = deque([(0, 0, 0)]) while queue: x, y, length = queue.popleft() # Check if we have reached the destination if x == m - 1 and y == n - 1: return length for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and (nx, ny) not in visited: if abs(grid[nx][ny] - grid[x][y]) <= k: visited.add((nx, ny)) queue.append((nx, ny, length + 1)) # If we exhausted the queue without finding the destination return -1"},{"question":"You have an unsorted array `nums` of integers, which may contain duplicates. Write an algorithm to return the **length** of the **longest consecutive elements sequence**. Your algorithm should run in **O(n)** time. # Example: **Input:** nums = [100, 4, 200, 1, 3, 2] **Output:** 4 **Explanation:** The longest consecutive sequence is [1, 2, 3, 4]. Therefore, its length is 4. **Note:** - Elements in the sequence must be consecutive integers; you cannot skip any numbers in the sequence. - The solution must have a time complexity of O(n).","solution":"def longest_consecutive(nums): Returns the length of the longest consecutive elements sequence in the unsorted array. if not nums: return 0 num_set = set(nums) max_length = 0 for num in num_set: if num - 1 not in num_set: # Check if it\'s the start of a sequence current_num = num current_length = 1 while current_num + 1 in num_set: current_num += 1 current_length += 1 max_length = max(max_length, current_length) return max_length"},{"question":"Write a function that takes in an array of integers `nums` where every element appears twice except for one. Find that single one and return it. Your algorithm should have a linear runtime complexity and use only constant extra space.","solution":"def single_number(nums): Find the single element in an array of integers where every other element appears twice. Args: nums (List[int]): Array of integers. Returns: int: The single element. unique = 0 for num in nums: unique ^= num return unique"},{"question":"You are given a list of integers `nums` representing a number of houses on a street, where each element represents the amount of money hidden in that house. A thief is planning to rob the street and needs to maximize the money he can get under the following constraint: he cannot rob two consecutive houses. Write a function that returns the maximum amount of money the thief can rob without alerting the police.","solution":"def rob(nums): Returns the maximum amount of money the thief can rob without robbing two consecutive houses. if not nums: return 0 if len(nums) == 1: return nums[0] # Initialize variables to track the maximum amount of money prev = 0 current = 0 for num in nums: temp = current current = max(current, prev + num) prev = temp return current"},{"question":"Implement a `StringCompressor` class to perform basic string compression using the counts of repeated characters. For example, the string \\"aabcccccaaa\\" would become \\"a2b1c5a3\\". If the \\"compressed\\" string would not become smaller than the original string, your method should return the original string. The `StringCompressor` class should include the following methods: * `StringCompressor()` Initializes the object. * `string compress(const string& s)` Compresses the string `s` and returns the compressed string or the original string if compression does not reduce the length.","solution":"class StringCompressor: def __init__(self): pass def compress(self, s: str) -> str: if not s: return s compressed = [] count = 1 for i in range(1, len(s)): if s[i] == s[i - 1]: count += 1 else: compressed.append(s[i - 1] + str(count)) count = 1 compressed.append(s[-1] + str(count)) # Append the last character and its count compressed_string = \'\'.join(compressed) if len(compressed_string) < len(s): return compressed_string else: return s"},{"question":"You are given a string `s` consisting of lowercase English letters and an integer `k`. You can select up to `k` characters from `s` and change all occurrences of those characters into any other single character. Return _the length of the longest substring containing only one unique character after performing the character changes_.","solution":"def longest_substring_with_changes(s, k): Returns the length of the longest substring containing only one unique character after performing up to k changes. from collections import defaultdict n = len(s) if n == 0: return 0 left = 0 max_len = 0 max_count = 0 char_count = defaultdict(int) for right in range(n): char_count[s[right]] += 1 max_count = max(max_count, char_count[s[right]]) if (right - left + 1 - max_count) > k: char_count[s[left]] -= 1 left += 1 max_len = max(max_len, right - left + 1) return max_len"},{"question":"You are given a string `s` consisting of lowercase English letters. In one move, you can select any two adjacent characters and swap them. You want to form the lexicographically smallest string possible using at most `k` moves. Return _the lexicographically smallest string that can be obtained after performing at most `k` adjacent swaps_.","solution":"def get_smallest_string(s, k): Returns the lexicographically smallest string that can be obtained by performing at most k adjacent swaps. if k >= len(s) - 1: return \'\'.join(sorted(s)) s = list(s) # convert string to list for easier operations for i in range(len(s)): pos = i for j in range(i + 1, min(i + k + 1, len(s))): if s[j] < s[pos]: pos = j for j in range(pos, i, -1): s[j], s[j - 1] = s[j - 1], s[j] k -= 1 if k == 0: return \'\'.join(s) return \'\'.join(s)"},{"question":"A **transaction** in a database is a sequence of one or more SQL operations that are executed as a single unit of work. Transactions ensure consistency and reliability in the database by adhering to the ACID properties (Atomicity, Consistency, Isolation, Durability). In this question, you are provided a log file represented as an array of strings `logs`, where each string represents a particular transaction. Each log entry follows the format: - `BEGIN <transaction_id>`: Marks the beginning of a new transaction with identifier `<transaction_id>`. - `OPERATION <transaction_id> <operation>`: An operation statement belonging to the transaction with identifier `<transaction_id>`. - `END <transaction_id>`: Marks the end of the transaction with identifier `<transaction_id>`. - `ROLLBACK <transaction_id>`: Marks the rollback of the transaction with identifier `<transaction_id>`. All operations within this transaction are considered undone. Given the log of transactions, return the list of active transactions at the end of the log. Note that a transaction is considered active if it started but has neither ended nor been rolled back.","solution":"def active_transactions(logs): Returns a list of active transactions at the end of the log. Parameters: logs (list): A list of log entries where each entry is a string representing a transaction stage. Returns: list: A list of active transaction IDs. active = set() ended_or_rolled_back = set() for log in logs: parts = log.split() operation = parts[0] transaction_id = parts[1] if operation == \\"BEGIN\\": active.add(transaction_id) elif operation in (\\"END\\", \\"ROLLBACK\\"): if transaction_id in active: active.remove(transaction_id) ended_or_rolled_back.add(transaction_id) return sorted(list(active))"},{"question":"Design an algorithm that takes in a list of `n` integers representing daily stock prices and computes the maximum possible profit you can achieve by buying and selling the stock at most twice. Note that you must sell the stock before you buy again. Implement a function `maxProfitWithTwoTransactions(prices: List[int]) -> int` that returns the maximum profit. For example: ```python def maxProfitWithTwoTransactions(prices: List[int]) -> int: # Your code here ``` **Example:** ``` Input: prices = [3,3,5,0,0,3,1,4] Output: 6 Explanation: Buy on day 4 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3. Then buy on day 7 (price = 1) and sell on day 8 (price = 4), profit = 4-1 = 3. Total profit = 3 + 3 = 6. ```","solution":"def maxProfitWithTwoTransactions(prices): Function to calculate the maximum profit with at most two transactions. if not prices: return 0 n = len(prices) # Forward traversal to find max profit till each day with one transaction left_profits = [0] * n min_price = prices[0] for i in range(1, n): min_price = min(min_price, prices[i]) left_profits[i] = max(left_profits[i-1], prices[i] - min_price) # Backward traversal to find max profit from each day onwards with one transaction right_profits = [0] * n max_price = prices[-1] for i in range(n-2, -1, -1): max_price = max(max_price, prices[i]) right_profits[i] = max(right_profits[i+1], max_price - prices[i]) # Combine the two results to find the maximum profit with at most two transactions max_profit = 0 for i in range(n): max_profit = max(max_profit, left_profits[i] + right_profits[i]) return max_profit"},{"question":"Given a linked list, remove the n-th node from the end of the list and return its head. Implement a function `ListNode* removeNthFromEnd(ListNode* head, int n)` where `ListNode` is a node of a singly linked list and is defined as: ```cpp struct ListNode { int val; ListNode *next; ListNode() : val(0), next(nullptr) {} ListNode(int x) : val(x), next(nullptr) {} ListNode(int x, ListNode *next) : val(x), next(next) {} }; ``` You need to do this in one pass, meaning you should ideally traverse the list only once. # Example ```python Input: head = [1,2,3,4,5], n = 2 Output: [1,2,3,5] ``` ```python Input: head = [1], n = 1 Output: [] ``` ```python Input: head = [1,2], n = 1 Output: [1] ```","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def removeNthFromEnd(head, n): Removes the n-th node from the end of the list and returns the head of the modified list. dummy = ListNode(0, head) first = dummy second = dummy # Move first n+1 places ahead for _ in range(n + 1): first = first.next # Move first to the end, maintaining the gap while first: first = first.next second = second.next # Skip the desired node second.next = second.next.next return dummy.next"},{"question":"Given an array `arr1` of integers and an integer `k`, return an array `arr2` where each element in `arr2` is the sum of the previous `k` elements in `arr1`. If there are fewer than `k` elements before an element, sum all the available elements. For example, for `arr1 = [1, 2, 3, 4, 5]` and `k = 3`, the resulting array `arr2` should be `[1, 3, 6, 9, 12]`.","solution":"def sum_previous_k_elements(arr1, k): Returns an array where each element is the sum of the previous `k` elements in `arr1`. If there are fewer than `k` elements before an element, sum all available elements. arr2 = [] for i in range(len(arr1)): start_index = max(0, i - k + 1) arr2.append(sum(arr1[start_index:i+1])) return arr2"},{"question":"Given a string `s` containing only lowercase alphabetical characters, determine the length of the longest substring of `s` that contains only unique characters. Implement the `longestUniqueSubstring` function that takes in a string `s` and returns an integer representing the length of the longest substring with all unique characters. Your code will be tested using the following pseudocode: ```initialize a string s call longestUniqueSubstring(s) to get a result return result ``` If the result matches the expected length of the longest substring with all unique characters, then your code will be judged as correct.","solution":"def longestUniqueSubstring(s): Returns the length of the longest substring with all unique characters. n = len(s) if n == 0: return 0 max_length = 0 start = 0 char_index_map = {} for end in range(n): if s[end] in char_index_map: start = max(start, char_index_map[s[end]] + 1) char_index_map[s[end]] = end max_length = max(max_length, end - start + 1) return max_length"},{"question":"Write a function to randomly generate a set of `n` unique coupon codes, each of which is exactly `k` characters long. Each character in a coupon code can be an uppercase letter, a lowercase letter, or a digit. The function should return a list of such unique coupon codes. Ensure the uniqueness of the generated coupon codes. Example: ```python random_coupons(n=5, k=8) ``` might generate: ```python [\'aB3dE7h9\', \'Q7e2FtY9\', \'W6u8NcY1\', \'xP9kBk3F\', \'T8p3LmQ1\'] ```","solution":"import random import string def random_coupons(n, k): Generates a set of n unique coupon codes, each k characters long. Each character can be an uppercase letter, a lowercase letter, or a digit. coupon_set = set() characters = string.ascii_letters + string.digits while len(coupon_set) < n: coupon_code = \'\'.join(random.choices(characters, k=k)) coupon_set.add(coupon_code) return list(coupon_set)"},{"question":"You are given an integer array `heights` representing the heights of buildings and an integer `k`. Each building at position `i` can jump to a building at position `i + 1` **only if** the height difference between the buildings is at most `k`, i.e., `|heights[i] - heights[i + 1]| <= k`. Return the length of the **longest possible path** that starts at any building and jumps to subsequent buildings according to the given rule. If no valid path exists, return `0`.","solution":"def longest_path(heights, k): Returns the length of the longest possible path that starts at any building and jumps to subsequent buildings according to the given rule. :param heights: List[int] - the heights of the buildings :param k: int - the maximum allowed height difference :return: int - the length of the longest possible path n = len(heights) if n == 0: return 0 # Initialize the dp array where dp[i] is the longest path starting from building i dp = [1] * n for i in range(n - 2, -1, -1): for j in range(i + 1, n): if abs(heights[i] - heights[j]) <= k: dp[i] = max(dp[i], 1 + dp[j]) return max(dp)"},{"question":"A group of colleagues wants to play a game where they pass a ball around a circular table. They want to determine the position of the colleague who will be holding the ball after a certain number of passes. The game works as follows: Each colleague is assigned a unique ID from 1 to `n`, seated in sequential order around the table. The ball is initially held by the colleague with ID 1. They pass the ball to the next colleague in sequence (i.e., from ID `i` to ID `i + 1`). If the ball is with the last colleague (ID `n`), the next pass gives the ball back to the first colleague (ID 1). You are given two integers, `n` (the number of colleagues) and `k` (the number of passes). Write a function that returns the ID of the colleague holding the ball after `k` passes. For example: ```python def find_colleague(n, k): return (k % n) + 1 ```","solution":"def find_colleague(n, k): Returns the ID of the colleague holding the ball after k passes. Parameters: n (int): the number of colleagues k (int): the number of passes Returns: int: the ID of the colleague holding the ball return (k % n) + 1"},{"question":"You are given an array of integers `nums` representing a queue, where each element represents a person with a certain amount of patience. Each person can either wait for the person in front of them to move or move forward to the end of the queue if they have no patience left. The patience of a person decreases by 1 each second, and they will leave the queue if their patience reaches zero. You need to simulate the process and return the final state of the queue after all persons with patience 0 have left or moved to the end of the queue. The queue is processed in a first-in, first-out manner, meaning the person at the front is processed first at each second. Return _the final state of the queue as a list of integers, representing the remaining patience for each person._","solution":"def process_queue(nums): Simulates the process of people in a queue with patience moving forward. Arguments: nums -- a list of integers where each integer represents the patience of a person in the queue. Returns: A list of integers representing the remaining patience for each person in the final state of the queue. queue = nums[:] length = len(queue) index = 0 while index < length: if queue[index] <= 0: queue.pop(index) length -= 1 else: queue[index] -= 1 index += 1 return queue"},{"question":"Given an integer `n`, return the number of unique binary search trees that can be made with `n` distinct nodes, where the nodes are numbered from 1 to `n`. A binary search tree is a binary tree in which each node has at most two children and each node\'s left subtree contains values less than the node\'s value, and each node\'s right subtree contains values greater than the node\'s value.","solution":"def num_trees(n): Returns the number of unique binary search trees that can be made with n distinct nodes. if n < 0: raise ValueError(\\"n must be a non-negative integer\\") # Initialize the array `dp` where dp[i] represents the number of unique BSTs with i nodes. dp = [0] * (n + 1) # Base case: There is exactly one way to create a BST with 0 nodes (empty tree) dp[0] = 1 for nodes in range(1, n + 1): for root in range(1, nodes + 1): left = root - 1 # Number of nodes in left subtree right = nodes - root # Number of nodes in right subtree dp[nodes] += dp[left] * dp[right] return dp[n]"},{"question":"Given a string `s`, your task is to return the same string where every vowel in the string is replaced by the next vowel in the sequence. The vowels in the sequence are \'a\', \'e\', \'i\', \'o\', \'u\', and they wrap around. For example, an \'a\' should be replaced with \'e\', an \'e\' with \'i\', an \'i\' with \'o\', an \'o\' with \'u\', and \'u\' with \'a\'. Return the resulting string after all replacements.","solution":"def replace_vowels(s): Replaces every vowel in the string s with the next vowel in the sequence. The sequence is \'a\', \'e\', \'i\', \'o\', \'u\' and wraps around. Args: s (str): Input string Returns: str: String with vowels replaced by the next vowel in the sequence vowels = \'aeiou\' next_vowel = {vowels[i]: vowels[(i + 1) % 5] for i in range(5)} result = \'\' for char in s: if char in next_vowel: result += next_vowel[char] else: result += char return result"},{"question":"You are given an integer array `heights` representing the heights of buildings situated on a street. Your task is to determine the maximum area of a rectangular block that can be formed between these buildings, considering each building has a width of 1. The area of the block is given by the height of the smallest building in the chosen range multiplied by the number of buildings in that range. Return _the maximum possible area of such a block_.","solution":"def max_rectangular_area(heights): Calculate the maximum rectangular area using the heights of buildings. Parameters: heights (list): List of integers representing the heights of buildings Returns: int: Maximum area for rectangular block stack = [] max_area = 0 index = 0 while index < len(heights): if not stack or heights[stack[-1]] <= heights[index]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"You are given a list `tasks` where each task is represented by a tuple `(duration, deadline)`, indicating the time it takes to complete the task and the deadline before which it should be completed. Your objective is to find the **minimum lateness** for scheduling all tasks, where lateness for a task is defined as the positive difference between the completion time of the task and its deadline if the task finishes after the deadline, or zero if it finishes before or at the deadline. Assume one task can be performed at a time and each task starts immediately after the previous one without any idle time. Return the minimum possible lateness for the given set of tasks.","solution":"def min_lateness(tasks): Given a list of tasks with their duration and deadlines, calculates the minimum lateness for scheduling all tasks. :param tasks: List[Tuple[int, int]] - a list of tuples where each tuple represents (duration, deadline) :return: int - the minimum possible lateness # Sort tasks by their deadlines (earliest deadline first) to minimize lateness tasks.sort(key=lambda x: x[1]) total_time = 0 max_lateness = 0 for duration, deadline in tasks: total_time += duration lateness = max(total_time - deadline, 0) max_lateness = max(max_lateness, lateness) return max_lateness"},{"question":"You are given an integer array `nums` and an integer `target`. Return _the number of different pairs_ `(i, j)` _such that_ `nums[i] + nums[j] == target` _and_ `i` _is less than_ `j`. Each pair should be counted only once, and the order in which they are counted does not matter.","solution":"def count_pairs(nums, target): Returns the number of different pairs (i, j) such that nums[i] + nums[j] == target and i < j. count = 0 num_dict = {} for num in nums: complement = target - num if complement in num_dict: count += num_dict[complement] if num in num_dict: num_dict[num] += 1 else: num_dict[num] = 1 return count"},{"question":"Given an array of integers `nums`, determine whether there exists a continuous subarray of size at least 2 that sums up to a multiple of `k`. An integer x is a multiple of `k` if there exists an integer `n` such that `x = n * k`. Return `true` if such a subarray exists, otherwise return `false`. Note that `k` can be either positive or negative.","solution":"def check_subarray_sum(nums, k): Returns True if there exists a continuous subarray of size at least 2 that sums up to a multiple of k. if k == 0: # Special case: we look for subarray with sum zero when k = 0 for i in range(len(nums) - 1): if nums[i] == 0 and nums[i + 1] == 0: return True return False # Dictionary to store the remainder when sum is divided by k mods = {0: -1} total_sum = 0 for i, num in enumerate(nums): total_sum += num mod = total_sum % k if mod in mods: if i - mods[mod] > 1: return True else: mods[mod] = i return False"},{"question":"You are given a string `s` consisting of only lowercase letters and an integer `k`. A \\"rich\\" substring is defined as a substring where the same letter appears at least `k` times consecutively. Return the length of the longest rich substring in `s`. If there is no such substring, return 0.","solution":"def longest_rich_substring(s, k): Returns the length of the longest rich substring in `s` where the same letter appears at least `k` times consecutively. max_length = 0 current_length = 0 current_char = \'\' for char in s: if char == current_char: current_length += 1 else: current_char = char current_length = 1 if current_length >= k: max_length = max(max_length, current_length) return max_length if max_length >= k else 0"},{"question":"You are given an integer `n` representing the number of courses you need to take, labeled from `0` to `n-1`. You are also given an array `prerequisites` where `prerequisites[i] = [ai, bi]` indicates that you must take course `bi` before taking course `ai`. Return a boolean value indicating whether it is possible to finish all courses given these prerequisites.","solution":"def can_finish(num_courses, prerequisites): from collections import defaultdict, deque # Create an adjacency list to represent the graph graph = defaultdict(list) indegree = [0] * num_courses # Build the graph and compute indegree of each vertex for ai, bi in prerequisites: graph[bi].append(ai) indegree[ai] += 1 # Initialize queue with all courses having no prerequisites queue = deque([i for i in range(num_courses) if indegree[i] == 0]) visited_courses = 0 while queue: course = queue.popleft() visited_courses += 1 for neighbor in graph[course]: indegree[neighbor] -= 1 if indegree[neighbor] == 0: queue.append(neighbor) return visited_courses == num_courses"},{"question":"Given a `string` containing digits from `2-9` inclusive, return all possible letter combinations that the number could represent. The numbers are mapped to letters on a phone keypad as follows: - 2 -> \\"abc\\" - 3 -> \\"def\\" - 4 -> \\"ghi\\" - 5 -> \\"jkl\\" - 6 -> \\"mno\\" - 7 -> \\"pqrs\\" - 8 -> \\"tuv\\" - 9 -> \\"wxyz\\" Note that 1 does not map to any letters. Provide the combinations in **any order**.","solution":"def letter_combinations(digits): Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent. if not digits: return [] phone_mapping = { \'2\': \'abc\', \'3\': \'def\', \'4\': \'ghi\', \'5\': \'jkl\', \'6\': \'mno\', \'7\': \'pqrs\', \'8\': \'tuv\', \'9\': \'wxyz\' } def backtrack(index, path): if index == len(digits): combinations.append(\\"\\".join(path)) return possible_letters = phone_mapping[digits[index]] for letter in possible_letters: path.append(letter) backtrack(index + 1, path) path.pop() combinations = [] backtrack(0, []) return combinations"},{"question":"You are given an array of `n` integers called `nums`. An operation involves selecting an element from `nums` and removing it, but you cannot remove more than one element with the same value in one operation. The cost of the operation is calculated as the product of the selected element value and the number of times this element had previously appeared in the array before being removed. Return _the minimum total cost_ to make the array `nums` empty by performing this operation multiple times.","solution":"def minimum_cost_to_empty_array(nums): Calculate the minimum total cost to make the array nums empty by removing elements with specific cost calculated per the problem\'s rules. :param nums: List[int] - list of integers :return: int - minimum total cost from collections import Counter element_count = Counter(nums) cost = 0 for element, count in element_count.items(): # The cost is the sum of the arithmetic progression: # element * 1 + element * 2 + ... + element * count # which equals element * (1 + 2 + ... + count) subtotal = element * sum(range(1, count + 1)) cost += subtotal return cost"},{"question":"You are given an array of integers `tasks` where each element represents the duration of a task in minutes. You are also given an integer `n` representing the number of workers. Each worker can perform exactly one task at a time, and once a worker starts a task, they must complete it without interruptions. Distribute the tasks among the workers such that the maximum time taken by any worker to complete their assigned tasks is minimized. Return the minimum possible time taken for the worker who has the most cumulative task duration to complete all their tasks.","solution":"def canDistributeWithinTime(tasks, n, maxTime): # Helper function to check if tasks can be distributed within given maxTime current_time = 0 workers_used = 1 for task in tasks: if current_time + task <= maxTime: current_time += task else: workers_used += 1 if workers_used > n: return False current_time = task return True def distributeTasks(tasks, n): if n >= len(tasks): return max(tasks) low, high = max(tasks), sum(tasks) best_time = high while low <= high: mid = (low + high) // 2 if canDistributeWithinTime(tasks, n, mid): best_time = mid high = mid - 1 else: low = mid + 1 return best_time"},{"question":"Given a matrix of `m x n` elements (m rows, n columns), return all elements of the matrix in spiral order. The spiral order starts from the top-left corner of the matrix and progressively moves right, down, left, and up, repeating these movements while maintaining the boundaries being reduced after each full cycle. For example, given the following matrix: ``` [ [ 1, 2, 3 ], [ 4, 5, 6 ], [ 7, 8, 9 ] ] ``` The spiral order output should be `[1, 2, 3, 6, 9, 8, 7, 4, 5]`. Implement a function `spiralOrder(matrix: List[List[int]]) -> List[int]:` that takes a 2D list (matrix) as input and returns a list of integers representing the elements of the matrix in spiral order.","solution":"def spiralOrder(matrix): Returns all elements of the matrix in spiral order. if not matrix or not matrix[0]: return [] m, n = len(matrix), len(matrix[0]) result = [] left, right, top, bottom = 0, n-1, 0, m-1 while left <= right and top <= bottom: for j in range(left, right + 1): result.append(matrix[top][j]) for i in range(top + 1, bottom + 1): result.append(matrix[i][right]) if top < bottom: for j in range(right - 1, left - 1, -1): result.append(matrix[bottom][j]) if left < right: for i in range(bottom - 1, top, -1): result.append(matrix[i][left]) left += 1 right -= 1 top += 1 bottom -= 1 return result"},{"question":"You are given a matrix `m x n grid` where each cell can have one of three values: - `0` representing an empty cell, - `1` representing a fresh orange, or - `2` representing a rotten orange. Each minute, any fresh orange that is adjacent (4-directionally) to a rotten orange becomes rotten. Return _the minimum number of minutes that must elapse until no cell has a fresh orange_. If this is impossible, return `-1`. Implement the function `orangesRotting(int[][] grid)` that performs this task. Example usage of the function: ```python grid = [ [2, 1, 1], [1, 1, 0], [0, 1, 1] ] print(orangesRotting(grid)) # Output: 4 ```","solution":"from collections import deque def orangesRotting(grid): Returns the minimum number of minutes that must elapse until no fresh orange is left. If this is impossible, returns -1. rows, cols = len(grid), len(grid[0]) queue = deque() fresh_oranges = 0 # Initialize the queue with all rotten oranges for r in range(rows): for c in range(cols): if grid[r][c] == 2: queue.append((r, c)) elif grid[r][c] == 1: fresh_oranges += 1 # Directions for 4-adjacency: up, down, left, right directions = [(0, 1), (0, -1), (1, 0), (-1, 0)] # If there are no fresh oranges, return 0 immediately if fresh_oranges == 0: return 0 # Perform BFS to rot adjacent fresh oranges minutes_passed = -1 while queue: minutes_passed += 1 for _ in range(len(queue)): r, c = queue.popleft() for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < rows and 0 <= nc < cols and grid[nr][nc] == 1: grid[nr][nc] = 2 fresh_oranges -= 1 queue.append((nr, nc)) # If there are still fresh oranges left, return -1 if fresh_oranges > 0: return -1 return minutes_passed"},{"question":"You are given a string `s` and an array of strings `words`. Each word in the array `words` must appear as a subsequence in `s`. Find the number of distinct words in `words` that are subsequences of `s`. A subsequence is a sequence that can be derived from another sequence by deleting some or no elements without changing the order of the remaining elements. Write a function to determine this number.","solution":"def numDistinctSubsequences(s, words): def is_subsequence(word, s): it = iter(s) return all(c in it for c in word) return sum(1 for word in set(words) if is_subsequence(word, s))"},{"question":"Given a binary tree with `n` nodes, each node containing an integer value, determine the **lowest common ancestor** of two given nodes in the tree. The lowest common ancestor of two nodes `p` and `q` is defined as the deepest node that has both `p` and `q` as descendants (where we allow a node to be a descendant of itself). Return _the value of the lowest common ancestor_. If one or both of the given nodes do not exist in the tree, return `-1`.","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def find_lca(root, p, q): Finds the lowest common ancestor of two nodes p and q in the binary tree with root. Returns the value of the LCA, or -1 if one or both nodes do not exist in the tree. if root is None: return None if root.value == p or root.value == q: return root left = find_lca(root.left, p, q) right = find_lca(root.right, p, q) if left and right: return root return left if left else right def node_exists(root, value): if root is None: return False if root.value == value: return True return node_exists(root.left, value) or node_exists(root.right, value) def lowest_common_ancestor(root, p, q): if not node_exists(root, p) or not node_exists(root, q): return -1 lca_node = find_lca(root, p, q) return lca_node.value if lca_node else -1"},{"question":"You are on a 2D grid where each cell of the grid represents a building block with a certain height. The grid is represented by a `m x n` integer matrix `heights` where `heights[i][j]` is the height of the building block at coordinate `(i, j)`. Your goal is to find the minimum effort required for a path from the top-left corner to the bottom-right corner. You can move up, down, left, or right from one block to another, but the effort of moving from one block to another is the **absolute difference** in height between the two blocks. Return the _minimum effort required to achieve the goal_. (Note: Assume that there is always a valid path from the top-left corner to the bottom-right corner.)","solution":"import heapq def minimum_effort_path(heights): Returns the minimum effort required to travel from the top-left corner to the bottom-right corner. def neighbors(x, y): for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: if 0 <= x + dx < len(heights) and 0 <= y + dy < len(heights[0]): yield x + dx, y + dy m, n = len(heights), len(heights[0]) effort = [[float(\'inf\')] * n for _ in range(m)] effort[0][0] = 0 min_heap = [(0, 0, 0)] # effort, x, y while min_heap: current_effort, x, y = heapq.heappop(min_heap) if x == m - 1 and y == n - 1: return current_effort for nx, ny in neighbors(x, y): new_effort = max(current_effort, abs(heights[nx][ny] - heights[x][y])) if new_effort < effort[nx][ny]: effort[nx][ny] = new_effort heapq.heappush(min_heap, (new_effort, nx, ny))"},{"question":"You are given a binary search tree (BST) with `n` nodes where each node has a unique value. Implement an iterator over the BST that returns the next smallest number in the BST in O(1) average time complexity. The iterator should be initialized with the root node of the BST and should support the following operations: - `BSTIterator(TreeNode root)` Initializes an object of the BSTIterator class with the root of the tree. - `int next()` Returns the next smallest number in the BST. - `boolean hasNext()` Returns true if there exists a number in the traversal to be returned, otherwise false. A binary search tree is a binary tree in which for every node, the left subtree of the node contains only nodes with values less than the node\'s value, and the right subtree of the node contains only nodes with values greater than the node\'s value. Implement the above functionalities in the `BSTIterator` class. **Example:** ``` Input operations = [\\"BSTIterator\\", \\"next\\", \\"next\\", \\"hasNext\\", \\"next\\", \\"hasNext\\", \\"next\\", \\"hasNext\\", \\"next\\", \\"hasNext\\"] arguments = [[[7, 3, 15, null, null, 9, 20]], [], [], [], [], [], [], [], [], []] Output [null, 3, 7, true, 9, true, 15, true, 20, false] Explanation BSTIterator bSTIterator = new BSTIterator([7, 3, 15, null, null, 9, 20]); bSTIterator.next(); // return 3 bSTIterator.next(); // return 7 bSTIterator.hasNext(); // return true bSTIterator.next(); // return 9 bSTIterator.hasNext(); // return true bSTIterator.next(); // return 15 bSTIterator.hasNext(); // return true bSTIterator.next(); // return 20 bSTIterator.hasNext(); // return false ``` **Constraints:** - The number of nodes in the tree is in the range `[1, 10^5]`. - `0 <= Node.val <= 10^6` - `At most 10^5` calls will be made to `next` and `hasNext`.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right class BSTIterator: def __init__(self, root: TreeNode): self.stack = [] self._leftmost_inorder(root) def _leftmost_inorder(self, root): while root: self.stack.append(root) root = root.left def next(self) -> int: top_node = self.stack.pop() if top_node.right: self._leftmost_inorder(top_node.right) return top_node.val def hasNext(self) -> bool: return len(self.stack) > 0"},{"question":"You are given an integer array `nums` sorted in **non-decreasing** order. This array represents the digits of a single number. You need to add the digit `1` to this number and return the resulting integer as an array of digits in the same sorted ascending order. Note that `nums` will not contain any leading zeros, except for the number zero itself which is represented as `[0]`. Return the resultant array of digits after adding `1` to the original number.","solution":"def plus_one(nums): Given a list of integers representing the digits of a number, adds 1 to the number and returns the digits of the resulting number as a list. n = len(nums) carry = 1 for i in range(n - 1, -1, -1): new_digit = nums[i] + carry if new_digit == 10: nums[i] = 0 else: nums[i] = new_digit carry = 0 break if carry == 1: nums.insert(0, 1) return nums"},{"question":"You are given a list of non-negative integers `nums` representing the amount of money of each house arranged in a circular manner. Calculate the maximum amount of money you can rob tonight without alerting the police. Since it is a circular list, if you rob the first house, you cannot rob the last house, and if you rob the last house, you cannot rob the first house. Implement the function `maxRob(nums)` that returns the maximum amount of money you can rob. # Example: Input: `nums = [2, 3, 2]` Output: `3` Explanation: You cannot rob both house 1 (money = 2) and house 3 (money = 2), so the maximum amount of money you can rob = 3. # Constraints: * `1 <= nums.length <= 100` * `0 <= nums[i] <= 1000`","solution":"def rob_linear(nums): Returns the maximum amount of money that can be robbed in a linear arrangement of houses. prev, curr = 0, 0 for num in nums: prev, curr = curr, max(curr, prev + num) return curr def maxRob(nums): Returns the maximum amount of money that can be robbed in a circular arrangement of houses. if not nums: return 0 if len(nums) == 1: return nums[0] return max(rob_linear(nums[:-1]), rob_linear(nums[1:]))"},{"question":"You are given a list of integers `nums` where each integer represents the number of pages in a book. You need to allocate these books to a certain number of students such that the maximum pages allocated to a student is minimized. You are also given an integer `students`, the number of students available to read the books. Each student needs to be allocated at least one book, and each book can be allocated to only one student. Return the minimum possible maximum pages allocated to a student under these constraints.","solution":"def is_feasible(books, students, max_pages): current_pages, needed_students = 0, 1 for pages in books: if current_pages + pages <= max_pages: current_pages += pages else: needed_students += 1 if needed_students > students or pages > max_pages: return False current_pages = pages return True def min_pages(books, students): Returns the minimum possible maximum pages allocated to a student such that each student gets at least one book and the maximum pages allocated to a student is minimized. if students > len(books): return -1 low, high = max(books), sum(books) while low < high: mid = (low + high) // 2 if is_feasible(books, students, mid): high = mid else: low = mid + 1 return low"},{"question":"You are given an array `arr` of integers and an integer `x`. You need to find the smallest subarray with a sum greater than or equal to `x`. A subarray is a contiguous part of an array. Return _the minimal length of such a subarray_. If there is no such subarray, return `0`.","solution":"def smallest_subarray_with_sum(arr, x): Returns the minimal length of the smallest subarray with a sum greater than or equal to x. If there is no such subarray, returns 0. n = len(arr) min_length = n + 1 start = 0 end = 0 current_sum = 0 while end < n: while current_sum < x and end < n: current_sum += arr[end] end += 1 while current_sum >= x and start < n: if end - start < min_length: min_length = end - start current_sum -= arr[start] start += 1 if min_length == n + 1: return 0 return min_length"},{"question":"You are given an array `arr` of integers. An element `arr[i]` is called a **peak** if it is greater than both its neighbors. For corner elements, we consider only one neighbor. Return the length of the longest subarray where every element is a peak. If there is no such subarray, return `0`.","solution":"def longest_peak_subarray(arr): Returns the length of the longest subarray where every element is a peak. A peak is an element that is greater than its neighbors. n = len(arr) if n < 3: return 0 longest = 0 current_length = 0 for i in range(1, n - 1): if arr[i] > arr[i - 1] and arr[i] > arr[i + 1]: if current_length == 0: current_length = 3 else: current_length += 1 else: if current_length > longest: longest = current_length current_length = 0 if current_length > longest: longest = current_length return longest"},{"question":"Given an integer array `nums` representing the amount of time each task takes, and an integer `k` representing the number of workers, return _the least amount of time required to complete all tasks_ when tasks are distributed optimally among the workers. Each worker can only work on one task at a time, and each task must be completed by exactly one worker.","solution":"def min_time_to_complete_tasks(nums, k): Returns the least amount of time required to complete all tasks when tasks are distributed optimally among k workers. :param nums: List of integers representing task times. :param k: Integer representing number of workers. :return: Integer representing the minimum time required. def can_complete_in_time(limit): workers_count = 1 current_sum = 0 for time in nums: if current_sum + time <= limit: current_sum += time else: workers_count += 1 current_sum = time if workers_count > k: return False return True left, right = max(nums), sum(nums) while left < right: mid = (left + right) // 2 if can_complete_in_time(mid): right = mid else: left = mid + 1 return left"},{"question":"Given an array of integers `heights` representing the structure of a terrain, where `heights[i]` represents the height of the terrain at index `i`, calculate the maximum amount of water that can be trapped after a rainfall. The width of each section of terrain is `1`. Return the maximum amount of trapped water.","solution":"def trap(heights): Calculate the maximum amount of water that can be trapped in the heights array after rainfall. :param heights: List[int] - list of integers representing the heights of the terrain :return: int - maximum amount of trapped water if not heights: return 0 n = len(heights) left_max = [0]*n right_max = [0]*n left_max[0] = heights[0] for i in range(1, n): left_max[i] = max(left_max[i-1], heights[i]) right_max[n-1] = heights[n-1] for i in range(n-2, -1, -1): right_max[i] = max(right_max[i+1], heights[i]) trapped_water = 0 for i in range(n): trapped_water += min(left_max[i], right_max[i]) - heights[i] return trapped_water"},{"question":"Given an integer array `arr` and an integer `n`, return the maximum possible sum of a subarray with at most `n` distinct elements. If there are multiple subarrays with the same maximum sum, return the sum of any one of them. A subarray is a contiguous part of the array.","solution":"def max_sum_subarray_with_n_distinct(arr, n): Returns the maximum possible sum of a subarray with at most n distinct elements. from collections import defaultdict if not arr or n == 0: return 0 max_sum = 0 current_sum = 0 left = 0 freq = defaultdict(int) for right in range(len(arr)): freq[arr[right]] += 1 current_sum += arr[right] while len(freq) > n: freq[arr[left]] -= 1 current_sum -= arr[left] if freq[arr[left]] == 0: del freq[arr[left]] left += 1 max_sum = max(max_sum, current_sum) return max_sum"},{"question":"Given an array of integers representing a permutation of numbers from `1` to `n` and an integer `k`, return _the minimum number of swaps required to sort the array in ascending order_. Note that the permutation may include duplicate numbers.","solution":"def minSwapsToSort(arr, k): Returns the minimum number of swaps required to sort the array in ascending order. n = len(arr) sorted_arr_with_indices = sorted([(value, idx) for idx, value in enumerate(arr)]) visited = [False] * n swaps = 0 for i in range(n): if visited[i] or sorted_arr_with_indices[i][1] == i: continue cycle_size = 0 x = i while not visited[x]: visited[x] = True x = sorted_arr_with_indices[x][1] cycle_size += 1 if cycle_size > 0: swaps += cycle_size - 1 return swaps"},{"question":"You are given a list of `n` strings, where each string consists of lowercase English letters. A string `x` is considered a **prefix** of string `y` if `y` can be formed by appending one or more characters to `x`. Your task is to group the strings such that no string in one group is a prefix of another string in the same group. Return the **minimum number** of such groups into which the initial list can be divided.","solution":"def min_groups(strings): Returns the minimum number of groups so that no string in one group is a prefix of another string in the same group. # Sort strings by length, then lexicographically strings.sort(key=lambda s: (len(s), s)) groups = [] for s in strings: placed = False for group in groups: if not any(g.startswith(s) or s.startswith(g) for g in group): group.append(s) placed = True break if not placed: groups.append([s]) return len(groups)"},{"question":"You are given an array of integers representing heights of walls in a row. Each element `heights[i]` represents the height of the wall at position `i`. Imagine this row of walls as forming a histogram. Return the area of the largest rectangle that can be formed within these walls. The rectangle should be completely contained within the histogram, and it can be positioned anywhere along the x-axis.","solution":"def largestRectangleArea(heights): Calculates the area of the largest rectangle in the histogram. :param heights: List of integers representing the heights of the bars. :return: Integer representing the largest rectangle area. stack = [] max_area = 0 index = 0 while index < len(heights): # If this bar is higher than the bar on the stack, push it to the stack if not stack or heights[index] >= heights[stack[-1]]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) # Now process the remaining bars in the stack while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"You are given an integer array `nums` where `nums[i]` represents the number of stones at the `i`-th position. Each turn, you must pick up all the stones from one pile (say at index `i`) and move `nums[i]` stones from that pile to the `i+1` pile and `i-1` pile evenly. If the number of stones to be moved is odd, one more stone will be moved to the `i+1` pile than to the `i-1` pile. Your task is to determine if you can make all the piles of stones equal after any number of turns. Return _a boolean_ value indicating whether it\'s possible to evenly distribute the stones across all piles.","solution":"def can_distribute_stones(nums): Returns True if it is possible to evenly distribute stones across all piles, False otherwise. total_stones = sum(nums) # If total stones are not divisible by the number of piles, we can\'t distribute them evenly if total_stones % len(nums) != 0: return False return True"},{"question":"You are given an m x n integer grid `heights` representing the height of a certain area of terrain. The `Pacific` ocean touches the left and top edges of the grid and the `Atlantic` ocean touches the right and bottom edges. Water can flow from a cell to another one if and only if the height of the latter is less than or equal to the height of the former. Find the list of grid coordinates where water can flow to both the `Pacific` and `Atlantic` oceans. Implement a function `List<List<Integer>> pacificAtlantic(int[][] heights)` that returns the list of coordinates where water can flow to both the `Pacific` and `Atlantic` oceans.","solution":"def pacificAtlantic(heights): if not heights or not heights[0]: return [] num_rows, num_cols = len(heights), len(heights[0]) pacific_reachable = [[False] * num_cols for _ in range(num_rows)] atlantic_reachable = [[False] * num_cols for _ in range(num_rows)] def dfs(row, col, reachable): reachable[row][col] = True for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: new_row, new_col = row + dx, col + dy if 0 <= new_row < num_rows and 0 <= new_col < num_cols and not reachable[new_row][new_col] and heights[new_row][new_col] >= heights[row][col]: dfs(new_row, new_col, reachable) for row in range(num_rows): dfs(row, 0, pacific_reachable) dfs(row, num_cols - 1, atlantic_reachable) for col in range(num_cols): dfs(0, col, pacific_reachable) dfs(num_rows - 1, col, atlantic_reachable) result = [] for row in range(num_rows): for col in range(num_cols): if pacific_reachable[row][col] and atlantic_reachable[row][col]: result.append([row, col]) return result"},{"question":"You are given an array of integers `arr` and an integer `k`. An operation involves taking any subarray `arr[i...j]` (where `i <= j`) and incrementing each element in that subarray by 1. You can perform this operation as many times as necessary. Return the minimum number of operations needed to make every element of the array at least `k`. For example, given the array `[1, 2, 5]` and `k = 4`, the minimum number of operations required to make every element at least `4` is `3`.","solution":"def min_operations_to_reach_k(arr, k): Given an array \'arr\' of integers and an integer \'k\', this function returns the minimum number of operations needed to make every element of the array at least \'k\'. An operation consists of choosing a subarray and incrementing every element in that subarray by 1. Parameters: arr (list of int): The input array of integers. k (int): The threshold value that each element in the array must reach or exceed. Returns: int: The minimum number of operations needed. operations = 0 max_value = max(arr) # If maximum element is already >= k, calculate the additional operations needed for other elements. for num in arr: if num < k: operations += (k - num) return operations"},{"question":"Write a function `hasCycle` that takes the head of a singly linked list and returns _true_ if there is a cycle in the linked list, or _false_ otherwise. A cycle exists if some node in the list can be reached again by continuously following the `next` pointer. Internal details of the nodes are abstracted via a class `ListNode` which has an integer value and a `next` pointer to the next node in the singly linked list. The function should have a time complexity of O(n) and a space complexity of O(1).","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def hasCycle(head): Detects if a cycle exists in a linked list. :param head: ListNode, the head of the singly linked list. :return: bool, True if there is a cycle in the linked list, otherwise False. if not head or not head.next: return False slow = head fast = head.next while slow != fast: if not fast or not fast.next: return False slow = slow.next fast = fast.next.next return True"},{"question":"Given a list of strings `words`, you need to group the anagrams together. An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once. You should return a list of lists, where each list contains all the anagrams grouped together. Each list of anagrams should be arranged in lexicographical order, and the entire output list should also be sorted lexicographically by the first word of each group. For example, given the input `[\\"bat\\", \\"tab\\", \\"eat\\", \\"tea\\", \\"tan\\", \\"nat\\"]`, the output should be `[[\\"bat\\", \\"tab\\"], [\\"eat\\", \\"tea\\"], [\\"nat\\", \\"tan\\"]]`.","solution":"def group_anagrams(words): Groups the anagrams together. Args: words: List of strings Returns: List of lists where each list contains all the anagrams grouped together, sorted lexicographically. from collections import defaultdict anagram_dict = defaultdict(list) for word in words: sorted_word = \'\'.join(sorted(word)) anagram_dict[sorted_word].append(word) result = [sorted(anagram_dict[key]) for key in anagram_dict] return sorted(result, key=lambda x: x[0])"},{"question":"Given a string `s` that consists of lowercase letters and a non-negative integer `k`, rearrange the string such that the same characters are at least distance `k` from each other. If it is not possible to rearrange the string in this way, return an empty string `\\"\\"`. For example: **Input**: `s = \\"aabbcc\\", k = 3` **Output**: `\\"abcabc\\"` or `\\"acbacb\\"` (any valid output) **Input**: `s = \\"aaabc\\", k = 3` **Output**: `\\"\\"` **Explanation**: - In the first example, one possible arrangement is \\"abcabc\\", ensuring that no characters repeat within less than k=3 distance. - In the second example, it is not possible to arrange the string such that no letter appears within every 3 positions from itself.","solution":"from heapq import heappush, heappop from collections import Counter, deque def rearrangeString(s, k): if k <= 1: return s char_count = Counter(s) max_heap = [] for char, count in char_count.items(): heappush(max_heap, (-count, char)) result = [] wait_queue = deque() while max_heap: count, char = heappop(max_heap) result.append(char) wait_queue.append((count+1, char)) if len(wait_queue) < k: continue count_to_readd, char_to_readd = wait_queue.popleft() if -count_to_readd > 0: heappush(max_heap, (count_to_readd, char_to_readd)) return \\"\\".join(result) if len(result) == len(s) else \\"\\""},{"question":"Given an array `nums` of size `n`, where each element is unique and lies in the range [1, n], return `true` if the array contains all the numbers from 1 to n (inclusive) and `false` otherwise.","solution":"def contains_all_numbers(nums): Returns True if the array contains all the numbers from 1 to n inclusive, False otherwise. n = len(nums) all_numbers = set(range(1, n + 1)) return all_numbers == set(nums)"},{"question":"You are given a list of strings `words` and a string `chars`. A string is considered \\"good\\" if it can be formed by characters from `chars` (each character can only be used once). Return the length of all good strings in `words`. For example: - If `words = [\\"cat\\",\\"bt\\",\\"hat\\",\\"tree\\"]` and `chars = \\"atach\\"`, then the answer is 6, because \\"cat\\" and \\"hat\\" are good strings and have a total length of 3 + 3 = 6. - If `words = [\\"hello\\",\\"world\\",\\"students\\"]` and `chars = \\"welldonehoneyr\\"`, then the answer is 10, because \\"hello\\" and \\"world\\" are good strings and have a total length of 5 + 5 = 10.","solution":"def can_form(word, chars_count): Check if the word can be formed by characters from chars_count. from collections import Counter word_count = Counter(word) for char, count in word_count.items(): if chars_count[char] < count: return False return True def total_length_of_good_strings(words, chars): Return the total length of all good strings. from collections import Counter chars_count = Counter(chars) total_length = 0 for word in words: if can_form(word, chars_count): total_length += len(word) return total_length"},{"question":"You are tasked with implementing a basic version of a text editor undo system. The editor will support the following operations: \\"write\\" which appends text to the current document, and \\"undo\\" which removes the most recently appended text. Implement the `TextEditor` class: - `TextEditor()` Initializes the object with an empty document. - `void write(String text)` Appends the given `text` to the document. - `String undo()` If there is text to undo, it removes the most recently appended text and returns it; otherwise, it returns an empty string.","solution":"class TextEditor: def __init__(self): Initializes the TextEditor object with an empty document. self.document = \\"\\" self.history = [] def write(self, text): Appends the given text to the document and saves the append operation to the history. self.document += text self.history.append(text) def undo(self): If there is text to undo, removes the most recently appended text and returns it; otherwise, returns an empty string. if self.history: last_text = self.history.pop() self.document = self.document[:-len(last_text)] return last_text return \\"\\""},{"question":"Given a 2D grid `grid` of `0`s and `1`s, an island is a group of connected `1`s (vertically or horizontally). An island is considered to be surrounded by water if it is completely enclosed by `0`s. Determine the number of distinct islands in the grid. Two islands are considered distinct if and only if one island is not identical (in terms of shape) to another island, when translated (i.e., moved left, right, up, or down).","solution":"def numDistinctIslands(grid): def dfs(x, y, direction): nonlocal shape if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and grid[x][y] == 1: grid[x][y] = 0 shape.append(direction) dfs(x + 1, y, \'d\') dfs(x - 1, y, \'u\') dfs(x, y + 1, \'r\') dfs(x, y - 1, \'l\') shape.append(\'b\') distinct_islands = set() for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == 1: shape = [] dfs(i, j, \'o\') distinct_islands.add(tuple(shape)) return len(distinct_islands)"},{"question":"You are given a **0-indexed** integer array `arr` and an integer `k`. We define the **block-sum** of the array `arr` as the sum of elements in any subarray of length `k`. Return the array that contains all the **block-sums** of `arr` for every starting index `0 <= i <= n-k`, where `n` is the length of the array `arr`. If no such subarray exists, return an empty array. **Note**: Assume the array length `n` and the integer `k` are such that `n >= k`.","solution":"def block_sums(arr, k): Returns an array containing the block sums of length k for the input array arr. n = len(arr) # Initialize the result array result = [] # Calculate the block sums for i in range(n - k + 1): block_sum = sum(arr[i:i+k]) result.append(block_sum) return result"},{"question":"You are given an `n`-ary tree, where each node is either a leaf node or an internal node. Internal nodes can have up to `n` children. The tree is represented as an array `nodes` where `nodes[i] = [v1, v2, ..., vk]` represents the children of the `i-th` node (in the given order), and an empty array `[]` represents a leaf node with no children. The tree is rooted at node `0`. Return the **level order traversal** of the tree as a 2D list where each inner list contains the node values at that level from left to right. For example, in a tree represented by `nodes = [[1, 2, 3], [4, 5, 6], [7], [8], [], [9], [], [], [], []]`, the output should be `[[0], [1, 2, 3], [4, 5, 6, 7, 8], [9]]`.","solution":"def level_order_traversal(nodes): Returns the level order traversal of the n-ary tree. nodes: List[List[int]] - An array representing the n-ary tree structure. Returns: List[List[int]] - A 2D list where each inner list contains the node values at that level. if not nodes: return [] level_order = [] queue = [0] while queue: current_level_size = len(queue) current_level = [] for _ in range(current_level_size): node = queue.pop(0) current_level.append(node) queue.extend(nodes[node]) level_order.append(current_level) return level_order"},{"question":"You are given a string `s` consisting of lowercase English letters. You can apply the following operation on the string any number of times: Choose a substring of `s` and re-arrange its characters in any order. Determine the **minimum** number of operations required so that no two identical characters are adjacent. If it is not possible to achieve such an arrangement, return `-1`.","solution":"def min_operations_to_avoid_adjacent_duplicates(s): from collections import Counter char_count = Counter(s) max_freq = max(char_count.values()) n = len(s) if max_freq > (n + 1) // 2: return -1 return 0"},{"question":"Given a **0-indexed** integer array `nums` of length `n`, where `1 <= n <= 1000` and all elements are unique, return the maximum possible sum of `2` elements from the array such that their indices differ by at least `k`. If it\'s not possible to find such a pair, return `-1`.","solution":"def max_sum_with_diff_at_least_k(nums, k): Function that returns the maximum possible sum of 2 elements from the array such that their indices differ by at least k. Arguments: nums -- list of unique integers k -- minimum index difference Returns: Maximum sum of 2 elements with index difference at least k, or -1 if not possible. n = len(nums) if n < k + 1: return -1 max_sum = -1 for i in range(n): for j in range(i + k, n): max_sum = max(max_sum, nums[i] + nums[j]) return max_sum"},{"question":"You are given a string `s` consisting of only characters \'a\' and \'b\'. You can perform a **flip** operation, which changes \'a\' to \'b\' or \'b\' to \'a\'. Your goal is to make the string a palindrome with the minimum number of flip operations. Return _the minimum number of flip operations needed to make the string a palindrome_.","solution":"def min_flips_to_palindrome(s): Returns the minimum number of flip operations needed to make the string a palindrome. n = len(s) flip_count = 0 for i in range(n // 2): if s[i] != s[n - i - 1]: flip_count += 1 return flip_count"},{"question":"You are given a list of strings `words` and a string `s`. Each string in `words` contains only lowercase English letters and has the same length. Determine the minimum number of adjacent swaps required to transform `s` into any string in `words`. If it is not possible to transform `s` into any string in `words` using adjacent swaps, return -1. An adjacent swap consists of swapping any two consecutive characters in the string.","solution":"def min_adjacent_swaps(words, s): def count_swaps(source, target): if sorted(source) != sorted(target): return -1 swaps = 0 source = list(source) for i in range(len(source)): if source[i] != target[i]: j = i while source[j] != target[i]: j += 1 while j > i: source[j], source[j - 1] = source[j - 1], source[j] swaps += 1 j -= 1 return swaps min_swaps = float(\'inf\') for word in words: swaps = count_swaps(s, word) if swaps != -1: min_swaps = min(min_swaps, swaps) return -1 if min_swaps == float(\'inf\') else min_swaps"},{"question":"A company has a series of tasks that need to be completed by its employees. Each task has a duration and a deadline by which it must be completed. Given a list of tasks where each task is represented as a pair of integers `(duration, deadline)`, write a function that schedules these tasks in such a way that the total lateness is minimized. The lateness is defined as the maximum of `0` and the difference between the actual finish time of a task and its deadline. Implement a function `minimizeLateness(tasks)` that takes a list of tuples representing the tasks and returns the schedule that minimizes the total lateness. For simplicity, assume that all tasks start at time `0`. The function signature should be: ```python def minimizeLateness(tasks: List[Tuple[int, int]]) -> List[int]: ``` Each output represents the order of tasks to minimize the total lateness, where the tasks are referenced by their indices in the original input list. Example: ```python tasks = [(3, 5), (2, 6), (1, 8)] print(minimizeLateness(tasks)) # Output might be [0, 1, 2] or [1, 0, 2] depending on the optimal schedule. ```","solution":"from typing import List, Tuple def minimizeLateness(tasks: List[Tuple[int, int]]) -> List[int]: Schedules tasks to minimize the total lateness. Parameters: - tasks: List of tuples where each tuple contains (duration, deadline) Returns: - List of indices representing the order of tasks to minimize total lateness # Sort tasks by their deadlines (earliest deadline first). sorted_tasks_indices = sorted(range(len(tasks)), key=lambda x: tasks[x][1]) return sorted_tasks_indices"},{"question":"You are given a binary tree represented in a data structure where each node contains a `val` representing its value, and `left` and `right` pointers pointing to its left and right children, respectively. Write a function that takes the root of the binary tree as input and returns the level order traversal of its nodes\' values (i.e., from left to right, level by level).","solution":"from collections import deque from typing import List, Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def level_order_traversal(root: Optional[TreeNode]) -> List[List[int]]: Returns the level order traversal of a binary tree. if not root: return [] result = [] queue = deque([root]) while queue: level_size = len(queue) level = [] for _ in range(level_size): node = queue.popleft() level.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.append(level) return result"},{"question":"A coding contest has three types of problems: easy, medium, and hard. The grading system assigns `a` points for an easy problem, `b` points for a medium problem, and `c` points for a hard problem. You are given an integer `target` representing the required score to win the contest. Write a function that determines the minimum number of problems a contestant needs to solve to achieve exactly the `target` score. If it\'s impossible to score exactly `target` points with the given scoring system, return `-1`. The function should take in four arguments: `a`, `b`, `c`, and `target`, and return the minimum number of problems needed or `-1` if it isn\'t feasible.","solution":"def min_problems_to_reach_target(a, b, c, target): Determines the minimum number of problems needed to achieve exactly the target score. Args: - a (int): Points for an easy problem. - b (int): Points for a medium problem. - c (int): Points for a hard problem. - target (int): The required score to win the contest. Returns: - int: The minimum number of problems needed to achieve the target score, or -1 if not possible. from itertools import combinations_with_replacement # To minimize the number of problems, try all combinations of problems for num_problems in range(1, target + 1): for combo in combinations_with_replacement([a, b, c], num_problems): if sum(combo) == target: return num_problems return -1"},{"question":"Mary wants to cut a stick of length `n` into shorter pieces such that each piece has a unique integer length. Return the maximum number of pieces that can be obtained. For example, if the stick has length `6`, it can be cut into pieces of lengths `1`, `2`, and `3`. If multiple ways are possible, return any one solution that gives the maximum number of cuts.","solution":"def max_unique_cuts(n): Returns the maximum number of unique integer length pieces that a stick of length n can be cut into. pieces = [] total_length = 0 current_length = 1 while total_length + current_length <= n: pieces.append(current_length) total_length += current_length current_length += 1 return pieces"},{"question":"Write a function `int strStr(string haystack, string needle)` that returns the index of the first occurrence of `needle` in `haystack`, or `-1` if `needle` is not part of `haystack`. Return 0 if `needle` is an empty string. Implement the function such that it follows these rules: 1. The function should handle the scenario where either `haystack` or `needle` (or both) can be empty. 2. Use a sliding window approach or a built-in substring search method without using `std::find` or similar functions explicitly from the library. 3. Ensure your implementation efficiently handles cases where the length of `needle` is greater than the length of `haystack`.","solution":"def strStr(haystack, needle): Returns the index of the first occurrence of \'needle\' in \'haystack\', or -1 if \'needle\' is not part of \'haystack\'. Returns 0 if \'needle\' is an empty string. if not needle: return 0 for i in range(len(haystack) - len(needle) + 1): if haystack[i:i + len(needle)] == needle: return i return -1"},{"question":"Given an array of integers `arr` sorted in increasing order, and an integer `target`, write a function to search for `target` in `arr`. If `target` exists, then return its index. Otherwise, return the index where `target` would be if it were inserted to maintain the sorted order. Assume the array does not contain duplicate elements.","solution":"def search_insert_position(arr, target): Search for target in a sorted array and return its index. If target is not found, return the index where it would be inserted to maintain the sorted order. :param arr: List[int] - A sorted list of integers :param target: int - The target integer to search for :return: int - The index of the target or the insertion point left, right = 0, len(arr) - 1 while left <= right: mid = (left + right) // 2 if arr[mid] == target: return mid elif arr[mid] < target: left = mid + 1 else: right = mid - 1 return left"},{"question":"Write a function `mostFrequentEven(int[] nums)` that takes an array of integers `nums` and returns the most frequent even element. If there is a tie for the most frequent, return the smallest even element among the tied elements. If there are no even elements, return `-1`.","solution":"def mostFrequentEven(nums): Returns the most frequent even element in the array nums. If there is a tie for the most frequent, returns the smallest even element among the tied elements. If there are no even elements, returns -1. from collections import Counter # Filter and count even numbers evens_count = Counter(num for num in nums if num % 2 == 0) if not evens_count: return -1 most_frequent_even = min((-count, num) for num, count in evens_count.items())[1] return most_frequent_even"},{"question":"Implement a file system that allows you to create paths and associate values with those paths. You should be able to create new paths and retrieve values from existing paths. Your implementation should support the following methods: - `FileSystem()`: Initializes the object. - `bool createPath(string path, int value)`: Creates a new path and associates a value with it. A path should not be created if the parent path does not exist or if the path already exists. Return `True` if the path was successfully created and `False` otherwise. - `int get(string path)`: Returns the value associated with the specified path, or `-1` if the path does not exist. A path is defined as a string that starts with a slash `\'/\'` followed by one or more lowercase English letters or the \'/\' character, representing the directories in the filesystem. You can assume that all given paths are valid and do not end with a slash.","solution":"class FileSystem: def __init__(self): self.paths = {} def createPath(self, path: str, value: int) -> bool: if path in self.paths or len(path) == 0 or path[0] != \'/\': return False parent = path.rfind(\'/\') if parent > 0 and path[:parent] not in self.paths: return False self.paths[path] = value return True def get(self, path: str) -> int: return self.paths.get(path, -1)"},{"question":"You are given a string `s` consisting of lowercase English letters and an integer `k`. You need to implement a function that splits the string into `k` parts while maintaining the order of characters and each part is as contiguous as possible. If it is impossible to split the string into exactly `k` parts of contiguous characters, return an empty list. Otherwise, return the list of `k` parts. Each part should be a non-empty string.","solution":"def split_string(s, k): Splits the string `s` into `k` contiguous parts if possible. Parameters: s (str): The input string consisting of lowercase English letters. k (int): The number of parts to split the string into. Returns: list: A list of `k` contiguous parts of the string or an empty list if not possible. n = len(s) if k > n: return [] part_length_basic = n // k remainder = n % k parts = [] start = 0 for i in range(k): end = start + part_length_basic + (1 if remainder > 0 else 0) parts.append(s[start:end]) start = end if remainder > 0: remainder -= 1 return parts"},{"question":"You are given a list of `tasks`, where `tasks[i]` represents the amount of time it takes to complete the `i-th` task. Each task can either be assigned to `machine A` or `machine B`. Your goal is to assign the tasks in such a way that the difference in total completion time between the two machines is minimized. Return _the minimum absolute difference in total completion time_ between the two machines. For example, given the tasks `[1, 2, 3, 4, 5]`, one possible assignment is `[1, 2, 3]` to `machine A` and `[4, 5]` to `machine B`, resulting in a total completion time of `6` for `machine A` and `9` for `machine B`. The difference is `3`, which is the minimum difference possible for this list of tasks.","solution":"from itertools import combinations def min_time_difference(tasks): total_time = sum(tasks) target = total_time // 2 possible_sums = set([0]) for task in tasks: current_sums = list(possible_sums) for cur_sum in current_sums: new_sum = cur_sum + task possible_sums.add(new_sum) closest_sum = min(possible_sums, key=lambda x: abs(target - x)) machine_A_time = closest_sum machine_B_time = total_time - closest_sum return abs(machine_A_time - machine_B_time)"},{"question":"Given an array of integers `nums` sorted in non-decreasing order, return the length of the longest subarray that contains only unique elements. A subarray is a contiguous portion of an array.","solution":"def length_of_longest_unique_subarray(nums): This function returns the length of the longest subarray with unique elements. :param nums: List[int] - array of integers sorted in non-decreasing order :return: int - length of the longest subarray containing unique elements n = len(nums) if n == 0: return 0 # Initialize variables max_len = 0 start = 0 seen = set() for end in range(n): while nums[end] in seen: seen.remove(nums[start]) start += 1 seen.add(nums[end]) max_len = max(max_len, end - start + 1) return max_len"},{"question":"Given a binary tree, implement a function to return the largest value in each row of the tree. Each row of the tree refers to each level of the tree\'s height, starting from the root level (0th). You may assume that the tree is non-empty and each node has an integer value. Example: Input: ``` 1 / 3 2 / 5 3 9 ``` Output: [1, 3, 9]","solution":"from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def largest_in_each_row(root): Returns a list of the largest values in each row of the binary tree. if not root: return [] result = [] queue = deque([root]) while queue: level_size = len(queue) max_value = float(\'-inf\') for _ in range(level_size): node = queue.popleft() max_value = max(max_value, node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.append(max_value) return result"},{"question":"Given an unsorted list of integers, write a function to find the smallest positive integer that cannot be represented as a sum of any subset of the list. For example, given the list [1, 2, 3, 8, 9], the smallest positive integer that cannot be represented as a sum of any subset of this list is 7. Your function should return this smallest positive integer.","solution":"def smallest_unrepresentable_sum(nums): Given an unsorted list of integers, find the smallest positive integer that cannot be represented as a sum of any subset of the list. nums.sort() smallest_missing = 1 for num in nums: if num > smallest_missing: break smallest_missing += num return smallest_missing"},{"question":"A company has a number of employees, each with a unique ID, working in different departments. Each employee either reports directly to another employee or does not report at all (i.e., they are the CEO). Given two 0-indexed integer arrays `manager` and `importance` of length `n` where `manager[i]` is the ID of the manager of the `i-th` employee and `importance[i]` is the importance value of the `i-th` employee, return the total importance value of the employees who are directly or indirectly managed by the employee with the given `id`. Note: - `manager[i] = -1` indicates that the `i-th` employee has no manager. - Each employee is guaranteed to not report to more than one manager.","solution":"def get_importance(manager, importance, id): Return the total importance value of the employees who are directly or indirectly managed by the employee with the given id. :param manager: List[int], manager[i] is the ID of the manager of the i-th employee :param importance: List[int], importance[i] is the importance value of the i-th employee :param id: int, the ID of the employee whose total importance we want to calculate :return: int from collections import defaultdict, deque n = len(manager) employee_to_subordinates = defaultdict(list) for i in range(n): if manager[i] != -1: employee_to_subordinates[manager[i]].append(i) total_importance = 0 queue = deque([id]) while queue: current = queue.popleft() total_importance += importance[current] for subordinate in employee_to_subordinates[current]: queue.append(subordinate) return total_importance"},{"question":"You are given `n` non-negative integers representing heights of columns in a histogram where the width of each column is `1`. Write a function that computes the maximum area of a rectangle formed by consecutive columns within the histogram. The function should return the area of the largest rectangle that can be formed from the histogram\'s column heights.","solution":"def largest_rectangle_area(heights): Computes the maximum area of a rectangle in a histogram represented by heights. :param List[int] heights: List of non-negative integers representing histogram column heights :return: The area of the largest rectangle that can be formed :rtype: int stack = [] max_area = 0 index = 0 while index < len(heights): if not stack or heights[stack[-1]] <= heights[index]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"You have a list of `n` integers and an integer `target`. Your task is to find all unique quadruplets `[a, b, c, d]` in the list that sum up to the `target` and return them as a list of lists. Each quadruplet should be sorted in non-decreasing order, and no two quadruplets should be the same. ```python def fourSum(nums: List[int], target: int) -> List[List[int]]: # Your implementation here ``` Note: The solution set should not contain duplicate quadruplets.","solution":"from typing import List def fourSum(nums: List[int], target: int) -> List[List[int]]: nums.sort() res = [] length = len(nums) for i in range(length - 3): # Avoid duplicate quadruplets with the same first number if i > 0 and nums[i] == nums[i - 1]: continue for j in range(i + 1, length - 2): # Avoid duplicate quadruplets with the same second number if j > i + 1 and nums[j] == nums[j - 1]: continue left, right = j + 1, length - 1 while left < right: total = nums[i] + nums[j] + nums[left] + nums[right] if total == target: res.append([nums[i], nums[j], nums[left], nums[right]]) # Avoid duplicate quadruplets with the same third and fourth numbers while left < right and nums[left] == nums[left + 1]: left += 1 while left < right and nums[right] == nums[right - 1]: right -= 1 left += 1 right -= 1 elif total < target: left += 1 else: right -= 1 return res"},{"question":"A knight is located on the bottom-right square of an `n x n` chessboard. The knight has standard chess knight moves, which means it can move to a square that is two squares away horizontally and one square vertically, or two squares vertically and one square horizontally. The knight needs to reach the top-left square of the chessboard. Write a function that returns the minimum number of moves the knight needs to reach the top-left square. If it\'s not possible for the knight to reach the top-left square, return `-1`. The function should have the following signature: ```python def minKnightMoves(n: int) -> int: pass ```","solution":"from collections import deque def minKnightMoves(n: int) -> int: if n == 1: return 0 # Possible moves for a knight knight_moves = [ (2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, 2), (-1, -2) ] # Initialize BFS start = (n - 1, n - 1) target = (0, 0) queue = deque([(start, 0)]) visited = set([start]) while queue: (x, y), moves = queue.popleft() if (x, y) == target: return moves for dx, dy in knight_moves: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < n and (nx, ny) not in visited: visited.add((nx, ny)) queue.append(((nx, ny), moves + 1)) return -1"},{"question":"Given a list of strings `words`, return the longest string in `words` that can be formed by deleting some characters of another string in `words` without reordering the remaining characters. If there are multiple possible results, return the one that\'s lexographically smallest. If no string in `words` can be formed by deleting characters from another string, return an empty string.","solution":"def find_longest_string(words): Returns the longest string in words that can be formed by deleting some characters of another string in words without reordering the remaining characters. If there are multiple possible results, returns the lexicographically smallest one. if not words: return \\"\\" def is_subsequence(x, y): it = iter(y) return all(c in it for c in x) longest = \\"\\" words.sort() for word in sorted(words, key=lambda x: (-len(x), x)): for potential in words: if word != potential and is_subsequence(word, potential): if len(word) > len(longest) or (len(word) == len(longest) and word < longest): longest = word break return longest"},{"question":"You are given a string `s` consisting of only lowercase alphabets and an integer `n`. You need to determine if there exists a substring of `s` with a length of at least `n` that contains exactly `n` distinct characters. Return _`true` if such a substring exists, otherwise return `false`_.","solution":"def check_substring(s, n): Determines if there exists a substring of `s` with length at least `n` that contains exactly `n` distinct characters. :param s: A string consisting of lowercase alphabets. :param n: An integer representing the number of distinct characters required. :return: Boolean indicating if such a substring exists. if n > len(s): return False distinct_counts = set() for i in range(len(s) - n + 1): substring = s[i:i+n] distinct_characters = set(substring) if len(distinct_characters) == n: return True distinct_counts.add(len(distinct_characters)) return False"},{"question":"You are given a list of unique integers `candidates` and a target integer `target`. Return a list of all unique combinations of `candidates` where the chosen numbers sum to `target`. The same number from `candidates` may be chosen an unlimited number of times. Implement the `CombinationSum` class: * `CombinationSum(vector<int>& candidates, int target)` initializes the object with the list of candidates and the target sum. * `vector<vector<int>> getCombinations()` returns a list of all unique combinations where the candidate numbers sum to `target`. Each combination is a list of integers, and the numbers in each combination must be in non-decreasing order.","solution":"from typing import List class CombinationSum: def __init__(self, candidates: List[int], target: int): self.candidates = candidates self.target = target def getCombinations(self) -> List[List[int]]: result = [] self.candidates.sort() def backtrack(start, path, target): if target < 0: return if target == 0: result.append(path) return for i in range(start, len(self.candidates)): candidate = self.candidates[i] backtrack(i, path + [candidate], target - candidate) backtrack(0, [], self.target) return result"},{"question":"You are given an **n-ary tree** with `n` nodes numbered from `0` to `n - 1`. Each node is either `good` or `bad`. The root of the tree is always node `0`, and each node has a specific number of child nodes. You are also given an integer array `values` where `values[i]` is `1` if node `i` is good and `0` if node `i` is bad. Your task is to find the longest path in the tree consisting only of `good` nodes starting from the root. Implement the `GoodNodesPathFinder` class: * `GoodNodesPathFinder(int n, int[] parents, int[] values)` - Constructs an instance of the class with the given number of nodes `n`, an integer array `parents` denoting the parent of each node (`parents[i]` is the parent of node `i`), and an integer array `values` representing the type of each node. * `int getLongestGoodPath()` - Returns the length of the longest path of good nodes starting from the root.","solution":"class GoodNodesPathFinder: def __init__(self, n, parents, values): self.n = n self.parents = parents self.values = values self.tree = [[] for _ in range(n)] for i in range(1, n): self.tree[parents[i]].append(i) self.max_length = 0 def getLongestGoodPath(self): def dfs(node): if self.values[node] == 0: return 0 max_depth = 0 for child in self.tree[node]: depth = dfs(child) max_depth = max(max_depth, depth) self.max_length = max(self.max_length, max_depth + 1) return max_depth + 1 dfs(0) return self.max_length"},{"question":"Given an integer array `nums`, return the number of consecutive increasing subsequences of length 3 (`triplets`). A sequence (x, y, z) is considered to be increasing if `0 <= x < y < z < nums.length` and `nums[x] < nums[y] < nums[z]`.","solution":"def count_increasing_triplets(nums): Returns the number of increasing triplets subsequences of length 3 in the array nums. n = len(nums) if n < 3: return 0 count = 0 for i in range(n - 2): for j in range(i + 1, n - 1): if nums[i] < nums[j]: for k in range(j + 1, n): if nums[j] < nums[k]: count += 1 return count"},{"question":"You are given a list of non-negative integers `nums` and an integer `target`. Determine if there are any three integers in `nums` whose sum is equal to `target`. Return `true` if such a combination exists, otherwise return `false`.","solution":"def three_sum(nums, target): Determines if there are three integers in nums whose sum equals target. :param nums: List of non-negative integers :param target: Integer target for the sum of three numbers :return: True if any three numbers sum up to the target, otherwise False nums.sort() n = len(nums) for i in range(n-2): if i > 0 and nums[i] == nums[i-1]: continue left, right = i + 1, n - 1 while left < right: curr_sum = nums[i] + nums[left] + nums[right] if curr_sum == target: return True elif curr_sum < target: left += 1 else: right -= 1 return False"},{"question":"Given a string `s` representing a valid IPv4 address, write a function to return a defanged version of that IP address. A defanged IP address replaces every period `\\".\\"` with `\\"[.]\\"`.","solution":"def defang_ip_addr(s): Returns a defanged version of the IP address. A defanged IP address replaces every period \\".\\" with \\"[.]\\". return s.replace(\'.\', \'[.]\')"},{"question":"You are given a string `email` that represents a user\'s email address. An email address consists of a local part followed by the `@` symbol and a domain part. To make it easier to observe user activity, you need to **mask** the public visible part of the email address while preserving its privacy. The local part is displayed as the first letter, followed by **a fixed number of asterisks** (\'*\'), and then the last letter before the `@` symbol. For the domain part, only the first and last letter remain visible, with the middle letters being replaced by asterisks (`*`). For instance, if the email address is `example@domain.com`, the masked version should be `e*****e@d*****n.com`. Develop a function that takes an email address as input and returns the masked email address based on the described rule.","solution":"def mask_email(email): Masks the email address following the rules: Local part: First letter, fixed number of asterisks, and last letter before @. Domain part: First letter, asterisks, last letter, and the domain extension. local, domain = email.split(\'@\') # Masking the local part if len(local) > 1: masked_local = local[0] + \'*\' * 5 + local[-1] else: masked_local = local # If the local part is too short to mask # Masking the domain part domain_name, domain_extension = domain.split(\'.\') if len(domain_name) > 1: masked_domain = domain_name[0] + \'*\' * (len(domain_name) - 2) + domain_name[-1] + \'.\' + domain_extension else: masked_domain = domain # If the domain name is too short to mask return f\\"{masked_local}@{masked_domain}\\""},{"question":"You are given a series of tasks represented as a list of integers where each entry corresponds to the amount of time required to complete that task. You are also given an integer `m`, representing the number of parallel workers available to complete these tasks. Each worker can take on one task at a time, and the tasks must be distributed in a way that minimizes the maximum time taken for any worker to complete their assigned tasks. Your goal is to determine this minimum possible maximum time. Write a function that takes a list of integers `tasks` and an integer `m`, and returns the minimum possible maximum time required to complete all the tasks with `m` workers.","solution":"def can_complete(tasks, m, mid): required_workers = 1 current_load = 0 for task in tasks: if current_load + task > mid: required_workers += 1 current_load = task if required_workers > m: return False else: current_load += task return True def min_max_time(tasks, m): if m == 1: return sum(tasks) if m >= len(tasks): return max(tasks) low, high = max(tasks), sum(tasks) result = high while low <= high: mid = (low + high) // 2 if can_complete(tasks, m, mid): result = mid high = mid - 1 else: low = mid + 1 return result"},{"question":"You are given a list of positive integers `nums` and an integer `k`, representing the number of steps you can take to increase an element. In one step, you can increase any element of the list by 1. Return the minimum number of steps required to make all elements in the list equal using exactly `k` steps. If it\'s not possible, return -1.","solution":"def min_steps(nums, k): Returns the minimum number of steps required to make all elements in the list equal using exactly k steps. If it\'s not possible, return -1. n = len(nums) total_sum = sum(nums) max_element = max(nums) # Check if it\'s possible to distribute k steps evenly if (total_sum + k) % n != 0: return -1 target = (total_sum + k) // n if target < max_element: return -1 required_steps = sum(target - num for num in nums) return k if required_steps == k else -1"},{"question":"You are given a list of non-negative integers `nums`. Your task is to find the **maximum** number you can form by combining these numbers. You are allowed to rearrange the numbers in any order to create this combination. Return the maximum number as a string since the number may be too large to fit in a standard integer type. For example, if `nums = [3, 30, 34, 5, 9]`, the maximum number you can form by combining them is `\\"9534330\\"`.","solution":"from functools import cmp_to_key def compare(x, y): # Custom comparator function to order numbers for creating the largest number if x+y > y+x: return -1 elif x+y < y+x: return 1 else: return 0 def largestNumber(nums): Forms the maximum number by rearranging non-negative integers in nums. Parameters: nums (list): List of non-negative integers. Returns: str: The maximum number formed by the integers as a string. # Convert numbers to strings for comparison nums_str = [str(num) for num in nums] # Sort numbers based on the custom comparator nums_str.sort(key=cmp_to_key(compare)) # Join sorted numbers to form the largest number largest_num = \'\'.join(nums_str) # Handle the case where the entire number is \'0\' if largest_num[0] == \'0\': return \'0\' return largest_num"},{"question":"Given a matrix of integers where each element represents the cost of moving through that cell, start at the top-left cell and move to the bottom-right cell. You can only move either right or down at any point in time. Return the minimum cost to reach the bottom-right cell from the top-left cell. Note that you cannot move diagonally or upward.","solution":"def min_path_sum(matrix): Given a matrix of integers where each element represents the cost of moving through that cell, returns the minimum cost to reach the bottom-right cell from the top-left cell. You can only move either right or down at any point in time. if not matrix or not matrix[0]: return 0 rows, cols = len(matrix), len(matrix[0]) dp = [[0] * cols for _ in range(rows)] dp[0][0] = matrix[0][0] for i in range(1, rows): dp[i][0] = dp[i - 1][0] + matrix[i][0] for j in range(1, cols): dp[0][j] = dp[0][j - 1] + matrix[0][j] for i in range(1, rows): for j in range(1, cols): dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + matrix[i][j] return dp[-1][-1]"},{"question":"Given two strings `s` and `t`, return `true` if `t` is an anagram of `s`, and `false` otherwise. An **anagram** of a string is a string that contains the same characters with the same frequencies, but possibly in a different order.","solution":"def is_anagram(s, t): Returns True if t is an anagram of s, otherwise False. return sorted(s) == sorted(t)"},{"question":"You are given two arrays of integers `nums1` and `nums2`. A pair of indices `(i, j)` is called **good** if `nums1[i]` and `nums2[j]` form an increasing sequence (i.e., `nums1[i] < nums2[j]`). You need to determine the **maximum length** of a subsequence in `nums1` that can form such a **good** pair with a subsequence in `nums2` where the order within each subsequence is preserved. Return _the maximum length of such a subsequence_.","solution":"def max_increasing_subsequence(nums1, nums2): Finds the maximum length of a subsequence in nums1 that can form a good pair with a subsequence in nums2. Parameters: nums1 (list of int): First list of integers. nums2 (list of int): Second list of integers. Returns: int: The length of the longest such subsequence. n, m = len(nums1), len(nums2) # dp[i][j] will store the length of the longest subsequence up to nums1[i] and nums2[j] dp = [[0] * (m + 1) for _ in range(n + 1)] for i in range(1, n + 1): for j in range(1, m + 1): if nums1[i - 1] < nums2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) return dp[n][m]"},{"question":"You are given a circular array of integers `nums` with length `n`. You need to perform `m` right rotations on the array. A right rotation means removing the last element of the array and inserting it in the front. Return the array after performing the specified number of rotations. **Example:** ``` Input: nums = [1, 2, 3, 4, 5], m = 2 Output: [4, 5, 1, 2, 3] ```","solution":"def right_rotate(nums, m): Performs m right rotations on the array nums. n = len(nums) # Effective rotations needed is m mod n because rotating n times leads to the same array m = m % n return nums[-m:] + nums[:-m]"},{"question":"Given an integer `n`, return the minimal number of operations to reduce it to zero. In one operation, you can reduce the number by either `1` or any power of `2` (i.e., `1, 2, 4, 8, 16, ...`).","solution":"def min_operations_to_zero(n): Given an integer n, return the minimal number of operations to reduce it to zero. You can reduce the number by either 1 or any power of 2 in each operation. dp = [float(\'inf\')] * (n + 1) dp[0] = 0 for i in range(1, n + 1): power = 1 while power <= i: dp[i] = min(dp[i], dp[i - power] + 1) power *= 2 return dp[n]"},{"question":"You are given a list of integers `numList` and an integer `k`. Your task is to determine if you can split `numList` into `k` continuous subsequences where each subsequence contains consecutive integers. Return `true` if it is possible to split `numList` in such a way, otherwise, return `false`. For example, given `numList = [1, 2, 3, 3, 4, 4, 5, 6]` and `k = 4`, a valid split would be `[[1, 2, 3], [3, 4, 5], [4, 5, 6], [5, 6, 7]]`. Return `true` if such a split is possible, otherwise return `false`.","solution":"from collections import Counter from heapq import * def is_possible_split(numList, k): if not numList: return False if len(numList) % k != 0: return False count = Counter(numList) min_heap = list(count.keys()) heapify(min_heap) while min_heap: min_val = min_heap[0] for i in range(min_val, min_val + k): if count[i] == 0: return False count[i] -= 1 if count[i] == 0: heappop(min_heap) elif count[i] < 0: return False return True"},{"question":"Given an array of integers `arr` where `arr[i]` represents the number of apples on the `i-th` day, and an array `days` of the same length where `days[i]` represents the number of days after the `i-th` day that the apples remain fresh, return _the maximum number of apples you can eat if you can only eat one apple per day and you must eat the fresh apples before they rot_.","solution":"import heapq def eatenApples(arr, days): Given an array of integers arr where arr[i] represents the number of apples on the i-th day and an array days of the same length where days[i] represents the number of days after the i-th day that the apples remain fresh, return the maximum number of apples you can eat if you can only eat one apple per day and you must eat the fresh apples before they rot. n = len(arr) heap = [] day = 0 eaten_apples = 0 while day < n or heap: # Add new apples if day < n and arr[day] > 0: heapq.heappush(heap, (day + days[day], arr[day])) # Remove rotten apples while heap and heap[0][0] <= day: heapq.heappop(heap) # Eat an apple, if possible if heap: expire_day, count = heapq.heappop(heap) if count > 1: heapq.heappush(heap, (expire_day, count - 1)) eaten_apples += 1 day += 1 return eaten_apples"},{"question":"You are given a list of `n` tasks, each represented by an integer duration in the array `tasks`, where `tasks[i]` is the duration of the i-th task. You also have a positive integer `sessionTime` which represents the maximum time you can work consecutively in a single session before taking a break. Your goal is to partition the tasks into the minimum number of work sessions such that the total duration of tasks in each session does not exceed `sessionTime`. Return _the minimum number of work sessions needed_.","solution":"def min_sessions(tasks, sessionTime): def can_partition(tasks, session_time, begin, partitions): if begin >= len(tasks): return True for i in range(len(partitions)): if partitions[i] + tasks[begin] <= session_time: partitions[i] += tasks[begin] if can_partition(tasks, session_time, begin+1, partitions): return True partitions[i] -= tasks[begin] if partitions[i] == 0: break return False tasks.sort(reverse=True) left, right = 1, len(tasks) while left < right: mid = (left + right) // 2 partitions = [0] * mid if can_partition(tasks, sessionTime, 0, partitions): right = mid else: left = mid + 1 return left"},{"question":"Write a function that takes an integer `n` and returns a list of strings representing all possible binary numbers of length `n` that do not contain two consecutive \'1\'s. For example, given `n = 3`, the function should return [\'000\', \'001\', \'010\', \'100\', \'101\']. The output can be in any order.","solution":"def generate_binary(n): Generate all binary strings of length n that do not contain consecutive \'1\'s. if n == 0: return [] if n == 1: return [\'0\', \'1\'] prev_prev_list = [\'0\', \'1\'] # Solutions for length 1 prev_list = [\'00\', \'01\', \'10\'] # Solutions for length 2 if n == 2: return prev_list for _ in range(3, n + 1): curr_list = [] for num in prev_list: if num[-1] == \'0\': curr_list.append(num + \'0\') curr_list.append(num + \'1\') else: # num[-1] == \'1\' curr_list.append(num + \'0\') prev_prev_list = prev_list prev_list = curr_list return prev_list"},{"question":"Given two strings `str1` and `str2`, determine if `str2` can be obtained by performing at most one swap of two characters in `str1`. A swap involves taking two distinct positions in the string and swapping the characters at these positions. Returns `True` if it\'s possible to obtain `str2` from `str1` by one swap, otherwise, return `False`.","solution":"def can_be_obtained_by_one_swap(str1, str2): Returns True if str2 can be obtained by one swap of two characters in str1, otherwise returns False. if len(str1) != len(str2): return False # Find character mismatches between the strings mismatches = [(i, (char1, char2)) for i, (char1, char2) in enumerate(zip(str1, str2)) if char1 != char2] # If there are no mismatches, the strings are already identical if not mismatches: return True # There should be exactly two mismatches for a single swap to be possible if len(mismatches) != 2: return False # Check if swapping the mismatched characters in str1 will make it equal to str2 (i1, (char1_1, char2_1)), (i2, (char1_2, char2_2)) = mismatches return char1_1 == char2_2 and char1_2 == char2_1"},{"question":"Given a list of `n` integers `nums` and an integer `k`, determine if there are `k` distinct integers in the array that add up to a given target sum `t`. Return `true` if such a combination exists, otherwise return `false`. Note that each integer in the list `nums` may only be used once in the combination.","solution":"def k_sum(nums, k, t): def k_sum_recursive(nums, k, t, index): # Base case: if k is 0, check if the target sum is also 0 if k == 0: return t == 0 # If we\'ve passed the end of the list or if there are not enough elements to form k if index >= len(nums) or len(nums) - index < k: return False # Include nums[index] in the current combination if k_sum_recursive(nums, k - 1, t - nums[index], index + 1): return True # Exclude nums[index] from the current combination if k_sum_recursive(nums, k, t, index + 1): return True return False return k_sum_recursive(nums, k, t, 0)"},{"question":"You are given an integer array `heights` representing the heights of buildings in a street from left to right. A building can see the sunset if it is not blocked by taller buildings to its right. Write a function that takes the array `heights` and returns the number of buildings that can see the sunset. The return value should be an integer representing the count of such buildings.","solution":"def countBuildingsWithSunsetView(heights): Returns the number of buildings that can see the sunset. n = len(heights) if n == 0: return 0 # Initialize the count with the first building being able to see the sunset count = 1 max_height = heights[-1] # Iterate from right to left and count buildings for i in range(n-2, -1, -1): if heights[i] > max_height: count += 1 max_height = heights[i] return count"},{"question":"You are given an unsorted array of integers `nums`, where each integer appears exactly three times, except for one integer which appears exactly once. Write a function that finds and returns the integer that appears only once. You must implement a solution with a linear runtime complexity and use only constant extra space.","solution":"def single_number(nums): Finds the number that appears exactly once in an array where every other number appears exactly three times. Args: nums (list[int]): An unsorted array of integers. Returns: int: The integer that appears exactly once. ones, twos = 0, 0 for num in nums: # `ones` contains XOR of all elements which have appeared \\"only once\\" ones = (ones ^ num) & ~twos # `twos` contains XOR of all elements which have appeared \\"only twice\\" twos = (twos ^ num) & ~ones return ones"},{"question":"You are given an array of positive integers `heights` where `heights[i]` represents the height of the ith student. A classroom setting requires students to stand in a line in non-decreasing order of their heights. However, they mistakenly lined up in the initial order provided. Calculate the minimum number of students who must move so that they can line up in non-decreasing order of their heights. Note that only reordering these students will impact their final positions.","solution":"def min_students_to_move(heights): Returns the minimum number of students that must move to line up in non-decreasing order of heights. sorted_heights = sorted(heights) count = 0 for i in range(len(heights)): if heights[i] != sorted_heights[i]: count += 1 return count"},{"question":"You are given a string `s` where each character is an ASCII letter. Rearrange the characters of the string such that two consecutive characters are not the same. If it is not possible to do so, return an empty string.","solution":"import heapq from collections import Counter def reorganize_string(s): Rearrange the characters of the string such that two consecutive characters are not the same. If it is not possible, return an empty string. counter = Counter(s) max_heap = [(-count, char) for char, count in counter.items()] heapq.heapify(max_heap) prev_count, prev_char = 0, \'\' result = [] while max_heap: count, char = heapq.heappop(max_heap) result.append(char) if prev_count < 0: heapq.heappush(max_heap, (prev_count, prev_char)) prev_count = count + 1 prev_char = char result_str = \'\'.join(result) if len(result_str) != len(s): return \'\' return result_str"},{"question":"You are given a string `s` and an integer `n`. Your task is to return the `n` most frequent characters in the string. If multiple characters have the same frequency, return them in lexicographical order. Implement a method `List<Character> mostFrequentChars(String s, int n)` that returns a list of `n` characters sorted by their frequency in descending order. If the number of unique characters in the string is less than `n`, return the entire set sorted by frequency and lexicographically where frequencies match.","solution":"from collections import Counter def mostFrequentChars(s, n): Returns the \'n\' most frequent characters in \'s\', sorted by frequency in descending order. If two characters have the same frequency, the characters are sorted lexicographically. # Count frequency of each character freq_counter = Counter(s) # Sort characters by frequency (descending) and lexicographical order sorted_chars = sorted(freq_counter.keys(), key=lambda x: (-freq_counter[x], x)) # Return the top \'n\' characters return sorted_chars[:n]"},{"question":"Given a matrix `grid` of shape `m x n` consisting of non-negative integers representing a height map, compute the amount of water it can trap after raining. Each cell contains an elevation height, and the water can only be trapped by sinking into the lower elevations. Return _the total amount of water trapped_.","solution":"import heapq def trap_rain_water(grid): if not grid or not grid[0]: return 0 m, n = len(grid), len(grid[0]) visited = [[False] * n for _ in range(m)] min_heap = [] # Add all the border cells to the min heap and mark them as visited for i in range(m): for j in (0, n-1): heapq.heappush(min_heap, (grid[i][j], i, j)) visited[i][j] = True for j in range(1, n-1): for i in (0, m-1): heapq.heappush(min_heap, (grid[i][j], i, j)) visited[i][j] = True total_water = 0 directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] while min_heap: height, x, y = heapq.heappop(min_heap) for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and not visited[nx][ny]: visited[nx][ny] = True total_water += max(0, height - grid[nx][ny]) heapq.heappush(min_heap, (max(height, grid[nx][ny]), nx, ny)) return total_water"},{"question":"A company has a network of servers represented by a `graph` where each server is a node, and a direct connection between two servers is an edge. Each server has a distinct `server_id` and a `load`, which is an integer representing the current amount of work the server is processing. The company wants to ensure no server becomes overloaded, so they want to perform load balancing. You are given a list `connections` where each element is a tuple `(server_id1, server_id2, weight)`, indicating a direct connection between `server_id1` and `server_id2` with a capacity (maximum additional load that can be transferred) of `weight`. You are also given a list `load_balancing` which consists of tuples `(from_server_id, to_server_id, load_amount)`. Return `true` if the load balancing described in `load_balancing` is possible without exceeding any server\'s capacity or connection\'s capacity, otherwise return `false`. In implementing the solution, consider edge cases such as disconnected servers and scenarios where multiple load balancing operations may share connections and server capacities.","solution":"def can_balance_load(n, connections, server_loads, load_balancing): # Initialize server loads and capacities from collections import defaultdict, deque server_load = {i: l for i, l in enumerate(server_loads)} capacities = defaultdict(lambda: defaultdict(int)) for s1, s2, w in connections: capacities[s1][s2] = w capacities[s2][s1] = w # Helper to update load balances def update_load(from_server, to_server, load): if server_load[from_server] < load: return False if capacities[from_server][to_server] < load: return False server_load[from_server] -= load server_load[to_server] += load capacities[from_server][to_server] -= load capacities[to_server][from_server] -= load return True # Perform the load balancing operations for from_server, to_server, load in load_balancing: if not update_load(from_server, to_server, load): return False return True"},{"question":"You are given a 2D grid of size `m x n` representing a map where `1` represents land and `0` represents water. An island is a group of `1`s (lands) connected **4-directionally** (horizontal or vertical). You may assume all four edges of the grid are surrounded by water. Count the total number of distinct islands. Two islands are considered distinct if and only if one island\'s shape is different from the other (not including rotations and reflections). Write a function that returns the number of distinct islands. ```python class Solution: def numDistinctIslands(self, grid: List[List[int]]) -> int: # Your implementation here ``` **Example:** ``` Input: grid = [[1,1,0,0,0], [1,1,0,0,0], [0,0,0,1,1], [0,0,0,1,1]] Output: 1 ```","solution":"class Solution: def numDistinctIslands(self, grid): def dfs(grid, r, c, direction): if (r < 0 or r >= len(grid) or c < 0 or c >= len(grid[0]) or grid[r][c] == 0): return grid[r][c] = 0 shape.append(direction) dfs(grid, r+1, c, \'D\') # Down dfs(grid, r-1, c, \'U\') # Up dfs(grid, r, c+1, \'R\') # Right dfs(grid, r, c-1, \'L\') # Left shape.append(\'B\') # Back, to mark end of a direction branch distinct_islands = set() for r in range(len(grid)): for c in range(len(grid[0])): if grid[r][c] == 1: shape = [] dfs(grid, r, c, \'S\') # Start distinct_islands.add(tuple(shape)) return len(distinct_islands)"},{"question":"You are managing a group of employees, and you want to organize them based on their skill levels. You are given a 2D integer array `skills` where `skills[i] = [skill_1, skill_2, ..., skill_m]` represents the `i-th` employee\'s skill levels in `m` different areas. An employee is considered **underqualified** if there exists another employee who has strictly higher skill levels in all `m` areas. More formally, an employee `i` is **underqualified** if there exists another employee `j` such that `skills[j][k] > skills[i][k]` for every `k` from `0` to `m-1`. Return _the number of **underqualified** employees_.","solution":"def count_underqualified_employees(skills): Returns the number of underqualified employees. Parameters: skills (list of list of int): 2D integer array representing skills of employees. Returns: int: Number of underqualified employees. n = len(skills) m = len(skills[0]) underqualified_count = 0 for i in range(n): underqualified = False for j in range(n): if i != j: all_higher = True for k in range(m): if skills[j][k] <= skills[i][k]: all_higher = False break if all_higher: underqualified = True break if underqualified: underqualified_count += 1 return underqualified_count"},{"question":"You are given a list of `n` integers `arr`, where each element either signifies an opening bracket `(` or a closing bracket `)`. Your task is to determine whether the given sequence of brackets is valid. A sequence of brackets is considered valid if: - It is an empty sequence. - It can be written as `AB` (A concatenated with B), where A and B are valid sequences. - It can be written as `(A)`, where A is a valid sequence. Return `true` if the sequence is valid, and `false` otherwise.","solution":"def is_valid_bracket_sequence(arr): Returns True if the given bracket sequence is valid, otherwise False. Parameters: arr (list of str): A list where each element is either \'(\' or \')\'. Returns: bool: True if the sequence is valid, False otherwise. stack = [] for char in arr: if char == \'(\': stack.append(char) elif char == \')\': if not stack or stack.pop() != \'(\': return False # If there are any unmatched opening brackets left in stack, it\'s invalid return len(stack) == 0"},{"question":"You are given an integer array `nums` that represents the stock prices of a company in chronological order. You can buy and sell the stocks following these two constraints: * You must sell before buying again. * You can only execute at most two transactions. A transaction consists of buying and then selling one share of the stock. Return _the maximum profit you can achieve with at most two transactions_. If no profit can be achieved, return `0`.","solution":"def max_profit(nums): Calculate the maximum profit with at most two transactions. if not nums: return 0 n = len(nums) # Initialize the variables. We use -infinity for the initial states of buying. first_buy, second_buy = float(\'-inf\'), float(\'-inf\') first_sell, second_sell = 0, 0 for price in nums: # As we proceed, we update the profit values, making sure we buy before we sell. first_buy = max(first_buy, -price) # Maximum profit after first buy first_sell = max(first_sell, first_buy + price) # Maximum profit after first sell second_buy = max(second_buy, first_sell - price) # Maximum profit after second buy second_sell = max(second_sell, second_buy + price) # Maximum profit after second sell return second_sell"},{"question":"You are given a list of `n` integers `arr`, and you need to split this list into exactly `m` non-empty continuous subarrays. Write a function to minimize the maximum sum among these `m` subarrays. Return this minimum possible maximum sum. For example, if the input list is `[7, 2, 5, 10, 8]` and `m` is 2, the optimal way to split is `[7, 2, 5]` and `[10, 8]` which has the maximum sum of 18, which is the minimized maximum sum.","solution":"def split_array_min_max_sum(arr, m): def can_split(max_sum): current_sum = 0 num_subarrays = 1 for num in arr: if current_sum + num > max_sum: num_subarrays += 1 current_sum = num if num_subarrays > m: return False else: current_sum += num return True left, right = max(arr), sum(arr) while left < right: mid = (left + right) // 2 if can_split(mid): right = mid else: left = mid + 1 return left"},{"question":"You are given an integer array `heights` representing the heights of buildings in a row, and an integer `v` representing the maximum volume of water that can be trapped between the buildings after it rains. For each building, water can only be trapped between buildings that are taller than the building being considered. Return _the maximum volume of water that can be trapped if the maximum volume that can be trapped is_ `<= v`, _otherwise return_ `v`.","solution":"def trap_water_capacity(heights, v): Returns the maximum volume of water that can be trapped or v if trapped water exceeds v. if not heights: return 0 n = len(heights) left_max = [0] * n right_max = [0] * n water = 0 # Fill left_max array left_max[0] = heights[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], heights[i]) # Fill right_max array right_max[n - 1] = heights[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], heights[i]) # Calculate trapped water for i in range(n): water += min(left_max[i], right_max[i]) - heights[i] return water if water <= v else v"},{"question":"A university offers a system where students can enroll in courses online. Each course has a maximum number of students (`maxSeats`) that can be enrolled. You are tasked with implementing a course enrollment system with the following functionalities: 1. `Course(name: str, maxSeats: int)`: Constructor to initialize a course with the given `name` and a maximum number of seats. 2. `bool enrollStudent(studentId: int)`: Enrolls a student by their `studentId` in the course if there is room. Returns `true` if the enrollment is successful, otherwise returns `false`. 3. `bool removeStudent(studentId: int)`: Removes a student from the course by their `studentId`. Returns `true` if the removal is successful, otherwise returns `false`. 4. `List[int] getEnrolledStudents()`: Returns a list of student IDs currently enrolled in the course. Implement the `Course` class with the methods described above. Note that `studentId` is guaranteed to be unique for each student.","solution":"class Course: def __init__(self, name: str, maxSeats: int): self.name = name self.maxSeats = maxSeats self.enrolledStudents = [] def enrollStudent(self, studentId: int) -> bool: if len(self.enrolledStudents) < self.maxSeats and studentId not in self.enrolledStudents: self.enrolledStudents.append(studentId) return True return False def removeStudent(self, studentId: int) -> bool: if studentId in self.enrolledStudents: self.enrolledStudents.remove(studentId) return True return False def getEnrolledStudents(self) -> list: return self.enrolledStudents"},{"question":"You are given a list of strings `words` and two different words `word1` and `word2`. Write a function to find the **shortest** distance between these two words in the sentence. _Here the shortest distance is measured in terms of the number of words in between_ (i.e., the minimum number of words from `word1` to `word2`). Assume that words are separated by spaces and the input sentence contains at least one occurrence of both `word1` and `word2`. Example: ``` Input: words = [\\"practice\\", \\"makes\\", \\"perfect\\", \\"coding\\", \\"makes\\"], word1 = \\"coding\\", word2 = \\"practice\\" Output: 3 ``` **Note:** You may assume that `word1` and `word2` are always present in the list.","solution":"def shortest_distance(words, word1, word2): Find the shortest distance between two words in a list of words. Args: words (list): List of words in the sentence. word1 (str): First word. word2 (str): Second word. Returns: int: The shortest distance between the two words. # Initialize variables to store the latest positions of word1 and word2. index1, index2 = -1, -1 min_distance = float(\'inf\') for index, word in enumerate(words): if word == word1: index1 = index elif word == word2: index2 = index # Calculate distance if both words have been seen if index1 != -1 and index2 != -1: min_distance = min(min_distance, abs(index1 - index2)) return min_distance"},{"question":"You are given a **0-indexed** integer array `heights`, where `heights[i]` represents the height of the `i`-th building. A vacation starts at the first building and ends at the last building. A person can move from the `i`-th building to the `(i + 1)`-th building if the height difference is at most `d`. Return the maximum number of buildings the person can visit in sequence, starting from the first building.","solution":"def max_buildings(heights, d): Returns the maximum number of buildings a person can visit in sequence starting from the first building. :param heights: List[int], heights of the buildings :param d: int, maximum allowed difference in heights :return: int, maximum number of buildings that can be visited n = len(heights) max_visits = 1 current_visits = 1 for i in range(n-1): if abs(heights[i] - heights[i + 1]) <= d: current_visits += 1 max_visits = max(max_visits, current_visits) else: current_visits = 1 return max_visits"},{"question":"You are given a list of integers `nums` and an integer `k`. Return the length of the longest subarray in `nums` that contains at most `k` distinct integers. If there are multiple subarrays with the maximum length, return the length of any one of them. The function should have a linear time complexity. Use the sliding window technique to solve this problem efficiently.","solution":"def length_of_longest_subarray(nums, k): Returns the length of the longest subarray with at most k distinct integers. from collections import defaultdict n = len(nums) if n == 0 or k == 0: return 0 left = 0 right = 0 max_length = 0 distinct_count = 0 freq = defaultdict(int) while right < n: if freq[nums[right]] == 0: distinct_count += 1 freq[nums[right]] += 1 right += 1 while distinct_count > k: freq[nums[left]] -= 1 if freq[nums[left]] == 0: distinct_count -= 1 left += 1 max_length = max(max_length, right - left) return max_length"},{"question":"You are given two arrays, `startTimes` and `endTimes`, where `startTimes[i]` is the start time when a meeting `i` begins, and `endTimes[i]` is the end time when meeting `i` ends. These arrays are of equal length, representing multiple meetings. A person can attend a meeting if it starts after their previous meeting ends. You need to determine the maximum number of meetings a person can attend without overlapping. Return the count of such maximum attendable meetings.","solution":"def maxMeetings(startTimes, endTimes): Determines the maximum number of non-overlapping meetings that can be attended. Args: - startTimes: List[int], where startTimes[i] is the start time of meeting i - endTimes: List[int], where endTimes[i] is the end time of meeting i Returns: - int: The maximum number of non-overlapping meetings # Combine the start and end times along with their indices meetings = sorted(zip(endTimes, startTimes)) count = 0 last_end_time = 0 for end_time, start_time in meetings: if start_time >= last_end_time: # Attend the meeting count += 1 last_end_time = end_time return count"},{"question":"You are given a string `a` and a string `b` that consists of lowercase letters. You need to determine if string `a` can be converted to string `b` by performing the following operations in sequence: 1. **Deletion:** You are allowed to delete any number of characters from string `a`. 2. **Insertion:** After deletion, you can insert any number of characters into the remaining string. Return _`true` if it is possible to convert string `a` to string `b` using the above operations, and `false` otherwise._","solution":"def can_convert(a, b): Checks if string `a` can be converted to string `b` by first performing deletions and then insertions. # Find the Longest Common Subsequence (LCS) of `a` and `b` m = len(a) n = len(b) LCS = [[0] * (n + 1) for _ in range(m + 1)] # Fill the LCS table for i in range(m + 1): for j in range(n + 1): if i == 0 or j == 0: LCS[i][j] = 0 elif a[i - 1] == b[j - 1]: LCS[i][j] = LCS[i - 1][j - 1] + 1 else: LCS[i][j] = max(LCS[i - 1][j], LCS[i][j - 1]) # Check if the longest common subsequence is equal to the length of b return LCS[m][n] == n"},{"question":"You are given an array of integers `arr` of length `n` and an integer `k`. An operation is defined as selecting a subarray of `arr` of length `k` and reversing it. Return _the minimum number of operations required to sort the array in non-decreasing order_ using this operation. If it is impossible to sort the array this way, return `-1`.","solution":"def min_operations_to_sort(arr, k): Returns the minimum number of operations required to sort the array using subarray reversals of length k. If it is impossible, returns -1. if k == 1: return -1 if arr != sorted(arr) else 0 n = len(arr) sorted_arr = sorted(arr) if arr == sorted_arr: return 0 def can_be_sorted_with_reversals(array, k): for i in range(0, len(array) - k + 1, k // 2): sub_array = array[i:i + k] if sorted(sub_array) != sub_array: sub_array.reverse() if sorted(sub_array) == sub_array: array[i:i + k] = sub_array return True return False operations = 0 while arr != sorted_arr: if not can_be_sorted_with_reversals(arr, k): return -1 operations += 1 return operations"},{"question":"You are given a **0-indexed** integer array `nums` and an integer `k`. Your task is to divide the array into `k` consecutive non-empty subarrays. The score of such a division is defined as the sum of the maximum subarray sums of each of the `k` subarrays. Return the **minimum possible score** that can be achieved with such a division. For example, if `nums = [3, 1, 4, 1, 5, 9]` and `k = 2`, you need to divide the array into 2 subarrays such that the score, which is the sum of the maximum sums of each subarray, is minimized.","solution":"def minScore(nums, k): def canDivide(target): count = 0 curr_sum = 0 for num in nums: if curr_sum + num > target: count += 1 curr_sum = num if curr_sum > target: return False else: curr_sum += num return count < k low, high = max(nums), sum(nums) while low < high: mid = (low + high) // 2 if canDivide(mid): high = mid else: low = mid + 1 return low"},{"question":"You are given a list of dates formatted as strings `[\\"YYYY-MM-DD\\"]`. Implement a function that groups the dates by the year and returns a dictionary, where the keys are years and the values are lists of dates that correspond to that year. The dates in each list should be sorted in ascending order. Here is the function signature you need to implement: ```python def group_dates_by_year(dates: List[str]) -> Dict[int, List[str]]: ``` **Example:** - Input: `[\\"2020-01-01\\", \\"2019-12-31\\", \\"2020-06-15\\", \\"2021-01-01\\"]` - Output: `{2020: [\\"2020-01-01\\", \\"2020-06-15\\"], 2019: [\\"2019-12-31\\"], 2021: [\\"2021-01-01\\"]}`","solution":"from typing import List, Dict def group_dates_by_year(dates: List[str]) -> Dict[int, List[str]]: Groups the given list of dates by year. Parameters: dates (List[str]): A list of dates in \'YYYY-MM-DD\' format. Returns: Dict[int, List[str]]: A dictionary where keys are years and values are lists of dates for that year. date_dict = {} for date in dates: year = int(date[:4]) # Extract year from date string if year not in date_dict: date_dict[year] = [] date_dict[year].append(date) # Sort the dates for each year for year in date_dict: date_dict[year].sort() return date_dict"},{"question":"You are given an array of integers `arr` and an integer `x`. Implement the `SubsetXORChecker` class: * `SubsetXORChecker(int[] arr)` Initializes the class with the array `arr`. * `boolean subsetXORSatisfies(int x)` Returns `true` if there exists a non-empty subset of `arr` whose XOR is equal to `x`, otherwise returns `false`.","solution":"class SubsetXORChecker: def __init__(self, arr): self.arr = arr def subsetXORSatisfies(self, x): n = len(self.arr) subset_count = 1 << n # There are 2^n subsets for a set of size n for i in range(1, subset_count): xor_sum = 0 for j in range(n): if i & (1 << j): # If the j-th bit of i is set, include arr[j] xor_sum ^= self.arr[j] if xor_sum == x: return True return False"},{"question":"You are given a 2D grid of size `m x n` representing a floor plan of a warehouse. Each cell in the grid can be either `0` (empty) or `1` (an obstacle). A robot starts at the top-left corner of the grid (cell `(0, 0)`) and aims to reach the bottom-right corner of the grid (cell `(m-1, n-1)`). The robot can move up, down, left, or right, but cannot move outside the grid or onto a cell containing an obstacle (`1`). Your task is to determine the **shortest path from the top-left corner to the bottom-right corner**. If reaching the bottom-right corner is not possible, return `-1`. Return _the length of the shortest path, or_ `-1` _if it is impossible to reach the destination_.","solution":"from collections import deque def shortest_path(grid): Returns the length of the shortest path from the top-left corner to the bottom-right corner in a 2D grid filled with obstacles. Returns -1 if the destination cannot be reached. :param grid: List[List[int]] -- 2D grid with 0 (empty) and 1 (obstacle) :return: int -- length of the shortest path or -1 if not reachable if not grid or grid[0][0] == 1 or grid[-1][-1] == 1: return -1 m, n = len(grid), len(grid[0]) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([(0, 0, 1)]) # (row, col, distance) visited = set((0, 0)) while queue: r, c, dist = queue.popleft() if r == m - 1 and c == n - 1: return dist for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < m and 0 <= nc < n and (nr, nc) not in visited and grid[nr][nc] == 0: visited.add((nr, nc)) queue.append((nr, nc, dist + 1)) return -1"},{"question":"You are given an array of integers `nums` and an integer `target`. Write a function that finds two distinct indices `i` and `j` in the array such that `nums[i]` + `nums[j]` equals `target`. Return a tuple of these indices `(i, j)` if such a pair exists, or `(-1, -1)` if no pair of indices satisfies the condition. The solution should be optimized for time complexity, ideally running in O(n) time.","solution":"def two_sum(nums, target): Finds two distinct indices in the array such that the numbers at those indices add up to the target. Parameters: nums (list of int): List of integers. target (int): The target sum. Returns: tuple: A tuple of two indices (i, j) if a pair is found, (-1, -1) otherwise. num_to_index = {} for i, num in enumerate(nums): complement = target - num if complement in num_to_index: return (num_to_index[complement], i) num_to_index[num] = i return (-1, -1)"},{"question":"Given a `string` `expr` representing a mathematical expression where operands are non-negative integers and operators are addition (`+`) and subtraction (`-`), evaluate the expression and return the result as an integer. The expression can have multiple operators and should honor the standard operator precedence. You can assume the input is always valid. For example, given `expr = \\"3+5-2+8-6\\"`, the output should be `8`.","solution":"def evaluate_expression(expr): Evaluates a mathematical expression with non-negative integers and +, - operators. Parameters: expr (str): The expression to evaluate Returns: int: The result of the expression # Split input based on \'+\' and \'-\' index = 0 length = len(expr) current_number = 0 result = 0 sign = 1 # Start with a positive sign while index < length: if expr[index].isdigit(): current_number = 0 while index < length and expr[index].isdigit(): current_number = current_number * 10 + int(expr[index]) index += 1 result += sign * current_number elif expr[index] == \'+\': sign = 1 index += 1 elif expr[index] == \'-\': sign = -1 index += 1 return result"},{"question":"You are given a list of integers `nums` representing the number of items in consecutively numbered actions. You can choose to either skip an action or collect the items from an action but you cannot collect items from two consecutive actions. Write a function to determine the maximum number of items you can collect. For example, given the list `nums = [3, 2, 5, 10, 7]`, the maximum number of items you can collect is `3 + 10 = 13` since you cannot collect items from actions `2` and `5` (which are consecutive). Return _the maximum number of items you can collect from the given actions without collecting from two consecutive actions_.","solution":"def max_items(nums): Determines the maximum number of items that can be collected without choosing two consecutive actions. if not nums: return 0 if len(nums) == 1: return nums[0] # Initialize dp array to store the maximum number of items that can be collected up to each index dp = [0] * len(nums) dp[0] = nums[0] dp[1] = max(nums[0], nums[1]) for i in range(2, len(nums)): dp[i] = max(dp[i-1], dp[i-2] + nums[i]) return dp[-1]"},{"question":"Given a string `s` and a dictionary of words `wordDict`, return _all the sentences in which each word is a valid word from `wordDict`_. The words in the sentences should be combined in the exact order as they appear in the string `s` and should not overlap. The order of sentences in the return list does not matter. **Example:** Input: `s = \\"catsanddog\\"`, `wordDict = [\\"cat\\", \\"cats\\", \\"and\\", \\"sand\\", \\"dog\\"]` Output: `[\\"cats and dog\\", \\"cat sand dog\\"]` Input: `s = \\"pineapplepenapple\\"`, `wordDict = [\\"apple\\", \\"pen\\", \\"applepen\\", \\"pine\\", \\"pineapple\\"]` Output: `[\\"pine apple pen apple\\", \\"pineapple pen apple\\", \\"pine applepen apple\\"]`","solution":"def word_break(s, wordDict): Given a string `s` and a dictionary of words `wordDict`, returns all the sentences in which each word is a valid word from `wordDict`. The words in the sentences should be combined in the exact order as they appear in the string `s` and should not overlap. :param s: Input string :param wordDict: List of valid words :return: List of all possible sentences word_set = set(wordDict) memo = {} def backtrack(start): if start in memo: return memo[start] if start == len(s): return [\\"\\"] sentences = [] for end in range(start + 1, len(s) + 1): word = s[start:end] if word in word_set: for sub_sentence in backtrack(end): if sub_sentence: sentences.append(word + \\" \\" + sub_sentence) else: sentences.append(word) memo[start] = sentences return sentences return backtrack(0)"},{"question":"You are given an integer array `heights` representing the heights of plants arranged in a straight line. Some plants may have grown taller than others. A plant `i` can see the sunset if there are no taller plants to the right of it. Write a function that returns the indices of the plants that can see the sunset. The array of indices should be in increasing order. Function signature: ```python def sunset_views(heights: List[int]) -> List[int]: pass ``` Note: - The function should return the indices of the plants that can see the sunset. - The output array should be in increasing order.","solution":"from typing import List def sunset_views(heights: List[int]) -> List[int]: Returns the indices of the plants that can see the sunset. n = len(heights) result = [] if n == 0: return result max_height = 0 for i in range(n - 1, -1, -1): if heights[i] > max_height: result.append(i) max_height = heights[i] return list(reversed(result))"},{"question":"You are given a 2D grid of size `m x n` representing a map of a region. The grid consists of three types of cells: - `\'1\'` represents land, - `\'0\'` represents water, - `\'X\'` represents a resource. An island is defined as a group of `1`\'s (land) connected vertically or horizontally. You are tasked to identify the number of islands that contain at least one `X` (resource). Return the number of such resource-containing islands.","solution":"def num_resource_islands(grid): if not grid or not grid[0]: return 0 m, n = len(grid), len(grid[0]) visited = [[False] * n for _ in range(m)] directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] def dfs(x, y): stack = [(x, y)] has_resource = False while stack: i, j = stack.pop() if grid[i][j] == \'X\': has_resource = True for di, dj in directions: ni, nj = i + di, j + dj if 0 <= ni < m and 0 <= nj < n and not visited[ni][nj] and (grid[ni][nj] == \'1\' or grid[ni][nj] == \'X\'): visited[ni][nj] = True stack.append((ni, nj)) return has_resource count = 0 for i in range(m): for j in range(n): if (grid[i][j] == \'1\' or grid[i][j] == \'X\') and not visited[i][j]: visited[i][j] = True if dfs(i, j): count += 1 return count"},{"question":"You are given two integers `m` and `n`, which represent the dimensions of a matrix. You also have an array of `k` triples, where each triple represents a cell in the matrix that is toggled (with the triple containing the row index, column index, and the number of times the cell is toggled). Initially, all cells in the matrix are set to `0`. A cell value is toggled between `0` and `1` each time it is toggled, i.e., if a cell is toggled an odd number of times, its final value will be `1`; if toggled an even number of times, it will be `0`. Your task is to return the number of cells in the matrix that end up with a value of `1`.","solution":"def count_toggled_cells(m, n, toggles): Returns the number of cells in the m x n matrix that end up with a value of 1. :param m: Number of rows in the matrix :param n: Number of columns in the matrix :param toggles: List of triples (row index, column index, number of times the cell is toggled) :return: Number of cells with value 1 matrix = [[0 for _ in range(n)] for _ in range(m)] for toggle in toggles: row, col, times = toggle matrix[row][col] = (matrix[row][col] + times) % 2 count_ones = sum(cell for row in matrix for cell in row) return count_ones"},{"question":"You have a list of `n` integers `nums` where each element in the list is in the range `[1, n]`. Some elements appear twice and others appear once. Find all the elements that appear twice in the list. Implement a function that returns a list of integers representing the duplicate elements in `nums`. Each element in the output list must be unique, and you can return the output list in any order. Note: You must solve the problem without modifying the list `nums` and use only constant extra space.","solution":"def find_duplicates(nums): Returns a list of duplicate numbers in the input list `nums`. Each element in the output list must be unique. duplicates = [] for num in nums: index = abs(num) - 1 if nums[index] < 0: duplicates.append(abs(num)) else: nums[index] = -nums[index] # Restore nums to its original values for i in range(len(nums)): nums[i] = abs(nums[i]) return duplicates"},{"question":"You are given a list of non-negative integers `arr` and a range `[low, high]`. Your task is to find and return the number of subarrays whose sum lies in the interval `[low, high]` inclusive. A subarray is a contiguous part of an array. For example, given `arr = [1, 2, 3, 4]` and `low = 3`, `high = 6`, the valid subarrays are `[1, 2]`, `[2, 3]`, `[3]`, `[3, 4]` and `[4]`, so the function should return 5.","solution":"def count_subarrays_with_sum_in_range(arr, low, high): Returns the number of subarrays with sums in the range [low, high]. def subarray_sums_with_max_sum(k): Helper function to return the count of subarrays with sum less than or equal to k. count = 0 current_sum = 0 start = 0 for end in range(len(arr)): current_sum += arr[end] while current_sum > k: current_sum -= arr[start] start += 1 count += end - start + 1 return count return subarray_sums_with_max_sum(high) - subarray_sums_with_max_sum(low - 1)"},{"question":"You are given an array of integers `nums` where each integer appears exactly three times except for one integer which appears exactly once. Find that single one-time occurrence integer. You must implement an algorithm that runs in linear runtime complexity and uses only constant extra space. Return _the single one-time occurrence integer_.","solution":"def single_number(nums): Returns the single one-time occurrence integer in the list where every integer appears exactly three times except for one integer which appears exactly once. ones, twos = 0, 0 for num in nums: ones = (ones ^ num) & ~twos twos = (twos ^ num) & ~ones return ones"},{"question":"You are given two strings `s` and `t` of equal length. You can perform the following operation on any character of the string `s`: choose any single character from `a` to `z` and change the selected character to this new character. You need to make `s` and `t` **anagrams** (i.e., rearrange the characters of `s` to match `t`). Find the minimum number of operations required to make `s` and `t` anagrams of each other. Return _the minimum number of operations required to make_ `s` _and_ `t` _anagrams_.","solution":"def min_operations_to_anagram(s, t): Returns the minimum number of operations required to make s and t anagrams. freq_s = [0] * 26 freq_t = [0] * 26 for char in s: freq_s[ord(char) - ord(\'a\')] += 1 for char in t: freq_t[ord(char) - ord(\'a\')] += 1 operations = 0 for i in range(26): operations += abs(freq_s[i] - freq_t[i]) return operations // 2"},{"question":"Given a non-negative integer `x`, return the square root of `x` rounded down to the nearest integer. You must not use any built-in exponentiation functions or operators. For example, given `x = 8`, the output should be `2`, since the square root of `8` rounded down is `2`.","solution":"def mySqrt(x): Returns the square root of x rounded down to the nearest integer. if x < 0: raise ValueError(\\"The input must be a non-negative integer.\\") if x == 0: return 0 start, end = 1, x while start <= end: mid = (start + end) // 2 if mid * mid == x: return mid elif mid * mid < x: start = mid + 1 else: end = mid - 1 return end"},{"question":"Given a list of non-overlapping intervals, merge those intervals if they overlap. Each interval is represented as a tuple `(start, end)` where `start` is the starting point and `end` is the endpoint. The intervals are not guaranteed to be in any specific order. Return _a new list of intervals such that no two intervals overlap and all overlapping intervals are merged into one_.","solution":"def merge_intervals(intervals): Merges a list of non-overlapping intervals if they overlap. Parameters: intervals (list of tuples): each tuple (start, end) represents an interval Returns: list of tuples: merged list of intervals if not intervals: return [] # Sort intervals based on the start value intervals.sort(key=lambda x: x[0]) merged = [intervals[0]] for current in intervals[1:]: last = merged[-1] if current[0] <= last[1]: # there is an overlap merged[-1] = (last[0], max(last[1], current[1])) # merge else: merged.append(current) return merged"},{"question":"You are given a string `s` representing a mathematical equation of the form `A=B` where `A` and `B` are expressions containing only positive integers and the operators `+` and `-`. Evaluate whether the equation holds true. Return `True` if the equation is valid and `False` otherwise. The equation will not contain any parentheses and will be formatted without any spaces.","solution":"def evaluate_expression(expression): Evaluates a mathematical expression containing positive integers and the operators + and -. total = 0 current_value = 0 operator = \'+\' for char in expression: if char.isdigit(): current_value = current_value * 10 + int(char) else: if operator == \'+\': total += current_value elif operator == \'-\': total -= current_value operator = char current_value = 0 if operator == \'+\': total += current_value elif operator == \'-\': total -= current_value return total def is_equation_valid(s): Evaluates if a given equation of the form A=B is valid. left_expression, right_expression = s.split(\'=\') left_value = evaluate_expression(left_expression) right_value = evaluate_expression(right_expression) return left_value == right_value"},{"question":"You are tasked with designing a simple text editor. The text editor supports the following operations: * Insert a character at a specific position. * Delete a character from a specific position. * Retrieve the current text in the editor. Implement a class `TextEditor` that supports these operations. The class should have the following methods: ```python class TextEditor: def __init__(self): Initialize your data structure here. pass def insert(self, pos: int, ch: str) -> None: Insert character ch at index pos. pass def delete(self, pos: int) -> None: Delete the character at index pos. pass def get_text(self) -> str: Get the current text in the editor. pass ``` Your implementation should efficiently manage the sequence of text operations and ensure that all methods run in optimal time.","solution":"class TextEditor: def __init__(self): Initialize your data structure here. self.text = [] def insert(self, pos: int, ch: str) -> None: Insert character ch at index pos. if pos < 0 or pos > len(self.text): raise IndexError(\\"Position out of bounds\\") self.text.insert(pos, ch) def delete(self, pos: int) -> None: Delete the character at index pos. if pos < 0 or pos >= len(self.text): raise IndexError(\\"Position out of bounds\\") self.text.pop(pos) def get_text(self) -> str: Get the current text in the editor. return \'\'.join(self.text)"},{"question":"You are given a string `s` consisting of lowercase English letters. Your task is to construct a new string by removing some characters from `s` and rearranging the remaining characters such that the new string is a palindrome. A palindrome is a string that reads the same forwards and backwards. Return the longest possible palindrome string that can be constructed from the given `s`. If there are multiple palindromes of the same maximum length, return any one of them.","solution":"def longest_palindrome(s): Generate the longest possible palindrome string that can be constructed from the given string `s`. If there are multiple palindromes of the same maximum length, return any one of them. from collections import Counter # Count the frequency of each character in the string freq = Counter(s) left_half = [] middle = \\"\\" # Build the left half of the palindrome for char, count in freq.items(): # Use the even part of count to create the left part of the palindrome left_half.append(char * (count // 2)) # If the character count is odd, consider it for the middle part. if count % 2 == 1: # If current middle is empty or we choose the first odd frequency character to be the middle middle = char left_half = \\"\\".join(left_half) # Complete the palindrome by mirroring the left_half around the middle character (if any) palindrome = left_half + middle + left_half[::-1] return palindrome"},{"question":"You are given a binary tree where each node contains an integer value. Implement the `AverageOfLevels` class with the following methods: * `AverageOfLevels(TreeNode root)` Initializes the `AverageOfLevels` object with the given binary tree\'s root. * `List<Double> averageOfLevels()` Returns a list of doubles representing the average value of the nodes on each level in the order from the root to the leaves.","solution":"from collections import deque from typing import List, Optional class TreeNode: def __init__(self, val: int = 0, left: Optional[\'TreeNode\'] = None, right: Optional[\'TreeNode\'] = None): self.val = val self.left = left self.right = right class AverageOfLevels: def __init__(self, root: TreeNode): self.root = root def averageOfLevels(self) -> List[float]: if not self.root: return [] queue = deque([self.root]) averages = [] while queue: level_length = len(queue) level_sum = 0 for _ in range(level_length): node = queue.popleft() level_sum += node.val if node.left: queue.append(node.left) if node.right: queue.append(node.right) averages.append(level_sum / level_length) return averages"},{"question":"Given an m x n matrix `matrix` of integers and an integer `target`, return _the position_ [r, c] _(row and column indices)_ of _all occurrences of_ `target` _if it is in the matrix, or an empty list if it is not in the matrix_. The elements in the matrix are sorted in non-decreasing order both row-wise and column-wise. Your algorithm should run with `O(m + n)` complexity.","solution":"def search_target_in_matrix(matrix, target): Search for all occurrences of target in a row-wise and column-wise sorted matrix. Args: matrix (List[List[int]]): 2D list of integers sorted row-wise and column-wise. target (int): The target integer to search for. Returns: List[List[int]]: List of [row, column] indices where target is found, or an empty list if target is not found. if not matrix or not matrix[0]: return [] m, n = len(matrix), len(matrix[0]) i, j = 0, n - 1 result = [] while i < m and j >= 0: if matrix[i][j] == target: result.append([i, j]) i += 1 j -= 1 elif matrix[i][j] > target: j -= 1 else: i += 1 return result"},{"question":"You are given an array `A` of non-negative integers. Your task is to partition `A` into two subsets such that the sum of the elements in both subsets is equal. Return `true` if it is possible to partition the array in this way, otherwise return `false`.","solution":"def can_partition(A): Determines if the array A can be partitioned into two subsets with equal sums. Args: A : List[int] - List of non-negative integers Returns: bool - True if the array can be partitioned into two subsets with equal sum, False otherwise. total_sum = sum(A) # If the total sum is odd, it\'s not possible to partition into equal subsets if total_sum % 2 != 0: return False target_sum = total_sum // 2 # Initialize a boolean DP array dp = [False] * (target_sum + 1) dp[0] = True # Update dp array based on numbers in A for num in A: for i in range(target_sum, num - 1, -1): dp[i] = dp[i] or dp[i - num] return dp[target_sum]"},{"question":"You\'re given an integer array `ratings` representing the ratings of `n` movies which a movie review website wants to recommend in a specific order based on a new algorithm. An integer `blockSize` is also given. The site will create overlapping blocks of ratings of length `blockSize` and recommend these blocks in reverse order. However, if there are fewer than `blockSize` ratings remaining at the end, the final block will consist only of the remaining ratings. For example, if `ratings = [5, 1, 9, 3, 7, 4]` and `blockSize = 3`, the overlapping blocks and their recommended order would be: - `[5, 1, 9]` - `[1, 9, 3]` - `[9, 3, 7]` - `[3, 7, 4]` Given the integer array `ratings` and the integer `blockSize`, return a 2D integer array where each subarray represents the blocks in the specified order. **Note**: The result array should contain the blocks in reverse order of their creation. If the block where the last group is less than `blockSize`, that block should still be added as is. Return the result as a 2D integer array of the blocks.","solution":"def recommend_blocks(ratings, blockSize): n = len(ratings) blocks = [] # Generate the blocks for i in range(n - blockSize + 1): blocks.append(ratings[i:i + blockSize]) # Add the final block if it\'s smaller than blockSize if n % blockSize != 0: remaining_block = ratings[-(n % blockSize):] blocks.append(remaining_block) # Return in reverse order return blocks[::-1]"},{"question":"You are given a two-dimensional grid of integers, where each cell in the grid contains a value that represents the cost to step on that cell. You are initially positioned at the top-left corner of the grid and you want to reach the bottom-right corner of the grid. You can only move either down or right at any point in time. Write a function that returns the minimum cost to reach from the top-left corner to the bottom-right corner of the grid.","solution":"def min_cost_path(grid): rows = len(grid) cols = len(grid[0]) # Create a 2D list to store the minimum cost to reach each cell cost = [[0 for _ in range(cols)] for _ in range(rows)] cost[0][0] = grid[0][0] # Initialize the first column for i in range(1, rows): cost[i][0] = cost[i-1][0] + grid[i][0] # Initialize the first row for j in range(1, cols): cost[0][j] = cost[0][j-1] + grid[0][j] # Populate the rest of the cost array for i in range(1, rows): for j in range(1, cols): cost[i][j] = min(cost[i-1][j], cost[i][j-1]) + grid[i][j] return cost[rows-1][cols-1]"},{"question":"You are given a list of `n` integers, `arr`, where `arr[i]` is the `ith` integer in the list. And an integer `m`, where `1 <= m <= n`. Your task is to determine the **maximum sum** of any `m` contiguous subarray within the list `arr`. A contiguous subarray is a sequence of consecutive elements in the original array. Return _the **maximum sum** of any `m` contiguous subarray in the list_.","solution":"def max_sum_of_m_contiguous_subarray(arr, m): Returns the maximum sum of any m contiguous subarray in the list arr. n = len(arr) # Calculate the sum of the first \'m\' elements max_sum = sum(arr[:m]) current_sum = max_sum # Slide over the array for i in range(m, n): current_sum = current_sum + arr[i] - arr[i - m] if current_sum > max_sum: max_sum = current_sum return max_sum"},{"question":"Given an array `arr` of positive integers, return the **length** of the **longest increasing subsequence** such that each element in the subsequence is a **power of two**. A **subsequence** is derived from an array by deleting some or none of the elements without changing the order of the remaining elements. A number is a power of two if it can be written as `2^k` where `k` is a non-negative integer.","solution":"def longest_power_of_two_subsequence(arr): Returns the length of the longest increasing subsequence where each element is a power of two. # Function to check if a number is a power of two def is_power_of_two(x): return (x & (x - 1)) == 0 and x != 0 # Filter the array to contain only powers of two powers_of_two = [num for num in arr if is_power_of_two(num)] if not powers_of_two: return 0 # Use dynamic programming to find the length of the longest increasing subsequence dp = [1] * len(powers_of_two) for i in range(len(powers_of_two)): for j in range(i): if powers_of_two[i] > powers_of_two[j]: dp[i] = max(dp[i], dp[j] + 1) return max(dp)"},{"question":"Given an integer array `nums` and an integer `k`, your task is to return the `k`-th smallest element in the array. Note that it is the `k`-th smallest element in the sorted order, not the `k`-th distinct element. Implement the method `int kthSmallest(int[] nums, int k)` that solves this problem efficiently.","solution":"def kthSmallest(nums, k): Returns the k-th smallest element in the array nums. nums.sort() return nums[k-1]"},{"question":"Write a function that takes a list of integers `nums` and returns the length of the longest subarray where the elements are arranged in a strictly increasing order. A subarray is defined as a contiguous portion of the array. Note that the elements within the subarray must increase without repetition of any values.","solution":"def longest_increasing_subarray(nums): Returns the length of the longest subarray where the elements are in strictly increasing order. if not nums: return 0 max_len = 1 current_len = 1 for i in range(1, len(nums)): if nums[i] > nums[i - 1]: current_len += 1 max_len = max(max_len, current_len) else: current_len = 1 return max_len"},{"question":"Given a binary tree, return the sum of values of its deepest leaves. A leaf is a node with no children, and the depth of a node is the number of edges in the longest path from the root to that node. The tree is represented as a series of TreeNode objects where each node has a value, and pointers to up to two children. Your task is to implement a function that computes this sum given the root of the binary tree.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def deepestLeavesSum(root): Returns the sum of values of the deepest leaves in a binary tree. :param root: TreeNode :return: int if not root: return 0 from collections import deque max_depth = 0 leaves_sum = 0 queue = deque([(root, 0)]) while queue: node, depth = queue.popleft() if node.left is None and node.right is None: if depth > max_depth: max_depth = depth leaves_sum = node.val elif depth == max_depth: leaves_sum += node.val else: if node.left: queue.append((node.left, depth + 1)) if node.right: queue.append((node.right, depth + 1)) return leaves_sum"},{"question":"You are given a `root` node of a binary tree. The tree is not necessarily a binary search tree. Each node contains an integer value. Your task is to find the length of the longest path where each node in the path has the same value. This path can be a combination of both parent-child connections and connections between siblings. Return _the length of the longest path with the same value_.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def longest_univalue_path(root): def helper(node): nonlocal longest if not node: return 0 left_length = helper(node.left) right_length = helper(node.right) left_univalue_path = left_length + 1 if node.left and node.left.val == node.val else 0 right_univalue_path = right_length + 1 if node.right and node.right.val == node.val else 0 longest = max(longest, left_univalue_path + right_univalue_path) return max(left_univalue_path, right_univalue_path) longest = 0 helper(root) return longest"},{"question":"You are given a 2D integer grid `matrix` representing a battlefield where `0` represents empty cells and `1` represents obstacles. Two players want to start from the top-left corner and reach the bottom-right corner of the battlefield. Both players follow the shortest path and can move only one cell at a time in the four cardinal directions (up, down, left, right). If it\'s not possible for either player to reach the destination due to obstacles, return `-1`. If they can both reach the destination, return an array containing the number of steps both players took to get there. If only one player can reach the destination in a shorter path, return the number of steps for the accommodating player.","solution":"from collections import deque def bfs(matrix, start, end): rows, cols = len(matrix), len(matrix[0]) visited = set() queue = deque([(start, 0)]) visited.add(start) while queue: (x, y), dist = queue.popleft() if (x, y) == end: return dist for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nx, ny = x + dx, y + dy if 0 <= nx < rows and 0 <= ny < cols and matrix[nx][ny] == 0 and (nx, ny) not in visited: visited.add((nx, ny)) queue.append(((nx, ny), dist + 1)) return -1 def shortest_path(matrix): if not matrix or not matrix[0]: return -1 rows, cols = len(matrix), len(matrix[0]) # Starting point and ending point coordinates start = (0, 0) end = (rows - 1, cols - 1) # Early exit if start or end is an obstacle if matrix[0][0] == 1 or matrix[rows - 1][cols - 1] == 1: return -1 steps_player1 = bfs(matrix, start, end) steps_player2 = steps_player1 # same path since they start and end at the same place if steps_player1 == -1: return -1 return [steps_player1, steps_player2]"},{"question":"You are given a **0-indexed** integer array `heights` representing the heights of terrain along a 2D landscape. In one operation, you can choose any two consecutive columns and reduce the height of the taller column by one to make it equal to the height of the shorter column. Return _the **minimum** number of operations needed to make all the heights in the array equal._","solution":"def min_operations_to_equalize(heights): Returns the minimum number of operations needed to make all the heights in the array equal. if not heights: return 0 max_height = max(heights) min_height = min(heights) return sum(height - min_height for height in heights)"},{"question":"You are given a string `s` consisting of only lowercase English letters. You can choose to perform any number of operations on this string, where in each operation, you select a non-empty substring and reverse it. The goal is to determine if you can transform the string into its lexicographically smallest possible form by performing these operations. Return a boolean value **true** if it is possible to transform the string into its lexicographically smallest form, and **false** otherwise.","solution":"def can_transform_to_lexicographically_smallest(s): Determines if it\'s possible to transform the string s into its lexicographically smallest possible form by reversing any number of substrings. Parameters: s (str): The original string consisting of only lowercase English letters. Returns: bool: True if the string can be transformed into the lexicographically smallest form, False otherwise. return sorted(s) == list(s)"},{"question":"You are given an integer array `nums` where `nums[i]` represents the number of units of a resource you have on the `i-th` day. You can choose to convert the resource units you have on a given day to money, but you must convert all units at once (i.e., take all units present on a day and set them to 0). The conversion rate is a non-negative integer given by the array `conversion` of the same length as `nums`, where `conversion[i]` indicates the rate on the ith day (money gained per unit of resource). Your goal is to maximize the total money obtained over a given period. Return _the **maximum** amount of money you can obtain if you are only allowed to convert the resource units to money on a **single** day._","solution":"def max_money(nums, conversion): Returns the maximum amount of money that can be obtained by converting the resources on a single day. Parameters: nums (list): List of integers where nums[i] is the number of units of a resource on the i-th day. conversion (list): List of integers where conversion[i] is the rate on the i-th day. Returns: int: Maximum money obtainable. max_profit = 0 for i in range(len(nums)): max_profit = max(max_profit, nums[i] * conversion[i]) return max_profit"},{"question":"You are given an array of non-negative integers `heights` representing the height of pillars arranged in a row. A water tank is formed between two pillars if and only if there are at least two pillars of height greater than zero. Find and return the maximum amount of water that can be trapped between the pillars after it rains. Note that the water trapped is confined within the bounds of the minimum height between the two pillars and that the heights of the pillars in between define the bottom of the water tank.","solution":"def max_water_trapped(heights): Calculate the maximum amount of water that can be trapped between the pillars. Parameters: heights (list): A list of non-negative integers representing the height of the pillars. Returns: int: The maximum amount of water that can be trapped. if not heights or len(heights) < 3: return 0 left = 0 right = len(heights) - 1 left_max = heights[left] right_max = heights[right] max_water = 0 while left < right: if heights[left] < heights[right]: left += 1 left_max = max(left_max, heights[left]) max_water += max(0, left_max - heights[left]) else: right -= 1 right_max = max(right_max, heights[right]) max_water += max(0, right_max - heights[right]) return max_water"},{"question":"You are given a matrix `grid` of `m` rows and `n` columns where each cell is either `0` (representing water) or `1` (representing land). A **lake** is formed by one or more connected horizontal or vertical cells of `0`s surrounded by land cells (1s). A land cell can border a lake on any side. You need to find the size of the largest lake in the matrix. Return _the size of the largest lake_. The test cases will be generated such that there is at least one lake in the matrix.","solution":"def largest_lake(grid): Returns the size of the largest lake in the given grid. A lake is formed by connected horizontal or vertical cells of 0\'s. :param grid: List[List[int]] - The grid of m rows and n columns :return: int - The size of the largest lake def dfs(x, y): # If the cell is out of bounds or not water, don\'t count it if x < 0 or x >= len(grid) or y < 0 or y >= len(grid[0]) or grid[x][y] != 0: return 0 # Mark the cell as visited by setting it to 2 grid[x][y] = 2 # Count this cell size = 1 # Explore all four possible directions and accumulate the size size += dfs(x + 1, y) size += dfs(x - 1, y) size += dfs(x, y + 1) size += dfs(x, y - 1) return size largest = 0 for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == 0: # Start a depth-first search from this cell lake_size = dfs(i, j) largest = max(lake_size, largest) return largest"},{"question":"Given a binary tree, return the bottom-up level order traversal of its nodes\' values. (i.e., from left to right, level by level from leaf to root). Each node is guaranteed to have an integer value. The tree is represented in the input as an array where `null` represents absent nodes. Example: Input: [3, 9, 20, null, null, 15, 7] Output: [[15, 7], [9, 20], [3]] This should be a function where the input is an array representing a binary tree and the output is a list of lists, each containing integers corresponding to the values of the tree nodes at each level, from bottom to top.","solution":"from collections import deque class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def levelOrderBottom(root): if not root: return [] result, queue = deque(), deque([root]) while queue: level = [] for _ in range(len(queue)): node = queue.popleft() if node: level.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.appendleft(level) return list(result) def deserialize(data): if not data: return None root = TreeNode(data[0]) queue = deque([root]) index = 1 while queue and index < len(data): node = queue.popleft() if data[index] is not None: node.left = TreeNode(data[index]) queue.append(node.left) index += 1 if index < len(data) and data[index] is not None: node.right = TreeNode(data[index]) queue.append(node.right) index += 1 return root def bottom_up_level_order_traversal(data): root = deserialize(data) return levelOrderBottom(root)"},{"question":"Given a binary tree, each node has additional two pointers `next` and `random`, which can point to any node in the tree (or null). Implement a function to clone this binary tree. The resulting tree should be identical to the original tree, with each `next` and `random` pointer in the new tree pointing to the corresponding node in the original tree\'s structure. The original binary tree should remain unchanged. - Class definition: ```python class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None self.next = None self.random = None ``` - Function signature: ```python def cloneBinaryTree(root: TreeNode) -> TreeNode: ```","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None self.next = None self.random = None def cloneBinaryTree(root: TreeNode) -> TreeNode: if not root: return None # Dictionary to keep track of cloned nodes cloned_nodes = {} # Helper function to perform the clone recursively def clone(node): if not node: return None if node in cloned_nodes: return cloned_nodes[node] cloned_node = TreeNode(node.val) cloned_nodes[node] = cloned_node cloned_node.left = clone(node.left) cloned_node.right = clone(node.right) cloned_node.next = clone(node.next) cloned_node.random = clone(node.random) return cloned_node return clone(root)"},{"question":"You are given a list of positive integers `nums` and an integer `target`. You must find whether there is a subset of `nums` that sums up to the `target` value. Return _true_ if such a subset exists, otherwise return _false_.","solution":"def subset_sum(nums, target): Determines if there is a subset of nums that sums up to the target value. Args: nums (list of int): List of positive integers. target (int): The target sum value. Returns: bool: True if a subset exists that sums up to target, else False. n = len(nums) dp = [[False] * (target + 1) for _ in range(n + 1)] # Base case: A sum of 0 can always be achieved by selecting no items. for i in range(n + 1): dp[i][0] = True # Populate the dp table for i in range(1, n + 1): for j in range(1, target + 1): dp[i][j] = dp[i-1][j] if j >= nums[i-1]: dp[i][j] = dp[i][j] or dp[i-1][j-nums[i-1]] return dp[n][target]"},{"question":"A server logs the start and stop times of various processes. Each log entry consists of a timestamp and an event type (either \\"start\\" or \\"stop\\"). Given a list of such log entries, calculate the total time during which any process was running. The timestamp is given as an integer representing the number of seconds since the start of the observation period. Each \\"start\\" event will have a corresponding \\"stop\\" event. Processes may overlap. The `logEntries` are sorted in ascending order of timestamps. Return the total running time of all processes combined. Example log entries: ``` [ {\\"timestamp\\": 1, \\"event\\": \\"start\\"}, {\\"timestamp\\": 4, \\"event\\": \\"start\\"}, {\\"timestamp\\": 5, \\"event\\": \\"stop\\"}, {\\"timestamp\\": 7, \\"event\\": \\"stop\\"} ] ``` Output: ``` 6 ```","solution":"def calculate_total_running_time(logEntries): Calculates the total running time of all processes combined. Parameters: logEntries (list of dict): List of log entries, each being a dictionary with keys \'timestamp\' and \'event\'. Event is either \'start\' or \'stop\'. Returns: int: Total running time of all processes. total_time = 0 active_processes = 0 start_time = None for entry in logEntries: if entry[\'event\'] == \'start\': if active_processes == 0: start_time = entry[\'timestamp\'] active_processes += 1 elif entry[\'event\'] == \'stop\': active_processes -= 1 if active_processes == 0 and start_time is not None: total_time += entry[\'timestamp\'] - start_time start_time = None return total_time"},{"question":"You are given a string `s` and an array of strings `words`. Each string in `words` can be inserted into the string `s` at any position. After inserting all the strings from `words`, check if the resulting string is a palindrome. Return `true` if it is possible to create a palindrome; otherwise, return `false`. Note that each string from `words` must be used exactly once and can only be inserted in its entirety at any position.","solution":"from collections import Counter def can_form_palindrome(s, words): Check if it is possible to insert all strings from \'words\' into \'s\' such that the resulting string is a palindrome. Args: s (str): The initial string. words (list of str): The list of words to insert. Returns: bool: True if it\'s possible to form a palindrome, False otherwise. # Combine all words to a single string all_words = \'\'.join(words) combined = s + all_words # Count frequency of each character char_count = Counter(combined) # Number of chars with odd counts in combined string odd_count = sum(1 for count in char_count.values() if count % 2 != 0) # A palindrome can have at most one character with an odd frequency return odd_count <= 1"},{"question":"You are given a string `s` consisting of lowercase English letters. A valid transformation of the string involves moving any number of letters from the end of the string to the beginning of the string without changing the order of those letters. Determine the lexicographically smallest string that can be obtained through any number of valid transformations. Return this lexicographically smallest string.","solution":"def smallest_lexicographic_string(s: str) -> str: Find the lexicographically smallest string by moving letters from the end to the beginning. Parameters: s (str): Input string consisting of lowercase English letters. Returns: str: Lexicographically smallest string possible. if not s: return \\"\\" smallest_string = s for i in range(1, len(s)): transformed = s[i:] + s[:i] if transformed < smallest_string: smallest_string = transformed return smallest_string"},{"question":"Given a string `t` consisting of only the characters \'A\' and \'B\'. A substring is defined as a contiguous sequence of characters within the string. A balanced substring is one in which the number of \'A\'s is equal to the number of \'B\'s. Write a function to return the length of the longest balanced substring in `t`. If no balanced substring exists, return `0`.","solution":"def longest_balanced_substring(t): Returns the length of the longest balanced substring where the number of \'A\'s is equal to the number of \'B\'s. :param t: A string consisting of only characters \'A\' and \'B\' :return: The length of the longest balanced substring max_length = 0 count = 0 indices = {0: -1} for idx, char in enumerate(t): if char == \'A\': count += 1 elif char == \'B\': count -= 1 if count in indices: max_length = max(max_length, idx - indices[count]) else: indices[count] = idx return max_length"},{"question":"You have a list of integers `nums` sorted in ascending order. You are tasked with removing duplicates in-place such that each unique element appears only once and returning the new length of the array. The relative order of the elements must be maintained, and you must use O(1) extra space. You may not need to change the list length after removal, just adjust the elements in-place and return the new length. For example, given the list `[0,0,1,1,1,2,2,3,3,4]`, after removing duplicates, the list should be updated in-place to `[0, 1, 2, 3, 4]`, and the returned length should be `5`.","solution":"def remove_duplicates(nums): Remove duplicates in place and return the new length of the array. :param nums: List[int] - List of sorted integers :return: int - New length of the array without duplicates if not nums: return 0 # Initialize the index for the next unique element. unique_index = 0 for i in range(1, len(nums)): if nums[i] != nums[unique_index]: unique_index += 1 nums[unique_index] = nums[i] # The new length is the number of unique elements. return unique_index + 1"},{"question":"You are given a **0-indexed** integer array `nums`, and an integer `target`. In one operation, you can move the element at position `i` to position `j` if `|i - j| == 1`. Your task is to determine whether it is possible to rearrange the array to form a consecutive sequence of integers starting from `target`. If it\'s possible, return `true`; otherwise, return `false`.","solution":"def can_form_consecutive_sequence(nums, target): Determine whether it is possible to rearrange the array to form a consecutive sequence of integers starting from \'target\'. Parameters: nums (list of int): A list of integers. target (int): The starting integer of the desired consecutive sequence. Returns: bool: True if it\'s possible to rearrange the array to form the desired sequence, False otherwise. n = len(nums) nums_sorted = sorted(nums) for i in range(n): if nums_sorted[i] != target + i: return False return True"},{"question":"You are given the task of creating a simulation of an ATM that handles basic transactions. The ATM should store an initial amount of cash and support the following operations: 1. **Deposit:** Accept a specified amount of money and increase the total. 2. **Withdraw:** Deduct a specified amount of money from the total. Ensure that withdrawals do not exceed the available balance. 3. **Check Balance:** Return the current available balance. Write a class `ATM` to simulate the ATM, which should have the following methods: - `deposit(amount)`: Adds `amount` to the current balance. - `withdraw(amount)`: Deducts `amount` from the current balance if sufficient funds are available; otherwise, it returns an error message. - `check_balance()`: Returns the current balance. Implement the class `ATM` such that it can be initialized with an optional starting balance and provide the functionality to process the described operations effectively.","solution":"class ATM: def __init__(self, initial_balance=0): Initializes the ATM with an optional initial balance. self.balance = initial_balance def deposit(self, amount): Deposits the specified amount into the ATM\'s balance. if amount > 0: self.balance += amount return self.balance else: return \\"Invalid deposit amount.\\" def withdraw(self, amount): Withdraws the specified amount from the ATM\'s balance if sufficient funds are available. if amount <= self.balance: self.balance -= amount return self.balance else: return \\"Insufficient funds.\\" def check_balance(self): Returns the current balance. return self.balance"},{"question":"Given two strings `a` and `b`, return the length of the longest subsequence that is common to both strings. A subsequence is a sequence that can be derived from another sequence by deleting some elements without changing the order of the remaining elements. For example, \\"abc\\", \\"abg\\", \\"bdf\\", \\"aeg\\", \\"acefg\\", ... are subsequences of \\"abcdefg\\". The common subsequence between \\"abcde\\" and \\"ace\\" is \\"ace\\" which has a length of 3. Note that the subsequences do not need to be contiguous.","solution":"def longest_common_subsequence(a, b): Returns the length of the longest common subsequence between strings a and b. m, n = len(a), len(b) # Create a DP table to store the lengths of longest common subsequence. dp = [[0] * (n + 1) for _ in range(m + 1)] # Build the dp table for i in range(1, m + 1): for j in range(1, n + 1): if a[i - 1] == b[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) return dp[m][n]"},{"question":"Given two sorted arrays `arr1` and `arr2` of size `m` and `n` respectively, return _a new sorted array that contains all the elements from `arr1` and `arr2`_. Do not use any pre-built array sorting functions for the final array.","solution":"def merge_sorted_arrays(arr1, arr2): Merge two sorted arrays into a new sorted array. :param arr1: List[int] - A sorted array of integers :param arr2: List[int] - A sorted array of integers :return: List[int] - A new sorted array containing all elements from arr1 and arr2 merged_array = [] i = 0 j = 0 while i < len(arr1) and j < len(arr2): if arr1[i] < arr2[j]: merged_array.append(arr1[i]) i += 1 else: merged_array.append(arr2[j]) j += 1 while i < len(arr1): merged_array.append(arr1[i]) i += 1 while j < len(arr2): merged_array.append(arr2[j]) j += 1 return merged_array"},{"question":"You are given an integer array `arr` consisting of `n` distinct integers. Your task is to rearrange the array into its lexicographically next permutation. The replacement must be in-place and use only constant extra memory. If no such permutation exists (i.e., the array is sorted in descending order), rearrange it as the smallest possible order (i.e., sorted in ascending order). Return the modified array.","solution":"def next_permutation(arr): Modify the array to its lexicographically next permutation. If no such permutation exists, rearrange it to the smallest possible order. n = len(arr) if n <= 1: return arr # Find the largest index k such that arr[k] < arr[k + 1] k = n - 2 while k >= 0 and arr[k] >= arr[k + 1]: k -= 1 if k >= 0: # Find the largest index l greater than k such that arr[k] < arr[l] l = n - 1 while l > k and arr[k] >= arr[l]: l -= 1 # Swap the value of arr[k] with that of arr[l] arr[k], arr[l] = arr[l], arr[k] # Reverse the sequence from arr[k + 1] up to the last element arr[k + 1:] = reversed(arr[k + 1:]) return arr"},{"question":"Given a list of integers `nums`, where each integer represents a task with a certain duration, and an integer `k` representing the number of processors available, partition the list into `k` contiguous subarrays such that the maximum sum of any subarray is minimized. Return the minimized value.","solution":"def can_partition(nums, k, max_sum): current_sum = 0 partitions = 1 for num in nums: if current_sum + num > max_sum: partitions += 1 current_sum = num if partitions > k: return False else: current_sum += num return True def minimize_max_partition_sum(nums, k): left, right = max(nums), sum(nums) while left < right: mid = (left + right) // 2 if can_partition(nums, k, mid): right = mid else: left = mid + 1 return left"},{"question":"You are given a **positive** integer `target` and a **non-empty, 0-indexed** integer array `nums` containing `m` **distinct** positive integers. You can perform the following operation: choose two integers, `i` and `j` (0 ≤ i, j < m), and replace `nums[i]` with `nums[i] + nums[j]` (you can add a number to itself). The goal is to make the array contain a number that is **exactly** equal to the target. Determine the **minimum number of operations** required to reach the target, or return `-1` if it is not possible to achieve the target using any sequence of operations.","solution":"from collections import deque def min_operations_to_target(nums, target): Determines the minimum number of operations required to include a number exactly equal to `target` in the `nums` array, or returns -1 if it is not possible. Parameters: nums (list of int): List of distinct positive integers. target (int): The target number to achieve in the array. Returns: int: Minimum number of operations or -1 if not possible. if target in nums: return 0 visited = set(nums) queue = deque([(num, 0) for num in nums]) while queue: current, ops = queue.popleft() if current == target: return ops for num in nums: next_val = current + num if next_val == target: return ops + 1 if next_val < target and next_val not in visited: visited.add(next_val) queue.append((next_val, ops + 1)) return -1"},{"question":"Given a string `s` containing only digits, return the number of ways to decode it. The decoding rules are: 1. \'1\' can be decoded as \'A\', \'2\' as \'B\', ..., \'26\' as \'Z\'. 2. A two-digit number like \'10\' or \'27\' must be treated as a single character if it falls within the range from \'10\' to \'26\'. For example, given the string `s = \\"226\\"`, there are three ways to decode it: \\"BZ\\", \\"VF\\", and \\"BBF\\". Return the number of possible decodings.","solution":"def num_decodings(s: str) -> int: if not s: return 0 n = len(s) dp = [0] * (n + 1) dp[0] = 1 for i in range(1, n + 1): if s[i - 1] != \'0\': dp[i] += dp[i - 1] if i > 1 and \\"10\\" <= s[i - 2:i] <= \\"26\\": dp[i] += dp[i - 2] return dp[n]"},{"question":"You are given a string `s` contiguous alphanumeric characters and a list of strings `words`. Your task is to determine how many times you can find each string from `words` as a substring in `s`. The search for each word must be case-sensitive. The function should return a list of integers where each integer corresponds to the count of the respective word in the `words` list. For example, if `s` is `\\"abcdeabc\\"` and `words` is `[\\"a\\", \\"abc\\", \\"cde\\", \\"x\\"]`, the output should be `[2, 2, 1, 0]` indicating that `\\"a\\"` appears twice, `\\"abc\\"` appears twice, `\\"cde\\"` appears once, and `\\"x\\"` does not appear in the string. Write a function that takes the string `s` and the list of strings `words` as input and returns the list of integers as described.","solution":"def count_substrings(s, words): This function takes a main string s and a list of words. It returns a list of integers where each integer is the count of occurrences of the respective word in the main string. counts = [] for word in words: count = 0 start = 0 while True: start = s.find(word, start) if start == -1: break count += 1 start += 1 # Move to the next character for overlapping substrings counts.append(count) return counts"},{"question":"You are given an **n x n** 2D matrix `grid` containing only `0`s and `1`s. A *connected group* is a set of adjacent `1`s (connected horizontally or vertically). Return _the size of the largest connected group in the grid_.","solution":"def largest_connected_group(grid): Returns the size of the largest connected group of 1\'s in the grid. def dfs(x, y): # Base case: if we\'re out of range or the cell is not a 1, return 0 if x < 0 or x >= len(grid) or y < 0 or y >= len(grid[0]) or grid[x][y] == 0: return 0 # Mark the cell as visited by setting it to 0 grid[x][y] = 0 # Initialize the size of this connected group to 1 (the current cell) size = 1 # Recursively visit all adjacent cells (up, down, left, right) size += dfs(x - 1, y) size += dfs(x + 1, y) size += dfs(x, y - 1) size += dfs(x, y + 1) return size max_size = 0 # Iterate over all cells in the grid for i in range(len(grid)): for j in range(len(grid[i])): # If we find a 1, perform a DFS to find the size of the connected group if grid[i][j] == 1: max_size = max(max_size, dfs(i, j)) return max_size"},{"question":"Given a binary tree, populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to `null`. Initially, all next pointers are set to `null`. Assume perfect binary tree (i.e., all leaves are at the same level, and every parent has two children). The tree data structure is given as follows: ```python class Node: def __init__(self, val: int = 0, left: \'Node\' = None, right: \'Node\' = None, next: \'Node\' = None): self.val = val self.left = left self.right = right self.next = next ``` Write a function to achieve this.","solution":"class Node: def __init__(self, val: int = 0, left: \'Node\' = None, right: \'Node\' = None, next: \'Node\' = None): self.val = val self.left = left self.right = right self.next = next def connect(root: \'Node\') -> \'Node\': Populate each next pointer to point to its next right node. if not root: return root # Initialize the current level starting point as the root node leftmost = root while leftmost.left: # Iterate through the current level nodes and establish the next connections for the lower level head = leftmost while head: # Connect both children of the current node head.left.next = head.right # If the current node has a next, connect the right child to the next left child if head.next: head.right.next = head.next.left # Move to the next node in the current level head = head.next # Move down to the next level (leftmost node of the next level) leftmost = leftmost.left return root"},{"question":"You have been given a collection of integers representing an initial array, and you need to process a series of operations on this array. The operations include adding an integer to the array and finding the median of the current array in constant time. Implement the `MedianFinder` class: * `MedianFinder()`: Initializes the `MedianFinder` object. * `void addNum(int num)`: Adds an integer `num` to the data structure. * `double findMedian()`: Returns the median of all integers added so far. If the number of elements is odd, return the middle element; otherwise, return the average of the two middle elements. Note: - The solution must ensure that `findMedian` has a complexity of O(1).","solution":"import heapq class MedianFinder: def __init__(self): Initialize your data structure here. self.small = [] # Max-heap (as min-heap with negative values) self.large = [] # Min-heap def addNum(self, num: int) -> None: if not self.large or num >= self.large[0]: heapq.heappush(self.large, num) else: heapq.heappush(self.small, -num) # Balance heaps if len(self.large) > len(self.small) + 1: heapq.heappush(self.small, -heapq.heappop(self.large)) elif len(self.small) > len(self.large): heapq.heappush(self.large, -heapq.heappop(self.small)) def findMedian(self) -> float: if len(self.large) > len(self.small): return float(self.large[0]) else: return (self.large[0] - self.small[0]) / 2.0"},{"question":"You are given a `grid` of size `m x n`, where each cell represents a plot of land that can either be `land` (denoted by `1`) or `water` (denoted by `0`). A `lake` is defined as a maximal group of connected `0`s that share a side with another `0`. Your task is to find the size of the smallest lake. If there is no lake, return `-1`. Water connected diagonally is not considered part of the same lake, and the boundary of the grid is always surrounded by land. Return _the size of the smallest lake_. ---","solution":"def smallest_lake(grid): Returns the size of the smallest lake (group of connected 0\'s), or -1 if there are no lakes. :param grid: List[List[int]] - 2D grid representing the land (1) and water (0) :return: int - size of the smallest lake, or -1 if there are no lakes def dfs(i, j, visited): Depth First Search to explore the lake size from (i, j) if (i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or grid[i][j] == 1 or visited[i][j]): return 0 visited[i][j] = True size = 1 size += dfs(i + 1, j, visited) size += dfs(i - 1, j, visited) size += dfs(i, j + 1, visited) size += dfs(i, j - 1, visited) return size m, n = len(grid), len(grid[0]) visited = [[False] * n for _ in range(m)] min_size = float(\'inf\') found_lake = False for i in range(m): for j in range(n): if grid[i][j] == 0 and not visited[i][j]: lake_size = dfs(i, j, visited) if lake_size > 0: found_lake = True min_size = min(min_size, lake_size) return min_size if found_lake else -1"},{"question":"A delivery drone needs to navigate a warehouse represented as a 2D grid with dimensions `r x c`. The drone starts at the top-left corner (0, 0) and its goal is to reach the bottom-right corner (r-1, c-1). Each cell in the grid contains an integer representing the cost of traversing that cell. The drone can move either right or down at any point in time. Given the grid of costs, return the minimum cost to reach the bottom-right corner from the top-left corner. You need to write a function that computes this minimum cost.","solution":"def min_cost_path(cost): Returns the minimum cost to reach the bottom-right corner of the grid from the top-left corner. :param cost: List[List[int]], a 2D list representing the cost grid. :return: int, minimum cost to reach (r-1, c-1) from (0, 0) if not cost or not cost[0]: return 0 r = len(cost) c = len(cost[0]) # Create a 2D list to store the minimum cost at each cell dp = [[0 for _ in range(c)] for _ in range(r)] dp[0][0] = cost[0][0] # Initialize the first row of dp array for j in range(1, c): dp[0][j] = dp[0][j-1] + cost[0][j] # Initialize the first column of dp array for i in range(1, r): dp[i][0] = dp[i-1][0] + cost[i][0] # Fill the dp array for the remaining cells for i in range(1, r): for j in range(1, c): dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + cost[i][j] return dp[r-1][c-1]"},{"question":"Given an array of integers `arr`, you are allowed to rotate the array to the right any number of times. A rotation means moving the last element of the array to the front. Your task is to return the maximum possible value of the array\'s first element after any number of rotations. Write a function that takes the array `arr` as input and returns this maximum value. You are guaranteed that the length of `arr` is at least 1.","solution":"def max_first_element(arr): Returns the maximum possible value of the array\'s first element after any number of right rotations. :param arr: List of integers :return: Maximum possible value of the array\'s first element return max(arr)"},{"question":"You are given a 2D integer array `board` representing a `m x n` grid of cells. The board contains integers where `0` represents water and `1` represents land. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are surrounded by water. Write a function to find the number of islands. An island is a maximal group of 1s connected in the four directions up, down, left, and right. Return the number of islands in the given grid.","solution":"def num_islands(board): Returns the number of islands in the given grid. if not board: return 0 def dfs(board, i, j): if i < 0 or i >= len(board) or j < 0 or j >= len(board[0]) or board[i][j] == 0: return board[i][j] = 0 # Mark the cell as visited # Explore neighbors dfs(board, i - 1, j) dfs(board, i + 1, j) dfs(board, i, j - 1) dfs(board, i, j + 1) count = 0 for i in range(len(board)): for j in range(len(board[0])): if board[i][j] == 1: count += 1 dfs(board, i, j) return count"},{"question":"You are given an array of integers `nums` where each integer appears exactly three times except for one integer, which appears exactly once. Write a function to find and return the single integer that appears only once. Example: Input: `nums = [2, 2, 3, 2]` Output: `3` Input: `nums = [0, 1, 0, 1, 0, 1, 99]` Output: `99` Note: Your algorithm should have a linear runtime complexity, and use only constant extra space.","solution":"def single_number(nums): Finds the single number that appears only once in the list where every other number appears exactly three times. ones, twos = 0, 0 for num in nums: ones = (ones ^ num) & ~twos twos = (twos ^ num) & ~ones return ones"},{"question":"You are given a **0-indexed** integer array `nums` of length `n` representing the initial configuration of a line of `n` players standing in a queue. Each player has a unique integer ID represented by `nums[i]`. You need to simulate the reorganization of the queue based on a sequence of swap operations. You are given a **0-indexed** 2D integer array `swaps` where `swaps[i] = [a, b]` indicates that the players at positions `a` and `b` should be swapped. After performing all the swaps in the given order, return the resulting queue as an integer array.","solution":"def reorganize_queue(nums, swaps): Reorganizes the queue based on a sequence of swap operations. Parameters: nums (List[int]): The initial configuration of the queue. swaps (List[List[int]]): A list of swap operations, where each operation is represented by a list of two integers [a, b] indicating the positions to be swapped. Returns: List[int]: The final configuration of the queue after performing all swaps. for swap in swaps: a, b = swap nums[a], nums[b] = nums[b], nums[a] return nums"},{"question":"You are given an array of integers `piles` where `piles[i]` is the number of stones in the `i-th` pile, and an integer `H` representing the number of hours you have to finish eating all the stones. Each hour, you can decide to eat any number of stones from a single pile. After each hour, one pile may be selected to eat from. Return _the minimum integer K such that it\'s possible to eat all the stones in the piles within `H` hours_.","solution":"def can_finish(piles, H, K): Helper function to determine if we can finish eating all piles with speed K in H hours. time = 0 for pile in piles: time += (pile + K - 1) // K # Equivalent to ceil(pile / K) return time <= H def min_eating_speed(piles, H): Returns the minimum integer K such that it is possible to eat all the stones in the piles within H hours. left, right = 1, max(piles) while left < right: mid = (left + right) // 2 if can_finish(piles, H, mid): right = mid else: left = mid + 1 return left"},{"question":"Given an array of integers `nums`, find the length of the longest subarray **without repeating elements**. Return the length of the longest subarray.","solution":"def length_of_longest_subarray(nums): Returns the length of the longest subarray without repeating elements. n = len(nums) if n == 0: return 0 longest = 0 start = 0 seen = {} for end in range(n): if nums[end] in seen and seen[nums[end]] >= start: start = seen[nums[end]] + 1 seen[nums[end]] = end longest = max(longest, end - start + 1) return longest"},{"question":"Given an array of integers `arr` and an integer `k`, rotate the array to the right by `k` steps, where `k` is non-negative. Implement a function that modifies the array in-place with O(1) extra space complexity. For example, if the array is `[1, 2, 3, 4, 5, 6, 7]` and `k` is `3`, the array should be rotated to `[5, 6, 7, 1, 2, 3, 4]`.","solution":"def rotate_array(arr, k): Rotates the array to the right by k steps. :param arr: List[int] - The array to be rotated :param k: int - The number of steps to rotate the array n = len(arr) k %= n # in case k is greater than the length of the array # Reverse the whole array arr.reverse() # Reverse the first k elements arr[:k] = arr[:k][::-1] # Reverse the remaining n - k elements arr[k:] = arr[k:][::-1]"},{"question":"Given a binary tree, write a function to check whether it is a complete binary tree. A binary tree is complete if all levels are completely filled except possibly for the last level which is filled from left to right. The function should return `true` if the tree is complete, and `false` otherwise. **Function Signature:** `def isCompleteBinaryTree(root: TreeNode) -> bool:` **Example:** ``` Input: 1 / 2 3 / / 4 5 6 Output: True Input: 1 / 2 3 / 4 5 Output: True Input: 1 / 2 3 / 4 5 6 Output: False ```","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def isCompleteBinaryTree(root: TreeNode) -> bool: if not root: return True queue = [root] end = False while queue: node = queue.pop(0) if node: if end: return False queue.append(node.left) queue.append(node.right) else: end = True return True"},{"question":"You are given a list of integers `arr` representing a list of coordinates on a number line, where `arr[i]` indicates the coordinate of the `i-th` point. Find the minimum number of moves required to make all the points in `arr` have the same coordinate. In one move, you can increment or decrement the coordinate of a point by 1. Return the minimum number of moves needed to align the coordinates.","solution":"def min_moves_to_align_coordinates(arr): Given a list of coordinates on a number line, return the minimum number of moves required to make all the points have the same coordinate. In one move, you can increment or decrement the coordinate of a point by 1. arr.sort() median = arr[len(arr) // 2] moves = sum(abs(x - median) for x in arr) return moves"},{"question":"You are given a **0-indexed** integer array `height` representing the height of buildings along a street. The buildings are of the same width and are placed next to each other. A magical water level rises, flooding parts of the buildings. The water level is represented by an integer `waterLevel`. * If a building\'s height is less than or equal to the `waterLevel`, that building is completely submerged and the height of the submerged part is recorded as the building\'s height. * If a building\'s height is greater than the `waterLevel`, only the part of the building up to the `waterLevel` is submerged and the height of the submerged part is recorded as `waterLevel`. Return the **total submerged height** of all the buildings when the water level is `waterLevel`. For example, given a height array `height = [4, 5, 7, 3]` and `waterLevel = 5`, the submerged heights are `[4, 5, 5, 3]`, and the total submerged height is `4 + 5 + 5 + 3 = 17`.","solution":"def total_submerged_height(height, waterLevel): Returns the total submerged height of all the buildings given the height array and the water level. Parameters: height (list of int): List of building heights. waterLevel (int): The level of the water. Returns: int: The total submerged height. submerged_height_total = 0 for h in height: submerged_height_total += min(h, waterLevel) return submerged_height_total"},{"question":"You are given a **0-indexed** integer array `arr` of even length `n`. The array contains exactly `n / 2` positive integers and `n / 2` negative integers. Rearrange the array in such a way that the positive and negative integers alternate, starting with any integer. If there are multiple valid rearrangements, return any of them. Implement a function `rearrangeArray(arr)` that rearranges the array as described and returns the rearranged array. If no valid rearrangement is possible, return an empty list.","solution":"def rearrangeArray(arr): # Separate positive and negative numbers pos = [num for num in arr if num > 0] neg = [num for num in arr if num < 0] # Initialize the result array res = [] # Use two pointers to alternate between positives and negatives pos_index = 0 neg_index = 0 use_pos = True # Start with positive if true, negative if false for _ in range(len(arr)): if use_pos: res.append(pos[pos_index]) pos_index += 1 else: res.append(neg[neg_index]) neg_index += 1 # Alternate the use_pos flag use_pos = not use_pos return res"},{"question":"You are given a 2D integer array `matrix` of size `m x n` and an integer `k`. Each value in the matrix represents an elevation at that point. Starting from the top-left corner (0,0), your goal is to reach the bottom-right corner (m-1, n-1), moving only right or down each time. For each step from cell `(r1, c1)` to cell `(r2, c2)`, calculate the \\"effort\\" as the absolute difference in elevations between the two cells: `|matrix[r2][c2] - matrix[r1][c1]|`. Find the minimum effort required to complete this path. Note that `m` and `n` satisfy the constraints of 1 <= m, n <= 100, and each elevation is an integer in the range 0 to 10^6. The test cases are generated so that the path always exists.","solution":"import heapq def minimumEffortPath(matrix): Returns the minimum effort required to move from the top-left to the bottom-right corner of the matrix. m, n = len(matrix), len(matrix[0]) visited = [[False] * n for _ in range(m)] efforts = [[float(\'inf\')] * n for _ in range(m)] efforts[0][0] = 0 # Min-Heap to store (effort, row, column) heap = [(0, 0, 0)] # (effort, row, column) directions = [(1, 0), (0, 1), (-1, 0), (0, -1)] while heap: effort, r, c = heapq.heappop(heap) if visited[r][c]: continue visited[r][c] = True if r == m - 1 and c == n - 1: return effort for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < m and 0 <= nc < n and not visited[nr][nc]: next_effort = max(effort, abs(matrix[nr][nc] - matrix[r][c])) if next_effort < efforts[nr][nc]: efforts[nr][nc] = next_effort heapq.heappush(heap, (next_effort, nr, nc)) return -1 # If no path is found, which won\'t happen as stated in the question"},{"question":"You are given an integer array `nums` representing the number of points allotted to various tasks. Your goal is to perform all the tasks to maximize your total points. However, performing a task at index `i` also requires deleting the task at index `i-1` and `i+1`, if they exist. You can choose to start from any task but cannot perform the same task more than once. Return the maximum points you can achieve by performing a sequence of tasks under the given constraints.","solution":"def deleteAndEarn(nums): Returns the maximum number of points that can be earned by performing tasks under the given constraints. if not nums: return 0 max_num = max(nums) points = [0] * (max_num + 1) # Calculate the total number of points for each number in nums for num in nums: points[num] += num take, skip = 0, 0 for point in points: take_new = skip + point skip_new = max(take, skip) take, skip = take_new, skip_new return max(take, skip)"},{"question":"You are given an integer array `w` where `w[i]` describes the weight of the `i-th` index (0-indexed). Write a function that randomly picks an index in proportion to its weight. Specifically, the probability of picking `i` is `w[i] / sum(w)`. You may assume the given array has at least one element and the sum of weights won\'t exceed `10^5`. Implement a function `pickIndex()` that returns the index selected based on the aforementioned probability distribution.","solution":"import random import bisect class Solution: def __init__(self, w): self.prefix_sums = [] total = 0 for weight in w: total += weight self.prefix_sums.append(total) self.total_sum = total def pickIndex(self): target = self.total_sum * random.random() # Find the index using binary search return bisect.bisect_left(self.prefix_sums, target)"},{"question":"Given two integer arrays `nums1` and `nums2` where `nums1` is sorted in **non-decreasing** order and `nums2` is sorted in **non-decreasing** order, merge these two arrays into a single array sorted in **non-decreasing** order. You should not allocate extra space for the merged array, but modify `nums1` to contain the final sorted array. Initially, `nums1` has a size of `m + n`, where the first `m` elements denote the elements that should be merged, and the last `n` elements are set to `0` and should be ignored. `nums2` has a size of `n`.","solution":"def merge(nums1, m, nums2, n): Merges two sorted arrays nums1 and nums2 in-place. The first m elements of nums1 contain the elements to be merged, and the last n elements of nums1 are set to 0 and should be ignored. nums2 contains n elements to be merged. # Indexes for the last elements in nums1 and nums2 index1, index2 = m - 1, n - 1 # Index for the last position in the merged array merge_index = m + n - 1 while index2 >= 0: if index1 >= 0 and nums1[index1] > nums2[index2]: nums1[merge_index] = nums1[index1] index1 -= 1 else: nums1[merge_index] = nums2[index2] index2 -= 1 merge_index -= 1"},{"question":"Given an array `arr` consisting of `n` integers, and an integer `k`, your task is to find the minimal length of a contiguous subarray of which the sum is greater than or equal to `k`. If there is no such subarray, return `-1`. Aim to achieve an efficient solution with a time complexity better than O(n^2).","solution":"def min_subarray_len(arr, k): Returns the minimal length of a contiguous subarray with a sum >= k. If no such subarray exists, returns -1. n = len(arr) min_len = float(\'inf\') current_sum = 0 start_index = 0 for end_index in range(n): current_sum += arr[end_index] while current_sum >= k: min_len = min(min_len, end_index - start_index + 1) current_sum -= arr[start_index] start_index += 1 return min_len if min_len != float(\'inf\') else -1"},{"question":": You are given an integer array `arr` and an integer `k`. Your task is to design an algorithm that returns the length of the longest contiguous subarray where the absolute difference between any two elements is less than or equal to `k`. Implement the `LongestContiguousSubarray` class: * `LongestContiguousSubarray(int[] arr, int k)` Initializes the object with the array `arr` and integer `k`. * `int findLength()` Calculates and returns the length of the longest contiguous subarray that fulfills the given condition.","solution":"class LongestContiguousSubarray: def __init__(self, arr, k): self.arr = arr self.k = k def findLength(self): n = len(self.arr) if n == 0: return 0 start = 0 max_length = 0 for end in range(n): for i in range(start, end): if abs(self.arr[end] - self.arr[i]) > self.k: start = i + 1 break max_length = max(max_length, end - start + 1) return max_length"},{"question":"You are given an integer array `nums` and an integer `k`. A **k-good subarray** is defined as a subarray that contains **exactly k distinct integers**. Return _the length of the shortest k-good subarray_. If no such subarray exists, return `-1`. A **subarray** is a contiguous part of an array.","solution":"def shortest_k_good_subarray(nums, k): from collections import defaultdict n = len(nums) freq = defaultdict(int) left = 0 min_length = float(\'inf\') distinct_count = 0 for right in range(n): if freq[nums[right]] == 0: distinct_count += 1 freq[nums[right]] += 1 while distinct_count >= k: if distinct_count == k: min_length = min(min_length, right - left + 1) freq[nums[left]] -= 1 if freq[nums[left]] == 0: distinct_count -= 1 left += 1 return min_length if min_length != float(\'inf\') else -1"},{"question":"Given a **positive integer** `n`, return the number of _distinct_ ways you can write `n` as the sum of **two or more** consecutive positive integers. For example, if `n = 15`, there are three ways: * `15 = 1 + 2 + 3 + 4 + 5` * `15 = 4 + 5 + 6` * `15 = 7 + 8` Note that `n` must be the sum of at least two consecutive integers.","solution":"def count_consecutive_sum_ways(n): Returns the number of distinct ways to write n as the sum of two or more consecutive positive integers. count = 0 k = 1 while k * (k + 1) < 2 * n: numerator = n - (k * (k + 1)) // 2 if numerator % (k + 1) == 0: count += 1 k += 1 return count"},{"question":"You are given a list of `prerequisites` where `prerequisites[i] = [a_i, b_i]` indicates that school `a_i` must be ranked higher than school `b_i` in the final ranking. There are `n` schools labeled from `0` to `n-1`. Return _a list representing the order of schools in the final ranking_ such that all the given prerequisites are satisfied. If there are multiple valid orderings, return any of them. If it is impossible to satisfy all the prerequisites, return an empty list.","solution":"from collections import defaultdict, deque def rank_schools(n, prerequisites): Returns the order of schools in the final ranking that satisfies all the given prerequisites. :param n: int, number of schools labeled from 0 to n-1 :param prerequisites: List[List[int]], list of [a_i, b_i] indicating school a_i should be ranked higher than school b_i :return: List[int], order of schools in the final ranking or an empty list if it is impossible to satisfy the prerequisites # Build the graph and calculate in-degrees graph = defaultdict(list) in_degree = {i: 0 for i in range(n)} for a, b in prerequisites: graph[a].append(b) in_degree[b] += 1 # Initialize the queue with nodes having in-degree of 0 queue = deque([node for node in in_degree if in_degree[node] == 0]) order = [] while queue: node = queue.popleft() order.append(node) for neighbor in graph[node]: in_degree[neighbor] -= 1 if in_degree[neighbor] == 0: queue.append(neighbor) # If the order doesn\'t contain all the schools, return an empty list if len(order) != n: return [] return order"},{"question":"Given a list of integers, find the length of the longest consecutive elements sequence. The consecutive elements sequence is a subsequence that appears in a consecutive increasing order. Your solution should have a time complexity of O(n).","solution":"def longest_consecutive(nums): Given a list of integers, return the length of the longest consecutive elements sequence. if not nums: return 0 num_set = set(nums) longest_streak = 0 for num in num_set: # Only start sequence if num is the start of a sequence if num - 1 not in num_set: current_num = num current_streak = 1 while current_num + 1 in num_set: current_num += 1 current_streak += 1 longest_streak = max(longest_streak, current_streak) return longest_streak"},{"question":"You are developing a file system management program where files and folders are organized in a hierarchical structure. Each file and folder is represented with a distinct string identifier. The root of the file system is represented by a single forward slash (`\\"/\\"`). Implement the `FileSystem` class: * `FileSystem()` Initializes the file system object. * `boolean createPath(String path, int value)` Creates a new file path with the given value, where `path` represents a fully qualified path starting from the root, and `value` is the associated data. This method should return `true` if the path was successfully created, `false` otherwise (i.e., if the parent path does not exist or the path already exists). * `int get(String path)` Returns the value associated with the given `path`. If the path does not exist, return `-1`. Example: ``` FileSystem fileSystem = new FileSystem(); fileSystem.createPath(\\"/a\\", 1); // returns true fileSystem.createPath(\\"/a/b\\", 2); // returns true fileSystem.get(\\"/a\\"); // returns 1 fileSystem.get(\\"/b\\"); // returns -1 ```","solution":"class FileSystem: def __init__(self): self.path_map = {\'/\': None} # Initialize root def createPath(self, path: str, value: int) -> bool: if path in self.path_map: return False parent_path = \'/\'.join(path.split(\'/\')[:-1]) if parent_path == \'\': parent_path = \'/\' if parent_path not in self.path_map: return False self.path_map[path] = value return True def get(self, path: str) -> int: if path in self.path_map: return self.path_map[path] return -1"},{"question":"Given an array of integers `arr`, return _the number of distinct pairs `(i, j)` such that `arr[i] + arr[j]` is even and `0 <= i < j < arr.length`._","solution":"def count_even_sum_pairs(arr): Returns the number of distinct pairs (i, j) such that arr[i] + arr[j] is even and 0 <= i < j < arr.length. Parameters: arr (list of int): A list of integers. Returns: int: The number of pairs with an even sum. odd_count = sum(1 for x in arr if x % 2 != 0) even_count = len(arr) - odd_count # Pairs of even sum can be formed by: # 1. Two odd numbers # 2. Two even numbers def combination_count(n): return n * (n - 1) // 2 pairs = combination_count(odd_count) + combination_count(even_count) return pairs"},{"question":"Given an integer `n`, find the total number of valid parentheses arrangements that can be made using `n` pairs of parentheses. A valid parentheses arrangement follows these rules: 1. Every opening parenthesis `(` has a corresponding closing parenthesis `)`. 2. An opening parenthesis must be closed in the correct order, i.e., each closing parenthesis must close the most recently opened parenthesis that has not been closed yet. Return the total number of valid combinations. [Question 4]:","solution":"def count_valid_parentheses(n): Returns the number of valid parentheses arrangements using n pairs of parentheses. This is essentially the nth Catalan number. if n == 0: return 1 catalan = [0] * (n + 1) catalan[0] = 1 for i in range(1, n + 1): catalan_i = 0 for j in range(i): catalan_i += catalan[j] * catalan[i - 1 - j] catalan[i] = catalan_i return catalan[n]"},{"question":"You are given a string `s` and a list of words `words`. All the strings in `words` are of the same length. A **concatenated substring** in `s` is a substring that contains all the strings in `words` exactly once and without any intervening characters. Find the starting indices of all concatenated substrings in `s` that are formed by combining each word in `words` exactly once and in any order. Return the starting indices of all such concatenated substrings in `s` in ascending order.","solution":"def findSubstring(s, words): Find the starting indices of all concatenated substrings in s that are formed by combining each word in words exactly once in any order. if not s or not words or not words[0]: return [] word_length = len(words[0]) num_words = len(words) total_length = word_length * num_words word_count = {} for word in words: if word in word_count: word_count[word] += 1 else: word_count[word] = 1 result = [] for i in range(word_length): left = i right = i current_count = {} while right + word_length <= len(s): word = s[right:right + word_length] right += word_length if word in word_count: if word in current_count: current_count[word] += 1 else: current_count[word] = 1 while current_count[word] > word_count[word]: left_word = s[left:left + word_length] current_count[left_word] -= 1 left += word_length if right - left == total_length: result.append(left) else: current_count.clear() left = right return sorted(result)"},{"question":"You are given a string `s` consisting of lowercase English letters, and you need to group the characters such that each group contains the same character repeated consecutively. After grouping, you need to encode the string using the format `number[character]`, where `number` is the count of characters in the current group, and `character` is the character being repeated. If any character appears only once consecutively, it is not encoded with a number. For example, if the string is `\\"aaabbbbcc\\"`, the encoded result would be `\\"3[a]4[b]2[c]\\"`. Write a function that takes the string `s` and returns its encoded version.","solution":"def encode_string(s): Encodes the string using the format number[character] for consecutive character groups. :param s: string input containing lowercase English letters :return: encoded string if not s: return \\"\\" encoded_string = \\"\\" count = 1 for i in range(1, len(s)): if s[i] == s[i - 1]: count += 1 else: if count > 1: encoded_string += f\\"{count}[{s[i - 1]}]\\" else: encoded_string += s[i - 1] count = 1 # Handle the last group if count > 1: encoded_string += f\\"{count}[{s[-1]}]\\" else: encoded_string += s[-1] return encoded_string"},{"question":"Given an `n x n` grid where each cell contains an integer value representing some weight, you need to find the minimum path sum from the top-left cell to the bottom-right cell. You can only move either down or right at any point in time. Return _the **minimum sum** of the weights along a path from the top-left to bottom-right of the grid._","solution":"def min_path_sum(grid): Function to find the minimum path sum from top-left to bottom-right of the grid. You can only move either down or right at any point in time. :param grid: List[List[int]] - 2D grid containing integer weights :return: int - minimum path sum if not grid or not grid[0]: return 0 rows, cols = len(grid), len(grid[0]) # Create a dp array to store the sum of paths dp = [[0 for _ in range(cols)] for _ in range(rows)] dp[0][0] = grid[0][0] # Initialize the first row for j in range(1, cols): dp[0][j] = dp[0][j - 1] + grid[0][j] # Initialize the first column for i in range(1, rows): dp[i][0] = dp[i - 1][0] + grid[i][0] # Calculate the path sums for the rest of the grid for i in range(1, rows): for j in range(1, cols): dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j] return dp[rows - 1][cols - 1]"},{"question":"You are given a **0-indexed** array `nums` of `n` integers and an integer `x`. Your task is to determine if there exists a subarray of `nums` such that the product of all the elements in this subarray is exactly `x`. Return **true** if such a subarray exists and **false** otherwise. A subarray is a contiguous non-empty sequence of elements within an array.","solution":"def product_subarray_exists(nums, x): Determine if there exists a subarray of nums such that the product of all elements in this subarray is exactly x. n = len(nums) for start in range(n): product = 1 for end in range(start, n): product *= nums[end] if product == x: return True return False"},{"question":"You are given an integer array `arr` of length `n`, where `arr[i]` is a unique value representing the `i-th` element. Your task is to split the array into two non-empty subarrays such that the absolute difference between the sums of the two subarrays is minimized. Return the minimum absolute difference between the sums of the two subarrays. For example, given the array `arr = [1, 2, 3, 4]`, you might split it into `[1, 2]` and `[3, 4]`, resulting in the absolute difference `|(1 + 2) - (3 + 4)| = 4 - 3 = 1`.","solution":"def min_abs_split_diff(arr): Splits the array into two non-empty subarrays such that the absolute difference between the sums of the two subarrays is minimized. Returns the minimum absolute difference. total_sum = sum(arr) n = len(arr) # To minimize the difference, we need to find a split that makes # one part sum close to half of the total sum. min_diff = float(\'inf\') current_sum = 0 for i in range(n - 1): current_sum += arr[i] remaining_sum = total_sum - current_sum diff = abs(current_sum - remaining_sum) min_diff = min(min_diff, diff) return min_diff"},{"question":"You are given an `n x n` matrix where each cell contains an integer. Some of the cells are blocked and are denoted by the value `-1`. A path from a cell `(i, j)` to a cell `(k, l)` is considered valid if you can move to an adjacent cell (vertically or horizontally) and the destination cell is not blocked. Write a function to determine the length of the shortest path between two given cells in the matrix. If no such path exists, return `-1`. The function should take the matrix and the coordinates of the two cells as input and return the length of the shortest path or `-1` if no such path exists.","solution":"from collections import deque def shortest_path(matrix, start, end): Find the shortest path between two cells in a matrix where some cells are blocked. :param matrix: List of lists representing the matrix :param start: Tuple representing the starting cell (row, col) :param end: Tuple representing the ending cell (row, col) :return: Length of the shortest path or -1 if no such path exists n = len(matrix) if matrix[start[0]][start[1]] == -1 or matrix[end[0]][end[1]] == -1: return -1 directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] queue = deque([(start[0], start[1], 0)]) visited = set() visited.add(start) while queue: r, c, dist = queue.popleft() if (r, c) == end: return dist for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < n and 0 <= nc < n and (nr, nc) not in visited and matrix[nr][nc] != -1: queue.append((nr, nc, dist + 1)) visited.add((nr, nc)) return -1"},{"question":"Given an array of integers `arr`, find and return _the length of the shortest subarray with a sum equal to_ `target`. If there is no such subarray, return `-1`. A subarray is a contiguous part of an array. **Follow up:** Can you solve the problem in _O(n)_ time complexity?","solution":"def shortest_subarray_with_target_sum(arr, target): from collections import defaultdict n = len(arr) min_length = float(\'inf\') current_sum = 0 prefix_sum = defaultdict(lambda: float(\'inf\')) prefix_sum[0] = -1 for i in range(n): current_sum += arr[i] if (current_sum - target) in prefix_sum: min_length = min(min_length, i - prefix_sum[current_sum - target]) if current_sum not in prefix_sum: prefix_sum[current_sum] = i return min_length if min_length != float(\'inf\') else -1"},{"question":"A company wants to reward its employees with bonuses based on their performance evaluations. The evaluations are stored in a list of integers where each integer represents an employee\'s performance score. The company has the following rules for distributing the bonuses: 1. Each employee must receive at least one bonus point. 2. Any employee with a higher performance score than his/her immediate neighbors must receive more bonus points than those neighbors. Given a list of integers `scores` representing the performance scores of employees, return the minimum number of bonus points the company must distribute. For example, given the list `scores = [1, 2, 2]`, return `4` since the bonuses could be `[1, 2, 1]`, which distributes a total of 4 bonus points.","solution":"def min_bonuses(scores): n = len(scores) if n == 0: return 0 if n == 1: return 1 bonuses = [1] * n # First pass: ensure each employee has more bonuses than previous if their score is higher for i in range(1, n): if scores[i] > scores[i - 1]: bonuses[i] = bonuses[i - 1] + 1 # Second pass: ensure each employee has more bonuses than next if their score is higher for i in range(n - 2, -1, -1): if scores[i] > scores[i + 1]: bonuses[i] = max(bonuses[i], bonuses[i + 1] + 1) return sum(bonuses)"},{"question":"Given a non-empty array of integers `arr`, find the length of the longest contiguous subsequence such that all elements in the subsequence are the same. Return the length of this subsequence. Note that a subsequence is derived by deleting some or no elements without changing the order of the remaining elements and it must contain contiguous elements.","solution":"def longest_contiguous_subsequence_length(arr): Returns the length of the longest contiguous subsequence such that all elements in the subsequence are the same. Parameters: arr (list): A non-empty list of integers Returns: int: The length of the longest contiguous subsequence if not arr: return 0 max_length = 1 current_length = 1 for i in range(1, len(arr)): if arr[i] == arr[i - 1]: current_length += 1 max_length = max(max_length, current_length) else: current_length = 1 return max_length"},{"question":"You are given a list of strings `products` and a string `searchWord`. Design an efficient algorithm that returns a list of lists of strings, where each sublist corresponds to the products in `products` that start with the prefix formed by progressively adding each character from `searchWord`. The products in each sublist should be sorted lexicographically and only the top 3 results should be included. If fewer than 3 products exist, include all of them. Return an empty sublist if no products exist for the given prefix.","solution":"def suggested_products(products, searchWord): Given a list of strings products and a string searchWord, return a list of lists of strings, where each sublist corresponds to the products in products that start with the prefix formed by progressively adding each character from searchWord. products.sort() result = [] prefix = \\"\\" for char in searchWord: prefix += char matching_products = [product for product in products if product.startswith(prefix)] result.append(matching_products[:3]) return result"},{"question":"Given a 2D grid of characters representing a maze, and two distinct characters \'S\' (start) and \'E\' (end), write a function to determine the **minimum** number of steps required to move from \'S\' to \'E\'. You can only move up, down, left, or right, and you cannot pass through \'#\' (walls). If there is no valid path from \'S\' to \'E\', return `-1`. The grid does not have boundaries, meaning movement off the grid is not allowed.","solution":"from collections import deque def min_steps_maze(grid): rows = len(grid) cols = len(grid[0]) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # Find starting point \'S\' and end point \'E\' for r in range(rows): for c in range(cols): if grid[r][c] == \'S\': start = (r, c) if grid[r][c] == \'E\': end = (r, c) # Set up the queue for BFS queue = deque([(start[0], start[1], 0)]) # (row, col, distance) visited = set() visited.add(start) while queue: r, c, dist = queue.popleft() if (r, c) == end: return dist for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < rows and 0 <= nc < cols and grid[nr][nc] != \'#\' and (nr, nc) not in visited: visited.add((nr, nc)) queue.append((nr, nc, dist + 1)) return -1"},{"question":"You are given two strings `s` and `t`. Each string consists of lowercase English letters only. You want to create a string `p` by interleaving the characters of `s` and `t` while maintaining their respective orders. Return the number of distinct strings `p` that can be formed this way. For example, if `s = \\"ab\\"` and `t = \\"cd\\"`, then the possible interleavings are \\"abcd\\", \\"acbd\\", \\"acdb\\", \\"cabd\\", \\"cadb\\", and \\"cdab\\". Thus, there are 6 distinct strings `p` that can be formed. Note that the resultant string `p` should include all characters of `s` and `t` in their original order from `s` and `t`.","solution":"def count_interleavings(s, t): Returns the number of distinct strings that can be created by interleaving the characters of s and t while maintaining their respective orders. # Initialize memoization table m, n = len(s), len(t) dp = [[0] * (n + 1) for _ in range(m + 1)] # Base case: There\'s one way to interleave two empty strings dp[0][0] = 1 # Fill the DP table for i in range(m + 1): for j in range(n + 1): if i > 0: dp[i][j] += dp[i - 1][j] if j > 0: dp[i][j] += dp[i][j - 1] return dp[m][n]"},{"question":"You are given an array of strings `words` where each string is composed of lowercase English letters. You are also given a string `str`. You want to determine if `str` can be formed by concatenating some (possibly repeated) strings from the array `words`. Return `true` if `str` can be formed in this way, and `false` otherwise.","solution":"def can_form_string(words, target_str): Determines if the target_str can be formed by concatenating some of the strings (possibly repeated) from the array words. :param words: List of strings. :param target_str: The target string. :return: Boolean indicating whether the target_str can be formed. str_length = len(target_str) dp = [False] * (str_length + 1) dp[0] = True for i in range(1, str_length + 1): for word in words: word_len = len(word) if i >= word_len and target_str[i - word_len:i] == word: dp[i] = dp[i] or dp[i - word_len] return dp[str_length]"},{"question":"You are given two integers `n` (length of an array) and `k` (a number of unique elements). Your task is to construct an array `arr` of length `n` such that it contains `k` different integers from `1` to `k`, and the sum of elements in `arr` is maximized. The integers in the array can repeat but should not be greater than `k`. Find the maximum possible sum of the array `arr`.","solution":"def max_sum_array(n, k): Constructs an array arr of length n such that it contains k different integers from 1 to k, and the sum of elements in arr is maximized. Parameters: n (int): Length of the array. k (int): Number of unique elements from 1 to k. Returns: list: An array arr that meets the criteria. # Fill the array with the maximum element k arr = [k] * n return arr def max_sum(n, k): Computes the maximum possible sum of an array of length n, containing k different integers from 1 to k. Parameters: n (int): Length of the array. k (int): Number of unique elements from 1 to k. Returns: int: The maximum possible sum of the array. return sum(max_sum_array(n, k))"},{"question":"You are given a string `pattern` and a string `inputStr`. The `pattern` consists of lowercase letters and question marks where each question mark can be replaced by any single lowercase letter. Determine if `inputStr` matches the `pattern` when the question marks are replaced appropriately. Return `true` if `inputStr` matches the `pattern`, otherwise return `false`. For example: - pattern: \\"a?c\\", inputStr: \\"abc\\" -> the function should return `true` as the question mark can be replaced by \'b\'. - pattern: \\"a?c\\", inputStr: \\"axc\\" -> the function should return `true` as the question mark can be replaced by \'x\'. - pattern: \\"a?c\\", inputStr: \\"abcde\\" -> the function should return `false` as the lengths of pattern and inputStr do not match.","solution":"def matches_pattern(pattern, inputStr): Returns True if the inputStr matches the pattern, False otherwise. if len(pattern) != len(inputStr): return False for p_char, i_char in zip(pattern, inputStr): if p_char != \'?\' and p_char != i_char: return False return True"},{"question":"You are given a `square` matrix called `grid` of size `n x n`, where `grid[i][j]` represents the height of a cell `(i, j)`. A path in the grid starts from `(0,0)` and ends at `(n-1, n-1)`. The path can only move in four possible directions: up, down, left, or right, and you can only move to adjacent cells if the height of the next cell is greater than or equal to the height of the current cell. Return _the minimum number of moves required to reach the cell _(n-1, n-1)_ from the cell _(0, 0)_, or `-1` if there is no viable path.","solution":"from collections import deque def min_moves(grid): n = len(grid) # Directions for moving up, down, left, and right directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # BFS initialization queue = deque([(0, 0, 0)]) # (row, column, moves) visited = set((0, 0)) while queue: x, y, moves = queue.popleft() # Check if we have reached the bottom-right corner if x == n - 1 and y == n - 1: return moves # Explore adjacent cells for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < n and (nx, ny) not in visited and grid[nx][ny] >= grid[x][y]: visited.add((nx, ny)) queue.append((nx, ny, moves + 1)) # If there\'s no viable path return -1"},{"question":"You are given a string `s` consisting of lowercase English letters. You need to divide the string into the fewest number of non-overlapping substrings such that each letter appears in at most one substring. Return the starting and ending indices of each substring. If there are multiple valid solutions, return any one of them. For example, given the string `s = \\"ababcbacadefegdehijhklij\\"`, one valid way to partition it is `[\\"ababcbaca\\", \\"defegde\\", \\"hijhklij\\"]`.","solution":"def partition_labels(s): Return the starting and ending indices of the smallest number of non-overlapping substrings such that each letter appears in at most one substring. if not s: return [] last_occurrence = {char: idx for idx, char in enumerate(s)} partitions = [] start, end = 0, 0 for idx, char in enumerate(s): end = max(end, last_occurrence[char]) if idx == end: partitions.append((start, end)) start = idx + 1 return partitions"},{"question":"[Question] 4: Given a list of integers `nums`, return `true` if there exists a triplet `(i, j, k)` such that `i < j < k` and `nums[i] < nums[j] < nums[k]`. Return `false` otherwise.","solution":"def increasing_triplet(nums): Returns True if there exists a triplet (i, j, k) such that i < j < k and nums[i] < nums[j] < nums[k]. Returns False otherwise. if len(nums) < 3: return False first = second = float(\'inf\') for num in nums: if num <= first: first = num elif num <= second: second = num else: return True return False"},{"question":"You are given a `0-indexed` integer array `heights` representing the heights of buildings in a row. You have a ball which you can drop from any building. The ball can move to the next building if its height is less than or equal to the current building\'s height. The goal is to determine the maximum number of consecutive buildings the ball can travel when dropped from any building. Return the maximum number of consecutive buildings the ball can travel, including the starting building.","solution":"def max_consecutive_buildings(heights): Returns the maximum number of consecutive buildings the ball can travel when dropped from any building. :param heights: List[int], the heights of buildings in a row. :return: int, the maximum number of consecutive buildings the ball can travel. max_count = 0 for i in range(len(heights)): current_count = 1 for j in range(i + 1, len(heights)): if heights[j] <= heights[j - 1]: current_count += 1 else: break max_count = max(max_count, current_count) return max_count"},{"question":"You are given a string `s` consisting of `[a-z, A-Z]` characters and an integer `k`. Your task is to return the lexicographically smallest string possible after removing `k` characters from the string `s`. Note: The resulting string must maintain the original order of characters. For example, given the string `s = \\"bacd\\"` and `k = 2`, the smallest possible string after removing 2 characters is `\\"ac\\"`.","solution":"def smallest_lexicographical_string(s, k): This function returns the lexicographically smallest string possible after removing `k` characters from the string `s` while maintaining the original order of characters. stack = [] remaining = k for char in s: while stack and remaining and stack[-1] > char: stack.pop() remaining -= 1 stack.append(char) # If still some characters are left to remove while remaining > 0: stack.pop() remaining -= 1 return \'\'.join(stack)"},{"question":"Given a string `s` and an array `indices` of the same length. The `indices` array is a permutation of numbers from `0` to `len(s) - 1` where `indices[i]` represents the index in the scrambled string `s` that needs to be moved to the position `i` in the resulting unshuffled string. Return the unshuffled string.","solution":"def restore_string(s, indices): Restores the original string from the scrambled string `s` using the given `indices`. result = [\'\'] * len(s) for i, idx in enumerate(indices): result[idx] = s[i] return \'\'.join(result)"},{"question":"Given a string `s`, you are allowed to convert it to a palindrome by adding characters in front of it. Return the palindrome that can be made by adding the fewest number of characters in front of `s`. If there are multiple solutions, return the lexicographically smallest one. A **palindrome** is a word that reads the same backward as forward.","solution":"def shortest_palindrome(s): Given a string s, converts it to a palindrome by adding the fewest number of characters in front of it. Returns the resulting palindrome. if s == \\"\\": return \\"\\" # Getting the suffix that is not part of the palindrome for i in range(len(s), -1, -1): if s[:i] == s[:i][::-1]: break # The characters to be added to the front to_add = s[i:][::-1] # Combining to form the palindrome return to_add + s"},{"question":"Given a list of `transactions` where each transaction is represented as a string array `[name, city, time, amount]` and each string is separated by a single space. A person could be involved in multiple transactions. A transaction is considered invalid if it meets **at least one** of the following conditions: - The amount exceeds 1000. - The transaction occurs within (and including) 60 minutes of another transaction with the same name in a different city. Return a list of all invalid transactions in a string array where each transaction is represented in its original string format. The transaction strings in the returned list should be sorted in the same order as they were provided in the input list.","solution":"def invalid_transactions(transactions): def parse_transaction(transaction): name, city, time, amount = transaction.split(\\" \\") return { \\"name\\": name, \\"city\\": city, \\"time\\": int(time), \\"amount\\": int(amount) } parsed_transactions = [parse_transaction(t) for t in transactions] invalid_transactions = [] length = len(parsed_transactions) for i in range(length): t1 = parsed_transactions[i] if t1[\\"amount\\"] > 1000: invalid_transactions.append(transactions[i]) continue for j in range(length): if i != j: t2 = parsed_transactions[j] if ( t1[\\"name\\"] == t2[\\"name\\"] and t1[\\"city\\"] != t2[\\"city\\"] and abs(t1[\\"time\\"] - t2[\\"time\\"]) <= 60 ): invalid_transactions.append(transactions[i]) break return invalid_transactions"},{"question":"You are given a list of non-negative integers `nums`. A sequence is called a **mountain** if it consists of at least three elements and there exists some `i` with `1 <= i <= len(nums) - 2` such that: - `nums[0] < nums[1] < ... < nums[i]` - `nums[i] > nums[i + 1] > ... > nums[len(nums) - 1]` Given an integer k, return the **length** of the longest **mountain** in `nums` that is of length **at most k**. If there is no such mountain, return `0`.","solution":"def longest_mountain(nums, k): Returns the length of the longest mountain in nums that is of length at most k. If there is no such mountain, returns 0. n = len(nums) if n < 3: return 0 longest = 0 for i in range(1, n - 1): if nums[i - 1] < nums[i] > nums[i + 1]: # peak of the mountain left = i - 1 while left > 0 and nums[left - 1] < nums[left]: left -= 1 right = i + 1 while right < n - 1 and nums[right] > nums[right + 1]: right += 1 mountain_length = right - left + 1 if mountain_length <= k: longest = max(longest, mountain_length) return longest"},{"question":"You have a `0-indexed` integer array `nums`. Your task is to find and return the maximum sum of any non-empty subarray of `nums`. A subarray is a contiguous part of an array. Note that a subarray of length `1` is considered valid. If the array contains only negative numbers, return the maximum single element.","solution":"def max_subarray_sum(nums): Finds the maximum sum of any non-empty subarray of nums. Parameters: nums (list): A list of integers. Returns: int: The maximum sum of any non-empty subarray. max_current = max_global = nums[0] for num in nums[1:]: max_current = max(num, max_current + num) if max_current > max_global: max_global = max_current return max_global"},{"question":"You are given a **logs** array where each element is a string representation of logs for user activities. Each log follows the format \\"user_id timestamp action\\", where user_id is a string identifying the user, timestamp is an integer representing the time of the action, and action is a string that can be either \\"login\\" or \\"logout\\". A user session is defined from \\"login\\" to \\"logout\\" for a particular user. Your task is to find out the duration of the longest session for any user. If a user has no logout after a login, that session is considered incomplete and should not be counted. Return an integer representing the duration of the longest session in the log entries.","solution":"def longest_session_duration(logs): Returns the duration of the longest session for any user. Parameters: logs (list of str): List of log strings in the format \\"user_id timestamp action\\". Returns: int: Duration of the longest session. If no valid sessions are found, return 0. sessions = {} max_duration = 0 for log in logs: user_id, timestamp, action = log.split() timestamp = int(timestamp) if user_id not in sessions: sessions[user_id] = {\'login\': None, \'logout\': None} if action == \'login\': sessions[user_id][\'login\'] = timestamp elif action == \'logout\': if sessions[user_id][\'login\'] is not None: session_duration = timestamp - sessions[user_id][\'login\'] max_duration = max(max_duration, session_duration) sessions[user_id] = {\'login\': None, \'logout\': None} # reset for future sessions return max_duration"},{"question":"You are given a matrix `grid` of size `n x n`, where each cell represents a battlefield spot that can either be `0` (empty) or `1` (occupied by an enemy unit). An enemy unit can move to any adjacent (4-directionally) empty cell in one step, but cannot move outside the grid or into another occupied cell. Your task is to determine the minimum number of steps required for all the enemy units to gather at any single point on the grid. If it\'s impossible for all units to meet, return `-1`.","solution":"from collections import deque def min_steps_to_gather(grid): if not grid: return -1 n = len(grid) enemies = [(i, j) for i in range(n) for j in range(n) if grid[i][j] == 1] if not enemies: return 0 def bfs_from(position): dist = [[-1] * n for _ in range(n)] queue = deque([position]) dist[position[0]][position[1]] = 0 while queue: x, y = queue.popleft() for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < n and grid[nx][ny] != 1 and dist[nx][ny] == -1: dist[nx][ny] = dist[x][y] + 1 queue.append((nx, ny)) return dist total_dists = [[0] * n for _ in range(n)] for enemy in enemies: dist = bfs_from(enemy) for i in range(n): for j in range(n): if grid[i][j] != 1 and dist[i][j] != -1: total_dists[i][j] += dist[i][j] elif dist[i][j] == -1: total_dists[i][j] = float(\'inf\') min_steps = min(min(row) for row in total_dists) return min_steps if min_steps != float(\'inf\') else -1"},{"question":"Given a matrix `matrix` of integers where each row is sorted in ascending order from left to right, and each column is sorted in ascending order from top to bottom, write a function `searchMatrix` that returns _whether a given target value exists in the matrix_. You must write an algorithm with `O(m + n)` time complexity, where `m` is the number of rows and `n` is the number of columns in the matrix.","solution":"def searchMatrix(matrix, target): Searches for a target value in a matrix where each row is sorted in ascending order from left to right, and each column is sorted in ascending order from top to bottom. :param matrix: List[List[int]], the matrix of integers :param target: int, the target value to search for :return: bool, True if the target exists in the matrix, otherwise False if not matrix or not matrix[0]: return False rows, cols = len(matrix), len(matrix[0]) row, col = 0, cols - 1 while row < rows and col >= 0: if matrix[row][col] == target: return True elif matrix[row][col] > target: col -= 1 else: row += 1 return False"},{"question":"Given a linked list, return the node where the cycle begins. If there is no cycle, return `null`. There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the `next` pointer. Internally, the `pos` is used to denote the index of the node that the tail\'s `next` pointer is connected to. **Note:** Do not modify the linked list.","solution":"class ListNode: def __init__(self, x): self.val = x self.next = None def detectCycle(head): Detects the node where the cycle begins in a linked list. :param head: ListNode, the head of the linked list :return: ListNode, the node where the cycle begins, or None if there is no cycle if not head or not head.next: return None slow = head fast = head # Detect whether there\'s a cycle using two pointers while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: break # If no cycle detected if not fast or not fast.next: return None # Find the entry to the cycle slow = head while slow != fast: slow = slow.next fast = fast.next return slow"},{"question":"You are given a 2D grid `board` containing `\'X\'` and `\'O\'`, where `\'X\'` represents a wall and `\'O\'` represents an open spot. A region is defined as a group of connected `\'O\'`s surrounded by `\'X\'`s. Write a function to capture all regions by flipping all `\'O\'`s within surrounded regions to `\'X\'`. The `\'O\'`s on the border (not surrounded by `\'X\'`s) should not be flipped. Return the modified board.","solution":"def capture_regions(board): if not board or not board[0]: return board rows, cols = len(board), len(board[0]) def dfs(r, c): if r < 0 or r >= rows or c < 0 or c >= cols or board[r][c] != \'O\': return board[r][c] = \'T\' dfs(r + 1, c) dfs(r - 1, c) dfs(r, c + 1) dfs(r, c - 1) # Start from the borders and mark all connected \'O\'s as \'T\' for i in range(rows): if board[i][0] == \'O\': dfs(i, 0) if board[i][cols - 1] == \'O\': dfs(i, cols - 1) for j in range(cols): if board[0][j] == \'O\': dfs(0, j) if board[rows - 1][j] == \'O\': dfs(rows - 1, j) # Flip all the \'O\'s to \'X\' and \'T\'s back to \'O\' for i in range(rows): for j in range(cols): if board[i][j] == \'O\': board[i][j] = \'X\' elif board[i][j] == \'T\': board[i][j] = \'O\' return board"},{"question":"You are given two lists of positive integers, `list1` and `list2`, each having `n` elements. An element `x` in `list1` is said to **dominate** an element `y` in `list2` if `x` is greater than `y`. Your task is to find the number of **dominations** between the elements of `list1` and `list2`, where each element in `list1` is compared with each element in `list2`. Return the total count of dominations.","solution":"def count_dominations(list1, list2): Returns the number of dominations where elements in list1 dominate elements in list2. Parameters: list1 (List[int]): The first list of positive integers. list2 (List[int]): The second list of positive integers. Returns: int: The total count of dominations. count = 0 for x in list1: for y in list2: if x > y: count += 1 return count"},{"question":"You are given a string `s` that consists of lowercase English letters and is a palindrome. You are allowed to replace **exactly one** character in the string with any other lowercase English letter. Your task is to make the string no longer a palindrome while ensuring it remains lexicographically smallest among all possible non-palindromic strings that can be created by replacing one character. Return _the resultant string after the replacement, or an empty string if it\'s impossible to make the string non-palindromic_.","solution":"def break_palindrome(s: str) -> str: This function takes a palindromic string and replaces exactly one character to make it non-palindromic while ensuring it remains lexicographically smallest. n = len(s) # If the length of s is 1, it is impossible to make it non-palindromic if n == 1: return \\"\\" # Convert the string to a list to allow mutation chars = list(s) # Try to change the first non-\'a\' character in the first half of the string to \'a\' for i in range(n // 2): if chars[i] != \'a\': chars[i] = \'a\' return \\"\\".join(chars) # If the string is entirely \'a\'s, we change the last character to \'b\' chars[-1] = \'b\' return \\"\\".join(chars)"},{"question":"Given a binary tree, return the level order traversal of its nodes\' values. (i.e., from left to right, level by level). Each node has a unique value. Here\'s an example binary tree that is serialized as `[3,9,20,null,null,15,7]`. The level order traversal of this tree is `[3, 9, 20, 15, 7]`. The provided input will be serialized as a `List` of integer values, representing the level order traversal of the binary tree with `null` values indicating the absence of a node. Your task is to implement the function `levelOrderTraversal` that reconstructs the binary tree from this serialized list and returns a list of integer values representing the level order traversal.","solution":"from typing import List, Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def build_tree_from_list(lst: List[Optional[int]]) -> Optional[TreeNode]: if not lst: return None root = TreeNode(lst[0]) queue = [root] i = 1 while queue and i < len(lst): current = queue.pop(0) if lst[i] is not None: current.left = TreeNode(lst[i]) queue.append(current.left) i += 1 if i < len(lst) and lst[i] is not None: current.right = TreeNode(lst[i]) queue.append(current.right) i += 1 return root def levelOrderTraversal(root: Optional[TreeNode]) -> List[int]: if not root: return [] result = [] queue = [root] while queue: current = queue.pop(0) result.append(current.val) if current.left: queue.append(current.left) if current.right: queue.append(current.right) return result def levelOrderTraversalFromList(lst: List[Optional[int]]) -> List[int]: root = build_tree_from_list(lst) return levelOrderTraversal(root)"},{"question":"You are given an array `heights` where `heights[i]` represents the height of the `i-th` building. A building is considered **waterproof** if there exists a sequence of contiguous buildings that includes this building, and the height of every building in this sequence is greater than or equal to the height of the building on either end of the sequence. Return _the number of waterproof buildings_ in the array.","solution":"def count_waterproof_buildings(heights): Returns the number of waterproof buildings in the list. if not heights: return 0 n = len(heights) count = 0 for i in range(n): left_max = max(heights[:i+1]) # Max height from the left including current building right_max = max(heights[i:]) # Max height from the right including current building # Check if there\'s at least one possible sequence that satisfies the condition if left_max >= heights[i] and right_max >= heights[i]: count += 1 return count"},{"question":"Write a function that takes a **non-empty** string `s` consisting only of `(` and `)` characters, and returns _the length of the longest valid (well-formed) parentheses substring_. A valid parentheses substring is a substring that is properly matched.","solution":"def longest_valid_parentheses(s: str) -> int: Given a string containing just the characters \'(\' and \')\', returns the length of the longest valid (well-formed) parentheses substring. max_len = 0 stack = [-1] for i, char in enumerate(s): if char == \'(\': stack.append(i) else: stack.pop() if not stack: stack.append(i) else: max_len = max(max_len, i - stack[-1]) return max_len"},{"question":"You are given an array of integers `nums` where each integer represents the height of a building. If it rains, the water is trapped between the buildings. Return _the total amount of trapped water_ after it rains.","solution":"def trap(height): Calculate the total amount of trapped water given the heights of the buildings. Parameters: height (List[int]): List of integers representing the height of buildings. Returns: int: The total amount of water trapped between the buildings. if not height: return 0 n = len(height) left_max = [0] * n right_max = [0] * n # Fill left_max array left_max[0] = height[0] for i in range(1, n): left_max[i] = max(left_max[i-1], height[i]) # Fill right_max array right_max[n-1] = height[n-1] for i in range(n-2, -1, -1): right_max[i] = max(right_max[i+1], height[i]) # Calculate the trapped water trapped_water = 0 for i in range(n): trapped_water += min(left_max[i], right_max[i]) - height[i] return trapped_water"},{"question":"Given an array of integers `arr` representing the heights of buildings in a row, your task is to determine the number of buildings that have an unobstructed view of the sunset. The buildings are considered to have sunset views based on the direction from which the sunset is viewed: from the left (west) towards the right (east). A building has an unobstructed view of the sunset if there are no taller buildings to its right. Return the indices of all such buildings in increasing order.","solution":"def find_buildings_with_sunset_view(arr): Returns the indices of buildings that have an unobstructed view of the sunset. n = len(arr) if n == 0: return [] max_height = arr[-1] result = [n-1] for i in range(n-2, -1, -1): if arr[i] > max_height: result.append(i) max_height = arr[i] return result[::-1]"},{"question":"You are given a rectangular grid of size `m x n` consisting of non-negative integers. You are initially positioned at the top-left corner `(0, 0)` and can move either down or right at any point in time until you reach the bottom-right corner `(m-1, n-1)`. The task is to find the minimum sum of all numbers along your path from the top-left corner to the bottom-right corner. Given the grid `matrix` and its dimensions `m` and `n`, write a function that returns the minimum path sum. _WARNINGS_: - Your function should handle edge cases where the grid might be empty. Note: You can assume that all inputs are valid integers and that `m` and `n` are between 1 and 100 inclusively.","solution":"def min_path_sum(matrix): Returns the minimum sum of all numbers along the path from the top-left corner to the bottom-right corner. :param matrix: List[List[int]] - 2D list representing the grid of non-negative integers :return: int - Minimum path sum from top-left to bottom-right corner if not matrix or not matrix[0]: return 0 m, n = len(matrix), len(matrix[0]) # Initialize the dp table with the top-left element of matrix dp = [[0] * n for _ in range(m)] dp[0][0] = matrix[0][0] # Initialize the first row for j in range(1, n): dp[0][j] = dp[0][j-1] + matrix[0][j] # Initialize the first column for i in range(1, m): dp[i][0] = dp[i-1][0] + matrix[i][0] # Populate the dp table for i in range(1, m): for j in range(1, n): dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + matrix[i][j] return dp[m-1][n-1]"},{"question":"You are given a list of `n` words and a string `s`. You need to find the longest word from the list that can be formed by deleting some characters of the string `s` without rearranging the remaining characters. If there is more than one possible result, return the longest word that appears first in lexicographical order. If no word can be formed, return an empty string. Write a function that accomplishes this. Example: ```plaintext words = [\\"apple\\", \\"kangaroo\\", \\"plea\\", \\"ple\\"] s = \\"abpcplea\\" ``` Output: \\"apple\\"","solution":"def findLongestWord(s, words): def is_subsequence(x): it = iter(s) return all(c in it for c in x) words.sort(key=lambda x: (-len(x), x)) for word in words: if is_subsequence(word): return word return \\"\\""},{"question":"Given a **directed, weighted graph** represented as an adjacency list, write a function that finds the shortest path from a given starting node to all other nodes using **Dijkstra\'s algorithm**. The graph is represented as a dictionary where the keys are node labels and the values are lists of tuples, with each tuple containing a neighboring node and the weight of the edge connecting them. Your function should return a dictionary mapping each node to the length of the shortest path from the starting node. If a node is unreachable, it should have a path length of infinity.","solution":"import heapq def dijkstra(graph, start_node): Implements Dijkstra\'s algorithm to find the shortest path from the start_node to all other nodes. :param graph: A dictionary representing the graph, where keys are nodes and values are lists of (neighbor, weight) tuples. :param start_node: The starting node for the shortest path calculation. :return: A dictionary mapping each node to the length of the shortest path from the start_node. distances = {node: float(\'inf\') for node in graph} distances[start_node] = 0 priority_queue = [(0, start_node)] while priority_queue: current_distance, current_node = heapq.heappop(priority_queue) if current_distance > distances[current_node]: continue for neighbor, weight in graph[current_node]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return distances"},{"question":"Given a list of `n` points, where each point is represented as a tuple `(x, y)` on a 2D plane, find the shortest path that visits all the points. The order of visiting the points does not matter. Implement the function `minPath(points)`, where `points` is a list of tuples. The function should return the length of the shortest path that starts at the first point, visits all the points exactly once, and returns to the starting point. Use the Euclidean distance to compute the distance between any two points.","solution":"import itertools import math def euclidean_distance(p1, p2): Calculates the Euclidean distance between two 2D points p1 and p2. return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2) def minPath(points): Calculates the length of the shortest path that visits all points starting and ending at the first point. if not points or len(points) == 1: return 0 start_point = points[0] other_points = points[1:] min_path_length = float(\'inf\') # Generate all permutations of the other points to find the shortest path for perm in itertools.permutations(other_points): path_length = euclidean_distance(start_point, perm[0]) # Calculate the path length for this permutation for i in range(len(perm) - 1): path_length += euclidean_distance(perm[i], perm[i + 1]) path_length += euclidean_distance(perm[-1], start_point) # Update the minimum path length found if path_length < min_path_length: min_path_length = path_length return min_path_length"},{"question":"Given a string `s` consisting of only two characters \'a\' and \'b\', you need to perform the following operation exactly once: select any two different indices `i` and `j` (1-based) from the string and swap the characters `s[i]` and `s[j]`. Your task is to return the lexicographically smallest string that can be obtained after performing the operation. If the input string `s` has a length less than 2, return the same string.","solution":"def smallest_lexicographical_swap(s): Returns the lexicographically smallest string that can be obtained after exactly one swap between two different indices. # If the string length is less than 2, return the same string. if len(s) < 2: return s s = list(s) # Convert string to list to perform swaps smallest_string = s[:] # Initialize the smallest string as the original list n = len(s) # Iterate over all pairs of indices for i in range(n): for j in range(i + 1, n): # Swap characters at indices i and j s[i], s[j] = s[j], s[i] # Check if we have a new smallest string if s < smallest_string: smallest_string = s[:] # Swap back the characters to restore original order s[i], s[j] = s[j], s[i] return \'\'.join(smallest_string)"},{"question":"You have a 2D grid `grid` of size `m x n` representing a map where `0` represents water and `1` represents land. An island is a maximal 4-directionally connected group of `1s`. The grid has exactly one island. The island doesn\'t have any lakes, meaning it is surrounded by water and isn\'t connected to any other land cells outside the grid. One cell width of water surrounds it on all edges. Find the smallest number of `0`s you must flip to `1`s in order to connect the island to any border of the grid (top, bottom, left, or right). Return this minimum number.","solution":"from collections import deque def min_flips_to_connect_island_to_border(grid): def bfs(queue, visited): while queue: x, y, dist = queue.popleft() if x == 0 or y == 0 or x == len(grid)-1 or y == len(grid[0])-1: return dist for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nx, ny = x + dx, y + dy if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and (nx, ny) not in visited: visited.add((nx, ny)) if grid[nx][ny] == 0: queue.append((nx, ny, dist+1)) else: # grid[nx][ny] == 1 queue.appendleft((nx, ny, dist)) return -1 # Find any land cell (1) to start BFS start = None for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == 1: start = (i, j) break if start: break # BFS to find the minimum number of flips to connect to border queue = deque([(start[0], start[1], 0)]) visited = set([start]) return bfs(queue, visited)"},{"question":"You are given an array of `n` integers, `arr`, where each element represents the cost to enter a stage in a video game. In this game, you can skip one stage at a time but not two consecutive stages. Your task is to determine the minimum possible total cost to reach the last stage of the game, starting from the first stage. You may assume that you always start at the first stage. Return the minimum total cost to reach the last stage.","solution":"def min_cost_to_reach_last_stage(arr): Return the minimum possible total cost to reach the last stage of the game. :param arr: List[int] - List of costs to enter each stage. :return: int - The minimum total cost to reach the last stage. n = len(arr) if n == 0: return 0 if n == 1: return arr[0] dp = [0] * n dp[0] = arr[0] dp[1] = arr[0] + arr[1] for i in range(2, n): dp[i] = arr[i] + min(dp[i-1], dp[i-2]) return dp[-1]"},{"question":"You are given two strings, `s` and `t`, both consisting of only lowercase letters. Your task is to determine if `s` can be transformed into `t` using the following rules an arbitrary number of times: 1. You can choose any character in `s` and change it to any other character. Return `true` if `s` can be transformed into `t` according to the above rules, otherwise return `false`. **Note:** The length of both strings `s` and `t` are guaranteed to be the same.","solution":"def can_transform(s, t): Determines if string s can be transformed into string t by changing any character in s to any other character. Since we can change any character in s to any character, we can transform s to t as long as their lengths are the same, which is specified in the problem statement. return len(s) == len(t)"},{"question":"A robot is located at the top-left corner of an `m x n` grid (`grid[0][0]`). The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (`grid[m-1][n-1]`). The robot\'s movement is dictated by a 2D integer array `moveCost` of dimensions `m x n`, where `moveCost[i][j]` represents the cost to move to cell `grid[i][j]`. Implement a function to determine the minimum cost to reach the bottom-right corner of the grid from the top-left corner. Return the minimum cost. --- **Note:** - You must visit each cell exactly once before reaching the destination. - You can assume that moving out of the boundary of the grid is not allowed.","solution":"def minPathCost(grid): Returns the minimum cost path from the top-left to the bottom-right of the grid. m, n = len(grid), len(grid[0]) dp = [[0] * n for _ in range(m)] # Initialize the dp array with the moveCost of the initial positions dp[0][0] = grid[0][0] # Fill the first row (since we can only move right) for j in range(1, n): dp[0][j] = dp[0][j - 1] + grid[0][j] # Fill the first column (since we can only move down) for i in range(1, m): dp[i][0] = dp[i - 1][0] + grid[i][0] # Fill the remaining cells for i in range(1, m): for j in range(1, n): dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j] return dp[m - 1][n - 1]"},{"question":"You are given a list of non-negative integers `nums` representing the number of candies of different colors in a box. Your task is to evenly distribute all the candies into the largest possible number of candy bags, with each bag containing the same number and mixture of candies. Return _the largest possible number of bags_ you can make, provided that each type of candy appears in the same quantity in each bag.","solution":"from math import gcd from functools import reduce def largest_possible_bags(nums): Returns the largest possible number of bags with the same number and mixture of candies. :param nums: List of non-negative integers representing the number of candies of different colors. :return: The largest number of bags. def find_gcd_of_list(lst): return reduce(gcd, lst) # Find gcd of all numbers in the list gcd_of_nums = find_gcd_of_list(nums) return gcd_of_nums"},{"question":"You are developing a multiplayer online game where players can form alliances to collaborate and compete against other alliances. Each player has a unique player ID represented by an integer, and alliances are represented as sets of player IDs. You are tasked with implementing the functionality to manage these alliances and to determine the strongest alliance based on given criteria. The criteria for determining the strength of an alliance include: 1. The **size** of the alliance, measured by the number of players in the alliance. 2. The **combined power** of the players in the alliance, where each player has a specific power level given by an integer. The `AllianceManager` class should allow you to add players to alliances, merge two alliances, remove a player from an alliance, and query the strongest alliance based on the above criteria. The class should be implemented with the following methods: - `AllianceManager()`: Initializes the object of the AllianceManager. - `void addPlayer(int playerId, int power)`: Adds a new player with `playerId` and `power` to the AllianceManager. Each player starts in their own individual alliance. - `void formAlliance(int playerId1, int playerId2)`: Merges the alliances containing `playerId1` and `playerId2`. If both players are already in the same alliance, no action is taken. - `void removePlayer(int playerId)`: Removes the player with `playerId` from their current alliance. If the player is not in any alliance, no action is taken. - `List<Integer> strongestAlliance()`: Returns the list of player IDs in the strongest alliance. If there are multiple alliances with the same strength, any one of them can be returned. **Note** that the combined power of an alliance is the sum of the power levels of its players, and the strongest alliance is the one with the highest combined power. If multiple alliances have the same combined power, the larger alliance (in terms of size) is considered stronger. If there are still ties, any of the strongest alliances can be chosen. Implement the `AllianceManager` class as described.","solution":"class AllianceManager: def __init__(self): # Initialize the internal state self.players = {} # {playerId: power} self.alliances = {} # {playerId: set of playerId} self.alliance_power = {} # {frozenset of playerId: combined power} def addPlayer(self, playerId, power): # Add player with their power level, each player starts as their own alliance if playerId not in self.players: self.players[playerId] = power self.alliances[playerId] = {playerId} self.alliance_power[frozenset({playerId})] = power def formAlliance(self, playerId1, playerId2): # Merge the alliances of playerId1 and playerId2 if playerId1 in self.players and playerId2 in self.players: alliance1 = self.alliances[playerId1] alliance2 = self.alliances[playerId2] if alliance1 != alliance2: new_alliance = alliance1.union(alliance2) combined_power = sum(self.players[p] for p in new_alliance) for player in new_alliance: self.alliances[player] = new_alliance # Clean up old alliance power entries self.alliance_power.pop(frozenset(alliance1), None) self.alliance_power.pop(frozenset(alliance2), None) self.alliance_power[frozenset(new_alliance)] = combined_power def removePlayer(self, playerId): # Remove the player from their current alliance if playerId in self.players: alliance = self.alliances[playerId] alliance.remove(playerId) old_power = self.alliance_power.pop(frozenset(alliance.union({playerId})), 0) old_power -= self.players[playerId] # Update the alliance and power if the player was not the only member if alliance: self.alliance_power[frozenset(alliance)] = old_power for player in alliance: self.alliances[player] = alliance else: for player in alliance: del self.alliances[player] del self.alliances[playerId] del self.players[playerId] def strongestAlliance(self): # Determine the strongest alliance based on combined power and size if not self.alliance_power: return [] strongest = max(self.alliance_power.items(), key=lambda x: (x[1], len(x[0]))) return list(strongest[0]) if strongest else []"},{"question":"You are given a string `s` which consists of lowercase English letters. You need to form a new string by performing the following algorithm on `s`: - Initialize an empty string `result`. - While `s` is not empty, do the following: - Find the lexicographically smallest character in `s`. - Remove every occurrence of this character from `s`. - Append the smallest character found to `result`. Return the string `result` after applying the algorithm.","solution":"def lexicographically_smallest_string(s): Returns a string formed by removing each lexicographically smallest character from `s` and appending it to the result until `s` is empty. result = [] # Convert s to list for easy removal of characters s = list(s) while s: # Find the lexicographically smallest character smallest_char = min(s) # Remove all occurrences of this smallest character s = [char for char in s if char != smallest_char] # Append the smallest character to the result result.append(smallest_char) return \'\'.join(result)"},{"question":"You are given a list of strings `str_list`. Each string represents a single word in the dictionary and they are all lowercase. Two words are considered adjacent if they differ by exactly one character. For example, \\"bat\\" and \\"cat\\" are adjacent but \\"bat\\" and \\"batman\\" are not. You are also given a starting word `start_word` and an ending word `end_word`. Determine the minimum number of transformations required to change `start_word` to `end_word`, by transforming one letter at a time to another word in `str_list`. Return the number of transformations, or -1 if it is not possible.","solution":"from collections import deque def transform_word_list(str_list, start_word, end_word): Determines the minimum number of transformations required to change start_word to end_word def is_adjacent(word1, word2): Helper function to check if two words are adjacent count = 0 for c1, c2 in zip(word1, word2): if c1 != c2: count += 1 if count > 1: return False return count == 1 word_set = set(str_list) if end_word not in word_set: return -1 queue = deque([(start_word, 0)]) visited = set([start_word]) while queue: current_word, transformation_steps = queue.popleft() for word in list(word_set): if is_adjacent(current_word, word) and word not in visited: if word == end_word: return transformation_steps + 1 visited.add(word) queue.append((word, transformation_steps + 1)) return -1"},{"question":"You are given a 2D grid of size `m x n` representing a farm, where each cell in the grid is either a `0` (an empty plot) or a `1` (a plot with a plant). You need to create an irrigation system by digging ditches that only connect adjacent plots sharing a side, forming groups of connected plots. Each group of connected plots must receive water from a separate irrigation ditch. Return the minimum number of irrigation ditches needed to ensure all plants receive water.","solution":"def num_of_irrigation_ditches(grid): Returns the minimum number of irrigation ditches needed for all plants. Parameters: grid (List[List[int]]): 2D list representing the farm. Returns: int: minimum number of irrigation ditches if not grid: return 0 def dfs(x, y): directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] stack = [(x, y)] while stack: cx, cy = stack.pop() for dx, dy in directions: nx, ny = cx + dx, cy + dy if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and grid[nx][ny] == 1: grid[nx][ny] = -1 stack.append((nx, ny)) ditches = 0 for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == 1: ditches += 1 grid[i][j] = -1 dfs(i, j) return ditches"},{"question":"You are given a string `s` consisting of lowercase English letters. Return _the **length of the longest subsequence** such that the subsequence is **palindromic** and can be found in both_ `s` _and its **reverse**._ In other words, the subsequence should appear in `s` as well as in the reversed string of `s`.","solution":"def longest_palindromic_subsequence(s): Returns the length of the longest palindromic subsequence. def lcs(X, Y): m = len(X) n = len(Y) L = [[0] * (n + 1) for i in range(m + 1)] for i in range(m + 1): for j in range(n + 1): if i == 0 or j == 0: L[i][j] = 0 elif X[i - 1] == Y[j - 1]: L[i][j] = L[i - 1][j - 1] + 1 else: L[i][j] = max(L[i - 1][j], L[i][j - 1]) return L[m][n] rev_s = s[::-1] return lcs(s, rev_s)"},{"question":"You are given a binary tree with `n` nodes where each node is numbered from `0` to `n-1` and has a `value`. The `value` of the nodes are unique and can be any integer, positive or negative. Write a function to determine the longest path in the tree where the values along the path form a strictly increasing sequence. The path does not necessarily have to pass through the root. Return _the **length** of the longest strictly increasing path_.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def longest_increasing_path(root): def dfs(node, prev_val, length): if not node: return length if node.val > prev_val: length += 1 else: length = 1 left_length = dfs(node.left, node.val, length) right_length = dfs(node.right, node.val, length) return max(length, left_length, right_length) if root is None: return 0 return dfs(root, float(\'-inf\'), 0)"},{"question":"You are given an integer array `nums`, and an integer `target`. Your task is to find out whether it is possible to choose a subset of `nums` such that the bitwise AND of that subset is exactly equal to `target`. Return `true` if such a subset exists, otherwise return `false`. A subset can contain any number of elements from the original array, including zero elements. If the subset is empty, the bitwise AND is considered to be equal to `-1`. Note that the bitwise AND of an array of numbers is the result of performing the AND operation on all the elements of the array.","solution":"def is_subset_and_equal_to_target(nums, target): Determines if there exists a subset whose bitwise AND is equal to the target. :param nums: List[int] - list of integers :param target: int - target value for bitwise AND :return: bool - True if such a subset exists, otherwise False # If target is -1, return True because an empty subset is considered to have a AND of -1 if target == -1: return True # Iterate through all subsets n = len(nums) for i in range(1 << n): subset_and = -1 for j in range(n): if i & (1 << j): if subset_and == -1: subset_and = nums[j] else: subset_and &= nums[j] if subset_and == target: return True return False"},{"question":"A group of friends is planning a hiking trip. To keep track of their individual distances, they have an array `distances` where `distances[i]` represents the distance covered by the `ith` friend in kilometers. A friend is willing to share their progress only if the total distance covered by them so far is greater than or equal to a specified threshold `T`. Considering the hikes happen sequentially (one after another), return the number of friends who will share their progress by the end of the trip.","solution":"def friends_willing_to_share(distances, T): Returns the number of friends who will share their progress by the end of the trip. Args: distances (list of int): List where distances[i] is the distance covered by ith friend. T (int): Threshold distance which a friend must at least cover to share their progress. Returns: int: Number of friends who will share their progress. count = 0 for distance in distances: if distance >= T: count += 1 return count"},{"question":"You are given a string `s` consisting only of letters \'a\' and \'b\'. You can delete any number of characters in the string \'s\' to make it a \\"good\\" string. A string is considered \\"good\\" if there are no two consecutive \'a\'s and no two consecutive \'b\'s. Return the minimum number of deletions required to make the string \\"good\\".","solution":"def min_deletions_to_make_good(s): Returns the minimum number of deletions required to make the string \'s\' good. A string is considered \\"good\\" if there are no two consecutive \'a\'s and no two consecutive \'b\'s. deletions = 0 for i in range(1, len(s)): if s[i] == s[i - 1]: deletions += 1 return deletions"},{"question":"You are given a list of integers `nums` and an integer `k`. A pair `(i, j)` is considered harmonious if `nums[i] + nums[j] == k` and `i < j`. Return _the number of harmonious pairs in_ `nums`. Example: - Input: `nums = [1, 2, 3, 4, 5]`, `k = 5` - Output: `2` Explanation: - The harmonious pairs are (0, 3) and (1, 2).","solution":"def count_harmonious_pairs(nums, k): Returns the number of harmonious pairs where nums[i] + nums[j] == k and i < j. count = 0 seen = {} for index, num in enumerate(nums): complement = k - num if complement in seen: count += seen[complement] if num in seen: seen[num] += 1 else: seen[num] = 1 return count"},{"question":"You are given a string `s` where each character in the string represents a student with each character being a \'+\' or a \'-\'. A \'+\' represents a student who scored above average on a test and a \'-\' represents a student who scored below average. Rearrange the string `s` such that all \'+\' characters come before all \'-\' characters. Return _the rearranged string_.","solution":"def rearrange_students(s): Rearranges the input string such that all \'+\' characters come before all \'-\' characters. Parameters: s (str): The input string containing \'+\' and \'-\' characters. Returns: str: The rearranged string with all \'+\' characters before all \'-\' characters. plus_count = s.count(\'+\') minus_count = s.count(\'-\') return \'+\' * plus_count + \'-\' * minus_count"},{"question":"You are given an array of integers `arr` where every element appears three times except for one. Return that single element that appears only once. Implement a function that achieves this in linear runtime complexity and without using extra memory (constant space).","solution":"def single_number(arr): Returns the single number that appears only once in the array where every other number appears three times. This solution assumes constant space and linear time complexity. ones, twos = 0, 0 for num in arr: # `ones & num` gives the bits that are there in both `ones` and the new number # we add these bits to `twos` using bitwise OR twos |= ones & num # XOR the new number with `ones`. The `Num` bits that are in `ones` will be zeroed out and vice versa # The bits that appear first time get stored in `ones`. ones ^= num # `common_bit_mask` contains all the common bit positions which have appeared three times common_bit_mask = ~(ones & twos) # Remove the common bits from `ones` and `twos` ones &= common_bit_mask twos &= common_bit_mask return ones"},{"question":"You are given an `m x n` grid `maze` consisting of walls (\'#\') and empty spaces (\'.\'). A ball is placed at the starting point `start` and you need to find if there is a path for the ball to reach the destination point `destination`. The ball can travel up, down, left, or right, but it can only stop when it hits a wall. You need to return `true` if there is such a path from `start` to `destination` in the maze, otherwise return `false`. The function signature is as follows: ```python def hasPath(maze: List[List[str]], start: List[int], destination: List[int]) -> bool: ``` The maze is represented by a 2D list with \'m\' rows and \'n\' columns, where \'#\' represents a wall and \'.\' represents an empty space. The start and destination points are given as two-element lists, each containing the row and column indices respectively. The ball stops moving when it encounters a wall or the edge of the grid.","solution":"from typing import List from collections import deque def hasPath(maze: List[List[str]], start: List[int], destination: List[int]) -> bool: def is_valid(x, y): return 0 <= x < len(maze) and 0 <= y < len(maze[0]) and maze[x][y] == \'.\' def bfs(start): queue = deque([start]) visited = set() visited.add((start[0], start[1])) while queue: x, y = queue.popleft() if [x, y] == destination: return True for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: new_x, new_y = x, y while is_valid(new_x + dx, new_y + dy): new_x += dx new_y += dy if (new_x, new_y) not in visited: visited.add((new_x, new_y)) queue.append((new_x, new_y)) return False return bfs(start)"},{"question":"[Question]: Given an array of non-negative integers `arr`, you are asked to maximize the number of the elements with at least one repetition in the array. You can perform the following operations any number of times: * Pick any two elements `arr[i]` and `arr[j]` (with `i != j`) and swap them. Return _the maximum number of elements with at least one repetition_ in the array after performing the above operations any number of times.","solution":"def max_elements_with_repetitions(arr): Returns the maximum number of elements with at least one repetition in the array. from collections import Counter # Count the frequency of each element count = Counter(arr) # Calculate the number of elements with at least one repetition elements_with_repetition = sum(1 for v in count.values() if v > 1) return elements_with_repetition"},{"question":"Given a specified time period in months, starting from January, you need to help a logistics company track their inventory changes. You are given an array of integers `inventoryChanges` where each element represents the net change in inventory for a corresponding month. The array has a length of 12, with `inventoryChanges[i]` representing the inventory change for month `i+1`. Additionally, you are provided an integer `currentInventory` which represents the company\'s inventory at the start of January. Your task is to calculate the inventory at the end of the year and return this final inventory value.","solution":"def calculate_final_inventory(inventoryChanges, currentInventory): Calculate the final inventory after applying the monthly changes. :param inventoryChanges: List of 12 integers representing inventory changes for each month. :param currentInventory: Integer representing the inventory at the start of January. :return: Integer representing the final inventory at the end of the year. for change in inventoryChanges: currentInventory += change return currentInventory"},{"question":"You are given a string containing only lowercase characters. You need to transform this string such that each character is replaced by the next immediate character in the alphabet, with \'z\' wrapping around to \'a\'. Return the transformed string. For example, given the string \\"abcdz\\", the output should be \\"bcdea\\".","solution":"def transform_string(s): Transforms a string such that each character is replaced by the next immediate character in the alphabet, with \'z\' wrapping around to \'a\'. Parameters: s (str): The input string containing only lowercase characters. Returns: str: The transformed string. result = [] for char in s: if char == \'z\': result.append(\'a\') else: result.append(chr(ord(char) + 1)) return \'\'.join(result)"},{"question":"You are given a linked list where each node contains an integer value. Implement a function to: 1. Reverse the linked list. 2. Split the reversed list into two halves. 3. Merge the two halves by alternating the nodes from each half. Return the merged linked list after processing. _Implement the `LinkedListProcessor` class:_ * `LinkedListProcessor(Node head)` Initializes the linked list with the provided head node. * `Node reverseList()` Reverses the linked list and returns the new head. * `Pair<Node, Node> splitList(Node head)` Splits the given list into two halves and returns a pair of nodes representing the heads of the two lists. If the list has an odd number of elements, the extra element should go in the first half. * `Node mergeLists(Node list1, Node list2)` Merges two lists by alternating nodes from each list and returns the head of the merged list.","solution":"class Node: def __init__(self, value=0, next=None): self.value = value self.next = next class LinkedListProcessor: def __init__(self, head): self.head = head def reverseList(self): prev = None current = self.head while current: next_node = current.next current.next = prev prev = current current = next_node self.head = prev return self.head def splitList(self, head): if not head: return None, None slow = head fast = head while fast and fast.next: prev_slow = slow slow = slow.next fast = fast.next.next middle = slow prev_slow.next = None return head, middle def mergeLists(self, list1, list2): if not list1: return list2 if not list2: return list1 head = list1 list1 = list1.next current = head toggle = True while list1 and list2: if toggle: current.next = list2 list2 = list2.next else: current.next = list1 list1 = list1.next toggle = not toggle current = current.next if list1: current.next = list1 if list2: current.next = list2 return head def process(self): # Step 1: Reverse the linked list reversed_head = self.reverseList() # Step 2: Split the reversed list into two halves first_half, second_half = self.splitList(reversed_head) # Step 3: Merge the two halves by alternating the nodes from each half merged_head = self.mergeLists(first_half, second_half) return merged_head"},{"question":"You are given a `linked list` where each node contains an integer `value`. Additionally, each node has a `next` pointer pointing to the next node in the list, or `null` if it is the last node. Your task is to write a function that rotates the linked list to the right by `k` places. For example, if the linked list is `1 -> 2 -> 3 -> 4 -> 5` and `k` is 2, the result should be `4 -> 5 -> 1 -> 2 -> 3`, as the list has been rotated right by 2 places. Note that `k` could be larger than the length of the list, so you need to account for such cases by rotating only the necessary number of times.","solution":"class ListNode: def __init__(self, value=0, next=None): self.value = value self.next = next def rotate_right(head, k): if not head or not head.next or k == 0: return head # First, determine the length of the list current = head length = 1 while current.next: current = current.next length += 1 # Make the list circular current.next = head # Find the new head position k = k % length steps_to_new_head = length - k new_tail = head for _ in range(steps_to_new_head - 1): new_tail = new_tail.next new_head = new_tail.next new_tail.next = None return new_head"},{"question":"Given an array `arr` of integers and an integer `k`, rearrange the array such that the element at the `kth` position in the array is in its final sorted position. You must do this in-place with O(n) average time complexity. Return the modified array where the element at index `k` is at its correct position and all other elements are in relative order around it.","solution":"def partition(arr, low, high): pivot = arr[high] i = low - 1 for j in range(low, high): if arr[j] <= pivot: i += 1 arr[i], arr[j] = arr[j], arr[i] arr[i + 1], arr[high] = arr[high], arr[i + 1] return i + 1 def quick_select(arr, low, high, k): if low < high: pivot_index = partition(arr, low, high) if pivot_index == k: return arr elif pivot_index > k: return quick_select(arr, low, pivot_index - 1, k) else: return quick_select(arr, pivot_index + 1, high, k) return arr def rearrange_around_k(arr, k): Rearranges the array such that the element at the kth position is in its final sorted position. return quick_select(arr, 0, len(arr) - 1, k)"},{"question":"Given the `root` of a binary tree, invert the tree, and return its root. Inverting a binary tree means swapping the left and right children of every node in the tree. Here is an example of an inverted binary tree: Input: ``` 4 / 2 7 / / 1 3 6 9 ``` Output: ``` 4 / 7 2 / / 9 6 3 1 ```","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def invert_tree(root): if root is None: return None # Swap the left and right children root.left, root.right = root.right, root.left # Recursively invert the children invert_tree(root.left) invert_tree(root.right) return root"},{"question":"Given an array of integers `heights` representing the height of buildings along a street. Each building is of width 1 unit. The city skyline is viewed from the left. Design a function to compute the skyline silhouette as seen from the left side. The silhouette should be represented as an array of integers where each value corresponds to the visible height of the respective buildings as seen from the left. For example: Given `heights = [3, 0, 4, 5, 2, 1]`, the result should be `[3, 4, 5, 5, 5, 5]` indicating the visible heights of the buildings from left to right.","solution":"def skyline_silhouette(heights): Computes the skyline silhouette as seen from the left side. Args: heights (list of int): Heights of the buildings Returns: list of int: Visible heights of the buildings from the left if not heights: return [] visible_heights = [] max_height = 0 for height in heights: max_height = max(max_height, height) visible_heights.append(max_height) return visible_heights"},{"question":"You are given a 2D `grid` of size `m x n` consisting of only `\'1\'`s (land) and `\'0\'`s (water). An island is a group of `\'1\'`s (land) connected **4-directionally** (horizontal or vertical). You may assume all four edges of the grid are surrounded by water. Write an algorithm to count the number of distinct islands in the given grid.","solution":"def numIslands(grid): This function returns the number of distinct islands in the given grid. An island is defined as a group of connected \'1\'s. if not grid: return 0 rows, cols = len(grid), len(grid[0]) def dfs(r, c): if r < 0 or c < 0 or r >= rows or c >= cols or grid[r][c] != \'1\': return grid[r][c] = \'0\' # Mark cell as visited by changing it to \'0\' # Visit all adjacent cells (4-directionally) dfs(r-1, c) dfs(r+1, c) dfs(r, c-1) dfs(r, c+1) island_count = 0 for r in range(rows): for c in range(cols): if grid[r][c] == \'1\': dfs(r, c) island_count += 1 return island_count"},{"question":"A company\'s website has a feature that records user activity on the site. Each user generates a series of events, where each event has a unique ID. Each event belongs to one of several categories, and the site logs the time each event occurs, measured in minutes elapsed since the start of the observation. Given a list of `events` where each element is a tuple of `(event_id, category, time)`, and an integer `interval`, return an array of tuples representing the maximum number of events that can occur within any `interval` minutes for each category. Each tuple in the output should be in the form `(category, max_count)` where `max_count` is the maximum number of events in that category that occurred within any continuous `interval` minutes. For example, given the input `events = [(1, \'A\', 10), (2, \'A\', 15), (3, \'B\', 30), (4, \'A\', 25), (5, \'B\', 35)]` and `interval = 10`, the output should be `[(\'A\', 2), (\'B\', 2)]`. This means that the maximum number of category \'A\' events within any 10-minute period is 2, and the same goes for category \'B\'.","solution":"from collections import defaultdict from bisect import bisect_right def max_events_in_interval(events, interval): Returns the maximum number of events within any interval minutes for each category. Parameters: events (list of tuple): A list where each element is a tuple (event_id, category, time) interval (int): The interval in minutes Returns: list of tuple: A list of tuples (category, max_count) for each category events_by_category = defaultdict(list) # Group events by category and sort by time for event_id, category, time in events: events_by_category[category].append(time) result = [] for category, times in events_by_category.items(): times.sort() max_count = 0 for i in range(len(times)): # Find the position where a time exceeds the current time + interval j = bisect_right(times, times[i] + interval) max_count = max(max_count, j - i) result.append((category, max_count)) return result"},{"question":"You are given an integer array `arr` consisting of `n` elements. Your task is to implement a class `OperationArray` that can efficiently perform the following operations: - `OperationArray(int[] arr)`: Initializes the object with the given integer array `arr`. - `void update(int index, int value)`: Updates the element at index `index` to `value`. - `int query(int left, int right)`: Returns the sum of the elements in the array within the inclusive range `[left, right]`. _Ensure that the class can handle multiple update and query operations efficiently._","solution":"class OperationArray: def __init__(self, arr): Initializes the object with the given integer array arr. self.n = len(arr) self.arr = arr[:] self.BIT = [0] * (self.n + 1) for i in range(self.n): self._update_BIT(i + 1, arr[i]) def _update_BIT(self, index, value): Updates the BIT with the provided value at the given index. while index <= self.n: self.BIT[index] += value index += index & -index def _prefix_sum(self, index): Returns the prefix sum from the start to the given index using BIT. result = 0 while index > 0: result += self.BIT[index] index -= index & -index return result def update(self, index, value): Updates the element at index to value. delta = value - self.arr[index] self.arr[index] = value self._update_BIT(index + 1, delta) def query(self, left, right): Returns the sum of the elements in the array within the inclusive range [left, right]. return self._prefix_sum(right + 1) - self._prefix_sum(left)"},{"question":"You are developing a ride-sharing app that involves the assignment and management of drivers to passengers. There are `n` available drivers, each with a unique ID from `0` to `n-1`. Each driver is given as a 1D integer array `drivers` where `drivers[i]` represents the distance of the `i-th` driver from the current passenger location. Implement a system that helps in the allocation of drivers to passengers based on proximity. The system should support the following functions: * `Assign`: Assigns the nearest available driver to a passenger. If there are multiple drivers at the same distance, the one with the smaller ID should be assigned. If no drivers are available, return `-1`. * `Free`: Releases the driver with the given ID back to the pool of available drivers. * `Evaluate`: Evaluates the average distance of all currently assigned drivers from their respective passenger locations. Implement the `RideSharingSystem` class: * `RideSharingSystem(int[] drivers)` Initializes the RideSharingSystem object with the distances of `n` drivers. * `int assign()` Returns the ID of the nearest available driver to be assigned to a passenger as described above, or `-1` if no drivers are available. * `void free(int driverId)` Releases the driver with ID `driverId` back to the pool of available drivers. * `double evaluate()` Returns the average distance of all currently assigned drivers from their passenger locations as a double. If there are no assigned drivers, return `0.0`. (Note: The test cases will ensure that `free` will only be called with a valid driver ID that has been previously assigned, and `evaluate` will only be called if there is at least one assigned driver.)","solution":"class RideSharingSystem: def __init__(self, drivers): self.drivers = drivers self.available_drivers = set(range(len(drivers))) self.assigned_drivers = {} def assign(self): if not self.available_drivers: return -1 nearest_driver_id = min(self.available_drivers, key=lambda x: (self.drivers[x], x)) self.available_drivers.remove(nearest_driver_id) self.assigned_drivers[nearest_driver_id] = self.drivers[nearest_driver_id] return nearest_driver_id def free(self, driverId): if driverId in self.assigned_drivers: del self.assigned_drivers[driverId] self.available_drivers.add(driverId) def evaluate(self): if not self.assigned_drivers: return 0.0 total_distance = sum(self.assigned_drivers.values()) return total_distance / len(self.assigned_drivers)"},{"question":"You are given a string `s` consisting only of characters \'a\', \'b\', and \'c\'. You want to remove all \'b\'s in the string in the minimum number of steps. Each step involves choosing a consecutive substring of `s` and removing all occurrences of \'b\' within that substring. Return the minimum number of steps required to make the string `s` contain no \'b\'s.","solution":"def min_steps_to_remove_b(s): Returns the minimum number of steps required to remove all \'b\'s from the string s. Args: s (str): The input string containing characters \'a\', \'b\', and \'c\'. Returns: int: The minimum number of steps needed to remove all \'b\'s. count_b = s.count(\'b\') return count_b"},{"question":"Given a string `s`, write a function to find the length of the longest substring without repeating characters. The function should return an integer representing the maximum length of such a substring. **Example:** Input: `s = \\"abcabcbb\\"` Output: `3` Explanation: The answer is `\\"abc\\"`, with the length of `3`. **Definition of the function:** Parameters: `String s` Returns: `int` The function should effectively use techniques such as sliding window and hashing to optimize the solution. Consider edge cases such as an empty string or a string with only one character.","solution":"def length_of_longest_substring(s): Returns the length of the longest substring without repeating characters. char_index_map = {} longest = 0 start = 0 for index, char in enumerate(s): if char in char_index_map and char_index_map[char] >= start: start = char_index_map[char] + 1 char_index_map[char] = index longest = max(longest, index - start + 1) return longest"},{"question":"You are given a binary tree in which each node contains an integer value. Implement a method to perform a level-order traversal (breadth-first traversal) of this tree and return the values of the nodes in the order they were visited. The TreeNode class is defined as follows: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` Your goal is to implement the following function: ```python def levelOrderTraversal(root: TreeNode) -> List[int]: # Your code here ``` **Example:** ```python # Example of a binary tree # 1 # / # 2 3 # / # 4 5 6 tree = TreeNode(1) tree.left = TreeNode(2) tree.right = TreeNode(3) tree.left.left = TreeNode(4) tree.left.right = TreeNode(5) tree.right.right = TreeNode(6) print(levelOrderTraversal(tree)) # Output: [1, 2, 3, 4, 5, 6] ``` **Note:** - The function should handle the case when the tree is empty (i.e., root is None) and return an empty list in that scenario.","solution":"from typing import List, Optional from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def levelOrderTraversal(root: Optional[TreeNode]) -> List[int]: if not root: return [] result = [] queue = deque([root]) while queue: node = queue.popleft() result.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) return result"},{"question":"You are given an array `points` where `points[i]` is a pair of integers representing the x- and y-coordinates of a point on a 2D plane. You need to determine the minimum number of arrows that must be shot to burst all balloons represented by the points. An arrow can be shot in a straight vertical line from x-coordinate `x` and will burst all balloons whose x-coordinates are within the range `[x_start, x_end]`. Return _the minimum number of arrows needed to burst all the balloons._","solution":"def findMinArrowShots(points): Finds the minimum number of arrows needed to burst all balloons. Parameters: points: List[List[int]] - a list of points representing the x-coordinates of the balloons. Returns: int - the minimum number of arrows needed to burst all the balloons. if not points: return 0 # Sort points by their end coordinates points.sort(key=lambda x: x[1]) arrows = 1 first_end = points[0][1] for x_start, x_end in points: if x_start > first_end: arrows += 1 first_end = x_end return arrows"},{"question":"You are given a list of non-negative integers `nums` and an integer `k`. You are required to distribute all integers in `nums` into `k` subsets in such a way that the maximum sum of integers in any subset is minimized. Return the minimized maximum sum of integers among all `k` subsets.","solution":"def can_partition(nums, k, max_sum): # Helper function to determine if it\'s possible to divide nums into k or fewer subsets # where the sum of each subset is less than or equal to `max_sum` current_sum, count = 0, 1 for num in nums: if current_sum + num > max_sum: count += 1 current_sum = num if count > k: return False else: current_sum += num return True def distribute(nums, k): Distribute the integers in nums into k subsets such that the maximum sum of integers in any subset is minimized. Return the minimized maximum sum. # Binary search range low, high = max(nums), sum(nums) while low < high: mid = (low + high) // 2 if can_partition(nums, k, mid): high = mid else: low = mid + 1 return low"},{"question":"Given a string `s` and an integer `k`, return the maximal number of vowel characters that appear consecutively in any substring of length `k` in `s`. For the purpose of this question, the vowels are defined as `\'a\', \'e\', \'i\', \'o\', \'u\'`.","solution":"def max_vowels(s, k): Returns the maximal number of vowel characters that appear consecutively in any substring of length `k` in `s`. :param s: The input string. :param k: Length of the substring. :returns: Maximal number of vowel characters in any substring of length `k`. vowels = set(\'aeiou\') max_vowel_count = 0 current_vowel_count = sum(1 for char in s[:k] if char in vowels) max_vowel_count = current_vowel_count for i in range(k, len(s)): if s[i - k] in vowels: current_vowel_count -= 1 if s[i] in vowels: current_vowel_count += 1 max_vowel_count = max(max_vowel_count, current_vowel_count) return max_vowel_count"},{"question":"Given a list of strings `words`, and a single string `subsequence`, return the count of strings within `words` that contain `subsequence` as a subsequence. A string `s` is said to contain `subsequence` as a subsequence if by deleting some (or none) of the characters of `s`, one can obtain `subsequence` without reordering the remaining characters. For example, given `words = [\\"abc\\", \\"aebdc\\", \\"ac\\", \\"akd\\"]` and `subsequence = \\"abc\\"`, the following strings in `words` contain `subsequence`: - \\"abc\\" (no deletions needed) - \\"aebdc\\" (delete \'e\' and \'d\' to get \\"abc\\" as a subsequence) Thus, the function should return 2.","solution":"def count_subsequence_occurrences(words, subsequence): def is_subsequence(s, subseq): subseq_index = 0 for char in s: if subseq_index < len(subseq) and char == subseq[subseq_index]: subseq_index += 1 if subseq_index == len(subseq): return True return subseq_index == len(subseq) count = 0 for word in words: if is_subsequence(word, subsequence): count += 1 return count"},{"question":"You are given a list of words `words` where each word only contains lowercase English letters. You need to determine the smallest rectangle that can be formed using the words in `words` such that each word is a row in the rectangle and the rectangle has all unique columns. The rectangle must use all words exactly once. Return the area of the smallest rectangle, or -1 if such a rectangle does not exist. Each word can only be used exactly once, and the order of the words does not matter.","solution":"def smallest_rectangle_area(words): Returns the area of the smallest rectangle that can be formed using the words such that each word is a row in the rectangle and all columns are unique. If such a rectangle does not exist, return -1. from itertools import permutations def has_unique_columns(words_rect): cols = [\'\'.join(row[i] for row in words_rect) for i in range(len(words_rect[0]))] return len(cols) == len(set(cols)) min_area = float(\'inf\') word_length = len(words[0]) for perm in permutations(words): if has_unique_columns(perm): min_area = min(min_area, len(words) * word_length) break return min_area if min_area != float(\'inf\') else -1"},{"question":"You are given a string `s` containing only lowercase alphabetical characters and an integer `k`. A substring is called a **k-repeated substring** if it contains at least `k` different characters and all these characters appear the same number of times in the substring. Return _the length of the **longest k-repeated substring**_ in `s`. If no such substring exists, return 0.","solution":"def is_k_repeated_substring(substr, k): Check if the given substring contains at least k different characters and all characters appear the same number of times. from collections import Counter counter = Counter(substr) if len(counter) < k: return False occurrences = list(counter.values()) return len(set(occurrences)) == 1 def longest_k_repeated_substring(s, k): Returns the length of the longest k-repeated substring in s. If no such substring exists, return 0. n = len(s) max_length = 0 for length in range(1, n+1): for start in range(n-length+1): substr = s[start:start+length] if is_k_repeated_substring(substr, k): max_length = max(max_length, length) return max_length"},{"question":"Given a string `s`, find the length of the longest substring without repeating characters. If the input string is empty, the length of the longest substring is `0`. Return the length as an integer.","solution":"def length_of_longest_substring(s): Returns the length of the longest substring without repeating characters. Parameters: s (str): The input string. Returns: int: The length of the longest substring without repeating characters. char_index = {} longest_length = 0 start = 0 for end in range(len(s)): if s[end] in char_index: start = max(start, char_index[s[end]] + 1) char_index[s[end]] = end longest_length = max(longest_length, end - start + 1) return longest_length"},{"question":"You are given an array of `n` integers `arr`. You can perform the following operation as many times as you want: choose any `i` such that `1 <= i < n` and `arr[i]` is less than both `arr[i-1]` and `arr[i+1]`, then remove `arr[i]`. Return _the maximum length of the array you can achieve where no such `i` exists_.","solution":"def max_length_no_valley(arr): Calculate the maximum length of the array where no element is smaller than both its previous and next elements. if len(arr) < 3: return len(arr) to_remove = set() for i in range(1, len(arr)-1): if arr[i] < arr[i-1] and arr[i] < arr[i+1]: to_remove.add(i) # Removing indices in to_remove set new_arr = [arr[i] for i in range(len(arr)) if i not in to_remove] return len(new_arr)"},{"question":"You are given a matrix `grid` of size `m x n` consisting of only `0`s and `1`s. A group of connected `1`s forms an island. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are surrounded by water. Determine the maximum number of islands you can remove if you are allowed to remove any single island entirely. Return the number of remaining islands after such a removal. If there are no islands, return `0`.","solution":"def maxRemainingIslands(grid): def dfs(grid, i, j): if i < 0 or j < 0 or i >= len(grid) or j >= len(grid[0]) or grid[i][j] != 1: return grid[i][j] = -1 # Mark the cell as visited dfs(grid, i+1, j) dfs(grid, i-1, j) dfs(grid, i, j+1) dfs(grid, i, j-1) def countIslands(grid): island_count = 0 for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == 1: island_count += 1 dfs(grid, i, j) return island_count initial_island_count = countIslands([row[:] for row in grid]) # Count initial number of islands if initial_island_count == 0: return 0 # No islands to remove max_remaining_islands = 0 for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == 1: temp_grid = [row[:] for row in grid] dfs(temp_grid, i, j) # Remove the island by marking all its cells remaining_islands = countIslands(temp_grid) max_remaining_islands = max(max_remaining_islands, remaining_islands) return max_remaining_islands"},{"question":"You are given an array of integers `arr` and an integer `target`. You need to determine if there exist three integers in `arr` such that the sum is equal to `target`. Return `true` if such a combination is found, otherwise return `false`. Note that each element in the array may only be used once in the combination.","solution":"def three_sum(arr, target): Determines if there exist three integers in `arr` such that their sum is `target`. :param arr: List of integers :param target: Integer target sum :return: Boolean indicating if there is a combination of three integers that sum to `target` arr.sort() n = len(arr) for i in range(n - 2): if i > 0 and arr[i] == arr[i - 1]: continue left, right = i + 1, n - 1 while left < right: total = arr[i] + arr[left] + arr[right] if total == target: return True elif total < target: left += 1 else: right -= 1 return False"},{"question":"Given an array of integers `nums` representing the number of balloons in each room, you need to deflate balloons in such a way that no two adjacent rooms have non-zero balloons at the same time. You can choose any room to start deflating the balloons. For each room, you can either leave the balloons as they are or deflate all the balloons in that room. Return the **maximum** total number of balloons you can leave inflated after deflating some rooms under the given condition.","solution":"def maxBalloons(nums): n = len(nums) if n == 0: return 0 elif n == 1: return nums[0] dp = [0] * n dp[0] = nums[0] dp[1] = max(nums[0], nums[1]) for i in range(2, n): dp[i] = max(dp[i-1], dp[i-2] + nums[i]) return dp[-1]"},{"question":"Given a string `s` consisting of lowercase English letters, you need to find the first non-repeating character in the string and return its index. If it does not exist, return -1. Implement the function `int firstUniqChar(string s)` which receives the string `s` and returns the index of the first non-repeating character. For example: 1. Input: `s = \\"leetcode\\"` Output: `0` 2. Input: `s = \\"loveleetcode\\"` Output: `2` 3. Input: `s = \\"aabb\\"` Output: `-1`","solution":"def firstUniqChar(s): Returns the index of the first non-repeating character in string s. If no such character exists, returns -1. from collections import Counter # Count the frequency of each character in the string count = Counter(s) # Iterate through the string to find the first non-repeating character for index, char in enumerate(s): if count[char] == 1: return index return -1"},{"question":"You are given a string `s` containing only lowercase English letters and a list of queries. Each query is represented by a pair of integers `(l, r)` where `0 <= l <= r < len(s)`. For each query, you need to check if the substring `s[l:r+1]` is a palindrome. Return a list of boolean values corresponding to each query, where `True` means the substring is a palindrome and `False` means it is not. A string is a palindrome when it reads the same forward and backward. For example, \\"madam\\" and \\"racecar\\" are palindromes, while \\"hello\\" is not. Implement a function that takes the string `s` and the list of queries as input, and returns the list of boolean values indicating whether each queried substring is a palindrome.","solution":"def is_palindrome(s, l, r): Checks if the substring s[l:r+1] is a palindrome. substring = s[l:r+1] return substring == substring[::-1] def check_palindromes(s, queries): Given a string s and a list of queries (l, r) pairs, returns a list of boolean values indicating whether the substring s[l:r+1] is a palindrome. results = [] for l, r in queries: results.append(is_palindrome(s, l, r)) return results"},{"question":"You are given a string `s` and an integer `k`. You need to transform the string into a new string by reversing every `k` characters. If there are fewer than `k` characters left, reverse all of them. If there are less than `2k` but greater than or equal to `k` characters, then reverse the first `k` characters and leave the others as original. Write a function that returns the modified string after performing the described operations.","solution":"def reverse_k_characters(s, k): Reverses every k characters in the string s. If there are fewer than k characters left, reverse all of them. If there are less than 2k but greater than or equal to k characters, reverse the first k characters and leave the others as original. chars = list(s) for i in range(0, len(s), 2 * k): chars[i:i+k] = reversed(chars[i:i+k]) return \'\'.join(chars)"},{"question":"Given an array of integers `nums` and an integer `x`, we want to minimize the sum of all x-length subsequences in `nums`. You can choose any `x` number of consecutive elements from the array to form a subsequence. Return _the minimum sum_ of any such subsequence.","solution":"def min_x_length_subsequence_sum(nums, x): Returns the minimum sum of any x-length subsequence in the nums array. A subsequence consists of x consecutive elements in the array. if not nums or x <= 0 or x > len(nums): return 0 # Initialize the minimum sum with a large value min_sum = float(\'inf\') # Slide a window of size x across the array current_sum = sum(nums[:x]) min_sum = min(min_sum, current_sum) for i in range(x, len(nums)): current_sum += nums[i] - nums[i - x] min_sum = min(min_sum, current_sum) return min_sum"},{"question":"A company has a group of employees, and each employee has a unique integer ID. The management wants to implement a system to track employee collaboration through projects. Given a list of unique project codes, each associated with a list of employee IDs who worked on that project, determine the maximum number of employees who have participated in at least one project together, directly or indirectly. Two employees are considered to have participated together if they have collaborated on the same project, or if there is a sequence of projects and employees such that they can be indirectly linked through common collaborations. Return the size of the largest such group of connected employees.","solution":"def largest_group(employees_projects): from collections import defaultdict # Create a dictionary to map employee to projects employee_projects = defaultdict(set) for project, employees in employees_projects.items(): for employee in employees: employee_projects[employee].add(project) # Create a graph where nodes are employees and edges exist if they share a project graph = defaultdict(list) for project, employees in employees_projects.items(): for i in range(len(employees)): for j in range(i + 1, len(employees)): graph[employees[i]].append(employees[j]) graph[employees[j]].append(employees[i]) # To find the largest connected component, we perform DFS/BFS on the graph def dfs(employee, visited): stack = [employee] size = 0 while stack: emp = stack.pop() if emp not in visited: visited.add(emp) size += 1 for neighbor in graph[emp]: if neighbor not in visited: stack.append(neighbor) return size visited = set() max_group_size = 0 for employee in employee_projects.keys(): if employee not in visited: max_group_size = max(max_group_size, dfs(employee, visited)) return max_group_size"},{"question":"Given a string `s`, return the longest palindromic substring in `s`. Implement the `Solution` class: - `Solution(String s)` Initializes the object with the string `s`. - `String longestPalindrome()` Returns the longest palindromic substring in the given string.","solution":"class Solution: def __init__(self, s): self.s = s def longestPalindrome(self): s = self.s n = len(s) if n == 0: return \\"\\" longest_palindrome = \\"\\" def expand_around_center(left, right): while left >= 0 and right < n and s[left] == s[right]: left -= 1 right += 1 return s[left + 1:right] for i in range(n): odd_palindrome = expand_around_center(i, i) even_palindrome = expand_around_center(i, i + 1) current_longest = max(odd_palindrome, even_palindrome, longest_palindrome, key=len) if len(current_longest) > len(longest_palindrome): longest_palindrome = current_longest return longest_palindrome"},{"question":"You are given two strings `s1` and `s2`, both of which represent sequence of characters. Your goal is to transform `s1` into `s2` using the minimum number of operations as defined below: * Insert a character from `s2` into `s1` * Delete a character from `s1` * Replace a character in `s1` with a character from `s2` Write a program to compute the minimum number of operations required to convert `s1` into `s2`. Return this minimum count as an integer. # Example: ```python Input: s1 = \\"intention\\", s2 = \\"execution\\" Output: 5 Explanation: Intention can be transformed into execution in 5 operations as follows: 1. intention -> exention (insert \'e\', replace \'i\' with \'e\') 2. exention -> exection (replace \'n\' with \'c\') 3. exection -> executon (insert \'u\', replace \'t\' with \'u\') 4. executon -> executon (no operations needed) 5. executon -> execution (insert \'i\', replace \'l\' with \'c\') ```","solution":"def min_operations(s1, s2): Returns the minimum number of operations required to transform s1 into s2. m, n = len(s1), len(s2) dp = [[0] * (n + 1) for _ in range(m + 1)] for i in range(m + 1): for j in range(n + 1): if i == 0: dp[i][j] = j # If s1 is empty, insert all characters of s2 elif j == 0: dp[i][j] = i # If s2 is empty, delete all characters of s1 elif s1[i - 1] == s2[j - 1]: dp[i][j] = dp[i - 1][j - 1] # Characters match, no operation needed else: dp[i][j] = 1 + min(dp[i][j - 1], # Insert dp[i - 1][j], # Delete dp[i - 1][j - 1]) # Replace return dp[m][n]"},{"question":"You are given a `2D` integer array `grid` representing a binary maze of dimension `m x n`. The start cell is located at the top-left corner `(0, 0)` and the goal is to reach the bottom-right corner `(m - 1, n - 1)`. Each cell in the grid can either be `0` (free path) or `1` (an obstacle). You can only move up, down, left, or right, and cannot move diagonally. Determine if there is a path from the start cell to the goal cell. Return `true` if such a path exists, otherwise return `false`. Note that you cannot move outside the boundary of the grid.","solution":"def is_path_exists(grid): Determines if there is a path from the top-left corner to the bottom-right corner in a binary maze. :param grid: List[List[int]] - A 2D list representing the binary maze :return: bool - True if a path exists, False otherwise if not grid or not grid[0]: return False from collections import deque m, n = len(grid), len(grid[0]) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] if grid[0][0] == 1 or grid[m-1][n-1] == 1: return False queue = deque([(0, 0)]) grid[0][0] = 1 # Mark as visited while queue: x, y = queue.popleft() if x == m - 1 and y == n - 1: return True for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] == 0: queue.append((nx, ny)) grid[nx][ny] = 1 # Mark as visited return False"},{"question":"A company uses keycards to access its buildings. The security system logs every time a keycard is used to enter and exit the building. The logs contain the `timestamp` of each entry and exit event, the `employee_id` of the person using the keycard, and whether the event was an `enter` or `exit` action. Given a list of logs, each represented as a tuple `(timestamp, employee_id, action)`, write a function that returns the total time each employee spent inside the building for the given set of logs. The `timestamp` is a non-negative integer that represents the time in seconds from the start of the day, `employee_id` is a unique identifier for each employee, and `action` is either \'enter\' or \'exit\'. **Example:** ```python logs = [ (1, \'A\', \'enter\'), (2, \'A\', \'exit\'), (4, \'B\', \'enter\'), (5, \'B\', \'exit\'), (7, \'C\', \'enter\'), (8, \'C\', \'exit\') ] Output: { \'A\': 1, \'B\': 1, \'C\': 1 } ``` Assume that the logs for each employee are well-formed, i.e., there are no consecutive \'enter\' or \'exit\' actions for the same employee, and each employee starts their day with an \'enter\' action.","solution":"def calculate_total_time_in_building(logs): Calculates the total time each employee spent inside the building. Args: logs (list): List of tuples containing the (timestamp, employee_id, action). Returns: dict: Dictionary with employee_id as the key and total time spent in the building as the value. total_time = {} entry_time = {} for timestamp, employee_id, action in logs: if action == \'enter\': entry_time[employee_id] = timestamp elif action == \'exit\': if employee_id in entry_time: time_spent = timestamp - entry_time[employee_id] if employee_id in total_time: total_time[employee_id] += time_spent else: total_time[employee_id] = time_spent del entry_time[employee_id] return total_time"},{"question":"You are given a rectangular grid with dimensions `m x n`, where some cells contain obstacles represented by `1` and other cells are empty represented by `0`. You start at the top-left corner of the grid and need to reach the bottom-right corner (both starting and ending cells are guaranteed to be empty). Your task is to count the total number of unique paths from the top-left to the bottom-right corner while avoiding obstacles. Write a function, `uniquePathsWithObstacles`, that takes a 2D list (`grid`) representing the grid and returns the number of unique paths. **Notes:** - You can only move either down or to the right at any point in time. - The grid dimensions are `m` x `n` where `1 <= m, n <= 100`. - If there is no valid path to the bottom-right corner, return `0`.","solution":"def uniquePathsWithObstacles(grid): Returns the number of unique paths from top-left to bottom-right corner of the grid, avoiding obstacles represented by 1. if not grid or grid[0][0] == 1: return 0 m, n = len(grid), len(grid[0]) dp = [[0] * n for _ in range(m)] # Start point dp[0][0] = 1 # Fill the dp table for i in range(m): for j in range(n): if grid[i][j] == 1: dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[-1][-1]"},{"question":"You are given a string `s` consisting of lowercase alphabets and an integer `p`. Your task is to determine the length of the smallest substring of `s` such that the number of distinct characters in the substring is greater than or equal to `p`. If no such substring exists, return `-1`.","solution":"def smallest_substring_with_distinct_chars(s, p): Returns the length of the smallest substring such that the number of distinct characters in the substring is greater than or equal to p. If no such substring exists, returns -1. from collections import defaultdict if p == 0: return 0 n = len(s) if p > n: return -1 left, right = 0, 0 char_count = defaultdict(int) distinct_count = 0 min_length = float(\'inf\') while right < n: char_count[s[right]] += 1 if char_count[s[right]] == 1: distinct_count += 1 while distinct_count >= p: min_length = min(min_length, right - left + 1) char_count[s[left]] -= 1 if char_count[s[left]] == 0: distinct_count -= 1 left += 1 right += 1 return min_length if min_length != float(\'inf\') else -1"},{"question":"You are given a list of non-negative integers `arr` representing the height of blocks at specific indices. Each block has a width of `1`. The blocks together form a histogram. Calculate how much water it is able to trap after raining. The histogram is essentially an array where each value indicates the height of the block at that position. The water that can be trapped is the difference between the height of the block at a specific position and the height of the tallest blocks to the left and to the right of that position. * For example, given the list `arr = [0,1,0,2,1,0,1,3,2,1,2,1]`, the amount of water that can be trapped is `6`. Implement the following function: ``` def trap(arr: List[int]) -> int: # your code goes here ```","solution":"def trap(arr): Calculate the amount of water that can be trapped after raining. Args: arr (List[int]): A list of non-negative integers representing the height of blocks. Returns: int: The total amount of water trapped. if not arr: return 0 n = len(arr) left_max = [0] * n right_max = [0] * n # Fill left_max array left_max[0] = arr[0] for i in range(1, n): left_max[i] = max(left_max[i-1], arr[i]) # Fill right_max array right_max[n-1] = arr[n-1] for i in range(n-2, -1, -1): right_max[i] = max(right_max[i+1], arr[i]) # Calculate the trapped water trapped_water = 0 for i in range(n): trapped_water += min(left_max[i], right_max[i]) - arr[i] return trapped_water"},{"question":"You are given a string `s` consisting of lowercase English letters and an integer array `distance` of length 26. Each `distance[i]` represents the distance between the first occurrence and the next occurrence of the ith letter in the alphabet (0-indexed). For example, `distance[0]` represents the distance for \'a\', `distance[1]` represents the distance for \'b\', and so on. The task is to determine if the distance values are correctly mapped. Write a function `bool checkDistances(string s, vector<int>& distance)` that returns `true` if for every letter in `s`, the difference in indices between the first occurrence and the second occurrence exactly matches the value in `distance`, otherwise return `false`. You may assume that each letter only appears twice in the string `s`.","solution":"def checkDistances(s, distance): first_occurrence = [-1] * 26 for i, char in enumerate(s): idx = ord(char) - ord(\'a\') if first_occurrence[idx] == -1: first_occurrence[idx] = i else: if i - first_occurrence[idx] - 1 != distance[idx]: return False return True"},{"question":"You are given a string `s` and an integer `k`. The string `s` contains only lowercase English letters. You need to manipulate the string by removing exactly `k` characters such that the remaining characters are contiguous and lexicographically smallest possible. Return the lexicographically smallest string you can obtain after removing `k` characters from `s`. Note that the length of `s` will be greater than `k`.","solution":"def lexicographically_smallest_substring(s, k): Returns the lexicographically smallest substring after removing exactly k characters from s. stack = [] remaining = len(s) - k for char in s: while stack and stack[-1] > char and len(stack) + len(s) - s.index(char) > remaining: stack.pop() if len(stack) < remaining: stack.append(char) s = s[1:] return \'\'.join(stack)"},{"question":"You are given an integer array `arr` consisting of positive integers. In one operation, you can select any two adjacent elements and replace both with their sum. Return the _**minimum number of operations** required to make every element in_ `arr` _equal_.","solution":"def min_operations(arr): Returns the minimum number of operations required to make every element in arr equal. # If array length is 1, it\'s already equal if len(arr) == 1: return 0 n = len(arr) operations = 0 while len(arr) > 1: # Find the two smallest adjacent elements min_val = float(\'inf\') min_index = -1 for i in range(len(arr) - 1): if arr[i] + arr[i + 1] < min_val: min_val = arr[i] + arr[i + 1] min_index = i # Replace the smallest two adjacent elements with their sum arr[min_index] = arr[min_index] + arr[min_index + 1] del arr[min_index + 1] operations += 1 return operations"},{"question":"You are given an integer array `arr` of size `n`. You need to break the array into exactly `k` non-empty subarrays such that the maximum sum of any subarray is minimized. Return _the minimized maximum sum of the subarrays_. A subarray is a contiguous part of the array. For example, if `arr = [10, 20, 30, 40]` and `k = 2`, you might break the array into `[10, 20, 30]` and `[40]`, where the sum of the first subarray is `60` and the sum of the second subarray is `40`. The minimized maximum sum of the subarrays in this case would be `40`, as you can also split the array into `[10, 20]` and `[30, 40]`, resulting in sums `30` and `70`.","solution":"def split_array_minimized_max_sum(arr, k): def can_split(max_sum): current_sum, splits = 0, 1 for num in arr: if current_sum + num > max_sum: splits += 1 current_sum = num if splits > k: return False else: current_sum += num return True left, right = max(arr), sum(arr) while left < right: mid = (left + right) // 2 if can_split(mid): right = mid else: left = mid + 1 return left"},{"question":"Given an array of integers `arr`, create a function that finds the number of contiguous subarrays that have a sum equal to a given integer `k`. The function takes two inputs: the array `arr` and the integer `k`, and returns an integer representing the count of such subarrays. Ensure that your solution has a time complexity better than O(n^2).","solution":"def subarray_sum(arr, k): Returns the number of contiguous subarrays that have a sum equal to k. Parameters: arr (list): List of integers k (int): The target sum Returns: int: The count of subarrays that sum to k count = 0 current_sum = 0 sum_dict = {0: 1} # To handle the case when subarray starts from index 0 for num in arr: current_sum += num if current_sum - k in sum_dict: count += sum_dict[current_sum - k] if current_sum in sum_dict: sum_dict[current_sum] += 1 else: sum_dict[current_sum] = 1 return count"},{"question":"Given a string `s` representing a sentence, return the same sentence with the words reversed. A word is defined as a sequence of non-space characters. The words in `s` will be separated by at least one space. Each word in the sentence should also retain its original order of characters. For example, given the string `\\"hello world\\"`, the output should be `\\"world hello\\"`.","solution":"def reverse_words(s): Reverses the words in the input sentence while retaining their original order. Parameters: s (str): A sentence where words are separated by spaces. Returns: str: The sentence with the words\' order reversed. # Split the sentence into words words = s.split() # Reverse the list of words reversed_words = words[::-1] # Join the reversed list into a new sentence reversed_sentence = \' \'.join(reversed_words) return reversed_sentence"},{"question":"You are given a list of `n` integers representing the heights of buildings in a city. The goal is to determine the maximum area of a rectangle that can be formed by any two buildings, such that the width of the rectangle is the number of buildings between the two chosen buildings (inclusive) and the height of the rectangle is the minimum height of the two chosen buildings. Implement a function that returns the maximum area possible.","solution":"def max_rectangle_area(buildings): Calculates the maximum area of a rectangle that can be formed by any two buildings. Args: buildings (List[int]): List of building heights. Returns: int: The maximum area. max_area = 0 n = len(buildings) for i in range(n): for j in range(i+1, n): height = min(buildings[i], buildings[j]) width = j - i + 1 area = height * width max_area = max(max_area, area) return max_area"},{"question":"You are given a binary tree with `n` nodes, where each node has a unique integer value from `1` to `n`. The root node has a value `0`. You need to return the largest subtree sum, where the subtree sum is defined as the sum of all node values in that subtree. Write a function that returns an integer which is the largest subtree sum in the given binary tree.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def largest_subtree_sum(root): Returns the largest subtree sum in the given binary tree. Parameters: root (TreeNode): The root node of the binary tree. Returns: int: The largest subtree sum. def subtree_sum(node): if node is None: return 0 left_sum = subtree_sum(node.left) right_sum = subtree_sum(node.right) current_sum = node.val + left_sum + right_sum # Track the maximum subtree sum encountered so far nonlocal max_sum if current_sum > max_sum: max_sum = current_sum return current_sum max_sum = float(\'-inf\') subtree_sum(root) return max_sum # Example usage: # root = TreeNode(1) # root.left = TreeNode(2) # root.right = TreeNode(3) # subtree_sum = largest_subtree_sum(root) # print(subtree_sum) # Expected output is 6 (subtree with root node 1)"},{"question":"You are given two strings, `word1` and `word2`, and your task is to merge them into one string in a **zigzag** manner, i.e., taking characters alternately from each string. If one of the strings is exhausted before the other, append the remaining characters of the longer string. Return the merged string. Ensure that the merging maintains the relative order of letters from both strings.","solution":"def merge_zigzag(word1, word2): Merges two strings in a zigzag manner. Args: word1 (str): The first string. word2 (str): The second string. Returns: str: The merged string. merged = [] len1, len2 = len(word1), len(word2) i = 0 # Merge in zigzag until one string is exhausted while i < len1 and i < len2: merged.append(word1[i]) merged.append(word2[i]) i += 1 # If word1 is longer, append the remaining characters if i < len1: merged.append(word1[i:]) # If word2 is longer, append the remaining characters if i < len2: merged.append(word2[i:]) return \'\'.join(merged)"},{"question":"You are given a list of `n` integers `heights` representing the height of buildings in a cityscape, and an integer `k` representing the maximum number of jumps you can make between buildings of decreasing height. Write a function that determines if you can start from the first building and reach the last building by making at most `k` jumps. A jump from building `i` to building `j` is valid if `heights[j] < heights[i]` and `j > i`. Return `True` if it is possible to reach the last building, otherwise return `False`.","solution":"def can_reach_last_building(heights, k): Determines if it\'s possible to reach the last building from the first building by making at most `k` jumps between buildings of decreasing height. Arguments: heights -- a list of integers representing the height of buildings k -- an integer representing the maximum number of jumps Returns: True if it\'s possible to reach the last building, otherwise False n = len(heights) if n == 1: # No jumping needed if there\'s only one building return True jumps = 0 current_position = 0 while jumps < k and current_position < n - 1: next_position = current_position for j in range(current_position + 1, n): if heights[j] < heights[current_position]: next_position = j break if next_position == current_position: return False jumps += 1 current_position = next_position return current_position == n - 1"},{"question":"A circular queue is a linear data structure that follows the FIFO (First-In-First-Out) principle and connects the last position back to the first position to make a circle. It efficiently utilizes space by reusing vacated spots. Implement the `MyCircularQueue` class: - `MyCircularQueue(int k)` Initializes the circular queue with a maximum size `k`. - `boolean enQueue(int value)` Inserts an element into the circular queue. Return `true` if the operation is successful, `false` otherwise. - `boolean deQueue()` Deletes an element from the circular queue. Return `true` if the operation is successful, `false` otherwise. - `int Front()` Gets the front item from the queue. Return `-1` if the queue is empty. - `int Rear()` Gets the last item from the queue. Return `-1` if the queue is empty. - `boolean isEmpty()` Checks whether the circular queue is empty or not. - `boolean isFull()` Checks whether the circular queue is full or not. Your implementation should ensure that all operations are performed in constant time complexity, O(1).","solution":"class MyCircularQueue: def __init__(self, k: int): Initialize the circular queue with a maximum size of k. self.queue = [0] * k self.max_size = k self.head = -1 self.tail = -1 self.size = 0 def enQueue(self, value: int) -> bool: Insert an element into the circular queue. Return true if the operation is successful, false otherwise. if self.isFull(): return False if self.isEmpty(): self.head = 0 # when queue is empty, set head to 0 self.tail = (self.tail + 1) % self.max_size self.queue[self.tail] = value self.size += 1 return True def deQueue(self) -> bool: Deletes an element from the circular queue. Return true if the operation is successful, false otherwise. if self.isEmpty(): return False if self.head == self.tail: # if there is only one element left self.head = -1 self.tail = -1 else: self.head = (self.head + 1) % self.max_size self.size -= 1 return True def Front(self) -> int: Gets the front item from the queue. Return -1 if the queue is empty. if self.isEmpty(): return -1 return self.queue[self.head] def Rear(self) -> int: Gets the last item from the queue. Return -1 if the queue is empty. if self.isEmpty(): return -1 return self.queue[self.tail] def isEmpty(self) -> bool: Checks whether the circular queue is empty or not. return self.size == 0 def isFull(self) -> bool: Checks whether the circular queue is full or not. return self.size == self.max_size"},{"question":"You are given a string `s` containing only lowercase letters. You can perform the following operation on `s` any number of times: - Choose a non-empty substring `t` of `s` such that every character in `t` appears the same number of times in `t`. - Replace `t` with any single character from `t`. Return the minimum possible length of `s` after performing the above operation any number of times.","solution":"def min_length_after_operations(s): Returns the minimum possible length of string s after performing the given operations. from collections import Counter # Count the occurrences of each character in the string. char_count = Counter(s) # The minimum possible length is the number of unique characters in the string. return len(char_count)"},{"question":"You are given a two-dimensional grid `grid` of size `m x n` consisting of `\'0\'`s (representing water) and `\'1\'`s (representing land). An island is a maximal group of connected lands connected horizontally or vertically but not diagonally. The grid\'s boundary is surrounded by water. Convert all islands that are entirely surrounded by water to water (i.e., change all `\'1\'`s to `\'0\'`s in such islands). Return the modified grid. Note: An island is considered surrounded if there are no `\'1\'`s connected to its borders horizontally or vertically.","solution":"def is_island_surrounded(grid, i, j, m, n): Helper function to check if island starting at position (i,j) is surrounded by water. It uses Depth-First Search (DFS) traversal to mark all the land (\'1\'s) part of this island. It will return False immediately if it finds \'1\' at the border. stack = [(i, j)] island_cells = [] is_surrounded = True while stack: r, c = stack.pop() if (r, c) in island_cells: continue island_cells.append((r, c)) if r == 0 or r == m-1 or c == 0 or c == n-1: is_surrounded = False for x, y in ((r+1, c), (r-1, c), (r, c+1), (r, c-1)): if 0 <= x < m and 0 <= y < n and grid[x][y] == \'1\' and (x, y) not in island_cells: stack.append((x, y)) return is_surrounded, island_cells def convert_surrounded_islands(grid): Convert all islands that are entirely surrounded by water to water. if not grid: return grid m, n = len(grid), len(grid[0]) for i in range(m): for j in range(n): if grid[i][j] == \'1\': is_surrounded, island_cells = is_island_surrounded(grid, i, j, m, n) if is_surrounded: for r, c in island_cells: grid[r][c] = \'0\' return grid"},{"question":"You are given a list of `tasks`, where each task has a `start` time and an `end` time, represented as tuples `(start, end)`. Your goal is to determine the minimum number of classrooms required to schedule all given tasks. A classroom can only hold one task at any given time, but multiple classrooms can run simultaneously if needed. Write a function that calculates the minimum number of classrooms needed.","solution":"def min_classrooms(tasks): Calculate the minimum number of classrooms needed to schedule all tasks. if not tasks: return 0 # Separate the start and end times start_times = sorted(task[0] for task in tasks) end_times = sorted(task[1] for task in tasks) start_pointer = end_pointer = 0 used_classrooms = 0 max_classrooms = 0 while start_pointer < len(tasks): if start_times[start_pointer] < end_times[end_pointer]: used_classrooms += 1 start_pointer += 1 else: used_classrooms -= 1 end_pointer += 1 max_classrooms = max(max_classrooms, used_classrooms) return max_classrooms"},{"question":"You are given a linked list where each node contains an integer value. Write a function that rearranges the list such that all odd-indexed nodes are grouped together followed by the even-indexed nodes. Note that the node values should retain their relative order among the odd-indexed and even-indexed nodes. For example, given the linked list: `1->2->3->4->5`, the nodes at odd indexes are `1, 3, 5` and the nodes at even indexes are `2, 4`, so the rearranged list should be `1->3->5->2->4`. Return the head of the modified linked list.","solution":"class ListNode: def __init__(self, value=0, next=None): self.value = value self.next = next def rearrange_odd_even(head): if not head or not head.next: return head odd = head even = head.next even_head = even while even and even.next: odd.next = odd.next.next even.next = even.next.next odd = odd.next even = even.next odd.next = even_head return head"},{"question":"Given a **0-indexed** integer array `arr` of length `n` representing the number of stones in `n` piles, your task is to determine the minimum number of moves required to make all piles equal. In one move, you can remove one stone from any pile with more than one stone and place it in another pile. Return _the minimum number of moves to make all piles equal_.","solution":"def min_moves_to_make_piles_equal(arr): Returns the minimum number of moves required to make all piles equal. In one move, you can remove one stone from any pile and place it in another pile. max_pile = max(arr) total_moves = 0 for pile in arr: total_moves += max_pile - pile return total_moves"},{"question":"You are given an array of positive integers `arr` representing the amount of money in each house arranged in a line. You are also given an integer `k` which represents the minimum number of houses that need to be skipped between two consecutive houses you want to rob. Return _the **maximum amount of money** you can rob without alerting the police._ You cannot rob two consecutive houses, and you must follow the skipping constraint.","solution":"def max_robbed_money(arr, k): n = len(arr) if not arr: return 0 if k >= n: return max(arr) dp = [0] * n dp[0] = arr[0] for i in range(1, n): if i <= k: dp[i] = max(dp[i-1], arr[i]) # up to first k houses, we can only rob individually up to the max else: dp[i] = max(dp[i-1], arr[i] + dp[i-k-1]) return dp[-1]"},{"question":"You are given a binary tree with `n` nodes, where each node has a unique value from `1` to `n`. The root node is defined as the node with value `1`. A node `v` is considered an ancestor of node `w` if there is a path from the root to `w` that contains `v`. You need to process multiple queries on the binary tree. Each query consists of two integers `u` and `v`. For each query, determine if `u` is an ancestor of `v`. Return an array of boolean values where the `i`-th value is the result of the `i`-th query. Write a function `isAncestor` that takes the following parameters: - `n` (integer): the number of nodes in the binary tree. - `edges` (list of pairs of integers): a list representing the edges of the binary tree where `edges[i] = [a, b]` indicates there is an edge from `a` to `b`. - `queries` (list of pairs of integers): a list representing the queries where `queries[i] = [u, v]` indicates the `i-th` query if `u` is an ancestor of `v`. The function should return a list of boolean values representing the answers to the queries.","solution":"def isAncestor(n, edges, queries): from collections import defaultdict, deque # Build adjacency list adj_list = defaultdict(list) for a, b in edges: adj_list[a].append(b) # Define parents for each node and initialize with None parent = {i: None for i in range(1, n+1)} parent[1] = 0 # As root has no parent, we can use 0 as a mark # BFS to set all parent nodes def bfs(root): queue = deque([root]) while queue: node = queue.popleft() for child in adj_list[node]: if parent[child] is None: parent[child] = node queue.append(child) # Call bfs starting from root node bfs(1) # Helper function to find if u is ancestor of v def is_ancestor(u, v): while v and v != u: v = parent[v] return v == u # Result for each query return [is_ancestor(u, v) for u, v in queries]"},{"question":"You are given an integer array `heights` representing the heights of buildings, where `heights[i]` is the height of the i-th building. Between two buildings, you can place a bridge if and only if the height difference between the two buildings is less than or equal to a given integer `k`. Return _the maximum number of bridges that can be placed. A bridge connects exactly two buildings and each building can have at most one bridge connecting it to another building._","solution":"def max_bridges(heights, k): Returns the maximum number of bridges that can be placed given the heights of the buildings and the maximum allowable height difference for a bridge, k. # Sort the array of heights heights.sort() max_count = 0 i = 0 while i < len(heights) - 1: if abs(heights[i] - heights[i + 1]) <= k: max_count += 1 i += 2 # skip the next element as it is already paired else: i += 1 return max_count"},{"question":"Given a 2D binary matrix `matrix`, return _the maximum square area of 1\'s_ that can be formed within the matrix. A square area of 1\'s is a submatrix where all elements within the square are 1.","solution":"def maximal_square(matrix): if not matrix: return 0 n = len(matrix) m = len(matrix[0]) dp = [[0] * (m + 1) for _ in range(n + 1)] max_side = 0 for i in range(1, n + 1): for j in range(1, m + 1): if matrix[i - 1][j - 1] == \'1\': dp[i][j] = min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1 max_side = max(max_side, dp[i][j]) return max_side ** 2"},{"question":"You are given a list of integers `nums` and an integer `k`. We define the `k`-constrained subarray of `nums` starting at index `i` as the subarray that contains `nums[i]` and is constrained by the next `k` elements. That is, the subarray is `[nums[i], nums[i + 1], ..., nums[i + k - 1]]`. If there are fewer than `k` elements remaining in `nums` starting from `i`, the subarray includes all the remaining elements. Your task is to return the maximum product of all `k`-constrained subarrays starting from any valid index `i`.","solution":"def max_k_constrained_product(nums, k): Returns the maximum product of all k-constrained subarrays. Parameters: nums (list): A list of integers. k (int): The constraint length of the subarray. Returns: int: The maximum product of all k-constrained subarrays. if not nums: return 0 max_product = float(\'-inf\') for i in range(len(nums)): product = 1 for j in range(k): if i + j < len(nums): product *= nums[i + j] else: break max_product = max(max_product, product) return max_product"},{"question":"You are given an integer array `arr` of length `n` and an integer `x`. Your task is to determine if you can partition `arr` into `k` non-empty, contiguous subarrays such that the sum of integers in each subarray is less than or equal to `x`. Return `true` if such a partitioning is possible, otherwise return `false`. Note: You must use binary search and a greedy approach to solve this problem efficiently.","solution":"def can_partition(arr, k, x): Returns True if it\'s possible to partition arr into k non-empty contiguous subarrays such that the sum of integers in each subarray is less than or equal to x. Parameters: arr (list of int): The array to partition k (int): Number of subarrays to partition into x (int): The maximum allowed sum of each subarray Returns: bool: True if partitioning is possible, False otherwise def is_valid_partition(mid): current_sum = 0 partitions = 1 for num in arr: if current_sum + num > mid: partitions += 1 current_sum = num if partitions > k: # If we need more partitions than allowed return False else: current_sum += num return partitions <= k if max(arr) > x: # if the largest element is greater than x, partition is not possible return False left, right = max(arr), sum(arr) # lower and upper bounds for binary search while left < right: mid = (left + right) // 2 if is_valid_partition(mid): right = mid else: left = mid + 1 return left <= x"},{"question":"You are given an array of integers `nums` and an integer `k`. Write an algorithm to find the maximum possible sum of a subarray with length `k` and the minimum possible sum of a subarray with length `k`. Implement the `Solution` class: * `Solution(int[] nums, int k)` Initializes the object with the array `nums` and the integer `k`. * `int maxSumSubarray()` Returns the maximum possible sum of a subarray with length `k`. * `int minSumSubarray()` Returns the minimum possible sum of a subarray with length `k`.","solution":"class Solution: def __init__(self, nums, k): self.nums = nums self.k = k def maxSumSubarray(self): if not self.nums or self.k <= 0 or self.k > len(self.nums): return 0 max_sum = sum(self.nums[:self.k]) window_sum = max_sum for i in range(self.k, len(self.nums)): window_sum += self.nums[i] - self.nums[i - self.k] max_sum = max(max_sum, window_sum) return max_sum def minSumSubarray(self): if not self.nums or self.k <= 0 or self.k > len(self.nums): return 0 min_sum = sum(self.nums[:self.k]) window_sum = min_sum for i in range(self.k, len(self.nums)): window_sum += self.nums[i] - self.nums[i - self.k] min_sum = min(min_sum, window_sum) return min_sum"},{"question":"You are given a string `s` consisting of lowercase English letters and an integer `k`. You need to modify the string in such a way that there are **at most** `k` distinct characters in the resulting string. Find the length of the longest substring you can obtain after performing the modification.","solution":"def length_of_longest_substring_k_distinct(s, k): Returns the length of the longest substring with at most k distinct characters. :param s: String consisting of lowercase English letters. :param k: Integer for maximum allowed distinct character count. :return: Integer length of the longest substring with at most k distinct characters. if k == 0: return 0 start = 0 max_length = 0 char_count = {} for end in range(len(s)): # Add the current character to the dictionary and update its count char_count[s[end]] = char_count.get(s[end], 0) + 1 # While the number of distinct characters exceeds k, update the start position while len(char_count) > k: char_count[s[start]] -= 1 if char_count[s[start]] == 0: del char_count[s[start]] start += 1 # Calculate the maximum length of the substring max_length = max(max_length, end - start + 1) return max_length"},{"question":"You are given a **0-indexed** array of integers `arr` and an integer `k`. The **product** of an array is defined as the product of all elements in the array. Determine the **minimum length** of a contiguous subarray of `arr` such that the product of its elements is equal to `k`. If no such subarray exists, return `-1`. Note that each element in the array and `k` are positive integers.","solution":"def minimum_length_subarray_with_product(arr, k): Determine the minimum length of a contiguous subarray of arr such that the product of its elements is equal to k. If no such subarray exists, return -1. n = len(arr) left = 0 product = 1 min_length = float(\'inf\') for right in range(n): product *= arr[right] while product >= k and left <= right: if product == k: min_length = min(min_length, right - left + 1) product //= arr[left] left += 1 return min_length if min_length != float(\'inf\') else -1"},{"question":"You are given a **0-indexed** integer array `positions`, where `positions[i]` represents the position of a robot on a number line. The distance between two robots is defined as the absolute difference of their positions. The robots must form pairs such that the maximum distance between any pair is minimized. Return _the minimized maximum distance_ between any robot pairs. Note that each robot can only belong to one pair.","solution":"def minimized_max_distance(positions): Returns the minimized maximum distance between any robot pairs such that the distance between two robots is defined as the absolute difference of their positions. Args: positions (List[int]): a list of integers representing the positions of robots. Returns: int: the minimized maximum distance between any robot pairs. # Sort the positions to make the pairing easier (closest to adjacent positions) positions.sort() # Initialize the minimized maximum distance to 0 minimized_max_dist = 0 # Iterate through the list, pairing adjacent robots for i in range(0, len(positions) - 1, 2): minimized_max_dist = max(minimized_max_dist, positions[i + 1] - positions[i]) return minimized_max_dist"},{"question":"You are given an integer array `nums` of length `n` where each element represents the number of citations a researcher has received for their papers. A researcher has an `h-index` if `h` of their `n` papers have at least `h` citations each, and the other `n-h` papers have no more than `h` citations each. If there are several possible values for `h`, the maximum one should be chosen. Calculate and return the researcher\'s `h-index`.","solution":"def h_index(citations): Calculate and return the researcher\'s h-index. The h-index is defined as the maximum value h such that the given author has published h papers that have each been cited at least h times. :param citations: List[int] - The array of citations per paper. :return: int - The calculated h-index. citations.sort(reverse=True) h = 0 for i in range(len(citations)): if citations[i] >= i + 1: h = i + 1 else: break return h"},{"question":"You are developing a system that manages parking at a multi-storey car park. Each car park has a certain number of levels, and each level has a certain number of parking slots. Implement a class `ParkingSystem` that simulates the parking system of a multi-storey car park: * `ParkingSystem(int[] levelsAndSlots)`: Initializes the car park with the given configuration where `levelsAndSlots[i]` represents the number of slots available on the `i-th` level. * `boolean parkCar(int carType, int level)`: Attempts to park a car of the specified type on the given level. If there is an available slot for the car on the given level, the car is parked, and the method returns `true`. Otherwise, the method returns `false`. * `boolean leaveCar(int carType, int level)`: Removes a car of the specified type from the given level. If there is such a car on the level, it is removed, and the method returns `true`. Otherwise, the method returns `false`.","solution":"class ParkingSystem: def __init__(self, levelsAndSlots): self.levels = [] for slots in levelsAndSlots: self.levels.append({ \'total_slots\': slots, \'occupied_slots\': 0 }) def parkCar(self, level): if level < len(self.levels) and self.levels[level][\'occupied_slots\'] < self.levels[level][\'total_slots\']: self.levels[level][\'occupied_slots\'] += 1 return True return False def leaveCar(self, level): if level < len(self.levels) and self.levels[level][\'occupied_slots\'] > 0: self.levels[level][\'occupied_slots\'] -= 1 return True return False"},{"question":"Given a **binary matrix** `grid`, where each cell is either `0` (representing water) or `1` (representing land), return _the length of the perimeter of the island in `grid`_. The island is always surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are surrounded by water.","solution":"def islandPerimeter(grid): Returns the perimeter of the island in the binary matrix grid. :param grid: List[List[int]] - A list of lists where each element is either 0 or 1. :return: int - The perimeter of the island. rows = len(grid) cols = len(grid[0]) perimeter = 0 for r in range(rows): for c in range(cols): if grid[r][c] == 1: perimeter += 4 if r > 0 and grid[r-1][c] == 1: # Check above perimeter -= 2 if c > 0 and grid[r][c-1] == 1: # Check left perimeter -= 2 return perimeter"},{"question":"You are given an integer array `nums` and an integer `target`. You want to build an expression out of `nums` by inserting the operators \'+\' and \'-\' between the given numbers. Determine the number of different ways you can add the operators to get the sum equal to `target`. Return _the number of different expressions that can be constructed out of_ `nums` _which evaluates to_ `target`.","solution":"def find_target_sum_ways(nums, target): Returns the number of different expressions that can be constructed out of nums which evaluates to target. from collections import defaultdict dp = defaultdict(int) dp[0] = 1 for num in nums: next_dp = defaultdict(int) for sum_ in dp: next_dp[sum_ + num] += dp[sum_] next_dp[sum_ - num] += dp[sum_] dp = next_dp return dp[target]"},{"question":"You are given an array of integers `heights` representing the height of trees in a forest. A lumberjack wants to cut down the trees, but can only cut trees of the same height at the same time. Each cut operation costs 1 unit of energy, and the lumberjack can only cut trees that are adjacent to each other. Return _the **minimum** units of energy required to cut down all the trees so that no trees remain in the forest._","solution":"def min_energy_to_cut_trees(heights): Calculate the minimum units of energy required to cut down all trees in the forest so that no trees remain. Parameters: heights (list): A list of integers representing the heights of trees in the forest. Returns: int: The minimum units of energy required to cut all the trees. if not heights: return 0 energy = 0 current_height = None for height in heights: if current_height != height: energy += 1 current_height = height return energy"},{"question":"You are given an integer array `arr` and an integer `k`. A subsequence of `arr` is called **suboptimal** if it includes exactly `k` elements and the difference between the maximum and minimum elements of the subsequence is minimized. Return _the difference between the maximum and minimum elements of the most **suboptimal** subsequence of `arr`_.","solution":"def minDifferenceOfSuboptimalSubsequence(arr, k): Finds the minimum difference between the maximum and minimum elements of a suboptimal subsequence of length k. if not arr or k <= 0 or k > len(arr): return 0 # or raise an appropriate exception arr.sort() min_difference = float(\'inf\') for i in range(len(arr) - k + 1): current_difference = arr[i + k - 1] - arr[i] min_difference = min(min_difference, current_difference) return min_difference"},{"question":"Given an array `nums` of integers and an integer `k`, return the length of the longest continuous subarray that contains at most `k` distinct integers. **Note:** - `1 <= nums.length <= 10^5` - `0 <= nums[i] < 10^6` - `1 <= k <= nums.length`","solution":"def longest_subarray_with_k_distinct(nums, k): Returns the length of the longest continuous subarray that contains at most k distinct integers. Parameters: nums (list of int): A list of integers. k (int): Number of distinct integers allowed in the subarray. Returns: int: Length of the longest subarray with at most k distinct integers. from collections import defaultdict n = len(nums) if n == 0 or k == 0: return 0 left = 0 right = 0 max_length = 0 count = defaultdict(int) while right < n: count[nums[right]] += 1 while len(count) > k: count[nums[left]] -= 1 if count[nums[left]] == 0: del count[nums[left]] left += 1 max_length = max(max_length, right - left + 1) right += 1 return max_length"},{"question":"You are given a list of integers `nums` representing the number of votes each candidate received in an election. The `nums` list is sorted in non-increasing order. You are allowed to perform the following operation any number of times: - Choose any candidate (except the first one) and transfer one vote to a different candidate (including potentially the first one). Your goal is to minimize the difference between the votes of the candidate with the maximum votes and the candidate with the minimum votes. Return the minimum possible difference between the maximum and minimum votes after performing any number of operations. **Example:** ```text Input: nums = [10, 3, 2, 2] Output: 1 Explanation: We can perform the following operations to minimize the difference: - Transfer 2 votes from the first candidate to the last candidate: [8, 3, 2, 4] - Transfer 1 vote from the second candidate to the third candidate: [8, 2, 3, 4] The difference between the maximum and minimum votes is 1. ```","solution":"def minimize_difference(nums): Minimizes the difference between the maximum and minimum votes after performing any number of allowed operations. :param nums: List[int] - the number of votes each candidate received, sorted in non-increasing order :return: int - the minimum possible difference between the maximum and minimum votes if not nums: return 0 max_votes, min_votes = nums[0], nums[-1] # Since nums is sorted in non-increasing order # Calculate the number of votes that are excess and the number of candidates: total_votes = sum(nums) n = len(nums) # Find the theoretical average if votes were distributed equally equal_votes = total_votes // n # If the total number of votes is exactly divisible by the number of candidates, # then the best we can do is to make votes of all candidates equal. if total_votes % n == 0: return 0 # Otherwise, the best we can do is to make the difference no greater than 1, # because we can only move whole votes. return 1"},{"question":"You are given an array of positive integers `arr` representing the heights of `n` buildings lined up from left to right. The buildings are viewed from the west, meaning you are looking at them from the leftmost side. A building has an **ocean view** if all taller buildings to its right (if any) are blocked by it. Return an array of indices of the buildings that have an **ocean view**, in increasing order.","solution":"def find_buildings_with_ocean_view(arr): Returns the indices of buildings that have an ocean view. A building has an ocean view if all taller buildings to its right (if any) are blocked by it. :param arr: List[int] - Heights of the buildings :return: List[int] - Indices of buildings with ocean view n = len(arr) result = [] max_height_so_far = 0 for i in reversed(range(n)): if arr[i] > max_height_so_far: result.append(i) max_height_so_far = arr[i] return result[::-1] # reverse to get indices in increasing order"},{"question":"You are given a grid of size `n x m` representing a field where each cell contains either grass (\'G\') or water (\'W\'). The field has a few cows grazing on the grass. Each cow starts grazing from a specific cell in the grid, represented by the array `cows` where `cows[i] = [cowRi, cowCi]` is the starting position of the `iᵗʰ` cow. A cow can only move to neighboring cells (up, down, left, or right) if the cell contains grass and has not been grazed yet. After a cow moves to a new cell containing grass, it grazes that cell, turning it into an empty cell (\'.\'). Given the grid and the array `cows`, return _an integer representing the largest number of cells a single cow can graze starting from its initial position and moving until it can no longer move to a new grass cell_. If no cow can graze any cells, return 0.","solution":"def largest_grazed_area(grid, cows): Returns the largest number of cells a single cow can graze starting from its initial position. def dfs(x, y): if x < 0 or x >= len(grid) or y < 0 or y >= len(grid[0]) or grid[x][y] != \'G\': return 0 grid[x][y] = \'.\' count = 1 for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: count += dfs(x + dx, y + dy) return count max_grazed = 0 for cow in cows: cowR, cowC = cow if grid[cowR][cowC] == \'G\': max_grazed = max(max_grazed, dfs(cowR, cowC)) return max_grazed"},{"question":"You are given a string `order` and an array of strings `words`. `order` is a permutation of the lowercase English letters. Whole array of `words` is sorted according to the order defined by the string `order`. Your task is to reorder the array of strings in `words` according to the standard lexicographical order (i.e., dictionary order). Return the reordered array of strings.","solution":"def reorder_to_standard_lexicographical(order, words): Reorder the array of strings `words` according to the standard lexicographical order. Parameters: order (str): A permutation of the lowercase English letters. words (list): An array of strings sorted according to the order defined by `order`. Returns: list: The reordered array of strings according to standard lexicographical order. return sorted(words)"},{"question":"Given a string `s` and an integer array `indices` of the same length, return a new string where each character is relocated to the position specified in `indices`. Specifically, the character at the `i-th` position of the original string should move to the position `indices[i]` in the new string.","solution":"def restore_string(s, indices): Restores the string such that the character at the i-th position moves to indices[i]. Parameters: s (str): The original string. indices (list of int): The new positions for each character. Returns: str: The restored string. # Create a list with the same length as s, initialized with empty characters restored = [\'\'] * len(s) # Iterate over each character in the string along with its index for i, char in enumerate(s): # Place the character at its new position as specified in indices restored[indices[i]] = char # Join the list into a string and return it return \'\'.join(restored)"},{"question":"You are given a list of `points` representing the coordinates of `N` points on a 2D plane, where each point is represented as `[x, y]`. A line is said to be vertical if it is parallel to the y-axis. Your task is to determine if there is a vertical line that divides the points into two non-empty sets with mirror symmetry about the line. Return _`true` if such a vertical line exists, otherwise return `false`._","solution":"def is_reflected(points): Determine if there is a vertical line that divides the points into two non-empty sets with mirror symmetry about the line. :param points: List of coordinate points [x, y]. :return: Boolean indicating if such a line exists. if not points: return True # Create a set of all points for fast lookup points_set = set(map(tuple, points)) # Find the minimum and maximum x coordinates min_x = float(\'inf\') max_x = float(\'-inf\') for x, y in points: min_x = min(min_x, x) max_x = max(max_x, x) # The middle is the potential vertical line middle = (min_x + max_x) / 2.0 # Check for each point if its reflection across the middle exists for x, y in points: reflected_point = (2 * middle - x, y) if reflected_point not in points_set: return False return True"},{"question":"You are given an encoded string where each group of characters is followed by an integer representing the number of times the characters should be repeated. Write a function to decode the string and return the expanded result. For example, the input \\"a2b3\\" should be decoded as \\"aabbb\\". Assume the input string is always valid, with no spaces and every character group is followed by at least one digit.","solution":"def decode_string(encoded_str): Decodes the given encoded string where each character group is followed by an integer representing the number of times the characters should be repeated. decoded_str = \\"\\" i = 0 while i < len(encoded_str): char = encoded_str[i] repeat_count = \\"\\" # Look ahead to collect the digit(s) j = i + 1 while j < len(encoded_str) and encoded_str[j].isdigit(): repeat_count += encoded_str[j] j += 1 decoded_str += char * int(repeat_count) i = j # Move to the next character group return decoded_str"},{"question":"You are given a string `s` and an array of integers `distance` where `distance[i]` represents the distance between the two occurrences of the character `i + \'a\'` in the string `s`. Each letter appears exactly twice in the string. Return _true_ if the given `distance` array is correct for the string `s`, otherwise return _false_.","solution":"def checkDistances(s, distance): Returns True if the given distance array is correct for the string s, otherwise returns False. first_occurrence = {} for i, char in enumerate(s): if char in first_occurrence: actual_distance = i - first_occurrence[char] - 1 expected_distance = distance[ord(char) - ord(\'a\')] if actual_distance != expected_distance: return False else: first_occurrence[char] = i return True"},{"question":"You are given a **0-indexed** integer array `heights` of length `n` where `heights[i]` represents the height of the `ith` building. Assume a person can jump from the top of one building to another if and only if the height of the destination building is less than or equal to the current building height plus a given allowable jump height `k`. The person starts from the first building (index `0`). Return the maximum number of buildings the person can visit, including the starting building, while making valid jumps.","solution":"def max_buildings(heights, k): Returns the maximum number of buildings the person can visit. n = len(heights) count = 1 # Number of buildings visited starts with the first building current_building = 0 for i in range(1, n): if heights[i] <= heights[current_building] + k: count += 1 current_building = i return count"},{"question":"You are given a **directed graph** with `n` nodes labeled from `0` to `n-1`. Each node has one outgoing edge defined by the array `edges`, where `edges[i]` represents the end node of a directed edge starting from node `i`, or `-1` if there is no outgoing edge. A node is considered to be in a **cycle** if it is part of a directed cycle. Your task is to determine the length of the **longest cycle** in the graph. If no cycle exists, return `-1`. Return _the length of the longest cycle_ in the graph represented by the given `edges` array.","solution":"def longest_cycle(edges): Finds the length of the longest cycle in the directed graph represented by edges. If no cycle exists, returns -1. Parameters: edges (List[int]): List of integers representing the end node of a directed edge starting from node `i`, or `-1` if there is no outgoing edge. Returns: int: The length of the longest cycle, or -1 if no cycle exists. n = len(edges) visited = [False] * n rec_stack = [False] * n longest_cycle_length = -1 def dfs(node, path_length, path_index): nonlocal longest_cycle_length if visited[node]: if rec_stack[node]: # A cycle is detected cycle_length = path_length - path_index[node] longest_cycle_length = max(longest_cycle_length, cycle_length) return visited[node] = True rec_stack[node] = True path_index[node] = path_length if edges[node] != -1: dfs(edges[node], path_length + 1, path_index) rec_stack[node] = False for i in range(n): if not visited[i]: dfs(i, 0, [-1] * n) return longest_cycle_length"},{"question":"Given an integer array `arr` of size `n`, you need to determine the minimum number of moves required to make all elements of the array equal. In one move, you can choose any single element of the array and either increment or decrement it by 1. Create a function `minMovesToEqualElements(arr)` that returns the minimum number of moves. Write an algorithm that solves this problem in O(n log n) time complexity.","solution":"def minMovesToEqualElements(arr): Returns the minimum number of moves required to make all elements of the array equal. arr.sort() median = arr[len(arr) // 2] return sum(abs(num - median) for num in arr)"},{"question":"Build a data structure that supports adding integers onto a heap and fetching the mode of the heap - the integer that appears the most frequently. Your implementation should support the following operations: * `ModeHeap()` Initializes the data structure. * `void add(int num)` Adds an integer `num` to the heap. * `int getMode()` Returns the mode of the integers currently in the heap. If multiple modes exist, return any one of them. Note: Ensure that your methods work efficiently with respect to time and space complexity.","solution":"import heapq from collections import defaultdict class ModeHeap: def __init__(self): Initializes the ModeHeap data structure. self.heap = [] self.num_count = defaultdict(int) self.mode = None self.mode_count = 0 def add(self, num): Adds an integer num to the heap and updates the mode. heapq.heappush(self.heap, num) self.num_count[num] += 1 # Update mode if necessary if self.num_count[num] > self.mode_count: self.mode = num self.mode_count = self.num_count[num] def getMode(self): Returns the mode of the integers currently in the heap. return self.mode"},{"question":"Given a string `s`, return the length of the longest substring that contains no repeated characters. The substring must be contiguous but does not need to be a dictionary word. Your solution should achieve this in linear time complexity, considering the optimal approach to efficiently determine the longest such substring.","solution":"def length_of_longest_substring(s): Returns the length of the longest substring without repeating characters. char_index = {} longest = 0 start = 0 for i, char in enumerate(s): if char in char_index and char_index[char] >= start: start = char_index[char] + 1 char_index[char] = i longest = max(longest, i - start + 1) return longest"},{"question":"Write a function `findCriticalConnections` that provides a list of critical connections in a network. The network is represented as an undirected graph where each node is uniquely numbered. A connection (an edge between two nodes) is considered critical if its removal will make some nodes unable to reach some other nodes. The graph is given as a list of connections. There are `n` nodes in the graph, and each of the connections is a pair `[a, b]`, representing an edge between nodes `a` and `b`. The function signature is as follows: ```python def findCriticalConnections(n: int, connections: List[List[int]]) -> List[List[int]]: pass ``` _Return the list of all critical connections in any order._","solution":"from typing import List def findCriticalConnections(n: int, connections: List[List[int]]) -> List[List[int]]: import collections def dfs(node, discovery_time, visited, parent, low, disc, graph, critical_conns): children = 0 visited[node] = True disc[node] = low[node] = discovery_time[0] discovery_time[0] += 1 for neighbor in graph[node]: if not visited[neighbor]: parent[neighbor] = node children += 1 dfs(neighbor, discovery_time, visited, parent, low, disc, graph, critical_conns) low[node] = min(low[node], low[neighbor]) if low[neighbor] > disc[node]: critical_conns.append([node, neighbor]) elif neighbor != parent[node]: low[node] = min(low[node], disc[neighbor]) graph = collections.defaultdict(list) for u, v in connections: graph[u].append(v) graph[v].append(u) discovery_time = [0] visited = [False] * n disc = [float(\\"Inf\\")] * n low = [float(\\"Inf\\")] * n parent = [-1] * n critical_conns = [] for i in range(n): if not visited[i]: dfs(i, discovery_time, visited, parent, low, disc, graph, critical_conns) return critical_conns"},{"question":"You are given a `1-indexed` integer array `nums` where each integer represents the number of prizes at different prize stations. You also have an integer `m` which denotes the total number of prizes you need to collect. In one move, you can only collect all the prizes at one station. Write an algorithm to find the minimum number of moves required to collect exactly `m` prizes. If it\'s impossible to collect exactly `m` prizes, return `-1`.","solution":"def min_moves_to_collect_prizes(nums, m): Finds the minimum number of moves to collect exactly m prizes. :param nums: List[int] - list of integers where each integer represents the number of prizes at different prize stations. :param m: int - the total number of prizes needed to collect. :return: int - minimum number of moves to collect exactly m prizes, or -1 if it\'s not possible. from itertools import combinations # Consider all possible combinations of prizes n = len(nums) for moves in range(1, n+1): for combo in combinations(nums, moves): if sum(combo) == m: return moves return -1"},{"question":"You are given a list of `points` where each point is a tuple representing coordinates on a 2D plane. Implement the `PointDistance` class: - `void addPoint(tuple point)` Adds the specified `point` to the list of points. - `float findClosestDistance(tuple target)` Returns the smallest distance from the `target` point to any existing point in the list. The distance between points `(x1, y1)` and `(x2, y2)` is calculated by the formula `sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2)`. The `sqrt()` function from the `math` module may be used to compute the square root.","solution":"import math class PointDistance: def __init__(self): self.points = [] def addPoint(self, point): self.points.append(point) def findClosestDistance(self, target): if not self.points: return float(\'inf\') closest_distance = float(\'inf\') for point in self.points: distance = self._calculateDistance(point, target) if distance < closest_distance: closest_distance = distance return closest_distance def _calculateDistance(self, point1, point2): return math.sqrt((point2[0] - point1[0]) ** 2 + (point2[1] - point1[1]) ** 2)"},{"question":"A game consists of a grid of size `m x n` filled with non-negative integers. You are given a 2D grid `grid` and an integer `k`. In a single move, you can select an element `x` from the grid and move `x` number of steps in any of the four cardinal directions (up, down, left, or right), wrapping around the edges as necessary. Your task is to determine whether it is possible to start from any element in the grid and reach any other element in the grid in exactly `k` moves. Return `true` if it\'s possible, otherwise, return `false`.","solution":"def can_reach_in_k_moves(grid, k): Determines if it\'s possible to move from any element to any other element in the grid in exactly `k` moves, wrapping around the edges as necessary. :param grid: List[List[int]] - 2D list representing the grid :param k: int - number of moves required :return: bool - True if possible, False otherwise m, n = len(grid), len(grid[0]) # If the number of moves is zero or the required number of moves is multiple # of the grid\'s perimeter, then it\'s always possible if k == 0: return True # If k is multiple of either the number of rows or columns, # then we can reach any element if k % m == 0 or k % n == 0: return True return False"},{"question":"Given two integers `n` and `k`, return all possible combinations of `k` numbers out of the range `[1, n]`. You may return the answer in any order. Implement the `getCombinations` function which takes two integers `n` and `k` and returns a list of all possible combinations of `k` numbers chosen from the range `[1, n]`.","solution":"from itertools import combinations def getCombinations(n, k): Returns all possible combinations of k numbers out of the range [1, n]. return list(combinations(range(1, n+1), k))"},{"question":"You are given an array of integers `arr` and an integer `k`. Your task is to find the length of the shortest contiguous subarray that contains at least `k` distinct numbers. If no such subarray exists, return `-1`. **Definition of the function**: ```python def shortest_subarray_with_k_distinct(arr: List[int], k: int) -> int: ``` **Example:** ```python arr = [1, 2, 1, 2, 3, 4] k = 3 # In this example, the shortest subarray with at least 3 distinct numbers is [1, 2, 3] or [2, 3, 4], both of which have a length of 3. # Therefore, the function should return 3. print(shortest_subarray_with_k_distinct(arr, k)) # Output: 3 ``` **Constraints:** * The length of `arr` will be in the range `[1, 10^5]`. * The value of each element in `arr` will be an integer in the range `[1, 10^9]`. * The value of `k` will be in the range `[1, 10^5]`.","solution":"def shortest_subarray_with_k_distinct(arr, k): from collections import defaultdict n = len(arr) if k > n: return -1 left = 0 right = 0 unique_count = 0 min_len = float(\'inf\') counts = defaultdict(int) while right < n: if counts[arr[right]] == 0: unique_count += 1 counts[arr[right]] += 1 right += 1 while unique_count >= k: min_len = min(min_len, right - left) counts[arr[left]] -= 1 if counts[arr[left]] == 0: unique_count -= 1 left += 1 return min_len if min_len != float(\'inf\') else -1"},{"question":"You are given an array of integers `arr` representing a list of numbers. You want to find the overall sum of the minimum value of every contiguous subarray of `arr`. A **contiguous subarray** is a subset of `arr` that can be derived by deleting some (possibly zero) elements from the beginning and some (possibly zero) elements from the end without changing the order of the remaining elements. Write a function that returns this overall sum. For example, given the array `[3, 1, 2, 4]`, the contiguous subarrays are `[3]`, `[3, 1]`, `[3, 1, 2]`, `[3, 1, 2, 4]`, `[1]`, `[1, 2]`, `[1, 2, 4]`, `[2]`, `[2, 4]`, `[4]` and their corresponding minimum values are `3, 1, 1, 1, 1, 1, 2, 2, 2, 4`. The sum of these minimums is `1 + 3 + 1 + 4 + 1 + 1 + 2 + 2 + 2 + 4 = 21`.","solution":"def sum_of_minimums(arr): Returns the overall sum of the minimum value of every contiguous subarray of `arr`. n = len(arr) overall_sum = 0 for i in range(n): current_min = arr[i] for j in range(i, n): current_min = min(current_min, arr[j]) overall_sum += current_min return overall_sum"},{"question":"Given a 2D grid of size `m x n` representing a maze, return _the minimum number of steps required to move from the start (`0, 0`) to the destination (`m-1, n-1`)._ You can only move up (↑), down (↓), left (←), or right (→) at any point in time, and you cannot move into any cell that contains a wall (`\'W\'`). If there is no valid path from start to destination, return `-1`. The maze is represented as follows: - `\'E\'` denotes an empty cell. - `\'W\'` denotes a wall.","solution":"from collections import deque def min_steps_maze(maze): Returns the minimum number of steps required to move from the start (0, 0) to the destination (m-1, n-1) in the given maze. If there is no valid path, returns -1. m, n = len(maze), len(maze[0]) if maze[0][0] == \'W\' or maze[m-1][n-1] == \'W\': return -1 directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([(0, 0, 0)]) # (row, col, steps) visited = set((0, 0)) while queue: x, y, steps = queue.popleft() if x == m - 1 and y == n - 1: return steps for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and maze[nx][ny] == \'E\' and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny, steps + 1)) return -1"},{"question":"Given an integer `n` and a list of integers `arr` representing back-to-back daily temperatures, return another list such that, for each day in the input list, tells you how many days you would have to wait until a warmer temperature. If there is no future day for which this is possible, put `0` instead. For example, given the list `arr = [73, 74, 75, 71, 69, 72, 76, 73]`, the output should be `[1, 1, 4, 2, 1, 1, 0, 0]`. This question tests your understanding of stack data structure and efficient array traversal techniques.","solution":"def dailyTemperatures(arr): Given a list of daily temperatures, return a list such that each element represents the number of days you would have to wait until a warmer temperature. :param arr: List of integers representing daily temperatures :return: List of integers representing waiting days for a warmer temperature n = len(arr) answer = [0] * n stack = [] for i in range(n): while stack and arr[i] > arr[stack[-1]]: j = stack.pop() answer[j] = i - j stack.append(i) return answer"},{"question":"You are given a list of non-negative integers representing the amount of rainwater trapped on top of walls of varying heights, where the width of each wall segment is 1. Calculate _the maximum amount of rainwater that can be trapped_ between the walls. The list represents an elevation map where the width of each bar is 1. Output: An integer representing the maximum water trapped.","solution":"def trap(height): Calculate the maximum amount of rainwater trapped. :param height: List[int], representing the elevation map. :return: int, the maximum amount of rainwater that can be trapped. if not height: return 0 left, right = 0, len(height) - 1 left_max, right_max = height[left], height[right] water_trapped = 0 while left < right: if left_max < right_max: left += 1 left_max = max(left_max, height[left]) water_trapped += max(0, left_max - height[left]) else: right -= 1 right_max = max(right_max, height[right]) water_trapped += max(0, right_max - height[right]) return water_trapped"},{"question":"A social media platform uses a scoring system to rank the activity of its users. Each user can perform different actions that contribute to their score. There are three types of actions, each associated with a specific score value: - Post creation adds 10 points. - Comment adds 5 points. - Like adds 1 point. You are required to implement the `UserScoreTracker` class that manages users\' scores as they perform different actions: - `UserScoreTracker()` initializes the tracker with an empty user database. - `addUser(string userId)` adds a new user with the given `userId`. If the user already exists, the request is ignored. - `recordAction(string userId, string actionType)` records an action of type `actionType` (either \\"post\\", \\"comment\\", or \\"like\\") for the user with the given `userId`. The user\'s score is updated accordingly. If the user does not exist, the request is ignored. - `getUserScore(string userId)` returns the current score of the user with the given `userId`. If the user does not exist, returns 0. - `getTopKUsers(int k)` returns a list of the top `k` users in descending order of their scores. If there are ties in scores, the users should be arranged in alphabetical order by `userId`. Ensure the class maintains efficient operations for potentially large numbers of users and actions.","solution":"class UserScoreTracker: def __init__(self): self.users = {} self.actions = {\\"post\\": 10, \\"comment\\": 5, \\"like\\": 1} def addUser(self, userId): if userId not in self.users: self.users[userId] = 0 def recordAction(self, userId, actionType): if userId in self.users and actionType in self.actions: self.users[userId] += self.actions[actionType] def getUserScore(self, userId): return self.users.get(userId, 0) def getTopKUsers(self, k): sorted_users = sorted(self.users.items(), key=lambda x: (-x[1], x[0])) return [user for user, score in sorted_users[:k]]"},{"question":"You are given a binary tree in which each node contains an integer value. Implement a function `sumOfLongestPath(root)` that returns the sum of the values along the longest path from the root to a leaf. If there are multiple longest paths, return the sum of the values along the path with the greatest sum. The tree nodes are represented as follows: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` For example, given the following binary tree: ``` 1 / 2 3 / 4 5 6 ``` The longest path is `1 -> 2 -> 5 -> 6`, and the sum is `1 + 2 + 5 + 6 = 14`. Therefore, `sumOfLongestPath(root)` should return `14`.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def sumOfLongestPath(root: TreeNode) -> int: def dfs(node: TreeNode): if not node: return (0, 0) # (sum, depth) if not node.left and not node.right: return (node.val, 1) # Leaf node left_sum, left_depth = dfs(node.left) right_sum, right_depth = dfs(node.right) if left_depth > right_depth: return (left_sum + node.val, left_depth + 1) elif left_depth < right_depth: return (right_sum + node.val, right_depth + 1) else: # Same depth, return the path with the greater sum return (max(left_sum, right_sum) + node.val, left_depth + 1) return dfs(root)[0]"},{"question":"Given a string `s` containing lowercase English letters, form a new string by arranging the letters in the order they first appeared in the string `s`, but remove all subsequent occurrences of each character after its first appearance. Return the resulting string. For example, given the string `s` = \\"cbacdcbc\\", the result would be \\"cbad\\".","solution":"def remove_duplicates(s): Returns a new string by arranging the letters in the order they first appeared in the string s, but with all subsequent occurrences of each character removed. seen = set() result = [] for char in s: if char not in seen: seen.add(char) result.append(char) return \'\'.join(result)"},{"question":"You are given the heads of two singly linked lists, `headA` and `headB`. The two linked lists intersect at some node. Find the node at which the intersection begins and return it. If the two linked lists have no intersection, return `null`. Note that the linked lists must retain their original structure after the function returns. The solution should have a time complexity of `O(n)` and use only `O(1)` additional memory.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def get_intersection_node(headA, headB): Finds the node at which the intersection of two singly linked lists begins. If no intersection, returns None. if not headA or not headB: return None pointer_a = headA pointer_b = headB while pointer_a is not pointer_b: pointer_a = pointer_a.next if pointer_a else headB pointer_b = pointer_b.next if pointer_b else headA return pointer_a"},{"question":"You are given an integer `X` representing an initial value and integer arrays `A` and `B` of the same length. Arrays `A` and `B` represent pairs of values that can be used in operations to transform the value. For each pair `(A[i], B[i])`, you can choose to either add or subtract `A[i]` from `X`, and multiply the result by `B[i]`. You must perform exactly one operation using each pair in any order. Return `true` if it is possible to make `X` equal to 0 after using all pairs and `false` otherwise.","solution":"def can_transform_to_zero(X, A, B): Determines if it\'s possible to make X equal to 0 by applying operations with pairs from A and B. For each pair (A[i], B[i]), you can either add or subtract A[i] from X and multiply the result by B[i]. Args: X: Initial value. A: List of integers. B: List of integers. Returns: True if it\'s possible to make X equal to 0, False otherwise. return _can_transform_helper(X, A, B, 0) def _can_transform_helper(X, A, B, index): if index == len(A): return X == 0 add_option = (X + A[index]) * B[index] subtract_option = (X - A[index]) * B[index] return _can_transform_helper(add_option, A, B, index + 1) or _can_transform_helper(subtract_option, A, B, index + 1)"},{"question":"Given an integer array `prices` representing the prices of a set of items, return the **maximum number of items** you can buy with a given amount of money `budget`. You must buy items in such a way that the **total cost** does not exceed the `budget`. If it is not possible to buy at least one item, return `0`. Important: You can only buy one item of each price, and you must consider the prices in ascending order to maximize the number of items purchased.","solution":"def max_items(prices, budget): Returns the maximum number of items that can be bought with the given budget. Args: prices (list of int): The prices of the items. budget (int): The available budget. Returns: int: The maximum number of items that can be bought without exceeding the budget. prices.sort() total_cost = 0 num_items = 0 for price in prices: if total_cost + price <= budget: total_cost += price num_items += 1 else: break return num_items"},{"question":"You are given an integer array `nums` sorted in **non-decreasing order**. You need to remove the **duplicates** in-place such that each unique element appears only once. The relative order of the elements should be kept the same. Instead of returning the length of the array and modifying the original array directly, return a new array containing only the unique elements in sorted order. You should aim to solve this with a solution that has a time complexity of O(n) where n is the length of the array `nums`.","solution":"def remove_duplicates(nums): Removes duplicates from a sorted array and returns a new array with unique elements. :param nums: List of integers sorted in non-decreasing order :return: New list containing only unique elements, in the same order as original if not nums: return [] unique_nums = [nums[0]] for i in range(1, len(nums)): if nums[i] != nums[i - 1]: unique_nums.append(nums[i]) return unique_nums"},{"question":"Given a grid consisting of `\'0\'s` (empty cell) and `\'X\'s` (block cell), you have to determine the maximum size square sub-grid that contains only `\'0\'s`. Construct and return the size of this maximum square sub-grid.","solution":"def maximalSquare(grid): if not grid: return 0 m = len(grid) n = len(grid[0]) max_square_size = 0 dp = [[0]*n for _ in range(m)] for i in range(m): for j in range(n): if grid[i][j] == \'0\': if i == 0 or j == 0: dp[i][j] = 1 else: dp[i][j] = min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1 max_square_size = max(max_square_size, dp[i][j]) return max_square_size"},{"question":"You are given a binary search tree (BST) with non-negative values. Design an algorithm to find the sum of the node values between two given bounds (inclusive). The algorithm should return the sum of all the node values in the BST that fall within the given range.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def range_sum_BST(root, low, high): Returns the sum of node values in the BST that fall within the given range [low, high]. if not root: return 0 if root.val < low: return range_sum_BST(root.right, low, high) elif root.val > high: return range_sum_BST(root.left, low, high) else: return (root.val + range_sum_BST(root.left, low, high) + range_sum_BST(root.right, low, high))"},{"question":"You are given a string `s` consisting only of characters `\'a\'` and `\'b\'`. You can delete any character in the string. Deleting a character takes 1 unit of time. The goal is to make the string alternating, which means no two adjacent characters are the same. Return the minimum time needed to make the string alternating.","solution":"def min_time_to_alternate(s): Calculate the minimum time to make string s alternating. n = len(s) # Two patterns to compare: # pattern1: \\"ababab...\\" # pattern2: \\"babababa...\\" time1 = 0 # to make it like \\"ababab...\\" time2 = 0 # to make it like \\"bababab...\\" for i in range(n): if (i % 2 == 0 and s[i] != \'a\') or (i % 2 == 1 and s[i] != \'b\'): time1 += 1 if (i % 2 == 0 and s[i] != \'b\') or (i % 2 == 1 and s[i] != \'a\'): time2 += 1 return min(time1, time2)"},{"question":"Given an integer array `nums`, return the length of the longest increasing subsequence. A subsequence is a sequence derived from another sequence by deleting some or no elements without changing the order of the remaining elements. For example, given `nums = [10, 9, 2, 5, 3, 7, 101, 18]`, the longest increasing subsequence is `[2, 3, 7, 101]`, so your function should return its length, which is `4`.","solution":"def length_of_lis(nums): Returns the length of the longest increasing subsequence in nums. :param nums: List of integers :type nums: list :return: Length of the longest increasing subsequence :rtype: int if not nums: return 0 dp = [1] * len(nums) for i in range(1, len(nums)): for j in range(i): if nums[i] > nums[j]: dp[i] = max(dp[i], dp[j] + 1) return max(dp)"},{"question":"You are given a string `s`, which may contain lowercase letters and digits. You need to find the sum of all digits in the string and return it. If there are no digits in the string, return 0. For example, if `s = \\"abc1234def\\"`, then the sum of all digits is `1 + 2 + 3 + 4 = 10`, so you should return `10`. Implement a function that accomplishes this task.","solution":"def sum_of_digits(s): Returns the sum of all digits in the string s. return sum(int(char) for char in s if char.isdigit())"},{"question":"Given an array of integers `nums`, you are tasked with distributing these integers into two subsets `S1` and `S2` such that the absolute difference between the sum of the elements in `S1` and `S2` is minimized. Each integer in `nums` must be assigned to exactly one of the two subsets. Return the minimum possible value of the absolute difference between the sums. You may assume that the total number of integers in `nums` is less than or equal to 100.","solution":"def min_subset_sum_difference(nums): total_sum = sum(nums) n = len(nums) # The target is to check half of the total_sum target = total_sum // 2 # Initialize a dp array dp = [False] * (target + 1) dp[0] = True # Update the dp array for num in nums: for j in range(target, num - 1, -1): if dp[j - num]: dp[j] = True # Find the maximum j for which dp[j] is true for j in range(target, -1, -1): if dp[j]: return total_sum - 2 * j"},{"question":"You are given a string `s` consisting of lowercase English letters. Determine if you can reorder the characters in `s` to form a string that does not contain two adjacent characters that are the same. If such a reordering exists, return _one valid rearrangement_. If no such reordering exists, return an _empty string_. For example, if the string `s` was `\\"aab\\"`, a valid reordering would be `\\"aba\\"`, whereas for `s = \\"aaab\\"`, no reordering exists that fits the requirement. Simpler Example: - Input: `s = \\"aab\\"` - Output: `\\"aba\\"` Return one valid rearranged string if possible, or an empty string if not.","solution":"from collections import Counter import heapq def reorganize_string(s): Given a string s, return a reorganized string such that no two adjacent chars are the same. If no such arrangement is possible, return an empty string. # Count frequency of each character char_count = Counter(s) # Create a max heap based on character frequency max_heap = [(-freq, char) for char, freq in char_count.items()] heapq.heapify(max_heap) prev_char = None prev_freq = 0 result = [] while max_heap: freq, char = heapq.heappop(max_heap) result.append(char) if prev_freq < 0: heapq.heappush(max_heap, (prev_freq, prev_char)) prev_char = char prev_freq = freq + 1 # If the length of result isn\'t equal to input string\'s length, return empty string if len(result) != len(s): return \\"\\" return \\"\\".join(result)"},{"question":"A **chain** of characters is defined as a sequence of characters where each character is lexically greater than or equal to the previous character. Given a **0-indexed** list of strings `words`, return the length of the longest chain of characters that can be formed using any combination of strings and any order within those strings. Each character in the final chain must be picked from one of the strings in the list such that the resulting chain remains in non-decreasing order. Note that characters from the same string should be consecutive in the result.","solution":"def longest_chain(words): Returns the length of the longest chain of characters from the given list of strings. All characters in the longest chain must appear in non-decreasing order. :param words: List of strings :return: Integer length of the longest chain # Concatenate all words into one chain and sort it all_chars = \'\'.join(words) sorted_chars = sorted(all_chars) # The length of the sorted characters list is the length of the longest chain return len(sorted_chars)"},{"question":"Given an array of positive integers `arr`, determine if there exists a subset of `arr` whose elements add up to a given integer `sum`. Return `true` if such a subset exists, otherwise return `false`. Note: An empty subset of `arr` does not count towards the sum.","solution":"def subset_sum(arr, sum): Determines if there exists a subset of `arr` whose elements add up to `sum`. n = len(arr) dp = [[False] * (sum + 1) for _ in range(n + 1)] for i in range(n + 1): dp[i][0] = True for i in range(1, n + 1): for j in range(1, sum + 1): if arr[i - 1] <= j: dp[i][j] = dp[i - 1][j] or dp[i - 1][j - arr[i - 1]] else: dp[i][j] = dp[i - 1][j] return dp[n][sum]"},{"question":"You are given a string `s` representing a sequence of lowercase English letters. A **run-length encoded** version of the string is a string that can be constructed by concatenating groups of identical consecutive characters where each group is represented by the character followed by the count of its occurrences. For example, the run-length encoding of `\\"aaabbc\\"` is `\\"a3b2c1\\"`. Write a function that takes the string `s` and returns its run-length encoded version.","solution":"def run_length_encoding(s): Takes a string s and returns its run-length encoded version. if not s: return \\"\\" encoded_string = [] current_char = s[0] count = 1 for char in s[1:]: if char == current_char: count += 1 else: encoded_string.append(current_char + str(count)) current_char = char count = 1 # Append the last group encoded_string.append(current_char + str(count)) return \'\'.join(encoded_string)"},{"question":"You are given an integer array `heights` representing the heights of students standing in a line. A new student joins the back of the line. After joining, this student wishes to move to a position such that the sequence of students\' heights remains non-decreasing. Your task is to find the minimum number of moves the new student needs to make to achieve this. Implement the function `minMovesToSort` which takes an array `heights` and an integer `newStudentHeight` representing the height of the new student, and returns the minimum number of moves required for the new student to reach a valid position in the line. Realize that a move is defined as swapping the new student with any one of its adjacent students. The goal is to place the new student in the correct position such that the entire sequence of heights is sorted in non-decreasing order after these moves.","solution":"def minMovesToSort(heights, newStudentHeight): Returns the minimum number of moves required for the new student to reach a valid position in the line such that the sequence of students\' heights remains non-decreasing. heights.append(newStudentHeight) n = len(heights) # We start from the end of the list and move leftward position = n - 1 moves = 0 while position > 0 and heights[position - 1] > heights[position]: # Swap the new student with the previous student heights[position], heights[position - 1] = heights[position - 1], heights[position] position -= 1 moves += 1 return moves"},{"question":"You are given a rectangular grid with `n` rows and `m` columns filled with either `0` or `1`. Each cell within the grid can be traversed if it contains `1`, and it cannot be traversed if it contains `0`. Your task is to determine the minimum number of steps required to move from the top-left corner (0, 0) to the bottom-right corner (n-1, m-1) of the grid. You can move up, down, left, or right, but you cannot move diagonally. If it is impossible to reach the bottom-right corner, return `-1`. Formally, you need to implement the function `minSteps(grid: List[List[int]]) -> int` that returns the minimum number of steps needed or `-1` if the bottom-right corner is not reachable.","solution":"from typing import List from collections import deque def minSteps(grid: List[List[int]]) -> int: Returns the minimum number of steps required to reach the bottom-right corner from the top-left corner of the grid. If it is impossible to reach the bottom-right corner, returns -1. if not grid or not grid[0] or grid[0][0] == 0 or grid[-1][-1] == 0: return -1 n, m = len(grid), len(grid[0]) directions = [(1, 0), (0, 1), (-1, 0), (0, -1)] queue = deque([(0, 0)]) steps = 0 while queue: for _ in range(len(queue)): x, y = queue.popleft() if (x, y) == (n-1, m-1): return steps for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and grid[nx][ny] == 1: queue.append((nx, ny)) grid[nx][ny] = 0 # Mark as visited steps += 1 return -1"},{"question":"You are given a string `s` containing only digits. The string represents a very large number. Your task is to determine if it is possible to rearrange the digits of `s` such that the resulting number is divisible by 3. If it is possible, return _the rearranged number that is divisible by 3_. If multiple arrangements are possible, return the largest such number. If it\'s not possible, return -1.","solution":"def rearrange_to_divisible_by_3(s): Given a string s containing only digits, determine if it can be rearranged into a number that is divisible by 3. Return the largest possible such number or -1 if it\'s not possible. # Convert the string into a list of digits digits = [int(char) for char in s] # Sum of the digits digit_sum = sum(digits) # Check if sum of the digits is divisible by 3 if digit_sum % 3 != 0: return -1 # Sort digits in descending order to form the largest number possible digits.sort(reverse=True) # Join sorted digits and form the largest number largest_number = \'\'.join(map(str, digits)) return largest_number"},{"question":"You are given an `m x n` matrix where each cell contains an integer. Implement a class `SubmatrixSumFinder` with the following methods: * `SubmatrixSumFinder(matrix: List[List[int]])` Initializes the object with the matrix `matrix`. * `int sumRegion(row1: int, col1: int, row2: int, col2: int)` Returns the sum of all elements in the submatrix defined by its upper-left corner `(row1, col1)` and lower-right corner `(row2, col2)`. You should optimize the `sumRegion` method to be called frequently.","solution":"from typing import List class SubmatrixSumFinder: def __init__(self, matrix: List[List[int]]): if not matrix or not matrix[0]: raise ValueError(\\"Matrix cannot be empty\\") self.matrix = matrix self.m = len(matrix) self.n = len(matrix[0]) # Initialize the prefix sum matrix. self.prefix_sum = [[0] * (self.n + 1) for _ in range(self.m + 1)] # Calculate the prefix sum for each cell. for i in range(1, self.m + 1): for j in range(1, self.n + 1): self.prefix_sum[i][j] = (self.matrix[i - 1][j - 1] + self.prefix_sum[i - 1][j] + self.prefix_sum[i][j - 1] - self.prefix_sum[i - 1][j - 1]) def sumRegion(self, row1: int, col1: int, row2: int, col2: int) -> int: return (self.prefix_sum[row2 + 1][col2 + 1] - self.prefix_sum[row1][col2 + 1] - self.prefix_sum[row2 + 1][col1] + self.prefix_sum[row1][col1])"},{"question":"Given an integer array `nums`, move all zeros to the end of the array while maintaining the relative order of the non-zero elements. Implement a function that modifies the array in-place and returns nothing. For example, given `nums = [0, 1, 0, 3, 12]`, your function should modify `nums` to `[1, 3, 12, 0, 0]`.","solution":"def move_zeroes(nums): Moves all zeros in the list to the end while maintaining the order of non-zero elements. Modifies the list in-place and returns nothing. non_zero_index = 0 # pointer for non-zero elements # Iterate over the nums array for i in range(len(nums)): if nums[i] != 0: # Swap the elements nums[non_zero_index], nums[i] = nums[i], nums[non_zero_index] non_zero_index += 1"},{"question":"Given a `rows x cols` binary matrix filled with 0\'s and 1\'s, find the largest square containing only 1\'s and return its area. The matrix `matrix` is represented as a 2D list where `matrix[i][j]` is either \'0\' or \'1\'. You must solve this problem using dynamic programming for optimal performance.","solution":"def maximalSquare(matrix): Returns the area of the largest square containing only 1\'s in the binary matrix. if not matrix or not matrix[0]: return 0 max_side = 0 rows, cols = len(matrix), len(matrix[0]) dp = [[0] * (cols + 1) for _ in range(rows + 1)] for i in range(1, rows + 1): for j in range(1, cols + 1): if matrix[i - 1][j - 1] == \'1\': dp[i][j] = min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1 max_side = max(max_side, dp[i][j]) return max_side * max_side"},{"question":"You are given a **0-indexed** integer array `heights` representing the height of students in a line. You are also given an integer `limit` which represents the maximum allowable difference in height between any two consecutive students that can be swapped. Your task is to return _the minimum number of swaps needed to arrange the students in non-decreasing order of their height under the given constraint_.","solution":"from collections import deque def minSwapsToSort(heights, limit): n = len(heights) # Create an array of pairs where each pair is (height, index) height_and_index = [(heights[i], i) for i in range(n)] # Sort based on heights height_and_index.sort() visited = [False] * n swaps = 0 for i in range(n): if visited[i] or height_and_index[i][1] == i: continue cycle_size = 0 x = i while not visited[x]: visited[x] = True x = height_and_index[x][1] # Check the height difference constraint if cycle_size > 0 and abs(heights[i] - heights[height_and_index[x][1]]) > limit: return -1 cycle_size += 1 if cycle_size > 0: swaps += (cycle_size - 1) return swaps"},{"question":"Given a linked list, remove the `n`-th node from the end of the list and return its head. Ensure your algorithm uses only one pass through the list.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def remove_nth_from_end(head, n): Removes the n-th node from the end of the list and returns its head. :param head: ListNode - The head of the linked list. :param n: int - The position of the node counted from the end to be removed. :return: ListNode - The head of the modified linked list. dummy = ListNode(0, head) first = dummy second = dummy # Move first n+1 steps ahead for _ in range(n+1): first = first.next # Move both first and second until first reaches the end while first: first = first.next second = second.next # Remove the nth node from the end second.next = second.next.next return dummy.next"},{"question":"A palindrome is a string that reads the same forward and backward. Given an integer `n`, generate all possible strings of length `n` that are palindromes using lowercase English letters. Return the list of these palindromic strings in lexicographical order.","solution":"from itertools import product def generate_palindromes(n): Generates all palindrome strings of length n using lowercase English letters. Args: n (int): The length of the palindrome strings to generate. Returns: List[str]: A list of palindromic strings in lexicographical order. if n == 1: return [chr(i) for i in range(ord(\'a\'), ord(\'z\') + 1)] half_len = (n + 1) // 2 half_palindromes = product(\'abcdefghijklmnopqrstuvwxyz\', repeat=half_len) palindromes = [] for half in half_palindromes: if n % 2 == 0: palindrome = \'\'.join(half) + \'\'.join(half[::-1]) else: palindrome = \'\'.join(half) + \'\'.join(half[-2::-1]) palindromes.append(palindrome) return palindromes"},{"question":"Write a function that takes a string `s` and a pattern `p` as arguments and returns `True` if `s` matches the pattern `p`, otherwise returns `False`. The pattern can include wildcard characters: - `?` matches any single character. - `*` matches any sequence of characters (including the empty sequence). The function should handle the pattern matching efficiently. For example: - Input: `s = \\"adceb\\", p = \\"*a*b\\"` - Output: `True` - Explanation: The pattern `*a*b` matches the entire string \\"adceb\\".","solution":"def is_match(s, p): Returns True if the string `s` matches the pattern `p`, otherwise returns False. The pattern can include wildcard characters where: - `?` matches any single character. - `*` matches any sequence of characters (including the empty sequence). s_len, p_len = len(s), len(p) dp = [[False] * (p_len + 1) for _ in range(s_len + 1)] dp[0][0] = True for j in range(1, p_len + 1): if p[j - 1] == \'*\': dp[0][j] = dp[0][j - 1] for i in range(1, s_len + 1): for j in range(1, p_len + 1): if p[j - 1] == \'*\': dp[i][j] = dp[i][j - 1] or dp[i - 1][j] elif p[j - 1] == \'?\' or s[i - 1] == p[j - 1]: dp[i][j] = dp[i - 1][j - 1] return dp[s_len][p_len]"},{"question":"**[Question 4]:** Given a binary tree, implement a function to perform a **boundary traversal** of the tree. The boundary traversal should include the **left boundary**, followed by **leaves**, and then the **right boundary** in the reverse order. Nodes on the boundary should be included only once. For a node in the boundary, the **left boundary** is the path from the root to the left-most node and the **right boundary** is the path from the root to the right-most node. The leaves are the nodes which do not have any children. The binary tree has the following definition: ```cpp struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode() : val(0), left(nullptr), right(nullptr) {} TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} }; ``` Write a function `vector<int> boundaryTraversal(TreeNode* root)` that returns a list of integers representing the boundary traversal of the tree. If the root is `NULL`, it should return an empty list. You can assume: - The number of nodes in the tree is in the range `[1, 10^4]`. - `-10^4 <= Node.val <= 10^4`.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def boundaryTraversal(root): if not root: return [] def add_left_boundary(node, boundary): while node: if not is_leaf(node): boundary.append(node.val) if node.left: node = node.left else: node = node.right def add_right_boundary(node, boundary): stack = [] while node: if not is_leaf(node): stack.append(node.val) if node.right: node = node.right else: node = node.left while stack: boundary.append(stack.pop()) def add_leaves(node, leaves): if is_leaf(node): leaves.append(node.val) if node.left: add_leaves(node.left, leaves) if node.right: add_leaves(node.right, leaves) def is_leaf(node): return node.left is None and node.right is None boundary = [] if not is_leaf(root): boundary.append(root.val) if root.left: add_left_boundary(root.left, boundary) add_leaves(root, boundary) if root.right: add_right_boundary(root.right, boundary) return boundary"},{"question":"You are given an integer array `arr` of length `n` where `1 <= n <= 10^5` and `1 <= arr[i] <= 10^9`. You can perform the following operation at most `k` times where `k` is a given positive integer: - Select any element in the array and replace it with any positive integer. Your objective is to make the array strictly increasing with the minimum number of operations. Return the minimum number of operations required to achieve this, or -1 if it\'s not possible within the given `k` operations.","solution":"def min_operations_to_make_strictly_increasing(arr, k): n = len(arr) # Find the longest increasing subsequence (LIS) length in arr. lis_len = lis_length(arr) # Calculate the minimum number of operations needed min_operations = n - lis_len # If the minimum number of operations needed is less than or equal to k, return it. Otherwise, return -1. return min_operations if min_operations <= k else -1 def lis_length(arr): if not arr: return 0 # This will hold the increasing subsequence lis = [] for num in arr: # Use binary search to determine the position to replace in `lis` left, right = 0, len(lis) while left < right: mid = (left + right) // 2 if lis[mid] < num: left = mid + 1 else: right = mid # If left is within the lis array bounds, replace the element at `left` if left < len(lis): lis[left] = num else: # Otherwise, append the number to the lis array lis.append(num) # The length of `lis` is the length of the longest increasing subsequence return len(lis)"},{"question":"You are given a 2D grid of characters `board` and a string `word`. Return _true_ if `word` exists in the grid. The word can be constructed from letters of sequentially adjacent cells, where \\"adjacent\\" cells are horizontally or vertically neighboring. The same letter cell may not be used more than once. In your function, implement an efficient algorithm that explores all possible paths in the grid to find the word. Use backtracking to ensure you do not revisit any cell in the same search path.","solution":"def exist(board, word): if not board or not word: return False rows, cols = len(board), len(board[0]) def backtrack(r, c, index): if index == len(word): return True if r < 0 or r >= rows or c < 0 or c >= cols or board[r][c] != word[index]: return False tmp, board[r][c] = board[r][c], \'#\' found = (backtrack(r+1, c, index+1) or backtrack(r-1, c, index+1) or backtrack(r, c+1, index+1) or backtrack(r, c-1, index+1)) board[r][c] = tmp return found for row in range(rows): for col in range(cols): if backtrack(row, col, 0): return True return False"},{"question":"An island is represented by a `grid` of size `m x n`, where each cell can be `water` (represented by `0`) or `land` (represented by `1`). An island is considered a group of `1`s (land) connected **4-directionally** (horizontal or vertical). You may assume all four edges of the grid are surrounded by water. Your task is to find the size of the largest island. The size of an island is the number of land cells (`1`s) in that island. Write a function that takes the `grid` as input and returns the size of the largest island.","solution":"def largest_island(grid): Returns the size of the largest island in the given grid. if not grid or not grid[0]: return 0 m, n = len(grid), len(grid[0]) visited = [[False] * n for _ in range(m)] def dfs(i, j): if i < 0 or i >= m or j < 0 or j >= n or grid[i][j] == 0 or visited[i][j]: return 0 visited[i][j] = True return 1 + dfs(i + 1, j) + dfs(i - 1, j) + dfs(i, j + 1) + dfs(i, j - 1) max_island_size = 0 for i in range(m): for j in range(n): if grid[i][j] == 1 and not visited[i][j]: max_island_size = max(max_island_size, dfs(i, j)) return max_island_size"},{"question":"Write a function to find the shortest path between two nodes in an unweighted graph. The graph is represented as an adjacency list. Your function should take in the graph as a dictionary, the starting node, and the target node. Return a list of nodes representing the shortest path from the starting node to the target node. If no path exists, return an empty list.","solution":"from collections import deque def shortest_path(graph, start, target): Finds the shortest path in an unweighted graph using BFS. Parameters: graph (dict): The graph represented as an adjacency list. start (node): The starting node. target (node): The target node. Returns: list: A list of nodes representing the shortest path from start to target, if no path exists, returns an empty list. if start not in graph or target not in graph: return [] queue = deque([[start]]) visited = set([start]) while queue: path = queue.popleft() node = path[-1] if node == target: return path for neighbor in graph[node]: if neighbor not in visited: visited.add(neighbor) new_path = list(path) new_path.append(neighbor) queue.append(new_path) return []"},{"question":"Given a directed graph, represented as an adjacency list, determine if the graph contains a cycle. The graph is provided as a dictionary where the keys are nodes, and the values are lists of nodes that can be reached from the key node. Return `true` if the graph contains a cycle and `false` otherwise.","solution":"def contains_cycle(graph): Determines if the directed graph contains a cycle. Parameters: graph (dict): A dictionary representing the adjacency list of the graph. Returns: bool: True if the graph contains a cycle, False otherwise. def dfs(node, visited, rec_stack): visited.add(node) rec_stack.add(node) for neighbor in graph.get(node, []): if neighbor not in visited: if dfs(neighbor, visited, rec_stack): return True elif neighbor in rec_stack: return True rec_stack.remove(node) return False visited = set() rec_stack = set() for node in graph: if node not in visited: if dfs(node, visited, rec_stack): return True return False"},{"question":"Given an array of `n` integers, where each element represents the height of a building, return _the **maximum area** of a rectangle that can fit within the skyline formed by these buildings_. Heights are all positive integers. The width of each building is `1` unit. The skyline consists of contiguous bars. Find the largest rectangle that fits, considering the heights of the bars.","solution":"def largest_rectangle_area(heights): Calculate the maximum rectangle area in histogram represented by heights. :param heights: List[int] - list of heights of buildings :return: int - maximum rectangle area stack = [] max_area = 0 index = 0 while index < len(heights): if not stack or heights[stack[-1]] <= heights[index]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"You are given two integer arrays, `arr1` and `arr2`, each array is sorted in ascending order and consists of unique elements. Your task is to merge these arrays into a single sorted array such that the resulting array maintains the unique element property. Implement the function `mergeSortedArrays(int[] arr1, int[] arr2)` which merges `arr1` and `arr2` into a new sorted array. Return _the merged array_ where each element is **unique**.","solution":"def mergeSortedArrays(arr1, arr2): Merges two sorted arrays into one sorted array with unique elements. Parameters: arr1 (list of int): The first sorted array. arr2 (list of int): The second sorted array. Returns: list of int: A merged and sorted array with unique elements. merged_set = set(arr1).union(set(arr2)) merged_list = sorted(merged_set) return merged_list"},{"question":"Given an integer array `arr` representing the heights of students in a queue, you need to find the minimum number of students that must be moved to get a strictly increasing sequence from the start to the end of the queue. Each student\'s height is represented by an element in the array `arr[i]`, where `0 <= i < len(arr)`. Write a function `minStudentsToMove(arr)` that returns the minimum number of students to be moved to achieve the increasing order. For example, for the input `[4, 3, 2, 6, 5, 7]`, the function should return `3` since moving the students with heights `4, 3, and 2` to the end will result in the sequence `[6, 5, 7, 4, 3, 2]`, which is strictly increasing from the start.","solution":"def minStudentsToMove(arr): Returns the minimum number of students to move to get a strictly increasing sequence. The approach uses the length of the Longest Increasing Subsequence (LIS) since the minimum number of students to move is `len(arr) - length of LIS`. if not arr: return 0 n = len(arr) lis = [1] * n for i in range(1, n): for j in range(0, i): if arr[i] > arr[j]: lis[i] = max(lis[i], lis[j] + 1) return n - max(lis)"},{"question":"Given a string `sentence` containing only lowercase English letters and spaces, return the number of words that have at least one character repeated consecutively. A word is defined as a sequence of non-space characters. The function should handle the input string efficiently and return the correct count.","solution":"def count_repeated_consecutive_chars(sentence): Counts the number of words that have at least one character repeated consecutively. Args: sentence (str): Input string containing only lowercase English letters and spaces. Returns: int: Number of words with at least one character repeated consecutively. words = sentence.split() count_repeated = 0 for word in words: previous_char = \'\' for char in word: if char == previous_char: count_repeated += 1 break previous_char = char return count_repeated"},{"question":"You are managing a parking lot and need to implement a system to track the status of the parking slots. The parking lot contains `n` slots numbered from `1` to `n`. Implement a function to handle the following operations: 1. **Park a car**: Park a car in the nearest available slot to the entrance (slot `1`). 2. **Remove a car**: Remove a car from a given slot. 3. **Check status**: Check if a specific slot is available or occupied. Your task is to design a data structure that supports these operations efficiently. Implement the following methods: - `park()`: Parks a car in the nearest available slot and returns the slot number. - `remove(slot_number)`: Removes the car from the specified slot. If the slot is already empty, the method does nothing. - `check_status(slot_number)`: Checks if the specified slot is available. Returns `True` if the slot is available, `False` otherwise. Return the results of these operations as described.","solution":"import heapq class ParkingLot: def __init__(self, n): self.n = n self.available_slots = list(range(1, n + 1)) heapq.heapify(self.available_slots) self.occupied_slots = set() def park(self): if not self.available_slots: return None slot = heapq.heappop(self.available_slots) self.occupied_slots.add(slot) return slot def remove(self, slot_number): if slot_number in self.occupied_slots: self.occupied_slots.remove(slot_number) heapq.heappush(self.available_slots, slot_number) def check_status(self, slot_number): return slot_number not in self.occupied_slots"},{"question":"Given a binary tree represented as an array, where the parent-child relationship is defined such that, for a node at index `i`, its left child is at index `2*i + 1` and its right child is at index `2*i + 2`, determine if the tree is a valid binary search tree (BST). Assume the binary tree does not contain duplicate values. Return `true` if the tree is a valid BST, and `false` otherwise.","solution":"def is_valid_bst(arr): Determines if the given binary tree represented as an array is a valid BST. :param arr: List[int], a list of integers where arr represents a binary tree. :return: bool, True if the tree is a valid BST, False otherwise. def is_bst_util(index, left, right): if index >= len(arr) or arr[index] == None: return True if arr[index] <= left or arr[index] >= right: return False left_child_index = 2 * index + 1 right_child_index = 2 * index + 2 return (is_bst_util(left_child_index, left, arr[index]) and is_bst_util(right_child_index, arr[index], right)) return is_bst_util(0, float(\'-inf\'), float(\'inf\'))"},{"question":"You are given a `0-indexed` integer array `arr` of size `n`. A **partition index** is an index `i` such that the sum of the elements to the left of `i` (including `i`) is equal to the sum of elements to the right of `i`. Return _the partition index_ if it exists, otherwise return `-1`. If there are multiple partition indices, return the one with the smallest index.","solution":"def find_partition_index(arr): Returns the smallest partition index if it exists, otherwise returns -1. total_sum = sum(arr) left_sum = 0 for i, num in enumerate(arr): left_sum += num if left_sum * 2 == total_sum + num: return i return -1"},{"question":"Given a grid of size `m x n`, consisting of \'X\' and \'O\' characters, where \'X\' represents land and \'O\' represents water, return the number of distinct islands. An island is a group of connected \'X\'s (land), connected horizontally, vertically, or diagonally. You may assume all four edges of the grid are surrounded by water. An example input could look like this: ``` [ [\\"X\\",\\"O\\",\\"O\\",\\"X\\",\\"X\\"], [\\"X\\",\\"X\\",\\"O\\",\\"O\\",\\"X\\"], [\\"O\\",\\"X\\",\\"X\\",\\"O\\",\\"O\\"], [\\"O\\",\\"O\\",\\"O\\",\\"O\\",\\"X\\"] ] ``` In this example, there are 3 distinct islands.","solution":"def num_distinct_islands(grid): Returns the number of distinct islands in the given grid. def dfs(i, j): stack = [(i, j)] while stack: x, y = stack.pop() if 0 <= x < m and 0 <= y < n and grid[x][y] == \'X\': grid[x][y] = \'O\' # Mark the cell as visited # Explore all 8 possible directions (horizontally, vertically, and diagonally) directions = [(-1, 0), (1, 0), (0, -1), (0, 1), (-1, -1), (-1, 1), (1, -1), (1, 1)] for dx, dy in directions: stack.append((x + dx, y + dy)) if not grid or not grid[0]: return 0 m, n = len(grid), len(grid[0]) island_count = 0 for i in range(m): for j in range(n): if grid[i][j] == \'X\': island_count += 1 dfs(i, j) return island_count"},{"question":"You are given a **0-indexed** integer array `candies` representing the number of candies of different types. Each element `candies[i]` represents the number of candies of type `i`. You need to distribute these candies equally among `k` friends such that each friend receives the same number of candies of each type. Return _a boolean array_ `answer` where: * `answer[i]` is `true` if it is possible to distribute the candies of type `i` equally among the friends, else `answer[i]` is `false`. In other words, `answer[i]` is `true` if `candies[i] % k == 0`, otherwise it is `false`.","solution":"def can_distribute_candies(candies, k): Determines if each type of candy can be evenly distributed among k friends. Parameters: candies (list of int): List where candies[i] represents the number of candies of type i. k (int): Number of friends to distribute the candies to. Returns: list of bool: List where answer[i] is true if candies[i] can be evenly distributed among k friends, false otherwise. return [candy % k == 0 for candy in candies]"},{"question":"You are developing a file system that simulates a directory structure with folders and files. Implement a system that can simulate basic file browsing and file management operations. Each folder can contain files and other folders. Each file and folder has a name (a unique string). The operations that the system should support include: 1. `mkdir(path)`: Create a new directory at the specified `path`. If intermediate directories do not exist, they should be created. 2. `addContentToFile(filePath, content)`: Append the given `content` to the file located at `filePath`. If the file does not exist, it should be created. 3. `readContentFromFile(filePath)`: Read the entire content of the file located at `filePath`. 4. `ls(path)`: List the names of the files and directories in the directory specified by `path`. The list should be in lexicographical order. 5. `cd(path)`: Change the current directory to the one specified by `path`. Assume the following constraints: - The file system will only receive calls to the methods in a valid order, and there will not be any calls to read, write, or navigate to non-existing paths or files. Implement the `FileSystem` class with the above methods. Your implementation should ensure efficient file and directory management.","solution":"class FileSystem: def __init__(self): self.files = {} self.cur_dir = \'/\' def mkdir(self, path): dirs = path.split(\'/\') node = self.files for d in dirs: if d: if d not in node: node[d] = {} node = node[d] def addContentToFile(self, filePath, content): dirs = filePath.split(\'/\') node = self.files for d in dirs[:-1]: if d: if d not in node: node[d] = {} node = node[d] file_name = dirs[-1] if file_name in node: node[file_name] += content else: node[file_name] = content def readContentFromFile(self, filePath): dirs = filePath.split(\'/\') node = self.files for d in dirs[:-1]: if d: node = node[d] return node[dirs[-1]] def ls(self, path): dirs = path.split(\'/\') node = self.files for d in dirs: if d: node = node[d] if isinstance(node, str): return [dirs[-1]] return sorted(node.keys()) def cd(self, path): self.cur_dir = path"},{"question":"In a binary tree, a node is considered \\"good\\" if in the path from the root to that node, there are no nodes with a value greater than the value of that node. Given the `root` of a binary tree, return the number of \\"good\\" nodes in the tree. For example, given the binary tree represented as: ``` 3 / 1 4 / / 3 1 5 ``` The \\"good\\" nodes are the nodes with values [3, 4, 3, 5], because: - The root node (3) is always a \\"good\\" node. - The node with value 4 in the right subtree is \\"good\\" because 4 ≥ 3. - The node with value 3 in the left subtree is \\"good\\" because 3 ≥ 3 (itself). - The node with value 5 in the rightmost part of the tree is \\"good\\" because 5 > 4 and 5 > 3. Return the integer count of such \\"good\\" nodes.","solution":"# Definition for a binary tree node. class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def good_nodes(root): def dfs(node, max_val): if not node: return 0 # Determine if the current node is \\"good\\" is_good = node.val >= max_val total_good = 1 if is_good else 0 # Update the max value on this path new_max_val = max(max_val, node.val) # Continue the search on the left and right subtrees total_good += dfs(node.left, new_max_val) total_good += dfs(node.right, new_max_val) return total_good return dfs(root, root.val)"},{"question":"Given a string `s`, you need to **rotate** the string to the right by `k` places. For example, if `s = \\"abcdefg\\"` and `k = 3`, the rotated string would be `\\"efgabcd\\"`. Write a function that takes `s` and `k` as input parameters and returns the rotated string. Note that `k` can be greater than the length of `s`, so the function should handle such cases appropriately.","solution":"def rotate_string(s, k): Rotates the string s to the right by k places. if not s: return s k = k % len(s) # effective rotation return s[-k:] + s[:-k]"},{"question":"Given a string `s` consisting of lowercase alphabets, divide the string into as many parts as possible such that each letter appears in at most one part. Return _an array representing the length of each part_. It is guaranteed that the optimal solution is unique. For example, given the string `s = \\"ababcbacadefegdehijhklij\\"`, the output should be `[9, 7, 8]`, indicating the parts as `\\"ababcbaca\\"`, `\\"defegde\\"`, and `\\"hijhklij\\"`.","solution":"def partition_labels(s): Returns an array representing the lengths of parts divided by the rule that each letter appears in at most one part. last_index = {ch: idx for idx, ch in enumerate(s)} partitions = [] start, end = 0, 0 for idx, ch in enumerate(s): end = max(end, last_index[ch]) if idx == end: partitions.append(end - start + 1) start = idx + 1 return partitions"},{"question":"Given `n` non-negative integers representing the heights of a series of vertical bars, where the width of each bar is 1, compute how much water it is able to trap after raining. * For example, given `heights = [0,1,0,2,1,0,1,3,2,1,2,1]`, the output should be `6`. Return _the total trapped water volume_.","solution":"def trap(height): Returns the total amount of trapped water given the heights of the bars. if not height: return 0 n = len(height) left_max = [0] * n right_max = [0] * n left_max[0] = height[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], height[i]) right_max[n - 1] = height[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], height[i]) trapped_water = 0 for i in range(n): trapped_water += min(left_max[i], right_max[i]) - height[i] return trapped_water"},{"question":"You are given a matrix `mat` of dimensions `m x n` where each cell contains either a `0` or a `1`. You need to find the largest square that contains only `1`s and return its area. Write a function to identify this square based on the given matrix. **Example:** ``` Input: mat = [ [1, 0, 1, 0, 0], [1, 0, 1, 1, 1], [1, 1, 1, 1, 1], [1, 0, 0, 1, 0] ] Output: 4 ```","solution":"def maximal_square(matrix): if not matrix or not matrix[0]: return 0 rows, cols = len(matrix), len(matrix[0]) dp = [[0] * cols for _ in range(rows)] max_side = 0 for i in range(rows): for j in range(cols): if matrix[i][j] == 1: if i == 0 or j == 0: dp[i][j] = 1 else: dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1 max_side = max(max_side, dp[i][j]) return max_side * max_side"},{"question":"Given a string `s`, determine if it is a valid serialization of a binary tree. A valid serialization includes nodes and null markers represented by `#`, separated by commas. The tree is serialized in a pre-order manner. Return `True` if the given `s` is a valid serialization, otherwise return `False`. Example: - Input: \\"9,3,4,#,#,1,#,#,2,#,6,#,#\\" - Output: True - Input: \\"1,#\\" - Output: False","solution":"def isValidSerialization(s): Determine if a given string `s` is a valid preorder serialization of a binary tree. nodes = s.split(\',\') slots = 1 # we start with 1 slot to place the root for node in nodes: slots -= 1 # we occupy a slot for the current node if slots < 0: return False if node != \'#\': slots += 2 # non-null nodes generate two more slots return slots == 0"},{"question":"You are given a matrix `grid` of size `m x n` consisting of non-negative integers. Your task is to implement a class called `MaxSumPath` that helps to find the maximum sum of a path from the top-left cell to the bottom-right cell in the grid. You can only move either `right` or `down` at any point in time. Implement the `MaxSumPath` class: * `MaxSumPath(int[][] grid)` initializes the object with the integer matrix `grid`. * `int getMaxSumPath()` returns the maximum sum of a path from the top-left to the bottom-right cell in the grid. **Example:** ``` Input: grid = [ [5, 3, 2, 1], [1, 2, 10, 3], [4, 3, 2, 1] ] MaxSumPath maxSumPath = new MaxSumPath(grid); maxSumPath.getMaxSumPath(); // Returns 24 ```","solution":"class MaxSumPath: def __init__(self, grid): self.grid = grid self.m = len(grid) self.n = len(grid[0]) def getMaxSumPath(self): dp = [[0] * self.n for _ in range(self.m)] dp[0][0] = self.grid[0][0] for i in range(1, self.m): dp[i][0] = dp[i-1][0] + self.grid[i][0] for j in range(1, self.n): dp[0][j] = dp[0][j-1] + self.grid[0][j] for i in range(1, self.m): for j in range(1, self.n): dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + self.grid[i][j] return dp[self.m - 1][self.n - 1]"},{"question":"You are given an array of non-negative integers `nums` and an integer `target`. Each integer in `nums` represents the number of coins of that value. Determine the minimum number of coins required to make the `target` amount. If it is not possible to reach the target amount with the given coins, return `-1`. **Note:** Each type of coin can be used as many times as necessary. Return _an integer representing the minimum number of coins needed to make the `target` amount._","solution":"def min_coins(nums, target): Determine the minimum number of coins required to make the target amount. Args: nums (List[int]): List of non-negative integers representing coin values. target (int): Target amount. Returns: int: Minimum number of coins needed to make the target amount or -1 if it\'s not possible. if target == 0: return 0 # Initialize DP array with a large value (target + 1 is used here as a form of \\"infinity\\") dp = [target + 1] * (target + 1) dp[0] = 0 # Populate the dp array for coin in nums: for x in range(coin, target + 1): dp[x] = min(dp[x], dp[x - coin] + 1) return dp[target] if dp[target] != target + 1 else -1"},{"question":"You are given a **0-indexed** integer array `heights` representing the heights of buildings in a city from left to right. Each building is of width `1`. The rain will fill the space between the buildings from left to right. Return _an integer_ representing _the maximum amount of rainwater that can be trapped between the buildings._ For each building, every unit area of rainwater trapped is represented as `1`. The height of a building contributes to blocking the rainwater from either side.","solution":"def trap_rain_water(heights): Calculate the maximum amount of rainwater that can be trapped between the buildings. :param heights: List[int] - The heights of the buildings. :return: int - The maximum amount of rainwater that can be trapped. if not heights: return 0 n = len(heights) left_max = [0] * n right_max = [0] * n left_max[0] = heights[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], heights[i]) right_max[n - 1] = heights[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], heights[i]) trapped_water = 0 for i in range(n): trapped_water += min(left_max[i], right_max[i]) - heights[i] return trapped_water"},{"question":"Given two integers `start` and `end`, you need to transform the integer `start` to `end` by performing a series of operations. In each step, you can either: - Add 1 to the current integer. - Subtract 1 from the current integer. - Multiply the current integer by 2. - Divide the current integer by 2 (only if the current integer is even). Return the minimum number of operations required to transform `start` to `end`. If it is not possible to perform the transformation, return `-1`.","solution":"from collections import deque def min_operations(start, end): Return the minimum number of operations required to transform `start` to `end`. The operations allowed are: - Add 1 to the current integer. - Subtract 1 from the current integer. - Multiply the current integer by 2. - Divide the current integer by 2 (only if the current integer is even). if start == end: return 0 queue = deque([(start, 0)]) # (current value, number of steps) visited = set([start]) # To avoid revisiting nodes while queue: current, steps = queue.popleft() for next_value in (current + 1, current - 1, current * 2, current // 2 if current % 2 == 0 else current): if next_value == end: return steps + 1 if next_value not in visited: visited.add(next_value) queue.append((next_value, steps + 1)) return -1"},{"question":"You are given a list of integers `arr` and an integer `m`. You need to partition the list into at most `m` non-empty continuous subarrays. Let `dp(i, j)` be the maximum sum of the elements for the partition ending at index `i` and using exactly `j` subarrays. Your task is to determine the sum of the values in the `dp` table at the last index of `arr`. The goal is to find the minimum possible value of the largest sum among these partitions. Return _the minimum possible value of the largest sum among these partitions_.","solution":"def min_large_sum_partition(arr, m): Function to find the minimum possible value of the largest sum among these partitions. :param arr: List[int] - list of integers :param m: int - number of partitions :return: int - Minimum possible value of the largest sum among these partitions n = len(arr) if m >= n: return max(arr) def can_partition(max_sum): current_sum = 0 required_subarrays = 1 for num in arr: if current_sum + num <= max_sum: current_sum += num else: required_subarrays += 1 current_sum = num if required_subarrays > m: return False return True left, right = max(arr), sum(arr) while left < right: mid = (left + right) // 2 if can_partition(mid): right = mid else: left = mid + 1 return left"},{"question":"You are given a **0-indexed** 2D integer array `flights` and an **integer** `n` representing the number of cities. `flights[i] = [city1, city2, cost]` indicates that there is a direct flight from city `city1` to city `city2` with a cost of `cost`. You are also given an integer `src` representing your starting city, and an integer `dst` representing your destination city. Return _the **minimum cost** to travel from `src` to `dst`_, or `-1` if there is no way to reach `dst` from `src`.","solution":"import heapq def find_cheapest_flight(n, flights, src, dst): Returns the minimum cost to travel from src to dst. If there is no way to reach dst from src, returns -1. :param n: int - number of cities :param flights: List[List[int]] - list of flights [city1, city2, cost] :param src: int - starting city :param dst: int - destination city :return: int - minimum cost to reach dst from src, or -1 if unreachable graph = {i: [] for i in range(n)} for flight in flights: graph[flight[0]].append((flight[1], flight[2])) # Priority queue to store (cost, node) pq = [(0, src)] min_cost = {i: float(\'inf\') for i in range(n)} min_cost[src] = 0 while pq: current_cost, current_city = heapq.heappop(pq) if current_city == dst: return current_cost for neighbor, cost in graph[current_city]: next_cost = current_cost + cost if next_cost < min_cost[neighbor]: min_cost[neighbor] = next_cost heapq.heappush(pq, (next_cost, neighbor)) return -1 if min_cost[dst] == float(\'inf\') else min_cost[dst]"},{"question":"You are given an array of positive integers `arr` and an integer `k`. You can perform the following operation on the array: * Select any `k` consecutive elements from the array and remove them. Your task is to determine the minimum number of operations required to remove all elements from the array. If it\'s not possible to remove all elements using this operation, return `-1`.","solution":"def min_operations_to_remove_all(arr, k): length = len(arr) # If k is larger than length, it\'s impossible to remove all elements if k > length: return -1 # Number of operations is the ceiling of length divided by k # This is equivalent to (length + k - 1) // k # which ensures that any remainder still requires an additional operation operations = (length + k - 1) // k return operations"},{"question":"You have a **0-indexed** integer array `numbers` that is **initially sorted** in non-decreasing order. You have to write a function that searches for a given target number in the array. However, the array has been **rotated** at some pivot unknown to you beforehand. For example, the array `[0,1,2,4,5,6,7]` might become `[4,5,6,7,0,1,2]` after rotation. If the target is found in the array, return its index. Otherwise, return `-1`. You must write an algorithm with `O(log n)` runtime complexity.","solution":"def search_in_rotated_array(numbers, target): Performs a search in a rotated sorted array to find the target value. :param numbers: List[int] - A rotated sorted array :param target: int - The target value to be searched :return: int - The index of the target if found, otherwise -1 if not numbers: return -1 left, right = 0, len(numbers) - 1 while left <= right: mid = left + (right - left) // 2 if numbers[mid] == target: return mid # Determine the sorted half of the array if numbers[left] <= numbers[mid]: # Left half is sorted if numbers[left] <= target < numbers[mid]: right = mid - 1 else: left = mid + 1 else: # Right half is sorted if numbers[mid] < target <= numbers[right]: left = mid + 1 else: right = mid - 1 return -1"},{"question":"You are given a grid of size `m x n` consisting of non-negative integers representing the value in each cell. You are on the top-left cell (0, 0) and your goal is to reach the bottom-right cell (m-1, n-1), moving only down or to the right. Your aim is to maximize the sum of values on your path. Return the maximum sum you can obtain by following such a path.","solution":"def max_path_sum(grid): Calculate the maximum path sum from the top-left to the bottom-right of the grid. :param grid: List[List[int]], a 2D list representing the grid :return: int, the maximum sum of values from top-left to bottom-right if not grid or not grid[0]: return 0 m, n = len(grid), len(grid[0]) dp = [[0]*n for _ in range(m)] dp[0][0] = grid[0][0] # Fill the first row for j in range(1, n): dp[0][j] = dp[0][j-1] + grid[0][j] # Fill the first column for i in range(1, m): dp[i][0] = dp[i-1][0] + grid[i][0] # Fill the rest of the dp table for i in range(1, m): for j in range(1, n): dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j] return dp[m-1][n-1]"},{"question":"You are given a list of non-negative integers representing the amount of money of each house in a row. Each house can be robbed, but adjacent houses cannot be robbed on the same night due to security alarms connecting them. Return the maximum amount of money you can rob tonight without alerting the police.","solution":"def rob(houses): Computes the maximum amount of money that can be robbed without alerting the police. Args: houses (list): List of non-negative integers representing the amount of money in each house. Returns: int: Maximum amount of money that can be robbed. if not houses: return 0 n = len(houses) if n == 1: return houses[0] # Initialize the dp array dp = [0] * n dp[0] = houses[0] dp[1] = max(houses[0], houses[1]) for i in range(2, n): dp[i] = max(dp[i-1], dp[i-2] + houses[i]) return dp[-1]"},{"question":"Given a string `sequence` and an integer array `indices`, return a new string formed by inserting a space at each index in `indices`. The order of insertion should follow the order given in `indices`. Note that the given `indices` are valid and guaranteed to be in non-decreasing order.","solution":"def insert_spaces(sequence, indices): Inserts spaces at specified indices in the given sequence. Args: sequence (str): The original string. indices (list of int): The list of indices where spaces should be inserted. Returns: str: The new string with spaces inserted. result = [] last_index = 0 for index in indices: result.append(sequence[last_index:index]) result.append(\\" \\") last_index = index result.append(sequence[last_index:]) return \\"\\".join(result)"},{"question":"You are given an array of `n` integers, where each integer represents the height of a person in a line. A line is considered to be “out of order” if there are two people in a row such that the person on the left is taller than the person on the right. Your task is to calculate the minimum number of swaps required to make the line \\"in order\\" (sorted in non-decreasing order). Write a function that takes an array of heights and returns the minimum number of swaps needed to sort the array.","solution":"def min_swaps_to_sort(arr): Returns the minimum number of swaps required to sort the array in non-decreasing order. # Create a list of tuples where each tuple is (index, element) indexed_arr = list(enumerate(arr)) # Sort the array based on the elements indexed_arr.sort(key=lambda x: x[1]) visited = [False] * len(arr) swaps = 0 for i in range(len(arr)): # If already visited or already in the right place if visited[i] or indexed_arr[i][0] == i: continue # Find number of nodes in this cycle cycle_size = 0 j = i while not visited[j]: visited[j] = True j = indexed_arr[j][0] cycle_size += 1 # If there is cycle of size n, it will take (n-1) swaps to fix it if cycle_size > 0: swaps += (cycle_size - 1) return swaps"},{"question":"You are given the root of a binary tree, where each node contains an integer value. Implement a function `findLargestPathSum(root)` that returns the maximum sum of values from any path in the tree. A path is defined as any sequence of nodes from some starting node to any node in the tree along the parent-child connections. The path must contain at least one node and does not need to go through the root. Note that the path does not have to be from leaf to leaf.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def findLargestPathSum(root): def max_gain(node): nonlocal max_sum if not node: return 0 # Max sum on the left and right sub-trees of node left_gain = max(max_gain(node.left), 0) right_gain = max(max_gain(node.right), 0) # Price to start a new path where `node` is the highest node new_path_sum = node.val + left_gain + right_gain # Update max_sum if it\'s better to start a new path max_sum = max(max_sum, new_path_sum) # For recursion, return the max gain if continue the same path return node.val + max(left_gain, right_gain) max_sum = float(\'-inf\') max_gain(root) return max_sum"},{"question":"You are given a string `s` and a list of words `wordList`. The string `s` is formed by concatenating all the words in `wordList` in a random order, with each word used exactly once. Return _the original order of words in_ `wordList` _as they appear in the concatenated string_ `s`. The words in `wordList` are non-empty and sorted in lexicographical order. If multiple orders are possible, return **any valid order**.","solution":"def find_original_order(s, wordList): Finds the original order of words in the concatenated string s given a lexicographically sorted wordList. Parameters: - s (str): The concatenated string formed by randomly ordered words. - wordList (list): A list of words sorted in lexicographical order. Returns: - list: A list representing the original order of words as they appear in s. n = len(wordList) # Sort words in the order they appear in s sorted_words = sorted(wordList, key=lambda word: s.index(word)) return sorted_words"},{"question":"You are given an array of integers `arr` representing the heights of a row of buildings. The skyscrapers are situated such that they can rain and water can be trapped between them. Write a function to calculate the amount of water that can be trapped between the buildings after it rains. Each element in the array represents the height of the building at that index. Return _the total units of water that can be trapped between the buildings_.","solution":"def trap(height): Compute how much water can be trapped between the buildings after it rains. :param height: List[int] - List of integers representing height of buildings :return: int - Total units of water trapped if not height: return 0 n = len(height) left_max = [0] * n right_max = [0] * n water_trapped = 0 left_max[0] = height[0] for i in range(1, n): left_max[i] = max(left_max[i-1], height[i]) right_max[n-1] = height[n-1] for i in range(n-2, -1, -1): right_max[i] = max(right_max[i+1], height[i]) for i in range(n): water_trapped += min(left_max[i], right_max[i]) - height[i] return water_trapped"},{"question":"You are given a string `s` consisting of lowercase English letters and a word `word`. Your task is to return the number of times `word` appears as a subsequence within `s`. A subsequence is a sequence that can be derived from another sequence by deleting some or no elements without changing the order of the remaining elements.","solution":"def num_of_subsequences(s, word): Returns the number of times `word` appears as a subsequence within `s`. :param s: String consisting of lowercase English letters. :param word: String word to find as a subsequence within `s`. :return: Number of times `word` appears as a subsequence within `s`. m, n = len(s), len(word) if n == 0: return 1 dp = [0] * (n + 1) dp[0] = 1 for i in range(m): for j in range(n - 1, -1, -1): if s[i] == word[j]: dp[j + 1] += dp[j] return dp[n]"},{"question":"You are given an array of integers `arr` and an integer `x`. Find the **smallest** possible length of a contiguous subarray of which the sum is **equal to or greater than** `x`. If there isn\'t one, return `0` instead. For example, given `arr = [2, 3, 1, 2, 4, 3]` and `x = 7`, the minimum length subarray with sum at least `7` is `[4, 3]`, so the answer would be `2`. Return _the **length** of the smallest subarray satisfying the condition_. If no such subarray exists, return `0`.","solution":"def min_subarray_len(arr, x): Returns the length of the smallest contiguous subarray with sum at least x. If there isn\'t one, returns 0. n = len(arr) min_len = float(\'inf\') current_sum = 0 start = 0 for end in range(n): current_sum += arr[end] while current_sum >= x: min_len = min(min_len, end - start + 1) current_sum -= arr[start] start += 1 return min_len if min_len != float(\'inf\') else 0"},{"question":"You are given an integer array `logs` where each element represents the time a user logged in on a particular day. Each user can log in multiple times during the same day. You need to process these logs to find the **maximum span** of login times in a single day. The span is defined as the difference between the latest and earliest login time on that day. Return the **maximum span** of login times for any day in the given logs. If there are no multiple logins on any day, return 0.","solution":"from collections import defaultdict def max_login_span(logs): Returns the maximum span of login times on a single day. Args: logs (List[(int, int)]): A list of tuples where each tuple represents (day, time) of login. Returns: int: The maximum span of login times in a day. day_logs = defaultdict(list) for day, time in logs: day_logs[day].append(time) max_span = 0 for times in day_logs.values(): if len(times) > 1: times.sort() span = times[-1] - times[0] if span > max_span: max_span = span return max_span"},{"question":"You are given a 2D integer matrix `matrix` where rows are sorted in ascending order and columns are sorted in ascending order. Your task is to find an integer `target`. If `target` is found in the matrix, return its position as a tuple `(row_index, column_index)`. If `target` is not found, return `(-1, -1)`. The matrix may contain duplicated elements. Return the position of the first occurrence of the target.","solution":"def search_sorted_matrix(matrix, target): Searches for the target in a 2D sorted matrix (rows and columns sorted). Returns the position (row_index, column_index) if found, else (-1, -1). if not matrix or not matrix[0]: return (-1, -1) rows = len(matrix) cols = len(matrix[0]) for i in range(rows): for j in range(cols): if matrix[i][j] == target: return (i, j) return (-1, -1)"},{"question":"You are given two strings `s` and `t` consisting of only lowercase alphabet characters. Your task is to determine the minimum window substring in `s` that contains all the characters in `t` (including duplicates). If there is no such window in `s` that covers all characters in `t`, return an empty string. **Note:** If there are multiple answers, return the first occurring minimum window (i.e., the one with the smallest starting index).","solution":"from collections import Counter def min_window(s, t): if not t or not s: return \\"\\" dict_t = Counter(t) required = len(dict_t) filtered_s = [(i, char) for i, char in enumerate(s) if char in dict_t] l, r = 0, 0 formed = 0 window_counts = {} ans = float(\'inf\'), None, None while r < len(filtered_s): char = filtered_s[r][1] window_counts[char] = window_counts.get(char, 0) + 1 if window_counts[char] == dict_t[char]: formed += 1 while l <= r and formed == required: char = filtered_s[l][1] end = filtered_s[r][0] start = filtered_s[l][0] if end - start + 1 < ans[0]: ans = (end - start + 1, start, end) window_counts[char] -= 1 if window_counts[char] < dict_t[char]: formed -= 1 l += 1 r += 1 return \\"\\" if ans[0] == float(\'inf\') else s[ans[1]: ans[2] + 1]"},{"question":"Implement a data structure called `MyLinkedList` which simulates the behavior of a singly linked list. Your `MyLinkedList` class should provide the following methods: * `get(int index)` - Get the value of the `index-th` node in the linked list. If the index is invalid, return `-1`. * `addAtHead(int val)` - Add a node of value `val` before the first element of the linked list. After the insertion, the new node will be the first node of the linked list. * `addAtTail(int val)` - Append a node of value `val` to the last element of the linked list. * `addAtIndex(int index, int val)` - Add a node of value `val` before the `index-th` node in the linked list. If `index` equals the length of the linked list, the new node will be appended to the end of the linked list. If `index` is greater than the length, the node will not be inserted. * `deleteAtIndex(int index)` - Delete the `index-th` node in the linked list, if the index is valid. Keep in mind: - The indices are **zero-based**, meaning that the head corresponds to index `0`. - Each method should perform in constant time, if possible. - You must solve the problem without using the built-in linked list data structure provided by your programming language.","solution":"class MyLinkedList: class Node: def __init__(self, val=0, next=None): self.val = val self.next = next def __init__(self): self.head = None self.size = 0 def get(self, index): if index < 0 or index >= self.size: return -1 current = self.head for _ in range(index): current = current.next return current.val def addAtHead(self, val): new_node = self.Node(val, self.head) self.head = new_node self.size += 1 def addAtTail(self, val): new_node = self.Node(val) if self.size == 0: self.head = new_node else: current = self.head while current.next: current = current.next current.next = new_node self.size += 1 def addAtIndex(self, index, val): if index > self.size: return if index <= 0: self.addAtHead(val) elif index == self.size: self.addAtTail(val) else: new_node = self.Node(val) current = self.head for _ in range(index - 1): current = current.next new_node.next = current.next current.next = new_node self.size += 1 def deleteAtIndex(self, index): if index < 0 or index >= self.size: return current = self.head if index == 0: self.head = current.next else: for _ in range(index - 1): current = current.next current.next = current.next.next self.size -= 1"},{"question":"You are given a string `s` consisting only of characters `\'a\'`, `\'b\'`, and `\'c\'`. You can perform the following operation any number of times: choose an occurrence of the string `\\"ab\\"` and replace it with `\\"ba\\"`. Return _the lexicographically smallest string_ you can obtain after applying the operation any number of times. A string `x` is lexicographically smaller than a string `y` if in the first position where `x` and `y` differ, `x` has a character that comes earlier in the alphabet than the corresponding character in `y`.","solution":"def lexicographically_smallest_string(s): Returns the lexicographically smallest string by replacing occurrences of \\"ab\\" with \\"ba\\". # Continuously move \'a\' characters to the left in the presence of \'b\'. # This can be done by sorting part here to get the effect in O(nlogn) time. sorted_segments = \'\'.join(sorted(s)) return sorted_segments"},{"question":"You are given an integer array `nums` of size `n`, representing the positions of `n` stones in a row. Initially, there is a frog at the first stone (i.e., `nums[0]`). The frog wants to travel to the last stone (i.e., `nums[n-1]`). The frog can make a jump of any length `k` such that the jump length changes by at most 1 unit compared to the previous jump length. Return _true_ if the frog can reach the last stone, and _false_ otherwise. Note: 1. The frog\'s initial jump can be of any positive length. 2. The stones are sorted in a strictly increasing manner.","solution":"def can_cross(nums): if not nums: return False stone_positions = set(nums) dp = {x: set() for x in nums} # Dictionary to store reachable jumps for each stone dp[nums[0]].add(0) for stone in nums: for jump_length in dp[stone]: for k in [jump_length - 1, jump_length, jump_length + 1]: if k > 0 and stone + k in stone_positions: dp[stone + k].add(k) return bool(dp[nums[-1]])"},{"question":"You are given a 2D grid `grid` of size `m x n` where each cell is either a land cell (represented by `1`) or a water cell (represented by `0`). An island is a maximal 4-directionally connected group of land cells. Write a function `maxDistance` that returns the maximum distance between any water cell and the nearest land cell. The distance used in this problem is the Manhattan distance defined as `|x1 - x2| + |y1 - y2|`. If there is no land or if there is no water in the grid, return `-1`. Note: The grid contains at least one water cell and one land cell.","solution":"from collections import deque def maxDistance(grid): m, n = len(grid), len(grid[0]) queue = deque() directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] # Enqueue all land cells for i in range(m): for j in range(n): if grid[i][j] == 1: queue.append((i, j, 0)) if len(queue) == 0 or len(queue) == m * n: # No water or no land return -1 max_distance = -1 while queue: x, y, dist = queue.popleft() max_distance = max(max_distance, dist) for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] == 0: grid[nx][ny] = 1 # mark as visited queue.append((nx, ny, dist + 1)) return max_distance"},{"question":"Given a binary string `s`, return _the **count of contiguous substrings** that have the same number of `0`s and `1`s, and all the `0`s and all the `1`s in these substrings are grouped consecutively._ Substrings that occur multiple times are counted the number of times they occur.","solution":"def count_binary_substrings(s): Returns the count of contiguous substrings that have the same number of 0s and 1s, with all the 0s and all the 1s in these substrings grouped consecutively. if not s: return 0 counts = [] current_char = s[0] current_count = 0 for char in s: if char == current_char: current_count += 1 else: counts.append(current_count) current_char = char current_count = 1 counts.append(current_count) # append the last count result = 0 for i in range(1, len(counts)): result += min(counts[i - 1], counts[i]) return result"},{"question":"You are given a string `s` representing a sentence only containing digits and lower case English letters. Return the number of digits in the string that are greater than the average of all digits present in the string.","solution":"def digits_greater_than_average(s): Returns the number of digits in the string s that are greater than the average of all digits present in the string. digits = [int(ch) for ch in s if ch.isdigit()] if not digits: return 0 average = sum(digits) / len(digits) count = sum(1 for digit in digits if digit > average) return count"},{"question":"Given an array of integers `arr` representing a circle, return _the maximum sum of a contiguous subarray in the circular array_. A circular array means the end of the array wraps around to the beginning. For example, given `arr = [5, -3, 5]`, the maximum sum would be `10`, formed by the subarray `[5, 5]` which wraps around. Keep in mind different edge cases such as all negative numbers and singular array elements. Return the maximum subarray sum for the circular array.","solution":"def max_subarray_sum_circular(arr): def kadane(nums): local_max, global_max = nums[0], nums[0] for num in nums[1:]: local_max = max(num, local_max + num) global_max = max(global_max, local_max) return global_max total = sum(arr) max_kadane = kadane(arr) min_kadane = kadane([-x for x in arr]) max_wrap = total + min_kadane if max_wrap == 0: return max_kadane else: return max(max_kadane, max_wrap)"},{"question":"Given an array of integers `nums` and an integer `target`, determine if there are three distinct integers in the array that sum up to the `target`. Return _a 2D array containing all unique triplets_ `(nums[i], nums[j], nums[k])` such that their sum is equal to `target`. Each triplet should be sorted in ascending order, and the solution set must not contain duplicate triplets. If no such triplets exist, return an empty list. For example, if `nums` is `[-1, 0, 1, 2, -1, -4]` and `target` is `0`, the function should return `[[-1, -1, 2], [-1, 0, 1]]`.","solution":"def three_sum(nums, target): Given an array of integers nums and an integer target, determine if there are three distinct integers in the array that sum up to the target. Return a 2D array containing all unique triplets (nums[i], nums[j], nums[k]) such that their sum is equal to the target. :param nums: List of integers. :param target: integer target value. :return: List of unique triplets that sum up to the target. nums.sort() result = [] length = len(nums) for i in range(length - 2): if i > 0 and nums[i] == nums[i - 1]: continue left, right = i + 1, length - 1 while left < right: current_sum = nums[i] + nums[left] + nums[right] if current_sum == target: result.append([nums[i], nums[left], nums[right]]) while left < right and nums[left] == nums[left + 1]: left += 1 while left < right and nums[right] == nums[right - 1]: right -= 1 left += 1 right -= 1 elif current_sum < target: left += 1 else: right -= 1 return result"},{"question":"You are given two strings `s1` and `s2`. Your task is to determine if `s1` is an anagram of `s2`. Two strings are considered anagrams if and only if they contain the same characters in the same frequency. Return `True` if `s1` and `s2` are anagrams, otherwise return `False`. Note that the strings are case-insensitive and might contain spaces.","solution":"def are_anagrams(s1, s2): Determines if s1 and s2 are anagrams (case-insensitive and ignoring spaces). # Remove spaces and convert to lowercase s1 = s1.replace(\\" \\", \\"\\").lower() s2 = s2.replace(\\" \\", \\"\\").lower() # Check if the sorted characters of both strings are the same return sorted(s1) == sorted(s2)"},{"question":"You are given a list of `n` integers, `arr`, and an integer `x`. Your task is to partition the list into two subsets such that the absolute difference between their sums is minimized. Return the minimum possible absolute difference.","solution":"def min_subset_sum_difference(arr, n, x): # Calculate total sum of elements total_sum = sum(arr) # Initialize DP table dp = [[False for _ in range(total_sum + 1)] for _ in range(n + 1)] # Populate the partition table dp[][] for i in range(n + 1): dp[i][0] = True for i in range(1, n + 1): for j in range(1, total_sum + 1): dp[i][j] = dp[i-1][j] if arr[i-1] <= j: dp[i][j] = dp[i][j] or dp[i-1][j-arr[i-1]] # Find the maximum j such that dp[n][j] is true where j loops from 0 to total_sum/2 diff = float(\'inf\') for j in range(total_sum // 2, -1, -1): if dp[n][j] == True: diff = total_sum - 2 * j break return diff"},{"question":"Given a list of integers `numbers` and an integer `threshold`, return the **maximum length** of a contiguous subarray where the sum of the elements in the subarray is less than or equal to `threshold`. For example: - For `numbers = [1, 2, 3, 4, 5]` and `threshold = 10`, the maximum length is 4 because the subarray `[1, 2, 3, 4]` has a sum of 10 which meets the condition. - For `numbers = [1, 1, 1, 1, 1]` and `threshold = 3`, the maximum length is 3 because the subarray `[1, 1, 1]` has a sum of 3 which meets the condition.","solution":"def max_length_subarray(numbers, threshold): Returns the maximum length of a contiguous subarray where the sum of the elements in the subarray is less than or equal to the given threshold. n = len(numbers) max_length = 0 current_sum = 0 start = 0 for end in range(n): current_sum += numbers[end] while current_sum > threshold: current_sum -= numbers[start] start += 1 max_length = max(max_length, end - start + 1) return max_length"},{"question":"Given an integer array `arr`, return the length of the **longest contiguous subarray** that contains at most two distinct integers. The contiguous subarray is a subarray of a larger array that is continuous in terms of index positions. Your function should efficiently find this length by iterating through the array and tracking the elements within the current window of inspection using appropriate data structures. **Example:** ```python arr = [1, 2, 1, 2, 3, 4, 3] ``` In this example, the longest contiguous subarray that contains at most two distinct integers is `[1, 2, 1, 2]` which has a length of 4. Therefore, your function should return 4.","solution":"def length_of_longest_subarray(arr): Returns the length of the longest contiguous subarray that contains at most two distinct integers in the given array `arr`. max_length = 0 left = 0 count = {} for right in range(len(arr)): count[arr[right]] = count.get(arr[right], 0) + 1 while len(count) > 2: count[arr[left]] -= 1 if count[arr[left]] == 0: del count[arr[left]] left += 1 max_length = max(max_length, right - left + 1) return max_length"},{"question":"Given an array of integers `nums` and an integer `target`, return _the number of combinations that add up to `target` using the numbers in `nums`_. You may use each number in `nums` as many times as needed. The order of the numbers in the combination matters (i.e., `[1, 3]` and `[3, 1]` are treated as different combinations).","solution":"def combinationSum4(nums, target): Returns the number of combinations that add up to target using the numbers in nums. You may use each number in nums as many times as needed. dp = [0] * (target + 1) dp[0] = 1 for i in range(1, target + 1): for num in nums: if i >= num: dp[i] += dp[i - num] return dp[target]"},{"question":"Given a string `s` consisting of lowercase letters, you need to determine the minimum number of operations required to move all characters of the same type together. In one operation, you can take any character from the string and place it at any position within the string. Return the minimum number of operations needed to group all identical characters together.","solution":"def min_operations_to_group_chars(s): from collections import Counter if len(s) < 2: return 0 char_freq = Counter(s) max_freq = max(char_freq.values()) return len(s) - max_freq"},{"question":"You are given a list of integers `arr` where each integer represents the height of a vertical line on a coordinate plane. These lines are positioned such that the `i-th` line is at `(i, arr[i])`. A pair of lines forms a container that contains the most water if the width (distance between the lines) times the smaller of the two heights is maximum. Return _the maximum amount of water that can be contained_.","solution":"def max_area(height): Returns the maximum amount of water that can be contained by any two lines from the height array. left, right = 0, len(height) - 1 max_water = 0 while left < right: # Calculate the width and height of the container width = right - left min_height = min(height[left], height[right]) # Calculate the area of the container current_water = width * min_height # Update the maximum water contained if current water is greater if current_water > max_water: max_water = current_water # Move the pointer which is at the shorter line inward if height[left] < height[right]: left += 1 else: right -= 1 return max_water"},{"question":"You are given a **0-indexed** integer array `arr`. You need to identify the **longest** possible **bitonic subsequence** in `arr`. A **bitonic subsequence** is a subsequence which first increases and then, after reaching a maximum value, decreases. Note that the subsequence may also be **strictly increasing** or **strictly decreasing**. Return _the length of the **longest bitonic subsequence**_. A **subsequence** of an array is a new array generated from the original array by deleting some elements (possibly none) without changing the remaining elements\' relative order. For example, the longest bitonic subsequence in `[1, 2, 5, 3, 2]` is `[1, 2, 5, 3, 2]` with length `5`.","solution":"def longest_bitonic_subsequence(arr): Returns the length of the longest bitonic subsequence in the array. n = len(arr) if n == 0: return 0 # Initialize the increasing and decreasing subsequences inc = [1] * n dec = [1] * n # Fill increasing subsequence array for i in range(1, n): for j in range(i): if arr[i] > arr[j]: inc[i] = max(inc[i], inc[j] + 1) # Fill decreasing subsequence array for i in range(n - 2, -1, -1): for j in range(n - 1, i, -1): if arr[i] > arr[j]: dec[i] = max(dec[i], dec[j] + 1) # The length of longest bitonic subsequence is the max value of (inc[i] + dec[i] - 1) max_length = 0 for i in range(n): max_length = max(max_length, inc[i] + dec[i] - 1) return max_length"},{"question":"Consider a directed graph represented by an adjacency list, where `graph[i]` is a list of all nodes `i` points to. A node is considered a **safe node** if every possible path starting from that node has no cycles. In other words, a node is safe if and only if all paths starting from it eventually end at a terminal node (a node with no outgoing edges). Write a function that returns a list of all **safe nodes** in the graph, sorted in ascending order. [ text{Example:} ] [ text{Input: } graph = [[1,2],[2,3],[5],[0],[5],[],[]] ] [ text{Output: } [2,4,5,6] ] [ text{Explanation: } - Node 5 and 6 are terminal nodes. - All paths from node 2 lead to terminal nodes (either directly to node 5 or to node 5 via node 4). - Similarly, all paths from node 4 lead to terminal nodes (directly to node 5). - Node 3 leads to node 0, which is not safe, making node 3 unsafe. - Node 0 points to node 1 and node 2; since node 1 leads to node 3 which is unsafe, node 0 is also unsafe. - Node 1 also leads to node 3 which is unsafe, making node 1 unsafe. Therefore, the safe nodes, in ascending order, are [2,4,5,6].","solution":"def eventualSafeNodes(graph): Returns a list of all safe nodes in the graph, sorted in ascending order. n = len(graph) safe = [False] * n visited = [False] * n in_recursion_stack = [False] * n def isSafe(node): if safe[node]: return True if in_recursion_stack[node]: return False in_recursion_stack[node] = True for neighbor in graph[node]: if not isSafe(neighbor): return False in_recursion_stack[node] = False safe[node] = True return True for i in range(n): if not visited[i]: visited[i] = isSafe(i) return [i for i in range(n) if safe[i]]"},{"question":"Given a string `s` and an integer `k`, partition the string into contiguous substrings such that each substring contains at most `k` distinct characters. Return _the minimum number of substrings needed to achieve this._","solution":"def min_partitions(s, k): Given a string s and an integer k, partitions the string into contiguous substrings such that each substring contains at most k distinct characters. Returns the minimum number of substrings needed to achieve this. :param s: str, input string :param k: int, maximum distinct characters allowed in each substring :return: int, minimum number of substrings if k == 0: return 0 substr_count = 0 start = 0 while start < len(s): end = start distinct_chars = set() while end < len(s) and (len(distinct_chars) < k or (len(distinct_chars) == k and s[end] in distinct_chars)): distinct_chars.add(s[end]) end += 1 substr_count += 1 start = end return substr_count"},{"question":"You are given a string `s` and a string `t`. You can select any set of characters from `s` (including an empty set) and rearrange them to form a subsequence of `t`. Your task is to determine the length of the longest subsequence of `t` that can be formed this way. Implement the function `int longestSubsequence(String s, String t)` that returns the length of this subsequence.","solution":"def longestSubsequence(s, t): Returns the length of the longest subsequence of `t` that can be formed by re-arranging characters of `s`. from collections import Counter # Count occurrences of each character in s and t s_count = Counter(s) t_count = Counter(t) # Determine the maximum length subsequence possible len_subsequence = 0 for char in t_count: if char in s_count: len_subsequence += min(s_count[char], t_count[char]) return len_subsequence"},{"question":"You are given a string `s` and a string `pattern`. You have to determine whether `s` can be transformed into `pattern` by reordering its characters. More formally, return `True` if the characters of `s` can be rearranged to form the string `pattern`, and `False` otherwise. Consider all characters to be lowercase alphabets. The length of both strings will be the same. Strings `s` and `pattern` consist of only lowercase English letters.","solution":"def can_transform(s, pattern): Returns True if the characters of s can be rearranged to form the string pattern, False otherwise. return sorted(s) == sorted(pattern)"},{"question":"A programming competition organizer intends to publish rankings based on the submitted solutions\' execution times. You are given a list of execution times where `times[i]` represents the time taken (in milliseconds) to execute the solution submitted by participant `i`. Your task is to determine the ranking of each participant, where the rank is defined based on the execution time in ascending order. Participants with lower execution times should have a higher rank (i.e., rank of 1 is assigned to the participant with the least execution time). In case of participants with identical execution times, assign them the same rank. Then, you should reassign subsequent ranks to accommodate the ties. For example, if the minimum execution time occurs twice for the first rank, the next rank would be `3` rather than `2`. Given the array `times`, return an array where the `i-th` element represents the rank of the participant `i`.","solution":"def rank_participants(times): Return the ranks of participants based on their execution times. Parameters: times (List[int]): List of execution times where times[i] is the execution time of participant i. Returns: List[int]: List of ranks where the i-th element is the rank of the participant i. sorted_times = sorted((time, idx) for idx, time in enumerate(times)) ranks = [0] * len(times) current_rank = 1 for i in range(len(times)): if i == 0 or sorted_times[i][0] != sorted_times[i - 1][0]: current_rank = i + 1 ranks[sorted_times[i][1]] = current_rank return ranks"},{"question":"Given an integer array `arr` of size `n` and an integer `k`, your task is to determine the maximum possible sum of a non-empty subarray of `arr` such that no two elements within this subarray have a difference greater than `k`. A subarray is a contiguous part of the array. Return _the maximum sum of a valid subarray that meets the condition_.","solution":"def maximum_subarray_with_k(arr, k): if not arr: return 0 n = len(arr) max_sum = float(\'-inf\') current_sum = 0 for i in range(n): if i == 0 or abs(arr[i] - arr[i - 1]) <= k: current_sum += arr[i] else: current_sum = arr[i] max_sum = max(max_sum, current_sum) return max_sum"},{"question":"[Question] 4: You are given a `m x n` grid filled with an infinite supply of unit cubes. The grid represents a 3D model where each cell holds height `h` unit cubes stacked on top of each other. Write a function that calculates the total surface area of the 3D shape represented by the grid. The surface area is the sum of the area of all the exposed unit cube faces. The surface area of the shape is calculated by adding up the area of all the exposed faces of the cubes that are not covered by other cubes. Note: 1. Each cell `grid[i][j]` represents the height `h` of the stack at the position `(i, j)`. An empty cell has height `0`. 2. Only the top, bottom, and four side faces of each cube are considered. The height of a cube\'s side face is always `1` unit. 3. If two cubes are adjacent, the face between them is not exposed. Calculate and return the total surface area of the 3D shape.","solution":"def surfaceArea(grid): Calculate the total surface area of the 3D shape represented by the grid. :param grid: List[List[int]]: A 2D list representing the height of the stacks of cubes :return: int: The total surface area of the 3D shape m, n = len(grid), len(grid[0]) total_surface_area = 0 for i in range(m): for j in range(n): if grid[i][j] > 0: # Add the top and bottom faces total_surface_area += 2 # Add the sides # Check the current cell height and compare it to the neighboring cells # Front (i-1) total_surface_area += grid[i][j] if i == 0 else max(grid[i][j] - grid[i-1][j], 0) # Back (i+1) total_surface_area += grid[i][j] if i == m-1 else max(grid[i][j] - grid[i+1][j], 0) # Left (j-1) total_surface_area += grid[i][j] if j == 0 else max(grid[i][j] - grid[i][j-1], 0) # Right (j+1) total_surface_area += grid[i][j] if j == n-1 else max(grid[i][j] - grid[i][j+1], 0) return total_surface_area"},{"question":"You are given an integer array `scores` representing the scores of athletes in a competition. Your task is to assign ranks to the athletes based on their scores, where the highest score gets rank 1, the second highest gets rank 2, and so on. However, if two athletes have the same score, they receive the same rank, and the next rank is skipped. For example, if the scores are `[100, 90, 90, 80]`, the ranks would be `[1, 2, 2, 4]`. Given the array `scores`, return an array of integers representing the ranks of each athlete in the order they appear in `scores`.","solution":"def calculate_ranks(scores): Given an array of scores, return an array of ranks based on the scores. sorted_scores = sorted(((score, idx) for idx, score in enumerate(scores)), reverse=True) ranks = [0] * len(scores) current_rank = 1 for i, (score, idx) in enumerate(sorted_scores): if i > 0 and score == sorted_scores[i - 1][0]: ranks[idx] = ranks[sorted_scores[i - 1][1]] else: ranks[idx] = current_rank current_rank += 1 return ranks"},{"question":"You are given a **0-indexed** integer array `ratings` of size `n`, where `ratings[i]` represents the performance rating of the `ith` employee. Each employee is to receive a bonus in the form of additional points based on their performance rating relative to their neighbors. The following rules must be followed: - Each employee must receive at least `1` bonus point. - Any employee with a higher rating than their immediate neighbor(s) must receive more bonus points than those neighbors. Return _the minimum number of bonus points required to distribute among the employees following the above rules._","solution":"def min_bonus(ratings): n = len(ratings) if n == 0: return 0 bonus = [1] * n # First pass from left to right for i in range(1, n): if ratings[i] > ratings[i - 1]: bonus[i] = bonus[i - 1] + 1 # Second pass from right to left for i in range(n - 2, -1, -1): if ratings[i] > ratings[i + 1]: bonus[i] = max(bonus[i], bonus[i + 1] + 1) return sum(bonus)"},{"question":"You are given a **binary tree** and you need to carry out several queries on it. The binary tree is represented by its root node, and each node has a value, `val`, and two children `left` and `right`, which can be `null`. Each query consists of a single value, `v`, and you need to determine whether there exists a **root-to-leaf** path in the tree such that the sum of the path equals `v`. A **root-to-leaf** path is a path starting from the root and ending at any leaf node. The sum of the path is the sum of the values of all the nodes along the path. You need to return an array of boolean values where each boolean indicates whether the corresponding query value exists as a root-to-leaf path sum in the tree. Write a function `pathSumQueries` that takes the root of the binary tree and an array of query values, and returns an array of booleans indicating the presence of each sum in the tree paths. Example: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def pathSumQueries(root: TreeNode, queries: List[int]) -> List[bool]: # Your code goes here ```","solution":"from typing import List, Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def pathSumQueries(root: TreeNode, queries: List[int]) -> List[bool]: def has_path_sum(node: TreeNode, target_sum: int) -> bool: if not node: return False if not node.left and not node.right: return node.val == target_sum new_sum = target_sum - node.val return has_path_sum(node.left, new_sum) or has_path_sum(node.right, new_sum) results = [] for query in queries: results.append(has_path_sum(root, query)) return results"},{"question":"Given an array of integers `arr` sorted in non-decreasing order, return an array of the squares of each number, also sorted in non-decreasing order.","solution":"def sorted_squares(arr): Given a list of integers sorted in non-decreasing order, returns a list of the squares of each number, also sorted in non-decreasing order. result = [x ** 2 for x in arr] result.sort() return result"},{"question":"Given an array of integers `arr`, return the length of the longest contiguous subarray such that every number in this subarray appears at least twice within this subarray. If no such subarray exists, return `0`.","solution":"def longest_subarray_with_duplicates(arr): Returns the length of the longest contiguous subarray such that every number in this subarray appears at least twice within the subarray. n = len(arr) max_len = 0 left = 0 while left < n: freq = {} right = left while right < n: freq[arr[right]] = freq.get(arr[right], 0) + 1 # Check if all elements in the current window appear at least twice if all(val >= 2 for val in freq.values()): max_len = max(max_len, right - left + 1) right += 1 left += 1 return max_len"},{"question":"You are given a list of `n` strings, `dictionary`, where each string represents a valid word. You are also provided with a string `sentence` composed of lowercase alphabets and spaces. Your task is to implement a function that converts the first occurrence of each possible prefix of each word in the `sentence` to its shortest possible root word from the `dictionary`. The root word is identified as the shortest word in `dictionary` which is a prefix of a word in the `sentence`. Familiarize yourself with the prefix concept where a string `s1` is a prefix of a string `s2` if `s2` starts with `s1`. Return the modified sentence after replacing each word\'s prefix. If no root word can replace a word, leave the word unchanged in the `sentence`.","solution":"def replaceWords(dictionary, sentence): Converts the first occurrence of each possible prefix of each word in the sentence to its shortest possible root word from the dictionary. Parameters: dictionary (list of str): A list of valid root words. sentence (str): A string composed of words separated by spaces. Returns: str: Modified sentence with words replaced by their shortest root word prefix. dictionary = sorted(dictionary, key=len) def replace_root(word): for root in dictionary: if word.startswith(root): return root return word words = sentence.split() transformed_words = [replace_root(word) for word in words] return \' \'.join(transformed_words)"},{"question":"Given a 2D grid of size `m x n` where each cell can either be `0` (empty) or `1` (blocked), find the length of the shortest path from the top-left corner `(0, 0)` to the bottom-right corner `(m-1, n-1)` by moving up, down, left, or right. If such a path does not exist, return `-1`. The path cannot cross any cells that contain a `1`.","solution":"from collections import deque def shortest_path(grid): Returns the length of the shortest path from the top-left corner to the bottom-right corner in a grid, or -1 if no such path exists. # Helper function to check if a cell is within bounds and is not blocked def is_valid(x, y): return 0 <= x < m and 0 <= y < n and grid[x][y] == 0 m, n = len(grid), len(grid[0]) # If the start or end point is blocked, return -1 if grid[0][0] == 1 or grid[m-1][n-1] == 1: return -1 # Directions array for moving in all 4 directions (right, down, left, up) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] # Queue to perform BFS, and a set to track visited cells queue = deque([(0, 0, 1)]) # (row, column, distance) visited = set((0, 0)) while queue: x, y, dist = queue.popleft() # If we reached the bottom-right corner if x == m-1 and y == n-1: return dist # Explore all possible directions for dx, dy in directions: nx, ny = x + dx, y + dy if is_valid(nx, ny) and (nx, ny) not in visited: queue.append((nx, ny, dist + 1)) visited.add((nx, ny)) return -1 # If no path is found"},{"question":"Given the `root` of a binary tree, return the maximum level sum among all levels of the tree. The level sum is the sum of node values at each level of the binary tree.","solution":"from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def maxLevelSum(root): Returns the maximum level sum of the binary tree. if not root: return 0 max_sum = float(\'-inf\') queue = deque([(root, 1)]) current_level = 1 current_sum = 0 while queue: node, level = queue.popleft() if level > current_level: max_sum = max(max_sum, current_sum) current_sum = 0 current_level = level current_sum += node.val if node.left: queue.append((node.left, level + 1)) if node.right: queue.append((node.right, level + 1)) max_sum = max(max_sum, current_sum) return max_sum"},{"question":"You are given a binary tree with `n` nodes. Each node is assigned a unique integer value from `1` to `n`. You are also given a list of queries, where each query contains a pair of integers `(a, b)` representing two nodes in the tree. For each query, determine the length of the shortest path between nodes `a` and `b` in terms of the number of edges. Return an array of the shortest path lengths for each query.","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def build_tree(edges): from collections import defaultdict nodes = {} for u, v in edges: if u not in nodes: nodes[u] = TreeNode(u) if v not in nodes: nodes[v] = TreeNode(v) # Assuming the tree doesn\'t specify left/right directly in edges. if not nodes[u].left: nodes[u].left = nodes[v] else: nodes[u].right = nodes[v] # returning the root (assuming it\'s node 1) return nodes[1] def find_shortest_paths(root, queries): from collections import deque def bfs(root): queue = deque([(root, None)]) parent = {root.val: None} depth = {root.val: 0} while queue: node, par = queue.popleft() if node: if par is not None: parent[node.val] = par depth[node.val] = depth[par] + 1 if node.left: queue.append((node.left, node.val)) if node.right: queue.append((node.right, node.val)) return parent, depth parent, depth = bfs(root) def get_lca(a, b): while a != b: if depth[a] > depth[b]: a = parent[a] else: b = parent[b] return a def get_path_length(a, b): lca = get_lca(a, b) return depth[a] + depth[b] - 2 * depth[lca] results = [] for a, b in queries: results.append(get_path_length(a, b)) return results"},{"question":"Write a function that evaluates the dice game **\\"Greed\\"**. You are given an array of integers representing five dice rolls, `dice`. The scoring rules are as follows: - A roll of `1` is worth 100 points. - A roll of `5` is worth 50 points. - Three `1`s add 1000 points to the total score. - Three of any other number `n` add `n * 100` points to the total score (for example, three `4`s add 400 points). Other rolls are worth 0 points if they do not match any of the criteria above. Return _the total score for the given dice rolls._ **Examples:** - For `dice = [1, 1, 1, 5, 1]`, the function should return `1150` because three `1`s count as `1000` points, the fourth `1` counts as `100` points, and the `5` counts as `50` points. - For `dice = [2, 3, 4, 6, 2]`, the function should return `0` because none of these rolls meet the scoring criteria. - For `dice = [3, 4, 5, 3, 3]`, the function should return `350` because three `3`s count as `300` points and the `5` counts as `50` points.","solution":"def greed_score(dice): Evaluates the score for the dice game Greed. Parameters: dice: List[int] - A list of five integers representing dice rolls. Returns: int - The total score based on the rules of the game. from collections import Counter # Count the occurrences of each die roll roll_counts = Counter(dice) score = 0 # Check for three of a kind for num in range(1, 7): if roll_counts[num] >= 3: if num == 1: score += 1000 else: score += num * 100 roll_counts[num] -= 3 # Score remaining rolls score += roll_counts[1] * 100 score += roll_counts[5] * 50 return score"},{"question":"You are given a `matrix` of integers with `rows` and `columns`, where `matrix[i][j]` represents the value at the `i-th` row and `j-th` column. A **magic submatrix** is a square submatrix of size `k x k` (where `k > 1`) in which all the elements have the same sum for each of their rows, columns, and diagonals. Return _the size `k` of the largest magic submatrix in the given matrix_. If no such submatrix exists, return `0`.","solution":"def check_magic(matrix, row, col, k): Checks if the submatrix of size k x k starting at (row, col) is magic. sums = [] # Check rows and columns sums for i in range(k): sums.append(sum(matrix[row + i][col:col + k])) sums.append(sum(matrix[row + j][col + i] for j in range(k))) # Check diagonal sums sums.append(sum(matrix[row + i][col + i] for i in range(k))) sums.append(sum(matrix[row + i][col + k - 1 - i] for i in range(k))) return len(set(sums)) == 1 def largest_magic_submatrix(matrix): Returns the size k of the largest magic submatrix in matrix. rows, cols = len(matrix), len(matrix[0]) max_k = min(rows, cols) for k in range(max_k, 1, -1): for row in range(rows - k + 1): for col in range(cols - k + 1): if check_magic(matrix, row, col, k): return k return 0"},{"question":"You are given an array `events` representing the start and end times of several events in a day. Each event is represented as a tuple `(start, end)` where `start` and `end` are 24-hour times formatted as `\\"HH:MM\\"`. Determine if a person can attend all the given events without any overlap. An event `(start1, end1)` overlaps with another event `(start2, end2)` if and only if there is any time that is common to both events. Return _a boolean value_ indicating whether all events can be attended without overlap.","solution":"def can_attend_all_events(events): Determines if a person can attend all given events without any overlap. Args: events (list of tuple): A list where each tuple contains the start and end times of an event in \\"HH:MM\\" format. Returns: bool: True if a person can attend all events without overlap, False otherwise. # Convert time string to minutes since 00:00 for easier comparison def convert_to_minutes(time_str): hours, minutes = map(int, time_str.split(\\":\\")) return hours * 60 + minutes # Sort events based on start time events = sorted(events, key=lambda x: convert_to_minutes(x[0])) # Compare each event with the next to check for overlap for i in range(len(events) - 1): end_current = convert_to_minutes(events[i][1]) start_next = convert_to_minutes(events[i + 1][0]) if end_current > start_next: return False return True"},{"question":"In a social media application, the number of followers a user has can be represented as an array where `followers[i]` is the number of followers for the `i-th` user. Each user can follow any number of other users, but cannot follow themselves. If a user follows another user, all of their followers will also start following the followed user. Given an integer `k`, return _the minimum number of direct follows needed to ensure that at least `k` users each have at least one follower_. If it\'s not possible, return `-1`. Ensure that the number of follows is minimized to meet the required condition.","solution":"def min_follows_to_ensure_k_users_with_followers(followers, k): Calculate minimum number of follows needed to ensure at least k users each have at least one follower. :param followers: List[int], list of integers where followers[i] is the number of followers for the i-th user. :param k: int, the number of users to have at least one follower each. :return: int, minimum number of follows needed or -1 if not possible. if len(followers) < k: return -1 # Sort followers in descending order followers.sort(reverse=True) # Initialize follow count follows_needed = 0 followers_with_followers = 0 # Iterate over the followers list and count how many users already have at least one follower for f in followers: if f > 0: followers_with_followers += 1 # If enough users already have at least one follower, return 0 if followers_with_followers >= k: return 0 # Calculate follows needed to ensure k users have at least one follower follows_needed = k - followers_with_followers return follows_needed"},{"question":"You are given a list of `n` strings `words`, where each string is composed of lowercase English letters. You need to group the strings into anagrams. Anagrams are strings that can be formed by rearranging the letters of another string. Return a list of lists, where each sublist contains the strings that are anagrams of each other, and the sublists are ordered in increasing order of their first appearance in the `words` list. Each sublist should also maintain the order in which the anagram strings appeared originally.","solution":"from collections import defaultdict def group_anagrams(words): Groups strings into anagrams. anagram_groups = defaultdict(list) for word in words: sorted_word = tuple(sorted(word)) anagram_groups[sorted_word].append(word) result = [] for group in anagram_groups.values(): result.append(group) return result"},{"question":"You are given a `0-indexed` integer array `heights` representing the height of buildings on a street. A building `i` can see another building `j` if both the following conditions are true: * `i < j` * For every `k` between `i` and `j` (`i < k < j`), the height of building `k` is less than the height of building `j`. Return an integer array `answer` where `answer[i]` is the index of the closest building that building `i` can see. If no such building exists, set `answer[i] = -1`.","solution":"def find_closest_visible_buildings(heights): For each building in the heights array, find the index of the closest building that it can see. If no such building exists, return -1 for that index. n = len(heights) answer = [-1] * n for i in range(n): for j in range(i + 1, n): if heights[j] > heights[i]: can_see = True for k in range(i + 1, j): if heights[k] >= heights[j]: can_see = False break if can_see: answer[i] = j break return answer"},{"question":"You are given an array `products` where `products[i]` is a string representing the name of the `i-th` product, and an integer `k`. You want to find the `k` most frequent products mentioned in customer reviews. The frequency of a product is defined as the number of times its name appears in the array `products`. Return the `k` most frequent products sorted in alphabetical order. If there are multiple products with the same frequency, the order in which they appear should be alphabetical.","solution":"from collections import Counter def k_most_frequent_products(products, k): Returns the k most frequent products sorted in alphabetical order. Parameters: products (List[str]): A list of product names. k (int): The number of top frequent products to return. Returns: List[str]: A list of the k most frequent products sorted in alphabetical order. product_count = Counter(products) # sort products first by frequency (in descending order), then alphabetically sorted_products = sorted(product_count.keys(), key=lambda x: (-product_count[x], x)) return sorted_products[:k]"},{"question":"Given a string `s` consisting of lowercase English letters, you need to find the length of the longest substring of `s` that can be written as a substring of the string `t` after removing some (possibly zero) characters from `t` without changing the order of the remaining characters. For example, if `s = \\"abc\\"` and `t = \\"ahbgdc\\"`, the longest substring of `s` that can also be found in `t` is `\\"abc\\"` with a length of 3. Return the length of this longest substring.","solution":"def longest_common_subsequence_length(s, t): Find the length of the longest subsequence in s that appears in t Args: s (str): The first string. t (str): The second string. Returns: int: The length of the longest common subsequence that can be derived from s and appears in t. m, n = len(s), len(t) dp = [[0]*(n+1) for _ in range(m+1)] for i in range(1, m+1): for j in range(1, n+1): if s[i-1] == t[j-1]: dp[i][j] = dp[i-1][j-1] + 1 else: dp[i][j] = max(dp[i-1][j], dp[i][j-1]) return dp[m][n]"},{"question":"You are given a list of `n` integers `a1, a2, ..., an` and another integer `k`. Your task is to determine the maximum sum of any non-empty subarray of `a` where the total length of the subarray is less than or equal to `k`. A subarray is a contiguous portion of an array. Write a function that returns an integer which is the maximum subarray sum as per the given constraints.","solution":"def max_subarray_sum(arr, k): Returns the maximum sum of any non-empty subarray of arr with length <= k. :param arr: List of integers :param k: Maximum length of the subarray :return: Maximum sum of any subarray with length <= k n = len(arr) if n == 0: return 0 max_sum = float(\'-inf\') for i in range(n): current_sum = 0 for j in range(i, min(i + k, n)): current_sum += arr[j] if current_sum > max_sum: max_sum = current_sum return max_sum"},{"question":"You are given a list of non-negative integers representing the amount of rainwater each column in a bar graph can trap. Write an algorithm to compute how much water it is able to trap after raining. The bar graph is represented as an array `height` where each element is the height of the bar and the width of each bar is 1 unit. The task is to calculate the total units of water trapped between the columns after the rain.","solution":"def trap(height): Calculate the total units of water trapped between the columns after the rain. :param height: List[int] - List of non-negative integers representing the height of columns. :return: int - Total units of water trapped. n = len(height) if n == 0: return 0 left_max = [0] * n right_max = [0] * n left_max[0] = height[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], height[i]) right_max[n - 1] = height[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], height[i]) water_trapped = 0 for i in range(n): water_trapped += min(left_max[i], right_max[i]) - height[i] return water_trapped"},{"question":"Given a ***sorted integer array*** `arr` and an integer `target`, find the **first and last position** of `target` in `arr`. If `target` is not present in `arr`, return `[-1, -1]`. You must write an algorithm with `O(log n)` runtime complexity. **Definition of findRange:** Parameters: `int[] arr, int target` Returns: `int[]` **Example:** Given arr = `[5, 7, 7, 8, 8, 10]`, target = `8`, Return `[3, 4]`. Given arr = `[5, 7, 7, 8, 8, 10]`, target = `6`, Return `[-1, -1]`.","solution":"def findRange(arr, target): Returns the first and last position of target in arr. If target is not present, returns [-1, -1]. def binary_search_left(arr, target): left, right = 0, len(arr) - 1 while left <= right: mid = (left + right) // 2 if arr[mid] < target: left = mid + 1 else: right = mid - 1 return left def binary_search_right(arr, target): left, right = 0, len(arr) - 1 while left <= right: mid = (left + right) // 2 if arr[mid] <= target: left = mid + 1 else: right = mid - 1 return right left_idx = binary_search_left(arr, target) right_idx = binary_search_right(arr, target) if left_idx <= right_idx < len(arr) and arr[left_idx] == target and arr[right_idx] == target: return [left_idx, right_idx] return [-1, -1]"},{"question":"Given a list of integers `nums` and an integer `k`, return the maximum number of consecutive integers that sum up to a value that does not exceed `k`. You may assume that the given integer list `nums` is non-empty and contains only positive integers.","solution":"def max_consecutive_sum(nums, k): Returns the maximum number of consecutive integers in \'nums\' whose sum does not exceed \'k\'. max_length = 0 current_sum = 0 start = 0 for end in range(len(nums)): current_sum += nums[end] while current_sum > k: current_sum -= nums[start] start += 1 max_length = max(max_length, end - start + 1) return max_length"},{"question":"Given an array `nums` of `n` integers, you are allowed to rotate the array to the right by `k` steps, where `k` is a non-negative integer. Your task is to determine the maximum element in the modified array after you perform the rotation. Return the maximum element of the array after `k` rotations. Note that the rotation must be in-place with `O(1)` extra space.","solution":"def max_element_after_k_rotations(nums, k): Returns the maximum element in the array after rotating it to the right by k steps. :param nums: List of integers representing the array. :param k: Integer representing the number of steps to rotate. :return: The maximum element in the array after rotation. n = len(nums) if n == 0: return None k = k % n # Normalize k to be within the bounds of the array length if k > 0: nums[:] = nums[-k:] + nums[:-k] # Rotate the array return max(nums)"},{"question":"You are given an integer array `nums` of length `n`, which contains integers in the range `[1, n]` where each integer appears once or twice. Find all the integers from `1` to `n` that do not appear in `nums` and return them in an array sorted in ascending order. Can you solve this problem in O(n) time and without using extra space (excluding the output array)?","solution":"def find_disappeared_numbers(nums): Finds all the integers from 1 to n that do not appear in nums. Args: nums (list): List of integers where each integer appears once or twice. Returns: list: List of integers that do not appear in nums, sorted in ascending order. n = len(nums) for i in range(n): index = abs(nums[i]) - 1 if nums[index] > 0: nums[index] = -nums[index] result = [i + 1 for i in range(n) if nums[i] > 0] return result"},{"question":"You are given a binary tree with `n` nodes where each node can have either `0`, `1`, or `2` children. Each node is labeled with a unique integer from `1` to `n`. You need to find the number of paths in this tree where the sum of the node values on the path is equal to a given integer `sum`. A path is defined as any sequence of nodes starting from a leaf node to any ancestor node, including the root. The paths must contain at least one node. Return the number of such paths.","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def pathSumFromLeaf(root, target_sum): Finds the number of paths from leaf nodes to root whose sums equal target_sum. def dfs(node, current_path): if not node: return 0 if not node.left and not node.right: # We are at a leaf node, start checking sums from here current_path.append(node.val) current_sum = 0 path_count = 0 for val in reversed(current_path): current_sum += val if current_sum == target_sum: path_count += 1 current_path.pop() return path_count current_path.append(node.val) left_paths = dfs(node.left, current_path) right_paths = dfs(node.right, current_path) current_path.pop() return left_paths + right_paths return dfs(root, []) # Example usage: # root = TreeNode(5) # root.left = TreeNode(4) # root.right = TreeNode(8) # root.left.left = TreeNode(11) # root.right.left = TreeNode(13) # root.right.right = TreeNode(4) # result = pathSumFromLeaf(root, 22) # Should be 3 if proper tree is provided"},{"question":"Given a list of integers, `arr`, where `arr[i]` represents the number of citations a researcher received for their i-th paper, return the researcher\'s h-index. The h-index is defined as the maximum value h such that the given researcher has published h papers that have each been cited at least h times.","solution":"def h_index(citations): Returns the h-index for the given list of citations. Parameters: citations (List[int]): A list of citation counts. Returns: int: The h-index. citations.sort(reverse=True) h = 0 for i, citation in enumerate(citations): if citation >= i + 1: h = i + 1 else: break return h"},{"question":"You are given an array of positive integers `arr`. Your task is to return the number of tuples `(i, j, k, l)` such that `i < j < k < l` and the product of `arr[i]`, `arr[j]`, `arr[k]`, and `arr[l]` is a perfect square. A perfect square is an integer that is the square of another integer. Your solution should focus on both correctness and efficiency, considering both small and large input sizes for the array.","solution":"from collections import Counter import math def is_perfect_square(n): root = int(math.sqrt(n)) return root * root == n def count_tuples(arr): count = 0 n = len(arr) # Pre-compute the prime factor counts for all numbers in arr def prime_factor_counts(x): counts = Counter() d = 2 while d * d <= x: while (x % d) == 0: counts[d] += 1 x //= d d += 1 if x > 1: counts[x] += 1 return counts factor_counts = [prime_factor_counts(x) for x in arr] def can_form_perfect_square(i, j, k, l): combined_counts = Counter() for idx in [i, j, k, l]: combined_counts += factor_counts[idx] for count in combined_counts.values(): if count % 2 != 0: return False return True # Search for all quadruples (i, j, k, l) for i in range(n): for j in range(i+1, n): for k in range(j+1, n): for l in range(k+1, n): if can_form_perfect_square(i, j, k, l): count += 1 return count"},{"question":"You are given an `m x n` binary matrix `grid` where `0` represents water and `1` represents land. An island in the grid is a group of `1`\'s (land) connected 4-directionally (horizontal or vertical.) You may assume all four edges of the grid are surrounded by water. The area of an island is the number of cells with a value `1` in the island. Write an algorithm to return an array of islands\' areas, sorted in descending order. If there are no islands, return an empty array. For example, given the `grid` `[[0,1,0],[1,1,0],[0,0,0]]`, the areas of the islands are `[3]`.","solution":"def num_islands_areas(grid): Returns a list of island areas in the grid, sorted in descending order. def dfs(x, y): # Base case for DFS if x < 0 or x >= m or y < 0 or y >= n or grid[x][y] == 0: return 0 # Mark the cell as visited grid[x][y] = 0 # Explore all 4 directions area = 1 area += dfs(x + 1, y) area += dfs(x - 1, y) area += dfs(x, y + 1) area += dfs(x, y - 1) return area m, n = len(grid), len(grid[0]) island_areas = [] for i in range(m): for j in range(n): if grid[i][j] == 1: island_areas.append(dfs(i, j)) return sorted(island_areas, reverse=True)"},{"question":"You are given an array `arr` of `n` positive integers. Your task is to construct a new array of the same length where each element at index `i` of the new array is the product of all elements of the original array except the one at index `i`. You are required to accomplish this without using division and in linear time. Return the newly constructed array.","solution":"def product_except_self(arr): Given an array `arr` of positive integers, return a new array such that each element at index `i` is the product of all elements of the original array except the one at index `i`. :param arr: List[int] - Input list of integers :return: List[int] - Resulting list of products n = len(arr) if n == 0: return [] left_products = [1] * n right_products = [1] * n result = [1] * n # Fill left_products array where left_products[i] contains the product of all elements to the left of index i for i in range(1, n): left_products[i] = left_products[i - 1] * arr[i - 1] # Fill right_products array where right_products[i] contains the product of all elements to the right of index i for i in range(n - 2, -1, -1): right_products[i] = right_products[i + 1] * arr[i + 1] # Construct result array where result[i] is the product of left_products[i] and right_products[i] for i in range(n): result[i] = left_products[i] * right_products[i] return result"},{"question":"You are given a weighted, directed graph represented as an adjacency list, where `graph[u]` is a list of pairs `(v, w)` indicating there is an edge from node `u` to node `v` with weight `w`. You are also given two nodes, `start` and `end`. Determine if there is a path from `start` to `end` such that the sum of the edge weights along this path is exactly equal to a given value `targetWeight`. If such a path exists, return `true`; otherwise, return `false`.","solution":"def has_path_with_exact_weight(graph, start, end, targetWeight): Determines if there is a path from start to end such that the sum of the edge weights along this path is exactly equal to targetWeight. def dfs(node, current_sum): if current_sum > targetWeight: return False if node == end: return current_sum == targetWeight for neighbor, weight in graph.get(node, []): if dfs(neighbor, current_sum + weight): return True return False return dfs(start, 0)"},{"question":"You are given an integer array `arr` consisting of `n` distinct integers. Let\'s define an **ideal permutation** as an arrangement of `arr` where the absolute difference between any two consecutive elements is at most `1`. Find the number of ideal permutations possible. Return the result modulo `10^9 + 7`.","solution":"def ideal_permutations(arr): Returns the number of ideal permutations of the array where the absolute difference between any two consecutive elements is at most 1. Args: arr: List[int] - The given array of distinct integers. Returns: int - The number of ideal permutations modulo 10^9 + 7. MOD = 10**9 + 7 n = len(arr) # Only two permutations are ideal: # 1. arr sorted in ascending order # 2. arr sorted in descending order return 2 % MOD"},{"question":"You are given two integers `n` and `m`, representing the number of rows and columns respectively. You are also given a 2D integer array `grid` of size `n x m`. Your task is to find the sum of the integers in the grid that are located on the boundary. The boundary elements are those in the first row, last row, first column, and last column. Return the sum of the boundary elements. For example, given the grid: ``` [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] ``` The boundary elements are `[1, 2, 3, 4, 6, 7, 8, 9]`. The sum of these boundary elements is `40`. Return the sum of the boundary elements.","solution":"def boundary_sum(n, m, grid): Returns the sum of the boundary elements in the grid of size n x m. if n == 0 or m == 0: return 0 boundary_elements = [] # Add elements from the first row boundary_elements.extend(grid[0]) # Add elements from the last row if there is more than one row if n > 1: boundary_elements.extend(grid[n-1]) # Add elements from the first and last columns, excluding already added first and last rows for i in range(1, n-1): if m > 0: boundary_elements.append(grid[i][0]) # first column elements if m > 1: boundary_elements.append(grid[i][m-1]) # last column elements return sum(boundary_elements)"},{"question":"Given an array of integers `arr`, find the sum of the elements between indices `i` and `j` (inclusive) for a range of queries. Each query is given as a pair of indices `[i, j]`. Return an array of sums where each element is the result of the corresponding query. You should aim to answer the queries efficiently, particularly if the number of queries is large.","solution":"def sum_ranges(arr, queries): Given an array of integers `arr`, this function returns the sum of elements between indices `i` and `j` (inclusive) for a range of queries. The queries are given as a list of pairs of indices `[i, j]`. To efficiently answer the queries, we precompute prefix sums. # Precompute prefix sums n = len(arr) prefix_sums = [0] * (n + 1) for i in range(n): prefix_sums[i + 1] = prefix_sums[i] + arr[i] # Answer each query using the prefix sums result = [] for i, j in queries: result.append(prefix_sums[j + 1] - prefix_sums[i]) return result"},{"question":"Write a function that takes an array of strings `strs` and groups the anagrams together. You can return the answer in any order. An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once. For example, \\"listen\\" is an anagram of \\"silent\\". ```python def groupAnagrams(strs: List[str]) -> List[List[str]]: # Your code here ```","solution":"from typing import List from collections import defaultdict def groupAnagrams(strs: List[str]) -> List[List[str]]: Groups anagrams together from the given list of strings. Args: - strs (List[str]): List of strings to be grouped Returns: - List[List[str]]: List of groups of anagrams anagram_dict = defaultdict(list) for s in strs: # Sorting each string to use as a key for anagram groups sorted_str = \'\'.join(sorted(s)) anagram_dict[sorted_str].append(s) return list(anagram_dict.values())"},{"question":"An **expression tree** is a binary tree used to represent arithmetic expressions. Each leaf node represents an operand, such as a constant or variable, and each internal node represents an operator. Given an expression tree, evaluate the expression represented by the tree. You need to perform depth-first traversal to evaluate it. The input is the root node of a binary tree, where each node is represented as an object with: - `val` (a string): The value of the node, which can be an operator (\'+\', \'-\', \'*\', \'/\') for internal nodes or an integer for leaf nodes. - `left` (TreeNode): The left child of the node. - `right` (TreeNode): The right child of the node. Return the result of evaluating the expression. **Example:** Consider the following expression tree: ``` \\"*\\" / \\"+\\" \\"5\\" / \\"3\\" \\"2\\" ``` The above tree represents the expression (3 + 2) * 5. The result of evaluating this expression is 25.","solution":"class TreeNode: def __init__(self, val, left=None, right=None): Initialize a tree node. :param val: The value of the node, which can be an operator or an operand. :param left: The left child node. :param right: The right child node. self.val = val self.left = left self.right = right def evaluate_expression_tree(node): Evaluates the expression represented by the given binary tree. :param node: The root node of the expression tree. :return: The result of the expression. if node is None: return 0 # If it\'s a leaf node (operand), return its value as an integer if node.left is None and node.right is None: return int(node.val) # Recursively evaluate the left and right subtrees left_value = evaluate_expression_tree(node.left) right_value = evaluate_expression_tree(node.right) # Apply the operator at the current node to the values obtained from the subtrees if node.val == \'+\': return left_value + right_value elif node.val == \'-\': return left_value - right_value elif node.val == \'*\': return left_value * right_value elif node.val == \'/\': return left_value / right_value"},{"question":"You are given a list of integers representing the daily temperature readings for a month. Each reading is an integer between `-50` and `50`. Define a \\"heatwave\\" as a sequence of consecutive days where the temperature is above `30` degrees for at least `3` consecutive days. Write a program that determines the number of heatwaves in the given list of temperatures. Return the total number of heatwaves found in the list. Ensure your program efficiently handles edge cases and long input sequences.","solution":"def count_heatwaves(temperatures): Returns the number of heatwaves in the list of temperatures. A heatwave is defined as at least 3 consecutive days with temperature above 30 degrees. heatwaves = 0 consecutive_days = 0 for temp in temperatures: if temp > 30: consecutive_days += 1 else: if consecutive_days >= 3: heatwaves += 1 consecutive_days = 0 if consecutive_days >= 3: heatwaves += 1 return heatwaves"},{"question":"You are given two integer arrays `arr1` and `arr2`, both of size `n`, which represent the availability of products in two warehouses. The goal is to create a combined availability array `result` of size `n` such that every element in `result` is the sum of the corresponding elements in `arr1` and `arr2`. However, if the sum of the corresponding elements from `arr1` and `arr2` is greater than a given threshold `m`, set that element in the `result` array to `m` instead. Return the resulting combined availability array `result`.","solution":"def combine_availability(arr1, arr2, m): Combine the availability of products from two warehouses with a threshold. Parameters: arr1 (list of int): Availability array of the first warehouse. arr2 (list of int): Availability array of the second warehouse. m (int): Threshold value. Returns: list of int: Combined availability array. n = len(arr1) result = [min(arr1[i] + arr2[i], m) for i in range(n)] return result"},{"question":"You are given an array `costs` where `costs[i]` is the cost of the ith item in a shop. You would like to buy all items, but you have a `coupon` that allows you to buy one item for free. Your task is to calculate the minimum possible cost to buy all items using the coupon. Write a function that takes an integer array `costs` and returns an integer representing the minimum cost to buy all items considering the coupon. You may assume that the array is non-empty and contains positive integers.","solution":"def minimum_cost_with_coupon(costs): Returns the minimum cost to buy all items considering the coupon which allows you to buy one item for free. Parameters: costs (list): A list of positive integers representing the cost of each item. Returns: int: The minimum cost to buy all items using the coupon. if len(costs) == 1: return 0 total_cost = sum(costs) max_cost_item = max(costs) return total_cost - max_cost_item"},{"question":"Design a class `TimeMap` to store timestamped key-value pairs, and to retrieve the value associated with a key at the latest timestamp before or equal to a given timestamp. The `TimeMap` class should have the following methods: * `TimeMap()`: Initializes the object of the data structure. * `set(String key, String value, int timestamp)`: Stores the key `key` with the value `value` at the given `timestamp`. * `get(String key, int timestamp)`: Returns a value such that `set` was called previously with `key` and a timestamp `prevTimestamp` such that `prevTimestamp` <= `timestamp`. If there are multiple such values, it returns the value associated with the largest `prevTimestamp`. If there are no values, it returns an empty string `\\"\\"`. Ensure that the solution executes efficiently, particularly with regards to the retrieval of values based on timestamp.","solution":"from collections import defaultdict import bisect class TimeMap: def __init__(self): Initializes the object of the data structure. self.store = defaultdict(list) def set(self, key, value, timestamp): Stores the key `key` with the value `value` at the given `timestamp`. :param key: str :param value: str :param timestamp: int self.store[key].append((timestamp, value)) def get(self, key, timestamp): Returns a value such that `set` was called previously with `key` and a timestamp `prevTimestamp` such that `prevTimestamp` <= `timestamp`. If there are multiple such values, it returns the value associated with the largest `prevTimestamp`. If there are no values, it returns an empty string `\\"\\"`. :param key: str :param timestamp: int :return: str if key not in self.store or not self.store[key]: return \\"\\" timestamps = [ts for ts, _ in self.store[key]] pos = bisect.bisect_right(timestamps, timestamp) if pos == 0: return \\"\\" return self.store[key][pos - 1][1]"},{"question":"Implement a function `string mergeSort(string s)` that sorts the characters in the input string `s` using the merge sort algorithm. Merge sort is a divide-and-conquer algorithm that works as follows: 1. Divide the unsorted string into `n` partitions, each containing one character (an array of one character is considered sorted). 2. Repeatedly merge partitions to produce new sorted partitions until there is only one partition left. 3. The final partition is the sorted string. The function should return the sorted string. For example: * `mergeSort(\\"dcba\\")` should return `\\"abcd\\"`. * `mergeSort(\\"apple\\")` should return `\\"aelpp\\"`.","solution":"def merge_sort(s): if len(s) <= 1: return s # Divide the string into two halves mid = len(s) // 2 left_half = merge_sort(s[:mid]) right_half = merge_sort(s[mid:]) # Conquer by merging the sorted halves return merge(left_half, right_half) def merge(left, right): sorted_string = [] i = j = 0 # Combine the two halves in sorted order while i < len(left) and j < len(right): if left[i] <= right[j]: sorted_string.append(left[i]) i += 1 else: sorted_string.append(right[j]) j += 1 # Append any remaining elements from the left and right halves sorted_string.extend(left[i:]) sorted_string.extend(right[j:]) return \'\'.join(sorted_string)"},{"question":"You are given an array `nums` of size `n` consisting of **positive** integers. Your task is to determine the **smallest** number that is **missing** from the array. A number is considered **missing** if it is not present in the array and is **greater** than 0. *For example, given `nums = [3, 4, -1, 1]`, the smallest number missing from the array is `2`.* Return _the smallest positive integer that is missing from the array_.","solution":"def find_smallest_missing_positive(nums): Finds the smallest positive integer that is missing from the list. :param nums: List of integers :return: Smallest missing positive integer nums = [num for num in nums if num > 0] # Remove negative numbers and zero nums_set = set(nums) # Create a set for O(1) look-ups i = 1 # Start from the smallest positive integer while i in nums_set: i += 1 return i"},{"question":"Given an array of integers `arr`, return the number of **distinct pairs** `(i, j)` such that `arr[i] + arr[j]` is a perfect square, where `0 <= i < j < arr.length`. A **perfect square** is an integer that is the square of an integer, e.g., `1, 4, 9, 16`.","solution":"from itertools import combinations import math def is_perfect_square(num): Check if the given number is a perfect square. if num < 0: return False sqrt = int(math.sqrt(num)) return sqrt * sqrt == num def count_perfect_square_pairs(arr): Returns the number of distinct pairs (i, j) such that arr[i] + arr[j] is a perfect square. count = 0 for (i, j) in combinations(range(len(arr)), 2): if is_perfect_square(arr[i] + arr[j]): count += 1 return count"},{"question":"You are given a linked list and two integers `m` and `n` where `1 <= m <= n <= length of list`. Reverse the nodes of the list from position `m` to `n`. Do it in one-pass. A **one-pass algorithm** is when the data is only iterated over once, moving from beginning to end. Return the head of the modified linked list where the segment between `m` and `n` has been reversed, but the rest of the list remains in its original order.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverseBetween(head, m, n): Reverse the linked list from position m to n in one-pass. if not head or m == n: return head dummy = ListNode(0) dummy.next = head prev = dummy # Move prev to the node just before the start of the reverse segment for _ in range(m - 1): prev = prev.next start = prev.next # The first node of the reverse segment then = start.next # The second node of the reverse segment # Reverse the segment between m and n for _ in range(n - m): start.next = then.next then.next = prev.next prev.next = then then = start.next return dummy.next"},{"question":"Given a circular array `nums` of integers, compute the maximum sum of a subarray in circular fashion. A circular array wraps around from the end of the array to the start. The **maximum sum circular subarray** can be built by either choosing a subarray within the original array or a subarray that wraps around the end and begins at the start of the array. You need to return the maximum possible sum. For example: - Input: `nums = [1,-2,3,-2]` - Output: `3` (Explanation: The subarray [3] has the maximum sum.) - Input: `nums = [5,-3,5]` - Output: `10` (Explanation: The subarray [5,5] wraps around to produce the maximum sum.) Implement a solution with linear time complexity.","solution":"def max_subarray_sum_circular(nums): Returns the maximum sum of a subarray in a circular array. def kadane(arr): Helper function to find the maximum subarray sum using Kadane\'s algorithm. max_sum = cur_sum = arr[0] for num in arr[1:]: cur_sum = max(num, cur_sum + num) max_sum = max(max_sum, cur_sum) return max_sum # Case 1: get the maximum sum using standard Kadane\'s algorithm max_kadane = kadane(nums) # Case 2: Now find the maximum possible sum that includes corner elements. total_sum = sum(nums) # Invert the sign of the numbers for Kadane\'s on inverted numbers to find the minimum subarray sum in original numbers nums = [-num for num in nums] max_wrap = total_sum + kadane(nums) # If max_wrap is 0, it means all numbers are negative. Thus, we should not consider max_wrap as it means to take no elements. if max_wrap == 0: return max_kadane return max(max_kadane, max_wrap)"},{"question":"You are given a robot cleaner in a room modeled as a `m x n` grid. The grid is represented by an integer matrix `room` where `0` represents an empty cell, `1` represents an obstacle, and `2` represents the initial position of the robot. The robot can move up, down, left, or right, and is required to clean the entire room (i.e., visit every empty cell at least once). Your task is to write an algorithm that returns the minimum number of moves the robot needs to clean the room starting from its initial position. If it is not possible to clean the entire room, return `-1`. Note: - The robot cannot move into an obstacle cell (represented by `1`). - The robot can revisit empty cells if necessary.","solution":"from collections import deque def min_moves_to_clean_room(room): Returns the minimum number of moves the robot needs to clean the room. If it is not possible to clean the entire room, return -1. m, n = len(room), len(room[0]) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # Find the initial position of the robot initial_pos = None for i in range(m): for j in range(n): if room[i][j] == 2: initial_pos = (i, j) break if initial_pos: break # Breadth-First Search (BFS) setup queue = deque([(initial_pos[0], initial_pos[1], 0)]) # (x, y, moves) visited = set() visited.add((initial_pos[0], initial_pos[1])) while queue: x, y, moves = queue.popleft() # Check all four directions for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and (nx, ny) not in visited and room[nx][ny] != 1: visited.add((nx, ny)) queue.append((nx, ny, moves + 1)) # Check if all cells are visited for i in range(m): for j in range(n): if room[i][j] == 0 and (i, j) not in visited: return -1 return max([moves for x, y, moves in queue]) if queue else moves"},{"question":"You are given a list of non-negative integers `nums` and an integer `k`. We define the **score** of a list as the largest sum of any of its non-empty subarrays. A _subarray_ is a contiguous part of an array. Return the maximum possible **score** of a subarray that can be achieved by changing at most `k` elements of the list to any value. Each change can be any integer (positive, negative, or zero). (Note: In this problem, you are allowed to change at most `k` elements from `nums` to any values to get the maximum possible score of any subarray.)","solution":"def max_subarray_score_after_k_changes(nums, k): def kadane(nums): max_current = max_global = nums[0] for num in nums[1:]: max_current = max(num, max_current + num) if max_current > max_global: max_global = max_current return max_global # If no changes are allowed, return the maximum subarray sum using Kadane\'s algorithm. if k == 0: return kadane(nums) # If we can change all elements, the best score will be obtained by changing all to a very large positive number. # For simplicity, assume changing to 1000 (since it\'s arbitrary and just demonstrates the logic). if k>= len(nums): return 1000 * len(nums) n = len(nums) max_score = float(\'-inf\') # Try modifying each subarray by changing up to k elements to some large positive number for i in range(n): for j in range(i, min(i + k, n)): original_subarray = nums[i:j+1] new_subarray = [1000] * (j - i + 1) combined = nums[:i] + new_subarray + nums[j+1:] max_score = max(max_score, kadane(combined)) return max_score"},{"question":"Given an array of integers `nums` and an integer `k`, return the maximum sum of a subarray that has a length defined as less than or equal to `k`. The subarray must be contiguous, and the sum must be less than or equal to a given integer `t`. If there is no such subarray, return 0. For example, suppose `nums` is `[1, 2, 3, -1, -2, 3, 5]`, `k` is `3`, and `t` is `6`, the function should return the sum `6`, which corresponds to the subarray `[3, -1, -2, 3]`. Ensure that your solution is efficient and can handle larger arrays as well.","solution":"def max_subarray_sum(nums, k, t): Returns the maximum sum of a subarray with length less than or equal to k and sum less than or equal to t. Args: nums (List[int]): List of integers. k (int): Maximum length of the subarray. t (int): Maximum allowable sum of the subarray. Returns: int: Maximum sum of the subarray that meets the criteria. max_sum = float(\'-inf\') for i in range(len(nums)): current_sum = 0 for j in range(i, min(i + k, len(nums))): current_sum += nums[j] if current_sum <= t: max_sum = max(max_sum, current_sum) return max_sum if max_sum != float(\'-inf\') else 0"},{"question":"Given a matrix `grid` of size `m x n` consisting of positive integers and an integer `k`, find the length of the shortest path from the top-left to the bottom-right corner of the matrix while eliminating at most `k` obstacles. You can move up, down, left, or right from and to any cell in the matrix. If it is impossible to reach the bottom-right corner, return `-1`.","solution":"from collections import deque def shortestPath(grid, k): m, n = len(grid), len(grid[0]) if m == 1 and n == 1: return 0 queue = deque([(0, 0, 0, k)]) visited = {(0, 0): k} directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] while queue: x, y, steps, remaining_k = queue.popleft() for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n: new_k = remaining_k - grid[nx][ny] if nx == m-1 and ny == n-1: return steps + 1 if new_k >= 0: if (nx, ny) not in visited or visited[(nx, ny)] < new_k: visited[(nx, ny)] = new_k queue.append((nx, ny, steps + 1, new_k)) return -1"},{"question":"You are given a string `s` and an integer `k`. A `substring` is a contiguous sequence of characters within the string. Find the maximum number of distinct characters in any substring of length `k`. Return _the maximum number of distinct characters_ among all substrings of length `k`. If the length of string `s` is less than `k`, return `0`.","solution":"def max_distinct_characters(s, k): Returns the maximum number of distinct characters in any substring of length k. If the length of string s is less than k, return 0. :param s: Input string :param k: Length of substring :return: Maximum number of distinct characters in any substring of length k if len(s) < k: return 0 max_distinct = 0 for i in range(len(s) - k + 1): substring = s[i:i+k] distinct_characters = len(set(substring)) max_distinct = max(max_distinct, distinct_characters) return max_distinct"},{"question":"A warehouse manager has a set of boxes, each with a certain weight. You are given an integer array `weights` representing the weights of the boxes. The manager wants to partition the boxes into two groups such that the weight difference between the two groups is minimized. Return the **minimum possible weight difference** between the two groups. For example, given `weights = [1, 6, 11, 5]`, the output should be `1`, as the groups can be partitioned into `[1, 6, 5]` and `[11]`, with the respective sums being `12` and `11`, and thus the weight difference is `|12 - 11| = 1`.","solution":"def minimum_weight_difference(weights): total_weight = sum(weights) n = len(weights) dp = [False] * (total_weight // 2 + 1) dp[0] = True for weight in weights: for j in range(total_weight // 2, weight - 1, -1): dp[j] = dp[j] or dp[j - weight] for i in range(total_weight // 2, -1, -1): if dp[i]: sum1 = i break sum2 = total_weight - sum1 return abs(sum2 - sum1)"},{"question":"Given an array of integers `nums`, you need to find the **maximum length** of a contiguous subarray that contains **at most two distinct integers**. Return _the length of such a subarray_. For example, in the array `[1, 2, 1]`, the maximum length of a contiguous subarray that contains at most two distinct integers is `3`.","solution":"def max_length_of_subarray(nums): Returns the maximum length of a contiguous subarray that contains at most two distinct integers. :param nums: List[int] - list of integers. :return: int - maximum length of the subarray. if not nums: return 0 start, max_length = 0, 0 count = {} for end in range(len(nums)): if nums[end] in count: count[nums[end]] += 1 else: count[nums[end]] = 1 while len(count) > 2: count[nums[start]] -= 1 if count[nums[start]] == 0: del count[nums[start]] start += 1 max_length = max(max_length, end - start + 1) return max_length"},{"question":"You are given an integer array `nums` where the integers are sorted in ascending order, and an integer `target`. If `target` exists in the array, return the index of its first occurrence. If `target` does not exist in the array, return the index where it would be if it were inserted in order. You must write an algorithm with O(log n) runtime complexity. For example, given `nums = [1, 3, 5, 6]` and `target = 5`, the function should return `2`. Given `nums = [1, 3, 5, 6]` and `target = 2`, the function should return `1`.","solution":"def search_insert(nums, target): Returns the index of the target in the sorted array nums if present. If the target is not present, returns the index where it would be inserted. The algorithm runs in O(log n) time complexity using binary search. left, right = 0, len(nums) - 1 while left <= right: mid = (left + right) // 2 if nums[mid] == target: return mid elif nums[mid] < target: left = mid + 1 else: right = mid - 1 return left"},{"question":"You are given a **0-indexed** integer array `height` of length `n` where `height[i]` represents the height of the `i-th` tower. The towers form a skyline from left to right. You need to paint the towers such that: 1. Each tower is painted either red, blue, or green. 2. No two adjacent towers are painted the same color. Return _the total number of distinct ways to paint the towers_ modulo `10^9 + 7`.","solution":"MOD = 10**9 + 7 def numWaysToPaintTowers(height): n = len(height) if n == 0: return 0 if n == 1: return 3 # Only one tower can be painted in 3 ways. # Initial setup for the first tower. R, B, G = 1, 1, 1 for i in range(1, n): # Calculate new values of R, B, G. new_R = (B + G) % MOD new_B = (R + G) % MOD new_G = (R + B) % MOD R, B, G = new_R, new_B, new_G # Total ways to paint towers for the last tower. total_ways = (R + B + G) % MOD return total_ways"},{"question":"You need to implement a feature to log the user activity in an application. Each time a user performs an action, it gets logged with a timestamp and an action description. The logs are stored as a list of tuples, where each tuple contains a timestamp and an action description. Write a function that, given a list of logged user actions and a start and end timestamp, returns the list of actions that were performed within that time range (inclusive). The returned list should be sorted by timestamps in ascending order. If no actions are found in the given time range, return an empty list. # Example: ```python logs = [ (1624291200, \\"Login\\"), (1624291260, \\"View Dashboard\\"), (1624291320, \\"Logout\\"), (1624291380, \\"Login\\"), (1624291440, \\"Download Report\\") ] start_timestamp = 1624291200 end_timestamp = 1624291320 filter_logs(logs, start_timestamp, end_timestamp) ``` # Output: ``` [ (1624291200, \\"Login\\"), (1624291260, \\"View Dashboard\\"), (1624291320, \\"Logout\\") ] ```","solution":"def filter_logs(logs, start_timestamp, end_timestamp): Returns a list of actions that were performed within the given time range inclusive. Parameters: logs (list of tuple): A list of tuples containing (timestamp, action description). start_timestamp (int): The start of the timestamp range. end_timestamp (int): The end of the timestamp range. Returns: list of tuple: A list of actions performed within the given time range inclusive. return sorted([log for log in logs if start_timestamp <= log[0] <= end_timestamp])"},{"question":"Given a binary tree, write a function `int deepestLeavesSum(TreeNode* root)` that returns the sum of the values of its deepest leaves. The deepest leaves are defined as the leaves of the tree that are the furthest away from the root. Each tree node has the following structure: ```cpp struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode() : val(0), left(nullptr), right(nullptr) {} TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} }; ``` Return _the sum of the values of the deepest leaves_.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def deepestLeavesSum(root): from collections import deque if not root: return 0 queue = deque([root]) while queue: level_sum = 0 for _ in range(len(queue)): node = queue.popleft() level_sum += node.val if node.left: queue.append(node.left) if node.right: queue.append(node.right) return level_sum"},{"question":"Write a function `shuffleString` that takes two input parameters: a string `s` and an integer array `indices` of the same length. The function should return a new string where the character at the `i-th` position in the new string is the character at the position `indices[i]` in `s`. Each value in `indices` is unique and is within the range [0, length of `s` - 1].","solution":"def shuffleString(s, indices): This function returns a new string where the character at the i-th position in the new string is the character at the position indices[i] in s. # Initialize a list of the same length as s with None shuffled = [\'\'] * len(s) # Place each character at its new position for i, index in enumerate(indices): shuffled[index] = s[i] # Join the list into a string and return return \'\'.join(shuffled)"},{"question":"You are given a binary search tree (BST) and an integer `target`. Your task is to find the value in the BST that is closest to the target. Implement the function `closestValue` which takes the root of the BST and the target integer as arguments and returns the value in the BST that is closest to the target. Assume that there is at least one node in the tree. Your implementation should adhere to the following method signature: ``` def closestValue(root: TreeNode, target: float) -> int: ... ``` # Example: Given BST: ``` 4 / 2 5 / 1 3 ``` - For `target = 3.714286`, the function should return `4`, since `4` is the closest value to `3.714286` in the BST.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def closestValue(root: TreeNode, target: float) -> int: closest = root.val current = root while current is not None: if abs(current.val - target) < abs(closest - target): closest = current.val if target < current.val: current = current.left else: current = current.right return closest"},{"question":"You are given an array of integers `nums` representing the population count of various cities. You want to split these cities into two groups such that the absolute difference of the sum of populations between the two groups is minimal. Return _the minimal possible absolute difference_.","solution":"def minimal_population_difference(nums): Returns the minimal possible absolute difference of the sum of populations between two groups of cities. total_sum = sum(nums) n = len(nums) dp = [[False]*(total_sum//2 + 1) for _ in range(n+1)] for i in range(n+1): dp[i][0] = True for i in range(1, n + 1): for j in range(1, total_sum//2 + 1): dp[i][j] = dp[i-1][j] if j >= nums[i-1]: dp[i][j] = dp[i][j] or dp[i-1][j-nums[i-1]] for j in range(total_sum//2, -1, -1): if dp[n][j]: return abs(total_sum - 2*j)"},{"question":"Design a Queue using Stacks. Implement the `MyQueue` class with the following operations: * `void push(int x)` - Pushes element `x` to the back of the queue. * `int pop()` - Removes the element from the front of the queue and returns it. * `int peek()` - Returns the element at the front of the queue. * `bool empty()` - Returns whether the queue is empty or not.","solution":"class MyQueue: def __init__(self): # Two stacks to implement queue self.stack_in = [] self.stack_out = [] def push(self, x: int): self.stack_in.append(x) def pop(self) -> int: self._move_elements() return self.stack_out.pop() def peek(self) -> int: self._move_elements() return self.stack_out[-1] def empty(self) -> bool: return not self.stack_in and not self.stack_out # Helper function to transfer elements from stack_in to stack_out def _move_elements(self): if not self.stack_out: while self.stack_in: self.stack_out.append(self.stack_in.pop())"},{"question":"You are given an array of `n` integers, and your task is to rearrange the array elements to form the **lexicographically next greater permutation** of the given array. If such an arrangement is not possible, it must rearrange the elements as the **lowest possible order** (i.e., sorted in ascending order). The replacement must be **in-place** and use only constant extra memory. Return the modified array.","solution":"def next_permutation(arr): Modifies the array to its next lexicographical permutation. If such permutation is not possible, returns the array sorted in ascending order. n = len(arr) if n <= 1: return arr # Step 1: Find the longest non-increasing suffix i = n - 2 while i >= 0 and arr[i] >= arr[i + 1]: i -= 1 if i == -1: # The entire array is non-increasing, hence no next permutation is possible. arr.reverse() return arr # Step 2: Find the rightmost element that is greater than arr[i] j = n - 1 while arr[j] <= arr[i]: j -= 1 # Step 3: Swap arr[i] with arr[j] arr[i], arr[j] = arr[j], arr[i] # Step 4: Reverse the suffix starting at arr[i + 1] arr[i + 1:] = reversed(arr[i + 1:]) return arr"},{"question":"Write a function that takes a string `text` as input and returns the longest substring without repeating characters. If there are multiple substrings with the same maximum length, return the first one.","solution":"def longest_unique_substring(text): Returns the longest substring without repeating characters. If there are multiple substrings with the same maximum length, returns the first one. if not text: return \\"\\" start = max_length = 0 used_char = {} longest_substr = \'\' for i, char in enumerate(text): if char in used_char and start <= used_char[char]: start = used_char[char] + 1 else: cur_length = i - start + 1 if cur_length > max_length: max_length = cur_length longest_substr = text[start:i+1] used_char[char] = i return longest_substr"},{"question":"A software developer is working on a system that logs user activity. Each log entry is a string formatted as `\\"user_type;activity_type;timestamp\\"`, where: - `user_type` is either `\\"guest\\"` or `\\"registered\\"`, - `activity_type` is a string representing the type of activity (e.g., `\\"login\\"`, `\\"logout\\"`, `\\"purchase\\"`), and - `timestamp` is a string representing the time the activity occurred in the format `\\"YYYY-MM-DD HH:MM:SS\\"`. Given a list of log entries and a specific user type, return a list of activities performed by that user type in chronological order based on the `timestamp`. Implement the function `get_activities(logs: List[str], user_type: str) -> List[str]` that takes a list of log entries and a user type as parameters and returns the activities performed by the specified user type in the order they occurred. For example, given the following inputs: ```python logs = [ \\"guest;login;2023-01-01 10:00:00\\", \\"registered;purchase;2023-01-01 09:00:00\\", \\"guest;logout;2023-01-01 10:30:00\\", \\"registered;login;2023-01-01 09:30:00\\" ] user_type = \\"registered\\" ``` The function should return: ```python [\\"purchase\\", \\"login\\"] ```","solution":"from typing import List def get_activities(logs: List[str], user_type: str) -> List[str]: Returns a list of activities performed by the specified user type in chronological order. Parameters: logs (List[str]): List of log entries in the format \\"user_type;activity_type;timestamp\\". user_type (str): The user type to filter by (either \\"guest\\" or \\"registered\\"). Returns: List[str]: List of activities performed by the specified user type in chronological order. # Filter logs based on the specified user type filtered_logs = [log for log in logs if log.split(\';\')[0] == user_type] # Extract the activity type and timestamp activities = [(log.split(\';\')[1], log.split(\';\')[2]) for log in filtered_logs] # Sort the activities based on the timestamp activities.sort(key=lambda x: x[1]) # Return the sorted activity types return [activity[0] for activity in activities]"},{"question":"You are given an array of integers `heights` representing the height of buildings in a city skyline. The goal is to find out the total area covered by the buildings when viewed from a distance. Each building is represented as a rectangle, and the width of each building is `1` unit. Write a function `totalSkylineArea(heights)` that takes an array `heights` and returns the total area covered by the skyline. The function should consider overlapping heights and ensure that a taller building in front obscures any shorter buildings behind it. Example: Input: `heights = [1, 3, 2, 4, 3]` Output: `10` Explanation: The total area is calculated as 1 (height 1) + 3 (height 3) + 2 (height 2) + 4 (height 4) + 3 (height 3), but since the 2 and 3 are obscured by the 4, they are not counted twice. Function signature: `def totalSkylineArea(heights: List[int]) -> int:`","solution":"from typing import List def totalSkylineArea(heights: List[int]) -> int: Returns the total skyline area covered by the buildings when viewed from a distance. if not heights: return 0 return sum(heights)"},{"question":"Given a string `s` representing a column title as appears in an Excel sheet, return its corresponding column number. For example: | Column | Number | |--------|--------| | \\"A\\" | 1 | | \\"B\\" | 2 | | \\"Z\\" | 26 | | \\"AA\\" | 27 | | \\"AB\\" | 28 | | ... | ... | Write the code that will take a string and return its corresponding column number: `int convertToNumber(string s)`.","solution":"def convertToNumber(s): Converts the column title to its corresponding Excel column number. result = 0 for char in s: result = result * 26 + (ord(char) - ord(\'A\') + 1) return result"},{"question":"You are given a **0-indexed** integer array `arrival` of length `n` where `arrival[i]` represents the arrival time of the `i-th` person to a party. Each person needs exactly `k` minutes to meet the host. The host can only meet one person at a time and can meet a person starting from the time of their arrival. The host cannot meet another person until the current meeting is finished. Return the _minimum total time required_ to greet all the guests if the host starts meeting the guests as soon as they arrive.","solution":"def min_total_greeting_time(arrival, k): Returns the minimum total time required to greet all the guests. Parameters: arrival (List[int]): A list of integers representing the arrival times of the guests. k (int): The time in minutes required to meet one guest. Returns: int: The minimum total time required to greet all the guests. if not arrival: return 0 arrival.sort() total_time = 0 end_time = 0 for time in arrival: if time >= end_time: total_time += k end_time = time + k else: total_time += k return total_time"},{"question":"Given an array of `n` integers, design an algorithm to find the length of the longest subarray where the difference between any two elements is at most `k`. Return the length of this subarray.","solution":"def longest_subarray_with_diff_at_most_k(arr, k): Return the length of the longest subarray where the difference between any two elements is at most k. if not arr: return 0 from collections import defaultdict n = len(arr) left = 0 frequency = defaultdict(int) max_length = 0 for right in range(n): frequency[arr[right]] += 1 while max(frequency) - min(frequency) > k: frequency[arr[left]] -= 1 if frequency[arr[left]] == 0: del frequency[arr[left]] left += 1 max_length = max(max_length, right - left + 1) return max_length"},{"question":"You are given a string `s` of length `n` containing only lowercase alphabets and a list of integers `indices` of length `n` where `indices[i]` represents the new position of the `ith` character in the shuffled string. Return _the shuffled string_. The string `s` should be shuffled in such a way that the character originally at the `ith` position moves to `indices[i]` in the shuffled string.","solution":"def restore_string(s, indices): Shuffle the string s according to indices. Parameters: s (str): The input string. indices (list): The new indices for the characters in s. Returns: str: The shuffled string. # Initialize a list of the same length as s with empty strings shuffled = [\'\'] * len(s) # Assign characters to their new positions for i, idx in enumerate(indices): shuffled[idx] = s[i] # Join the list into a single string and return return \'\'.join(shuffled)"},{"question":"You are given an array of integers `arr` where the array is a **permutation** of the first `n` positive integers. You need to calculate the **minimum number** of swaps required to sort the array in ascending order. Return _the **minimum number** of swaps required to sort the array_.","solution":"def min_swaps_to_sort(arr): Returns the minimum number of swaps required to sort the array. n = len(arr) arr_pos = [(val, idx) for idx, val in enumerate(arr)] arr_pos.sort(key=lambda x: x[0]) visited = [False] * n ans = 0 for i in range(n): if visited[i] or arr_pos[i][1] == i: continue cycle_size = 0 x = i while not visited[x]: visited[x] = True x = arr_pos[x][1] cycle_size += 1 if cycle_size > 0: ans += cycle_size - 1 return ans"},{"question":"Given an integer array `arr`, your task is to arrange the digits of the numbers to form the smallest possible number. The smallest number should be returned as a string to handle large numeric values. For example, given the input array `arr = [50, 2, 1, 9]`, the output should be \\"12509\\" as arranging these digits gives the smallest possible number.","solution":"import functools def compare_digits(x, y): if x + y < y + x: return -1 else: return 1 def smallest_number(arr): Given an integer array `arr`, arranges the digits to form the smallest possible number. str_arr = list(map(str, arr)) str_arr.sort(key=functools.cmp_to_key(compare_digits)) return \'\'.join(str_arr)"},{"question":"You are given two strings `s` and `p` of non-zero length. Your task is to find the smallest window in `s` that contains all the characters of `p`. In case there are multiple such windows, return the one that appears first from the left. Return an empty string if no such window exists. **Note**: - The window needs to contain all such characters including all repetitions. - Characters in the window should meet the frequency counts in `p`. For example, given `s = \\"ADOBECODEBANC\\"` and `p = \\"ABC\\"`, the output should be `\\"BANC\\"`. **Hint**: You might consider using a sliding window approach to solve this problem.","solution":"from collections import Counter, defaultdict def min_window(s, p): if not s or not p: return \\"\\" dict_p = Counter(p) required = len(dict_p) left, right = 0, 0 formed = 0 window_counts = defaultdict(int) ans = float(\\"inf\\"), None, None while right < len(s): character = s[right] window_counts[character] += 1 if character in dict_p and window_counts[character] == dict_p[character]: formed += 1 while left <= right and formed == required: character = s[left] end = right - left + 1 if end < ans[0]: ans = (end, left, right) window_counts[character] -= 1 if character in dict_p and window_counts[character] < dict_p[character]: formed -= 1 left += 1 right += 1 if ans[0] == float(\\"inf\\"): return \\"\\" else: return s[ans[1]: ans[2] + 1]"},{"question":"A warehouse stores items in stacks, and you need to simulate the process of pushing and popping items based on incoming commands. You are given an integer `n` representing the number of commands and a list of strings `commands` where each command is either `PUSH x` (a push operation with an integer `x`) or `POP` (a pop operation). Implement a function that simulates these commands on a stack and returns a list with: 1. The integer popped from the stack whenever a `POP` command is issued. 2. If a `POP` command is issued when the stack is empty, return `-1` for that command. Your function should handle the commands in the order they appear, starting with an empty stack. Example: ```python n = 5 commands = [\\"PUSH 3\\", \\"PUSH 5\\", \\"POP\\", \\"POP\\", \\"POP\\"] # Output: [5, 3, -1] ```","solution":"def simulate_stack(n, commands): stack = [] result = [] for command in commands: if \\"PUSH\\" in command: _, value = command.split() stack.append(int(value)) elif command == \\"POP\\": if stack: result.append(stack.pop()) else: result.append(-1) return result"},{"question":"You are given a list of integers representing the stock prices of a company in chronological order. You are allowed to buy and sell the stock only once. Design an algorithm to find the maximum profit you can achieve. If no profit is possible, return 0.","solution":"def max_profit(prices): Returns the maximum profit from buying and selling the stock once. If no profit is possible, returns 0. :param prices: List[int] - list of stock prices in chronological order :return: int - the maximum profit if not prices: return 0 min_price = float(\'inf\') max_profit = 0 for price in prices: min_price = min(min_price, price) profit = price - min_price max_profit = max(max_profit, profit) return max_profit"},{"question":"You are given an integer array `nums` consisting of **n** elements, where each element is between 1 and **n** (inclusive). Some elements appear **twice** and others appear **once**. Find all the elements of `[1, n]` inclusive that do not appear in `nums` and return them in ascending order. Try to achieve this without using extra space and in linear time complexity.","solution":"def findDisappearedNumbers(nums): Returns the elements of [1, n] that do not appear in nums. n = len(nums) for i in range(n): index = abs(nums[i]) - 1 if nums[index] > 0: nums[index] = -nums[index] result = [] for i in range(n): if nums[i] > 0: result.append(i + 1) return sorted(result)"},{"question":"Write a function that takes an unsorted list of integers and two integers `low` and `high`, and returns the count of how many elements from the list fall within the inclusive range `[low, high]`. Do not use any built-in sorting functions. Your solution should aim for a time complexity of O(n).","solution":"def count_elements_in_range(nums, low, high): Counts how many elements in the list fall within the inclusive range [low, high]. Args: - nums (list of int): The list of integers to check. - low (int): The lower bound of the range. - high (int): The upper bound of the range. Returns: - int: The count of elements within the range. count = 0 for num in nums: if low <= num <= high: count += 1 return count"},{"question":"You are given a string `s` and an integer `p`. Determine if you can create a new string by reordering the characters of `s` such that the new string contains no two adjacent characters that are the same and all characters appear exactly `p` times consecutively before reappearing. Return `true` if such a rearrangement is possible, otherwise return `false`.","solution":"from collections import Counter import heapq def can_rearrange(s, p): Determines if the input string s can be rearranged to ensure that no two adjacent characters are the same and all characters appear exactly p times consecutively before reappearing. :param s: Input string. :param p: Minimum spacing between the same characters. :return: True if rearrangement is possible, False otherwise. if p <= 1: return True # Count frequency of characters freq = Counter(s) # Create a max heap based on character frequency max_heap = [(-count, char) for char, count in freq.items()] heapq.heapify(max_heap) # Queue to keep track of the element in waiting to be pushed back into the heap queue = [] output = [] while max_heap: count, char = heapq.heappop(max_heap) output.append(char) queue.append((char, count + 1)) # decrement the count since we use the char once if len(queue) < p: continue # After p elements, push the oldest one back to the heap if it still has a count remaining front_char, front_count = queue.pop(0) if front_count < 0: heapq.heappush(max_heap, (front_count, front_char)) return len(output) == len(s)"},{"question":"Given an array of integers `arr`, you want to form the largest possible integer by concatenating the elements of the array. Each element of the array represents a single digit (0-9). Return the largest formed integer as a string. Note that the integer should not contain any leading zeros unless the resulting number is `0`. For example, if the input array is `[3, 30, 34, 5, 9]`, the largest possible integer formed by concatenating the elements is `9534330`.","solution":"from functools import cmp_to_key def largest_number(arr): Forms the largest possible integer by concatenating the elements of the array. Args: arr (list): A list of integers. Returns: str: The largest formed integer as a string. if not arr: return \\"0\\" # Convert all integers to strings for easier comparison arr = list(map(str, arr)) # Define a custom comparator def compare(x, y): if x + y > y + x: return -1 elif x + y < y + x: return 1 else: return 0 # Sort the array based on the custom comparator arr.sort(key=cmp_to_key(compare)) # Concatenate the sorted array largest_num_str = \'\'.join(arr) # Remove leading zeros from the result largest_num_str = largest_num_str.lstrip(\'0\') # Return \'0\' if the result is an empty string return largest_num_str or \'0\'"},{"question":"You are given a list of `tasks` where `tasks[i] = [starti, endi]` represent the start and end times of the `i-th` task. Your goal is to find the minimum number of meeting rooms required to hold all the tasks. If a task starts at the same time another task ends, they do not overlap. Return the minimum number of meeting rooms needed.","solution":"def minMeetingRooms(tasks): Returns the minimum number of meeting rooms needed to hold all the tasks. if not tasks: return 0 # Separate out the start and end times start_times = sorted([task[0] for task in tasks]) end_times = sorted([task[1] for task in tasks]) start_pointer = end_pointer = 0 used_rooms = 0 while start_pointer < len(tasks): # If there is a meeting that has ended if start_times[start_pointer] >= end_times[end_pointer]: used_rooms -= 1 end_pointer += 1 # Allocate a room used_rooms += 1 start_pointer += 1 return used_rooms"},{"question":"You are given a list of integers `nums`, where each integer represents the number of matches needed to form one digit of a seven-segment display (0-9). Find the **largest** possible number that can be formed using exactly the given amount of matches. Return the resulting number in string format.","solution":"def largest_number_from_matches(matches): Find the largest possible number that can be formed using exactly the given amount of matches. :param matches: Number of matches available :return: The largest number represented as a string that can be formed with the matches # Digit to matches mapping digit_to_matches = [6, 2, 5, 5, 4, 5, 6, 3, 7, 6] if matches == 2: return \\"1\\" num_digits = matches // 2 if matches % 2 == 0: return \'1\' * num_digits else: return \'7\' + \'1\' * (num_digits - 1)"},{"question":"Given two strings `s1` and `s2`, determine if `s2` is a scrambled string of `s1`. A scrambled string of a string is created by randomly swapping the characters at certain places in the string. You should perform this operation recursively. A string `s1` is a scrambled string of `s2` if `s2` can be partitioned into two non-empty substrings such that one of the substrings is a scrambled string of the first substring and the other substring is a scrambled string of the second substring. Return `true` if `s2` is a scrambled string of `s1`, and `false` otherwise.","solution":"def is_scramble(s1, s2): Determines if s2 is a scrambled string of s1. if len(s1) != len(s2): return False if s1 == s2: return True if sorted(s1) != sorted(s2): return False n = len(s1) for i in range(1, n): if (is_scramble(s1[:i], s2[:i]) and is_scramble(s1[i:], s2[i:])) or (is_scramble(s1[:i], s2[-i:]) and is_scramble(s1[i:], s2[:-i])): return True return False"},{"question":"Given a **2D array** `grid` representing a Manhattan city grid of size `m x n`, where each cell contains a non-negative integer representing the time a person takes to cross that cell, find the minimum time required to travel from the top-left corner (0,0) to the bottom-right corner (m-1,n-1). You can only move right or down at any point in time. Return the minimum time required.","solution":"def min_path_time(grid): Returns the minimum time required to travel from the top-left corner to the bottom-right corner of a Manhattan city grid where each cell contains the time to cross it. You can only move right or down. if not grid or not grid[0]: return 0 m, n = len(grid), len(grid[0]) # Create a 2D dp array of the same size as grid dp = [[0] * n for _ in range(m)] # Initialize the top-left corner dp[0][0] = grid[0][0] # Fill the first row (can only come from the left) for j in range(1, n): dp[0][j] = dp[0][j-1] + grid[0][j] # Fill the first column (can only come from above) for i in range(1, m): dp[i][0] = dp[i-1][0] + grid[i][0] # Compute the minimum path time for the rest of the grid for i in range(1, m): for j in range(1, n): dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j] return dp[m-1][n-1]"},{"question":"You are given a list of course prerequisites `prerequisites` where `prerequisites[i] = [ai, bi]` indicates that you must take course `bi` before course `ai`. You are also given an integer `numCourses` representing the total number of courses labeled from `0` to `numCourses-1`. Determine if it is possible for you to finish all courses. If it is possible, return the order you should take these courses. Otherwise, return an empty list.","solution":"from collections import defaultdict, deque def findOrder(numCourses, prerequisites): Determines if it is possible to finish all courses and returns the order of courses to take. :param numCourses: int - Total number of courses :param prerequisites: List[List[int]] - List of course prerequisites :return: List[int] - Order of courses to take, else an empty list if not possible # Create a graph and a list to count in-degrees of nodes graph = defaultdict(list) indegree = [0] * numCourses # Populate the graph and in-degree array for course, prereq in prerequisites: graph[prereq].append(course) indegree[course] += 1 # Queue for nodes with no incoming edges zero_indegree_queue = deque([i for i in range(numCourses) if indegree[i] == 0]) course_order = [] while zero_indegree_queue: current_course = zero_indegree_queue.popleft() course_order.append(current_course) # Decrease the in-degree of neighbouring nodes by 1 for neighbor in graph[current_course]: indegree[neighbor] -= 1 if indegree[neighbor] == 0: zero_indegree_queue.append(neighbor) # If the course_order\'s length is equal to numCourses, we have a valid order if len(course_order) == numCourses: return course_order else: return []"},{"question":"Given a list of `n` tasks represented by strings `tasks` and a positive integer `k`, representing the cooldown period between two same tasks, return the least number of intervals the CPU will take to finish all the given tasks. Each interval can either be occupied by executing any one task or be an idle interval.","solution":"from collections import Counter def leastInterval(tasks, k): Returns the least number of intervals the CPU will take to finish all tasks with cooldown period k. task_counts = Counter(tasks) # Count the frequencies of each task max_count = max(task_counts.values()) # Get the maximum frequency of any task max_count_tasks = list(task_counts.values()).count(max_count) # Count the number of tasks with the maximum frequency # Calculate the number of intervals based on the formula intervals = (max_count - 1) * (k + 1) + max_count_tasks # The result is the max of the calculated intervals and the number of tasks return max(intervals, len(tasks))"},{"question":"There is a city with `n` buildings that are represented by an integer array `heights`, where `heights[i]` is the height of the `i-th` building. The city has been covered in snow, resulting in certain buildings being obscured from view from the leftmost side. You are to determine how many buildings are visible when viewed from the leftmost side of the city. A building is considered visible if all the buildings before it (to its left) are shorter in height. Return _the number of buildings that are visible from the leftmost side of the city_.","solution":"def count_visible_buildings(heights): Returns the number of buildings visible from the leftmost side of the city. Parameters: heights (List[int]): List of building heights. Returns: int: Number of visible buildings from the leftmost view. if not heights: return 0 visible_count = 1 max_height = heights[0] for height in heights[1:]: if height > max_height: visible_count += 1 max_height = height return visible_count"},{"question":"You are given an integer array `ratings` where `ratings[i]` represents the rating of the `ith` employee. You are to distribute sweets to these employees such that: - Each employee must receive at least one sweet. - Employees with a higher rating than their adjacent employees must receive more sweets than their adjacent employees. Return the *minimum number of sweets* you need to distribute to satisfy the above conditions.","solution":"def min_sweets(ratings): Returns the minimum number of sweets required to distribute to employees such that each employee receives at least one sweet and employees with higher ratings receive more sweets than their adjacent employees. n = len(ratings) if n == 0: return 0 sweets = [1] * n # Sweep from left to right for i in range(1, n): if ratings[i] > ratings[i - 1]: sweets[i] = sweets[i - 1] + 1 # Sweep from right to left for i in range(n - 2, -1, -1): if ratings[i] > ratings[i + 1]: sweets[i] = max(sweets[i], sweets[i + 1] + 1) return sum(sweets)"},{"question":"You are given an integer array `heights` that represents the heights of buildings in a city, where each height is an integer. You need to calculate the amount of water that can be trapped between the buildings after it rains. Implement a function that returns the total volume of water trapped between the buildings. The water trapped at each building is determined by the difference between the building\'s height and the height of the shortest building that limits the water from either side.","solution":"def trap(heights): Given a list of integers representing building heights, calculates the total amount of water that can be trapped between the buildings after it rains. :param heights: List[int], a list of building heights. :return: int, the total volume of trapped water. if not heights: return 0 total_water = 0 n = len(heights) left_max = [0] * n right_max = [0] * n # Fill left_max array left_max[0] = heights[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], heights[i]) # Fill right_max array right_max[n - 1] = heights[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], heights[i]) # Calculate the trapped water for i in range(n): total_water += min(left_max[i], right_max[i]) - heights[i] return total_water"},{"question":"You are given a list of non-negative integers `height` where each element represents the height of a vertical bar. Suppose each bar has a width of `1`. Find the two bars that together with the x-axis form a container, such that the container contains the most water. Return _the maximum amount of water a container can store_.","solution":"def max_area(height): Returns the maximum amount of water a container can store given the list of heights. left, right = 0, len(height) - 1 max_area = 0 while left < right: width = right - left area = min(height[left], height[right]) * width max_area = max(max_area, area) if height[left] < height[right]: left += 1 else: right -= 1 return max_area"},{"question":"You are given an integer array `nums` and an integer `target`. Your task is to find the continuous subarray within `nums` (containing at least one number) which has the largest sum and does not exceed the `target` value. Return _the **maximum** sum of such a subarray_. If there is no such subarray, return 0.","solution":"def max_sum_subarray(nums, target): Finds the maximum sum of a continuous subarray within nums which does not exceed the target value. Returns 0 if no such subarray exists. max_sum = 0 # Variable to store the maximum sum current_sum = 0 # Variable to store the current sum of the subarray start = 0 # Start index of the subarray for end in range(len(nums)): current_sum += nums[end] # Shrink the window until the current sum is less than or equal to target while current_sum > target and start <= end: current_sum -= nums[start] start += 1 # Update the maximum sum if the current subarray\'s sum is less than or equal to target if current_sum <= target: max_sum = max(max_sum, current_sum) return max_sum"},{"question":"A large art museum has a series of rooms connected by passageways. The museum can be modeled as a **bi-directional connected** graph with `n` vertices where each vertex is labeled from `1` to `n` (**inclusive**). The passageways in the museum are represented as a 2D integer array `passageways`, where each `passageways[i] = [ui, vi]` denotes a bi-directional passageway between room `ui` and room `vi`. Each passageway has a security checkpoint where a **security guard** checks the visitors. The time taken for a security check at each passageway is `chk_Time` minutes. Visitors start their journey from the main entrance, which is at room `1`, and move to another room until they exit the museum through the exit, which is at room `n`. To avoid any security problems, the museum administrator wants to know how much time it will take for visitors to go from the entrance to the exit. However, due to limited security resources, they are interested in knowing the time taken in traversing the quickest path. Given `n`, `passageways`, and `chk_Time`, determine the **minimum time** it will take for visitors to go from room `1` to room `n` considering the security checks at each passageway. **Notes:** - Every passageway is bi-directional and no passageway connects a room to itself. - Each passageway has only one security checkpoint. - Security checks do not add any physical movement time, each check takes exactly `chk_Time` minutes. Return _the **minimum time** required to go from room_ `1` _to room_ `n`.","solution":"from collections import deque, defaultdict def min_traversal_time(n, passageways, chk_Time): Returns the minimum time required to get from room 1 to room n, including security checkpoint times. Arguments: n : int : The number of rooms passageways : List[List[int]] : The bi-directional passageways between rooms chk_Time : int : The security check time for each passageway Returns: int : The minimum time to travel from room 1 to room n # Create an adjacency list for the graph graph = defaultdict(list) for u, v in passageways: graph[u].append(v) graph[v].append(u) # BFS initialization queue = deque([(1, 0)]) # (current room, accumulated time) visited = {1} while queue: current_room, current_time = queue.popleft() # If we\'ve reached room `n`, return the accumulated time if current_room == n: return current_time # Explore all neighbors for neighbor in graph[current_room]: if neighbor not in visited: visited.add(neighbor) queue.append((neighbor, current_time + chk_Time)) # If there\'s no path from room 1 to room n return -1 # though, as per problem constraints, the museum is always connected # Example usage: # n = 5 # passageways = [[1, 2], [1, 3], [3, 4], [4, 5]] # chk_Time = 2 # print(min_traversal_time(n, passageways, chk_Time)) # Output should be 6"},{"question":"Given a binary tree, return the sum of values of all nodes that have an even-valued grandparent. A node is considered a grandparent if it has grandchildren, i.e., it is the parent of a node that is itself a parent. A binary tree is defined as: ```plaintext struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode() : val(0), left(nullptr), right(nullptr) {} TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} }; ``` Return the sum as an integer.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def sum_even_grandparent(root): def dfs(node, parent, grandparent): if not node: return 0 sum_value = 0 if grandparent and grandparent.val % 2 == 0: sum_value += node.val sum_value += dfs(node.left, node, parent) sum_value += dfs(node.right, node, parent) return sum_value return dfs(root, None, None)"},{"question":"Given a list of integers `nums`, find the length of the longest subsequence such that the difference between the consecutive elements is either `-1`, `0`, or `1`. A subsequence is derived from another list by deleting some or no elements without changing the order of the remaining elements. Return the length of the longest such subsequence.","solution":"def longest_subsequence(nums): Returns the length of the longest subsequence such that the difference between consecutive elements is either -1, 0, or 1. if not nums: return 0 subsequences = [1] * len(nums) for i in range(1, len(nums)): for j in range(i): if abs(nums[i] - nums[j]) <= 1: subsequences[i] = max(subsequences[i], subsequences[j] + 1) return max(subsequences)"},{"question":"Given an array of integers `arr`, representing the prices of different items. You are allowed two independent transactions: buy one item and sell it later, then buy another item and sell it later. Determine the maximum profit you can achieve using at most two transactions. **Note:** * You cannot engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again). * You may assume that you cannot sell an item before you buy it. * If no profit can be made, return `0`.","solution":"def max_profit_with_two_transactions(prices): if len(prices) == 0: return 0 # Initialize variables for the maximum profit after the first and the second transaction max_profit_1 = 0 max_profit_2 = 0 # Initialize variables for the lowest price we have seen so far min_price_1 = float(\'inf\') min_price_2 = float(\'inf\') for price in prices: # Update for the first transaction min_price_1 = min(min_price_1, price) max_profit_1 = max(max_profit_1, price - min_price_1) # Update for the second transaction min_price_2 = min(min_price_2, price - max_profit_1) max_profit_2 = max(max_profit_2, price - min_price_2) return max_profit_2"},{"question":"Given an array of integers `nums`, you are tasked with finding the **longest consecutive sequence** in the array. A consecutive sequence is a sequence of numbers where each number in the sequence is exactly one greater than the previous number. For example: - In the array `[100, 4, 200, 1, 3, 2]`, the longest consecutive sequence is `[1, 2, 3, 4]`, and its length is `4`. Write a function that returns the length of the longest consecutive sequence. Your function should have a time complexity of `O(n)`. **Function Signature**: ```python def longest_consecutive_sequence(nums: List[int]) -> int: pass ```","solution":"def longest_consecutive_sequence(nums): Returns the length of the longest consecutive sequence in the array. Args: nums (List[int]): List of integers. Returns: int: Length of the longest consecutive sequence. if not nums: return 0 num_set = set(nums) longest_streak = 0 for num in num_set: # Only start counting when `num` is the beginning of a sequence if num - 1 not in num_set: current_num = num current_streak = 1 while current_num + 1 in num_set: current_num += 1 current_streak += 1 longest_streak = max(longest_streak, current_streak) return longest_streak"},{"question":"You are given a list of strings `patterns` and a single string `word`. Each `pattern` in `patterns` can contain the special character `*`, which matches any sequence of characters (including the empty sequence). A string `pattern` matches the string `word` if and only if it is possible to replace the `*` in the pattern with some sequence (possibly empty) of characters in the string `word` such that the resulting pattern equals `word`. Return _the number of patterns in `patterns` that match `word`_.","solution":"def count_matching_patterns(patterns, word): Returns the number of patterns that match the word. A pattern matches the word if it can be transformed into the word by replacing \'*\' with any sequence of characters (including the empty sequence). def matches(pattern, word): parts = pattern.split(\'*\') if len(parts) == 1: return pattern == word if not word.startswith(parts[0]): return False word = word[len(parts[0]):] for part in parts[1:-1]: if part not in word: return False word = word[word.index(part) + len(part):] return word.endswith(parts[-1]) return sum(1 for pattern in patterns if matches(pattern, word))"},{"question":"You are given a `m x n` 2D grid initialized with all 0\'s and an array of operations `ops`, where `ops[i] = [ai, bi]` means all the cells in the subrectangle grid(0, 0) to grid(ai-1, bi-1) inclusive should be incremented by one. Return the number of maximum integers in the matrix after performing all the operations.","solution":"def max_count(m, n, ops): Returns the number of maximum integers in the m x n matrix after performing all the operations. Args: m (int): number of rows in the matrix. n (int): number of columns in the matrix. ops (List[List[int]]): List of operations where each operations is [ai, bi]. Returns: int: The number of cells with the maximum integer after operations. if not ops: return m * n min_a = min(op[0] for op in ops) min_b = min(op[1] for op in ops) return min_a * min_b"},{"question":"Given a rectangular grid consisting of `m` rows and `n` columns, find the minimum number of `1x2` dominoes needed to cover the entire grid. Return an integer representing the fewest number of dominoes required. You can assume that the grid dimensions `m` and `n` do not exceed 30 and at least one dimension is even to ensure a perfect tiling is possible. You can place the dominoes either horizontally or vertically within the grid.","solution":"def min_number_of_1x2_dominoes(m, n): Returns the minimum number of 1x2 dominoes required to cover the entire m x n grid. # Each domino covers 2 cells total_cells = m * n # Minimum number of dominoes needed is half the total number of cells, rounded down min_dominoes = total_cells // 2 return min_dominoes"},{"question":"Given a list of `n` integers, separate them into two subsets such that the absolute difference between the sums of the subsets is minimized. Return the minimum possible absolute difference. This problem is equivalent to partitioning the list into two subsets such that the sum of one subset is as close as possible to half of the total sum of the list.","solution":"def min_subset_sum_diff(nums): Returns the minimum possible absolute difference between the sums of two subsets of nums. total_sum = sum(nums) n = len(nums) target = total_sum // 2 # Initialize a DP array where dp[i] means whether a subset with sum i can be formed dp = [False] * (target + 1) dp[0] = True # Populate the DP array for num in nums: # Traverse backwards to avoid overwriting dp values we need to read for i in range(target, num - 1, -1): dp[i] = dp[i] or dp[i - num] # Find the closest sum to half of the total sum for i in range(target, -1, -1): if dp[i]: subset_sum = i break other_subset_sum = total_sum - subset_sum return abs(subset_sum - other_subset_sum)"},{"question":"Given a `m x n` matrix of letters and a string `word`, determine if the word exists in the grid. The word can be constructed from letters of sequentially adjacent cells, where \\"adjacent\\" cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once. Return true if the word exists in the grid, otherwise return false.","solution":"def exist(board, word): def dfs(board, word, i, j, k): if not (0 <= i < len(board) and 0 <= j < len(board[0]) and board[i][j] == word[k]): return False if k == len(word) - 1: return True tmp, board[i][j] = board[i][j], \'/\' res = dfs(board, word, i+1, j, k+1) or dfs(board, word, i-1, j, k+1) or dfs(board, word, i, j+1, k+1) or dfs(board, word, i, j-1, k+1) board[i][j] = tmp return res for i in range(len(board)): for j in range(len(board[0])): if dfs(board, word, i, j, 0): return True return False"},{"question":"You are given a list of non-negative integers `nums` representing the amount of stones in each pile. Every step, you may take any two piles of stones and merge them into one pile. The cost of this merge is the sum of the two piles\' stones. Your objective is to determine the minimum possible cost to combine all the stones into one single pile. Return _the **minimum** cost needed to merge all piles into one_.","solution":"import heapq def min_cost_to_merge_stones(nums): Returns the minimum cost needed to merge all stones into one pile. if not nums: return 0 heapq.heapify(nums) total_cost = 0 while len(nums) > 1: first = heapq.heappop(nums) second = heapq.heappop(nums) merge_cost = first + second total_cost += merge_cost heapq.heappush(nums, merge_cost) return total_cost"},{"question":"Write a function that takes in a list of strings `logs`, where each log is a space-separated string with two parts: the identifier and the content. Your task is to reorder these logs according to the following criteria: 1. Letter-logs come before all digit-logs. 2. Letter-logs are ordered lexicographically by their content. If two logs have the same content, then the identifier is used to break the tie. 3. Digit-logs should remain in their original order. For example: * Input: `logs = [\\"dig1 8 1 5 1\\", \\"let1 art can\\", \\"dig2 3 6\\", \\"let2 own kit dig\\", \\"let3 art zero\\"]` * Output: `[\\"let1 art can\\", \\"let3 art zero\\", \\"let2 own kit dig\\", \\"dig1 8 1 5 1\\", \\"dig2 3 6\\"]` Implement a function `reorderLogFiles(logs: List[str]) -> List[str]` that returns the reordered list of logs accordingly.","solution":"from typing import List def reorderLogFiles(logs: List[str]) -> List[str]: def get_key(log): identifier, rest = log.split(\\" \\", 1) # Determine if the log is a letter-log or a digit-log if rest[0].isdigit(): # Return a tuple that decides digit-logs will come after letter-logs return (1,) else: # Sort letter-logs by content and identifier return (0, rest, identifier) return sorted(logs, key=get_key)"},{"question":"You are given a grid of size `m x n` represented by a binary matrix, where `0` represents water, `1` represents land, and each cell is connected vertically and horizontally (not diagonally). An island is a maximal 4-directionally connected group of `1`s. You may assume all four edges of the grid are surrounded by water. Write an algorithm to count the number of islands in the given grid. Return the number of islands.","solution":"def count_islands(grid): Returns the number of islands in the given grid. Args: grid (List[List[int]]): The grid representing land (1) and water (0). Returns: int: The number of islands. if not grid or not grid[0]: return 0 def dfs(i, j): if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or grid[i][j] == 0: return grid[i][j] = 0 # Mark the cell as visited # Visit all 4 adjacent cells dfs(i + 1, j) dfs(i - 1, j) dfs(i, j + 1) dfs(i, j - 1) m, n = len(grid), len(grid[0]) num_islands = 0 for i in range(m): for j in range(n): if grid[i][j] == 1: num_islands += 1 dfs(i, j) return num_islands"},{"question":"You are given a list of flights represented by a 2D integer array `flights` where `flights[i] = [fromi, toi, pricei]` indicates a flight from city `fromi` to city `toi` with a ticket price of `pricei`. You are also provided integers `src`, `dst`, and `k`, representing the starting city, the destination city, and the maximum number of stops you are allowed to make. Return _the lowest price of a flight from `src` to `dst` with at most `k` stops_. If there is no such route, return `-1`.","solution":"import heapq from collections import defaultdict, deque def find_cheapest_price(n, flights, src, dst, k): Returns the lowest price of a flight from src to dst with at most k stops. If there is no such route, returns -1. graph = defaultdict(list) for u, v, price in flights: graph[u].append((v, price)) pq = [(0, src, 0)] costs = defaultdict(lambda: float(\'inf\')) costs[(src, 0)] = 0 while pq: total_cost, current_city, stops = heapq.heappop(pq) if current_city == dst: return total_cost if stops <= k: for neighbor, price in graph[current_city]: next_cost = total_cost + price if next_cost < costs[(neighbor, stops + 1)]: costs[(neighbor, stops + 1)] = next_cost heapq.heappush(pq, (next_cost, neighbor, stops + 1)) return -1"},{"question":"You are given an integer array `arr` and a target integer `x`. You need to find if there are two distinct integers in the array that add up to `x`. If such a pair exists, return an array of their indices in ascending order. If no such pair exists, return an empty array. Note that there may be multiple pairs that satisfy the condition, but you only need to return the indices of one such pair. Ensure your solution has a time complexity better than O(n^2).","solution":"def find_pair_with_sum(arr, x): Finds indices of two distinct integers in the array that add up to `x`. Returns an array of their indices in ascending order. If no such pair exists, return an empty array. :param arr: List of integers :param x: Target sum :return: List of two indices or empty list num_to_index = {} for i, num in enumerate(arr): complement = x - num if complement in num_to_index: return sorted([num_to_index[complement], i]) num_to_index[num] = i return []"},{"question":"You are given an integer `m` representing the number of teams in a tournament. Each team has a unique skill level represented in an integer array `skills`, where `skills[i]` is the skill level of the `i-th` team. The tournament proceeds in rounds, and in each round, each team pairs up with another team to play a match. The team with the higher skill level wins the match, and the losing team is eliminated. If two teams have the same skill level, one of them is chosen randomly to win. Return _the skill level of the team that wins the tournament_. Note: The tournament will always have `m` teams and `m` will always be a power of 2.","solution":"import random def tournament_winner(skills): Determine the winner of the tournament based on skills. In each round, the higher skill team wins. If skill levels are the same, a random one wins. :param skills: List[int] representing skill levels of teams :return: int representing the skill level of the winning team if not skills or len(skills) == 1: return skills[0] if skills else None while len(skills) > 1: next_round = [] for i in range(0, len(skills), 2): if skills[i] > skills[i+1]: next_round.append(skills[i]) elif skills[i] < skills[i+1]: next_round.append(skills[i+1]) else: next_round.append(random.choice([skills[i], skills[i+1]])) skills = next_round return skills[0]"},{"question":"You are given a string `s` containing only lowercase English letters. Your goal is to build the longest string possible by deleting some (possibly zero) characters from `s` so that every character that remains appears at least `k` times in the final string. Return _the length of the longest possible valid string you can obtain_.","solution":"from collections import Counter def longest_valid_string_length(s, k): Returns the length of the longest possible string where each character appears at least k times. # Count frequency of each character in the input string char_count = Counter(s) # Find the sum of counts for characters that appear at least k times valid_length = sum(count for count in char_count.values() if count >= k) return valid_length"},{"question":"You are given a list of `n` flights represented as a list of tuples `flights`, where `flights[i] = (start_i, end_i, price_i)` denotes a flight from city `start_i` to city `end_i` with a price `price_i`. There are `k` travelers making trips between cities and each traveler has a budget, represented as a list of tuples `trips`, where `trips[i] = (origin_i, destination_i, budget_i)` gives the starting city, destination city, and the budget of the ith traveler. For each traveler, determine if there is a sequence of flights (not necessarily direct) that will take them from their origin to their destination such that the total cost is within their budget. Return a list of booleans where each boolean indicates if the ith traveler can make the trip within the specified budget.","solution":"import heapq def is_trip_possible(flights, trips): # Create a graph from the list of flights graph = {} for start, end, price in flights: if start not in graph: graph[start] = [] graph[start].append((end, price)) def dijkstra(origin, destination, budget): # Priority queue to store (cost, node) pq = [(0, origin)] # Dictionary to store the minimum cost to reach each node min_cost = {origin: 0} while pq: current_cost, current_city = heapq.heappop(pq) if current_city == destination and current_cost <= budget: return True if current_cost > budget: continue for neighbor, price in graph.get(current_city, []): new_cost = current_cost + price if new_cost < min_cost.get(neighbor, float(\'inf\')): min_cost[neighbor] = new_cost heapq.heappush(pq, (new_cost, neighbor)) return min_cost.get(destination, float(\'inf\')) <= budget results = [] for origin, destination, budget in trips: results.append(dijkstra(origin, destination, budget)) return results"},{"question":"You are given a string `s` consisting of lowercase English letters and you are allowed to perform the following operation any number of times: select any two adjacent characters and remove them if they are the same. Your task is to return the final string after performing all possible operations. If the final string is empty, return an empty string instead. Consider the example: - For the input `s = \\"abbaca\\"`, you can remove the \\"bb\\" to get \\"aaca\\", then remove \\"aa\\" to get \\"ca\\". Since there are no more adjacent characters that are the same, the final string is \\"ca\\". Return the final string after all possible operations.","solution":"def remove_adjacent_duplicates(s): Removes adjacent duplicate characters from the string s. stack = [] for char in s: if stack and stack[-1] == char: stack.pop() else: stack.append(char) return \'\'.join(stack)"},{"question":"You are given a 2D grid of integers `grid` where each cell can contain a `0` (representing an empty cell), a `1` (representing a land cell), or a `2` (representing a water cell). The grid represents a map of a region, and your goal is to perform artificial flooding. You want to determine the minimum number of water cells `2`s you need to add to the grid such that every land cell `1` in the grid is adjacent (directly connected horizontally or vertically) to at least one water cell `2`. Return the minimum number of water cells needed to be added to achieve this condition.","solution":"def min_water_cells_to_add(grid): Returns the minimum number of water cells needed to be added to ensure every land cell is adjacent to at least one water cell. rows, cols = len(grid), len(grid[0]) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] def in_bounds(r, c): return 0 <= r < rows and 0 <= c < cols def is_adjacent_to_water(r, c): for dr, dc in directions: nr, nc = r + dr, c + dc if in_bounds(nr, nc) and grid[nr][nc] == 2: return True return False # Find all land cells that are not adjacent to any water cell land_cells = [(r, c) for r in range(rows) for c in range(cols) if grid[r][c] == 1 and not is_adjacent_to_water(r, c)] return len(land_cells)"},{"question":"Given a **0-indexed** array of integers `height` where `height[i]` represents the height of a section of fence, calculate the **largest rectangle** that can be formed between two sections of the fence. The rectangular area is only bordered by sections with heights `height[i]` and `height[j]` (where `i` and `j` are indices in the array), and the rectangle\'s height is defined as the minimum height of these two sections. The width of the rectangle is the distance between these two sections, given by the absolute difference between the indices `i` and `j`. Return _the **maximum area** of any rectangle that can be formed in this way_.","solution":"def max_area(height): Calculate the maximum area of a rectangle that can be formed between two sections of the fence. :param height: List[int], a list of integers where height[i] represents the height of a section of fence :return: int, the maximum area of the rectangle max_area = 0 left, right = 0, len(height) - 1 while left < right: width = right - left current_height = min(height[left], height[right]) current_area = width * current_height max_area = max(max_area, current_area) # Move the pointer of the shorter section to try and find a taller one if height[left] < height[right]: left += 1 else: right -= 1 return max_area"},{"question":"Given an array of positive integers `boxes` representing the number of balls in each box, you need to process a list of queries. Each query is represented as a pair `(i, j)`, and the response to the query is the **greatest common divisor (GCD)** of all the numbers in the `boxes` array starting from index `i` to index `j` (both inclusive). Return an array containing the results of each query in the same order as they were given.","solution":"import math from typing import List, Tuple def gcd_of_subarray(boxes: List[int], queries: List[Tuple[int, int]]) -> List[int]: Given an array of positive integers `boxes` and queries represented as pairs `(i, j)`, returns an array containing the GCD of all the numbers in the `boxes` array starting from index `i` to index `j` (both inclusive) for each query. def gcd(a, b): while b: a, b = b, a % b return a def calc_gcd(start, end): current_gcd = boxes[start] for k in range(start + 1, end + 1): current_gcd = gcd(current_gcd, boxes[k]) if current_gcd == 1: # Early termination for the GCD of 1 break return current_gcd results = [] for i, j in queries: results.append(calc_gcd(i, j)) return results"},{"question":"You are given two strings, `s` and `t`. Determine if `s` can be converted into `t` by replacing each character in `s` with another character such that no two characters in `s` map to the same character in `t`, and all occurrences of a character in `s` map to the same character in `t`. Return `true` if `s` can be converted into `t`, and `false` otherwise.","solution":"def can_convert(s, t): Determine if string s can be converted into string t by replacing each character in s with another character. Each character in s should map to the same character in t and no two characters in s should map to the same character in t. if len(s) != len(t): return False s_to_t_mapping = {} t_to_s_mapping = {} for sc, tc in zip(s, t): if sc in s_to_t_mapping: if s_to_t_mapping[sc] != tc: return False else: s_to_t_mapping[sc] = tc if tc in t_to_s_mapping: if t_to_s_mapping[tc] != sc: return False else: t_to_s_mapping[tc] = sc return True"},{"question":"Given a 2D grid of `m` x `n` integers, find the number of unique paths from the top-left corner to the bottom-right corner. You can only move either down or right at any point in time. Additionally, some cells may be blocked (represented by a -1) and cannot be traversed. Return the number of unique paths that avoid blocked cells. If no such path exists, return 0.","solution":"def unique_paths_with_obstacles(grid): Returns the number of unique paths from top-left corner to bottom-right corner in a grid with given obstacles. :param grid: List[List[int]] -- 2D grid of integers where -1 represents a blocked cell. :return: int -- number of unique paths avoiding blocked cells. if not grid or grid[0][0] == -1 or grid[-1][-1] == -1: return 0 m, n = len(grid), len(grid[0]) dp = [[0] * n for _ in range(m)] dp[0][0] = 1 for i in range(m): for j in range(n): if grid[i][j] == -1: dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[-1][-1]"},{"question":"You are given a 0-indexed integer array `heights` of length `n` representing the heights of a series of skyscrapers. A location `i` in the array is considered a \\"view point\\" if the height of the skyscraper at that location is greater than or equal to the height of all skyscrapers to its right, inclusive. Return _an integer array containing the indices of all view points in ascending order_.","solution":"def find_view_points(heights): Returns the indices of all view points in ascending order. A location `i` in the array is considered a \\"view point\\" if the height of the skyscraper at that location. is greater than or equal to the height of all skyscrapers to its right, inclusive. n = len(heights) if n == 0: return [] max_height_from_right = heights[-1] view_points = [n - 1] for i in range(n - 2, -1, -1): if heights[i] >= max_height_from_right: view_points.append(i) max_height_from_right = heights[i] return view_points[::-1]"},{"question":"You are given an array `timestamps` where `timestamps[i]` represents the time at which the `i`-th event occurred and a positive integer `w`. An event is valid if there exists another event that occurred at most `w` minutes before it. Two events with `timestamps[i]` and `timestamps[j]` are considered to occur at most `w` minutes apart if `|timestamps[i] - timestamps[j]| <= w`. Return the number of valid events in the array.","solution":"def valid_events_count(timestamps, w): Returns the number of valid events in the timestamps array. An event is valid if there exists another event that occurred at most w minutes before it. Parameters: timestamps (List[int]): The timestamps of events. w (int): The maximum allowable difference in minutes between two events for them to be considered valid. Returns: int: The number of valid events. valid_events = 0 for i in range(1, len(timestamps)): for j in range(i): if abs(timestamps[i] - timestamps[j]) <= w: valid_events += 1 break return valid_events"},{"question":"You are given an array `intervals` where `intervals[i] = [starti, endi]` represents the start and end of the `i-th` interval. Implement a function `mergeIntervals` that merges all overlapping intervals and returns a new array with the merged intervals. Each interval should be represented as a pair `[start, end]`. The intervals in the resulting array should be sorted in ascending order based on their start values. If there are multiple intervals with the same start value, they should be sorted by their end values. For example: - Given `intervals = [[1,3],[2,6],[8,10],[15,18]]`, your function should return `[[1,6],[8,10],[15,18]]`. - Given `intervals = [[1,4],[4,5]]`, your function should return `[[1,5]]`. Return the resulting array.","solution":"def mergeIntervals(intervals): Merges all overlapping intervals and returns a new array with the merged intervals. Args: intervals (List[List[int]]): List of intervals [start, end] Returns: List[List[int]]: List of merged intervals. if not intervals: return [] # Sort intervals by starting times; if same start, sort by end times intervals.sort(key=lambda x: (x[0], x[1])) # Initialize the merged intervals with the first interval merged = [intervals[0]] for current in intervals[1:]: last_merged = merged[-1] # If the current interval overlaps with the last merged interval, merge them if current[0] <= last_merged[1]: last_merged[1] = max(last_merged[1], current[1]) else: merged.append(current) return merged"},{"question":"Write a function `findSpiralOrder(matrix)` that returns an array of integers representing the elements of a 2D matrix in spiral order. The spiral order starts at the top-left corner of the matrix and moves right across the top row, then down the last column, then left across the bottom row, and then up the first column, repeating this pattern inward until all elements have been included. If the matrix is empty, return an empty array. The matrix is represented by a list of lists, where each inner list is a row of elements. Example: ``` Input: matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] Output: [1, 2, 3, 6, 9, 8, 7, 4, 5] ```","solution":"def findSpiralOrder(matrix): Returns the elements of the matrix in spiral order. if not matrix: return [] spiral_order = [] top, bottom = 0, len(matrix) - 1 left, right = 0, len(matrix[0]) - 1 while top <= bottom and left <= right: for i in range(left, right + 1): spiral_order.append(matrix[top][i]) top += 1 for i in range(top, bottom + 1): spiral_order.append(matrix[i][right]) right -= 1 if top <= bottom: for i in range(right, left - 1, -1): spiral_order.append(matrix[bottom][i]) bottom -= 1 if left <= right: for i in range(bottom, top - 1, -1): spiral_order.append(matrix[i][left]) left += 1 return spiral_order"},{"question":"You are given a binary tree represented as an array where each element denotes a node in the tree and its value. The element at index 0 represents the root of the tree, elements at indices 1 and 2 represent the children of the root (left and right respectively), and similarly for subsequent levels. Write a function to return the maximum depth of the binary tree. The tree is not necessarily balanced, and some nodes might not have both children (represented as `None` in the tree array). Your function should handle cases where the tree is empty.","solution":"def maxDepth(arr): Returns the maximum depth of the binary tree represented as an array. Parameters: - arr: List[int or None], a list representing the binary tree. Returns: - int: Maximum depth of the binary tree. def depth(index): if index >= len(arr) or arr[index] is None: return 0 left_depth = depth(2 * index + 1) right_depth = depth(2 * index + 2) return 1 + max(left_depth, right_depth) return depth(0)"},{"question":"A tree is an undirected graph in which any two nodes are connected by exactly one path. In a tree of `n` nodes numbered from `0` to `n-1`, find the length of the longest path existing between any two nodes. The length of a path is represented by the number of edges between the two nodes. You are given a 2D array `edges` where `edges[i] = [u, v]` denotes an edge between nodes `u` and `v`. Return _the length of the longest path in the tree_.","solution":"from collections import deque, defaultdict def longest_path_in_tree(n, edges): Returns the length of the longest path in the tree. :param n: int - number of nodes in the tree :param edges: List[List[int]] - edges of the tree :return: int - length of the longest path if n == 1: return 0 # Build the graph graph = defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) # Helper utility function to perform BFS and return farthest node and its distance def bfs(node): visited = [-1] * n q = deque([(node, 0)]) visited[node] = 0 farthest_node = node max_distance = 0 while q: current_node, current_distance = q.popleft() for neighbor in graph[current_node]: if visited[neighbor] == -1: visited[neighbor] = current_distance + 1 q.append((neighbor, current_distance + 1)) if visited[neighbor] > max_distance: max_distance = visited[neighbor] farthest_node = neighbor return farthest_node, max_distance # Start from an arbitrary node (node 0), find farthest node A farthest_node_A, _ = bfs(0) # From node A, find the farthest node B, the distance from A to B is the longest path _, longest_path_length = bfs(farthest_node_A) return longest_path_length"},{"question":"You are given a list of flights, represented as a series of routes between cities. Each route is represented as a tuple `(source, destination, cost)`, indicating the route from `source` to `destination` with a travel cost of `cost`. The list of flights may include several paths between the same pair of cities, with different travel costs. You are also given two integers `n` and `k`. The integer `n` represents the total number of cities labeled from `0` to `n-1`, and `k` represents the maximum number of stops you are allowed to make during your trip. The task is to find the minimum travel cost to reach the `destination` city from the `source` city with at most `k` stops. If there is no valid path with `k` stops or less, return -1. **Input:** - `flights`: List of (source, destination, cost) tuples - `n`: Total number of cities - `source`: Starting city - `destination`: Target city - `k`: Maximum number of allowed stops **Output:** - Return the minimum travel cost from `source` to `destination` with at most `k` stops, or -1 if no such path exists.","solution":"import heapq from collections import defaultdict, deque def find_cheapest_price(n, flights, source, destination, k): # Create an adjacency list for the graph representation graph = defaultdict(list) for u, v, w in flights: graph[u].append((v, w)) # Priority queue to hold (cost, current city, stops) pq = [(0, source, 0)] # Dictionary to record the minimum cost to reach each node with at most a certain number of stops costs = {(source, 0): 0} while pq: cost, node, stops = heapq.heappop(pq) # If we reach the destination within the allowed stops, return the cost if node == destination and stops <= k + 1: return cost # If we can still make a stop if stops <= k: for nei, price in graph[node]: next_cost = cost + price if (nei, stops + 1) not in costs or next_cost < costs[(nei, stops + 1)]: costs[(nei, stops + 1)] = next_cost heapq.heappush(pq, (next_cost, nei, stops + 1)) return -1"},{"question":"You are given two **0-indexed** integer arrays `arr1` and `arr2`, both of length `n`, and an integer `k`. Initial values of both arrays are between `0` and `1`. In one operation, you can choose an index `i` (`0 <= i < n`) and invert both `arr1[i]` and `arr2[i]` simultaneously (change `0` to `1` and `1` to `0`). The goal is to make both arrays equal, that is, `arr1[j] == arr2[j]` for all `0 <= j < n`. Return _the **minimum number** of operations needed to make both arrays equal, or `-1` if it is not possible within `k` operations_.","solution":"def min_operations_to_equal_arrays(arr1, arr2, k): Returns the minimum number of operations needed to make arr1 and arr2 equal or -1 if it is not possible within k operations. if len(arr1) != len(arr2): return -1 n = len(arr1) diff_count = sum(1 for i in range(n) if arr1[i] != arr2[i]) if diff_count % 2 != 0 or diff_count > 2 * k: return -1 return diff_count // 2"},{"question":"You are given a list of strings `words`, where each string is a word consisting of lowercase English letters only. Your task is to determine if there exists a pair of words `(word1, word2)` from the list, such that `word1 + word2` (concatenation of `word1` and `word2`) is a palindrome. A palindrome is a string that reads the same forward and backward. If such a pair exists, return `true`. Otherwise, return `false`. For example, given the input list `[\\"bat\\", \\"tab\\", \\"cat\\"]`, the concatenation of `\\"bat\\"` and `\\"tab\\"` is `\\"battab\\"`, which is a palindrome. Therefore, the function should return `true`.","solution":"def is_palindrome(s): Helper function to check if a string is a palindrome. return s == s[::-1] def palindrome_pair(words): Function to determine if there exists a pair of words in the input list such that their concatenation is a palindrome. word_set = set(words) for word in words: for i in range(len(word) + 1): prefix = word[:i] suffix = word[i:] # Check if the suffix + prefix is a palindrome if is_palindrome(prefix) and suffix[::-1] in word_set and suffix[::-1] != word: return True # Check if the prefix + suffix is a palindrome if is_palindrome(suffix) and prefix[::-1] in word_set and prefix[::-1] != word: return True return False"},{"question":"Write a function that takes as input a list of strings, where each string represents a word. The function should return a dictionary where the keys are the words from the input list and the values are the counts of how many times each word appears in the input list. Ensure the words are case insensitive, meaning \\"Word\\" and \\"word\\" should be counted as the same word.","solution":"def count_words(word_list): Takes a list of words and returns a dictionary with words as the keys and their counts as the values. Words are counted in a case-insensitive manner. :param word_list: List of words :return: Dictionary with word counts word_count = {} for word in word_list: word_lower = word.lower() if word_lower in word_count: word_count[word_lower] += 1 else: word_count[word_lower] = 1 return word_count"},{"question":"An organization is looking to distribute work among their employees in an efficient manner. Each employee has a certain level of skill which is represented by an integer. The organization wants to assign tasks such that the difference in skill levels between any two employees assigned to the same task does not exceed a certain threshold. Given an array `skills` of size `n` where `skills[i]` represents the skill level of the `i-th` employee, and an integer `threshold`, return the maximum number of tasks that can be assigned. Each task requires exactly two employees. A task can be assigned if the absolute difference in their skill levels is less than or equal to `threshold`. * For example, if `skills = [4, 8, 5, 3, 1]` and `threshold = 2`, then one possible way to assign the tasks is to pair employees with skill levels [3, 1] and [5, 4].","solution":"def max_tasks(skills, threshold): Returns the maximum number of tasks that can be assigned where each task has exactly two employees with a skill difference that does not exceed the threshold. skills.sort() i, j = 0, 1 num_tasks = 0 n = len(skills) while i < n and j < n: if (skills[j] - skills[i]) <= threshold: num_tasks += 1 i += 2 j = i + 1 else: j += 1 if j == n and i + 1 < n: i += 1 j = i + 1 return num_tasks"},{"question":"Given a `matrix` of characters and a target `word`, return `true` if the word exists in the matrix, or `false` otherwise. The word can be constructed from letters of sequentially adjacent cells, where \\"adjacent\\" cells are horizontally or vertically neighboring. The same letter cell may not be used more than once. Implement the function as: ```python def exist(board: List[List[str]], word: str) -> bool: ``` **Example:** ``` Input: board = [[\'A\',\'B\',\'C\',\'E\'], [\'S\',\'F\',\'C\',\'S\'], [\'A\',\'D\',\'E\',\'E\']], word = \\"ABCCED\\" Output: true Input: board = [[\'A\',\'B\',\'C\',\'E\'], [\'S\',\'F\',\'C\',\'S\'], [\'A\',\'D\',\'E\',\'E\']], word = \\"SEE\\" Output: true Input: board = [[\'A\',\'B\',\'C\',\'E\'], [\'S\',\'F\',\'C\',\'S\'], [\'A\',\'D\',\'E\',\'E\']], word = \\"ABCB\\" Output: false ``` Ensure your solution has an average time complexity that handles large inputs efficiently.","solution":"def exist(board, word): def dfs(board, word, i, j, index): if index == len(word): return True if i < 0 or i >= len(board) or j < 0 or j >= len(board[0]) or board[i][j] != word[index]: return False temp = board[i][j] board[i][j] = \'#\' found = dfs(board, word, i+1, j, index+1) or dfs(board, word, i-1, j, index+1) or dfs(board, word, i, j+1, index+1) or dfs(board, word, i, j-1, index+1) board[i][j] = temp return found for i in range(len(board)): for j in range(len(board[0])): if dfs(board, word, i, j, 0): return True return False"},{"question":"You are given an unsorted integer array `arr` and an integer `k`. Sort the array such that each element can move at most `k` positions away from its original position. Return the sorted array. **Description**: Implement an algorithm that sorts an almost sorted array where each element is at most `k` positions away from its sorted position. The solution should make use of an appropriate data structure to ensure efficient sorting given the constraints on the element movements.","solution":"import heapq def sort_k_sorted_array(arr, k): Sorts an array where each element is at most k positions away from its sorted position. :param arr: List[int] - The input unsorted integer array :param k: int - The maximum distance any element can be from its sorted position :return: List[int] - The k-sorted result if not arr or k < 0: return arr # Create a min heap with the first k+1 elements min_heap = arr[:k+1] heapq.heapify(min_heap) sorted_index = 0 # Process remaining elements in the array for i in range(k+1, len(arr)): arr[sorted_index] = heapq.heappop(min_heap) heapq.heappush(min_heap, arr[i]) sorted_index += 1 # Place remaining elements from the min heap to the array while min_heap: arr[sorted_index] = heapq.heappop(min_heap) sorted_index += 1 return arr"},{"question":"You are given a 2D grid of size `m x n` representing a labyrinth, where `1` represents an open cell through which you can pass, and `0` represents a blocked cell. Your task is to find the shortest path from the top-left corner to the bottom-right corner, moving only up, down, left, or right. If there is no possible path, return `-1`. The grid guarantees that the top-left and bottom-right cells are always open. Return the length of the shortest path.","solution":"from collections import deque def shortest_path_labyrinth(grid): Calculate the shortest path from top-left to bottom-right in a labyrinth grid. Args: grid: List[List[int]]: A 2D list where 1 represents open paths and 0 represents blocked cells. Returns: int: The length of the shortest path from the top-left to the bottom-right cell. -1 if no path exists. if not grid or not grid[0]: return -1 m, n = len(grid), len(grid[0]) if grid[0][0] == 0 or grid[m-1][n-1] == 0: return -1 # Directions for moving in the grid: right, down, left, up directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([(0, 0, 1)]) # (x, y, distance) visited = set((0, 0)) while queue: x, y, distance = queue.popleft() # If we reached the bottom-right corner if x == m-1 and y == n-1: return distance for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and (nx, ny) not in visited and grid[nx][ny] == 1: visited.add((nx, ny)) queue.append((nx, ny, distance + 1)) return -1"},{"question":"There are `n` bulbs in a row, numbered from `1` to `n`. Initially, all the bulbs are switched off. Each bulb has a switch associated with it. You are given an array `presses`, where `presses[i]` represents the switch number pressed at the `i-th` press. When a switch is pressed, it toggles that bulb\'s state (from off to on or from on to off). Write a function to return the number of bulbs that are on after all the switches in `presses` have been pressed in the given order.","solution":"def count_bulbs_on(n, presses): Returns the number of bulbs that are on after all the switches in \'presses\' have been pressed. n : int : The number of bulbs presses: list of int : The list representing the switch number pressed in the order return : int : Number of bulbs that are on # Initialize all bulbs to off (0) bulbs = [0] * n # Toggle the bulbs according to the presses for switch in presses: # Toggle the bulb state: 0 becomes 1, 1 becomes 0 bulbs[switch - 1] ^= 1 # Count the number of bulbs that are on return sum(bulbs)"},{"question":"You are given an array of integers `heights` where `heights[i]` represents the height of the `i-th` student. The students stand in a line and cannot see the board if there\'s a taller student standing in front of them. Return _the **maximum** number of students who can see the board when they are arranged in any order you choose_.","solution":"def max_students_can_see_board(heights): Returns the maximum number of students who can see the board. heights.sort(reverse=True) tallest_so_far = heights[0] count = 1 for i in range(1, len(heights)): if heights[i] < tallest_so_far: count += 1 tallest_so_far = heights[i] return count"},{"question":"You are given a list of `n` integers. You need to partition the list into two subsets such that the sum of the elements in both subsets is equal. Return `true` if you can achieve this partition, or `false` otherwise.","solution":"def can_partition(nums): total_sum = sum(nums) # If the total sum is odd, it\'s impossible to partition it into equal subsets if total_sum % 2 != 0: return False target = total_sum // 2 n = len(nums) # Create a 1D DP array dp = [False] * (target + 1) dp[0] = True # Iterate through the numbers for num in nums: # Update the dp array from right to left for i in range(target, num - 1, -1): dp[i] = dp[i] or dp[i - num] return dp[target]"},{"question":"You are given a binary tree represented by its `root` node. Return _the sum of values of its deepest leaves_.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left = left self.right = right def deepest_leaves_sum(root): if not root: return 0 from collections import deque queue = deque([root]) while queue: level_sum = 0 for _ in range(len(queue)): node = queue.popleft() level_sum += node.val if node.left: queue.append(node.left) if node.right: queue.append(node.right) return level_sum"},{"question":"`You are given a binary tree where each node is labeled with a number. You need to determine the sum of values of all nodes that are at an even depth. The root node is at depth 0, its children are at depth 1, its grandchildren are at depth 2, and so on. Given the root node of a binary tree, return the sum of values of all nodes that are at an even depth.`","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def sum_of_even_depths(root): Calculate the sum of values of all nodes that are at an even depth. def dfs(node, depth): if not node: return 0 sum_val = node.val if depth % 2 == 0 else 0 return sum_val + dfs(node.left, depth + 1) + dfs(node.right, depth + 1) return dfs(root, 0)"},{"question":"Given a `2D` grid of integers representing a map where `1` represents land and `0` represents water, write a function to determine the perimeter of the shape formed by the land cells. The grid cells are connected horizontally/vertically (not diagonally). The perimeter is calculated by adding each cell\'s boundary that touches water or the edge of the grid. Return _the **perimeter** of the land shape as an integer_.","solution":"def islandPerimeter(grid): Returns the perimeter of the island in the given grid. if not grid or not grid[0]: return 0 perimeter = 0 rows = len(grid) cols = len(grid[0]) for i in range(rows): for j in range(cols): if grid[i][j] == 1: # Check top if i == 0 or grid[i-1][j] == 0: perimeter += 1 # Check bottom if i == rows-1 or grid[i+1][j] == 0: perimeter += 1 # Check left if j == 0 or grid[i][j-1] == 0: perimeter += 1 # Check right if j == cols-1 or grid[i][j+1] == 0: perimeter += 1 return perimeter"},{"question":"You are given a **0-indexed** integer array `heights`, where `heights[i]` represents the height of the `i-th` student in a class. The students are initially arranged from left to right in random order. You need to arrange the students in non-decreasing order of their heights. Return the **minimum number** of moves required to make this arrangement. In one move, you can take any student and place them at any position in the array.","solution":"def minimum_moves_to_sort(heights): Returns the minimum number of moves required to arrange the students\' heights in non-decreasing order. In one move, you can take any student and place them at any position in the array. n = len(heights) sorted_heights = sorted(heights) # Find the length of the longest increasing subsequence (LIS) that is # already in the given heights list. lis_length = [1] * n for i in range(n): for j in range(i): if heights[i] >= heights[j]: lis_length[i] = max(lis_length[i], lis_length[j] + 1) longest_increasing_subsequence = max(lis_length) return n - longest_increasing_subsequence"},{"question":"Given a string `s`, find the length of the longest substring of `s` such that every character in this substring appears at least `p` times. Return _the length of the longest_ _substring_ _of `s` where each character appears at least_ `p` _times_.","solution":"def longest_substring_with_at_least_p_repeats(s, p): Given a string s and an integer p, returns the length of the longest substring such that every character in this substring appears at least p times. def helper(s, p): if len(s) < p: return 0 frequency = {} for char in s: frequency[char] = frequency.get(char, 0) + 1 for char in frequency: if frequency[char] < p: # Split the string by this character and recursively check each part return max(helper(t, p) for t in s.split(char)) # If all characters meet the frequency requirement, return the length of the string return len(s) return helper(s, p)"},{"question":"Given a string `s`, return _the length of the shortest palindromic subsequence that can be formed by adding at most one character to_ `s`. If the string is already a palindrome, return its length.","solution":"def is_palindrome(s): return s == s[::-1] def shortest_palindromic_subsequence_length(s): Returns the length of the shortest palindromic subsequence that can be formed by adding at most one character to s. If the string is already a palindrome, return its length. if is_palindrome(s): return len(s) # Check if adding one character can make it a palindrome for i in range(len(s)): if is_palindrome(s[:i] + s[i+1:]): return len(s) + 1 # If no single addition makes it a palindrome, add one character at the end return len(s) + 1"},{"question":"You are given a string `s` consisting of lowercase letters. You have to perform the following operation until you cannot anymore: Find the leftmost pair of adjacent letters that are the same and remove them from the string. After removing a pair, concatenate the remaining parts of the string. Return the final string after performing all possible operations. If the final string is empty, return an empty string.","solution":"def remove_adjacent_pairs(s: str) -> str: stack = [] for char in s: if stack and stack[-1] == char: stack.pop() else: stack.append(char) return \'\'.join(stack)"},{"question":"You are given two strings `s` and `t`, and you need to transform string `s` into string `t` using the following operations beginning from an empty string: 1. Append any character to the string. 2. Delete the last character of the string. Determine the **minimum number of operations** required to transform `s` into `t`. Return the minimum number of operations needed to make the transformation.","solution":"def min_operations(s, t): Returns the minimum number of operations required to transform string `s` into string `t`. # Find the length of the strings len_s = len(s) len_t = len(t) # Find the length of the longest common prefix of s and t common_length = 0 while (common_length < len_s and common_length < len_t and s[common_length] == t[common_length]): common_length += 1 # Operations needed to remove the characters in s but not in the common prefix delete_operations = len_s - common_length # Operations needed to add the characters in t but not in the common prefix append_operations = len_t - common_length # Total operations return delete_operations + append_operations"},{"question":"You are given an integer array `heights` representing the heights of buildings on an infinitely long street. The array `heights` is guaranteed to have a length greater than or equal to 1. You are also given an integer `w` and you have an endoscope with a maximum distance view of `2w` units wide. The endoscope can only view the building directly in front of it and `w` buildings on either side. Your task is to determine the maximum height visible in each range of the endoscope as it moves along the street from the first building to the last building. Return an array containing the maximum height in each endoscope range. In the array, for the first building, the endoscope view would be `[first_building to first_building + w]`, for the second building `[second_building - w to second_building + w]` and so on, until the last building which will have the view `[last_building - w to last_building]`. If the view exceeds the range of the street, adjust accordingly to fit the street bounds. For example, if the `heights` array is `[2, 1, 4, 5, 3, 2]` and `w = 1`, the output array should be `[2, 4, 5, 5, 5, 3]`, signifying the maximum heights visible to the endoscope at each position along the street.","solution":"def max_heights_visible(heights, w): Determines the maximum height visible in each range of the endoscope as it moves along the street. Args: heights (list of int): List of building heights. w (int): The half width of the endoscope view. Returns: list of int: List of maximum heights in each view range. n = len(heights) max_heights = [] for i in range(n): start = max(0, i - w) end = min(n - 1, i + w) max_heights.append(max(heights[start:end+1])) return max_heights"},{"question":"You are given a string `s` containing lowercase and uppercase letters. An \\"almost palindrome\\" is defined as a string that can become a palindrome by removing **at most** one character. Given the string `s`, determine whether it is an \\"almost palindrome\\". Return `true` if `s` can be transformed into a palindrome by removing at most one character, and `false` otherwise.","solution":"def is_almost_palindrome(s): Determines if the string can be transformed into a palindrome by removing at most one character. :param s: Input string :return: Boolean indicating if the string is an \\"almost palindrome\\" def is_palindrome_range(i, j): while i < j: if s[i] != s[j]: return False i += 1 j -= 1 return True start, end = 0, len(s) - 1 while start < end: if s[start] != s[end]: # Try removing either start or end character return is_palindrome_range(start + 1, end) or is_palindrome_range(start, end - 1) start += 1 end -= 1 return True"},{"question":"Given an array of integers `arr`, you need to partition the array into exactly three non-empty contiguous subarrays such that the sum of the elements in these subarrays are equal. If it\'s possible to partition the array this way, return `true`, otherwise return `false`. Note that the partitioned subarrays should not overlap with each other and must cover the entire array.","solution":"def can_partition_into_three_equal_sum_subarrays(arr): total_sum = sum(arr) if total_sum % 3 != 0: return False target_sum = total_sum // 3 n = len(arr) current_sum, partitions = 0, 0 for number in arr: current_sum += number if current_sum == target_sum: partitions += 1 current_sum = 0 if partitions == 2: # We need only 2 partitions, the rest will be the third part return True return False"},{"question":"You are given a matrix `grid` of size `m x n` representing a map, where each cell in the grid contains a value indicating the height of the terrain at that point. You are also given a start position `(start_x, start_y)` and a destination position `(end_x, end_y)`. You can move in four possible directions within the grid (up, down, left, right), but can move to a cell only if the elevation difference between the current cell and the destination cell is less than or equal to 1. Return _the minimum number of steps needed to reach the destination from the start position using valid movements_. If it is not possible to reach the destination, return `-1`.","solution":"from collections import deque def min_steps(grid, start_x, start_y, end_x, end_y): Find the minimum number of steps required to reach the destination from the start position with the given grid conditions. m, n = len(grid), len(grid[0]) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] def is_valid(x, y): return 0 <= x < m and 0 <= y < n visited = [[False for _ in range(n)] for _ in range(m)] queue = deque([(start_x, start_y, 0)]) visited[start_x][start_y] = True while queue: x, y, steps = queue.popleft() if (x, y) == (end_x, end_y): return steps for dx, dy in directions: nx, ny = x + dx, y + dy if is_valid(nx, ny) and not visited[nx][ny] and abs(grid[x][y] - grid[nx][ny]) <= 1: queue.append((nx, ny, steps + 1)) visited[nx][ny] = True return -1"},{"question":"You are given two arrays `arr1` and `arr2`, each containing distinct integers. Find the length of the longest subarray that appears in both arrays, with the elements in the same order in both subsequences. For example, if `arr1 = [1, 2, 3, 4, 5]` and `arr2 = [3, 4, 5, 6, 7]`, then the longest common subarray is `[3, 4, 5]` with a length of `3`. Return the length of the longest common subarray.","solution":"def longest_common_subarray_length(arr1, arr2): Returns the length of the longest common subarray with elements in same order in both arrays. n = len(arr1) m = len(arr2) dp = [[0] * (m + 1) for _ in range(n + 1)] max_len = 0 for i in range(1, n + 1): for j in range(1, m + 1): if arr1[i - 1] == arr2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 max_len = max(max_len, dp[i][j]) return max_len"},{"question":"Given a list of **n** integers, determine whether it is possible to rearrange the list such that no two adjacent integers have the same value. If it is possible, return the rearranged list. If there are multiple valid rearrangements, return any of them. If it is not possible, return an empty list.","solution":"from collections import Counter from heapq import heappush, heappop def rearrange_list(nums): Rearranges the list such that no two adjacent integers are the same. Parameters: nums (List[int]): List of integers. Returns: List[int]: Rearranged list or empty list if not possible. if not nums: return [] count = Counter(nums) max_heap = [] for num, cnt in count.items(): heappush(max_heap, (-cnt, num)) result = [] prev_cnt, prev_num = 0, None while max_heap: cnt, num = heappop(max_heap) result.append(num) if prev_cnt < 0: heappush(max_heap, (prev_cnt, prev_num)) prev_cnt, prev_num = cnt + 1, num if len(result) != len(nums): return [] return result"},{"question":"Given a list of directories `directories` where directories[i] represents the absolute path of the i-th directory as a string. A sub-directory ends with the “/” character. Delete all the redundant parent directories which are ancestors of other directories in the list and return the list in lexicographical order of the remaining directories. For example, if `directories` is [\\"/a\\", \\"/a/b\\", \\"/c/d\\", \\"/c/d/e\\", \\"/c/f\\"], you should return [\\"/a\\", \\"/c/d\\", \\"/c/f\\"] since \\"/a\\" is a parent directory of \\"/a/b\\" and \\"/c/d\\" is a parent directory of \\"/c/d/e\\". You need to implement the function: ```python def remove_redundant_directories(directories: List[str]) -> List[str]: pass ```","solution":"from typing import List def remove_redundant_directories(directories: List[str]) -> List[str]: # First, sort the directories lexicographically directories.sort() # Initialize a list to hold the result result = [] # Iterate through each directory for directory in directories: # If result is empty or the last entry in result is not a parent of the current directory if not result or not directory.startswith(result[-1] + \'/\'): result.append(directory) return result"},{"question":"Implement a data structure that supports adding new words and finding if a string matches any previously added string with support for \'.\' wildcards. The \'.\' character can represent any one letter. Implement the `WordDictionary` class: * `WordDictionary()` Initializes the object. * `void addWord(String word)` Adds a word into the data structure. * `boolean search(String word)` Returns `true` if the word is in the data structure (with support for \'.\' wildcards), otherwise returns `false`. For example, the `addWord(\\"bad\\")` and `search(\\"b.d\\")` should return `true` since \'.\' can represent \'a\'.","solution":"class WordDictionary: def __init__(self): self.words = [] def addWord(self, word): self.words.append(word) def search(self, word): for w in self.words: if len(w) != len(word): continue for i in range(len(w)): if word[i] != \'.\' and word[i] != w[i]: break else: return True return False"},{"question":"A company has `n` employees numbered from `0` to `n - 1`. Each employee has a unique rating represented by the array `ratings` where `ratings[i]` is the rating of the `i-th` employee. The company wants to create teams such that each team consists of at least one employee and the sum of ratings of the employees in the team does not exceed `maxRating`. Return the _number of different ways_ to form such teams or `-1` if it’s not possible to form any team respecting the constraints. Note that teams with different sets of employees are considered different teams even if they have the same sum of ratings.","solution":"def count_teams(ratings, maxRating): n = len(ratings) def count_subsets(idx, current_sum): if current_sum > maxRating: return 0 if idx == n: return 1 if current_sum <= maxRating else 0 include = count_subsets(idx + 1, current_sum + ratings[idx]) exclude = count_subsets(idx + 1, current_sum) return include + exclude count = count_subsets(0, 0) - 1 # Subtract 1 to exclude the empty subset return count if count > 0 else -1"},{"question":"A researcher is analyzing sequences of DNA represented as strings composed of the characters \'A\', \'C\', \'G\', and \'T\'. He wants to identify the most frequently occurring 10-letter-long sequences (substrings) that appear in a DNA string `s`. Write a function to find all the 10-letter-long sequences (substrings) that occur more than once in a DNA molecule. You need to return these sequences as a list of strings, where each string represents a 10-letter-long repeating sequence. If no such sequence is found, return an empty list. The DNA string `s` will be at least 10 characters long.","solution":"from collections import defaultdict def find_repeated_dna_sequences(s): Returns a list of 10-letter-long sequences (substrings) that occur more than once in the given DNA string `s`. sequence_length = 10 sequence_count = defaultdict(int) result = [] for i in range(len(s) - sequence_length + 1): sequence = s[i:i + sequence_length] sequence_count[sequence] += 1 for sequence, count in sequence_count.items(): if count > 1: result.append(sequence) return result"},{"question":"Given an `n x n` grid where each cell is either a `0` (empty) or a `1` (blocked), return _the length of the shortest path from the top-left corner `(0, 0)` to the bottom-right corner `(n-1, n-1)`, moving only up, down, left, or right_. If no such path exists, return `-1`.","solution":"from collections import deque def shortest_path_binary_matrix(grid): if not grid or grid[0][0] == 1 or grid[-1][-1] == 1: return -1 n = len(grid) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([(0, 0, 1)]) visited = set((0, 0)) while queue: x, y, length = queue.popleft() if x == n-1 and y == n-1: return length for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < n and (nx, ny) not in visited and grid[nx][ny] == 0: queue.append((nx, ny, length + 1)) visited.add((nx, ny)) return -1"},{"question":"Given an array of integers `arr`, you are allowed to perform the following operation any number of times: Choose two adjacent elements and remove the smaller one. Your task is to determine the minimum possible value of the largest element in the array after performing the operations.","solution":"def min_largest_after_operations(arr): Returns the minimum possible value of the largest element in the array by repeatedly removing the smaller of two adjacent elements. return min(arr)"},{"question":"You are given a **0-indexed** integer array `heights` representing the heights of trees in a row. You can choose to cut down some of the trees, removing the elements from the array. After cutting down some trees, the remaining trees should form a strictly increasing sequence in terms of their heights. Return _the **minimum** number of trees you need to cut down_ to achieve this. For example, given the input `heights = [3, 7, 5, 6, 9]`, the output should be `1` because you can remove the tree with height `5` to get the increasing sequence `[3, 7, 6, 9]`.","solution":"def min_trees_to_cut(heights): from bisect import bisect_left def longest_increasing_subsequence(seq): lis = [] for x in seq: idx = bisect_left(lis, x) if idx == len(lis): lis.append(x) else: lis[idx] = x return len(lis) n = len(heights) lis_length = longest_increasing_subsequence(heights) return n - lis_length"},{"question":"You are given an array of integers `arr` and a target integer `target`. Your task is to find a **continuous subarray** whose sum equals the target integer and has the **smallest possible length**. If there are multiple subarrays with the same smallest length that sum to the target, return any one of them. If no such subarray exists, return an empty array. Note that the subarray must contain at least one integer and should consist of contiguous elements of the original array.","solution":"def min_length_subarray(arr, target): Finds the smallest continuous subarray whose sum equals the target. If there are multiple subarrays with the same smallest length that sum to the target, returns any one of them. If no such subarray exists, returns an empty array. n = len(arr) min_len = float(\'inf\') start = 0 current_sum = 0 result = [] for end in range(n): current_sum += arr[end] while current_sum >= target: if current_sum == target: if end - start + 1 < min_len: min_len = end - start + 1 result = arr[start:end + 1] current_sum -= arr[start] start += 1 return result"},{"question":"**[Question 4]:** You are given an integer array `arr` of length `n` and an integer `k`. Your task is to determine the number of unique pairs `(i, j)` where `0 <= i, j < n` and `i != j` such that the absolute difference between `arr[i]` and `arr[j]` is exactly `k`. Return _the number of such unique pairs_.","solution":"def count_pairs_with_difference(arr, k): Returns the number of unique pairs (i, j) where 0 <= i, j < n and i != j such that the absolute difference between arr[i] and arr[j] is exactly k. :param arr: List of integers. :param k: Integer for the absolute difference. :return: Integer count of unique pairs. count = 0 seen = set(arr) for num in arr: if (num + k) in seen: count += 1 if (num - k) in seen: count += 1 # Each pair is counted twice, so need to divide the count by 2. return count // 2"},{"question":"You are given a 0-indexed integer array `nums` containing `n` distinct numbers in the range `[0, n]`. All the numbers in this range are present in the array except one. Find and return the missing number.","solution":"def find_missing_number(nums): Given a list `nums` containing distinct numbers in the range `[0, n]` except one missing number, this function finds and returns the missing number. n = len(nums) total_sum = n * (n + 1) // 2 array_sum = sum(nums) missing_number = total_sum - array_sum return missing_number"},{"question":"Given an array of integers, return the length of the longest subarray that contains only even numbers.","solution":"def longest_even_subarray(arr): Returns the length of the longest subarray that contains only even numbers. Parameters: arr (list of int): The input array of integers. Returns: int: The length of the longest subarray containing only even numbers. max_length = 0 current_length = 0 for num in arr: if num % 2 == 0: current_length += 1 max_length = max(max_length, current_length) else: current_length = 0 return max_length"},{"question":"You are given a collection of `n` items, each with a weight `w[i]` and a value `v[i]`. You want to fill a knapsack with a capacity `W` such that the total value is maximized. However, you are also given a constraint in the form of a set of forbidden item pairs `F`, where each pair `(i, j)` indicates that items `i` and `j` cannot be included in the knapsack together. Implement a function to determine the maximum value you can obtain while respecting the capacity and forbidden pairs constraints.","solution":"def knapsack_with_constraints(n, weights, values, W, forbidden_pairs): from itertools import combinations def is_valid_set(selected_indices, forbidden_pairs): selected_set = set(selected_indices) for (i, j) in forbidden_pairs: if i in selected_set and j in selected_set: return False return True max_value = 0 for r in range(n + 1): for item_set in combinations(range(n), r): total_weight = sum(weights[i] for i in item_set) total_value = sum(values[i] for i in item_set) if total_weight <= W and is_valid_set(item_set, forbidden_pairs): max_value = max(max_value, total_value) return max_value"},{"question":"You are given an array of integers `arr` where the absolute difference between any two consecutive elements is at most `1`. Your task is to sort the array in non-decreasing order. You must implement an in-place sorting algorithm that operates in linear time. Return the sorted array.","solution":"def sort_almost_sorted_array(arr): Sorts an array where the absolute difference between any two consecutive elements is at most 1. The function uses counting sort given the constraint, which is suitable for linear time sorting. :param arr: A list of integers :return: A sorted list of integers in non-decreasing order if not arr: return arr min_val = min(arr) max_val = max(arr) count = [0] * (max_val - min_val + 1) for num in arr: count[num - min_val] += 1 index = 0 for val in range(len(count)): while count[val] > 0: arr[index] = val + min_val index += 1 count[val] -= 1 return arr"},{"question":"Given an integer array `arr`, you are to remove each occurrence of the most frequent element until no such element remains. If there are multiple elements with the same highest frequency, remove any one of them. The process is repeated until the array is empty. Return _the total number of removal operations performed_.","solution":"from collections import Counter def remove_most_frequent(arr): Returns the number of removal operations performed until the array is empty by removing each occurrence of the most frequent element. removal_operations = 0 while arr: count = Counter(arr) most_frequent = count.most_common(1)[0][0] occurrences = count[most_frequent] removal_operations += occurrences arr = [x for x in arr if x != most_frequent] return removal_operations"},{"question":"You are given `k` integer arrays, each of which is sorted in ascending order. Write a function to merge all the arrays into a single sorted array while maintaining the order. Return the merged sorted array. You should aim to achieve this with an efficient algorithm.","solution":"import heapq def merge_sorted_arrays(arrays): Merge k sorted arrays into a single sorted array. Parameters: arrays (list of list of int): a list of k sorted integer arrays Returns: list of int: a single sorted array # Create a min-heap to store the first element of each array along with the array index and element index min_heap = [] for array_index, array in enumerate(arrays): if array: # check if the array is not empty heapq.heappush(min_heap, (array[0], array_index, 0)) result = [] while min_heap: # Get the smallest element from the heap value, array_index, element_index = heapq.heappop(min_heap) result.append(value) # If there is another element in the same array, add it to the heap if element_index + 1 < len(arrays[array_index]): next_tuple = (arrays[array_index][element_index + 1], array_index, element_index + 1) heapq.heappush(min_heap, next_tuple) return result"},{"question":"Given an integer array `nums` and an integer `k`, return the _k-_th distinct element of the array. If there are fewer than `k` distinct elements, return an empty string `\\"\\" `. The elements in the array are considered in the order in which they appear.","solution":"def kth_distinct_element(nums, k): Returns the k-th distinct element of the array `nums`. If there are fewer than k distinct elements, returns an empty string. Parameters: nums (list of int): List of integers. k (int): The k-th position to find the distinct element. Returns: int or str : The k-th distinct element or \\"\\" if fewer than k distinct elements exist. distinct_elements = [] seen = set() for num in nums: if num not in seen: distinct_elements.append(num) seen.add(num) if k <= len(distinct_elements): return distinct_elements[k-1] else: return \\"\\""},{"question":"Given an array `nums` containing `n` distinct numbers in the range `[0, n]`, where `n` is the size of the array, find the one number that is missing from the range. Implement the function `int findMissingNumber(vector<int>& nums)` that returns the missing number.","solution":"def findMissingNumber(nums): Given an array nums containing n distinct numbers in the range [0, n], where n is the size of the array, find the one number that is missing from the range. Args: - nums: list of int Returns: - int: the missing number n = len(nums) expected_sum = n * (n + 1) // 2 actual_sum = sum(nums) missing_number = expected_sum - actual_sum return missing_number"},{"question":"You are given a sorted array of integers `arr` and a target integer `target`. Your task is to find the number of unique pairs of elements in the array such that their sum is equal to `target`. Each pair should be reported in lexicographical order, and each element of the pair should be a unique element from the array. Return a list of the pairs. If no such pair is found, return an empty list.","solution":"def find_unique_pairs(arr, target): Returns a list of unique pairs of elements in the sorted array `arr` such that their sum is equal to `target`. pairs = [] left, right = 0, len(arr) - 1 while left < right: current_sum = arr[left] + arr[right] if current_sum == target: pairs.append((arr[left], arr[right])) left += 1 right -= 1 # Skip duplicates while left < right and arr[left] == arr[left - 1]: left += 1 while left < right and arr[right] == arr[right + 1]: right -= 1 elif current_sum < target: left += 1 else: right -= 1 return pairs"},{"question":"You are given an integer array `heights` representing the heights of `n` buildings, where `heights[i]` is the height of the `i-th` building. A building can see the sunset if and only if it is taller than all the buildings to its right. A building that can see the sunset adds a \'1\' to the result, while a building that cannot see the sunset adds a \'0\' to the result. Return _an array of integers where each element is either `1` or `0`, indicating whether the corresponding building can see the sunset_.","solution":"def can_see_sunset(heights): Determines which buildings can see the sunset. Args: heights (list of int): Heights of the buildings. Returns: list of int: A binary list where 1 indicates the building can see the sunset and 0 indicates it cannot. n = len(heights) result = [0] * n max_height = -1 for i in range(n - 1, -1, -1): if heights[i] > max_height: result[i] = 1 max_height = heights[i] return result"},{"question":"Given an integer `n`, generate all structurally unique BST\'s (binary search trees) that store values 1 to `n`. Return the list of the root nodes of all the unique BSTs. Each tree should be represented as a TreeNode object where `TreeNode` is a class with `val`, `left`, and `right` attributes. As part of creating your function, implement the following helper function within it that you can use to generate each tree: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` For instance, given `n = 3`, there will be a total of 5 unique BSTs, and your function should return the list of their root nodes.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def generateTrees(n): Generates all structurally unique BST\'s (binary search trees) that store values 1 to `n`. Parameters: n (int): The number of nodes in the BST. Returns: List[TreeNode]: A list of root nodes of all unique BSTs. if n == 0: return [] def generate_tree(start, end): if start > end: return [None] all_trees = [] for i in range(start, end + 1): left_trees = generate_tree(start, i - 1) right_trees = generate_tree(i + 1, end) for left in left_trees: for right in right_trees: current_tree = TreeNode(i) current_tree.left = left current_tree.right = right all_trees.append(current_tree) return all_trees return generate_tree(1, n)"},{"question":"You are given a list of non-negative integers `nums`, which represents the digits of a non-negative integer. Modify the list to represent the integer plus one. The digits are stored such that the most significant digit is at the head of the list, and each element in the array contains a single digit. Return the modified list of digits.","solution":"def plus_one(digits): Given a list of non-negative integers `digits` representing digits of a non-negative integer, this function modifies the list to represent the integer plus one. for i in range(len(digits)-1, -1, -1): if digits[i] < 9: digits[i] += 1 return digits digits[i] = 0 return [1] + digits"},{"question":"You are given an array `heights` where `heights[i]` is the height of the ith building. The buildings are followed by `N` people, each of whom will visit the buildings in order starting from the first one. Person `i` can either climb up to a building that is taller than the last one they visited or move to a building of the same or shorter height without a problem. However, if a building is taller than the previous one, they cannot move past the building unless they have a ladder. Each person only carries one ladder. Return _the minimum number of ladders required to allow all `N` people to visit all the buildings in the given order_. **Note:** * The buildings are visited sequentially from left to right. * If there are no buildings, return `0`.","solution":"def min_ladders_required(heights, N): Returns the minimum number of ladders required to allow all N people to visit all the buildings in the given order. :param heights: List[int] - List where heights[i] is the height of the ith building. :param N: int - Number of people :return: int - Minimum number of ladders required if not heights or N <= 0: return 0 # If there\'s only one building, no ladder is needed if len(heights) == 1: return 0 ladders_needed = 0 for i in range(1, len(heights)): if heights[i] > heights[i - 1]: ladders_needed += 1 return ladders_needed"},{"question":"You are given a list of integers `heights` representing the heights of buildings in a cityscape. The buildings are in a straight line and the cityscape can be viewed from the left side. From this viewpoint, a building is visible if there are no taller buildings to its left. Return _the number of buildings that are visible from the left side of the cityscape._.","solution":"def count_visible_buildings(heights): Given a list of heights representing the heights of buildings, return the number of buildings that are visible from the left side. A building is visible if there are no taller buildings to its left. Args: heights (list): A list of integers representing heights of buildings. Returns: int: The number of visible buildings from the left side. if not heights: return 0 max_height = heights[0] visible_count = 1 for height in heights[1:]: if height > max_height: visible_count += 1 max_height = height return visible_count"},{"question":"You are given a string `s` containing lowercase letters. A certain operation involves selecting any two adjacent characters in the string and either swapping them or removing both if they are the same character. Devise a function to determine the lexicographically smallest string possible after performing any number of operations.","solution":"def lexicographically_smallest_string(s): Returns the lexicographically smallest string possible after performing any number of allowed operations i.e., swapping or removing adjacent similar characters. stack = [] for char in s: if stack and stack[-1] == char: stack.pop() else: stack.append(char) return \\"\\".join(stack)"},{"question":"You are provided with an array of integers, `arr`, and a target integer, `k`. Write a function to determine if there exists a continuous subarray (of at least two numbers) that sums up to a multiple of `k`, that is, there exists some subarray `[arr[i], arr[i+1], ..., arr[j]]` with `i <= j` such that the sum of the subarray is `n * k`, where `n` is a positive integer. Return `True` if such a subarray exists, otherwise return `False`.","solution":"def check_subarray_sum(arr, k): Returns True if there exists a continuous subarray of at least two numbers that sums up to a multiple of k, otherwise returns False. if k == 0: return any(arr[i] == 0 and arr[i + 1] == 0 for i in range(len(arr) - 1)) mod_dict = {0: -1} current_sum = 0 for idx, num in enumerate(arr): current_sum += num mod = current_sum % k if mod in mod_dict: if idx - mod_dict[mod] > 1: return True else: mod_dict[mod] = idx return False"},{"question":"You are given a `rows x cols` matrix `grid` representing a map of land and water cells. - Cells with the value `1` represent land. - Cells with the value `0` represent water. An **island** is a group of `1`\'s (land cells) connected **4-directionally** (horizontal or vertical). You may assume all four edges of the grid are surrounded by water. The island\'s **perimeter** is the total number of graphical units around the island. Given the `grid`, return _the perimeter of the island_.","solution":"def islandPerimeter(grid): Returns the perimeter of the island in the grid. rows = len(grid) cols = len(grid[0]) perimeter = 0 for r in range(rows): for c in range(cols): if grid[r][c] == 1: # Start with 4 sides of the cell perimeter += 4 # Subtract sides for neighboring land cells if r > 0 and grid[r-1][c] == 1: # upper cell perimeter -= 1 if r < rows - 1 and grid[r+1][c] == 1: # lower cell perimeter -= 1 if c > 0 and grid[r][c-1] == 1: # left cell perimeter -= 1 if c < cols - 1 and grid[r][c+1] == 1: # right cell perimeter -= 1 return perimeter"},{"question":"Consider a sequence of numbers represented by an array `nums`, where each number is between `1` and `n` inclusive. A number from `1` to `n` is said to be **missing** if it does not appear in the array, and a number is called a **duplicate** if it appears more than once in the array. You are guaranteed that the array contains exactly one duplicate number and exactly one missing number in the range from `1` to `n`. Return both the duplicate number and the missing number as a tuple.","solution":"def find_duplicate_and_missing(nums): Finds and returns the duplicate and missing number in the given list of nums. Args: nums: list, list of integers where each integer is between 1 and n. Returns: tuple, (duplicate, missing) where \'duplicate\' is the number which appears more than once and \'missing\' is the number that is missing in the list. n = len(nums) actual_sum = n * (n + 1) // 2 actual_sum_square = n * (n + 1) * (2 * n + 1) // 6 sum_nums = sum(nums) sum_square_nums = sum(x * x for x in nums) # x - y = sum_nums - actual_sum # x^2 - y^2 = sum_square_nums - actual_sum_square diff = sum_nums - actual_sum sum_sq_diff = sum_square_nums - actual_sum_square # x^2 - y^2 = (x - y)(x + y) # sum_sq_diff = diff * (x + y) total = sum_sq_diff // diff x = (diff + total) // 2 y = total - x return x, y"},{"question":"You are given two strings, `s` and `t`. A string is considered **transformable** if it can be turned into another string by reversing any of its substrings any number of times. Return `true` if `s` can be transformed into `t`, and `false` otherwise. The strings `s` and `t` will only contain lowercase letters.","solution":"def can_transform(s, t): Determines if string `s` can be transformed into string `t` by reversing any of its substrings any number of times. # The strings s and t can be transformed into each other iff they have the same sorted list of characters return sorted(s) == sorted(t)"},{"question":"You are given an array of integers `arr` where the ith integer represents the height of a tower. You are allowed to perform a restricted set of modifications to the array: In each operation, you can increase or decrease the height of any tower by 1. Your goal is to make all the towers the same height in such a way that the total number of operations is minimized. Return _the minimum number of operations required to make all the towers the same height_. If it is not possible to make all towers the same height, return `-1`.","solution":"def min_operations_to_equalize_heights(arr): Returns the minimum number of operations required to make all towers the same height. If it\'s not possible, returns -1. An operation consists of increasing or decreasing the height of any tower by 1. if not arr: return 0 # Define median as the target height because minimizing the sum of absolute differences # is achieved by the median. arr.sort() median = arr[len(arr) // 2] # Compute the total operations required to adjust all towers to the median height. operations = sum(abs(height - median) for height in arr) return operations"},{"question":"Given an integer array `arr` and an integer `sum`, return _`true` if there exist **three distinct indices** `i`, `j`, `k` such that `arr[i] + arr[j] + arr[k] == sum`_. Otherwise, return `false`.","solution":"def find_three_sum(arr, target_sum): Given an integer array `arr` and an integer `sum`, return True if there exist three distinct indices i, j, k such that arr[i] + arr[j] + arr[k] == sum. Otherwise, return False. n = len(arr) arr.sort() # Sort the array to use two-pointer technique for i in range(n - 2): # Define the two pointers left = i + 1 right = n - 1 while left < right: current_sum = arr[i] + arr[left] + arr[right] if current_sum == target_sum: return True elif current_sum < target_sum: left += 1 else: right -= 1 return False"},{"question":"You are given an array `personData` where each element is an object representing a person, containing the following information: the person\'s `name`, `age`, and a list of the person\'s `friends`, who are identified by their unique names. Write a function that determines if there is a chain of friends connecting two given people, `personA` and `personB`. Two people are considered connected if you can start from `personA` and reach `personB` by following the \\"friends\\" links. Return a boolean value indicating whether such a connection exists.","solution":"def are_connected(personData, personA, personB): Returns True if there is a chain of friends connecting personA and personB, else False. # Create a dictionary to map people\'s names to their friends lists data = {person[\'name\']: person[\'friends\'] for person in personData} # BFS to find if personB can be reached starting from personA from collections import deque visited = set() queue = deque([personA]) while queue: current_person = queue.popleft() if current_person == personB: return True if current_person not in visited: visited.add(current_person) if current_person in data: queue.extend(data[current_person]) return False"},{"question":"You are given a list of operations on a string where each operation is defined as `[operation_type, index, char]`. The `operation_type` can be `insert` or `delete`. If it is `insert`, insert `char` at the position `index` in the current string. If it is `delete`, remove the character at the position `index`. You need to return the final string after performing all the operations in the order they are given. For example, given the string `\\"abcdef\\"` and the operations `[[\\"insert\\", 3, \\"X\\"], [\\"delete\\", 1], [\\"insert\\", 0, \\"Y\\"]]`, you would transform the string as follows: 1. Insert `X` at index `3`: `\\"abcXdef\\"`. 2. Delete the character at index `1`: `\\"acXdef\\"`. 3. Insert `Y` at index `0`: `\\"YacXdef\\"`. Your task is to implement the function that processes the string and returns the final result.","solution":"def process_operations(s, operations): Processes a list of operations on a string. Parameters: s (str): The initial string. operations (list): A list of operations where each operation is a list in the form [operation_type, index, char]. \'operation_type\' can be \'insert\' or \'delete\'. \'char\' is only used for \'insert\' operations. Returns: str: The final string after processing all operations. s = list(s) # Convert string to list for easy manipulation of elements for operation in operations: op_type = operation[0] index = operation[1] if op_type == \'insert\': char = operation[2] s.insert(index, char) elif op_type == \'delete\': s.pop(index) return \'\'.join(s)"},{"question":"Given an integer array `numbers` where each element represents the score of a player in a game, and an integer `k`, return the maximum possible sum of `k` consecutive elements in the array. If the array has fewer than `k` elements, return `0`. You must solve the problem with a single pass through the array and without using any additional data structures exceeding `O(k)` space complexity.","solution":"def max_consecutive_sum(numbers, k): Returns the maximum possible sum of k consecutive elements in the array. If the array has fewer than k elements, return 0. :param numbers: List[int] - List of integers representing scores. :param k: int - Number of consecutive elements to sum. :return: int - Maximum sum of k consecutive elements. n = len(numbers) if n < k: return 0 # Compute the sum of the first k elements. max_sum = current_sum = sum(numbers[:k]) # Iterate through the array starting from the k-th element. for i in range(k, n): # Sliding the window right, subtract the leftmost element and add the incoming element. current_sum += numbers[i] - numbers[i - k] # Update max_sum if the current_sum is greater. max_sum = max(max_sum, current_sum) return max_sum"},{"question":"You are given a string `s` consisting of only lowercase English letters. Determine if `s` can be rearranged to form a palindrome. A palindrome is a word that reads the same forward and backward. Return _true_ if it is possible to rearrange `s` to form a palindrome, or _false_ otherwise. Create the function `canFormPalindrome(s: str) -> bool` that takes a string `s` as input and returns a boolean value.","solution":"def canFormPalindrome(s: str) -> bool: Returns True if the string `s` can be rearranged to form a palindrome, False otherwise. from collections import Counter count = Counter(s) odd_count = 0 for freq in count.values(): if freq % 2 != 0: odd_count += 1 # For a string to be rearranged into a palindrome: # At most one character count can be odd. return odd_count <= 1"},{"question":"Given a string `word`, return the length of the longest palindrome that can be built with those characters. The characters are case-sensitive, for example, \\"Aa\\" is not considered a palindrome here.","solution":"def longest_palindrome(word): Given a string `word`, return the length of the longest palindrome that can be built with those characters. from collections import Counter char_count = Counter(word) length_of_palindrome = 0 odd_count_found = False for count in char_count.values(): if count % 2 == 0: length_of_palindrome += count else: length_of_palindrome += count - 1 odd_count_found = True if odd_count_found: length_of_palindrome += 1 return length_of_palindrome"},{"question":"Write a function `findLargestSquare` that takes in a matrix of characters consisting of `\'1\'`s and `\'0\'`s, representing a binary matrix. The function should return the area of the largest square containing only `\'1\'`s. For example, given the following matrix: ``` [ [\'1\', \'0\', \'1\', \'0\', \'0\'], [\'1\', \'0\', \'1\', \'1\', \'1\'], [\'1\', \'1\', \'1\', \'1\', \'1\'], [\'1\', \'0\', \'0\', \'1\', \'0\'] ] ``` The largest square containing only `\'1\'`s has an area of `4`, as illustrated by the square formed by elements from `[1,2]` to `[2,3]` in the matrix. Return the area of the largest square containing only `\'1\'`s.","solution":"def findLargestSquare(matrix): if not matrix: return 0 rows, cols = len(matrix), len(matrix[0]) dp = [[0] * (cols + 1) for _ in range(rows + 1)] max_side = 0 for i in range(1, rows + 1): for j in range(1, cols + 1): if matrix[i - 1][j - 1] == \'1\': dp[i][j] = min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1 max_side = max(max_side, dp[i][j]) return max_side * max_side"},{"question":"Given a string `s` representing a DNA sequence, return _the **length** of the longest substring that contains at most 2 distinct nucleotides_. The DNA sequence consists of the characters \'A\', \'C\', \'G\', and \'T\'.","solution":"def length_of_longest_substring_two_distinct(s: str) -> int: from collections import defaultdict left = 0 max_length = 0 char_count = defaultdict(int) for right, char in enumerate(s): char_count[char] += 1 while len(char_count) > 2: left_char = s[left] char_count[left_char] -= 1 if char_count[left_char] == 0: del char_count[left_char] left += 1 max_length = max(max_length, right - left + 1) return max_length"},{"question":"You are given an integer array `arr` representing the time spent by each task. Your objective is to schedule the tasks in such a way that the difference between the total times spent on two different machines is minimized. You have two machines and you want to distribute the tasks between them. Return the minimum possible difference in total times spent on both machines.","solution":"def min_difference(arr): Returns the minimum difference between the total times spent on two machines. total_sum = sum(arr) n = len(arr) # Use dynamic programming to solve the subset sum problem dp = [[False] * (total_sum // 2 + 1) for _ in range(n + 1)] # Initialize dp matrix for i in range(n + 1): dp[i][0] = True # Fill dp matrix for i in range(1, n + 1): for j in range(1, total_sum // 2 + 1): if arr[i - 1] <= j: dp[i][j] = dp[i - 1][j] or dp[i - 1][j - arr[i - 1]] else: dp[i][j] = dp[i - 1][j] # Find the maximum value of j such that dp[n][j] is True for j in range(total_sum // 2, -1, -1): if dp[n][j]: return total_sum - 2 * j"},{"question":"You are given a linked list of integers called `nodeList`. Your task is to segregate the linked list such that all nodes with even values appear before nodes with odd values in the modified linked list. The relative order among the even and odd nodes should remain unchanged. Return the head of the modified linked list.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def segregateEvenOdd(nodeList): even_head = ListNode(0) odd_head = ListNode(0) even = even_head odd = odd_head current = nodeList while current: if current.val % 2 == 0: even.next = current even = even.next else: odd.next = current odd = odd.next current = current.next even.next = odd_head.next odd.next = None return even_head.next"},{"question":"Given a string of words separated by spaces, reverse the order of characters in each word while preserving the order of words and the spaces between them. For example, given the input `\\"hello world\\"`, the output should be `\\"olleh dlrow\\"`. Note that the order of words (\\"hello\\" and \\"world\\") remains the same, but the characters within each word are reversed. Implement the `reverseWords` function that takes a single argument, `s`, which is the input string, and returns a new string with the characters in each word reversed.","solution":"def reverseWords(s): Reverses the order of characters in each word of the string while preserving the order of words and spaces. Parameters: s (str): The input string Returns: str: The string with word characters reversed # Split the input string by spaces words = s.split(\' \') # Reverse the characters in each word reversed_words = [word[::-1] for word in words] # Join them back with spaces and return return \' \'.join(reversed_words)"},{"question":"You are given a 2D grid of size `m x n` filled with non-negative integers. Each cell of the grid represents an elevation map where the value of each cell is the height of the terrain at that point. An island is defined as a group of connected cells where each cell in the group has at least one horizontally or vertically adjacent cell in the group. Determine the number of distinct islands in the grid. An island is considered to be distinct if and only if it has a unique shape. Two islands are considered to be the same if they can be translated (not rotated or reflected) to match each other. Given the grid, return _the number of distinct islands_.","solution":"def numDistinctIslands(grid): def dfs(r, c, direction, shape): if 0 <= r < len(grid) and 0 <= c < len(grid[0]) and grid[r][c] == 1: grid[r][c] = 0 shape.append(direction) dfs(r + 1, c, \'d\', shape) # move down dfs(r - 1, c, \'u\', shape) # move up dfs(r, c + 1, \'r\', shape) # move right dfs(r, c - 1, \'l\', shape) # move left shape.append(\'b\') # mark backtracking shapes = set() for r in range(len(grid)): for c in range(len(grid[0])): if grid[r][c] == 1: shape = [] dfs(r, c, \'o\', shape) # origin shapes.add(tuple(shape)) return len(shapes)"},{"question":"You are given a **0-indexed** array `tasks` of `n` integers representing the amount of work required for each task. You are also given an integer `k` representing the maximum amount of work you can complete in a single session. You need to complete all tasks in as few sessions as possible. In each session, you may choose any subset of tasks to work on, but the total work in a session must not exceed `k`. Return _the minimum number of sessions_ required to complete all tasks.","solution":"def min_sessions(tasks, k): Determines the minimum number of sessions required to complete all tasks. n = len(tasks) # dp[mask] will be the min number of sessions required to finish the tasks denoted by mask dp = [float(\'inf\')] * (1 << n) dp[0] = 0 # work[mask] keeps track of total work for tasks denoted by mask work = [0] * (1 << n) for mask in range(1 << n): for i in range(n): if mask & (1 << i): work[mask] += tasks[i] for mask in range(1 << n): submask = mask while submask: if work[submask] <= k: dp[mask] = min(dp[mask], dp[mask ^ submask] + 1) submask = (submask - 1) & mask return dp[(1 << n) - 1]"},{"question":"[Question]: You are given an integer array `nums` of length `n`. A subset\'s sum is considered \\"special\\" if it is divisible by a given integer `k`. Return `true` if there exists a non-empty subset of `nums` whose sum is special, and `false` otherwise. A subset is a sequence that can be derived from the array by deleting some elements without changing the order of the remaining elements.","solution":"def has_special_subset(nums, k): Returns True if there exists a non-empty subset in nums whose sum is divisible by k, otherwise False. n = len(nums) # Use a set to keep track of all possible subset sums encountered possible_sums = set([0]) for num in nums: # Generate new possible sums by adding the current num to each existing sum in possible_sums new_sums = {num + s for s in possible_sums} possible_sums.update(new_sums) # Check if any of the new sums are divisible by k if any(s % k == 0 and s != 0 for s in new_sums): return True return False"},{"question":"You are given an array `arr` of length `n` sorted in non-decreasing order and a target value `target`. Your task is to find if there exists a pair of integers in the array whose sum is equal to the target value. Return _a boolean `true` if such a pair exists, and `false` otherwise_. **Notes:** - The function should have a time complexity of O(n). - You can use additional space proportional to the input size to achieve the desired efficiency.","solution":"def has_pair_with_sum(arr, target): Returns True if there exists a pair of integers in the array whose sum is equal to the target value. Uses a set to achieve O(n) time complexity. seen_numbers = set() for num in arr: required_num = target - num if required_num in seen_numbers: return True seen_numbers.add(num) return False"},{"question":"Given a string `s`, return the number of palindromic substrings in it. The substrings with different start indices or end indices are counted as different substrings even if they consist of the same characters. For example, given `s = \\"abc\\"`, the output should be 3, because there\'s no palindrome longer than 1 character in the string. Given `s = \\"aaa\\"`, the output should be 6, because \\"a\\", \\"a\\", \\"a\\", \\"aa\\", \\"aa\\", \\"aaa\\" are all palindromic substrings.","solution":"def count_palindromic_substrings(s): Returns the number of palindromic substrings in the string `s`. n = len(s) count = 0 # A helper function to count palindromes centered at `left` and `right` def count_from_center(left, right): nonlocal count while left >= 0 and right < n and s[left] == s[right]: count += 1 left -= 1 right += 1 for center in range(n): # Count odd-length palindromes (single character center) count_from_center(center, center) # Count even-length palindromes (two characters center) count_from_center(center, center + 1) return count"},{"question":"You are given a list of `n` distinct integers `arr`. You need to divide this list into the minimum number of non-overlapping subarrays such that each subarray is a continuous sequence (i.e., each subarray contains consecutive integers in any order). Determine the number of such subarrays. Return the number of subarrays as an integer.","solution":"def count_continuous_subarrays(arr): Divides the list into the minimum number of non-overlapping subarrays such that each subarray contains consecutive integers in any order. :param arr: List of distinct integers :return: The number of subarrays if not arr: return 0 arr.sort() num_of_subarrays = 1 for i in range(1, len(arr)): if arr[i] != arr[i-1] + 1: num_of_subarrays += 1 return num_of_subarrays"},{"question":"Given an array of integers `nums` representing the number of candles, where each candle has a certain height. Every day, the tallest candle(s) can be blown out. Once blown out, the candles decrease in height by 1 unit. Return _the total number of days required to blow out all the candles until all candles are completely burned out_. If there are no more tall candles to blow out, return the largest remaining height as the number of days remaining.","solution":"def days_to_blow_out_candles(nums): Given an array of integers nums representing the number of candles where each candle has a certain height. Every day, the tallest candle(s) can be blown out. Once blown out, the candles decrease in height by 1 unit. Return the total number of days required to blow out all the candles until all candles are completely burned out. if not nums: return 0 days = 0 while any(candle > 0 for candle in nums): tallest = max(nums) days += 1 for i in range(len(nums)): if nums[i] == tallest: nums[i] -= 1 return days"},{"question":"You are given two arrays `ranks` and `scores` where `ranks[i]` represents the rank of the `i-th` player, and `scores[i]` represents the total score of the `i-th` player. Players with a higher rank appear earlier in the list. Your task is to return a new array `results` such that `results[i]` contains the `rank` of each player that has a higher score than `scores[i]` but appears later in the list. If there are no such players for a given `i`, `results[i]` should be -1.","solution":"def find_higher_rank_later(ranks, scores): Returns an array where each element is the rank of the first player appearing later with a higher score than the corresponding player, or -1 if no such player exists. n = len(ranks) results = [-1] * n for i in range(n): rank_i = ranks[i] score_i = scores[i] for j in range(i + 1, n): if scores[j] > score_i: results[i] = ranks[j] break return results"},{"question":"You are given an integer array `nums`. Our goal is to construct an array `output` such that `output[i]` is equal to the product of all the elements of `nums` except `nums[i]`. Write a function that returns this `output` array. The solution must be implemented without using division and should have a time complexity of O(n).","solution":"def product_except_self(nums): Returns an array such that output[i] is equal to the product of all the elements of nums except nums[i]. n = len(nums) output = [1] * n # Construct the prefix product array prefix = 1 for i in range(n): output[i] = prefix prefix *= nums[i] # Construct the suffix product array and multiply with prefix product suffix = 1 for i in range(n - 1, -1, -1): output[i] *= suffix suffix *= nums[i] return output"},{"question":"You are given a `d x t` integer grid `temperatures` where `temperatures[i][j]` represents the recorded temperature on the `i-th` day at the `j-th` time slot. Each day has multiple time slots for recording temperatures. Your task is to find the _maximum temperature recorded within the given period_. Return the _highest temperature_ recorded from the grid.","solution":"def find_max_temperature(temperatures): Returns the highest temperature recorded within the given grid of temperatures. :param temperatures: List of lists where temperatures[i][j] represents the temperature on the i-th day at the j-th time slot. :return: The highest temperature recorded. if not temperatures or not temperatures[0]: return None max_temp = float(\'-inf\') for day in temperatures: for temp in day: if temp > max_temp: max_temp = temp return max_temp"},{"question":"You are given a string `expression` containing digits and the operations `+`, `-`, `*`, and `/`, where the digits and the operations are valid postfix (reverse Polish notation). Evaluate the expression and return the result. The integer division should truncate toward zero.","solution":"def eval_postfix(expression): Evaluates a postfix expression and returns the result. :param expression: A string containing a valid postfix expression :return: The result of the evaluation as an integer stack = [] for token in expression.split(): if token.isdigit() or (token.startswith(\'-\') and token[1:].isdigit()): stack.append(int(token)) else: b = stack.pop() a = stack.pop() if token == \'+\': stack.append(a + b) elif token == \'-\': stack.append(a - b) elif token == \'*\': stack.append(a * b) elif token == \'/\': stack.append(int(a / b)) # Truncate toward zero return stack[0]"},{"question":"You are given a list of `n` tasks, each represented by an integer `tasks[i]`, where each element denotes the duration of the task. Tasks have dependencies, meaning that certain tasks must be completed before others can be started. You are also given a list of `dependencies` where `dependencies[i] = [a, b]` indicates that task `a` must be completed before task `b` can be started. Each task can be worked on by a single worker in parallel if its dependencies are met. Your goal is to determine the minimum amount of time required to complete all tasks. Return _the minimum time required to finish all tasks given their dependencies_.","solution":"def min_time_to_finish_tasks(tasks, dependencies): from collections import defaultdict, deque # Build the graph and calculate in-degree graph = defaultdict(list) in_degree = defaultdict(int) for a, b in dependencies: graph[a].append(b) in_degree[b] += 1 # Find tasks with no dependencies zero_in_degree_queue = deque() for task in range(len(tasks)): if in_degree[task] == 0: zero_in_degree_queue.append(task) # Initialize minimum time required for each task task_time = [0] * len(tasks) while zero_in_degree_queue: current_task = zero_in_degree_queue.popleft() # Calculate completion time for tasks dependent on current_task for neighbor in graph[current_task]: task_time[neighbor] = max(task_time[neighbor], task_time[current_task] + tasks[current_task]) in_degree[neighbor] -= 1 if in_degree[neighbor] == 0: zero_in_degree_queue.append(neighbor) # The final completion time for each task for i in range(len(tasks)): task_time[i] += tasks[i] return max(task_time)"},{"question":"You are tasked with developing an algorithm to transform an input string `s` into a target string `t` using a minimum number of operations. The only operations you can perform are: 1. Insert a character 2. Delete a character 3. Replace a character Both the input and target strings consist of lowercase English letters. Return the minimum number of operations required to convert the string `s` to the string `t`.","solution":"def min_distance(s, t): Returns the minimum number of operations required to convert string s to string t. The allowed operations are insert, delete, and replace a character. m, n = len(s), len(t) dp = [[0] * (n + 1) for _ in range(m + 1)] for i in range(m + 1): for j in range(n + 1): if i == 0: dp[i][j] = j # Need to insert all characters of t elif j == 0: dp[i][j] = i # Need to delete all characters of s elif s[i - 1] == t[j - 1]: dp[i][j] = dp[i - 1][j - 1] # Characters are the same, no operation needed else: dp[i][j] = 1 + min(dp[i - 1][j], # Deletion dp[i][j - 1], # Insertion dp[i - 1][j - 1]) # Replacement return dp[m][n]"},{"question":"Implement a function that takes a list of positive integers and returns a list of integers where each element is the product of all the numbers in the original list except the one at the current index. You are not allowed to use division in your solution.","solution":"def product_except_self(nums): Returns a list such that each element is the product of all the numbers in the input list except the one at the same index. length = len(nums) output = [1] * length # Calculate products to the left of each element left_product = 1 for i in range(length): output[i] = left_product left_product *= nums[i] # Calculate products to the right of each element right_product = 1 for i in range(length - 1, -1, -1): output[i] *= right_product right_product *= nums[i] return output"},{"question":"You are given a string `s` representing a binary number, where `s[i]` is either \'0\' or \'1\'. You can perform an operation on `s` where, in one operation, you can delete any substring \\"01\\" or \\"10\\" from `s`. Your task is to return the length of the smallest possible string that can be obtained by performing the above operations multiple times. For example, given s = \\"110100\\", you can delete \\"10\\" -> \\"1100\\", then delete \\"10\\" -> \\"10\\" and finally delete \\"10\\" -> \\"\\", so the length of the smallest possible string is 0. If s = \\"111\\", the smallest possible string is \\"111\\" itself, so the length is 3.","solution":"def min_length_of_binary_string(s): Returns the length of the smallest possible string that can be obtained by repeatedly deleting \\"01\\" or \\"10\\". return abs(s.count(\'0\') - s.count(\'1\'))"},{"question":"Given an array of integers, find the maximum possible sum of a non-empty subarray, with at most one element being removed. A subarray is a contiguous part of an array. Note that you may not remove more than one element, and you may choose not to remove any elements at all.","solution":"def max_sum_subarray_with_one_removal(arr): Finds the maximum possible sum of a non-empty subarray, with at most one element being removed. :param arr: List of integers :return: Integer representing the maximum sum achievable n = len(arr) if n == 0: return 0 # Arrays to store max sum subarray ending at each index max_ending_here = [0] * n max_starting_here = [0] * n # Forward pass: calculate max subarray sum ending at each index max_ending_here[0] = arr[0] for i in range(1, n): max_ending_here[i] = max(arr[i], max_ending_here[i-1] + arr[i]) # Backward pass: calculate max subarray sum starting at each index max_starting_here[-1] = arr[-1] for i in range(n-2, -1, -1): max_starting_here[i] = max(arr[i], max_starting_here[i+1] + arr[i]) # Calculate max sum of subarray with at most one element removed max_sum = max(max_ending_here) # This considers the case where no element is removed for i in range(1, n-1): max_sum = max(max_sum, max_ending_here[i-1] + max_starting_here[i+1]) return max_sum"},{"question":"You are given a matrix `grid` representing a field of values. Each cell in the field has a value indicating the amount of gold in that cell. You can start collecting gold from any cell in the grid that contains gold. From a cell, you can move to any of the four cells directly adjacent (left, right, up, down). The field also has a special property: once you collect gold from a cell, that cell becomes empty and cannot be used again. Your goal is to find the maximum amount of gold you can collect starting from any cell and moving to adjacent cells collecting gold until there are no more cells left to move to. Return the maximum amount of gold you can collect. The matrix `grid` is represented as a 2D array of integers where: - `grid[i][j]` represents the amount of gold in the cell located at row `i` and column `j`. - `0` represents an empty cell that contains no gold. Example: ``` Input: grid = [ [0,6,0], [5,8,7], [0,9,0] ] Output: 24 Explanation: Start from the cell (1, 1) (with 8), collect 8, then move to cell (2, 1) (with 9) and collect 9, then move to cell (1, 2) (with 7) and collect 7. So total gold collected is 8 + 9 + 7 = 24. ```","solution":"def get_maximum_gold(grid): Returns the maximum amount of gold that can be collected from the grid. def backtrack(x, y): if x < 0 or x >= len(grid) or y < 0 or y >= len(grid[0]) or grid[x][y] == 0: return 0 gold = grid[x][y] grid[x][y] = 0 # Mark the cell as visited by setting it to 0 max_gold = 0 for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: max_gold = max(max_gold, backtrack(x + dx, y + dy)) grid[x][y] = gold # Restore the cell value return gold + max_gold max_gold_collected = 0 for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] != 0: max_gold_collected = max(max_gold_collected, backtrack(i, j)) return max_gold_collected"},{"question":"You are given an array `jobs` where `jobs[i]` represents the amount of time it takes to complete the `i-th` job. You have one worker available and you want to minimize the overall completion time by scheduling these jobs in sequence. However, the worker can only handle a maximum continuous work session of `T` hours and needs at least one hour of rest before starting another session. Implement a function that returns the minimum number of work sessions required to complete all jobs, where each session doesn\'t exceed `T` hours.","solution":"def min_work_sessions(jobs, T): This function calculates the minimum number of work sessions required to complete all jobs given that each session can\'t exceed T hours and the worker needs at least one hour of rest after each session. :param jobs: List of integers, where jobs[i] is the time to complete the i-th job. :param T: Maximum continuous work session time. :return: Minimum number of work sessions required. # Sorting jobs in descending order to schedule longest jobs first jobs.sort(reverse=True) sessions = 0 while jobs: current_time = 0 temp_jobs = [] for job in jobs: if current_time + job <= T: current_time += job else: temp_jobs.append(job) jobs = temp_jobs sessions += 1 return sessions"},{"question":"You are given a network of `n` nodes labeled from `0` to `n-1` and a list of `edges` where `edges[i] = [a, b]` indicates that there is a bidirectional connection between nodes `a` and `b`. You are also given a source node `start` and a target node `end`. Write a function to determine if there exists a valid path from `start` to `end`. If there is a valid path, return `true`; otherwise, return `false`.","solution":"def valid_path(n, edges, start, end): Determines if there is a valid path from start to end in an undirected graph. :param n: Integer, number of nodes :param edges: List of edges in the graph :param start: Starting node :param end: Target node :return: Boolean, True if a valid path exists, False otherwise from collections import defaultdict, deque # Create adjacency list graph = defaultdict(list) for a, b in edges: graph[a].append(b) graph[b].append(a) # Perform BFS queue = deque([start]) visited = set() while queue: node = queue.popleft() if node == end: return True if node not in visited: visited.add(node) for neighbor in graph[node]: if neighbor not in visited: queue.append(neighbor) return False"},{"question":"A robot is located at the top-left corner of a `m x n` grid (marked `\\"Start\\"` in the diagram below). The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked `\\"Finish\\"` in the diagram below). Now consider if some obstacles are added to the grids. How many unique paths would there be to reach the bottom-right corner? An obstacle and empty space are marked as `1` and `0` respectively in the grid. Provide an implementation for the function: ```python def uniquePathsWithObstacles(obstacleGrid: List[List[int]]) -> int ``` This function takes a list of lists, `obstacleGrid`, where `obstacleGrid[i][j]` is: * 1 if the cell has an obstacle. * 0 if the cell is empty. The function should return the number of unique paths from the top-left corner to the bottom-right corner avoiding obstacles.","solution":"from typing import List def uniquePathsWithObstacles(obstacleGrid: List[List[int]]) -> int: if not obstacleGrid or not obstacleGrid[0] or obstacleGrid[0][0] == 1: return 0 m, n = len(obstacleGrid), len(obstacleGrid[0]) dp = [[0]*n for _ in range(m)] dp[0][0] = 1 # Start position # Fill the first column for i in range(1, m): dp[i][0] = dp[i-1][0] if obstacleGrid[i][0] == 0 else 0 # Fill the first row for j in range(1, n): dp[0][j] = dp[0][j-1] if obstacleGrid[0][j] == 0 else 0 # Fill the rest of the grid for i in range(1, m): for j in range(1, n): if obstacleGrid[i][j] == 0: dp[i][j] = dp[i-1][j] + dp[i][j-1] else: dp[i][j] = 0 return dp[-1][-1]"},{"question":"You are given two strings, `s` and `goal`. Your task is to determine if you can swap two letters in string `s` such that the resulting string matches the string `goal`. If it is possible to achieve this by swapping exactly two letters once, return `true`; otherwise, return `false`. Implement the function: ```python def buddyStrings(s: str, goal: str) -> bool: ``` # Constraints: - The input strings `s` and `goal` will be lowercase alphabets. - The lengths of `s` and `goal` will be between 1 and 2 * 10^4, inclusive. # Example: ```python buddyStrings(\\"ab\\", \\"ba\\") # Returns: True buddyStrings(\\"ab\\", \\"ab\\") # Returns: False buddyStrings(\\"aa\\", \\"aa\\") # Returns: True buddyStrings(\\"aaaaaaabc\\", \\"aaaaaaacb\\") # Returns: True buddyStrings(\\"\\", \\"aa\\") # Returns: False ```","solution":"def buddyStrings(s: str, goal: str) -> bool: if len(s) != len(goal): return False if s == goal: # Check if there is any character that appears at least twice seen = set() for char in s: if char in seen: return True seen.add(char) return False # Find the pairs of characters that are different pairs = [] for a, b in zip(s, goal): if a != b: pairs.append((a, b)) # If there are exactly two pairs and they are swappable to make the strings equal return len(pairs) == 2 and pairs[0] == pairs[1][::-1]"},{"question":"Given an array of integers `nums`, write a function that returns the maximum sum of a contiguous subarray within the array (`nums`) that contains at least one element. The function should have a time complexity of O(n). For example, given the input array `nums = [-2,1,-3,4,-1,2,1,-5,4]`, the function should return `6` as the maximum sum of a contiguous subarray is `[4, -1, 2, 1]` which sums to `6`.","solution":"def max_subarray_sum(nums): This function returns the maximum sum of a contiguous subarray within the input array `nums`. if not nums: return 0 max_sum = current_sum = nums[0] for num in nums[1:]: current_sum = max(num, current_sum + num) max_sum = max(max_sum, current_sum) return max_sum"},{"question":"You are given a list of integers representing heights of students in a line at a school assembly. Each student wants to see the stage, but taller students in front of them block their view. You must determine the number of students who can see the stage if the students stand in the same order as the given list. Write a function `countVisibleStudents` that takes a list of integers `heights` and returns the number of students who can see the stage. A student can see the stage if there are no taller students directly in front of them in the line. **Function Signature:** `def countVisibleStudents(heights: List[int]) -> int:`","solution":"def countVisibleStudents(heights): Returns the number of students who can see the stage. A student can see the stage if there are no taller students directly in front of them in the line. max_height = 0 visible_count = 0 for height in heights: if height > max_height: visible_count += 1 max_height = height return visible_count"},{"question":"You are given a **0-indexed** 2D integer array `matrix` of dimensions `m x n`. Each element in the matrix represents a height at that position. A peak element is an element that is strictly greater than its neighbors. Return the coordinates `[x, y]` of any peak element found in the matrix. Neighbors of an element at position `[i, j]` are the elements `[i-1, j]`, `[i+1, j]`, `[i, j-1]`, and `[i, j+1]` if they exist within the boundaries of the matrix. The result should be returned as a list of two integers `[x, y]`. If there are multiple peak elements, you may return any of them.","solution":"def find_peak_2d(matrix): def is_peak(x, y): curr = matrix[x][y] if x > 0 and matrix[x-1][y] >= curr: return False if x < len(matrix) - 1 and matrix[x+1][y] >= curr: return False if y > 0 and matrix[x][y-1] >= curr: return False if y < len(matrix[0]) - 1 and matrix[x][y+1] >= curr: return False return True for i in range(len(matrix)): for j in range(len(matrix[0])): if is_peak(i, j): return [i, j] return None # In case there are no peaks which should not be possible with given problem constraints."},{"question":"Given an m x n binary matrix `grid`, return _the length of the shortest clear path in the matrix_. If there is no clear path, return -1. A binary matrix has only 0\'s (representing empty cells) and 1\'s (representing blocked cells). The shortest clear path is defined as the shortest path, from the top-left corner (0, 0) to the bottom-right corner (m-1, n-1), that only moves through empty cells (0\'s). If there is no clear path from the top-left corner to the bottom-right corner, return -1. You can move up, down, left, or right from an empty cell to another empty cell.","solution":"from collections import deque def shortest_path_binary_matrix(grid): Finds the length of the shortest clear path in a binary matrix grid. :param grid: List[List[int]] - binary matrix :return: int - length of the shortest clear path or -1 if no clear path exists if not grid or grid[0][0] != 0 or grid[-1][-1] != 0: return -1 m, n = len(grid), len(grid[0]) directions = [(1, 0), (0, 1), (-1, 0), (0, -1)] # four possible movements queue = deque([(0, 0, 1)]) # (row, col, path_length) visited = set((0, 0)) while queue: row, col, path_length = queue.popleft() if row == m - 1 and col == n - 1: return path_length for dr, dc in directions: r, c = row + dr, col + dc if 0 <= r < m and 0 <= c < n and grid[r][c] == 0 and (r, c) not in visited: queue.append((r, c, path_length + 1)) visited.add((r, c)) return -1"},{"question":"You are given an integer array `nums` sorted in non-decreasing order and an integer target. Suppose we are to find two integers in `nums` such that their sum is exactly `target`. Return an array of the indices of the two numbers such that they add up to the target. You may assume that each input would have exactly one solution, and you may not use the same element twice. Your solution should aim to be O(n) in time complexity.","solution":"def two_sum(nums, target): Given an array of integers `nums` sorted in non-decreasing order and an integer `target`, returns the indices of the two numbers such that they add up to `target`. left, right = 0, len(nums) - 1 while left < right: current_sum = nums[left] + nums[right] if current_sum == target: return [left, right] elif current_sum < target: left += 1 else: right -= 1 return None # As per the problem statement, there is always exactly one solution."},{"question":"You are given a `0-indexed` `n x n` integer matrix `grid`, where `grid[i][j]` represents the number of obstacles at cell `(i, j)`. Starting from the top-left cell `(0, 0)`, you are allowed to move to the right or downward to reach the bottom-right cell `(n-1, n-1)`. Implement a function to find a path that minimizes the sum of obstacles you encounter on the path, including the starting and ending cells. Return the minimum sum of obstacles along such a path.","solution":"def min_path_sum(grid): Find the minimum sum path from the top-left to the bottom-right of the matrix. n = len(grid) if n == 0: return 0 # Initialize the dp table dp = [[0] * n for _ in range(n)] # Set the value for the starting cell (0, 0) dp[0][0] = grid[0][0] # Initialize first row (can only come from the left) for j in range(1, n): dp[0][j] = dp[0][j-1] + grid[0][j] # Initialize first column (can only come from above) for i in range(1, n): dp[i][0] = dp[i-1][0] + grid[i][0] # Fill the dp table for i in range(1, n): for j in range(1, n): dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j] return dp[n-1][n-1]"},{"question":"You are given an integer array `nums` sorted in non-decreasing order. A value `target` is also provided. Your task is to determine if there exists a pair of elements in the array whose sum is equal to `target`. Return `true` if such a pair exists, and `false` otherwise. You must write an algorithm with `O(n)` time complexity.","solution":"def has_two_sum(nums, target): Returns True if there exists two elements in a sorted array nums that sum to the target. Otherwise, returns False. left, right = 0, len(nums) - 1 while left < right: current_sum = nums[left] + nums[right] if current_sum == target: return True elif current_sum < target: left += 1 else: right -= 1 return False"},{"question":"You are given a **m x n** integer matrix `mat` and an integer `target`. Determine the position `(i, j)` of the element in `mat` that is closest to `target`. If there are multiple such elements, return the smallest position in row-major order (meaning `(i1, j1)` is smaller than `(i2, j2)` if `i1 < i2` or (`i1 == i2` and `j1 < j2`)). Return _a tuple (i, j)_ as the position of the closest element.","solution":"def find_closest_element(mat, target): Returns the position (i, j) of the element in the matrix that is closest to the target. def distance(val1, val2): return abs(val1 - val2) closest_position = (-1, -1) min_distance = float(\'inf\') for i in range(len(mat)): for j in range(len(mat[i])): current_distance = distance(mat[i][j], target) if (current_distance < min_distance) or (current_distance == min_distance and (i < closest_position[0] or (i == closest_position[0] and j < closest_position[1]))): closest_position = (i, j) min_distance = current_distance return closest_position"},{"question":"You are given two non-empty arrays `nums1` and `nums2` which contain positive integers. You can apply the following operation any number of times on the arrays: Select a pair of elements `(x, y)` such that `x` is an element in `nums1` and `y` is an element in `nums2`, and swap them if and only if `x < y`. Return `true` if you can make every element in `nums1` greater than or equal to every element in `nums2` by performing such zero or more operations, and `false` otherwise.","solution":"def can_swap_to_satisfy(nums1, nums2): Determine if it\'s possible to make every element in nums1 greater than or equal to every element in nums2 with swaps. Parameters: nums1 (list of int): First list of positive integers. nums2 (list of int): Second list of positive integers. Returns: bool: True if it\'s possible to satisfy the condition by swapping, False otherwise. nums1.sort() nums2.sort() # Check if the largest element in nums1 is greater than # the smallest element in nums2 if nums1[-1] >= nums2[0]: return True return False"},{"question":"Implement a data structure `Vector2D` that represents a two-dimensional vector iterator. Given `vec` represents a 2D vector, `Vector2D` should be able to iterate over all elements in `vec`. Implement the `Vector2D` class: - `Vector2D(List<List<Integer>> vec)` Initializes the 2D vector with the list `vec`. - `int next()` Returns the next element in the 2D vector. - `boolean hasNext()` Returns `true` if there are more elements in the 2D vector, and `false` otherwise. The implementation should handle cases where rows of the vector have different lengths or are empty. Example: ``` Vector2D iterator = new Vector2D([[1,2],[3],[4]]); iterator.next(); // return 1 iterator.next(); // return 2 iterator.hasNext(); // return true iterator.next(); // return 3 iterator.hasNext(); // return true iterator.next(); // return 4 iterator.hasNext(); // return false ```","solution":"class Vector2D: def __init__(self, vec): self.vec = vec self.row = 0 self.col = 0 self.advance_to_next() def advance_to_next(self): while self.row < len(self.vec) and self.col >= len(self.vec[self.row]): self.row += 1 self.col = 0 def next(self): if not self.hasNext(): raise Exception(\\"No more elements\\") result = self.vec[self.row][self.col] self.col += 1 self.advance_to_next() return result def hasNext(self): self.advance_to_next() return self.row < len(self.vec)"},{"question":"Given an array of integers `tasks` representing the amount of time each task takes and an integer `n` representing the cooling period between the same tasks, write a function that returns the least number of units of times that the CPU will take to finish all the given tasks. Each task could be executed in any order within the constraints of the cooling period. For example, if you have tasks `[1, 1, 2, 1]` and the cooldown `n = 2`, you would have to organize them so that there are at least 2 units of time between the same tasks. Implement the function: ``` int leastInterval(vector<int>& tasks, int n) ```","solution":"from collections import Counter def least_interval(tasks, n): Returns the least number of units times that the CPU will take to finish all the given tasks with a cooling period of `n` between the same tasks. task_counts = Counter(tasks) max_count = max(task_counts.values()) # Find the number of tasks that have the maximum count max_count_tasks = sum(1 for count in task_counts.values() if count == max_count) # The part without the remainder tasks part_length = max_count - 1 empty_slots = part_length * (n - (max_count_tasks - 1)) available_tasks = len(tasks) - max_count * max_count_tasks idles = max(0, empty_slots - available_tasks) return len(tasks) + idles"},{"question":"You are given an integer array `weights` representing the weights of `n` items, and another integer `k` representing the number of containers. You need to distribute these items into the `k` containers such that: - Each container can hold any number of items. - The weight of items in a container can be any value, but the total weight in each container should be as balanced as possible. Return _the maximum weight of the heaviest container_ after distribution.","solution":"def distribute_weights(weights, k): def can_distribute(max_weight): current_weight = 0 containers_used = 1 for weight in weights: if current_weight + weight > max_weight: containers_used += 1 current_weight = weight if containers_used > k: return False else: current_weight += weight return True left, right = max(weights), sum(weights) while left < right: mid = (left + right) // 2 if can_distribute(mid): right = mid else: left = mid + 1 return left"},{"question":"Given two strings `s1` and `s2`, return the length of the longest common subsequence of `s1` and `s2`. A subsequence is a sequence that appears in the same relative order, but not necessarily consecutively. You must write an algorithm with `O(n * m)` runtime complexity, where `n` and `m` are the lengths of `s1` and `s2`, respectively.","solution":"def longest_common_subsequence(s1, s2): Returns the length of the longest common subsequence of s1 and s2. n = len(s1) m = len(s2) dp = [[0] * (m + 1) for _ in range(n + 1)] for i in range(1, n + 1): for j in range(1, m + 1): if s1[i - 1] == s2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) return dp[n][m]"},{"question":"Given a list of non-negative integers `arr` and an integer `k`, find the number of contiguous subarrays where the number of unique elements is exactly `k`. A subarray is a contiguous part of an array.","solution":"from collections import defaultdict def subarrays_with_k_distinct(arr, k): def at_most_k_distinct(arr, k): count = defaultdict(int) result = 0 left = 0 for right in range(len(arr)): if count[arr[right]] == 0: k -= 1 count[arr[right]] += 1 while k < 0: count[arr[left]] -= 1 if count[arr[left]] == 0: k += 1 left += 1 result += right - left + 1 return result return at_most_k_distinct(arr, k) - at_most_k_distinct(arr, k - 1)"},{"question":"You are given a list of integers `nums` which contains positive and negative numbers. You need to find the maximum absolute sum of any subarray of `nums`. A subarray is a contiguous subsequence of the array. Return the maximum absolute sum of any subarray, which means you should consider both the maximum sum and minimum sum of subarrays and return the highest of their absolute values. The subarray can be of any length from 1 up to the length of `nums`.","solution":"def max_absolute_subarray_sum(nums): Returns the maximum absolute sum of any subarray of nums. max_ending_here, max_so_far = 0, 0 min_ending_here, min_so_far = 0, 0 for num in nums: max_ending_here = max(0, max_ending_here + num) max_so_far = max(max_so_far, max_ending_here) min_ending_here = min(0, min_ending_here + num) min_so_far = min(min_so_far, min_ending_here) return max(max_so_far, abs(min_so_far))"},{"question":"Given an undirected graph represented as an adjacency list, where each node corresponds to a unique integer value, determine if the graph contains a cycle. A cycle is defined as a sequence of edges and vertices wherein a vertex is reachable from itself. Write a function `bool hasCycle(List<List<int>> graph)` that takes a graph represented as a list of lists where `graph[i]` contains all the nodes connected to node `i` and returns `true` if the graph contains a cycle, and `false` otherwise.","solution":"def hasCycle(graph): Determines if the graph contains a cycle. Parameters: graph (List[List[int]]): The adjacency list of the graph. Returns: bool: True if the graph contains a cycle, False otherwise. def dfs(node, parent): visited[node] = True for neighbor in graph[node]: if not visited[neighbor]: # If the neighbor has not been visited, recur on it if dfs(neighbor, node): return True elif neighbor != parent: # If an adjacent is visited and not the parent of the current vertex, then there is a cycle return True return False visited = [False] * len(graph) # Call the recursive helper function to detect cycle in different DFS trees for node in range(len(graph)): if not visited[node]: # Don\'t recur for `node` if it is already visited if dfs(node, -1): # If a cycle is found return True return False"},{"question":"Implement the `lowestCommonAncestor` function in a binary search tree. Given the `root` of a binary search tree and two values `p` and `q`, find the lowest common ancestor (LCA) of the two values. The LCA is defined between two nodes `p` and `q` as the lowest node in the tree that has both `p` and `q` as descendants (where we allow a node to be a descendant of itself). You may assume that both values `p` and `q` exist in the tree. Return the value of the LCA node.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def lowestCommonAncestor(root, p, q): Returns the value of the lowest common ancestor of nodes p and q. :param root: TreeNode, the root of the binary search tree :param p: int, value of the first node :param q: int, value of the second node :return: int, value of the lowest common ancestor while root: if p < root.val and q < root.val: root = root.left elif p > root.val and q > root.val: root = root.right else: return root.val"},{"question":"You are given an array `heights` representing the heights of buildings in a straight line. Each building has a width of `1`. The span of a building `heights[i]` is from index `i` to index `i + 1`. You need to find the maximum rectangular area that can be formed by consecutive buildings. Return the maximum rectangular area possible.","solution":"def max_histogram_area(heights): Returns the maximum rectangular area in a histogram represented by heights array. stack = [] max_area = 0 index = 0 while index < len(heights): if not stack or heights[stack[-1]] <= heights[index]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"You are given a list of `n` strings `words` and a string `target` where the length of the `target` string is greater than or equal to 3. Each word in `words` can be used to form the `target` string by concatenating any number of given words (each word can be used multiple times). Return _the **minimum number** of words from the `words` list required to form the `target` string_. If the `target` string cannot be formed, return `-1`.","solution":"def min_words_to_form_target(words, target): Returns the minimum number of words required to form the target string, or -1 if it is not possible. from collections import deque, defaultdict # Initialize queue for BFS and a dictionary to store the minimum operations queue = deque([(target, 0)]) visited = set([target]) while queue: current, steps = queue.popleft() for word in words: if current.startswith(word): new_target = current[len(word):] if new_target == \'\': # Whole target can be constructed return steps + 1 if new_target not in visited: visited.add(new_target) queue.append((new_target, steps + 1)) return -1"},{"question":"You are given a list of `n` positive integers, where each integer represents the height of a building. The heights are given in an array `buildings`, where `buildings[i]` is the height of the i-th building. A building is **visible** if there are no taller buildings to its right. Write a function that returns the number of visible buildings from left to right in the array. Example: ``` Input: buildings = [3, 7, 8, 3, 6, 1] Output: 3 Explanation: The visible buildings are 8, 6 and 1. ```","solution":"def count_visible_buildings(buildings): Returns the number of visible buildings from left to right in the array. if not buildings: return 0 max_height = buildings[-1] count_visible = 1 # The last building is always visible for i in range(len(buildings) - 2, -1, -1): if buildings[i] > max_height: count_visible += 1 max_height = buildings[i] return count_visible"},{"question":"Given an array of integers `arr` representing the heights of blocks, a block can be stacked on another block if and only if both blocks have the same height. You want to find the height of the tallest tower that can be formed by stacking these blocks. Return _the height of the tallest tower that can be formed_.","solution":"def tallest_tower_height(arr): Given an array of integers representing the heights of blocks, returns the height of the tallest tower that can be formed by stacking blocks of the same height. if not arr: return 0 height_counts = {} for height in arr: if height in height_counts: height_counts[height] += 1 else: height_counts[height] = 1 return max(height_counts.values())"},{"question":"A palindrome is a word, phrase, number, or other sequences of characters that read the same forward and backward (ignoring spaces, punctuation, and capitalization). Given a string `s`, determine the minimum number of characters you need to insert into `s` to make it a palindrome. Write a function `int minInsertions(String s)` that returns the minimum number of insertions needed. For example: - Given `s = \\"abc\\"`, the function should return `2` because inserting `\\"bca\\"` or `\\"ac\\"`, respectively, we get `\\"abcba\\"`. - Given `s = \\"race\\"`, the function should return `3` because inserting `\\"e\\"`, `\\"c\\"`, and `\\"a\\"` respectively, we get `\\"racecar\\"`.","solution":"def minInsertions(s): Returns the minimum number of insertions needed to make a string a palindrome. n = len(s) rev_s = s[::-1] dp = [[0] * (n+1) for _ in range(n+1)] for i in range(n): for j in range(n): if s[i] == rev_s[j]: dp[i+1][j+1] = dp[i][j] + 1 else: dp[i+1][j+1] = max(dp[i][j+1], dp[i+1][j]) lcs_length = dp[n][n] return n - lcs_length"},{"question":"You are given two strings `s` and `t` where `t` is generated by randomly shuffling string `s` and then adding one more character at a random position. Write a function to find the additional character in `t`.","solution":"def find_the_difference(s, t): Finds the additional character in t that is not in s. count_s = {} count_t = {} # Count characters in s for char in s: if char in count_s: count_s[char] += 1 else: count_s[char] = 1 # Count characters in t for char in t: if char in count_t: count_t[char] += 1 else: count_t[char] = 1 # Find the different character for char in count_t: if char not in count_s or count_t[char] > count_s[char]: return char"},{"question":"You are given a list of words `words` and a string `order` that represents the order of the characters in an alien alphabet. Write a function to determine if the given list of words is sorted lexicographically in this alien language. * You need to compare the words based on the character order given in `order`, and return `True` if they are sorted, otherwise return `False`. * All characters in the alien language are guaranteed to be lowercase English letters. * The length of `order` is 26, indicating it contains every lowercase English letter exactly once. * The length of the word list `words` and the length of each word will be within the range [1, 100]. Implement the function `isAlienSorted(words: List[str], order: str) -> bool`. # Function signature: ```python def isAlienSorted(words: List[str], order: str) -> bool: # Your code here ```","solution":"def isAlienSorted(words, order): Returns True if words are sorted lexicographically according to the alien language order, otherwise False. order_index = {char: index for index, char in enumerate(order)} def is_sorted(word1, word2): for char1, char2 in zip(word1, word2): if order_index[char1] < order_index[char2]: return True elif order_index[char1] > order_index[char2]: return False return len(word1) <= len(word2) for i in range(len(words) - 1): if not is_sorted(words[i], words[i + 1]): return False return True"},{"question":"Given a string `calendar` representing the appointments of a single person in a day, where each character of the string represents a time slot. If `calendar[i]` is `\'X\'`, it means the person is busy during the `i-th` time slot; otherwise, they are free. Write a function to determine the maximum number of consecutive free time slots the person has during the day. Return _the length_ of this longest span of consecutive free time slots.","solution":"def max_consecutive_free_slots(calendar): Determine the maximum number of consecutive free time slots in a calendar. Args: calendar (str): A string where \'X\' represents busy and other characters represent free slots. Returns: int: The length of the longest span of consecutive free time slots. max_free_slots = 0 current_free_slots = 0 for slot in calendar: if slot == \'X\': current_free_slots = 0 else: current_free_slots += 1 max_free_slots = max(max_free_slots, current_free_slots) return max_free_slots"},{"question":"Given a string `s` consisting of lower-case English letters, we want to split `s` into as many palindromic substrings as possible. A **palindromic substring** is a string that reads the same forward and backward. Write a function that returns the maximum number of palindromic substrings that `s` can be split into. Note that each character of the string must be part of exactly one palindromic substring.","solution":"def max_palindromic_substrings(s): Returns the maximum number of palindromic substrings that the string s can be split into. # Each single character is a palindrome by itself return len(s)"},{"question":"You are given a list of `n` integers `arr` and an integer `target`. Write a function to identify if there are three distinct integers in `arr` whose sum equals `target`. Return `true` if such a combination exists, and `false` otherwise. The function should have a time complexity better than O(n^3). For example: - Given `arr = [1, 4, 45, 6, 10, 8]` and `target = 22`, the function should return `true` because `4 + 10 + 8 = 22`. - Given `arr = [1, 2, 4, 6, 10]` and `target = 19`, the function should return `false`.","solution":"def three_sum(arr, target): Checks if there are three distinct integers in arr whose sum equals target. arr.sort() n = len(arr) for i in range(n - 2): left, right = i + 1, n - 1 while left < right: curr_sum = arr[i] + arr[left] + arr[right] if curr_sum == target: return True elif curr_sum < target: left += 1 else: right -= 1 return False"},{"question":"You are given two strings `s` and `t`. You want to form `t` using some characters from `s`. To achieve this, you can remove any number of characters (possibly zero) from `s` to create a subsequence of `s` that is a permutation of `t`. You need to check if it is possible to do this. Return `true` if you can form `t` from `s`, otherwise return `false`. **Example:** ``` Input: s = \\"abccba\\", t = \\"abc\\" Output: true Input: s = \\"abccba\\", t = \\"abb\\" Output: true Input: s = \\"abccba\\", t = \\"abcd\\" Output: false ```","solution":"from collections import Counter def can_form_subsequence(s, t): Checks if it is possible to form string t using characters from string s. s_counter = Counter(s) t_counter = Counter(t) for char, count in t_counter.items(): if s_counter[char] < count: return False return True"},{"question":"Given an input string `s` that consists of lowercase letters, you need to partition this string into as many parts as possible so that no letter appears in more than one part. Return a list of integers representing the size of these parts. For example, if the input string is `\\"ababcbacadefegdehijhklij\\"`, the partition is `\\"ababcbaca\\", \\"defegde\\", \\"hijhklij\\"`, which represents sizes `[9, 7, 8]`. To solve this problem, you can iterate through the string and determine the earliest point at which each part must end. This requires keeping track of the last occurrence of each character in the string.","solution":"def partitionLabels(s): Partitions the input string s into as many parts as possible so that no letter appears in more than one part. Returns a list of integers representing the size of these parts. # Store the last occurrence of each character last_occurrence = {c: i for i, c in enumerate(s)} partitions = [] start, end = 0, 0 # Iterate through the string to find partitions for i, c in enumerate(s): end = max(end, last_occurrence[c]) if i == end: partitions.append(end - start + 1) start = i + 1 return partitions"},{"question":"You are given two arrays `names` and `scores`, where `names[i]` is the name of the i-th student and `scores[i]` is their corresponding score. Write a function that returns a new array of names sorted in descending order by their scores. If two students have the same score, their names should be sorted in alphabetical order.","solution":"def sort_students_by_score(names, scores): Sorts the students\' names by their scores in descending order. If two students have the same score, their names are sorted alphabetically. :param names: List of student names. :param scores: List of corresponding scores. :return: List of names sorted by scores in descending order. # Combining names and scores into a list of tuples combined = list(zip(names, scores)) # Sorting primarily by score descending, and secondarily by name ascending combined_sorted = sorted(combined, key=lambda x: (-x[1], x[0])) # Extracting the sorted names sorted_names = [name for name, score in combined_sorted] return sorted_names"},{"question":"Given a string `s` and an integer `k`, you need to perform the following operation `k` times: Choose a substring of `s` of length `2` or more and reverse it. The goal is to convert `s` into a palindrome (a string that reads the same forward as backwards). Return `true` if it\'s possible to obtain a palindrome using up to `k` reverse operations, otherwise return `false`.","solution":"def can_convert_to_palindrome(s, k): Returns True if it\'s possible to convert string s into a palindrome using up to k reverse operations, otherwise returns False. n = len(s) mismatch_count = 0 # Calculate the number of mismatched character pairs for i in range(n // 2): if s[i] != s[n - i - 1]: mismatch_count += 1 # Each mismatch requires at least one reverse operation to correct return mismatch_count <= k"},{"question":"Given an array of integers representing the amount of time required to complete each task and an integer `n` representing the maximum time limit for any worker, design a method to assign tasks to workers such that the total time taken by each worker does not exceed `n`. __Return the minimum number of workers required__ to finish all the tasks. You can assume that each worker can take on multiple tasks as long as the total time of the assigned tasks does not exceed the worker\'s time limit.","solution":"def min_workers(tasks, n): Returns the minimum number of workers required to complete all tasks such that no worker has more than `n` amount of work. Parameters: tasks (list): List of integers representing the time required for each task. n (int): Maximum time limit for any worker. Returns: int: Minimum number of workers required. from collections import defaultdict # Base case if not tasks: return 0 # Sort the tasks in descending order tasks.sort(reverse=True) # List to store the time allocation for each worker workers = [] # Assign tasks to workers for task in tasks: placed = False for i in range(len(workers)): if workers[i] + task <= n: workers[i] += task placed = True break if not placed: # Need a new worker for this task workers.append(task) return len(workers)"},{"question":"Given a rectangular grid of size `m x n` filled with integers, write a function to find the maximum sum of any sub-grid of size `a x b`. A sub-grid is defined as any `a`-rows by `b`-columns section of the grid. The function should return the maximum sum as an integer.","solution":"def max_sum_subgrid(grid, a, b): Find the maximum sum of any a x b sub-grid in the given m x n grid. Parameters: grid (list of list of int): The m x n grid filled with integers. a (int): Number of rows in the sub-grid. b (int): Number of columns in the sub-grid. Returns: int: The maximum sum of any a x b sub-grid. m = len(grid) n = len(grid[0]) # Create a prefix sum array prefix_sum = [[0] * (n + 1) for _ in range(m + 1)] # Calculate prefix sum for i in range(m): for j in range(n): prefix_sum[i + 1][j + 1] = grid[i][j] + prefix_sum[i][j + 1] + prefix_sum[i + 1][j] - prefix_sum[i][j] max_sum = float(\'-inf\') # Find maximum sum of a x b sub-grid for i in range(a, m + 1): for j in range(b, n + 1): current_sum = (prefix_sum[i][j] - prefix_sum[i - a][j] - prefix_sum[i][j - b] + prefix_sum[i - a][j - b]) max_sum = max(max_sum, current_sum) return max_sum"},{"question":"Given an array of integers representing the price of merchandise over several days, find the maximum profit you can achieve. You may complete at most two transactions. A transaction consists of buying and then selling one piece of merchandise. Note that you cannot engage in multiple transactions simultaneously (i.e., you must sell the piece before you can buy again). Implement a function `maxProfit` that accepts an array `prices` and returns an integer representing the maximum profit. If no profit can be achieved, return 0. Note: * Input array `prices` will have a length of at least one. * Each element in `prices` represents the price of merchandise on that day.","solution":"def maxProfit(prices): Finds the maximum profit from at most two transactions on daily stock prices. Parameters: prices (List[int]): List of stock prices. Returns: int: The maximum profit possible. if not prices: return 0 first_buy, first_sell = float(\'-inf\'), 0 second_buy, second_sell = float(\'-inf\'), 0 for price in prices: first_buy = max(first_buy, -price) first_sell = max(first_sell, first_buy + price) second_buy = max(second_buy, first_sell - price) second_sell = max(second_sell, second_buy + price) return second_sell"},{"question":"You are given an integer array `heights` representing the heights of trees in a forest. A tree height is defined as the maximum height encountered in a contiguous subarray of `heights`. The local optimality of the forest can be disturbed if two adjacent trees have similar heights. Therefore, your task is to find the number of distinct pairs `(i, j)` (where `i` < `j`) such that the heights of the trees at `i` and `j` differ by at least a given value `d`. Return the total count of such valid pairs.","solution":"def count_valid_pairs(heights, d): Counts the number of distinct pairs (i, j) such that the heights of the trees at i and j differ by at least d. Parameters: heights (list of int): The list of tree heights. d (int): The minimum difference in tree height required for a pair to be valid. Returns: int: The count of valid pairs. n = len(heights) count = 0 for i in range(n): for j in range(i+1, n): if abs(heights[i] - heights[j]) >= d: count += 1 return count"},{"question":"You are given a binary tree where each node contains an integer value. Define the vertical sum of a binary tree as the sum of all the nodes that are vertically aligned at the same horizontal distance from the root. Write a function to return a list of integers representing the vertical sum of the binary tree from the leftmost column to the rightmost column. ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def vertical_sum(root: TreeNode) -> List[int]: # Your code here ``` Given the root of a binary tree, implement the `vertical_sum` function that computes and returns the vertical sums in a list. The list should be returned in order of the columns, starting from the leftmost column.","solution":"from typing import Optional, List import collections class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def vertical_sum(root: Optional[TreeNode]) -> List[int]: if not root: return [] column_table = collections.defaultdict(int) queue = collections.deque([(root, 0)]) while queue: node, column = queue.popleft() column_table[column] += node.val if node.left: queue.append((node.left, column - 1)) if node.right: queue.append((node.right, column + 1)) min_column = min(column_table.keys()) max_column = max(column_table.keys()) return [column_table[col] for col in range(min_column, max_column + 1)]"},{"question":"You are given an array `logs` where each log is a string formatted as `\\"<id> <timestamp>\\"`. The `id` is an alphanumeric string, and `timestamp` is an integer representing the time in seconds since an arbitrary point in time. The array is not sorted. Define a log as \'interesting\' if the difference in timestamp between it and any other log with the same id is greater than or equal to `t`, where `t` is a given threshold in seconds. Return an array of the `id`s that have any \'interesting\' logs, sorted alphabetically. Note: The same `id` will not appear more than once in the output array.","solution":"def find_interesting_logs(logs, t): Returns the list of ids that have any interesting logs. Args: logs: List of log entries where each entry is a string \\"<id> <timestamp>\\" t: Integer threshold in seconds Returns: List of ids with interesting logs, sorted alphabetically. from collections import defaultdict log_dict = defaultdict(list) # Parse the logs into a dictionary for log in logs: id, timestamp = log.split() timestamp = int(timestamp) log_dict[id].append(timestamp) interesting_ids = set() # Check for interesting ids for id, timestamps in log_dict.items(): timestamps.sort() for i in range(1, len(timestamps)): if timestamps[i] - timestamps[i - 1] >= t: interesting_ids.add(id) break return sorted(interesting_ids)"},{"question":"You are given an integer array `arr` of size `n` which represents the locations of `n` stores on a number line. Additionally, you are given an integer `k` representing the number of warehouses to build. Each warehouse can provide supplies to all stores within a certain range to the left and right of its location. Determine the minimum possible total range that needs to be covered by the warehouses to supply all stores. Return _the minimum total range_. The range is defined as the difference between the maximum and minimum store locations that a warehouse can serve.","solution":"def min_total_range(arr, k): Returns the minimum possible total range that needs to be covered by the warehouses to supply all stores. Parameters: arr (list of int): The list of integers representing the locations of the stores. k (int): The number of warehouses to build. Returns: int: The minimum total range. if not arr or k <= 0 or k >= len(arr): return 0 arr.sort() n = len(arr) gaps = [arr[i] - arr[i-1] for i in range(1, n)] gaps.sort() return sum(gaps[:n-k])"},{"question":"Given a matrix of size `m x n` with `0`\'s representing water and `1`\'s representing land, find the largest contiguous island of land areas. Contiguous land areas are connected vertically or horizontally (not diagonally). An island is considered as a connected component of `1`s. Return the size of the largest island. If there is no land, return `0`.","solution":"def largest_island(matrix): Returns the size of the largest contiguous island of 1\'s in the given matrix. if not matrix: return 0 m, n = len(matrix), len(matrix[0]) visited = [[False for _ in range(n)] for _ in range(m)] def dfs(i, j): if i < 0 or i >= m or j < 0 or j >= n or visited[i][j] or matrix[i][j] == 0: return 0 visited[i][j] = True size = 1 # current land # explore all 4 directions size += dfs(i - 1, j) size += dfs(i + 1, j) size += dfs(i, j - 1) size += dfs(i, j + 1) return size largest = 0 for i in range(m): for j in range(n): if matrix[i][j] == 1 and not visited[i][j]: island_size = dfs(i, j) largest = max(largest, island_size) return largest"},{"question":"You are given a string `s` consisting of lower-case English letters. You are allowed to perform any number of operations to this string. In one operation, you can select any two adjacent characters and replace them with the same character. Your goal is to determine the lexicographically smallest string that can be obtained after an infinite number of operations. Return _the lexicographically smallest string_.","solution":"def lexicographically_smallest_string(s: str) -> str: Returns the lexicographically smallest string that can be obtained after an infinite number of the allowed operations. if not s: return \\"\\" smallest_char = min(s) return smallest_char * len(s)"},{"question":"You are given a string `s` consisting of lowercase English letters and an integer `k`. A **subarray** is a contiguous segment of a string. Consider finding the longest subarray in which there are at most `k` different characters. Write a function that returns the length of such a subarray.","solution":"def longest_subarray_with_k_distinct(s, k): Returns the length of the longest subarray with at most k distinct characters. Args: s (str): The input string. k (int): The maximum number of distinct characters allowed. Returns: int: The length of the longest subarray with at most k distinct characters. if k == 0: return 0 char_count = {} left = 0 max_length = 0 for right in range(len(s)): char = s[right] if char in char_count: char_count[char] += 1 else: char_count[char] = 1 while len(char_count) > k: left_char = s[left] char_count[left_char] -= 1 if char_count[left_char] == 0: del char_count[left_char] left += 1 max_length = max(max_length, right - left + 1) return max_length"},{"question":"Given an integer `x`, return _the minimum number of steps required to reduce `x` to 1_ following these rules: - If `x` is even, you may divide it by 2. - If `x` is odd, you may either increment or decrement it by 1.","solution":"def min_steps_to_one(x): Returns the minimum number of steps required to reduce `x` to 1. If `x` is even, we divide it by 2. If `x` is odd, we either increment or decrement it by 1. steps = 0 while x != 1: if x % 2 == 0: x //= 2 else: if x == 3 or ((x >> 1) & 1) == 0: x -= 1 else: x += 1 steps += 1 return steps"},{"question":"Write a function `minimumWindowSubstring` that takes in two strings `s` and `t`, and returns the minimum window in `s` which will contain all the characters in `t`. If there is no such window in `s` that covers all characters in `t`, return the empty string `\\"\\"`. Note that if there is such a window, it is guaranteed that there will always be only one unique minimum window in `s`.","solution":"from collections import Counter, defaultdict def minimumWindowSubstring(s, t): Returns the minimum window in s which will contain all the characters in t. If there is no such window, returns an empty string. if not t or not s: return \\"\\" # Dictionary to keep a count of all the unique characters in t dict_t = Counter(t) # Number of unique characters in t that must be present in the window required = len(dict_t) # Dictionary to keep a count of all the unique characters in the current window window_counts = defaultdict(int) # Formed is the number of unique characters in the current window where their count in window is the same as in t formed = 0 l, r = 0, 0 # (window length, left, right) ans = float(\\"inf\\"), None, None while r < len(s): # Add one character from the right to the window character = s[r] window_counts[character] += 1 # If the current character\'s frequency in the window matches its frequency in t, increment the formed counter if character in dict_t and window_counts[character] == dict_t[character]: formed += 1 # Try and contract the window till the point where it ceases to be \'desirable\' while l <= r and formed == required: character = s[l] # Save the smallest window if r - l + 1 < ans[0]: ans = (r - l + 1, l, r) # The character at the position pointed by the left pointer is removed from the window window_counts[character] -= 1 if character in dict_t and window_counts[character] < dict_t[character]: formed -= 1 # Move the left pointer ahead l += 1 # Keep expanding the window once done contracting r += 1 return \\"\\" if ans[0] == float(\\"inf\\") else s[ans[1]: ans[2] + 1]"},{"question":"Given a string `s` consisting of lowercase English letters, return the length of the **longest substring** with no repeating characters. If there are multiple substrings of the same length, return the length of the first one encountered. Important points to note: - The substring should be *contiguous*. - The solution should be efficient, aiming for a linear-time complexity where possible.","solution":"def length_of_longest_substring(s): Returns the length of the longest substring without repeating characters. n = len(s) if n == 0: return 0 max_len = 0 start = 0 used_chars = {} for i in range(n): if s[i] in used_chars and start <= used_chars[s[i]]: start = used_chars[s[i]] + 1 else: max_len = max(max_len, i - start + 1) used_chars[s[i]] = i return max_len"},{"question":"Given an array of integers `nums` and an integer `k`, arrange the array such that each number in `nums` is repeated `k` times consecutively. The order of the elements should remain the same as the original order in `nums`. Return the modified array. For example, if `nums = [1, 2, 3]` and `k = 2`, the output should be `[1, 1, 2, 2, 3, 3]`.","solution":"def repeat_elements(nums, k): Returns an array where each element in nums is repeated k times consecutively. Args: nums: A list of integers. k: An integer indicating how many times each element should be repeated. Returns: A list of integers where each element is repeated k times consecutively. if k <= 0: return [] result = [] for num in nums: result.extend([num] * k) return result"}]'),N={name:"App",components:{PoemCard:Y},data(){return{searchQuery:"",visibleCount:4,poemsData:A,isLoading:!1}},computed:{filteredPoems(){const i=this.searchQuery.trim().toLowerCase();return i?this.poemsData.filter(e=>e.question&&e.question.toLowerCase().includes(i)||e.solution&&e.solution.toLowerCase().includes(i)):this.poemsData},displayedPoems(){return this.searchQuery.trim()?this.filteredPoems:this.filteredPoems.slice(0,this.visibleCount)},hasMorePoems(){return!this.searchQuery.trim()&&this.visibleCount<this.poemsData.length}},methods:{async loadMore(){this.isLoading=!0,await new Promise(i=>setTimeout(i,1e3)),this.visibleCount+=4,this.isLoading=!1}}},F={class:"search-container"},z={class:"card-container"},L={key:0,class:"empty-state"},C=["disabled"],S={key:0},D={key:1};function E(i,e,u,c,s,a){const f=p("PoemCard");return n(),r("section",null,[e[4]||(e[4]=t("div",{class:"top-banner"},[t("div",{class:"top-banner-title"},[t("div",{class:"top-banner-title-text"},"🤔prompts chat🧠")])],-1)),t("div",F,[e[3]||(e[3]=t("span",{class:"search-icon"},"🔍",-1)),_(t("input",{type:"text",class:"search-input","onUpdate:modelValue":e[0]||(e[0]=o=>s.searchQuery=o),placeholder:"Search..."},null,512),[[b,s.searchQuery]]),s.searchQuery?(n(),r("button",{key:0,class:"clear-search",onClick:e[1]||(e[1]=o=>s.searchQuery="")}," ✕ ")):l("",!0)]),t("div",z,[(n(!0),r(y,null,w(a.displayedPoems,(o,g)=>(n(),v(f,{key:g,poem:o},null,8,["poem"]))),128)),a.displayedPoems.length===0?(n(),r("div",L,' No results found for "'+h(s.searchQuery)+'". ',1)):l("",!0)]),a.hasMorePoems?(n(),r("button",{key:0,class:"load-more-button",disabled:s.isLoading,onClick:e[2]||(e[2]=(...o)=>a.loadMore&&a.loadMore(...o))},[s.isLoading?(n(),r("span",D,"Loading...")):(n(),r("span",S,"See more"))],8,C)):l("",!0)])}const G=m(N,[["render",E],["__scopeId","data-v-30377a0c"]]),M=JSON.parse('{"title":"","description":"","frontmatter":{"page":true},"headers":[],"relativePath":"library/11.md","filePath":"library/11.md"}'),P={name:"library/11.md"},B=Object.assign(P,{setup(i){return(e,u)=>(n(),r("div",null,[x(G)]))}});export{M as __pageData,B as default};
