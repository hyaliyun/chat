import{_ as h,o as n,c as i,a as t,m as c,t as d,C as g,M as _,U as y,f as u,F as b,p as v,e as w,q as x}from"./chunks/framework.B1z0IdBH.js";const k={name:"PoemCard",props:{poem:{type:Object,required:!0}}},T={class:"poem-container"},q={class:"review"},E={class:"review-title"},I={class:"review-content"};function A(r,e,l,p,s,a){return n(),i("div",T,[t("div",q,[t("div",E,[e[0]||(e[0]=t("span",{class:"icon"},"question:",-1)),c(d(l.poem.question),1)]),e[2]||(e[2]=t("div",{class:"divider"},null,-1)),t("p",I,[e[1]||(e[1]=t("span",{class:"icon"},"answer:",-1)),c(d(l.poem.solution),1)])])])}const C=h(k,[["render",A],["__scopeId","data-v-66379a47"]]),S=JSON.parse('[{"question":"# Word Ladder Transformation Pathfinding Challenge You are given an initial word, a target word, and a list of intermediate words (word dictionary). Each transformation involves changing exactly one letter to form a new word that must exist in the word dictionary. Your task is to find the shortest possible sequence of transformations from the initial word to the target word. If no such transformation sequence exists, return an empty list. Word Ladder Overview: The Word Ladder problem can be solved efficiently using the Breadth-First Search (BFS) algorithm, which explores all possible single-letter transformations level by level. * **Time Complexity**: O(n * m^2) where `n` is the number of words in the dictionary and `m` is the length of the words. * **Space Complexity**: O(n) # Task: 1. Implement the `word_ladder_path` function that finds the shortest transformation path from a start word to an end word using the words provided in the dictionary. 2. Ensure that your implementation handles all edge cases appropriately. 3. The function should return a list of strings representing the transformation path from the start word to the end word. # Function Signature: ```python def word_ladder_path(begin_word: str, end_word: str, word_list: list) -> list: ``` # Input: * `begin_word` (String): The initial word from which the transformation begins. * `end_word` (String): The target word to which the transformation ends. * `word_list` (List[String]): A list of strings representing the word dictionary. # Output: * A list of strings representing the shortest transformation path from `begin_word` to `end_word`. If no transformation is possible, return an empty list. # Constraints: * All words in the input list, as well as `begin_word` and `end_word`, will have the same length `m` where 1 <= m <= 10. * The length of the word list will be between 1 and 5000. * All words consist of lowercase English letters. # Example: ```python >>> word_ladder_path(\\"hit\\", \\"cog\\", [\\"hot\\",\\"dot\\",\\"dog\\",\\"lot\\",\\"log\\",\\"cog\\"]) [\\"hit\\", \\"hot\\", \\"dot\\", \\"dog\\", \\"cog\\"] >>> word_ladder_path(\\"hit\\", \\"cog\\", [\\"hot\\",\\"dot\\",\\"dog\\",\\"lot\\",\\"log\\"]) [] >>> word_ladder_path(\\"a\\", \\"c\\", [\\"a\\",\\"b\\",\\"c\\"]) [\\"a\\", \\"c\\"] >>> word_ladder_path(\\"abc\\", \\"xyz\\", [\\"abz\\", \\"axy\\", \\"ayz\\", \\"xyz\\"]) [\\"abc\\", \\"abz\\", \\"ayz\\", \\"xyz\\"] >>> word_ladder_path(\\"same\\", \\"same\\", [\\"same\\"]) [\\"same\\"] ``` # Requirements: 1. Your solution should use BFS for efficiency and correctness. 2. Handle all edge cases properly, including when no transformation is possible.","solution":"from collections import deque def word_ladder_path(begin_word: str, end_word: str, word_list: list) -> list: if end_word not in word_list: return [] word_list = set(word_list) queue = deque([[begin_word]]) visited = set([begin_word]) while queue: current_path = queue.popleft() current_word = current_path[-1] if current_word == end_word: return current_path for i in range(len(current_word)): for char in \'abcdefghijklmnopqrstuvwxyz\': next_word = current_word[:i] + char + current_word[i+1:] if next_word in word_list and next_word not in visited: visited.add(next_word) new_path = list(current_path) new_path.append(next_word) queue.append(new_path) return []"},{"question":"# Binary Search Tree (BST) Unique Addition: Coding Challenge **Context**: In this task, you need to create a class for a Binary Search Tree (BST) that allows only unique values. Each value in the BST must be unique, meaning duplicates are not allowed. **Objective**: Write functions to insert a value into the BST, check if a value exists in the BST, and return an in-order traversal of the BST. **Class Specifications**: 1. **class Node** - Attributes: * `value`: The value of the node. * `left`: Reference to the left child node. * `right`: Reference to the right child node. 2. **class BST** - Methods: 1. **def __init__(self)** - Initializes an empty BST. 2. **def insert(self, value: int) -> bool** - Input: * `value`: The value to insert. - Output: * `True` if the value is successfully inserted. * `False` if the value already exists in the BST (no duplicates allowed). 3. **def exists(self, value: int) -> bool** - Input: * `value`: The value to check. - Output: * `True` if the value exists in the BST. * `False` if the value does not exist in the BST. 4. **def in_order(self) -> list** - Output: * A list of BST values resulting from an in-order traversal. **Example**: ```python # Create a new BST instance bst = BST() # Insert values into the BST bst.insert(50) # True bst.insert(30) # True bst.insert(70) # True bst.insert(20) # True bst.insert(40) # True bst.insert(60) # True bst.insert(60) # False (duplicate) bst.insert(10) # True # Check existence of values print(bst.exists(30)) # True print(bst.exists(100)) # False # Get in-order traversal print(bst.in_order()) # [10, 20, 30, 40, 50, 60, 70] ``` **Requirements**: - The BST should have the properties of a Binary Search Tree: * Left subtree of a node contains only nodes with values less than the node\'s value. * Right subtree of a node contains only nodes with values greater than the node\'s value. - No duplicate values are allowed, and the insert method should handle duplicate values appropriately. - Implement necessary checks and traversal to maintain the BST properties. This question tests understanding of BST properties, how to handle duplicates, and performing in-order traversal, similar to the Vigenère Cipher question\'s requirement for handling different character types and preserving their properties while implementing core functionalities.","solution":"class Node: def __init__(self, value): self.value = value self.left = None self.right = None class BST: def __init__(self): self.root = None def insert(self, value: int) -> bool: if self.root is None: self.root = Node(value) return True else: return self._insert_recursive(self.root, value) def _insert_recursive(self, current_node, value) -> bool: if value == current_node.value: return False # duplicate value elif value < current_node.value: if current_node.left is None: current_node.left = Node(value) return True else: return self._insert_recursive(current_node.left, value) else: # value > current_node.value if current_node.right is None: current_node.right = Node(value) return True else: return self._insert_recursive(current_node.right, value) def exists(self, value: int) -> bool: return self._exists_recursive(self.root, value) def _exists_recursive(self, current_node, value) -> bool: if current_node is None: return False if value == current_node.value: return True elif value < current_node.value: return self._exists_recursive(current_node.left, value) else: # value > current_node.value return self._exists_recursive(current_node.right, value) def in_order(self) -> list: result = [] self._in_order_recursive(self.root, result) return result def _in_order_recursive(self, current_node, result): if current_node is not None: self._in_order_recursive(current_node.left, result) result.append(current_node.value) self._in_order_recursive(current_node.right, result)"},{"question":"# Coding Question: Binary Search Tree Operations for an Inventory Management System Background: A warehouse inventory management system uses a binary search tree (BST) to keep track of items based on their unique identification numbers. This system must efficiently support operations such as adding new items, removing items, finding items, and listing all items in order. Task: Implement the following operations in your BST class: 1. **Insert Item**: Add a new item with a given identification number. 2. **Remove Item**: Remove an item with a specific identification number. 3. **Find Item**: Check if an item with a given identification number exists. 4. **Inorder Traversal**: List all items in ascending order of their identification numbers. Your BST class must have the following methods implementing the required operations: ```python class TreeNode: def __init__(self, key: int): Initialize a tree node with the given key. :param key: Integer identification number of the item. self.key = key self.left = None self.right = None class BinarySearchTree: def __init__(self): Initialize an empty binary search tree. self.root = None def insert(self, key: int) -> None: Insert an item with the given identification number into the BST. :param key: Integer identification number of the item. pass def remove(self, key: int) -> None: Remove an item with the specified identification number from the BST. :param key: Integer identification number of the item to be removed. pass def find(self, key: int) -> bool: Check if an item with the given identification number exists in the BST. :param key: Integer identification number of the item. :return: True if the item exists, False otherwise. pass def inorder_traversal(self) -> list[int]: Return a list of all item identification numbers in ascending order. :return: List of integer identification numbers in ascending order. pass ``` Input/Output Format: * `insert(key: int)` - Adds a new item with the specific identification number. * `remove(key: int)` - Removes the item with the specified identification number. * `find(key: int)` - Returns True if the item exists, False otherwise. * `inorder_traversal()` - Returns a sorted list of all item identification numbers. Constraints: * All identification numbers are unique integers. * The number of items will not exceed 10^6. Example Usage: ```python # Example initialization and operations bst = BinarySearchTree() bst.insert(50) bst.insert(30) bst.insert(70) bst.insert(20) bst.insert(40) bst.insert(60) bst.insert(80) print(bst.find(60)) # Output: True print(bst.find(25)) # Output: False bst.remove(20) inorder_list = bst.inorder_traversal() print(inorder_list) # Output: [30, 40, 50, 60, 70, 80] bst.remove(30) inorder_list = bst.inorder_traversal() print(inorder_list) # Output: [40, 50, 60, 70, 80] ``` Ensure that your implementation efficiently handles the operations and maintains the BST property through all manipulations.","solution":"class TreeNode: def __init__(self, key: int): self.key = key self.left = None self.right = None class BinarySearchTree: def __init__(self): self.root = None def insert(self, key: int) -> None: if self.root is None: self.root = TreeNode(key) else: self._insert(self.root, key) def _insert(self, node: TreeNode, key: int) -> None: if key < node.key: if node.left is None: node.left = TreeNode(key) else: self._insert(node.left, key) else: if node.right is None: node.right = TreeNode(key) else: self._insert(node.right, key) def remove(self, key: int) -> None: self.root = self._remove(self.root, key) def _remove(self, node: TreeNode, key: int) -> TreeNode: if node is None: return None if key < node.key: node.left = self._remove(node.left, key) elif key > node.key: node.right = self._remove(node.right, key) else: if node.left is None: return node.right elif node.right is None: return node.left min_larger_node = self._get_min(node.right) node.key = min_larger_node.key node.right = self._remove(node.right, min_larger_node.key) return node def _get_min(self, node: TreeNode) -> TreeNode: current = node while current.left is not None: current = current.left return current def find(self, key: int) -> bool: return self._find(self.root, key) def _find(self, node: TreeNode, key: int) -> bool: if node is None: return False if key == node.key: return True elif key < node.key: return self._find(node.left, key) else: return self._find(node.right, key) def inorder_traversal(self) -> list[int]: result = [] self._inorder_traversal(self.root, result) return result def _inorder_traversal(self, node: TreeNode, result: list[int]) -> None: if node: self._inorder_traversal(node.left, result) result.append(node.key) self._inorder_traversal(node.right, result)"},{"question":"# Question Context A software engineer is working on a simulation involving people moving around a grid. They need a function to calculate the Manhattan distance (also known as \\"taxicab\\" distance) between two points on a grid. You are tasked with creating this utility function. Task Write a function `manhattan_distance` that computes the Manhattan distance between two points on a grid. Function Signature ```python def manhattan_distance(point1: tuple, point2: tuple) -> int: ``` Input * `point1` (tuple): The coordinates of the first point in the form `(x1, y1)` where `x1` and `y1` are integers. * `point2` (tuple): The coordinates of the second point in the form `(x2, y2)` where `x2` and `y2` are integers. Output * (int): The Manhattan distance between the two points. Example ```python >>> manhattan_distance((1, 2), (4, 6)) 7 >>> manhattan_distance((0, 0), (3, 4)) 7 >>> manhattan_distance((-1, -1), (2, 3)) 7 ``` Constraints * Both points are described by tuples containing two integers. * Each coordinate `x` and `y` in the points can be any integer, positive or negative. Edge Cases * When both points are the same, the Manhattan distance should be 0. * When the points are aligned either vertically or horizontally, the distance should be the absolute difference in their respective coordinates.","solution":"def manhattan_distance(point1: tuple, point2: tuple) -> int: Computes the Manhattan distance between two points on a grid. Parameters: point1 (tuple): The coordinates of the first point in the form (x1, y1) point2 (tuple): The coordinates of the second point in the form (x2, y2) Returns: int: The Manhattan distance between the two points. x1, y1 = point1 x2, y2 = point2 return abs(x1 - x2) + abs(y1 - y2)"},{"question":"# Context You are tasked with developing a feature for an application\'s statistics module. This feature will enable users to compute the median and mode from a given list of integers. Your task is to create a function that will take a list of integers as input and return the median and mode of the list. # Task Implement a function `calculate_stats(numbers: list) -> dict` that determines the median and mode of a list of integers. The function should accept a list of integers and return a dictionary containing the calculated median and mode. # Input Requirements 1. `numbers`: A list of integers. # Output Format A dictionary with the following key-value pairs: - `\\"median\\"`: The median value of the input list (rounded to 2 decimal places, if necessary). - `\\"mode\\"`: The mode value of the input list. If there are multiple modes, return the smallest mode. # Constraints & Considerations - **Constraints**: - Raise an appropriate error for invalid input values, such as an empty list. A **ValueError** should be raised if the list is empty. - Raise a **TypeError** if the input is not a list of integers. - **Performance requirements**: The solution should efficiently handle basic sorting and frequency counting operations, ensuring smooth execution. # Function Signature In the implementation, ensure to define the function signature as follows: ```python def calculate_stats(numbers: list) -> dict: pass ``` # Example ```python >>> calculate_stats([1, 2, 2, 3, 4]) { \\"median\\": 2, \\"mode\\": 2 } >>> calculate_stats([5, 2, 3, 2, 5]) { \\"median\\": 3, \\"mode\\": 2 } >>> calculate_stats([5, 1, 3, 5, 2, 5]) { \\"median\\": 4.0, \\"mode\\": 5 } >>> calculate_stats([]) Traceback (most recent call last): ... ValueError: The list is empty. >>> calculate_stats(\\"string input\\") Traceback (most recent call last): ... TypeError: Input must be a list of integers. ```","solution":"def calculate_stats(numbers: list) -> dict: Calculate the median and mode of a list of integers. :param numbers: List of integers. :return: Dictionary with \'median\' and \'mode\' keys. :raises ValueError: If the list is empty. :raises TypeError: If input is not a list of integers. if not isinstance(numbers, list): raise TypeError(\\"Input must be a list of integers.\\") if len(numbers) == 0: raise ValueError(\\"The list is empty.\\") if not all(isinstance(x, int) for x in numbers): raise TypeError(\\"Input must be a list of integers.\\") # Sort the list sorted_numbers = sorted(numbers) # Calculate median n = len(sorted_numbers) midpoint = n // 2 if n % 2 == 0: median = (sorted_numbers[midpoint - 1] + sorted_numbers[midpoint]) / 2.0 else: median = float(sorted_numbers[midpoint]) # Calculate mode frequency = {} for num in sorted_numbers: frequency[num] = frequency.get(num, 0) + 1 max_count = max(frequency.values()) mode_candidates = [k for k, v in frequency.items() if v == max_count] mode = min(mode_candidates) return { \\"median\\": round(median, 2), \\"mode\\": mode }"},{"question":"# Coding Assessment Question You are required to implement a function to manage inventory for a simple retail store. The function will track and update quantities of products based on sales and restock operations. Proper implementation of inventory management will ensure accurate stock levels and prevent negative inventories. Task Implement a function `update_inventory` that processes a list of operations, updating the quantities of items in the inventory accordingly. Each operation is either sales, which decrements the item quantity, or restock, which increments the item quantity. Function Signature ```python def update_inventory(inventory: dict[str, int], operations: list[tuple[str, str, int]]) -> dict[str, int]: pass ``` Parameters - `inventory` (dict): A dictionary where keys are product names (strings) and values are their quantities (non-negative integers). - `operations` (list): A list of tuples, each containing: - An operation type (string), either \\"sell\\" or \\"restock\\". - The name of the product (string). - The quantity (integer) to update. Must be positive. Returns - The updated `inventory` dictionary with adjusted quantities after all operations have been applied. Constraints - A product mentioned in the operations but not existing in the initial inventory should be considered as having an initial quantity of 0. - Raise a `ValueError` if an operation tries to sell more items than are available in the inventory. - Ensure that all quantities remain non-negative after each operation. Example ```python >>> inventory = {\'apples\': 10, \'bananas\': 5} >>> operations = [(\'sell\', \'apples\', 3), (\'restock\', \'bananas\', 7), (\'sell\', \'oranges\', 2), (\'restock\', \'apples\', 5)] >>> update_inventory(inventory, operations) {\'apples\': 12, \'bananas\': 12, \'oranges\': -2} ``` Notes: - Ensure that your implementation handles edge cases appropriately. - Operations need to be processed in the order they appear in the list. - Proper error handling and input validation should be included to prevent negative inventories and to handle new products not in the initial dictionary.","solution":"def update_inventory(inventory: dict[str, int], operations: list[tuple[str, str, int]]) -> dict[str, int]: Updates the inventory based on a list of operations. :param inventory: A dictionary where keys are product names and values are their quantities. :param operations: A list of tuples with each containing an operation type (\'sell\' or \'restock\'), the product name, and the quantity. :return: Updated inventory dictionary. for operation, product, quantity in operations: # Ensure quantity is positive if quantity <= 0: raise ValueError(\\"Quantity must be a positive integer\\") # Initialize product quantity if not present in inventory if product not in inventory: inventory[product] = 0 if operation == \'sell\': # Check if selling more than available if inventory[product] < quantity: raise ValueError(f\\"Cannot sell {quantity} of {product}. Only {inventory[product]} available.\\") inventory[product] -= quantity elif operation == \'restock\': inventory[product] += quantity else: raise ValueError(\\"Invalid operation type. Only \'sell\' and \'restock\' are allowed.\\") return inventory"},{"question":"# Coding Assessment Question Description Dynamic programming and recursion techniques are widely used in solving optimization problems. One typical problem is determining the minimum number of coins needed to make a certain amount of change, given a set of coin denominations. Your task is to write a function that computes the minimum number of coins required to make a specific amount using a given set of coin denominations. Task Implement the function: ```python def min_coins(coins: List[int], amount: int) -> int: :param coins: List of coin denominations (positive integers). :param amount: The target amount to make with the given coins. :return: The minimum number of coins needed to make the target amount, or -1 if it is not possible. ``` This function should: * Take a list of coin denominations. * Determine the minimum number of coins needed to make up the specified amount. * Return -1 if the amount cannot be constructed with the given coins. Input * `coins`: List of positive integers representing the coin denominations. * `amount`: Integer representing the target amount. Output * Return the minimum number of coins to make up the `amount` or -1 if it is not possible. Constraints * 1 <= len(coins) <= 50 * 1 <= coins[i] <= 100 * 0 <= amount <= 10,000 Performance Requirements * The function should handle up to the maximum input sizes efficiently and produce results within reasonable time limits. Example: ```python coins = [1, 2, 5] amount = 11 result = min_coins(coins, amount) ``` The `result` should be `3`, as the minimum number of coins needed to make 11 is 3 (11 = 5 + 5 + 1). ```python coins = [2] amount = 3 result = min_coins(coins, amount) ``` The `result` should be `-1`, as it is impossible to make 3 with only coin denomination 2.","solution":"from typing import List def min_coins(coins: List[int], amount: int) -> int: # Create a table to store minimum number of coins for every amount from 0 to amount # We use amount + 1 to initially set an impossible high number (amount + 1) as we start and want to find min. dp = [amount + 1] * (amount + 1) dp[0] = 0 # Base case: no coins needed to make amount 0 # Iterate over each amount from 1 to the target amount for a in range(1, amount + 1): # For each coin, update the dp table if it can contribute to a lesser number of coins for coin in coins: if coin <= a: dp[a] = min(dp[a], dp[a - coin] + 1) # If dp[amount] is still amount + 1, then it was not possible to make change for the target amount return dp[amount] if dp[amount] != amount + 1 else -1"},{"question":"# Question You are tasked with implementing a k-nearest neighbors (k-NN) algorithm for classifying a given set of data points. The function should classify each point using the majority vote of its k nearest neighbors. Function Signature ```python def knn_classify(data: np.ndarray, labels: np.ndarray, query_points: np.ndarray, k: int) -> np.ndarray: ``` Parameters * `data`: A 2D numpy array of shape (n_samples, n_features) representing the training data. * `labels`: A 1D numpy array of shape (n_samples,), where each element is the label corresponding to a data point. * `query_points`: A 2D numpy array of shape (m_samples, n_features) representing the points to classify. * `k`: An integer representing the number of nearest neighbors to use for classification. Output * Returns a 1D numpy array containing the predicted labels for each of the query points. Description 1. For each point in `query_points`, calculate the Euclidean distance to all points in `data`. 2. Identify the k nearest neighbors based on these distances. 3. Assign the most common label among the nearest neighbors to the query point. 4. Return the predicted labels for all query points. Example ```python import numpy as np data = np.array([[1, 2], [1, 0], [0, 1], [5, 5], [6, 6], [5, 6]]) labels = np.array([0, 0, 0, 1, 1, 1]) query_points = np.array([[0, 0], [5, 5]]) k = 3 predictions = knn_classify(data, labels, query_points, k) print(predictions) ``` This should print an array with the predicted labels for the query points based on the k-nearest neighbors algorithm. For the given example, this could be: ```python array([0, 1]) ``` **Constraints**: - The number of neighbors `k` will be a positive integer less than or equal to the total number of data points. - The dimensionality of the data points in `data` and `query_points` will be the same. - Each label in `labels` is assumed to be a non-negative integer.","solution":"import numpy as np from collections import Counter def knn_classify(data: np.ndarray, labels: np.ndarray, query_points: np.ndarray, k: int) -> np.ndarray: def euclidean_distance(p1, p2): return np.sqrt(np.sum((p1 - p2) ** 2)) predictions = [] for query in query_points: distances = [euclidean_distance(query, point) for point in data] k_indices = np.argsort(distances)[:k] k_nearest_labels = labels[k_indices] most_common_label = Counter(k_nearest_labels).most_common(1)[0][0] predictions.append(most_common_label) return np.array(predictions)"},{"question":"# Problem Statement You are helping to develop an application that manages a collection of books. Each book is represented by its title, author, and year of publication. One of the features you need to implement is a search functionality that can find books by title. The search should be case-insensitive and allow for partial matches. # Function Specifications Function: `search_books(books, query)` - **Input**: - `books`: A list of dictionaries, each dictionary represents a book with the following keys: - `title`: A string representing the book title. - `author`: A string representing the book author. - `year`: An integer representing the year of publication. - `query`: A string representing the search query. - **Output**: A list of dictionaries representing the books that match the search query based on title. - **Constraints**: The `books` list can be empty. The `query` string can be empty but should return an empty list in such case. The search should be case-insensitive. # Examples Example 1: Searching Books ```python >>> books = [ {\\"title\\": \\"The Catcher in the Rye\\", \\"author\\": \\"J.D. Salinger\\", \\"year\\": 1951}, {\\"title\\": \\"To Kill a Mockingbird\\", \\"author\\": \\"Harper Lee\\", \\"year\\": 1960}, {\\"title\\": \\"1984\\", \\"author\\": \\"George Orwell\\", \\"year\\": 1949}, {\\"title\\": \\"The Great Gatsby\\", \\"author\\": \\"F. Scott Fitzgerald\\", \\"year\\": 1925} ] >>> search_books(books, \\"the\\") [ {\\"title\\": \\"The Catcher in the Rye\\", \\"author\\": \\"J.D. Salinger\\", \\"year\\": 1951}, {\\"title\\": \\"The Great Gatsby\\", \\"author\\": \\"F. Scott Fitzgerald\\", \\"year\\": 1925} ] >>> search_books(books, \\"198\\") [ {\\"title\\": \\"1984\\", \\"author\\": \\"George Orwell\\", \\"year\\": 1949} ] >>> search_books(books, \\"MOCK\\") [ {\\"title\\": \\"To Kill a Mockingbird\\", \\"author\\": \\"Harper Lee\\", \\"year\\": 1960} ] >>> search_books(books, \\"\\") [] ``` # Detailed Instructions 1. **Implement `search_books` function**: - If the `books` list is empty or the `query` string is empty, return an empty list. - Convert both the book titles and the search query to lowercase to ensure case-insensitivity. - Iterate through the list of books and check whether the lowercase query string is a substring of the lowercase book title. - Collect and return all books that match the search criteria as a list of dictionaries. # Additional Notes - Ensure to test your function with different cases, including but not limited to, empty input list, empty query string, no matches and case variations in the search. - Aim to keep solving time within reasonable limits considering a typical size of the books list. Good luck and be sure to thoroughly test your implementation!","solution":"def search_books(books, query): Searches for books by title in a case-insensitive manner. Args: - books (list): List of dictionaries representing books. Each dictionary has keys: \'title\', \'author\', \'year\'. - query (str): Search query string. Returns: - list: List of dictionaries representing books that match the search query. if not query: return [] query_lower = query.lower() matched_books = [book for book in books if query_lower in book[\\"title\\"].lower()] return matched_books"},{"question":"# Coding Assessment Question Problem Statement Given an array of integers representing the heights of bars in a histogram, implement a function `max_histogram_area(heights)` that calculates the area of the largest rectangle that can be formed within the bounds of the histogram. Each bar in the histogram is of width 1 unit. Function Signature ```python def max_histogram_area(heights: List[int]) -> int: pass ``` Input - `heights`: A list of integers where each integer represents the height of a bar in the histogram. E.g., `[2, 1, 5, 6, 2, 3]` Output - An integer representing the maximum area of a rectangle in the histogram. Constraints - The number of bars in the histogram: (1 leq N leq 10^5) - All heights are non-negative integers. E.g., `[2, 1, 5, 6, 2, 3]` Example ```python heights = [2, 1, 5, 6, 2, 3] print(max_histogram_area(heights)) # Output: 10 heights = [2, 4] print(max_histogram_area(heights)) # Output: 4 ``` Notes - Consider using a stack to keep track of the indices of the bars. - The key idea is to find the maximum width for each bar where it is the shortest bar in the rectangle. - The total time complexity should aim to be (O(N)). This question assesses understanding of efficient stack usage and the ability to handle scenarios involving calculations over varying segments of an array with potential optimizations.","solution":"def max_histogram_area(heights): Given a list of integers representing the heights of bars in a histogram, returns the area of the largest rectangle that can be formed within the bounds of the histogram. stack = [] max_area = 0 index = 0 while index < len(heights): # If this bar is higher than the bar at stack top, push it to the stack if not stack or heights[stack[-1]] <= heights[index]: stack.append(index) index += 1 else: # Pop the top top_of_stack = stack.pop() # Calculate the area with heights[top_of_stack] stack as the smallest (or minimum height) bar \'h\' area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) # update max_area, if needed max_area = max(max_area, area) # Now, pop the remaining bars from stack and calculate area with every popped bar while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"# Subset Sum Difference: Minimize the Difference Between Two Subsets **Scenario**: You are given an array of integers and your task is to partition the array into two subsets such that the absolute difference between the sums of the two subsets is minimized. This problem is a common variant of the Partition Problem and related to dynamic programming and greedy algorithms. **Problem Statement**: Write a function `min_subset_difference(arr: list[int]) -> int` that partitions the array `arr` into two subsets and returns the minimum possible absolute difference between the sums of these subsets. **Input**: - An integer list `arr` where 1 <= len(arr) <= 100 and 1 <= arr[i] <= 2000. **Output**: - Returns a single integer representing the minimum possible absolute difference between the sums of the two subsets. **Constraints**: - The sum of integers in `arr` shall not exceed 20000. **Function Signature**: ```python def min_subset_difference(arr: list[int]) -> int: pass ``` **Example**: ```python print(min_subset_difference([1, 6, 11, 5])) # Output: 1 # Explanation: # One way to partition the array into two subsets is {1, 5, 6} and {11}. # Sum of first subset = 1 + 5 + 6 = 12 # Sum of second subset = 11 # Difference between the sums = |12 - 11| = 1 ``` **Notes**: - Use dynamic programming to solve this problem efficiently. - Consider summing up all elements and then aiming to reach the closest sum to `total_sum // 2` using a subset of the elements to achieve this minimization.","solution":"def min_subset_difference(arr): Returns the minimum possible absolute difference between the sums of two subsets. total_sum = sum(arr) n = len(arr) # Initialize a DP array to keep track of achievable sums up to total_sum//2 dp = [False] * (total_sum // 2 + 1) dp[0] = True # Process each number in the array for num in arr: for j in range(total_sum // 2, num - 1, -1): dp[j] = dp[j] or dp[j - num] # Find the closest achievable sum to total_sum // 2 for j in range(total_sum // 2, -1, -1): if dp[j]: return total_sum - 2 * j"},{"question":"# Shortest Path with Dijkstra\'s Algorithm Context As part of optimizing the logistics within a warehouse, you need to determine the shortest paths from a given starting point to all other locations within the warehouse. You decide to use Dijkstra\'s Algorithm to achieve this goal. Your task is to implement the function that constructs a graph from given vertices and edges, and then apply Dijkstra\'s Algorithm to find the shortest paths. Objectives 1. Write a function to build a graph using an adjacency list representation. 2. Implement Dijkstra\'s Algorithm to find the shortest paths from a starting vertex. Functions 1. **Graph Construction** ```python def build_graph(vertices, edges): Build a graph from given vertices and edges using an adjacency list representation. :param vertices: List of vertex identifiers :param edges: List of edges represented as tuples (vertex1, vertex2, weight) :return: Dictionary representing the adjacency list of the graph ``` 2. **Dijkstra\'s Shortest Path** ```python def dijkstra_shortest_path(graph, start_vertex): Apply Dijkstra\'s algorithm to find the shortest paths from a given starting vertex. :param graph: Dictionary representing the adjacency list of the graph :param start_vertex: The starting vertex for the shortest path calculations :return: Dictionary with vertices as keys and their shortest path distance from the start_vertex as values ``` Input - **Vertices**: A list of integers representing the vertex identifiers (e.g., [0, 1, 2, 3, 4]). - **Edges**: A list of tuples representing the edges with weights (e.g., [(0, 1, 4), (0, 2, 1), (2, 1, 2), (1, 3, 5), (2, 3, 8)]). - **Start Vertex**: An integer representing the starting vertex for the shortest path calculation. Output - A dictionary with vertices as keys and their shortest path distances from the start_vertex as values. - Print the step-by-step execution trace showing the current state of the shortest path calculations. Constraints * There will be no more than 1000 vertices and 10000 edges. * Weights are guaranteed to be positive integers. Example ```python vertices = [0, 1, 2, 3] edges = [(0, 1, 4), (0, 2, 1), (2, 1, 2), (1, 3, 5), (2, 3, 8)] graph = build_graph(vertices, edges) start_vertex = 0 shortest_paths = dijkstra_shortest_path(graph, start_vertex) print(shortest_paths) ``` Expected output: ``` Shortest paths from vertex 0: 0 -> 0: 0 0 -> 1: 3 0 -> 2: 1 0 -> 3: 8 ``` Note: The output format may vary, but it should accurately reflect the shortest paths from the start vertex to each other vertex in the graph.","solution":"import heapq def build_graph(vertices, edges): Build a graph from given vertices and edges using an adjacency list representation. :param vertices: List of vertex identifiers :param edges: List of edges represented as tuples (vertex1, vertex2, weight) :return: Dictionary representing the adjacency list of the graph graph = {vertex: {} for vertex in vertices} for v1, v2, weight in edges: graph[v1][v2] = weight graph[v2][v1] = weight # Assuming it\'s an undirected graph return graph def dijkstra_shortest_path(graph, start_vertex): Apply Dijkstra\'s algorithm to find the shortest paths from a given starting vertex. :param graph: Dictionary representing the adjacency list of the graph :param start_vertex: The starting vertex for the shortest path calculations :return: Dictionary with vertices as keys and their shortest path distance from the start_vertex as values distances = {vertex: float(\'infinity\') for vertex in graph} distances[start_vertex] = 0 priority_queue = [(0, start_vertex)] while priority_queue: current_distance, current_vertex = heapq.heappop(priority_queue) if current_distance > distances[current_vertex]: continue for neighbor, weight in graph[current_vertex].items(): distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return distances"},{"question":"# Coding Question Context Binary search is an efficient algorithm for finding an item from a sorted list of items. It works by repeatedly dividing in half the portion of the list that could contain the item, until you\'ve narrowed down the possible locations to just one. This question will focus on a modified version of binary search, where instead of finding if an element exists in the list, you need to find the smallest element greater than or equal to a given target value. Task You are required to implement the following function: * **find_ceiling(nums: List[int], target: int) -> int**: * Find the smallest element in the sorted list `nums` that is greater than or equal to the `target`. * If no such element exists, return -1. Input and Output Formats * `find_ceiling`: * Input: A sorted list of integers `nums` and an integer `target`. * Output: An integer representing the smallest element greater than or equal to `target`. If such element does not exist, return -1. Performance Requirements Ensure that your solution is efficient, with a time complexity of O(log n), where n is the length of the list. Constraints * The list `nums` will be sorted in non-decreasing order. * The elements of `nums` and `target` will be integers where -10^9 ≤ nums[i], target ≤ 10^9. * The length of `nums` will be between 1 and 10^5. Example ```python # Test cases assert find_ceiling([1, 3, 5, 6, 8, 10], 7) == 8 assert find_ceiling([1, 3, 5, 6, 8, 10], 10) == 10 assert find_ceiling([1, 3, 5, 6, 8, 10], 11) == -1 ``` Function Signature ```python from typing import List def find_ceiling(nums: List[int], target: int) -> int: # Your implementation here pass ```","solution":"from typing import List def find_ceiling(nums: List[int], target: int) -> int: Find the smallest element in the sorted list `nums` that is greater than or equal to the `target`. If no such element exists, return -1. left, right = 0, len(nums) - 1 result = -1 while left <= right: mid = (left + right) // 2 if nums[mid] >= target: result = nums[mid] right = mid - 1 else: left = mid + 1 return result"},{"question":"# Maze Pathfinding Algorithm You have been provided with a partial implementation of a Maze Pathfinding class. Your task is to complete the class by implementing the `find_path` method based on the provided analysis. Objective Complete the implementation of the `find_path` method in the `MazePathfinder` class to find a path from the top-left corner to the bottom-right corner of a 2D grid maze using Breadth-First Search (BFS). # Tasks 1. **find_path(maze)**: - Implements the Breadth-First Search (BFS) algorithm to traverse the maze. - Finds the shortest path from the start position (0, 0) to the goal position (N-1, M-1). - Handles cases where the maze has no valid path and returns an empty list in such scenarios. - Uses a queue to manage the BFS frontier and tracks visited cells to avoid revisiting. # Input/Output - **find_path method**: - **Input**: - `maze`: A 2D list (N x M) representing the maze grid with 0s as passable cells and 1s as impassable cells. - **Output**: A list of tuples representing the coordinates of the cells in the shortest path from the start to the goal. If no path exists, return an empty list. # Constraints - The maze grid is an N x M list where N and M are non-negative integers (1 ≤ N, M ≤ 100). - The input maze must have at least one cell (N, M ≥ 1). - You are guaranteed that the start (0, 0) and goal (N-1, M-1) positions are passable cells (i.e., they contain 0). - The BFS should terminate as soon as the goal is reached to ensure the shortest path. # Sample Usage ```python maze = [ [0, 1, 0, 0, 0], [0, 1, 0, 1, 0], [0, 0, 0, 1, 0], [0, 1, 1, 1, 0], [0, 0, 0, 0, 0] ] pathfinder = MazePathfinder() path = pathfinder.find_path(maze) print(path) # Expected output: [(0, 0), (1, 0), (2, 0), (2, 1), (2, 2), (3, 2), (4, 2), (4, 3), (4, 4)] ``` # Sample Implementation Framework ```python class MazePathfinder: def __init__(self): self.directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] def find_path(self, maze): from collections import deque if not maze or not maze[0]: return [] N, M = len(maze), len(maze[0]) start, goal = (0, 0), (N-1, M-1) if maze[start[0]][start[1]] != 0 or maze[goal[0]][goal[1]] != 0: return [] queue = deque([(start[0], start[1], [])]) visited = set((start[0], start[1])) while queue: x, y, path = queue.popleft() path = path + [(x, y)] if (x, y) == goal: return path for direction in self.directions: new_x, new_y = x + direction[0], y + direction[1] if 0 <= new_x < N and 0 <= new_y < M and maze[new_x][new_y] == 0 and (new_x, new_y) not in visited: queue.append((new_x, new_y, path)) visited.add((new_x, new_y)) return [] # Example usage maze = [ [0, 1, 0, 0, 0], [0, 1, 0, 1, 0], [0, 0, 0, 1, 0], [0, 1, 1, 1, 0], [0, 0, 0, 0, 0] ] pathfinder = MazePathfinder() path = pathfinder.find_path(maze) print(path) # Expected output: [(0, 0), (1, 0), (2, 0), (2, 1), (2, 2), (3, 2), (4, 2), (4, 3), (4, 4)] ``` Write your implementation of the `find_path` method below.","solution":"from collections import deque class MazePathfinder: def __init__(self): self.directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] def find_path(self, maze): if not maze or not maze[0]: return [] N, M = len(maze), len(maze[0]) start, goal = (0, 0), (N-1, M-1) if maze[start[0]][start[1]] != 0 or maze[goal[0]][goal[1]] != 0: return [] queue = deque([(start[0], start[1], [])]) visited = set((start[0], start[1])) while queue: x, y, path = queue.popleft() path = path + [(x, y)] if (x, y) == goal: return path for direction in self.directions: new_x, new_y = x + direction[0], y + direction[1] if 0 <= new_x < N and 0 <= new_y < M and maze[new_x][new_y] == 0 and (new_x, new_y) not in visited: queue.append((new_x, new_y, path)) visited.add((new_x, new_y)) return [] # Example usage maze = [ [0, 1, 0, 0, 0], [0, 1, 0, 1, 0], [0, 0, 0, 1, 0], [0, 1, 1, 1, 0], [0, 0, 0, 0, 0] ] pathfinder = MazePathfinder() path = pathfinder.find_path(maze) print(path) # Expected output: [(0, 0), (1, 0), (2, 0), (2, 1), (2, 2), (3, 2), (4, 2), (4, 3), (4, 4)]"},{"question":"# Coding Question You are to create a function to balance and prioritize tasks in a multi-threaded environment, ensuring that high-priority tasks are handled before low-priority tasks. The function should maintain an efficient task scheduling mechanism to achieve this goal. Your task is to implement the task scheduler with the following features: 1. **Task Queue Management**: Maintain a priority queue to manage incoming tasks based on their priority levels. 2. **Multi-Threaded Execution**: Efficiently handle the execution of tasks using multiple threads, ensuring high-priority tasks are executed before low-priority ones. 3. **Dynamic Task Addition**: Allow tasks to be dynamically added to the scheduler while it\'s running, maintaining the priority queue order. Your function should take the following parameters: - `tasks` (List[Tuple[int, Callable]]): A list of tasks where each task is represented by a tuple consisting of an integer priority and a callable function. - `num_threads` (int): The number of threads to use for executing tasks. Return: - No return value; the function should execute and complete all tasks. # Function Signature ```python from typing import List, Tuple, Callable import threading import queue def priority_task_scheduler( tasks: List[Tuple[int, Callable]], num_threads: int ) -> None: pass ``` # Requirements: 1. Maintain a priority queue to manage the scheduling of tasks based on their priority. 2. Use multiple threads to execute tasks, giving precedence to tasks with higher priority. 3. Support the dynamic addition of new tasks to the scheduler while it is running, ensuring that the priority is respected. # Example Usage ```python import time def task_a(): print(\\"Executing Task A\\") time.sleep(1) def task_b(): print(\\"Executing Task B\\") time.sleep(1) def task_c(): print(\\"Executing Task C\\") time.sleep(1) tasks = [ (1, task_a), (3, task_c), (2, task_b) ] priority_task_scheduler(tasks, 2) ``` In this example, tasks with higher priority numbers should be executed first. The scheduler should use 2 threads to execute the tasks concurrently while maintaining the priority order. This function should ensure that tasks are executed in the order of their priority, efficiently using the given number of threads.","solution":"from typing import List, Tuple, Callable import threading import queue def priority_task_scheduler( tasks: List[Tuple[int, Callable]], num_threads: int ) -> None: task_queue = queue.PriorityQueue() for priority, task in tasks: task_queue.put((-priority, task)) def worker(): while not task_queue.empty(): priority, task = task_queue.get() task() task_queue.task_done() threads = [] for _ in range(num_threads): thread = threading.Thread(target=worker) thread.start() threads.append(thread) for thread in threads: thread.join() def add_task(scheduler_queue, task, priority): scheduler_queue.put((-priority, task))"},{"question":"# Check if a Number is a Power of Three Problem Statement You are required to implement an algorithm that determines whether a given number is a power of three. The function should return `True` if the number is a power of three and `False` otherwise. Use a recursive approach for your solution. Function Signature ```python def is_power_of_three(n: int) -> bool: ``` Input - `n: int` - an integer, where `1 <= n <= 10^9`. Output - A boolean value `True` if the input number is a power of three, otherwise `False`. Example ```plaintext Input: 27 Output: True Input: 10 Output: False ``` Constraints - The function must be implemented using a recursive approach. Note 1. Your implementation should handle the given constraints efficiently. 2. Avoid using iterative loops and logarithmic functions directly; focus on using recursion to solve the problem.","solution":"def is_power_of_three(n: int) -> bool: if n < 1: return False if n == 1: return True if n % 3 != 0: return False return is_power_of_three(n // 3)"},{"question":"# Question: Implementing an Efficient String Compression Algorithm You are required to implement a string compression algorithm. This algorithm should compress the string such that consecutive duplicate characters are reduced to the character followed by the count of its repetitions. Write a function `compress_string(input_str: str) -> str` that compresses the string in the following manner: 1. Consecutive duplicate characters are replaced by the character followed by the number of repeats. 2. Single characters should remain as is without a trailing number. # Input * `input_str` (str): A string containing only alphanumeric characters. # Output * A compressed version of the input string. # Constraints * The length of the input string (`n`): 1 ≤ n ≤ 10^5. # Performance Requirements * The solution must complete in O(n) time complexity. * Space complexity should be O(n). # Example ```python input_str = \\"aaabbcaaa\\" print(compress_string(input_str)) # Expected Output: \\"a3b2ca3\\" input_str = \\"abcd\\" print(compress_string(input_str)) # Expected Output: \\"abcd\\" input_str = \\"aabbcc\\" print(compress_string(input_str)) # Expected Output: \\"a2b2c2\\" ``` Ensure to test your function with various cases, including strings with single characters, varying lengths, and different patterns of repetitions. The implementation should handle edge cases efficiently and produce the correct output for all valid inputs.","solution":"def compress_string(input_str: str) -> str: if not input_str: return \\"\\" compressed = [] count = 1 for i in range(1, len(input_str)): if input_str[i] == input_str[i - 1]: count += 1 else: compressed.append(input_str[i - 1]) if count > 1: compressed.append(str(count)) count = 1 compressed.append(input_str[-1]) if count > 1: compressed.append(str(count)) return \'\'.join(compressed)"},{"question":"# Coding Assessment Task Scenario A software development company is improving their codebase and you have been asked to implement a function that validates text based on specific patterns. This task helps ensure data consistency and compliance with formatting standards across various text inputs in their system. Question Write a function `validate_pattern(s: str) -> bool` that takes a string `s` and checks whether it conforms to a specific pattern. The pattern is defined as follows: 1. The string must start with one or more uppercase letters. 2. It should be followed by exactly one digit. 3. After the digit, it should have a sequence of lowercase letters (at least one). Input * A string `s` with a length of 1 to 100 characters. Output * A boolean `True` if the string matches the pattern, `False` otherwise. Constraints 1. The function should efficiently handle strings at the maximum length. 2. Edge cases, such as empty strings or lack of any part of the pattern, should be properly managed. Examples ```python assert validate_pattern(\\"A1a\\") == True assert validate_pattern(\\"ABC3xyz\\") == True assert validate_pattern(\\"Abc12def\\") == False assert validate_pattern(\\"A\\") == False assert validate_pattern(\\"1a\\") == False assert validate_pattern(\\"A1\\") == False ``` Requirements * Use regular expressions to implement the pattern matching. * The solution should be concise and optimized for performance. * Proper handling of edge cases and valid input inspection is required.","solution":"import re def validate_pattern(s: str) -> bool: Validates if the input string conforms to the pattern of: - One or more uppercase letters - Exactly one digit - One or more lowercase letters pattern = r\'^[A-Z]+[0-9][a-z]+\' return bool(re.match(pattern, s))"},{"question":"# Question: Minimum Number of Coins for Change You are given a list of integers `coins` representing the denominations of coins available in a currency system and an integer `amount` representing the total amount of money. Your task is to determine the fewest number of coins that you need to make up that amount. If the amount cannot be made up by any combination of the coins, return -1. Write a function `min_coins(coins: List[int], amount: int) -> int` to solve the problem. Function Signature ```python def min_coins(coins: List[int], amount: int) -> int: pass ``` Input - A list of integers `coins` (1 <= len(coins) <= 100): The denominations of coins available. - An integer `amount` (0 <= amount <= 10000): The total amount of money to be made up. Output - An integer, representing the fewest number of coins needed to make up the given amount. Return -1 if the amount cannot be made up from the given coins. Constraints - All elements of `coins` are positive integers. - `1 <= len(coins) <= 100` - `0 <= amount <= 10000` Example ```python assert min_coins([1, 2, 5], 11) == 3 # 11 = 5 + 5 + 1 assert min_coins([2], 3) == -1 # Cannot make up 3 with only denomination 2 assert min_coins([1, 2, 5], 0) == 0 # No coins are needed for amount 0 assert min_coins([1], 2) == 2 # 2 = 1 + 1 assert min_coins([2, 5, 10, 1], 27) == 4 # 27 = 10 + 10 + 5 + 2 ``` Notes - You may assume that the input list `coins` will always contain unique denomination values and will be non-empty. - Ensure that your function is optimized to handle the upper limits of the input constraints efficiently.","solution":"from typing import List def min_coins(coins: List[int], amount: int) -> int: Returns the fewest number of coins needed to make up the given amount. If the amount cannot be made up by any combination of the coins, return -1. # Initialize the array for DP with amount+1 (since amount 0 could be formed without any coins) dp = [float(\'inf\')] * (amount + 1) dp[0] = 0 # Process each amount from 1 to the given amount for a in range(1, amount + 1): for coin in coins: if a - coin >= 0: dp[a] = min(dp[a], dp[a - coin] + 1) # If dp[amount] is still infinity, return -1 (means amount cannot be formed by given coins) return dp[amount] if dp[amount] != float(\'inf\') else -1"},{"question":"# Coding Question Context You are familiar with Pascal\'s Triangle, a triangular array of the binomial coefficients. Each number is the sum of the two directly above it. Pascal\'s Triangle has many applications in binomial expansions, combinatorics, and probability theory. In this problem, we will explore a specific application of Pascal\'s Triangle. Given a row index, k, your task is to return the k-th row of Pascal\'s Triangle. Task Implement a function to generate the k-th row of Pascal\'s Triangle. 1. **get_pascals_triangle_row(k: int) -> List[int]**: * Generate the k-th row of Pascal\'s Triangle. Input and Output Formats * `get_pascals_triangle_row`: * Input: A single integer `k` (0 ≤ k ≤ 33). * Output: A list of integers representing the k-th row of Pascal\'s Triangle. Performance Requirements Ensure your solution works efficiently within the given constraints. Constraints * 0 ≤ k ≤ 33 Example ```python # Test cases assert get_pascals_triangle_row(0) == [1] assert get_pascals_triangle_row(1) == [1, 1] assert get_pascals_triangle_row(2) == [1, 2, 1] assert get_pascals_triangle_row(3) == [1, 3, 3, 1] assert get_pascals_triangle_row(4) == [1, 4, 6, 4, 1] ```","solution":"def get_pascals_triangle_row(k: int) -> list[int]: Generate the k-th row of Pascal\'s Triangle. :param k: The row index of Pascal\'s Triangle to generate. :return: A list representing the k-th row of Pascal\'s Triangle. if k == 0: return [1] row = [1] for i in range(1, k+1): prev = row[i-1] * (k - i + 1) // i row.append(prev) return row"},{"question":"# Movie Recommendations System with Collaborative Filtering Scenario: You are a software developer working on a movie streaming platform that provides personalized movie recommendations to users. The current task is to implement a collaborative filtering system using user ratings. Collaborative filtering involves building a model from user rating data that can predict users\' movie preferences based on the preferences of other users. Requirements: 1. **Data Structures**: Maintain user ratings in a dictionary format where keys are user IDs and values are dictionaries of movie ratings. 2. **Similarity Computation**: Implement a function to compute the similarity between two users using the Pearson correlation coefficient. 3. **Recommendation Generation**: Provide a function to generate movie recommendations for a specific user based on their similarity to other users. Input & Output: * **Function Signatures**: ```python from typing import Dict, List, Tuple class MovieRecommender: def __init__(self): # Initialize an empty user ratings dictionary pass def add_user_ratings(self, user_id: int, ratings: Dict[int, float]) -> None: # Add or update the ratings for a specific user pass def compute_similarity(self, user_id_1: int, user_id_2: int) -> float: # Compute and return the Pearson correlation coefficient between two users pass def recommend_movies(self, user_id: int, num_recommendations: int) -> List[Tuple[int, float]]: # Generate a list of recommended movies and their predicted ratings for the specified user pass ``` * **Constraints**: * Each rating is a float between 0.5 and 5.0 (inclusive). * `add_user_ratings` can be called multiple times for the same user to update their ratings. * Ensure your implementation handles cases where users have rated different sets of movies. * **Error Messages**: * Raise `ValueError` with message \\"User not found\\" if recommending movies for a non-existent user. * Raise `ValueError` with message \\"Insufficient data for similarity computation\\" if there is not enough data to compute similarity between users. Example: ```python # Example usage: recommender = MovieRecommender() # Add user ratings recommender.add_user_ratings(1, {101: 3.5, 102: 4.0, 103: 2.5}) recommender.add_user_ratings(2, {101: 4.0, 102: 4.5, 103: 3.0, 104: 5.0}) recommender.add_user_ratings(3, {101: 2.0, 103: 3.5, 105: 4.0}) # Compute similarity between users similarity_1_2 = recommender.compute_similarity(1, 2) similarity_1_3 = recommender.compute_similarity(1, 3) # Generate movie recommendations recommendations_for_user_1 = recommender.recommend_movies(1, 2) print(similarity_1_2) print(similarity_1_3) print(recommendations_for_user_1) ``` Implementation Details: Provide your implementation for the `MovieRecommender` class following the specifications and requirements provided.","solution":"from typing import Dict, List, Tuple import math class MovieRecommender: def __init__(self): self.user_ratings = {} def add_user_ratings(self, user_id: int, ratings: Dict[int, float]) -> None: if user_id not in self.user_ratings: self.user_ratings[user_id] = ratings else: self.user_ratings[user_id].update(ratings) def compute_similarity(self, user_id_1: int, user_id_2: int) -> float: if user_id_1 not in self.user_ratings or user_id_2 not in self.user_ratings: raise ValueError(\\"User not found\\") common_movies = set(self.user_ratings[user_id_1]) & set(self.user_ratings[user_id_2]) if len(common_movies) < 2: raise ValueError(\\"Insufficient data for similarity computation\\") ratings1 = [self.user_ratings[user_id_1][movie] for movie in common_movies] ratings2 = [self.user_ratings[user_id_2][movie] for movie in common_movies] mean1 = sum(ratings1) / len(ratings1) mean2 = sum(ratings2) / len(ratings2) numerator = sum((ratings1[i] - mean1) * (ratings2[i] - mean2) for i in range(len(ratings1))) denominator = math.sqrt(sum((ratings1[i] - mean1) ** 2 for i in range(len(ratings1)))) * math.sqrt(sum((ratings2[i] - mean2) ** 2 for i in range(len(ratings2)))) if denominator == 0: return 0.0 return numerator / denominator def recommend_movies(self, user_id: int, num_recommendations: int) -> List[Tuple[int, float]]: if user_id not in self.user_ratings: raise ValueError(\\"User not found\\") totals = {} similarity_sums = {} for other_user in self.user_ratings: if other_user == user_id: continue try: similarity = self.compute_similarity(user_id, other_user) except ValueError: continue for movie, rating in self.user_ratings[other_user].items(): if movie not in self.user_ratings[user_id] or self.user_ratings[user_id][movie] == 0: if movie not in totals: totals[movie] = 0 if movie not in similarity_sums: similarity_sums[movie] = 0 totals[movie] += rating * similarity similarity_sums[movie] += similarity rankings = [(total / similarity_sums[movie], movie) for movie, total in totals.items() if similarity_sums[movie] != 0] rankings.sort(reverse=True) return [(movie, rating) for rating, movie in rankings[:num_recommendations]]"},{"question":"# Problem Statement You are provided with an implementation of a queue. A queue is a data structure that supports First In, First Out (FIFO) operations, allowing you to add (`enqueue`) and remove (`dequeue`) elements from the queue. The current implementation includes basic queue operations such as `enqueue`, `dequeue`, `peek`, `is_empty`, `is_full`, `size`, and `__contains__`. # Task Your task is to implement an additional method called `reverse_queue` in the `Queue` class. This method should reverse the order of elements in the queue in place, without using any additional data structures or collections, beyond the temporary variables required for the operations. # Method Signature ```python def reverse_queue(self) -> None: Reverse the order of elements in the queue. >>> Q = Queue() >>> Q.enqueue(1) >>> Q.enqueue(2) >>> Q.enqueue(3) >>> Q.reverse_queue() >>> print(Q) [3, 2, 1] ``` # Constraints * The queue may contain up to `limit` elements. * The available methods of the `Queue` class (i.e., `enqueue`, `dequeue`, `size`, etc.) are the only allowed interactions with the queue. * You must not use any other data structures (such as lists, stacks, or another queue) for this task. # Expectations * The `reverse_queue` method should work for an empty queue without errors. * The queue order should be completely reversed after executing the `reverse_queue` method. * Ensure that no elements are lost or duplicated during the reversal process. * The efficiency of the reversal should be reasonable given the constraints. # Example ```python Q = Queue() Q.enqueue(1) Q.enqueue(2) Q.enqueue(3) Q.reverse_queue() assert str(Q) == \\"[3, 2, 1]\\" ``` Implement the `reverse_queue` method below: ```python def reverse_queue(self) -> None: # Your code goes here ```","solution":"class Queue: def __init__(self): self.queue = [] def enqueue(self, item): self.queue.append(item) def dequeue(self): if not self.is_empty(): return self.queue.pop(0) else: raise IndexError(\\"Dequeue from an empty queue\\") def peek(self): if not self.is_empty(): return self.queue[0] else: raise IndexError(\\"Peek from an empty queue\\") def is_empty(self): return len(self.queue) == 0 def is_full(self, limit): return len(self.queue) >= limit def size(self): return len(self.queue) def __contains__(self, item): return item in self.queue def __str__(self): return str(self.queue) def reverse_queue(self) -> None: if self.is_empty(): return item = self.dequeue() self.reverse_queue() self.enqueue(item) # Example usage: Q = Queue() Q.enqueue(1) Q.enqueue(2) Q.enqueue(3) print(\\"Original Queue: \\", Q) Q.reverse_queue() print(\\"Reversed Queue: \\", Q)"},{"question":"# Problem Statement: Given an array of integers, find the maximum possible sum of a non-empty subsequence that is strictly increasing. Implement a function, `max_sum_increasing_subsequence`, that achieves this. # Function Signature: ```python def max_sum_increasing_subsequence(arr: List[int]) -> int: ``` # Input: * An array of integers `arr` where 1 <= len(arr) <= 1000 and -10^6 <= arr[i] <= 10^6 for all elements `i`. # Output: * The maximum possible sum of a strictly increasing subsequence from the input array. # Example: ```python assert max_sum_increasing_subsequence([1, 101, 2, 3, 100, 4, 5]) == 106 assert max_sum_increasing_subsequence([3, 4, 5, 10]) == 22 assert max_sum_increasing_subsequence([10, 5, 4, 3]) == 10 assert max_sum_increasing_subsequence([-1, -2, -3, 4, 5, -10]) == 9 ``` # Constraints: * The function should efficiently handle the allowed input sizes. * Raise a TypeError if the input is not a list of integers. # Requirements: 1. Ensure the function is efficient given the arrays can be relatively large. 2. Handle edge cases such as negative numbers, arrays with all elements being the same, and arrays with strictly decreasing sequences. # Context: This function might be used in scenarios where analyzing trends within data is essential. For instance, stock price analysis might leverage this to find periods of maximum growth.","solution":"def max_sum_increasing_subsequence(arr): if not isinstance(arr, list) or not all(isinstance(i, int) for i in arr): raise TypeError(\\"Input must be a list of integers\\") n = len(arr) if n == 0: return 0 # Initialize the max_sum array with the values from arr max_sum = arr.copy() # Fill max_sum[] using the iterative method for i in range(1, n): for j in range(i): if arr[i] > arr[j] and max_sum[i] < max_sum[j] + arr[i]: max_sum[i] = max_sum[j] + arr[i] # Return the maximum value from max_sum[] return max(max_sum)"},{"question":"# Network Latency Simulation In this problem, you will design a module to simulate network latency over various nodes using a simplified model of a network path. You will implement a class `NetworkPath` that encapsulates the functionality to add nodes, represent the connections with latencies, and calculate the total latency for a given path. # Class and Methods Specification: Class: ```python class NetworkPath: def __init__(self): pass def add_node(self, node: str) -> None: pass def connect_nodes(self, node1: str, node2: str, latency: float) -> None: pass def calculate_latency(self, path: list) -> float: pass def validate_network(self, *nodes: str) -> None: pass ``` # Method Description: * `__init__(self)`: Initialize the `NetworkPath` instance with no initial nodes or connections. * `add_node(self, node: str) -> None`: Adds a new node to the network. Nodes should be unique and represented by strings. * `connect_nodes(self, node1: str, node2: str, latency: float) -> None`: Connects two existing nodes in the network with a given latency. Validates that both nodes exist in the network. * `calculate_latency(self, path: list) -> float`: Calculates the total latency for a given path, which is provided as a list of nodes. Validates that all nodes in the path are connected directly as specified by the `connect_nodes` method. * `validate_network(self, *nodes: str) -> None`: Validates that all specified nodes exist in the network and throws a `ValueError` if a node does not exist. # Constraints: - Latency values are measured in milliseconds and can be only positive numbers. - The nodes are represented by unique strings. - Inputs will always be well-formed strings for nodes and floating-point numbers for latencies. # Examples: ```python network_path = NetworkPath() # Adding nodes network_path.add_node(\\"A\\") network_path.add_node(\\"B\\") network_path.add_node(\\"C\\") # Connecting nodes with latencies network_path.connect_nodes(\\"A\\", \\"B\\", 10.5) network_path.connect_nodes(\\"B\\", \\"C\\", 5.2) # Example for calculating latency: latency = network_path.calculate_latency([\\"A\\", \\"B\\", \\"C\\"]) print(latency) # Output should be 15.7 # Validation of non-existing nodes try: network_path.calculate_latency([\\"A\\", \\"C\\"]) except ValueError as e: print(e) # Output should be a validation error message ``` Additional validation: 1. If the given path contains nodes that do not exist in the network or are not directly connected as per the given connections, throw a `ValueError` with a suitable message.","solution":"class NetworkPath: def __init__(self): self.nodes = set() self.connections = {} def add_node(self, node: str) -> None: if node in self.nodes: raise ValueError(f\\"Node {node} already exists.\\") self.nodes.add(node) self.connections[node] = {} def connect_nodes(self, node1: str, node2: str, latency: float) -> None: self.validate_network(node1, node2) if latency <= 0: raise ValueError(\\"Latency must be a positive number.\\") self.connections[node1][node2] = latency self.connections[node2][node1] = latency def calculate_latency(self, path: list) -> float: total_latency = 0.0 for i in range(len(path) - 1): node1 = path[i] node2 = path[i + 1] self.validate_network(node1, node2) if node2 not in self.connections[node1]: raise ValueError(f\\"No direct connection between {node1} and {node2}.\\") total_latency += self.connections[node1][node2] return total_latency def validate_network(self, *nodes: str) -> None: for node in nodes: if node not in self.nodes: raise ValueError(f\\"Node {node} does not exist.\\")"},{"question":"# Coding Assessment: Determine if Tree is Symmetric Context You are working as a software engineer developing a library for manipulating binary trees. One of the features of this library is to determine if a given binary tree is symmetric. A symmetric tree is one that is a mirror reflection of itself about its center. Task Write a function `is_symmetric` that checks if a given binary tree is symmetric around its center. Input - `root`: The root node of the binary tree. Each node has two children: `left` and `right`. Output - A boolean value `True` if the tree is symmetric, otherwise `False`. Constraints - The number of nodes in the tree is in the range `[1, 1000]`. - Each node\'s value is an integer in the range `[-1000, 1000]`. Example ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_symmetric(root: TreeNode) -> bool: # Your implementation here pass # Example Usage # Symmetric tree tree = TreeNode(1) tree.left = TreeNode(2) tree.right = TreeNode(2) tree.left.left = TreeNode(3) tree.left.right = TreeNode(4) tree.right.left = TreeNode(4) tree.right.right = TreeNode(3) print(is_symmetric(tree)) # Expected Output: True # Not symmetric tree tree2 = TreeNode(1) tree2.left = TreeNode(2) tree2.right = TreeNode(2) tree2.left.right = TreeNode(3) tree2.right.right = TreeNode(3) print(is_symmetric(tree2)) # Expected Output: False ``` In your solution: 1. Implement a helper function `is_mirror` that checks if two subtrees are mirror images of each other. 2. Use the helper function to recursively compare nodes from the left and right subtrees. 3. Ensure the base cases handle null nodes and leaf comparisons.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_mirror(left: TreeNode, right: TreeNode) -> bool: if not left and not right: return True if not left or not right: return False return (left.val == right.val) and is_mirror(left.left, right.right) and is_mirror(left.right, right.left) def is_symmetric(root: TreeNode) -> bool: if not root: return True return is_mirror(root.left, root.right)"},{"question":"# Scenario: You are developing a library for mathematical operations, and one of the features you need to implement is a function to determine if a number is a Harshad number (also known as a Niven number). A Harshad number is an integer that is divisible by the sum of its digits. Given the function definition below, implement the logic to determine if a number is a Harshad number. # Function Specification **Function name**: `is_harshad_number` **Input**: - `num` (int): A positive integer. **Output**: - (bool): `True` if the number is a Harshad number, `False` otherwise. **Constraints**: - `num` will always be a positive integer. - The function should handle values up to 10^9 efficiently. **Examples**: ```python >>> is_harshad_number(18) True >>> is_harshad_number(19) False >>> is_harshad_number(21) True >>> is_harshad_number(22) False ``` # Task: Complete the implementation of the `is_harshad_number` function to correctly identify whether a given integer is a Harshad number.","solution":"def is_harshad_number(num): Determines if a number is a Harshad (Niven) number. Parameters: - num (int): A positive integer. Returns: - bool: True if num is a Harshad number, False otherwise. # Calculate the sum of the digits of the number sum_of_digits = sum(int(digit) for digit in str(num)) # Check if the number is divisible by the sum of its digits return num % sum_of_digits == 0"},{"question":"# Question: CSV-based Student Grade Management System Context You are hired by a local school to develop a student grade management system. The school records student grade information in a CSV format. Your task is to implement functions that can read student names and grades from a CSV file, calculate average grades, and identify students whose average grade falls below a specified threshold. Task Implement a system to manage student grades using CSV files. The system should be capable of reading CSV files, calculating student average grades, and filtering students based on their average grades. Requirements 1. **calculate_averages(file_path: str) -> Dict[str, float]**: - Read the student grades from a CSV file specified by `file_path`. - Calculate the average grade for each student. - Return a dictionary with student names as keys and their average grades as values. 2. **identify_low_performers(file_path: str, threshold: float) -> List[str]**: - Use the `calculate_averages` function to get the average grades. - Identify students whose average grade is below the specified `threshold`. - Return a list of names of these low-performing students. Input Format - `calculate_averages`: a string containing the file path to the CSV file. - `identify_low_performers`: a string containing the file path to the CSV file and a float specifying the grade threshold. CSV Format - The CSV file will have the following structure: ``` Name,Grade1,Grade2,Grade3,...,GradeN Student1,85,90,78,...,88 Student2,70,75,80,...,65 ``` - The first row contains column headers. - Each subsequent row contains the name of a student followed by their grades. Output Format - `calculate_averages`: a dictionary mapping student names to their average grades. - `identify_low_performers`: a list of names of students whose average grade is below the threshold. Constraints - The input CSV file is non-empty and correctly formatted. - Grades are integers ranging from 0 to 100. Examples ```python # Example CSV Content Name,Grade1,Grade2,Grade3,Grade4 Alice,85,90,88,84 Bob,70,75,80,65 Charlie,95,92,90,94 Diana,60,58,62,61 # calculate_averages Examples >>> calculate_averages(\\"student_grades.csv\\") {\'Alice\': 86.75, \'Bob\': 72.5, \'Charlie\': 92.75, \'Diana\': 60.25} # identify_low_performers Examples >>> identify_low_performers(\\"student_grades.csv\\", 75) [\'Bob\', \'Diana\'] >>> identify_low_performers(\\"student_grades.csv\\", 90) [\'Alice\', \'Bob\', \'Diana\'] ``` Notes - Ensure to handle file reading exceptions appropriately. - Consider edge cases such as students with no grades (though not expected based on the constraints). - Use Python\'s built-in `csv` module for reading CSV files.","solution":"import csv from typing import Dict, List def calculate_averages(file_path: str) -> Dict[str, float]: Reads the student grades from a CSV file specified by file_path, calculates the average grade for each student, and returns a dictionary with student names as keys and their average grades as values. averages = {} with open(file_path, mode=\'r\', newline=\'\') as file: csv_reader = csv.reader(file) header = next(csv_reader) # Read the header for row in csv_reader: name = row[0] grades = list(map(int, row[1:])) average = sum(grades) / len(grades) averages[name] = average return averages def identify_low_performers(file_path: str, threshold: float) -> List[str]: Identifies students whose average grade is below a specified threshold. averages = calculate_averages(file_path) low_performers = [name for name, average in averages.items() if average < threshold] return low_performers"},{"question":"You are asked to create a function to evaluate the nth Fibonacci number in the Fibonacci sequence. The Fibonacci sequence is defined as follows: F(0) = 0, F(1) = 1, and F(n) = F(n-1) + F(n-2) for n > 1. Implement a function `fibonacci(n: int) -> int` that calculates the nth Fibonacci number using matrix exponentiation, which provides a more efficient solution compared to the simple recursive or iterative approaches. # Function Signature ```python def fibonacci(n: int) -> int: ``` # Input - `n`: A non-negative integer representing the position in the Fibonacci sequence. # Output - The nth Fibonacci number. # Constraints - `n` will be a non-negative integer within the range of 0 to 10^9. # Example ```python >>> fibonacci(0) 0 >>> fibonacci(1) 1 >>> fibonacci(10) 55 >>> fibonacci(50) 12586269025 ``` # Requirements - You must implement the matrix exponentiation method to compute the nth Fibonacci number. - The function should handle very large values of `n` efficiently within O(log(n)) time complexity. - Avoid using recursion to prevent stack overflow for large values of `n`.","solution":"def fibonacci(n: int) -> int: if n == 0: return 0 if n == 1: return 1 def matrix_multiply(A, B): return [ [A[0][0] * B[0][0] + A[0][1] * B[1][0], A[0][0] * B[0][1] + A[0][1] * B[1][1]], [A[1][0] * B[0][0] + A[1][1] * B[1][0], A[1][0] * B[0][1] + A[1][1] * B[1][1]], ] def matrix_power(matrix, power): if power == 1: return matrix if power % 2 == 0: half_power = matrix_power(matrix, power // 2) return matrix_multiply(half_power, half_power) else: return matrix_multiply(matrix, matrix_power(matrix, power - 1)) result_matrix = matrix_power([[1, 1], [1, 0]], n - 1) return result_matrix[0][0]"},{"question":"# Problem Statement You are working on a platform that allows users to track their daily water intake. To help users understand their drinking patterns over time, you need to implement a feature that identifies the longest streak of consecutive days where the user met or exceeded their daily water intake goal. You are given two lists: `days` and `intakes`. The `days` list contains the dates the user recorded their intake, and the `intakes` list contains the amount of water they drank on those days in liters. Both lists are of the same length and are sorted in ascending order by date. Implement a function that takes these two lists, as well as the daily water intake goal, and returns the longest streak of consecutive days where the user\'s intake met or exceeded the goal. # Function Details: **Function Name**: `longest_streak` **Input**: - `days`: A list of strings representing dates in \\"YYYY-MM-DD\\" format. - `intakes`: A list of floats representing the amount of water in liters the user drank on corresponding days. - `goal`: A float representing the daily water intake goal in liters. **Output**: - An integer representing the length of the longest streak of consecutive days where the user\'s intake met or exceeded the goal. **Constraints**: - The length of `days` and `intakes` will not exceed 10^5. - All dates in `days` are unique and sorted in ascending order. - The `days` and `intakes` lists have the same length. # Example: ```python def longest_streak(days: list, intakes: list, goal: float) -> int: # Your implementation here pass # Example Test Cases print(longest_streak([\\"2023-01-01\\", \\"2023-01-02\\", \\"2023-01-03\\"], [2.0, 1.5, 3.0], 2.0)) # Expected: 1 print(longest_streak([\\"2023-01-01\\", \\"2023-01-02\\", \\"2023-01-03\\", \\"2023-01-04\\"], [2.0, 2.0, 2.0, 2.0], 2.0)) # Expected: 4 print(longest_streak([\\"2023-01-01\\", \\"2023-01-03\\", \\"2023-01-04\\"], [2.0, 2.0, 1.0], 2.0)) # Expected: 1 print(longest_streak([\\"2023-01-01\\", \\"2023-01-02\\", \\"2023-01-03\\", \\"2023-01-04\\", \\"2023-01-05\\"], [1.0, 1.0, 2.0, 1.0, 2.5], 2.0)) # Expected: 1 print(longest_streak([], [], 2.0)) # Expected: 0 ``` # Notes: - The function should handle edge cases such as empty lists or when there are no days meeting the goal. - Ensure the implementation efficiently processes up to the maximum constraint.","solution":"from datetime import datetime, timedelta def longest_streak(days: list, intakes: list, goal: float) -> int: Returns the length of the longest streak of consecutive days where the user\'s intake met or exceeded the goal. if not days or not intakes or len(days) != len(intakes): return 0 longest = 0 current_streak = 0 prev_date = None for date_str, intake in zip(days, intakes): current_date = datetime.strptime(date_str, \'%Y-%m-%d\') if intake >= goal: if prev_date is None or current_date == prev_date + timedelta(days=1): current_streak += 1 else: current_streak = 1 else: current_streak = 0 longest = max(longest, current_streak) prev_date = current_date return longest"},{"question":"# Coding Assessment Question Problem Context: A string is considered \\"unique\\" if all the characters in the string are distinct. For example, the string \\"abcdefg\\" is unique, whereas the string \\"aabbcc\\" is not. Task: Write a function that checks if the characters in the given string are unique. Your function should return `True` if all characters in the string are unique, and `False` otherwise. Function Signature: ```python def are_characters_unique(s: str) -> bool: ``` Input: * A string (s) (0 ≤ |s| ≤ 10^6): The input string to be checked for uniqueness. Output: * A boolean: `True` if all characters in the string are unique, otherwise `False`. Constraints: * Your solution should be efficient and handle large strings within the given constraint. Example: ```python >>> are_characters_unique(\\"abcdefg\\") True >>> are_characters_unique(\\"aabbcc\\") False >>> are_characters_unique(\\"\\") True >>> are_characters_unique(\\"1234567890\\") True >>> are_characters_unique(\\"112233\\") False ``` Notes: * You may assume the input string contains only ASCII characters. * Consider the efficiency of your solution, particularly for large strings. * You should handle edge cases, such as an empty string, gracefully.","solution":"def are_characters_unique(s: str) -> bool: Checks if all characters in the string s are unique. Args: s (str): Input string to check for unique characters. Returns: bool: True if all characters are unique, False otherwise. # Using a set to keep track of characters seen so far seen_chars = set() for char in s: if char in seen_chars: return False seen_chars.add(char) return True"},{"question":"# Inventory Management System In this assessment, you will implement a class-based system in Python to manage inventory for a small store. Your class should allow for adding new products, updating stock levels, and calculating the total value of the inventory. Class Signature ```python class Inventory: def __init__(self): Initializes the inventory with an empty product list. def add_product(self, product_name: str, quantity: int, price_per_unit: float): Adds a new product to the inventory or updates the quantity and price if the product already exists. :param product_name: The name of the product. :param quantity: The quantity of the product. :param price_per_unit: The price per unit of the product. def update_stock(self, product_name: str, quantity: int): Updates the stock level for a given product. :param product_name: The name of the product. :param quantity: The quantity to update (can be positive or negative). def get_total_inventory_value(self) -> float: Calculates the total value of the inventory based on quantity and price per unit. :return: The total value of the inventory. ``` Instructions 1. **Initialization**: The inventory should be initialized with an empty list of products. 2. **Product Management**: Add and update products with proper attributes (name, quantity, price per unit). 3. **Stock Update**: Update stock quantity ensuring that the quantity does not drop below zero. 4. **Inventory Value**: Calculate the total value of the inventory by summing the value of all products (`quantity * price per unit`). Constraints - Product names are unique strings. - Quantities are non-negative integers. - Prices are positive floating-point numbers. - Handle cases where the product being updated does not exist in the inventory. Example ```python inventory = Inventory() inventory.add_product(\\"Apple\\", 50, 0.5) inventory.add_product(\\"Banana\\", 100, 0.2) inventory.update_stock(\\"Apple\\", -10) inventory.add_product(\\"Orange\\", 200, 0.3) total_value = inventory.get_total_inventory_value() ``` Expected Output: The total inventory value should be calculated correctly based on the current stock levels and prices. For the above example, the output would be `50*0.5 + 100*0.2 + 200*0.3 = 95.0`. Important Points - Ensure that your class handles invalid operations gracefully. - Keep the interface clean and intuitive for easy use and integration.","solution":"class Inventory: def __init__(self): Initializes the inventory with an empty product list. self.products = {} def add_product(self, product_name: str, quantity: int, price_per_unit: float): Adds a new product to the inventory or updates the quantity and price if the product already exists. :param product_name: The name of the product. :param quantity: The quantity of the product. :param price_per_unit: The price per unit of the product. if product_name in self.products: self.products[product_name][\'quantity\'] += quantity self.products[product_name][\'price_per_unit\'] = price_per_unit else: self.products[product_name] = {\'quantity\': quantity, \'price_per_unit\': price_per_unit} def update_stock(self, product_name: str, quantity: int): Updates the stock level for a given product. :param product_name: The name of the product. :param quantity: The quantity to update (can be positive or negative). if product_name in self.products: self.products[product_name][\'quantity\'] += quantity if self.products[product_name][\'quantity\'] < 0: self.products[product_name][\'quantity\'] = 0 else: raise ValueError(\\"The product does not exist in the inventory.\\") def get_total_inventory_value(self) -> float: Calculates the total value of the inventory based on quantity and price per unit. :return: The total value of the inventory. total_value = 0.0 for product in self.products.values(): total_value += product[\'quantity\'] * product[\'price_per_unit\'] return total_value"},{"question":"# Problem Statement: You are required to write a function that takes a list of integers and a target sum. The function should count the number of unique pairs in the list that add up to the target sum. **Function Signature**: ```python def count_pairs_with_sum(nums: list[int], target: int) -> int: pass ``` # Input: - A list of integers `nums` (0 <= len(nums) <= 10^4, -10^4 <= nums[i] <= 10^4). - An integer `target` (-10^4 <= target <= 10^4). # Output: - An integer representing the number of unique pairs that sum up to the target value. # Constraints: - A pair (a, b) is considered unique if there is no other pair (c, d) with the same a and b regardless of their order. - The function should aim for an efficient solution in terms of time complexity. # Example: ```python >>> count_pairs_with_sum([1, 2, 3, 4, 3], 6) 2 >>> count_pairs_with_sum([1, 1, 1, 1], 2) 1 >>> count_pairs_with_sum([0, -1, 2, -3, 1], -2) 1 ``` # Description: Write a function `count_pairs_with_sum` that takes in a list of integers and a target sum to find the number of unique pairs of integers in the list that add up to the target sum. To handle efficiency, consider using a set to keep track of the elements and their complements with respect to the target sum.","solution":"def count_pairs_with_sum(nums: list[int], target: int) -> int: This function returns the number of unique pairs in the list that sum up to the target. seen = set() pairs = set() for num in nums: complement = target - num if complement in seen: pairs.add((min(num, complement), max(num, complement))) seen.add(num) return len(pairs)"},{"question":"# Question: Compare Version Numbers You are developing a software update system and need to compare software version numbers to determine their order. Implement a function `compare_versions(version1: str, version2: str) -> int` that compares two version numbers `version1` and `version2`. Version numbers are formatted as strings consisting of digits and dots. For instance, \\"1.0.1\\", \\"2.0\\", or \\"1.0.0.1\\". Each version number contains one or more subversions separated by dots, where each subversion is a non-negative integer. Blank subversion numbers should be considered as zero. The function should perform lexicographically comparison: - Return `1` if `version1` > `version2`. - Return `-1` if `version1` < `version2`. - Return `0` if both version numbers are equal. Ensure that your function: - Handles versions with different lengths by considering missing subversion numbers as zero. - Compares numbers appropriately even if the strings end in different lengths with trailing zeros. **Input:** - `version1`: str - A string representing the first version number. - `version2`: str - A string representing the second version number. **Output:** - An integer denoting the result of the comparison: `1`, `-1`, or `0`. **Constraints:** - All parts of the version strings are non-negative integers and do not contain leading zeros. **Example:** ```python version1 = \\"1.0.1\\" version2 = \\"1.0.0.1\\" assert compare_versions(version1, version2) == 1 version1 = \\"2.1\\" version2 = \\"2.01\\" assert compare_versions(version1, version2) == 0 version1 = \\"3.5.4\\" version2 = \\"3.5\\" assert compare_versions(version1, version2) == 1 version1 = \\"1.2.3\\" version2 = \\"1.2.3.4\\" assert compare_versions(version1, version2) == -1 ``` **Please Note:** - Do not assume input strings are standardized to equal lengths; missing versions should be compared as zero. - The function should efficiently handle possible large version numbers.","solution":"def compare_versions(version1: str, version2: str) -> int: Compare two software version numbers. Args: version1: str - A string representing the first version number. version2: str - A string representing the second version number. Returns: int: 1 if version1 > version2, -1 if version1 < version2, 0 if both are equal. # Split the version strings by \'.\' v1_parts = list(map(int, version1.split(\'.\'))) v2_parts = list(map(int, version2.split(\'.\'))) # Pad the shorter list with zeros max_length = max(len(v1_parts), len(v2_parts)) v1_parts.extend([0] * (max_length - len(v1_parts))) v2_parts.extend([0] * (max_length - len(v2_parts))) # Compare each part for i in range(max_length): if v1_parts[i] > v2_parts[i]: return 1 if v1_parts[i] < v2_parts[i]: return -1 # If all parts are equal return 0"},{"question":"# Question: Valid Palindrome with Removal Context: Given a string, you need to determine whether you can make it a palindrome by removing at most one character. For example, \\"abca\\" can become a palindrome by removing either \'b\' or \'c\'. You need to design an algorithm to check if converting the string into a palindrome by removing one character is possible. Task: Implement a function `validPalindrome` that: 1. Takes a string `s` as input. 2. Returns `True` if it is possible to make the string a palindrome by removing at most one character, otherwise returns `False`. Input: - A string `s` containing lowercase letters (1 <= len(s) <= 1000). Output: - A boolean value indicating whether the string can be made a palindrome by removing at most one character. Constraints: - The string length does not exceed `1000` characters. - You should aim to solve this problem with O(n) time complexity. Example: ```python def validPalindrome(s: str) -> bool: # Your implementation # Example Usage: # s = \\"abca\\" # print(validPalindrome(s)) # Output: True # s = \\"abc\\" # print(validPalindrome(s)) # Output: False ``` Performance Requirement: Ensure that your solution efficiently handles strings up to the maximum length constraint of 1000 characters.","solution":"def validPalindrome(s: str) -> bool: def is_palindrome_range(i, j): return all(s[k] == s[j-k+i] for k in range(i, (i+j)//2 + 1)) left, right = 0, len(s) - 1 while left < right: if s[left] != s[right]: return is_palindrome_range(left+1, right) or is_palindrome_range(left, right-1) left += 1 right -= 1 return True"},{"question":"# Question: Implement a Simple Calculator Write a function `simple_calculator(expression: str) -> float` that takes a string representation of a mathematical expression and returns the evaluated result. The function should support basic arithmetic operations: addition, subtraction, multiplication, and division. Input - `expression`: A string containing a mathematical expression. The expression will have non-negative integer operands and the operators `+`, `-`, `*`, `/` with no spaces in between. Output - A float representing the evaluated result of the expression. Constraints - The input expression will have valid syntax. - Division by zero should raise a `ZeroDivisionError`. - The length of the expression will be between 1 and 50 characters. Error Handling - Raise `ZeroDivisionError` for any division by zero within the expression. Example ```python >>> simple_calculator(\\"3+2*2\\") 7.0 >>> simple_calculator(\\"10/2-3\\") 2.0 >>> simple_calculator(\\"8/3\\") 2.6666666666666665 >>> simple_calculator(\\"8/0\\") Traceback (most recent call last): ... ZeroDivisionError: division by zero ``` Notes - Ensure the function evaluates the expression respecting the operator precedence (i.e., multiplication and division before addition and subtraction). - Use appropriate methods to parse and evaluate the mathematical expression safely.","solution":"def simple_calculator(expression: str) -> float: Evaluates a mathematical expression string containing basic arithmetic operations and returns the result as a float. try: result = eval(expression) return float(result) except ZeroDivisionError: raise ZeroDivisionError(\\"division by zero\\") # To ensure safety and prevent potential security issues with eval, # we could extend this answer by implementing a proper parser."},{"question":"# Optimizing Vehicle Routes Background: In logistics and transportation, optimizing vehicle routes is essential to minimize travel time and fuel consumption. The Traveling Salesman Problem (TSP) is a classic optimization problem where a vehicle needs to visit a set of destinations exactly once and return to the starting point, minimizing the total travel distance. Task: Implement a Python function that uses a heuristic approach to approximate a solution to the Traveling Salesman Problem. The function should return the order in which the destinations should be visited to minimize the travel distance. Requirements: 1. **Function Signature**: ```python def tsp_heuristic(dist_matrix: List[List[int]]) -> List[int]: pass ``` 2. **Input**: * `dist_matrix` (List[List[int]]): A 2D list representing the distance matrix where `dist_matrix[i][j]` is the distance between destination `i` and destination `j`. 3. **Output**: * A list of integers representing the order in which the destinations should be visited to achieve an approximately minimal travel distance. Constraints: * The number of destinations (n) is between 1 and 20. * Distances between destinations are non-negative integers. Performance: * Ensure the function is efficient for the given constraints. Example: ```python dist_matrix = [ [0, 10, 15, 20], [10, 0, 35, 25], [15, 35, 0, 30], [20, 25, 30, 0] ] print(tsp_heuristic(dist_matrix)) ``` Output: ``` [0, 1, 3, 2, 0] ``` Edge Cases: * Handle cases with only one destination. * Handle cases with zero distances (i.e., `dist_matrix[i][i]` is always 0). --- This question aligns in terms of complexity, length, and topic with the given example question on sequence alignment, while introducing a new domain (optimization problems in logistics) that requires similar problem-solving skills.","solution":"from typing import List def tsp_heuristic(dist_matrix: List[List[int]]) -> List[int]: Approximates a solution to the Traveling Salesman Problem using the nearest neighbor heuristic and returns the order of visiting the destinations. n = len(dist_matrix) visited = [False] * n route = [] current_node = 0 route.append(current_node) visited[current_node] = True for _ in range(n - 1): nearest_neighbor = None min_distance = float(\'inf\') for neighbor in range(n): if not visited[neighbor] and dist_matrix[current_node][neighbor] < min_distance: min_distance = dist_matrix[current_node][neighbor] nearest_neighbor = neighbor current_node = nearest_neighbor route.append(current_node) visited[current_node] = True route.append(route[0]) # return to the starting point return route"},{"question":"# Graph Traversal Challenge In this task, you will work with an undirected graph represented as an adjacency list and perform a breadth-first search (BFS) traversal to find the shortest path between two nodes. Background: Graph traversal algorithms are crucial for solving various problems in computer science, including shortest path calculations, network analysis, and more. BFS is a fundamental algorithm used primarily for unweighted graphs to find the shortest path between nodes. Your objective is to implement a function that takes an adjacency list representation of an undirected graph, a starting node, and an ending node, and returns the shortest path (in terms of the number of edges) between the start and end nodes. If no path exists, the function should return `None`. # Function Signature ```python def shortest_path_bfs(graph: Dict[int, List[int]], start: int, end: int) -> List[int]: Find the shortest path in an undirected graph using BFS. graph (Dict[int, List[int]]): The adjacency list representing the graph. Nodes are represented by integers and edges are represented by lists of adjacent nodes. start (int): The starting node. end (int): The ending node. Returns: List[int]: The shortest path from start to end as a list of nodes. If no path exists, return None. ``` # Constraints 1. The graph is represented as a dictionary where keys are node identifiers (integers) and values are lists of adjacent nodes (integers). 2. The function should handle graphs with up to 10^5 nodes and 10^5 edges. 3. Start and end nodes are guaranteed to be valid nodes present in the graph. # Input & Output Formats * Input: An adjacency list representing the graph, a starting node, and an ending node. Example: `graph = {1: [2, 3], 2: [1, 4], 3: [1], 4: [2]}` `start = 1` `end = 4` * Output: A list of integers representing the shortest path from `start` to `end`. Example: `[1, 2, 4]` If no path exists, return `None`. # Example ```python # Example main function to demonstrate if __name__ == \\"__main__\\": graph = { 1: [2, 3], 2: [1, 4], 3: [1], 4: [2] } start, end = 1, 4 print(shortest_path_bfs(graph, start, end)) # Expected output: [1, 2, 4] ``` # Performance Requirements * The function should efficiently handle large graphs by ensuring BFS traversal has a time complexity of O(V + E), where `V` is the number of vertices and `E` is the number of edges. # Additional Notes * Implement helper functions if necessary to keep the code modular and readable. * Ensure that the solution includes sufficient error handling and edge-case considerations, such as when the start and end nodes are the same.","solution":"from collections import deque from typing import Dict, List def shortest_path_bfs(graph: Dict[int, List[int]], start: int, end: int) -> List[int]: Find the shortest path in an undirected graph using BFS. graph (Dict[int, List[int]]): The adjacency list representing the graph. Nodes are represented by integers and edges are represented by lists of adjacent nodes. start (int): The starting node. end (int): The ending node. Returns: List[int]: The shortest path from start to end as a list of nodes. If no path exists, return None. if start == end: return [start] visited = {start} queue = deque([(start, [start])]) while queue: current_node, path = queue.popleft() for neighbor in graph.get(current_node, []): if neighbor in visited: continue if neighbor == end: return path + [neighbor] visited.add(neighbor) queue.append((neighbor, path + [neighbor])) return None"},{"question":"Task You are given a list of transactions containing purchase information, including the item name, price, and quantity. Write a function to generate a receipt for these transactions. # Task 1. **generate_receipt(transactions: List[Dict[str, Union[str, float, int]]]) -> str** - Input: A list of dictionaries where each dictionary represents a transaction. Each transaction has the following keys: - `item`: A string representing the name of the item. - `price`: A float representing the price of a single item. - `quantity`: An integer representing the number of items purchased. - Output: A string containing the formatted receipt. - Constraints: - The input list can be empty, in which case the receipt should state \\"No items purchased.\\" - All float values should be formatted to 2 decimal places. # Example Usage ```python transactions = [ {\\"item\\": \\"apple\\", \\"price\\": 0.75, \\"quantity\\": 3}, {\\"item\\": \\"banana\\", \\"price\\": 0.50, \\"quantity\\": 5}, {\\"item\\": \\"orange\\", \\"price\\": 1.25, \\"quantity\\": 2} ] print(generate_receipt(transactions)) # Output: # Receipt: # apple x3 @ 0.75 = 2.25 # banana x5 @ 0.50 = 2.50 # orange x2 @ 1.25 = 2.50 # ----------------------------- # Total = 7.25 empty_transactions = [] print(generate_receipt(empty_transactions)) # Output: # No items purchased. ``` # Additional Requirements 1. **Edge Cases**: - Ensure the function handles an empty input list by returning a message saying \\"No items purchased.\\" - Ensure the function correctly handles entries where the quantity is zero or negative, excluding such entries from the receipt. 2. **Formatting**: - Ensure the receipt aligns correctly, with items aligned to the left and prices aligned to the right. - Ensure each transaction is on a new line, followed by a total line that sums up all the transactions. Implement the function `generate_receipt` according to the defined requirements.","solution":"def generate_receipt(transactions): Generates a formatted receipt for given transactions. Args: transactions (list): List of dictionaries, each representing a transaction. Returns: str: Formatted receipt. if not transactions: return \\"No items purchased.\\" lines = [\\"Receipt:\\"] total = 0.0 for t in transactions: item = t[\'item\'] price = float(t[\'price\']) quantity = int(t[\'quantity\']) if quantity <= 0: continue line_total = price * quantity lines.append(f\\"{item:<10} x{quantity} @ {price:.2f} = {line_total:.2f}\\") total += line_total if total == 0.0: return \\"No items purchased.\\" lines.append(\\"-\\" * 29) lines.append(f\\"Total = {total:.2f}\\") return \\"n\\".join(lines)"},{"question":"# Problem Statement You are given two strings, `source` and `target`, and need to determine if you can convert the string `source` to the string `target` by changing exactly one character. Implement the function `one_edit_away(source: str, target: str) -> bool` that performs this check. Input * `source` (str): the original string. * `target` (str): the target string to compare against the original string. Output * The function should return a boolean indicating whether the conversion is possible by changing exactly one character. Example ```python >>> one_edit_away(\\"cart\\", \\"mart\\") True >>> one_edit_away(\\"cat\\", \\"bat\\") True >>> one_edit_away(\\"cat\\", \\"cats\\") False >>> one_edit_away(\\"cat\\", \\"cut\\") True >>> one_edit_away(\\"cat\\", \\"dog\\") False ``` # Constraints * The input strings can contain any characters, including letters, digits, and special characters. * The length of both strings should be between 1 and 10^5 characters. * The function should strive to minimize its time complexity, ideally O(n), where n is the length of the strings. # Requirements * The function should handle edge cases where the strings differ in length, including when they are empty or contain only one character. * Utilize efficient string comparison techniques to ensure performance meets the constraints. * Ensure the solution is robust and handles unexpected inputs gracefully.","solution":"def one_edit_away(source: str, target: str) -> bool: Determine if the source string can be converted into the target string by changing exactly one character. # If the lengths of the strings are not equal, they cannot be one-edit away if len(source) != len(target): return False # Check if there is exactly one differing character differences = 0 for s, t in zip(source, target): if s != t: differences += 1 if differences > 1: return False return differences == 1"},{"question":"# Problem Statement You need to write a program that will help a gardener keep track of the watering schedule for their plants. Each plant needs to be watered at different intervals (e.g., every 3 days, every 5 days). Your task is to determine the next date each plant needs to be watered, based on the last watered date and the watering interval provided. # Requirements 1. Implement a function named `next_watering_date` that takes: * A dictionary `plants` where the keys are the plant names (strings) and values are tuples containing: - The last date the plant was watered (string in `YYYY-MM-DD` format). - The number of days between watering each plant (integer). 2. The `next_watering_date` function should: * Return a dictionary with the plant names as keys and the next watering date as values (strings in `YYYY-MM-DD` format). 3. If the input date format is incorrect or the interval is not a positive integer, raise an appropriate error. # Input Format ```python next_watering_date(plants: Dict[str, Tuple[str, int]]) -> Dict[str, str] ``` # Output Format * Returns a dictionary with plant names as keys and their next watering date as values. # Constraints * The date strings will be in the `YYYY-MM-DD` format. * The interval will always be a positive integer. # Example ```python plants = { \\"Rose\\": (\\"2023-05-20\\", 3), \\"Tulip\\": (\\"2023-06-15\\", 5), \\"Sunflower\\": (\\"2023-07-01\\", 7) } # Finding the next watering dates next_dates = next_watering_date(plants) print(next_dates) ``` *Expected Output*: ```python { \\"Rose\\": \\"2023-05-23\\", \\"Tulip\\": \\"2023-06-20\\", \\"Sunflower\\": \\"2023-07-08\\" } ``` # Notes * Use standard libraries for date manipulation to handle date calculations. * Ensure the program handles invalid date formats and raises informative error messages. * Assume the input will always have valid plant names and non-empty dictionaries.","solution":"from datetime import datetime, timedelta def next_watering_date(plants): Calculate the next watering date for each plant based on the last watering date and the interval. Args: plants (dict): A dictionary where keys are plant names and values are tuples containing the last watered date (str in \'YYYY-MM-DD\' format) and the interval (int, days between watering). Returns: dict: A dictionary with plant names as keys and the next watering dates (str) as values. Raises: ValueError: If the date format is incorrect or the interval is not a positive integer. next_dates = {} for plant_name, (last_watered_str, interval) in plants.items(): try: last_watered_date = datetime.strptime(last_watered_str, \\"%Y-%m-%d\\") except ValueError: raise ValueError(f\\"Incorrect date format for plant {plant_name}. Expected \'YYYY-MM-DD\'.\\") if not isinstance(interval, int) or interval <= 0: raise ValueError(f\\"Invalid interval for plant {plant_name}. Interval must be a positive integer.\\") next_watered_date = last_watered_date + timedelta(days=interval) next_dates[plant_name] = next_watered_date.strftime(\\"%Y-%m-%d\\") return next_dates"},{"question":"# Problem Statement You are given an unsorted array of integers and must find a pair of elements that sum up to a given target value. Your task is to implement a function that efficiently finds and returns one such pair if it exists. If no such pair exists, the function should return `None`. # Requirements 1. Implement the function to find a pair of numbers that add up to the target value. 2. Optimize the solution to run in linear time complexity. 3. Handle edge cases, including arrays with fewer than two elements. # Function Signature ```python def find_pair_with_sum(arr: list[int], target: int) -> tuple[int, int] | None: pass ``` # Expected Input and Output * **Input**: * A list of integers `arr` with length `n` (`0 <= n <= 10^6`), not necessarily sorted. * An integer `target` (`-10^9 <= target <= 10^9`). * **Output**: * A tuple `(x, y)` where `x` and `y` are two distinct numbers from `arr` such that `x + y == target`. * Return `None` if no such pair exists. # Constraints * The function should run in O(n) time complexity. * The solution must work efficiently for large input sizes. # Performance Requirements * The solution should use a single pass through the array and appropriate data structures to achieve the required time complexity. # Example Usage ```python assert find_pair_with_sum([2, 7, 11, 15], 9) == (2, 7) assert find_pair_with_sum([3, 2, 4], 6) == (2, 4) assert find_pair_with_sum([3, 3], 6) == (3, 3) assert find_pair_with_sum([1, 2, 3, 4], 10) == None ``` # Hints 1. Use a hash table to store the differences between the target and the array elements as you iterate through the array. 2. For each element, check if its complement (target - element) exists in the hash table. 3. Ensure that the elements in the returned pair are distinct.","solution":"def find_pair_with_sum(arr: list[int], target: int) -> tuple[int, int] | None: Finds and returns a pair of distinct numbers from the array that add up to the target value. If no such pair exists, returns None. seen = set() for num in arr: complement = target - num if complement in seen: return (complement, num) seen.add(num) return None"},{"question":"# Problem Description: You are required to write a function `first_non_repeating_char(s: str) -> str` that finds the first character in the string `s` that does not repeat anywhere in the string. If there is no such character, the function should return an empty string. # Input: * A single string `s` of length `0 <= len(s) <= 10^6`. # Output: * A single character that is the first non-repeating character in the string, or an empty string if no such character exists. # Constraints: * The input `s` can be any character or sequence of characters, including spaces and punctuation. * The function should be case sensitive. # Examples: ```python >>> first_non_repeating_char(\\"aabbccdeeff\\") \'d\' >>> first_non_repeating_char(\\"aA\\") \'a\' >>> first_non_repeating_char(\\"\\") \'\' >>> first_non_repeating_char(\\"abcabcabc\\") \'\' >>> first_non_repeating_char(\\"swiss\\") \'w\' >>> first_non_repeating_char(\\"xxyz\\") \'y\' ``` # Note: * The function should be case sensitive, meaning \'A\' and \'a\' are considered different characters. * Consider handling both typical and edge cases efficiently. # Guidelines: * Implement the function `first_non_repeating_char(s: str) -> str` that meets the above requirements. * Do not use any import statements other than the standard library functions that may be necessary.","solution":"def first_non_repeating_char(s: str) -> str: Finds the first character in the string `s` that does not repeat anywhere in the string. If there is no such character, returns an empty string. # Dictionary to count occurrences of each character char_count = {} # First pass to count all characters for char in s: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 # Second pass to find the first non-repeating character for char in s: if char_count[char] == 1: return char # If there\'s no non-repeating character return \\"\\""},{"question":"# Coding Assessment Question Context: You are developing an automated system to track customer purchases and compute loyalty points based on various promotions. The goal is to efficiently calculate the total loyalty points for each customer. Task: Write a Python function `calculate_loyalty_points(transactions: list[dict]) -> dict[str, int]` that takes a list of transactions and computes the total loyalty points earned by each customer. Implementation Steps: 1. Parse the input list of transactions where each transaction is a dictionary containing the keys `customer_id` (str), `amount` (float), and `promotion` (str). 2. Apply the promotion rules to calculate the points for each transaction: - \\"STANDARD\\": Earn 1 point for every whole unit of currency spent. - \\"DOUBLE\\": Earn 2 points for every whole unit of currency spent. - \\"HALF\\": Earn 0.5 points for every whole unit of currency spent. 3. Aggregate the points for each customer. 4. Return a dictionary mapping each customer ID to their total loyalty points (rounded down to the nearest integer). Input Format: - `transactions`: A list of dictionaries, where each dictionary represents a transaction and has the following structure: ```python { \\"customer_id\\": \\"customer1\\", \\"amount\\": 120.50, \\"promotion\\": \\"DOUBLE\\" } ``` Output Format: - Return a dictionary where the keys are customer IDs (strings) and the values are total loyalty points (integers) rounded down to the nearest integer. Constraints: - Each transaction dictionary will always have valid keys `customer_id`, `amount`, and `promotion`. - The `promotion` value will always be one of \\"STANDARD\\", \\"DOUBLE\\", or \\"HALF\\". - The list of transactions may contain up to 10,000 entries. Performance Requirements: - The solution should have a time complexity of O(m), where m is the number of transactions. - Ensure efficient aggregation and minimal usage of additional space. Example: Suppose the input list `transactions` is: ```python transactions = [ {\\"customer_id\\": \\"cust1\\", \\"amount\\": 123.45, \\"promotion\\": \\"STANDARD\\"}, {\\"customer_id\\": \\"cust2\\", \\"amount\\": 99.99, \\"promotion\\": \\"DOUBLE\\"}, {\\"customer_id\\": \\"cust1\\", \\"amount\\": 50.00, \\"promotion\\": \\"HALF\\"} ] ``` Calling `calculate_loyalty_points(transactions)` might yield: ```python { \\"cust1\\": 123, \\"cust2\\": 199 } ``` (Note: The actual points calculated might vary based on the amount and the promotion applied, but should be consistent with the described rules.) Note: - Ensure the points calculation logic adheres strictly to the promotion rules. - Handle edge cases such as zero amount transactions and appropriately apply the promotions.","solution":"def calculate_loyalty_points(transactions): Calculates the total loyalty points earned by each customer based on their transactions. Args: transactions (list of dict): A list of transactions, each containing customer_id (str), amount (float), and promotion (str). Returns: dict: A dictionary mapping customer_id to their total loyalty points. points_per_promotion = { \\"STANDARD\\": 1, \\"DOUBLE\\": 2, \\"HALF\\": 0.5 } customer_points = {} for transaction in transactions: customer_id = transaction[\\"customer_id\\"] amount = transaction[\\"amount\\"] promotion = transaction[\\"promotion\\"] points_multiplier = points_per_promotion[promotion] # Calculate points for this transaction (rounded down to the nearest integer) points = int(amount * points_multiplier) # Aggregate points for each customer if customer_id in customer_points: customer_points[customer_id] += points else: customer_points[customer_id] = points return customer_points"},{"question":"# Problem Statement You are required to develop a function that validates and formats a given United States Social Security Number (SSN). The function should accommodate different input formats and output a standardized format. A valid SSN follows the format \\"XXX-XX-XXXX\\" where each \\"X\\" is a digit. # Function Signature ```python def format_ssn(ssn: str) -> str: pass ``` # Input - **ssn** (str): The input string representing the SSN, which might contain various non-digit characters or improperly arranged digits. # Output - **result** (str): The properly formatted SSN as a string in the \\"XXX-XX-XXXX\\" format. # Constraints 1. The function should raise a `ValueError` if the input is not a valid SSN. 2. Spaces, dashes, and other non-digit characters should be ignored when reading the SSN. 3. The final output should always be in the \\"XXX-XX-XXXX\\" format, maintaining the leading zeroes if present in the original SSN. # Examples ```python >>> format_ssn(\\"123-45-6789\\") \'123-45-6789\' >>> format_ssn(\\"123 45 6789\\") \'123-45-6789\' >>> format_ssn(\\"123.45.6789\\") \'123-45-6789\' >>> format_ssn(\\"123-4a-567-89\\") \'123-45-6789\' >>> format_ssn(\\"12-345678\\") Traceback (most recent call last): ... ValueError: Invalid SSN >>> format_ssn(\\"abcdefghijk\\") Traceback (most recent call last): ... ValueError: Invalid SSN ``` # Implementation Notes To implement the function, take the following steps: 1. Strip all non-digit characters from the input string. 2. Verify that the resulting string contains exactly 9 digits. 3. Format the verified digits into the \\"XXX-XX-XXXX\\" format. 4. Raise a `ValueError` if the initial input is not a valid SSN according to the aforementioned rules. Ensure that the function handles cases with various types of extraneous characters and spaces, while still validating the length and structure of the resulting SSN.","solution":"def format_ssn(ssn: str) -> str: Validates and formats a given United States Social Security Number (SSN). Args: ssn (str): The input string representing the SSN, which might contain various non-digit characters or improperly arranged digits. Returns: str: The properly formatted SSN as a string in the \\"XXX-XX-XXXX\\" format. Raises: ValueError: If the input is not a valid SSN. # Extract digits from the input string digits = \'\'.join(filter(str.isdigit, ssn)) # Check if the extracted digits form a valid SSN if len(digits) != 9: raise ValueError(\\"Invalid SSN\\") # Format the valid SSN formatted_ssn = f\\"{digits[:3]}-{digits[3:5]}-{digits[5:]}\\" return formatted_ssn"},{"question":"# Problem Statement You are asked to implement a `SparseMatrix` class which effectively manages a 2D matrix with a majority of zero values. Your task will include creating methods for setting and getting values in the matrix, as well as methods for adding and multiplying two sparse matrices. # Requirements Sparse Matrix Data Storage - Utilize an efficient storage mechanism, such as a dictionary, to store non-zero values along with their coordinates. Methods to Implement 1. `set_value(self, row: int, col: int, value: int) -> None`: - Sets the element at the specified row and column to the given value. If the value is zero, the element should be removed from the storage. 2. `get_value(self, row: int, col: int) -> int`: - Returns the value at the specified row and column. If the element is not explicitly stored, it should return zero. 3. `add(self, other: \'SparseMatrix\') -> \'SparseMatrix\'`: - Adds the current sparse matrix with another sparse matrix and returns a new `SparseMatrix` instance containing the result. 4. `multiply(self, other: \'SparseMatrix\') -> \'SparseMatrix\'`: - Multiplies the current sparse matrix with another sparse matrix and returns a new `SparseMatrix` instance containing the result. # Constraints - The dimensions of the matrices in add and multiply operations will always be valid. - Rows and columns are zero-indexed. - The matrices can have large dimensions, but most of the elements are zero. # Example Usage ```python matrix1 = SparseMatrix() matrix1.set_value(0, 1, 5) matrix1.set_value(1, 2, 3) matrix2 = SparseMatrix() matrix2.set_value(0, 1, 2) matrix2.set_value(1, 2, 7) matrix2.set_value(2, 0, 4) # Adding two matrices sum_matrix = matrix1.add(matrix2) assert sum_matrix.get_value(0, 1) == 7 # 5 + 2 assert sum_matrix.get_value(1, 2) == 10 # 3 + 7 assert sum_matrix.get_value(2, 0) == 4 # 0 + 4 # Multiplying two matrices product_matrix = matrix1.multiply(matrix2) assert product_matrix.get_value(0, 2) == 35 # 5*7 assert product_matrix.get_value(1, 0) == 0 # No non-zero values present assert product_matrix.get_value(1, 2) == 0 # No non-zero values present # Adding a few more checks to confirm the multiplication results assert product_matrix.get_value(0, 0) == 0 # No non-zero values present assert product_matrix.get_value(1, 1) == 0 # No non-zero values present print(f\\"Sum matrix at (0, 1): {sum_matrix.get_value(0, 1)}\\") print(f\\"Product matrix at (0, 2): {product_matrix.get_value(0, 2)}\\") ``` # Notes - Ensure your `SparseMatrix` class is efficient in terms of both time and space complexity. - Think carefully about how you will store and manage the non-zero values. - Write adequate tests to thoroughly validate the functionality of your methods. Implement the required methods in the `SparseMatrix` class to meet the above requirements.","solution":"class SparseMatrix: def __init__(self): self.values = {} def set_value(self, row: int, col: int, value: int) -> None: if value != 0: self.values[(row, col)] = value elif (row, col) in self.values: del self.values[(row, col)] def get_value(self, row: int, col: int) -> int: return self.values.get((row, col), 0) def add(self, other: \'SparseMatrix\') -> \'SparseMatrix\': result = SparseMatrix() result.values = self.values.copy() for (row, col), value in other.values.items(): result.set_value(row, col, result.get_value(row, col) + value) return result def multiply(self, other: \'SparseMatrix\') -> \'SparseMatrix\': result = SparseMatrix() for (row1, col1), value1 in self.values.items(): for (row2, col2), value2 in other.values.items(): if col1 == row2: result.set_value(row1, col2, result.get_value(row1, col2) + value1 * value2) return result"},{"question":"# Coding Assessment Question: Determine if a String Has All Unique Characters **Background**: One of the common problems in string manipulation is determining whether a string contains all unique characters. This can help ensure the validity of passwords or identifiers in various applications. **Function Description**: Write a function `has_unique_characters(s: str) -> bool` that checks if a given string `s` has all unique characters. The function should return `True` if all characters are unique and `False` otherwise. Input: * `s`: a string consisting of printable ASCII characters. Output: * A boolean value indicating whether the string has all unique characters. Constraints: * The function should not use any additional data structures (i.e., follow O(1) space complexity) beyond minimal variables. * Consider both uppercase and lowercase letters as distinct characters (i.e., \'A\' is different from \'a\'). Example: ```python assert has_unique_characters(\\"abcdefgh\\") == True assert has_unique_characters(\\"hello\\") == False assert has_unique_characters(\\"1234567890\\") == True assert has_unique_characters(\\"AaBbCc\\") == True assert has_unique_characters(\\"Python Programming\\") == False assert has_unique_characters(\\"\\") == True ``` Additional Context: 1. A valid username in a system may require that all characters are unique to prevent duplication errors. 2. Passwords with all unique characters can generally be more secure, ensuring a wider range of characters used. Create an efficient, concise implementation that checks character uniqueness without utilizing any additional collections like sets or lists.","solution":"def has_unique_characters(s: str) -> bool: Determines if a given string s has all unique characters. if len(s) > 128: # There are only 128 unique ASCII characters. return False checker = 0 for char in s: val = ord(char) # Get ASCII value of the char if (checker & (1 << val)) > 0: return False # Bitwise AND of checker and (1 << val) is not zero if bit was already set checker |= (1 << val) # Set the bit corresponding to this character in checker return True"},{"question":"# Question: Construct Subsets Without Conflicts You are given a list of tasks, each with a start and end time. Your goal is to construct the maximum set of non-overlapping tasks. This problem is also known as the interval scheduling maximization problem. # Objective: Write a function `max_non_overlapping_tasks(tasks)` that takes a list of tasks, where each task is represented as a tuple of `(start_time, end_time)`, and returns the maximum number of non-overlapping tasks that can be scheduled. # Input: * `tasks`: List of tuples of integers where each tuple represents a task\'s start and end time, e.g., `[(1, 3), (2, 5), (4, 6)]` # Output: * The function should return an integer representing the maximum number of non-overlapping tasks. # Constraints: * The size of `tasks` will be between `0` and `10^5`. * Each `start_time` and `end_time` in the tasks will be between `0` and `10^9`. * A task is defined as non-overlapping if it starts after the previous task ends. # Performance Requirements: * The time complexity should be O(n log n). * The space complexity should be O(n). # Example: ```python def max_non_overlapping_tasks(tasks): pass # Example usage tasks = [(1, 3), (2, 5), (4, 6), (7, 8)] print(max_non_overlapping_tasks(tasks)) # Output: 3 ``` # Solution Requirements: 1. Sort the tasks based on their end times. 2. Traverse through the sorted tasks and select tasks that do not conflict with the currently selected tasks. 3. Implement helper functions as needed to maintain clarity and modularity. 4. Ensure the code handles edge cases such as tasks list being empty. # Additional Context (Optional): The interval scheduling maximization problem is a classic example of a greedy algorithm application. This problem can be encountered in various real-world scheduling tasks such as booking rooms, job scheduling, and resource allocation.","solution":"def max_non_overlapping_tasks(tasks): Returns the maximum number of non-overlapping tasks that can be scheduled. Args: tasks (list): A list of tuples where each tuple represents a task\'s start and end time (start_time, end_time). Returns: int: Maximum number of non-overlapping tasks. # Sort tasks by their ending times tasks.sort(key=lambda x: x[1]) # Initialize variables max_tasks = 0 last_end_time = 0 # Iterate over sorted tasks for start, end in tasks: if start >= last_end_time: # If the current task starts after or when the last selected task ended, choose it max_tasks += 1 last_end_time = end # Update the last end time to the current task\'s end time return max_tasks"},{"question":"# Problem Statement Write a function `generate_prime_factors` that returns a list of all distinct prime factors of a given positive integer `n`. The prime factors of a number are the prime numbers that divide the number exactly, without leaving a remainder, other than 1 and the number itself. # Function Signature ```python def generate_prime_factors(n: int) -> List[int]: ``` # Input * **n**: A positive integer (1 ≤ n ≤ 1,000,000). # Output * Returns a list of integers representing distinct prime factors of `n`, in ascending order. # Constraints * The input `n` is guaranteed to be a positive integer. * The output list should not contain any duplicate prime factors. # Examples 1. `generate_prime_factors(1)` returns `[]` 2. `generate_prime_factors(2)` returns `[2]` 3. `generate_prime_factors(3)` returns `[3]` 4. `generate_prime_factors(4)` returns `[2]` 5. `generate_prime_factors(28)` returns `[2, 7]` 6. `generate_prime_factors(100)` returns `[2, 5]` 7. `generate_prime_factors(97)` returns `[97]` # Notes * You may utilize basic mathematical operations and loops. * Ensure the function handles large input values efficiently within the given constraints. * The function should consider edge cases such as when `n` is itself a prime number, or when `n` is 1, which has no prime factors.","solution":"from typing import List def generate_prime_factors(n: int) -> List[int]: Returns a list of all distinct prime factors of a given positive integer n. if n < 2: # No prime factors for numbers less than 2 return [] prime_factors = [] # Handling smallest prime factor, which is 2 if n % 2 == 0: prime_factors.append(2) while n % 2 == 0: n //= 2 # Handling odd prime factors for i in range(3, int(n**0.5) + 1, 2): if n % i == 0: prime_factors.append(i) while n % i == 0: n //= i # If n is still greater than 2, then n must be a prime number if n > 2: prime_factors.append(n) return prime_factors"},{"question":"# Coding Challenge: Maximum Subarray Sum Algorithm Scenario You work for a financial services firm where you need to analyze sequences of daily stock prices to identify the most profitable buy-and-sell opportunities. To do this, you need an efficient way to find the contiguous subarray within a one-dimensional array of stock price changes which has the largest sum. Task Write a function `max_subarray_sum(prices_changes)` that efficiently finds and returns the maximum possible sum of a contiguous subarray in a given list of price changes. Expected Function Signature ```python def max_subarray_sum(prices_changes: List[int]) -> int: prices_changes: A list of integers representing daily changes in stock prices ``` Input - A list of integers `prices_changes` where each integer represents the change in stock price on a given day. The list will have at least one element and up to 10^5 elements. Output - An integer representing the maximum sum of a contiguous subarray. Constraints - Aim for an efficient algorithm, ideally with a time complexity of O(n). Example ```python # Example list of daily stock price changes prices_changes = [-2, 1, -3, 4, -1, 2, 1, -5, 4] # The maximum sum of a contiguous subarray is 6, which is achieved by the subarray [4, -1, 2, 1] max_sum = max_subarray_sum(prices_changes) print(max_sum) # Output should be 6 ``` Additional Information - Consider using Kadane’s algorithm to solve this problem effectively. - Handle edge cases such as all negative numbers, where picking the least negative number might be the best option.","solution":"def max_subarray_sum(prices_changes): Finds the maximum sum of a contiguous subarray within a list of price changes. :param prices_changes: List of integers representing daily changes in stock prices :return: Maximum possible sum of a contiguous subarray # Initialize current and global maximums current_max = prices_changes[0] global_max = prices_changes[0] for price in prices_changes[1:]: current_max = max(price, current_max + price) if current_max > global_max: global_max = current_max return global_max"},{"question":"# Question You are tasked with implementing a queue data structure for a ticketing system using two stacks. The queue should support the following operations efficiently. 1. `enqueue(x)`: Enqueue element `x` to the back of the queue. 2. `dequeue()`: Dequeue the element from the front of the queue and return it. If the queue is empty, return `None`. 3. `peek()`: Get the front element without dequeuing it. If the queue is empty, return `None`. 4. `is_empty()`: Return `True` if the queue is empty, otherwise `False`. # Constraints - Do not use any built-in queue or deque data structures. - The queue size can be dynamic and you should handle different data types. - Ensure that the operations are efficient, leveraging the stack properties effectively. # Function Specifications Class: `QueueUsingStacks` - **Method**: `enqueue(self, x: Any) -> None` - **Description**: Add element `x` to the back of the queue. - **Input**: `x` (element to be enqueued, can be of any data type) - **Output**: None - **Method**: `dequeue(self) -> Any` - **Description**: Remove the element from the front of the queue and return it. - **Output**: The dequeued element. If the queue is empty, return `None`. - **Method**: `peek(self) -> Any` - **Description**: Return the element at the front of the queue without removing it. - **Output**: The front element. If the queue is empty, return `None`. - **Method**: `is_empty(self) -> bool` - **Description**: Check if the queue is empty. - **Output**: `True` if the queue is empty, otherwise `False`. # Example ```python class QueueUsingStacks: def __init__(self) -> None: self.stack1 = [] self.stack2 = [] def enqueue(self, x: Any) -> None: self.stack1.append(x) def dequeue(self) -> Any: if self.is_empty(): return None if not self.stack2: while self.stack1: self.stack2.append(self.stack1.pop()) return self.stack2.pop() def peek(self) -> Any: if self.is_empty(): return None if not self.stack2: while self.stack1: self.stack2.append(self.stack1.pop()) return self.stack2[-1] def is_empty(self) -> bool: return not self.stack1 and not self.stack2 # Test Cases # Create a new queue queue = QueueUsingStacks() # Test enqueue queue.enqueue(1) queue.enqueue(2) queue.enqueue(3) # Test peek print(queue.peek()) # Output: 1 # Test dequeue print(queue.dequeue()) # Output: 1 print(queue.dequeue()) # Output: 2 # Test is_empty print(queue.is_empty()) # Output: False # Test dequeue and is_empty print(queue.dequeue()) # Output: 3 print(queue.is_empty()) # Output: True print(queue.dequeue()) # Output: None ``` This question asks you to implement a queue using two stacks. The operations on the queue should be efficiently managed using the stack operations. Test cases should verify the basic functionality of enqueue, dequeue, peek, and is_empty methods.","solution":"class QueueUsingStacks: def __init__(self): self.stack1 = [] self.stack2 = [] def enqueue(self, x): Add element x to the back of the queue. :param x: Element to be enqueued, can be of any data type. self.stack1.append(x) def dequeue(self): Remove the element from the front of the queue and return it. If the queue is empty, return None. :return: The dequeued element, or None if the queue is empty. if self.is_empty(): return None if not self.stack2: while self.stack1: self.stack2.append(self.stack1.pop()) return self.stack2.pop() def peek(self): Return the element at the front of the queue without removing it. If the queue is empty, return None. :return: The front element, or None if the queue is empty. if self.is_empty(): return None if not self.stack2: while self.stack1: self.stack2.append(self.stack1.pop()) return self.stack2[-1] def is_empty(self): Check if the queue is empty. :return: True if the queue is empty, otherwise False. return not self.stack1 and not self.stack2"},{"question":"# Question **Question**: Implement an **LRU Cache** (Least Recently Used Cache) to manage a fixed-size cache of integer items. # Context You are developing a caching mechanism to optimize data retrieval times in a software system. The goal is to maintain a fixed-size cache and evict the least recently used items when the cache reaches its capacity. # Task - Write a class `LRUCache` that simulates the behavior of an LRU cache. The class should provide the following methods: - `__init__(self, capacity: int)`: Initializes the cache with a fixed capacity. - `get(self, key: int) -> int`: Retrieves the value associated with the given key if it exists in the cache. Returns -1 if the key is not found. - `put(self, key: int, value: int) -> None`: Adds a key-value pair to the cache. If the cache exceeds its capacity, evict the least recently used item. # Requirements - **Input**: The capacity of the cache as an integer `capacity` and key-value pairs for the `get` and `put` methods. - **Output**: The `get` method should return the value associated with the key or -1 if the key is not found. The `put` method does not return anything. - **Constraints**: - The `get` and `put` methods must operate with a time complexity of ( O(1) ). - Use a combination of a dictionary and a doubly linked list to achieve the required performance. # Example ```python # Sample usage cache = LRUCache(2) cache.put(1, 1) # Cache is {1=1} cache.put(2, 2) # Cache is {1=1, 2=2} assert cache.get(1) == 1 # Returns 1 cache.put(3, 3) # Evicts key 2, Cache is {1=1, 3=3} assert cache.get(2) == -1 # Returns -1 (not found) cache.put(4, 4) # Evicts key 1, Cache is {4=4, 3=3} assert cache.get(1) == -1 # Returns -1 (not found) assert cache.get(3) == 3 # Returns 3 assert cache.get(4) == 4 # Returns 4 ``` ```python class LRUCache: def __init__(self, capacity: int): self.capacity = capacity self.cache = {} self.order = [] def get(self, key: int) -> int: if key in self.cache: self.order.remove(key) self.order.append(key) return self.cache[key] return -1 def put(self, key: int, value: int) -> None: if key in self.cache: self.order.remove(key) elif len(self.cache) == self.capacity: oldest = self.order.pop(0) del self.cache[oldest] self.cache[key] = value self.order.append(key) ``` Write the `LRUCache` class to meet the above requirements and ensure it passes the example usage provided.","solution":"class Node: def __init__(self, key:int, value:int): self.key = key self.value = value self.prev = None self.next = None class LRUCache: def __init__(self, capacity: int): self.capacity = capacity self.cache = {} self.head, self.tail = Node(0, 0), Node(0, 0) self.head.next, self.tail.prev = self.tail, self.head def _add(self, node: Node) -> None: p = self.tail.prev p.next = node self.tail.prev = node node.prev = p node.next = self.tail def _remove(self, node: Node) -> None: p = node.prev n = node.next p.next = n n.prev = p def get(self, key: int) -> int: if key in self.cache: node = self.cache[key] self._remove(node) self._add(node) return node.value return -1 def put(self, key: int, value: int) -> None: if key in self.cache: self._remove(self.cache[key]) elif len(self.cache) >= self.capacity: lru = self.head.next self._remove(lru) del self.cache[lru.key] node = Node(key, value) self._add(node) self.cache[key] = node"},{"question":"# Problem You need to develop a function that simulates the generation and spread of forest fires on a 2D grid. Your goal is to model the burning process in which trees ignite and cause nearby trees to also catch fire. # Function Signature ```python def forest_fire_simulation( width: int, height: int, tree_density: float, initial_burn_prob: float, spread_prob: float, max_iterations: int ) -> dict: pass ``` # Parameters - **width, height** `(int)`: Dimensions of the grid (1 ≤ width, height ≤ 100). - **tree_density** `(float)`: The probability that a cell contains a tree at initialization (0 ≤ tree_density ≤ 1). - **initial_burn_prob** `(float)`: The probability that a tree is initially on fire (0 ≤ initial_burn_prob ≤ 1). - **spread_prob** `(float)`: The probability that fire spreads from a burning tree to an adjacent tree (0 ≤ spread_prob ≤ 1). - **max_iterations** `(int)`: Maximum number of iterations to run the simulation (1 ≤ max_iterations ≤ 1000). # Returns - **result** `(dict)`: A dictionary with the final counts of trees and burnt trees. - `{\\"trees\\": <final trees count>, \\"burnt_trees\\": <final burnt trees count>}` # Detailed Requirements 1. **Initialization**: - Generate a grid with dimensions `width` x `height`. - Populate the grid with trees based on `tree_density`. - Randomly set some trees on fire based on `initial_burn_prob`. 2. **Simulation Loop**: - For each iteration, update the state of the grid: - A tree that is burning will turn into an empty cell (burnt tree) after that iteration. - A burning tree will attempt to spread fire to its adjacent trees (up, down, left, right) based on `spread_prob`. - Stop the simulation if no trees are burning or `max_iterations` is reached. 3. **Return Final Counts**: - After completing the simulation, return the counts of remaining trees and burnt trees. # Example ```python width = 30 height = 30 tree_density = 0.6 initial_burn_prob = 0.05 spread_prob = 0.3 max_iterations = 100 result = forest_fire_simulation( width, height, tree_density, initial_burn_prob, spread_prob, max_iterations ) print(result) # Output: {\'trees\': X, \'burnt_trees\': Y} ``` In this example, replace `X` and `Y` with the resulting counts of remaining trees and burnt trees after the simulation runs for `max_iterations` iterations or no more trees are burning.","solution":"import random def forest_fire_simulation( width: int, height: int, tree_density: float, initial_burn_prob: float, spread_prob: float, max_iterations: int ) -> dict: EMPTY, TREE, BURNING = 0, 1, 2 def initialize_grid(): grid = [] for _ in range(height): row = [] for _ in range(width): if random.random() < tree_density: if random.random() < initial_burn_prob: row.append(BURNING) else: row.append(TREE) else: row.append(EMPTY) grid.append(row) return grid def spread_fire(grid): new_grid = [row[:] for row in grid] for y in range(height): for x in range(width): if grid[y][x] == BURNING: # Current tree will turn to empty next round new_grid[y][x] = EMPTY # Try to spread fire to adjacent trees for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nx, ny = x + dx, y + dy if 0 <= nx < width and 0 <= ny < height and grid[ny][nx] == TREE: if random.random() < spread_prob: new_grid[ny][nx] = BURNING return new_grid def count_trees_and_burnt(grid): trees_count = sum(row.count(TREE) for row in grid) burnt_count = sum(row.count(BURNING) + row.count(EMPTY) for row in grid) return trees_count, burnt_count grid = initialize_grid() for _ in range(max_iterations): grid = spread_fire(grid) if all(tree != BURNING for row in grid for tree in row): break trees_count, burnt_count = count_trees_and_burnt(grid) return {\'trees\': trees_count, \'burnt_trees\': height * width - trees_count}"},{"question":"# Question You are required to implement a function to perform matrix transposition and matrix multiplication using both iterative and recursive methods as per the description. Your implementation should handle valid inputs and raise errors for invalid inputs. Function Signature ```python def matrix_transpose_iterative(matrix: List[List[int]]) -> List[List[int]]: def matrix_transpose_recursive(matrix: List[List[int]], transpose: Optional[List[List[int]]] = None, row: int = 0) -> List[List[int]]: def matrix_multiply_iterative(matrix_a: List[List[int]], matrix_b: List[List[int]]) -> List[List[int]]: def matrix_multiply_recursive(matrix_a: List[List[int]], matrix_b: List[List[int]], result: Optional[List[List[int]]] = None, i: int = 0, j: int = 0, k: int = 0) -> List[List[int]]: ``` Requirements: 1. **Function 1**: `matrix_transpose_iterative(matrix: List[List[int]]) -> List[List[int]]` - Performs matrix transposition in an iterative manner. - Should raise `ValueError` for non-rectangular matrices. 2. **Function 2**: `matrix_transpose_recursive(matrix: List[List[int]], transpose: Optional[List[List[int]]] = None, row: int = 0) -> List[List[int]]` - Performs matrix transposition using recursion. - Raise specific errors (`ValueError`) for invalid matrix dimensions. 3. **Function 3**: `matrix_multiply_iterative(matrix_a: List[List[int]], matrix_b: List[List[int]]) -> List[List[int]]` - Performs matrix multiplication in an iterative manner. - Should raise `ValueError` if the matrices cannot be multiplied due to dimension mismatch. 4. **Function 4**: `matrix_multiply_recursive(matrix_a: List[List[int]], matrix_b: List[List[int]], result: Optional[List[List[int]]] = None, i: int = 0, j: int = 0, k: int = 0) -> List[List[int]]` - Performs matrix multiplication using recursion. - Raise specific errors (`ValueError`) for invalid matrix dimensions. Input - `matrix`, `matrix_a`, `matrix_b`: A list of lists of integers representing the matrices. `matrix` should be rectangular for transpose functions and `matrix_a` and `matrix_b` should have compatible dimensions for multiplication. Output - Returns a 2D list of integers representing the transposed or multiplied matrix. Constraints - Inputs must always represent valid matrices with integer values. - Matrices will not exceed dimensions of 20x20 for transposition and 10x10 for multiplication to ensure optimal performance. Example ```python >>> matrix_transpose_iterative([[1, 2, 3], [4, 5, 6]]) [[1, 4], [2, 5], [3, 6]] ``` ```python >>> matrix_transpose_recursive([[1, 2, 3], [4, 5, 6]]) [[1, 4], [2, 5], [3, 6]] ``` ```python >>> matrix_multiply_iterative([[1, 2], [3, 4]], [[5, 6], [7, 8]]) [[19, 22], [43, 50]] ``` ```python >>> matrix_multiply_recursive([[1, 2], [3, 4]], [[5, 6], [7, 8]]) [[19, 22], [43, 50]] ``` Scenario Consider implementing your solution while keeping in mind matrix dimension validation, edge cases, and performance impacts. Use try-except blocks cautiously to catch and report invalid matrix structures or dimension mismatches.","solution":"from typing import List, Optional def matrix_transpose_iterative(matrix: List[List[int]]) -> List[List[int]]: if not matrix or not matrix[0]: raise ValueError(\\"Matrix is empty or not rectangular\\") num_rows, num_cols = len(matrix), len(matrix[0]) transpose = [[matrix[row][col] for row in range(num_rows)] for col in range(num_cols)] return transpose def matrix_transpose_recursive(matrix: List[List[int]], transpose: Optional[List[List[int]]] = None, row: int = 0) -> List[List[int]]: if not matrix or not matrix[0]: raise ValueError(\\"Matrix is empty or not rectangular\\") if transpose is None: num_cols = len(matrix[0]) transpose = [[] for _ in range(num_cols)] if row == len(matrix): return transpose else: for col in range(len(matrix[row])): transpose[col].append(matrix[row][col]) return matrix_transpose_recursive(matrix, transpose, row + 1) def matrix_multiply_iterative(matrix_a: List[List[int]], matrix_b: List[List[int]]) -> List[List[int]]: if not matrix_a or not matrix_b or not matrix_a[0] or not matrix_b[0] or len(matrix_a[0]) != len(matrix_b): raise ValueError(\\"Invalid matrix dimensions for multiplication\\") result = [[0 for _ in range(len(matrix_b[0]))] for _ in range(len(matrix_a))] for i in range(len(matrix_a)): for j in range(len(matrix_b[0])): for k in range(len(matrix_b)): result[i][j] += matrix_a[i][k] * matrix_b[k][j] return result def matrix_multiply_recursive(matrix_a: List[List[int]], matrix_b: List[List[int]], result: Optional[List[List[int]]] = None, i: int = 0, j: int = 0, k: int = 0) -> List[List[int]]: if not matrix_a or not matrix_b or not matrix_a[0] or not matrix_b[0] or len(matrix_a[0]) != len(matrix_b): raise ValueError(\\"Invalid matrix dimensions for multiplication\\") if result is None: result = [[0 for _ in range(len(matrix_b[0]))] for _ in range(len(matrix_a))] if i >= len(matrix_a): return result if j >= len(matrix_b[0]): return matrix_multiply_recursive(matrix_a, matrix_b, result, i + 1, 0, 0) if k >= len(matrix_b): return matrix_multiply_recursive(matrix_a, matrix_b, result, i, j + 1, 0) result[i][j] += matrix_a[i][k] * matrix_b[k][j] return matrix_multiply_recursive(matrix_a, matrix_b, result, i, j, k + 1)"},{"question":"**Context**: You are tasked with optimizing the item storage in a game inventory system. The inventory system arranges items in a 2D grid where each cell can either contain an item or be empty. Items can have different heights and widths, and you\'re asked to write an efficient algorithm to determine if a new item can fit into the grid at any position. **Problem**: Write a function `can_fit_item` that determines if a new item of given dimensions can fit into the existing grid without overlapping any existing items. **Function Signature**: ```python def can_fit_item(grid: list, item_height: int, item_width: int) -> bool: ``` **Input**: * A 2D list `grid` of size `m x n` representing the inventory grid where each cell can be either 0 (empty) or 1 (occupied). * Two integers `item_height` and `item_width` representing the height and width of the new item respectively. **Output**: * Return `True` if the item can fit into the grid at any position without overlapping any existing items, otherwise return `False`. **Constraints**: * The grid dimensions `m` and `n` are up to 1000. * The item dimensions `item_height` and `item_width` are up to the grid dimension or smaller. * The item has to fit fully within the grid boundaries. **Performance Requirements**: * The solution should efficiently check possible placements. A naive approach could result in O(m*n*item_height*item_width) complexity, but there are more optimal ways to achieve this. **Example**: ```python grid = [ [0, 1, 0, 0], [0, 1, 0, 0], [0, 0, 0, 1], [1, 1, 0, 0] ] item_height = 2 item_width = 2 output = can_fit_item(grid, item_height, item_width) print(output) # Expected: True, as the item (2x2) can fit at position (2, 1) ```","solution":"def can_fit_item(grid, item_height, item_width): m = len(grid) n = len(grid[0]) for i in range(m - item_height + 1): for j in range(n - item_width + 1): # Check if item can fit starting from (i, j) can_fit = True for k in range(i, i + item_height): for l in range(j, j + item_width): if grid[k][l] == 1: can_fit = False break if not can_fit: break if can_fit: return True return False"},{"question":"# Objective Writing a function to analyze a string for certain repetitive patterns and identify a specific mathematical property. # Problem Statement You are tasked with implementing a function that assesses a string to detect the longest substring repeating at least `k` times and determines the length of this substring. If no such substring exists, the function should return 0. Function Signature ```python def longest_repeating_substring(s: str, k: int) -> int: Finds the length of the longest repeating substring that appears at least k times in the input string. Parameters: s (str): The input string to be analyzed. k (int): The minimum number of repetitions required for the substring. Returns: int: The length of the longest repeating substring that meets the required repetitions, or 0 if none exist. ``` # Requirements 1. **Substring Analysis**: Implement robust logic to identify substrings and their repetition counts. 2. **Length Calculation**: Determine the length of the longest substring meeting the specified repetition criteria. 3. **Edge Case Handling**: Return 0 if no such substring is found or if inputs are invalid. # Example Input/Output ```python >>> longest_repeating_substring(\\"abababccc\\", 3) 2 >>> longest_repeating_substring(\\"abcabcabcabc\\", 4) 3 >>> longest_repeating_substring(\\"abcd\\", 2) 0 ``` *Expected Output*: The output should be an integer representing the length of the longest repeating substring that appears at least `k` times, or 0 if none are found. # Constraints - You can assume that `s` will be a non-empty string containing only lowercase alphabetic characters. - The value of `k` will be a positive integer. - Optimize for performance, ensuring the implementation can handle large strings efficiently. - Consider edge cases such as very small strings or large values of `k`. # Notes - Use efficient string processing techniques. - Explore possible solutions using sliding windows, hashing, or suffix arrays. - Ensure your implementation is well-optimized and handles large inputs within acceptable time and space complexity. Implement the `longest_repeating_substring` function based on the provided requirements.","solution":"def longest_repeating_substring(s: str, k: int) -> int: Finds the length of the longest repeating substring that appears at least k times in the input string. Parameters: s (str): The input string to be analyzed. k (int): The minimum number of repetitions required for the substring. Returns: int: The length of the longest repeating substring that meets the required repetitions, or 0 if none exist. from collections import defaultdict def has_k_repetitions(s, length, k): count = defaultdict(int) for i in range(len(s) - length + 1): substring = s[i:i+length] count[substring] += 1 if count[substring] >= k: return True return False left, right = 1, len(s) result = 0 while left <= right: mid = (left + right) // 2 if has_k_repetitions(s, mid, k): result = mid left = mid + 1 else: right = mid - 1 return result"},{"question":"Consider the problem of implementing a program to manage a basic cache using Least Recently Used (LRU) caching algorithm. You are required to design two primary functions to handle cache operations and cache state. # Function Specifications **Function 1**: ```python def refer(cache_size: int, pages: list[int]) -> list[int]: pass ``` **Function 2**: ```python def get_cache() -> list[int]: pass ``` # Input * `cache_size`: An integer representing the size of the cache. * `pages`: A list of `m` integers, where each integer represents a page reference in a sequence. # Output * For `refer`: A list of integers representing the state of the cache after processing the page references in the given sequence. * For `get_cache`: A list of integers representing the current state of the cache at any given time. # Constraints * 1 ≤ cache_size ≤ 100 * 1 ≤ m ≤ 1000 * All page references in the sequence are positive integers. # Requirements * Implement both functions using the Least Recently Used (LRU) caching algorithm. * Ensure your implementation efficiently handles cache references and updates. * If a page is not found in the cache and the cache is full, the least recently used page should be removed to make space for the new page. * Print the final state of the cache after all page references have been processed. # Example ```python # Inputs cache_size = 3 pages = [1, 2, 3, 4, 2, 1, 5, 1, 2, 3, 4, 5] # Function 1: refer final_cache_state = refer(cache_size, pages) # Cache State Output: [3, 4, 5] # Function 2: get_cache current_cache_state = get_cache() # Current Cache State Output (can be called any time): [3, 4, 5] ``` Implement the required functions ensuring adherence to the LRU caching algorithm principles, managing cache references and state updates efficiently.","solution":"from collections import deque cache = deque() def refer(cache_size: int, pages: list[int]) -> list[int]: global cache cache.clear() for page in pages: if page in cache: cache.remove(page) elif len(cache) == cache_size: cache.popleft() cache.append(page) return list(cache) def get_cache() -> list[int]: return list(cache)"},{"question":"# Problem Statement You are tasked with writing a program that processes an input string by converting it into its \\"letter frequency signature.\\" The letter frequency signature of a string is a string that describes the number of occurrences of each different letter in the input string in alphabetical order. # Task: Write a function `letter_frequency_signature(s: str) -> str:` that takes a single input string representing the text to be analyzed and returns a string that represents the counts of each letter, formatted as \\"<letter>:<count>\\", sorted alphabetically by the letters. # Input * `s`: a string containing lower-case alphabetical characters (a-z) or an empty string. # Output * A string in the format \\"<letter>:<count>\\" for each letter, sorted alphabetically, each pair separated by a comma. Letters with a count of zero should be omitted. # Constraints * The input string will only contain lower-case alphabetical characters or be empty. * The output should not include characters with a zero count. # Example Input `s = \\"banana\\"` Output `\'a:3,b:1,n:2\'` Input `s = \\"apple\\"` Output `\'a:1,e:1,l:1,p:2\'` Input `s = \\"\\"` Output `\'\'` # Implementation Notes - Writing concise and well-documented code is expected. - Consider using type hints and ensuring code readability. - The solution should be tested for various edge cases, including an empty string. # Function Signature ```python def letter_frequency_signature(s: str) -> str: pass ``` # Additional Requirements 1. Implement comprehensive validation of inputs. 2. Include error handling for invalid input types. 3. Efficient processing for longer strings.","solution":"def letter_frequency_signature(s: str) -> str: Returns the letter frequency signature of the given string. :param s: Input string containing lower-case alphabetical characters. :return: A string representing the counts of each letter in the format \\"letter:count\\", sorted alphabetically, separated by commas. from collections import Counter # Count the frequency of each character in the string counter = Counter(s) # Format the counts into the specified format frequency_signature = \',\'.join(f\\"{char}:{count}\\" for char, count in sorted(counter.items())) return frequency_signature"},{"question":"# List Rotation Challenge In this challenge, you are required to rotate the elements of a given list to the right by a specified number of steps. Rotating a list means that elements shifted beyond the last position are looped back to the beginning of the list. Scenario Imagine you are designing a feature for an image slideshow application. Users can decide how many images they want to skip forward or backward in their album. To simulate this feature, you will rotate a list representing the order of images based on a user-defined number of steps. Function Signature ```python def rotate_list(lst: list, k: int) -> list: This function receives a list and an integer indicating how many positions to rotate the list to the right. It returns the list after rotation. Args: lst (list): A list of elements to be rotated. k (int): An integer indicating the number of positions to rotate. Returns: list: The list after being rotated by k positions. ``` Input - `lst`: A list containing any data type elements. - `k`: An integer representing the number of rightward rotations to apply. Output - The list obtained after rotating the original list `k` positions to the right. Constraints - The length of `lst` will be between 0 and 1000. - The integer `k` can be any valid integer, positive, zero, or negative. Examples ```python >>> rotate_list([1, 2, 3, 4, 5], 2) [4, 5, 1, 2, 3] >>> rotate_list([1, 2, 3, 4, 5], -2) [3, 4, 5, 1, 2] >>> rotate_list([1, 2, 3, 4, 5], 5) [1, 2, 3, 4, 5] >>> rotate_list([], 3) [] >>> rotate_list([\'a\', \'b\', \'c\', \'d\'], 1) [\'d\', \'a\', \'b\', \'c\'] ``` Requirements - The operation should handle cases where `k` is larger than the length of the list by using modulo operation appropriately. - Instead of implementing this using a loop approach, aim to utilize slicing for an efficient solution. - Consider edge cases such as empty lists and negative rotations. Tips - Determine the effective rotation steps by reducing `k` modulo the length of the list. - Handle scenarios where `k` is negative by converting it to the corresponding positive rotations. Implement the function `rotate_list` and test it with appropriate inputs.","solution":"def rotate_list(lst: list, k: int) -> list: This function receives a list and an integer indicating how many positions to rotate the list to the right. It returns the list after rotation. Args: lst (list): A list of elements to be rotated. k (int): An integer indicating the number of positions to rotate. Returns: list: The list after being rotated by k positions. n = len(lst) if n == 0: return lst # Normalize rotations in case k is larger than the length of the list k = k % n # If k is 0, rotation means the list remains the same if k == 0: return lst # Perform the rotation using slicing return lst[-k:] + lst[:-k]"},{"question":"# Problem Statement **Highest Frequency Element Finder** Given an array of integers, write a function to determine the element with the highest frequency. If multiple elements have the same highest frequency, return the smallest element among them. You need to implement the function `find_highest_frequency_element(arr: List[int]) -> int` that satisfies the requirements below. # Input - `arr`: A list of integers (1 ≤ len(arr) ≤ 10^6). # Output - Returns the integer that has the highest frequency in the array. If multiple integers have the same highest frequency, return the smallest integer among them. # Constraints - 1 ≤ arr[i] ≤ 10^9 for all valid i. # Performance Requirements - The solution should cater to large inputs efficiently with a time complexity of O(n) using appropriate data structures. # Example ```python >>> find_highest_frequency_element([1, 3, 2, 3, 4, 1, 2, 3, 1]) 1 >>> find_highest_frequency_element([4, 4, 2, 2, 3, 3]) 2 >>> find_highest_frequency_element([10, 10, 20, 20, 30, 30, 30]) 30 ``` # Notes - For arrays with a single element, return that element. - Ensure the function handles both very large arrays and elements efficiently. - Use suitable data structures to maintain frequency counts and determine smallest element in case of ties.","solution":"from collections import defaultdict from typing import List def find_highest_frequency_element(arr: List[int]) -> int: Find the element with the highest frequency in the array. If multiple elements have the same highest frequency, return the smallest element. frequency = defaultdict(int) # Calculate the frequency of each element for num in arr: frequency[num] += 1 # Find the element with the highest frequency max_count = 0 max_elements = [] for num, count in frequency.items(): if count > max_count: max_count = count max_elements = [num] elif count == max_count: max_elements.append(num) # Return the smallest element among those with the highest frequency return min(max_elements)"},{"question":"# Subset Sum Problem Problem Description Given a list of integers, determine if there exists a non-empty subset whose elements sum up to a given target value. If such a subset exists, return any one of the subsets; otherwise, return an empty list. Function Signature Write a Python function `subset_sum(nums: List[int], target: int) -> List[int]` that takes two parameters: - `nums`: A list of integers. - `target`: An integer representing the target sum. Return The function should return: - A list of integers representing any one subset whose sum is equal to the target. - An empty list if no such subset exists. Constraints - The number of elements in `nums` will be between 1 and 30. - The integers in `nums` and `target` can range from -100 to 100. Example ```python def subset_sum(nums: List[int], target: int) -> List[int]: # Your code here # Example Test Cases nums1 = [1, 2, 3, 7] target1 = 6 print(subset_sum(nums1, target1)) # Output: [1, 2, 3] (or any other subset sum that equals 6) nums2 = [1, -1, 2, 4, 5] target2 = 0 print(subset_sum(nums2, target2)) # Output: [1, -1] (or any other subset sum that equals 0) nums3 = [2, 4, 6, 8] target3 = 5 print(subset_sum(nums3, target3)) # Output: [] ``` In these examples, the first list has a subset that sums up to 6, the second list has a subset that sums up to 0, and the third list does not have any subset that sums up to 5. Requirements - Implement the `subset_sum` function to determine a valid subset whose sum equals the target value. - Ensure the solution handles both positive and negative integers and considers empty subsets as invalid.","solution":"from typing import List def subset_sum(nums: List[int], target: int) -> List[int]: def find_subset(index, current_sum, subset): if current_sum == target: return subset if index >= len(nums) or current_sum > target: return [] # Include the current element result = find_subset(index + 1, current_sum + nums[index], subset + [nums[index]]) if result: return result # Exclude the current element return find_subset(index + 1, current_sum, subset) return find_subset(0, 0, [])"},{"question":"# Coding Assessment Question **Scenario**: Imagine you are building a photo album management software. One of the features is to identify duplicate photos, even if they are of different file names. To achieve this, you will need to compare two images by their pixel values and determine whether they are identical. Given the size of the data involved, an efficient solution is paramount. # Problem Statement: Implement a function `are_images_identical(image1: List[List[int]], image2: List[List[int]])` that determines whether two images are identical. Each image is represented as a list of lists, where each inner list represents a row of pixel values in the image. # Requirements: 1. **Input**: - Two 2D lists `image1` and `image2` representing the pixel values of the images. 2. **Output**: - A boolean value: `True` if the images are identical, `False` otherwise. 3. **Constraints**: - Both images have the same dimensions. - The dimensions of the images will not exceed 1000 x 1000 pixels. - Pixel values are in the range [0, 255]. # Examples: ```python >>> are_images_identical([[255, 255, 255], [0, 0, 0]], [[255, 255, 255], [0, 0, 0]]) True >>> are_images_identical([[255, 255, 255], [0, 0, 0]], [[255, 255, 255], [0, 0, 1]]) False >>> are_images_identical([[0, 0], [0, 0]], [[0, 0], [0, 0]]) True >>> are_images_identical([[100, 150, 200], [50, 75, 100]], [[100, 150, 200], [50, 75, 101]]) False >>> are_images_identical([[1]], [[1]]) True ``` # Guidelines: * Ensure the solution is efficient and avoids unnecessary computations. * Handle edge cases such as empty or single-pixel images. * You may assume that the input lists are well-formed and will always contain only integers within the specified range.","solution":"def are_images_identical(image1, image2): Determine if two images are identical by comparing their pixel values. Args: image1 (List[List[int]]): The first image represented as a 2D list of pixel values. image2 (List[List[int]]): The second image represented as a 2D list of pixel values. Returns: bool: True if the images are identical, False otherwise. if len(image1) != len(image2): return False for row1, row2 in zip(image1, image2): if row1 != row2: return False return True"},{"question":"# Problem Statement As an engineer working on a drone navigation system, you are tasked with designing an algorithm to optimize the flight path of a drone to avoid obstacles in real-time. The flight area is represented as a 2D grid where each cell can be either an open space or an obstacle. The drone starts at a given position and must reach a target position using the shortest path while avoiding obstacles. # Function Signature ```python def shortest_path(grid, start, target): Finds the shortest path from start to target position on a grid avoiding obstacles. Arguments: grid -- 2D list of integers (1 represents an obstacle, 0 represents open space) start -- Tuple (x, y) representing the starting position target -- Tuple (x, y) representing the target position Returns: An integer representing the length of the shortest path from start to target. If there\'s no valid path, return -1. pass ``` # Input * `grid` (list of lists of integers): A 2D grid representing the flight area. `1` represents an obstacle, and `0` represents open space. * `start` (tuple of two integers): Starting position `(x, y)` of the drone. * `target` (tuple of two integers): Target position `(x, y)` the drone needs to reach. # Output An integer representing the length of the shortest path from the start to the target position. If there\'s no valid path, return -1. # Constraints * The grid has dimensions ( m times n ) where ( 1 leq m, n leq 100 ). * Each cell in the grid is either `0` or `1`. * The start and target positions are valid (i.e., they are within the grid and always `0`). * The drone can move up, down, left, or right (not diagonally). # Performance Requirements * Your solution should run efficiently within the given constraints. * Ensure the algorithm handles edge cases such as no possible path due to obstacles. # Example ```python # Define the grid grid = [ [0, 0, 0, 0], [1, 1, 0, 1], [0, 0, 0, 0], [0, 1, 1, 0], [0, 0, 0, 0] ] # Define start and target positions start = (0, 0) target = (4, 3) # Call the function path_length = shortest_path(grid, start, target) # Example output # 7 ``` # Explanation The function calculates the shortest path length from the start position `(0, 0)` to the target position `(4, 3)` while avoiding obstacles. The example output indicates that the shortest path has a length of 7. If there were no valid path, the function would return -1.","solution":"from collections import deque def shortest_path(grid, start, target): Finds the shortest path from start to target position on a grid avoiding obstacles. Arguments: grid -- 2D list of integers (1 represents an obstacle, 0 represents open space) start -- Tuple (x, y) representing the starting position target -- Tuple (x, y) representing the target position Returns: An integer representing the length of the shortest path from start to target. If there\'s no valid path, return -1. rows, cols = len(grid), len(grid[0]) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] def is_valid(x, y): return 0 <= x < rows and 0 <= y < cols and grid[x][y] == 0 queue = deque([(start[0], start[1], 0)]) visited = set(start) while queue: x, y, dist = queue.popleft() if (x, y) == target: return dist for dx, dy in directions: nx, ny = x + dx, y + dy if is_valid(nx, ny) and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny, dist + 1)) return -1"},{"question":"# Problem Statement You are given a list of `n` integer points on a 2D plane, where `points[i] = [xi, yi]`. You need to find the maximum number of points that lie on the same straight line. Write a function that computes the maximum number of points that are located on the same straight line passing through any two given points (xi, yi). # Function Signature ```python def max_points_on_a_line(points: List[List[int]]) -> int: ``` # Input - `points` (List[List[int]]): A list of `n` points represented as a list of integer pairs `[xi, yi]`. # Output - Returns the maximum number of points that lie on the same straight line. # Constraints - `1 <= n <= 300` - `-10^4 <= xi, yi <= 10^4` - All coordinates are integers. # Example ```python points = [[1, 1], [2, 2], [3, 3]] print(max_points_on_a_line(points)) # Output: 3 points = [[1, 1], [3, 2], [5, 3], [4, 1], [2, 3], [1, 4]] print(max_points_on_a_line(points)) # Output: 4 ``` # Additional Information: * You may simplify the problem by thinking in terms of slope and intercept. * Avoid floating-point precision issues by using rational numbers or synchronous integer checking. * Make sure to account for vertical lines which have an undefined slope.","solution":"from typing import List from collections import defaultdict from math import gcd def max_points_on_a_line(points: List[List[int]]) -> int: def slope(p1, p2): dx = p1[0] - p2[0] dy = p1[1] - p2[1] if dx == 0: return \'inf\' g = gcd(dx, dy) return (dy // g, dx // g) if len(points) < 3: return len(points) max_points = 1 for i, point1 in enumerate(points): slopes = defaultdict(int) for j, point2 in enumerate(points): if i != j: s = slope(point1, point2) slopes[s] += 1 max_points = max(max_points, slopes[s] + 1) return max_points"},{"question":"# Coding Assessment Question **Context:** As part of the development team for an e-commerce platform, you are tasked with creating a utility to help manage stock inventories. One of the challenges is determining the optimal way to split a given quantity of products into boxes. The requirement is to ensure that each box is filled to its maximum capacity before starting to fill the next one. **Task:** Implement a function `distribute_inventory` that, given the total number of items and the maximum capacity of a single box, distributes the items into the minimum number of boxes required. The function should return a list where each element represents the number of items in a respective box. Function Signature: ```python def distribute_inventory(total_items: int, box_capacity: int) -> list: pass ``` Input: * `total_items` - An integer representing the total number of items. * `box_capacity` - An integer representing the maximum capacity of a single box. Output: * A list of integers where each integer represents the number of items in one box. Constraints: 1. Validate that both inputs `total_items` and `box_capacity` are non-negative integers. 2. Ensure that `box_capacity` is greater than 0 to avoid division by zero. 3. Optimize for cases with very large `total_items` values. Examples: ```python >>> distribute_inventory(15, 4) [4, 4, 4, 3] >>> distribute_inventory(10, 3) [3, 3, 3, 1] >>> distribute_inventory(25, 7) [7, 7, 7, 4] >>> distribute_inventory(7, 7) [7] >>> distribute_inventory(0, 5) [] ``` **Notes:** - Make sure to validate the input before proceeding with the distribution logic. - The function should fill each box to its maximum capacity before starting to fill the next one unless the total items are fewer than the box_capacity, in which case, all items go into one box. **Hints:** - You can use integer division and modulus operations to determine the number of required boxes and the distribution of items among them. - Handle edge cases where the total_items or box_capacity inputs might be zero.","solution":"def distribute_inventory(total_items: int, box_capacity: int) -> list: Distribute total_items into boxes each with a maximum capacity of box_capacity. Args: total_items (int): The total number of items to distribute. box_capacity (int): The capacity of each box. Returns: list: A list representing the number of items in each box. if not isinstance(total_items, int) or not isinstance(box_capacity, int): raise ValueError(\\"Both total_items and box_capacity must be integers.\\") if total_items < 0 or box_capacity <= 0: raise ValueError(\\"total_items must be non-negative and box_capacity must be greater than zero.\\") result = [] remaining_items = total_items while remaining_items > 0: if remaining_items >= box_capacity: result.append(box_capacity) else: result.append(remaining_items) remaining_items -= box_capacity return result"},{"question":"# Context Binary Search is a fundamental algorithm in computer science, known for its efficiency in finding an element in a sorted array. It can be further used to solve various problems such as finding the lower and upper bounds for a given value. # Question Write a function `find_bounds` that accepts a sorted list of integers and a target value. The function should return the indices of the first and last occurrence of the target value in the list. If the target value is not found in the list, return [-1, -1]. # Function Signature ```python def find_bounds(array: List[int], target: int) -> List[int]: Finds the first and last occurrence indices of the target value in the sorted list. :param array: The sorted list of integers. :param target: The target value to find. :return: A list containing the first and last indices of the target value. ``` # Input * `array`: A list of sorted integers, e.g., `[1, 2, 2, 2, 3, 4, 5]` * `target`: An integer value to find in the list, e.g., `2` # Output * A list containing the first and last indices of the target value, e.g., `[1, 3]` if the target is found, otherwise `[-1, -1]`. # Constraints * The input list `array` is sorted in ascending order and can be of any length. * Try to achieve the solution with a time complexity of O(log n). # Examples ```python assert find_bounds([1, 2, 2, 2, 3, 4, 5], 2) == [1, 3] assert find_bounds([1, 2, 2, 2, 3, 4, 5], 3) == [4, 4] assert find_bounds([1, 2, 2, 2, 3, 4, 5], 6) == [-1, -1] assert find_bounds([], 3) == [-1, -1] ```","solution":"from typing import List def find_bounds(array: List[int], target: int) -> List[int]: def find_first(): low, high = 0, len(array) - 1 first = -1 while low <= high: mid = (low + high) // 2 if array[mid] == target: first = mid high = mid - 1 elif array[mid] < target: low = mid + 1 else: high = mid - 1 return first def find_last(): low, high = 0, len(array) - 1 last = -1 while low <= high: mid = (low + high) // 2 if array[mid] == target: last = mid low = mid + 1 elif array[mid] < target: low = mid + 1 else: high = mid - 1 return last first = find_first() if first == -1: return [-1, -1] last = find_last() return [first, last]"},{"question":"# JSON Path Extraction Assessment You are tasked with implementing a JSON path extraction functionality. JSON path allows you to navigate through a JSON document to extract information. The goal is to write a function `extract_json_path` that accepts a JSON object and a path string and returns the value found at that path within the JSON object. Function: `extract_json_path(json_obj: dict, path: str) -> Any` This function should accept a JSON object and a path string and return the value found at the specified path within the JSON object. # Input & Output Format 1. **Input for `extract_json_path`**: A JSON object (represented as a dictionary in Python) and a path string. 2. **Output for `extract_json_path`**: The value found at the specified path within the JSON object. # Constraints * If the path does not exist within the JSON object, the function should return `None`. * The path should support nested JSON navigation using dot notation (e.g., `key1.key2.key3`). * The input JSON object can have nested structurers such as lists and dictionaries. * Assume valid JSON paths (existing keys) are provided and there will be no invalid paths (e.g., syntax errors in paths). * The maximum depth of the JSON object is 10 levels. # Requirements * Ensure robust handling of edge cases such as non-existing paths, empty JSON objects, or complex nested structures. * The function should efficiently navigate through the JSON structure without unnecessary performance overhead. # Example ```python json_example = { \\"name\\": \\"Alice\\", \\"details\\": { \\"age\\": 30, \\"address\\": { \\"street\\": \\"123 Maple St\\", \\"city\\": \\"Wonderland\\" }, \\"phones\\": [\\"123-456-7890\\", \\"987-654-3210\\"] }, \\"preferences\\": { \\"colors\\": [\\"red\\", \\"blue\\"], \\"foods\\": { \\"breakfast\\": \\"pancakes\\", \\"lunch\\": \\"sandwich\\" } } } assert extract_json_path(json_example, \\"name\\") == \\"Alice\\" assert extract_json_path(json_example, \\"details.age\\") == 30 assert extract_json_path(json_example, \\"details.address.city\\") == \\"Wonderland\\" assert extract_json_path(json_example, \\"preferences.colors\\") == [\\"red\\", \\"blue\\"] assert extract_json_path(json_example, \\"preferences.foods.breakfast\\") == \\"pancakes\\" assert extract_json_path(json_example, \\"details.phones.1\\") == \\"987-654-3210\\" assert extract_json_path(json_example, \\"details.address.zipcode\\") == None assert extract_json_path({}, \\"any.path\\") == None ``` These example tests indicate what the expected output for given inputs should be. Make sure your implementation passes these checks and handles other potential scenarios well.","solution":"def extract_json_path(json_obj, path): Extracts the value from a JSON object based on the given dot notation path. Parameters: json_obj (dict): The JSON object as a dictionary. path (str): The dot notation string path to extract the value from the JSON object. Returns: Any: The value found at the specified path, or None if the path does not exist. try: keys = path.split(\\".\\") current_value = json_obj for key in keys: if isinstance(current_value, list): key = int(key) current_value = current_value[key] return current_value except (KeyError, IndexError, TypeError, ValueError): return None"},{"question":"# Perfect Number Finder Context A perfect number is a positive integer that is equal to the sum of its proper divisors, excluding itself. For example, the proper divisors of 28 are 1, 2, 4, 7, and 14, and their sum is 28, thus making it a perfect number. Task You are tasked with implementing the function `find_nth_perfect_number(n: int) -> int` that finds the nth perfect number. Function Signature ```python def find_nth_perfect_number(n: int) -> int ``` Input * `n` (int): A positive integer representing the sequence position of the perfect number. Output * Returns an integer representing the nth perfect number. Constraints * The function must handle values of `n` up to 4 due to the large size of perfect numbers. Examples ```python find_nth_perfect_number(1) -> 6 # 6 is the first perfect number. find_nth_perfect_number(2) -> 28 # 28 is the second perfect number. find_nth_perfect_number(3) -> 496 # 496 is the third perfect number. find_nth_perfect_number(4) -> 8128 # 8128 is the fourth perfect number. ``` Note * Use efficient algorithms to determine and verify if a number is perfect. * Special conditions or optimizations might be necessary for handling larger numbers as they grow exponentially within the sequence. Hints 1. Start by generating potential candidates using the known properties and definitions of perfect numbers. 2. Implement helper functions to calculate the sum of proper divisors.","solution":"def find_nth_perfect_number(n: int) -> int: Returns the nth perfect number. def is_perfect(number: int) -> bool: Returns True if the number is a perfect number, otherwise False. return number == sum(divisor for divisor in range(1, number // 2 + 1) if number % divisor == 0) count = 0 number = 2 # Start checking from 2 while True: if is_perfect(number): count += 1 if count == n: return number number += 1"},{"question":"# Coding Question Given a list of strings and a target word, we need to determine the number of strings in the list that can be transformed into the target word by rearranging their characters. Write a function to find the count of such strings. # Function Signature ```python def count_anagrams(strings: List[str], target: str) -> int: pass ``` # Input * `strings` (List[str]): A list of words. * `target` (str): The target word. # Output * `int`: The count of strings in the list that are anagrams of the target word. # Constraints * 1 <= len(strings) <= 10^5 * 1 <= len(target) <= 100 * All strings in the list and the target will only contain lowercase English letters. # Example ```python assert count_anagrams([\\"listen\\", \\"silent\\", \\"enlist\\", \\"google\\", \\"inlets\\", \\"banana\\"], \\"listen\\") == 4 assert count_anagrams([\\"apple\\", \\"pale\\", \\"leap\\", \\"apply\\", \\"plea\\"], \\"apple\\") == 3 ``` # Explanation - For the list [\\"listen\\", \\"silent\\", \\"enlist\\", \\"google\\", \\"inlets\\", \\"banana\\"] and target \\"listen\\", the strings \\"listen\\", \\"silent\\", \\"enlist\\", and \\"inlets\\" are anagrams of the target and the count is 4. - For the list [\\"apple\\", \\"pale\\", \\"leap\\", \\"apply\\", \\"plea\\"] and target \\"apple\\", the strings \\"apple\\", \\"pale\\", and \\"plea\\" are anagrams of the target and the count is 3. **Considerations**: - Consider using character frequency maps for efficient anagram checking. - Utilize suitable data structures for ensuring that the solution scales well with the input size. - Skip strings that are of different lengths than the target word to optimize the performance further.","solution":"from typing import List from collections import Counter def count_anagrams(strings: List[str], target: str) -> int: target_counter = Counter(target) return sum(1 for s in strings if Counter(s) == target_counter)"},{"question":"# Question: You are tasked with developing an algorithm for autocomplete functionality, which suggests words based on a given prefix. For simplicity, we\'ll use a dictionary that contains a list of words. Your goal is to implement the `autocomplete` function that returns all words which start with the given prefix. # Requirements: - Write a function `autocomplete(dictionary: List[str], prefix: str) -> List[str]` which returns a list of words from the dictionary that start with the given prefix. - The returned list should be sorted alphabetically. # Constraints: - The input dictionary will contain between 0 and 10,000 words. - Each word in the dictionary will have between 1 and 100 characters. - The prefix will have between 1 and 100 characters. # Input Example: ```python dictionary = [\\"apple\\", \\"appetizer\\", \\"banana\\", \\"application\\", \\"apply\\", \\"app\\", \\"apricot\\"] prefix = \\"app\\" ``` # Expected Output: ```python [\\"app\\", \\"apple\\", \\"application\\", \\"appetizer\\", \\"apply\\"] ``` # Notes: - The prefix \\"app\\" matches the words \\"app\\", \\"apple\\", \\"application\\", \\"appetizer\\", and \\"apply\\" in the dictionary. - Ensure the results are returned in alphabetical order. # Implementation: Implement the function `autocomplete` using your preferred method, ensuring it efficiently handles the constraints.","solution":"from typing import List def autocomplete(dictionary: List[str], prefix: str) -> List[str]: Returns a list of words from the dictionary that start with the given prefix. Args: dictionary (List[str]): List of words. prefix (str): The prefix to match. Returns: List[str]: List of words starting with the given prefix, sorted alphabetically. return sorted([word for word in dictionary if word.startswith(prefix)])"},{"question":"# Sorting Apparel by Fit Given a list of apparel items along with their sizes, implement a function that sorts these apparels according to a specific ordering of sizes. The sizes follow the order: `[\\"XS\\", \\"S\\", \\"M\\", \\"L\\", \\"XL\\", \\"XXL\\"]`. The function should output the list sorted in the specified size order. Function Signature: ```python def sort_apparel_by_size(apparels: list) -> list: ``` Inputs: - `apparels` (`list`): A list of tuples, where each tuple contains: - `name` (`str`): The name of the apparel. - `size` (`str`): Size of the apparel which is one of `[\\"XS\\", \\"S\\", \\"M\\", \\"L\\", \\"XL\\", \\"XXL\\"]`. Output: - `list`: The sorted list of tuples based on the size ordering. Constraints: - The size strings will always be from the set `[\\"XS\\", \\"S\\", \\"M\\", \\"L\\", \\"XL\\", \\"XXL\\"]`. - Preserve the relative order of apparels with the same size. Example Usage: ```python apparels = [ (\\"T-Shirt\\", \\"M\\"), (\\"Jacket\\", \\"L\\"), (\\"Pants\\", \\"S\\"), (\\"Socks\\", \\"XS\\"), (\\"Hat\\", \\"XL\\"), (\\"Gloves\\", \\"XXL\\") ] print(sort_apparel_by_size(apparels)) # Expected output: # [ # (\\"Socks\\", \\"XS\\"), # (\\"Pants\\", \\"S\\"), # (\\"T-Shirt\\", \\"M\\"), # (\\"Jacket\\", \\"L\\"), # (\\"Hat\\", \\"XL\\"), # (\\"Gloves\\", \\"XXL\\") # ] ``` Implement `sort_apparel_by_size`, ensuring to maintain the defined size order and handle various edge cases efficiently.","solution":"def sort_apparel_by_size(apparels: list) -> list: Sorts apparels based on predefined size order: [\\"XS\\", \\"S\\", \\"M\\", \\"L\\", \\"XL\\", \\"XXL\\"]. :param apparels: List of tuples where each tuple contains (name, size) :return: Sorted list of tuples size_order = {\\"XS\\": 0, \\"S\\": 1, \\"M\\": 2, \\"L\\": 3, \\"XL\\": 4, \\"XXL\\": 5} return sorted(apparels, key=lambda x: size_order[x[1]])"},{"question":"# Problem Statement You are working on a library management system which supports borrowing and returning books. You need to implement a feature that tracks the status of books and provides information about availability. # Task Implement a class called `LibrarySystem` that allows you to manage the borrowing and returning of books. Function Implementations 1. **add_book(book_id: int, title: str) -> None** - Adds a new book to the library with a unique `book_id` and a `title`. 2. **borrow_book(book_id: int) -> bool** - If the book with the given `book_id` is available, marks it as borrowed and returns `True`. Otherwise, it returns `False`. 3. **return_book(book_id: int) -> bool** - If the book with the given `book_id` was borrowed, marks it as returned and available, then returns `True`. Otherwise, it returns `False`. 4. **is_available(book_id: int) -> bool** - Returns `True` if the book with the given `book_id` is available for borrowing, and `False` otherwise. 5. **get_all_books() -> List[Tuple[int, str, str]]** - Returns a list of all books in the library, with each book represented as a tuple (`book_id`, `title`, `status`), where `status` is either \\"available\\" or \\"borrowed\\". Constraints - Book IDs are unique non-negative integers. - Titles are non-empty strings. - The library can contain up to `10^6` books. Performance Requirements - All operations should be optimized for performance, with average case time complexity as low as possible. Example ```python lib_system = LibrarySystem() # Adding books lib_system.add_book(1, \\"To Kill a Mockingbird\\") lib_system.add_book(2, \\"1984\\") lib_system.add_book(3, \\"The Great Gatsby\\") # Checking book availability print(lib_system.is_available(1)) # Output: True print(lib_system.is_available(2)) # Output: True # Borrowing books print(lib_system.borrow_book(1)) # Output: True print(lib_system.borrow_book(1)) # Output: False # Returning books print(lib_system.return_book(1)) # Output: True print(lib_system.return_book(1)) # Output: False # Getting all books print(lib_system.get_all_books()) # Output: [ (1, \\"To Kill a Mockingbird\\", \\"available\\"), (2, \\"1984\\", \\"available\\"), (3, \\"The Great Gatsby\\", \\"available\\") ] ``` Implement the `LibrarySystem` class with the required methods ensuring optimal performance and considering possible edge cases.","solution":"from typing import List, Tuple class LibrarySystem: def __init__(self): self.books = {} def add_book(self, book_id: int, title: str) -> None: if book_id not in self.books: self.books[book_id] = {\\"title\\": title, \\"status\\": \\"available\\"} def borrow_book(self, book_id: int) -> bool: if book_id in self.books and self.books[book_id][\\"status\\"] == \\"available\\": self.books[book_id][\\"status\\"] = \\"borrowed\\" return True return False def return_book(self, book_id: int) -> bool: if book_id in self.books and self.books[book_id][\\"status\\"] == \\"borrowed\\": self.books[book_id][\\"status\\"] = \\"available\\" return True return False def is_available(self, book_id: int) -> bool: if book_id in self.books and self.books[book_id][\\"status\\"] == \\"available\\": return True return False def get_all_books(self) -> List[Tuple[int, str, str]]: return [(book_id, data[\\"title\\"], data[\\"status\\"]) for book_id, data in self.books.items()]"},{"question":"# Question: Creating a Custom Tree Structure and Traversal Algorithm You need to design and implement a custom tree structure called `CustomTree` that supports additional constraints on the values stored in its nodes. Furthermore, you will be tasked with implementing a traversal algorithm to verify these constraints. # Task: 1. **Implement the `CustomTree` Class**: - Design a class `CustomTree` with the following capabilities: - Insert nodes while maintaining a constraint that each node\'s value must be unique and greater than all values in its left subtree but less than those in its right subtree. - Support methods for inserting, deleting, and searching for nodes while keeping the tree balanced. 2. **Traversal and Constraint Verification**: - Implement a method to traverse the tree and verify whether the structure meets the unique value constraint at each level. # Specifications: - **`CustomTree` Class**: - `__init__(self)`: Initialize the tree, optionally with a root node. - `insert(self, value: int)`: Insert a node with the specified value into the tree. - `delete(self, value: int)`: Delete a node with the specified value from the tree. - `search(self, value: int) -> bool`: Search for a node with the specified value. - `verify_constraints(self) -> bool`: Verify the unique value constraint across the tree. - `__str__(self) -> str`: Return a string representation of the tree. # Input and Output - **Input**: - An integer value to insert, delete, or search depending on the operation. - **Output**: - For the `insert`, `delete`, and `search` methods, there is no output, but the operations are performed on the tree. - The `verify_constraints` method should return a boolean indicating whether all node values are unique and meet the specified constraints. - The `__str__` method should return a string representation of the tree\'s structure. # Constraints: - All node values must be integers. - The tree must balance itself upon insert and delete to maintain efficient operations. # Example: ```python # Initialize tree ct = CustomTree() # Insert nodes ct.insert(10) ct.insert(5) ct.insert(15) ct.insert(3) ct.insert(7) # Search for nodes print(ct.search(7)) # Output: True print(ct.search(12)) # Output: False # Delete a node ct.delete(7) # Verify constraints print(ct.verify_constraints()) # Output: True # Print the tree structure print(ct) # Output: Custom tree structure in a readable format ``` # Deliverables: - The complete implementation of the `CustomTree` class with insert, delete, search, and verify methods. - A method to represent the tree as a string. - Unittests to validate the correct operation of the tree for insertion, deletion, search, and constraint verification. - An analysis of the implemented methods regarding their time and space complexity.","solution":"class TreeNode: def __init__(self, value): self.value = value self.left = None self.right = None class CustomTree: def __init__(self): self.root = None def insert(self, value): if self.root is None: self.root = TreeNode(value) else: self._insert_recursive(self.root, value) def _insert_recursive(self, node, value): if value < node.value: if node.left is None: node.left = TreeNode(value) else: self._insert_recursive(node.left, value) elif value > node.value: if node.right is None: node.right = TreeNode(value) else: self._insert_recursive(node.right, value) def search(self, value): return self._search_recursive(self.root, value) def _search_recursive(self, node, value): if node is None: return False if value == node.value: return True elif value < node.value: return self._search_recursive(node.left, value) else: return self._search_recursive(node.right, value) def delete(self, value): self.root, _ = self._delete_recursive(self.root, value) def _delete_recursive(self, node, value): if node is None: return node, None if value < node.value: node.left, _ = self._delete_recursive(node.left, value) elif value > node.value: node.right, _ = self._delete_recursive(node.right, value) else: if node.left is None: return node.right, node elif node.right is None: return node.left, node min_larger_node = self._get_min(node.right) node.value = min_larger_node.value node.right, _ = self._delete_recursive(node.right, node.value) return node, node def _get_min(self, node): while node.left is not None: node = node.left return node def verify_constraints(self): return self._verify_constraints_recursive(self.root, float(\'-inf\'), float(\'inf\')) def _verify_constraints_recursive(self, node, min_val, max_val): if node is None: return True if not (min_val < node.value < max_val): return False return (self._verify_constraints_recursive(node.left, min_val, node.value) and self._verify_constraints_recursive(node.right, node.value, max_val)) def __str__(self): if self.root is None: return \'Empty tree\' return self._tree_to_string(self.root, 0, \'\') def _tree_to_string(self, node, depth, res): if node is not None: res = self._tree_to_string(node.right, depth + 1, res) res += \'n\' + (\' \' * 4 * depth) + str(node.value) res = self._tree_to_string(node.left, depth + 1, res) return res"},{"question":"# Shortest Path using Dijkstra\'s Algorithm Problem Statement You are given a weighted directed graph represented by an adjacency list where each node is connected to one or more other nodes with given edge weights. Your task is to implement Dijkstra\'s algorithm to find the shortest path from a given source node to a target node. Function Signature ```python def find_shortest_path(adjacency_list: dict, source: int, target: int) -> list: Compute the shortest path from a source node to a target node using Dijkstra\'s algorithm. Args: adjacency_list (dict): A dictionary representing adjacency list of the graph where keys are node numbers and values are lists of tuples (neighbour, weight). source (int): The starting node for the shortest path. target (int): The destination node for the shortest path. Returns: list: A list of nodes representing the shortest path from source to target. If no path exists, return an empty list. Example: adjacency_list = { 0: [(1, 4), (2, 1)], 1: [(3, 1)], 2: [(1, 2), (3, 5)], 3: [] } source = 0 target = 3 find_shortest_path(adjacency_list, source, target) -> [0, 2, 1, 3] ``` Constraints * The graph is connected. * The graph contains at least one vertex. * Edge weights are non-negative integers. * There might be multiple shortest paths, return any one of them. Implementation Details * Implement and use a Min-Heap to track and extract the minimum weight edge. * Your implementation should handle the edge cases of empty graphs and graphs with varying edge densities. * Ensure your solution efficiently handles graphs with up to 1000 vertices and 20000 edges. * Handle the case when no path exists from the source to the target by returning an empty list. Example Input ```python adjacency_list = { 0: [(1, 4), (2, 1)], 1: [(3, 1)], 2: [(1, 2), (3, 5)], 3: [] } source = 0 target = 3 ``` Expected Output ```python [0, 2, 1, 3] ```","solution":"import heapq def find_shortest_path(adjacency_list: dict, source: int, target: int) -> list: Compute the shortest path from a source node to a target node using Dijkstra\'s algorithm. Args: adjacency_list (dict): A dictionary representing adjacency list of the graph where keys are node numbers and values are lists of tuples (neighbour, weight). source (int): The starting node for the shortest path. target (int): The destination node for the shortest path. Returns: list: A list of nodes representing the shortest path from source to target. If no path exists, return an empty list. # Initialize the min-heap with the source node and distance min_heap = [(0, source)] # Map to store the shortest distance to each node distances = {source: 0} # Map to store the best path to each node predecessor = {source: None} while min_heap: current_distance, current_node = heapq.heappop(min_heap) # If we reached the target, we can reconstruct the path if current_node == target: path = [] while current_node is not None: path.append(current_node) current_node = predecessor[current_node] return path[::-1] for neighbor, weight in adjacency_list.get(current_node, []): distance = current_distance + weight # Only consider this new path if it\'s better if neighbor not in distances or distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(min_heap, (distance, neighbor)) predecessor[neighbor] = current_node # If the target was never reached, return an empty list return []"},{"question":"# Coding Assessment Question Scenario You are tasked with implementing a function to identify the most frequently occurring word in a book\'s text and return it. The text will be provided as a string. The function should ignore the case of the words and must handle punctuation marks properly. Function Specification Write a function `most_frequent_word` that performs the following: - **Parameters**: - `text` (str): The text of the book provided as a single string. - **Returns**: - A string representing the most frequently occurring word in the text. If there is a tie, return any one of the most frequently occurring words. Examples ```python def most_frequent_word(text: str) -> str: pass # Example test cases print(most_frequent_word(\\"In a village of La Mancha, the name of which I have no desire to call to mind, there lived not long since one of those gentlemen that keep a lance in the lance-rack, an old buckler, a lean hack, and a greyhound for coursing.\\")) # Expected output: \'a\' print(most_frequent_word(\\"To be, or not to be, that is the question: Whether \'tis nobler in the mind to suffer The slings and arrows of outrageous fortune, Or to take arms against a sea of troubles\\")) # Expected output: \'to\' ``` Constraints - Punctuation such as commas, periods, and apostrophes should be handled and not included in words. - The function should ignore the case of the words (i.e., \\"The\\" and \\"the\\" should be considered the same word). Requirements Focus on creating an efficient implementation that handles large volumes of text gracefully. Ensure proper handling of edge cases such as empty strings or texts with no words.","solution":"import re from collections import Counter def most_frequent_word(text: str) -> str: Returns the most frequently occurring word in the provided text. The function is case-insensitive and ignores punctuation. # Remove punctuation and convert text to lower case text = re.sub(r\'[^ws]\', \'\', text).lower() # Split text into words words = text.split() if not words: return \\"\\" # Count the frequency of each word word_counts = Counter(words) # Find the most common word most_common_word = word_counts.most_common(1)[0][0] return most_common_word"},{"question":"# Scenario You are tasked with optimizing the storage and retrieval of temperature data for various locations over a period of time. The data collected includes multiple readings per day for each location, and you need to efficiently store this data and query the highest temperature recorded for a given location over a specific date range. # Question Implement a solution to manage temperature data using a Segment Tree. Given temperature readings for various locations, you need to be able to add new readings and query the highest temperature recorded for a specific location over a specified range of dates. Requirements 1. Implement the `build_segment_tree(data: List[float], start: int, end: int) -> SegmentTreeNode` function to build a Segment Tree. 2. Implement the `update_segment_tree(tree: SegmentTreeNode, index: int, value: float)` function to update the Segment Tree with new temperature readings. 3. Implement the `range_max_query(tree: SegmentTreeNode, start_date: int, end_date: int) -> float` function to query the highest temperature over a specified date range. 4. The `data` list contains temperature readings where the index represents the date. 5. The `start_date` and `end_date` for the query are integers representing dates. Example ```python # Define temperature readings for a location with date indices data = [ 32.0, 34.5, 30.2, 35.1, 33.0, 36.4, 37.0 # daily temperatures ] # Build Segment Tree segment_tree = build_segment_tree(data, 0, len(data) - 1) # Update Segment Tree with a new reading update_segment_tree(segment_tree, 3, 38.0) # update the temperature on day 3 # Perform range maximum query max_temperature = range_max_query(segment_tree, 2, 5) # Outputs print(f\\"Max temperature from day 2 to day 5: {max_temperature}\\") ``` # Constraints and Performance - `1 <= len(data) <= 10000` - Each temperature reading is a float value within the range `[-100.0, 100.0]` - The solution should aim to efficiently handle multiple updates and range queries, achieving logarithmic or better performance for each operation.","solution":"class SegmentTreeNode: def __init__(self, start, end, max_value): self.start = start self.end = end self.max_value = max_value self.left = None self.right = None def build_segment_tree(data, start, end): if start == end: return SegmentTreeNode(start, end, data[start]) mid = (start + end) // 2 left_child = build_segment_tree(data, start, mid) right_child = build_segment_tree(data, mid + 1, end) max_value = max(left_child.max_value, right_child.max_value) root = SegmentTreeNode(start, end, max_value) root.left = left_child root.right = right_child return root def update_segment_tree(tree, index, value): if tree.start == tree.end == index: tree.max_value = value return mid = (tree.start + tree.end) // 2 if index <= mid: update_segment_tree(tree.left, index, value) else: update_segment_tree(tree.right, index, value) tree.max_value = max(tree.left.max_value, tree.right.max_value) def range_max_query(tree, start_date, end_date): if tree.start == start_date and tree.end == end_date: return tree.max_value mid = (tree.start + tree.end) // 2 if end_date <= mid: return range_max_query(tree.left, start_date, end_date) elif start_date > mid: return range_max_query(tree.right, start_date, end_date) else: left_max = range_max_query(tree.left, start_date, mid) right_max = range_max_query(tree.right, mid + 1, end_date) return max(left_max, right_max)"},{"question":"# Problem Statement: You are tasked with writing a function that finds the nth number in the Fibonacci sequence, considering the sequence starts with 0 and 1. However, you must ensure your solution handles the possibility of very large outputs efficiently. # Function Signature: ```python def nth_fibonacci(n: int) -> int: pass ``` # Input: * `n` - A non-negative integer (0 ≤ n ≤ 10^6) # Output: * Returns the nth Fibonacci number. # Constraints: * The function should handle input in the specified range efficiently. * The result can be extremely large, so use an appropriate method to handle large integers. # Examples: ```python assert nth_fibonacci(0) == 0 # The 0th fibonacci number is 0 assert nth_fibonacci(1) == 1 # The 1st fibonacci number is 1 assert nth_fibonacci(10) == 55 # The 10th fibonacci number is 55 assert nth_fibonacci(50) == 12586269025 # The 50th fibonacci number is 12586269025 assert nth_fibonacci(100) == 354224848179261915075 # The 100th fibonacci number is 354224848179261915075 ``` **Note**: Ensure your function is optimized to run in a reasonable time for the maximum input size. # Task: Write an efficient implementation of the function `nth_fibonacci` that computes the nth Fibonacci number using an optimized algorithm to handle very large values of n effectively.","solution":"def nth_fibonacci(n: int) -> int: Returns the nth Fibonacci number, optimized for very large values of n. if n == 0: return 0 elif n == 1: return 1 # Helper function to multiply two matrices def matrix_multiply(A, B): return [ [A[0][0] * B[0][0] + A[0][1] * B[1][0], A[0][0] * B[0][1] + A[0][1] * B[1][1]], [A[1][0] * B[0][0] + A[1][1] * B[1][0], A[1][0] * B[0][1] + A[1][1] * B[1][1]] ] # Helper function to raise a matrix to the power of n def matrix_power(matrix, power): result = [[1, 0], [0, 1]] # Identity matrix base = matrix while power > 0: if power % 2 == 1: result = matrix_multiply(result, base) base = matrix_multiply(base, base) power //= 2 return result # Initial transformation matrix transformation_matrix = [[1, 1], [1, 0]] # Calculate the (n-1)th power of the transformation matrix result_matrix = matrix_power(transformation_matrix, n - 1) # The nth Fibonacci number is stored at result_matrix[0][0] return result_matrix[0][0]"},{"question":"# Coding Question: Advanced Array Rotation In data analysis, rotating data sets is a routine operation. You are required to handle large arrays of data where performance optimization is crucial. Implement an array rotation function that efficiently rotates the array either to the left or to the right based on input. Task: Write a function that rotates a given list to the left or the right by a specified number of steps. Ensure the function handles both large lists and large number of rotations efficiently. Requirements: 1. **Input**: - A list of integers `data`. - An integer `steps`: the number of steps to rotate the array. A positive value indicates a right rotation, while a negative value indicates a left rotation. 2. **Output**: - A new list which is rotated accordingly. Constraints: - The list length (n) is between 1 and 10^6. - Each element in the list is an integer within the range of -10^9 to 10^9. - The value for `steps` can be within the range of -10^9 to 10^9. Example: ```python >>> rotate_array([1, 2, 3, 4, 5], 2) [4, 5, 1, 2, 3] >>> rotate_array([1, 2, 3, 4, 5], -2) [3, 4, 5, 1, 2] >>> rotate_array([1, 2, 3, 4, 5], 5) [1, 2, 3, 4, 5] >>> rotate_array([1, 2, 3, 4, 5], 7) [4, 5, 1, 2, 3] ``` # Your task: 1. Implement the function `rotate_array` which performs the described rotation efficiently. 2. Ensure the function handles large input sizes optimally. 3. Consider and handle edge cases such as empty lists, and very large or very small `steps`. **Function signature**: ```python def rotate_array(data: list, steps: int) -> list: pass ``` Note: - You should not use any built-in functions that directly solve the problem. - Provide a brief explanation of your strategy and how you optimize performance and handle edge cases.","solution":"def rotate_array(data: list, steps: int) -> list: Rotates the array to the right by the specified number of steps if steps is positive. Rotates the array to the left by the specified number of steps if steps is negative. n = len(data) if n == 0: return [] # Normalize steps to be within the range of the list length steps %= n # If steps is negative, convert left rotation to equivalent right rotation if steps < 0: steps += n # Rotate the list to the right by `steps` steps return data[-steps:] + data[:-steps]"},{"question":"# Matrix Rotation Check: Is It a Rotation? Problem Statement You are given two `n x n` matrices, `A` and `B`, where `n` is a positive integer. The goal is to determine if matrix `B` can be obtained by rotating matrix `A` (by 90, 180, or 270 degrees). Write a function `is_rotation(A: List[List[int]], B: List[List[int]]) -> bool` that determines if matrix `B` can be obtained by rotating matrix `A`. Input * `A` (List[List[int]]): A `n x n` matrix containing integers. * `B` (List[List[int]]): A `n x n` matrix containing integers. Output * Return `True` if matrix `B` can be obtained by rotating matrix `A`. * Otherwise, return `False`. Constraints * The dimensions of matrices `A` and `B` are between 1x1 and 100x100 inclusive. * Each element in the matrices is an integer in the range (-10^4) to (10^4). Examples ```python A = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] B = [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] is_rotation(A, B) -> True # Explanation: B is A rotated by 90 degrees. A = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] B = [ [9, 8, 7], [6, 5, 4], [3, 2, 1] ] is_rotation(A, B) -> False # Explanation: B cannot be obtained by rotating A. A = [ [1, 2], [3, 4] ] B = [ [4, 3], [2, 1] ] is_rotation(A, B) -> True # Explanation: B is A rotated by 180 degrees. ``` Additional Information To check for rotations efficiently, you can implement helper functions to rotate the matrix by 90, 180, and 270 degrees and then compare each result with matrix `B`. Test your implementation thoroughly against various edge cases.","solution":"from typing import List def rotate_90(matrix: List[List[int]]) -> List[List[int]]: Returns the matrix rotated by 90 degrees clockwise. return [list(row) for row in zip(*matrix[::-1])] def is_rotation(A: List[List[int]], B: List[List[int]]) -> bool: Check if matrix B is a rotation of matrix A by 90, 180, or 270 degrees. if A == B: return True for _ in range(3): A = rotate_90(A) if A == B: return True return False"},{"question":"# Coding Assessment Question You are working on a reservation system for a passenger train service. Passengers can make reservations, and you need to manage the list of reservations. Enhance the `ReservationList` class by adding two new operations: 1. `cancel_reservation(ticket_id: int) -> bool` - Cancels a reservation based on a unique ticket ID. Returns `True` if the reservation was successfully canceled; returns `False` if the ticket ID is not found. 2. `get_reservation_details(ticket_id: int) -> dict` - Retrieves the details of a reservation for a given ticket ID. Returns a dictionary with the reservation details or an empty dictionary if the ticket ID is not found. Implement the following methods with the exact signatures and constraints as shown. Expected Input and Output Formats: ```python class ReservationList: ... def cancel_reservation(self, ticket_id: int) -> bool: Cancels a reservation based on the ticket ID. >>> reservations = ReservationList() >>> reservations.add_reservation(101, \\"John Doe\\", \\"A1\\", \\"2023-05-01\\") >>> reservations.add_reservation(102, \\"Jane Smith\\", \\"A2\\", \\"2023-05-01\\") >>> reservations.cancel_reservation(101) True >>> reservations.cancel_reservation(105) False >>> def get_reservation_details(self, ticket_id: int) -> dict: Retrieves the details of a reservation by ticket ID. >>> reservations = ReservationList() >>> reservations.add_reservation(101, \\"John Doe\\", \\"A1\\", \\"2023-05-01\\") >>> reservations.get_reservation_details(101) {\'ticket_id\': 101, \'name\': \'John Doe\', \'seat\': \'A1\', \'date\': \'2023-05-01\'} >>> reservations.get_reservation_details(105) {} >>> ``` Constraints: - The list should handle arbitrary numbers of reservations. - Performance targets: - Cancelling a reservation should be O(1) if the reservation exists. - Fetching reservation details should be O(1) if the reservation exists. - Ensure that each `ticket_id` is unique and validate it upon reservation. **Scenario/Context**: You\'re responsible for ensuring the reservation system operates efficiently for passengers making and canceling train reservations on the go. You need to manage reservation lists accurately and retrieve reservation details quickly when required. Implement these functions to seamlessly integrate into the existing reservation management system.","solution":"class ReservationList: def __init__(self): self.reservations = {} def add_reservation(self, ticket_id: int, name: str, seat: str, date: str) -> bool: Adds a reservation to the system. Returns True if the reservation is added, False if the ticket_id already exists. if ticket_id in self.reservations: return False self.reservations[ticket_id] = { \'ticket_id\': ticket_id, \'name\': name, \'seat\': seat, \'date\': date } return True def cancel_reservation(self, ticket_id: int) -> bool: Cancels a reservation based on the ticket ID. Returns True if the reservation was successfully canceled; returns False if the ticket ID is not found. if ticket_id in self.reservations: del self.reservations[ticket_id] return True return False def get_reservation_details(self, ticket_id: int) -> dict: Retrieves the details of a reservation by ticket ID. Returns a dictionary with the reservation details or an empty dictionary if the ticket ID is not found. return self.reservations.get(ticket_id, {})"},{"question":"# Objective: Design a function to compute the next palindrome number greater than a given integer **n**. # Instructions: Write a function `next_palindrome(n: int) -> int` that finds and returns the smallest palindrome number greater than the given integer `n`. # Expected Input & Output Formats: - **Input**: A single integer `n` representing the base number. - Constraints: ( 1 leq n leq 10^{18} ) - The function should handle invalid inputs by raising a `ValueError` if the input is not a positive integer. - **Output**: A single integer representing the next palindrome number greater than `n`. # Performance Requirements: Ensure the function is optimized to handle large input sizes efficiently. Utilize string manipulation techniques to identify and create the next palindrome. # Example Usage: ```python def next_palindrome(n: int) -> int: Returns the next palindrome number greater than n. >>> next_palindrome(123) 131 >>> next_palindrome(99) 101 >>> next_palindrome(12321) 12421 >>> next_palindrome(-1) Traceback (most recent call last): ... ValueError: Invalid input >>> next_palindrome(15.5) Traceback (most recent call last): ... ValueError: Invalid input if not isinstance(n, int) or n < 1: raise ValueError(\\"Invalid input\\") def is_palindrome(x): s = str(x) return s == s[::-1] m = n + 1 while not is_palindrome(m): m += 1 return m if __name__ == \\"__main__\\": from doctest import testmod testmod() print(f\\"{next_palindrome(123) = }\\") ``` Ensure your new question seamlessly matches the style, complexity, and scope of the provided samples. This question tests the ability to manipulate and analyze strings effectively, similar to the first question, which leverages modular arithmetic for efficient large number calculations.","solution":"def next_palindrome(n: int) -> int: Returns the next palindrome number greater than n. :param n: A positive integer :return: The next palindrome number greater than n :raises ValueError: If the input is not a positive integer if not isinstance(n, int) or n < 1: raise ValueError(\\"Invalid input\\") def is_palindrome(x: int) -> bool: Checks if the integer x is a palindrome. s = str(x) return s == s[::-1] m = n + 1 while not is_palindrome(m): m += 1 return m"},{"question":"# Problem Description You are given a binary tree and tasked with implementing a function `longest_zigzag_path` that finds the length of the longest zigzag path in the tree. A zigzag path in a binary tree is defined as a path that alternates between left and right child nodes at each step, starting from any node. The length of a path is the number of edges in it. # Function Signature ```python def longest_zigzag_path(root: TreeNode) -> int: Returns the length of the longest zigzag path in the binary tree. Example: Given tree: 1 / 2 3 4 5 / 6 7 The longest zigzag path: 1 -> 2 -> 4 -> 6 or 1 -> 3 -> 5 -> 7 Result: 3 pass ``` # Constraints * The number of nodes in the tree is in the range [1, 10^4]. * -100 <= Node.val <= 100 * Each node has either 0, 1, or 2 children. * The given tree is a binary tree and not necessarily a binary search tree. # Requirements - Your solution should be efficient and make use of Depth-First Search (DFS) or Breadth-First Search (BFS) techniques. - Carefully manage the alternating nature of the zigzag path while traversing the tree. # Input & Output Examples 1. **Example:** - Input Tree: ``` 1 / 2 3 4 5 / 6 7 ``` - Output: 3 2. **Example:** - Input Tree: ``` 1 / 2 / 3 4 ``` - Output: 2 # Additional Information - You may assume the `TreeNode` class and helper functions for constructing the tree are already defined. - Be sure to handle edge cases such as a tree with only one node or trees with varying structures to ensure robustness. This question aims to test your ability to navigate and manipulate tree structures while applying depth-first or breadth-first search strategies to solve the problem efficiently.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def longest_zigzag_path(root: TreeNode) -> int: def dfs(node, direction, length): nonlocal max_length if not node: return max_length = max(max_length, length) if direction == \'left\': dfs(node.left, \'right\', length + 1) dfs(node.right, \'left\', 1) elif direction == \'right\': dfs(node.right, \'left\', length + 1) dfs(node.left, \'right\', 1) else: dfs(node.left, \'right\', 1) dfs(node.right, \'left\', 1) if not root: return 0 max_length = 0 dfs(root, \'\', 0) return max_length"},{"question":"# Coding Question Context: You are tasked with developing a function that processes a list of integers and identifies the subsequence with the highest sum, where each element in the subsequence must be spaced at least one position apart from the adjacent elements within the subsequence. Prompt: Given a list of integers, implement a function `max_non_adjacent_sum(nums: List[int]) -> int` that returns the highest possible sum of a subsequence where no two elements are adjacent in the original list. Input: * A list of integers `nums`. Output: * An integer representing the maximum sum of the non-adjacent subsequence. Constraints: * The list `nums` will have a length between 1 and 10^4. * Each element in `nums` will be an integer between -10^4 and 10^4. Example: ```python def max_non_adjacent_sum(nums: List[int]) -> int: pass # Example usage: print(max_non_adjacent_sum([3, 2, 5, 10, 7])) # Output: 15 print(max_non_adjacent_sum([-2, 1, 3, -4, 5])) # Output: 8 print(max_non_adjacent_sum([3, 2, 7, 10])) # Output: 13 ``` Explanation: * For the first example, the highest sum is obtained by choosing the subsequence [3, 10, 2] or [3, 10, 5], both yielding a sum of 15. * For the second example, the highest sum is from the subsequence [3, 5], resulting in 8. * For the third example, the subsequence [3, 10] yields the highest sum, which is 13. Performance: * Your solution should efficiently handle the upper constraint of list size while ensuring an optimal subsequence sum identification.","solution":"from typing import List def max_non_adjacent_sum(nums: List[int]) -> int: if not nums: return 0 incl = 0 excl = 0 for num in nums: new_excl = max(incl, excl) incl = excl + num excl = new_excl return max(incl, excl)"},{"question":"# Problem Statement You are given a list of integers representing the lengths of sticks. Your task is to write a function `find_longest_stick_sequence` that determines the longest sequence of consecutive integers that can be formed using the lengths provided. # Function Signature ```python def find_longest_stick_sequence(stick_lengths: list[int]) -> list[int]: Given a list of stick lengths (integers), return the longest sequence of consecutive integers. Args: - stick_lengths (list[int]): list of stick lengths. Returns: - list of integers representing the longest sequence of consecutive stick lengths in ascending order. Examples: >>> find_longest_stick_sequence([100, 4, 200, 1, 3, 2]) [1, 2, 3, 4] >>> find_longest_stick_sequence([1, 2, 2, 1, 3, 5, 4]) [1, 2, 3, 4, 5] >>> find_longest_stick_sequence([]) [] >>> find_longest_stick_sequence([7, 8, 3, 1, 2, 9, 10]) [7, 8, 9, 10] pass ``` # Constraints - Your function should handle input lists with up to (10^5) elements. - Elements of the list can be any integer (positive, negative, or zero). - You must aim for a solution with a time complexity no worse than (O(N)) and space complexity no worse than (O(N)). **Note**: Your implementation will be judged on both correctness and efficiency. Using a data structure such as a set for quick lookups should help achieve the desired complexity. # Requirements - Handle edge cases such as empty lists or lists with multiple identical elements appropriately. - Ensure that the sequence of consecutive integers is returned in ascending order.","solution":"def find_longest_stick_sequence(stick_lengths: list[int]) -> list[int]: Given a list of stick lengths (integers), return the longest sequence of consecutive integers. Args: - stick_lengths (list[int]): list of stick lengths. Returns: - list of integers representing the longest sequence of consecutive stick lengths in ascending order. if not stick_lengths: return [] # Use a set for quick lookup stick_set = set(stick_lengths) longest_sequence = [] for stick in stick_set: # Check if this stick could be the start of a sequence if stick - 1 not in stick_set: current_length = 1 current_stick = stick while current_stick + current_length in stick_set: current_length += 1 current_sequence = list(range(stick, stick + current_length)) if len(current_sequence) > len(longest_sequence): longest_sequence = current_sequence return longest_sequence"},{"question":"# Coding Assessment Question Task Create a function that identifies all numbers less than a given input `N` that are equal to the sum of the factorial of their digits. The function should then return the sum of these numbers. Function Signature ```python def sum_of_digit_factorials(N: int) -> int: ``` # Input - `N` (int): An integer that is the upper limit for checking the numbers. `N` will be at least 10. # Output - (int): The sum of all numbers less than `N` which are equal to the sum of the factorial of their digits. # Constraints - The input `N` will be a positive integer. # Requirements * Each digit of a number `x` should be considered independently, and the sum of the factorial of the digits should be equal to the number `x`. * The function should handle values of `N` up to a reasonable range efficiently. # Example Here is an example of how your function might be called and what the expected output would be: ```python assert sum_of_digit_factorials(50000) == 40730 ``` Explanation: - 145 is one such number: 1! + 4! + 5! = 1 + 24 + 120 = 145 - 40585 is another: 4! + 0! + 5! + 8! + 5! = 24 + 1 + 120 + 40320 + 120 = 40585 - Therefore, the sum of these numbers is 145 + 40585 = 40730 # Notes * Use Python’s built-in library for computing factorials to handle individual digit factorial calculations. * Think about optimizing the checking process to handle large values of `N` effectively.","solution":"import math def sum_of_digit_factorials(N: int) -> int: Returns the sum of all numbers less than N which are equal to the sum of the factorial of their digits. def is_digit_factorial(num): return num == sum(math.factorial(int(digit)) for digit in str(num)) return sum(num for num in range(10, N) if is_digit_factorial(num))"},{"question":"# Fibonacci Number Search Context The Fibonacci sequence is a series of numbers where each number is the sum of the two preceding ones, usually starting with 0 and 1. This sequence frequently appears in mathematics and computer science due to its natural properties and recursive nature. Problem Given an integer `n`, implement a function `fibonacci_contains(number: int, n: int) -> bool` that determines if the number `n` appears in the first `number` Fibonacci numbers. The function should return `True` if `n` is found within the generated sequence and `False` otherwise. Implementation Requirements * Generate the Fibonacci sequence up to `number` elements. * Check if the given `n` is present within the first `number` Fibonacci numbers. * The function should return a boolean value indicating the presence of `n`. Example ```python def fibonacci_contains(number: int, n: int) -> bool: # Your implementation here print(fibonacci_contains(10, 34)) # True, since 34 is in the first 10 Fibonacci numbers. print(fibonacci_contains(5, 4)) # False, since 4 is not in the first 5 Fibonacci numbers. ``` Constraints * `number` is a positive integer. * `n` is a non-negative integer. * Handle the case where `number` is very large efficiently. * Ensure that your function works correctly for edge cases like `number = 1`, `number = 2`, and `n = 0`. Additional Notes * The Fibonacci sequence starts with 0 and 1. * Optimize the function to handle reasonably large values of `number`. * Focus on readability and performance to ensure the function runs efficiently for large inputs.","solution":"def fibonacci_contains(number: int, n: int) -> bool: Determines if the number `n` appears in the first `number` Fibonacci numbers. :param number: The number of Fibonacci elements to consider. :param n: The number to look for in the Fibonacci sequence. :return: True if `n` is in the first `number` Fibonacci numbers, else False. if number <= 0: return False if n == 0: return True if number > 0 else False fibonacci_sequence = [0, 1] for i in range(2, number): next_fib = fibonacci_sequence[-1] + fibonacci_sequence[-2] fibonacci_sequence.append(next_fib) return n in fibonacci_sequence[:number]"},{"question":"# Scenario Data structures play a crucial role in organizing and managing data efficiently. One such example is arranging intervals and querying data within specific time windows, which is widely used in scheduling, monitoring systems, and event management applications. # Problem Statement You are tasked with implementing a data structure that allows inserting intervals and querying how many intervals overlap with a given time point. Specifically, you need to write a class that supports two operations: adding a time interval and querying the number of intervals overlapping with a given time. # Class Specification ```python class IntervalManager: def __init__(self): pass def add_interval(self, start: int, end: int) -> None: pass def count_overlapping_intervals(self, time: int) -> int: pass ``` # Method Descriptions 1. **`__init__()`**: Initializes the data structure. 2. **`add_interval(start: int, end: int) -> None`**: Adds a new interval with `start` and `end` times (inclusive). You can assume that `start` is always less than or equal to `end`. 3. **`count_overlapping_intervals(time: int) -> int`**: Returns the number of intervals that overlap with the given `time`. # Constraints * All time values and interval boundaries are integers within the range ([-10^6, 10^6]). * The class should handle at least (10^5) intervals efficiently. # Examples ```python manager = IntervalManager() manager.add_interval(1, 5) manager.add_interval(3, 7) manager.add_interval(4, 6) manager.add_interval(8, 10) assert manager.count_overlapping_intervals(4) == 3 assert manager.count_overlapping_intervals(6) == 2 assert manager.count_overlapping_intervals(8) == 1 assert manager.count_overlapping_intervals(2) == 1 ``` # Explanation 1. After adding intervals [1, 5], [3, 7], [4, 6], and [8, 10]: - For `time=4`, intervals [1, 5], [3, 7], and [4, 6] overlap, so the count is 3. - For `time=6`, intervals [3, 7] and [4, 6] overlap, so the count is 2. - For `time=8`, only interval [8, 10] overlaps, so the count is 1. - For `time=2`, only interval [1, 5] overlaps, so the count is 1. # Note To ensure high performance, consider using efficient data structures such as balanced binary search trees or interval trees to manage and query the intervals effectively.","solution":"class IntervalManager: def __init__(self): self.intervals = [] def add_interval(self, start: int, end: int) -> None: self.intervals.append((start, end)) def count_overlapping_intervals(self, time: int) -> int: count = 0 for start, end in self.intervals: if start <= time <= end: count += 1 return count"},{"question":"# Question: Efficient String Reversal You are tasked with writing a function that efficiently reverses a string. The function should be capable of handling both small and large inputs and should have a consideration for performance and memory usage. **Objective**: Implement a function that takes a string as input and returns the reversed string. **Function Signature**: ```python def efficient_string_reversal(s: str) -> str: pass ``` # Input: - `s` (str): A string consisting of alphanumeric characters and punctuation marks. # Output: - Returns a string which is the reverse of the input string `s`. # Constraints: - The length of the input string `s` can be up to 10^6 characters. - The reversal of the string should be done in O(n) time complexity and use O(n) space complexity where n is the length of the string. # Performance Requirements: - Ensure the function handles edge cases such as empty strings and single-character strings. # Example Scenarios 1. Reversing a regular string: ```python assert efficient_string_reversal(\\"hello\\") == \\"olleh\\" ``` 2. Handling an empty string: ```python assert efficient_string_reversal(\\"\\") == \\"\\" ``` 3. Reversing a string with punctuation: ```python assert efficient_string_reversal(\\"hello!\\") == \\"!olleh\\" ``` # Specific Challenge: The function should demonstrate efficiency in its implementation, particularly for very large strings up to 10^6 characters. Ensure that it runs within the specified constraints without running into performance issues. Implement the `efficient_string_reversal` function to cover these points.","solution":"def efficient_string_reversal(s: str) -> str: Returns the reversed string of the input string s. return s[::-1]"},{"question":"# Coding Challenge Context: You are given a problem involving string manipulation where you need to reorganize the letters of a given word. Objective: Write a function `reorganize_string(s: str) -> str` that takes a single string input ( s ), which contains only lowercase English letters, and returns a new string where no two adjacent characters are the same. If it is not possible to reorganize the string in such a way, return an empty string. Input: The input will be a single string ( s ) where ( 1 leq |s| leq 10^4 ). Output: The output should be a single string meeting the specified condition or an empty string if the reorganization is not possible. Constraints: - The function should handle edge cases such as strings of length 1. - The solution must consider efficient handling of string manipulation for large input sizes up to 10,000 characters. Examples: ```python >>> reorganize_string(\\"aab\\") \\"aba\\" >>> reorganize_string(\\"aaab\\") \\"\\" >>> reorganize_string(\\"abcabc\\") \\"abcabc\\" or \\"acbacb\\" >>> reorganize_string(\\"aaabbbcccc\\") \\"abcabcabcc\\" or any valid reorganization ``` Performance Requirement: While the provided range of the string length is reasonably large, ensure that your approach remains efficient and runs within acceptable time limits for the upper constraints. Good luck!","solution":"import heapq from collections import Counter def reorganize_string(s: str) -> str: Reorganizes the input string such that no two adjacent characters are the same. If not possible, returns an empty string. # Count frequency of each character freq = Counter(s) # Create a max heap based on the character frequency max_heap = [(-count, char) for char, count in freq.items()] heapq.heapify(max_heap) previous_char = None previous_count = 0 result = [] while max_heap: count, char = heapq.heappop(max_heap) result.append(char) # Decrement previous character count and push back if it still has count left if previous_char and previous_count < 0: heapq.heappush(max_heap, (previous_count, previous_char)) # Current character goes out and prepares for the next one previous_char = char previous_count = count + 1 # decrement count since Python heapq is a min-heap # If the reorganized string is the same length as the input, return it; otherwise, return empty string return \'\'.join(result) if len(result) == len(s) else \\"\\""},{"question":"# Question: Circular String Rotation Scenario: String manipulation is a common task in programming, often requiring efficient operations for shifts and rotations. One interesting scenario involves rotating a string circularly in either the leftward or rightward direction by a specified number of positions. Task: Write a function `circular_rotate_string(s: str, k: int, direction: str) -> str` that circularly rotates the given string `s` by `k` positions in the specified direction (`\'left\'` or `\'right\'`) and returns the resulting string. Function Specifications: 1. `circular_rotate_string(s: str, k: int, direction: str) -> str` - **Input**: - `s`: a string consisting of lowercase or uppercase letters. - `k`: a non-negative integer representing the number of positions to rotate. - `direction`: a string indicating the direction of rotation (`\'left\'` or `\'right\'`). - **Output**: A string representing the input string after circular rotation. Examples: ```python >>> print(circular_rotate_string(\\"abcdef\\", 1, \\"left\\")) \\"bcdefa\\" >>> print(circular_rotate_string(\\"abcdef\\", 2, \\"left\\")) \\"cdefab\\" >>> print(circular_rotate_string(\\"abcdef\\", 1, \\"right\\")) \\"fabcde\\" >>> print(circular_rotate_string(\\"abcdef\\", 3, \\"right\\")) \\"defabc\\" >>> print(circular_rotate_string(\\"rotation\\", 4, \\"left\\")) \\"ationrot\\" >>> print(circular_rotate_string(\\"rotation\\", 2, \\"right\\")) \\"onrotati\\" ``` Constraints: - The function must handle cases where `k` is larger than the length of the string by using modulo operation to reduce redundant rotations. - The function should efficiently handle strings of varying lengths (from 1 to 1000 characters). Performance Requirements: - The solution must run in linear time O(n), where n is the length of the string, and use constant additional space O(1).","solution":"def circular_rotate_string(s: str, k: int, direction: str) -> str: Rotates the string s circularly by k positions in the specified direction. :param s: The input string :param k: Number of positions to rotate :param direction: The direction of rotation (\'left\' or \'right\') :return: The resulting string after rotation if not s: return s n = len(s) k = k % n # Reduce k to be within the bounds of the string length if direction == \'left\': return s[k:] + s[:k] elif direction == \'right\': return s[-k:] + s[:-k] else: raise ValueError(\\"direction should be \'left\' or \'right\'\\")"},{"question":"# Problem Statement **Implement a Basic Public Key Cryptography System** In this problem, you are required to implement a simplified version of the RSA algorithm, a widely-used asymmetric cryptographic system. Your function will generate a pair of public and private keys, and then use these keys to encrypt and decrypt a given message. # Requirements 1. **Function Signature**: ```python def generate_keys(p, q): Arguments: p -- A prime number q -- A prime number Returns: public_key -- A tuple (e, n) private_key -- A tuple (d, n) def encrypt(public_key, plaintext): Arguments: public_key -- A tuple (e, n): The public key plaintext -- A string of upto 50 characters Returns: ciphertext -- An integer representing the encrypted message. def decrypt(private_key, ciphertext): Arguments: private_key -- A tuple (d, n): The private key ciphertext -- An integer representing the encrypted message. Returns: plaintext -- A string representing the decrypted message. ``` 2. **Input Format**: - `p` and `q`: Two prime numbers used for key generation in `generate_keys`. - `public_key`: A tuple `(e, n)` generated from `generate_keys`. - `private_key`: A tuple `(d, n)` generated from `generate_keys`. - `plaintext`: A string of maximum length 50 characters to be encrypted. - `ciphertext`: An integer representing the encrypted message to be decrypted. 3. **Output Format**: - `public_key`: A tuple `(e, n)` representing the public key. - `private_key`: A tuple `(d, n)` representing the private key. - `ciphertext`: An integer representing the encrypted message. - `plaintext`: A string representing the decrypted message. 4. **Constraints**: - `p` and `q` will both be prime numbers. - The plaintext message will be a string of at most 50 characters. - Utilize function definitions such as `gcd` and modular arithmetic functions as needed. 5. **Performance Requirements**: - Ensure that key generation, encryption, and decryption are efficient. - Handle edge cases gracefully, such as invalid inputs or empty messages. # Example ```python # Example usage p = 61 # Example prime number q = 53 # Example prime number public_key, private_key = generate_keys(p, q) message = \\"Hello RSA!\\" ciphertext = encrypt(public_key, message) print(ciphertext) # Display the encrypted message as an integer decrypted_message = decrypt(private_key, ciphertext) print(decrypted_message) # Expected output: \\"Hello RSA!\\" ``` # Notes * Ensure the `generate_keys` function includes the generation of `n`, `e`, `d` values correctly based on the RSA algorithm. * You may consider helper functions for calculating gcd, modular exponentiation, and other necessary arithmetic operations. * Include appropriate error handling and validation for edge cases, such as checking if `p` and `q` are prime.","solution":"import random def gcd(a, b): while b: a, b = b, a % b return a def modinv(a, m): m0, x0, x1 = m, 0, 1 if m == 1: return 0 while a > 1: q = a // m m, a = a % m, m x0, x1 = x1 - q * x0, x0 if x1 < 0: x1 += m0 return x1 def is_prime(num): if num <= 1: return False if num <= 3: return True if num % 2 == 0 or num % 3 == 0: return False i = 5 while i * i <= num: if num % i == 0 or num % (i + 2) == 0: return False i += 6 return True def generate_keys(p, q): if not (is_prime(p) and is_prime(q)): raise ValueError(\\"Both numbers must be prime.\\") elif p == q: raise ValueError(\\"p and q cannot be the same\\") n = p * q phi = (p - 1) * (q - 1) e = random.randrange(1, phi) g = gcd(e, phi) while g != 1: e = random.randrange(1, phi) g = gcd(e, phi) d = modinv(e, phi) return (e, n), (d, n) def encrypt(public_key, plaintext): e, n = public_key plaintext_integers = [ord(char) for char in plaintext] ciphertext = [pow(m, e, n) for m in plaintext_integers] return ciphertext def decrypt(private_key, ciphertext): d, n = private_key decrypted_integers = [pow(c, d, n) for c in ciphertext] plaintext = \'\'.join([chr(m) for m in decrypted_integers]) return plaintext"},{"question":"# Question You are given a function to process text files containing lists of names. Your task is to develop a function that reads a given text file, processes the list of names, and outputs a sorted, case-insensitive, unique list of names. Additionally, you need to implement a feature to filter names based on a given prefix. # Function Specification **Task**: * Write a function `process_names` that will read the names from a file, process the list to ensure all names are unique and sorted in a case-insensitive manner. * Furthermore, write another function `filter_names` that filters the processed list of names based on a given prefix. **Functions to Implement**: ```python def process_names(file_path: str) -> list[str]: pass def filter_names(names: list[str], prefix: str) -> list[str]: pass ``` **Parameters**: * `process_names`: * `file_path` (str): The path to the input text file containing the list of names. * `filter_names`: * `names` (list[str]): The list of processed names from `process_names`. * `prefix` (str): The prefix to filter names by. **Returns**: * `process_names` returns a list of case-insensitive, unique names sorted alphabetically. * `filter_names` returns a list of names filtered by the given prefix. # Constraints: * The function should handle large files efficiently. * Assume the text file always contains valid names. * Use external libraries if necessary to assist with file handling and string processing. # Examples: Assuming `file_path` is the path to \\"names.txt\\", ```python # Process names from file processed_names = process_names(\\"data/names.txt\\") # Filter names by prefix \'Jo\' filtered_names = filter_names(processed_names, \\"Jo\\") ``` # Implementation Notes: * For `process_names`, read the file, remove duplicate names, and sort them in a case-insensitive manner. * For `filter_names`, filter the given list of names using the provided prefix, considering case-insensitivity. # Performance Considerations: * Utilize built-in Python set operations to remove duplicates. * Ensure efficient file reading for large files using buffered reading. * Optimize the sorting algorithm for better performance with large lists. # Assumptions: * The `names.txt` file contains one name per line. * Names can include spaces but should be stripped of leading and trailing whitespace. * The returned list of names should not contain duplicates and should be sorted in a case-insensitive way.","solution":"def process_names(file_path: str) -> list[str]: Reads a text file containing a list of names, processes the list to ensure all names are unique and sorted in a case-insensitive manner. :param file_path: Path to the input text file containing the list of names. :return: A sorted list of unique names (case-insensitive). unique_names = set() with open(file_path, \'r\') as file: for line in file: line = line.strip() if line: unique_names.add(line.lower()) sorted_names = sorted(unique_names, key=lambda x: x.lower()) return sorted_names def filter_names(names: list[str], prefix: str) -> list[str]: Filters the processed list of names based on the given prefix. :param names: The list of processed names. :param prefix: The prefix to filter names by. :return: A list of names filtered by the given prefix (case-insensitive). prefix = prefix.lower() filtered_names = [name for name in names if name.startswith(prefix)] return filtered_names"},{"question":"# Coding Question: Sorting with Custom Criteria **Context**: You are developing a sorting functionality for an online store\'s inventory. The inventory contains items with various attributes, and you need to sort the items based on a custom criterion specified by the store manager. The criterion requires sorting items primarily by their price in ascending order, and if two items have the same price, then by their rating in descending order. **Task**: Implement a function: 1. `sort_inventory(items: List[Dict[str, Union[str, float]]]) -> List[Dict[str, Union[str, float]]]` The function should take a list of dictionaries and return a sorted list based on the given criterion. **Constraints**: - Each dictionary in the list has the following structure: ```python { \\"name\\": str, # The name of the item \\"price\\": float, # The price of the item \\"rating\\": float # The rating of the item } ``` - The list of items can have a length between 1 and 1000. - The \\"price\\" of each item will be a non-negative number. - The \\"rating\\" of each item will be between 0.0 and 5.0 inclusive. - The returned list must maintain the relative order of equal elements as per the secondary sorting key when appropriate. **Examples**: ```python items = [ {\\"name\\": \\"item1\\", \\"price\\": 20.0, \\"rating\\": 4.5}, {\\"name\\": \\"item2\\", \\"price\\": 15.0, \\"rating\\": 4.7}, {\\"name\\": \\"item3\\", \\"price\\": 15.0, \\"rating\\": 4.8}, {\\"name\\": \\"item4\\", \\"price\\": 25.0, \\"rating\\": 4.2} ] sorted_items = sort_inventory(items) assert sorted_items == [ {\\"name\\": \\"item3\\", \\"price\\": 15.0, \\"rating\\": 4.8}, {\\"name\\": \\"item2\\", \\"price\\": 15.0, \\"rating\\": 4.7}, {\\"name\\": \\"item1\\", \\"price\\": 20.0, \\"rating\\": 4.5}, {\\"name\\": \\"item4\\", \\"price\\": 25.0, \\"rating\\": 4.2} ] ``` Use the following guidelines to implement and test your function: - Ensure the items are sorted primarily by `price` in ascending order. - Ensure items with the same `price` are sorted by `rating` in descending order. - Validate that your function handles edge cases, such as an empty list or lists with items having similar attributes. Implement the function `sort_inventory` according to these requirements, ensuring the output matches the expected sorted order for the provided examples. ```python def sort_inventory(items): # Your code here ```","solution":"from typing import List, Dict, Union def sort_inventory(items: List[Dict[str, Union[str, float]]]) -> List[Dict[str, Union[str, float]]]: Sorts a list of items based on price in ascending order, if two items have the same price then by rating in descending order. return sorted(items, key=lambda x: (x[\'price\'], -x[\'rating\']))"},{"question":"Problem Statement You are tasked with implementing a function that counts the occurrences of unique elements in an integer list and returns a dictionary representing the frequency of each element. This function specifically focuses on handling large datasets efficiently. Design a function `count_elements(arr: List[int]) -> Dict[int, int]` that meets the following criteria: * Takes a list of integers as input. * Returns a dictionary where keys are the unique elements from the input list and values are the corresponding counts of those elements. # Input * A list of integers where the length of the list is in the range 1 to 10^5. # Output * A dictionary that maps each unique integer from the input list to its count. # Constraints * Handle the input list efficiently to ensure optimal performance even with upper limit constraints. * Elements can be positive, negative, or zero. # Example Input: ```python arr = [1, 2, 2, 3, 3, 3, 4, 4, 4, 4] ``` Output: ```python {1: 1, 2: 2, 3: 3, 4: 4} ``` Explanation: - The number 1 appears once. - The number 2 appears twice. - The number 3 appears thrice. - The number 4 appears four times. Input: ```python arr = [0, 0, 1, -1, -1, -1] ``` Output: ```python {0: 2, 1: 1, -1: 3} ``` Explanation: - The number 0 appears twice. - The number 1 appears once. - The number -1 appears three times. # Additional Requirements * Aim to achieve an O(n) time complexity and O(n) space complexity where n is the number of elements in the input list.","solution":"from typing import List, Dict def count_elements(arr: List[int]) -> Dict[int, int]: Counts the frequency of each unique element in the input list. Parameters: arr (List[int]): List of integers. Returns: Dict[int, int]: Dictionary with unique elements as keys and their counts as values. frequency_dict = {} for num in arr: if num in frequency_dict: frequency_dict[num] += 1 else: frequency_dict[num] = 1 return frequency_dict"},{"question":"# Problem Statement You are required to implement a simplified version of a hash table with a chaining mechanism to handle collisions. This hash table should support basic operations: insert, delete, and search. Your task is to ensure the efficiency and correctness of the hash table operations. # Task 1. Implement the `HashTable` class with necessary methods to perform insert, delete, and search operations. 2. Utilize separate chaining to resolve collisions. 3. Ensure all hash table operations are robust by testing various edge cases. # Requirements - Implement the `HashTable` class with appropriate data structures for the chaining mechanism. - Ensure the `insert`, `delete`, and `search` methods function correctly. - Validate functionality with provided sample inputs. # Example Cases Here are some cases demonstrating the expected behavior of your hash table: ```python ht = HashTable(10) ht.insert(12, \\"Alice\\") ht.insert(22, \\"Bob\\") ht.insert(32, \\"Charlie\\") assert ht.search(12) == \\"Alice\\" assert ht.search(22) == \\"Bob\\" assert ht.search(32) == \\"Charlie\\" assert ht.search(42) == None ht.delete(22) assert ht.search(22) == None ht.insert(22, \\"Dan\\") assert ht.search(22) == \\"Dan\\" ``` You need to implement the `HashTable` class in the provided code to meet the above requirements. # Expected Function Signatures ```python class HashTable: def __init__(self, size: int) -> None: ... def insert(self, key: int, value: str) -> None: ... def delete(self, key: int) -> None: ... def search(self, key: int) -> str | None: ... ``` # Constraints - Handle integer keys and string values. - Focus on code efficiency and handle potential edge cases robustly. - Assume that the hash table size will be provided during initialization and will be a positive integer.","solution":"class HashTable: def __init__(self, size: int) -> None: Initialize the hash table with the given size. Each bucket in the hash table will contain a list for separate chaining. self.size = size self.table = [[] for _ in range(size)] def _hash(self, key: int) -> int: Compute the hash value for a given key. return key % self.size def insert(self, key: int, value: str) -> None: Insert a key-value pair into the hash table. hash_index = self._hash(key) # Check if the key already exists in the bucket and update its value if it does for pair in self.table[hash_index]: if pair[0] == key: pair[1] = value return # If the key does not exist, append the new key-value pair self.table[hash_index].append([key, value]) def delete(self, key: int) -> None: Delete a key-value pair from the hash table. hash_index = self._hash(key) for pair in self.table[hash_index]: if pair[0] == key: self.table[hash_index].remove(pair) return def search(self, key: int) -> str | None: Search for a value by key in the hash table. hash_index = self._hash(key) for pair in self.table[hash_index]: if pair[0] == key: return pair[1] return None"},{"question":"# Problem Statement Given a list of integers and an integer `k`, your task is to write a function that determines whether there are two distinct indices `i` and `j` in the list such that the absolute difference between `nums[i]` and `nums[j]` is at most `k` and the difference between `i` and `j` is at most `t`. # Function Signature ```python def contains_nearby_almost_duplicate(nums: List[int], k: int, t: int) -> bool: ``` # Input * `nums` (List[int]): A list of integers. * `k` (int): An integer representing the maximum difference in indices allowed. * `t` (int): An integer representing the maximum absolute difference allowed between two elements. # Output * Returns `True` if the condition is met, otherwise `False`. # Constraints * The number of elements in `nums` will be in the range `[0, 10^4]`. * The value of elements in `nums` will be in the range `[-2^31, 2^31 - 1]`. * `0 <= k <= 10^4` * `0 <= t <= 2^31 - 1` # Example ```python nums = [1, 2, 3, 1] k = 3 t = 0 print(contains_nearby_almost_duplicate(nums, k, t)) # Output: True nums = [1, 0, 1, 1] k = 1 t = 2 print(contains_nearby_almost_duplicate(nums, k, t)) # Output: True nums = [1, 5, 9, 1, 5, 9] k = 2 t = 3 print(contains_nearby_almost_duplicate(nums, k, t)) # Output: False ``` # Additional Information: * Consider edge cases where `nums` is empty or contains only one element. * Make sure your function handles large values and large differences efficiently.","solution":"from typing import List import bisect def contains_nearby_almost_duplicate(nums: List[int], k: int, t: int) -> bool: if t < 0 or k < 0: return False sorted_list = [] for i in range(len(nums)): # We maintain a sorted window of size k if i > k: # Remove the element that is out of the current sliding window sorted_list.remove(nums[i - k - 1]) # Find the proper insertion point for nums[i] in sorted_list pos = bisect.bisect_left(sorted_list, nums[i]) # Check against the smallest greater or equal element if pos < len(sorted_list) and sorted_list[pos] - nums[i] <= t: return True # Check against the largest smaller element if pos > 0 and nums[i] - sorted_list[pos - 1] <= t: return True # Insert nums[i] into the sorted list maintaining the sorted property bisect.insort(sorted_list, nums[i]) return False"},{"question":"# Problem Statement You are given an N-ary tree representing a filesystem, where each node represents a directory. Each directory may contain zero or more subdirectories. The root of the tree represents the root directory of the filesystem. Your task is to implement a function `max_depth(root: \'Node\') -> int` to find the maximum depth of the given filesystem. The maximum depth is defined as the length of the longest path from the root directory to any leaf directory in the system. # Function Signature ```python class Node: def __init__(self, name: str, subdirectories: list[\'Node\']): self.name = name self.subdirectories = subdirectories def max_depth(root: Node) -> int: pass ``` # Input * `root`: The root node of the N-ary tree representing the filesystem. Each node is an instance of the `Node` class. # Output * An integer representing the maximum depth of the filesystem. # Constraints * Each node has a unique name. * The number of nodes in the tree may be up to 10^4. * The depth of the tree may be as large as 10^3. # Example ```python root = Node(\\"root\\", [ Node(\\"sub1\\", [ Node(\\"sub1_1\\", []), Node(\\"sub1_2\\", [ Node(\\"sub1_2_1\\", []) ]) ]), Node(\\"sub2\\", []) ]) print(max_depth(root)) # Output: 3 root2 = Node(\\"root\\", [ Node(\\"sub1\\", [ Node(\\"sub1_1\\", [ Node(\\"sub1_1_1\\", []), Node(\\"sub1_1_2\\", []) ]) ]), Node(\\"sub2\\", [ Node(\\"sub2_1\\", []), Node(\\"sub2_2\\", [ Node(\\"sub2_2_1\\", [ Node(\\"sub2_2_1_1\\", []) ]) ]) ]) ]) print(max_depth(root2)) # Output: 4 ``` # Note You can assume that the filesystem tree is well-formed and that there are no cycles in the tree structure. Your implementation should handle large trees efficiently and return results within a reasonable time frame. Pay attention to the balance between readability and performance, ensuring that your solution is both understandable and optimal.","solution":"class Node: def __init__(self, name: str, subdirectories: list = None): self.name = name self.subdirectories = subdirectories if subdirectories is not None else [] def max_depth(root: Node) -> int: if not root: return 0 if not root.subdirectories: return 1 return 1 + max(max_depth(subdir) for subdir in root.subdirectories)"},{"question":"# Problem Statement Create a function that, given a string, identifies the most frequently occurring character and the length of its consecutive appearances. If there are multiple characters with the same frequency, return the one that appears first lexicographically. # Requirements 1. Implement the function `max_consecutive_char_info(s: str) -> Tuple[str, int]`. 2. The function should raise an exception if the string is empty. 3. The function should return a tuple where: - The first element is the character with the highest frequency of consecutive appearances. - The second element is the length of its consecutive appearances. 4. Optimize for performance where possible. # Input - A single string `s` of length (1 leq |s| leq 10^6). # Output - A tuple consisting of: - A character, which is the most frequently occurring character in consecutive sequences. - An integer representing the length of the longest sequence of consecutive appearances of that character. # Example ```python >>> max_consecutive_char_info(\\"aaabbcccd\\") (\'a\', 3) >>> max_consecutive_char_info(\\"fffeeeedddccc\\") (\'e\', 4) >>> max_consecutive_char_info(\\"xyz\\") (\'x\', 1) >>> max_consecutive_char_info(\\"aabbbccdddd\\") (\'d\', 4) ``` # Constraints - Ensure the solution is efficient and can handle the maximum input size within a reasonable time.","solution":"from typing import Tuple def max_consecutive_char_info(s: str) -> Tuple[str, int]: if not s: raise ValueError(\\"Input string must not be empty\\") max_char = s[0] max_count = 1 current_char = s[0] current_count = 1 for i in range(1, len(s)): if s[i] == current_char: current_count += 1 else: if current_count > max_count or (current_count == max_count and current_char < max_char): max_char = current_char max_count = current_count current_char = s[i] current_count = 1 if current_count > max_count or (current_count == max_count and current_char < max_char): max_char = current_char max_count = current_count return max_char, max_count"},{"question":"# Finding the Kth Smallest Element in a Matrix You are given a class `Matrix` that represents a two-dimensional grid of integers with various functionalities, including adding elements, retrieving elements, and computing properties based on the grid. Your task is to extend this class to support finding the kth smallest element efficiently. # Problem Statement Implement the method `find_kth_smallest` in the `Matrix` class to find the kth smallest element in the matrix. # Constraints 1. The matrix is guaranteed to be square and sorted in non-decreasing order in both rows and columns. 2. 1 <= number of rows/columns <= 50 3. -10^4 <= element in matrix <= 10^4 4. 1 <= k <= (number of rows * number of columns) # Input Format ```plaintext - An integer k, representing the position of the smallest element to find. ``` # Output Format ```plaintext - The kth smallest element in the matrix. ``` # Example ```python rows = [ [1, 5, 9], [10, 11, 13], [12, 13, 15] ] matrix = Matrix(rows) result = matrix.find_kth_smallest(8) print(result) # Output should be: # 13 ``` # Implementation Extend the `Matrix` class with the `find_kth_smallest` method. Complete the `find_kth_smallest` method in the following manner: 1. Utilize an efficient algorithm, such as the min-heap or binary search on matrix elements, to find the kth smallest element. 2. Return the kth smallest element as an integer. ```python import heapq class Matrix: def __init__(self, rows: List[List[int]]): self.rows = rows # Other methods def find_kth_smallest(self, k: int) -> int: n = len(self.rows) min_heap = [(self.rows[r][0], r, 0) for r in range(n)] heapq.heapify(min_heap) for _ in range(k - 1): element, r, c = heapq.heappop(min_heap) if c + 1 < n: heapq.heappush(min_heap, (self.rows[r][c + 1], r, c + 1)) return min_heap[0][0] ``` # Notes 1. Ensure the method is efficient and handles the constraints effectively. 2. Consider edge cases, such as when k is the minimum or maximum possible value within the matrix.","solution":"import heapq from typing import List class Matrix: def __init__(self, rows: List[List[int]]): self.rows = rows def find_kth_smallest(self, k: int) -> int: n = len(self.rows) min_heap = [(self.rows[r][0], r, 0) for r in range(n)] heapq.heapify(min_heap) for _ in range(k - 1): element, r, c = heapq.heappop(min_heap) if c + 1 < n: heapq.heappush(min_heap, (self.rows[r][c + 1], r, c + 1)) return heapq.heappop(min_heap)[0]"},{"question":"# Fibonacci Series Modification Problem Statement: Write a function `modified_fibonacci` that returns a list of the first `n` terms of a modified Fibonacci sequence. In this sequence, each term is the sum of the previous term and the term before the previous term, but with the initial two terms given as `a` and `b` respectively. Input: - An integer `n` (2 ≤ n ≤ 1000), representing the number of terms to generate in the sequence. - Two integers `a` and `b` (-10^6 ≤ a, b ≤ 10^6), representing the first two terms of the sequence. Output: - A list of the first `n` terms of the modified Fibonacci sequence starting with `a` and `b`. Constraints: - Ensure the solution is efficient and able to handle the upper limits of the input size. Example: **Input:** ```python 5, 2, 3 ``` **Output:** ```python [2, 3, 5, 8, 13] ``` Notes: - The function should account for both positive and negative initial values for `a` and `b`. - Handle edge cases such as the minimum value of `n` being 2.","solution":"def modified_fibonacci(n, a, b): Generates a list of the first `n` terms of a modified Fibonacci sequence starting with `a` and `b`. sequence = [a, b] for i in range(2, n): next_term = sequence[-1] + sequence[-2] sequence.append(next_term) return sequence # Example usage: # print(modified_fibonacci(5, 2, 3)) # Output: [2, 3, 5, 8, 13]"},{"question":"# Problem Statement You are given a list of integers representing the heights of buildings. Your task is to write a function, `max_sunlight_exposure`, that computes the longest sequence of buildings that receive sunlight. A building receives sunlight if it is taller than any of the buildings before it. # Function Signature ```python def max_sunlight_exposure(heights: list[int]) -> int: ``` # Input - `heights`: List of integers representing the heights of buildings. Length of the list (n) will be between 0 and 10^5 inclusive. # Output - Returns an integer representing the maximum number of consecutive buildings that receive sunlight. # Examples ```python assert max_sunlight_exposure([3, 1, 4, 7, 5]) == 3 assert max_sunlight_exposure([6, 5, 4, 3, 2, 1]) == 1 assert max_sunlight_exposure([1, 2, 3, 4, 5]) == 5 assert max_sunlight_exposure([10]) == 1 assert max_sunlight_exposure([]) == 0 ``` # Constraints & Notes - If the list is empty, the result should be 0. - Ensure to handle the cases where heights are strictly increasing or strictly decreasing. - Aim for an efficient solution with a time complexity of O(n). # Explanation - In the first example, the heights of the buildings are [3, 1, 4, 7, 5]. The tallest sequence that receives sunlight is [3, 4, 7]. - In the second example, all the buildings\' heights are decreasing, so only the first building receives sunlight. - In the third example, the buildings\' heights are strictly increasing, so all 5 buildings receive sunlight.","solution":"def max_sunlight_exposure(heights) -> int: Returns the maximum number of consecutive buildings that receive sunlight. A building receives sunlight if it is taller than any of the buildings before it. if not heights: return 0 max_exposure = 1 current_height = heights[0] for height in heights[1:]: if height > current_height: max_exposure += 1 current_height = height return max_exposure"},{"question":"# Context: Imagine you are developing a simple inventory tracking system for a small store. The store needs to manage its inventory of items, each with a unique identifier, name, and quantity. Your task is to implement a class that can add new items, update the quantity of existing items, and return the total quantity of all items in the inventory. # Objective: Write a class `Inventory` with methods to add items, update quantities, and calculate the total quantity of items. # Input: - Method calls to the `Inventory` class. # Output: - The methods will perform updates on the inventory and return the total quantity when requested. # Constraints: - Each item in the inventory is identified by a unique string identifier. - The quantity of any item is a non-negative integer. # Class Signature: ```python class Inventory: def __init__(self): # Initializes an empty inventory pass def add_item(self, item_id: str, name: str, quantity: int): # Adds a new item to the inventory with the given id, name, and quantity pass def update_quantity(self, item_id: str, quantity: int): # Updates the quantity of the specified item pass def total_quantity(self) -> int: # Returns the total quantity of all items in the inventory pass ``` # Methods Explanation: 1. `add_item(self, item_id: str, name: str, quantity: int)`: - Adds a new item with the given identifier, name, and quantity to the inventory. - If the item already exists, it will update the quantity to be the sum of existing and new quantity. 2. `update_quantity(self, item_id: str, quantity: int)`: - Updates the quantity of the existing item identified by `item_id` to the given value. - If the item does not exist, it will be treated as a new item. 3. `total_quantity(self) -> int`: - Returns the cumulative quantity of all items in the inventory. # Examples: ```python inventory = Inventory() inventory.add_item(\'001\', \'apple\', 50) inventory.add_item(\'002\', \'banana\', 30) inventory.update_quantity(\'001\', 70) # Now the quantity of \'apple\' is 70 inventory.add_item(\'003\', \'orange\', 25) print(inventory.total_quantity()) # Output: 125 inventory.update_quantity(\'002\', 40) # Now the quantity of \'banana\' is 40 print(inventory.total_quantity()) # Output: 135 ``` # Notes: - Ensure that the `add_item` method can handle the case where the item already exists by summing the quantities correctly. - Provide robust handling to avoid negative quantities. Create and describe the logic used to ensure correct, efficient, and optimized performance.","solution":"class Inventory: def __init__(self): # Initializes an empty inventory self.items = {} def add_item(self, item_id: str, name: str, quantity: int): # Adds a new item to the inventory with the given id, name, and quantity if item_id in self.items: self.items[item_id][\'quantity\'] += quantity else: self.items[item_id] = {\'name\': name, \'quantity\': quantity} def update_quantity(self, item_id: str, quantity: int): # Updates the quantity of the specified item if item_id in self.items: self.items[item_id][\'quantity\'] = quantity else: self.items[item_id] = {\'name\': \'\', \'quantity\': quantity} def total_quantity(self) -> int: # Returns the total quantity of all items in the inventory return sum(item[\'quantity\'] for item in self.items.values())"},{"question":"# Problem Description You are given a `target_list` and a `sub_list`. Your task is to write a function `remove_sublist_elements` that removes all the elements in `sub_list` from `target_list`. # Input * `target_list` (list): A list of elements which could be integers, strings, or any type of elements. * `sub_list` (list): A subset of elements which could be integers, strings, or any type of elements. # Output * The function should return a list with all elements of `sub_list` removed from `target_list`. # Constraints * The input lists can consist of any type of elements. * The lengths of the lists can be different. * `sub_list` can be empty, in which case the output should be the same as `target_list`. # Example ```python >>> remove_sublist_elements([1, 2, 3, 4, 5], [2, 4]) [1, 3, 5] >>> remove_sublist_elements([\\"apple\\", \\"banana\\", \\"cherry\\"], [\\"banana\\"]) [\\"apple\\", \\"cherry\\"] >>> remove_sublist_elements([\\"a\\", \\"b\\", \\"c\\", \\"a\\"], [\\"a\\"]) [\\"b\\", \\"c\\"] >>> remove_sublist_elements([1, 2, 3], []) [1, 2, 3] ``` # Requirements * Implement the function `remove_sublist_elements` that meets the specifications. * Ensure the code passes all edge cases and efficiently handles the constraints.","solution":"def remove_sublist_elements(target_list, sub_list): Removes all elements of sub_list from target_list. Parameters: target_list (list): A list containing any type of elements. sub_list (list): A list containing any type of elements to be removed from target_list. Returns: list: A list with elements of sub_list removed from target_list. return [item for item in target_list if item not in sub_list]"},{"question":"# Task Given a string, write a Python function `longest_subsequence_without_repeat(s: str) -> int` to find the length of the longest subsequence (not necessarily contiguous) in the string that does not contain any repeating characters. # Function Signature ```python def longest_subsequence_without_repeat(s: str) -> int: pass ``` # Input * **s**: A string ( s ) consisting of lowercase English letters (1 ≤ |s| ≤ 10,000). # Output * Returns the length of the longest subsequence in the string that does not contain any repeating characters. # Constraints * The function should efficiently handle the upper limit of ( s ). # Example Consider ( s = \\"abcabcbb\\"). The longest subsequence without repeating characters can be \\"abc\\" or \\"acb\\" or \\"bac\\", etc. Therefore, the function should return 3. ```python >>> longest_subsequence_without_repeat(\\"abcabcbb\\") 3 ``` # Note Make sure to account for cases where the input string may include all unique characters or have high levels of repetition.","solution":"def longest_subsequence_without_repeat(s: str) -> int: Returns the length of the longest subsequence of s that does not contain any repeating characters. # Use a set to track unique characters unique_chars = set(s) return len(unique_chars)"},{"question":"# Question: Shortest Path in a Weighted Graph You are given a weighted, directed graph with **n** vertices numbered from 0 to n-1. Each edge has a weight representing the cost or distance between the vertices it connects. You need to implement a method to calculate the shortest path from a given source vertex to a given target vertex using Dijkstra\'s Algorithm. Scenario: Package Delivery Route Imagine you are designing a package delivery system. The graph\'s vertices represent locations, and the edges represent roads with specific travel distances. Your task is to find the shortest and most efficient route from the starting location (source vertex) to the delivery destination (target vertex). # Function Signature ```python def dijkstra_shortest_path(n, edges, source, target): Computes the shortest path from source to target using Dijkstra\'s Algorithm. Parameters: n (int) : Number of vertices in the graph. edges (list of tuple): Each tuple (u, v, w) represents an edge from vertex u to vertex v with weight w. source (int): The source vertex in the graph. target (int): The target vertex in the graph. Returns: int: The shortest path value from source to target. Returns -1 if no path exists. pass ``` # Input - **n**: An integer, the number of vertices in the graph. - **edges**: A list of tuples where each tuple `(u, v, w)` indicates an edge from vertex `u` to vertex `v` with weight `w`. - **source**: An integer representing the source vertex. - **target**: An integer representing the target vertex. # Output - The function should return a single integer which is the shortest path from the source vertex to the target vertex. Return -1 if no path exists. # Example ```python # Example input n = 5 edges = [(0, 1, 10), (0, 3, 5), (1, 2, 1), (2, 4, 4), (3, 1, 2), (3, 4, 2), (4, 2, 3)] source = 0 target = 4 # Example output print(dijkstra_shortest_path(n, edges, source, target)) # Expected output: 7 ``` # Constraints 1. (2 leq n leq 5000) 2. (1 leq text{number of edges} leq 10000) 3. (0 leq u, v < n) 4. (1 leq w leq 10000) # Notes 1. Ensure to handle edge cases such as disconnected graphs and graphs with negative weight edges (not allowed). 2. You can assume that the input graph has no negative weight cycles. Implement the `dijkstra_shortest_path` function that returns the shortest path from source to target for the specified graph.","solution":"import heapq def dijkstra_shortest_path(n, edges, source, target): Computes the shortest path from source to target using Dijkstra\'s Algorithm. Parameters: n (int) : Number of vertices in the graph. edges (list of tuple): Each tuple (u, v, w) represents an edge from vertex u to vertex v with weight w. source (int): The source vertex in the graph. target (int): The target vertex in the graph. Returns: int: The shortest path value from source to target. Returns -1 if no path exists. # Create adjacency list graph = {i: [] for i in range(n)} for u, v, w in edges: graph[u].append((v, w)) # Priority queue to store (distance, node) pq = [(0, source)] # Distance dictionary to store the minimum distance to each node dist = {i: float(\'inf\') for i in range(n)} dist[source] = 0 while pq: current_distance, current_node = heapq.heappop(pq) # If we reach the target, return the distance if current_node == target: return current_distance # If the popped node\'s distance is greater than the recorded distance, skip it if current_distance > dist[current_node]: continue for neighbor, weight in graph[current_node]: distance = current_distance + weight # Only consider this new path if it\'s better if distance < dist[neighbor]: dist[neighbor] = distance heapq.heappush(pq, (distance, neighbor)) # If the target is unreachable return -1"},{"question":"# File Compression and Decompression Background You are developing a utility to compress and decompress files using a simple compression algorithm. The algorithm replaces common substrings with shorter representations to reduce the file size. Task Implement two functions, `compress` and `decompress`, that handle string compression and decompression respectively, using a predefined dictionary of common substrings and their replacements. Requirements 1. Define a dictionary named `compression_dict` that stores frequently occurring substrings as keys and their short representations as values. 2. Implement the `compress` function to replace each substring found in `compression_dict` with its corresponding short representation in a given input string. 3. Implement the `decompress` function to do the reverse transformation: replace each short representation in a given compressed string with its original substring. Function Signatures ```python def compress(input_str: str) -> str: def decompress(compressed_str: str) -> str: ``` Parameters * `input_str` (str): The input string to be compressed. * `compressed_str` (str): The compressed string to be decompressed. Constraints * Replace the substrings in the input string as per the `compression_dict` key-value pairs. * Ensure that decompression rebuilds the original string from the compressed version. * Handle case sensitivity in substrings and maintain the integrity of character sequences. * If an input string lacks any substrings from `compression_dict`, return it unchanged. * Raise appropriate errors if the strings are empty. Example Usage ```python compression_dict = { \\"the\\": \\"1\\", \\"and\\": \\"2\\", \\"compression\\": \\"3\\", \\"algorithm\\": \\"4\\" } # Compress the input string compressed_result = compress(\\"the compression algorithm and the efficiency\\") print(compressed_result) # Output: \\"1 3 4 2 1 efficiency\\" # Decompress the compressed string decompressed_result = decompress(\\"1 3 4 2 1 efficiency\\") print(decompressed_result) # Output: \\"the compression algorithm and the efficiency\\" ```","solution":"# Define the compression dictionary compression_dict = { \\"the\\": \\"1\\", \\"and\\": \\"2\\", \\"compression\\": \\"3\\", \\"algorithm\\": \\"4\\" } def compress(input_str: str) -> str: Compress the input string using the predefined compression dictionary. :param input_str: The input string to compress :return: The compressed string if not input_str: raise ValueError(\\"Input string cannot be empty\\") for k, v in compression_dict.items(): input_str = input_str.replace(k, v) return input_str def decompress(compressed_str: str) -> str: Decompress the input string using the predefined compression dictionary. :param compressed_str: The compressed string to decompress :return: The decompressed string if not compressed_str: raise ValueError(\\"Compressed string cannot be empty\\") # Reverse the compression dictionary decompression_dict = {v: k for k, v in compression_dict.items()} for k, v in decompression_dict.items(): compressed_str = compressed_str.replace(k, v) return compressed_str"},{"question":"# Scenario You are working on implementing a part of a neural network that requires a softmax activation function. The softmax function is commonly used in the output layer of a classifier to interpret the model\'s output as probabilities. # Task Implement the function `softmax(vector: np.ndarray) -> np.ndarray` to apply the softmax activation to a given input vector. # Function Signature ```python def softmax(vector: np.ndarray) -> np.ndarray: pass ``` # Input: * `vector` (np.ndarray): A 1-D numpy array representing the input scores. # Output: * Returns an ndarray containing the softmax probabilities computed from the input vector. # Constraints: * The vector will have at least one element. * Each element in the vector is a real number. # Examples: 1. Input: `vector = np.array([2.0, 1.0, 0.1])` Output: `np.array([0.65900114, 0.24243297, 0.09856589])` 2. Input: `vector = np.array([-1.0, 0.0, 1.0])` Output: `np.array([0.09003057, 0.24472847, 0.66524096])` # Note: Softmax is defined as: [ text{softmax}(x_i) = frac{e^{x_i}}{sum_{j} e^{x_j}} ] where ( x_i ) is the ( i )-th element of the input vector, and the sum is over all elements ( j ). The implementation should carefully handle numerical stability to avoid overflow and underflow during the exponential calculation. A common trick is to subtract the maximum value in the input vector from each element to stabilize the computation.","solution":"import numpy as np def softmax(vector: np.ndarray) -> np.ndarray: Compute the softmax of a vector. Args: vector (np.ndarray): A 1-D numpy array representing the input scores. Returns: np.ndarray: A 1-D numpy array containing the softmax probabilities. # Subtract the max value from the vector elements for numerical stability c = np.max(vector) exp_shifted = np.exp(vector - c) sum_exp_shifted = np.sum(exp_shifted) return exp_shifted / sum_exp_shifted"},{"question":"Write a function `min_jumps_to_end(arr: List[int]) -> int` that takes a list of positive integers, `arr`, representing the maximum you can jump forward from that position and returns the minimum number of jumps needed to reach the last index of the list. If it is not possible to reach the last index, the function should return -1. # Example ```python >>> min_jumps_to_end([6, 2, 4, 0, 5, 1, 1, 4, 2, 9]) 2 >>> min_jumps_to_end([1, 1, 1, 1, 1]) 4 >>> min_jumps_to_end([3, 2, 1, 0, 4]) -1 ``` # Constraints * The length of `arr` will always be between 1 and 10^5. * Each element of `arr` will be a non-negative integer less than or equal to 10^6. # Requirements 1. Implement the function using an efficient algorithm to calculate the minimum number of jumps. 2. Optimize for both time and space complexity to handle larger inputs effectively. 3. Handle edge cases such as: - The input list being of length 1. - Large values within `arr`. - Scenarios where the last index is not reachable. # Performance Expectations * The solution should ideally have a time complexity of O(n). * The solution should have a space complexity of O(1), excluding the input list storage. # Additional Information The list represents jumps where you can leap from the current position up to the value at that index. The goal is to find the fewest number of such jumps required to get from the start to the end of the list. If reaching the end is impossible given the jumps available, return -1.","solution":"from typing import List def min_jumps_to_end(arr: List[int]) -> int: if len(arr) == 1: return 0 if arr[0] == 0: return -1 jumps = 0 maxReach = arr[0] step = arr[0] for i in range(1, len(arr)): if i == len(arr) - 1: return jumps + 1 maxReach = max(maxReach, i + arr[i]) step -= 1 if step == 0: jumps += 1 if i >= maxReach: return -1 step = maxReach - i return -1"},{"question":"# Scenario A database manager needs a utility to calculate the nth Fibonacci number efficiently. The Fibonacci sequence starts with 0 and 1, and each subsequent number is the sum of the previous two. However, due to the size of the numbers for larger n, the calculation could be computationally intensive. You are to implement a function to compute this efficiently, possibly using memoization or an iterative approach. # Task Description Implement a function `nth_fibonacci` that takes an integer `n` and returns the nth Fibonacci number. # Function Signature ```python def nth_fibonacci(n: int) -> int: pass ``` # Input * A single integer `n` where 0 ≤ n ≤ 30. # Output * A single integer representing the nth Fibonacci number. # Constraints * The input integer `n` will be between 0 and 30 inclusive. # Example Example 1 ```python n = 0 print(nth_fibonacci(n)) # Output: 0 ``` Example 2 ```python n = 1 print(nth_fibonacci(n)) # Output: 1 ``` Example 3 ```python n = 10 print(nth_fibonacci(n)) # Output: 55 ``` Example 4 ```python n = 20 print(nth_fibonacci(n)) # Output: 6765 ``` # Notes * Your implementation should ensure efficient computation for the given range. * Consider edge cases such as Fibonacci(0) and Fibonacci(1).","solution":"def nth_fibonacci(n: int) -> int: Returns the nth Fibonacci number efficiently using an iterative approach. if n == 0: return 0 elif n == 1: return 1 a, b = 0, 1 for _ in range(2, n+1): a, b = b, a + b return b"},{"question":"# Coding Question: RGB to Hexadecimal Conversion Write a function that converts an RGB color value to its corresponding hexadecimal color code. Function Signature ```python def rgb_to_hex(r: int, g: int, b: int) -> str: pass ``` Input Parameters * `r` (int): Red component of the RGB color. Should be in the range [0, 255]. * `g` (int): Green component of the RGB color. Should be in the range [0, 255]. * `b` (int): Blue component of the RGB color. Should be in the range [0, 255]. Output * A string representing the hexadecimal color code in the format `\'#RRGGBB\'`. Constraints * All input integers (`r`, `g`, `b`) must be in the range [0, 255]. If any value is out of this range, the function should raise a `ValueError`. Doctests ```python >>> rgb_to_hex(0, 128, 255) \'#0080FF\' >>> rgb_to_hex(255, 255, 255) \'#FFFFFF\' >>> rgb_to_hex(34, 139, 34) \'#228B22\' >>> rgb_to_hex(0, 0, 0) \'#000000\' ``` The function should raise a `ValueError` for the following cases: ```python >>> rgb_to_hex(256, 100, 100) Traceback (most recent call last): ... ValueError: RGB values must be in the range [0, 255] >>> rgb_to_hex(-1, 50, 50) Traceback (most recent call last): ... ValueError: RGB values must be in the range [0, 255] >>> rgb_to_hex(100, 100, -20) Traceback (most recent call last): ... ValueError: RGB values must be in the range [0, 255] ``` Ensure your implementation converts RGB values accurately to their hexadecimal counterpart and handles error cases as specified.","solution":"def rgb_to_hex(r: int, g: int, b: int) -> str: Converts RGB values to a hexadecimal color code. Parameters: r (int): Red component (0-255) g (int): Green component (0-255) b (int): Blue component (0-255) Returns: str: Hexadecimal color code in the format \'#RRGGBB\' Raises: ValueError: If any of the input values are not in the range [0, 255]. if not(0 <= r <= 255) or not(0 <= g <= 255) or not(0 <= b <= 255): raise ValueError(\\"RGB values must be in the range [0, 255]\\") return f\\"#{r:02X}{g:02X}{b:02X}\\""},{"question":"# Problem Statement Scenario You are part of a development team working on a system that requires the conversion of integers to their Roman numeral representation. Roman numerals are represented by combinations of the following symbols: - `I`, `V`, `X`, `L`, `C`, `D`, `M` These are typically combined as follows: - `I` (1) - `IV` (4) - `V` (5) - `IX` (9) - `X` (10) - `XL` (40) - `L` (50) - `XC` (90) - `C` (100) - `CD` (400) - `D` (500) - `CM` (900) - `M` (1000) Task Write a function `int_to_roman` which takes a single positive integer as input and returns its Roman numeral representation as a string. Input Format * A single integer `num` (1 ≤ `num` ≤ 3999). Output Format * A string representing the Roman numeral equivalent of the input number. Constraints * The input will always be a positive integer within the range [1, 3999]. Example ```python int_to_roman(3) # Output: \'III\' int_to_roman(58) # Output: \'LVIII\' int_to_roman(1994) # Output: \'MCMXCIV\' int_to_roman(2021) # Output: \'MMXXI\' ``` Notes * Ensure that the Roman numeral representation follows the conventional rules and syntax. * Consider the efficiency of your solution, especially given the constraint on the maximum value.","solution":"def int_to_roman(num): Convert an integer to a Roman numeral. Args: num: An integer (1 ≤ num ≤ 3999) Returns: A string representing the Roman numeral equivalent of the input number. val = [ 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1 ] syms = [ \\"M\\", \\"CM\\", \\"D\\", \\"CD\\", \\"C\\", \\"XC\\", \\"L\\", \\"XL\\", \\"X\\", \\"IX\\", \\"V\\", \\"IV\\", \\"I\\" ] roman_num = \'\' i = 0 while num > 0: for _ in range(num // val[i]): roman_num += syms[i] num -= val[i] i += 1 return roman_num"},{"question":"# Edge Detection Using the Canny Method Context Edge detection is an important task in image processing and computer vision, used to identify the boundaries within images. The Canny edge detection algorithm is a popular multi-stage algorithm to detect a wide range of edge types in images. Task You need to implement a simplified version of the Canny edge detection algorithm for grayscale images. Your task involves writing a function `canny_edge_detector` that takes the following inputs: 1. `image`: Input grayscale image (normalized to values between 0 and 1). 2. `low_threshold`: Lower bound for hysteresis thresholding. 3. `high_threshold`: Upper bound for hysteresis thresholding. The function should return a 2D array `edges` indicating detected edges with pixel values set to 1 (edge) or 0 (non-edge). Input - `image`: 2D NumPy array of shape `(n, m)` representing a grayscale image. - `low_threshold`: Float value between `0` and `1` for the lower bound of hysteresis thresholding. - `high_threshold`: Float value between `0` and `1` for the upper bound of hysteresis thresholding. Output - 2D NumPy array of shape `(n, m)` with binary values indicating the edges detected. Constraints - Each pixel value in `image` is between `0` and `1`. - `low_threshold` and `high_threshold` are both positive float values where `low_threshold <= high_threshold`. - Size of the image should not exceed `512x512`. Performance Requirements - The function should efficiently handle images of size up to `512x512` within a reasonable time frame (~5 seconds). # Example ```python import numpy as np def canny_edge_detector(image: np.ndarray, low_threshold: float, high_threshold: float) -> np.ndarray: # Step 1: Apply Gaussian filter # Step 2: Compute gradients using Sobel operators # Step 3: Calculate gradient magnitude and direction # Step 4: Apply Non-Maximum Suppression # Step 5: Perform Hysteresis Thresholding # ... [Your Code Here] ... return edges # Example usage: image = np.array([[0, 0, 0, 0, 0], [0, 1, 1, 1, 0], [0, 1, 0, 1, 0], [0, 1, 1, 1, 0], [0, 0, 0, 0, 0]], dtype=np.float32) low_threshold = 0.1 high_threshold = 0.3 edges = canny_edge_detector(image, low_threshold, high_threshold) print(edges) ```","solution":"import numpy as np from scipy.ndimage import gaussian_filter, sobel def canny_edge_detector(image: np.ndarray, low_threshold: float, high_threshold: float) -> np.ndarray: Detect edges in the input grayscale image using a simplified version of the Canny edge detection algorithm. Parameters: - image: Input grayscale image (normalized to values between 0 and 1). - low_threshold: Lower bound for hysteresis thresholding. - high_threshold: Upper bound for hysteresis thresholding. Returns: - 2D NumPy array indicating detected edges with pixel values set to 1 (edge) or 0 (non-edge). # Step 1: Apply Gaussian filter to smooth the image smoothed = gaussian_filter(image, sigma=1.4) # Step 2: Compute gradients using Sobel operators gradient_x = sobel(smoothed, axis=1) gradient_y = sobel(smoothed, axis=0) # Step 3: Calculate gradient magnitude and direction gradient_magnitude = np.hypot(gradient_x, gradient_y) gradient_direction = np.arctan2(gradient_y, gradient_x) # Step 4: Apply Non-Maximum Suppression M, N = gradient_magnitude.shape suppressed = np.zeros((M, N), dtype=np.float32) angle = gradient_direction * 180. / np.pi angle[angle < 0] += 180 for i in range(1, M-1): for j in range(1, N-1): q, r = 255, 255 # Angle 0 if (0 <= angle[i, j] < 22.5) or (157.5 <= angle[i, j] <= 180): q = gradient_magnitude[i, j+1] r = gradient_magnitude[i, j-1] # Angle 45 elif 22.5 <= angle[i, j] < 67.5: q = gradient_magnitude[i+1, j-1] r = gradient_magnitude[i-1, j+1] # Angle 90 elif 67.5 <= angle[i, j] < 112.5: q = gradient_magnitude[i+1, j] r = gradient_magnitude[i-1, j] # Angle 135 elif 112.5 <= angle[i, j] < 157.5: q = gradient_magnitude[i-1, j-1] r = gradient_magnitude[i+1, j+1] if (gradient_magnitude[i, j] >= q) and (gradient_magnitude[i, j] >= r): suppressed[i, j] = gradient_magnitude[i, j] else: suppressed[i, j] = 0 # Step 5: Perform Hysteresis Thresholding edges = np.zeros((M, N), dtype=np.float32) strong = high_threshold weak = low_threshold strong_i, strong_j = np.where(suppressed >= strong) zeros_i, zeros_j = np.where(suppressed < weak) weak_i, weak_j = np.where((suppressed <= strong) & (suppressed >= weak)) edges[strong_i, strong_j] = 1 edges[weak_i, weak_j] = 0.5 for i in range(1, M-1): for j in range(1, N-1): if edges[i, j] == 0.5: if ((edges[i+1, j-1:j+2] == 1).any() or (edges[i-1, j-1:j+2] == 1).any() or (edges[i, [j-1, j+1]] == 1).any()): edges[i, j] = 1 else: edges[i, j] = 0 return edges.astype(int)"},{"question":"# Problem Statement You are given a non-negative integer as input and you need to determine the sum of its digits. Your task is to implement a function `sum_of_digits(n: int) -> int` that returns the sum of the digits of the given integer `n`. # Input - `n`: A non-negative integer. # Output - An integer representing the sum of the digits of `n`. # Constraints - The integer `n` will be at most 10^12. # Examples ```python assert sum_of_digits(12345) == 15 assert sum_of_digits(987654321) == 45 assert sum_of_digits(0) == 0 assert sum_of_digits(1001) == 2 ``` # Requirements - Your implementation should efficiently handle the constraints. # Notes - You may assume that `n` is always a non-negative integer. - The function should have a linear time complexity, i.e., O(d), where d is the number of digits in `n`.","solution":"def sum_of_digits(n: int) -> int: Returns the sum of the digits of the given non-negative integer n. :param n: A non-negative integer :return: Sum of the digits of n return sum(int(digit) for digit in str(n))"},{"question":"# Question: Implement a Min Stack Scenario In many applications, it\'s useful to have a stack that not only supports the basic operations of push and pop, but can also return the minimum element in constant time. You are tasked with implementing such a data structure. Task Implement a class `MinStack` with the following methods: 1. **`__init__(self):`** * Initializes the stack object. 2. **`push(self, val: int) -> None:`** * Pushes the element `val` onto the stack. 3. **`pop(self) -> None:`** * Removes the element on the top of the stack. 4. **`top(self) -> int:`** * Gets the top element of the stack. 5. **`getMin(self) -> int:`** * Retrieves the minimum element in the stack. Constraints * All methods should run in O(1) time complexity. * The methods will be called as follows: * `obj = MinStack()` * `obj.push(val)` * `obj.pop()` * `param_3 = obj.top()` * `param_4 = obj.getMin()` Example ```python minStack = MinStack() minStack.push(-2) minStack.push(0) minStack.push(-3) print(minStack.getMin()) # returns -3 minStack.pop() print(minStack.top()) # returns 0 print(minStack.getMin()) # returns -2 ```","solution":"class MinStack: def __init__(self): self.stack = [] self.min_stack = [] def push(self, val: int) -> None: self.stack.append(val) # If the min_stack is empty or the current value is less than or equal to # the top value of min_stack, we push it onto the min_stack. if not self.min_stack or val <= self.min_stack[-1]: self.min_stack.append(val) def pop(self) -> None: if self.stack: val = self.stack.pop() # If the value popped from the main stack is the same as the value at # the top of the min_stack, we also pop from the min_stack. if val == self.min_stack[-1]: self.min_stack.pop() def top(self) -> int: # Return the top value of the main stack. if self.stack: return self.stack[-1] return None # Or raise an exception def getMin(self) -> int: # Return the top value of the min_stack which is the minimum value in the main stack. if self.min_stack: return self.min_stack[-1] return None # Or raise an exception"},{"question":"# Recursive String Reversal **Scenario**: You are developing string manipulation utilities for a software library, and one of the utilities requires reversing a given string recursively. This functionality might be used in various applications, such as data processing, cryptographic algorithms, or even basic string handling functions. **Task**: Implement a function `reverse_string` that reverses a string using a recursive approach. Your function should not use any iterative constructs such as loops. **Specifications**: * You will write a function `reverse_string(s: str) -> str`. * `s`: The input string that needs to be reversed. **Constraints**: * The function should be implemented recursively—using for or while loops will not be accepted. **Expected Output**: * Return the reversed string as `str`. **Examples**: ```python # Example 1: Reverse a simple string output = reverse_string(\\"hello\\") print(output) # Expected: \\"olleh\\" # Example 2: Reverse a string with spaces output = reverse_string(\\"data science\\") print(output) # Expected: \\"ecneics atad\\" # Example 3: Reverse an empty string output = reverse_string(\\"\\") print(output) # Expected: \\"\\" # Example 4: Reverse a string with special characters output = reverse_string(\\"!@# 123\\") print(output) # Expected: \\"321 #@!\\" ``` Implement the `reverse_string` function to meet these requirements.","solution":"def reverse_string(s): Reverses a string using a recursive approach. Args: s (str): The input string that needs to be reversed. Returns: str: The reversed string. if len(s) == 0: return s return s[-1] + reverse_string(s[:-1])"},{"question":"# Maximum Subarray Sum: Divide and Conquer Implement a function `maximum_subarray_sum(nums: List[int]) -> int` that receives a list of integers and returns the sum of the maximum sum subarray. A subarray is a contiguous part of the array. Inputs: * `nums`: A list of integers where 1 ≤ n ≤ 10^5. Outputs: * An integer representing the maximum sum that can be obtained from any subarray of `nums`. Constraints: * The list will always contain at least one element. Example Usage: ```python assert maximum_subarray_sum([-2,1,-3,4,-1,2,1,-5,4]) == 6 # Explanation: [4,-1,2,1] has the largest sum = 6 assert maximum_subarray_sum([1]) == 1 # Single element list has the largest sum = 1 assert maximum_subarray_sum([5,4,-1,7,8]) == 23 # Entire array sum is 23 assert maximum_subarray_sum([-1, -2, -3, -4]) == -1 # Single element -1 is the maximum sum ``` # Requirements: * Your function should use a divide-and-conquer approach, leveraging techniques that break the problem into smaller subproblems, solve each subproblem independently, and combine their solutions to solve the original problem. * The solution should ensure (O(n log n)) time complexity. * Make sure your implementation efficiently handles large input arrays up to the constraint limit without hitting recursion depth issues. # Task: 1. Implement the `maximum_subarray_sum` function using the specified guidelines. 2. Validate your solution by ensuring it correctly identifies the maximum subarray sum for a variety of test cases, including edge cases with negative numbers and single-element arrays.","solution":"from typing import List def maximum_subarray_sum(nums: List[int]) -> int: def max_crossing_sum(arr, left, mid, right): sm = 0 left_sum = float(\'-inf\') # Include elements on left of mid. for i in range(mid, left - 1, -1): sm = sm + arr[i] if (sm > left_sum): left_sum = sm sm = 0 right_sum = float(\'-inf\') # Include elements on right of mid for i in range(mid + 1, right + 1): sm = sm + arr[i] if (sm > right_sum): right_sum = sm # Return sum of elements on left and right of mid return left_sum + right_sum def max_subarray_sum(arr, left, right): # Base case: Only one element if left == right: return arr[left] # Find middle point mid = (left + right) // 2 # Return maximum of following three possible cases: # a) Maximum subarray sum in left half # b) Maximum subarray sum in right half # c) Maximum subarray sum such that the subarray crosses the midpoint return max(max_subarray_sum(arr, left, mid), max_subarray_sum(arr, mid + 1, right), max_crossing_sum(arr, left, mid, right)) return max_subarray_sum(nums, 0, len(nums) - 1)"},{"question":"Question: Implement a Customizable Sorting Algorithm with Multiple Comparison Strategies # Objective Create a flexible sorting function that can sort a list of elements based on different comparison strategies. This function should be highly modular, allowing users to pass custom comparison functions for sorting elements. # Requirements 1. **Custom Comparison Function**: * Implement a function that can accept a user-defined comparison function. * The comparison function should take two arguments and return: * Negative value if the first argument should come before the second. * Zero if they are considered equal. * Positive value if the first argument should come after the second. 2. **Sorting Algorithm**: * Use the quicksort algorithm for the implementation. * Integrate the custom comparison function into the sorting logic. * Ensure the function is efficient and correctly follows the quicksort algorithm properties. 3. **Modularity and Reusability**: * Ensure the sorting function is modular and can be easily extended to support different data types and comparison logic. * Provide unit tests to validate the sorting of various data sets with different comparison functions. # Input/Output Specification 1. **Input**: * `data`: A list of elements to be sorted. The elements can be of any sortable data type. * `compare`: A comparison function that defines the sorting order. 2. **Output**: * A new list of elements sorted based on the provided comparison function. # Constraints * Ensure the function gracefully handles empty lists and lists with one element. * Comparison functions should be efficient to avoid performance bottlenecks. # Example Usage ```python def custom_compare(x, y): return x - y data = [9, 3, 5, 1, 7] sorted_data = custom_sort(data, custom_compare) print(sorted_data) # Output should be [1, 3, 5, 7, 9] ``` Provide additional unit tests and examples to verify the correct implementation of `custom_sort`. # Submission * Implement the `custom_compare` function to compare integers. * Implement the `custom_sort` function following the provided specifications. * Include unit tests to verify the correctness and efficiency of your implementation. * Ensure your code is well-documented and modular to support future extensions and ease of understanding. **Note:** Avoid using built-in sorting functions or any high-level libraries for sorting. Only use standard Python functionality.","solution":"def custom_sort(data, compare): Sorts a list of elements using a custom comparison function. Parameters: data (list): The list of elements to be sorted. compare (function): The comparison function that compares two elements. Returns: list: A new list of elements sorted based on the provided comparison function. if len(data) <= 1: return data else: pivot = data[0] lesser_than_pivot = [x for x in data[1:] if compare(x, pivot) < 0] equal_to_pivot = [x for x in data if compare(x, pivot) == 0] greater_than_pivot = [x for x in data[1:] if compare(x, pivot) > 0] return custom_sort(lesser_than_pivot, compare) + equal_to_pivot + custom_sort(greater_than_pivot, compare) def custom_compare(x, y): A sample custom comparison function. Parameters: x, y: The two elements to compare. Returns: int: Negative if x < y, zero if x == y, positive if x > y return x - y"},{"question":"# Repeated Digit Sum **Context**: The repeated digit sum problem involves recursively summing the digits of a number until a single-digit result is obtained. For instance, given the number 987, you would first sum the digits (9 + 8 + 7 = 24), and then sum the digits of the result (2 + 4 = 6), giving a single-digit result of 6. **Objective**: Implement the function `repeated_digit_sum(n: int) -> int` that takes a non-negative integer `n` and returns its repeated digit sum. **Specifications**: * Input: A non-negative integer `n` (0 ≤ `n` ≤ (10^{18})). * Output: A single integer representing the repeated digit sum of `n`. **Example**: ```python >>> repeated_digit_sum(987) 6 >>> repeated_digit_sum(12345) 6 ``` **Constraints**: 1. The function should handle edge cases (e.g., `n` being 0). 2. Consider the performance implications for very large values of `n`. **Performance**: - Targeted time complexity: ( O(log(n)) ) - Targeted space complexity: ( O(1) ) **Notes**: - Do not use external libraries. - Aim for an efficient calculation method that minimizes the number of recursive or iterative steps. # Implementation Your task is to complete the following function skeleton: ```python def repeated_digit_sum(n: int) -> int: Given a number, return its repeated digit sum. # Implement the function here pass ``` --- This problem integrates well with the existing set by introducing a novel yet conceptually similar challenge focusing on digit manipulation and recursive/iterative computation, and it matches the expected style, complexity, and length.","solution":"def repeated_digit_sum(n: int) -> int: Given a number, return its repeated digit sum. if n == 0: return 0 if n % 9 == 0: return 9 else: return n % 9"},{"question":"# Question Title: Odd Integers in an Interval Objective: Implement a function that takes an integer interval and determines whether there are any odd integers within that interval. Description: Given two integers, `start` and `end`, determine if there are any odd integers within the inclusive interval `[start, end]`. If there are odd integers within the interval, return `True`, otherwise return `False`. Function Definition: ```python def has_odd_integers(start: int, end: int) -> bool: Determine if there are odd integers within the inclusive interval [start, end]. Args: start (int): The starting integer of the interval. end (int): The ending integer of the interval. Returns: bool: True if there are any odd integers within the interval, False otherwise. ``` Constraints: 1. The interval is inclusive of both `start` and `end`. 2. The input values can be negative. 3. Assume `start <= end`. Input: - `start`: An integer indicating the starting point of the interval. - `end`: An integer indicating the ending point of the interval. Output: - A boolean indicating whether there are any odd integers within the interval. Example: ```python print(has_odd_integers(2, 5)) # Expected output: True (odd integers: 3, 5) print(has_odd_integers(4, 8)) # Expected output: True (odd integers: 5, 7) print(has_odd_integers(10, 20)) # Expected output: True (odd integers: 11, 13, 15, 17, 19) print(has_odd_integers(2, 2)) # Expected output: False (no odd integers in the interval) print(has_odd_integers(-3, 1)) # Expected output: True (odd integers: -3, -1, 1) ``` Edge Cases to Consider: 1. Intervals with no odd integers (e.g., even-only intervals). 2. Intervals where `start` equals `end`. 3. Negative integer intervals. Good luck!","solution":"def has_odd_integers(start: int, end: int) -> bool: Determine if there are odd integers within the inclusive interval [start, end]. Args: start (int): The starting integer of the interval. end (int): The ending integer of the interval. Returns: bool: True if there are any odd integers within the interval, False otherwise. for num in range(start, end + 1): if num % 2 != 0: return True return False"},{"question":"# Question: Task Scheduler Simulation Context You have been assigned to develop an algorithm to simulate a task scheduler that manages and executes various tasks on a single-core processor. Each task has a specified execution time, and there can be dependencies between tasks. A task can only begin execution once all its dependent tasks have been completed. Task Implement a task scheduler simulation that determines the order in which tasks should be scheduled to ensure all dependencies are honored. Requirements 1. **task_scheduler(tasks: Dict[str, List[str]], times: Dict[str, int]) -> List[str]**: - `tasks`: A dictionary where each key represents a task (as a string) and its value is a list of tasks (as strings) that must be completed before the key task can start. - `times`: A dictionary where each key represents a task (as a string) and its value is the execution time (as an integer) for that task. Your function should return a list of tasks in the order they should be executed. If there is any cycle in the dependencies (i.e., a task depending on itself indirectly), raise a `ValueError` with the message \\"Circular dependency detected\\". Input Format - `tasks`: A dictionary where keys and values are strings representing task names and their dependencies respectively. - `times`: A dictionary where keys are task names and values are integers representing the execution time for each task. Output Format - A list of strings representing the task execution order. Constraints - Each task name is unique. - Each task\'s execution time is a positive integer. - There are no duplicate dependencies. - All tasks and dependencies are in lowercase. Examples ```python # Example 1 tasks = { \\"a\\": [], \\"b\\": [\\"a\\"], \\"c\\": [\\"b\\"], \\"d\\": [\\"a\\", \\"c\\"] } times = { \\"a\\": 3, \\"b\\": 2, \\"c\\": 2, \\"d\\": 4 } >>> task_scheduler(tasks, times) [\'a\', \'b\', \'c\', \'d\'] # Example 2 tasks = { \\"a\\": [\\"b\\"], \\"b\\": [\\"c\\"], \\"c\\": [\\"a\\"] } times = { \\"a\\": 1, \\"b\\": 1, \\"c\\": 1 } >>> task_scheduler(tasks, times) ValueError: Circular dependency detected # Example 3 tasks = { \\"a\\": [], \\"b\\": [\\"a\\"], \\"c\\": [\\"b\\"], \\"d\\": [\\"c\\"] } times = { \\"a\\": 3, \\"b\\": 2, \\"c\\": 1, \\"d\\": 4 } >>> task_scheduler(tasks, times) [\'a\', \'b\', \'c\', \'d\'] ``` Notes - Consider using topological sorting to determine the task order. - Ensure to handle cases where a task might have multiple dependencies correctly. - Assume all given tasks and dependencies are valid per the given constraints unless stated otherwise.","solution":"def task_scheduler(tasks, times): from collections import defaultdict, deque # Building the in-degree and graph in_degree = defaultdict(int) graph = defaultdict(list) # Initialize in-degree for all tasks for task in tasks: in_degree[task] = 0 # Construct the graph and in-degree of each task for task in tasks: for dep in tasks[task]: graph[dep].append(task) in_degree[task] += 1 # Queue for the tasks with no dependencies (in-degree 0) queue = deque([task for task in tasks if in_degree[task] == 0]) result = [] while queue: current = queue.popleft() result.append(current) for neighbor in graph[current]: in_degree[neighbor] -= 1 if in_degree[neighbor] == 0: queue.append(neighbor) # If result length is not the same as the number of tasks, there\'s a circular dependency if len(result) != len(tasks): raise ValueError(\\"Circular dependency detected\\") return result"},{"question":"# Coding Question You are tasked with creating a function that processes user profiles and identifies duplicate usernames. The function should handle variations in username formatting, such as case sensitivity and leading/trailing spaces, when determining duplicates. Implement the main function `find_duplicate_usernames(usernames: List[str]) -> List[str]` to identify all duplicates and return them in a list. Function Signature ```python def find_duplicate_usernames(usernames: List[str]) -> List[str]: # implementation goes here ``` # Requirements 1. **Input**: - `usernames` (List[str]): List of usernames to be checked for duplicates. 2. **Output**: - Returns a list of duplicate usernames (case insensitive and trimmed for spaces). # Constraints 1. The function should ignore leading and trailing spaces while comparing usernames. 2. Usernames should be considered case insensitive. 3. The returned list should contain duplicates as they first appear in the input list. 4. The order of the duplicates in the output list should be the same as their first appearance in the input list. # Example Scenarios Example 1: ```python print(find_duplicate_usernames([\\"Alice\\", \\"bob\\", \\"alice\\", \\" Bob \\", \\"ALICE\\"])) # Expected Output: [\\"alice\\", \\"bob\\"] ``` Example 2: ```python print(find_duplicate_usernames([\\"john\\", \\"John\\", \\"JOHN \\", \\" doe \\", \\"DOE\\", \\"doe\\"])) # Expected Output: [\\"john\\", \\"doe\\"] ``` # Notes - Ensure your code processes the list efficiently to handle large inputs. - Include necessary comments to explain key sections of your code. Present your code in a clean, readable format with appropriate error handling and comments.","solution":"def find_duplicate_usernames(usernames): Identifies duplicate usernames in a list, case-insensitive and ignoring leading/trailing spaces. Parameters: usernames (list of str): List of usernames. Returns: list of str: List of duplicate usernames in their first appearance order (normalized to lower case and trimmed). normalized_usernames = set() duplicates = set() result = [] for username in usernames: normalized_username = username.strip().lower() if normalized_username in normalized_usernames: if normalized_username not in duplicates: duplicates.add(normalized_username) result.append(normalized_username) else: normalized_usernames.add(normalized_username) return result"},{"question":"Additional Coding Assessment Question: # Problem Statement You are asked to implement a program to calculate and display the Sierpinski triangle, a well-known fractal, using the chaos game approach. Implement a Python function to generate and visualize the Sierpinski triangle. Function Definition ```python def sierpinski_triangle( num_points: int, iterations: int, image_size: int ) -> None: Generate and visualize the Sierpinski triangle using the chaos game approach. Parameters: - num_points: Number of points to display in the Sierpinski triangle. - iterations: Number of iterations to perform in the chaos game. - image_size: Size of the image canvas for visualization. Return: None. (Displays the plot of the Sierpinski triangle) ``` Requirements * **Input**: - `num_points` (int): The number of points to generate and display in the Sierpinski triangle. - `iterations` (int): The number of iterative steps to perform for each point. - `image_size` (int): The size of the square canvas for rendering the triangle. * **Output**: The function should not return any value but should display a plot of the Sierpinski triangle on a graphical canvas. * **Constraints**: - `100 <= num_points <= 100000` - `1 <= iterations <= 10000` - `100 <= image_size <= 2000` Example ```python sierpinski_triangle(num_points=10000, iterations=500, image_size=1000) ``` This example should produce a visual representation of the Sierpinski triangle on a 1000x1000 canvas. Details * Initialize a list of vertices of an equilateral triangle. * Randomly choose a point inside the triangle to start. * For a given number of points, iteratively: 1. Randomly select one of the vertices. 2. Move halfway from the current point to the chosen vertex. 3. Plot the new point. * Continue the iteration process to generate the fractal pattern. This function should visually demonstrate the iterative process leading to the distinct fractal nature of the Sierpinski triangle on a specified canvas size.","solution":"import matplotlib.pyplot as plt import random def sierpinski_triangle(num_points: int, iterations: int, image_size: int) -> None: Generate and visualize the Sierpinski triangle using the chaos game approach. Parameters: - num_points: Number of points to display in the Sierpinski triangle. - iterations: Number of iterations to perform in the chaos game. - image_size: Size of the image canvas for visualization. Return: None. (Displays the plot of the Sierpinski triangle) # Define the vertices of an equilateral triangle vertices = [(0, 0), (image_size, 0), (image_size / 2, image_size * (3 ** 0.5) / 2)] # Initialize the starting point inside the triangle x, y = image_size / 2, image_size / 4 # Create lists to hold the coordinates of the points x_points = [] y_points = [] # Iterate and generate points for _ in range(iterations): for _ in range(num_points): # Randomly select one of the vertices vx, vy = random.choice(vertices) # Move halfway from the current point to the vertex x = (x + vx) / 2 y = (y + vy) / 2 # Collect the new point x_points.append(x) y_points.append(y) # Plot the points plt.figure(figsize=(8, 8)) plt.scatter(x_points, y_points, s=0.1, color=\'black\') plt.axis(\'off\') plt.show()"},{"question":"# Problem Statement: You need to implement a function to generate all possible substrings of a given string. Substrings are defined as contiguous sequences of characters within a string. Your function should return these substrings in a sorted list (lexicographical order). # Function Signature: ``` def generate_substrings(s: str) -> List[str]: ``` # Input: - `s`: a string (1 ≤ |s| ≤ 100). # Output: - A list of strings containing all possible substrings sorted lexicographically. # Constraints: * The input string `s` will contain only lowercase English letters. # Example: Example 1: ``` Input: s = \\"abc\\" Output: [\'a\', \'ab\', \'abc\', \'b\', \'bc\', \'c\'] ``` Example 2: ``` Input: s = \\"aa\\" Output: [\'a\', \'a\', \'aa\'] ``` # Requirements: - Ensure the function returns all possible substrings correctly sorted in lexicographical order. - Consider the time complexity of generating and sorting substrings. # Hint: Explore constructing substrings by iterating over all possible starting and ending positions, then sort the resulting list.","solution":"from typing import List def generate_substrings(s: str) -> List[str]: Generates all possible substrings of the given string and returns them sorted lexicographically. substrings = [] n = len(s) for i in range(n): for j in range(i+1, n+1): substrings.append(s[i:j]) return sorted(substrings)"},{"question":"# Problem Description: Implement an In-Memory Key-Value Store with TTL You are required to implement a custom in-memory key-value store that supports setting a Time-To-Live (TTL) value for each key. This TTL defines the duration (in seconds) after which the key should expire and be automatically deleted from the store. # Requirements 1. **Class Implementation**: Create a class `TTLKeyValueStore` with the following methods: * `__init__(self)`: Initializes the key-value store. * `set(self, key, value, ttl=None)`: Sets a key-value pair in the store with an optional TTL. * `get(self, key)`: Returns the value associated with the key if it has not expired, otherwise returns `None`. * `delete(self, key)`: Deletes the key from the store if it exists. * `has(self, key)`: Checks if the key exists and has not expired. 2. Ensure your solution can handle the following: * Automatic expiration of keys after the TTL duration. * Efficient retrieval and deletion of keys. * Handling of edge cases where keys do not exist, have expired, or where invalid TTL values are provided. 3. **Constraints**: * Keys and values are strings. * TTL is provided in seconds and is an integer. A TTL value of `None` means the key does not expire. * The store must handle rapid set and get operations efficiently. # Example ```python class TTLKeyValueStore: def __init__(self): # Your initialization code goes here pass def set(self, key, value, ttl=None): # Your code to set a key-value pair goes here pass def get(self, key): # Your code to get the value of a key goes here pass def delete(self, key): # Your code to delete a key goes here pass def has(self, key): # Your code to check if a key exists goes here pass # Example usage store = TTLKeyValueStore() store.set(\\"key1\\", \\"value1\\", 5) # Sets key1 with value1 and a TTL of 5 seconds print(store.get(\\"key1\\")) # Returns \'value1\' time.sleep(6) # Wait for 6 seconds print(store.get(\\"key1\\")) # Returns None as the key has expired print(store.has(\\"key1\\")) # Returns False store.set(\\"key2\\", \\"value2\\") # Sets key2 with value2 with no TTL print(store.get(\\"key2\\")) # Returns \'value2\' store.delete(\\"key2\\") # Deletes key2 from the store print(store.has(\\"key2\\")) # Returns False ``` Implement the class while considering performance and the automatic handling of expired keys. You may use helper classes or functions as necessary.","solution":"import time import threading class TTLKeyValueStore: def __init__(self): self.store = {} self.ttl_store = {} self.lock = threading.Lock() def _purge_expired_keys(self): current_time = time.time() keys_to_delete = [key for key, expiry in self.ttl_store.items() if expiry is not None and expiry <= current_time] for key in keys_to_delete: if key in self.store: del self.store[key] if key in self.ttl_store: del self.ttl_store[key] def set(self, key, value, ttl=None): with self.lock: self._purge_expired_keys() self.store[key] = value if ttl is not None: self.ttl_store[key] = time.time() + ttl else: self.ttl_store[key] = None def get(self, key): with self.lock: self._purge_expired_keys() if key in self.store: return self.store[key] return None def delete(self, key): with self.lock: if key in self.store: del self.store[key] if key in self.ttl_store: del self.ttl_store[key] def has(self, key): with self.lock: self._purge_expired_keys() return key in self.store"},{"question":"# Matrix Rank Calculation **Context:** In linear algebra, the rank of a matrix is an important property that gives insights into the dimensions of the column space. It can be used to understand the solutions to a system of linear equations represented by the matrix. Your task is to implement a function to compute the rank of a matrix. **Problem Statement:** Write a function `matrix_rank` that takes a 2D numerical matrix as input and returns its rank. Utilize standard linear algebra techniques and ensure your implementation handles matrices of varying sizes, including edge cases like empty matrices and zero matrices. ```python def matrix_rank(mat: np.ndarray) -> int: pass ``` **Function Definition:** * **Input**: * `mat` (np.ndarray): A two-dimensional numpy array representing the matrix whose rank is to be calculated. * **Output**: * Returns `int`: The rank of the input matrix. **Constraints**: 1. The function should handle matrices of any size, including edge cases. 2. The matrix elements can be integers or floating-point numbers. 3. Utilize numpy library functions for efficient computation. **Edge Cases to Consider**: 1. Empty matrix. 2. Zero matrix. 3. Single row or single column matrices. 4. High precision floating-point elements. # Example: ```python import numpy as np mat1 = np.array([[1, 2], [3, 4]]) mat2 = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) mat3 = np.zeros((4, 4)) print(matrix_rank(mat1)) # Output: 2 print(matrix_rank(mat2)) # Output: 2 print(matrix_rank(mat3)) # Output: 0 ``` **Verification**: Add a unit test class `TestMatrixRank` with methods to test the matrix_rank function, covering regular scenarios, boundary conditions, and edge cases as described. ```python import unittest class TestMatrixRank(unittest.TestCase): def test_regular_matrix(self): mat = np.array([[1, 2], [3, 4]]) result = matrix_rank(mat) expected = 2 self.assertEqual(result, expected) def test_singular_matrix(self): mat = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) result = matrix_rank(mat) expected = 2 self.assertEqual(result, expected) def test_zero_matrix(self): mat = np.zeros((4, 4)) result = matrix_rank(mat) expected = 0 self.assertEqual(result, expected) def test_empty_matrix(self): mat = np.array([[]]) result = matrix_rank(mat) expected = 0 self.assertEqual(result, expected) def test_single_row_matrix(self): mat = np.array([[1, 2, 3]]) result = matrix_rank(mat) expected = 1 self.assertEqual(result, expected) def test_single_column_matrix(self): mat = np.array([[1], [2], [3]]) result = matrix_rank(mat) expected = 1 self.assertEqual(result, expected) if __name__ == \'__main__\': unittest.main() ```","solution":"import numpy as np def matrix_rank(mat: np.ndarray) -> int: Returns the rank of the given matrix. Parameters: mat (np.ndarray): A 2D numpy array representing the matrix. Returns: int: The rank of the matrix. if mat.size == 0: return 0 return np.linalg.matrix_rank(mat)"},{"question":"# Problem Statement You are required to implement a function `find_most_frequent_words` that takes a string of text and returns the `n` most frequent words in the text. Function Signature ```python def find_most_frequent_words(text: str, n: int) -> List[str]: pass ``` Requirements 1. The function should identify the `n` most frequent words in the provided text. 2. Words are case-insensitive, so \\"Apple\\" and \\"apple\\" should be counted as the same word. 3. Return the words in descending order of frequency. If two words have the same frequency, sort them lexicographically. 4. The input text only contains alphabetic characters and whitespace. 5. Ensure that the input parameters are valid: - `text` is a non-empty string. - `n` is a positive integer less than or equal to the number of unique words in the text. Inputs - `text: str` - The text to analyze. - `n: int` - The number of most frequent words to return. Outputs - Return type is `List[str]`. Constraints - The length of `text` will not exceed `10,000` characters. - The maximum number of unique words will not exceed `1,000`. Example ```python # Example 1 text_1 = \\"apple orange banana apple strawberry banana apple\\" most_frequent_1 = find_most_frequent_words(text_1, 2) assert most_frequent_1 == [\\"apple\\", \\"banana\\"] # Example 2 text_2 = \\"one two two three three three four four four four\\" most_frequent_2 = find_most_frequent_words(text_2, 3) assert most_frequent_2 == [\\"four\\", \\"three\\", \\"two\\"] ``` Notes 1. Words are separated by spaces. 2. You should ignore any leading or trailing whitespace in the input text. 3. Handle varying cases consistently: treat \\"Word\\" and \\"word\\" as the same word. 4. Assume the input is well-formed and contains only properly formatted alphabetic text. # Detailed Steps 1. Normalize the text to lower case. 2. Split the text into individual words. 3. Count the frequency of each word using a dictionary or any suitable data structure. 4. Sort the words by frequency and, in case of ties, sort them lexicographically. 5. Return the top `n` words based on the sorted order.","solution":"from typing import List from collections import Counter def find_most_frequent_words(text: str, n: int) -> List[str]: # normalize the text to lowercase text = text.lower() # split the text into words words = text.split() # count the frequency of each word word_counts = Counter(words) # sort the words first by frequency (in descending order), then lexicographically sorted_words = sorted(word_counts.keys(), key=lambda x: (-word_counts[x], x)) # return the top n words return sorted_words[:n]"},{"question":"Array Manipulation Question **Scenario**: As a developer building data analysis tools, you are often required to preprocess large datasets. One common task is to transform an array of numbers by carrying out specified operations efficiently. **Task**: Implement a function `apply_operations` that takes an array of integers and a list of operations, and returns the array after all operations have been applied. Each operation is specified as a tuple where the first element is the operation type (\'add\', \'subtract\', \'multiply\', or \'divide\'), the second element is the target index in the array, and the third element is the value to apply in the operation. **Function Signature**: ```python def apply_operations(arr: list[int], operations: list[tuple[str, int, int]]) -> list[int]: Apply a series of operations to transform the provided array. Parameters: arr (list[int]): The initial array of integers. operations (list[tuple[str, int, int]]): A list of operations. Each operation is a tuple containing: - str: The operation type (\'add\', \'subtract\', \'multiply\', \'divide\') - int: The target index in the array. - int: The value to apply in the operation. Returns: list[int]: The transformed array after all operations have been applied. Example Usage: >>> apply_operations([1, 2, 3, 4], [(\'add\', 1, 5), (\'multiply\', 2, 3), (\'subtract\', 0, 1)]) [0, 7, 9, 4] >>> apply_operations([10, 20, 30], [(\'divide\', 2, 3), (\'subtract\', 1, 5)]) [10, 15, 10] # Your code here ``` **Constraints**: - The length of `arr` is within the range [1, 10^5]. - The number of operations is within the range [1, 10^5]. - Operation types are always valid from the set {\'add\', \'subtract\', \'multiply\', \'divide\'}. - Target indices are valid, i.e., 0 ≤ index < len(arr). - Division is integer division (use `//` operator for division). - The function should execute within a reasonable time limit and with optimal memory usage. Ensure your implementation handles potential edge cases, such as operations resulting in zero or negative values and complex sequences of operations.","solution":"def apply_operations(arr, operations): Apply a series of operations to transform the provided array. Parameters: arr (list[int]): The initial array of integers. operations (list[tuple[str, int, int]]): A list of operations. Each operation is a tuple containing: - str: The operation type (\'add\', \'subtract\', \'multiply\', \'divide\') - int: The target index in the array. - int: The value to apply in the operation. Returns: list[int]: The transformed array after all operations have been applied. for operation in operations: op_type, index, value = operation if op_type == \'add\': arr[index] += value elif op_type == \'subtract\': arr[index] -= value elif op_type == \'multiply\': arr[index] *= value elif op_type == \'divide\': arr[index] //= value return arr"},{"question":"# Coding Assessment Question Scenario You are developing an application for a logistics company that optimizes warehouse storage. One essential feature is to calculate the number of distinct products in the warehouse inventory. Given a list of product codes where some may appear multiple times, the task is to determine the number of unique products. Objective Write a function `count_unique_products(product_codes)` that: - Takes a list of `product_codes` (strings), where each string represents a product code. - Returns an integer representing the number of distinct product codes in the list. Function Signature ```python def count_unique_products(product_codes: list) -> int: pass ``` Input - `product_codes`: A list containing up to 100,000 product codes (strings). - Each product code is guaranteed to be a non-empty string of up to 20 characters. Output - An integer representing the number of unique product codes. Constraints - The function should handle large inputs efficiently. - All product codes are case-sensitive (\\"code1\\" and \\"Code1\\" are considered different). Example ```python product_codes = [\'A123\', \'B456\', \'A123\', \'C789\', \'B456\'] ``` Calling `count_unique_products(product_codes)` should return `3`. Additional Notes - Use appropriate data structures to ensure efficiency. - Consider edge cases such as an empty list or all unique product codes.","solution":"def count_unique_products(product_codes: list) -> int: Returns the number of unique product codes in the given list. # Use a set to store unique product codes since sets do not allow duplicates unique_codes = set(product_codes) # The number of unique product codes is the size of the set return len(unique_codes)"},{"question":"# Question You are given a list of integers `arr`, and your task is to write a function `find_missing_numbers(arr: List[int], m: int) -> List[int]` that returns a sorted list of all the integers between `1` and `m` (inclusive) that are not present in `arr`. Input - A list of integers `arr` where (1 leq text{len}(arr) leq 10^5) and (1 leq text{arr[i]} leq m). - An integer `m` where (1 leq m leq 10^5). Output - A sorted list of integers representing the missing numbers between `1` and `m`. Examples ```python assert find_missing_numbers([1, 2, 4], 5) == [3, 5] assert find_missing_numbers([2, 3, 7, 8], 10) == [1, 4, 5, 6, 9, 10] assert find_missing_numbers([], 5) == [1, 2, 3, 4, 5] ``` Constraints - Only integers will be provided as input. - Consider edge cases such as `arr` being empty or containing all numbers from `1` to `m`. * Make sure your solution performs efficiently for large inputs to handle the constraints properly. * Clearly handle the input validation and edge cases to ensure the robustness of your solution.","solution":"from typing import List def find_missing_numbers(arr: List[int], m: int) -> List[int]: Returns a sorted list of all the integers between 1 and m (inclusive) that are not present in arr. # Convert arr to a set for O(1) lookups arr_set = set(arr) # Find missing numbers by iterating from 1 to m missing_numbers = [num for num in range(1, m + 1) if num not in arr_set] return missing_numbers"},{"question":"Problem Description You are tasked with implementing a text line analyzer that can: 1. Count the number of words in a given line of text. 2. Identify the unique words and their frequencies. 3. Handle the case insensitivity for word counting. 4. Optimize the function for analyzing large texts by avoiding redundant processing. Task 1. **Implement `count_words` to count the number of words**: * Define a function that takes a string `text_line`. * A word is defined as a sequence of alphanumeric characters. * Words are separated by spaces or punctuation marks. * The function should return an integer representing the number of words. 2. **Implement `word_frequencies` to return the frequency of each unique word**: * Define a function that takes a string `text_line`. * The function should return a dictionary where the keys are unique words (case insensitive) and the values are their respective counts in the line. 3. **Implement `optimize_text_analysis` for large texts**: * Define a function that takes a list of strings `text_lines`. * This function should process each line only once and return a summary dictionary: - A total word count. - A dictionary of frequencies for all unique words across all lines. # Input and Output Formats Function 1: `count_words` * **Input**: * A `text_line` (string) containing words separated by spaces or punctuation marks. * Example: `\\"Hello world! This is a test.\\"` * **Output**: * An integer representing the total number of words. * Example: `6` * **Example**: ```python count_words(\\"Hello world! This is a test.\\") == 6 ``` Function 2: `word_frequencies` * **Input**: * A `text_line` (string) containing words separated by spaces or punctuation marks. * Example: `\\"Hello world! Hello.\\"` * **Output**: * A dictionary where keys are words (in lowercase) and values are their frequencies. * Example: `{\\"hello\\": 2, \\"world\\": 1}` * **Example**: ```python word_frequencies(\\"Hello world! Hello.\\") == {\\"hello\\": 2, \\"world\\": 1} ``` Function 3: `optimize_text_analysis` * **Input**: * A list of `text_lines` where each element is a string containing words separated by spaces or punctuation marks. * Example: `[\\"Hello world!\\", \\"This is a new world.\\"]` * **Output**: * A dictionary with two keys: - \\"total_words\\" representing the total word count. - \\"frequencies\\" representing the dictionary of word frequencies. * Example: `{\\"total_words\\": 7, \\"frequencies\\": {\\"hello\\": 1, \\"world\\": 2, \\"this\\": 1, \\"is\\": 1, \\"a\\": 1, \\"new\\": 1}}` * **Example**: ```python optimize_text_analysis([\\"Hello world!\\", \\"This is a new world.\\"]) == {\\"total_words\\": 7, \\"frequencies\\": {\\"hello\\": 1, \\"world\\": 2, \\"this\\": 1, \\"is\\": 1, \\"a\\": 1, \\"new\\": 1}} ``` Implementation Details 1. Implement the `count_words` function to correctly count words separated by spaces or punctuation marks. 2. Implement the `word_frequencies` function to parse the text line, handle case insensitivity, and count word frequencies. 3. Implement the `optimize_text_analysis` function to efficiently process a list of text lines, avoiding redundant word counts and aggregating results.","solution":"import re from collections import defaultdict def count_words(text_line): Count the number of words in a given line of text. :param text_line: String containing words separated by spaces or punctuation marks. :return: Integer representing the number of words. words = re.findall(r\'bw+b\', text_line) return len(words) def word_frequencies(text_line): Return the frequency of each unique word in a given line of text. :param text_line: String containing words separated by spaces or punctuation marks. :return: Dictionary with words as keys and their frequencies as values. words = re.findall(r\'bw+b\', text_line.lower()) frequency_dict = defaultdict(int) for word in words: frequency_dict[word] += 1 return dict(frequency_dict) def optimize_text_analysis(text_lines): Process a list of text lines and return a summary dictionary. :param text_lines: List of strings, each containing words separated by spaces or punctuation marks. :return: Dictionary with total word count and word frequencies. total_words = 0 frequency_dict = defaultdict(int) for line in text_lines: words_in_line = re.findall(r\'bw+b\', line.lower()) total_words += len(words_in_line) for word in words_in_line: frequency_dict[word] += 1 return {\\"total_words\\": total_words, \\"frequencies\\": dict(frequency_dict)}"},{"question":"# Question Overview You are given a list of integers where each integer appears exactly twice except for one integer that appears exactly once. Your task is to identify the integer that appears only once. # Problem Statement **Function Signature**: ```python def find_unique_element(nums: List[int]) -> int: pass ``` **Input**: - A list of integers `nums` where the size of the list is odd (`1 ≤ len(nums) ≤ 10^7`), and each integer appears exactly twice except for one integer that appears exactly once. **Output**: - An integer that is the unique element in the list. # Constraints - The solution must run in (O(n)) time complexity. - The solution must use (O(1)) additional space complexity. # Hints - Consider using bitwise operations to achieve the space complexity requirement. - The XOR operation can be particularly useful for this problem. # Additional Requirements - Include meaningful comments in your code explaining each step. - Ensure your solution passes the following test cases: ```python assert find_unique_element([2, 3, 5, 4, 5, 3, 4]) == 2 assert find_unique_element([2, 2, 1]) == 1 assert find_unique_element([10, 10, 11, 11, 7]) == 7 assert find_unique_element([9]) == 9 assert find_unique_element([1,1,2,2,3,3,4,4,5,5,6]) == 6 ``` # Performance Testing - Your solution should efficiently handle inputs up to `10^7` within a reasonable time frame.","solution":"from typing import List def find_unique_element(nums: List[int]) -> int: Finds the integer that appears exactly once in the list where every other integer appears exactly twice. Parameters: nums (List[int]): A list of integers where one element appears exactly once and all other elements appear exactly twice. Returns: int: The unique element. unique_element = 0 for num in nums: unique_element ^= num return unique_element"},{"question":"# Problem Statement You are tasked with implementing a function to calculate the nth Fibonacci number using two different approaches: recursive with memoization and iterative. Your goal is to analyze the performance gains of using memoization in the recursive approach and compare it with the iterative method. # Requirements 1. **Recursive Implementation with Memoization**: - Function Name: `recursive_fibonacci` - Input: Single integer `n` - Output: Integer representing the nth Fibonacci number - Constraints: * Assume the input is a non-negative integer. * Return an error message for negative inputs. 2. **Iterative Implementation**: - Function Name: `iterative_fibonacci` - Input: Single integer `n` - Output: Integer representing the nth Fibonacci number - Constraints: * Assume the input is a non-negative integer. * Return an error message for negative inputs. 3. You should use Python\'s `functools.lru_cache` for memoization within the recursive function. # Example For example, the implementation should produce the following outputs: ```python assert recursive_fibonacci(5) == 5 assert iterative_fibonacci(5) == 5 assert recursive_fibonacci(0) == 0 assert iterative_fibonacci(0) == 0 assert recursive_fibonacci(-1) == \\"Error: Input must be a non-negative integer.\\" assert iterative_fibonacci(-1) == \\"Error: Input must be a non-negative integer.\\" ``` # Function Definitions **Recursive Implementation with Memoization** ```python from functools import lru_cache @lru_cache def recursive_fibonacci(n: int) -> int: if n < 0: return \\"Error: Input must be a non-negative integer.\\" if n in (0, 1): return n return recursive_fibonacci(n - 1) + recursive_fibonacci(n - 2) ``` **Iterative Implementation** ```python def iterative_fibonacci(n: int) -> int: if n < 0: return \\"Error: Input must be a non-negative integer.\\" if n == 0: return 0 elif n == 1: return 1 a, b = 0, 1 for _ in range(2, n + 1): a, b = b, a + b return b ``` Implement these functions and ensure they pass the provided example cases.","solution":"from functools import lru_cache @lru_cache(maxsize=None) def recursive_fibonacci(n: int) -> int: if n < 0: return \\"Error: Input must be a non-negative integer.\\" if n in (0, 1): return n return recursive_fibonacci(n - 1) + recursive_fibonacci(n - 2) def iterative_fibonacci(n: int) -> int: if n < 0: return \\"Error: Input must be a non-negative integer.\\" if n == 0: return 0 elif n == 1: return 1 a, b = 0, 1 for _ in range(2, n + 1): a, b = b, a + b return b"},{"question":"# Context You\'re designing a system for document version control that can efficiently merge different changes made to the same base document. Your task is to implement a Three-Way Merge utility that takes in a base version, a local version, and a remote version of a document, and merges the changes with minimal conflicts. # Task Implement the `ThreeWayMerge` class. Method Details 1. **`__init__(self, base: str, local: str, remote: str)`**: * Initializes with the base, local, and remote versions of the document. 2. **`find_conflicts(self) -> list[tuple[int, str, str]]`**: * Finds and returns a list of conflicts, where each conflict is represented by a tuple containing the line number, the conflicting local change, and the conflicting remote change. 3. **`merge(self) -> str`**: * Merges the local and remote changes with the base version, resolving conflicts by appending both versions in the order they appear if no conflicts are detected. # Requirement Ensure your implementation of the `ThreeWayMerge` class: * **Is thorough**: defines and captures conflicts appropriately. * **Handles edge cases**: such as identical base, local, and remote versions, or completely different versions. * **Provides clarity**: in reporting conflicts and merging changes. # Input and Output * Input: * Three strings: `base`, `local`, and `remote`, representing different versions of the document. * Output: * For `find_conflicts`: A list of conflicts in the format [(line_number, local_change, remote_change)]. * For `merge`: A single string representing the merged document. # Example ```python # Example documents base_doc = \\"line1nline2nline3\\" local_doc = \\"line1nline2_localnline3\\" remote_doc = \\"line1nline2_remotenline3\\" # Initialize the merging process merge_instance = ThreeWayMerge(base_doc, local_doc, remote_doc) # Finding conflicts print(merge_instance.find_conflicts()) # Output: [(2, \'line2_local\', \'line2_remote\')] # Merging documents print(merge_instance.merge()) # Output: \\"line1nline2_localnline2_remotenline3\\" ``` # Constraints * Each document string may contain multiple lines separated by newline `\'n\'` characters. * Length of each document string: (1 leq |text{text}| leq 10^5) * All lines are considered unique and comparisons are case-sensitive.","solution":"class ThreeWayMerge: def __init__(self, base: str, local: str, remote: str): self.base = base.splitlines() self.local = local.splitlines() self.remote = remote.splitlines() def find_conflicts(self) -> list[tuple[int, str, str]]: conflicts = [] max_lines = max(len(self.base), len(self.local), len(self.remote)) for i in range(max_lines): base_line = self.base[i] if i < len(self.base) else \\"\\" local_line = self.local[i] if i < len(self.local) else \\"\\" remote_line = self.remote[i] if i < len(self.remote) else \\"\\" if local_line != base_line and remote_line != base_line and local_line != remote_line: conflicts.append((i + 1, local_line, remote_line)) return conflicts def merge(self) -> str: merged_lines = [] max_lines = max(len(self.base), len(self.local), len(self.remote)) for i in range(max_lines): base_line = self.base[i] if i < len(self.base) else \\"\\" local_line = self.local[i] if i < len(self.local) else \\"\\" remote_line = self.remote[i] if i < len(self.remote) else \\"\\" if local_line == remote_line: merged_lines.append(local_line) elif local_line == base_line: merged_lines.append(remote_line) elif remote_line == base_line: merged_lines.append(local_line) else: merged_lines.append(local_line) merged_lines.append(remote_line) return \\"n\\".join(merged_lines)"},{"question":"# Binary Search Tree Insertion You are tasked with implementing an insertion method for a Binary Search Tree (BST). A BST is a binary tree in which for each node, the value of all the nodes in the left subtree is less than or equal to the node’s value, and the value of all the nodes in the right subtree is greater than or equal to the node’s value. Task Implement a method named `insert` in the `BinarySearchTree` class that inserts a given value into the BST while maintaining the BST properties. Input * The BST is initially empty or contains some nodes. * The `insert` method should take a single integer value ( text{val} ) to be inserted. Output * The method does not return any value. It modifies the BST in place. Constraints * Duplicates are allowed. In case of a duplicate, the new node should be inserted in the right subtree. * The values to be inserted are always valid integers. Examples Consider an initially empty BST: Performing `insert(5)` results in a tree with a single node `5`. Performing `insert(3)` results in a tree with root `5` and left child `3`. Performing `insert(7)` results in a tree with root `5`, left child `3`, and right child `7`. Performing `insert(5)` results in the tree now having root `5`, left child `3`, right child `7`, and a right child `5` for the root node. Implementation ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right class BinarySearchTree: def __init__(self): self.root = None def insert(self, val: int) -> None: Inserts a value into the BST. Parameters: - val: (int) The value to be inserted. if self.root is None: self.root = TreeNode(val) else: self._insert_recursive(self.root, val) def _insert_recursive(self, node: TreeNode, val: int) -> None: if val <= node.val: if node.left is None: node.left = TreeNode(val) else: self._insert_recursive(node.left, val) else: if node.right is None: node.right = TreeNode(val) else: self._insert_recursive(node.right, val) # Example usage: bst = BinarySearchTree() bst.insert(5) bst.insert(3) bst.insert(7) bst.insert(5) ``` Additional Information Ensure that the `insert` method handles all edge cases such as inserting into an empty tree, inserting a value that has duplicates, and maintaining the structure of the BST correctly.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right class BinarySearchTree: def __init__(self): self.root = None def insert(self, val: int) -> None: Inserts a value into the BST. Parameters: - val: (int) The value to be inserted. if self.root is None: self.root = TreeNode(val) else: self._insert_recursive(self.root, val) def _insert_recursive(self, node: TreeNode, val: int) -> None: if val <= node.val: if node.left is None: node.left = TreeNode(val) else: self._insert_recursive(node.left, val) else: if node.right is None: node.right = TreeNode(val) else: self._insert_recursive(node.right, val)"},{"question":"# Problem Statement: You are responsible for creating the `LinkedListPalindromeChecker` class that determines if a singly linked list of integers is a palindrome. The function should traverse and assess the nodes without altering the list structure and should achieve optimal time and space efficiency. # Requirements: * Implement the class `LinkedListPalindromeChecker` with a method `is_palindrome` that accepts the head of a linked list and returns a boolean indicating whether the linked list is a palindrome. * Ensure the solution handles various edge cases, e.g., empty list, single element list, etc. * Use a combination of fast and slow pointers to determine the midpoint and facilitate comparison. # Function Signature: ```python class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next class LinkedListPalindromeChecker: def is_palindrome(self, head: ListNode) -> bool: ``` # Expected Input: * A singly linked list of integers, represented by the head node. # Expected Output: * A boolean value (True or False) indicating if the linked list is a palindrome. # Constraints: * The number of nodes in the list is in the range [0, 10^5]. * -10^9 <= ListNode.val <= 10^9 # Implementation Details: 1. Utilize two pointers (fast and slow) to find the midpoint of the list. 2. Reverse the second half of the list while maintaining linkage. 3. Compare the first half and the reversed second half of the list for palindrome check. 4. Restore the second half to its original order, ensuring the linked list remains unmodified. # Example: ```python >>> node1 = ListNode(1) >>> node2 = ListNode(2) >>> node3 = ListNode(2) >>> node4 = ListNode(1) >>> node1.next = node2 >>> node2.next = node3 >>> node3.next = node4 >>> checker = LinkedListPalindromeChecker() >>> checker.is_palindrome(node1) True >>> node5 = ListNode(3) >>> node4.next = node5 >>> checker.is_palindrome(node1) False ``` # Notes: * Avoid additional space complexity by not using extra data structures like arrays. * Focus on achieving the solution with O(n) time complexity and O(1) additional space complexity.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next class LinkedListPalindromeChecker: def is_palindrome(self, head: ListNode) -> bool: if not head or not head.next: return True # Use two pointers to find the midpoint slow, fast = head, head while fast and fast.next: slow = slow.next fast = fast.next.next # Reverse the second half of the list prev, curr = None, slow while curr: next_temp = curr.next curr.next = prev prev = curr curr = next_temp # Compare the first and second half nodes first, second = head, prev while second: # Only need to compare until second part is exhausted if first.val != second.val: return False first, second = first.next, second.next return True"},{"question":"# Coding Assessment Question **Title:** Merging Sorted Arrays into a Single Sorted Array **Context:** You are given two sorted arrays of integers, and your task is to merge them into a single sorted array. The resultant merged array should also be sorted in ascending order. You may not use any built-in sort functions; you must implement the merging logic manually. Your task is to implement the function: 1. `merge_sorted_arrays(arr1: List[int], arr2: List[int]) -> List[int]`: This function should merge two sorted arrays into a single sorted array. **Requirements:** 1. Implement the `merge_sorted_arrays` function that takes two sorted arrays and returns a single sorted array containing all elements from both input arrays. 2. You should ensure the time complexity of the merging process is O(n + m), where `n` and `m` are the lengths of `arr1` and `arr2`, respectively. 3. Pay attention to edge cases like one or both arrays being empty. **Input:** - `arr1` (List[int]): The first sorted array. - `arr2` (List[int]): The second sorted array. **Output:** - A list of integers representing the merged sorted array. **Constraints:** - The elements in both input arrays will be within the range of -10^6 to 10^6. - The length of each array will be between 0 and 10^5. **Examples:** ```python # Example 1 assert merge_sorted_arrays([1, 3, 5], [2, 4, 6]) == [1, 2, 3, 4, 5, 6] # Example 2 assert merge_sorted_arrays([1, 2, 3], []) == [1, 2, 3] # Example 3 assert merge_sorted_arrays([], [4, 5, 6]) == [4, 5, 6] ``` **Performance Expectation:** - The `merge_sorted_arrays` function should execute in O(n + m) time complexity where `n` and `m` are the lengths of the input arrays `arr1` and `arr2`. **Note:** Ensure to handle cases where one or both arrays are empty, as well as cases where arrays have different lengths.","solution":"def merge_sorted_arrays(arr1, arr2): Merges two sorted arrays into a single sorted array. Parameters: arr1 (List[int]): The first sorted array. arr2 (List[int]): The second sorted array. Returns: List[int]: A single sorted array containing all elements from arr1 and arr2. merged_array = [] i, j = 0, 0 while i < len(arr1) and j < len(arr2): if arr1[i] < arr2[j]: merged_array.append(arr1[i]) i += 1 else: merged_array.append(arr2[j]) j += 1 while i < len(arr1): merged_array.append(arr1[i]) i += 1 while j < len(arr2): merged_array.append(arr2[j]) j += 1 return merged_array"},{"question":"# Majority Element Finder You need to implement a function that finds the majority element in a list. A majority element in a list `arr` of size `n` is an element that appears more than `n // 2` times. Assume that the input list always contains a majority element. **Function Signature:** ```python def majority_element(arr: list[int]) -> int: Find the majority element in the list. Args: arr (list[int]): The input list of integers. Returns: int: The majority element. Examples: >>> majority_element([3, 2, 3]) 3 >>> majority_element([2, 2, 1, 1, 1, 2, 2]) 2 >>> majority_element([1, 1, 1, 1, 2, 2, 2]) 1 >>> majority_element([7, 7, 5, 7, 6, 7, 7]) 7 ``` # Input: - A list of integers `arr` of size `n` where `1 <= n <= 10^6` and each element is within the range `-10^6` to `10^6`. # Output: - Return the integer that is the majority element. # Example: ```markdown Example 1: Input: arr = [3, 2, 3] Output: 3 Example 2: Input: arr = [2, 2, 1, 1, 1, 2, 2] Output: 2 Example 3: Input: arr = [1, 1, 1, 1, 2, 2, 2] Output: 1 ``` # Constraints: - The function must run in O(n) time complexity. - The function must use O(1) extra space. # Explanation: 1. Initialize two variables, `candidate` and `count`, to track the current candidate for the majority element and its count. 2. Traverse through each element in the array: - If `count` is 0, set the current element as the `candidate` and set `count` to 1. - If the current element is equal to `candidate`, increment `count`. - Otherwise, decrement `count`. 3. The element stored in `candidate` at the end of traversal is the majority element. Ensure your function handles the edge cases and performs efficiently up to the maximum constraints.","solution":"def majority_element(arr): Find the majority element in the list. Args: arr (list[int]): The input list of integers. Returns: int: The majority element. candidate = None count = 0 for num in arr: if count == 0: candidate = num count = 1 elif num == candidate: count += 1 else: count -= 1 return candidate"},{"question":"# Scenario You are required to implement a similar functionality but for a different group: the top 5 most populous cities in the world for the current year. # Task Write a Python function, `get_most_populous_cities()`, that retrieves the top 5 most populous cities in the world from a specified API. The function should return the details of these cities. # Requirements 1. **Function Signature**: ```python def get_most_populous_cities() -> list[dict[str, str | int]]: ``` 2. **Input**: No input required. The function fetches the data automatically. 3. **Output**: A list of dictionaries, each containing the following keys and their corresponding values: * `City`: Name of the city. * `Country`: Country where the city is located. * `Population`: Current population of the city. * `Ranking`: Rank considering the current population. 4. **Constraints**: * Use the existing endpoints specified in the code snippets. * Ensure the data fetched is for the current year. * Handle potential errors like network issues, missing data or malformed JSON responses. * Ensure unique rankings (no ties in population). # Example ```python [ { \'City\': \'Tokyo\', \'Country\': \'Japan\', \'Population\': 37393128, \'Ranking\': 1 }, { \'City\': \'Delhi\', \'Country\': \'India\', \'Population\': 30290936, \'Ranking\': 2 }, { \'City\': \'Shanghai\', \'Country\': \'China\', \'Population\': 27058479, \'Ranking\': 3 }, { \'City\': \'São Paulo\', \'Country\': \'Brazil\', \'Population\': 21846507, \'Ranking\': 4 }, { \'City\': \'Mexico City\', \'Country\': \'Mexico\', \'Population\': 21671908, \'Ranking\': 5 } ] ``` # Additional Guidelines * You may reuse and modify certain functions from the provided code snippets. * Ensure your function is efficient and includes error handling for robustness. * Write a few test cases to validate your implementation.","solution":"import requests def get_most_populous_cities() -> list[dict[str, str | int]]: Fetches the top 5 most populous cities in the world for the current year. Returns: list[dict[str, str | int]]: List of dictionaries containing information about the top 5 most populous cities. url = \\"https://example.com/api/population-cities\\" try: response = requests.get(url) response.raise_for_status() # If the HTTP request returned an unsuccessful status code data = response.json() # Sorting cities by population and taking the top 5 most_populous = sorted(data, key=lambda x: x[\'Population\'], reverse=True)[:5] # Adding Ranking to each city for rank, city in enumerate(most_populous, start=1): city[\'Ranking\'] = rank return most_populous except requests.RequestException as e: print(f\\"Request error: {e}\\") return [] except (ValueError, KeyError) as e: print(f\\"Data processing error: {e}\\") return []"},{"question":"# Problem Statement You are given a string containing lowercase letters and an integer `k`. Your task is to implement a function that identifies the k most frequent characters in the string and returns them in descending order based on their frequency. If two characters have the same frequency, order them lexicographically. # Function Details Function Name: `top_k_frequent` * **Input**: * `s` (string): The input string containing lowercase letters. * `k` (int): The number of top frequent characters to return. * **Output**: * A list of `k` characters in descending order of their frequency. # Example ```python >>> top_k_frequent(\\"aabbccdd\\", 2) [\'a\', \'b\'] >>> top_k_frequent(\\"aabbccdd\\", 3) [\'a\', \'b\', \'c\'] >>> top_k_frequent(\\"abcabcabc\\", 1) [\'a\'] ``` # Constraints 1. `0 <= len(s) <= 10^5` 2. `1 <= k <= 26` (since there are at most 26 letters in the English alphabet) 3. In case `k` is greater than the number of unique characters in the string, return all unique characters sorted by frequency and then lexicographically. # Note - Use efficient data structures and algorithms to handle large string lengths up to 100,000 characters. - Consider edge cases such as an empty string, strings with all unique characters, and strings where multiple characters have the same frequency. Good luck, and ensure your solution is optimized for performance and adheres to common principles for achieving the task.","solution":"from collections import Counter def top_k_frequent(s, k): Identifies the k most frequent characters in the string and returns them in descending order based on their frequency. If two characters have the same frequency, order them lexicographically. :param s: Input string containing lowercase letters. :param k: Number of top frequent characters to return. :return: List of k characters in descending order of their frequency. # Count frequency of each character in the string freq = Counter(s) # Sort characters first by frequency (descending) then lexicographically (ascending) sorted_chars = sorted(freq.keys(), key=lambda x: (-freq[x], x)) # Return the top k characters return sorted_chars[:k]"},{"question":"# Problem Statement: You are asked to create a Python function that interacts with the OpenWeatherMap API to fetch the current weather information for a provided city. The fetched data should be formatted for readability and saved into a local file. The function should handle edge cases like invalid API keys, non-existent city names, or network failures gracefully. # Function Signature: ```python def fetch_and_save_weather(city: str, api_key: str, filename: str) -> None: Fetches current weather information for the given city and saves the details to a file. Parameters: city (str): Name of the city to fetch the weather for. api_key (str): OpenWeatherMap API key. filename (str): Name of the file to save the weather details. Raises: ValueError: If `api_key` is blank or invalid. IOError: If there is an error while writing to the file. ``` # Input: - `city`: A string representing the city name. - `api_key`: A string representing the OpenWeatherMap API key. - `filename`: A string representing the name of the file where the weather details will be saved. # Output: - None (Details should be written to the given file). # Example Invocation: ```python # Fetch weather information for the city \'London\' and save to \'weather.txt\' fetch_and_save_weather(\'London\', os.environ.get(\\"WEATHER_API_KEY\\", \\"\\"), \'weather.txt\') ``` # Constraints: 1. **API Key Handling**: The function should raise a `ValueError` if `api_key` is blank. 2. **Error Handling**: Gracefully handle cases where the city does not exist, the API key is invalid, or there\'s a network failure. Include retries for transient network issues. 3. **File Operations**: Ensure proper reading and writing from and to files, respectively. Handle file I/O errors appropriately. 4. **Performance**: Optimize network calls to avoid unnecessary delays, and ensure the data is written efficiently. Use the following OpenWeatherMap API endpoint to fetch weather information: ``` http://api.openweathermap.org/data/2.5/weather?q=<city>&appid=<api_key> ``` # Notes: * **Authentication is made via the API key**. Include the API key in the request URL. * Do not hardcode the filename; pass it as a function argument. * Include comments and document the code thoroughly to explain the logic and error handling involved. * Format the weather details in a readable way before saving them to the file (e.g., using JSON pretty print or formatted strings).","solution":"import requests import json import os def fetch_and_save_weather(city: str, api_key: str, filename: str) -> None: Fetches current weather information for the given city and saves the details to a file. Parameters: city (str): Name of the city to fetch the weather for. api_key (str): OpenWeatherMap API key. Must not be blank. filename (str): Name of the file to save the weather details. Raises: ValueError: If `api_key` is blank or invalid. IOError: If there is an error while writing to the file. if not api_key: raise ValueError(\\"API key is required and cannot be blank.\\") url = f\\"http://api.openweathermap.org/data/2.5/weather?q={city}&appid={api_key}\\" try: response = requests.get(url) response.raise_for_status() # Raise an HTTPError for bad responses weather_data = response.json() # Check if the city was found if weather_data.get(\\"cod\\") != 200: raise ValueError(f\\"City `{city}` not found or API key invalid.\\") # Formatting the weather data that you want to save formatted_data = json.dumps(weather_data, indent=4) # Writing weather data to the file with open(filename, \'w\') as file: file.write(formatted_data) except requests.exceptions.RequestException as e: raise RuntimeError(f\\"Network-related issue occurred: {e}\\") except IOError as e: raise IOError(f\\"File I/O error: {e}\\")"},{"question":"# Question: Graph Traversal Shortest Path Given a graph represented as an adjacency list, implement a function to find the shortest path between two nodes using the Breadth-First Search (BFS) algorithm. The graph is undirected and can contain cycles. You are required to enhance this function to handle the following: 1. **Edge Weights**: Adapt your BFS approach to handle weighted edges, ensuring that the function can still find the shortest path efficiently. 2. **Handling Disconnected Graphs**: Ensure your function can gracefully handle cases where the graph is disconnected, and return appropriate output when no path exists between the given nodes. Your function signature should be consistent with the original context, taking in the graph as an adjacency list, starting node, and ending node. # Input * A dictionary `graph` where the keys are nodes, and the values are lists of tuples `(neighbor, weight)` representing the neighboring nodes and the respective edge weights. * A node `start` from which the search starts. * A node `end` where the search finishes. # Output * A list of nodes representing the shortest path from `start` to `end`. * If no path exists, return an empty list. # Constraints * The graph can contain up to 10000 nodes. * Edge weights are non-negative integers. * Ensure that your implementation efficiently computes the shortest path within the given constraints. # Example ```python graph = { \'A\': [(\'B\', 1), (\'C\', 4)], \'B\': [(\'A\', 1), (\'D\', 2)], \'C\': [(\'A\', 4), (\'D\', 3), (\'E\', 2)], \'D\': [(\'B\', 2), (\'C\', 3), (\'E\', 1)], \'E\': [(\'C\', 2), (\'D\', 1)] } print(shortest_path(graph, \'A\', \'E\')) # Expected Output: [\'A\', \'B\', \'D\', \'E\'] or [\'A\', \'C\', \'E\'] ``` # Note Validate your implementation with additional test cases, including graphs with cycles, varying edge weights, and disconnected components.","solution":"import heapq def shortest_path(graph, start, end): Finds the shortest path between two nodes in a weighted, undirected graph using Dijkstra\'s algorithm. Returns an empty list if no path exists between start and end. # Min-heap to store (distance so far, current node, path so far) heap = [(0, start, [start])] # Dictionary to store the shortest path to each node found so far shortest_paths = {start: (0, [start])} while heap: current_distance, current_node, path = heapq.heappop(heap) if current_node == end: return path for neighbor, weight in graph.get(current_node, []): distance = current_distance + weight if neighbor not in shortest_paths or distance < shortest_paths[neighbor][0]: shortest_paths[neighbor] = (distance, path + [neighbor]) heapq.heappush(heap, (distance, neighbor, path + [neighbor])) return [] # Example usage: # graph = { # \'A\': [(\'B\', 1), (\'C\', 4)], # \'B\': [(\'A\', 1), (\'D\', 2)], # \'C\': [(\'A\', 4), (\'D\', 3), (\'E\', 2)], # \'D\': [(\'B\', 2), (\'C\', 3), (\'E\', 1)], # \'E\': [(\'C\', 2), (\'D\', 1)] # } # # print(shortest_path(graph, \'A\', \'E\')) # Output: [\'A\', \'B\', \'D\', \'E\']"},{"question":"**Question**: Subarray Sum Equals K Given an array of integers and an integer `k`, you need to find the total number of continuous subarrays whose sum equals to `k`. Your task is to write a function that computes this total. # Function Signature ```python def subarray_sum(nums: List[int], k: int) -> int: pass ``` # Input The function should take in two arguments: - `nums (List[int])`: A list of integers. - `k (int)`: The target sum for the subarrays. # Output The function should return an integer: - The number of continuous subarrays that sum to `k`. # Constraints - `1 ≤ len(nums) ≤ 2 * 10^4` - `-1000 ≤ nums[i] ≤ 1000` - `-10^7 ≤ k ≤ 10^7` # Examples ```python >>> subarray_sum([1, 1, 1], 2) 2 >>> subarray_sum([1, 2, 3], 3) 2 ``` # Performance Requirement - The function should have a time complexity of O(n), handling the largest input sizes efficiently. # Additional Context (if needed) You are analyzing a sequence of transactions to identify any continuous periods where the sum of the transactions equals a specific target value. This problem could help in identifying fraudulent activities or analyzing financial metrics.","solution":"from typing import List def subarray_sum(nums: List[int], k: int) -> int: count = 0 current_sum = 0 prefix_sums = {0: 1} # Dictionary to store the cumulative sum and its frequency for num in nums: current_sum += num if current_sum - k in prefix_sums: count += prefix_sums[current_sum - k] if current_sum in prefix_sums: prefix_sums[current_sum] += 1 else: prefix_sums[current_sum] = 1 return count"},{"question":"# Problem Statement Design a system that can store, retrieve, and manipulate a collection of Contacts. Each Contact has a name, phone number, and email address. Implement the `ContactBook` class that provides functionalities to manage the contacts efficiently. # Requirements 1. **Class Definition**: Create a class called `ContactBook`. 2. **Methods**: - `__init__(self)`: Initializes an empty contact book. - `add_contact(self, name: str, phone: str, email: str)`: Adds a contact to the book. - `remove_contact(self, name: str)`: Removes a contact by name. - `get_contact(self, name: str) -> dict`: Retrieves the contact details by name. - `update_contact(self, name: str, phone: str = None, email: str = None)`: Updates the contact details by name. - `list_contacts(self) -> list[dict]`: Lists all contacts in the contact book. 3. **Error Handling**: Properly handle cases where contacts do not exist. 4. **Performance Requirements**: * Ensure contact lookups, addition, and removals are optimized for performance. * Disable contact name duplication: each contact should be unique by name. 5. **Data Integrity**: * Ensure that the phone number and email address are formatted correctly (basic validation needed). * Ensure that no duplicate phone numbers or email addresses are allowed in the contact book. # Constraints - All contact names are unique. - Phone numbers must be valid (e.g., only digits, length between 7 and 15). - Email addresses must be valid (e.g., contain \\"@\\" and \\".\\"). - The contact book can have a maximum of 1000 contacts. - The input data will always be well-formed and valid. # Input/Output Structure * **Input**: Operations are method calls with parameters. * **Output**: Methods `get_contact` and `list_contacts` return contact details, others do not return any values. # Example ```python # Example Usage contact_book = ContactBook() contact_book.add_contact(\\"Alice\\", \\"1234567890\\", \\"alice@example.com\\") contact_book.add_contact(\\"Bob\\", \\"0987654321\\", \\"bob@example.com\\") print(contact_book.get_contact(\\"Alice\\")) # Output: {\\"name\\": \\"Alice\\", \\"phone\\": \\"1234567890\\", \\"email\\": \\"alice@example.com\\"} contact_book.update_contact(\\"Alice\\", email=\\"alice_new@example.com\\") print(contact_book.get_contact(\\"Alice\\")) # Output: {\\"name\\": \\"Alice\\", \\"phone\\": \\"1234567890\\", \\"email\\": \\"alice_new@example.com\\"} contact_book.remove_contact(\\"Bob\\") print(contact_book.list_contacts()) # Output: [{\\"name\\": \\"Alice\\", \\"phone\\": \\"1234567890\\", \\"email\\": \\"alice_new@example.com\\"}] ```","solution":"class ContactBook: def __init__(self): self.contacts = {} def add_contact(self, name: str, phone: str, email: str): if self._validate_phone(phone) and self._validate_email(email): if name not in self.contacts: self.contacts[name] = {\'phone\': phone, \'email\': email} def remove_contact(self, name: str): if name in self.contacts: del self.contacts[name] def get_contact(self, name: str) -> dict: return self.contacts.get(name, {}) def update_contact(self, name: str, phone: str = None, email: str = None): if name in self.contacts: if phone and self._validate_phone(phone): self.contacts[name][\'phone\'] = phone if email and self._validate_email(email): self.contacts[name][\'email\'] = email def list_contacts(self) -> list: return [{\'name\': name, \'phone\': details[\'phone\'], \'email\': details[\'email\']} for name, details in self.contacts.items()] def _validate_phone(self, phone: str) -> bool: return phone.isdigit() and 7 <= len(phone) <= 15 def _validate_email(self, email: str) -> bool: return \\"@\\" in email and \\".\\" in email"},{"question":"# Coding Question: Most Frequent Element in Subarray Background Given an array of integers, you are required to find the most frequent element in any subarray of a given length. This problem requires efficiently calculating the most frequent element while considering performance for large datasets. Objective Write a function `most_frequent_element(nums: list, k: int) -> int` that determines the most frequent element in every contiguous subarray of length `k` and returns the element that appears most frequently across all these subarrays. Input * A list of integers representing the array of numbers. * A single integer representing the length `k` of the subarray. Output * Return an integer representing the most frequent element appearing in the subarrays of length `k`. Constraints * The array of numbers will have a positive length. * All elements in the array are integers. * `k` is a positive integer and less than or equal to the length of the array. Example ```python >>> most_frequent_element([1, 2, 2, 3, 1, 2, 2], 3) 2 >>> most_frequent_element([4, 3, 7, 3, 4, 7, 3, 7], 4) 3 ``` Notes * The use of sliding window techniques will help achieve an optimal solution. * Ensure to handle edge cases such as: * Subarrays containing multiple elements with the same highest frequency. Edge Cases * If the array is empty or `k` is less than or equal to zero, the function should raise appropriate error messages. Validation Your solution should be efficient enough to handle arrays of large size (up to 10^5 elements) given that `k` is within the valid range.","solution":"from collections import Counter def most_frequent_element(nums: list, k: int) -> int: Find the most frequent element in every contiguous subarray of length k. Returns the element that appears most frequently across all these subarrays. if not nums or k <= 0: raise ValueError(\\"Array must not be empty and k must be a positive integer.\\") n = len(nums) if k > n: raise ValueError(\\"k must be less than or equal to the length of the array.\\") frequency_counter = Counter() current_window = Counter() # Initialize the current window with the first k elements for i in range(k): current_window[nums[i]] += 1 # Update the frequency counter with the initial window max_freq_element = max(current_window, key=current_window.get) frequency_counter[max_freq_element] += 1 for i in range(k, n): # Slide the window to the right outgoing_element = nums[i - k] incoming_element = nums[i] current_window[outgoing_element] -= 1 if current_window[outgoing_element] == 0: del current_window[outgoing_element] current_window[incoming_element] += 1 # Find the most frequent element in the current window current_max_freq_element = max(current_window, key=current_window.get) frequency_counter[current_max_freq_element] += 1 # Find the overall most frequent element in all subarrays overall_max_freq_element = max(frequency_counter, key=frequency_counter.get) return overall_max_freq_element"},{"question":"Matrix Diagonal Sum You are tasked with implementing a function that calculates the sum of elements on the primary and secondary diagonal of a square matrix ( n times n ). The primary diagonal is from the top-left to bottom-right, and the secondary diagonal is from the top-right to bottom-left. # Function Signature ```python def diagonal_sum(matrix: List[List[int]]) -> int: pass ``` # Input * (text{matrix}) (2 ≤ text{len(matrix)} ≤ 1000): A square matrix where each element is an integer ( -10^6 leq text{matrix[i][j]} leq 10^6 ). # Output * Returns an integer representing the sum of the primary and secondary diagonal elements. * If a cell belongs to both diagonals (i.e., it is the center of an odd-sized matrix), count it only once. # Example ```python >>> matrix = [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ] >>> diagonal_sum(matrix) 25 # Primary diagonal: 1 + 5 + 9 = 15 # Secondary diagonal: 3 + 5 + 7 = 15 # Since \'5\' is counted twice, the sum is 15 + 15 - 5 = 25 >>> matrix = [ ... [1, 2], ... [3, 4] ... ] >>> diagonal_sum(matrix) 10 # Primary diagonal: 1 + 4 = 5 # Secondary diagonal: 2 + 3 = 5 # The sum is 5 + 5 = 10 ``` # Constraints * Make sure to handle matrices of large size within efficient time complexity. * Consider edge cases where the matrix has the minimum size (2x2). # Notes 1. Each element of the matrix is bounded between ( -10^6 ) and ( 10^6 ). 2. Properly manage the indexing to avoid counting the center element twice for odd-sized matrices.","solution":"from typing import List def diagonal_sum(matrix: List[List[int]]) -> int: n = len(matrix) primary_sum = 0 secondary_sum = 0 for i in range(n): primary_sum += matrix[i][i] secondary_sum += matrix[i][n - 1 - i] if n % 2 == 1: center_element = matrix[n // 2][n // 2] return primary_sum + secondary_sum - center_element else: return primary_sum + secondary_sum"},{"question":"# Coding Question Implement a function `reverse_subarray` that takes an integer array and a pair of integers representing the start and end indices of a subarray. The function should reverse the subarray within the original array and return the modified array. Ensure you handle edge cases appropriately, such as invalid indices. Function Signature ```python def reverse_subarray(arr: List[int], start: int, end: int) -> List[int]: pass ``` Input and Output Format * **Input**: An array of integers and two integers representing the start and end indices. * **Output**: The array with the specified subarray reversed. Examples ```python >>> reverse_subarray([1, 2, 3, 4, 5], 1, 3) [1, 4, 3, 2, 5] >>> reverse_subarray([7, 8, 9, 10], 0, 2) [9, 8, 7, 10] >>> reverse_subarray([1, 2, 3, 4, 5], 0, 4) [5, 4, 3, 2, 1] >>> reverse_subarray([1], 0, 0) [1] ``` Constraints * `0 <= start <= end < len(arr)` * If `start` or `end` is out of the valid range, raise an `IndexError` with the message `\\"Invalid start or end index\\"`. Requirements * Implement error handling for invalid index inputs. * Ensure the implementation is efficient and runs in `O(n)` time complexity, where `n` is the length of the input array.","solution":"from typing import List def reverse_subarray(arr: List[int], start: int, end: int) -> List[int]: Reverses a subarray from start to end index in the given list. Parameters: arr (List[int]): The input list of integers. start (int): The starting index of the subarray. end (int): The ending index of the subarray. Returns: List[int]: The list after reversing the specified subarray. Raises: IndexError: If start or end is out of the valid range. if start < 0 or end >= len(arr) or start > end: raise IndexError(\\"Invalid start or end index\\") arr[start:end+1] = arr[start:end+1][::-1] return arr"},{"question":"# String Permutation Check **Context**: As a software developer, you are asked to work on an algorithm that verifies if one string is a permutation of another. This is a fundamental problem in computer science with applications ranging from cryptography to data validation. **Task**: Implement a function `is_permutation(str1: str, str2: str) -> bool` that determines if one string is a permutation of another. Two strings are permutations if they contain the same characters with the same frequencies. **Guidelines**: 1. **Input**: * `str1` and `str2`, two strings composed of ASCII characters. 2. **Output**: * `True` if `str1` is a permutation of `str2`. * `False` otherwise. 3. **Constraints**: * Assume the input strings can be of considerable length. * Ignore case differences (i.e., case insensitive check). * Handle any special characters as normal characters, treating them equally. **Performance Requirements**: * The solution should have a time complexity of O(n), where n is the length of the strings. * Aim for space complexity within O(1) beyond the input string storage. **Example**: ```python >>> is_permutation(\\"Listen\\", \\"Silent\\") True >>> is_permutation(\\"Triangle\\", \\"Integral\\") True >>> is_permutation(\\"Apple\\", \\"Pabble\\") False >>> is_permutation(\\"Hello, World!\\", \\"Ld!roeW ,lHoll\\") True >>> is_permutation(\\"Test\\", \\"T estt\\") False >>> is_permutation(\\"\\", \\"\\") True ``` Implement your solution in the function `is_permutation`. --- This new question aligns with the original one by focusing on a common computer science problem, utilizes string manipulation, and has similar complexity and requirements.","solution":"def is_permutation(str1: str, str2: str) -> bool: Determine if str1 is a permutation of str2. Case insensitive comparison, treat special characters as normal characters. if len(str1) != len(str2): return False # Normalize the strings to lowercase str1 = str1.lower() str2 = str2.lower() # Use a fixed-size list to count frequencies of ASCII characters char_count = [0] * 128 # Assuming ASCII input # Count characters in str1 for char in str1: char_count[ord(char)] += 1 # Subtract counts using str2 for char in str2: char_count[ord(char)] -= 1 if char_count[ord(char)] < 0: return False return True"},{"question":"Problem Statement You need to implement a function that finds all possible word breaks for a given string, using a provided dictionary of words. A word break is a way to partition the string into a space-separated sequence of dictionary words. # Function Signature ```python def word_breaks(s: str, word_dict: List[str]) -> List[str]: ``` # Input - `s`: A string representing the input string. - `word_dict`: A list of strings representing the dictionary of words. # Output - Returns a list of strings, where each string is a valid word break of the input string. # Constraints - The length of the input string `s` will not exceed 20. - The total number of words in the dictionary will not exceed 1000. - The length of each word in the dictionary will not exceed 10. - The dictionary will not contain duplicate words. - The input string and dictionary words will contain only lowercase English letters. # Example ```python s = \\"catsanddog\\" word_dict = [\\"cat\\", \\"cats\\", \\"and\\", \\"sand\\", \\"dog\\"] print(word_breaks(s, word_dict)) # Output: [\\"cats and dog\\", \\"cat sand dog\\"] s = \\"pineapplepenapple\\" word_dict = [\\"apple\\", \\"pen\\", \\"applepen\\", \\"pine\\", \\"pineapple\\"] print(word_breaks(s, word_dict)) # Output: [\\"pine apple pen apple\\", \\"pineapple pen apple\\", \\"pine applepen apple\\"] s = \\"catsandog\\" word_dict = [\\"cats\\", \\"dog\\", \\"sand\\", \\"and\\", \\"cat\\"] print(word_breaks(s, word_dict)) # Output: [] ``` # Note - You can reuse dictionary words multiple times in the word break. - The order of the elements in the output list does not matter. # Explanation - In the first example, there are two ways to break the string \\"catsanddog\\" using the given dictionary: \\"cats and dog\\" or \\"cat sand dog\\". - In the second example, there are three ways to break the string \\"pineapplepenapple\\": \\"pine apple pen apple\\", \\"pineapple pen apple\\", or \\"pine applepen apple\\". - In the third example, there is no valid way to break the string \\"catsandog\\" using the given dictionary.","solution":"from typing import List def word_breaks(s: str, word_dict: List[str]) -> List[str]: Finds all possible word breaks for a given string s using a provided dictionary of words. def backtrack(start): if start == len(s): return [[]] if start in memo: return memo[start] results = [] for end in range(start + 1, len(s) + 1): word = s[start:end] if word in word_dict_set: for rest in backtrack(end): results.append([word] + rest) memo[start] = results return results word_dict_set = set(word_dict) memo = {} results = backtrack(0) return [\' \'.join(words) for words in results]"},{"question":"# Subarray Sum Problem Context You are working on a financial application that analyzes investment portfolios. A common task is to determine the potential returns of sub-intervals within a series of daily returns. Given an array of integers representing daily returns, your task is to find the maximum possible sum of any contiguous subarray. This will help in advising which sub-period had the best performance. Problem Statement Implement a function `max_subarray_sum(arr: List[int]) -> int` that returns the maximum sum of any contiguous subarray within the given list of daily returns. Input * A list of integers `arr` where each integer represents a daily return. * The length of the list will be between 1 and 10^5, and each integer will be in the range `[-10^4, 10^4]`. Output * An integer representing the maximum sum of any contiguous subarray. Constraints * The subarray can be as small as one element. * The input list will have at least one element. Performance Requirements * The solution should run in O(n) time complexity, where n is the length of the input list. Example ```python def max_subarray_sum(arr: List[int]) -> int: Finds the maximum sum of any contiguous subarray in the provided list. Args: arr (List[int]): List of daily returns. Returns: int: Maximum sum of any contiguous subarray. max_so_far = arr[0] max_ending_here = arr[0] for i in range(1, len(arr)): max_ending_here = max(arr[i], max_ending_here + arr[i]) max_so_far = max(max_so_far, max_ending_here) return max_so_far # Test Cases print(max_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4])) # Output: 6 print(max_subarray_sum([1])) # Output: 1 print(max_subarray_sum([-1, -2, -3, -4])) # Output: -1 print(max_subarray_sum([5, -2, 3, -1, 2])) # Output: 7 print(max_subarray_sum([3, -2, 5, -1])) # Output: 6 ```","solution":"from typing import List def max_subarray_sum(arr: List[int]) -> int: Finds the maximum sum of any contiguous subarray in the provided list. Args: arr (List[int]): List of daily returns. Returns: int: Maximum sum of any contiguous subarray. max_so_far = arr[0] max_ending_here = arr[0] for i in range(1, len(arr)): max_ending_here = max(arr[i], max_ending_here + arr[i]) max_so_far = max(max_so_far, max_ending_here) return max_so_far"},{"question":"# Problem Statement Write a function to determine the minimum number of coin flips required to make all coins show the same face. You are given a list representing a sequence of coin flips, where 0 represents heads and 1 represents tails. The goal is to either all be heads (0) or all be tails (1). # Function Signature ```python def min_flips_to_same_face(coins: list[int]) -> int: Given a list of integers, where each integer is either 0 (heads) or 1 (tails), returns the minimum number of flips required to make all elements in the list the same. Returns an integer representing the minimum number of coin flips. ``` # Input Constraints - `coins` is a non-empty list consisting of only 0s and 1s. - The length of `coins` is between 1 and 10^6. # Examples ```python >>> min_flips_to_same_face([0, 1, 1, 0, 1]) 2 >>> min_flips_to_same_face([1, 1, 1, 1, 1]) 0 >>> min_flips_to_same_face([0, 0, 0, 0, 1]) 1 >>> min_flips_to_same_face([0]) 0 ``` # Notes - Count the number of heads (0s) and tails (1s) in the list. - The minimum flips required will be the lesser of the two counts, as this will be the number of flips needed to make all coins either heads or tails. - Ensure the function can handle large inputs efficiently.","solution":"def min_flips_to_same_face(coins): Given a list of integers, where each integer is either 0 (heads) or 1 (tails), returns the minimum number of flips required to make all elements in the list the same. Returns an integer representing the minimum number of coin flips. # Count the number of heads (0s) and tails (1s) in the coins list count_heads = coins.count(0) count_tails = len(coins) - count_heads # The minimum number of flips will be the lesser count of heads or tails return min(count_heads, count_tails)"},{"question":"# Question You are asked to implement a new feature for a class `AVLTree` to enhance its handling of balanced tree operations. The class currently supports basic AVL tree insertions and rotations to maintain balance. # Requirements Write a new method `split_and_merge` in the given `AVLTree` class. This method should: 1. **Split the tree** into two separate AVL trees based on a given pivot value. 2. **Merge two AVL trees** into a single balanced AVL tree. 3. **Ensure** that all tree properties are maintained during these operations. # Function Signature ```python def split_and_merge(self, pivot: int, merge_tree: \'AVLTree\') -> \'AVLTree\': Split the tree into two AVL trees based on the pivot value and merge it with another AVL tree. Args: pivot: The value at which the tree should be split. merge_tree: The AVLTree to be merged after the split. Returns: A new AVL tree that combines the split parts and the merge_tree. Example: >>> tree1 = AVLTree() >>> tree1.insert(20) >>> tree1.insert(30) >>> tree1.insert(10) >>> tree2 = AVLTree() >>> tree2.insert(25) >>> tree2.insert(35) >>> new_tree = tree1.split_and_merge(15, tree2) >>> new_tree.preorder_traversal() # doctest: +ELLIPSIS [20, 10, 30, 25, 35, ...] pass ``` # Constraints 1. The split should maintain the balance properties of an AVL tree for both resulting trees. 2. The merge operation should combine trees efficiently, maintaining AVL balance. 3. The pivot may or may not exist in the tree; handle both scenarios gracefully. # Input * `pivot`: An integer to determine where to split the tree. * `merge_tree`: An instance of `AVLTree` that needs to be merged. # Output * A new instance of `AVLTree` which is the result of merging the split portions with `merge_tree`. # Assumptions 1. The class `AVLTree` and its basic methods (`insert`, `preorder_traversal`, `rotate_left`, `rotate_right`, etc.) have been correctly implemented. 2. The given pivot value can be anywhere within the integer range. 3. Both the current tree and the merge_tree are initially balanced AVL trees. # Scenarios The implementation will be challenged to: 1. Correctly split the tree around the pivot value, maintaining balance and structure. 2. Efficiently merge the resulting trees with another AVL tree while preserving AVL properties. 3. Handle various scenarios of pivots, such as a pivot at the root, in the middle, or at the leaf.","solution":"class AVLTree: class Node: def __init__(self, key, height=1, left=None, right=None): self.key = key self.height = height self.left = left self.right = right def __init__(self): self.root = None def height(self, node): if not node: return 0 return node.height def update_height(self, node): if node: node.height = max(self.height(node.left), self.height(node.right)) + 1 def balance_factor(self, node): if not node: return 0 return self.height(node.left) - self.height(node.right) def rotate_right(self, y): x = y.left T2 = x.right x.right = y y.left = T2 self.update_height(y) self.update_height(x) return x def rotate_left(self, x): y = x.right T2 = y.left y.left = x x.right = T2 self.update_height(x) self.update_height(y) return y def rebalance(self, node): self.update_height(node) balance = self.balance_factor(node) if balance > 1: if self.balance_factor(node.left) < 0: node.left = self.rotate_left(node.left) return self.rotate_right(node) if balance < -1: if self.balance_factor(node.right) > 0: node.right = self.rotate_right(node.right) return self.rotate_left(node) return node def _insert(self, node, key): if not node: return self.Node(key) if key < node.key: node.left = self._insert(node.left, key) else: node.right = self._insert(node.right, key) return self.rebalance(node) def insert(self, key): self.root = self._insert(self.root, key) def preorder_traversal(self, node): if not node: return [] return [node.key] + self.preorder_traversal(node.left) + self.preorder_traversal(node.right) def merge_trees(self, tree1, tree2): # Convert tree2 to list and insert all keys into tree1 def tree_to_list(node): if not node: return [] return tree_to_list(node.left) + [node.key] + tree_to_list(node.right) keys = tree_to_list(tree2.root) for key in keys: tree1.insert(key) return tree1 def split_and_merge(self, pivot, merge_tree): # Helper function to split tree into two trees around pivot def split_tree(node, pivot): if not node: return None, None if node.key <= pivot: small, large = split_tree(node.right, pivot) node.right = small return node, large else: small, large = split_tree(node.left, pivot) node.left = large return small, node left_tree_root, right_tree_root = split_tree(self.root, pivot) left_tree = AVLTree() left_tree.root = left_tree_root right_tree = AVLTree() right_tree.root = right_tree_root # Merge left_tree with merge_tree result_tree = self.merge_trees(left_tree, merge_tree) # Merge result_tree with right_tree result_tree = self.merge_trees(result_tree, right_tree) return result_tree"},{"question":"# Problem Statement You are tasked to write a function that calculates the number of unique combinations of teams that can be formed from a list of candidates, where the size of any team must fall within a given range. The order of candidates in a team does not matter, and each candidate can be chosen only once per team. # Function Signature ```python def count_team_combinations(candidates: int, min_team_size: int, max_team_size: int) -> int: ``` # Input 1. `candidates` (int): The total number of available candidates. This should be a positive integer greater than 0. 2. `min_team_size` (int): The minimum number of candidates required to form a team. This should be at least 1 and no more than the number of candidates. 3. `max_team_size` (int): The maximum number of candidates that can be in a team. This should be at least equal to the `min_team_size` and no more than the number of candidates. # Output * Returns an integer representing the number of unique combinations of teams that can be formed within the specified range of sizes. # Rules and Constraints 1. The value of `min_team_size` should be less than or equal to `max_team_size`. 2. The value of `max_team_size` should not exceed the total number of `candidates`. 3. Ensure your solution handles large values efficiently. # Example ```python count_team_combinations(6, 2, 3) # Should return 25 ``` # Explanation - For 6 candidates and a minimum team size of 2: - Teams of size 2: ( binom{6}{2} = 15 ) - Teams of size 3: ( binom{6}{3} = 20 ) - Total: ( 15 + 20 = 35 ) Thus, there are 35 unique combinations of teams that can be formed within the range of 2 to 3 candidates. # Performance Requirements Your implementation should efficiently compute the result, making effective use of combinatorics principles. Avoid recomputation by employing caching or dynamic programming methods where appropriate. # Hints 1. You can make use of Python\'s `math.comb` function (available in Python 3.8+) to calculate combinations. 2. Remember to handle edge cases such as when `min_team_size` equals `max_team_size` or when the number of candidates is minimal.","solution":"import math def count_team_combinations(candidates: int, min_team_size: int, max_team_size: int) -> int: Calculates the number of unique combinations of teams that can be formed from a list of candidates, where the size of any team must fall within a given range. total_combinations = 0 for team_size in range(min_team_size, max_team_size + 1): total_combinations += math.comb(candidates, team_size) return total_combinations"},{"question":"# String Reversals and Their Properties You are tasked to design two functions `reverse_string` and `is_palindrome` that manipulate and inspect strings for their properties. # Function Specifications Function 1: Reverse String ```python def reverse_string(s: str) -> str: This function takes a string and returns its reverse. Args: s : str : input string. Returns: str : the reversed string. ``` Function 2: Is Palindrome ```python def is_palindrome(s: str) -> bool: This function checks whether a given string is a palindrome. Args: s : str : input string. Returns: bool : True if the string is a palindrome, False otherwise. ``` # Input/Output Format * **Input**: - `s`: A string which could contain uppercase and lowercase letters and possibly spaces. * **Output**: - For `reverse_string`: Returns the reversed string. - For `is_palindrome`: Returns True if the input string is a palindrome, False otherwise. # Constraints - The input string `s` will have at least 1 character and at most 1000 characters. - For checking palindrome, consider only alphanumeric characters and ignore cases (e.g., \\"A man, a plan, a canal: Panama\\" is considered a palindrome). - Handle exceptions and edge cases where inputs do not meet the specified constraints. # Example Example 1: Reverse String Input: ```python s = \\"Hello, World!\\" ``` Output: ```python \\"!dlroW ,olleH\\" ``` Example 2: Is Palindrome Input: ```python s = \\"A man, a plan, a canal: Panama\\" ``` Output: ```python True ``` # Implementation Write the implementations of the functions as specified. Ensure you handle edge cases and provide meaningful error messages in exceptional scenarios.","solution":"def reverse_string(s: str) -> str: This function takes a string and returns its reverse. Args: s : str : input string. Returns: str : the reversed string. return s[::-1] def is_palindrome(s: str) -> bool: This function checks whether a given string is a palindrome. Args: s : str : input string. Returns: bool : True if the string is a palindrome, False otherwise. # Filter only alphanumeric characters and convert to lower case filtered_chars = \'\'.join(c.lower() for c in s if c.isalnum()) # Check if the filtered string reads the same forwards and backwards return filtered_chars == filtered_chars[::-1]"},{"question":"# Problem Statement Write a function that validates an IPv4 address and determines its address class (A, B, C, D, or E). # Requirements 1. Implement the function `validate_ip_address(ip: str) -> Tuple[bool, str]`. 2. The function should: - Check if the input string is a valid IPv4 address. - Determine the class of the given IPv4 address if it is valid. 3. Return a tuple where: - The first element is a boolean indicating if the input is a valid IPv4 address. - The second element is a string indicating the address class (`A`, `B`, `C`, `D`, or `E`) if the address is valid, otherwise return `\\"Invalid\\"`. # Input - A single string `ip` representing the IPv4 address. # Output - A tuple consisting of: - A boolean indicating the validity of the IP address. - A string representing the class of the address or `\\"Invalid\\"` if the address is not valid. # IP Address Classes 1. Class A: 1.0.0.0 to 126.255.255.255 2. Class B: 128.0.0.0 to 191.255.255.255 3. Class C: 192.0.0.0 to 223.255.255.255 4. Class D: 224.0.0.0 to 239.255.255.255 (Multicast) 5. Class E: 240.0.0.0 to 255.255.255.255 (Reserved) # Example ```python >>> validate_ip_address(\\"192.168.1.1\\") (True, \'C\') >>> validate_ip_address(\\"255.255.255.255\\") (True, \'E\') >>> validate_ip_address(\\"10.0.0.1\\") (True, \'A\') >>> validate_ip_address(\\"256.1.1.1\\") (False, \'Invalid\') >>> validate_ip_address(\\"Hello.World\\") (False, \'Invalid\') >>> validate_ip_address(\\"127.0.0.1\\") (True, \'A\') ``` # Constraints - Ensure the function efficiently handles possible edge cases and returns appropriate results for invalid inputs.","solution":"from typing import Tuple def validate_ip_address(ip: str) -> Tuple[bool, str]: Validates an IPv4 address and determines its class. Parameters: ip (str): The IPv4 address as a string. Returns: Tuple[bool, str]: A tuple where the first element is a boolean indicating if the IPv4 address is valid, and the second element is a string indicating the address class or \\"Invalid\\". # Split the IP address by \'.\' parts = ip.split(\'.\') # Check if the IP address consists of exactly 4 parts if len(parts) != 4: return (False, \\"Invalid\\") try: # Convert parts to integers and check if they are in the valid range (0-255) octets = [int(part) for part in parts] if not all(0 <= octet <= 255 for octet in octets): return (False, \\"Invalid\\") except ValueError: # If conversion to integer fails, the IP is invalid return (False, \\"Invalid\\") # Determine the class of the IP address based on the first octet first_octet = octets[0] if 1 <= first_octet <= 126: return (True, \\"A\\") elif 128 <= first_octet <= 191: return (True, \\"B\\") elif 192 <= first_octet <= 223: return (True, \\"C\\") elif 224 <= first_octet <= 239: return (True, \\"D\\") elif 240 <= first_octet <= 255: return (True, \\"E\\") else: return (False, \\"Invalid\\")"},{"question":"# Question: Implement a Sparse Matrix Using Linked Lists You are tasked with implementing a sparse matrix data structure to efficiently manage matrices with a high proportion of zero values. Your implementation should use linked lists to store non-zero elements and support basic matrix operations. Your implementation should include the following functions: 1. **`insert(matrix: Dict[int, Dict[int, int]], row: int, col: int, value: int) -> None`**: This function should insert an element with the specified value at the given row and column position. If the value is zero, remove any existing element at the position. 2. **`get(matrix: Dict[int, Dict[int, int]], row: int, col: int) -> int`**: This function should return the value of the element at the given row and column position. If there is no element at the position, return 0. 3. **`display(matrix: Dict[int, Dict[int, int]]) -> None`**: This function should print the matrix in a human-readable format, displaying all elements in their respective positions, with zeroes for positions that are not explicitly stored. Input and Output Formats - The **`insert`** function should take a matrix (represented as a dictionary of dictionaries), a row position, a column position, and an integer value, and insert the value into the matrix at the specified position. - The **`get`** function should take a matrix, a row position, and a column position, and return the value at the specified position. - The **`display`** function should take a matrix and print all elements in their respective positions in the format of a rectangular matrix. Constraints - The matrix should handle a large number of rows and columns efficiently. - Assume the row and column indices are non-negative integers. - Assume the maximum size for the matrix is 1000x1000. Example Usage ```python # Initialize an empty sparse matrix matrix = {} # Insert elements into the matrix insert(matrix, 0, 1, 5) insert(matrix, 1, 0, 3) insert(matrix, 2, 2, 7) # Get and print elements of the matrix print(get(matrix, 0, 1)) # Expected Output: 5 print(get(matrix, 1, 1)) # Expected Output: 0 # Display the matrix display(matrix) # Expected Output: # 0 5 0 0 0 ... # 3 0 0 0 0 ... # 0 0 7 0 0 ... # ... ``` Make sure to handle edge cases and ensure that your implementation can efficiently manage the sparse matrix properties.","solution":"def insert(matrix, row, col, value): Insert an element in the sparse matrix with the given value at the specified row and col. If the value is zero, remove any existing element at the position. if value == 0: if row in matrix and col in matrix[row]: del matrix[row][col] if not matrix[row]: # if the row dictionary is empty, remove the row del matrix[row] else: if row not in matrix: matrix[row] = {} matrix[row][col] = value def get(matrix, row, col): Get the element from the sparse matrix at the specified row and col. If the position does not contain any element, return 0. if row in matrix and col in matrix[row]: return matrix[row][col] return 0 def display(matrix, rows=10, cols=10): Display the sparse matrix in a human-readable format for the given number of rows and cols. for r in range(rows): for c in range(cols): print(get(matrix, r, c), end=\\" \\") print()"},{"question":"# Scenario You have been hired by a logistics company to create a package tracking system. One of the requirements is to validate and categorize tracking numbers based on certain criteria. # Problem Statement Write a function `categorize_tracking_numbers(tracking_numbers: List[str]) -> Dict[str, List[str]]` that takes a list of tracking numbers and categorizes them into multiple lists based on the following conditions: 1. Tracking numbers containing only digits 2. Tracking numbers containing only uppercase letters 3. Tracking numbers containing only lowercase letters 4. Tracking numbers with both letters and digits 5. Tracking numbers exceeding 12 characters in length Ensure that each tracking number falls into only one category, prioritizing the conditions in the order given above. Input * `tracking_numbers` (List of strings): A list of tracking numbers. Output * `result` (Dictionary): A dictionary with keys [\\"digits\\", \\"uppercase\\", \\"lowercase\\", \\"alphanumeric\\", \\"long\\"] and values as lists of tracking numbers that belong to those categories. Function Signature ```python def categorize_tracking_numbers(tracking_numbers: List[str]) -> Dict[str, List[str]]: pass ``` Constraints * The length of each tracking number should not exceed 20 characters. * The function should handle invalid or empty inputs gracefully. * Consider the string as a whole for each condition (i.e., a tracking number \\"ABC123\\" is considered alphanumeric). Example ```python tracking_numbers = [ \\"123456\\", \\"ABCDXYZ\\", \\"abcdef\\", \\"1A2B3C4D\\", \\"a1b2c3d4e5\\", \\"1234567890123\\", ] expected_output = { \\"digits\\": [\\"123456\\"], \\"uppercase\\": [\\"ABCDXYZ\\"], \\"lowercase\\": [\\"abcdef\\"], \\"alphanumeric\\": [\\"1A2B3C4D\\", \\"a1b2c3d4e5\\"], \\"long\\": [\\"1234567890123\\"], } result = categorize_tracking_numbers(tracking_numbers) assert result == expected_output ``` Note Ensure your solution efficiently handles edge cases and large inputs. Document any assumptions made.","solution":"from typing import List, Dict def categorize_tracking_numbers(tracking_numbers: List[str]) -> Dict[str, List[str]]: result = { \\"digits\\": [], \\"uppercase\\": [], \\"lowercase\\": [], \\"alphanumeric\\": [], \\"long\\": [] } for tracking_number in tracking_numbers: if len(tracking_number) > 12: result[\\"long\\"].append(tracking_number) elif tracking_number.isdigit(): result[\\"digits\\"].append(tracking_number) elif tracking_number.isupper() and tracking_number.isalpha(): result[\\"uppercase\\"].append(tracking_number) elif tracking_number.islower() and tracking_number.isalpha(): result[\\"lowercase\\"].append(tracking_number) else: result[\\"alphanumeric\\"].append(tracking_number) return result"},{"question":"# Question: Find the Smallest Prime Factor Sum Context: Given an integer n, the sum of its prime factors is the sum of all prime numbers that divide n, counted with their multiplicities. For example, the prime factorization of 18 is 2 × 3 × 3, and the sum of its prime factors would be 2 + 3 + 3 = 8. You are required to find the integer in a given range that has the smallest sum of its prime factors. Specification: * Function Name: `smallest_prime_factor_sum` * Input: An integer `max_n` (2 ≤ max_n ≤ 10^5). * Output: The integer between 2 and `max_n` that has the smallest sum of its prime factors. * Constraints: Ensure the function operates efficiently within the given constraints. Requirements: Implement the function `smallest_prime_factor_sum` to accept an integer `max_n` and return the integer within the range [2, max_n] that has the smallest sum of its prime factors. Example: ```python def smallest_prime_factor_sum(max_n: int) -> int: pass # Examples print(smallest_prime_factor_sum(10)) # should return 2 print(smallest_prime_factor_sum(100)) # should return 2 ``` Additional Information: * Implement an efficient algorithm to compute prime factors and facilitate comparison across the range. * Optimize for performance as the upper limit for `max_n` is relatively high. * Consider edge cases and handle input validation as necessary.","solution":"def smallest_prime_factor_sum(max_n: int) -> int: def prime_factors_sum(n): sum_pf = 0 # Check for number of twos that divide n while n % 2 == 0: sum_pf += 2 n = n // 2 # n must be odd at this point so check for odd factors for i in range(3, int(n**0.5)+1, 2): while n % i == 0: sum_pf += i n = n // i # This condition is to check if n is a prime number greater than 2 if n > 2: sum_pf += n return sum_pf min_sum = float(\'inf\') min_num = 2 for i in range(2, max_n + 1): pf_sum = prime_factors_sum(i) if pf_sum < min_sum: min_sum = pf_sum min_num = i return min_num"},{"question":"# Context: You are developing a simplified filesystem within a given programming language. Among the features requested, the ability to list all files in a directory, including those within nested subdirectories, is crucial. # Task: Extend the existing `Directory` and `File` classes to include a method for recursively listing all files within a directory and any nested subdirectories. This method should return a list of filenames with their relative paths from the current directory. # Requirements: 1. **Class Modification:** - Add a method `list_files` to the `Directory` class which returns a list of all filenames within the directory and its subdirectories. - Ensure the method maintains the structure and hierarchy in the returned list by including the relative paths of the files. 2. **Edge Case Handling:** - Handle the case where the directory is empty. - Ensure the method does not enter an infinite loop due to circular references (if applicable). 3. **Testing:** - Demonstrate the correctness of your implementation with several test cases, including empty directories, directories with multiple nested subdirectories, and directories with no files. **Input and Output formats:** - **Input:** A `Directory` object. - **Output:** A list of filenames with their relative paths. **Constraints:** - Assume the `Directory` and `File` classes are already defined with necessary attributes and basic methods. - Avoid using built-in or third-party libraries directly for directory traversal. # Example: ```python root = Directory(\\"root\\") dir_a = Directory(\\"dir_a\\") dir_b = Directory(\\"dir_b\\") file_1 = File(\\"file_1.txt\\") file_2 = File(\\"file_2.txt\\") file_3 = File(\\"file_3.txt\\") root.add(dir_a) root.add(file_1) dir_a.add(dir_b) dir_a.add(file_2) dir_b.add(file_3) # Expected output: [\'file_1.txt\', \'dir_a/file_2.txt\', \'dir_a/dir_b/file_3.txt\'] assert root.list_files() == [\'file_1.txt\', \'dir_a/file_2.txt\', \'dir_a/dir_b/file_3.txt\'] ``` **Note:** Handle necessary class structure adjustments but avoid referring directly to some implementations to ensure unique and meaningful contributions.","solution":"class File: def __init__(self, name): self.name = name class Directory: def __init__(self, name): self.name = name self.contents = [] def add(self, item): self.contents.append(item) def list_files(self, prefix=\\"\\"): files_list = [] for item in self.contents: if isinstance(item, File): files_list.append(f\\"{prefix}{item.name}\\") elif isinstance(item, Directory): sub_dir_files = item.list_files(f\\"{prefix}{item.name}/\\") files_list.extend(sub_dir_files) return files_list"},{"question":"# Data Manipulation Challenge **Context**: You are given a pandas DataFrame containing sales data for a retail store. Each entry in the DataFrame represents a transaction and contains information about the item sold, the quantity, the item price, and the transaction date. Your task is to preprocess this data to generate certain summary statistics required for analysis. Function Signature: ```python def process_sales_data(df: pd.DataFrame) -> pd.DataFrame: ``` Parameters: - `df`: a pandas DataFrame with the following columns: - `item`: a string representing the name of the item sold. - `quantity`: an integer representing the quantity of items sold in the transaction. - `price`: a float representing the price of the item. - `transaction_date`: a string in the format \'YYYY-MM-DD\' representing the date of the transaction. Output: - Return a new DataFrame with the following columns: - `item`: the name of the item. - `total_quantity`: the total quantity sold of that item. - `total_sales`: the total sales revenue generated from that item. Constraints: - The input DataFrame will have at least 1 row and at most 1,000,000 rows. - Assume the `transaction_date` is always in the \'YYYY-MM-DD\' format. - Assume no missing values in the input DataFrame. Instructions: 1. Group the input DataFrame by the `item` column. 2. Calculate the total quantity sold for each item. 3. Calculate the total sales revenue for each item, which is the sum of `quantity * price` for all transactions of that item. 4. Return a new DataFrame with the `item`, `total_quantity`, and `total_sales` columns, sorted by `total_sales` in descending order. Example: ```python import pandas as pd data = { \'item\': [\'apple\', \'banana\', \'apple\', \'orange\', \'banana\'], \'quantity\': [10, 5, 6, 7, 3], \'price\': [1.0, 0.5, 1.0, 1.5, 0.5], \'transaction_date\': [\'2023-01-01\', \'2023-01-02\', \'2023-01-03\', \'2023-01-04\', \'2023-01-05\'] } df = pd.DataFrame(data) result = process_sales_data(df) print(result) ``` Expected Output: ``` item total_quantity total_sales 0 apple 16 16.0 1 orange 7 10.5 2 banana 8 4.0 ``` Note: This problem is designed to assess your ability to manipulate and aggregate data using pandas. Ensure your solution is efficient and can handle large datasets.","solution":"import pandas as pd def process_sales_data(df: pd.DataFrame) -> pd.DataFrame: # Group by item and calculate the total quantity and sales grouped = df.groupby(\'item\').agg( total_quantity=(\'quantity\', \'sum\'), total_sales=(\'price\', lambda x: (x * df.loc[x.index, \'quantity\']).sum()) ).reset_index() # Sort by total_sales in descending order sorted_result = grouped.sort_values(by=\'total_sales\', ascending=False).reset_index(drop=True) return sorted_result"},{"question":"# Determine if a Binary Tree is a Subtree of Another Binary Tree You are given two binary trees, `root` and `subRoot`. Write a function to determine if `subRoot` is a subtree of `root`. A subtree of a binary tree `root` is a tree consisting of a node in `root` and all of its descendants. The `subRoot` tree must have exactly the same structure and node values as a subtree of `root`. Your task is to implement a function `is_subtree(root, subRoot)` to check if one tree is a subtree of another. Function Signature ```python def is_subtree(root: Optional[TreeNode], subRoot: Optional[TreeNode]) -> bool: pass ``` # Input Format - `root` and `subRoot`: The root nodes of the binary trees. # Output Format Return a boolean value: - `True` if `subRoot` is a subtree of `root`. - `False` otherwise. # Constraints - Each tree node has a unique integer value. - The trees could be empty (i.e., `None`). # Example ```python # Example 1 root = TreeNode(3) root.left = TreeNode(4) root.right = TreeNode(5) root.left.left = TreeNode(1) root.left.right = TreeNode(2) subRoot = TreeNode(4) subRoot.left = TreeNode(1) subRoot.right = TreeNode(2) assert is_subtree(root, subRoot) == True # Example 2 root = TreeNode(3) root.left = TreeNode(4) root.right = TreeNode(5) root.left.left = TreeNode(1) root.left.right = TreeNode(2) root.left.right.left = TreeNode(0) subRoot = TreeNode(4) subRoot.left = TreeNode(1) subRoot.right = TreeNode(2) assert is_subtree(root, subRoot) == False # Example 3 root = None subRoot = None assert is_subtree(root, subRoot) == True # Example 4 root = TreeNode(1) subRoot = None assert is_subtree(root, subRoot) == True # Example 5 root = None subRoot = TreeNode(1) assert is_subtree(root, subRoot) == False ``` Implement the function so that it adheres to the specifications and handles the given examples correctly.","solution":"from typing import Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_subtree(root: Optional[TreeNode], subRoot: Optional[TreeNode]) -> bool: if not subRoot: return True if not root: return False if is_same_tree(root, subRoot): return True return is_subtree(root.left, subRoot) or is_subtree(root.right, subRoot) def is_same_tree(p: Optional[TreeNode], q: Optional[TreeNode]) -> bool: if not p and not q: return True if not p or not q: return False if p.val != q.val: return False return is_same_tree(p.left, q.left) and is_same_tree(p.right, q.right)"},{"question":"Scenario: You are a developer at a tech startup tasked with developing a simple log analysis tool. Your job is to write a function that reads a list of log entries and extracts the most frequent IP address from these logs. Each log entry is in the format \\"timestamp - IP Address - message\\". Task: Write a Python function `most_frequent_ip` that takes a list of log entries and returns the IP address that appears most frequently. If multiple IP addresses appear with the same highest frequency, return any one of them. Function Signature: ```python def most_frequent_ip(logs: list[str]) -> str: ``` Input: - A list of strings, `logs` (0 <= len(logs) <= 10^5), where each string is a log entry in the format \\"timestamp - IP Address - message\\". Output: - A string representing the most frequent IP address in the logs. Constraints: - Each log entry is guaranteed to be correctly formatted. - The function should handle edge cases efficiently (e.g., empty log list, single log entry, multiple IPs with the same frequency). Example Usage: ```python >>> most_frequent_ip([ \\"2023-01-01 10:00:00 - 192.168.1.1 - User logged in\\", \\"2023-01-01 10:05:00 - 192.168.1.2 - User logged out\\", \\"2023-01-01 10:10:00 - 192.168.1.1 - User logged in\\", \\"2023-01-01 10:15:00 - 192.168.1.3 - User requested data\\", \\"2023-01-01 10:20:00 - 192.168.1.1 - User logged out\\" ]) \'192.168.1.1\' >>> most_frequent_ip([ \\"2023-01-01 10:00:00 - 10.0.0.1 - User login\\", \\"2023-01-01 10:05:00 - 10.0.0.2 - User logged out\\", \\"2023-01-01 10:10:00 - 10.0.0.1 - Data requested\\", \\"2023-01-01 10:15:00 - 10.0.0.1 - User uploaded file\\", \\"2023-01-01 10:20:00 - 10.0.0.3 - User requested data\\" ]) \'10.0.0.1\' >>> most_frequent_ip([ \\"2023-01-01 10:00:00 - 192.168.1.15 - Connection established\\" ]) \'192.168.1.15\' >>> most_frequent_ip([]) \'\' ```","solution":"def most_frequent_ip(logs: list[str]) -> str: from collections import Counter if not logs: return \'\' ip_count = Counter(log.split(\' - \')[1] for log in logs) most_common_ip, _ = ip_count.most_common(1)[0] return most_common_ip"},{"question":"# Coding Assessment Question: Implement a Min-Heap with Extract-Min Operation Objective: Implement a Min-Heap data structure with the capability to insert elements and extract the minimum element efficiently. Description: Design and implement a class `MinHeap` which supports the following methods: * `__init__(self)`: Initializes an empty Min-Heap. * `insert(self, value)`: Inserts a value into the Min-Heap. * `extract_min(self)`: Extracts and returns the minimum value from the Min-Heap. If the heap is empty, it should return `None`. * `peek(self)`: Returns the minimum value without removing it from the heap. If the heap is empty, it should return `None`. Input/Output: * `__init__(self)`: Initializes an empty Min-Heap. * `insert(self, value)`: Inserts the value into the Min-Heap. * `extract_min(self)`: Returns the minimum value and removes it from the heap, or `None` if the heap is empty. * `peek(self)`: Returns the minimum value without removing it, or `None` if the heap is empty. Constraints: * You may assume all input values are integers. * The heap should maintain the Min-Heap property after every insertion and extraction. Example: ```python # Example usage min_heap = MinHeap() min_heap.insert(10) min_heap.insert(5) min_heap.insert(30) min_heap.insert(2) print(min_heap.peek()) # Output: 2 print(min_heap.extract_min()) # Output: 2 print(min_heap.extract_min()) # Output: 5 print(min_heap.extract_min()) # Output: 10 print(min_heap.extract_min()) # Output: 30 print(min_heap.extract_min()) # Output: None ``` Requirements: * Implement heap operations to maintain the Min-Heap property. * Ensure efficient insertion and extraction operations. * Handle edge cases like extracting from an empty heap gracefully. Hints: * Use a list to represent the heap. * The minimum element is always at the root of the heap. * Consider using helper methods to perform heapify operations.","solution":"class MinHeap: def __init__(self): self.heap = [] def _parent(self, i): return (i - 1) // 2 def _left_child(self, i): return 2 * i + 1 def _right_child(self, i): return 2 * i + 2 def _heapify_up(self, index): while index != 0 and self.heap[self._parent(index)] > self.heap[index]: self.heap[self._parent(index)], self.heap[index] = self.heap[index], self.heap[self._parent(index)] index = self._parent(index) def _heapify_down(self, index): smallest = index left = self._left_child(index) right = self._right_child(index) if left < len(self.heap) and self.heap[left] < self.heap[smallest]: smallest = left if right < len(self.heap) and self.heap[right] < self.heap[smallest]: smallest = right if smallest != index: self.heap[smallest], self.heap[index] = self.heap[index], self.heap[smallest] self._heapify_down(smallest) def insert(self, value): self.heap.append(value) self._heapify_up(len(self.heap) - 1) def extract_min(self): if not self.heap: return None root = self.heap[0] if len(self.heap) == 1: return self.heap.pop() self.heap[0] = self.heap.pop() self._heapify_down(0) return root def peek(self): if not self.heap: return None return self.heap[0]"},{"question":"# Scenario You are tasked with developing a utility in a software application that schedules events based on their start and end times. To prevent scheduling conflicts, you need to count the maximum number of concurrent events occurring at any point in time. # Task Implement a function `max_concurrent_events` that returns the maximum number of events that overlap at any given point. # Function Signature ```python def max_concurrent_events(events: list) -> int: Returns the maximum number of concurrent events. :param events: A list of tuples where each tuple contains two integers representing the start and end times of an event. :return: An integer representing the maximum number of overlapping events. ``` # Input - `events`: A list of tuples `events`, where each tuple `(start, end)` represents the start and end times of an event with 1 ≤ len(events) ≤ 10^5. `start` and `end` are integers where `1 ≤ start < end ≤ 10^6`. # Output - Returns an integer representing the maximum number of events that overlap at any given point in time. # Constraints - The function should handle large inputs efficiently. # Performance Requirements - The algorithm should run in O(n log n) time complexity, where `n` is the number of events. # Example ```python events = [(1, 4), (2, 5), (3, 6)] print(max_concurrent_events(events)) # Output: 3 events = [(10, 20), (15, 25), (20, 30), (25, 35)] print(max_concurrent_events(events)) # Output: 2 ``` # Notes - Consider sorting the events and using a sweep line algorithm or a similar technique to efficiently count the overlapping events. - Ensure your implementation handles edge cases like events that start and end at the same time.","solution":"def max_concurrent_events(events: list) -> int: Returns the maximum number of concurrent events. :param events: A list of tuples where each tuple contains two integers representing the start and end times of an event. :return: An integer representing the maximum number of overlapping events. # Create a list to store all the times and their respective events (start/end) times = [] for start, end in events: times.append((start, \'start\')) times.append((end, \'end\')) # Sort times by time, if times are equal, \'end\' comes before \'start\' to avoid double counting times.sort(key=lambda x: (x[0], x[1] == \'start\')) max_concurrent = 0 current_concurrent = 0 # Sweep through the times for time, ttype in times: if ttype == \'start\': current_concurrent += 1 max_concurrent = max(max_concurrent, current_concurrent) else: current_concurrent -= 1 return max_concurrent"},{"question":"# Calculate Matrix Determinant # You are tasked with implementing a function to compute the determinant of a square matrix using a recursive approach. The function should be able to handle matrices up to 4x4 in size. **Function Signature**: ```python def calculate_determinant(matrix: Matrix) -> int: ``` **Input**: * `matrix`: A 2D list of integers representing the square matrix. **Output**: * Returns an integer representing the determinant of the matrix. **Constraints**: * The input matrix will be a square matrix (i.e., n x n matrix). * 1 <= len(matrix) <= 4 * Each element in the matrix: -100 <= element <= 100 **Example**: ```python matrix_2x2 = [ [1, 2], [3, 4] ] calculate_determinant(matrix_2x2) # Output: -2 matrix_3x3 = [ [6, 1, 1], [4, -2, 5], [2, 8, 7] ] calculate_determinant(matrix_3x3) # Output: -306 matrix_4x4 = [ [1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16] ] calculate_determinant(matrix_4x4) # Output: 0 ``` **Note**: 1. If the matrix is not square or if the dimensions exceed 4x4, your function should raise a `ValueError` with the message \\"Invalid matrix dimensions\\". 2. Ensure that your function efficiently handles the recursive computation to calculate the determinant. **Performance Requirements**: - Your solution should optimize the recursion to ensure it is manageable within the given constraints (1 <= n <= 4).","solution":"def calculate_determinant(matrix): Returns the determinant of a square matrix of size up to 4x4. # Check if the matrix is not square or exceeds 4x4 dimensions n = len(matrix) if n < 1 or n > 4 or any(len(row) != n for row in matrix): raise ValueError(\\"Invalid matrix dimensions\\") # Base cases for 1x1, 2x2, and 3x3 matrices if n == 1: return matrix[0][0] elif n == 2: return matrix[0][0] * matrix[1][1] - matrix[0][1] * matrix[1][0] elif n == 3: return (matrix[0][0] * (matrix[1][1] * matrix[2][2] - matrix[1][2] * matrix[2][1]) - matrix[0][1] * (matrix[1][0] * matrix[2][2] - matrix[1][2] * matrix[2][0]) + matrix[0][2] * (matrix[1][0] * matrix[2][1] - matrix[1][1] * matrix[2][0])) # Recursive case for a 4x4 matrix determinant = 0 for c in range(n): sub_matrix = [row[:c] + row[c+1:] for row in matrix[1:]] cofactor = ((-1)**c) * matrix[0][c] * calculate_determinant(sub_matrix) determinant += cofactor return determinant"},{"question":"# Rectangle Overlap Area You are given the coordinates of the bottom-left and top-right corners of two rectangles. Write a function to compute the area of the overlap between the two rectangles. If the rectangles don\'t overlap, return 0. # Problem Description Using the provided coordinates for two rectangles, write a new function `overlap_area` that calculates the area of their intersection. # Function Signature ```python def overlap_area(x1: int, y1: int, x2: int, y2: int, x3: int, y3: int, x4: int, y4: int) -> int: ``` # Input - `x1` (int): The x-coordinate of the bottom-left corner of the first rectangle. - `y1` (int): The y-coordinate of the bottom-left corner of the first rectangle. - `x2` (int): The x-coordinate of the top-right corner of the first rectangle. - `y2` (int): The y-coordinate of the top-right corner of the first rectangle. - `x3` (int): The x-coordinate of the bottom-left corner of the second rectangle. - `y3` (int): The y-coordinate of the bottom-left corner of the second rectangle. - `x4` (int): The x-coordinate of the top-right corner of the second rectangle. - `y4` (int): The y-coordinate of the top-right corner of the second rectangle. # Output - Returns an integer indicating the area of the overlap of the two rectangles. If there is no overlap, return 0. # Example ```python def overlap_area(x1: int, y1: int, x2: int, y2: int, x3: int, y3: int, x4: int, y4: int) -> int: >>> overlap_area(0, 0, 2, 2, 1, 1, 3, 3) 1 >>> overlap_area(0, 0, 1, 1, 2, 2, 3, 3) 0 >>> overlap_area(-1, -1, 2, 2, 0, 0, 1, 1) 1 # Calculate overlap boundaries overlap_x1 = max(x1, x3) overlap_y1 = max(y1, y3) overlap_x2 = min(x2, x4) overlap_y2 = min(y2, y4) # Check if there is an overlap if overlap_x1 < overlap_x2 and overlap_y1 < overlap_y2: overlap_width = overlap_x2 - overlap_x1 overlap_height = overlap_y2 - overlap_y1 return overlap_width * overlap_height else: return 0 ``` # Explanation In this function: - We first determine the overlap boundaries by calculating the max bottom-left coordinates and min top-right coordinates for both rectangles. - If the calculated overlap boundaries form a valid rectangle (i.e., the bottom-left coordinates are less than the top-right coordinates), we compute its area. - If there is no overlap, the function returns 0. This problem focuses on geometric calculations and handling edge cases, maintaining a complexity comparable to determining fluid flow categories based on Reynolds number.","solution":"def overlap_area(x1: int, y1: int, x2: int, y2: int, x3: int, y3: int, x4: int, y4: int) -> int: Calculate the area of overlap between two rectangles. Args: x1, y1: Bottom-left corner of the first rectangle. x2, y2: Top-right corner of the first rectangle. x3, y3: Bottom-left corner of the second rectangle. x4, y4: Top-right corner of the second rectangle. Returns: The area of the overlapping region. If they don\'t overlap, returns 0. Examples: >>> overlap_area(0, 0, 2, 2, 1, 1, 3, 3) 1 >>> overlap_area(0, 0, 1, 1, 2, 2, 3, 3) 0 >>> overlap_area(-1, -1, 2, 2, 0, 0, 1, 1) 1 # Calculate overlap boundaries overlap_x1 = max(x1, x3) overlap_y1 = max(y1, y3) overlap_x2 = min(x2, x4) overlap_y2 = min(y2, y4) # Check if there is an overlap if overlap_x1 < overlap_x2 and overlap_y1 < overlap_y2: overlap_width = overlap_x2 - overlap_x1 overlap_height = overlap_y2 - overlap_y1 return overlap_width * overlap_height else: return 0"},{"question":"# Coding Assessment Task Context You are working on a project that involves large text corpora, and you need to perform efficient text preprocessing. Your goal is to implement a text preprocessing class that can clean, tokenize, and create batches of text data for further analysis. Objective Implement a new class `TextPreprocessor` that includes functionalities for cleaning, tokenizing, and generating batches of text data. Your implementation should include: 1. **Text Cleaning**: Remove special characters, numbers, and extra whitespace. 2. **Tokenization**: Split text into tokens and create a vocabulary. 3. **Batching**: Generate batches of tokenized text data. Requirements - Use modern Python libraries such as `re` for text cleaning and `collections` for vocabulary creation. - Implement methods to clean text, tokenize text, and generate batches of tokenized text. - Ensure efficient handling and storing of large text datasets. - Properly handle exceptions and edge cases. # Function Specifications `TextPreprocessor` * **Attributes**: - `vocabulary`: A dictionary mapping tokens to their corresponding integer indices. - `inverse_vocabulary`: A dictionary mapping integer indices back to tokens. - `max_vocab_size`: Maximum size of the vocabulary. * **Methods**: - `__init__(self, max_vocab_size=10000)`: Initialize the Preprocessor with a maximum vocabulary size. - `_clean_text(self, text)`: Clean the input text by removing special characters, numbers, and extra whitespace. - `_tokenize_text(self, text)`: Tokenize the cleaned text into tokens. - `_build_vocabulary(self, tokenized_texts)`: Build a vocabulary from a list of tokenized texts. - `generate_batches(self, tokenized_texts, batch_size)`: Generate batches of tokenized text data. # Constraints - Limit the vocabulary to a maximum size of `max_vocab_size`. - Ensure tokenized text data fits well into memory. - Support different batch sizes for training. Example Usage ```python text_data = [ \\"This is the first sentence.\\", \\"And here\'s another sentence.\\", \\"Yet another example sentence for testing.\\" ] preprocessor = TextPreprocessor(max_vocab_size=5000) cleaned_texts = [preprocessor._clean_text(text) for text in text_data] tokenized_texts = [preprocessor._tokenize_text(text) for text in cleaned_texts] preprocessor._build_vocabulary(tokenized_texts) batches = preprocessor.generate_batches(tokenized_texts, batch_size=2) for batch in batches: print(batch) ``` # Hints - Use the `re.sub` function for text cleaning. - The `collections.Counter` class can help with building the vocabulary efficiently. - Ensure that the batch generation method yields batches of a specified size.","solution":"import re from collections import Counter from typing import List, Generator class TextPreprocessor: def __init__(self, max_vocab_size=10000): self.max_vocab_size = max_vocab_size self.vocabulary = {} self.inverse_vocabulary = {} def _clean_text(self, text: str) -> str: Clean the input text by removing special characters, numbers, and extra whitespace. text = re.sub(r\'d+\', \'\', text) # Remove numbers text = re.sub(r\'W+\', \' \', text) # Remove special characters text = re.sub(r\'s+\', \' \', text).strip() # Remove extra whitespace return text.lower() def _tokenize_text(self, text: str) -> List[str]: Tokenize the cleaned text into tokens. return text.split() def _build_vocabulary(self, tokenized_texts: List[List[str]]) -> None: Build a vocabulary from a list of tokenized texts. all_tokens = [token for text in tokenized_texts for token in text] counter = Counter(all_tokens) most_common_tokens = counter.most_common(self.max_vocab_size) self.vocabulary = {token: idx for idx, (token, _) in enumerate(most_common_tokens, 1)} self.inverse_vocabulary = {idx: token for token, idx in self.vocabulary.items()} def generate_batches(self, tokenized_texts: List[List[str]], batch_size: int) -> Generator[List[List[str]], None, None]: Generate batches of tokenized text data. for i in range(0, len(tokenized_texts), batch_size): yield tokenized_texts[i:i + batch_size]"},{"question":"# Question: Expandable Matrix Path Finder You are given a matrix (2D grid) containing characters, and your task is to implement a function that finds all expandable rectangular sub-matrices such that all characters within these sub-matrices are identical. The size of the sub-matrix must be at least a given minimum size and the sub-matrix can expand in any direction but must maintain the same character throughout. Function Signature: ```python def expandable_matrix_path_finder(matrix: List[List[str]], min_size: Tuple[int, int]) -> List[Tuple[int, int, int, int]]: ``` Input: - **matrix**: A 2D grid of characters represented as a list of lists. - **min_size**: A tuple (m, n) representing the minimum number of rows (`m`) and columns (`n`) for the sub-matrices. Output: - **Result**: A list of tuples, where each tuple contains four integers representing the top-left corner (row, column) and the dimensions (row_span, col_span) of an expandable sub-matrix. These sub-matrices must be at least `min_size` in area and contain identical characters. Constraints & Notes: - Elements of the matrix are single characters (a-z, 0-9). - The dimensions of the matrix are at most 100x100. - The minimum size is guaranteed to be at most 10x10. - Ensure that identified sub-matrices do not overlap with each other. Example: **Input**: ```python matrix = [ [\'a\', \'a\', \'b\', \'b\'], [\'a\', \'a\', \'b\', \'b\'], [\'c\', \'c\', \'b\', \'b\'], [\'c\', \'c\', \'b\', \'b\'] ] min_size = (2, 2) ``` **Output**: ```python [ (0, 0, 2, 2), (0, 2, 4, 2), (2, 0, 2, 2) ] ``` **Input**: ```python matrix = [ [\'a\', \'a\', \'a\', \'b\', \'b\'], [\'a\', \'a\', \'a\', \'b\', \'b\'], [\'a\', \'a\', \'a\', \'b\', \'b\'], [\'c\', \'c\', \'c\', \'b\', \'b\'] ] min_size = (3, 3) ``` **Output**: ```python [ (0, 0, 3, 3) ] ``` Implementation Details: - To identify expandable sub-matrices, you may need to check all possible rectangular regions in the matrix and verify their uniformity. - Consider helper functions to check and validate sub-matrices dynamically as they expand from different starting positions. - Optimize for performance by avoiding redundant checks and by utilizing dynamic programming techniques if applicable. - Handle edge cases such as the given matrix being too small to contain any sub-matrix of the required minimum size.","solution":"from typing import List, Tuple def expandable_matrix_path_finder(matrix: List[List[str]], min_size: Tuple[int, int]) -> List[Tuple[int, int, int, int]]: def is_valid_submatrix(sr, sc, er, ec, char) -> bool: for r in range(sr, er + 1): for c in range(sc, ec + 1): if matrix[r][c] != char: return False return True def get_max_expandable_submatrix(sr, sc): char = matrix[sr][sc] max_row, max_col = len(matrix), len(matrix[0]) er, ec = sr, sc while er < max_row and matrix[er][sc] == char: er += 1 while ec < max_col and matrix[sr][ec] == char: ec += 1 er -= 1 ec -= 1 for r in range(sr, er + 1): for c in range(sc, ec + 1): if not is_valid_submatrix(sr, sc, r, c, char): return sr, sc, r - sr + 1, c - sc + 1 return sr, sc, er - sr + 1, ec - sc + 1 m, n = len(matrix), len(matrix[0]) min_row, min_col = min_size results = [] visited = [[False] * n for _ in range(m)] for r in range(m): for c in range(n): if not visited[r][c]: sr, sc, row_span, col_span = get_max_expandable_submatrix(r, c) if row_span >= min_row and col_span >= min_col: results.append((sr, sc, row_span, col_span)) for rr in range(sr, sr + row_span): for cc in range(sc, sc + col_span): visited[rr][cc] = True return results"},{"question":"# Coding Assessment Question Context: You are working on a system that requires efficient string manipulation. An important operation needed is to compress strings in a particular format known as **run-length encoding** (RLE). This encoding technique is primarily used where frequent and consecutive repetition of characters occurs. You will be required to implement both the encoding and decoding functions for run-length encoding. Task: 1. Implement a function to encode a string using run-length encoding. 2. Implement a function to decode a run-length encoded string. 3. Include a main function to accept a string from the user, encode it, and then decode the result to verify both operations. Requirements: 1. **Function `rle_encode(s: str) -> str`** - Receive a string as input and return its run-length encoded form. - For example, `AAABBBCCDAA` should be encoded as `3A3B2C1D2A`. 2. **Function `rle_decode(s: str) -> str`** - Receive a run-length encoded string as input and return the original string. - For example, `3A3B2C1D2A` should be decoded back to `AAABBBCCDAA`. 3. **Function `main()`** - Accept a string from the user. - Encode the input string using `rle_encode` and print the result. - Decode the encoded string using `rle_decode` and print the result. - Verify and print whether the original string matches the decoded string. Constraints: - The input string for encoding should contain only uppercase alphabetic characters (`A-Z`). - The input string should have a reasonable length (e.g., up to 100 characters) to demonstrate the concept effectively. - Ensure the decoding accurately reconstructs the original string even with complex patterns. Example: For an input string `AAABBBCCDAA`: - `rle_encode(\\"AAABBBCCDAA\\")` should return `3A3B2C1D2A`. - `rle_decode(\\"3A3B2C1D2A\\")` should return `AAABBBCCDAA`. - The main function should verify that the original string `AAABBBCCDAA` matches the decoded string `AAABBBCCDAA`.","solution":"def rle_encode(s: str) -> str: Encode a string using run-length encoding. Parameters: s (str): The input string to be encoded. Returns: str: The run-length encoded string. if not s: return \\"\\" encoded_string = [] count = 1 for i in range(1, len(s)): if s[i] == s[i - 1]: count += 1 else: encoded_string.append(f\\"{count}{s[i - 1]}\\") count = 1 # Append the last character and its count encoded_string.append(f\\"{count}{s[-1]}\\") return \'\'.join(encoded_string) def rle_decode(s: str) -> str: Decode a run-length encoded string. Parameters: s (str): The run-length encoded string. Returns: str: The decoded original string. decoded_string = [] count = 0 for char in s: if char.isdigit(): count = count * 10 + int(char) else: decoded_string.append(char * count) count = 0 return \'\'.join(decoded_string) def main(): original_string = input(\\"Enter the string to encode: \\") encoded_string = rle_encode(original_string) decoded_string = rle_decode(encoded_string) print(f\\"Original String: {original_string}\\") print(f\\"Encoded String: {encoded_string}\\") print(f\\"Decoded String: {decoded_string}\\") if original_string == decoded_string: print(\\"Success: The decoded string matches the original string.\\") else: print(\\"Error: The decoded string does not match the original string.\\")"},{"question":"# Binary Search Tree: Insertion and Search Context A Binary Search Tree (BST) is a binary tree where each node has a comparable key (and an associated value) and satisfies the following condition: The key in each node is larger than the keys in all nodes in that node\'s left subtree and smaller than the keys in all nodes in that node\'s right subtree. Objective Write a Python class `BST` that supports insertion of elements and searching for elements. The class should include the following methods: - `insert(self, key)`: Inserts a new key into the BST. - `search(self, key)`: Searches for a given key in the BST and returns `True` if it exists, `False` otherwise. Input - A sequence of operations to perform on the BST, which could be either `insert` or `search`, followed by an integer key. Output - For each search operation, return `True` if the key exists, otherwise `False`. Example ```python bst = BST() operations = [ (\'insert\', 5), (\'insert\', 2), (\'insert\', 8), (\'search\', 2), (\'search\', 10) ] results = [] for op, key in operations: if op == \'insert\': bst.insert(key) elif op == \'search\': results.append(bst.search(key)) print(results) # Output: [True, False] ``` Constraints 1. The keys are integers and can be positive or negative. 2. The total number of operations will not exceed 10^4. 3. Each key will be a unique integer for `insert` operations. Implementation Details Below is a skeleton structure you can start with: ```python class BST: class Node: def __init__(self, key): self.key = key self.left = None self.right = None def __init__(self): self.root = None def insert(self, key): if self.root is None: self.root = self.Node(key) else: self._insert(self.root, key) def _insert(self, node, key): if key < node.key: if node.left is None: node.left = self.Node(key) else: self._insert(node.left, key) else: if node.right is None: node.right = self.Node(key) else: self._insert(node.right, key) def search(self, key): return self._search(self.root, key) def _search(self, node, key): if node is None: return False if key == node.key: return True elif key < node.key: return self._search(node.left, key) else: return self._search(node.right, key) ``` Ensure that your implementation adheres to the given constraints and handles all edge cases gracefully.","solution":"class BST: class Node: def __init__(self, key): self.key = key self.left = None self.right = None def __init__(self): self.root = None def insert(self, key): if self.root is None: self.root = self.Node(key) else: self._insert(self.root, key) def _insert(self, node, key): if key < node.key: if node.left is None: node.left = self.Node(key) else: self._insert(node.left, key) else: if node.right is None: node.right = self.Node(key) else: self._insert(node.right, key) def search(self, key): return self._search(self.root, key) def _search(self, node, key): if node is None: return False if key == node.key: return True elif key < node.key: return self._search(node.left, key) else: return self._search(node.right, key)"},{"question":"Problem Statement You are tasked with implementing a feature extraction technique for text data, specifically the term frequency-inverse document frequency (TF-IDF) scheme. This task will involve calculating term frequencies (TF), inverse document frequencies (IDF), and combining these to compute the TF-IDF scores for each term in a given set of documents. # Function Signature ```python def compute_tfidf(documents: List[str]) -> List[Dict[str, float]]: :param documents: a list of strings, where each string represents a document. :return: a list of dictionaries, where each dictionary maps terms to their TF-IDF scores for the respective document. ``` # Input * A list of `n` documents, each represented as a string of words (strings), denoted as `documents`. # Output * A list of `n` dictionaries where each dictionary corresponds to one document. Each dictionary contains terms (words) as keys and their TF-IDF scores as values. # Constraints * Each document is a non-empty string consisting of words separated by whitespace. * Words are case-insensitive, treated in lowercase. * Special characters and punctuations should be ignored, only alphanumeric words are considered. * Assume the document list will contain at least one document. * Use the logarithm base 10 for IDF calculation. # Additional Requirements * Tokenization of words should be performed, ensuring that special characters and punctuation are removed. * Implement the following steps in your function: 1. Compute the term frequency (TF) for each term in each document. 2. Compute the inverse document frequency (IDF) for each term using the entire document set. 3. Calculate the TF-IDF score for each term in each document by multiplying TF and IDF. * Do not use any high-level library functions for TF-IDF, such as sklearn\'s TfidfVectorizer. # Example Usage ```python documents = [ \\"The cat sat on the mat.\\", \\"The dog sat on the log.\\", \\"Cats and dogs are great pets.\\" ] result = compute_tfidf(documents) print(result) # Example output might look like: # [ # {\'cat\': 0.477, \'sat\': 0.176, \'mat\': 0.477, \'the\': 0.000, \'on\': 0.176}, # {\'dog\': 0.477, \'sat\': 0.176, \'log\': 0.477, \'the\': 0.000, \'on\': 0.176}, # {\'cats\': 0.301, \'and\': 0.301, \'dogs\': 0.301, \'are\': 0.301, \'great\': 0.301, \'pets\': 0.301} # ] ``` # Hints * Use a counter to easily compute the term frequency (TF) of each word in a document. * When computing IDF, consider the number of documents that contain each word. * Apply logarithmic scaling to the IDF component to handle large document sets. * Ensure that the TF-IDF values are accurately normalized if needed.","solution":"import math import re from collections import defaultdict, Counter from typing import List, Dict def tokenize(document: str) -> List[str]: Tokenizes a document into a list of words. Converts to lowercase and removes special characters. return re.findall(r\'bw+b\', document.lower()) def compute_tfidf(documents: List[str]) -> List[Dict[str, float]]: Calculates the TF-IDF scores for each term in each document. # Step 1: Tokenize documents tokenized_documents = [tokenize(doc) for doc in documents] # Step 2: Calculate Term Frequency (TF) tf = [] for tokens in tokenized_documents: word_count = len(tokens) counter = Counter(tokens) tf.append({word: count / word_count for word, count in counter.items()}) # Step 3: Calculate Document Frequency (DF) df = defaultdict(int) for tokens in tokenized_documents: unique_tokens = set(tokens) for token in unique_tokens: df[token] += 1 # Step 4: Calculate Inverse Document Frequency (IDF) total_documents = len(documents) idf = {word: math.log10(total_documents / count) for word, count in df.items()} # Step 5: Calculate TF-IDF tfidf = [] for doc_tf in tf: doc_tfidf = {word: tf_val * idf[word] for word, tf_val in doc_tf.items()} tfidf.append(doc_tfidf) return tfidf"},{"question":"Problem Statement **Temperature Trend Analysis** You are provided with a temperature log representing daily recorded temperatures for a certain period. Your task is to identify the longest period of consecutive days where the temperature was strictly increasing. To achieve this, you should implement the function `longest_increasing_temperature_streak` that takes a list of integers representing the recorded temperatures and returns an integer representing the length of the longest streak of strictly increasing temperatures. # Input Your function should take one argument: 1. **temperatures** (`list[int]`): A list of integers where each integer represents the recorded temperature of a day. # Output An integer that represents the length of the longest period with strictly increasing temperatures. # Constraints * The length of the temperature list will be between 1 and 10^5. * The temperature values will be between -100 and 100. # Examples ```python # Example 1: print(longest_increasing_temperature_streak([30, 31, 32, 33, 29, 30, 31, 32])) # Output: 4 # Example 2: print(longest_increasing_temperature_streak([45, 42, 46, 47, 48, 40, 43, 44, 45])) # Output: 4 # Example 3: print(longest_increasing_temperature_streak([50, 49, 48, 47, 46])) # Output: 1 # Example 4: print(longest_increasing_temperature_streak([20])) # Output: 1 ``` # Submission Implement the function `longest_increasing_temperature_streak` which analyzes the given temperature log and returns the length of the longest streak with strictly increasing temperatures. Ensure your solution handles the constraints efficiently.","solution":"def longest_increasing_temperature_streak(temperatures): Returns the length of the longest period with strictly increasing temperatures. if not temperatures: return 0 longest_streak = 1 current_streak = 1 for i in range(1, len(temperatures)): if temperatures[i] > temperatures[i - 1]: current_streak += 1 else: longest_streak = max(longest_streak, current_streak) current_streak = 1 longest_streak = max(longest_streak, current_streak) return longest_streak"},{"question":"# Question: Armstrong Number Validation You are to implement a function `is_armstrong(number: int) -> bool` which determines whether a given integer is an Armstrong number. An Armstrong number, also known as a narcissistic number, is a number that is equal to the sum of its own digits each raised to the power of the number of digits. # Inputs and Outputs: - **Input**: A single integer `number`. - **Output**: A boolean value `True` if the given number is an Armstrong number, otherwise `False`. # Constraints: 1. The input number must be a non-negative integer. 2. The function should handle numbers both small and extremely large, as long as they fit into the standard integer type. 3. You must raise a `ValueError` with a meaningful message if the input is a negative integer. # Examples: ```python is_armstrong(0) # Output: True is_armstrong(1) # Output: True is_armstrong(153) # Output: True is_armstrong(370) # Output: True is_armstrong(371) # Output: True is_armstrong(407) # Output: True is_armstrong(9474) # Output: True is_armstrong(9475) # Output: False # Raises ValueError is_armstrong(-153) ``` # Implementation Challenges: 1. Handling input validation to ensure only non-negative integers are processed. 2. Correctly computing the Armstrong condition, especially for numbers with many digits. 3. Managing edge cases like the number 0 and 1, which are always Armstrong numbers by definition.","solution":"def is_armstrong(number: int) -> bool: Determines if a given number is an Armstrong number. Parameters: number (int): The number to check. Returns: bool: True if the number is an Armstrong number, False otherwise. Raises: ValueError: If the input number is negative. if number < 0: raise ValueError(\\"The input number must be a non-negative integer.\\") digits = str(number) num_digits = len(digits) total = sum(int(digit) ** num_digits for digit in digits) return total == number"},{"question":"# Problem Statement You are required to find all the prime factors of a given positive integer, considering the following constraints and input formats. # Task: Write a function `prime_factors(n: int) -> List[int]:` that takes an integer `n`, finds all of its prime factors, and returns them in a list in increasing order. # Input * `n`: a positive integer (n >= 1) # Output * A list of integers where each integer is a prime factor of `n`, sorted in increasing order. # Constraints * The function should handle the edge cases, such as input being one. * If the input is one, the function should return an empty list since 1 has no prime factors. * If the input is less than one or it isn\'t a valid integer, the function should return an empty list. # Example Input `n = 28` Output `[2, 7]` Input `n = 60` Output `[2, 3, 5]` Input `n = 1` Output `[]` # Implementation Notes - Writing concise and well-documented code is expected. - Consider using type hints and ensuring code readability. - The solution should be tested for various edge cases. # Function Signature ```python from typing import List def prime_factors(n: int) -> List[int]: pass ``` # Additional Requirements 1. Implement comprehensive validation of inputs. 2. Include error handling for invalid input types. 3. Efficient processing for large values of n by minimizing unnecessary computations.","solution":"from typing import List def prime_factors(n: int) -> List[int]: if not isinstance(n, int) or n < 1: return [] factors = [] if n == 1: return factors # Check for the number of 2s that divide n if n % 2 == 0: factors.append(2) while n % 2 == 0: n = n // 2 # n must be odd at this point, thus a skip of 2 (i.e., i = i + 2) can be used for i in range(3, int(n**0.5) + 1, 2): if n % i == 0: factors.append(i) while n % i == 0: n = n // i # This condition is to check if n is a prime number greater than 2 if n > 2: factors.append(n) return factors"},{"question":"# Question Scenario: You are working on a data transformation application that processes large datasets. One of the tasks involves reversing the words in a given sentence while preserving the order of the words. This function is often used to generate new test cases for verifying data handling consistency. Task: Implement the function `reverse_words` that takes a single string input representing a sentence and returns the sentence with the characters in each word reversed, but the order of the words preserved. Implementation: 1. Define the function `reverse_words(sentence: str) -> str`. 2. Ensure the function handles the following: * Only alphabetic strings and spaces need to be considered. * Multiple spaces between words should be preserved in the output. * Input validation to ensure the input is a string. 3. Optimize for performance (O(n) time complexity). Input: * A single string `sentence`. Output: * A string representing the input sentence with characters in each word reversed but word order preserved. Constraints: * The input length does not exceed 10^6 characters. * The input string may include multiple spaces between words and at the start or end of the string. Examples: ```python >>> reverse_words(\\"hello world\\") \\"olleh dlrow\\" >>> reverse_words(\\"Python is fun\\") \\"nohtyP si nuf\\" >>> reverse_words(\\"multiple spaces\\") \\"elpitlum secaps\\" >>> reverse_words(\\"\\") \\"\\" >>> reverse_words(\\" a b c \\") \\" a b c \\" ``` Performance Requirements: The function should run efficiently with a linear time complexity with respect to the input string\'s length, ensuring it can handle large inputs up to 10^6 characters.","solution":"def reverse_words(sentence): Reverses the characters in each word of the given sentence but preserves the order of the words. Args: sentence (str): Input sentence Returns: str: Sentence with each word\'s characters reversed if not isinstance(sentence, str): raise ValueError(\\"Input must be a string\\") # Split the sentence into words considering multiple spaces words = sentence.split(\' \') # Reverse each word reversed_words = [word[::-1] for word in words] # Rejoin reversed words with spaces kept intact return \' \'.join(reversed_words)"},{"question":"# Text File Data Analysis In this task, you are required to implement a function that processes a list of text files, extracts specific statistical metrics, and ranks the files based on the frequency of a given keyword. # Function Requirements You will implement the following function: ```python def rank_files(files: list[str], keyword: str, case_sensitive: bool = False) -> list[tuple[int, int]]: Processes a list of text files, counts the occurrences of a given keyword in each file, and ranks the files based on these counts. Args: - files: List of file paths to the text files. - keyword: The keyword to search for in the files. - case_sensitive: Boolean indicating whether the keyword search should be case sensitive. Default is False. Returns: - A list of tuples where each tuple contains the index of a file and the count of the keyword in that file, sorted in descending order of keyword count. pass ``` # Input/Output - **Input**: - `files`: list of strings, paths to text files. - `keyword`: string, the keyword to search for within the text files. - `case_sensitive`: boolean, indicating if the search should be case sensitive (default is False). - **Output**: - List of tuples, each containing the index of a file and the count of the keyword in that file, sorted in descending order of keyword count. # Constraints: - You can assume all files provided exist and are valid text files. - The files may vary in size and content. - If multiple files have the same count of keyword occurrences, their order should remain as in the input list. # Example: ```python files = [\\"file1.txt\\", \\"file2.txt\\", \\"file3.txt\\"] keyword = \\"data\\" case_sensitive = False rank_files(files, keyword, case_sensitive) ``` # Scenario: You are handling a document analysis system where users upload a set of textual documents. The system should then identify how frequently a specific keyword appears in each document. The results should rank documents by their keyword frequency to help users quickly find relevant documents. # Note: - Ensure your solution reads the text files, processes them accurately, and returns the keyword ranking correctly. - Possible libraries you might use are `os`. This question provides a text processing and data analysis challenge, similar in complexity to the image processing task but set in a different domain.","solution":"def rank_files(files: list[str], keyword: str, case_sensitive: bool = False) -> list[tuple[int, int]]: Processes a list of text files, counts the occurrences of a given keyword in each file, and ranks the files based on these counts. Args: - files: List of file paths to the text files. - keyword: The keyword to search for in the files. - case_sensitive: Boolean indicating whether the keyword search should be case sensitive. Default is False. Returns: - A list of tuples where each tuple contains the index of a file and the count of the keyword in that file, sorted in descending order of keyword count. keyword_count = [] for index, file in enumerate(files): try: with open(file, \'r\') as f: content = f.read() if not case_sensitive: content = content.lower() keyword = keyword.lower() count = content.count(keyword) keyword_count.append((index, count)) except FileNotFoundError: keyword_count.append((index, 0)) # Sort the files based on the count of the keyword in descending order keyword_count.sort(key=lambda x: x[1], reverse=True) return keyword_count"},{"question":"# Morse Code Converter Problem Statement You have been hired to write a function that converts a given string into its corresponding Morse code representation. Each letter in the input string should be replaced by its Morse code equivalent according to the following mapping: * \'A\' or \'a\' -> \\".-\\" * \'B\' or \'b\' -> \\"-...\\" * \'C\' or \'c\' -> \\"-.-.\\" * \'D\' or \'d\' -> \\"-..\\" * \'E\' or \'e\' -> \\".\\" * \'F\' or \'f\' -> \\"..-.\\" * \'G\' or \'g\' -> \\"--.\\" * \'H\' or \'h\' -> \\"....\\" * \'I\' or \'i\' -> \\"..\\" * \'J\' or \'j\' -> \\".---\\" * \'K\' or \'k\' -> \\"-.-\\" * \'L\' or \'l\' -> \\".-..\\" * \'M\' or \'m\' -> \\"--\\" * \'N\' or \'n\' -> \\"-.\\" * \'O\' or \'o\' -> \\"---\\" * \'P\' or \'p\' -> \\".--.\\" * \'Q\' or \'q\' -> \\"--.-\\" * \'R\' or \'r\' -> \\".-.\\" * \'S\' or \'s\' -> \\"...\\" * \'T\' or \'t\' -> \\"-\\" * \'U\' or \'u\' -> \\"..-\\" * \'V\' or \'v\' -> \\"...-\\" * \'W\' or \'w\' -> \\".--\\" * \'X\' or \'x\' -> \\"-..-\\" * \'Y\' or \'y\' -> \\"-.--\\" * \'Z\' or \'z\' -> \\"--..\\" * \'0\' -> \\"-----\\" * \'1\' -> \\".----\\" * \'2\' -> \\"..---\\" * \'3\' -> \\"...--\\" * \'4\' -> \\"....-\\" * \'5\' -> \\".....\\" * \'6\' -> \\"-....\\" * \'7\' -> \\"--...\\" * \'8\' -> \\"---..\\" * \'9\' -> \\"----.\\" * \' \' (space) -> \\"/\\" Any other characters should raise a `ValueError` with the message \\"Invalid character in input\\". Write a function `to_morse_code` that takes in a string and returns the Morse code equivalent. Function Signature ```python def to_morse_code(text: str) -> str: pass ``` Input * `text` (str): A string containing alphanumeric characters and spaces, with a length between 1 and 1000. Output * Returns a string where each alphanumeric character of the input text has been replaced by its Morse code equivalent, separated by spaces, and words are separated by a \'/\'. Constraints * You must not use external libraries or modules (use only Python\'s standard library). Example ```python # Example 1 to_morse_code(\\"HELLO WORLD\\") # Output: \\".... . .-.. .-.. --- / .-- --- .-. .-.. -..\\" # Example 2 to_morse_code(\\"SOS 123\\") # Output: \\"... --- ... / .---- ..--- ...--\\" # Example 3 try: to_morse_code(\\"HELLO!\\") except ValueError as e: print(str(e)) # Output: \\"Invalid character in input\\" ```","solution":"def to_morse_code(text: str) -> str: morse_dict = { \'A\': \\".-\\", \'B\': \\"-...\\", \'C\': \\"-.-.\\", \'D\': \\"-..\\", \'E\': \\".\\", \'F\': \\"..-.\\", \'G\': \\"--.\\", \'H\': \\"....\\", \'I\': \\"..\\", \'J\': \\".---\\", \'K\': \\"-.-\\", \'L\': \\".-..\\", \'M\': \\"--\\", \'N\': \\"-.\\", \'O\': \\"---\\", \'P\': \\".--.\\", \'Q\': \\"--.-\\", \'R\': \\".-.\\", \'S\': \\"...\\", \'T\': \\"-\\", \'U\': \\"..-\\", \'V\': \\"...-\\", \'W\': \\".--\\", \'X\': \\"-..-\\", \'Y\': \\"-.--\\", \'Z\': \\"--..\\", \'0\': \\"-----\\", \'1\': \\".----\\", \'2\': \\"..---\\", \'3\': \\"...--\\", \'4\': \\"....-\\", \'5\': \\".....\\", \'6\': \\"-....\\", \'7\': \\"--...\\", \'8\': \\"---..\\", \'9\': \\"----.\\", \' \': \\"/\\" } result = [] for char in text.upper(): if char in morse_dict: result.append(morse_dict[char]) else: raise ValueError(\\"Invalid character in input\\") return \' \'.join(result)"},{"question":"# Question Given a list of integers, write two functions: 1. Determine if the list can be classified as an arithmetic sequence. 2. Calculate the sum of the first `n` terms of the arithmetic sequence if it is valid. Requirements - Implement the function `is_arithmetic_sequence(sequence: list) -> bool`: * This function should return `True` if the given list forms an arithmetic sequence, else return `False`. * An empty list should return `False`. * If the input is not a list, raise a `ValueError`. - Implement the function `arithmetic_sequence_sum(sequence: list, n: int) -> int`: * This function should return the sum of the first `n` terms of the arithmetic sequence if `is_arithmetic_sequence(sequence)` returns `True`. * If the list is not an arithmetic sequence, raise a `ValueError`. * If the input is not a list or `n` is not an integer, raise a `ValueError`. * If `n` is greater than the length of the sequence, return the sum of the provided sequence. Input Format * `sequence`: A list of integers. * `n`: An integer indicating the number of terms to sum. Output Format * `is_arithmetic_sequence`: Return a boolean value. * `arithmetic_sequence_sum`: Return an integer value that is the sum of the first `n` terms of the arithmetic sequence, or raises a `ValueError` if the list is not an arithmetic sequence. # Examples ```python >>> is_arithmetic_sequence([3, 6, 9, 12]) True >>> is_arithmetic_sequence([2, 5, 8, 12]) False >>> is_arithmetic_sequence([7, 14, 21, 28]) True >>> is_arithmetic_sequence([1]) True >>> arithmetic_sequence_sum([3, 6, 9, 12], 3) 18 >>> arithmetic_sequence_sum([2, 5, 8, 11], 4) 26 >>> arithmetic_sequence_sum([7, 14, 21], 5) 42 >>> arithmetic_sequence_sum([10], 1) 10 >>> arithmetic_sequence_sum([2, 5, 8, 11], 2) 7 ``` Constraints * The input list must only contain integers. * Both functions must handle erroneous inputs gracefully by raising `ValueError` with appropriate messages. Additional Information Arithmetic sequences, also known as arithmetic progressions, are sequences of numbers in which the difference between the consecutive terms is constant. The sum of the first `n` terms of an arithmetic sequence is given by the formula `n/2 * (2a + (n-1)d)` where `a` is the first term, and `d` is the common difference.","solution":"def is_arithmetic_sequence(sequence): Returns True if the given list forms an arithmetic sequence, else returns False. if not isinstance(sequence, list): raise ValueError(\\"Input must be a list.\\") if len(sequence) == 0: return False if len(sequence) == 1: return True common_difference = sequence[1] - sequence[0] for i in range(1, len(sequence)): if sequence[i] - sequence[i - 1] != common_difference: return False return True def arithmetic_sequence_sum(sequence, n): Returns the sum of the first n terms of the arithmetic sequence if it is a valid sequence, else raises ValueError. if not isinstance(sequence, list): raise ValueError(\\"Input must be a list.\\") if not isinstance(n, int): raise ValueError(\\"The number of terms must be an integer.\\") if not is_arithmetic_sequence(sequence): raise ValueError(\\"The list is not an arithmetic sequence.\\") if n > len(sequence): n = len(sequence) a = sequence[0] d = sequence[1] - sequence[0] if len(sequence) > 1 else 0 return n / 2 * (2 * a + (n - 1) * d)"},{"question":"# Problem Statement You are given a balanced binary search tree (BST) and a target value. Your task is to find the value in the BST that is closest to the target value. You need to implement a function to efficiently find this closest value. # Function Signature ```python def closest_value(root: \'TreeNode\', target: float) -> int: pass ``` # Input * `root`: A reference to the root node of a balanced binary search tree (BST) where each node is defined as: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` * `target`: A float representing the target value. # Output * Returns the integer value from the BST that is closest to the target value. # Constraints * The BST is guaranteed to have at least one node. * The BST does not contain duplicate values. * Your implementation should handle float target values appropriately. * Aim to achieve an efficient solution with a time complexity better than O(n). # Example ```python # Example 1: # 4 # / # 2 5 # / # 1 3 >>> root = TreeNode(4, TreeNode(2, TreeNode(1), TreeNode(3)), TreeNode(5)) >>> closest_value(root, 3.714286) 4 # Example 2: # 10 # / # 5 20 >>> root = TreeNode(10, TreeNode(5), TreeNode(20)) >>> closest_value(root, 19) 20 ``` # Additional Information * Ensure your function handles edge cases, such as a tree with a single node or very small/large target values. * Consider both iterative and recursive approaches for your implementation, but aim for an efficient one. * Discuss the trade-offs of different approaches if applicable.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def closest_value(root: TreeNode, target: float) -> int: Finds the value in the BST that is closest to the target value. closest = root.val while root: # Update the closest value if the current value is closer to the target if abs(root.val - target) < abs(closest - target): closest = root.val # Since it\'s a BST, use the property of BST to decide the direction if target < root.val: root = root.left else: root = root.right return closest"},{"question":"# Problem Statement: Movies Ratings Tracker You are tasked with implementing a `MoviesRatingsTracker` class that can help manage and track movie ratings submitted by users. The class needs to store ratings for various movies efficiently and provide functionality to retrieve useful statistics. # Requirements: 1. **Add Rating**: Implement a method to add a rating for a given movie. Each rating is an integer between 0 and 5 (inclusive). 2. **Get Average Rating**: Implement a method to retrieve the average rating for a given movie. 3. **Get Top Rated Movie**: Implement a method to retrieve the movie with the highest average rating. 4. **Edge Cases Handling**: - Ensure ratings are only between 0 and 5. - Handle cases where movies have no ratings yet. - Ensure ties in the highest average rating are resolved by the movie name in lexicographical order. # Class Implementations: * `add_rating(movie_name: str, rating: int) -> None` * Adds the given rating for the specified movie. * Throws an exception if the rating is out of bounds. * `get_average_rating(movie_name: str) -> float` * Returns the average rating for the specified movie. * Returns `None` if the movie does not have any ratings. * `get_top_rated_movie() -> str` * Returns the name of the movie with the highest average rating. * Returns `None` if no movies have been rated yet. # Input Format: * For `add_rating`: - `movie_name` is a non-empty string representing the name of the movie. - `rating` is an integer between 0 and 5 (inclusive). * For `get_average_rating`: - `movie_name` is a non-empty string representing the name of the movie. * For `get_top_rated_movie`: - No input parameters. # Output Format: * For `add_rating`: - No output (the rating is added internally). * For `get_average_rating`: - A float representing the average rating, rounded to 2 decimal places. If no ratings exist for the movie, return `None`. * For `get_top_rated_movie`: - A string representing the top rated movie based on average rating. If there are no ratings, return `None`. # Example: ```python tracker = MoviesRatingsTracker() # Adding ratings tracker.add_rating(\\"Inception\\", 5) tracker.add_rating(\\"Inception\\", 4) tracker.add_rating(\\"The Matrix\\", 5) tracker.add_rating(\\"The Matrix\\", 4) # Getting average ratings print(tracker.get_average_rating(\\"Inception\\")) # Output: 4.50 print(tracker.get_average_rating(\\"The Matrix\\")) # Output: 4.50 # Getting top rated movie print(tracker.get_top_rated_movie()) # Output: Inception # Adding more ratings tracker.add_rating(\\"The Matrix\\", 3) # Getting updated average ratings print(tracker.get_average_rating(\\"Inception\\")) # Output: 4.50 print(tracker.get_average_rating(\\"The Matrix\\")) # Output: 4.00 # Getting updated top rated movie print(tracker.get_top_rated_movie()) # Output: Inception ``` # Hint: You might find it helpful to use a dictionary to store ratings and calculate averages. Also, consider using helper functions to manage common tasks like updating average ratings.","solution":"class MoviesRatingsTracker: def __init__(self): self.movie_ratings = {} def add_rating(self, movie_name: str, rating: int) -> None: Adds a given rating to the specified movie. Raises a ValueError if the rating is not between 0 and 5 inclusive. if rating < 0 or rating > 5: raise ValueError(\\"Rating must be between 0 and 5 inclusive.\\") if movie_name not in self.movie_ratings: self.movie_ratings[movie_name] = [] self.movie_ratings[movie_name].append(rating) def get_average_rating(self, movie_name: str) -> float: Returns the average rating of the specified movie. Returns None if the movie has no ratings yet. if movie_name not in self.movie_ratings or len(self.movie_ratings[movie_name]) == 0: return None ratings = self.movie_ratings[movie_name] average = sum(ratings) / len(ratings) return round(average, 2) def get_top_rated_movie(self) -> str: Returns the movie with the highest average rating. In case of a tie, returns the lexicographically smallest movie name. Returns None if no movies have been rated yet. if not self.movie_ratings: return None top_movie = None top_avg_rating = -1 for movie, ratings in self.movie_ratings.items(): average_rating = sum(ratings) / len(ratings) if (average_rating > top_avg_rating or (average_rating == top_avg_rating and movie < top_movie)): top_avg_rating = average_rating top_movie = movie return top_movie"},{"question":"# Longest Increasing Subsequence (LIS) with Memoization You need to implement an efficient algorithm to find the length of the longest increasing subsequence in a given list of integers. Use memoization to avoid redundant calculations and achieve optimal performance. **Scenario**: A software team needs to identify the increasing trend of data points over a period. Given a list of integers representing data points, develop a function to find the length of the longest subsequence where each element is larger than the previous one. **Function Specification**: ```python def longest_increasing_subsequence(nums: list) -> int: :param nums: List of integers representing data points. :return: Length of the longest increasing subsequence. ``` **Input and Output Formats**: * Input: * `nums` – A list of integers. * Output: * An integer representing the length of the longest increasing subsequence. **Constraints**: * `1 <= len(nums) <= 1000` * `-10^9 <= nums[i] <= 10^9` **Performance Requirements**: * Ensure your solution runs efficiently with the given constraints using memoization or dynamic programming. **Examples**: ```python # Example 1 print(longest_increasing_subsequence([10, 9, 2, 5, 3, 7, 101, 18])) # Output: 4 # Explanation: The longest increasing subsequence is [2, 3, 7, 101], which has length 4. # Example 2 print(longest_increasing_subsequence([0, 1, 0, 3, 2, 3])) # Output: 4 # Explanation: The longest increasing subsequence is [0, 1, 2, 3], which has length 4. # Example 3 print(longest_increasing_subsequence([7, 7, 7, 7, 7, 7, 7])) # Output: 1 # Explanation: There is no increasing subsequence other than the individual elements themselves. The length is 1. ``` Ensure your function handles edge cases properly and runs efficiently within the provided constraints.","solution":"def longest_increasing_subsequence(nums): Returns the length of the longest increasing subsequence in a list of integers. if not nums: return 0 n = len(nums) memo = [1] * n # Initialize memo table with 1, as each element is an LIS of length 1 for i in range(1, n): for j in range(i): if nums[i] > nums[j]: memo[i] = max(memo[i], memo[j] + 1) return max(memo)"},{"question":"# Question: Rotating a Matrix Your task is to write a function that rotates a given n x n matrix 90 degrees clockwise. # Input * A list of lists representing an n x n matrix of integers. # Output * The rotated matrix (list of lists), which is also an n x n matrix. # Constraints * The dimensions of the matrix (n): 1 ≤ n ≤ 1000. * The value of matrix elements: -10^9 ≤ element ≤ 10^9. # Example ```python matrix1 = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] print(rotate_matrix(matrix1)) # Expected Output: # [ # [7, 4, 1], # [8, 5, 2], # [9, 6, 3] # ] matrix2 = [ [1, 2], [3, 4] ] print(rotate_matrix(matrix2)) # Expected Output: # [ # [3, 1], # [4, 2] # ] ``` Ensure to write the function as efficiently as possible in terms of both time and space complexity. # Notes - Handle both small and large matrices gracefully. - Validate the function against edge cases, such as single-element matrices.","solution":"def rotate_matrix(matrix): Rotates a given n x n matrix 90 degrees clockwise. Args: matrix (list of list of int): The input n x n matrix. Returns: list of list of int: The rotated matrix. n = len(matrix) # Create a new matrix for the result with the same dimensions rotated = [[0]*n for _ in range(n)] # Perform the rotation for i in range(n): for j in range(n): rotated[j][n-1-i] = matrix[i][j] return rotated # Example usage matrix1 = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] print(rotate_matrix(matrix1)) # Expected Output: # [ # [7, 4, 1], # [8, 5, 2], # [9, 6, 3] # ] matrix2 = [ [1, 2], [3, 4] ] print(rotate_matrix(matrix2)) # Expected Output: # [ # [3, 1], # [4, 2] # ]"},{"question":"Password Strength Checker You are tasked with implementing a password strength checker function that determines the strength of a given password based on specific criteria. **Password Strength Criteria**: 1. Password length: * Less than 8 characters: Weak * 8 to 12 characters: Medium * More than 12 characters: Strong 2. Character variety: * Includes both upper and lower case letters. * Includes digits. * Includes special characters (e.g., !, @, #, , etc). **Input**: - A single string `password` representing the password to check. **Output**: - Returns one of the following strings: * \\"Weak\\" if the password is less than 8 characters long or does not meet at least two of the character variety criteria. * \\"Medium\\" if the password is 8 to 12 characters long and meets at least two of the character variety criteria. * \\"Strong\\" if the password is more than 12 characters long and meets all the character variety criteria. - Raises a `ValueError` for incorrect input types (not a string). # Task: 1. Implement the function `check_password_strength(password: str) -> str` to evaluate the strength of the password based on the criteria specified. 2. Ensure to validate the input type. # Example Usages: ```python assert check_password_strength(\\"abcd123\\") == \\"Weak\\" # Less than 8 characters assert check_password_strength(\\"Abcdef12\\") == \\"Medium\\" # Meets two criteria assert check_password_strength(\\"A@b1CdefgHijk\\") == \\"Strong\\" # Meets all criteria assert check_password_strength(\\"abcdEFGH\\") == \\"Medium\\" # Meets two criteria assert check_password_strength(\\"abcdefg\\") == \\"Weak\\" # Does not meet variety criteria ```","solution":"import re def check_password_strength(password: str) -> str: if not isinstance(password, str): raise ValueError(\\"password must be a string\\") length = len(password) has_upper = bool(re.search(r\'[A-Z]\', password)) has_lower = bool(re.search(r\'[a-z]\', password)) has_digit = bool(re.search(r\'d\', password)) has_special = bool(re.search(r\'[!@#%^&*(),.?\\":{}|<>]\', password)) variety_criteria_count = sum([has_upper, has_lower, has_digit, has_special]) if length < 8: return \\"Weak\\" elif 8 <= length <= 12 and variety_criteria_count >= 2: return \\"Medium\\" elif length > 12 and variety_criteria_count == 4: return \\"Strong\\" else: return \\"Weak\\""},{"question":"# Coding Assessment Question Question: Arithmetic Sequence Check You are required to implement a function `is_arithmetic_sequence` that checks if a given list of integers forms an arithmetic sequence. An arithmetic sequence is a sequence of numbers in which the difference between consecutive terms is constant. Function Signature ```python def is_arithmetic_sequence(arr: list) -> bool: ``` Input - `arr` (list of int): A list of integers. Output - returns: `True` if the list forms an arithmetic sequence, `False` otherwise. Constraints - The input array can be empty or have up to (10^3) elements. - The elements of the array are integers in the range ([-10^6, 10^6]). Examples ```python assert is_arithmetic_sequence([1, 3, 5, 7, 9]) == True assert is_arithmetic_sequence([2, 4, 8, 16]) == False assert is_arithmetic_sequence([-5, -2, 1, 4, 7]) == True assert is_arithmetic_sequence([0, 0, 0, 0, 0]) == True ``` # Scenario You are evaluating a sequence of integers to determine if they maintain a consistent difference between consecutive elements. This function is essential for verifying that the elements of an array follow the pattern of an arithmetic sequence. Your task is to define whether the sequence adheres to this rule.","solution":"def is_arithmetic_sequence(arr: list) -> bool: Check if the given list of integers forms an arithmetic sequence. if len(arr) <= 1: return True common_difference = arr[1] - arr[0] for i in range(2, len(arr)): if arr[i] - arr[i-1] != common_difference: return False return True"},{"question":"Coding Assessment Question # Scenario In supply chain management, it is crucial to determine the total cost of transporting goods between multiple warehouses. Goods can be moved directly or through intermediate warehouses, with different costs associated with each route, and the goal is to find the minimum transportation cost from a starting warehouse to a destination warehouse. # Problem Design a function `min_transport_cost(n: int, edges: list[tuple], start: int, end: int) -> int` to calculate the minimum transportation cost between two warehouses given multiple routes and their respective costs. 1. The input `n` will be the number of warehouses. 2. The input `edges` will be a list of tuples where each tuple represents a direct route with three integers `(u, v, w)` indicating a route from warehouse `u` to warehouse `v` with a transportation cost of `w`. 3. The function should return the minimum cost required to transport goods from the `start` warehouse to the `end` warehouse. If no route exists, the function should return -1. Example ```python def min_transport_cost(n: int, edges: list[tuple], start: int, end: int) -> int: pass # Examples print(min_transport_cost(5, [(0, 1, 10), (0, 2, 5), (1, 2, 2), (2, 1, 3), (1, 3, 1), (2, 3, 9), (3, 4, 4)], 0, 4)) # 14 print(min_transport_cost(3, [(0, 1, 6), (0, 2, 10), (1, 2, 4)], 0, 2)) # 10 print(min_transport_cost(4, [(0, 1, 1), (1, 2, 1), (2, 3, 1)], 0, 3)) # 3 print(min_transport_cost(4, [(0, 1, 1), (1, 2, 1), (2, 3, 1)], 3, 0)) # -1 (no route) ``` # Constraints * 1 <= n <= 1000 * Each warehouse is labeled with an integer from 0 to n-1. * 0 <= len(edges) <= 2000 * Each route cost `w` will be a positive integer. # Function Signature ```python def min_transport_cost(n: int, edges: list[tuple], start: int, end: int) -> int: pass ``` # Considerations 1. **Efficiency**: Given the potential size of the input, ensure the algorithm is optimized for performance. 2. **Graph Algorithms**: Utilize appropriate graph traversal or shortest path algorithms like Dijkstra\'s or Bellman-Ford. 3. **Edge Cases**: Handle scenarios with no routes, disconnected warehouses, and identical start-end warehouses.","solution":"import heapq from collections import defaultdict import sys def min_transport_cost(n: int, edges: list[tuple], start: int, end: int) -> int: Returns the minimum transportation cost from start warehouse to end warehouse. graph = defaultdict(list) for u, v, w in edges: graph[u].append((v, w)) # Dijkstra\'s algorithm to find the shortest path pq = [(0, start)] dist = {i: sys.maxsize for i in range(n)} dist[start] = 0 while pq: current_distance, u = heapq.heappop(pq) # If we reached the end node if u == end: return current_distance if current_distance > dist[u]: continue for neighbor, weight in graph[u]: distance = current_distance + weight if distance < dist[neighbor]: dist[neighbor] = distance heapq.heappush(pq, (distance, neighbor)) return -1 if dist[end] == sys.maxsize else dist[end]"},{"question":"# Problem Statement You are given a list of stocks where each stock\'s performance is represented as a string of alphanumeric characters. The characters in the string appear in the order of occurrence of the transactions. A stock is considered \\"steady\\" if the relative order of both alphabets and digits remains consistent. Your task is to determine if a given stock is \\"steady\\". Implement the function `is_steady_stock(stock: str) -> bool`, which takes a string `stock` and returns a boolean indicating whether the stock is steady. # Input * `stock`: A string where each character is either an alphabet or a digit. The length of the string is between 1 and 1000 inclusive. # Output * A boolean indicating whether the stock is steady. # Constraints 1. The string contains only alphanumeric characters. # Requirements * The function should efficiently determine if the order of alphabets and digits remains stable, considered independently. # Example ```python # Example usage print(is_steady_stock(\\"a1b2c3\\")) # Output should be: True print(is_steady_stock(\\"3a2b1c\\")) # Output should be: False ``` # Explanation The first string \\"a1b2c3\\" is steady because the alphabets and digits keep their relative order: - Alphabets: \'a\', \'b\', \'c\' (in order) - Digits: \'1\', \'2\', \'3\' (in order) The second string \\"3a2b1c\\" is not steady because: - Digits are \'3\', \'2\', \'1\' (not in order) - Despite alphabets being \'a\', \'b\', \'c\' (in order), the digits are not.","solution":"def is_steady_stock(stock: str) -> bool: Determines if the given stock is steady. A stock is considered \\"steady\\" if the relative order of both alphabets and digits remains consistent. Parameters: stock (str): The stock performance string consisting of alphanumeric characters. Returns: bool: True if the stock is steady, False otherwise. alphabets = [] digits = [] for char in stock: if char.isalpha(): alphabets.append(char) elif char.isdigit(): digits.append(char) if alphabets != sorted(alphabets): return False if digits != sorted(digits): return False return True"},{"question":"# Advanced File Search using Regular Expressions Background In software development, file searching is a common task, often required for parsing logs, searching code bases, and filtering data. Regular expressions provide a powerful tool for such searches by allowing pattern matching across textual data. Problem Statement You need to implement a function `search_files` that searches for files in a specified directory which contain lines matching a given regular expression pattern. The function should return a list of filenames where at least one line matches the pattern. Function Signature ```python def search_files(directory: str, pattern: str) -> list[str]: Search for files in the specified directory containing lines that match the pattern. :param directory: Path to the directory where files need to be searched :param pattern: Regular expression pattern to match in the files :return: List of filenames with at least one line matching the pattern pass ``` Requirements 1. Implement the `search_files` function that searches all files within the provided directory and returns a list of filenames where any line contains text that matches the given regular expression pattern. 2. The function must only search within files and not directories. 3. Return only the filenames that have at least one matching line. Constraints - Assume `directory` is a valid path to an existing directory. - Pattern will be a valid regular expression. - Lines in files could be very long, handle them wisely to avoid unnecessary memory consumption. - Only text files should be considered and other file types should be ignored. Examples Consider the following directory structure: ``` /example_dir |-- file1.txt |-- file2.log |-- file3.md |-- sub_directory |-- file4.txt ``` Contents of files: - `/example_dir/file1.txt`: ``` hello world this is a test ``` - `/example_dir/file2.log`: ``` hello regex patterns matched ``` - `/example_dir/file3.md`: ``` simple markdown file nothing to see here ``` - `/example_dir/sub_directory/file4.txt`: ``` nested directories are here but we won\'t search them ``` ```python # Example 1 directory = \\"/example_dir\\" pattern = r\\"bhellob\\" matched_files = search_files(directory, pattern) # Expected: [\'file1.txt\', \'file2.log\'] # Example 2 directory = \\"/example_dir\\" pattern = r\\"btestb\\" matched_files = search_files(directory, pattern) # Expected: [\'file1.txt\'] ``` Additional Notes: - Use the built-in `os` and `re` modules for directory traversal and regular expression matching, respectively. - Make sure your function is efficient and handles large directories and files gracefully. - Ensure that your function can work with various text encodings present in files, default to \'utf-8\' and handle other encodings appropriately.","solution":"import os import re def search_files(directory: str, pattern: str) -> list[str]: Search for files in the specified directory containing lines that match the pattern. :param directory: Path to the directory where files need to be searched :param pattern: Regular expression pattern to match in the files :return: List of filenames with at least one line matching the pattern matched_files = [] regex = re.compile(pattern) try: for root, dirs, files in os.walk(directory): for file in files: file_path = os.path.join(root, file) try: with open(file_path, \'r\', encoding=\'utf-8\') as f: for line in f: if regex.search(line): matched_files.append(file) break except (IOError, UnicodeDecodeError): # Skip files that cannot be read or decoded continue # Do not search subdirectories break except Exception as e: raise e return matched_files"},{"question":"# Problem Statement Create an advanced version of the Binary Search algorithm to demonstrate your understanding of search algorithms and optimization techniques. Your task is to implement an efficient and robust solution that excels in handling various edge cases. # Advanced Binary Search # Objective: Implement a function `advanced_binary_search(arr: list, target: int) -> int` that performs a binary search on a sorted list and returns the index of the target value. If the target is not found, return -1. Your function should also handle duplicate values correctly by returning the first occurrence of the target. # Requirements: 1. **Input**: * `arr`: A list of integers sorted in non-decreasing order with size `n (0 <= n <= 10^5)` elements. * `target`: An integer value to search for in the list. 2. **Output**: * The index of the first occurrence of `target` in the list, or -1 if the target is not found. 3. **Constraints**: * Your implementation must run in O(log n) time complexity. * Handle arrays with duplicate values and ensure the first occurrence of the target is returned. 4. **Edge cases**: * Handle empty lists and lists with a single element. * The function should not error out for valid inputs. # Function Signature: ```python def advanced_binary_search(arr: list, target: int) -> int: pass ``` # Example: ```python # Example 1: arr = [1, 2, 3, 4, 4, 5] target = 4 # Output: 3 (first occurrence of 4 is at index 3) # Example 2: arr = [1, 2, 3, 4, 5] target = 6 # Output: -1 (6 is not in the list) # Example 3: arr = [] target = 1 # Output: -1 (the list is empty) # Example 4: arr = [5] target = 5 # Output: 0 (5 is the only element) ``` # Notes: 1. Ensure your function works efficiently for large inputs up to the maximum constraint size. 2. Make sure your implementation correctly handles the edge cases and returns the first occurrence of the target if there are duplicates.","solution":"def advanced_binary_search(arr: list, target: int) -> int: Performs a binary search on a sorted list and returns the index of the first occurrence of the target value. If the target is not found, returns -1. :param arr: List of sorted integers :param target: Integer value to search for :return: Index of the first occurrence of target or -1 if target is not found left, right = 0, len(arr) - 1 result = -1 while left <= right: mid = (left + right) // 2 if arr[mid] == target: result = mid right = mid - 1 # Continue searching on the left half elif arr[mid] < target: left = mid + 1 else: right = mid - 1 return result"},{"question":"# Dynamic String Pattern Matching Context You are tasked with implementing a dynamic string pattern matching function that can handle multiple wildcard characters. The wildcard characters include \'*\' which matches zero or more characters, and \'?\' which matches exactly one character. This will test your understanding of dynamic programming concepts and string manipulation in algorithms. Task 1. **Implement Pattern Matching Function**: - Develop a function that takes two strings, `s` (the string to be matched) and `p` (the pattern), and determines whether the string matches the pattern. 2. **Dynamic Programming Approach**: - Use a dynamic programming table to keep track of matching states between substrings of `s` and `p`. Expected Function Implementation ```python def is_match(s: str, p: str) -> bool: # Your code here ``` Input and Output **Input**: - `s` (string): The string to be matched. - `p` (string): The pattern containing wildcard characters \'*\' and \'?\'. **Output**: - A boolean value indicating whether the string matches the pattern. Constraints - The input strings `s` and `p` should contain only lowercase English letters and the wildcard characters \'*\' and \'?\'. - The length of `s` and `p` will not exceed 200 characters. Scenario Implement the pattern matching function using a dynamic programming approach. The function should efficiently handle all possible edge cases, such as patterns with consecutive \'*\' characters or patterns that are longer than the string. Test the implementation to ensure it correctly identifies matches and mismatches according to the described setup. Example ```python print(is_match(\\"adceb\\", \\"*a*b\\")) # Output: True print(is_match(\\"acdcb\\", \\"a*c?b\\")) # Output: False print(is_match(\\"\\",\\"*\\")) # Output: True print(is_match(\\"aa\\", \\"a\\")) # Output: False ``` Ensure that the pattern matching function is implemented correctly and handles all the specified constraints.","solution":"def is_match(s: str, p: str) -> bool: Determines if the string `s` matches the pattern `p`. The pattern can include \'?\' which matches exactly one character and \'*\' which matches zero or more characters. # dp[i][j] will be True if the first `i` characters in `s` can match the first `j` characters in `p` dp = [[False] * (len(p) + 1) for _ in range(len(s) + 1)] # Empty pattern matches empty string dp[0][0] = True # Fill the entries for patterns with leading \'*\' for j in range(1, len(p) + 1): if p[j-1] == \'*\': dp[0][j] = dp[0][j-1] # Fill the dp table for i in range(1, len(s) + 1): for j in range(1, len(p) + 1): if p[j-1] == \'*\': dp[i][j] = dp[i][j-1] or dp[i-1][j] elif p[j-1] == \'?\' or p[j-1] == s[i-1]: dp[i][j] = dp[i-1][j-1] return dp[len(s)][len(p)]"},{"question":"# Problem Statement You are developing a simple attendance management system for a classroom. Each student is represented by their unique ID and a respective list of attendance entries. Each attendance entry has a corresponding date and a boolean indicating attendance on that date. You are required to write a function to calculate the attendance percentage of a student given their ID and a dictionary of attendance records for multiple students. # Function Signature ```python def attendance_percentage(student_id: int, attendance_records: dict) -> float: pass ``` # Input - `student_id (int)`: The unique ID of the student whose attendance percentage needs to be calculated; non-negative integer. - `attendance_records (dict)`: A dictionary where keys are student IDs (integers) and values are lists of tuples. Each tuple contains a string representing a date in \'YYYY-MM-DD\' format and a boolean indicating attendance (True for present, False for absent). # Output - Returns the attendance percentage of the student as a float. If there are no attendance records for the student, return -1. # Constraints - Each student ID is guaranteed to be unique within the attendance records. - The dates are well-formed and do not need additional validation. - There must be at least one student with attendance records in the input dictionary. - The function should raise a `ValueError` if the `student_id` is not present in the `attendance_records` dictionary. # Requirements - Your solution must handle and validate all possible edge cases. - Performance considerations: Ensure your solution runs efficiently for large input sizes. # Example ```python >>> attendance_records = { ... 101: [(\'2023-10-01\', True), (\'2023-10-02\', False), (\'2023-10-03\', True)], ... 102: [(\'2023-10-01\', True), (\'2023-10-02\', True), (\'2023-10-03\', True)], ... 103: [(\'2023-10-01\', False), (\'2023-10-02\', False)] ... } >>> attendance_percentage(student_id=101, attendance_records=attendance_records) 66.66666666666666 >>> attendance_percentage(student_id=102, attendance_records=attendance_records) 100.0 >>> attendance_percentage(student_id=103, attendance_records=attendance_records) 0.0 >>> attendance_percentage(student_id=104, attendance_records=attendance_records) Traceback (most recent call last): ... ValueError: Student ID not found in attendance records ``` # Implementation In this task, you are asked to implement the `attendance_percentage` function according to the provided specifications and constraints. Ensure you handle all edge cases appropriately and raise the appropriate errors as detailed.","solution":"def attendance_percentage(student_id, attendance_records): Calculates the attendance percentage of a student given their ID and a dictionary of attendance records for multiple students. Parameters: student_id (int): The unique ID of the student whose attendance percentage needs to be calculated. attendance_records (dict): A dictionary where keys are student IDs (integers) and values are lists of tuples. Each tuple contains a date (\'YYYY-MM-DD\') and a boolean indicating attendance. Returns: float: Attendance percentage of the student. If there are no attendance records for the student, return -1. Raises: ValueError: If the student ID is not found in the attendance records. if student_id not in attendance_records: raise ValueError(\\"Student ID not found in attendance records\\") records = attendance_records[student_id] if not records: return -1 total_classes = len(records) attended_classes = sum(1 for date, attended in records if attended) return (attended_classes / total_classes) * 100"},{"question":"**Coding Question: Product of Array Except Self with Extra Space** **Scenario**: You are working with a data processing system that frequently needs to compute products of array elements. One specific problem requires you to compute the product of all elements in an array except for the element at each position, without using division. Your task is to implement this calculation efficiently. **Problem**: Implement a function `product_except_self` that takes an array of integers and returns a new array such that each element at index `i` of the new array is the product of all the numbers in the original array except the one at `i`. # Requirements: 1. Do not use the division operation. 2. Achieve a time complexity of O(n). # Function Signature: ```python def product_except_self(nums: List[int]) -> List[int]: Given an array nums, return an array output such that output[i] is equal to the product of all the elements of nums except nums[i]. Args: nums (List[int]): The input array of integers. Returns: List[int]: The resultant array where each element is the product of all elements except the one at the same position in the input array. Examples: >>> product_except_self([1, 2, 3, 4]) [24, 12, 8, 6] >>> product_except_self([0, 1]) [1, 0] >>> product_except_self([-1, 1, 0, -3, 3]) [0, 0, 9, 0, 0] ``` # Constraints: - The input array will have at least 2 elements but not more than (10^5) elements. - Each element of the array can be from (-30) to (30) inclusive. # Examples 1. **Input**: `[1, 2, 3, 4]` **Output**: `[24, 12, 8, 6]` -> Products are (2 times 3 times 4), (1 times 3 times 4), (1 times 2 times 4), (1 times 2 times 3) 2. **Input**: `[0, 1]` **Output**: `[1, 0]` -> For index 0, product is just (1). For index 1, product is (0). 3. **Input**: `[-1, 1, 0, -3, 3]` **Output**: `[0, 0, 9, 0, 0]` -> Products for indices with 0 generates 0, while the product at index 2 (excluding 0) results in ( -1 times 1 times -3 times 3 = 9). ```python def product_except_self(nums: List[int]) -> List[int]: n = len(nums) # Create output array with all elements initialized to 1 for multiplication output = [1] * n # Temp variable to store left products left = 1 for i in range(n): output[i] = left left *= nums[i] # Temp variable to store right products right = 1 for i in range(n-1, -1, -1): output[i] *= right right *= nums[i] return output ```","solution":"from typing import List def product_except_self(nums: List[int]) -> List[int]: n = len(nums) # Create output array with all elements initialized to 1 for multiplication output = [1] * n # Temp variable to store left products left = 1 for i in range(n): output[i] = left left *= nums[i] # Temp variable to store right products right = 1 for i in range(n-1, -1, -1): output[i] *= right right *= nums[i] return output"},{"question":"# Polynomial Curve Fitting **Context**: In data analysis and machine learning, polynomial curve fitting is a common task where a polynomial function is fitted to a set of data points. This method helps in predicting and understanding the trend of data. **Problem Statement**: Implement a function `polynomial_curve_fit` that fits a polynomial of a specified degree to given data points using the least-squares method. The function should return the polynomial coefficients that minimize the squared error of the fit. # Function Signature ```python def polynomial_curve_fit( x_values: list[float], y_values: list[float], degree: int ) -> list[float]: pass ``` # Input - **x_values (list[float])**: A list of x-coordinates of the data points. - **y_values (list[float])**: A list of y-coordinates of the data points. - **degree (int)**: The degree of the polynomial to fit. # Output - **list[float]**: A list of coefficients of the polynomial in ascending order, i.e., from the constant term to the highest degree term. # Constraints 1. The length of `x_values` and `y_values` will be the same. 2. The degree of the polynomial will be at least 0 and at most one less than the number of data points. 3. `x_values` will have no repeated values. # Examples ```python x_vals = [1, 2, 3, 4, 5] y_vals = [2, 3, 5, 7.5, 11] deg = 2 print(polynomial_curve_fit(x_vals, y_vals, deg)) # Output: [1.25, 0.95, 0.3] (example output, actual values may differ) x_vals = [0, 1, 2, 3] y_vals = [1, 2, 4, 8] deg = 3 print(polynomial_curve_fit(x_vals, y_vals, deg)) # Output: [1, -0.5, 1.25, 0.25] (example output, actual values may differ) ``` # Notes * Your function should raise a ValueError with a descriptive message if the input lists are not the same length. * Utilize NumPy\'s `polyfit` function to implement the least-squares polynomial fit. * Ensure your function handles edge cases efficiently, such as fitting very high-degree polynomials or polynomials to a small number of points. * Include additional test cases to validate your implementation with various degrees of polynomial fits. **Testing**: Besides the provided examples, create additional test cases to ensure the implementation\'s robustness, including edge cases such as: 1. Providing only one data point and fitting a polynomial of degree 0. 2. Fitting a degree polynomial equal to the number of data points minus one (e.g., a cubic polynomial to 4 points). 3. Testing with real-world data points to verify the accuracy of the fit.","solution":"import numpy as np def polynomial_curve_fit(x_values, y_values, degree): Fits a polynomial of a specified degree to the given data points. Args: x_values (list of float): The x-coordinates of the data points. y_values (list of float): The y-coordinates of the data points. degree (int): The degree of the polynomial to fit. Returns: list of float: The coefficients of the polynomial in ascending order. if len(x_values) != len(y_values): raise ValueError(\\"The length of x_values and y_values must be the same.\\") coefficients = np.polyfit(x_values, y_values, degree) return coefficients.tolist()[::-1] # Return coefficients in ascending order"},{"question":"# Scenario You are a software engineer working on a project to develop an efficient file storage system. To optimize storage and retrieval operations, you need to determine the longest sequence of unique characters from a given file content, treating the file content as a string of characters. # Task Write a function `longest_unique_substring_length(s: str) -> int` that finds the length of the longest substring with all unique characters from a given string `s`. # Input * **s**: A string of length `1 <= len(s) <= 100,000`, representing the file content. # Output * Return the length of the longest substring that contains only unique characters. # Function Signature ```python def longest_unique_substring_length(s: str) -> int: pass ``` # Examples * `longest_unique_substring_length(\\"abcdefabcbb\\")` should return `6`. * `longest_unique_substring_length(\\"bbbbb\\")` should return `1`. * `longest_unique_substring_length(\\"pwwkew\\")` should return `3`. # Constraints * Your implementation should be efficient, taking into account the length of the input string. # Notes * Consider using a sliding window approach to achieve an optimal solution. * Ensure your solution handles large input sizes efficiently, both in terms of time and space complexity.","solution":"def longest_unique_substring_length(s: str) -> int: Returns the length of the longest substring with all unique characters. n = len(s) char_index = {} max_len = 0 start = 0 # Start index of the current substring for end in range(n): if s[end] in char_index and char_index[s[end]] >= start: start = char_index[s[end]] + 1 char_index[s[end]] = end max_len = max(max_len, end - start + 1) return max_len"},{"question":"Problem Statement You are provided with a text document and you need to implement a function that identifies and counts the occurrences of a specific word given as input, ignoring case sensitivity. Design a function `count_word_occurrences(text: str, word: str) -> int` that meets the following criteria: * Takes a string `text` which represents the content of the text document. * Takes a string `word` which represents the word to be counted. * Returns an integer representing the number of times the word occurs in the text. # Input * A string `text` with length `m` where 1 ≤ m ≤ 10^6. * A string `word` with length `n` where 1 ≤ n ≤ 100. # Output * An integer representing the count of the word\'s occurrences in the text. # Constraints * Your function must be case-insensitive. For example, if the word is \\"Python\\" and the text contains \\"python\\", \\"Python\\", and \\"PYTHON\\", all these should be counted. * Assume that the word only consists of alphabetical characters and that the text does not contain any special characters or punctuation. # Example Input: ```python text = \\"Python is great. I love python because Python is easy to learn.\\" word = \\"python\\" ``` Output: ```python 3 ``` Explanation: The word \\"python\\" appears three times in the text regardless of case. Input: ```python text = \\"Data Science is a vast field and Python plays a major role in it.\\" word = \\"role\\" ``` Output: ```python 1 ``` Explanation: The word \\"role\\" appears once in the text. # Additional Requirements * You should aim to achieve an O(m) time complexity where `m` is the length of the input text.","solution":"def count_word_occurrences(text: str, word: str) -> int: Counts the occurrences of a specific word in a given text, ignoring case sensitivity. Parameters: - text (str): The text content to search within. - word (str): The word to count in the text. Returns: - int: The number of times the word occurs in the text. # Convert both text and word to lower case to ensure case insensitive comparison lower_text = text.lower() lower_word = word.lower() # Split the text into words using whitespace as delimiter words = lower_text.split() # Count occurrences of the word in split words list count = words.count(lower_word) return count"},{"question":"# Binary Search Algorithm In algorithm design, the binary search algorithm is a popular method for finding a specific element in a sorted array efficiently. It operates by repeatedly dividing the search interval in half. If the element\'s value is less than the middle element\'s, the search continues in the lower half, otherwise in the upper half. This problem focuses on implementing a recursive version of binary search. # Objective Write a Python function `recursive_binary_search(arr, target)` that performs a binary search on a sorted array to find the target element. The function should return the index of the target element if it exists in the array, otherwise return `-1`. The function must be implemented using recursion. # Requirements 1. The function should accept two parameters: - `arr`: a list of integers that is already sorted in ascending order. - `target`: an integer value to search for within the array. 2. The function should return the index of `target` if it exists within `arr`. If the `target` is not found, the function should return `-1`. 3. The function must use recursion to perform the binary search. 4. Include appropriate input validation: - If `arr` is not a list or `target` is not an integer, raise a `TypeError`. # Implementation Details - Use a helper function (nested within `recursive_binary_search`), which performs the actual recursive search. This helper function should have additional parameters (e.g., `low` and `high`) to keep track of the current search interval. - The initial call to the helper function should cover the full range of indices in `arr`. # Input Format - `arr` (list): A list of integers sorted in ascending order. - `target` (int): An integer value to search for within the array. # Output Format - An integer representing the index of the target element, or `-1` if the target is not found. # Examples 1. `recursive_binary_search([1, 2, 3, 4, 5], 3)` returns `2` 2. `recursive_binary_search([1, 3, 5, 7, 9], 6)` returns `-1` 3. `recursive_binary_search([10, 20, 30, 40, 50], 50)` returns `4` 4. `recursive_binary_search([2, 4, 6, 8, 10], 7)` returns `-1` 5. `recursive_binary_search([5, 10, 15, 20, 25], 5)` returns `0` 6. `recursive_binary_search([], 1)` returns `-1` # empty list case 7. `recursive_binary_search(\'[1, 2, 3]\', 2)` raises `TypeError: arr must be a list of integers` 8. `recursive_binary_search([1, 2, 3], \'2\')` raises `TypeError: target must be an integer` # Constraints - Ensure the implementation handles typical use cases efficiently. - Input values will be within the valid range for Python integers.","solution":"def recursive_binary_search(arr, target): Perform a binary search using recursion to find the index of the target in a sorted array. :param arr: A list of integers sorted in ascending order. :param target: An integer value to search for within the array. :return: The index of the target element if it exists in the array; otherwise, -1. if not isinstance(arr, list) or not all(isinstance(x, int) for x in arr): raise TypeError(\\"arr must be a list of integers\\") if not isinstance(target, int): raise TypeError(\\"target must be an integer\\") def helper(low, high): if low > high: return -1 mid = (low + high) // 2 if arr[mid] == target: return mid elif arr[mid] > target: return helper(low, mid - 1) else: return helper(mid + 1, high) return helper(0, len(arr) - 1)"},{"question":"# Finding the First Unique Character in a String **Context**: In many applications, it is necessary to identify the first unique character in a string. A unique character is one that appears exactly once in the string. This type of problem is common in text processing and can help optimize algorithms for text analysis. **Task**: Write a function `first_unique_character(s: str) -> int` that returns the index of the first non-repeating character in a given string. If there is no unique character, return -1. **Input**: * `s`: A string of lowercase English letters. Example: `\\"leetcode\\"` **Output**: * Return an integer representing the index of the first unique character. If no such character exists, return -1. **Constraints**: * The string length will be between 1 and 10,000. Requirements: 1. The time complexity should not exceed O(n). ```python def first_unique_character(s: str) -> int: Return the index of the first non-repeating character in a string. Wiki: https://en.wikipedia.org/wiki/Character_frequency >>> first_unique_character(\\"leetcode\\") 0 >>> first_unique_character(\\"loveleetcode\\") 2 >>> first_unique_character(\\"aabb\\") -1 >>> first_unique_character(\\"cc\\") -1 >>> first_unique_character(\\"abcd\\") 0 from collections import Counter # Your code here count = Counter(s) for index, char in enumerate(s): if count[char] == 1: return index return -1 if __name__ == \\"__main__\\": import doctest doctest.testmod() ``` **Explanation**: 1. Create a frequency counter for all characters in the string. 2. Iterate through the string and check the count of each character. 3. Return the index of the first character that appears only once. 4. If no such character is found, return -1. **Edge Cases to Consider**: 1. The string has no unique characters. 2. The string has all unique characters. 3. The string length is at its minimum (1 character). 4. The string length is at its maximum (10,000 characters).","solution":"def first_unique_character(s: str) -> int: Return the index of the first non-repeating character in a string. >>> first_unique_character(\\"leetcode\\") 0 >>> first_unique_character(\\"loveleetcode\\") 2 >>> first_unique_character(\\"aabb\\") -1 >>> first_unique_character(\\"cc\\") -1 >>> first_unique_character(\\"abcd\\") 0 from collections import Counter count = Counter(s) for index, char in enumerate(s): if count[char] == 1: return index return -1"},{"question":"# Coding Assessment Question Context You are assisting a software startup in developing a function that calculates the Simple Moving Average (SMA) of stock prices over a specified period. The Simple Moving Average is a commonly used indicator in finance, calculated by summing up the stock\'s closing prices over a certain timeframe and then dividing the sum by that timeframe. Task Implement a function named `simple_moving_average` that accepts two parameters: `prices` (a list of floats representing the closing prices of the stock) and `window_size` (an integer representing the number of periods over which to calculate the SMA). The function should return a list of floats representing the SMA values for each period starting from the `window_size`-th price. The function should raise a `ValueError` if: 1. `window_size` is less than or equal to 0. 2. `window_size` is greater than the number of prices. Function Signature ```python def simple_moving_average(prices: list[float], window_size: int) -> list[float]: pass ``` Input * `prices` (list[float]): A list of closing stock prices. * `window_size` (int): The number of periods over which to calculate the SMA. Output * A list of floats representing the SMA values. Constraints * The `prices` list will have at least one price. * `window_size` will be a positive integer. * Ensure sufficient input check to handle edge cases. Examples ```python >>> simple_moving_average([1, 2, 3, 4, 5], 3) [2.0, 3.0, 4.0] >>> simple_moving_average([10, 20, 30, 40, 50], 2) [15.0, 25.0, 35.0, 45.0] >>> simple_moving_average([5, 6, 7], 5) Traceback (most recent call last): ... ValueError: Window size must not be greater than the number of prices >>> simple_moving_average([], 3) Traceback (most recent call last): ... ValueError: Window size must not be greater than the number of prices ``` Additional Notes * Ensure your implementation handles the constraints and edge cases efficiently. * Numeric precision is crucial: ensure that your solution returns floating-point values to maintain accuracy. * Focus on the performance of your algorithm, especially for larger input sizes.","solution":"def simple_moving_average(prices: list[float], window_size: int) -> list[float]: Calculate the Simple Moving Average (SMA) for a list of stock prices over a given window size. :param prices: List[float] - The list of closing stock prices. :param window_size: int - The number of periods to calculate the SMA over. :return: List[float] - A list of SMA values for each period. :raises ValueError: If window_size is invalid (<=0 or more than number of prices). if window_size <= 0: raise ValueError(\\"Window size must be greater than 0\\") if window_size > len(prices): raise ValueError(\\"Window size must not be greater than the number of prices\\") sma_values = [] for i in range(len(prices) - window_size + 1): window = prices[i:i+window_size] sma = sum(window) / window_size sma_values.append(sma) return sma_values"},{"question":"# **Question: Develop a Text-Based Game Engine with Scenario Management** Your task is to create a text-based adventure game engine that dynamically manages scenarios, player choices, and resulting outcomes. The game should be driven by a scenario tree where each node represents a game situation and possible transitions based on player input. **Requirements:** 1. **Game Structure**: - Implement a `Scenario` class representing individual game scenarios. - Implement a `GameEngine` class to manage the flow of the game based on the scenario tree. - Scenarios consist of a description, a set of player choices, and corresponding outcomes leading to other scenarios. 2. **Function Implementation**: - `add_scenario(description, choices)`: Adds a scenario to the game. `choices` is a dictionary where keys are player choices and values are IDs of the next scenarios. - `start_game(start_scenario_id)`: Starts the game from the scenario identified by `start_scenario_id`. - `make_choice(choice)`: Takes a player\'s choice, transitions to the next scenario, and returns the new scenario\'s description and options. - `get_current_scenario()`: Returns the description and player choices of the current scenario. 3. **I/O Specifications**: - **Input**: - Scenario descriptions: Text descriptions of the scenarios. - Choices: A dictionary mapping player choices (strings) to the IDs of subsequent scenarios. - Player choices during gameplay. - **Output**: - The game engine should provide feedback to the player by describing the current scenario and available choices after each transition. - It should handle end game conditions if a scenario leads to a conclusion. **Constraints**: - The engine should be designed to be expandable. You can add more scenarios and choices without modifying existing code (beyond defining new scenarios and transitions). - All choices must be validated against the current scenario\'s options. # Example Usage: ```python # Sample Game Definition # Initialize the game engine engine = GameEngine() # Add scenarios to the game engine.add_scenario( 1, \\"You find yourself in a dense forest. There are paths to the left and right.\\", {\\"left\\": 2, \\"right\\": 3} ) engine.add_scenario( 2, \\"You follow the left path and encounter a river.\\", {\\"cross\\": 4, \\"go back\\": 1} ) engine.add_scenario( 3, \\"You take the right path and meet a friendly traveler.\\", {\\"talk\\": 5, \\"ignore\\": 1} ) engine.add_scenario( 4, \\"You successfully cross the river and find treasure.\\", {\\"end\\": None} ) engine.add_scenario( 5, \\"The traveler gives you a valuable hint about finding treasure.\\", {\\"follow hint\\": 4, \\"return\\": 1} ) # Start the game engine.start_game(1) # Simulate player choices print(engine.get_current_scenario()) # Output: (\\"You find yourself in a dense forest. There are paths to the left and right.\\", {\\"left\\": 2, \\"right\\": 3}) engine.make_choice(\\"left\\") print(engine.get_current_scenario()) # Output: (\\"You follow the left path and encounter a river.\\", {\\"cross\\": 4, \\"go back\\": 1}) engine.make_choice(\\"cross\\") print(engine.get_current_scenario()) # Output: (\\"You successfully cross the river and find treasure.\\", {\\"end\\": None}) ``` In the example above, the game engine should be capable of managing complex scenarios based on player input, ensuring smooth transitions and accurate scenario descriptions at each stage of the game. Implement methods to handle various player actions and ensure proper navigation through the scenario tree.","solution":"class Scenario: def __init__(self, description, choices): self.description = description self.choices = choices class GameEngine: def __init__(self): self.scenarios = {} self.current_scenario_id = None def add_scenario(self, scenario_id, description, choices): self.scenarios[scenario_id] = Scenario(description, choices) def start_game(self, start_scenario_id): if start_scenario_id not in self.scenarios: raise ValueError(\\"Invalid start scenario id\\") self.current_scenario_id = start_scenario_id def make_choice(self, choice): if self.current_scenario_id is None: raise ValueError(\\"The game has not started yet\\") current_scenario = self.scenarios[self.current_scenario_id] if choice not in current_scenario.choices: raise ValueError(\\"Invalid choice\\") next_scenario_id = current_scenario.choices[choice] if next_scenario_id is None: self.current_scenario_id = None else: self.current_scenario_id = next_scenario_id return self.get_current_scenario() def get_current_scenario(self): if self.current_scenario_id is None: return (\\"The game has ended.\\", {}) current_scenario = self.scenarios[self.current_scenario_id] return (current_scenario.description, current_scenario.choices)"},{"question":"# Scenario You have been tasked with developing a tool to manage a collection of user records in a registration system. The system must efficiently handle insertion and searching of user records based on a unique user identifier. # Task You are required to write a class `UserRecords` that allows adding and searching for users based on their unique identifier. Each user record will contain an integer `user_id` and a string `user_name`. # Requirements * **Input**: - Use the `add_user` method to insert a new user record, which takes two arguments: `user_id` (an integer) and `user_name` (a string), e.g., `add_user(1, \\"Alice\\")`. - Use the `search_user` method to find a user by their `user_id`, which takes one argument: `user_id` (an integer), e.g., `search_user(1)`. * **Output**: - The `add_user` method should return `True` if the user was added successfully, and `False` if a user with the same `user_id` already exists. - The `search_user` method should return the `user_name` corresponding to the `user_id` if found, or `None` if the user does not exist. * **Constraints**: - The `user_id` is guaranteed to be unique for each user. - The `user_name` is guaranteed to be a non-empty string. Here\'s the class signature: ```python class UserRecords: def __init__(self): pass def add_user(self, user_id, user_name): pass def search_user(self, user_id): pass ``` # Example ```python # Usage of the UserRecords class users = UserRecords() # Adding users >>> users.add_user(1, \\"Alice\\") True >>> users.add_user(2, \\"Bob\\") True >>> users.add_user(1, \\"Charlie\\") # Duplicate user_id False # Searching users >>> users.search_user(1) \'Alice\' >>> users.search_user(3) # User not found None ``` # Notes 1. Consider using a dictionary to store the user records for efficient insertion and lookup operations. 2. Ensure your code handles edge cases, such as adding multiple users with the same `user_id`. 3. Provide inline documentation explaining your logic and approach.","solution":"class UserRecords: def __init__(self): Initialize a UserRecords object with an empty dictionary to store user records. self.records = {} # Dictionary to store user records def add_user(self, user_id, user_name): Add a user record with the given user_id and user_name. Args: user_id (int): The unique identifier for the user. user_name (str): The name of the user. Returns: bool: True if the user was added successfully, False if a user with the same user_id already exists. if user_id in self.records: return False # User with this user_id already exists self.records[user_id] = user_name return True def search_user(self, user_id): Search for a user by their unique identifier. Args: user_id (int): The unique identifier for the user. Returns: str or None: The name of the user if found, None otherwise. return self.records.get(user_id, None)"},{"question":"# Calculating the Maximum Water Area In a histogram-style plot, we have a list of non-negative integers representing the heights of vertical lines drawn at each unit index. Suppose you were to fill this plot with water, where the water could only be trapped between the bars based on their heights. Your task is to calculate the maximum area of water that could be trapped between these bars. # Requirements: 1. Implement a function `max_water_area(heights: List[int]) -> int` that calculates the maximum area of water. 2. The input list will only contain non-negative integers and can have up to `10^5` elements. 3. If the list contains fewer than 2 elements, the maximum trapped water area should be `0`. # Constraints: - `length of heights` is within the range `[0, 10^5]` - Height values are within the range `[0, 10^5]` # Example: ```python # Example 1 heights = [1, 8, 6, 2, 5, 4, 8, 3, 7] max_water_area(heights) => 49 # Example 2 heights = [1, 1] max_water_area(heights) => 1 # Example 3 heights = [4, 3, 2, 1, 4] max_water_area(heights) => 16 # Example 4 heights = [] max_water_area(heights) => 0 ``` # Edge Cases: - `heights` can be empty; in this case, the output should be `0`. - No water can be trapped if there aren\'t at least two bars. - All elements in `heights` can be zeros or equal. # Performance Considerations: - Aim for an O(n) solution by utilizing a two-pointer technique to achieve optimal performance for large input sizes. # Function Signature: ```python def max_water_area(heights: List[int]) -> int: pass ``` # Implementation Note: - You must validate the input to ensure all elements in `heights` are non-negative integers. Raise a `ValueError` if the input does not comply.","solution":"from typing import List def max_water_area(heights: List[int]) -> int: if not all(isinstance(height, int) and height >= 0 for height in heights): raise ValueError(\\"All elements in heights must be non-negative integers.\\") n = len(heights) if n < 2: return 0 left, right = 0, n - 1 max_area = 0 while left < right: width = right - left height = min(heights[left], heights[right]) max_area = max(max_area, width * height) if heights[left] < heights[right]: left += 1 else: right -= 1 return max_area"},{"question":"# Question: Inventory System Management Objective: You\'re tasked with developing an inventory management system for a small retail store. The system should include functionality to track items, their quantities, and manage stock adjustments. Additionally, implement features to generate reports on inventory status. Part 1: Managing Inventory Items 1. **Class: `InventoryItem`** * Create a class to represent an item in the inventory. * Each item should have a name, SKU (Stock Keeping Unit), initial quantity, and price per unit. Implement methods to get item details and adjust the quantity. ```python class InventoryItem: def __init__(self, name: str, sku: str, quantity: int, price: float): Initialize an inventory item. Parameters: name (str): Name of the item. sku (str): SKU of the item. quantity (int): Initial quantity of the item. price (float): Price per unit of the item. pass # Your implementation def adjust_quantity(self, amount: int) -> None: Adjust the quantity of the item. Parameters: amount (int): Amount by which to adjust the quantity. pass # Your implementation def get_details(self) -> dict: Get the details of the inventory item. Returns: dict: Details of the item including name, SKU, current quantity, and price. pass # Your implementation ``` 2. **Class: `InventoryManager`** * Create a class to manage the inventory operations. * This class should maintain a list of `InventoryItem` objects and include methods to add items, adjust stock, and generate reports. ```python class InventoryManager: def __init__(self): Initialize the inventory manager with an empty list of items. pass # Your implementation def add_item(self, item: InventoryItem) -> None: Add an item to the inventory. Parameters: item (InventoryItem): The item to be added. pass # Your implementation def adjust_item_stock(self, sku: str, amount: int) -> None: Adjust the stock of an item based on its SKU. Parameters: sku (str): The SKU of the item. amount (int): Amount by which to adjust the stock. pass # Your implementation Part 2: Generating Reports 3. **Method: `generate_report`** * Implement a method in `InventoryManager` to generate a report of the current inventory status. * The report should include details like SKU, name, quantity, and total value (quantity * price) for each item. ```python def generate_report(self) -> None: Generate a report of the current inventory status. The report should list all items with their SKU, name, quantity, and total value. pass # Your implementation ``` Constraints & Requirements: * Ensure that the `adjust_quantity` method in `InventoryItem` class does not allow negative quantities. * SKU values should be unique for each item. * The `generate_report` method should neatly format the report, making it easy to read. * Handle edge cases such as adjusting stock for non-existent SKUs or invalid quantity adjustments gracefully. Example: ```python item1 = InventoryItem(\\"Laptop\\", \\"SKU123\\", 10, 999.99) item2 = InventoryItem(\\"Mouse\\", \\"SKU456\\", 50, 19.99) manager = InventoryManager() manager.add_item(item1) manager.add_item(item2) manager.adjust_item_stock(\\"SKU123\\", -2) manager.adjust_item_stock(\\"SKU456\\", 5) print(item1.get_details()) # Output: {\'name\': \'Laptop\', \'sku\': \'SKU123\', \'quantity\': 8, \'price\': 999.99} print(item2.get_details()) # Output: {\'name\': \'Mouse\', \'sku\': \'SKU456\', \'quantity\': 55, \'price\': 19.99} manager.generate_report() # Example Report: # SKU Name Quantity Total Value # SKU123 Laptop 8 7999.92 # SKU456 Mouse 55 1099.45 ``` Ensure your implementation covers all specified functionalities, handles errors gracefully, and generates clear and accurate reports.","solution":"class InventoryItem: def __init__(self, name: str, sku: str, quantity: int, price: float): Initialize an inventory item. Parameters: name (str): Name of the item. sku (str): SKU of the item. quantity (int): Initial quantity of the item. price (float): Price per unit of the item. self.name = name self.sku = sku self.quantity = max(0, quantity) self.price = price def adjust_quantity(self, amount: int) -> None: Adjust the quantity of the item. Parameters: amount (int): Amount by which to adjust the quantity. self.quantity = max(0, self.quantity + amount) def get_details(self) -> dict: Get the details of the inventory item. Returns: dict: Details of the item including name, SKU, current quantity, and price. return { \'name\': self.name, \'sku\': self.sku, \'quantity\': self.quantity, \'price\': self.price } class InventoryManager: def __init__(self): Initialize the inventory manager with an empty list of items. self.items = {} def add_item(self, item: InventoryItem) -> None: Add an item to the inventory. Parameters: item (InventoryItem): The item to be added. if item.sku in self.items: raise ValueError(\\"SKU already exists in inventory\\") self.items[item.sku] = item def adjust_item_stock(self, sku: str, amount: int) -> None: Adjust the stock of an item based on its SKU. Parameters: sku (str): The SKU of the item. amount (int): Amount by which to adjust the stock. if sku not in self.items: raise ValueError(\\"Item with the given SKU does not exist\\") self.items[sku].adjust_quantity(amount) def generate_report(self) -> None: Generate a report of the current inventory status. The report should list all items with their SKU, name, quantity, and total value. print(\\"SKU Name Quantity Total Value\\") for item in self.items.values(): total_value = item.quantity * item.price print(f\\"{item.sku} {item.name} {item.quantity} {total_value:.2f}\\")"},{"question":"# Question: Peak Element in an Array Context You are given an array of integers. Your task is to find a peak element in the array. A peak element is an element that is greater than its neighbors. For the elements at the boundaries of the array, we can only consider one neighbor. Function Definition Complete the function `find_peak_element` that accepts one parameter: - `arr` (List[int]): a list of integers. The function should return the index of any one peak element if multiple peak elements exist. You can assume that the array contains at least one peak element. Example ```python def find_peak_element(arr: List[int]) -> int: Returns the index of any one peak element in the array. >>> find_peak_element([1, 2, 3, 1]) 2 >>> find_peak_element([1, 2, 1, 3, 5, 6, 4]) 5 >>> find_peak_element([10]) 0 >>> find_peak_element([2, 1]) 0 # Your implementation here # Example usage result = find_peak_element([1, 2, 3, 1]) print(result) # Output can be 2 ``` Constraints: - The input array length is between 1 and 10^6. - Perform the operation in O(log n) time complexity if possible. Use binary search if applicable. - If the array contains multiple peak elements, any peak element\'s index can be returned. By following these guidelines, your new question provides a different scenario while aligning with the complexity, length, and cognitive challenges presented in the existing set of questions.","solution":"def find_peak_element(arr): Returns the index of any one peak element in the array. >>> find_peak_element([1, 2, 3, 1]) 2 >>> find_peak_element([1, 2, 1, 3, 5, 6, 4]) 1 or 5 >>> find_peak_element([10]) 0 >>> find_peak_element([2, 1]) 0 start = 0 end = len(arr) - 1 while start < end: mid = (start + end) // 2 if arr[mid] > arr[mid + 1]: end = mid else: start = mid + 1 return start"},{"question":"# Coding Assessment Question Scenario: You\'re developing a tool for managing event schedules. Each event has a specific start and end time represented in 24-hour notation. Your task is to design a function that takes a list of events and determines if any of them overlap. Task: Write a function `check_event_overlap(events: List[Tuple[str, str]]) -> bool` that checks if any two events overlap based on their start and end times. If any two events overlap, the function should return `True`; otherwise, it should return `False`. Input: 1. `events`: A list of tuples, each containing two strings representing the start time and end time of an event (formatted as \\"HH:MM\\" in 24-hour notation). Output: - A boolean indicating whether any two events overlap. Constraints: - The input list can have anywhere between 1 and 1000 events. - Start and end times are formatted correctly as \\"HH:MM\\". - Each event\'s start time is strictly less than its end time. Example: ```python events = [ (\\"09:00\\", \\"10:00\\"), (\\"10:30\\", \\"11:30\\"), (\\"10:00\\", \\"11:00\\") ] print(check_event_overlap(events)) # Output: True events = [ (\\"09:00\\", \\"10:00\\"), (\\"10:00\\", \\"11:00\\"), (\\"11:00\\", \\"12:00\\") ] print(check_event_overlap(events)) # Output: False ``` # Performance Requirements: - The algorithm should handle up to 1000 events efficiently. - Aim for a time complexity of O(n log n), where n is the number of events. Note: - Ensure to handle edge cases where there is only one event, or events are back to back without any gaps or overlaps.","solution":"from typing import List, Tuple def check_event_overlap(events: List[Tuple[str, str]]) -> bool: Checks if any two events overlap based on their start and end times. :param events: List of tuples with each containing start and end time of an event (\\"HH:MM\\") :return: True if any two events overlap, False otherwise # Convert time \\"HH:MM\\" to minutes def to_minutes(time: str) -> int: hours, minutes = map(int, time.split(\':\')) return hours * 60 + minutes # Sort events based on start time events.sort(key=lambda x: to_minutes(x[0])) for i in range(len(events) - 1): # End time of the current event end_current = to_minutes(events[i][1]) # Start time of the next event start_next = to_minutes(events[i + 1][0]) # If end time of current event is greater than start time of next event, they overlap if end_current > start_next: return True return False"},{"question":"You are given an array of integers representing a city\'s temperature over several days. The city\'s meteorological department wants to find out the number of days until a warmer temperature occurs for each day. If there is no future day with a warmer temperature, record 0 for that day. This problem can be optimized using the stack data structure. **Task**: For each day in the temperature array, calculate the number of days until a warmer temperature. If no warmer temperature exists in the future, return 0 for that day. **Function Signature**: ```python def daily_temperatures(T: List[int]) -> List[int]: Args: T : List[int] : A list of integers where each integer represents the temperature of a day. Returns: List[int] : List of integers where each integer represents the number of days until a warmer temperature. ``` # Input * List `T` of integers representing temperatures (`30 ≤ T[i] ≤ 100` for each `T[i]`). # Output * List of integers where each integer represents the number of days until a warmer temperature for the respective day in input list `T`. # Example ```python T = [73, 74, 75, 71, 69, 72, 76, 73] print(daily_temperatures(T)) # Output: [1, 1, 4, 2, 1, 1, 0, 0] ``` # Explanation - For day 0 (73°F), the next day is warmer (74°F), so 1 day. - For day 1 (74°F), the next day is warmer (75°F), so 1 day. - For day 2 (75°F), the 6th day (76°F) is warmer, so 4 days. - For day 3 (71°F), the 5th day (72°F) is warmer, so 2 days. - For day 4 (69°F), the 5th day (72°F) is warmer, so 1 day. - For day 5 (72°F), the 6th day (76°F) is warmer, so 1 day. - For day 6 (76°F), there is no future warmer day, so 0 days. - For day 7 (73°F), there is no future warmer day, so 0 days. # Constraints * Avoid exceeding time limits by implementing a solution with linear complexity, utilizing a stack-based approach.","solution":"from typing import List def daily_temperatures(T: List[int]) -> List[int]: Finds the number of days until a warmer temperature for each day in the list T. Args: T : List[int] : A list of integers where each integer represents the temperature of a day. Returns: List[int] : List of integers where each integer represents the number of days until a warmer temperature. n = len(T) result = [0] * n stack = [] for i in range(n): while stack and T[i] > T[stack[-1]]: prev_day = stack.pop() result[prev_day] = i - prev_day stack.append(i) return result"},{"question":"# Designing a Basic File System Interface Context You are tasked with implementing a basic in-memory file system interface that allows users to create, read, write, and delete files and directories. The system should maintain a hierarchical structure where directories can contain files as well as other directories, similar to a real-world file system. Problem Statement Implement a class `FileSystem` that provides methods to manipulate files and directories. Your implementation should support the following operations: 1. `create_directory(path: str) -> None`: Creates a directory at the specified path. 2. `create_file(path: str, content: str) -> None`: Creates a file at the specified path with the given content. If the file already exists, overwrite its content. 3. `read_file(path: str) -> str`: Reads the content of the file located at the specified path. 4. `delete(path: str) -> None`: Deletes the file or directory at the specified path. Deleting a directory should also delete all its contents (both files and directories). Requirements 1. **Input and Output Formats**: - `create_directory(path: str)`: Path is a string indicating the location where the directory should be created. The path is formatted as `\\"/dir1/dir2/dir3\\"`. - `create_file(path: str, content: str)`: Path is a string indicating the location where the file should be created. Content is the string to be written to the file. - `read_file(path: str)`: Path is a string indicating the location of the file to be read. Returns the file content as a string. - `delete(path: str)`: Path is a string indicating the location of the file or directory to be deleted. 2. **Constraints**: - Paths will always be absolute, starting with `/`. - Directory paths will not end with `/`. - Assume all paths provided are valid and well-formed. - File content strings have a maximum length of 10^6 characters. - There will be a maximum of 10^4 operations. 3. **Performance**: - Ensure efficient file and directory operations, focusing on both time complexity and memory usage. Example ```python class FileSystem: def __init__(self): # Implement this constructor pass def create_directory(self, path: str) -> None: # Implement this method pass def create_file(self, path: str, content: str) -> None: # Implement this method pass def read_file(self, path: str) -> str: # Implement this method pass def delete(self, path: str) -> None: # Implement this method pass # Example usage: fs = FileSystem() fs.create_directory(\\"/a/b\\") fs.create_file(\\"/a/b/file.txt\\", \\"hello world\\") print(fs.read_file(\\"/a/b/file.txt\\")) # Expected output: \\"hello world\\" fs.delete(\\"/a/b/file.txt\\") # Attempting to read the file after deletion can raise an exception or return an empty string depending on your implementation. fs.create_file(\\"/a/b/file.txt\\", \\"new content\\") print(fs.read_file(\\"/a/b/file.txt\\")) # Expected output: \\"new content\\" ``` Notes - Ensure your implementation handles nested directories correctly. - Pay attention to edge cases such as creating a file in a non-existent directory. - The deletion of directories should be recursive, ensuring all nested files and directories are deleted.","solution":"class FileSystem: def __init__(self): self.fs = {} def _get_target(self, path): components = path.strip(\'/\').split(\'/\') cur = self.fs for comp in components[:-1]: if comp not in cur: cur[comp] = {} cur = cur[comp] return cur, components[-1] def create_directory(self, path: str) -> None: target, dir_name = self._get_target(path) if dir_name not in target: target[dir_name] = {} def create_file(self, path: str, content: str) -> None: target, file_name = self._get_target(path) target[file_name] = content def read_file(self, path: str) -> str: target, file_name = self._get_target(path) return target[file_name] def delete(self, path: str) -> None: target, name = self._get_target(path) del target[name]"},{"question":"# Prime Factors of a Number Problem Statement: Write a function `find_prime_factors` that returns a list of prime factors of a given integer `n`. Prime factors of a number are the prime numbers that divide the number exactly without leaving a remainder. Ensure to list each prime factor the number of times it divides `n`. Input: - An integer `n` (2 ≤ n ≤ 10^6), representing the number to find prime factors for. Output: - A list of integers representing the prime factors of `n` in ascending order. Constraints: - The input `n` will always be greater than 1. - The solution should be efficient in terms of both time and space complexity. Example: **Input:** ```python 60 ``` **Output:** ```python [2, 2, 3, 5] ``` Notes: - For the number `60`, the prime factors are `2, 2, 3,` and `5` because (60 = 2 times 2 times 3 times 5). - Ensure to handle large values of `n` and optimize the algorithm for efficiency.","solution":"def find_prime_factors(n): Returns a list of prime factors of the given integer n. Parameters: n (int): the integer to find prime factors for Returns: List[int]: list of prime factors of n in ascending order prime_factors = [] # Divide n by 2 until it is odd while n % 2 == 0: prime_factors.append(2) n = n // 2 # n must be odd at this point, starts with the smallest possible odd prime factor, i = 3 for i in range(3, int(n**0.5)+1, 2): while n % i == 0: prime_factors.append(i) n = n // i # If n is a prime number greater than 2 if n > 2: prime_factors.append(n) return prime_factors"},{"question":"# Problem Statement Design and implement a simplified version of a file system to handle storage and retrieval of files and directories. Your file system should support the following operations: 1. **Create a file**: - Add a file with a specific name and content to a given directory. - If the directory or file already exists, raise an appropriate exception. 2. **Create a directory**: - Add a new directory under a given path. - If the path or directory already exists, raise an appropriate exception. 3. **List contents**: - List all the files and directories within a given directory. 4. **Read a file**: - Retrieve the content of a file given its path. - If the file does not exist, raise an appropriate exception. Each file or directory path should be represented as a string, following a Unix-like format (e.g., `/home/user/docs`). # Method Signatures ```python class SimpleFileSystem: def __init__(self): Initialize an empty file system. pass def create_file(self, path: str, content: str) -> None: Create a file with the specified content at the given path. Args: - path (str): The path where the file should be created. - content (str): The content to be stored in the file. Raises: - Exception: If the file or directory already exists. pass def create_directory(self, path: str) -> None: Create a new directory at the specified path. Args: - path (str): The path where the directory should be created. Raises: - Exception: If the directory or any part of the path already exists. pass def list_contents(self, path: str) -> list[str]: List all files and directories in the provided directory. Args: - path (str): The path of the directory to list. Returns: - list[str]: A list of names of files and directories in the given directory. Raises: - Exception: If the directory does not exist. pass def read_file(self, path: str) -> str: Retrieve the content of the file at the given path. Args: - path (str): The path of the file to read. Returns: - str: The content of the file. Raises: - Exception: If the file does not exist. pass ``` # Constraints - All directory and file names consist only of alphanumeric characters and forward slashes (/). - The root directory is denoted by the single slash character (`/`). - Paths are always absolute, starting with the root `/`. - Paths do not have trailing slashes. - Each directory along the path must exist to create a new file or directory inside it. # Example Usage ```python # Initialize an empty file system fs = SimpleFileSystem() # Create directories fs.create_directory(\'/home\') fs.create_directory(\'/home/user\') fs.create_directory(\'/home/user/docs\') # Create a file fs.create_file(\'/home/user/docs/file1.txt\', \'This is the content of file1.\') # List contents of a directory print(fs.list_contents(\'/home/user\')) # Output: [\'docs\'] # List contents of another directory print(fs.list_contents(\'/home/user/docs\')) # Output: [\'file1.txt\'] # Read a file content = fs.read_file(\'/home/user/docs/file1.txt\') print(content) # Output: \'This is the content of file1.\' ``` **Your task is to complete the implementation of the `SimpleFileSystem` class as specified above. Ensure to handle all edge cases and raise appropriate exceptions where necessary.**","solution":"class SimpleFileSystem: class File: def __init__(self, name, content): self.name = name self.content = content class Directory: def __init__(self, name): self.name = name self.contents = {} def __init__(self): self.root = self.Directory(\\"/\\") def _get_directory(self, path): if path == \\"/\\": return self.root parts = path.strip(\\"/\\").split(\\"/\\") curr = self.root for part in parts: if part not in curr.contents or not isinstance(curr.contents[part], SimpleFileSystem.Directory): raise Exception(\\"Directory does not exist\\") curr = curr.contents[part] return curr def _get_parent_directory_and_name(self, path): parts = path.strip(\\"/\\").split(\\"/\\") name = parts.pop() parent_path = \\"/\\" + \\"/\\".join(parts) parent = self._get_directory(parent_path) return parent, name def create_file(self, path: str, content: str) -> None: parent, name = self._get_parent_directory_and_name(path) if name in parent.contents: raise Exception(\\"File or directory already exists\\") parent.contents[name] = self.File(name, content) def create_directory(self, path: str) -> None: parent, name = self._get_parent_directory_and_name(path) if name in parent.contents: raise Exception(\\"Directory or file already exists\\") parent.contents[name] = self.Directory(name) def list_contents(self, path: str) -> list: directory = self._get_directory(path) return list(directory.contents.keys()) def read_file(self, path: str) -> str: parent, name = self._get_parent_directory_and_name(path) if name not in parent.contents or not isinstance(parent.contents[name], SimpleFileSystem.File): raise Exception(\\"File does not exist\\") return parent.contents[name].content"},{"question":"# Problem Statement: You are tasked with extending the functionality of a library management system with advanced features. Your goal is to implement and enhance several components to ensure efficient library operations. # Requirements: 1. **Member Class:** - Create a `Member` class to store member information with attributes: `member_id`, `name`, `email`, and `borrowed_books` (a list of book IDs). - Include methods to add or remove borrowed books from a member\'s record. 2. **Book Class:** - Implement a `Book` class to track book details with attributes: `book_id`, `title`, `author`, `genre`, and `is_borrowed`. - Provide methods to mark a book as borrowed or returned. 3. **Library Class:** - Develop a `Library` class to manage members and books. - Methods: - `add_member(member: Member) -> None`: Registers a new member. - `add_book(book: Book) -> None`: Adds a new book to the library collection. - `borrow_book(member_id: int, book_id: int) -> bool`: Allows a member to borrow a book if available. - `return_book(member_id: int, book_id: int) -> bool`: Facilitates returning a borrowed book. - `search_books_by_author(author: str) -> List[Book]`: Searches books by the given author. 4. **Exception Handling:** - Implement robust exception handling in your `Library` class methods to manage errors like invalid member IDs, invalid book IDs, trying to borrow an already borrowed book, etc. 5. **Performance Logging:** - Add functionality to log key metrics such as the number of books borrowed, number of books returned, total number of members, and total number of books available. # Input/Output Formats: * **Input:** - Member and book data for `Library` operations. - Requests to borrow or return books. * **Output:** - Member and book data after operations. - Log of performance metrics. # Constraints: - Each book_id and member_id is unique. - The library can hold a maximum of 10,000 books and 1,000 members. - Each member can borrow a maximum of 5 books at a time. # Sample Usage: ```python # Initialize Library instance library = Library() # Add Members member_1 = Member(1, \\"Alice\\", \\"alice@example.com\\", []) member_2 = Member(2, \\"Bob\\", \\"bob@example.com\\", []) library.add_member(member_1) library.add_member(member_2) # Add Books book_1 = Book(101, \\"Title A\\", \\"Author X\\", \\"Fiction\\", False) book_2 = Book(102, \\"Title B\\", \\"Author Y\\", \\"Non-Fiction\\", False) library.add_book(book_1) library.add_book(book_2) # Borrow and Return Books library.borrow_book(1, 101) library.return_book(1, 101) # Search Books books_by_author_x = library.search_books_by_author(\\"Author X\\") for book in books_by_author_x: print(f\\"{book.title} by {book.author}\\") # Print performance metrics metrics = library.get_performance_metrics() print(\\"Metrics:\\", metrics) ``` **Note:** Focus on maintaining code readability, optimizing performance, and ensuring the robustness of the implemented functionality.","solution":"from typing import List class Member: def __init__(self, member_id: int, name: str, email: str): self.member_id = member_id self.name = name self.email = email self.borrowed_books = [] def add_borrowed_book(self, book_id: int): if len(self.borrowed_books) < 5: self.borrowed_books.append(book_id) else: raise Exception(\\"Member has already borrowed the maximum number of books\\") def remove_borrowed_book(self, book_id: int): if book_id in self.borrowed_books: self.borrowed_books.remove(book_id) else: raise Exception(\\"Book not found in member\'s borrowed books\\") class Book: def __init__(self, book_id: int, title: str, author: str, genre: str): self.book_id = book_id self.title = title self.author = author self.genre = genre self.is_borrowed = False def mark_as_borrowed(self): if not self.is_borrowed: self.is_borrowed = True else: raise Exception(\\"Book is already borrowed\\") def mark_as_returned(self): if self.is_borrowed: self.is_borrowed = False else: raise Exception(\\"Book is not borrowed\\") class Library: def __init__(self): self.members = {} self.books = {} self.metrics = { \\"borrowed_books_count\\": 0, \\"returned_books_count\\": 0, \\"total_members\\": 0, \\"total_books\\": 0 } def add_member(self, member: Member) -> None: if member.member_id not in self.members and self.metrics[\\"total_members\\"] < 1000: self.members[member.member_id] = member self.metrics[\\"total_members\\"] += 1 else: raise Exception(\\"Member already exists or maximum members reached\\") def add_book(self, book: Book) -> None: if book.book_id not in self.books and self.metrics[\\"total_books\\"] < 10000: self.books[book.book_id] = book self.metrics[\\"total_books\\"] += 1 else: raise Exception(\\"Book already exists or maximum books reached\\") def borrow_book(self, member_id: int, book_id: int) -> bool: if member_id in self.members and book_id in self.books: member = self.members[member_id] book = self.books[book_id] if not book.is_borrowed and len(member.borrowed_books) < 5: member.add_borrowed_book(book_id) book.mark_as_borrowed() self.metrics[\\"borrowed_books_count\\"] += 1 return True else: raise Exception(\\"Book already borrowed or member has max borrowed books\\") else: raise Exception(\\"Invalid member ID or book ID\\") def return_book(self, member_id: int, book_id: int) -> bool: if member_id in self.members and book_id in self.books: member = self.members[member_id] book = self.books[book_id] if book.is_borrowed and book_id in member.borrowed_books: member.remove_borrowed_book(book_id) book.mark_as_returned() self.metrics[\\"returned_books_count\\"] += 1 return True else: raise Exception(\\"Book not borrowed or invalid return attempt\\") else: raise Exception(\\"Invalid member ID or book ID\\") def search_books_by_author(self, author: str) -> List[Book]: return [book for book in self.books.values() if book.author == author] def get_performance_metrics(self): return self.metrics"},{"question":"# Interactive Voice Response (IVR) System Design Background You are developing a basic Interactive Voice Response (IVR) system for a telecom company where customers can navigate through a menu to access different services. The IVR system uses a hierarchical approach where each menu can have several submenus, and each submenu can contain actions that need to be performed, such as connecting to a representative or listening to information. Task Implement the `navigate` method in a provided `MenuItem` interface that defines the structure of each menu and its submenus. Your task is to manage the state of the IVR system as users navigate through the menus and perform specified actions at any given menu level. Requirements - Implement the `navigate` method in a class, `Menu`, that conforms to the `MenuItem` interface. - The `navigate` method should allow traversal from one menu level to a submenu based on user input. - Handle the actions for both accessing a submenu and performing terminal operations (e.g., listen to an information message or connect to a representative). Menu Description Each menu is described by its name, a dictionary of submenus, and functions to be performed when certain selections are made: ```python class MenuItem: def navigate(self, choice: str) -> \'MenuItem\': pass class Menu(MenuItem): def __init__(self, name: str): self.name = name self.submenus = {} self.actions = {} def navigate(self, choice: str) -> \'MenuItem\': # Implement this method pass def add_submenu(self, choice: str, submenu: \'Menu\'): self.submenus[choice] = submenu def add_action(self, choice: str, action: callable): self.actions[choice] = action ``` Input - Each menu and submenu is navigated by a string input that corresponds to a choice. - The `navigate` method may be called repeatedly as users traverse through the menu system. Output - The next `MenuItem` to navigate to or perform the specified action associated with the choice. Example Usage ```python def connect_to_representative(): print(\\"Connecting to a representative...\\") def play_information(): print(\\"Playing information...\\") # Define the main menu and submenus main_menu = Menu(\\"Main Menu\\") billing_menu = Menu(\\"Billing Menu\\") technical_support_menu = Menu(\\"Technical Support Menu\\") # Add submenus and actions to the main menu main_menu.add_submenu(\\"1\\", billing_menu) main_menu.add_submenu(\\"2\\", technical_support_menu) main_menu.add_action(\\"0\\", connect_to_representative) # Add actions to billing menu billing_menu.add_action(\\"1\\", play_information) # Navigate through the menus current_menu = main_menu while True: choice = input(f\\"Current Menu: {current_menu.name}nEnter your choice: \\") if choice in current_menu.actions: current_menu.actions[choice]() break elif choice in current_menu.submenus: current_menu = current_menu.submenus[choice] else: print(\\"Invalid choice, please try again.\\") ``` Constraints - Ensure that the system can handle invalid entries and guide the user appropriately. - Gracefully handle case-insensitivity and trimming of extra white spaces in user input selections. Good luck!","solution":"class MenuItem: def navigate(self, choice: str) -> \'MenuItem\': pass class Menu(MenuItem): def __init__(self, name: str): self.name = name self.submenus = {} self.actions = {} def navigate(self, choice: str) -> \'MenuItem\': choice = choice.strip().lower() if choice in self.actions: self.actions[choice]() return self elif choice in self.submenus: return self.submenus[choice] else: print(\\"Invalid choice, please try again.\\") return self def add_submenu(self, choice: str, submenu: \'Menu\'): self.submenus[choice.strip().lower()] = submenu def add_action(self, choice: str, action: callable): self.actions[choice.strip().lower()] = action def connect_to_representative(): print(\\"Connecting to a representative...\\") def play_information(): print(\\"Playing information...\\")"},{"question":"# Maximal Square Area in a Matrix Problem You are given a matrix of \'0\'s and \'1\'s stored in a text file. The task is to find the area of the largest square containing only \'1\'s and return its area. Function Signature ```python def maximal_square_area(filename: str) -> int: Returns the area of the largest square containing only \'1\'s in the matrix from the file. Parameters: filename (str): the name of the file containing the matrix Returns: int: the area of the largest square containing only \'1\'s ``` Input * The filename of the text file containing an n x m matrix of characters \'0\' and \'1\'. Each character is separated by a comma (`,`). Output * An integer representing the area of the largest square containing only \'1\'s. Constraints * The matrix will be a non-empty rectangular matrix (n >= 1, m >= 1). * Each cell will contain either \'0\' or \'1\'. Example Given the following matrix in a file `binary_matrix.txt`: ``` 1,0,1,0,0 1,0,1,1,1 1,1,1,1,1 1,0,0,1,0 ``` Calling `maximal_square_area(\\"binary_matrix.txt\\")` should return `4`. Requirements * The function should handle possible edge cases like an empty file or malformed input gracefully. * Your implementation should be efficient, ideally with a time complexity of O(n * m). --- This question adheres to the style, length, difficulty level, topic alignment, and uniqueness required, integrating seamlessly with your provided set of questions.","solution":"def maximal_square_area(filename: str) -> int: Returns the area of the largest square containing only \'1\'s in the matrix from the file. with open(filename, \'r\') as file: # Read the file contents matrix = [] for line in file: matrix.append([int(x) for x in line.strip().split(\',\')]) if not matrix: return 0 n = len(matrix) m = len(matrix[0]) dp = [[0] * m for _ in range(n)] max_side = 0 for i in range(n): for j in range(m): if matrix[i][j] == 1: if i == 0 or j == 0: dp[i][j] = 1 else: dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1 max_side = max(max_side, dp[i][j]) return max_side * max_side"},{"question":"# Problem Statement You are tasked with implementing a function that validates a given string to determine if it is a correctly formatted vehicle registration plate number following the German system. # Function Signature ```python def is_german_plate(input_str: str) -> bool: pass ``` # Input - `input_str` (str): The string representing the vehicle registration plate number to be validated. # Output - `bool`: Return `True` if the input is a valid German vehicle registration plate number, `False` otherwise. # Constraints 1. `input_str` length is between 1 and 20 characters. 2. A valid registration plate number must follow these rules: - Start with 1 to 3 uppercase letters denoting the city (e.g., \\"B\\", \\"F\\", \\"M\\", \\"KAR\\", etc.) - Followed by 1 or 2 uppercase letters. - End with 1 to 4 numeric digits. - May optionally have a space or hyphen separating the sections. - Must not contain any special characters except space or hyphen. # Requirements - Your function should return `True` or `False` based on the validation checks. - Handle invalid input types by raising appropriate exceptions. - Execution time and space should be efficient, given that valid registration plate numbers have a practical constraint on length and characters. # Examples ```python # Valid German vehicle registration plate numbers print(is_german_plate(\\"B MW 1234\\")) # Output: True print(is_german_plate(\\"F-AZ 987\\")) # Output: True print(is_german_plate(\\"M 12345\\")) # Output: False (Too many digits) print(is_german_plate(\\"KAR-KA53\\")) # Output: True print(is_german_plate(\\"D 123A\\")) # Output: False (Contains an invalid character at the end) # Invalid input format try: is_german_plate(12345) except ValueError as e: print(e) # Output: \\"Expected str as input, found <class \'int\'>\\" # Invalid format with special characters try: is_german_plate(\\"BMW#1234\\") except ValueError as e: print(e) # Output: \\"Plate number contains invalid characters\\" ``` # Evaluation Criteria - Correctness: The function should correctly validate German vehicle registration plate numbers and return accurate results. - Efficiency: The function should run in polynomial time based on the input length. - Robustness: The function must handle various invalid inputs gracefully by raising appropriate exceptions.","solution":"import re def is_german_plate(input_str: str) -> bool: Validates if the input string is a correctly formatted German vehicle registration plate number. Parameters: input_str (str): The string representing the vehicle registration plate number to be validated. Returns: bool: True if the input is a valid German vehicle registration plate number, False otherwise. if not isinstance(input_str, str): raise ValueError(f\\"Expected str as input, found {type(input_str)}\\") # Define the regex pattern for a valid German vehicle registration plate number pattern = r\'^[A-Z]{1,3}[-s]?[A-Z]{1,2}[-s]?[0-9]{1,4}\' # Check if the input string matches the pattern match = re.match(pattern, input_str) return match is not None"},{"question":"Problem Statement: Create a function called `build_pyramid` that generates a pyramid pattern with a given number of levels. Each level of the pyramid contains the level number printed consecutively, with each level centered compared to the widest point of the pyramid. Do not use any built-in functions for string formatting or alignment. # Expected Function Signature: ```python from typing import List def build_pyramid(levels: int) -> List[str]: pass ``` # Input: * `levels` (int): An integer representing the number of levels in the pyramid. The levels are numbered starting from 1. # Output: * Returns a list of strings, where each string represents a level of the pyramid, centered according to the widest point. # Constraints: * `1 <= levels <= 100` # Examples: * `build_pyramid(1)` should return `[\\"1\\"]` * `build_pyramid(2)` should return `[\\" 1 \\", \\"222\\"]` * `build_pyramid(3)` should return `[\\" 1 \\", \\" 222 \\", \\"33333\\"]` * `build_pyramid(5)` should return `[ \\" 1 \\", \\" 222 \\", \\" 33333 \\", \\" 4444444 \\", \\"555555555\\" ]` # Notes: 1. Each level `i` (starting from 1) contains the integer `i` repeated `2*i - 1` times. 2. The width of the widest level is equal to `2*levels - 1`. 3. Center each level by adding appropriate spaces to both sides so that the widest level is properly justified. 4. Ensure different edge cases are handled, such as the smallest and largest possible values of `levels`. 5. Avoid using any built-in Python string formatting or centering functions such as `str.center()`. Instead, manually calculate the required spaces for alignment.","solution":"from typing import List def build_pyramid(levels: int) -> List[str]: result = [] max_width = 2 * levels - 1 for i in range(1, levels + 1): level = str(i) * (2 * i - 1) spaces = (max_width - len(level)) // 2 result.append(\\" \\" * spaces + level + \\" \\" * spaces) return result"},{"question":"# Sum of Squares In mathematics, the sum of squares is a simple yet significant concept. The sum of the squares of the first ( n ) natural numbers is given by the formula: [ text{Sum of Squares} = 1^2 + 2^2 + 3^2 + ldots + n^2 ] Your task is to implement a function `sum_of_squares(n: int) -> int` that calculates the sum of squares of the first ( n ) natural numbers. # Input * `n` (int): The number of natural numbers to sum. ( n ) must be a non-negative integer. # Output * Returns the sum of squares of the first ( n ) natural numbers (int). # Constraints 1. If ( n ) is negative, raise a `ValueError` with the message: \\"The input must be a non-negative integer\\". 2. The returned value should be an integer. # Examples ```python >>> sum_of_squares(5) 55 >>> sum_of_squares(0) 0 >>> sum_of_squares(1) 1 >>> sum_of_squares(10) 385 >>> sum_of_squares(-3) ValueError: The input must be a non-negative integer >>> sum_of_squares(12) 650 ``` # Additional Information - Ensure your code handles edge cases appropriately and raises errors for invalid input.","solution":"def sum_of_squares(n: int) -> int: Calculates the sum of squares of the first n natural numbers. Parameters: n (int): The number of natural numbers to sum. Must be a non-negative integer. Returns: int: The sum of squares of the first n natural numbers. if n < 0: raise ValueError(\\"The input must be a non-negative integer\\") return sum(i**2 for i in range(1, n + 1))"},{"question":"# Problem Statement You are tasked with designing and implementing an `AutocompleteSystem` that provides autocomplete suggestions based on a given prefix. The `AutocompleteSystem` should maintain a dictionary of words with their corresponding frequencies and return suggestions in the order of their frequency, with the most frequent words appearing first. # Requirements: 1. **Add Word**: - Implement a method to add a word to the dictionary with its frequency. If the word already exists, update its frequency. 2. **Get Suggestions**: - Implement a method to return up to `k` suggestions for a given prefix. The suggestions should be ordered by their frequency. If two words have the same frequency, order them lexicographically. # Method Signatures ```python class AutocompleteSystem: def __init__(self): Initialize the AutocompleteSystem with an empty dictionary. pass def add_word(self, word: str, frequency: int) -> None: Add a word to the dictionary with the given frequency. If the word already exists, update its frequency. Args: - word (str): The word to add to the dictionary. - frequency (int): The frequency of the word. pass def get_suggestions(self, prefix: str, k: int) -> list[str]: Get up to k suggestions for the given prefix ordered by frequency. If two words have the same frequency, order them lexicographically. Args: - prefix (str): The prefix to autocomplete. - k (int): The maximum number of suggestions to return. Returns: - list[str]: A list of up to k autocomplete suggestions. pass ``` # Constraints - All input words consist of lowercase English letters. - The frequency of each word is a positive integer. - The number of words in the dictionary does not exceed 10^5. - The length of each word and prefix does not exceed 100. - The `get_suggestions` method will be called frequently and should be optimized for performance. # Example Usage ```python # Initialize the Autocomplete System auto_complete = AutocompleteSystem() # Add words to the dictionary with their frequencies auto_complete.add_word(\\"apple\\", 5) auto_complete.add_word(\\"app\\", 3) auto_complete.add_word(\\"application\\", 4) auto_complete.add_word(\\"appetizer\\", 3) # Get autocomplete suggestions for the prefix \'app\' suggestions = auto_complete.get_suggestions(\\"app\\", 3) print(suggestions) # [\\"apple\\", \\"application\\", \\"appetizer\\"] or [\\"apple\\", \\"application\\", \\"app\\"] depending on if “app” and “appetizer” have same frequency # Add more words to update frequencies auto_complete.add_word(\\"apply\\", 2) # Get autocomplete suggestions for the prefix \'app\' suggestions = auto_complete.get_suggestions(\\"app\\", 4) print(suggestions) # [\\"apple\\", \\"application\\", \\"appetizer\\", \\"apply\\"] ``` **Complete the implementation of the `AutocompleteSystem` class as specified above. Ensure the suggestions are sorted by frequency and lexicographically when frequencies are tied.**","solution":"class AutocompleteSystem: def __init__(self): Initialize the AutocompleteSystem with an empty dictionary. self.word_freq = {} def add_word(self, word: str, frequency: int) -> None: Add a word to the dictionary with the given frequency. If the word already exists, update its frequency. Args: - word (str): The word to add to the dictionary. - frequency (int): The frequency of the word. if word in self.word_freq: self.word_freq[word] += frequency else: self.word_freq[word] = frequency def get_suggestions(self, prefix: str, k: int) -> list: Get up to k suggestions for the given prefix ordered by frequency. If two words have the same frequency, order them lexicographically. Args: - prefix (str): The prefix to autocomplete. - k (int): The maximum number of suggestions to return. Returns: - list: A list of up to k autocomplete suggestions. suggestions = [word for word in self.word_freq if word.startswith(prefix)] sorted_suggestions = sorted(suggestions, key=lambda x: (-self.word_freq[x], x)) return sorted_suggestions[:k]"},{"question":"# Coding Assessment Question You are given a list of stock prices where the index in the list signifies the day of the stock price. For example, the price at index 0 is the stock price on day 0. Your task is to simulate a single buy and sell to maximize profit. # Task Write a Python function that performs the following: 1. Reads in a list of stock prices where each element represents the stock price on a given day. 2. Finds the maximum profit possible by buying on one day and selling on another later day. 3. Returns a tuple containing the maximum profit, the day to buy (index), and the day to sell (index). # Requirements 1. **Input**: A list of integers or floating-point numbers representing stock prices. 2. **Output**: A tuple (max_profit, buy_day, sell_day). If no profit is possible, return (0, -1, -1). 3. **Constraints**: * The list input can have up to 100,000 elements. * The input list can be empty or have fewer than 2 elements. In such cases, the function should return (0, -1, -1). # Performance * The function must be efficient in handling larger lists, with considerations for both time and space complexity. Examples: ```python # Example 1: prices = [7, 1, 5, 3, 6, 4] max_profit(prices) # Output: (5, 1, 4) # Example 2: prices = [7, 6, 4, 3, 1] max_profit(prices) # Output: (0, -1, -1) # Example 3: prices = [] max_profit(prices) # Output: (0, -1, -1) ``` # Solution Template ```python def max_profit(prices): if len(prices) < 2: return (0, -1, -1) min_price = prices[0] min_day = 0 max_profit = 0 buy_day = -1 sell_day = -1 for i in range(1, len(prices)): if prices[i] - min_price > max_profit: max_profit = prices[i] - min_price buy_day = min_day sell_day = i if prices[i] < min_price: min_price = prices[i] min_day = i if max_profit == 0: return (0, -1, -1) return (max_profit, buy_day, sell_day) ``` Adjust the solution as necessary to refine it to meet the performance and functional requirements efficiently.","solution":"def max_profit(prices): Finds the maximum profit possible by buying on one day and selling on another later day. Parameters: prices (list of int/float): A list of stock prices where each element represents the price on a given day. Returns: tuple: A tuple containing the maximum profit, the day to buy (index), and the day to sell (index). If no profit is possible, returns (0, -1, -1). if len(prices) < 2: return (0, -1, -1) min_price = prices[0] min_day = 0 max_profit = 0 buy_day = -1 sell_day = -1 for i in range(1, len(prices)): if prices[i] - min_price > max_profit: max_profit = prices[i] - min_price buy_day = min_day sell_day = i if prices[i] < min_price: min_price = prices[i] min_day = i if max_profit == 0: return (0, -1, -1) return (max_profit, buy_day, sell_day)"},{"question":"# Question: Develop an Order Fulfillment System for a Warehouse **Context**: You are building an order fulfillment system for a warehouse. The system will receive a set of orders, each consisting of items with specific quantities. The warehouse has a finite inventory with certain quantities available for each item. Your task is to create a function `process_orders` that processes a list of orders and attempts to fulfill them sequentially. If an order cannot be completely fulfilled due to insufficient inventory, that order should be skipped, and the system should move to the next order. **Function Signature**: ```python def process_orders(inventory: dict[str, int], orders: list[dict[str, int]]) -> list[bool]: pass ``` **Input**: - `inventory`: A dictionary where keys are item names (strings) and values are the available quantities (integers) of these items in the warehouse. - `orders`: A list of dictionaries, where each dictionary represents an order. The keys are item names (strings) and the values are the required quantities (integers) for that order. **Output**: - Returns a list of boolean values where each boolean corresponds to an order from the input list. `True` indicates that the order was successfully fulfilled, and `False` indicates that the order was skipped due to insufficient inventory. **Constraints**: - The inventory dictionary and orders list will contain valid item names and non-negative integer quantities. - It is guaranteed that item names will only consist of alphanumeric characters. - The order of processing the orders should be the same as their appearance in the input list. **Example**: ```python inventory = { \\"itemA\\": 10, \\"itemB\\": 5, \\"itemC\\": 7 } orders = [ {\\"itemA\\": 3, \\"itemB\\": 2}, {\\"itemA\\": 4, \\"itemC\\": 8}, {\\"itemB\\": 1, \\"itemC\\": 2} ] process_orders(inventory, orders) # Expected output: [True, False, True] # Explanation: # - The first order ({\\"itemA\\": 3, \\"itemB\\": 2}) is fulfilled. Inventory is now {\\"itemA\\": 7, \\"itemB\\": 3, \\"itemC\\": 7}. # - The second order ({\\"itemA\\": 4, \\"itemC\\": 8}) cannot be fulfilled due to insufficient \\"itemC\\". # - The third order ({\\"itemB\\": 1, \\"itemC\\": 2}) is fulfilled. Inventory is now {\\"itemA\\": 7, \\"itemB\\": 2, \\"itemC\\": 5}. ``` # Guidelines: 1. Make sure to update the inventory only when an order can be fully fulfilled. 2. Orders should be processed in the given sequence, and skipped if any item\'s required quantity cannot be met. 3. Each item\'s quantity in the inventory should be considered individually and updated after successfully fulfilling an order.","solution":"def process_orders(inventory, orders): result = [] for order in orders: can_fulfill = True # Check if the order can be fulfilled for item, qty in order.items(): if item not in inventory or inventory[item] < qty: can_fulfill = False break # Fulfill the order if possible if can_fulfill: for item, qty in order.items(): inventory[item] -= qty result.append(True) else: result.append(False) return result"},{"question":"# Problem Statement You are given an array of integers where each integer occurs an even number of times, except for one. Your task is to implement a function that finds the integer that occurs only once. # Function Signature ```python def find_unique_integer(arr: list[int]) -> int: ``` # Input - `arr`: A list of integers where each integer occurs exactly twice except for one that occurs once. The length of the list will be an odd number between 1 and 10^5. # Output - Return the integer that occurs only once in the array. # Constraints - The input list will always contain at least one integer. - The integer values can range from -10^9 to 10^9. # Example ```python assert find_unique_integer([2, 3, 5, 4, 5, 3, 4]) == 2 assert find_unique_integer([10, 14, 10]) == 14 assert find_unique_integer([1, 1, 0, -1, -1, 0, 2]) == 2 assert find_unique_integer([8, 8, 9, 10, 10]) == 9 assert find_unique_integer([1000000000, -1000000000, -1000000000]) == 1000000000 ``` # Notes 1. Consider handling edge cases where the input list contains a large number of elements. 2. Ensure that your solution is efficient in terms of time and space complexity. 3. Use appropriate data structures to make the implementation straightforward and clear.","solution":"def find_unique_integer(arr: list[int]) -> int: Finds the integer that occurs exactly once in the list. All other integers occur an even number of times. Args: arr (list): List of integers, where each integer occurs exactly twice except for one. Returns: int: The integer that occurs only once. # Using XOR operator to find the unique number unique_number = 0 for num in arr: unique_number ^= num return unique_number"},{"question":"# Problem Statement: You are required to implement a **Longest Increasing Subsequence with Binary Indexed Tree (Fenwick Tree)**. This data structure should efficiently compute the length of the longest increasing subsequence in an array of integers using the principles of a Fenwick Tree. Function Signatures: 1. `__init__(self, nums: List[int]) -> None`: Initialize the object with the given list of integers. 2. `length_of_lis(self) -> int`: Return the length of the longest increasing subsequence in the array. Constraints: - The length of the array `N` will be between `1` and `10^5`. - The value of each element `nums[i]` will be between `1` and `10^5`. Example: ```python >>> lis = LongestIncreasingSubsequence([10, 9, 2, 5, 3, 7, 101, 18]) >>> lis.length_of_lis() 4 >>> lis = LongestIncreasingSubsequence([0, 1, 0, 3, 2, 3]) >>> lis.length_of_lis() 4 >>> lis = LongestIncreasingSubsequence([7, 7, 7, 7, 7, 7, 7]) >>> lis.length_of_lis() 1 ``` # Implementation: You are required to implement the `LongestIncreasingSubsequence` class to meet the given specifications. Use a Fenwick Tree to keep track of the lengths of increasing subsequences efficiently. Make sure to handle the edge cases and ensure the scalability of your implementation.","solution":"from bisect import bisect_left from typing import List class FenwickTree: def __init__(self, size): self.size = size self.tree = [0] * (size + 1) def update(self, index, value): while index <= self.size: self.tree[index] = max(self.tree[index], value) index += index & -index def query(self, index): max_value = 0 while index > 0: max_value = max(max_value, self.tree[index]) index -= index & -index return max_value class LongestIncreasingSubsequence: def __init__(self, nums: List[int]) -> None: self.nums = nums def length_of_lis(self) -> int: if not self.nums: return 0 # Discretize the values to ensure the Fenwick Tree doesn\'t needlessly become too large sorted_unique_nums = sorted(set(self.nums)) fenwick_tree = FenwickTree(len(sorted_unique_nums)) max_lis_length = 0 for num in self.nums: # Find the position of the current number in the sorted unique list pos = bisect_left(sorted_unique_nums, num) + 1 # Query the maximum LIS length up to the current number\'s position current_lis_length = fenwick_tree.query(pos - 1) # Update the Fenwick Tree with the new LIS length for this number fenwick_tree.update(pos, current_lis_length + 1) # Update the max_lis_length if necessary max_lis_length = max(max_lis_length, current_lis_length + 1) return max_lis_length"},{"question":"# Generating Permutations Recursively You are tasked with writing a function that generates all possible permutations of a given list of distinct elements. The function should use a recursive approach to generate and return all permutations in lexicographical order. Requirements - **Function Name**: `generate_permutations` - **Input**: A list of distinct integers `elements: list`. - **Output**: A list of lists containing all permutations of the input list. Constraints 1. The input list will have a length `0 <= len(elements) <= 8`. 2. The elements of the list are distinct integers and can be positive or negative. Expected Performance - Use a recursive approach to explore all permutations. - Return the permutations in lexicographical order. # Example ```python generate_permutations([1, 2]) # Output: [[1, 2], [2, 1]] generate_permutations([3, 1, 2]) # Output: [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]] generate_permutations([-1, 0, 1]) # Output: [[-1, 0, 1], [-1, 1, 0], [0, -1, 1], [0, 1, -1], [1, -1, 0], [1, 0, -1]] generate_permutations([]) # Output: [[]] ``` # Implementation Details - Use a recursive function to generate permutations. - Ensure the base case and the recursive case are properly defined. - Make sure that the function handles cases where the input list is empty. - Do not use Python\'s built-in permutation functions or libraries directly. Note Focus on understanding the concept of recursion and lexicographical order to generate the permutations correctly.","solution":"def generate_permutations(elements): Generates all permutations of a list of distinct integers in lexicographical order. :param elements: List of distinct integers. :return: List of lists containing all permutations in lexicographical order. def helper(current, remaining): if not remaining: permutations.append(current) else: for i in range(len(remaining)): helper(current + [remaining[i]], remaining[:i] + remaining[i+1:]) elements.sort() # Ensure that permutations are in lexicographical order permutations = [] helper([], elements) return permutations"},{"question":"# Problem Statement You are requested to design a simple command-line based quiz game. The quiz will contain a series of multiple-choice questions, and the player\'s score will be calculated based on correct answers. This program helps in evaluating knowledge in a fun and interactive way. # Requirements Implement a Python function `quiz_game` that operates as follows: 1. The function starts by welcoming the player and explaining the rules. 2. It presents each question to the player one by one along with the multiple-choice answers. 3. The player selects an answer by entering the corresponding option number. 4. After the player responds to all the questions, the function displays the total number of correct answers and their score. # Constraints * You should use a fixed set of at least 5 multiple-choice questions, each with 4 options where only one option is correct. * Each question and its choices should be presented in a clear and organized manner. * Assume the player will enter valid integers corresponding to the option numbers. # Input and Output Formats * **No Input**: * The function does not take any parameters directly. * **Output**: * The function should print the questions, options, and the final score in the console. # Example of Function Usage ```python def quiz_game(): # Your implementation here # Example of usage quiz_game() ``` # Notes * You may use any built-in Python libraries and modules. * Implement clear and user-friendly prompts to guide the player through the quiz game. # Example Execution Flow ```python Welcome to the Quiz Game! You will be asked 5 questions. Please enter the number corresponding to your answer. What is the capital of France? 1. Paris 2. London 3. Berlin 4. Madrid Your answer: 1 What is 2 + 2? 1. 3 2. 4 3. 5 4. 6 Your answer: 2 Which planet is known as the Red Planet? 1. Venus 2. Saturn 3. Mars 4. Jupiter Your answer: 3 ... Congratulations! You have completed the quiz. You got 4 out of 5 questions correct. Your score: 80% ```","solution":"def quiz_game(): questions = [ { \\"question\\": \\"What is the capital of France?\\", \\"choices\\": [\\"Paris\\", \\"London\\", \\"Berlin\\", \\"Madrid\\"], \\"answer\\": 1 }, { \\"question\\": \\"What is 2 + 2?\\", \\"choices\\": [\\"3\\", \\"4\\", \\"5\\", \\"6\\"], \\"answer\\": 2 }, { \\"question\\": \\"Which planet is known as the Red Planet?\\", \\"choices\\": [\\"Venus\\", \\"Saturn\\", \\"Mars\\", \\"Jupiter\\"], \\"answer\\": 3 }, { \\"question\\": \\"Who wrote \'Romeo and Juliet\'?\\", \\"choices\\": [\\"William Shakespeare\\", \\"Charles Dickens\\", \\"Jane Austen\\", \\"Mark Twain\\"], \\"answer\\": 1 }, { \\"question\\": \\"What is the freezing point of water?\\", \\"choices\\": [\\"0 degrees Celsius\\", \\"32 degrees Fahrenheit\\", \\"Both A and B\\", \\"None of the above\\"], \\"answer\\": 3 } ] correct_answers = 0 print(\\"Welcome to the Quiz Game!\\") print(\\"You will be asked 5 questions. Please enter the number corresponding to your answer.\\") for i, q in enumerate(questions): print(f\\"nQuestion {i + 1}: {q[\'question\']}\\") for idx, choice in enumerate(q[\\"choices\\"], 1): print(f\\"{idx}. {choice}\\") answer = int(input(\\"Your answer: \\")) if answer == q[\\"answer\\"]: correct_answers += 1 print(\\"nCongratulations! You have completed the quiz.\\") print(f\\"You got {correct_answers} out of {len(questions)} questions correct.\\") score_percentage = (correct_answers / len(questions)) * 100 print(f\\"Your score: {score_percentage:.2f}%\\")"},{"question":"# String Slicer Class You need to create a `StringSlicer` class that slices strings based on specific instructions. The class should be able to take a string and a list of slicing instructions and return the sliced parts of the string according to the instructions. **Objective**: Implement the `StringSlicer` class with a method to slice the string based on a given list of slicing instructions. **Requirements**: 1. Class `StringSlicer` should have an `__init__` method that takes a string. 2. Method `slice` should take a list of slicing instructions, where each instruction is a tuple (start, end). 3. Each slicing instruction tuple (start, end) represents the start index (inclusive) and the end index (exclusive) for slicing the string. 4. The `slice` method should return a list of sliced strings based on the given instructions. **Expected Input/Output**: - The `__init__` method initializes the string to be sliced. - The `slice` method takes a list of slicing instructions and returns a list of corresponding sliced string parts. ```python class StringSlicer: def __init__(self, string: str) -> None: self.string = string def slice(self, instructions: list[tuple[int, int]]) -> list[str]: slices = [] for start, end in instructions: slices.append(self.string[start:end]) return slices # Testing the functionality def test_end_to_end_string_slicer() -> None: slicer = StringSlicer(\\"Hello, this is a string slicing example!\\") instructions = [(0, 5), (7, 11), (23, 31)] result = slicer.slice(instructions) assert result == [\\"Hello\\", \\"this\\", \\"slicing\\"] if __name__ == \\"__main__\\": import doctest doctest.testmod() ``` # Example ```python slicer = StringSlicer(\\"Sample string for slicing\\") instructions = [(0, 6), (7, 13), (18, 25)] sliced_parts = slicer.slice(instructions) print(\\"Sliced Parts:\\", sliced_parts) # Output should be [\'Sample\', \'string\', \'slicing\'] ```","solution":"class StringSlicer: def __init__(self, string: str) -> None: self.string = string def slice(self, instructions: list[tuple[int, int]]) -> list[str]: slices = [] for start, end in instructions: slices.append(self.string[start:end]) return slices"},{"question":"# Question: Implement a Dynamic Memory Manager for Efficient Resource Allocation **Context**: You are working on an operating system simulator and need to manage memory allocation and deallocation efficiently. The goal is to implement a dynamic memory manager that handles requests in a contiguous memory block. Memory allocation should employ the first-fit strategy, and deallocation should merge adjacent free blocks to avoid fragmentation. **Requirements**: 1. Implement a class `DynamicMemoryManager` with methods to allocate and deallocate memory. 2. Use the first-fit algorithm to allocate memory. 3. Ensure that adjacent free blocks are merged after deallocation to maintain memory efficiency. 4. Memory management operations should be efficient in terms of time complexity. **Class Signature**: ```python class DynamicMemoryManager: def __init__(self, size: int): pass def allocate_memory(self, size: int) -> int: pass def deallocate_memory(self, address: int) -> None: pass ``` **Functionality**: - `__init__(size: int)`: Initialize a memory manager with a given total size. - `allocate_memory(size: int) -> int`: Allocate a memory block of the given size using the first-fit strategy and return the starting address of the allocated block. If allocation fails, return -1. - `deallocate_memory(address: int) -> None`: Deallocate the block of memory starting at the given address and merge any adjacent free blocks. **Constraints**: - Memory requests and deallocations are valid. - The simulator should handle memory operations for large sizes efficiently. **Examples**: ```python >>> memory_manager = DynamicMemoryManager(100) >>> addr1 = memory_manager.allocate_memory(10) >>> addr2 = memory_manager.allocate_memory(20) >>> addr1 # Should be 0 as it\'s the first allocation 0 >>> addr2 # Should be 10, right after the first 10 units 10 >>> memory_manager.deallocate_memory(10) >>> addr3 = memory_manager.allocate_memory(15) >>> addr3 # Should reuse the space deallocated at address 10 10 >>> addr4 = memory_manager.allocate_memory(25) >>> addr4 # Should be placed after the first allocation and reused blocks 40 ``` **Hint**: Maintain a list or data structure to keep track of allocated and free memory blocks. This will help in efficiently finding suitable blocks for allocation and merging blocks during deallocation.","solution":"class DynamicMemoryManager: def __init__(self, size: int): self.size = size self.memory = [(0, size)] # List of (starting address, size) tuples representing free blocks def allocate_memory(self, size: int) -> int: for i, (addr, block_size) in enumerate(self.memory): if block_size >= size: if block_size == size: self.memory.pop(i) else: self.memory[i] = (addr + size, block_size - size) return addr return -1 def deallocate_memory(self, address: int, size: int) -> None: self.memory.append((address, size)) self.memory.sort() # Merge adjacent blocks merged_memory = [] prev_start, prev_size = self.memory[0] for start, block_size in self.memory[1:]: if prev_start + prev_size == start: prev_size += block_size else: merged_memory.append((prev_start, prev_size)) prev_start, prev_size = start, block_size merged_memory.append((prev_start, prev_size)) self.memory = merged_memory"},{"question":"# Question: Context: As a software developer working on a file storage service, you need to create a feature that compresses and decompresses strings efficiently. You are tasked with creating functions to run-length encode and decode strings. Task: Implement two functions: `encode(s: str) -> str` and `decode(s: str) -> str` to perform run-length encoding and decoding respectively. * The `encode` function should take a string `s` and return its run-length encoded form. * The `decode` function should take a run-length encoded string and return the original string. Run-length encoding is a simple form of data compression where consecutive occurrences of the same character are replaced by a single instance of that character followed by the number of occurrences. For example, \\"aaabccddd\\" would be encoded as \\"a3b1c2d3\\". Constraints: * The input string for encoding, `s`, will only contain lowercase English letters and will have a length of up to `10^5`. * The encoded string for decoding will be a valid run-length encoded string as specified. Input: * A string `s` for encoding where `1 <= len(s) <= 10^5` * A valid run-length encoded string for decoding where `1 <= len(s) <= 10^5` Output: * The run-length encoded string for `encode`. * The original string for `decode`. Example: ```python assert encode(\\"aaabccddd\\") == \\"a3b1c2d3\\" assert decode(\\"a3b1c2d3\\") == \\"aaabccddd\\" assert encode(\\"aabcccccaaa\\") == \\"a2b1c5a3\\" assert decode(\\"a2b1c5a3\\") == \\"aabcccccaaa\\" ``` Requirements: * Your solution should be efficient in terms of both time and space complexity. * You must handle edge cases such as strings with only one character repeatedly and long repetitive sequences efficiently.","solution":"def encode(s: str) -> str: if not s: return \\"\\" encoded_str = [] count = 1 prev_char = s[0] for char in s[1:]: if char == prev_char: count += 1 else: encoded_str.append(f\\"{prev_char}{count}\\") prev_char = char count = 1 encoded_str.append(f\\"{prev_char}{count}\\") return \'\'.join(encoded_str) def decode(s: str) -> str: if not s: return \\"\\" decoded_str = [] i = 0 while i < len(s): char = s[i] i += 1 count_str = [] while i < len(s) and s[i].isdigit(): count_str.append(s[i]) i += 1 count = int(\'\'.join(count_str)) decoded_str.append(char * count) return \'\'.join(decoded_str)"},{"question":"# Context You are developing a grid-based game where players can move between cells. Some cells contain obstacles, and the objective is to find the shortest path from the player\'s starting position to a target position, avoiding any obstacles. # Task Implement a function `find_shortest_path(grid: List[List[int]], start: Tuple[int, int], end: Tuple[int, int]) -> List[Tuple[int, int]]` that finds the shortest path in a 2D grid from the `start` position to the `end` position. The grid is represented as a matrix of 0s and 1s, where 0s are walkable cells, and 1s are obstacles. If there is no path, the function should return an empty list. # Input and Output * **Input**: * `grid` (List[List[int]]): A 2D list representing the grid. * `start` (Tuple[int, int]): The starting position in the grid. * `end` (Tuple[int, int]): The target position in the grid. * **Output**: * A list of tuples representing the shortest path from the `start` to the `end`, including both. If no path exists, return an empty list. # Constraints * The grid dimensions are between 1 and 100. * The values in the grid are either 0 (walkable) or 1 (obstacle). * The start and end positions are valid and within the grid bounds. * Movement is allowed up, down, left, and right (no diagonal movement). # Example ```python example_grid = [ [0, 0, 1, 0], [1, 0, 1, 0], [0, 0, 0, 0], [0, 1, 1, 1], [0, 0, 0, 0] ] print(find_shortest_path(example_grid, (0, 0), (4, 3))) # Expected Output: # [ # (0, 0), # (1, 1), # (2, 2), # (3, 2), # (4, 3) # ] # or another valid shortest path if multiple exist print(find_shortest_path(example_grid, (0, 0), (1, 0))) # Expected Output: # [] ``` # Performance Requirements The function should have a time complexity of O(N * M), where N and M are the number of rows and columns in the grid, respectively. Ensure that the solution is efficient for grids up to the maximum size of 100x100. # Note You do not need to handle input validation. Assume all input provided will be valid according to the constraints.","solution":"from typing import List, Tuple from collections import deque def find_shortest_path(grid: List[List[int]], start: Tuple[int, int], end: Tuple[int, int]) -> List[Tuple[int, int]]: if grid[start[0]][start[1]] == 1 or grid[end[0]][end[1]] == 1: return [] rows, cols = len(grid), len(grid[0]) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] queue = deque([(start, [start])]) visited = set([start]) while queue: (current, path) = queue.popleft() if current == end: return path for direction in directions: next_row, next_col = current[0] + direction[0], current[1] + direction[1] next_cell = (next_row, next_col) if 0 <= next_row < rows and 0 <= next_col < cols and grid[next_row][next_col] == 0 and next_cell not in visited: visited.add(next_cell) queue.append((next_cell, path + [next_cell])) return []"},{"question":"# Cache-Friendly Matrix Transposition **Context**: Matrix transposition is a common operation in various scientific computations. To enhance the performance of matrix operations, it is important to utilize cache-friendly strategies that minimize cache misses and optimize memory access patterns. Task Implement the function `transpose_matrix` that takes an input matrix and returns its transpose. Ensure the implementation is cache-friendly to maximize performance. Input Format * A 2D list `matrix` containing `m` rows and `n` columns (0 ≤ m, n ≤ 1000). Output Format * The transposed 2D list, where the rows are converted to columns and vice versa. Constraints * Time Complexity: O(m * n). * Space Complexity: O(m * n). Function Signature ```python def transpose_matrix(matrix: list[list[int]]) -> list[list[int]]: pass ``` Implementation Details 1. Traverse the matrix in a way that optimizes cache usage. 2. Handle irregular matrices (different number of rows and columns). 3. Return a new 2D list that is the transposed version of the input matrix. Example ```python print(transpose_matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]])) # Output: [[1, 4, 7], [2, 5, 8], [3, 6, 9]] print(transpose_matrix([[1, 2, 3], [4, 5, 6]])) # Output: [[1, 4], [2, 5], [3, 6]] print(transpose_matrix([[]])) # Output: [[]] print(transpose_matrix([])) # Output: [] ``` Notes * Ensure the function handles edge cases like empty matrices and single-element matrices. * Opt for memory access patterns that reduce cache misses for better performance in large matrices.","solution":"def transpose_matrix(matrix): Given a 2-dimensional list (matrix), return its transpose. if not matrix: return [] m, n = len(matrix), len(matrix[0]) transpose = [[None]*m for _ in range(n)] for i in range(m): for j in range(n): transpose[j][i] = matrix[i][j] return transpose"},{"question":"# Problem: Matrix Chain Multiplication You are provided with a function named `matrix_chain_order` that computes the minimum number of multiplications required to multiply a given chain of matrices. Each matrix i has dimensions p[i-1] x p[i]. Your task is to complete this function such that it returns the minimum number of multiplications needed to multiply the chain of matrices. # Function Signature: ```python def matrix_chain_order(p: List[int]) -> int: This function computes the minimum number of multiplications required to multiply a chain of matrices. Args: p (List[int]): A list of integers denoting the dimensions of matrices. If there are n matrices, the list contains n+1 elements. Returns: int: The minimum number of multiplications needed to multiply the chain of matrices. pass ``` # Input: * `p`: A list of integers where the length of the list is n+1 for n matrices. The i-th matrix has dimensions p[i-1] x p[i]. # Constraints: * The length of list p will be in range [2, 101]. Therefore, n (number of matrices) will be in range [1, 100]. * Each element of list p will be in the range [1, 1000]. # Output: * An integer representing the minimum number of multiplications needed to multiply the chain of matrices. # Example: ```python p = [1, 2, 3, 4] result = matrix_chain_order(p) print(result) # Output should be the minimum number of multiplications needed to multiply the chain of matrices # In this case, the output would be 18. ``` # Hints: * Use dynamic programming to solve the problem. * Define a table `m` such that `m[i][j]` represents the minimum number of scalar multiplications needed to compute the product of matrices A_i through A_j. * Utilize the recursion: `m[i][j] = min(m[i][k] + m[k+1][j] + p[i-1] * p[k] * p[j])` for i ≤ k < j.","solution":"def matrix_chain_order(p): This function computes the minimum number of multiplications required to multiply a chain of matrices. Args: p (List[int]): A list of integers denoting the dimensions of matrices. If there are n matrices, the list contains n+1 elements. Returns: int: The minimum number of multiplications needed to multiply the chain of matrices. n = len(p) - 1 m = [[0 for x in range(n)] for y in range(n)] for L in range(2, n + 1): for i in range(n - L + 1): j = i + L - 1 m[i][j] = float(\'inf\') for k in range(i, j): q = m[i][k] + m[k + 1][j] + p[i] * p[k + 1] * p[j + 1] if q < m[i][j]: m[i][j] = q return m[0][n - 1]"},{"question":"# Regular String Expressions Matching You are required to write a Python function that emulates a simplified version of a regular expression matcher. This simplified regular expression matcher should support the following special characters: 1. `.` - Matches any single character. 2. `*` - Matches zero or more of the preceding element. Task Requirements: 1. **Function Implementation** - Implement the function as described below: * `def is_match(s: str, p: str) -> bool`: - **Input**: * `s`: a string containing only lowercase letters. * `p`: a string containing only lowercase letters, `.` and `*`. - **Output**: * Return `True` if the pattern `p` matches the entire string `s`. Otherwise, return `False`. 2. **Examples**: * `is_match(\\"aa\\", \\"a\\")` should return `False` * `is_match(\\"aa\\", \\"a*\\")` should return `True` * `is_match(\\"ab\\", \\".*\\")` should return `True` * `is_match(\\"aab\\", \\"c*a*b\\")` should return `True` * `is_match(\\"mississippi\\", \\"mis*is*p*.\\")` should return `False` 3. **Constraints**: * The input strings `s` and `p` will not exceed 1000 characters. 4. **Guidelines**: * Focus on a dynamic programming approach for the implementation to ensure efficiency. * Use memoization to avoid redundant calculations. * The function should handle edge cases where `s` or `p` could be empty. 5. **Testing**: * Write a test function using `pytest` to validate your `is_match` function with various test cases including edge cases. Ensure different combinations of string `s` and pattern `p` are thoroughly tested to cover all scenarios of allowed special characters. By implementing the above function, you will be testing your understanding of regular expressions and ensuring that your solution is both efficient and correct.","solution":"def is_match(s: str, p: str) -> bool: Returns True if the pattern p matches the entire string s, otherwise returns False. memo = {} def dp(i, j): if (i, j) in memo: return memo[(i, j)] if j == len(p): ans = i == len(s) else: first_match = i < len(s) and p[j] in {s[i], \'.\'} if j + 1 < len(p) and p[j + 1] == \'*\': ans = dp(i, j + 2) or (first_match and dp(i + 1, j)) else: ans = first_match and dp(i + 1, j + 1) memo[(i, j)] = ans return ans return dp(0, 0)"},{"question":"# Coding Assessment Question Context: Develop a function that evaluates the level of nesting in a given string based on the use of round brackets (parentheses). This is essential in understanding the depth of nested expressions in computational languages. Problem Statement: Write a function `max_nesting_depth` that takes a string containing round brackets, and determines the depth of the deepest nested parentheses. ```python def max_nesting_depth(s: str) -> int: Calculate the maximum nesting depth of parentheses in the string. Args: s (str): The input string containing round brackets. Returns: int: The maximum depth of nested parentheses. pass ``` Input: - `s`: A string containing only characters \'(\', \')\', and English letters. Output: - Return an integer representing the maximum depth of nested parentheses. Constraints: - The length of string `s` is between 0 and 10000. Performance Requirements: - The function should run in linear time, O(n), where n is the length of the string. Examples: 1. `max_nesting_depth(\\"(a(b(c)d)e)\\")` should return `3`. 2. `max_nesting_depth(\\"((())\\")` should return `3`. 3. `max_nesting_depth(\\"a(b)c\\")` should return `1`. 4. `max_nesting_depth(\\")\\")` should return `0`. 5. `max_nesting_depth(\\"\\")` should return `0`. Notes: - If the string does not contain any parentheses, return 0. - Consider cases with unbalanced parentheses, where the function should still return the maximum depth of correctly nested pairs. - Ignore all characters other than \'(\' and \')\'.","solution":"def max_nesting_depth(s: str) -> int: Calculate the maximum nesting depth of parentheses in the string. Args: s (str): The input string containing round brackets. Returns: int: The maximum depth of nested parentheses. max_depth = 0 current_depth = 0 for char in s: if char == \'(\': current_depth += 1 if current_depth > max_depth: max_depth = current_depth elif char == \')\': if current_depth > 0: # Only decrease if previously increased current_depth -= 1 return max_depth"},{"question":"# Coding Question: Implement and Analyze the Chinese Remainder Theorem Context The Chinese Remainder Theorem (CRT) is a powerful tool in number theory and computer science that allows solutions to a system of simultaneous congruences with pairwise coprime moduli. This problem requires understanding modular arithmetic, extended Euclidean algorithm, and properties of congruences to effectively apply CRT and analyze its application. Problem Statement You are tasked with writing two functions: 1. **chinese_remainder_theorem(n: List[int], a: List[int]) -> int**: Solves the system of congruences using the Chinese Remainder Theorem. 2. **is_coprime_list(n: List[int]) -> bool**: Checks if all values in the list `n` are pairwise coprime. Input/Output Formats - **Function 1: `chinese_remainder_theorem(n: List[int], a: List[int]) -> int`** - **Input**: Two lists of integers `n` and `a` of the same length `k`, where `n[i]` and `a[i]` represent the modulus and remainder for the ith congruence respectively. - **Output**: A single integer that is the solution to the system of congruences if all moduli are pairwise coprime, otherwise return `None`. - **Constraints**: `1 ≤ k ≤ 10^3`, `1 ≤ n[i] ≤ 10^6`, `0 ≤ a[i] < n[i]` - **Function 2: `is_coprime_list(n: List[int]) -> bool`** - **Input**: A list of integers `n`. - **Output**: `True` if all integers in `n` are pairwise coprime, `False` otherwise. - **Constraints**: `1 ≤ len(n) ≤ 10^3`, `1 ≤ n[i] ≤ 10^6` Detailed Requirements - **Edge Cases**: - Handle empty input lists by raising a `ValueError`. - Ensure appropriate pairwise coprimality checks in `is_coprime_list`. - Return `None` from `chinese_remainder_theorem` if moduli are not pairwise coprime. - **Error Handling**: Additionally provide meaningful error messages for invalid inputs. Example ```python >>> is_coprime_list([3, 5, 7]) True >>> is_coprime_list([3, 6, 9]) False >>> chinese_remainder_theorem([3, 5, 7], [2, 3, 2]) 23 >>> chinese_remainder_theorem([3, 6, 9], [2, 3, 2]) None ``` Performance Goal - Efficiently handle large lists and integer values up to the given constraints. - Leverage properties of the Euclidean algorithm to ensure performance efficiency.","solution":"from typing import List from functools import reduce from math import gcd def is_coprime_pair(x: int, y: int) -> bool: return gcd(x, y) == 1 def is_coprime_list(n: List[int]) -> bool: if not n: raise ValueError(\\"Input list cannot be empty\\") length = len(n) for i in range(length): for j in range(i + 1, length): if not is_coprime_pair(n[i], n[j]): return False return True def extended_gcd(a: int, b: int): if b == 0: return a, 1, 0 g, x1, y1 = extended_gcd(b, a % b) x = y1 y = x1 - (a // b) * y1 return g, x, y def chinese_remainder_theorem(n: List[int], a: List[int]) -> int: if not (len(n) == len(a) and n): raise ValueError(\\"Input lists must be of the same length and non-empty\\") if not is_coprime_list(n): return None prod = reduce(lambda x, y: x * y, n) result = 0 for ni, ai in zip(n, a): pi = prod // ni _, x, _ = extended_gcd(pi, ni) result += ai * x * pi return result % prod"},{"question":"# Context: You are working on a data visualization tool that needs to generate histograms from a list of integers. The challenge is to determine the frequency of each unique integer in the provided list and return a formatted string representing these frequencies. # Problem Statement: Write a Python function `generate_histogram(values: List[int]) -> str` that takes a list of integers and returns a string representing the frequency histogram of those integers. The histogram should line up the frequencies with the integer values in ascending order, and each frequency should be denoted by a corresponding number of stars (`*`). For each unique integer: - The formatted string should output the integer followed by a colon (`:`) and a series of stars representing the count of that integer. - Each integer-frequency pair should be on a new line. - The histogram should be sorted by the integers in ascending order. # Inputs: - `values (List[int])`: A list of integers. # Outputs: - A string representing the histogram. # Constraints: - `1 <= len(values) <= 10^4` - Each integer in the list will be in the range `-10^5 <= x <= 10^5`. # Example: ```python from typing import List def generate_histogram(values: List[int]) -> str: pass # An example of the function in use: values = [1, 3, 2, 3, 2, 1, 1, 3, 4] print(generate_histogram(values)) # Output: # 1: *** # 2: ** # 3: *** # 4: * ``` # Notes: - Ensure the output string maintains proper formatting for easier readability. - Handle possible edge cases such as an empty list or all integers being the same. - Aim for efficient computation to handle larger input sizes.","solution":"from typing import List from collections import Counter def generate_histogram(values: List[int]) -> str: # Count the frequencies of each integer freq = Counter(values) # Sort the unique integers sorted_unique_integers = sorted(freq.keys()) # Build the histogram string histogram_lines = [f\\"{num}: {\'*\' * freq[num]}\\" for num in sorted_unique_integers] return \\"n\\".join(histogram_lines)"},{"question":"# Problem Statement You are tasked with creating an efficient algorithm that can perform operations on a collection of URLs stored in a trie (prefix tree). Implement two main functions, `insert_url(trie: dict, url: str) -> None` and `find_urls(trie: dict, prefix: str) -> List[str]`. Task 1: `insert_url(trie: dict, url: str) -> None` - **Input**: - `trie`: A dictionary representing the root node of the trie. - `url`: A string containing the URL to be inserted into the trie. - **Output**: - The function should modify the trie in place, inserting the URL. Task 2: `find_urls(trie: dict, prefix: str) -> List[str]` - **Input**: - `trie`: A dictionary representing the root node of the trie. - `prefix`: A string representing the prefix of the URLs to retrieve from the trie. - **Output**: - Returns a list of URLs that start with the specified prefix. Requirements and Constraints 1. **Assumptions**: - The URLs consist of lowercase alphanumeric characters and periods. - The trie data structure is represented as a nested dictionary where each character of a URL is a key. 2. **Constraints**: - URLs will not exceed 256 characters. - The total number of stored URLs at any time will not exceed 10000. Implementation Details - Handle edge cases such as duplicate URLs and invalid prefixes gracefully. - Optimize the trie structure for insertion and prefix search operations. # Example ```python def insert_url(trie: dict, url: str) -> None: # implementation here def find_urls(trie: dict, prefix: str) -> List[str]: # implementation here # Example usage: trie = {} insert_url(trie, \\"www.google.com\\") insert_url(trie, \\"www.golang.org\\") insert_url(trie, \\"www.github.com\\") insert_url(trie, \\"www.geeksforgeeks.org\\") prefix = \\"www.go\\" urls_with_prefix = find_urls(trie, prefix) # Expected output: [\'www.google.com\', \'www.golang.org\'] ``` Note: - Your solution should produce deterministic results. - Include test cases in your code to demonstrate the functionality.","solution":"def insert_url(trie, url): Insert a given URL into the trie. Args: trie (dict): The root node of the trie. url (str): The URL to be inserted. node = trie for char in url: if char not in node: node[char] = {} node = node[char] node[\'*\'] = url # \'*\' signifies the end of the URL def find_urls(trie, prefix): Find all URLs in the trie that start with the given prefix. Args: trie (dict): The root node of the trie. prefix (str): The prefix to search for. Returns: List[str]: A list of URLs that start with the given prefix. def dfs(node, path, results): if \'*\' in node: results.append(node[\'*\']) for char in node: if char != \'*\': dfs(node[char], path + char, results) results = [] node = trie for char in prefix: if char in node: node = node[char] else: return results dfs(node, prefix, results) return results"},{"question":"# Zigzag Conversion A new messaging app developer is working on a feature that formats text messages into a zigzag pattern for their display. Your task is to implement a function that converts a given string into a zigzag pattern string. Function Signature ```python def zigzag_conversion(s: str, numRows: int) -> str: pass ``` Input - A string, `s`, representing the text to be converted. - An integer, `numRows`, representing the number of rows in the zigzag pattern. Output - A string, representing the input `s` formatted in a zigzag pattern. # Constraints - `1 <= len(s) <= 1000` - `1 <= numRows <= 1000` # Performance Requirements - Your implementation should efficiently handle the provided constraints, converting the string in O(n) time, where n is the length of the string. # Example For example, given `s` = \\"PAYPALISHIRING\\" and `numRows` = 3, the output should be \\"PAHNAPLSIIGYIR\\". Pattern visualization: ``` P A H N A P L S I I G Y I R ``` # Sample Input/Output ```python assert zigzag_conversion(\\"PAYPALISHIRING\\", 3) == \\"PAHNAPLSIIGYIR\\" assert zigzag_conversion(\\"PAYPALISHIRING\\", 4) == \\"PINALSIGYAHRPI\\" assert zigzag_conversion(\\"A\\", 1) == \\"A\\" assert zigzag_conversion(\\"PAYPALISHIRING\\", 1) == \\"PAYPALISHIRING\\" assert zigzag_conversion(\\"ABC\\", 2) == \\"ACB\\" ``` # Hints - Think about how the indices of characters in the zigzag pattern relate to one another. - Consider whether you need to traverse the string in a straightforward manner or if you need a more complex iteration to populate the zigzag rows. - Handle edge cases, such as when `numRows` is 1, which means the output should be the same as the input string.","solution":"def zigzag_conversion(s: str, numRows: int) -> str: Converts the input string into a zigzag pattern string. :param s: The string to be converted. :param numRows: The number of rows in the zigzag pattern. :return: The string in zigzag pattern. if numRows == 1 or numRows >= len(s): return s # Create an array of strings to hold the zigzag pattern rows = [\\"\\"] * numRows current_row = 0 going_down = False for char in s: rows[current_row] += char if current_row == 0 or current_row == numRows - 1: going_down = not going_down current_row += 1 if going_down else -1 return \\"\\".join(rows)"},{"question":"# Problem Statement You are given a list of strings where each string represents a file path in a hierarchical structure. Each file path is a sequence of directory names separated by forward slashes (`/`). Your task is to implement a function `find_longest_common_path(paths: list[str]) -> str` that finds the longest common path shared by all the file paths in the list. # Function Signature ```python def find_longest_common_path(paths: list[str]) -> str: pass ``` # Input * `paths`: A list of strings representing file paths. Each string contains only alphanumeric characters and the `/` symbol. # Output * A string representing the longest common path shared by all the file paths in the list. * If there is no common path, return an empty string `\\"\\"`. # Constraints * `paths` will contain at least one file path. * Each file path will be non-empty and will not have leading or trailing slashes. * The length of each file path will not exceed 1000 characters. * `paths` list will contain up to 10^5 file paths. # Example ```python paths1 = [ \\"home/user/docs\\", \\"home/user/music\\", \\"home/user/docs/reports\\" ] print(find_longest_common_path(paths1)) # Output: \\"home/user\\" paths2 = [ \\"var/log/nginx\\", \\"var/log/apache\\", \\"var/log/syslog\\", \\"var/cache/apt\\" ] print(find_longest_common_path(paths2)) # Output: \\"var\\" paths3 = [ \\"root/admin/settings\\", \\"root/admin/users\\", \\"home/user/files\\" ] print(find_longest_common_path(paths3)) # Output: \\"\\" ``` # Note The function should handle large inputs efficiently. Consider the constraints and optimize your algorithm to process the list of file paths within a reasonable time frame. You may use data structures such as lists or sets to assist in finding the common path segments.","solution":"def find_longest_common_path(paths): Finds the longest common path shared by all the file paths in the list. Args: paths (list of str): List of strings representing file paths. Returns: str: Longest common path shared by all the file paths. If there is no common path, return an empty string. if not paths: return \\"\\" # Split all paths by \'/\' split_paths = [path.split(\'/\') for path in paths] # Find the minimum length of all split paths min_len = min(len(path) for path in split_paths) longest_common_path_parts = [] for i in range(min_len): # Take the i-th part of each split path current_parts = [path[i] for path in split_paths] # If all parts are the same, add it to the common path parts if all(part == current_parts[0] for part in current_parts): longest_common_path_parts.append(current_parts[0]) else: break # Join the common path parts with \'/\' return \'/\'.join(longest_common_path_parts)"},{"question":"# Problem Context You work at a software company that specializes in developing text processing tools. One of the core functionalities is to search for patterns within large bodies of text efficiently. Your task is to implement a pattern matching algorithm for this purpose. # Task Implement a class `PatternMatcher` to find all occurrences of a given pattern in a text using the Knuth-Morris-Pratt (KMP) string matching algorithm. # Function Signature ```python class PatternMatcher: def __init__(self, pattern: str): ... def compute_lps_array(self): ... def kmp_search(self, text: str) -> list[int]: ... ``` # Requirements 1. **Initialization (`__init__` method)**: - Accepts a `pattern` string and stores it. - Validates if the pattern is non-empty. 2. **Compute Longest Prefix Suffix Array (`compute_lps_array` method)**: - Constructs the longest prefix suffix (LPS) array for the pattern. - This array facilitates the KMP search by skipping unnecessary comparisons. 3. **KMP Search (`kmp_search` method)**: - Accepts a `text` string in which to search for occurrences of the pattern. - Uses the LPS array to find and return a list of starting indices where the pattern is found in the text. # Input and Output Format * **Input**: Pattern and text strings ```plaintext Pattern: \\"ABABCABAB\\" Text: \\"ABABDABACDABABCABAB\\" ``` * **Output**: - Method signature implementations. - The list of starting indices where the pattern occurs in the given text. ```plaintext [10] ``` # Constraints 1. Pattern length: 1 to (10^5). 2. Text length: 1 to (10^5). 3. Both pattern and text consist of uppercase English letters. # Example Usage ```python if __name__ == \\"__main__\\": matcher = PatternMatcher(\\"ABABCABAB\\") indices = matcher.kmp_search(\\"ABABDABACDABABCABAB\\") print(indices) # Output: [10] ``` # Additional Guidelines 1. **Edge Cases**: - Handle input properly where the pattern is bigger than the text. - Ensure the pattern and text consist only of uppercase English letters. 2. **Performance**: - Efficiently compute the LPS array. - Ensure the search algorithm operates in O(N) time complexity, where N is the length of the text. --- By implementing this pattern matcher, you will enable efficient text processing for large texts and patterns, which is a common requirement in various software applications.","solution":"class PatternMatcher: def __init__(self, pattern: str): if not pattern: raise ValueError(\\"Pattern must be non-empty.\\") self.pattern = pattern self.lps = self.compute_lps_array() def compute_lps_array(self): Compute the Longest Prefix Suffix (LPS) array. lps = [0] * len(self.pattern) length = 0 # length of the previous longest prefix suffix i = 1 while i < len(self.pattern): if self.pattern[i] == self.pattern[length]: length += 1 lps[i] = length i += 1 else: if length != 0: length = lps[length - 1] else: lps[i] = 0 i += 1 return lps def kmp_search(self, text: str) -> list[int]: Perform KMP search and return indices of pattern match in the text. pattern_length = len(self.pattern) text_length = len(text) indices = [] text_index = 0 # index for text pattern_index = 0 # index for pattern while text_index < text_length: if self.pattern[pattern_index] == text[text_index]: text_index += 1 pattern_index += 1 if pattern_index == pattern_length: indices.append(text_index - pattern_index) pattern_index = self.lps[pattern_index - 1] elif text_index < text_length and self.pattern[pattern_index] != text[text_index]: if pattern_index != 0: pattern_index = self.lps[pattern_index - 1] else: text_index += 1 return indices"},{"question":"# Question: Implement a Custom Dropout Layer in a Neural Network You are given a simple Neural Network implementation where you need to add a custom dropout layer. The dropout layer should randomly disable a fraction of the neurons (i.e., set their activations to zero) during training to prevent overfitting. Your task is to: 1. Implement the `custom_dropout` function that takes the input array and a dropout probability, and returns the array with a fraction of its elements set to zero. 2. Integrate this dropout function into the provided neural network\'s forward pass to improve the network\'s regularization. Requirements: - Your `custom_dropout` function should accept two parameters: - `input_array`: A 2D numpy array representing the activations from the previous layer. - `dropout_prob`: The probability of dropping each neuron (0 <= `dropout_prob` < 1). Input: - `input_array`: A 2D numpy array. - `dropout_prob` (float): The probability of dropping each neuron\'s activation. Output: - `dropped_output`: A 2D numpy array of the same shape as `input_array`, with a fraction of elements set to zero based on the dropout probability. Constraints: - Ensure that the dropout is applied only during training and not during evaluation. # Example: ```python # Example input: input_array = np.array([[1.0, 2.0, 3.0], [4.0, 5.0, 6.0]]) dropout_prob = 0.5 # Possible expected output (actual output may vary due to randomness): # dropped_output = np.array([[1.0, 0.0, 3.0], # [0.0, 5.0, 0.0]]) ``` Function signature: ```python def custom_dropout(input_array: np.ndarray, dropout_prob: float) -> np.ndarray: pass ``` Integrate your `custom_dropout` function into the given neural network\'s forward pass, ensuring dropout is only applied during training. ```python class SimpleNeuralNetwork: def __init__(self, input_size, hidden_size, output_size, dropout_prob): self.input_size = input_size self.hidden_size = hidden_size self.output_size = output_size self.dropout_prob = dropout_prob # Initialize weights self.W1 = np.random.randn(input_size, hidden_size) self.W2 = np.random.randn(hidden_size, output_size) def forward(self, x, training=True): # Perform the forward pass self.z1 = np.dot(x, self.W1) self.a1 = self.activate(self.z1) # Activation function (e.g., ReLU) if training: self.a1 = custom_dropout(self.a1, self.dropout_prob) self.z2 = np.dot(self.a1, self.W2) self.a2 = self.activate(self.z2) # Activation function (e.g., softmax) return self.a2 def activate(self, x): # Placeholder activation function return np.maximum(0, x) # Example: ReLU ``` Ensure your dropout function is correctly called within the `SimpleNeuralNetwork` class and properly tested to handle training and evaluation phases.","solution":"import numpy as np def custom_dropout(input_array: np.ndarray, dropout_prob: float) -> np.ndarray: Applies dropout to input_array with the given dropout probability. Args: input_array (np.ndarray): 2D input array (activations from the previous layer). dropout_prob (float): Probability of dropping a neuron (0 <= dropout_prob < 1). Returns: np.ndarray: Output array with some elements dropped (set to zero). if not 0 <= dropout_prob < 1: raise ValueError(\\"dropout_prob must be in the range [0, 1).\\") # Generate a mask with the same shape as input_array, where elements are 0 with # probability dropout_prob and 1 with probability (1 - dropout_prob) mask = np.random.binomial(1, 1 - dropout_prob, size=input_array.shape) # Apply the mask to the input_array dropped_output = input_array * mask # Optionally scale the output by 1 / (1 - dropout_prob) during training to maintain output expectation # dropped_output /= (1 - dropout_prob) return dropped_output class SimpleNeuralNetwork: def __init__(self, input_size, hidden_size, output_size, dropout_prob): self.input_size = input_size self.hidden_size = hidden_size self.output_size = output_size self.dropout_prob = dropout_prob # Initialize weights self.W1 = np.random.randn(input_size, hidden_size) self.W2 = np.random.randn(hidden_size, output_size) def forward(self, x, training=True): # Perform the forward pass self.z1 = np.dot(x, self.W1) self.a1 = self.activate(self.z1) # Activation function (e.g., ReLU) if training: self.a1 = custom_dropout(self.a1, self.dropout_prob) self.z2 = np.dot(self.a1, self.W2) self.a2 = self.activate(self.z2) # Activation function (e.g., softmax) return self.a2 def activate(self, x): # Placeholder activation function return np.maximum(0, x) # Example: ReLU"},{"question":"# Warehouse Inventory Management As a software developer for a logistics company, you\'ve been tasked with designing a system to manage the inventory of products across different warehouses. Your goal is to implement a function that tracks product quantities, handles restocking, and processes outgoing orders. Task Implement a class `Inventory` to manage products in a warehouse. The class should support adding new products, restocking existing products, and fulfilling orders. Class Definition ```python class Inventory: def __init__(self): Initializes an empty inventory. self.stock = {} def add_product(self, product_id: str, quantity: int) -> None: Adds a new product with the given quantity to the inventory. If the product already exists, the quantity should be increased. Parameters: product_id (str): The ID of the product. quantity (int): The quantity of the product to add. if product_id in self.stock: self.stock[product_id] += quantity else: self.stock[product_id] = quantity def remove_product(self, product_id: str, quantity: int) -> bool: Removes the specified quantity of the product from the inventory. If the product does not exist or if the quantity is insufficient, the operation should fail. Parameters: product_id (str): The ID of the product. quantity (int): The quantity of the product to remove. Returns: bool: True if the removal was successful, False otherwise. if product_id in self.stock and self.stock[product_id] >= quantity: self.stock[product_id] -= quantity if self.stock[product_id] == 0: del self.stock[product_id] return True return False def get_quantity(self, product_id: str) -> int: Returns the current quantity of the specified product. Parameters: product_id (str): The ID of the product. Returns: int: The quantity of the product, or 0 if the product does not exist. return self.stock.get(product_id, 0) ``` Requirements 1. **Initialization**: - The `Inventory` class should initialize with an empty stock. 2. **Adding Products**: - Products can be added to the inventory with a specified quantity. If the product already exists, the quantity should be updated. 3. **Removing Products**: - Products should be removable in specified quantities. If the product does not exist or if the quantity is insufficient, the operation should return `False`. 4. **Getting Quantities**: - The system should be able to report the current quantity of any given product. If the product does not exist, it should return 0. Input and Output - **Input**: - For `add_product`: A string `product_id` representing the ID of the product and an integer `quantity` representing the amount to add. - For `remove_product`: A string `product_id` representing the ID of the product and an integer `quantity` representing the amount to remove. - For `get_quantity`: A string `product_id` representing the ID of the product. - **Output**: - For `remove_product`: A boolean indicating the success of the removal. - For `get_quantity`: An integer representing the current quantity of the product. Example ```python inventory = Inventory() inventory.add_product(\'A123\', 100) inventory.add_product(\'B456\', 200) print(inventory.get_quantity(\'A123\')) # Output: 100 print(inventory.remove_product(\'A123\', 50)) # Output: True print(inventory.get_quantity(\'A123\')) # Output: 50 print(inventory.remove_product(\'C789\', 10)) # Output: False print(inventory.get_quantity(\'C789\')) # Output: 0 print(inventory.remove_product(\'A123\', 60)) # Output: False ``` Constraints - The quantity values are non-negative integers. - Product IDs are non-empty strings.","solution":"class Inventory: def __init__(self): Initializes an empty inventory. self.stock = {} def add_product(self, product_id: str, quantity: int) -> None: Adds a new product with the given quantity to the inventory. If the product already exists, the quantity should be increased. Parameters: product_id (str): The ID of the product. quantity (int): The quantity of the product to add. if product_id in self.stock: self.stock[product_id] += quantity else: self.stock[product_id] = quantity def remove_product(self, product_id: str, quantity: int) -> bool: Removes the specified quantity of the product from the inventory. If the product does not exist or if the quantity is insufficient, the operation should fail. Parameters: product_id (str): The ID of the product. quantity (int): The quantity of the product to remove. Returns: bool: True if the removal was successful, False otherwise. if product_id in self.stock and self.stock[product_id] >= quantity: self.stock[product_id] -= quantity if self.stock[product_id] == 0: del self.stock[product_id] return True return False def get_quantity(self, product_id: str) -> int: Returns the current quantity of the specified product. Parameters: product_id (str): The ID of the product. Returns: int: The quantity of the product, or 0 if the product does not exist. return self.stock.get(product_id, 0)"},{"question":"**Context**: Given a string of words separated by spaces, we want to find the length of the longest word. **Task**: Write a function `longest_word_length(s)` that computes the length of the longest word in the given string `s`. The function should: - Take a string `s` as input, where `1 <= len(s) <= 10^5` and `s` consists of lowercase and uppercase alphabets as well as spaces. - Return an integer representing the length of the longest word in the string. **Constraints**: - Words in the string are separated by single spaces. - The input string does not contain leading or trailing spaces. **Examples**: ```python >>> longest_word_length(\\"The quick brown fox jumps over the lazy dog\\") 5 >>> longest_word_length(\\"Hello world\\") 5 >>> longest_word_length(\\"a b c d e f g h i j k\\") 1 >>> longest_word_length(\\"coding is fun but challenging\\") 11 ``` You may assume the input to the function is properly formatted based on the constraints mentioned. **Hint**: Consider using the `split()` method to break the string into words, then find the maximum length among them using a simple iteration.","solution":"def longest_word_length(s): Returns the length of the longest word in the string s. return max(len(word) for word in s.split())"},{"question":"# Question **Character Sequence Analysis** You need to design a function in Python that analyzes a given string to find the longest sequence of consecutive identical characters and returns its length. The provided code snippets for similar tasks contain inefficient implementations and fail to handle certain edge cases. Your task is to: 1. Optimize the code for efficiency. 2. Handle edge cases appropriately. 3. Ensure the function is robust and accurate. **Function Signature** ```python def longest_consecutive_sequence(s: str) -> int: ... ``` # Expected Input and Output Format * **Input**: * `s` (str): A string containing only lowercase English letters. (0 <= len(s) <= 10^6) * **Output**: * An integer representing the length of the longest sequence of consecutive identical characters. # Constraints * Ensure that the function returns 0 if the input string is empty. # Scenario/Context Imagine you are building a text editor that includes features to detect and highlight unusually repetitive sequences of characters, which could indicate typos or formatting errors. Understanding the length of such sequences helps in providing better text analysis. # Examples **Example 1**: ```python >>> longest_consecutive_sequence(\\"aaabbccdee\\") 3 ``` **Example 2**: ```python >>> longest_consecutive_sequence(\\"a\\") 1 ``` **Example 3**: ```python >>> longest_consecutive_sequence(\\"abbcccddddeee\\") 4 ``` **Example Edge Case**: ```python >>> longest_consecutive_sequence(\\"\\") 0 ``` # Performance Considerations * Ensure optimal performance for strings of length up to 10^6. * Minimize memory usage by avoiding unnecessary data structures. Submit your implementation as the `longest_consecutive_sequence` function.","solution":"def longest_consecutive_sequence(s: str) -> int: Returns the length of the longest sequence of consecutive identical characters in the string s. if not s: return 0 max_len = 1 current_len = 1 for i in range(1, len(s)): if s[i] == s[i-1]: current_len += 1 if current_len > max_len: max_len = current_len else: current_len = 1 return max_len"},{"question":"# Word Frequency Counter: Efficient Text Analysis Design a class `TextAnalyzer` that processes a given text to count the frequency of each word and provides functionalities to query this information efficiently. # Task Implement the class `TextAnalyzer` with the following methods: 1. `__init__(self, text: str)`: Initializes the TextAnalyzer with the given text. 2. `word_frequency(self, word: str) -> int`: Returns the frequency of the specified word in the text. 3. `top_k_frequent_words(self, k: int) -> List[str]`: Returns a list of the `k` most frequent words in the text in descending order of their frequency. # Specifications Method 1: `__init__` - **Input**: A string `text`. - **Output**: None. Initializes the class with the text and processes it to count the word frequencies. Method 2: `word_frequency` - **Input**: A string `word`. - **Output**: An integer representing the frequency of the specified word in the text. Method 3: `top_k_frequent_words` - **Input**: An integer `k`. - **Output**: A list of the `k` most frequent words in the text, ordered by frequency from highest to lowest. If multiple words have the same frequency, they should be sorted alphabetically. # Constraints 1. Words are to be considered case-insensitively. 2. Only consider alphanumeric characters (words can contain letters and/or numbers). 3. Punctuation and other non-alphanumeric characters should be ignored. 4. If `k` is greater than the number of unique words, return all words sorted by frequency. # Performance Requirements - The class should process the text in linear time relative to its length for initialization. - Both `word_frequency` and `top_k_frequent_words` should aim for logarithmic time complexity after the initial processing step. # Example ```python >>> text = \\"This is a test. This test is only a test. If this had been an actual emergency, you would have been instructed where to tune in your area. This is only a test.\\" >>> analyzer = TextAnalyzer(text) >>> analyzer.word_frequency(\\"test\\") 4 >>> analyzer.word_frequency(\\"this\\") 3 >>> analyzer.top_k_frequent_words(3) [\'test\', \'is\', \'a\'] >>> analyzer.top_k_frequent_words(5) [\'test\', \'is\', \'a\', \'been\', \'if\'] >>> analyzer.top_k_frequent_words(1) [\'test\'] >>> analyzer.top_k_frequent_words(0) [] ``` # Implementation ```python from typing import List, Dict from collections import defaultdict, Counter import re class TextAnalyzer: def __init__(self, text: str): self.word_freq = self._process_text(text) def _process_text(self, text: str) -> Dict[str, int]: # Convert to lower case and find all words words = re.findall(r\'bw+b\', text.lower()) return dict(Counter(words)) def word_frequency(self, word: str) -> int: return self.word_freq.get(word.lower(), 0) def top_k_frequent_words(self, k: int) -> List[str]: if k <= 0: return [] sorted_words = sorted(self.word_freq.items(), key=lambda item: (-item[1], item[0])) return [word for word, freq in sorted_words[:k]] ``` This question aligns with a focus on text processing and data structures like dictionaries and lists, balancing cognitive load and complexity while ensuring practical applicability in real-world scenarios.","solution":"from typing import List, Dict from collections import Counter import re class TextAnalyzer: def __init__(self, text: str): self.word_freq = self._process_text(text) def _process_text(self, text: str) -> Dict[str, int]: # Convert to lower case and find all words words = re.findall(r\'bw+b\', text.lower()) return dict(Counter(words)) def word_frequency(self, word: str) -> int: return self.word_freq.get(word.lower(), 0) def top_k_frequent_words(self, k: int) -> List[str]: if k <= 0: return [] sorted_words = sorted(self.word_freq.items(), key=lambda item: (-item[1], item[0])) return [word for word, freq in sorted_words[:k]]"},{"question":"# Question: Largest Element in a Matrix Given a matrix of integers, implement a function to find the largest element in the matrix. Your solution should efficiently traverse the matrix and return the maximum value found. Input * A 2D list `matrix` where each element is an integer. Output * An integer which is the largest element in the matrix. Constraints * `1 <= number of rows <= 100` * `1 <= number of columns <= 100` * Each integer in the matrix will fall within the range `-10^5 <= matrix[i][j] <= 10^5` Example ```python >>> largest_element([[3, 1, 4], [1, 5, 9], [2, 6, 5]]) 9 >>> largest_element([[7, 3], [2, 8], [1, 6]]) 8 >>> largest_element([[-1, -2, -3], [-4, -5, -6], [-7, -8, -9]]) -1 >>> largest_element([[2]]) 2 ``` Additional Notes - Ensure your function handles both positive and negative integers. - The matrix will always have at least one element. - The solution should traverse the matrix in an optimal manner without incurring significant overhead. ```python def largest_element(matrix): max_element = float(\'-inf\') for row in matrix: for element in row: if element > max_element: max_element = element return max_element ```","solution":"def largest_element(matrix): Returns the largest element in the given matrix. Args: matrix: A 2D list of integers. Returns: An integer which is the largest element in the matrix. max_element = float(\'-inf\') for row in matrix: for element in row: if element > max_element: max_element = element return max_element"},{"question":"# Problem Statement You need to implement a function called `min_spanning_tree` that finds the Minimum Spanning Tree (MST) of a given connected, undirected graph using Kruskal\'s algorithm. Your implementation should efficiently manage the graph\'s edges and employ the union-find data structure to detect and prevent cycles, ensuring optimal performance for large graphs. # Function Signature ```python def min_spanning_tree( num_nodes: int, edges: List[Tuple[int, int, int]] ) -> Tuple[int, List[Tuple[int, int]]]: Compute the Minimum Spanning Tree (MST) of a given graph using Kruskal\'s algorithm. Parameters: num_nodes (int): The number of nodes in the graph. edges (List[Tuple[int, int, int]]): A list of tuples where each tuple (u, v, w) represents an edge between nodes u and v with weight w. Returns: Tuple[int, List[Tuple[int, int]]]: The total weight of the MST and a list of edges (as tuples of nodes) that form the MST. pass ``` # Input * `num_nodes` is an integer representing the number of nodes in the graph. * `edges` is a list of tuples where each tuple `(u, v, w)` represents an edge between nodes `u` and `v` with weight `w`. # Output The function returns a tuple: * **total_weight**: An integer representing the sum of the weights of all edges in the MST. * **mst_edges**: A list of tuples representing the edges in the MST, where each tuple contains the two nodes connected by the edge. # Constraints * The graph is connected, meaning there is at least one path between any pair of nodes. * All nodes are distinct and indexed from 0 to `num_nodes - 1`. * The number of edges can be up to `num_nodes * (num_nodes - 1) / 2`. # Performance Requirements * The implementation should efficiently handle graphs with up to 10^5 nodes and up to 10^6 edges. * The use of efficient data structures, such as the union-find (disjoint-set) for cycle detection, is required. # Scenarios 1. **Basic Functionality**: Implement Kruskal\'s algorithm to output the MST for a simple connected graph. 2. **Edge Cases**: Handle cases where multiple edges have the same weight, ensuring a correct and minimal weight MST. 3. **Optimization**: Optimize the algorithm to handle large graphs and reduce the complexity where possible, such as by efficiently managing edge sorting and union operations. # Example ```python # Example 1 num_nodes = 4 edges = [(0, 1, 1), (1, 2, 4), (0, 2, 3), (2, 3, 2), (1, 3, 5)] result = min_spanning_tree(num_nodes, edges) # Expected output: (6, [(0, 1), (2, 3), (0, 2)]) # Explanation: The MST has a total weight of 6 and includes the edges (0-1), (2-3), and (0-2). # Example 2 num_nodes = 3 edges = [(0, 1, 1), (1, 2, 2), (0, 2, 3)] result = min_spanning_tree(num_nodes, edges) # Expected output: (3, [(0, 1), (1, 2)]) # Explanation: The MST has a total weight of 3 and includes the edges (0-1) and (1-2). ``` The newly created question on implementing `min_spanning_tree` fits well with the provided `kmeans` problem, matching in scope, complexity and length, while focusing on a different but related core algorithmic domain.","solution":"from typing import List, Tuple def find(parent, i): if parent[i] == i: return i else: return find(parent, parent[i]) def union(parent, rank, x, y): xroot = find(parent, x) yroot = find(parent, y) if rank[xroot] < rank[yroot]: parent[xroot] = yroot elif rank[xroot] > rank[yroot]: parent[yroot] = xroot else: parent[yroot] = xroot rank[xroot] += 1 def min_spanning_tree(num_nodes: int, edges: List[Tuple[int, int, int]]) -> Tuple[int, List[Tuple[int, int]]]: Compute the Minimum Spanning Tree (MST) of a given graph using Kruskal\'s algorithm. Parameters: num_nodes (int): The number of nodes in the graph. edges (List[Tuple[int, int, int]]): A list of tuples where each tuple (u, v, w) represents an edge between nodes u and v with weight w. Returns: Tuple[int, List[Tuple[int, int]]]: The total weight of the MST and a list of edges (as tuples of nodes) that form the MST. # Sort all the edges in non-decreasing order of their weight edges = sorted(edges, key=lambda item: item[2]) parent = [] rank = [] # Initialize `parent` and `rank` arrays for all nodes for node in range(num_nodes): parent.append(node) rank.append(0) result = [] # This will store the resultant MST i = 0 # Index variable, used for sorted edges e = 0 # Index variable, used for result array # Number of edges to be taken is equal to V-1 while e < num_nodes - 1: # Step 2: Pick the smallest edge. Check if it forms a cycle with the spanning tree formed so far. u, v, w = edges[i] i = i + 1 x = find(parent, u) y = find(parent, v) # If including this edge does not cause a cycle, include it in the result. if x != y: e = e + 1 result.append((u, v, w)) union(parent, rank, x, y) # Calculate the total weight of the MST total_weight = sum([w for u, v, w in result]) # Extract only the edges, without the weights mst_edges = [(u, v) for u, v, w in result] return total_weight, mst_edges"},{"question":"# Question: Implement a Function to Sort Strings by Their Anagram Groups You are tasked with implementing a function that takes a list of strings and groups the anagrams together. Two words are anagrams if they contain the same characters with the same frequencies. The function should return a new list of lists, where each sublist contains strings that are anagrams of each other. # Function Signature ```python def group_anagrams(words: List[str]) -> List[List[str]]: pass ``` # Input - A list of strings `words` where each string may contain any alphanumeric characters. # Output - A list of lists of strings, where each sublist contains strings that are anagrams of each other. # Constraints - All strings are lower-cased. - The length of each string is between 1 and 100 characters. - The list `words` can contain between 1 and 100 strings. # Examples 1. **Input**: `[\\"bat\\", \\"tab\\", \\"cat\\", \\"act\\", \\"rat\\", \\"tar\\"]` - **Output**: `[[\\"bat\\", \\"tab\\"], [\\"cat\\", \\"act\\"], [\\"rat\\", \\"tar\\"]]` 2. **Input**: `[\\"listen\\", \\"silent\\", \\"enlist\\", \\"rat\\", \\"tar\\", \\"art\\"]` - **Output**: `[[\\"listen\\", \\"silent\\", \\"enlist\\"], [\\"rat\\", \\"tar\\", \\"art\\"]]` 3. **Input**: `[\\"abc\\", \\"bca\\", \\"cab\\", \\"xyz\\", \\"yzx\\", \\"zxy\\"]` - **Output**: `[[\\"abc\\", \\"bca\\", \\"cab\\"], [\\"xyz\\", \\"yzx\\", \\"zxy\\"]]` # Sample Test ```python assert group_anagrams([\\"bat\\", \\"tab\\", \\"cat\\", \\"act\\", \\"rat\\", \\"tar\\"]) == [[\\"bat\\", \\"tab\\"], [\\"cat\\", \\"act\\"], [\\"rat\\", \\"tar\\"]] assert group_anagrams([\\"listen\\", \\"silent\\", \\"enlist\\", \\"rat\\", \\"tar\\", \\"art\\"]) == [[\\"listen\\", \\"silent\\", \\"enlist\\"], [\\"rat\\", \\"tar\\", \\"art\\"]] assert group_anagrams([\\"abc\\", \\"bca\\", \\"cab\\", \\"xyz\\", \\"yzx\\", \\"zxy\\"]) == [[\\"abc\\", \\"bca\\", \\"cab\\"], [\\"xyz\\", \\"yzx\\", \\"zxy\\"]] ``` # Hint Consider sorting the characters of each word to form a key for grouping. Use a dictionary to collect groups of anagrams.","solution":"from collections import defaultdict from typing import List def group_anagrams(words: List[str]) -> List[List[str]]: anagrams = defaultdict(list) for word in words: # Sort the word to create a key sorted_word = \'\'.join(sorted(word)) # Append the original word to the list for this key anagrams[sorted_word].append(word) # Return the grouped anagrams as a list of lists return list(anagrams.values())"},{"question":"# Tuple Manipulation Create a class `TupleOperations` to perform various operations on tuples. Implement the following methods: 1. **Tuple Sum**: * Implement a method `tuple_sum` which takes a list of tuples, each containing the same number of numeric elements, and returns a single tuple where each element is the sum of the corresponding elements in the input tuples. * **Input**: A list of tuples, where each tuple contains numeric elements and all tuples have the same length. * **Output**: A single tuple where each element is the sum of the corresponding elements from the input tuples. 2. **Tuple Product with Scalar**: * Implement a method `tuple_product` that takes a tuple and a scalar value, and returns a new tuple where each element is the product of the corresponding element in the input tuple and the scalar. * **Input**: A tuple containing numeric elements and a scalar value. * **Output**: A new tuple where each element is the product of the corresponding element in the input tuple and the scalar. **Function Signatures**: ```python def tuple_sum(tuples: list[tuple[float]]) -> tuple[float]: ... def tuple_product(t: tuple[float], s: float) -> tuple[float]: ... ``` **Constraints**: 1. For tuple sum: - All tuples must have the same length. - Raise an exception if tuples have different lengths. 2. For tuple product: - The tuple must contain numeric values. - The scalar must be a numeric value. - Raise appropriate exceptions for type violations. **Example Usage**: ```python # Tuple Sum tuples = [(1.0, 2.0, 3.0), (4.0, 5.0, 6.0), (7.0, 8.0, 9.0)] result_sum = TupleOperations.tuple_sum(tuples) print(result_sum) # Output: (12.0, 15.0, 18.0) # Tuple Product with Scalar t = (1.0, 2.0, 3.0) scalar = 2.0 result_product = TupleOperations.tuple_product(t, scalar) print(result_product) # Output: (2.0, 4.0, 6.0) ```","solution":"class TupleOperations: @staticmethod def tuple_sum(tuples): if not tuples: return () length = len(tuples[0]) for t in tuples: if len(t) != length: raise ValueError(\\"All tuples must have the same length.\\") return tuple(sum(t) for t in zip(*tuples)) @staticmethod def tuple_product(t, s): if not isinstance(s, (int, float)): raise ValueError(\\"Scalar must be a numeric value.\\") for elem in t: if not isinstance(elem, (int, float)): raise ValueError(\\"All elements in the tuple must be numeric.\\") return tuple(elem * s for elem in t)"},{"question":"# Question: You are tasked with implementing a function that reads the contents of a file and counts the frequency of each word. The function should then save these frequencies to a new file in a specific format. Your solution should follow these steps: 1. Read the entire content of the input file. 2. Split the content into individual words (words are sequences of alphanumeric characters). 3. Count the frequency of each word, ignoring case (i.e., treat \'Word\' and \'word\' as the same). 4. Write the word frequencies to a new file, where each line contains a word and its frequency, separated by a space. The words should be in alphabetical order. Your function should handle possible errors such as file not found, read/write errors, and ensure all opened files are properly closed. Specifications: * **Function Name**: `word_frequency` * **Inputs**: - `input_file_path`: A string representing the path to the input file. - `output_file_path`: A string representing the path to the output file. * **Outputs**: - A string message indicating the success or failure of the operation. * **Constraints**: - The input file will be a plain text file. - The function must handle file not found, read/write errors gracefully. - The output file should be overwritten if it already exists. Example: ```python input_file_path = \\"example.txt\\" output_file_path = \\"word_count.txt\\" print(word_frequency(input_file_path, output_file_path)) # Expected output: \\"Word frequencies have been successfully written to word_count.txt\\" # The output file content would look something like this if the input file contains \\"Hello world hello\\": # hello 2 # world 1 ``` **Note**: Ensure your function is self-contained. Use appropriate data structures to store the word frequencies and make sure to handle case insensitivity effectively.","solution":"import re from collections import Counter def word_frequency(input_file_path, output_file_path): Reads the contents of an input file, counts the frequency of each word, and writes the word frequencies to an output file in alphabetical order. Args: input_file_path (str): Path to the input text file. output_file_path (str): Path to the output file where word frequencies will be saved. Returns: str: Message indicating the success or failure of the operation. try: # Read the entire content of the input file with open(input_file_path, \'r\') as file: content = file.read() # Split the content into words (alphanumeric characters) words = re.findall(r\'bw+b\', content.lower()) # Count the frequency of each word word_counts = Counter(words) # Write the word frequencies to the output file in alphabetical order with open(output_file_path, \'w\') as output_file: for word, count in sorted(word_counts.items()): output_file.write(f\'{word} {count}n\') return f\\"Word frequencies have been successfully written to {output_file_path}\\" except FileNotFoundError: return \\"Error: The input file was not found.\\" except IOError: return \\"Error: An I/O error occurred while processing the files.\\""},{"question":"# Challenging Coding Assessment Question Context Sorting algorithms are fundamental for solving various problems in computer science efficiently. Quicksort, in particular, is widely used due to its average-case time complexity of O(n log n). This question will task you with implementing this pivotal algorithm. Task Implement a function `quicksort(arr: List[int]) -> List[int]` that sorts a list of integers using the Quicksort algorithm. Follow the details and constraints provided below: Input and Output Formats: ```python def quicksort(arr: List[int]) -> List[int]: pass # Example usage: print(quicksort([3, 6, 8, 10, 1, 2, 1])) # Output: [1, 1, 2, 3, 6, 8, 10] print(quicksort([9, -3, 5, 2, 0, -6])) # Output: [-6, -3, 0, 2, 5, 9] ``` Constraints: * The input list may contain duplicate values. * The input list can have at most 10^5 elements. * Ensure your function executes efficiently to handle large lists within a reasonable timeframe. Requirements: 1. **Partitioning Strategy:** Implement the partitioning step crucial for Quicksort, ensuring an optimal pivot selection (can be first element, last element, or median). 2. **Recursive Sorting:** Utilize recursion to sort the subarrays derived from partitioning. 3. **Edge Cases:** Handle edge case inputs such as empty arrays and arrays with one element gracefully. Performance Goals: * The expected average-case time complexity of Quicksort is O(n log n). Strive to achieve this in your implementation. * Ensure in-place sorting to manage space efficiently, aiming for O(log n) auxiliary space due to recursive calls. Complete the `quicksort` function, adhering to the outlined specifications, and ensure it performs efficiently for all given constraints.","solution":"from typing import List def quicksort(arr: List[int]) -> List[int]: Sorts a list of integers using the Quicksort algorithm. if len(arr) <= 1: return arr pivot = arr[len(arr) // 2] # Optimally choosing the pivot as the middle element left = [x for x in arr if x < pivot] middle = [x for x in arr if x == pivot] right = [x for x in arr if x > pivot] return quicksort(left) + middle + quicksort(right)"},{"question":"# **Question: Implementing a Matrix Class with Special Arithmetic Operations** In this task, you are required to implement a custom `Matrix` class in Python that supports various matrix operations, including addition, subtraction, multiplication, and element-wise division. The goal is to make these operations intuitive using Python’s operator overloading. **Requirements:** 1. **Matrix Class Implementation**: - Implement a `Matrix` class with attributes for storing the matrix values. - The matrix should be stored as a list of lists, where each inner list represents a row. 2. **Operation Implementation**: - Define methods for matrix addition (`+`), subtraction (`-`), multiplication (`*`), and element-wise division (`/`). - Implement the following methods: - `__add__(self, other)`: Adds two matrices of the same dimensions. - `__sub__(self, other)`: Subtracts two matrices of the same dimensions. - `__mul__(self, other)`: Multiplies two matrices (dot product). - `__truediv__(self, other)`: Performs element-wise division of two matrices of the same dimensions. 3. **I/O Specifications**: - **Input**: - The matrices to be operated on can be specified as lists of lists. - Each matrix is expected to have consistent dimensions (all rows having the same number of columns). - **Output**: - Resultant matrices from each operation. **Constraints**: - Assume input matrices will be valid and have compatible dimensions for the specified operations. - The class should not use any third-party matrix manipulation libraries. Utilize built-in Python functionalities. # Example Usage: ```python # Instantiate two matrices matrix_a = Matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) matrix_b = Matrix([[9, 8, 7], [6, 5, 4], [3, 2, 1]]) # Perform matrix addition result_add = matrix_a + matrix_b print(result_add) # Perform matrix subtraction result_sub = matrix_a - matrix_b print(result_sub) # Perform matrix multiplication result_mul = matrix_a * matrix_b print(result_mul) # Perform element-wise division result_div = matrix_a / matrix_b print(result_div) ``` # Expected Output: For example, if you instantiate the matrices and perform listed operations, the program should output the following: ```python # Addition [[10, 10, 10], [10, 10, 10], [10, 10, 10]] # Subtraction [[-8, -6, -4], [-2, 0, 2], [4, 6, 8]] # Multiplication (Dot product) [[30, 24, 18], [84, 69, 54], [138, 114, 90]] # Element-wise Division [[0.1111111111111111, 0.25, 0.42857142857142855], [0.6666666666666666, 1.0, 1.5], [2.3333333333333335, 4.0, 9.0]] ``` In this example, ensure that your class performs matrix operations accurately while handling errors such as dimension mismatches gracefully. The `Matrix` class should provide intuitive and efficient methods for these operations.","solution":"class Matrix: def __init__(self, values): self.values = values def __add__(self, other): if self._dimensions != other._dimensions: raise ValueError(\\"Matrices must have the same dimensions to add\\") result = [[self.values[i][j] + other.values[i][j] for j in range(self._columns)] for i in range(self._rows)] return Matrix(result) def __sub__(self, other): if self._dimensions != other._dimensions: raise ValueError(\\"Matrices must have the same dimensions to subtract\\") result = [[self.values[i][j] - other.values[i][j] for j in range(self._columns)] for i in range(self._rows)] return Matrix(result) def __mul__(self, other): if self._columns != other._rows: raise ValueError(\\"Number of columns in first matrix must be equal to number of rows in second matrix to multiply\\") # Dot product result = [[sum(self.values[i][k] * other.values[k][j] for k in range(self._columns)) for j in range(other._columns)] for i in range(self._rows)] return Matrix(result) def __truediv__(self, other): if self._dimensions != other._dimensions: raise ValueError(\\"Matrices must have the same dimensions for element-wise division\\") result = [[self.values[i][j] / other.values[i][j] for j in range(self._columns)] for i in range(self._rows)] return Matrix(result) @property def _rows(self): return len(self.values) @property def _columns(self): return len(self.values[0]) @property def _dimensions(self): return (self._rows, self._columns) def __repr__(self): return f\\"Matrix({self.values})\\""},{"question":"# Coding Assessment Question Union-Find Data Structure Implementation Given a set of elements, your task is to implement a Union-Find data structure (also known as Disjoint-Set) with path compression and union by rank to manage the connected components dynamically. Function Signature: ```python class UnionFind: def __init__(self, n: int): pass def find(self, node: int) -> int: pass def union(self, node1: int, node2: int) -> None: pass def connected(self, node1: int, node2: int) -> bool: pass ``` Input: - `n`: The number of elements in the set (elements are indexed from 0 to n-1). - `node`, `node1`, `node2`: Integer indices representing elements of the set. Output: - `find`: Returns the representative (root) of the set containing the given element. - `union`: Joins the sets containing `node1` and `node2`. - `connected`: Returns `True` if `node1` and `node2` are in the same set, `False` otherwise. Constraints: - Ensure that `0 <= node, node1, node2 < n`. - Optimize for near-constant time `union` and `find` operations. Example: ```python uf = UnionFind(10) uf.union(1, 2) uf.union(2, 5) uf.union(5, 6) uf.union(6, 7) print(uf.connected(1, 7)) # Output should be True print(uf.connected(3, 7)) # Output should be False uf.union(3, 8) print(uf.connected(3, 8)) # Output should be True print(uf.find(7)) # Output should be 1 or another representative depending on the internals of the union operations print(uf.find(3)) # Output should be 3 or another representative depending on the internals of the union operations ``` Requirements: - Implement path compression in the `find` method to flatten the structure, ensuring that all nodes point directly to the representative. - Implement union by rank in the `union` method to attach the shorter tree under the root of the taller tree. - Handle edge cases such as duplicate unions or connected queries on elements not previously joined. Hints: - Initialize an array `parent` where `parent[i] = i` for each element `i`. - Maintain an array `rank` to keep track of the depth of each tree. - Ensure that the `find` method updates the parent pointers recursively to achieve full path compression. Good luck!","solution":"class UnionFind: def __init__(self, n: int): self.parent = list(range(n)) self.rank = [1] * n def find(self, node: int) -> int: if self.parent[node] != node: # Path compression self.parent[node] = self.find(self.parent[node]) return self.parent[node] def union(self, node1: int, node2: int) -> None: root1 = self.find(node1) root2 = self.find(node2) if root1 != root2: # Union by rank if self.rank[root1] > self.rank[root2]: self.parent[root2] = root1 elif self.rank[root1] < self.rank[root2]: self.parent[root1] = root2 else: self.parent[root2] = root1 self.rank[root1] += 1 def connected(self, node1: int, node2: int) -> bool: return self.find(node1) == self.find(node2)"},{"question":"# Task: Implement a function named `currency_conversion` to convert currency units. The function should support the following units: - USD (United States Dollar) - EUR (Euro) - GBP (British Pound) - JPY (Japanese Yen) - AUD (Australian Dollar) - CAD (Canadian Dollar) # Requirements: - The function should take three parameters: - `value` (float): the numeric value to convert. - `from_currency` (str): the currency unit of the input value. - `to_currency` (str): the currency unit of the desired output value. - The function should return the converted value as a float. # Constraint: - The function must handle different cases of currency codes (e.g., \'usd\', \'USD\', \'Usd\'). - If an invalid currency unit is provided, the function should raise a `ValueError` with a descriptive error message listing acceptable currency codes. - Use the following fixed conversion rates for this problem: - 1 USD = 0.85 EUR - 1 USD = 0.75 GBP - 1 USD = 110.0 JPY - 1 USD = 1.35 AUD - 1 USD = 1.25 CAD # Examples: ```python >>> currency_conversion(100, \'USD\', \'EUR\') 85.0 >>> currency_conversion(200, \'GBP\', \'JPY\') 29333.33 >>> currency_conversion(50, \'AUD\', \'CAD\') 46.30 >>> currency_conversion(500, \'invalid_currency\', \'CAD\') Traceback (most recent call last): ... ValueError: Invalid \'from_currency\' value: \'invalid_currency\'. Conversion currencies are: USD, EUR, GBP, JPY, AUD, CAD. ```","solution":"def currency_conversion(value, from_currency, to_currency): Converts a value from one currency to another using predefined conversion rates. :param value: numeric value to convert :param from_currency: the currency unit of the input value :param to_currency: the currency unit of the desired output value :return: converted value as a float :raises ValueError: if \'from_currency\' or \'to_currency\' are invalid currency codes rates = { \'USD\': 1.0, \'EUR\': 0.85, \'GBP\': 0.75, \'JPY\': 110.0, \'AUD\': 1.35, \'CAD\': 1.25 } valid_currencies = rates.keys() from_currency = from_currency.upper() to_currency = to_currency.upper() if from_currency not in valid_currencies: raise ValueError(f\\"Invalid \'from_currency\' value: \'{from_currency}\'. Conversion currencies are: {\', \'.join(valid_currencies)}.\\") if to_currency not in valid_currencies: raise ValueError(f\\"Invalid \'to_currency\' value: \'{to_currency}\'. Conversion currencies are: {\', \'.join(valid_currencies)}.\\") usd_value = value / rates[from_currency] converted_value = usd_value * rates[to_currency] return round(converted_value, 2)"},{"question":"# Question: In-Place Array Reversal with Multiple Constraints You have been tasked with implementing a function to reverse an input array in-place. However, this function must adhere to multiple constraints regarding the reversal. Specifically, you should only reverse the even-indexed elements of the array and leave the odd-indexed elements in their original order. # Function Signature ```python def reverse_even_indices(arr: list[int]) -> None: pass ``` # Input * `arr`: A list of integers to be partially reversed. The list will contain at least one element. # Output * This function should modify the `arr` list in-place. It does not return anything. # Constraints * The list should contain at most 1000 elements. * The elements of the list can be any integer within the range `-10^6` to `10^6`. # Example Example 1 ```python arr = [1, 2, 3, 4, 5, 6] reverse_even_indices(arr) assert arr == [5, 2, 3, 4, 1, 6] ``` Example 2 ```python arr = [10, 20, 30, 40, 50, 60, 70] reverse_even_indices(arr) assert arr == [70, 20, 50, 40, 30, 60, 10] ``` # Additional Information * Even-indexed elements mean elements at positions 0, 2, 4, etc. * The in-place nature of the function means altering the original array directly without using extra space that scales with the input size. * Ensure that only even-indexed elements are reversed, while the positions of odd-indexed elements remain unchanged.","solution":"def reverse_even_indices(arr: list[int]) -> None: Reverses the even-indexed elements of the list in-place. Odd-indexed elements remain in their original order. # Extracting even-indexed elements even_indexed_elements = [arr[i] for i in range(0, len(arr), 2)] # Reversing even-indexed elements even_indexed_elements.reverse() # Placing the reversed even-indexed elements back in the original array for i in range(0, len(arr), 2): arr[i] = even_indexed_elements.pop(0)"},{"question":"# Pixel Grid Validation and Transformation You are tasked with writing a function that validates and transforms a 2D grid of pixels represented as a nested list of strings. Each pixel can either be \\"0\\" (white) or \\"1\\" (black). The function will perform the following operations: 1. Validate the grid to ensure all rows have the same length and contain only the strings \\"0\\" or \\"1\\". 2. Count and return the number of black pixels (\\"1\\"). 3. Convert all white pixels (\\"0\\") surrounding each group of black pixels (\\"1\\") into a new character, \\"*\\", and return the transformed grid. # Core Concepts: - Nesting of lists. - String manipulation. - Grid validation. # Function Signature: ```python def validate_and_transform_pixel_grid(pixel_grid: list) -> tuple: pass ``` # Input: - A 2D nested list where each element is a string \\"0\\" or \\"1\\". # Outputs: - A tuple containing: 1. An integer: the count of black pixels. 2. A 2D nested list representing the transformed grid. # Operation Details: 1. **Validation**: - Ensure that the grid is not empty and is rectangular (all rows must have the same number of columns). - Each element must be either \\"0\\" or \\"1\\". - If any invalid data is found, raise a `ValueError` with an appropriate message. 2. **Transformation**: - For each bordering \\"0\\" pixel around a group of \\"1\\" pixels, convert it to \\"*\\". - Use 8-connectedness (horizontal, vertical, and diagonal neighbors). # Constraints: - The grid will be a list of lists, where each internal list represents a row. - The grid size will be at most 100x100. # Example: ```python pixel_grid = [ [\\"0\\", \\"0\\", \\"1\\", \\"0\\", \\"0\\"], [\\"0\\", \\"1\\", \\"1\\", \\"1\\", \\"0\\"], [\\"1\\", \\"1\\", \\"1\\", \\"1\\", \\"1\\"], [\\"0\\", \\"1\\", \\"1\\", \\"1\\", \\"0\\"], [\\"0\\", \\"0\\", \\"1\\", \\"0\\", \\"0\\"] ] result = validate_and_transform_pixel_grid(pixel_grid) # Expected Output: # (13, [ # [\\"*\\", \\"*\\", \\"1\\", \\"*\\", \\"*\\"], # [\\"*\\", \\"1\\", \\"1\\", \\"1\\", \\"*\\"], # [\\"1\\", \\"1\\", \\"1\\", \\"1\\", \\"1\\"], # [\\"*\\", \\"1\\", \\"1\\", \\"1\\", \\"*\\"], # [\\"*\\", \\"*\\", \\"1\\", \\"*\\", \\"*\\"] # ]) ``` # Notes: - Ensure the solution is efficient for grids up to the maximum size. - Provide clear and concise error messages for invalid input cases. - You may define helper functions within `validate_and_transform_pixel_grid()` to improve code readability and maintainability. Submit your implementation of `validate_and_transform_pixel_grid()` along with a few test cases demonstrating its correctness and efficiency.","solution":"def validate_and_transform_pixel_grid(pixel_grid): Validates and transforms a 2D grid of pixels. Parameters: pixel_grid (list): 2D list of strings (\\"0\\" or \\"1\\"). Returns: tuple: count of black pixels (\\"1\\") and transformed grid. # Validate the grid if not pixel_grid or not all(isinstance(row, list) for row in pixel_grid): raise ValueError(\\"Invalid grid: must be a non-empty 2D list.\\") num_cols = len(pixel_grid[0]) black_pixel_count = 0 for row in pixel_grid: if len(row) != num_cols: raise ValueError(\\"Invalid grid: all rows must have the same length.\\") if not all(pixel in (\\"0\\", \\"1\\") for pixel in row): raise ValueError(\\"Invalid grid: each element must be \'0\' or \'1\'.\\") black_pixel_count += row.count(\\"1\\") # Transform the grid def is_border_cell(x, y): if pixel_grid[x][y] != \\"0\\": return False directions = [ (-1, 0), (1, 0), (0, -1), (0, 1), (-1, -1), (1, 1), (-1, 1), (1, -1) ] for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < len(pixel_grid) and 0 <= ny < len(pixel_grid[0]) and pixel_grid[nx][ny] == \\"1\\": return True return False transformed_grid = [row[:] for row in pixel_grid] for i in range(len(pixel_grid)): for j in range(len(pixel_grid[0])): if is_border_cell(i, j): transformed_grid[i][j] = \\"*\\" return black_pixel_count, transformed_grid"},{"question":"# Coding Question Objective Write a function `find_missing_number` that identifies the missing number from a list of consecutive integers. The list contains all integers except one, and the function should find and return that missing integer. Function Signature ```python def find_missing_number(nums: list) -> int: pass ``` Input * `nums`: A list of integers. Output * An integer representing the missing number in the list. Constraints * The list `nums` contains `n` unique integers ranging from `1` to `n+1` (inclusive) with exactly one number missing. * The list can be of size `0 <= n <= 10^6`. Examples ```python >>> find_missing_number([1, 2, 4, 5, 6]) 3 >>> find_missing_number([1, 3, 4, 5]) 2 >>> find_missing_number([2, 3]) 1 >>> find_missing_number([]) 1 ``` Additional Requirements * The function should be optimized for performance with O(n) time complexity. * It should handle large lists efficiently. * The function should work without modifying the input list. * Ensure edge cases, such as very small or empty lists, are properly handled.","solution":"def find_missing_number(nums): Given a list of consecutive integers with exactly one missing number, this function finds the missing number. :param nums: List of integers :return: The missing integer n = len(nums) + 1 total_sum = (n * (n + 1)) // 2 current_sum = sum(nums) return total_sum - current_sum"},{"question":"# Bulb Distribution You are a lighting engineer, and you need to distribute a given number of identical bulbs across several specified rooms in such a way that the light intensity is balanced. Each room must have at least one bulb, and the distribution should minimize the difference between the rooms with the most and the fewest bulbs. # Function Signature: ```python def distribute_bulbs(num_bulbs: int, num_rooms: int) -> List[int]: pass ``` # Input: - `num_bulbs`: An integer representing the total number of bulbs. - `num_rooms`: An integer representing the total number of rooms. # Output: - A list of integers where each integer represents the number of bulbs in each room. # Constraints: - `1 ≤ num_bulbs ≤ 10^4` - `1 ≤ num_rooms ≤ 10^3` - `num_bulbs ≥ num_rooms` (each room must have at least one bulb) # Example: ```python num_bulbs = 10 num_rooms = 3 # Expected output could be: # [4, 3, 3] or [3, 3, 4] or [3, 4, 3] output_distribution = distribute_bulbs(num_bulbs, num_rooms) ``` # Explanation: 1. Each room needs at least one bulb. Therefore, after assigning one bulb to each room, the remaining bulbs should be distributed as evenly as possible. 2. The function should aim to minimize the difference in bulb count between the room with the most bulbs and the room with the fewest bulbs. 3. The result should be a list where the sum of the elements equals `num_bulbs` and the length of the list equals `num_rooms`. # Notes: - Consider edge cases where the number of bulbs and rooms are close to their constraints. - Optimize for simplicity and clarity in your implementation.","solution":"def distribute_bulbs(num_bulbs: int, num_rooms: int) -> list[int]: # Each room must have at least one bulb bulbs_distribution = [1] * num_rooms num_bulbs -= num_rooms # We already placed one bulb in each room # Distribute remaining bulbs as evenly as possible index = 0 while num_bulbs > 0: bulbs_distribution[index] += 1 num_bulbs -= 1 index = (index + 1) % num_rooms return bulbs_distribution"},{"question":"# Coding Question: Substring Anagram Finder You are given a text file `input.txt` that contains a string of lowercase letters and a target word. Your task is to write a Python function `find_anagram_substrings(file_path)` that reads the file, processes the string and the target word, and returns the starting indices of all substrings of the main string that are anagrams of the target word. Input: - `file_path` (string): The path to the `input.txt` file. Output: - Returns a list of integers representing the starting indices of anagram substrings. Constraints: - The length of the main string and the target word are both between 1 and 10^5. - Only lowercase English letters are used. - The input file format will always be two lines: the first line is the main string, and the second line is the target word. Example: If the `input.txt` contains: ``` abxaba ab ``` The function should return `[0, 3, 4]` (since substrings starting at indices 0, 3, and 4 are \\"ab\\", \\"ba\\", and \\"ab\\" respectively, which are all anagrams of \\"ab\\"). Notes: * An anagram of a word is a permutation of its letters. * Handle potential edge cases such as empty strings gracefully. * Optimize for large input sizes by using efficient algorithms. **Hint**: You can use a sliding window and character counting approach to achieve the desired efficiency. # Evaluation Criteria 1. **Correctness**: The function should return correct starting indices of anagram substrings. 2. **Efficiency**: The solution should handle large input sizes efficiently. 3. **Robustness**: The function should manage various edge cases and input inconsistencies gracefully. 4. **Clarity**: The code should be readable and well-commented. **Sample Implementation Skeleton**: ```python def find_anagram_substrings(file_path): from collections import Counter # Read file and process input try: with open(file_path, \'r\') as file: main_string = file.readline().strip() target_word = file.readline().strip() target_count = Counter(target_word) window_count = Counter(main_string[:len(target_word)]) result = [] # Check initial window if window_count == target_count: result.append(0) # Slide the window over the main string for i in range(1, len(main_string) - len(target_word) + 1): window_count[main_string[i - 1]] -= 1 # Remove char going out of the window if window_count[main_string[i - 1]] == 0: del window_count[main_string[i - 1]] window_count[main_string[i + len(target_word) - 1]] += 1 # Add char coming into the window if window_count == target_count: result.append(i) return result except Exception as e: print(f\\"An error occurred: {e}\\") return [] # Example usage: # print(find_anagram_substrings(\'path_to_input.txt\')) ```","solution":"def find_anagram_substrings(file_path): from collections import Counter # Read file and process input try: with open(file_path, \'r\') as file: main_string = file.readline().strip() target_word = file.readline().strip() if not main_string or not target_word: return [] target_length = len(target_word) main_length = len(main_string) if target_length > main_length: return [] target_count = Counter(target_word) window_count = Counter(main_string[:target_length]) result = [] # Check initial window if window_count == target_count: result.append(0) # Slide the window over the main string for i in range(1, main_length - target_length + 1): # Remove char going out of the window start_char = main_string[i - 1] window_count[start_char] -= 1 if window_count[start_char] == 0: del window_count[start_char] # Add char coming into the window end_char = main_string[i + target_length - 1] window_count[end_char] += 1 if window_count == target_count: result.append(i) return result except Exception as e: print(f\\"An error occurred: {e}\\") return []"},{"question":"# Implementing Breadth-First Search (BFS) in a Graph In this coding problem, you will implement the breadth-first search (BFS) algorithm to traverse a graph. You will also adapt the BFS traversal to determine the shortest path between two nodes in an unweighted graph. Problem Description You are given a graph represented by an adjacency list where each node is labeled by a unique integer. Your task is to write two functions - one to perform BFS traversal from a given starting node and another to find the shortest path between two nodes using BFS. Functions to Implement 1. **`bfs_traversal`**: ```python def bfs_traversal(graph: Dict[int, List[int]], start_node: int) -> List[int]: ``` - **Input Parameters**: - `graph`: A dictionary where each key is a node, and the corresponding value is a list of neighbor nodes. - `start_node`: The starting node for BFS traversal. - **Output**: - A list of nodes in the order they are visited in BFS traversal starting from `start_node`. 2. **`shortest_path_bfs`**: ```python def shortest_path_bfs(graph: Dict[int, List[int]], start_node: int, target_node: int) -> List[int]: ``` - **Input Parameters**: - `graph`: A dictionary where each key is a node, and the corresponding value is a list of neighbor nodes. - `start_node`: The starting node for the path search. - `target_node`: The target node for the path search. - **Output**: - Returns a list of nodes representing the shortest path from `start_node` to `target_node` using BFS. If no path exists, return an empty list. Constraints - The graph is unweighted, and all edges are bidirectional. - The `graph` dictionary will always contain valid nodes. - `start_node` and `target_node` will always be valid nodes in the graph. Example Usage 1. BFS traversal of a graph starting from node 0: ```python graph = { 0: [1, 2], 1: [0, 3, 4], 2: [0], 3: [1], 4: [1, 5], 5: [4] } traversal_result = bfs_traversal(graph, 0) print(traversal_result) # Example output: [0, 1, 2, 3, 4, 5] ``` 2. Finding the shortest path between node 0 and node 5: ```python path_result = shortest_path_bfs(graph, 0, 5) print(path_result) # Example output: [0, 1, 4, 5] ``` You must follow the given function signatures and provide a complete implementation for the problem described above.","solution":"from collections import deque from typing import Dict, List def bfs_traversal(graph: Dict[int, List[int]], start_node: int) -> List[int]: visited = set() traversal_order = [] queue = deque([start_node]) while queue: node = queue.popleft() if node not in visited: visited.add(node) traversal_order.append(node) for neighbor in graph[node]: if neighbor not in visited: queue.append(neighbor) return traversal_order def shortest_path_bfs(graph: Dict[int, List[int]], start_node: int, target_node: int) -> List[int]: if start_node == target_node: return [start_node] visited = set() queue = deque([(start_node, [start_node])]) while queue: current_node, path = queue.popleft() visited.add(current_node) for neighbor in graph[current_node]: if neighbor == target_node: return path + [neighbor] if neighbor not in visited: visited.add(neighbor) queue.append((neighbor, path + [neighbor])) return []"},{"question":"# Find the Missing Number In a Given Range In this task, you will demonstrate your ability to implement a simple yet crucial algorithmic problem: finding a missing number in a sequence. This exercise tests your understanding of basic arithmetic operations, loop constructs, and array manipulation. Objective Implement a function that finds and returns the missing number in a given list of integers that should form a continuous sequence within a specified range. Function Signature ```python def find_missing_number(nums: list[int], start: int, end: int) -> int: pass ``` Expected Input and Output * **Input**: * A list of integers, `nums`, containing all but one number from the range `start` to `end` inclusive, e.g., `[4, 5, 7, 8, 9]`. * Two integers, `start` and `end`, defining the inclusive range, e.g., `4` and `9`. * **Output**: * An integer representing the missing number in the range, e.g., `6` for the above input. Constraints * Each number in the range `start` to `end` (inclusive) appears exactly once in the list except for one missing number. * The range will contain at least two numbers, i.e., `end - start >= 1`. * The list can contain up to 1,000,000 elements. * Negative integers are allowed within the range. Performance Requirements * Time Complexity: O(n) * Space Complexity: O(1) Additional Requirements 1. Include error handling for cases where the list size does not match the expected size based on the range or if invalid inputs are provided. 2. Your function should handle edge cases such as high ranges efficiently. Example Code Ensure your solution passes the following test cases: ```python # Test cases assert find_missing_number([1, 2, 4, 5], 1, 5) == 3 assert find_missing_number([2, 3, 4, 6, 5, 7], 2, 7) == 6 assert find_missing_number([-3, -4, -6, -1, -2], -6, -1) == -5 assert find_missing_number([101, 102, 103, 105], 101, 105) == 104 assert find_missing_number([], 1, 2) == 1 # or it could be 2 depending on the definition, adjust constraints if needed ``` Context Finding a missing number in a sequence is a common problem faced in technical interviews and competitive programming. It solidifies the understanding of manipulating and iterating through arrays efficiently, and understanding basic number properties. This ensures that you are able to handle both foundational and performance considerations in algorithm implementation.","solution":"def find_missing_number(nums: list[int], start: int, end: int) -> int: Finds the missing number in a given sequence that should range from start to end inclusive. if len(nums) != (end - start): raise ValueError(\\"The length of nums is not correct for the given range.\\") total_sum = sum(range(start, end + 1)) actual_sum = sum(nums) return total_sum - actual_sum"},{"question":"# Problem Statement Given an array of integers, you need to determine the length of the longest increasing subsequence that can be obtained by deleting zero or more elements from the array without changing the order of the remaining elements. Two approaches to solve the problem are required: one with dynamic programming (without patience sorting) and one using patience sorting with binary search. # Function Signature ```python def longest_increasing_subsequence_dp(arr: list[int]) -> int: pass def longest_increasing_subsequence_patience(arr: list[int]) -> int: pass ``` **Input Format**: - `arr` (list of integers): A list of integers representing the array. **Output Format**: - Both functions should return an integer representing the length of the longest increasing subsequence. **Constraints**: - The number of elements in the array n is in the range [1, 10^4]. - Each element of the array arr[i] is an integer in the range [-10^9, 10^9]. # Example Usage ```python # Longest Increasing Subsequence Example arr = [10, 9, 2, 5, 3, 7, 101, 18] # Compute LIS using dynamic programming approach dp_result = longest_increasing_subsequence_dp(arr) print(dp_result) # Output should be 4 (The sequence [2, 3, 7, 18]) # Compute LIS using patience sorting approach patience_result = longest_increasing_subsequence_patience(arr) print(patience_result) # Output should be 4 (The sequence [2, 3, 7, 18]) ``` # Evaluation Criteria 1. Correctness: The solution should correctly compute the length of the longest increasing subsequence for given array inputs. 2. Efficiency: The dynamic programming solution should work within O(n^2) complexity, and the patience sorting solution should work within O(n log n) complexity. 3. Flexibility: Solutions should handle various inputs ranging from small arrays to large datasets. 4. Code Quality: The implementation should be well-structured, documented, and easy to follow.","solution":"def longest_increasing_subsequence_dp(arr: list[int]) -> int: if not arr: return 0 n = len(arr) dp = [1] * n for i in range(1, n): for j in range(i): if arr[i] > arr[j]: dp[i] = max(dp[i], dp[j] + 1) return max(dp) def longest_increasing_subsequence_patience(arr: list[int]) -> int: import bisect if not arr: return 0 tails = [] for num in arr: pos = bisect.bisect_left(tails, num) if pos < len(tails): tails[pos] = num else: tails.append(num) return len(tails)"},{"question":"# Problem: Reorganize Array Based on Frequency Given an array of integers, write a function to reorganize the array such that the integers appear in descending order of their frequencies. If multiple integers have the same frequency, they should appear in ascending order. Problem Statement Given an array `arr` containing `n` integers, write a function that rearranges the elements in descending order of their frequency. If two elements have the same frequency, the smaller element should come first. Implement the function `reorganize_by_frequency(arr: list[int]) -> list[int]`: * **Input**: A list of integers `arr` where (1 leq text{len}(arr) leq 10^5). * **Output**: A list of integers ordered by frequency and value as described. Example ```python >>> reorganize_by_frequency([1, 2, 3, 2, 4, 1, 1]) [1, 1, 1, 2, 2, 3, 4] >>> reorganize_by_frequency([5, 5, 5, 4, 4, 3, 2, 1]) [5, 5, 5, 4, 4, 1, 2, 3] >>> reorganize_by_frequency([1, 1, 1, 2, 2, 3, 3, 3, 4]) [1, 1, 1, 3, 3, 3, 2, 2, 4] ``` Guidelines * **Edge Cases**: Consider the case when the array is empty. * **Performance**: Efficiently use data structures to count frequencies and sort the array within the constraints.","solution":"from collections import Counter def reorganize_by_frequency(arr): Reorganizes the array elements in descending order of their frequency. If multiple elements have the same frequency, they appear in ascending order. if not arr: return [] # Count frequencies of each element frequency = Counter(arr) # Create a sorted list based on frequency (descending) and then by value (ascending) sorted_elements = sorted(arr, key=lambda x: (-frequency[x], x)) return sorted_elements"},{"question":"# Problem Statement Write a function `encode_rle` that implements the Run-Length Encoding (RLE) algorithm. The function should take a string as input and return its RLE encoding. In RLE, consecutive occurrences of the same character are replaced with the character followed by the number of occurrences. # Input * A string `input_str`, where 1 <= len(input_str) <= 10^6. # Output * A string representing the RLE-encoded version of `input_str`. # Constraints * The input string will only contain uppercase and lowercase English letters. # Example ```python encode_rle(\\"aaabbcc\\") # Returns \\"a3b2c2\\" encode_rle(\\"a\\") # Returns \\"a1\\" encode_rle(\\"abbb\\") # Returns \\"a1b3\\" encode_rle(\\"hhhhhhhhhh\\")# Returns \\"h10\\" ``` # Hints * Utilize a loop to traverse the string and count consecutive characters. * Consider edge cases where the string length is 1.","solution":"def encode_rle(input_str): Encodes the given string using Run-Length Encoding (RLE). Parameters: input_str (str): The input string to encode. Returns: str: The RLE encoded string. if not input_str: return \\"\\" encoded = [] count = 1 prev_char = input_str[0] for char in input_str[1:]: if char == prev_char: count += 1 else: encoded.append(f\\"{prev_char}{count}\\") prev_char = char count = 1 encoded.append(f\\"{prev_char}{count}\\") return \'\'.join(encoded)"},{"question":"# Problem Statement You are given an undirected graph represented as a dictionary where keys are node identifiers (integers) and values are lists of integers representing the nodes directly connected to the key node. Your task is to write a function that returns a list of all nodes that are reachable from a given starting node. The function should handle edge cases and validate inputs appropriately, using depth-first search (DFS). # Function Signature ```python def find_reachable_nodes(graph: dict, start_node: int) -> list: pass ``` # Inputs - `graph (dict)`: A dictionary representing an undirected graph. The dictionary keys are integers representing nodes, and the values are lists of integers representing the nodes directly connected to the key node. - `start_node (int)`: An integer representing the node from which to start the search. # Outputs - `reachable_nodes (list)`: A list of integers representing all nodes reachable from the `start_node`. The list should be sorted in ascending order. # Constraints 1. The `graph` dictionary can be empty. 2. If not empty, the `graph` dictionary can contain up to 10,000 nodes. 3. Each key (node) in the `graph` has a list of integers representing connected nodes; the connections are bidirectional. # Examples ```python # Example 1 graph = { 1: [2, 3], 2: [1, 4, 5], 3: [1], 4: [2], 5: [2]} start_node = 1 print(find_reachable_nodes(graph, start_node)) # Output: [1, 2, 3, 4, 5] # Example 2 graph = { 1: [2], 2: [1, 3], 3: [2]} start_node = 2 print(find_reachable_nodes(graph, start_node)) # Output: [1, 2, 3] # Example 3 graph = {} start_node = 0 print(find_reachable_nodes(graph, start_node)) # Output: ValueError: \\"graph cannot be empty\\" # Example 4 graph = { 1: [2, 3], 2: [1, 3], 3: [1, 2]} start_node = 4 print(find_reachable_nodes(graph, start_node)) # Output: ValueError: \\"start_node 4 is not present in the graph\\" ``` # Notes - Ensure your solution handles the case when `graph` is empty by raising a `ValueError` with the message \\"graph cannot be empty\\". - If the `start_node` does not exist in the `graph`, raise a `ValueError` with the message `start_node {start_node} is not present in the graph`. - This problem can be approached using a depth-first search (DFS). Focus on creating an efficient and clear implementation. - The `reachable_nodes` should be sorted before returning the result.","solution":"def find_reachable_nodes(graph: dict, start_node: int) -> list: Returns a list of all nodes that are reachable from the given `start_node` using DFS. The list is sorted in ascending order. Parameters: graph (dict): An undirected graph represented as a dictionary. start_node (int): The starting node for the search. Returns: list: A list of reachable nodes in ascending order. Raises: ValueError: If the graph is empty or the start_node is not in the graph. if not graph: raise ValueError(\\"graph cannot be empty\\") if start_node not in graph: raise ValueError(f\\"start_node {start_node} is not present in the graph\\") reachable_nodes = set() stack = [start_node] while stack: node = stack.pop() if node not in reachable_nodes: reachable_nodes.add(node) stack.extend([n for n in graph[node] if n not in reachable_nodes]) return sorted(reachable_nodes)"},{"question":"# Sorting Objects Based on Multiple Attributes Context: You are given a list of objects where each object has several attributes. You need to sort the objects based on multiple attributes in a specified order of priority. Problem Statement: Write a Python function `sort_objects(objects, sorting_order)` that takes as input a list of dictionaries representing the objects and a list of strings representing the sorting order of the attributes. The function should return the list of objects sorted according to the provided sorting order. Function Signature: ```python from typing import List, Dict def sort_objects(objects: List[Dict], sorting_order: List[str]) -> List[Dict]: pass ``` Input: - `objects`: A list of dictionaries representing the objects where each dictionary contains attributes and their respective values (e.g., `{\'name\': \'John\', \'age\': 25, \'score\': 90}`). - `sorting_order`: A list of strings representing the attributes by which the objects should be sorted, in order of priority. Output: - A list of dictionaries representing the objects sorted based on the provided sorting order of their attributes. Example: ```python objects = [ {\'name\': \'John\', \'age\': 25, \'score\': 90}, {\'name\': \'Alice\', \'age\': 30, \'score\': 85}, {\'name\': \'Bob\', \'age\': 22, \'score\': 95}, {\'name\': \'Alice\', \'age\': 25, \'score\': 88} ] sorting_order = [\'name\', \'age\'] # Objects sorted by \'name\' alphabetically and then by \'age\' in ascending order sorted_objects = sort_objects(objects, sorting_order) print(sorted_objects) # Output: # [ # {\'name\': \'Alice\', \'age\': 25, \'score\': 88}, # {\'name\': \'Alice\', \'age\': 30, \'score\': 85}, # {\'name\': \'Bob\', \'age\': 22, \'score\': 95}, # {\'name\': \'John\', \'age\': 25, \'score\': 90} # ] ``` Constraints: 1. The list of dictionaries can contain up to 10,000 objects. 2. Each dictionary will have the same set of keys, and the values can be assumed to be of the types that support comparison operations (e.g., integers, strings). 3. The \'sorting_order\' list will only contain valid keys that exist in the dictionaries. 4. Ensure the solution handles edge cases like empty lists or lists with objects having identical attribute values in the sorting order. Note: - Use Python\'s built-in sorting functions and facilities to handle the multi-attribute sorting efficiently. - Test the function with various configurations of objects and sorting orders to ensure accuracy and performance.","solution":"from typing import List, Dict def sort_objects(objects: List[Dict], sorting_order: List[str]) -> List[Dict]: return sorted(objects, key=lambda obj: tuple(obj[order] for order in sorting_order))"},{"question":"# Reverse Integer Problem You are given a 32-bit signed integer, `x`. Write a function to reverse `x` and return it. If reversing `x` causes the value to go outside the signed 32-bit integer range [-2<sup>31</sup>, 2<sup>31</sup> - 1], then return 0. Function Signature ```python def reverse_integer(x: int) -> int: ``` Input - `x` (int): A 32-bit signed integer. Output - Returns the reversed integer if it fits within the 32-bit signed integer range, otherwise returns 0. Constraints - The input integer `x` is guaranteed to be within the range of a 32-bit signed integer. Examples ```python # Example 1 assert reverse_integer(123) == 321 # Example 2 assert reverse_integer(-123) == -321 # Example 3 assert reverse_integer(120) == 21 # Example 4 assert reverse_integer(0) == 0 # Example 5 assert reverse_integer(1534236469) == 0 # Reversed integer exceeds 32-bit signed integer range # Example 6 assert reverse_integer(-2147483648) == 0 # Reversed integer exceeds 32-bit signed integer range ``` Detailed Explanation 1. **Understanding the Problem**: - Reverse the digits of the number while retaining the sign (`+` or `-`). - Ensure the reversed number fits within the 32-bit signed integer range. 2. **Algorithm**: - Check if the number is negative and handle the sign appropriately. - Reverse the digits of the number using string manipulation. - Convert the reversed string back to an integer. - Check if the reversed integer is within the 32-bit signed integer range. If not, return 0. 3. **Edge Cases**: - Handle cases where the reversal could lead to overflow. - Ensure reversing numbers such as `0`, `10`, and `-10` behave as expected. Provide a robust implementation of the function `reverse_integer` following these guidelines and ensuring that all edge cases are handled correctly.","solution":"def reverse_integer(x: int) -> int: Reverse the digits of the given 32-bit signed integer `x`. If the reversed integer overflows, returns 0. sign = -1 if x < 0 else 1 x = abs(x) reversed_x = int(str(x)[::-1]) * sign if reversed_x < -2**31 or reversed_x > 2**31 - 1: return 0 return reversed_x"},{"question":"# Problem Statement You are tasked with implementing a function to convert a given English sentence into Pig Latin. The rules for converting to Pig Latin are as follows: 1. For words that begin with a vowel (a, e, i, o, u), add \\"way\\" to the end of the word. - Example: \\"apple\\" becomes \\"appleway\\". 2. For words that begin with one or more consonants, move all the consonants that appear before the first vowel to the end of the word, then add \\"ay\\". - Example: \\"banana\\" becomes \\"ananabay\\". 3. If a word contains no vowels, treat it as if it begins with a consonant and simply add \\"ay\\" at the end. - Example: \\"rhythm\\" becomes \\"rhythmay\\". 4. Preserve the capitalization of the original words. Write a function `convert_to_pig_latin` that accepts a sentence and returns it converted to Pig Latin. # Function Specification **Function Name**: `convert_to_pig_latin` **Input**: * `sentence` (str): A sentence containing words to be converted. Each word is separated by spaces and consists of alphabet characters (a-z or A-Z). **Output**: * `pig_latin_sentence` (str): The input sentence converted to Pig Latin. # Example ```python >>> convert_to_pig_latin(\\"Hello world from Pig Latin\\") \'Ellohay orldway omfray Igpay Atinlay\' ``` # Constraints * The sentence will be non-empty and contain at least one word. * Words will consist of alphabetic characters only and will be separated by a single space. * No punctuation will be present in the input sentence. # Requirements * Ensure your solution handles edge cases such as words starting with a vowel or having no vowels. * The solution should maintain the original word capitalization in the output. * Do not use any built-in functions that directly perform the Pig Latin transformation. # Implementation Note Focus on splitting the input sentence into individual words, applying the conversion rules to each word, and then joining the words back into a single sentence. Be mindful of preserving the original capitalization.","solution":"def convert_to_pig_latin(sentence): def convert_word(word): vowels = \\"aeiouAEIOU\\" if word[0] in vowels: return word + \\"way\\" first_vowel_index = -1 for i, char in enumerate(word): if char in vowels: first_vowel_index = i break if first_vowel_index == -1: return word + \\"ay\\" # No vowels present in the word consonant_prefix = word[:first_vowel_index] rest_of_word = word[first_vowel_index:] converted_word = rest_of_word + consonant_prefix + \\"ay\\" if word[0].isupper(): converted_word = converted_word.capitalize() return converted_word words = sentence.split() pig_latin_words = [convert_word(word) for word in words] pig_latin_sentence = \\" \\".join(pig_latin_words) return pig_latin_sentence"},{"question":"# Implement a Function to Reverse Words in a String Write a function named `reverse_words` that takes in a string, where each word is separated by a single space, and returns a new string with the order of the words reversed. # Function Signature ```python def reverse_words(s: str) -> str: ``` # Parameters and Constraints - `s` is a non-empty string containing only alphabets and spaces. - Words in the input string are separated by a single space. - There will be no leading or trailing spaces. # Example ```python assert reverse_words(\\"hello world\\") == \\"world hello\\" assert reverse_words(\\"The quick brown fox\\") == \\"fox brown quick The\\" assert reverse_words(\\"a b c\\") == \\"c b a\\" assert reverse_words(\\"Practice makes perfect\\") == \\"perfect makes Practice\\" ``` # Additional Notes - The function should split the input string into words, reverse the order of the words, and join them back into a single string with a single space separating the words. - Do not use built-in functions that directly reverse the words. - Handle edge case scenarios such as single-word strings properly.","solution":"def reverse_words(s: str) -> str: Returns a new string with the order of the words in the input string reversed. Parameters: s (str): Input string with words separated by a single space. Returns: str: String with words order reversed. # Split the string into words words = s.split() # Reverse the order of words reversed_words = words[::-1] # Join the reversed words back into a single string reversed_string = \' \'.join(reversed_words) return reversed_string"},{"question":"# Your Task: You are required to implement a function that determines the minimum number of steps required to reduce a number to zero. The function must follow these rules: - If the current number is even, you divide it by 2. - If the current number is odd, you subtract 1 from it. Each operation (division or subtraction) counts as one step. Your task is to return the total number of steps needed to reduce the given number to zero. **Function Signature**: ```python def min_steps_to_zero(number: int) -> int: ``` **Input**: - An integer `number` where `0 <= number <= 10^6`. **Output**: - An integer representing the minimum number of steps required to reduce `number` to zero. **Constraints**: - The input `number` will be non-negative. **Example**: ```python >>> min_steps_to_zero(14) 6 >>> min_steps_to_zero(8) 4 >>> min_steps_to_zero(123) 12 ``` # Explanation: - For the number `14`, the function performs 6 steps: 14 → 7 → 6 → 3 → 2 → 1 → 0. - For the number `8`, the function performs 4 steps: 8 → 4 → 2 → 1 → 0. - For the number `123`, the function performs 12 steps: 123 → 122 → 61 → 60 → 30 → 15 → 14 → 7 → 6 → 3 → 2 → 1 → 0. Implement the function `min_steps_to_zero` to fulfill the requirements mentioned. Be sure to consider edge cases and performance characteristics in your implementation.","solution":"def min_steps_to_zero(number: int) -> int: steps = 0 while number > 0: if number % 2 == 0: number //= 2 else: number -= 1 steps += 1 return steps"},{"question":"# Question Write a Python function that checks if a given word can be typed using letters of only one row of a standard QWERTY keyboard. Implementation Details Create a function `can_type_with_one_row(word: str) -> bool` that returns `True` if the entire word can be typed using letters from only one row of a QWERTY keyboard, and `False` otherwise. Use the rows as they appear below: - First row: \\"QWERTYUIOP\\" (or \\"qwertyuiop\\") - Second row: \\"ASDFGHJKL\\" (or \\"asdfghjkl\\") - Third row: \\"ZXCVBNM\\" (or \\"zxcvbnm\\") Input * `word` (str): A string representing the word to be checked. Output * A boolean value `True` if the word can be typed using one keyboard row. Otherwise, return `False`. Constraints * The word should contain only alphabetic characters (upper or lower case). Example ```python >>> can_type_with_one_row(\\"Daddy\\") False >>> can_type_with_one_row(\\"Alaska\\") True >>> can_type_with_one_row(\\"Peace\\") False >>> can_type_with_one_row(\\"hello\\") False >>> can_type_with_one_row(\\"Zipper\\") True ``` Edge Cases - Empty string input should return `True` since it trivially meets the one-row condition. - Words with mixed case letters should still adhere to the one-row rule. **Hint**: Convert the word to a consistent case (either upper or lower) to simplify checking against the rows.","solution":"def can_type_with_one_row(word: str) -> bool: Check if a given word can be typed using letters of only one row of a standard QWERTY keyboard. # Keyboard rows row1 = set(\\"qwertyuiop\\") row2 = set(\\"asdfghjkl\\") row3 = set(\\"zxcvbnm\\") # Convert word to lowercase to simplify comparison word_set = set(word.lower()) # Check if the word letters (lowercase) are a subset of any of the rows return word_set <= row1 or word_set <= row2 or word_set <= row3"},{"question":"Problem Statement You need to implement a function that returns the number of prime numbers less than a given positive integer `n`. The function should be optimized for high-performance to handle very large values of `n`. # Function Signature ```python def count_primes(n: int) -> int: ``` # Input: - `n` (int): A positive integer. (Constraints: 0 ≤ n ≤ 10^7) # Output: - An integer representing the count of prime numbers less than `n`. # Example: ```python count_primes(10) # Output: 4 (because there are 4 primes less than 10: 2, 3, 5, 7) count_primes(25) # Output: 9 (because there are 9 primes less than 25: 2, 3, 5, 7, 11, 13, 17, 19, 23) count_primes(2) # Output: 0 (because there are no primes less than 2) ``` # Constraints: 1. n is a non-negative integer. 2. The function must run in O(n log log n) time using an efficient algorithm like the Sieve of Eratosthenes. # Detailed Requirements: 1. The function should return 0 if `n` is less than 2. 2. Utilize the Sieve of Eratosthenes to count the number of primes. 3. Ensure the solution is optimized for large values up to 10^7. # Additional Context: Prime number counting is a fundamental task in number theory and has numerous applications in cryptography, security algorithms, and mathematical research. The Sieve of Eratosthenes is a classic algorithm with a time complexity of O(n log log n) that efficiently finds all prime numbers up to a specified integer, making it suitable for this problem.","solution":"def count_primes(n: int) -> int: Returns the number of prime numbers less than a given positive integer n. if n < 2: return 0 is_prime = [True] * n is_prime[0] = is_prime[1] = False for start in range(2, int(n**0.5) + 1): if is_prime[start]: for multiple in range(start*start, n, start): is_prime[multiple] = False return sum(is_prime)"},{"question":"# Problem Description You are given a string expression composed of digits and the operators `+`, `-`, `*`, and `/` where each number can be a floating-point number. Your task is to evaluate this expression according to the operator precedence rules (multiplication and division before addition and subtraction) and return the result as a float. Assume that the expression is always valid. # Function Signature ```python def evaluate_expression(expression: str) -> float: pass ``` # Input - `expression` (str): A string representing a valid arithmetic expression. The numbers and operators are sequential without any spaces. # Output - float: The result of the evaluated expression. # Constraints - The length of the expression string will be at most 1000. - Operators are `+, -, *, /`. - Every operator and operand are valid and follow arithmetic rules. # Examples ```python assert evaluate_expression(\\"3+5*2\\") == 13.0 assert evaluate_expression(\\"10+2*6\\") == 22.0 assert evaluate_expression(\\"100*2+12\\") == 212.0 assert evaluate_expression(\\"100*(2+12)\\") == 1400.0 assert evaluate_expression(\\"100*(2+12)/14\\") == 100.0 ```","solution":"def evaluate_expression(expression: str) -> float: def apply_operator(operators, values): operator = operators.pop() right = values.pop() left = values.pop() if operator == \'+\': values.append(left + right) elif operator == \'-\': values.append(left - right) elif operator == \'*\': values.append(left * right) elif operator == \'/\': values.append(left / right) def precedence(op): if op in (\'+\', \'-\'): return 1 if op in (\'*\', \'/\'): return 2 return 0 values = [] operators = [] i = 0 while i < len(expression): if expression[i] == \' \': i += 1 continue if expression[i] == \'(\': operators.append(expression[i]) elif expression[i].isdigit() or expression[i] == \'.\': val = 0 decimal = False decimal_factor = 0.1 while (i < len(expression) and (expression[i].isdigit() or expression[i] == \'.\')): if expression[i] == \'.\': decimal = True elif decimal: val += int(expression[i]) * decimal_factor decimal_factor /= 10 else: val = (val * 10) + int(expression[i]) i += 1 values.append(val) i -= 1 elif expression[i] == \')\': while operators and operators[-1] != \'(\': apply_operator(operators, values) operators.pop() else: while (operators and precedence(operators[-1]) >= precedence(expression[i])): apply_operator(operators, values) operators.append(expression[i]) i += 1 while operators: apply_operator(operators, values) return values[0]"},{"question":"# Unique Factorial Digits Sum Context You\'re given an integer `n`, and you need to find the sum of the digits of the factorial of `n`. The factorial of a number `n`, denoted as `n!`, is the product of all positive integers less than or equal to `n`. As the values of factorials grow extremely large, calculating the sum of their digits presents a computational challenge. Task Write a function `sum_of_factorial_digits(n: int) -> int`, where `n` is a non-negative integer. The function should return the sum of all the digits of the factorial of `n`. Input * An integer `n` where `0 ≤ n ≤ 100`. Output * An integer representing the sum of the digits of the factorial of `n`. Constraints * Ensure your solution handles the large size of factorial results appropriately. Example For `n = 5`: ```plaintext sum_of_factorial_digits(5) => 3 ``` Explanation: * 5! = 120 * Sum of digits = 1 + 2 + 0 = 3 For `n = 10`: ```plaintext sum_of_factorial_digits(10) => 27 ``` Explanation: * 10! = 3,628,800 * Sum of digits = 3 + 6 + 2 + 8 + 8 + 0 + 0 = 27 Performance Requirements * Your solution should be efficient, given the potential size of the factorial values. Utilize libraries for handling large integers if necessary. Implementation Ensure careful consideration of computational efficiency and numerical handling in your implementation. ```python def sum_of_factorial_digits(n: int) -> int: Return the sum of the digits of the factorial of the given number n. from math import factorial # Calculate the factorial of n fact = factorial(n) # Convert factorial result to string to sum its digits return sum(int(digit) for digit in str(fact)) # Test the function print(sum_of_factorial_digits(5)) # Output: 3 print(sum_of_factorial_digits(10)) # Output: 27 ``` This question aligns with the style, complexity, and topics of similar coding assessments that challenge the understanding of large number manipulation and computational efficiency.","solution":"def sum_of_factorial_digits(n: int) -> int: Return the sum of the digits of the factorial of the given number n. from math import factorial # Calculate the factorial of n fact = factorial(n) # Convert factorial result to string to sum its digits return sum(int(digit) for digit in str(fact))"},{"question":"# Array Rotation and Search As a programming task, you need to implement and manipulate an array by rotating it and then performing specific search operations on the rotated array. 1. **Array Rotation**: Implement a function to rotate an array by `k` positions to the right. This means that the elements at the end of the array will wrap around to the beginning. 2. **Search in Rotated Array**: Develop a function that searches for a target value in the rotated array and returns its index. If the target is not found, return `-1`. # Input and Output Format * Implement two distinct functions: * `rotate_array(arr: List[int], k: int) -> List[int]`: Rotates the array `arr` by `k` positions. * `search_rotated_array(arr: List[int], target: int) -> int`: Searches for the `target` value in the rotated array and returns its index. If not found, return `-1`. # Constraints * The array will contain integers and will have at least one element. * The number of rotation positions `k` will be a non-negative integer. * Both functions should handle edge cases, such as empty arrays and large rotation values. # Examples ```python # Example usage: # Rotate the array arr = [1, 2, 3, 4, 5] k = 2 rotated_arr = rotate_array(arr, k) print(rotated_arr) # Output: [4, 5, 1, 2, 3] # Search in rotated array target = 3 index = search_rotated_array(rotated_arr, target) print(index) # Output: 2 # Edge case: empty array arr = [] k = 3 rotated_arr = rotate_array(arr, k) print(rotated_arr) # Output: [] # Edge case: target not found arr = [4, 5, 1, 2, 3] target = 6 index = search_rotated_array(arr, target) print(index) # Output: -1 ``` Implement the above functions, ensuring that the array is appropriately rotated and the search operation correctly identifies the target index or returns `-1` if the target is not found.","solution":"def rotate_array(arr, k): Rotates the array `arr` by `k` positions to the right. if not arr: return [] k %= len(arr) return arr[-k:] + arr[:-k] def search_rotated_array(arr, target): Searches for the `target` value in the rotated array `arr` and returns its index. If the target is not found, return `-1`. if not arr: return -1 left, right = 0, len(arr) - 1 while left <= right: mid = (left + right) // 2 if arr[mid] == target: return mid if arr[left] <= arr[mid]: # If the left part is sorted if arr[left] <= target < arr[mid]: right = mid - 1 else: left = mid + 1 else: # If the right part is sorted if arr[mid] < target <= arr[right]: left = mid + 1 else: right = mid - 1 return -1"},{"question":"# Implement a Priority Queue Using a Min-Heap **Context**: A priority queue is an abstract data type similar to a regular queue or stack data structure in which each element additionally contains a \\"priority\\" associated with it. In a priority queue, an element with high priority is served before an element with low priority. If two elements have the same priority, they are served according to their order in the queue. Your task is to implement a priority queue using a min-heap data structure. # Task: 1. **Heap Implementation**: Implement a min-heap data structure. 2. **Priority Queue Functions**: Implement functions for inserting an element with a given priority, accessing the element with the highest priority (smallest value), and extracting the element with the highest priority. # Inputs: - **operations**: A list of operations to be performed on the priority queue. - Each operation is a dictionary with two keys: - **type**: A string which can be either \\"insert\\", \\"peek\\", or \\"extract\\". - **value**: A tuple containing two elements (integer priority, value) for \\"insert\\" operations, and None for \\"peek\\" and \\"extract\\" operations. # Expected Output: - Print results of \\"peek\\" and \\"extract\\" operations. - For \\"insert\\" operations, the code should modify the min-heap accordingly but does not need to print anything. # Code Constraints: - Use lists to represent the heap structure. - Ensure that each operation runs in logarithmic time complexity. - Include meaningful comments and print statements for analysis and debug purposes. Here is the skeleton of the program you need to implement: ```python class MinHeap: def __init__(self): self.heap = [] def insert(self, element): self.heap.append(element) self._heapify_up(len(self.heap) - 1) def peek(self): if self.heap: return self.heap[0] return None def extract_min(self): if len(self.heap) < 1: return None root = self.heap[0] self.heap[0] = self.heap[-1] self.heap.pop() self._heapify_down(0) return root def _heapify_up(self, index): parent_index = (index - 1) // 2 if parent_index >= 0 and self.heap[index][0] < self.heap[parent_index][0]: self.heap[index], self.heap[parent_index] = self.heap[parent_index], self.heap[index] self._heapify_up(parent_index) def _heapify_down(self, index): smallest = index left_child_index = 2 * index + 1 right_child_index = 2 * index + 2 if (left_child_index < len(self.heap) and self.heap[left_child_index][0] < self.heap[smallest][0]): smallest = left_child_index if (right_child_index < len(self.heap) and self.heap[right_child_index][0] < self.heap[smallest][0]): smallest = right_child_index if smallest != index: self.heap[index], self.heap[smallest] = self.heap[smallest], self.heap[index] self._heapify_down(smallest) def process_operations(operations): pq = MinHeap() for operation in operations: op_type = operation[\'type\'] value = operation[\'value\'] if op_type == \'insert\': pq.insert(value) elif op_type == \'peek\': print(pq.peek()) elif op_type == \'extract\': print(pq.extract_min()) def main(): operations = [ {\'type\': \'insert\', \'value\': (2, \'cook dinner\')}, {\'type\': \'insert\', \'value\': (1, \'take out trash\')}, {\'type\': \'peek\', \'value\': None}, {\'type\': \'extract\', \'value\': None}, {\'type\': \'peek\', \'value\': None}, {\'type\': \'extract\', \'value\': None}, {\'type\': \'insert\', \'value\': (3, \'watch TV\')}, {\'type\': \'peek\', \'value\': None} ] process_operations(operations) if __name__ == \\"__main__\\": main() ``` # Evaluation - You will be evaluated on correctly implementing the min-heap structure. - Your priority queue must handle the given operations efficiently. - Clear and concise code with appropriate function naming and comments.","solution":"class MinHeap: def __init__(self): self.heap = [] def insert(self, element): self.heap.append(element) self._heapify_up(len(self.heap) - 1) def peek(self): if self.heap: return self.heap[0] return None def extract_min(self): if len(self.heap) < 1: return None root = self.heap[0] self.heap[0] = self.heap[-1] self.heap.pop() self._heapify_down(0) return root def _heapify_up(self, index): parent_index = (index - 1) // 2 if parent_index >= 0 and self.heap[index][0] < self.heap[parent_index][0]: self.heap[index], self.heap[parent_index] = self.heap[parent_index], self.heap[index] self._heapify_up(parent_index) def _heapify_down(self, index): smallest = index left_child_index = 2 * index + 1 right_child_index = 2 * index + 2 if (left_child_index < len(self.heap) and self.heap[left_child_index][0] < self.heap[smallest][0]): smallest = left_child_index if (right_child_index < len(self.heap) and self.heap[right_child_index][0] < self.heap[smallest][0]): smallest = right_child_index if smallest != index: self.heap[index], self.heap[smallest] = self.heap[smallest], self.heap[index] self._heapify_down(smallest) def process_operations(operations): pq = MinHeap() result = [] for operation in operations: op_type = operation[\'type\'] value = operation[\'value\'] if op_type == \'insert\': pq.insert(value) elif op_type == \'peek\': result.append(pq.peek()) elif op_type == \'extract\': result.append(pq.extract_min()) return result"},{"question":"Subarray with Maximum Sum Given an integer array `nums`, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum. You should use an **iterative approach** to solve this problem efficiently, leveraging the **Kadane’s Algorithm** to achieve the optimal solution. Input * A list of integers `nums` representing the array of numbers. Output * An integer which is the sum of the subarray with the maximum sum. Constraints * `1 <= len(nums) <= 10^5` * `-10^4 <= nums[i] <= 10^4` Example ```python >>> max_subarray_sum([1, -3, 2, 1, -1]) 3 >>> max_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) 6 >>> max_subarray_sum([5, 4, -1, 7, 8]) 23 >>> max_subarray_sum([-2, -3, -1]) -1 ``` Additional Notes Handle the edge cases such as: - When all elements are negative, the result should be the largest single element in the array. - Ensure the solution works efficiently within the given constraints.","solution":"def max_subarray_sum(nums): Finds the contiguous subarray with the largest sum using Kadane\'s Algorithm. Args: nums (list): List of integers. Returns: int: Sum of the subarray with the maximum sum. max_current = max_global = nums[0] for num in nums[1:]: max_current = max(num, max_current + num) if max_current > max_global: max_global = max_current return max_global"},{"question":"# Simulating a Simple TCP/IP Stack **Scenario**: A simplified version of the TCP/IP stack is required to be implemented in Python to better understand how network data is transmitted and received over a network. This helps in learning the fundamental concepts of Computer Networks and how data encapsulation and decapsulation work in a network. **Task**: 1. Implement the following function to simulate the sending of data packets using encapsulation in the TCP/IP model: ```python def send_data(data: str) -> str: Simulate the sending of data by encapsulating it in TCP/IP layers. Args: data (str): The data to be sent over the network. Returns: str: Encapsulated data formatted as \\"IP_Header TCP_Header Data\\". ``` 2. Implement the following function to simulate the receiving of data packets using decapsulation in the TCP/IP model: ```python def receive_data(packet: str) -> str: Simulate the receiving of data by decapsulating it from TCP/IP layers. Args: packet (str): The encapsulated data received over the network. Returns: str: The original data extracted after decapsulation. ``` **Constraints**: - Use fixed strings \\"IP_Header\\" and \\"TCP_Header\\" for simplicity in encapsulation. - Ensure the functions handle edge cases such as empty data, very short data, and different header sizes. - The send_data function should handle a maximum data length of up to 10^3 characters within a reasonable time. **Input Format**: - `data` (str): The input data string to be sent over the network. - `packet` (str): The encapsulated data as a string. **Output Format**: - Encapsulated output (str): The formatted string representing the encapsulated data. - Decapsulated output (str): The original data recovered from the encapsulated string. **Examples**: ```python data_to_send = \\"Hello, World!\\" packet = send_data(data_to_send) print(packet) # Expected \\"IP_Header TCP_Header Hello, World!\\" received_data = receive_data(packet) print(received_data) # Expected \\"Hello, World!\\" ``` **Note**: Thoroughly test your implementation, ensuring that encapsulation followed by decapsulation returns the original data consistently.","solution":"def send_data(data: str) -> str: Simulate the sending of data by encapsulating it in TCP/IP layers. Args: data (str): The data to be sent over the network. Returns: str: Encapsulated data formatted as \\"IP_Header TCP_Header Data\\". ip_header = \\"IP_Header\\" tcp_header = \\"TCP_Header\\" packet = f\\"{ip_header} {tcp_header} {data}\\" return packet def receive_data(packet: str) -> str: Simulate the receiving of data by decapsulating it from TCP/IP layers. Args: packet (str): The encapsulated data received over the network. Returns: str: The original data extracted after decapsulation. # Split the packet by spaces to separate headers from the data parts = packet.split(\' \', 2) # We use 2 to only split on the first two spaces if len(parts) == 3: _, _, data = parts return data else: return \\"\\""},{"question":"# Problem Statement You are designing a system for logging and monitoring sensor data in a factory. Each sensor produces data at regular intervals, and you need to store this data efficiently for quick retrieval and analysis. Your task is to implement a function `compress_reading_intervals` that compresses a list of data intervals by merging overlapping or continuous intervals. # Function Signature ```python def compress_reading_intervals(intervals: List[Tuple[int, int]]) -> List[Tuple[int, int]]: ``` # Input - `intervals` (List[Tuple[int, int]]): A list of tuples where each tuple represents an interval with start and end times in seconds. The intervals may not be sorted and may overlap. # Output - Returns a list of tuples representing non-overlapping and merged intervals sorted in ascending order by start time. # Constraints - All start and end times are non-negative integers. - Start time of an interval is always less than or equal to its end time. - The number of intervals does not exceed 10^4. # Example ```python >>> compress_reading_intervals([(1, 3), (2, 4), (5, 6), (7, 10), (8, 12)]) [(1, 4), (5, 6), (7, 12)] >>> compress_reading_intervals([(1, 2), (2, 3), (4, 5), (5, 6)]) [(1, 3), (4, 6)] >>> compress_reading_intervals([(10, 20), (15, 25), (27, 30)]) [(10, 25), (27, 30)] >>> compress_reading_intervals([(5, 8), (6, 10), (11, 12), (1, 2)]) [(1, 2), (5, 10), (11, 12)] ``` # Instructions 1. Implement the `compress_reading_intervals` function in the given signature. 2. Sort the intervals by start time. 3. Merge the overlapping intervals and return the resulting list. # Evaluation Criteria Your solution will be assessed based on: 1. Correct implementation of merging intervals. 2. Proper handling of edge cases. 3. Efficient and clean code adhering to the given constraints.","solution":"from typing import List, Tuple def compress_reading_intervals(intervals: List[Tuple[int, int]]) -> List[Tuple[int, int]]: # If the list is empty, return it directly if not intervals: return [] # First, sort the intervals based on the starting time intervals.sort(key=lambda x: x[0]) merged_intervals = [] current_start, current_end = intervals[0] for start, end in intervals[1:]: if start <= current_end: # There is an overlap current_end = max(current_end, end) else: merged_intervals.append((current_start, current_end)) current_start, current_end = start, end # Don\'t forget to append the last interval merged_intervals.append((current_start, current_end)) return merged_intervals"},{"question":"# Question You need to develop a functionality to process a large dataset of log entries efficiently. The task is to implement a system to identify and aggregate the counts of unique log messages. Objectives - Implement a `LogProcessor` class that can process log entries in an optimum manner. - The class should provide methods to add new log entries and retrieve counts of unique log messages. Input - A list of log entries: `List[str]`, where each log entry is a string. - Method call to add new log entry `add_log(log_entry: str)`. - Method call to get count for a specific log message `get_log_count(log_entry: str) -> int`. Output - Method `get_log_count` should return an integer representing the number of times the specific log message has been added. - If the log message is not present, return 0. Constraints - The number of log fragments added can be up to 10^6. - The length of each log entry can be up to 200 characters. - The log entries consist of printable ASCII characters. Example ```python # Example usage log_entries = [\\"error at module 1\\", \\"warning at module 2\\", \\"error at module 1\\", \\"warning at module 2\\", \\"info at module 3\\"] log_processor = LogProcessor(log_entries) log_processor.add_log(\\"error at module 1\\") log_processor.add_log(\\"critical at module 4\\") print(log_processor.get_log_count(\\"error at module 1\\")) # Expected: 3 print(log_processor.get_log_count(\\"warning at module 2\\")) # Expected: 2 print(log_processor.get_log_count(\\"info at module 3\\")) # Expected: 1 print(log_processor.get_log_count(\\"critical at module 4\\")) # Expected: 1 print(log_processor.get_log_count(\\"unknown\\")) # Expected: 0 ``` Requirements 1. Complete the implementation of the `LogProcessor` class. 2. Ensure that adding log entries and retrieving counts operate efficiently given the constraints. 3. Optimize both space and time complexity where possible. You are not required to modify the initialization interface, but you can design internal data structures and algorithms to meet the given requirements.","solution":"from collections import defaultdict class LogProcessor: def __init__(self, log_entries=None): self.log_counts = defaultdict(int) if log_entries: for log in log_entries: self.add_log(log) def add_log(self, log_entry: str): self.log_counts[log_entry] += 1 def get_log_count(self, log_entry: str) -> int: return self.log_counts.get(log_entry, 0)"},{"question":"# Problem Statement You have been assigned to implement a function that simplifies evaluating mathematical expressions with basic arithmetic operations. Your task is to write a function `evaluate_expression` that takes an arithmetic expression in string form and returns the evaluated result as a float. The expression can contain positive and negative numbers, and the operations: addition (`+`), subtraction (`-`), multiplication (`*`), division (`/`), and parentheses (`(` and `)`). Implement the function `evaluate_expression(expression: str) -> float` to achieve this. Input: - `expression`: str (a valid arithmetic expression composed of digits, operators `+`, `-`, `*`, `/`, `(`, and `)`, along with potential spaces) Output: - A float representing the evaluated result of the expression. Constraints: - The expression will be a valid, non-empty string. - The numbers can be integers or floating-point numbers. - Division by zero scenarios should be detected and corrected by raising a `ZeroDivisionError`. - The expression length will not exceed 1000 characters. # Examples: 1. `evaluate_expression(\\"2 + 3 * 4\\")` should return `14.0`. 2. `evaluate_expression(\\"(1 + 2) * 3 - 4 / 2\\")` should return `7.0`. 3. `evaluate_expression(\\"10 / 2 + 3 * (4 - 1)\\")` should return `13.0`. 4. `evaluate_expression(\\"3 + 4 * 2 / (1 - 5)^2\\")` should return `3.5`. # Notes: - Implement error handling to raise `ZeroDivisionError` if division by zero is attempted. - Ensure spaces in the expression are handled correctly and do not affect the outcome. - Parentheses should be used to enforce priority of calculation. ```python def evaluate_expression(expression: str) -> float: try: # The helper function handles parenthesis and passes the refined expression def parse_expression(expr): stack, num, sign = [], 0, 1 for i, char in enumerate(expr): if char.isdigit(): num = num * 10 + int(char) elif char in \'+-\': stack.append(sign * num) sign = 1 if char == \'+\' else -1 num = 0 elif char == \'(\': stack.append(sign) stack.append(\'(\') sign = 1 elif char == \')\': stack.append(sign * num) num = 0 total = 0 while stack[-1] != \'(\': total += stack.pop() stack.pop() # remove the \'(\' symbol total *= stack.pop() # apply the sign stack.append(total) elif char in \'*/\': if char == \'*\': num *= int(expression[i+1]) else: num /= int(expression[i+1]) return sum(stack) + sign * num # Remove spaces and evaluate the normalized expression expression = expression.replace(\' \', \'\') return float(parse_expression(expression)) except ZeroDivisionError: raise ZeroDivisionError(\\"Division by zero is not allowed.\\") except Exception as e: raise ValueError(\\"Invalid expression.\\") # Test the function with the provided examples print(evaluate_expression(\\"2 + 3 * 4\\")) # Output: 14.0 print(evaluate_expression(\\"(1 + 2) * 3 - 4 / 2\\")) # Output: 7.0 print(evaluate_expression(\\"10 / 2 + 3 * (4 - 1)\\")) # Output: 13.0 print(evaluate_expression(\\"3 + 4 * 2 / (1 - 5)^2\\")) # Output: 3.5 ```","solution":"def evaluate_expression(expression: str) -> float: try: # Replace the \'^\' operator with \'**\' for exponentiation (if used in tests) expression = expression.replace(\'^\', \'**\') # Evaluate the expression using eval result = eval(expression) return float(result) except ZeroDivisionError: raise ZeroDivisionError(\\"Division by zero is not allowed.\\") except SyntaxError: raise ValueError(\\"Invalid expression.\\") except Exception as e: raise ValueError(f\\"Error in expression evaluation: {e}\\")"},{"question":"# Coding Assessment Question Context In computer science, string manipulation and pattern matching are frequent tasks that often require efficient algorithms. One common problem is to check if two strings are anagrams of each other. An anagram is a rearrangement of the characters in one string to form another string. Task Write a Python function that checks if two given strings are anagrams of each other. The function should be case-insensitive and should ignore any non-alphanumeric characters. Function Signature ```python def are_anagrams(str1: str, str2: str) -> bool: pass ``` Input * Two strings, `str1` and `str2`, each with a maximum length of 10,000 characters. Output * A boolean value indicating whether the two strings are anagrams (`True`) or not (`False`). Example ```python print(are_anagrams(\\"Astronomer\\", \\"Moon starer\\")) # Output: True print(are_anagrams(\\"Hello, World!\\", \\"dlroW ,olleH!\\")) # Output: True print(are_anagrams(\\"Python\\", \\"typhon!\\")) # Output: True print(are_anagrams(\\"apple\\", \\"pale\\")) # Output: False ``` Constraints * The function should handle upper- and lower-case characters identically. * Ignore spaces, punctuation marks, and other non-alphanumeric characters during the comparison. * Efficiently handle the computation with respect to time and space. * Assume the strings contain valid Unicode characters. Notes * Use Python\'s `str` methods to preprocess the input strings. * Consider using data structures like dictionaries or counters for an efficient comparison. * Ensure the function performs well with the upper limit of string length.","solution":"import re from collections import Counter def are_anagrams(str1: str, str2: str) -> bool: Check if two strings are anagrams of each other. Args: str1 (str): The first string. str2 (str): The second string. Returns: bool: True if the strings are anagrams, False otherwise. # Remove non-alphanumeric characters and convert to lowercase cleaned_str1 = re.sub(r\'[^a-z0-9]\', \'\', str1.lower()) cleaned_str2 = re.sub(r\'[^a-z0-9]\', \'\', str2.lower()) # Use Counter to compare character frequencies return Counter(cleaned_str1) == Counter(cleaned_str2)"},{"question":"# Sum of Distinct Powers of Two Given a number `n`, write a function that returns a list of all possible sums of distinct powers of two that equal `n` using a backtracking approach. The function should return these sums in lexicographical order of the sets. Function Signature: ```python def powers_of_two_sum(n: int) -> list[list[int]]: pass ``` Input * `n` (int): A positive integer (1 <= n <= 1000). Output * A list of lists, where each sublist contains distinct powers of two that sum up to `n`. Constraints 1. Each element of the resulting sublists must be a distinct power of two. 2. The sum of the elements in each sublist must be exactly `n`. 3. The result should be sorted lexicographically. Example ```python assert powers_of_two_sum(10) == [[2, 8]] assert powers_of_two_sum(12) == [[4, 8]] assert powers_of_two_sum(1) == [[1]] assert powers_of_two_sum(5) == [[1, 4]] assert powers_of_two_sum(3) == [[1, 2]] ``` # Explanation * For the input `10`, the only combination of distinct powers of two that sum to `10` is `[2, 8]`. * For the input `12`, the result `[4, 8]` is the only valid combination. Implementation Steps 1. Generate all powers of two up to the largest possible power that does not exceed `n`. 2. Use a helper function to recursively build combinations of these powers that sum to `n`. 3. Ensure each combination contains distinct powers of two and collect these combinations. 4. Return the combinations sorted in lexicographical order.","solution":"def powers_of_two_sum(n: int) -> list[list[int]]: def backtrack(target, start, path, result): if target == 0: result.append(path[:]) return for i in range(start, len(powers)): if powers[i] > target: break path.append(powers[i]) backtrack(target - powers[i], i + 1, path, result) path.pop() powers = [] power = 1 while power <= n: powers.append(power) power *= 2 result = [] backtrack(n, 0, [], result) result.sort() return result"},{"question":"# Coding Assessment Question: Catalan Number Computation **Context**: Catalan numbers form a sequence of natural numbers that have various applications in combinatorial mathematics. The nth Catalan number is given by the formula: [ C(n) = frac{(2n)!}{(n+1)!n!} ] or recursively, [ C(0) = 1 ] [ C(n) = sum_{i=0}^{n-1} C(i) cdot C(n-i-1) ] # Problem Statement Your task is to implement the function `compute_catalan_number(n: int) -> int` that calculates the nth Catalan number. The function should efficiently compute the result, possibly using dynamic programming to avoid redundant calculations. # Function Specification * **Input**: * An integer `n` (0 <= n <= 10000) * **Output**: * The nth Catalan number as an integer. * **Constraints**: * Your implementation must efficiently handle large values of `n` up to 10,000. * You should raise a `TypeError` if `n` is not an integer. * You should raise a `ValueError` if `n` is negative. # Examples ```python >>> compute_catalan_number(0) 1 >>> compute_catalan_number(1) 1 >>> compute_catalan_number(2) 2 >>> compute_catalan_number(3) 5 >>> compute_catalan_number(4) 14 >>> compute_catalan_number(10) 16796 >>> compute_catalan_number(10000) <large_number> # correct value for this large index >>> compute_catalan_number(-1) Traceback (most recent call last): ... ValueError: n must be a non-negative integer. >>> compute_catalan_number(2.5) Traceback (most recent call last): ... TypeError: n must be an integer. ``` # Guidelines * Use dynamic programming to optimize your Catalan number function. * Ensure that your function is efficient and can handle the maximum input constraint within a reasonable time frame. * Properly handle edge cases by raising the appropriate exceptions for invalid inputs.","solution":"def compute_catalan_number(n): Compute the nth Catalan number. Args: n (int): the index of the Catalan number to compute Returns: int: the nth Catalan number Raises: TypeError: if `n` is not an integer ValueError: if `n` is negative if not isinstance(n, int): raise TypeError(\\"n must be an integer.\\") if n < 0: raise ValueError(\\"n must be a non-negative integer.\\") if n == 0: return 1 # Initialize a list to store computed Catalan numbers catalan = [0] * (n + 1) catalan[0] = 1 for i in range(1, n + 1): for j in range(i): catalan[i] += catalan[j] * catalan[i - 1 - j] return catalan[n]"},{"question":"# Coding Assessment Question Scenario In many systems, it\'s essential to determine whether certain processes overlap in terms of their execution schedules. You are provided with data on the start and end times of various processes and need to check for any overlaps among these timings. Problem Statement Implement a function `check_process_overlap` that takes a list of tuples where each tuple contains two integers representing the start and end times of a process. The function should return a boolean value indicating whether any two processes overlap. Function Signature ```python def check_process_overlap(processes: list[tuple[int, int]]) -> bool: Determines if there are any overlapping process timings in the given list. :param processes: List of tuples, where each tuple contains two integers, the start and end times of a process. :return: True if any two processes overlap, otherwise False. Example Usage: >>> processes = [(1, 5), (6, 10), (5, 7)] >>> check_process_overlap(processes) False >>> processes = [(1, 5), (4, 10), (8, 12)] >>> check_process_overlap(processes) True ``` Requirements 1. **Sorting and Comparison**: Efficiently sort and compare the start and end times of processes to determine any overlaps. 2. **Validation**: Ensure the function handles edge cases such as empty lists or processes with invalid time intervals (where the start time is greater than the end time). 3. **Error Handling**: Consider invalid input scenarios, such as ensuring all tuples are well-formed with integer values. Constraints * The list `processes` will contain between 0 and 10^6 tuples. * Each tuple `(start, end)` will contain integers where `0 <= start, end <= 10^9`. * The start time will always be less than or equal to the end time. Performance Requirement * Ensure your implementation can handle these constraints efficiently in terms of both time and space. The ideal solution should operate in O(n log n) time complexity.","solution":"def check_process_overlap(processes): Determines if there are any overlapping process timings in the given list. :param processes: List of tuples, where each tuple contains two integers, the start and end times of a process. :return: True if any two processes overlap, otherwise False. # Sort the processes by their start times sorted_processes = sorted(processes, key=lambda x: x[0]) # Iterate through the list and check for overlaps for i in range(len(sorted_processes) - 1): current_end = sorted_processes[i][1] next_start = sorted_processes[i + 1][0] # Check if current process overlaps with the next if current_end > next_start: return True return False"},{"question":"# Question: Image Compression Rank Analysis Given a set of images, each represented as a 2D matrix of pixel intensity values (grayscale values ranging from 0 to 255), implement the function `find_rank_of_compression` which calculates the smallest rank for which the compressed rank-k approximation matrix\'s Frobenius norm is no more than a specified percentage of the original matrix\'s Frobenius norm. In numerical linear algebra, the Frobenius norm of a matrix A, denoted as ||A||_F, is defined as the square root of the sum of the absolute squares of its elements. Function Signature ```python def find_rank_of_compression(image: list[list[int]], threshold_percentage: float) -> int: ``` Parameters - `image`: list of list of int - A 2D matrix representing the image where each element is an integer between 0 and 255 inclusive. - `threshold_percentage`: float - The maximum allowable percentage of the Frobenius norm for the compressed image in terms of the original image\'s Frobenius norm. Returns - `int`: The smallest rank ( k ) such that the Frobenius norm of the rank-k approximation is no more than `threshold_percentage` of the Frobenius norm of the original matrix. Constraints 1. The dimensions of `image` will be ( 1 times 1 ) to ( 1000 times 1000 ). 2. Each element in `image` is an integer ( 0 leq text{pixel intensity} leq 255 ). 3. ( 0 < text{threshold_percentage} leq 100 ). Examples ```python # Example 1 image = [ [255, 0, 0], [0, 255, 0], [0, 0, 255] ] threshold_percentage = 50.0 print(find_rank_of_compression(image, threshold_percentage)) # Expected Output: 2 # Example 2 image = [ [255, 200, 150], [200, 255, 200], [150, 200, 255] ] threshold_percentage = 80.0 print(find_rank_of_compression(image, threshold_percentage)) # Expected Output: 1 ``` Note: * The Frobenius norm of an approximate rank-k matrix can be derived using Singular Value Decomposition (SVD). * Efficient computation and matrix handling techniques should be considered for large matrices.","solution":"import numpy as np def find_rank_of_compression(image, threshold_percentage): Calculate the smallest rank for which the compressed rank-k approximation matrix\'s Frobenius norm is no more than a specified percentage of the original matrix\'s Frobenius norm. Parameters: image (list of list of int): 2D matrix representing the image. threshold_percentage (float): Maximum allowable percentage of the Frobenius norm for the compressed image. Returns: int: The smallest rank k. matrix = np.array(image) original_fro_norm = np.linalg.norm(matrix, \'fro\') # Perform Singular Value Decomposition U, S, Vt = np.linalg.svd(matrix, full_matrices=False) cumulative_energy = 0 required_energy = (threshold_percentage / 100) * (original_fro_norm ** 2) for k in range(len(S)): cumulative_energy += S[k] ** 2 if cumulative_energy >= required_energy: return k + 1 return len(S)"},{"question":"# Problem: Image Filter Application Your task is to create an image filter application that applies various filters to images represented as 2D lists of integers. Each integer in the list represents a pixel\'s grayscale value (ranging from 0 to 255). The goal is to implement functions for a set of predefined filters, each altering the pixel values based on specified algorithms. Task Requirements: 1. **Function Signature**: - Implement functions corresponding to each of the following filters: * Inversion * Brightness Adjustment * Contrast Adjustment * Blur * Edge Detection - The function names should be prefixed with `apply_` followed by the filter name (e.g., `apply_inversion`). 2. **Input and Output**: - Each function should accept a 2D list (list of lists) of integers representing the image and additional parameters relevant to the filter (if any). - Each function should return a 2D list of integers representing the filtered image. - If invalid pixel values are provided (e.g., not in the range [0, 255]), the function should raise a `ValueError` with an appropriate message. 3. **Constraints**: - All pixel values must be integers within the range [0, 255]. - The 2D list must not be empty and must be rectangular (all rows have the same length). 4. **Performance Requirements**: - Ensure that the functions run efficiently by minimizing redundant computations. Example Functions: 1. **Inversion Filter** ```python def apply_inversion(image: list[list[int]]) -> list[list[int]]: for row in image: if any(pixel < 0 or pixel > 255 for pixel in row): raise ValueError(\\"apply_inversion() only accepts pixel values between 0 and 255\\") return [[255 - pixel for pixel in row] for row in image] ``` 2. **Brightness Adjustment Filter** ```python def apply_brightness_adjustment(image: list[list[int]], adjustment: int) -> list[list[int]]: for row in image: if any(pixel < 0 or pixel > 255 for pixel in row): raise ValueError(\\"apply_brightness_adjustment() only accepts pixel values between 0 and 255\\") return [[min(255, max(0, pixel + adjustment)) for pixel in row] for row in image] ``` Test Your Functions: Ensure to cover the following cases in your tests: - Typical valid inputs showing correct application of filters. - Boundary inputs like maximum and minimum pixel values. - Invalid inputs like pixel values outside [0, 255] raising appropriate errors. Provide at least one test example for each filter function in the form of `assert` statements to validate their behavior. Here are some example test cases: ```python # Test for apply_inversion image = [ [0, 128, 255], [64, 192, 128] ] expected_inverted_image = [ [255, 127, 0], [191, 63, 127] ] assert apply_inversion(image) == expected_inverted_image # Test for apply_brightness_adjustment brightness_adjustment = 50 expected_brightness_adjusted_image = [ [50, 178, 255], [114, 242, 178] ] assert apply_brightness_adjustment(image, brightness_adjustment) == expected_brightness_adjusted_image ```","solution":"def apply_inversion(image): for row in image: if any(pixel < 0 or pixel > 255 for pixel in row): raise ValueError(\\"apply_inversion() only accepts pixel values between 0 and 255\\") return [[255 - pixel for pixel in row] for row in image] def apply_brightness_adjustment(image, adjustment): for row in image: if any(pixel < 0 or pixel > 255 for pixel in row): raise ValueError(\\"apply_brightness_adjustment() only accepts pixel values between 0 and 255\\") return [[min(255, max(0, pixel + adjustment)) for pixel in row] for row in image]"},{"question":"Binary Search Algorithm Implement the binary search algorithm to find the position of a target value within a sorted array of integers. The function should efficiently locate the target using the divide-and-conquer approach inherent in binary search. Input * **arr**: List of integers representing the sorted array in non-decreasing order. * **target**: Integer representing the value to search for within `arr`. Output * Return an integer representing the index of `target` in `arr`. If `target` is not present in `arr`, return `-1`. # Constraints 1. `1 <= len(arr) <= 10^5` 2. `-10^6 <= arr[i] <= 10^6` for every valid index `i` 3. `-10^6 <= target <= 10^6` # Examples ```python print(binary_search([1, 3, 5, 7, 9], 5)) # Outputs: 2 print(binary_search([2, 4, 6, 8, 10], 7)) # Outputs: -1 print(binary_search([-5, -3, 0, 3, 5], 0)) # Outputs: 2 ``` # Notes * Ensure your binary search implementation runs in O(log n) time complexity. * Consider edge cases such as an empty array and arrays with duplicate values. * Your implementation should handle both positive and negative values within the array robustly. # Function Signature ```python def binary_search(arr: list, target: int) -> int: # You need to implement this function ``` # Context Binary search is an essential algorithm in computer science for search operations within sorted data structures. This problem will test your understanding of binary search mechanics, edge case handling, and efficiency in algorithm design.","solution":"def binary_search(arr, target): Perform a binary search for the target within the sorted array arr. left, right = 0, len(arr) - 1 while left <= right: mid = (left + right) // 2 if arr[mid] == target: return mid elif arr[mid] < target: left = mid + 1 else: right = mid - 1 return -1"},{"question":"# Coding Assessment Question: Perfect Square Identifier Context You need to identify and return a list of numbers that are perfect squares from a given list of integers. A perfect square is an integer that is the square of another integer. Task Write a function `find_perfect_squares(numbers: list[int]) -> list[int]` that takes a list of integers as input and returns a list of integers that are perfect squares. Input * `numbers`: A list of integers. Output * Returns a list of integers from the input list that are perfect squares. Constraints 1. The input list can contain both positive and negative integers. 2. Your function should ensure that no duplicates are included in the output list. 3. Consider performance aspects and try to make your solution as efficient as possible. Example ```python find_perfect_squares([1, 4, 9, 16, 2, 3, 5, 10, 20]) ``` **Expected Output**: ```python [1, 4, 9, 16] ``` Additional Examples ```python find_perfect_squares([25, -25, 36, 49, 50, 64, 100]) ``` **Expected Output**: ```python [25, 36, 49, 64, 100] find_perfect_squares([0, -1, -4, 1, 4, 9, 10, 11, 15]) ``` **Expected Output**: ```python [0, 1, 4, 9] find_perfect_squares([-9, -16, 10, 15, 20, -25]) # Since negative numbers cannot be perfect squares, negative values are ignored. ``` **Expected Output**: ```python [] ``` Notes 1. Ensure to validate the list of integers and eliminate any non-integer types if necessary. 2. Edge cases such as including zero as a perfect square should be handled correctly. 3. Optimize the function for performance, especially when dealing with large lists. Analysis - Input Length: Typically large lists. - Input Bounds: Both positive and negative integers. - Expected Output: A unique list of perfect squares confirmed by integer tests.","solution":"import math def find_perfect_squares(numbers): Returns a list of unique perfect squares from the input list. perfect_squares = set() for num in numbers: if num >= 0: # only non-negative numbers can be perfect squares root = int(math.isqrt(num)) if root * root == num: perfect_squares.add(num) return sorted(perfect_squares)"},{"question":"# Zero-Sum Subarray Problem Statement As part of a data analysis team, you are working with a large dataset and need to identify subarrays that sum up to zero. A subarray is any contiguous part of the array, including the entire array itself. Task Implement the function `find_zero_sum_subarray(arr: List[int]) -> bool` that determines whether there exists at least one subarray whose sum is zero. Input - `arr`: A list of integers which may contain both positive and negative numbers. Output - Returns a boolean value `True` if there exists at least one subarray with sum zero, otherwise `False`. Constraints - 1 ≤ length of array ≤ 100000 - -100000 ≤ element value in array ≤ 100000 Example ```python arr = [4, 2, -3, 1, 6] print(find_zero_sum_subarray(arr)) # Output: True (because the subarray [-3, 1, 2] sums to zero) arr = [4, 2, 0, 1, 6] print(find_zero_sum_subarray(arr)) # Output: True (because the subarray [0] sums to zero) arr = [-3, 2, 3, 1, 6] print(find_zero_sum_subarray(arr)) # Output: False (because no subarray sums to zero) ``` Note - A subarray of an array is a sequence of continuous elements. - Consider edge cases, such as arrays with only one element or arrays where a single element can form the zero-sum subarray.","solution":"from typing import List def find_zero_sum_subarray(arr: List[int]) -> bool: Determines whether there exists at least one subarray with sum zero. sum_set = set() current_sum = 0 for num in arr: current_sum += num if current_sum == 0 or current_sum in sum_set: return True sum_set.add(current_sum) return False"},{"question":"# Question: Find Missing Number in Consecutive Sequence You are given a list of unique positive integers that form a sequence of consecutive numbers, but with one number missing. Your task is to find the missing number using a mathematical formula for the sum of an arithmetic sequence. Function Signature: ```python def find_missing_number(sequence: List[int]) -> int: ``` Input: - `sequence` (List[int]): A list containing unique positive integers forming a sequence with one number missing. Output: - (int): Returns the missing number from the sequence. Constraints: 1. The list will always contain at least two numbers. 2. The missing number will always be somewhere within the range of the given sequence (i.e., not at the beginning or the end). Example Usage: ```python assert find_missing_number([1, 2, 4, 5]) == 3 assert find_missing_number([10, 11, 12, 14]) == 13 assert find_missing_number([20, 21, 23]) == 22 assert find_missing_number([100, 101, 102, 103, 105]) == 104 ``` Additional Notes: - Ensure to use the sum formula for an arithmetic sequence to determine the missing number to avoid iterating over the list multiple times. - If the input is not a list of integers, raise a `TypeError` with a message indicating the expected type. This question checks your understanding of arithmetic sequences, sum formula, and basic handling of list operations in Python.","solution":"from typing import List def find_missing_number(sequence: List[int]) -> int: Returns the missing number in the given sequence of consecutive numbers. if not all(isinstance(i, int) and i > 0 for i in sequence): raise TypeError(\\"sequence must be a list of unique positive integers.\\") n = len(sequence) + 1 start, end = min(sequence), max(sequence) # Sum of arithmetic sequence formula: n * (first_element + last_element) // 2 expected_sum = n * (start + end) // 2 actual_sum = sum(sequence) return expected_sum - actual_sum"},{"question":"# Question: Social Network Connection Finder You are tasked with developing a function that determines the shortest chain of connections (friend-of-a-friend relationships) between two users in a social network. The social network is represented as a graph where each node is a user and edges represent friendships. Your task is to implement the function `shortest_connection_path` that employs the Breadth-First Search (BFS) algorithm to find the shortest path of connections between two users. Function Signature ```python def shortest_connection_path(network: dict, user_a: str, user_b: str) -> list[str]: Args: network (dict): A dictionary where each key is a user and the value is a list of friends (users connected to the key user). user_a (str): The user from whom the connection path starts. user_b (str): The user to whom the connection path leads. Returns: list[str]: A list of users representing the shortest path of connections from user_a to user_b. If no path exists, return an empty list. ``` Example ```python social_network = { \\"Alice\\": [\\"Bob\\", \\"Claire\\"], \\"Bob\\": [\\"Alice\\", \\"Dante\\"], \\"Claire\\": [\\"Alice\\", \\"Emily\\"], \\"Dante\\": [\\"Bob\\"], \\"Emily\\": [\\"Claire\\", \\"Frank\\"], \\"Frank\\": [\\"Emily\\"], } print(shortest_connection_path(social_network, \\"Alice\\", \\"Frank\\")) # Output: [\'Alice\', \'Claire\', \'Emily\', \'Frank\'] print(shortest_connection_path(social_network, \\"Bob\\", \\"Emily\\")) # Output: [\'Bob\', \'Alice\', \'Claire\', \'Emily\'] print(shortest_connection_path(social_network, \\"Alice\\", \\"Alice\\")) # Output: [\'Alice\'] print(shortest_connection_path(social_network, \\"Alice\\", \\"Unknown\\")) # Output: [] ``` Constraints - User names are non-empty strings. - The network is undirected (friendship is mutual). - The user_a and user_b strings may or may not be present in the network. - If both user_a and user_b are the same, return a list containing just user_a. - Assume there are no self-loops in the graph. Notes - Handle edge cases appropriately, such as absent users in the network or no possible connection paths. - Optimize your solution to efficiently handle networks with up to 1000 users. - Ensure your implementation returns the shortest connection path accurately by using the BFS algorithm.","solution":"from collections import deque def shortest_connection_path(network, user_a, user_b): Returns the shortest path of connections from user_a to user_b using BFS. If no path exists, returns an empty list. if user_a not in network or user_b not in network: return [] if user_a == user_b: return [user_a] visited = set() queue = deque([(user_a, [user_a])]) while queue: current_user, path = queue.popleft() if current_user == user_b: return path visited.add(current_user) for friend in network.get(current_user, []): if friend not in visited: queue.append((friend, path + [friend])) return []"},{"question":"**Task**: Create and validate a router simulator that handles network packet routing based on a given set of rules. # Scenario You are designing a network utility for simulating packet routing through a network. The utility needs to process packets based on specific routing rules and return the expected outcomes. Each packet contains destination and size details, and each rule specifies the handling behavior for certain destination patterns with maximum load constraints. # Implementation Write a function called `router_simulator` with the following signature: ```python def router_simulator(packets: list, rules: list) -> list: Simulates the routing of packets through a network based on routing rules. Parameters: - packets (list): A list of packets, where each packet is represented as a tuple (destination, size). - rules (list): A list of routing rules, where each rule is a tuple: - (pattern, max_load, action) where: - pattern (str): A string representing the destination pattern. - max_load (int): The maximum total size of packets that can be processed for this pattern. - action (str): Either \'ACCEPT\' or \'REJECT\' indicating the rule\'s decision for the packets matched by the pattern. Returns: - list: A list of results for each packet, either \'ACCEPTED\' or \'REJECTED\' based on the routing rules applied. ``` # Requirements 1. Implement a packet routing simulation following the provided rules. 2. If a packet\'s destination matches a rule\'s pattern and its size does not exceed the rule\'s `max_load`, apply the rule\'s `action` to the packet. 3. Reduce the `max_load` of the rule by the packet size if the packet is accepted. 4. When multiple rules match a packet, apply the one with the highest priority (earliest in the list). 5. If no rule matches or the packet size exceeds the `max_load` of all matching rules, the packet is automatically rejected. # Constraints - The pattern is a simple string, and packets match rules based on substring containment. - Both `packets` and `rules` lists are non-empty. - Each packet size is a positive integer. # Example Usage ```python packets = [(\'192.168.1.1\', 100), (\'10.0.0.1\', 50), (\'192.168.1.2\', 50)] rules = [(\'192.168\', 150, \'ACCEPT\'), (\'10.0\', 100, \'REJECT\'), (\'192.168.1\', 200, \'ACCEPT\')] simulated_results = router_simulator(packets, rules) print(simulated_results) ``` # Expected Output ``` [\'ACCEPTED\', \'REJECTED\', \'ACCEPTED\'] ``` # Notes - Ensure the function efficiently processes packets and applies rules in order. - Test your implementation with various edge cases, including no matching rules and overlapping patterns. - Discuss any assumptions or improvements made while developing the function.","solution":"def router_simulator(packets, rules): results = [] for packet in packets: destination, size = packet packet_accepted = False for rule in rules: pattern, max_load, action = rule if pattern in destination and size <= max_load: if action == \'ACCEPT\': results.append(\'ACCEPTED\') rule[1] -= size # Decrement the max load packet_accepted = True break elif action == \'REJECT\': results.append(\'REJECTED\') packet_accepted = True break if not packet_accepted: results.append(\'REJECTED\') return results"},{"question":"# Question **Problem Statement**: You are given a list of integers and an integer `k`. Your task is to rotate the list to the right by `k` steps. Function Signature: ```python def rotate_list(nums: list[int], k: int) -> list[int]: pass ``` Input: - `nums`: A list of integers. `List[int]`. - `k`: An integer representing the number of steps to rotate the list. `int`. Output: - Return the modified list after rotating it to the right by `k` steps. Constraints: - The length of the list does not exceed (10^5). - Rotations beyond the length of the list should wrap around. For example, rotating a list of length 5 by 6 steps is equivalent to rotating it by 1 step. Examples: - `rotate_list([1, 2, 3, 4, 5], 2)` should return `[4, 5, 1, 2, 3]`. - `rotate_list([1, 2, 3, 4, 5], 5)` should return `[1, 2, 3, 4, 5]`. - `rotate_list([1, 2, 3, 4, 5], 7)` should return `[4, 5, 1, 2, 3]`. - `rotate_list([], 3)` should return `[]`. - `rotate_list([1], 0)` should return `[1]`. Notes: - Consider edge cases such as when the list is empty or when `k` is larger than the length of the list. - Aim for an efficient solution that operates within O(n) time complexity. **Hint**: - Use list slicing to achieve the rotation efficiently. Good luck!","solution":"def rotate_list(nums: list[int], k: int) -> list[int]: Rotates the list to the right by k steps. Args: nums (List[int]): the list of integers to be rotated. k (int): the number of steps to rotate the list. Returns: List[int]: the modified list after rotating it to the right by k steps. if not nums: return [] n = len(nums) k = k % n # In case k is larger than the list length return nums[-k:] + nums[:-k]"},{"question":"# Coding Assessment Question **Problem Context:** You are tasked with finding the longest palindrome that can be built by rearranging the characters of a given string. This problem evaluates your understanding of string manipulation, counting frequencies, and forming palindromes. # Problem Statement: Write a function `longest_palindrome` that takes a string `s` and returns the length of the longest palindrome that can be built with the characters of `s`. # Function Signature: ```python def longest_palindrome(s: str) -> int: pass ``` # Input: - `s` (str): A string consisting of lowercase and/or uppercase letters. The length of `s` does not exceed 1000 characters. # Output: - (int): The length of the longest palindrome that can be built with the characters from `s`. # Constraints: - ( 1 leq text{len}(s) leq 1000 ) # Example: ```python assert longest_palindrome(\\"abccccdd\\") == 7 assert longest_palindrome(\\"a\\") == 1 assert longest_palindrome(\\"ab\\") == 1 assert longest_palindrome(\\"aA\\") == 1 ``` # Requirements: - Implement the function using efficient string manipulation and counting techniques to handle the constraints. - Ensure that your code correctly takes into account both lowercase and uppercase characters. - Consider edge cases and ensure your code performs optimally for large inputs. # Notes: - Palindromes are strings that read the same forwards and backwards. - You can assume the presence of at most one character with an odd count in the longest palindrome, which can be positioned in the center. - Use a dictionary or a counter from the collections module to count the frequency of each character.","solution":"def longest_palindrome(s: str) -> int: Calculates the length of the longest palindrome that can be built with the characters of s. :param s: A string consisting of lowercase and/or uppercase letters. :return: Length of the longest palindrome. from collections import Counter count = Counter(s) length = 0 odd_found = False for freq in count.values(): if freq % 2 == 0: length += freq else: length += freq - 1 odd_found = True # If there\'s an odd count char, we can place it in the center to increase length by 1 if odd_found: length += 1 return length"},{"question":"# Reverse a String Without Using Built-in Functions **Problem Statement**: You are required to implement a function `reverse_string(input_string: str) -> str` that returns the reverse of a given string without using any built-in functions for reversing (such as `reversed()`, `[::-1]`, etc.). **Input and Output**: - **Input**: A single string `input_string`. - **Output**: Returns the reversed string. **Constraints**: - The input string will have a maximum length of 1000 characters. - The input string will consist only of printable ASCII characters. **Examples**: ```python def reverse_string(input_string: str) -> str: # Your implementation here print(reverse_string(\\"hello\\")) # \\"olleh\\" print(reverse_string(\\"Python\\")) # \\"nohtyP\\" print(reverse_string(\\"12345\\")) # \\"54321\\" print(reverse_string(\\"!@#%^&*()\\")) # \\")(*&^%#@!\\" print(reverse_string(\\"abcd efgh\\")) # \\"hgfe dcba\\" print(reverse_string(\\"\\")) # \\"\\" ``` **Guidelines**: 1. Initialize an empty string to store the reversed string. 2. Iterate through the input string from the last character to the first. 3. Append each character to the new string. 4. Return the new string as the reversed result. **Note**: Aim to handle the reversal process manually using loops while adhering to constraints and without using restricted functions.","solution":"def reverse_string(input_string: str) -> str: Returns the reverse of the input string without using built-in reverse functions. reversed_str = \\"\\" for char in input_string: reversed_str = char + reversed_str return reversed_str"},{"question":"# Container With Most Water You are given an array of integers `height` where each element represents the height of a vertical line on a histogram. The distance between two lines is the difference in their indices. Write a function to find the maximum amount of water a container can store when formed by pairing any two of these lines. **Function Signature:** ```python def max_water_container(height: List[int]) -> int: pass ``` # Input 1. A list of integers `height` where `height[i]` represents the height of the i-th vertical line. # Output * The function should return an integer representing the maximum amount of water a container can store. # Constraints * The length of the list `height` will be between 2 and 10<sup>5</sup>. * Each `height[i]` will be between 0 and 10<sup>4</sup>. # Example Example 1 Input: ```python height = [1, 8, 6, 2, 5, 4, 8, 3, 7] ``` Output: ``` 49 ``` Example 2 Input: ```python height = [1, 1] ``` Output: ``` 1 ``` # Note - The maximum area of water that a container can store is calculated by taking two heights, finding the minimum of these two heights, and multiplying it by the distance between them. - You should use an efficient algorithm to solve this problem within the constraints, such as the two-pointer technique.","solution":"from typing import List def max_water_container(height: List[int]) -> int: Given an array of integers height where each element represents the height of a vertical line, returns the maximum amount of water a container can store when formed by any two of these lines. left, right = 0, len(height) - 1 max_area = 0 while left < right: # Calculate the current area current_area = (right - left) * min(height[left], height[right]) # Update max_area if the current_area is greater max_area = max(max_area, current_area) # Move the pointers to try and find a higher area if height[left] < height[right]: left += 1 else: right -= 1 return max_area"},{"question":"# Problem Statement You are tasked with developing an algorithm that simulates a simplified version of a file system\'s directory structure. This file system supports operations such as creating directories, listing contents, and navigating through the directory hierarchy. Implement the class `SimpleFileSystem` to manage these operations. # Class Definition ```python class SimpleFileSystem: def __init__(self): Initialize the file system with a root directory. pass def mkdir(self, path: str) -> None: Create a directory at the given path. Args: path (str): The directory path to create. pass def ls(self, path: str) -> list: List the contents of the directory at the given path. Args: path (str): The directory path to list. Returns: list: A list of directory names in lexicographical order. pass def cd(self, path: str) -> None: Change the current working directory. Args: path (str): The directory path to change to. pass def pwd(self) -> str: Get the current working directory path. Returns: str: The current working directory path. pass ``` # Requirements 1. Use a dictionary to represent the directory structure. 2. Assume all paths are absolute (starting from the root) and use \'/\' as the path separator. 3. Directories created should be listed in lexicographical order. 4. Implement error handling for operations that reference non-existent paths. # Constraints 1. Operations `mkdir`, `ls`, and `cd` should reflect behavior analogous to Unix commands. 2. Directories have unique names within their respective parent directory. 3. Directories should automatically be created if mkdir is called with a nested path that has missing intermediate directories. # Example Usage ```python # Initialize the file system fs = SimpleFileSystem() # Create directories fs.mkdir(\\"/a/b/c\\") fs.mkdir(\\"/a/b/d\\") # List contents print(fs.ls(\\"/a/b\\")) # Output: [\\"c\\", \\"d\\"] # Change directory fs.cd(\\"/a/b/c\\") # Print working directory print(fs.pwd()) # Output: \\"/a/b/c\\" ``` # Output Create appropriate instance methods to handle the outlined functionality and ensure error management and edge cases are properly addressed in your code.","solution":"class SimpleFileSystem: def __init__(self): Initialize the file system with a root directory. self.fs = {\'/\': {}} self.current_path = \'/\' def mkdir(self, path: str) -> None: Create a directory at the given path. Args: path (str): The directory path to create. parts = path.split(\'/\') cursor = self.fs[\'/\'] for part in parts[1:]: if part not in cursor: cursor[part] = {} cursor = cursor[part] def ls(self, path: str) -> list: List the contents of the directory at the given path. Args: path (str): The directory path to list. Returns: list: A list of directory names in lexicographical order. parts = path.split(\'/\') cursor = self.fs[\'/\'] for part in parts[1:]: if part in cursor: cursor = cursor[part] else: return [] return sorted(cursor.keys()) def cd(self, path: str) -> None: Change the current working directory. Args: path (str): The directory path to change to. parts = path.split(\'/\') cursor = self.fs[\'/\'] for part in parts[1:]: if part in cursor: cursor = cursor[part] else: raise OSError(\\"No such directory\\") self.current_path = path def pwd(self) -> str: Get the current working directory path. Returns: str: The current working directory path. return self.current_path"},{"question":"# Course Attendance Tracker You are given a function `track_attendance` that logs student attendance for various college courses. Your next task is to enhance this function to generate a summary report for the attendance of each student across all courses. Function Signature ```python def track_attendance(log: list, new_entry: tuple) -> dict: Adds new attendance entry to the log and generates a summary report. Parameters: - log (list): The existing log of attendance entries. Each entry is a tuple containing: (student_id (int), course_id (int), is_present (bool)) - new_entry (tuple): A new entry to be added to the log. It is structured in the same format as log entries. Returns: - dict: A summary report of attendance containing: - student_id: Total number of days present across all courses. ``` Additional Constraints and Information: 1. **Input Validation**: - `new_entry` must be a tuple containing (student_id, course_id, is_present). - `student_id` and `course_id` should be positive integers. - `is_present` should be a boolean value. 2. **Output**: - A dictionary where keys are `student_id` and values are the total number of days the student is marked `is_present`. 3. **Edge Cases**: - New entry with invalid data types should raise an error. - Handle cases with duplicate or repeated entries. Examples: ```python >>> log = [ ... (1, 101, True), ... (2, 101, False), ... (1, 102, True) ... ] >>> track_attendance(log, (3, 101, True)) {1: 2, 2: 0, 3: 1} >>> track_attendance(log, (1, 101, False)) {1: 1, 2: 0} >>> track_attendance([], (2, 104, True)) {2: 1} >>> track_attendance(log, (1, 101)) Traceback (most recent call last): ... ValueError: new_entry must be a tuple containing (student_id, course_id, is_present) >>> track_attendance(log, (2, \\"course_104\\", True)) Traceback (most recent call last): ... ValueError: student_id and course_id must be positive integers. >>> track_attendance(log, (2, 104, \\"Yes\\")) Traceback (most recent call last): ... ValueError: is_present must be a boolean value. ``` Write the enhanced `track_attendance` function in Python to fulfill the described requirements.","solution":"def track_attendance(log: list, new_entry: tuple) -> dict: Adds new attendance entry to the log and generates a summary report. Parameters: - log (list): The existing log of attendance entries. Each entry is a tuple containing: (student_id (int), course_id (int), is_present (bool)) - new_entry (tuple): A new entry to be added to the log. It is structured in the same format as log entries. Returns: - dict: A summary report of attendance containing: - student_id: Total number of days present across all courses. # Basic validity checks if (not isinstance(new_entry, tuple) or len(new_entry) != 3): raise ValueError(\\"new_entry must be a tuple containing (student_id, course_id, is_present)\\") student_id, course_id, is_present = new_entry if (not isinstance(student_id, int) or not isinstance(course_id, int) or student_id <= 0 or course_id <= 0): raise ValueError(\\"student_id and course_id must be positive integers.\\") if not isinstance(is_present, bool): raise ValueError(\\"is_present must be a boolean value.\\") # Add the new entry to the log log.append(new_entry) # Create a summary report summary = {} for entry in log: student_id, _, is_present = entry if student_id not in summary: summary[student_id] = 0 if is_present: summary[student_id] += 1 return summary"},{"question":"# Problem Description You are tasked with implementing a system to manage an online store\'s catalog of items. This system must provide functionalities to add new items, update existing items, and search for items by category. # Requirements 1. **Class: `Item`** - **Attributes**: - `id`: a unique integer identifier for each item. - `name`: string representing the name of the item. - `category`: string representing the category of the item. - `price`: float representing the price of the item. 2. **Class: `Catalog`** - **Attributes**: - `items`: a dictionary mapping item IDs to `Item` objects. - `next_id`: an integer used to assign the next unique ID to a new item. - **Methods**: 1. **`__init__(self)`**: Initializes an empty catalog with `next_id` set to 1. 2. **`add_item(self, name, category, price)`**: - **Input**: A string `name`, a string `category`, and a float `price`. - **Output**: The ID of the newly added item. - **Behavior**: Creates a new `Item` object, assigns it a unique ID, adds it to the catalog, and returns its ID. 3. **`update_item(self, id, name, category, price)`**: - **Input**: An integer `id`, a string `name`, a string `category`, and a float `price`. - **Output**: `True` if the update was successful, otherwise `False`. - **Behavior**: Updates the item\'s details if it exists in the catalog. 4. **`search_by_category(self, category)`**: - **Input**: A string `category`. - **Output**: A list of items (represented as dictionaries) from the given category. - **Behavior**: Returns a list of item details for items belonging to the specified category. # Input and Output Formats - **Input**: Method parameters. - **Output**: Depend on the functionalities specified in the methods. # Example ```python # Create a Catalog instance catalog = Catalog() # Add items to the catalog item_id1 = catalog.add_item(\'Laptop\', \'Electronics\', 999.99) item_id2 = catalog.add_item(\'Smartphone\', \'Electronics\', 499.99) item_id3 = catalog.add_item(\'Notebook\', \'Stationery\', 1.99) # Update an item in the catalog update_success = catalog.update_item(item_id2, \'Smartphone\', \'Mobile Devices\', 549.99) # True # Search for items by category items_in_electronics = catalog.search_by_category(\'Electronics\') # Output: [{\'id\': item_id1, \'name\': \'Laptop\', \'category\': \'Electronics\', \'price\': 999.99}] items_in_stationery = catalog.search_by_category(\'Stationery\') # Output: [{\'id\': item_id3, \'name\': \'Notebook\', \'category\': \'Stationery\', \'price\': 1.99}] ``` # Constraints - The `name` and `category` will be non-empty strings of length up to 100. - The `price` will be a float in the range `[0.01, 9999.99]`. - An `id` used in the `update_item` method will always be a valid ID generated by the `Catalog`. # Task Implement the `Item` and `Catalog` classes in Python to meet the requirements described above.","solution":"class Item: def __init__(self, id, name, category, price): self.id = id self.name = name self.category = category self.price = price class Catalog: def __init__(self): self.items = {} self.next_id = 1 def add_item(self, name, category, price): item_id = self.next_id self.items[item_id] = Item(item_id, name, category, price) self.next_id += 1 return item_id def update_item(self, id, name, category, price): if id in self.items: self.items[id].name = name self.items[id].category = category self.items[id].price = price return True return False def search_by_category(self, category): return [ { \'id\': item.id, \'name\': item.name, \'category\': item.category, \'price\': item.price } for item in self.items.values() if item.category == category ]"},{"question":"# Image Processing: Cropping Command Simulation Objective Design and implement a function that simulates an image cropping command given a set of coordinates. To test your understanding of coordinate manipulation, you will manage boundaries and various edge cases. Function Signature ```python def crop_image(image: List[List[int]], top_left: Tuple[int, int], bottom_right: Tuple[int, int]) -> List[List[int]]: ... ``` Instructions 1. **Functionality**: - Implement the function to crop a given `image` represented by a 2D list of integers. - The `top_left` and `bottom_right` coordinates mark the rectangle to be cropped from the image. - Your function should return a new image that is the submatrix defined by the specified bounds in the original image. 2. **Considerations**: - The coordinates are inclusive, meaning the rectangle includes the pixel at `top_left` and `bottom_right`. - If the specified coordinates are out of the image bounds, the function should adjust them to fit within the actual image. - Handle cases where the coordinates are invalid (e.g., top_left is below or to the right of bottom_right) by returning an empty list. - Ensure the function efficiently handles large images. 3. **Examples**: - Given `image`: ```python image = [ [1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16] ] crop_image(image, (1, 1), (2, 2)) ``` - Output: ```python [ [6, 7], [10, 11] ] ``` - Adjusting out-of-bound coordinates: ```python crop_image(image, (-1, -1), (1, 1)) ``` - Output: ```python [ [1, 2], [5, 6] ] ``` 4. **Constraints**: - The image dimensions range from 1x1 to 1000x1000. - Function should handle non-square (rectangular) cropping as well. - Coordinate values for `top_left` and `bottom_right` should be integers. Notes - Assume the input format is correct, but handle cases where boundary adjustments are necessary. - Leverage the knowledge of list slicing and boundary checks to ensure the function maintains efficiency and correctness across possible edge cases.","solution":"from typing import List, Tuple def crop_image(image: List[List[int]], top_left: Tuple[int, int], bottom_right: Tuple[int, int]) -> List[List[int]]: rows = len(image) cols = len(image[0]) if rows > 0 else 0 top_row, left_col = top_left bottom_row, right_col = bottom_right # Adjust out-of-bound coordinates top_row = max(0, top_row) left_col = max(0, left_col) bottom_row = min(rows - 1, bottom_row) right_col = min(cols - 1, right_col) # Invalid coordinates if top_row > bottom_row or left_col > right_col: return [] return [row[left_col:right_col+1] for row in image[top_row:bottom_row+1]]"},{"question":"# Task: Implement a function named `schedule_meetings` to schedule non-overlapping meetings from a list of meeting requests in a single conference room. Each meeting request specifies a start and end time. # Requirements: - The function should take a single parameter: - `meetings` (list of tuples): Each tuple contains two integers representing the start and end times of a meeting request. - The function should return a list of tuples representing the maximum set of non-overlapping meetings that can be accommodated in the conference room. # Constraint: - If two meetings overlap, only one of them can be scheduled. For example, meeting `(1, 3)` and meeting `(2, 4)` overlap; therefore, only one can be selected. - Meetings touching at the boundary are not considered overlapping. For example, meeting `(1, 2)` and meeting `(2, 3)` can both be scheduled. # Examples: ```python >>> schedule_meetings([(1, 3), (2, 4), (3, 5), (0, 6), (5, 7), (8, 9)]) [(1, 3), (3, 5), (5, 7), (8, 9)] >>> schedule_meetings([(0, 1), (3, 5), (4, 6), (6, 8), (5, 7)]) [(0, 1), (3, 5), (6, 8)] >>> schedule_meetings([(1, 4), (2, 3), (3, 5), (3, 4)]) [(2, 3), (3, 4)] >>> schedule_meetings([(1, 3), (3, 5)]) [(1, 3), (3, 5)] ```","solution":"def schedule_meetings(meetings): Schedules the maximum number of non-overlapping meetings from the list of meeting requests. Parameters: meetings (list of tuples): Each tuple contains two integers representing the start and end times of a meeting request. Returns: list of tuples: The maximum set of non-overlapping meetings that can be accommodated. # Sort meetings by their end times sorted_meetings = sorted(meetings, key=lambda x: x[1]) non_overlapping_meetings = [] last_end_time = 0 for meeting in sorted_meetings: if meeting[0] >= last_end_time: non_overlapping_meetings.append(meeting) last_end_time = meeting[1] return non_overlapping_meetings"},{"question":"# Question Create a function named `file_extension_counter` that takes a single parameter - `file_list` (a list of strings representing file names). The function should count the occurrences of each file extension in the `file_list` and return a dictionary where the keys are the file extensions (including the dot, e.g., \\".txt\\") and the values are the counts of those extensions. The function should ignore file names without an extension and those that start with a hidden file indicator (a dot at the start of the file name). # Required Function Signature ```python def file_extension_counter(file_list: list[str]) -> dict[str, int]: pass ``` # Examples ```python >>> file_extension_counter([\\"document.txt\\", \\"image.png\\", \\"notes.md\\", \\".hiddenfile\\", \\"archive.zip\\", \\"archive.ZIP\\"]) {\\".txt\\": 1, \\".png\\": 1, \\".md\\": 1, \\".zip\\": 2} >>> file_extension_counter([\\"file1.doc\\", \\"file2.docx\\", \\"file3.DOCX\\", \\"file4.xls\\", \\"file1.DOC\\", \\"readme\\", \\"no_extension\\"]) {\\".doc\\": 2, \\".docx\\": 2, \\".xls\\": 1} >>> file_extension_counter([\\"image.jpeg\\", \\"photo.jpg\\", \\"graph.JPEG\\", \\"icon.ico\\", \\"favicon.ICO\\"]) {\\".jpeg\\": 2, \\".jpg\\": 1, \\".ico\\": 2} ``` # Constraints * `file_list` will be a list of non-empty strings. * File extensions are case-insensitive (e.g., \\".jpg\\" and \\".JPG\\" should be treated as the same). * The function should ignore files without an extension and hidden files (files that start with a dot). # Notes * Use the built-in string methods for handling file name and extension extraction. * Ensure that the returned dictionary keys are all in lowercase.","solution":"def file_extension_counter(file_list): from collections import Counter extension_counter = Counter() for file in file_list: if file.startswith(\'.\') or \'.\' not in file: continue _, ext = file.rsplit(\'.\', 1) if ext: extension_counter[f\\".{ext.lower()}\\"] += 1 return dict(extension_counter)"},{"question":"# Majority Element Finder **Objective**: Implement a function to find the majority element in a list of integers. **Scenario**: You are analyzing polling data to determine the majority preference among a group of voters. A majority element in an array is defined as an element that appears more than `n/2` times, where `n` is the number of elements in the array. Your task is to identify this element if it exists. **Function Signature**: ```python def find_majority_element(nums: list) -> int: pass ``` **Input**: - `nums` (list): A list of integers where the majority element, if it exists, appears more than `n/2` times. **Output**: - Returns the majority element if it exists. If there is no majority element, return -1. **Constraints**: - The input list `nums` will have a length between 1 and 10,000 integers. - All integers in the list will be in the range from -10^9 to 10^9. **Example**: ```python assert find_majority_element([3, 3, 4, 2, 4, 4, 2, 4, 4]) == 4 assert find_majority_element([3, 3, 4, 2, 4, 4, 2, 4]) == -1 ``` **Guidelines**: - You may use any algorithm to find the majority element, such as the Boyer-Moore Voting Algorithm. - Make sure the function returns the correct majority element or -1 if no such element exists. **Performance**: - Aim for an O(n) time complexity and O(1) space complexity.","solution":"def find_majority_element(nums: list) -> int: Returns the majority element if it exists in the list `nums`. If no majority element exists, returns -1. # Implementing Boyer-Moore Voting Algorithm count = 0 candidate = None # Phase 1: Find a potential majority candidate for num in nums: if count == 0: candidate = num count += (1 if num == candidate else -1) # Phase 2: Verify if the candidate is actually a majority if nums.count(candidate) > len(nums) // 2: return candidate else: return -1"},{"question":"# Problem Statement You are required to implement two utility functions: `url_encode` and `url_decode`. These functions will perform encoding of strings into URL-safe format where special characters are percent-encoded, and decoding such URLs back to their original strings correspondingly. **Function 1: `url_encode`** - **Input**: A `str` object `data`. - **Output**: A `str` object representing the URL-encoded representation of the input data. - **Constraints**: - Space characters should be encoded as `%20`. - The input `data` can be an empty string. **Function 2: `url_decode`** - **Input**: A `str` object `data` representing URL-encoded data. - **Output**: A `str` object which is the decoded representation of the input data. - **Constraints**: - The input `data` must contain valid URL-encoded components. - If the input data is invalid, the function should raise a `ValueError` with a descriptive message. # Example ```python def url_encode(data: str) -> str: \'\'\' This function encodes the input string into a URL-safe format. \'\'\' pass # TODO: Write the implementation here def url_decode(data: str) -> str: \'\'\' This function decodes the input URL-safe encoded string back to its original form. \'\'\' pass # TODO: Write the implementation here # Test Cases assert url_encode(\'Hello World!\') == \'Hello%20World%21\' assert url_encode(\'URL Encoding is cool.\') == \'URL%20Encoding%20is%20cool.\' assert url_encode(\'\') == \'\' assert url_decode(\'Hello%20World%21\') == \'Hello World!\' assert url_decode(\'URL%20Encoding%20is%20cool.\') == \'URL Encoding is cool.\' assert url_decode(\'\') == \'\' try: url_decode(\'Hello%20World!\') except ValueError as e: assert str(e) == \'URL-encoded data is invalid: Incomplete percent-encoding or invalid characters found.\' try: url_decode(\'Hello World\') except ValueError as e: assert str(e) == \'URL-encoded data is invalid: Data is not properly percent-encoded.\' try: url_decode(\'%2HHello%20World\') except ValueError as e: assert str(e) == \'URL-encoded data is invalid: Incomplete percent-encoding or invalid characters found.\' ``` **Additional Note**: - Ensure your code handles edge cases and invalid inputs appropriately, raising exceptions with meaningful messages. - The implementation should be efficient and correctly handle large input data within the constraints.","solution":"def url_encode(data: str) -> str: This function encodes the input string into a URL-safe format. result = \'\' for char in data: if char == \' \': result += \'%20\' elif char.isalnum() or char in \'-_.~\': result += char else: result += f\'%{ord(char):02X}\' return result def url_decode(data: str) -> str: This function decodes the input URL-safe encoded string back to its original form. import re pattern = re.compile(r\'%([0-9A-Fa-f]{2})\') try: return re.sub(pattern, lambda match: chr(int(match.group(1), 16)), data.replace(\'%20\', \' \')) except: raise ValueError(\'URL-encoded data is invalid: Incomplete percent-encoding or invalid characters found.\')"},{"question":"Password Strength Validator Objective Create a `validate_password` function that checks if a given password is strong based on specific criteria. The function should also suggest improvements if the password does not meet the criteria. Problem Statement A strong password must: 1. Be at least 8 characters long. 2. Contain at least one uppercase letter. 3. Contain at least one lowercase letter. 4. Contain at least one digit. 5. Contain at least one special character from the set: `!@#%^&*()-_+=`. Write a function `validate_password(password: str) -> Union[bool, List[str]]` that determines if the provided password is strong and provides feedback if not. **Input:** * A string `password` (1 <= length <= 256). **Output:** * Returns `True` if the password meets all the required criteria. * Returns a list of strings indicating the missing criteria if the password is not strong. **Constraints:** * Only printable ASCII characters will be present in the password. **Example:** ```python >>> validate_password(\\"Abc123\\") [\'Password must be at least 8 characters long\'] >>> validate_password(\\"abc123%\\") [\'Password must contain at least one uppercase letter\'] >>> validate_password(\\"Password123\\") [\'Password must contain at least one special character from the set: !@#%^&*()-_+=\'] >>> validate_password(\\"StrongPassw0rd!\\") True ``` Key Points: * Ensure that the feedback is specific and detailed, allowing the user to know exactly what is missing. * Optimize for clarity and efficiency. * Consider edge cases, such as passwords that are barely within the required length or those that satisfy most but not all criteria.","solution":"from typing import Union, List def validate_password(password: str) -> Union[bool, List[str]]: Validates the given password based on specific criteria to be considered strong. Parameters: - password: A string representing the password to validate. Returns: - True if the password meets all criteria. - A list of feedback strings indicating which criteria are not met if the password is not strong. criteria = [ (len(password) >= 8, \\"Password must be at least 8 characters long\\"), (any(c.isupper() for c in password), \\"Password must contain at least one uppercase letter\\"), (any(c.islower() for c in password), \\"Password must contain at least one lowercase letter\\"), (any(c.isdigit() for c in password), \\"Password must contain at least one digit\\"), (any(c in \\"!@#%^&*()-_+=\\" for c in password), \\"Password must contain at least one special character from the set: !@#%^&*()-_+=\\") ] feedback = [msg for valid, msg in criteria if not valid] if not feedback: return True else: return feedback"},{"question":"# Question You need to develop a function that processes an array of integers and sorts all prime numbers in ascending order while leaving the positions of the non-prime numbers unchanged. **Function Signature:** ```python def sort_primes(arr: List[int]) -> List[int]: Sorts the prime numbers in an array in ascending order while keeping the non-prime numbers in their original positions. Parameters: arr (List[int]): The list of integers to be processed. Returns: List[int]: The list with primes sorted in ascending order and non-prime numbers in their original positions. pass ``` **Input:** - `arr` (List[int]): A list of integers where primes need to be sorted. **Output:** - A list of integers with primes sorted in ascending order and non-prime numbers in their original positions. **Constraints:** - The list can contain positive and negative integers, as well as zero. - The list can be of any length, including zero. - The function should correctly identify prime numbers, including edge cases such as negative numbers and zero. **Example:** ```python >>> sort_primes([29, 15, -3, 4, 17, 5, 2]) [2, 15, -3, 4, 5, 17, 29] >>> sort_primes([7, 10, 23, 12, 19]) [7, 10, 19, 12, 23] >>> sort_primes([0, -1, -4, 2, 3, 5]) [0, -1, -4, 2, 3, 5] ``` **Instructions:** 1. Implement the `sort_primes` function to sort the prime numbers while maintaining the positions of non-prime numbers. 2. Prime numbers should be determined accurately. 3. Allow the function to handle edge cases, including lists with negative numbers, zeros, and non-prime numbers. 4. Ensure the solution is efficient and readable.","solution":"from typing import List def is_prime(n: int) -> bool: Returns True if n is a prime number, otherwise False. if n <= 1: return False if n == 2: return True if n % 2 == 0: return False max_divisor = int(n ** 0.5) + 1 for i in range(3, max_divisor, 2): if n % i == 0: return False return True def sort_primes(arr: List[int]) -> List[int]: Sorts the prime numbers in an array in ascending order while keeping the non-prime numbers in their original positions. # Extract primes and their indices primes = [num for num in arr if is_prime(num)] primes.sort() result = [] prime_index = 0 for num in arr: if is_prime(num): result.append(primes[prime_index]) prime_index += 1 else: result.append(num) return result"},{"question":"# Sudoku Solver Extension A classic Sudoku board is a 9x9 grid partially filled with digits from 1 to 9. The Sudoku solver problem requires filling the board such that each column, each row, and each of the nine 3x3 subgrids contain all digits from 1 to 9 exactly once. You are given an incomplete board and your task is to both solve the Sudoku and perform additional checks. 1. **Verify and Solve the Board**: Modify the solution to first verify if the board is a valid incomplete Sudoku setup following the rules of Sudoku (no duplicate numbers in any row, column, or subgrid). If valid, proceed to solve the board. 2. **Check for Multiple Solutions**: After solving the board, check if the Sudoku puzzle has more than one valid solution. Return a boolean indicating this. **Function Signatures**: ```python def verify_and_solve(board: List[List[int]]) -> List[List[int]]: Verifies and solves the Sudoku board if valid returns the solved board. def has_multiple_solutions(board: List[List[int]]) -> bool: Checks if the given Sudoku board has multiple solutions. ``` **Input Format**: * `board`: A 9x9 grid partially filled with digits from 1 to 9. Empty cells are represented by 0. **Output Format**: * For `verify_and_solve`: A 9x9 grid with the solved Sudoku if the input board is valid, otherwise raise a `ValueError` indicating the board is invalid. * For `has_multiple_solutions`: A boolean indicating if the board has multiple solutions. **Constraints**: * The board will always be a 9x9 grid. **Example**: ```python board = [ [5, 3, 0, 0, 7, 0, 0, 0, 0], [6, 0, 0, 1, 9, 5, 0, 0, 0], [0, 9, 8, 0, 0, 0, 0, 6, 0], [8, 0, 0, 0, 6, 0, 0, 0, 3], [4, 0, 0, 8, 0, 3, 0, 0, 1], [7, 0, 0, 0, 2, 0, 0, 0, 6], [0, 6, 0, 0, 0, 0, 2, 8, 0], [0, 0, 0, 4, 1, 9, 0, 0, 5], [0, 0, 0, 0, 8, 0, 0, 7, 9] ] verify_and_solve(board) # Returns the solved board if valid # [ # [5, 3, 4, 6, 7, 8, 9, 1, 2], # [6, 7, 2, 1, 9, 5, 3, 4, 8], # [1, 9, 8, 3, 4, 2, 5, 6, 7], # [8, 5, 9, 7, 6, 1, 4, 2, 3], # [4, 2, 6, 8, 5, 3, 7, 9, 1], # [7, 1, 3, 9, 2, 4, 8, 5, 6], # [9, 6, 1, 5, 3, 7, 2, 8, 4], # [2, 8, 7, 4, 1, 9, 6, 3, 5], # [3, 4, 5, 2, 8, 6, 1, 7, 9] # ] has_multiple_solutions(board) # Returns False if there is only one solution, True if there are multiple solutions ``` **Hint**: To check for multiple solutions, attempt to solve the puzzle and backtrack if more than one solution path is found. Make sure your board verification accurately captures invalid setups to avoid erroneous solutions.","solution":"from typing import List def verify_and_solve(board: List[List[int]]) -> List[List[int]]: def is_valid(board: List[List[int]], row: int, col: int, num: int) -> bool: # Check if the number is valid in the row for x in range(9): if board[row][x] == num: return False # Check if the number is valid in the column for x in range(9): if board[x][col] == num: return False # Check if the number is valid in the 3x3 subgrid start_row, start_col = 3 * (row // 3), 3 * (col // 3) for i in range(start_row, start_row + 3): for j in range(start_col, start_col + 3): if board[i][j] == num: return False return True def solve(board: List[List[int]]) -> bool: for i in range(9): for j in range(9): if board[i][j] == 0: for num in range(1, 10): if is_valid(board, i, j, num): board[i][j] = num if solve(board): return True board[i][j] = 0 return False return True def is_board_valid(board: List[List[int]]) -> bool: for i in range(9): for j in range(9): if board[i][j] != 0: num = board[i][j] board[i][j] = 0 if not is_valid(board, i, j, num): return False board[i][j] = num return True if not is_board_valid(board): raise ValueError(\\"Invalid Sudoku board\\") if solve(board): return board else: raise ValueError(\\"Sudoku puzzle cannot be solved\\") def has_multiple_solutions(board: List[List[int]]) -> bool: def is_valid(board: List[List[int]], row: int, col: int, num: int) -> bool: for x in range(9): if board[row][x] == num: return False for x in range(9): if board[x][col] == num: return False start_row, start_col = 3 * (row // 3), 3 * (col // 3) for i in range(start_row, start_row + 3): for j in range(start_col, start_col + 3): if board[i][j] == num: return False return True solutions_count = 0 def solve(board: List[List[int]]) -> bool: nonlocal solutions_count for i in range(9): for j in range(9): if board[i][j] == 0: for num in range(1, 10): if is_valid(board, i, j, num): board[i][j] = num if solve(board): return True board[i][j] = 0 return False solutions_count += 1 return solutions_count > 1 copy_board = [row[:] for row in board] solve(copy_board) return solutions_count > 1"},{"question":"# Scenario You are developing a contact management application. One of the key features is to manage and retrieve contact lists efficiently. Contacts should be stored with their names and phone numbers, and the application must support multiple operations including adding, finding, and listing contacts sorted by name. # Task Write three functions to add a contact, find a contact by name, and list all contacts sorted by name. # Function 1: `add_contact` Input - A list `contacts` representing the existing contacts, where each contact is a dictionary with keys \\"name\\" and \\"phone\\". - A dictionary `new_contact` representing the contact to be added with keys \\"name\\" and \\"phone\\". Output - The function modifies the `contacts` list in-place by adding the new contact. Example ```python contacts = [] new_contact = {\\"name\\": \\"Alice\\", \\"phone\\": \\"123-456-7890\\"} add_contact(contacts, new_contact) assert contacts == [{\\"name\\": \\"Alice\\", \\"phone\\": \\"123-456-7890\\"}] ``` # Function 2: `find_contact` Input - A list `contacts` representing the existing contacts, where each contact is a dictionary with keys \\"name\\" and \\"phone\\". - A string `name` representing the contact name to find. Output - A dictionary representing the contact with the specified `name`. If the contact is not found, return `None`. Example ```python contacts = [{\\"name\\": \\"Alice\\", \\"phone\\": \\"123-456-7890\\"}, {\\"name\\": \\"Bob\\", \\"phone\\": \\"987-654-3210\\"}] assert find_contact(contacts, \\"Alice\\") == {\\"name\\": \\"Alice\\", \\"phone\\": \\"123-456-7890\\"} assert find_contact(contacts, \\"Charlie\\") == None ``` # Function 3: `list_contacts_sorted` Input - A list `contacts` representing the existing contacts, where each contact is a dictionary with keys \\"name\\" and \\"phone\\". Output - A list of contacts sorted by the contact names in ascending order. Example ```python contacts = [{\\"name\\": \\"Charlie\\", \\"phone\\": \\"555-555-5555\\"}, {\\"name\\": \\"Alice\\", \\"phone\\": \\"123-456-7890\\"}, {\\"name\\": \\"Bob\\", \\"phone\\": \\"987-654-3210\\"}] assert list_contacts_sorted(contacts) == [ {\\"name\\": \\"Alice\\", \\"phone\\": \\"123-456-7890\\"}, {\\"name\\": \\"Bob\\", \\"phone\\": \\"987-654-3210\\"}, {\\"name\\": \\"Charlie\\", \\"phone\\": \\"555-555-5555\\"} ] ``` Constraints - Implement error handling for invalid inputs. - Ensure contacts with duplicate names are handled correctly. - Optimize for readability and efficiency. # Notes - Directly referencing existing code or solutions may result in immediate disqualification. - Ensure solutions handle edge cases and performance bottlenecks effectively.","solution":"def add_contact(contacts, new_contact): Adds a new contact to the contacts list. :param contacts: A list of dictionaries, where each dictionary contains \\"name\\" and \\"phone\\" keys. :param new_contact: A dictionary with \\"name\\" and \\"phone\\" keys representing the new contact. if not isinstance(contacts, list) or not isinstance(new_contact, dict): raise ValueError(\\"Invalid input types.\\") if \\"name\\" not in new_contact or \\"phone\\" not in new_contact: raise ValueError(\\"New contact must have \'name\' and \'phone\'.\\") contacts.append(new_contact) def find_contact(contacts, name): Finds a contact by name. :param contacts: A list of dictionaries, where each dictionary contains \\"name\\" and \\"phone\\" keys. :param name: The name of the contact to find. :return: A dictionary representing the contact with the specified name, or None if not found. if not isinstance(contacts, list) or not isinstance(name, str): raise ValueError(\\"Invalid input types.\\") for contact in contacts: if contact.get(\\"name\\") == name: return contact return None def list_contacts_sorted(contacts): Lists all contacts sorted by name in ascending order. :param contacts: A list of dictionaries, where each dictionary contains \\"name\\" and \\"phone\\" keys. :return: A list of contacts sorted by the contact names. if not isinstance(contacts, list): raise ValueError(\\"Invalid input type.\\") return sorted(contacts, key=lambda contact: contact.get(\\"name\\"))"},{"question":"# K Nearest Neighbors for Classification You are required to implement the K Nearest Neighbors (KNN) algorithm from scratch for a classification problem. Your task is to: 1. Download and process a given dataset. 2. Implement the KNN algorithm to classify data points. 3. Evaluate the model using accuracy as the metric. Dataset The dataset contains three columns: `feature1`, `feature2`, and `label`. The first row contains headers. Each row represents two features and the corresponding class label (0 or 1). **Download URL**: ``` https://raw.githubusercontent.com/dataprofessor/data/master/penguins_size.csv ``` Task Requirements 1. **Function to Collect Dataset**: - Read and return the dataset as a matrix. - Parse the CSV data from the URL. 2. **Function to Compute Euclidean Distance**: - Calculate the Euclidean distance between two data points. 3. **Function to Predict Label**: - Implement the KNN algorithm to predict the label for a given point. - Use the majority class among the K nearest neighbors. 4. **Function to Evaluate Model**: - Calculate the accuracy of the model by comparing the predicted and actual labels. 5. **Main Execution**: - Load the data, process it, and run KNN. - Print the accuracy of the KNN model on the dataset. Function Signatures You should implement the following functions: 1. `collect_dataset() -> np.matrix` 2. `euclidean_distance(point1: np.array, point2: np.array) -> float` 3. `knn_predict(data_x: np.matrix, test_point: np.array, k: int) -> int` 4. `evaluate_model(data_x: np.matrix, data_y: np.matrix, k: int) -> float` Input & Output Format - Input: **None**. The function should fetch the dataset and perform computations internally. - Output: **Accuracy of the KNN model**, printed in the console. Example ```python def main(): # Collect and process the dataset data = collect_dataset() len_data = data.shape[0] data_x = data[:, :-1].astype(float) data_y = data[:, -1].astype(int) # Define the number of neighbors to consider k = 5 # Evaluate the model accuracy = evaluate_model(data_x, data_y, k) print(f\\"Model Accuracy: {accuracy:.2f}%\\") if __name__ == \\"__main__\\": main() ``` Constraints - Ensure to handle network errors while fetching the dataset. - Validate the value of K (it should be a positive integer). - The model should run within a reasonable time frame, assuming the dataset size does not exceed 10000 points and K <= 10. This question builds upon the candidate\'s ability to understand and implement fundamental machine learning algorithms, similar to the original set\'s focus on gradient descent and linear regression, but in a classification context.","solution":"import numpy as np import pandas as pd from collections import Counter from urllib.error import HTTPError def collect_dataset(url=\\"https://raw.githubusercontent.com/dataprofessor/data/master/penguins_size.csv\\"): try: df = pd.read_csv(url) # Selecting only non-null rows for features and label \'species\' df = df[[\'culmen_length_mm\', \'culmen_depth_mm\', \'species\']].dropna() df[\'species\'] = df[\'species\'].astype(\'category\').cat.codes # Converts species to numerical codes return df.to_numpy() except HTTPError as e: print(f\\"HTTP Error: {e}\\") return None def euclidean_distance(point1, point2): return np.sqrt(np.sum((point1 - point2) ** 2)) def knn_predict(data_x, test_point, k): distances = [] for point in data_x: dist = euclidean_distance(test_point, point[:-1]) distances.append((dist, point[-1])) distances.sort(key=lambda x: x[0]) neighbors = distances[:k] labels = [neighbor[1] for neighbor in neighbors] most_common = Counter(labels).most_common(1) return most_common[0][0] def evaluate_model(data_x, data_y, k): correct_predictions = 0 for i in range(len(data_x)): test_point = data_x[i] original_label = data_y[i] data_without_test_point = np.delete(data_x, i, axis=0) predicted_label = knn_predict(data_without_test_point, test_point, k) if predicted_label == original_label: correct_predictions += 1 accuracy = (correct_predictions / len(data_x)) * 100 return accuracy def main(): data = collect_dataset() if data is None: return data_x = data[:, :-1].astype(float) data_y = data[:, -1].astype(int) k = 5 accuracy = evaluate_model(data_x, data_y, k) print(f\\"Model Accuracy: {accuracy:.2f}%\\") if __name__ == \\"__main__\\": main()"},{"question":"# Context You are given a matrix represented as a list of lists, where each sublist corresponds to a row in the matrix. The matrix contains integers, and your task is to implement a set of functions to efficiently rotate the matrix clockwise or counterclockwise by 90 degrees. # Task Create a `Matrix` class with methods to rotate the matrix in both directions. You should implement the methods – `rotate_clockwise()`, `rotate_counterclockwise()`, `print_matrix()`, and `get_matrix()`. # Requirements 1. The `rotate_clockwise()` method rotates the matrix by 90 degrees in the clockwise direction. 2. The `rotate_counterclockwise()` method rotates the matrix by 90 degrees in the counterclockwise direction. 3. The `print_matrix()` method prints the matrix in its current form. 4. The `get_matrix()` method returns the current state of the matrix. 5. Ensure your rotation methods operate with O(n²) time complexity, where n is the number of elements in the matrix. # Input/Output - The `rotate_clockwise()` method does not take any parameters and does not return a value. - The `rotate_counterclockwise()` method does not take any parameters and does not return a value. - The `print_matrix()` method prints the current state of the matrix. - The `get_matrix()` method returns the current state of the matrix as a list of lists. # Example ```python m = Matrix([ [1, 2, 3], [4, 5, 6], [7, 8, 9] ]) m.rotate_clockwise() m.print_matrix() # Output: # [7, 4, 1] # [8, 5, 2] # [9, 6, 3] m.rotate_counterclockwise() m.print_matrix() # Output: # [1, 2, 3] # [4, 5, 6] # [7, 8, 9] ``` # Notes * You can assume the matrix will always be non-empty and square (i.e., the number of rows equals the number of columns). * Focus on achieving the rotations with minimal redundancy and ensure in-place modification for optimum space usage.","solution":"class Matrix: def __init__(self, matrix): self.matrix = matrix def rotate_clockwise(self): Rotates the matrix by 90 degrees in the clockwise direction. self.matrix = [list(row) for row in zip(*self.matrix[::-1])] def rotate_counterclockwise(self): Rotates the matrix by 90 degrees in the counterclockwise direction. self.matrix = [list(row) for row in zip(*self.matrix)][::-1] def print_matrix(self): Prints the current state of the matrix. for row in self.matrix: print(row) def get_matrix(self): Returns the current state of the matrix. return self.matrix"},{"question":"# **Question: Unique Character Matrix** You are tasked to create a function that generates a special `n x n` matrix containing unique uppercase alphabetic characters (\'A\' to \'Z\'). The matrix should fill the first row with the first `n` letters in alphabetical order, the second row should start with the `(n+1)`-th letter, and so on, wrapping back to \'A\' if necessary after reaching \'Z\'. # **Specifications** 1. The function should generate a matrix where each cell contains a unique uppercase letter. 2. If `n` is greater than 26, the function should comfortably handle wrapping around the alphabet. 3. Ensure the matrix is square and all rows are of equal length. 4. Raise a `ValueError` if `n` is less than 1 or greater than 26. # **Function Signature**: ```python def generate_unique_char_matrix(n: int) -> list: pass ``` # **Input and Output** - **Input**: An integer `n` representing the dimension of the matrix. - **Output**: A 2D list representing the `n x n` matrix filled with unique uppercase letters. # **Examples**: ```python >>> generate_unique_char_matrix(1) [[\'A\']] >>> generate_unique_char_matrix(3) [[\'A\', \'B\', \'C\'], [\'D\', \'E\', \'F\'], [\'G\', \'H\', \'I\']] >>> generate_unique_char_matrix(5) [[\'A\', \'B\', \'C\', \'D\', \'E\'], [\'F\', \'G\', \'H\', \'I\', \'J\'], [\'K\', \'L\', \'M\', \'N\', \'O\'], [\'P\', \'Q\', \'R\', \'S\', \'T\'], [\'U\', \'V\', \'W\', \'X\', \'Y\']] >>> generate_unique_char_matrix(27) Traceback (most recent call last): ... ValueError: The value of n must be between 1 and 26. >>> generate_unique_char_matrix(0) Traceback (most recent call last): ... ValueError: The value of n must be between 1 and 26. ``` # **Note** Write a function `generate_unique_char_matrix` implementing the above specifications. Ensure it adheres to the constraints and performs efficiently.","solution":"def generate_unique_char_matrix(n: int) -> list: Generate a unique n x n matrix with uppercase alphabetic characters. Args: n (int): The dimension of the matrix. Returns: list: A 2D list representing the n x n matrix. Raises: ValueError: If n is less than 1 or greater than 26. if n < 1 or n > 26: raise ValueError(\\"The value of n must be between 1 and 26.\\") matrix = [] alphabet = [chr(i) for i in range(ord(\'A\'), ord(\'Z\') + 1)] for i in range(n): row = [] for j in range(n): index = (i * n + j) % 26 row.append(alphabet[index]) matrix.append(row) return matrix"},{"question":"# Scenario You are building a system that manages the scheduling of meetings between employees at different locations. Often, employees have overlapping availability slots, and the system must find the intersection of these slots to determine possible meeting times. Your task is to implement a function that calculates the intersection of two given sets of time slots, ensuring robustness against invalid inputs and handling edge cases effectively. # Function to Implement Write a function `find_common_slots`: Input - `slots_a` (list[tuple[int, int]]): The first list of time slots where each slot is a tuple of two integers representing the start and end time. - `slots_b` (list[tuple[int, int]]): The second list of time slots where each slot is a tuple of two integers representing the start and end time. Output - list[tuple[int, int]]: A list of tuples representing the common time slots. Constraints 1. The start time must be less than the end time for each time slot. 2. Time slots are represented in a 24-hour format (0 to 23). 3. Time slots within each list are non-overlapping and sorted by start time. # Requirements 1. Raise a `ValueError` if any time slot has a start time greater than or equal to its end time. 2. Use efficient algorithms and data structures to ensure performance. 3. Ensure the resulting list of common slots is non-overlapping and sorted by start time. # Example ```python >>> find_common_slots([(9, 12), (14, 16)], [(10, 13), (15, 17)]) [(10, 12), (15, 16)] >>> find_common_slots([(9, 13)], [(14, 16)]) [] >>> find_common_slots([(8, 10)], [(10, 12)]) [] >>> find_common_slots([(8, 10), (12, 15)], [(9, 11), (13, 16)]) [(9, 10), (13, 15)] >>> find_common_slots([(8, 10), (12, 15)], [(9, 11), (13, 16), [15, 17]]) Traceback (most recent call last): ... ValueError: The start time must be less than the end time in each time slot. ``` Ensure that your code handles various edge cases, such as no overlapping time slots, multiple overlapping segments, and invalid time slots. The function should be efficient and guarantee the resulting list is correctly formatted and sorted.","solution":"def find_common_slots(slots_a, slots_b): Finds the common time slots between two lists of time slots. :param slots_a: List of time slots from the first employee. :param slots_b: List of time slots from the second employee. :return: List of common time slots. # Helper function to validate the slots def validate_slots(slots): for start, end in slots: if start >= end: raise ValueError(\\"The start time must be less than the end time in each time slot.\\") # Validate input slots validate_slots(slots_a) validate_slots(slots_b) common_slots = [] i, j = 0, 0 while i < len(slots_a) and j < len(slots_b): start_a, end_a = slots_a[i] start_b, end_b = slots_b[j] # Find the overlap between two slots start_overlap = max(start_a, start_b) end_overlap = min(end_a, end_b) if start_overlap < end_overlap: common_slots.append((start_overlap, end_overlap)) # Move to the next slot if end_a < end_b: i += 1 else: j += 1 return common_slots"},{"question":"# Question: Implement a Function to Determine the Longest Unique Substring **Context**: In string manipulation, a common problem is finding the longest substring without any repeating characters. This problem is fundamental in the study of that involves hashing, sliding windows, and optimized traversals. **Task**: You need to write a function that finds the length and value of the longest substring in a given string that contains no repeating characters. **Function Signature**: ```python def longest_unique_substring(s: str) -> tuple[int, str]: pass ``` **Input**: - `s`: A string for which you want to determine the longest unique substring. **Output**: - A tuple where the first element is the integer length of the longest unique substring and the second element is the substring itself. **Examples**: ```python >>> longest_unique_substring(\\"abcabcbb\\") (3, \\"abc\\") >>> longest_unique_substring(\\"bbbbb\\") (1, \\"b\\") >>> longest_unique_substring(\\"pwwkew\\") (3, \\"wke\\") >>> longest_unique_substring(\\"\\") (0, \\"\\") ``` **Constraints**: - The input string `s` can contain any printable ASCII characters and its length `n` is in the range [0, 10^5]. **Performance Requirement**: - The solution should work in O(n) time complexity, where n is the length of the input string. **Instructions**: - Ensure your function can handle the specified constraints efficiently. - Verify your solution using the provided examples. - Focus on optimizing the traversal and storage of characters to achieve the desired time complexity.","solution":"def longest_unique_substring(s: str) -> tuple[int, str]: Finds the longest substring without repeating characters. Returns a tuple containing the length of the substring and the substring itself. n = len(s) if n == 0: return (0, \\"\\") char_index_map = {} max_length = 0 start = 0 longest_substr = \\"\\" for end in range(n): if s[end] in char_index_map and char_index_map[s[end]] >= start: start = char_index_map[s[end]] + 1 char_index_map[s[end]] = end current_length = end - start + 1 if current_length > max_length: max_length = current_length longest_substr = s[start:end + 1] return (max_length, longest_substr)"},{"question":"# Coding Assessment Question **Context:** You are given a class implementation for managing a booking system. This system keeps track of booking start and end times, ensuring that no two bookings overlap. **Task:** **Implement a method, `add_booking(self, start, end)`, within the `BookingSystem` class**, that accepts the start and end times (both integers, representing hours of the day in a 24-hour format). This method should check if the new booking overlaps with any existing bookings. If it does not overlap, it should add the booking to the system and return `True`. Otherwise, it should return `False`. **Input & Output**: - **start**: The starting hour of the booking (integer, 0 <= start <= 23). - **end**: The ending hour of the booking (integer, 0 < end <= 24). - The method should handle edge cases gracefully, such as: - Invalid time ranges where `start >= end`. - Overlapping bookings. **Requirements**: - Consider that the bookings are not sorted and can be added in any order. - Ensure the method efficiently checks for overlapping bookings. - Assume that both `start` and `end` are within a valid 24-hour time range and `end` is always greater than `start`. **Example**: ```python class BookingSystem: def __init__(self): self.bookings = [] def add_booking(self, start, end): # Implement method here b = BookingSystem() print(b.add_booking(10, 14)) # Output: True print(b.add_booking(12, 16)) # Output: False (overlaps with the previous booking) print(b.add_booking(16, 18)) # Output: True ``` **Expectation**: - Method implementation should add non-overlapping bookings and reject overlapping ones accurately.","solution":"class BookingSystem: def __init__(self): self.bookings = [] def add_booking(self, start, end): if start >= end: return False for booking in self.bookings: if not (end <= booking[0] or start >= booking[1]): return False self.bookings.append((start, end)) return True"},{"question":"# Coding Challenge: Find K Unique Integers with the Maximum Sum Scenario You are developing a new feature for a financial analytics tool. The tool involves analyzing a list of transactions to identify the most profitable transactions. Each transaction can be represented as an integer which may be positive (profit) or negative (loss). You need to optimize the profitability by selecting a subset of transactions. Task Write a function `max_sum_k_unique(transaction_list, k)` that returns the maximum sum of `k` unique integers from a list of transactions. Expected Function Signature ```python def max_sum_k_unique(transaction_list: List[int], k: int) -> int: transaction_list: List[int] - a list of integers representing transactions (both positive and negative) k: int - the number of unique transactions to select for the maximum sum ``` Input - `transaction_list` - A list of integers where each integer represents a transaction. The length of the list is between 1 and 10^5. - `k` - An integer representing the number of unique transactions you need to select. (1 ≤ k ≤ length of transaction_list) Output - An integer representing the maximum sum of `k` unique transactions. Constraints - If `k` is greater than the number of unique integers in the transaction list, return the sum of all unique integers. - The elements can have a value between -10^6 and 10^6. Example ```python transaction_list = [10, -10, 20, -20, 30, -30, 40, -40] k = 3 print(max_sum_k_unique(transaction_list, k)) # Output should be 90 (30+40+20) ``` Additional Information - Consider the performance requirement as the list can be very large. - Attention should be given to ensure the solution efficiently handles the extraction of unique integers and calculation of their sum. - You may use additional data structures like sets or heaps to aid in meeting performance requirements.","solution":"from typing import List def max_sum_k_unique(transaction_list: List[int], k: int) -> int: # Convert the list to a set to get unique transactions unique_transactions = list(set(transaction_list)) # Sort the unique transactions in descending order unique_transactions.sort(reverse=True) # If k is greater than the number of unique transactions, adjust k if k > len(unique_transactions): k = len(unique_transactions) # Take the highest k unique transactions and sum them up return sum(unique_transactions[:k])"},{"question":"# Scenario You are part of a team that is developing a software component for managing customer orders in an e-commerce platform. One of the frequent operations is to identify the most active customers based on their order history. To accomplish this, you need to implement a function that can track and return the top N customers who have placed the most orders. # Task Write a function: 1. **top_customers**: - **Input**: * `orders` (list of tuples): Each tuple contains two elements - a customer ID (string) and an order ID (string). * `N` (int): The number of top customers to return. - **Output**: * Returns a list of customer IDs (strings), representing the top N customers who have placed the most orders. If two customers have the same number of orders, their order in the result can be arbitrary. - **Constraints**: * `N` must be a positive integer less than or equal to the number of unique customers in `orders`. * The length of `orders` will not exceed 10,000. * The length of each customer ID and order ID will not exceed 100 characters. * Each customer ID and order ID will be unique. - **Example**: ```python orders = [ (\\"cust1\\", \\"order1\\"), (\\"cust2\\", \\"order2\\"), (\\"cust1\\", \\"order3\\"), (\\"cust3\\", \\"order4\\"), (\\"cust2\\", \\"order5\\"), (\\"cust2\\", \\"order6\\") ] N = 2 top_customers(orders, N) # Returns [\\"cust2\\", \\"cust1\\"] ``` # Performance Requirements Your implementation should aim for an efficient solution with a time complexity of O(n log n), where n is the number of unique customers in `orders`. # Additional Notes - Ensure that the function handles cases where `orders` is empty or `N` is zero by returning an empty list. - Validate your solution using unit tests to check for edge cases and typical scenarios, such as having multiple customers with the same number of orders or when the number of customers is less than `N`.","solution":"from collections import Counter import heapq def top_customers(orders, N): Returns the top N customers who have placed the most orders. Parameters: orders (list of tuples): Each tuple contains two elements - a customer ID (string) and an order ID (string). N (int): The number of top customers to return. Returns: list: A list of customer IDs (strings), representing the top N customers who have placed the most orders. if not orders or N <= 0: return [] # Count the number of orders for each customer order_count = Counter(customer_id for customer_id, order_id in orders) # Get the top N customers based on the number of orders top_n_customers = heapq.nlargest(N, order_count.items(), key=lambda x: x[1]) # Return only the customer IDs return [customer_id for customer_id, _ in top_n_customers]"},{"question":"Python Function to Detect Palindromic Substrings As a software engineer at a company developing a text processing and analysis tool, your task is to implement a function that detects all unique palindromic substrings in a given string. A palindrome is a word, phrase, number, or other sequence of characters that reads the same backward as forward. Function Signature ```python def find_palindromic_substrings(s: str) -> List[str]: pass ``` Input - A string, `s`, representing the input text. Output - A list of strings, each being a unique palindromic substring found within `s`. # Constraints - The length of `s` will be between 1 and 1,000. - The characters in `s` are ASCII characters. # Performance Requirements - Your implementation should run with a time complexity of O(n^2) due to the nature of substring exploration and checks. # Sample Input/Output ```python assert find_palindromic_substrings(\\"abracadabra\\") == [\\"a\\", \\"aca\\", \\"ada\\", \\"b\\", \\"c\\", \\"d\\", \\"r\\"] assert find_palindromic_substrings(\\"racecar\\") == [\\"a\\", \\"aceca\\", \\"cec\\", \\"e\\", \\"r\\", \\"racecar\\"] assert find_palindromic_substrings(\\"aabb\\") == [\\"a\\", \\"aa\\", \\"b\\", \\"bb\\"] assert find_palindromic_substrings(\\"abcdefg\\") == [\\"a\\", \\"b\\", \\"c\\", \\"d\\", \\"e\\", \\"f\\", \\"g\\"] assert find_palindromic_substrings(\\"madam\\") == [\\"a\\", \\"ada\\", \\"d\\", \\"m\\", \\"madam\\"] ``` # Hints - Consider expanding around the center of each possible palindrome. - Remember to check for both odd-length and even-length palindromes. - Ensure that the palindromic substrings in your output are unique.","solution":"from typing import List def find_palindromic_substrings(s: str) -> List[str]: def expand_around_center(left: int, right: int): while left >= 0 and right < len(s) and s[left] == s[right]: palindromes.add(s[left:right+1]) left -= 1 right += 1 if not s: return [] palindromes = set() for i in range(len(s)): expand_around_center(i, i) # Check for odd-length palindromes expand_around_center(i, i+1) # Check for even-length palindromes return list(palindromes)"},{"question":"# Context Dynamic programming is a powerful technique used to solve problems that can be broken down into overlapping subproblems. One classic example of its application is in computing the nth Fibonacci number efficiently. # Problem Statement Implement a function to calculate the nth Fibonacci number using dynamic programming to optimize for both time and space. The Fibonacci sequence is defined as: - F(0) = 0 - F(1) = 1 - F(n) = F(n-1) + F(n-2) for n ≥ 2 # Requirements * **Function Name**: `fib` * **Input**: An integer `n` representing the position in the Fibonacci sequence * **Output**: An integer representing the nth Fibonacci number # Constraints - 0 ≤ n ≤ 30 - Optimize the algorithm to run in linear time O(n) and use O(1) space complexity. # Example ```python def fib(n: int) -> int: # Your code here # Examples: print(fib(0)) # Output: 0 print(fib(1)) # Output: 1 print(fib(10)) # Output: 55 print(fib(30)) # Output: 832040 ``` # Special Considerations - Ensure that your function handles small inputs efficiently (e.g., n = 0 or n = 1). - Use an iterative approach to keep the space complexity constant (O(1)). - Avoid exceeding time complexity of O(n) for large inputs. # Testing Create a series of unit tests to validate your function under different scenarios including base cases (n=0, n=1), edge cases, and typical inputs.","solution":"def fib(n: int) -> int: Returns the nth Fibonacci number using an iterative approach with O(n) time complexity and O(1) space complexity :param n: An integer representing the position in the Fibonacci sequence :return: The nth Fibonacci number if n == 0: return 0 if n == 1: return 1 a, b = 0, 1 for _ in range(2, n + 1): a, b = b, a + b return b"},{"question":"# Coding Assessment Question **Maximal Subarray Sum using Dynamic Programming** You are given an array of integers. Your task is to implement a function `max_subarray_sum` that finds the contiguous subarray (containing at least one number) which has the largest sum and returns that sum. The function should use a dynamic programming approach to solve the problem. Function Signature ```python def max_subarray_sum(nums: list) -> int: ``` Input * `nums` (list of integers): A list of integers. Output * An integer representing the largest sum of the contiguous subarray. Constraints * The length of `nums` will be at least 1 and at most (10^5). * The elements of `nums` will be between (-10^4) and (10^4). Example ```python nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4] result = max_subarray_sum(nums) print(result) # Output: 6 # Explanation: The subarray [4, -1, 2, 1] has the largest sum of 6. ``` Detailed Explanation * Your function should iterate through the `nums` list while maintaining a current subarray sum and updating the maximum subarray sum found. * Use a dynamic programming approach where you keep track of the maximum sum ending at the current position and update the overall maximum sum accordingly. * Finally, return the overall maximum subarray sum. Ensure your implementation correctly handles edge cases such as an array with all negative numbers or an array with a single element.","solution":"def max_subarray_sum(nums: list) -> int: Finds the contiguous subarray with the largest sum and returns that sum. if not nums: return 0 # If the list is empty, return 0 (though per constraints, list will have at least one element) # Initialize the current subarray sum and maximum subarray sum with the first element current_sum = max_sum = nums[0] # Iterate over the array starting from the second element for num in nums[1:]: current_sum = max(num, current_sum + num) # Update the current subarray sum max_sum = max(max_sum, current_sum) # Update the maximum subarray sum found so far return max_sum"},{"question":"# Question As a backend developer, you are required to retrieve specific records of employees from a database. The provided code demonstrates a basic SQL query approach using Python\'s SQLite library. Currently, the code retrieves all employee records without any conditions. Your task is to enhance this code by implementing the following requirements: 1. **Filter Records**: - Retrieve only the records of employees who earn a salary greater than a specified amount. - Include a condition to filter employees based on their department. 2. **Error Handling**: Implement error handling for the following scenarios: - Database connection failure. - Query execution failure. 3. **Logging**: Add logging to provide insights into the stages of data retrieval (e.g., connected to database, query executed, records retrieved, connection closed). # Function to Implement ```python def retrieve_employee_records(db_path: str, salary_threshold: float, department: str): pass ``` # Input - `db_path`: A string representing the file path to the SQLite database. - `salary_threshold`: A float representing the salary threshold for filtering employee records. - `department`: A string representing the department to filter the employee records. # Output - Print logs for each stage of the data retrieval (e.g., connecting to database, executing query, records retrieved, connection closed). - Print all retrieved records in a readable format (e.g., list of dictionaries). # Constraints - Use only standard Python libraries (e.g., `sqlite3`, `logging`). - Assume the database has a table named `employees` with columns: `id` (INTEGER), `name` (TEXT), `salary` (REAL), `department` (TEXT). - The salary threshold is a non-negative float. - The department is a non-empty string. # Example Scenario Your function will connect to a database located at `/path/to/database.db`, retrieve all employees in the \\"Engineering\\" department with a salary greater than 50000, and print the retrieved records. Use proper error handling and logging to ensure robustness. ```python retrieve_employee_records(\'/path/to/database.db\', 50000, \'Engineering\') ```","solution":"import sqlite3 import logging def retrieve_employee_records(db_path: str, salary_threshold: float, department: str): # Configure logging logging.basicConfig(level=logging.INFO, format=\'%(asctime)s - %(levelname)s - %(message)s\') try: # Connect to the SQLite database logging.info(\'Connecting to the database.\') conn = sqlite3.connect(db_path) cursor = conn.cursor() logging.info(\'Successfully connected to the database.\') # Define the query with placeholders for parameters query = SELECT id, name, salary, department FROM employees WHERE salary > ? AND department = ? # Execute the query with parameters logging.info(\'Executing the query.\') cursor.execute(query, (salary_threshold, department)) # Fetch all the matching records records = cursor.fetchall() # Logging the retrieved records logging.info(f\\"Retrieved {len(records)} record(s).\\") for record in records: logging.info(f\\"Record: {record}\\") # Close the connection logging.info(\'Closing the database connection.\') conn.close() return records except sqlite3.DatabaseError as e: logging.error(f\\"Database error occurred: {e}\\") return [] except Exception as e: logging.error(f\\"An unexpected error occurred: {e}\\") return []"},{"question":"# Problem Statement You are tasked with implementing a simplified version of the game \\"Conway\'s Game of Life.\\" The game is played on a two-dimensional grid where each cell is either alive or dead. The state of the grid evolves in discrete steps, and the next state of a cell depends on its eight neighbors (horizontal, vertical, and diagonal). Your goal is to implement a function that computes the next state of the grid given its current state. # Function Signature ```python def game_of_life(grid: list[list[int]]) -> list[list[int]]: pass ``` # Input - `grid`: a list of lists of integers (0 or 1) representing the current state of each cell in the grid, where `0` is a dead cell and `1` is a live cell. The grid has at least 1 row and 1 column but no more than 100 rows and 100 columns. # Output - Returns a new list of lists of integers representing the next state of the grid following the rules of the game. # Rules For each cell in the grid: - A live cell with fewer than two live neighbors dies (underpopulation). - A live cell with two or three live neighbors remains alive (survival). - A live cell with more than three live neighbors dies (overpopulation). - A dead cell with exactly three live neighbors becomes alive (reproduction). # Constraints - The grid will always be rectangular (i.e., all rows will have the same length). # Example ```python grid = [ [0, 1, 0], [0, 0, 1], [1, 1, 1], [0, 0, 0] ] print(game_of_life(grid)) # Expected Output: # [ # [0, 0, 0], # [1, 0, 1], # [0, 1, 1], # [0, 1, 0] # ] ``` # Notes - Consider edge cells and their neighbors carefully as they have fewer neighbors than the inner cells. - Ensure to create a deep copy of the grid to avoid mutating the input grid during computation. - Implement helper functions if necessary for better modularity and readability of your code. - Test your function with various grid sizes and configurations to ensure correctness and robustness.","solution":"def count_live_neighbors(grid, row, col): Helper function to count live neighbors of a cell (row, col). directions = [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)] nrows = len(grid) ncols = len(grid[0]) live_neighbors = 0 for dr, dc in directions: r, c = row + dr, col + dc if 0 <= r < nrows and 0 <= c < ncols: live_neighbors += grid[r][c] return live_neighbors def game_of_life(grid): Computes the next state of the grid given its current state. if not grid or not grid[0]: return grid nrows = len(grid) ncols = len(grid[0]) next_state = [[0] * ncols for _ in range(nrows)] for row in range(nrows): for col in range(ncols): live_neighbors = count_live_neighbors(grid, row, col) if grid[row][col] == 1: if live_neighbors < 2 or live_neighbors > 3: next_state[row][col] = 0 else: next_state[row][col] = 1 else: if live_neighbors == 3: next_state[row][col] = 1 return next_state"},{"question":"# Problem Statement You are to implement a function that takes a string representing an arithmetic expression and validates its syntax according to basic arithmetic rules. The expression may only contain digits (0-9), parentheses `(` and `)`, and arithmetic operators `+`, `-`, `*`, and `/`. # Function Signature ```python def validate_arithmetic_expression(expression: str) -> bool: pass ``` # Input - **expression** (str): A string representing the arithmetic expression to be validated. # Output - **result** (bool): Returns `True` if the expression is valid, `False` otherwise. # Constraints 1. The expression will only contain characters `[0-9]`, `[()]`, `[+-*/]`, and spaces. 2. The expression must not lead to division by zero. 3. The expression must be correctly parenthesized. 4. The expression must not start or end with an operator. 5. The expression must not have two consecutive operators. 6. Operators must be properly spaced with operands. # Examples ```python >>> validate_arithmetic_expression(\\"3 + 5 / ( 2 - 1 )\\") True >>> validate_arithmetic_expression(\\"( 3 + 2 ) * 5 )\\") False >>> validate_arithmetic_expression(\\"3 ++ 5\\") False >>> validate_arithmetic_expression(\\"10 / 0 + 2\\") False >>> validate_arithmetic_expression(\\"()\\") False ``` # Implementation Notes To validate the arithmetic expression: 1. Check for valid characters only being digits, parentheses, and operators. 2. Validate matching and correct placement of parentheses. 3. Ensure no consecutive operators exist and that expression does not start or end with an operator. 4. Check for division by zero scenarios explicitly. 5. Handle edge cases like empty parentheses, isolated operators, and continuous digits with no operator between. Your solution should correctly identify and return the validity of the given arithmetic expression considering the comprehensive set of constraints.","solution":"def validate_arithmetic_expression(expression: str) -> bool: # Remove spaces for easier processing expression = expression.replace(\' \', \'\') # Checking for invalid characters for char in expression: if char not in \\"0123456789+-*/()\\": return False # Check for correct parenthesis stack = [] for char in expression: if char == \'(\': stack.append(char) elif char == \')\': if len(stack) == 0: return False stack.pop() if len(stack) != 0: return False # Check for consecutive operators and proper spacing operators = set(\\"+-*/\\") last_char = None i = 0 while i < len(expression): char = expression[i] if char in operators: if last_char in operators or last_char is None: return False if i + 1 < len(expression) and expression[i + 1] in operators: return False if char == \')\' and (last_char in operators or last_char == \'(\'): return False if char == \'(\' and (i + 1 < len(expression) and expression[i + 1] in operators): return False if char == \'0\' and last_char == \'/\': return False last_char = char i += 1 # Check if expression starts or ends with an operator if expression[0] in operators or expression[-1] in operators: return False return True"},{"question":"# Context You are responsible for developing a small part of a web server that processes request logs. Each log entry logs various details regarding a web request including the HTTP status code. You are asked to implement a function that analyzes the log entries and provides a count of how often each status code appears. # Task Implement a function that processes a list of HTTP request logs and returns a dictionary with the count of occurrences for each HTTP status code. # Function Signature ```python def count_status_codes(logs: list) -> dict: ``` # Input - `logs` (list): A list of log entries where each entry is a string that contains an HTTP status code. Each log entry has the format: `\\"<timestamp> <method> <request_path> <status>\\"`, where `status` is a 3-digit HTTP status code (e.g., \\"200\\", \\"404\\"). # Output - Returns a dictionary where each key is a status code (string) and each value is the corresponding count of occurrences (integer). # Examples ```python assert count_status_codes([ \\"2023-10-01T12:00:00 GET /index.html 200\\", \\"2023-10-01T12:01:00 GET /about.html 404\\", \\"2023-10-01T12:02:00 POST /submit 200\\", \\"2023-10-01T12:03:00 GET /contact.html 200\\", ]) == {\\"200\\": 3, \\"404\\": 1} assert count_status_codes([ \\"2023-10-02T10:20:00 GET /home 200\\", \\"2023-10-02T10:21:00 GET /home 500\\", \\"2023-10-02T10:22:00 GET /login 401\\", \\"2023-10-02T10:23:00 POST /login 200\\", \\"2023-10-02T10:24:00 POST /logout 200\\" ]) == {\\"200\\": 3, \\"500\\": 1, \\"401\\": 1} ``` # Constraints 1. Each log entry string will be properly formatted as described above. 2. The list of logs can be empty. 3. Status codes will always be 3-digit strings. 4. The input list can contain up to 10,000 log entries. # Edge Cases 1. The function should correctly handle an empty list, returning an empty dictionary. 2. Entries with the same status code must be correctly aggregated.","solution":"def count_status_codes(logs: list) -> dict: Processes a list of HTTP request logs and returns a dictionary with the count of occurrences for each HTTP status code. status_code_count = {} for log in logs: status_code = log.split()[-1] if status_code in status_code_count: status_code_count[status_code] += 1 else: status_code_count[status_code] = 1 return status_code_count"},{"question":"# Problem: Warehouse Inventory Management System Your goal is to develop a system that manages inventory in a warehouse by keeping track of multiple product items. Each product has some essential properties, and the system should ensure efficient addition, removal, and querying of products. Task Requirements: 1. **Class Design**: - Create a class `Product` that captures: * `name` (string): The name of the product. * `category` (string): The category to which the product belongs. * `price` (float): The price of the product. * `quantity` (int): The quantity of the product available in stock. 2. **Functions**: - Implement the following methods within the `Product` class: * `__init__(self, name: str, category: str, price: float, quantity: int)`: * Initializes a product with the given attributes. Ensure price and quantity are non-negative. * `update_price(self, new_price: float)`: * Updates the product’s price. Raise a `ValueError` if the new price is negative. * `modify_quantity(self, amount: int)`: * Updates the quantity by adding the given amount. Raise a `ValueError` if the resulting quantity is negative. * `__str__(self)`: * Returns a string representation of the product in the format: `Product(name=<name>, category=<category>, price=<price>, quantity=<quantity>)`. 3. **Class Design for Inventory**: - Create a class `Inventory` that manages multiple products: * Products should be stored in an internal dictionary where keys are product names and values are `Product` instances. 4. **Functions**: - Implement the following methods within the `Inventory` class: * `__init__(self)`: * Initializes an empty inventory. * `add_product(self, product: Product)`: * Adds a new product to the inventory. If a product with the same name exists, raise a `ValueError`. * `remove_product(self, product_name: str)`: * Removes a product from the inventory by name. If the product does not exist, raise a `ValueError`. * `get_product(self, product_name: str) -> Product`: * Returns the product with the given name. If the product does not exist, raise a `ValueError`. * `list_products(self) -> str`: * Returns a string listing the products in the inventory, each on a new line, by invoking their `__str__` method. Example Classes: 1. **Product** ```python class Product: def __init__(self, name: str, category: str, price: float, quantity: int): if price < 0 or quantity < 0: raise ValueError(\\"Price and quantity must be non-negative\\") self.name = name self.category = category self.price = price self.quantity = quantity def update_price(self, new_price: float): if new_price < 0: raise ValueError(\\"New price must be non-negative\\") self.price = new_price def modify_quantity(self, amount: int): if self.quantity + amount < 0: raise ValueError(\\"Resulting quantity cannot be negative\\") self.quantity += amount def __str__(self): return f\\"Product(name={self.name}, category={self.category}, price={self.price}, quantity={self.quantity})\\" ``` 2. **Inventory** ```python class Inventory: def __init__(self): self.products = {} def add_product(self, product: Product): if product.name in self.products: raise ValueError(\\"Product with this name already exists in the inventory\\") self.products[product.name] = product def remove_product(self, product_name: str): if product_name not in self.products: raise ValueError(\\"Product does not exist in the inventory\\") del self.products[product_name] def get_product(self, product_name: str) -> Product: if product_name not in self.products: raise ValueError(\\"Product does not exist in the inventory\\") return self.products[product_name] def list_products(self) -> str: return \'n\'.join(str(product) for product in self.products.values()) ``` Test Your Classes: Ensure to cover the following cases in your tests: - Initialization of products and inventory. - Addition, removal, and querying of products. - Handling of invalid scenarios such as negative price or quantity, duplicate product names, or non-existent product references. Provide at least one test example for each method in the form of `assert` statements to validate their behavior.","solution":"class Product: def __init__(self, name: str, category: str, price: float, quantity: int): if price < 0 or quantity < 0: raise ValueError(\\"Price and quantity must be non-negative\\") self.name = name self.category = category self.price = price self.quantity = quantity def update_price(self, new_price: float): if new_price < 0: raise ValueError(\\"New price must be non-negative\\") self.price = new_price def modify_quantity(self, amount: int): if self.quantity + amount < 0: raise ValueError(\\"Resulting quantity cannot be negative\\") self.quantity += amount def __str__(self): return f\\"Product(name={self.name}, category={self.category}, price={self.price}, quantity={self.quantity})\\" class Inventory: def __init__(self): self.products = {} def add_product(self, product: Product): if product.name in self.products: raise ValueError(\\"Product with this name already exists in the inventory\\") self.products[product.name] = product def remove_product(self, product_name: str): if product_name not in self.products: raise ValueError(\\"Product does not exist in the inventory\\") del self.products[product_name] def get_product(self, product_name: str) -> Product: if product_name not in self.products: raise ValueError(\\"Product does not exist in the inventory\\") return self.products[product_name] def list_products(self) -> str: return \'n\'.join(str(product) for product in self.products.values())"},{"question":"# Coding Assessment Question # Implementing a Merge Sort Algorithm You are required to implement the merge sort algorithm, a classic divide-and-conquer sorting technique. Merge sort is known for its efficiency and consistency in performance. # Objective Implement a function `merge_sort(arr: list) -> list` that sorts a given list of integers in ascending order using the merge sort algorithm. # Input * A list of integers `arr` with length `n` (0 ≤ n ≤ 1,000,000). # Output * Return a new list of integers in ascending order. # Constraints * Your solution should have O(n log n) time complexity. * Handle an empty list as input gracefully. * Avoid using Python\'s built-in sorting functions; demonstrate the implementation from scratch. # Example ```python def merge_sort(arr: list) -> list: if len(arr) <= 1: return arr mid = len(arr) // 2 left_half = merge_sort(arr[:mid]) right_half = merge_sort(arr[mid:]) return merge(left_half, right_half) def merge(left: list, right: list) -> list: sorted_arr = [] left_idx, right_idx = 0, 0 while left_idx < len(left) and right_idx < len(right): if left[left_idx] < right[right_idx]: sorted_arr.append(left[left_idx]) left_idx += 1 else: sorted_arr.append(right[right_idx]) right_idx += 1 sorted_arr.extend(left[left_idx:]) sorted_arr.extend(right[right_idx:]) return sorted_arr # Test cases print(merge_sort([])) # Output: [] print(merge_sort([3])) # Output: [3] print(merge_sort([3, 1, 2])) # Output: [1, 2, 3] print(merge_sort([5, 2, 9, 1]))# Output: [1, 2, 5, 9] print(merge_sort([8, 7, 5, 4, 2])) # Output: [2, 4, 5, 7, 8] ``` # Guidelines 1. The `merge_sort` function should recursively divide the list until it can no more, and use the `merge` helper function to combine the sorted halves. 2. The `merge` helper function should efficiently merge two sorted lists into a single sorted list. 3. Ensure that you test your function with various inputs, including edge cases such as empty lists and single-element lists.","solution":"def merge_sort(arr: list) -> list: if len(arr) <= 1: return arr mid = len(arr) // 2 left_half = merge_sort(arr[:mid]) right_half = merge_sort(arr[mid:]) return merge(left_half, right_half) def merge(left: list, right: list) -> list: sorted_arr = [] left_idx, right_idx = 0, 0 while left_idx < len(left) and right_idx < len(right): if left[left_idx] < right[right_idx]: sorted_arr.append(left[left_idx]) left_idx += 1 else: sorted_arr.append(right[right_idx]) right_idx += 1 sorted_arr.extend(left[left_idx:]) sorted_arr.extend(right[right_idx:]) return sorted_arr"},{"question":"# Tournament Points Calculation You are tasked with implementing a function to compute the total points for a football tournament based on match results. In the tournament: - Each win grants the team 3 points. - Each draw grants both teams 1 point each. - A loss grants 0 points. The results of the matches are given in a list of strings, where each string follows the format `\\"TeamA-TeamB:ScoreA-ScoreB\\"`. For example, `\\"Red-Blue:2-1\\"` indicates that Team Red won against Team Blue with a score of 2 to 1. You need to write a function `calculate_points(results: List[str]) -> Dict[str, int]` that takes a list of match results and returns a dictionary where the keys are team names and the values are their corresponding total points. # Function Signature ```python from typing import List, Dict def calculate_points(results: List[str]) -> Dict[str, int]: pass ``` # Input - `results`: A list of strings representing match results, `1 <= len(results) <= 1000`. - Each string is in the format `\\"TeamA-TeamB:ScoreA-ScoreB\\"`, where: - `TeamA` and `TeamB` are strings of alphabetical characters with no spaces, `1 <= len(Team) <= 10`. - `ScoreA` and `ScoreB` are integers representing the scores, `0 <= Score <= 100`. # Output - A dictionary where the keys are team names (strings) and the values are integers representing the total points for each team. # Examples ```python print(calculate_points([\\"Red-Blue:2-1\\", \\"Blue-Green:2-2\\", \\"Red-Green:3-0\\"])) # Expected output: {\'Red\': 6, \'Blue\': 1, \'Green\': 1} print(calculate_points([\\"Alpha-Bravo:1-0\\", \\"Charlie-Delta:0-0\\", \\"Bravo-Charlie:2-3\\"])) # Expected output: {\'Alpha\': 3, \'Bravo\': 0, \'Charlie\': 4, \'Delta\': 1} ``` # Constraints - Ensure you handle cases where multiple teams participate and some teams might not be in certain match results. - The function must process the input efficiently and calculate the points without unnecessary overhead. # Notes - Initialize points for a team to 0 before processing their matches if they do not appear in any previously processed result. - Carefully parse the match results to ascertain which team won or if it was a draw, and update their points accordingly.","solution":"from typing import List, Dict def calculate_points(results: List[str]) -> Dict[str, int]: points = {} for result in results: teams_scores = result.split(\\":\\") teams = teams_scores[0].split(\\"-\\") scores = list(map(int, teams_scores[1].split(\\"-\\"))) teamA, teamB = teams scoreA, scoreB = scores if teamA not in points: points[teamA] = 0 if teamB not in points: points[teamB] = 0 if scoreA > scoreB: points[teamA] += 3 elif scoreA < scoreB: points[teamB] += 3 else: points[teamA] += 1 points[teamB] += 1 return points"},{"question":"# Problem Statement You have been provided with a code snippet that defines a function to merge two sorted lists into one sorted list. You are now tasked with extending the functionality to merge `k` sorted lists into one sorted list. ```python def merge_k_sorted_lists(lists: list[list[int]]) -> list[int]: pass ``` # Input - `lists` (list[list[int]]): A list of `k` sorted lists, where each list contains integer values. Each list may have a different length. # Output - Returns a single sorted list containing all the elements of the `k` lists merged together. # Constraints - The total number of integers across all lists will not exceed 10^6. - Each individual list will be sorted in non-decreasing order. - There will be at least one list, but not more than 1000 lists. - The integers in the lists will be between -10^9 and 10^9. # Example ```python >>> lists = [ ... [1, 4, 5], ... [1, 3, 4], ... [2, 6] ... ] >>> merge_k_sorted_lists(lists) [1, 1, 2, 3, 4, 4, 5, 6] >>> lists = [ ... [-10, -5, 0], ... [2, 4, 6], ... [1, 3, 7, 10], ... ] >>> merge_k_sorted_lists(lists) [-10, -5, 0, 1, 2, 3, 4, 6, 7, 10] ``` # Notes - You may use a priority queue or a min-heap to efficiently merge all the lists. - Ensure the function is optimized to handle the upper limits of the constraints effectively.","solution":"from heapq import heappush, heappop def merge_k_sorted_lists(lists): Merges k sorted lists into a single sorted list. Parameters: lists (list of lists of int): A list of k sorted lists of integers. Returns: list of int: A sorted list containing all elements from the k input lists. min_heap = [] result = [] # Initialize the heap for i, sublist in enumerate(lists): if sublist: heappush(min_heap, (sublist[0], i, 0)) # Process the heap until it\'s empty while min_heap: val, list_index, element_index = heappop(min_heap) result.append(val) # If there\'s another element in the same list, push it into the heap if element_index + 1 < len(lists[list_index]): heappush(min_heap, (lists[list_index][element_index + 1], list_index, element_index + 1)) return result"},{"question":"**Question:** You are tasked with finding the smallest positive integer `N` such that its factorial `N!` contains at least `x` trailing zeroes. Factorial of a number `N`, denoted `N!`, is the product of all positive integers less than or equal to `N`. Trailing zeroes in a number are the number of consecutive zeros at the end of the number. The number of trailing zeroes in `N!` is determined by the number of times `N!` can be divided by 10, which requires pairs of prime factors 2 and 5. Given that there are always more factors of 2 than 5 in factorials, the number of trailing zeroes is determined by the number of times 5 is a factor in the numbers from `1` to `N`. # Task: Implement a function `find_number_with_trailing_zeroes` that computes the smallest integer `N` such that `N!` has at least `x` trailing zeroes. # Input: - **`x`**: An integer representing the minimum number of trailing zeroes required. # Output: - **Return Type**: Integer - **Description**: The smallest positive integer `N` such that `N!` contains at least `x` trailing zeroes. # Constraints and Notes: - The function needs to handle large values of `x` efficiently. - The value of `x` is guaranteed to be a non-negative integer. # Example: ```python def find_number_with_trailing_zeroes(x: int) -> int: # implement the function here pass if __name__ == \\"__main__\\": x = 5 result = find_number_with_trailing_zeroes(x) print(result) # Should print the smallest integer N whose factorial has at least 5 trailing zeroes ``` # Explanation - For `x = 5`, the smallest `N` is `25` because `25!` contains six 5-factors, creating six trailing zeroes. You are expected to use efficient algorithms to avoid unnecessary computations, ensuring that the solution works within a reasonable time frame for large values of `x`.","solution":"def find_number_with_trailing_zeroes(x: int) -> int: def count_trailing_zeroes(n): count = 0 power_of_5 = 5 while n >= power_of_5: count += n // power_of_5 power_of_5 *= 5 return count if x == 0: return 0 low, high = 0, 5 * x while low < high: mid = (low + high) // 2 if count_trailing_zeroes(mid) < x: low = mid + 1 else: high = mid return low"},{"question":"# Question You are tasked with developing a system for managing a list of patient records in a healthcare application. Each patient record contains the patient\'s ID, name, age, and a list of diagnosed conditions. The goal is to implement a set of Python functions that allows you to add new patient records, retrieve patient records by their ID, and update the list of diagnosed conditions for a patient. Given the following requirements: - Implement the following functions: - `add_patient()`: Adds a new patient record to the system. - `get_patient()`: Retrieves a patient record by their ID. - `update_conditions()`: Updates the diagnosed conditions for a patient. # Function Signatures ```python def add_patient(patients: Dict[int, Dict[str, Union[str, int, List[str]]]], patient_id: int, name: str, age: int, conditions: List[str]) -> None: pass def get_patient(patients: Dict[int, Dict[str, Union[str, int, List[str]]]], patient_id: int) -> Dict[str, Union[str, int, List[str]]]: pass def update_conditions(patients: Dict[int, Dict[str, Union[str, int, List[str]]]], patient_id: int, new_conditions: List[str]) -> None: pass ``` # Parameters - `patients`: A dictionary where the keys are patient IDs (integers) and the values are dictionaries representing patient records. Each patient record dictionary contains the keys \'name\' (string), \'age\' (integer), and \'conditions\' (list of strings). - `patient_id`: An integer representing the unique identifier of a patient. - `name`: A string representing the patient\'s name. - `age`: An integer representing the patient\'s age. - `conditions`: A list of strings representing the diagnosed conditions of the patient. - `new_conditions`: A list of strings representing the new set of diagnosed conditions for a patient. # Returns - `add_patient()`: None - `get_patient()`: A dictionary representing the patient record. - `update_conditions()`: None # Example ```python patients = { 101: {\'name\': \'Alice\', \'age\': 30, \'conditions\': [\'Diabetes\']}, 102: {\'name\': \'Bob\', \'age\': 25, \'conditions\': [\'Hypertension\']} } add_patient(patients, 103, \'Charlie\', 28, [\'Asthma\']) print(get_patient(patients, 103)) # Example Output: {\'name\': \'Charlie\', \'age\': 28, \'conditions\': [\'Asthma\']} update_conditions(patients, 103, [\'Asthma\', \'Allergy\']) print(get_patient(patients, 103)) # Example Output: {\'name\': \'Charlie\', \'age\': 28, \'conditions\': [\'Asthma\', \'Allergy\']} ``` # Additional Note Ensure that patient IDs are unique. Attempting to add a patient record with an existing ID should update the existing record. Your implementation should be able to handle a large number of patient records efficiently.","solution":"def add_patient(patients, patient_id, name, age, conditions): Adds a new patient record to the system. If the patient_id already exists, update the existing record. patients[patient_id] = { \'name\': name, \'age\': age, \'conditions\': conditions } def get_patient(patients, patient_id): Retrieves a patient record by their ID. return patients.get(patient_id, None) def update_conditions(patients, patient_id, new_conditions): Updates the diagnosed conditions for a patient. if patient_id in patients: patients[patient_id][\'conditions\'] = new_conditions"},{"question":"# Coding Challenge: Unique Matrix Rows You are given a matrix of integers and need to extract the unique rows from this matrix. Each row in the matrix can contain any combination of integers, and some rows may be duplicates. Your task is to write a function that returns a list of the unique rows in the order they first appear in the matrix. Task Write a function `unique_rows` that takes a 2D list (matrix) and returns a list containing the unique rows of the matrix. Each row in the resultant list should appear only once as they first appear in the input matrix. Function Signature ```python def unique_rows(matrix: List[List[int]]) -> List[List[int]]: pass ``` Input Description - `matrix`: A 2D list of integers representing the matrix. Each sublist represents a row of the matrix. Output Description - Return a list of unique rows from the input matrix in the order they appear. Constraints - The matrix will have at least one row and one column. - The matrix dimensions do not exceed 1000 x 1000. - Each row in the matrix is a list of integers, and the integers can be both positive and negative. - Duplicate rows must be removed while preserving the order of their first appearance. Example ```python matrix = [ [1, 2, 3], [4, 5, 6], [1, 2, 3], [7, 8, 9] ] print(unique_rows(matrix)) # Output: [[1, 2, 3], [4, 5, 6], [7, 8, 9]] matrix = [ [0, 1, 0], [1, 0, 1], [0, 1, 0], [1, 0, 1], [2, 2, 2] ] print(unique_rows(matrix)) # Output: [[0, 1, 0], [1, 0, 1], [2, 2, 2]] ``` Points to Consider - Pay attention to the preservation of the order of first appearances of unique rows. - Consider using efficient data structures to handle large matrices. - Include error handling for edge cases like empty matrices or non-uniform row lengths.","solution":"from typing import List def unique_rows(matrix: List[List[int]]) -> List[List[int]]: This function returns a list containing the unique rows of the matrix in the order they first appear. seen = set() unique = [] for row in matrix: t_row = tuple(row) if t_row not in seen: seen.add(t_row) unique.append(row) return unique"},{"question":"# Problem Statement You are tasked with writing a function that finds the longest substring of unique characters from a given string. This problem aims to test your understanding of string manipulation and efficient algorithm design. # Requirements * Implement a function `longest_unique_substring` that takes a single string as input and returns the longest substring that contains all unique characters. * Ensure the algorithm\'s time complexity is efficient, ideally O(n). # Input and Output * **Input**: A string `s` which can contain lowercase letters, uppercase letters, digits, and special characters. For example: - `\\"abcabcbb\\"` - `\\"bbbbb\\"` - `\\"pwwkew\\"` - `\\"dvdf\\"` * **Output**: A string representing the longest substring with all unique characters. # Constraints 1. The input string may have a length ranging from 0 to 1,000 characters. 2. Aim to complete the operation in linear time relative to the length of the input string. # Example Scenarios Example 1: * **Input**: `\\"abcabcbb\\"` * **Output**: `\\"abc\\"` Example 2: * **Input**: `\\"bbbbb\\"` * **Output**: `\\"b\\"` Example 3: * **Input**: `\\"pwwkew\\"` * **Output**: `\\"wke\\"` Example 4: * **Input**: `\\"dvdf\\"` * **Output**: `\\"vdf\\"` Example 5: * **Input**: `\\"\\"` * **Output**: `\\"\\"` Write the function `longest_unique_substring(s: str) -> str` to find the longest substring with unique characters as described.","solution":"def longest_unique_substring(s: str) -> str: Finds the longest substring with all unique characters in a given string. :param s: Input string :return: Longest substring with all unique characters # Dictionary to store the last seen index of each character last_seen = {} start = 0 max_len = 0 max_substring = \\"\\" for end in range(len(s)): if s[end] in last_seen and last_seen[s[end]] >= start: start = last_seen[s[end]] + 1 # Update the start position last_seen[s[end]] = end # Update the last seen index of the character if end - start + 1 > max_len: max_len = end - start + 1 max_substring = s[start:end + 1] return max_substring"},{"question":"# Problem Statement: You are given an array of integers where some specific elements appear exactly twice, and the rest appear exactly once. Implement an algorithm to identify and return a list of elements that appear twice in the array. # Input: 1. An integer `n` representing the size of the array (1 ≤ n ≤ 10000). 2. An array `arr` of `n` integers (1 ≤ arr[i] ≤ n). # Output: A list of integers representing the elements that appear exactly twice in the input array. The elements in the output should be sorted in ascending order. # Constraints: - All array elements are positive integers, and their values do not exceed the size of the array. - There is at least one element that appears twice. # Example: ```python # Sample input n = 8 arr = [4, 3, 2, 7, 8, 2, 3, 1] # Expected output [2, 3] ``` # Function Signature ```python def find_duplicates(n: int, arr: list[int]) -> list[int]: pass ``` # Instructions: 1. Implement the function `find_duplicates` based on the provided function signature. 2. Your function should return a list of integers that appear twice in the input array, sorted in ascending order. 3. Consider edge cases like arrays with all elements repeated, minimal size arrays, and arrays with single repeated elements.","solution":"def find_duplicates(n: int, arr: list[int]) -> list[int]: Returns a list of integers that appear exactly twice in the input array. element_count = {} for num in arr: if num in element_count: element_count[num] += 1 else: element_count[num] = 1 duplicates = [num for num, count in element_count.items() if count == 2] return sorted(duplicates)"},{"question":"# Problem Statement You are tasked with creating a function that calculates the nth Fibonacci number using dynamic programming. The function should use memoization to store intermediate results and improve computational performance. # Implementation Details Implement the following function: ```python def fibonacci(n: int) -> int: Calculate the nth Fibonacci number using dynamic programming. Args: n (int): Position in Fibonacci sequence (0-indexed). Returns: int: The nth Fibonacci number. Examples: >>> fibonacci(0) 0 >>> fibonacci(1) 1 >>> fibonacci(10) 55 >>> fibonacci(20) 6765 pass ``` Input * `n`: An integer, the position in the Fibonacci sequence (0 ≤ n ≤ 1000) Output * An integer, the nth Fibonacci number. Constraints * The position `n` will always be a non-negative integer within the given range. # Points to Consider * Handle edge values such as `n = 0` and `n = 1`. * Make sure to use memoization to improve efficiency. * Ensure the solution is optimized for higher values of `n`. Performance Requirements * The function should complete in a reasonable time for any input size within constraints (0 ≤ n ≤ 1000). --- This question assesses the candidate\'s ability to use dynamic programming techniques to solve problems efficiently, which is a crucial skill in algorithmic problem-solving and software development.","solution":"def fibonacci(n: int) -> int: Calculate the nth Fibonacci number using dynamic programming. Args: n (int): Position in Fibonacci sequence (0-indexed). Returns: int: The nth Fibonacci number. Examples: >>> fibonacci(0) 0 >>> fibonacci(1) 1 >>> fibonacci(10) 55 >>> fibonacci(20) 6765 if n <= 1: return n memo = [0] * (n + 1) memo[0] = 0 memo[1] = 1 for i in range(2, n + 1): memo[i] = memo[i - 1] + memo[i - 2] return memo[n]"},{"question":"# Task Description You are given an array of integers and a target sum. Your task is to implement a function that finds two distinct numbers in the array that add up to the target sum. If such a pair does not exist, return `None`. # Function to Implement `find_pair_with_target_sum(arr: list, target: int)` * **Input**: - `arr` (list): A list of integers. - `target` (int): The target sum. * **Output**: - Returns a tuple of two integers `(num1, num2)` such that `num1 + num2 == target`, or `None` if no such pair exists. # Constraints * The input array is guaranteed to have at least two elements. * Assume all numbers are integers. * Assume there may be negative, zero, and positive numbers. * The solution should have a time complexity better than O(n^2). # Requirements 1. Implement the `find_pair_with_target_sum` function that: - Uses an efficient algorithm to find the pair (consider using a hash map). - Returns the pair of numbers if found, else returns `None`. - Ensures the pair consists of distinct elements. # Example ```python # Example usage of the find_pair_with_target_sum function result = find_pair_with_target_sum([2, 7, 11, 15], 9) print(result) # Output: (2, 7) result = find_pair_with_target_sum([3, 2, 4], 6) print(result) # Output: (2, 4) result = find_pair_with_target_sum([3, 3], 6) print(result) # Output: None ``` # Notes * Make sure to handle cases where multiple pairs can add up to the target sum, but only return one valid pair. * Try to implement the function with optimal performance in mind.","solution":"def find_pair_with_target_sum(arr, target): Find two distinct numbers in the array that add up to the target sum. :param arr: List of integers :param target: Integer target sum :return: Tuple of two integers if found, else None seen = {} for num in arr: complement = target - num if complement in seen: return (complement, num) seen[num] = True return None"},{"question":"# Coding Assessment Question **Context**: You need to write a function that takes a string containing only uppercase letters and returns it transformed in a way that no letter occurs more than once in succession. This is a common pre-processing step in text compression algorithms where redundancy is reduced. Write a Python function `transform_string(text: str) -> str` that takes an input string and returns a new string in which no character appears consecutively more than once. **Function Signature**: ```python def transform_string(text: str) -> str: ``` **Input**: - `text`: string, a non-empty string containing only uppercase letters (A-Z). **Output**: - Return a string with consecutive duplicate characters removed. **Constraints**: - The input string length will not exceed 10^4. - The input string will contain only uppercase English letters. **Example**: ```python result = transform_string(\\"AAABBCCCCDDDE\\") print(result) # Should return \\"ABCDBE\\" result = transform_string(\\"A\\") print(result) # Should return \\"A\\" result = transform_string(\\"AAA\\") print(result) # Should return \\"A\\" ``` **Additional Instructions**: 1. Ensure the function performs efficiently, even for the upper limit of the input size. 2. Handle the edge cases, such as a single character string or a string with all identical characters. 3. The function should be case-sensitive and only deal with uppercase letters as specified.","solution":"def transform_string(text: str) -> str: Returns a new string where no character appears consecutively more than once. Parameters: text (str): a non-empty string containing only uppercase English letters (A-Z) Returns: str: a transformed string with consecutive duplicates removed. if not text: return \\"\\" result = [text[0]] for char in text[1:]: if char != result[-1]: result.append(char) return \\"\\".join(result)"},{"question":"# Question: Minimum Moves to Equal Array Elements II You are given an integer array `nums` of length `n` (1 ≤ n ≤ 100,000). Find the minimum number of moves required to make all array elements equal, where a move is defined as incrementing or decrementing an element by one. # Input * An integer array `nums` of length `n`. # Output * Return an integer representing the minimum number of moves required. # Constraints * You must solve this problem with an optimal algorithm to ensure performance with large arrays. # Example Input ```python nums = [1, 2, 3] ``` Output ```python 2 ``` Explanation The optimal solution is to move the 1 up to 2 and the 3 down to 2, resulting in two moves. Input ```python nums = [1, 10, 2, 9] ``` Output ```python 16 ``` Explanation The optimal solution here is to adjust all elements to 5 or 6, resulting in a minimum of 16 moves. # Function Signature ```python def min_moves(nums: List[int]) -> int: pass ```","solution":"from typing import List def min_moves(nums: List[int]) -> int: nums.sort() median = nums[len(nums) // 2] return sum(abs(num - median) for num in nums)"},{"question":"# Currency Conversion and Tax Calculation Task You are helping to develop an e-commerce platform that deals with multiple currencies and includes tax calculations for each product. Task Implement two functions: 1. `convert_currency(amount: float, rate: float) -> float` 2. `apply_tax(amount: float, tax_rate: float) -> float` # Input - `convert_currency` - `amount`: The amount of money in the original currency (floating-point number). - `rate`: The conversion rate to the target currency (floating-point number). - `apply_tax` - `amount`: The amount of money before tax (floating-point number). - `tax_rate`: The tax rate as a percentage (floating-point number). # Output - `convert_currency` returns the converted amount in the target currency (floating-point number). - `apply_tax` returns the total amount after applying the tax (floating-point number). # Constraints - Values for `amount`, `rate`, and `tax_rate` are always finite floating-point numbers. - `rate` and `tax_rate` are positive floating-point numbers, and typically `tax_rate` will be given as a percentage (0-100). # Examples ```python assert convert_currency(100.0, 0.85) == 85.0 assert convert_currency(200.0, 1.2) == 240.0 assert apply_tax(100.0, 15.0) == 115.0 assert apply_tax(200.0, 7.5) == 215.0 # Combined usage usd_amount = convert_currency(100.0, 0.85) final_amount = apply_tax(usd_amount, 15.0) assert final_amount == 97.75 # 85.0 after conversion, 97.75 after tax ``` # Notes Ensure your implementation handles: - Proper rounding of floating-point numbers to an appropriate number of decimal places. - Accurate application of the conversion and tax calculations. - Efficiency in processing high volumes of transactions.","solution":"def convert_currency(amount: float, rate: float) -> float: Convert an amount of money to another currency using the provided rate. Parameters: amount (float): The amount of money in the original currency. rate (float): The conversion rate to the target currency. Returns: float: The converted amount in the target currency. return round(amount * rate, 2) def apply_tax(amount: float, tax_rate: float) -> float: Apply tax to the given amount. Parameters: amount (float): The amount of money before tax. tax_rate (float): The tax rate as a percentage. Returns: float: The total amount after applying the tax. tax_amount = amount * (tax_rate / 100) return round(amount + tax_amount, 2)"},{"question":"# Problem Statement You are assigned to implement a function that finds and returns the longest contiguous subarray with the same value from a given list of integers. # Detailed Instructions Function Signature ```python def longest_contiguous_subarray(arr: List[int]) -> List[int]: pass ``` Inputs - `arr` (List[int]): A list of integers where the subarray needs to be found. Output - (List[int]): The longest contiguous subarray with the same value. If there are multiple subarrays with the same maximum length, return the one that appears first. # Requirements 1. Design an efficient algorithm to identify the longest subarray with the same value. 2. Handle edge cases such as empty lists, lists with all unique elements, and lists with repeated sequences. 3. Ensure the solution is optimized for large lists. # Constraints - The function should run efficiently, ideally in O(n) time complexity. - The input list `arr` can contain up to 10^5 elements. # Examples ```python >>> longest_contiguous_subarray([1, 1, 2, 2, 2, 3, 3]) [2, 2, 2] >>> longest_contiguous_subarray([5, 5, 5, 5]) [5, 5, 5, 5] >>> longest_contiguous_subarray([1, 2, 3, 4, 5]) [1] >>> longest_contiguous_subarray([]) [] >>> longest_contiguous_subarray([8, 8, 9, 9, 9, 8, 8, 8, 8]) [8, 8, 8, 8] ``` Implement the `longest_contiguous_subarray` function to meet the above requirements and thoroughly test it to ensure correctness and performance.","solution":"from typing import List def longest_contiguous_subarray(arr: List[int]) -> List[int]: if not arr: return [] max_subarray_start = 0 max_subarray_len = 1 current_start = 0 current_len = 1 for i in range(1, len(arr)): if arr[i] == arr[i - 1]: current_len += 1 else: current_start = i current_len = 1 if current_len > max_subarray_len: max_subarray_len = current_len max_subarray_start = current_start return arr[max_subarray_start:max_subarray_start + max_subarray_len]"},{"question":"# K-Means Clustering for Customer Segmentation You are tasked with implementing the K-Means clustering algorithm from scratch to perform customer segmentation based on purchasing behaviors. Your task involves: 1. Downloading and processing a given dataset. 2. Implementing the K-Means algorithm. 3. Visualizing the clusters. Dataset The dataset contains three columns: `CustomerID`, `Spending`, and `Visits`, with the first row containing headers. Each row represents a customer\'s spending behavior and the number of visits to the store. **Download URL**: ``` https://example.com/customer_behavior.csv ``` Task Requirements 1. **Function to Collect Dataset**: - Read and return the dataset as a matrix. - Parse the CSV data from the URL. 2. **Function to Initialize Centroids**: - Randomly initialize `k` centroids from the dataset. 3. **Function to Assign Clusters**: - For each data point, assign it to the nearest centroid. 4. **Function to Update Centroids**: - Update centroids by calculating the mean of all the data points assigned to each centroid. 5. **Function to Run K-Means**: - Implement the iterative process of assigning clusters and updating centroids until convergence. 6. **Function to Visualize Clusters**: - Plot the data points and centroids on a 2D graph. 7. **Main Execution**: - Load the data, process it, and run K-Means clustering. - Plot the final clusters. Function Signatures You should implement the following functions: 1. `collect_dataset() -> np.matrix` 2. `initialize_centroids(data: np.matrix, k: int) -> np.matrix` 3. `assign_clusters(data: np.matrix, centroids: np.matrix) -> np.array` 4. `update_centroids(data: np.matrix, assignments: np.array, k: int) -> np.matrix` 5. `run_kmeans(data: np.matrix, k: int, max_iterations: int = 100) -> Tuple[np.matrix, np.matrix]` 6. `visualize_clusters(data: np.matrix, centroids: np.matrix, assignments: np.array) -> None` Input & Output Format - Input: **None**. The function should fetch the dataset and perform computations internally. - Output: **Plot of the clusters** showing the segmented customer groups. Example ```python import numpy as np import matplotlib.pyplot as plt import requests import csv def collect_dataset() -> np.matrix: url = \'https://example.com/customer_behavior.csv\' response = requests.get(url) data = list(csv.reader(response.text.strip().split(\'n\'))) data_matrix = np.array(data[1:], dtype=float) return data_matrix def initialize_centroids(data: np.matrix, k: int) -> np.matrix: indices = np.random.choice(data.shape[0], k, replace=False) return data[indices] def assign_clusters(data: np.matrix, centroids: np.matrix) -> np.array: distances = np.linalg.norm(data[:, np.newaxis] - centroids, axis=2) return np.argmin(distances, axis=1) def update_centroids(data: np.matrix, assignments: np.array, k: int) -> np.matrix: new_centroids = np.array([data[assignments == ki].mean(axis=0) for ki in range(k)]) return new_centroids def run_kmeans(data: np.matrix, k: int, max_iterations: int = 100) -> Tuple[np.matrix, np.matrix]: centroids = initialize_centroids(data, k) for _ in range(max_iterations): assignments = assign_clusters(data, centroids) new_centroids = update_centroids(data, assignments, k) if np.all(centroids == new_centroids): break centroids = new_centroids return centroids, assignments def visualize_clusters(data: np.matrix, centroids: np.matrix, assignments: np.array) -> None: plt.scatter(data[:, 0], data[:, 1], c=assignments, cmap=\'viridis\') plt.scatter(centroids[:, 0], centroids[:, 1], s=300, c=\'red\', marker=\'x\') plt.xlabel(\'Spending\') plt.ylabel(\'Visits\') plt.title(\'Customer Segmentation using K-Means\') plt.show() def main(): data = collect_dataset() k = 3 centroids, assignments = run_kmeans(data, k) visualize_clusters(data, centroids, assignments) if __name__ == \\"__main__\\": main() ``` Constraints - Handle network errors while fetching the dataset. - Ensure that if two centroids are the same, reinitialize one to avoid division by zero errors. - Optimize the algorithm to run within a reasonable time frame given `max_iterations <= 1000`.","solution":"import numpy as np import matplotlib.pyplot as plt import requests import csv from typing import Tuple def collect_dataset() -> np.matrix: Downloads and processes the customer behavior dataset. url = \'https://example.com/customer_behavior.csv\' # Example URL; replace with actual URL response = requests.get(url) response.raise_for_status() data = list(csv.reader(response.text.strip().split(\'n\'))) data_matrix = np.array(data[1:], dtype=float) # Exclude header and convert to float matrix return data_matrix def initialize_centroids(data: np.matrix, k: int) -> np.matrix: Randomly initializes k centroids from the dataset. indices = np.random.choice(data.shape[0], k, replace=False) return np.array(data[indices]) def assign_clusters(data: np.matrix, centroids: np.matrix) -> np.array: Assigns each data point to the nearest centroid. distances = np.linalg.norm(data[:, np.newaxis] - centroids, axis=2) return np.argmin(distances, axis=1) def update_centroids(data: np.matrix, assignments: np.array, k: int) -> np.matrix: Updates centroids by calculating the mean of all data points assigned to each centroid. new_centroids = np.array([data[assignments == ki].mean(axis=0) for ki in range(k)]) return new_centroids def run_kmeans(data: np.matrix, k: int, max_iterations: int = 100) -> Tuple[np.matrix, np.array]: Runs the K-Means clustering algorithm. centroids = initialize_centroids(data, k) for _ in range(max_iterations): assignments = assign_clusters(data, centroids) new_centroids = update_centroids(data, assignments, k) if np.allclose(centroids, new_centroids): break centroids = new_centroids return centroids, assignments def visualize_clusters(data: np.matrix, centroids: np.matrix, assignments: np.array) -> None: Visualizes the clustered data points and centroids. plt.scatter(data[:, 1], data[:, 2], c=assignments, cmap=\'viridis\') plt.scatter(centroids[:, 1], centroids[:, 2], s=300, c=\'red\', marker=\'x\') plt.xlabel(\'Spending\') plt.ylabel(\'Visits\') plt.title(\'Customer Segmentation using K-Means\') plt.show() def main(): Main execution function to load data, run K-Means, and visualize clusters. data = collect_dataset() k = 3 centroids, assignments = run_kmeans(data, k) visualize_clusters(data, centroids, assignments) if __name__ == \\"__main__\\": main()"},{"question":"# Question: Implementing K-Means Clustering from Scratch K-Means Clustering is a popular unsupervised learning algorithm used to partition data into `k` distinct clusters. Given a set of data points, the algorithm assigns each point to one of the `k` clusters such that the sum of the squared distances from each point to its assigned cluster center is minimized. Implement the function `k_means_clustering(data, k, max_iters=300, tolerance=1e-4)` that performs the K-Means Clustering algorithm from scratch. **Input**: - `data` (2D numpy array): A dataset where each row corresponds to a data point and each column corresponds to a feature. - `k` (int): The number of clusters. - `max_iters` (int): The maximum number of iterations. Default is 300. - `tolerance` (float): The tolerance level for changes in cluster centroids. Default is 1e-4. **Output**: - `centroids` (2D numpy array): The final positions of the `k` cluster centroids. - `labels` (1D numpy array): The cluster assignment for each data point. **Constraints**: - The input `data` should be a numpy array with numerical entries. - The number of features (columns) in `data` is at most 10, and the number of data points (rows) is at most 10000. - Ensure the algorithm terminates either when `max_iters` is reached or when the change in centroids is smaller than `tolerance`. **Performance Requirements**: - The algorithm should converge efficiently within feasible iterations and computation time. - Optimize for both time and space complexity to handle the input size constraints. **Implementation Details**: - Randomly initialize `k` centroids from the data points. - Iterate the main steps of assigning data points to the nearest centroid and updating centroid positions. - Check for convergence based on the change in centroid positions. Example: ```python import numpy as np def k_means_clustering(data, k, max_iters=300, tolerance=1e-4): def initialize_centroids(data, k): indices = np.random.choice(len(data), k, replace=False) return data[indices] def assign_clusters(data, centroids): distances = np.linalg.norm(data[:, np.newaxis] - centroids, axis=2) return np.argmin(distances, axis=1) def update_centroids(data, labels, k): return np.array([data[labels == i].mean(axis=0) for i in range(k)]) centroids = initialize_centroids(data, k) for _ in range(max_iters): labels = assign_clusters(data, centroids) new_centroids = update_centroids(data, labels, k) if np.linalg.norm(new_centroids - centroids) < tolerance: break centroids = new_centroids return centroids, labels # Example Usage: if __name__ == \\"__main__\\": from sklearn.datasets import make_blobs import matplotlib.pyplot as plt # Generate example data data, _ = make_blobs(n_samples=300, centers=4, cluster_std=0.60, random_state=0) centroids, labels = k_means_clustering(data, k=4) plt.scatter(data[:, 0], data[:, 1], c=labels, s=50, cmap=\'viridis\') plt.scatter(centroids[:, 0], centroids[:, 1], c=\'red\', s=200, alpha=0.5) plt.show() ``` **Hints**: - Normalize data if necessary to ensure different scales of features do not skew the clustering. - Carefully handle cases where a cluster might end up with no data points assigned during iterations. - Use numpy operations to ensure efficient computation of distances and centroid updates.","solution":"import numpy as np def k_means_clustering(data, k, max_iters=300, tolerance=1e-4): def initialize_centroids(data, k): indices = np.random.choice(len(data), k, replace=False) return data[indices] def assign_clusters(data, centroids): distances = np.linalg.norm(data[:, np.newaxis] - centroids, axis=2) return np.argmin(distances, axis=1) def update_centroids(data, labels, k): return np.array([data[labels == i].mean(axis=0) for i in range(k)]) centroids = initialize_centroids(data, k) for _ in range(max_iters): labels = assign_clusters(data, centroids) new_centroids = update_centroids(data, labels, k) if np.linalg.norm(new_centroids - centroids) < tolerance: break centroids = new_centroids return centroids, labels"},{"question":"# Scenario You are working on a text processing application and need to implement a feature for word frequency analysis. This feature is tasked with identifying the most frequent words in a given paragraph of text, disregarding common punctuation and case differences. For example, for the paragraph \\"Hello world! Hello, everyone.\\", the most frequent word would be \\"hello\\". # Task Write two functions: 1. `word_frequency(text: str) -> dict` - This function should take a string paragraph as input and return a dictionary where the keys are words and the values are their respective frequencies. 2. `most_frequent_word(freq_dict: dict) -> str` - This function should take a dictionary generated by the first function and return the word with the highest frequency. In case of ties, return any one of the most frequent words. # Constraints * The input string will contain letters (A-Z, a-z), spaces, and common punctuation marks (.,!?). * Words are case-insensitive and should be normalized to lowercase in the frequency count. * The input string for `word_frequency` will be non-empty. # Input and Output Formats * **Word Frequency Function**: * Input: A string `text`. * Output: A dictionary with words as keys and their frequencies as values. * **Most Frequent Word Function**: * Input: A dictionary with words as keys and their frequencies as values. * Output: A string representing the most frequent word. --- # Example Word Frequency Analysis ```python >>> text = \\"Hello world! Hello, everyone.\\" >>> word_frequency(text) {\'hello\': 2, \'world\': 1, \'everyone\': 1} >>> freq_dict = {\'hello\': 2, \'world\': 1, \'everyone\': 1} >>> most_frequent_word(freq_dict) \'hello\' ``` # Edge Cases 1. Paragraph with punctuation only between words: ```python >>> text = \\"Hi, my name is Alice. Alice is my name!\\" >>> word_frequency(text) {\'hi\': 1, \'my\': 2, \'name\': 2, \'is\': 2, \'alice\': 2} >>> most_frequent_word({\'hi\': 1, \'my\': 2, \'name\': 2, \'is\': 2, \'alice\': 2}) \'my\' # or \'name\' or \'is\' or \'alice\' ``` 2. Paragraph with a single word repeated: ```python >>> text = \\"Test. Test. Test!\\" >>> word_frequency(text) {\'test\': 3} >>> most_frequent_word({\'test\': 3}) \'test\' ``` Ensure both functions handle these scenarios correctly.","solution":"import re from collections import defaultdict def word_frequency(text: str) -> dict: Returns a dictionary where the keys are words and the values are their respective frequencies. # Removing punctuation and converting text to lowercase words = re.findall(r\'bw+b\', text.lower()) freq_dict = defaultdict(int) for word in words: freq_dict[word] += 1 return dict(freq_dict) def most_frequent_word(freq_dict: dict) -> str: Returns the word with the highest frequency from the given dictionary. In case of ties, returns any one of the most frequent words. return max(freq_dict, key=freq_dict.get)"},{"question":"# Coding Assessment Question You are tasked with implementing two classes: `City` and `RouteNetwork`. The `RouteNetwork` class manages a network of cities and the distances between them. It should provide functionality to add cities, connect them with routes of specific distances, and calculate the shortest path between two cities using Dijkstra\'s algorithm. **Objective**: Implement the `City` and `RouteNetwork` classes with the following specifications. # City Class Specifications: 1. **Constructor**: ```python def __init__(self, name: str) -> None ``` - Initializes a city with a given `name`. # RouteNetwork Class Specifications: 1. **Constructor**: ```python def __init__(self) -> None ``` - Initializes an empty route network. 2. **Methods**: - `add_city(self, city: City) -> None` : Adds a city to the network. - `connect_cities(self, city1: City, city2: City, distance: float) -> None` : Connects two cities with a route of a specified distance. - `shortest_path(self, start: City, end: City) -> Tuple[float, List[str]]` : Calculates the shortest path between two cities using Dijkstra\'s algorithm. Returns the total distance and the path as a list of city names. # Input and Output Formats: - Cities are represented as instances of the `City` class, identified by their `name`. - The shortest path method should return a tuple containing the total distance (a float) and a list of city names representing the path. - Raise `ValueError` with descriptive messages for invalid input formats and other error scenarios such as cities not present in the network or when trying to connect cities that are not in the network. # Constraints: - The maximum number of cities in the network will be 1000. - Route distances will be positive floats. # Example Usage: ```python # Creating cities city_a = City(\\"A\\") city_b = City(\\"B\\") city_c = City(\\"C\\") # Creating and managing the route network network = RouteNetwork() network.add_city(city_a) network.add_city(city_b) network.add_city(city_c) network.connect_cities(city_a, city_b, 5.0) network.connect_cities(city_b, city_c, 3.0) network.connect_cities(city_a, city_c, 10.0) # Calculating the shortest path dist, path = network.shortest_path(city_a, city_c) # Output: dist = 8.0, path = [\\"A\\", \\"B\\", \\"C\\"] ``` **Your task**: Implement the `City` and `RouteNetwork` classes as per the above specifications.","solution":"import heapq from typing import List, Tuple, Dict class City: def __init__(self, name: str) -> None: self.name = name class RouteNetwork: def __init__(self) -> None: self.cities = {} self.adjacency_list = {} def add_city(self, city: City) -> None: if city.name in self.cities: raise ValueError(f\\"City {city.name} already exists.\\") self.cities[city.name] = city self.adjacency_list[city.name] = [] def connect_cities(self, city1: City, city2: City, distance: float) -> None: if city1.name not in self.cities or city2.name not in self.cities: raise ValueError(\\"Both cities must be in the network to connect them.\\") self.adjacency_list[city1.name].append((distance, city2.name)) self.adjacency_list[city2.name].append((distance, city1.name)) def shortest_path(self, start: City, end: City) -> Tuple[float, List[str]]: if start.name not in self.cities or end.name not in self.cities: raise ValueError(\\"Both start and end cities must be in the network.\\") distances = {city: float(\'inf\') for city in self.cities} previous_nodes = {city: None for city in self.cities} distances[start.name] = 0 priority_queue = [(0, start.name)] while priority_queue: current_distance, current_city = heapq.heappop(priority_queue) if current_distance > distances[current_city]: continue for adjacent_distance, adjacent_city in self.adjacency_list[current_city]: distance = current_distance + adjacent_distance if distance < distances[adjacent_city]: distances[adjacent_city] = distance previous_nodes[adjacent_city] = current_city heapq.heappush(priority_queue, (distance, adjacent_city)) path = [] if distances[end.name] == float(\'inf\'): return float(\'inf\'), path # No path found current_city = end.name while current_city: path.append(current_city) current_city = previous_nodes[current_city] path.reverse() return distances[end.name], path"},{"question":"# Sorting Algorithms: Merge Sort Implementation In this task, you are required to implement the merge sort algorithm, which is a classic example of the divide-and-conquer paradigm. Merge sort is known for its efficiency in sorting by recursively breaking down the array into smaller subarrays and then merging them back together in a sorted manner. # Problem Statement Write a function `merge_sort` that sorts a list of integers using the merge sort algorithm. The function should utilize a helper function `merge` to combine two sorted subarrays into a single sorted array. # Function Signature ```python def merge_sort(arr: List[int]) -> List[int]: ``` # Input - `arr`: A list of integers that needs to be sorted. # Output - A new list containing the sorted integers from the input list. # Constraints 1. The list will contain at most 10,000 integers. 2. Each integer in the list will be between -10^6 and 10^6. # Requirements 1. **Recursive Splitting**: Implement the function to recursively split the list into smaller subarrays. 2. **Merging**: Implement a helper function `merge` to combine two sorted subarrays into a single sorted array. 3. **Sorting**: Ensure the entire list is sorted in ascending order after the merge sort process. # Example ```python # Sample input arr = [38, 27, 43, 3, 9, 82, 10] # Perform merge sort sorted_arr = merge_sort(arr) print(sorted_arr) ``` # Expected Output ```python [3, 9, 10, 27, 38, 43, 82] ``` # Notes 1. Do not use Python\'s built-in sorting functions like `sorted` or `list.sort()` for the solution. 2. Ensure that your implementation handles the entire recursive divide-and-conquer sorting process efficiently.","solution":"from typing import List def merge_sort(arr: List[int]) -> List[int]: def merge(left: List[int], right: List[int]) -> List[int]: sorted_list = [] i = j = 0 while i < len(left) and j < len(right): if left[i] < right[j]: sorted_list.append(left[i]) i += 1 else: sorted_list.append(right[j]) j += 1 while i < len(left): sorted_list.append(left[i]) i += 1 while j < len(right): sorted_list.append(right[j]) j += 1 return sorted_list if len(arr) <= 1: return arr mid = len(arr) // 2 left_half = merge_sort(arr[:mid]) right_half = merge_sort(arr[mid:]) return merge(left_half, right_half)"},{"question":"# Rotating a Singly Linked List Write a function to rotate a singly linked list by \'k\' positions to the right. This means that the list should be modified so that the \'k\' last elements become the first k elements of the list in the same order, and all other elements are shifted accordingly. Class Definition Your task is to implement the following method in the `SinglyLinkedList` class, along with the `Node` class: - `rotate(k: int)`: Rotates the list to the right by \'k\' positions. If \'k\' is greater than the length of the list, the method should effectively behave as if \'k\' were `k % n`, where `n` is the length of the list. If \'k\' is zero or if the list is empty, the list should remain unchanged. Additionally, provide a `__str__()` method to convert the list to a string representation, where elements are separated by \'->\'. Requirements: 1. The rotation should be done in a single pass through the list wherever possible. 2. The list elements should retain their relative order after rotation. 3. Handle edge cases like an empty list or when \'k\' is greater than the length of the list. Constraints: - Integers will be used as data in nodes. - Assume the list can contain up to 10,000 nodes. ```python class Node: def __init__(self, data: int = 0, next: \'Node\' = None): self.data = data self.next = next class SinglyLinkedList: def __init__(self): self.head = None def append(self, data: int): new_node = Node(data) if not self.head: self.head = new_node return current = self.head while current.next: current = current.next current.next = new_node def rotate(self, k: int): if not self.head or k == 0: return # Calculate the length of the list current = self.head length = 1 while current.next: current = current.next length += 1 # Compute the effective rotation k = k % length if k == 0: return # Make the list circular current.next = self.head # Find the new head and tail steps_to_new_head = length - k new_tail = self.head for _ in range(steps_to_new_head - 1): new_tail = new_tail.next new_head = new_tail.next # Break the circle new_tail.next = None self.head = new_head def __str__(self) -> str: result = [] current = self.head while current: result.append(str(current.data)) current = current.next return \\"->\\".join(result) # Example Usage: # sll = SinglyLinkedList() # sll.append(1) # sll.append(2) # sll.append(3) # sll.append(4) # sll.append(5) # print(sll) # Output: 1->2->3->4->5 # sll.rotate(2) # print(sll) # Output: 4->5->1->2->3 # sll.rotate(3) # print(sll) # Output: 2->3->4->5->1 ```","solution":"class Node: def __init__(self, data: int = 0, next: \'Node\' = None): self.data = data self.next = next class SinglyLinkedList: def __init__(self): self.head = None def append(self, data: int): new_node = Node(data) if not self.head: self.head = new_node return current = self.head while current.next: current = current.next current.next = new_node def rotate(self, k: int): if not self.head or k == 0: return # Calculate the length of the list current = self.head length = 1 while current.next: current = current.next length += 1 # Compute the effective rotation k = k % length if k == 0: return # Make the list circular current.next = self.head # Find the new head and tail steps_to_new_head = length - k new_tail = self.head for _ in range(steps_to_new_head - 1): new_tail = new_tail.next new_head = new_tail.next # Break the circle new_tail.next = None self.head = new_head def __str__(self) -> str: result = [] current = self.head while current: result.append(str(current.data)) current = current.next return \\"->\\".join(result)"},{"question":"# Scenario Software engineers often need to deal with various sorting algorithms to optimize the performance of their applications. Among these algorithms, Merge Sort is particularly notable for its efficiency with large datasets. Your task is to extend the given code for implementing the Merge Sort algorithm to sort a list of dictionaries based on a specified key. # Problem Design a function `merge_sort_dicts(lst: list[dict], key: str) -> list[dict]` to sort a list of dictionaries in ascending order based on the values of a specified key using the Merge Sort algorithm. 1. The input `lst` will be a list of dictionaries where each dictionary contains at least the specified `key`. 2. The parameter `key` will be a string representing the key by which the list needs to be sorted. Example ```python def merge_sort_dicts(lst: list[dict], key: str) -> list[dict]: pass # Examples data = [ {\'name\': \'Alice\', \'score\': 72}, {\'name\': \'Bob\', \'score\': 95}, {\'name\': \'Charlie\', \'score\': 85}, {\'name\': \'Dave\', \'score\': 68} ] print(merge_sort_dicts(data, \'score\')) # [{\'name\': \'Dave\', \'score\': 68}, {\'name\': \'Alice\', \'score\': 72}, {\'name\': \'Charlie\', \'score\': 85}, {\'name\': \'Bob\', \'score\': 95}] data2 = [ {\'name\': \'Alice\', \'age\': 25}, {\'name\': \'Charlie\', \'age\': 35}, {\'name\': \'Bob\', \'age\': 22} ] print(merge_sort_dicts(data2, \'age\')) # [{\'name\': \'Bob\', \'age\': 22}, {\'name\': \'Alice\', \'age\': 25}, {\'name\': \'Charlie\', \'age\': 35}] ``` # Constraints * The input list will have at least one dictionary. * All dictionaries in the list will contain the specified key. * The values associated with the key will be comparable (e.g., integers, floats). * Assume that all key values are valid and no extra validation is required for keys or their values. # Function Signature ```python def merge_sort_dicts(lst: list[dict], key: str) -> list[dict]: pass ``` # Considerations 1. **Complexity**: Ensure that your implementation of Merge Sort maintains the `O(n log n)` complexity. 2. **Stability**: Maintain the order of items with equal key values as they appear in the original list. 3. **Recursion**: Utilize recursion effectively to split and merge the list.","solution":"def merge_sort_dicts(lst: list[dict], key: str) -> list[dict]: if len(lst) <= 1: return lst def merge(left, right, key): sorted_list = [] while left and right: if left[0][key] <= right[0][key]: sorted_list.append(left.pop(0)) else: sorted_list.append(right.pop(0)) sorted_list.extend(left if left else right) return sorted_list mid = len(lst) // 2 left_half = merge_sort_dicts(lst[:mid], key) right_half = merge_sort_dicts(lst[mid:], key) return merge(left_half, right_half, key)"},{"question":"# Problem: Validate US Phone Numbers Task Write a function `validate_phone_number(phone_number: str) -> bool` that validates whether a given string meets the criteria of a valid US phone number. A valid US phone number follows these patterns: - Optionally starts with a \'+\' followed by the country code \'1\' (e.g., +1). - Optionally starts with a country code \'1\' followed by a dash (e.g., 1-). - Three digits for the area code (required), which may be enclosed in parentheses. - Three digits following the area code and then four digits at the end. - Digits may be separated by spaces, dashes, or periods. The function should adhere to these rules and constraints and should correctly identify both valid and invalid phone numbers. Input - `phone_number` (str): A string representing the phone number to be validated. Output - Returns `True` if the phone number is valid according to the given criteria, `False` otherwise. Constraints - The input string will have a maximum length of (50). - The input must be a string. If not, raise a `ValueError` with a message indicating the type of the input found. Function Signature ```python def validate_phone_number(phone_number: str) -> bool: pass ``` Examples ```python >>> validate_phone_number(\\"+1 (123) 456-7890\\") True >>> validate_phone_number(\\"123-456-7890\\") True >>> validate_phone_number(\\"1.123.456.7890\\") True >>> validate_phone_number(\\"(123)456 7890\\") True >>> validate_phone_number(\\"123 456 789\\") False >>> validate_phone_number(\\"12345-67890\\") False >>> validate_phone_number(\\"+11234567890\\") True >>> validate_phone_number(\\"123-abc-7890\\") False ``` **Note**: Ensure your function efficiently handles strings up to the specified length and performs necessary checks for correct input type.","solution":"import re def validate_phone_number(phone_number: str) -> bool: Validates if the given phone number is a valid US phone number. if not isinstance(phone_number, str): raise ValueError(f\\"Input must be a string, got {type(phone_number).__name__}\\") # Regular expression for validating US phone numbers pattern = re.compile(r\\"^(+?1[-.s]?)?((?d{3})?[-.s]?d{3}[-.s]?d{4})\\") return bool(pattern.match(phone_number))"},{"question":"**Problem Statement:** Write a function `letter_histogram(sentence: str) -> dict` that takes a string `sentence` and returns a dictionary with the counts of each letter in the string. The function should ignore case (i.e., treat \'A\' and \'a\' as the same letter), and only consider alphabetic characters. The dictionary should have letters as keys and their counts as values. # Input: - A string `sentence` that can include spaces, punctuation, numbers, and mixed case letters. # Output: - A dictionary where the keys are lowercase alphabet letters, and the values are the counts of their occurrences in the given `sentence`. # Constraints: - The function should handle strings up to 10^6 characters long efficiently. - Ensure that only alphabetic characters are counted, and the function should ignore all other characters. # Examples: ```python >>> letter_histogram(\'Hello World!\') {\'h\': 1, \'e\': 1, \'l\': 3, \'o\': 2, \'w\': 1, \'r\': 1, \'d\': 1} >>> letter_histogram(\'12345 abc DEF\') {\'a\': 1, \'b\': 1, \'c\': 1, \'d\': 1, \'e\': 1, \'f\': 1} >>> letter_histogram(\'Wow!!! Such A Test.\') {\'w\': 2, \'o\': 1, \'s\': 2, \'u\': 1, \'c\': 1, \'h\': 1, \'a\': 1, \'t\': 2, \'e\': 1} ```","solution":"def letter_histogram(sentence: str) -> dict: Returns a dictionary with the counts of each letter in the string. The function ignores case and only considers alphabetic characters. from collections import defaultdict histogram = defaultdict(int) for char in sentence: if char.isalpha(): histogram[char.lower()] += 1 return dict(histogram)"},{"question":"# Question: Find the Missing Number in a Consecutive Sequence You are provided with an unsorted array containing `n-1` unique integers from a range of `0` to `n` where `n` is a positive integer. Your task is to find the missing integer from this range. **Function Signature**: `def find_missing_number(arr: List[int]) -> int:` **Input**: - A list `arr` of `n-1` unique integers ranging from `0` to `n`. **Output**: - Return the missing integer from the range. **Constraints**: - You must solve the problem in linear time and constant space. - The length of the array will be at most `10^4`. **Example**: ```python assert find_missing_number([3, 0, 1]) == 2 assert find_missing_number([0, 1]) == 2 assert find_missing_number([9,6,4,2,3,5,7,0,1]) == 8 assert find_missing_number([0]) == 1 ``` **Notes**: 1. Consider how you can leverage mathematical properties to find the missing number efficiently. 2. You might find the formula for the sum of the first `n` integers useful. 3. Ensure your solution works for all edge cases, including small-sized arrays and arrays with the largest possible missing number. Implement your solution in the following function definition: ```python def find_missing_number(arr: List[int]) -> int: # Your code here ```","solution":"from typing import List def find_missing_number(arr: List[int]) -> int: Finds the missing number in a list of integers ranging from 0 to n. n = len(arr) + 1 expected_sum = n * (n - 1) // 2 actual_sum = sum(arr) return expected_sum - actual_sum"},{"question":"# Problem Description You are given a list of integers and a target sum. Your task is to determine whether there exists a subset of the list whose elements sum up to the target value. You should use a dynamic programming approach to solve this problem efficiently given the constraints. Implement a function that: - **Function Name**: `subset_sum(nums: List[int], target: int) -> bool` - **Inputs**: - `nums` - a list of integers, where each integer is between 1 and 100 (inclusive). - `target` - an integer representing the target sum (0 <= target <= 10,000). - **Output**: Returns a boolean value (`True` or `False`) indicating whether such a subset exists. # Constraints - The length of the list `nums` is at most 100. - Ensure the solution is optimized for both time and space to handle the maximum constraints effectively. # Examples 1. **Example 1**: - **Input**: `nums = [3, 34, 4, 12, 5, 2], target = 9` - **Output**: `True` - **Explanation**: The subset `[3, 4, 2]` or `[4, 5]` sums up to 9. 2. **Example 2**: - **Input**: `nums = [1, 2, 3, 7], target = 6` - **Output**: `True` - **Explanation**: The subset `[1, 2, 3]` sums up to 6. 3. **Example 3**: - **Input**: `nums = [1, 2, 5], target = 4` - **Output**: `False` - **Explanation**: There is no subset that sums up to 4.","solution":"from typing import List def subset_sum(nums: List[int], target: int) -> bool: Determines if there\'s a subset of `nums` that adds up to `target`. Uses dynamic programming to solve the problem. n = len(nums) dp = [False] * (target + 1) dp[0] = True # There\'s always a subset with sum 0 (the empty subset) for num in nums: for t in range(target, num - 1, -1): dp[t] = dp[t] or dp[t - num] return dp[target]"},{"question":"Implementing Dijkstra\'s Algorithm for Shortest Path In the context of efficient route planning, consider a scenario where you need to find the shortest paths from a source node to all other nodes in a given weighted graph. This graph represents a city\'s road network where nodes are intersections and edges are roads with given travel times. # Task Complete the implementation of Dijkstra\'s algorithm to determine the shortest paths from a given source node to all other nodes in the graph. Function Signature ```python def dijkstra(graph: List[List[Tuple[int, int]]], source: int) -> List[int]: # Your implementation here ``` Input Format * A list of lists `graph` of size `n` where `graph[i]` is a list of tuples `(j, w)` representing an edge from node `i` to node `j` with weight `w`. * An integer `source` representing the source node. Output Format * Return a list of integers where the i-th element is the shortest distance from the `source` to node `i`. If a node is unreachable, its distance should be `-1`. Constraints * 1 ≤ n ≤ 10^4 (number of nodes). * 0 ≤ number of edges ≤ 5 * 10^4. * 1 ≤ weight of each edge ≤ 1000. # Example ```python graph = [ [(1, 1), (2, 4)], [(2, 2), (3, 5)], [(3, 1)], [] ] source = 0 print(dijkstra(graph, source)) # Output: [0, 1, 3, 4] ``` # Notes * Use a priority queue to achieve the time complexity of O((n + e) log n), where n is the number of nodes and e is the number of edges. * Each node is zero-indexed. * Ensure that your implementation handles large graphs efficiently.","solution":"import heapq def dijkstra(graph, source): Implements Dijkstra\'s algorithm to compute the shortest paths from a source node to all other nodes in the graph. :param graph: List[List[Tuple[int, int]]], adjacency list representation of the graph. :param source: int, the source node. :return: List[int], shortest distances from the source to all nodes, or -1 if a node is unreachable. n = len(graph) distances = [float(\'inf\')] * n distances[source] = 0 priority_queue = [(0, source)] # (distance, node) while priority_queue: current_distance, current_node = heapq.heappop(priority_queue) # If the popped node distance is not up to date, skip it if current_distance > distances[current_node]: continue # Explore neighbors for neighbor, weight in graph[current_node]: distance = current_distance + weight # Only consider this new path if it\'s better if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) # Change distances of unreachable nodes from inf to -1 reachable_distances = [d if d != float(\'inf\') else -1 for d in distances] return reachable_distances"},{"question":"# Coding Challenge: Blood Pressure Monitor Data Analysis You have been hired to analyze data from a new blood pressure monitoring device. The data is recorded continuously and logged in a specific format. Your task is to write a function that processes this log and identifies any critical hypertension spikes. **Your Task**: - Write a function `detect_hypertension_spikes(data: List[Tuple[str, int, int]]) -> List[str]` that identifies all timestamps where a hypertension spike occurs. - A hypertension spike is defined as any reading where the systolic blood pressure is greater than 140 mmHg or the diastolic blood pressure is greater than 90 mmHg. **Input**: - `data` (List[Tuple[str, int, int]]): A list of tuples where each tuple contains: - A timestamp (str) in the format \\"YYYY-MM-DD HH:MM:SS\\". - Systolic blood pressure (int). - Diastolic blood pressure (int). **Output**: - A list of strings representing the timestamps where a hypertension spike occurred. **Constraints**: - Assume the list of data points is sorted in ascending order based on the timestamp. - Timestamps will follow a consistent format and will be unique. - Blood pressure measurements are non-negative integers. ```python from typing import List, Tuple def detect_hypertension_spikes(data: List[Tuple[str, int, int]]) -> List[str]: Detect timestamps with hypertension spikes from the given blood pressure data. Parameters: - data (List[Tuple[str, int, int]]): List of tuples containing timestamp, systolic BP, and diastolic BP. Returns: - List[str]: List of timestamps where hypertension spikes occurred. spikes = [] for timestamp, systolic, diastolic in data: if systolic > 140 or diastolic > 90: spikes.append(timestamp) return spikes ``` **Example Scenarios**: 1. Given the data: ```python data = [ (\\"2023-02-10 08:30:00\\", 130, 85), (\\"2023-02-10 09:00:00\\", 145, 88), (\\"2023-02-10 09:30:00\\", 138, 92), (\\"2023-02-10 10:00:00\\", 125, 80) ] ``` - Calling `detect_hypertension_spikes(data)` should output `[\\"2023-02-10 09:00:00\\", \\"2023-02-10 09:30:00\\"]`. 2. Given the data: ```python data = [ (\\"2023-03-15 14:20:00\\", 120, 75), (\\"2023-03-15 14:50:00\\", 148, 95), (\\"2023-03-15 15:20:00\\", 135, 85) ] ``` - Calling `detect_hypertension_spikes(data)` should output `[\\"2023-03-15 14:50:00\\"]`. **Edge cases**: - Log with no hypertension spikes. - Continuous hypertension spikes detected in consecutive records. Ensure your solution accurately handles these cases and provides the correct output.","solution":"from typing import List, Tuple def detect_hypertension_spikes(data: List[Tuple[str, int, int]]) -> List[str]: Detect timestamps with hypertension spikes from the given blood pressure data. Parameters: - data (List[Tuple[str, int, int]]): List of tuples containing timestamp, systolic BP, and diastolic BP. Returns: - List[str]: List of timestamps where hypertension spikes occurred. spikes = [] for timestamp, systolic, diastolic in data: if systolic > 140 or diastolic > 90: spikes.append(timestamp) return spikes"},{"question":"# File Permission Checker - Function Implementation Problem Statement In a Unix-like operating system, file permissions are managed using a combination of symbols that specify who can read, write, and execute a file. These permissions are often represented as a string of ten characters (e.g., \'-rwxr-xr--\'). Your task is to implement a function that verifies whether a file has the specified set of permissions for a given user (owner, group, others) based on the permission string of the file. You should complete the Python function `check_permission` that follows this signature: ```python def check_permission(permission_str: str, user_type: str, required_permission: str) -> bool: pass ``` - **permission_str**: A string representing the file permissions (e.g., \'-rwxr-xr--\'). - **user_type**: A string indicating the user type (`\'owner\'`, `\'group\'`, `\'others\'`). - **required_permission**: A string representing the permissions that need to be checked (combination of \'r\', \'w\', \'x\'). The function should return `True` if the specified user has all of the required permissions according to the permission string, otherwise `False`. # Constraints - `permission_str` will always be exactly 10 characters long and follow the Unix permission representation format. - `user_type` will be one of the three values: `\'owner\'`, `\'group\'`, or `\'others\'`. - `required_permission` will only contain characters from the set `{\'r\', \'w\', \'x\'}`. - If any input violates these constraints, your function must raise a `ValueError` with a suitable error message. # Examples ```python >>> check_permission(permission_str=\'-rwxr-xr--\', user_type=\'owner\', required_permission=\'rwx\') True >>> check_permission(permission_str=\'-rwxr-xr--\', user_type=\'group\', required_permission=\'rwx\') False >>> check_permission(permission_str=\'-rwxr-xr--\', user_type=\'group\', required_permission=\'rx\') True >>> check_permission(permission_str=\'-rw-r--r--\', user_type=\'others\', required_permission=\'r\') True >>> check_permission(permission_str=\'-rw-r--r--\', user_type=\'others\', required_permission=\'x\') False >>> check_permission(permission_str=\'-rw-r--r--\', user_type=\'admin\', required_permission=\'r\') Traceback (most recent call last): ... ValueError: Invalid user type ``` # Requirements - **Input/output format**: As specified above. - **Performance**: The solution should handle permission checks in constant time, O(1). - **Errors**: Handle invalid inputs with appropriate error messages.","solution":"def check_permission(permission_str: str, user_type: str, required_permission: str) -> bool: if len(permission_str) != 10: raise ValueError(\\"Invalid permission string length\\") user_index_map = { \'owner\': 1, \'group\': 4, \'others\': 7 } if user_type not in user_index_map: raise ValueError(\\"Invalid user type\\") if any(x not in \\"rwx\\" for x in required_permission): raise ValueError(\\"Invalid required permission characters\\") start_idx = user_index_map[user_type] permission_slice = permission_str[start_idx:start_idx+3] return all(permission in permission_slice for permission in required_permission)"},{"question":"# Problem Statement You are given a 2D grid representing a binary matrix, where each cell can be `0` (an empty space) or `1` (an obstacle). Your task is to implement a function that checks whether there is a path from the top-left corner `(0,0)` to the bottom-right corner `(n-1,m-1)` of the matrix, moving only up, down, left, or right, and only through cells containing `0`. # Function Signature: ```python def path_exists(matrix: List[List[int]]) -> bool: ``` # Input: - `matrix`: A list of lists of integers representing the binary matrix. Each element is either `0` or `1`. # Output: - Returns a boolean: `True` if there is a path from the top-left to the bottom-right corner, otherwise `False`. # Constraints: - The matrix dimensions are `n` by `m`, where `1 <= n, m <= 100`. - The value at `matrix[0][0]` and `matrix[n-1][m-1]` is always `0`. # Example: ```python matrix_1 = [ [0, 1, 0, 0], [0, 1, 1, 0], [0, 0, 0, 1], [1, 1, 0, 0] ] result_1 = path_exists(matrix_1) print(result_1) # Example expected output: True matrix_2 = [ [0, 1, 0, 0], [0, 1, 1, 0], [0, 0, 1, 1], [1, 1, 0, 1] ] result_2 = path_exists(matrix_2) print(result_2) # Example expected output: False ``` # Notes: - Use a breadth-first search (BFS) or depth-first search (DFS) to determine if a path exists. - Consider edge cases such as very small matrices or matrices with multiple obstacles. - Ensure your solution handles the maximum constraints efficiently.","solution":"from typing import List from collections import deque def path_exists(matrix: List[List[int]]) -> bool: def is_valid(x, y): return 0 <= x < len(matrix) and 0 <= y < len(matrix[0]) and matrix[x][y] == 0 n, m = len(matrix), len(matrix[0]) if not (matrix[0][0] == 0 and matrix[n-1][m-1] == 0): return False directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([(0, 0)]) matrix[0][0] = 1 # Mark as visited while queue: x, y = queue.popleft() if (x, y) == (n-1, m-1): return True for direction in directions: nx, ny = x + direction[0], y + direction[1] if is_valid(nx, ny): queue.append((nx, ny)) matrix[nx][ny] = 1 # Mark as visited return False"},{"question":"# Scenario You are tasked with developing a function to aid in data analysis for a telecommunications company. They need a utility that can identify valid IP addresses within a given string. An IP address consists of four octets, each ranging from 0 to 255, separated by dots. Your function should extract and return all valid IP addresses found in the input string. # Objective Write a function `extract_valid_ip_addresses` that returns a list of valid IP addresses found within a given string. # Specification **Function Signature**: ```python def extract_valid_ip_addresses(s: str) -> list: pass ``` **Inputs**: * `s` (str): A string containing potential IP addresses. **Output**: * Returns a list of strings, where each string is a valid IP address found in the input. The IP addresses should maintain their order of appearance in the original string. # Constraints: * The length of `s` will not exceed 1000 characters. * Each octet must be between 0 and 255. * Leading zeroes in an octet make it invalid, except for the number 0 itself. # Example Usage: ```python print(extract_valid_ip_addresses(\\"The IPs are 192.168.1.1 and 10.0.0.1.\\")) # Expected Output: [\'192.168.1.1\', \'10.0.0.1\'] print(extract_valid_ip_addresses(\\"Invalid IPs: 256.100.50.25, 192.168.1.999\\")) # Expected Output: [] print(extract_valid_ip_addresses(\\"Some IPs: 172.16.254.1, 123.456.78.90, 0.0.0.0\\")) # Expected Output: [\'172.16.254.1\', \'0.0.0.0\'] print(extract_valid_ip_addresses(\\"IP: 1.2.3.4, more IPs: 12.34.56.78\\")) # Expected Output: [\'1.2.3.4\', \'12.34.56.78\'] ``` # Notes: - Ensure to account for typical edge cases, such as numbers out of range or invalid formats. - The function should ignore malformed octets but continue analyzing the rest of the string. - Use efficient methods for checking and extracting IP addresses to maintain performance within the given constraints. This question aligns with the original set by requiring problem-solving skills related to number theory and string manipulation, ensuring a balanced level of difficulty and scope.","solution":"import re def extract_valid_ip_addresses(s: str) -> list: Extracts and returns all valid IP addresses found in the input string. # Regular expression to match potential IP addresses (not yet validated) potential_ips = re.findall(r\'b(?:d{1,3}.){3}d{1,3}b\', s) valid_ips = [] for ip in potential_ips: octets = ip.split(\'.\') # Validate each octet if all(is_valid_octet(octet) for octet in octets): valid_ips.append(ip) return valid_ips def is_valid_octet(octet): Helper function to check if an octet is valid: - Should be a number between 0 and 255 - Should not have leading zeros except for 0 itself if not octet.isdigit(): return False num = int(octet) # Check range and leading zero conditions if num > 255 or (octet[0] == \'0\' and octet != \'0\'): return False return True"},{"question":"Problem Statement: You are given a string `text` and an integer `k`. Your task is to implement a function `has_repeated_characters` that determines if there exists any substring of length `k` within `text` that contains any repeated characters. Requirements: 1. Traverse the string `text` to find all possible substrings of length `k`. 2. Check each substring to determine if it contains any repeated characters. 3. Return `True` if any substring of length `k` has repeated characters; otherwise, return `False`. Function Signature: ```python def has_repeated_characters(text: str, k: int) -> bool: Checks if there is any substring of length k with repeated characters in the given text. :param text: A string to be searched. :param k: The length of substring to check for repeated characters. :return: True if any substring of length k contains repeated characters, otherwise False. ``` Example: ```python text = \\"abcdefg\\" print(has_repeated_characters(text, 3)) # Output: False print(has_repeated_characters(text, 2)) # Output: False print(has_repeated_characters(text, 8)) # Output: False text = \\"aabbcc\\" print(has_repeated_characters(text, 2)) # Output: True print(has_repeated_characters(text, 3)) # Output: True print(has_repeated_characters(text, 1)) # Output: True ``` Constraints: - The length of the string `text` is (1 leq |text| leq 10^5). - The integer `k` is (1 leq k leq |text|). Notes: - Consider using an appropriate data structure to efficiently check for repeated characters in each substring. - Ensure the solution operates within a reasonable time complexity, ideally close to (O(nk)).","solution":"def has_repeated_characters(text: str, k: int) -> bool: Checks if there is any substring of length k with repeated characters in the given text. :param text: A string to be searched. :param k: The length of substring to check for repeated characters. :return: True if any substring of length k contains repeated characters, otherwise False. if k > len(text): return False for i in range(len(text) - k + 1): substring = text[i:i+k] if len(set(substring)) < k: return True return False"},{"question":"# Question: Common Path Finder Context: In filesystems, paths are used to navigate through directories and subdirectories. It\'s often required to find the common base path shared between multiple paths. This type of problem might arise in fields like computing or data management when dealing with relative and absolute path manipulations. Objective: Write a function that takes a list of directory paths and returns the longest common base path. Function Signature: ```python def find_common_base_path(paths: List[str]) -> str: pass ``` Input: - `paths`: A list of strings, where each string represents an absolute directory path. Each path is non-empty and uses \'/\' as the directory separator. Output: - The function should return a string representing the longest common base path. Constraints: - The list `paths` will contain at least one path. - All given paths are valid and consist of alphanumeric characters and \'/\'. - The function should handle paths with no common base gracefully. Example: ```python >>> find_common_base_path([\'/home/user/docs\', \'/home/user/downloads\', \'/home/user/music\']) \'/home/user\' >>> find_common_base_path([\'/var/log\', \'/var/tmp\', \'/var/backups\']) \'/var\' >>> find_common_base_path([\'/root/project\', \'/etc/config\', \'/home\']) \'\' ``` Note: - In the first example, all paths share the base \'/home/user\'. - In the second example, all paths share the base \'/var\'. - In the third example, there is no common base path, so the function returns an empty string. Tips: - Consider splitting each path by \'/\' and comparing the segments. - Pay attention to edge cases where the paths might completely diverge after the root directory or have different starting points. - Try to ensure the solution is efficient and handles various lengths of paths lists robustly.","solution":"from typing import List def find_common_base_path(paths: List[str]) -> str: if not paths: return \\"\\" # Split each path into components split_paths = [path.split(\'/\') for path in paths] # Find the minimum path length min_length = min(len(path) for path in split_paths) common_base = [] for i in range(min_length): # Pick the i-th component from the first path current_component = split_paths[0][i] # Check if this component is common in all paths if all(path[i] == current_component for path in split_paths): common_base.append(current_component) else: break # Join the common components to form the common base path return \'/\'.join(common_base)"},{"question":"# Coding Question: Enhanced Budget Allocation You are developing a software application for a non-profit organization to assist in allocating their annual budget to various projects. Given the budget and a list of project funding requirements, your task is to extend the function to not only check if all projects can be funded but also calculate the remaining budget after the allocations. **Problem Statement**: Enhance the function to include the calculation of the remaining budget after attempting to allocate funds to all the projects. Function Signature ```python def enhanced_budget_allocation(budget: float, project_costs: List[float]) -> Tuple[bool, float]: Determines if all projects can be funded and calculates the remaining budget. Args: budget (float): annual budget of the organization in dollars. project_costs (List[float]): list of projected costs for each project in dollars. Returns: Tuple[bool, float]: Returns a tuple with: - can_fund_all (bool): True if all projects can be funded within the budget, False otherwise. - remaining_budget (float): the remaining budget after funding the projects. Raises: ValueError: if the budget is negative or any project cost is negative. ``` Inputs: |Name | Units | Type | |-------------|-------------------------|-----------| |budget | (in dollars) | float | |project_costs| (in dollars) | List[float]| Outputs: |Name | Units | Type | |---------------|-------------------------|-----------| |can_fund_all | (True/False) | bool | |remaining_budget | (in dollars) | float | Constraints: 1. Budget and project costs must be non-negative. 2. Use the formula `remaining_budget = budget - sum(project_costs)` to compute the remaining budget. 3. Compare the `sum(project_costs)` against the budget to determine if all projects can be funded. Example: ```python >>> enhanced_budget_allocation(1000, [200, 150, 300]) (True, 350.0) >>> enhanced_budget_allocation(500, [200, 150, 300]) (False, -150.0) ``` **Note**: Ensure robust handling of invalid inputs by raising `ValueError` if negative values are provided for budget or any project cost. **Performance Requirements**: * The time complexity should be O(n), where n is the number of projects, due to the summation of project costs.","solution":"from typing import List, Tuple def enhanced_budget_allocation(budget: float, project_costs: List[float]) -> Tuple[bool, float]: Determines if all projects can be funded and calculates the remaining budget. Args: budget (float): annual budget of the organization in dollars. project_costs (List[float]): list of projected costs for each project in dollars. Returns: Tuple[bool, float]: Returns a tuple with: - can_fund_all (bool): True if all projects can be funded within the budget, False otherwise. - remaining_budget (float): the remaining budget after funding the projects. Raises: ValueError: if the budget is negative or any project cost is negative. if budget < 0: raise ValueError(\\"Budget cannot be negative\\") if any(cost < 0 for cost in project_costs): raise ValueError(\\"Project costs cannot be negative\\") total_cost = sum(project_costs) can_fund_all = total_cost <= budget remaining_budget = budget - total_cost return can_fund_all, remaining_budget"},{"question":"# Problem Statement You are required to write a function that determines the difference between the largest and smallest numbers in a given list after applying a specified transformation. The transformation reverses the digits of each number in the list. # Function Signature ```python def max_min_difference_after_reverse(nums: list) -> int: ``` # Input and Output * **Input**: A list of integers `nums` where each integer is in the range `1 ≤ num ≤ 10^9`. * **Output**: An integer representing the difference between the largest and smallest numbers in the transformed list. # Example ```python assert max_min_difference_after_reverse([123, 456, 789]) == 876 # Reversed list: [321, 654, 987], difference = 987 - 321 = 666 assert max_min_difference_after_reverse([10, 20, 30]) == 21 # Reversed list: [1, 2, 3], difference = 3 - 1 = 2 assert max_min_difference_after_reverse([321, 4321, 875]) == 8509 # Reversed list: [123, 1234, 578], difference = 1234 - 123 = 1111 assert max_min_difference_after_reverse([111, 222, 333]) == 222 # Reversed list: [111, 222, 333], difference = 333 - 111 = 222 ``` # Constraints * The list `nums` will contain at least one integer. * The length of `nums` will not exceed `10^3`. # Notes * Ensure that the function efficiently handles the reversal and computation, keeping in mind the possible number of digits for each integer in the list.","solution":"def max_min_difference_after_reverse(nums: list) -> int: Given a list of integers, this function returns the difference between the largest and smallest numbers after reversing the digits of each number. reversed_nums = [int(str(num)[::-1]) for num in nums] max_reversed = max(reversed_nums) min_reversed = min(reversed_nums) return max_reversed - min_reversed"},{"question":"# Question: Implement a Class for A Circular Queue You are required to implement a circular queue data structure that handles integer data efficiently. A circular queue is a linear data structure that follows the FIFO (First In First Out) principle and connects the end of the queue with the beginning to create a circle. Your implementation should include the following methods: 1. **`__init__(self, k: int)`**: Initializes the circular queue with a given capacity `k`. 2. **`enqueue(self, value: int) -> bool`**: Inserts an element into the circular queue. Returns `True` if the operation is successful, otherwise returns `False`. 3. **`dequeue(self) -> bool`**: Deletes an element from the circular queue. Returns `True` if the operation is successful, otherwise returns `False`. 4. **`Front(self) -> int`**: Gets the front item from the queue. If the queue is empty, return `-1`. 5. **`Rear(self) -> int`**: Gets the last item from the queue. If the queue is empty, return `-1`. 6. **`isEmpty(self) -> bool`**: Checks whether the circular queue is empty. 7. **`isFull(self) -> bool`**: Checks whether the circular queue is full. Input and Output Formats - The **`__init__`** method should initialize the circular queue with the specified capacity `k`. - The **`enqueue`** method should add an integer value to the queue and return a boolean indicating success/failure. - The **`dequeue`** method should remove an integer value from the queue and return a boolean indicating success/failure. - The **`Front`** method should return the front integer value of the queue. - The **`Rear`** method should return the rear integer value of the queue. - The **`isEmpty`** method should return a boolean indicating if the queue is empty. - The **`isFull`** method should return a boolean indicating if the queue is full. Example Usage ```python # Initialize a queue with capacity 3 cq = CircularQueue(3) # Enqueue values print(cq.enqueue(1)) # Expected Output: True print(cq.enqueue(2)) # Expected Output: True print(cq.enqueue(3)) # Expected Output: True print(cq.enqueue(4)) # Expected Output: False (queue is full) # Check the front and rear values print(cq.Front()) # Expected Output: 1 print(cq.Rear()) # Expected Output: 3 # Dequeue a value print(cq.dequeue()) # Expected Output: True # Check the front and rear values after dequeue print(cq.Front()) # Expected Output: 2 print(cq.Rear()) # Expected Output: 3 # Check if the queue is empty or full print(cq.isEmpty()) # Expected Output: False print(cq.isFull()) # Expected Output: False ``` Make sure to handle edge cases such as attempting to dequeue from an empty queue or enqueueing into a full queue, and ensure that the circular nature of the queue is appropriately maintained.","solution":"class CircularQueue: def __init__(self, k: int): self.queue = [0] * k self.max_size = k self.front = 0 self.rear = 0 self.size = 0 def enqueue(self, value: int) -> bool: if self.isFull(): return False self.queue[self.rear] = value self.rear = (self.rear + 1) % self.max_size self.size += 1 return True def dequeue(self) -> bool: if self.isEmpty(): return False self.front = (self.front + 1) % self.max_size self.size -= 1 return True def Front(self) -> int: if self.isEmpty(): return -1 return self.queue[self.front] def Rear(self) -> int: if self.isEmpty(): return -1 return self.queue[(self.rear - 1 + self.max_size) % self.max_size] def isEmpty(self) -> bool: return self.size == 0 def isFull(self) -> bool: return self.size == self.max_size"},{"question":"# Problem Statement You are given two arrays, `arr1` and `arr2`, of integers and you need to find a pair of integers, one from each array, such that the absolute difference between the pair is minimized. # Function Signature ```python def find_min_difference_pair(arr1: List[int], arr2: List[int]) -> Tuple[int, int]: ``` # Input * `arr1` (list of integers): The first array (1 ≤ len(arr1) ≤ 1000, -10^6 ≤ arr1[i] ≤ 10^6). * `arr2` (list of integers): The second array (1 ≤ len(arr2) ≤ 1000, -10^6 ≤ arr2[i] ≤ 10^6). # Output * A tuple of two integers, one from each array, representing the pair with the minimum absolute difference. # Constraints * The arrays may contain duplicates. * If there are multiple pairs with the same minimum absolute difference, return any one of them. # Examples ```python print(find_min_difference_pair([1, 3, 15, 11, 2], [23, 127, 235, 19, 8])) # Output: (11, 8) or (3, 2) print(find_min_difference_pair([10, 5, 40], [50, 90, 45])) # Output: (40, 45) ``` # Explanation 1. For the first example, the function should find that the pair (11, 8) has the smallest absolute difference of 3, which cannot be improved by any other pairing. 2. For the second example, the function should return (40, 45) as the pair with the minimum absolute difference of 5.","solution":"from typing import List, Tuple def find_min_difference_pair(arr1: List[int], arr2: List[int]) -> Tuple[int, int]: arr1.sort() arr2.sort() i, j = 0, 0 min_diff = float(\'inf\') min_pair = (arr1[0], arr2[0]) while i < len(arr1) and j < len(arr2): diff = abs(arr1[i] - arr2[j]) if diff < min_diff: min_diff = diff min_pair = (arr1[i], arr2[j]) # Move the pointer from the array with the smaller value if arr1[i] < arr2[j]: i += 1 else: j += 1 return min_pair"},{"question":"# Question: Detect Cycle in a Directed Graph You are given a directed graph represented by a number of nodes (`n`) and a list of edges. Each edge is represented as `[u, v]` indicating a directed edge from node `u` to node `v`. Your task is to implement an algorithm to detect if there is a cycle in the graph. # Input - `num_nodes`: an integer `n` representing the number of nodes. (1 leq n leq 1000) - `edges`: a list of lists where each inner list has two integers `u` and `v` representing a directed edge from node `u` to node `v`. The edges are not necessarily sorted. (0 leq u, v < n) # Output - Return `True` if there is a cycle in the graph, otherwise return `False`. # Constraints 1. The graph is directed. 2. There may be multiple edges and self-loops. 3. The number of edges does not exceed (10^4). # Function Signature ```python def has_cycle(num_nodes: int, edges: List[List[int]]) -> bool: pass ``` # Example ```python num_nodes = 4 edges = [ [0, 1], [1, 2], [2, 0], [3, 3] ] result = has_cycle(num_nodes, edges) # Expected output: True num_nodes = 3 edges = [ [0, 1], [1, 2] ] result = has_cycle(num_nodes, edges) # Expected output: False ``` # Notes - Use Depth First Search (DFS) to implement cycle detection in the graph. - Keep track of the visited nodes and recursive call stack to detect back edges indicating cycles.","solution":"from typing import List def has_cycle(num_nodes: int, edges: List[List[int]]) -> bool: def dfs(node, visited, rec_stack): visited[node] = True rec_stack[node] = True for neighbor in adjacency_list[node]: if not visited[neighbor]: if dfs(neighbor, visited, rec_stack): return True elif rec_stack[neighbor]: return True rec_stack[node] = False return False # Create adjacency list adjacency_list = [[] for _ in range(num_nodes)] for u, v in edges: adjacency_list[u].append(v) # Keep track of visited nodes and the recursion stack visited = [False] * num_nodes rec_stack = [False] * num_nodes # Call the recursive helper function to detect cycle for each node for node in range(num_nodes): if not visited[node]: if dfs(node, visited, rec_stack): return True return False"},{"question":"# Prime Factorization Prime factorization is the process of breaking down a composite number into its prime factors. A prime factor is a prime number that divides another number evenly, i.e., without leaving a remainder. For example, the prime factorization of 28 is (2^2 times 7), since 2 and 7 are primes, and 2 multiplied by itself twice, then multiplied by 7, gives 28. # Task Write a function `prime_factors` that takes an integer `x` and returns a list of its prime factors in ascending order. Each prime factor should appear in the list the number of times it divides `x` so that the product of the list elements equals `x`. # Function Signature ```python def prime_factors(x: int) -> list: pass ``` # Input * An integer `x` (2 <= x <= 10**6), which is the number for which the prime factors need to be determined. # Output * A list of integers representing the prime factors of `x` in ascending order. # Example ```python >>> prime_factors(28) [2, 2, 7] >>> prime_factors(18) [2, 3, 3] >>> prime_factors(7) [7] ``` # Constraints 1. The input integer `x` is guaranteed to be between 2 and 1,000,000 (inclusive). 2. You may assume the function is only called with valid integer inputs. # Notes * Efficiently determine the prime factors by considering optimizations instead of checking each number up to `x` for primality. * Utilize mathematical properties of prime numbers and factorization to improve runtime performance for large values of `x`. Implement the function `prime_factors` according to the specifications.","solution":"def prime_factors(x: int) -> list: Returns the prime factors of the given integer x in ascending order. Each prime factor appears as many times as it divides x. factors = [] # Handle the factor 2 while x % 2 == 0: factors.append(2) x //= 2 # Handle odd factors factor = 3 while factor * factor <= x: while x % factor == 0: factors.append(factor) x //= factor factor += 2 # If x is still greater than 1, then it is a prime number if x > 1: factors.append(x) return factors"},{"question":"# String Transformation Checker You have been provided with a function that determines whether one string can be transformed into another through a series of specified operations. Each allowed operation involves replacing one character in the string with another character, and each character can only be replaced once. # Problem Statement Your task is to implement the function that checks whether it\'s possible to transform the string `source` into `target` using the described series of transformations. Transformation Rules 1. Each character in the `source` string can only be replaced once to another character. 2. Each character replacement is unique, meaning that if \'a\' is replaced with \'b\', no other character can be replaced with \'b\' again. # Requirements 1. **Function Signature**: ```python def can_transform(source, target): # your code here ``` 2. **Input**: - `source`: A string representing the original string that needs to be transformed. - `target`: A string representing the target string after transformations. 3. **Output**: - A boolean value (`True` or `False`), indicating whether the transformation is possible given the rules. 4. **Constraints**: - The length of `source` and `target` strings is the same. - Strings contain only lowercase alphabetical characters (a-z). # Examples ```python # Example usage and expected results source = \\"abc\\" target = \\"bcd\\" can_transform_result = can_transform(source, target) print(can_transform_result) # Expected Output: True source = \\"foo\\" target = \\"bar\\" can_transform_result = can_transform(source, target) print(can_transform_result) # Expected Output: False ``` Remember to ensure that the transformations are unique and that each character in the `source` string can only be mapped to one character in the `target` string. This prevents conflicts and ensures that the transformation is valid according to the given rules. # Explanation In the first example, a possible transformation sequence could be: - Replace \'a\' with \'b\'. - Replace \'b\' with \'c\'. - Replace \'c\' with \'d\'. In the second example: - \'f\' cannot be replaced with \'b\' while \'o\' is also replaced with \'a\' as there would be no unique way to transform \'foo\' into \'bar\' given the rules. Hence, the function returns `False`.","solution":"def can_transform(source, target): if len(source) != len(target): return False source_to_target = {} target_char_used = set() for s_char, t_char in zip(source, target): if s_char in source_to_target: if source_to_target[s_char] != t_char: return False else: if t_char in target_char_used: return False source_to_target[s_char] = t_char target_char_used.add(t_char) return True"},{"question":"# Challenge: You are supplied with a dictionary-based undirected graph representation of a city map. Each node represents an intersection, and each edge represents a street connecting two intersections. Your task is to determine the shortest path between any two specified intersections using the Breadth-First Search (BFS) algorithm. **Function Signature**: ```python def shortest_path(graph: dict, start: int, end: int) -> list: pass ``` # Requirements: - **Input**: A dictionary representation of an undirected graph and two integers. - The keys in the dictionary are integers representing the intersections. - The values are lists of integers representing the intersections connected directly to the key intersection. - The `start` and `end` parameters are integers representing the starting and ending intersection respectively. - **Output**: A list of integers representing the sequence of intersections making up the shortest path from `start` to `end`. If no path exists, return an empty list. # Constraints: - The graph is undirected and contains no parallel edges or self-loops. - Nodes are labeled with non-negative integers. - The graph can have up to 10^3 intersections and 10^4 streets. - Start and end nodes are guaranteed to be valid nodes in the graph. # Example: **Input**: ```python graph = { 0: [1, 2], 1: [0, 3], 2: [0, 3], 3: [1, 2, 4], 4: [3, 5], 5: [4] } start = 0 end = 5 ``` **Output**: ```python [0, 2, 3, 4, 5] ``` # Additional Examples: **Example 2**: **Input**: ```python graph = { 0: [1], 1: [0, 2], 2: [1, 3], 3: [2] } start = 0 end = 3 ``` **Output**: ```python [0, 1, 2, 3] ``` # Notes: 1. If there are multiple shortest paths, any one of them is a valid output. 2. Return an empty list if no path exists between the start and end intersections. 3. Ensure your solution is efficient and can handle the upper bounds of the constraints effectively.","solution":"from collections import deque def shortest_path(graph: dict, start: int, end: int) -> list: Determines the shortest path in an undirected graph using BFS. Parameters: graph (dict): The graph represented as adjacency lists. start (int): The starting node. end (int): The target node. Returns: list: The shortest path from start to end as a list of nodes. if start == end: return [start] # Initialize BFS queue = deque([(start, [start])]) visited = set() visited.add(start) while queue: current, path = queue.popleft() for neighbor in graph[current]: if neighbor not in visited: if neighbor == end: return path + [neighbor] visited.add(neighbor) queue.append((neighbor, path + [neighbor])) return [] # No path found"},{"question":"# Coding Assessment Question: Objective Create a balanced Binary Search Tree (BST) from a sorted list, and implement a function to determine the height of the resulting BST. Problem Description You are required to write a function `create_balanced_bst_and_height(sorted_list)` that takes a sorted list of integers and constructs a balanced Binary Search Tree (BST). The function should then return the height of the BST. Function Signature ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def create_balanced_bst_and_height(sorted_list: list[int]) -> int: pass ``` Parameters * `sorted_list (list[int])`: A list of integers that is already sorted in ascending order. Returns * `int`: The height of the balanced Binary Search Tree created from the sorted list. Constraints * The length of the sorted list can be between 0 and 10^4. * The list can be empty. Input/Output Examples ```python # Example 1 sorted_list = [-10, -3, 0, 5, 9] print(create_balanced_bst_and_height(sorted_list)) # Output: 2 # Example 2 sorted_list = [1, 2, 3, 4, 5, 6, 7] print(create_balanced_bst_and_height(sorted_list)) # Output: 3 # Example 3 sorted_list = [] print(create_balanced_bst_and_height(sorted_list)) # Output: -1 (For empty list, consider height as -1) ``` Notes * A balanced BST is one where the depth of the two subtrees of every node never differs by more than 1. * The height of a tree with a single node (root only) is considered 0. * If the list is empty, the function should return -1 to denote that the tree is non-existent. * Ensure that the tree is as balanced as possible when creating it.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def create_balanced_bst_and_height(sorted_list: list[int]) -> int: if not sorted_list: return -1 def sorted_array_to_bst(arr, start, end): if start > end: return None mid = (start + end) // 2 node = TreeNode(arr[mid]) node.left = sorted_array_to_bst(arr, start, mid - 1) node.right = sorted_array_to_bst(arr, mid + 1, end) return node def height(node): if not node: return -1 left_height = height(node.left) right_height = height(node.right) return 1 + max(left_height, right_height) root = sorted_array_to_bst(sorted_list, 0, len(sorted_list) - 1) return height(root)"},{"question":"# Question Create a class to represent a mutable 2D grid of integers, with methods for retrieving and modifying grid elements, and methods for computing the sum of all elements along a specified row or column. Specific Requirements: 1. **Class Name**: Grid 2. **Methods to Implement**: * `__init__(self, rows: int, cols: int)`: Initialize the grid with the specified number of rows and columns, with all elements initialized to zero. * `set_value(self, row: int, col: int, value: int) -> None`: Set the value of the element at the specified row and column index. * `get_value(self, row: int, col: int) -> int`: Retrieve the value of the element at the specified row and column index. * `sum_row(self, row: int) -> int`: Calculate and return the sum of all elements in the specified row. * `sum_column(self, col: int) -> int`: Calculate and return the sum of all elements in the specified column. 3. **Input**: Variably through method calls. 4. **Output**: Variably through method returns. Constraints: * Ensure that row and column indices used in `set_value` and `get_value` methods are valid (i.e., within the grid bounds). Raise an `IndexError` if an invalid index is used. * Implement the methods in such a way that they handle typical use cases efficiently. Performance Requirements: * **Time Complexity**: * `set_value` and `get_value` should be O(1). * `sum_row` and `sum_column` should be O(n), where n is the number of elements in the respective row or column. # Example Usage: ```python grid = Grid(3, 3) grid.set_value(1, 1, 5) grid.set_value(0, 2, 10) print(grid.get_value(1, 1)) # 5 print(grid.sum_row(1)) # 5 print(grid.sum_column(2)) # 10 grid.set_value(1, 2, 3) print(grid.sum_row(1)) # 8 ``` Your implementation should ensure proper handling of all specified methods and the typical operations mentioned above.","solution":"class Grid: def __init__(self, rows: int, cols: int): self.rows = rows self.cols = cols self.grid = [[0] * cols for _ in range(rows)] def set_value(self, row: int, col: int, value: int) -> None: if not (0 <= row < self.rows and 0 <= col < self.cols): raise IndexError(\\"Row or column index out of bounds\\") self.grid[row][col] = value def get_value(self, row: int, col: int) -> int: if not (0 <= row < self.rows and 0 <= col < self.cols): raise IndexError(\\"Row or column index out of bounds\\") return self.grid[row][col] def sum_row(self, row: int) -> int: if not (0 <= row < self.rows): raise IndexError(\\"Row index out of bounds\\") return sum(self.grid[row]) def sum_column(self, col: int) -> int: if not (0 <= col < self.cols): raise IndexError(\\"Column index out of bounds\\") return sum(self.grid[row][col] for row in range(self.rows))"},{"question":"**Problem Statement:** You are provided with a list of strings where each string consists of a mix of letters and digits. Your goal is to rearrange the characters in each string such that: 1. All letters appear before any digits. 2. Both letters and digits within their own groups should maintain their original order. 3. The rearranged strings are then concatenated together in their original order to form the final output string. **Specifications:** 1. Implement the function `rearrange_string`. - **Input**: A string `s` containing a mix of alphanumeric characters. - **Output**: A string where all letters appear before any digits, maintaining their original order. 2. Implement the function `combine_rearranged_strings`. - **Input**: A list of strings `strings_list`, where each string contains a mix of alphanumeric characters. - **Output**: A single string resulting from concatenating each rearranged string. **Example:** ```python >>> strings_list = [\\"a1b2c3\\", \\"x9y8\\", \\"1a2b3\\"] >>> combine_rearranged_strings(strings_list) \\"abc123xy98123\\" ``` - Explanation: - Rearranged \\"a1b2c3\\": \\"abc123\\" - Rearranged \\"x9y8\\": \\"xy98\\" - Rearranged \\"1a2b3\\": \\"ab123\\" - Concatenate: \\"abc123\\" + \\"xy98\\" + \\"ab123\\" -> \\"abc123xy98123\\" **Notes:** - Inputs are guaranteed to only contain alphanumeric characters. - The order of original characters within their groups (letters and digits) must be preserved. - The use of additional helper functions is encouraged if necessary. - You should not use any external libraries.","solution":"def rearrange_string(s): Rearranges the input string such that all letters appear before any digits while maintaining their original order. :param s: Input string containing a mix of alphanumeric characters :return: Rearranged string with letters first followed by digits letters = \'\'.join([char for char in s if char.isalpha()]) digits = \'\'.join([char for char in s if char.isdigit()]) return letters + digits def combine_rearranged_strings(strings_list): Concatenates each rearranged string (where all letters appear before digits) from the input strings list. :param strings_list: List of strings containing a mix of alphanumeric characters :return: A single string resulting from concatenating each rearranged string rearranged_strings = [rearrange_string(s) for s in strings_list] return \'\'.join(rearranged_strings)"},{"question":"# Problem Statement You are tasked with organizing a coding competition and need to ensure fair ranking based on the participants’ scores. Write a function to condense a list of scores by removing duplicates and returning the scores in descending order. Write a function `ranked_scores(scores)` that takes a list of scores and returns a list of unique scores sorted in descending order. # Function Signature ```python def ranked_scores(scores: List[int]) -> List[int]: ``` # Input * `scores` (a list of integers `0 <= scores[i] <= 10^6`, where `1 <= len(scores) <= 10^6`): The list of scores obtained by the participants. # Output * Return a list of unique scores sorted in descending order. # Constraints * The function should handle large input sizes efficiently. * You must not use any external libraries except for Python\'s standard library. # Performance Requirements * Must run within reasonable time limits for the maximum input sizes. # Example ```python print(ranked_scores([100, 90, 90, 80, 75, 75, 60])) # Output: [100, 90, 80, 75, 60] # Explanation: The unique scores in descending order. print(ranked_scores([1, 2, 3, 4, 5])) # Output: [5, 4, 3, 2, 1] # Explanation: All scores are unique and sorted in descending order. print(ranked_scores([3, 3, 3, 3, 3])) # Output: [3] # Explanation: Only one unique score. ``` # Additional Notes 1. Consider the possibility of duplicate scores and ensure they are removed efficiently. 2. The return list should be sorted in descending order, even if the input list is sorted in any other order or is unsorted. 3. Use appropriate data structures to handle the constraints and maintain the performance requirements.","solution":"def ranked_scores(scores): This function takes a list of scores and returns a list of unique scores sorted in descending order. Parameters: scores (List[int]): The list of scores obtained by the participants. Returns: List[int]: List of unique scores sorted in descending order. return sorted(set(scores), reverse=True)"},{"question":"# Question: Validate if a Binary Search Tree Given the `BinaryTree` class with its associated methods and functionalities, add a method to determine if the tree is a valid binary search tree (BST). **Definition**: A binary search tree is a binary tree in which for every node, the value of all nodes in its left subtree is less than the value of the node and the value of all nodes in its right subtree is greater than the value of the node. The task is broken down as follows: 1. Implement a method `is_bst` in the `BinaryTree` class that returns `True` if the tree is a valid BST and `False` otherwise. 2. Ensure your implementation is efficient and handles edge cases correctly. **Expected Input and Output**: * Input: None (Operates directly on the instance of the BinaryTree). * Output: Boolean (True if the tree forms a valid BST, False otherwise). **Constraints**: * The tree can be empty. In such cases, consider it an empty BST and return `True`. * You must avoid unnecessary traversals and ensure the solution has an optimal runtime and space complexity. # Example ```python # Example of usage: binary_tree = BinaryTree.construct_from_list([2, 1, 3]) print(binary_tree.is_bst()) # Expected output: True binary_tree = BinaryTree.construct_from_list([5, 1, 4, None, None, 3, 6]) print(binary_tree.is_bst()) # Expected output: False ``` # Performance Requirements Your method should ideally run in O(n) time complexity, where n is the number of nodes in the tree, and use O(h) space complexity, where h is the height of the tree due to the recursive nature of the solution. Your task: 1. Enhance the `BinaryTree` class as per the requirements. 2. Write appropriate test cases to validate the solution. Good luck!","solution":"class BinaryTreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right class BinaryTree: def __init__(self, root=None): self.root = root @classmethod def construct_from_list(cls, values): if not values: return cls() root = BinaryTreeNode(values[0]) queue = [(root, 0)] n = len(values) while queue: node, i = queue.pop(0) left_i, right_i = 2 * i + 1, 2 * i + 2 if left_i < n and values[left_i] is not None: node.left = BinaryTreeNode(values[left_i]) queue.append((node.left, left_i)) if right_i < n and values[right_i] is not None: node.right = BinaryTreeNode(values[right_i]) queue.append((node.right, right_i)) return cls(root) def is_bst(self): def is_bst_helper(node, lower=float(\'-inf\'), upper=float(\'inf\')): if not node: return True val = node.value if val <= lower or val >= upper: return False if not is_bst_helper(node.right, val, upper): return False if not is_bst_helper(node.left, lower, val): return False return True return is_bst_helper(self.root)"},{"question":"You are managing a network of computers in an office. Initially, there are no direct connections between any pairs of computers. Over time, connections (either direct or indirect) will be established between computers. Your task is to model these connections and optimize them using the Disjoint Set data structure. **Task**: Given a series of connection operations between computers, determine if all computers are connected after each operation. **Function Signature**: ```python def network_check(n: int, connections: List[Tuple[int, int]]) -> List[bool]: Args: n : int : Number of computers (each computer identified by an integer from 0 to n-1) connections : List[Tuple[int, int]] : A list of tuples where each tuple (a, b) signifies a connection operation establishing a connection between computers a and b. Returns: List[bool] : List of boolean values where each boolean indicates whether all computers are connected after each connection operation. ``` # Input * Integer `n` representing the number of computers (1 ≤ n ≤ 10^5). * List `connections` of connection operations [(a, b), ...] (0 ≤ a, b < n). # Output * List of boolean values where each boolean indicates whether all computers are connected after each connection operation. # Example ```python connections = [(0, 1), (1, 2), (2, 3), (3, 4), (4, 5)] print(network_check(6, connections)) # Output: [False, False, False, False, True] ``` # Explanation - After connecting computers 0 and 1, not all computers are connected, so the output is False. - After connecting computers 1 and 2, still not all computers are connected, so the output is False. - After connecting computers 2 and 3, still not all computers are connected, so the output is False. - After connecting computers 3 and 4, still not all computers are connected, so the output is False. - After connecting computers 4 and 5, all computers are finally connected, so the output is True. # Constraints * Employ the Disjoint Set Union-Find with both path compression and union by rank heuristics to avoid exceeding time limits.","solution":"from typing import List, Tuple class DisjointSetUnion: def __init__(self, size): self.parent = list(range(size)) self.rank = [1] * size self.component_count = size def find(self, x): if self.parent[x] != x: self.parent[x] = self.find(self.parent[x]) return self.parent[x] def union(self, x, y): root_x = self.find(x) root_y = self.find(y) if root_x != root_y: if self.rank[root_x] > self.rank[root_y]: self.parent[root_y] = root_x elif self.rank[root_x] < self.rank[root_y]: self.parent[root_x] = root_y else: self.parent[root_y] = root_x self.rank[root_x] += 1 self.component_count -= 1 def all_connected(self): return self.component_count == 1 def network_check(n: int, connections: List[Tuple[int, int]]) -> List[bool]: dsu = DisjointSetUnion(n) results = [] for a, b in connections: dsu.union(a, b) results.append(dsu.all_connected()) return results"},{"question":"# Problem Statement You are tasked with implementing a function to detect and count overlapping occurrences of a substring within a given string. Overlapping is allowed, so the same character in the main string can be part of multiple occurrences of the substring. # Function Specification **Function Name**: `count_overlaps` **Input**: * `main_string` (str): The string in which the substring is to be counted. * `sub_string` (str): The substring to count occurrences of within the main string. **Output**: * `count` (int): The count of overlapping occurrences of the substring within the main string. # Example ```python >>> count_overlaps(\\"aaaa\\", \\"aa\\") 3 >>> count_overlaps(\\"ababa\\", \\"aba\\") 2 >>> count_overlaps(\\"abcabcabc\\", \\"abc\\") 3 ``` # Constraints * The `main_string` and `sub_string` will be non-empty strings consisting of alphabet characters only. * The length of `sub_string` will always be less than or equal to the length of `main_string`. # Requirements * Implement a function that iterates through the `main_string` and detects all overlapping and non-overlapping occurrences of `sub_string`. * Optimize your solution to handle edge cases where the `main_string` or `sub_string` contain repeated characters. * Ensure that your algorithm efficiently handles strings of varying lengths within the constraints provided. # Implementation Note Instead of using basic string methods, consider sliding a window over the `main_string` and manually checking each possible occurrence to count overlaps properly.","solution":"def count_overlaps(main_string, sub_string): Returns the count of overlapping occurrences of sub_string in main_string. count = 0 sub_len = len(sub_string) for i in range(len(main_string) - sub_len + 1): if main_string[i:i + sub_len] == sub_string: count += 1 return count"},{"question":"# Problem Statement You are tasked with implementing a queue data structure for an automated ticketing system. The queue must support typical operations and handle error conditions gracefully. **Specifications**: Implement a `Queue` class with the following methods: 1. `enqueue(data: T)`: Add an element `data` to the end of the queue. 2. `dequeue() -> T`: Remove and return the front element of the queue. 3. `front() -> T`: Return (but do not remove) the front element of the queue. 4. `is_empty() -> bool`: Return `True` if the queue is empty, `False` otherwise. 5. `is_full() -> bool`: Return `True` if the queue is full, `False` otherwise. 6. `size() -> int`: Return the number of elements currently in the queue. **Error Handling**: - *QueueOverflowError*: Raised when attempting to enqueue to a full queue. - *QueueUnderflowError*: Raised when attempting to dequeue from or access the front of an empty queue. **Input/Output**: - Ensure that operations handle edge cases properly. - The queue should be limited by a maximum size constraint upon initialization. # Inputs: - Integer `limit`: Defines the maximum number of elements the queue can hold. - Sequence of operations requests including `enqueue`, `dequeue`, `front`, `is_empty`, `is_full`, `size`. # Outputs: - For `enqueue`: None. - For `dequeue` and `front`: The respective element. - For `is_empty`, `is_full`: Boolean value indicating state of queue. - For `size`: Integer indicating the queue\'s current size. # Example: ```python Q = Queue(3) Q.enqueue(10) Q.enqueue(20) print(Q.dequeue()) # Output: 10 print(Q.front()) # Output: 20 print(Q.is_empty()) # Output: False Q.enqueue(30) print(Q.is_full()) # Output: False Q.enqueue(40) Q.enqueue(50) # Raises QueueOverflowError: Too many elements ``` # Constraints: - Queue size `limit` ranges from 1 to 10^4. - Operations on the queue should be optimized for efficiency. # Task: Implement the `Queue` class described above, ensuring proper function and error handling compliance.","solution":"class QueueOverflowError(Exception): pass class QueueUnderflowError(Exception): pass class Queue: def __init__(self, limit): self.limit = limit self.queue = [] def enqueue(self, data): if self.size() >= self.limit: raise QueueOverflowError(\\"Queue is full\\") self.queue.append(data) def dequeue(self): if self.is_empty(): raise QueueUnderflowError(\\"Queue is empty\\") return self.queue.pop(0) def front(self): if self.is_empty(): raise QueueUnderflowError(\\"Queue is empty\\") return self.queue[0] def is_empty(self): return len(self.queue) == 0 def is_full(self): return len(self.queue) == self.limit def size(self): return len(self.queue)"},{"question":"# Problem Statement: Counting Set Bits In this problem, you are required to write a function that counts the number of set bits (1-bits) in the binary representation of a given non-negative integer. Function Signature ```python def count_set_bits(n: int) -> int: Given a non-negative integer `n`, return the number of set bits (1-bits) in its binary representation. Parameters: n (int): A non-negative integer. Returns: int: The count of set bits in the binary representation of `n`. pass ``` Examples ```python count_set_bits(0) # Output: 0 count_set_bits(5) # Output: 2 (binary: 101) count_set_bits(36) # Output: 2 (binary: 100100) count_set_bits(8) # Output: 1 (binary: 1000) count_set_bits(16) # Output: 1 (binary: 10000) ``` Constraints * The input integer `n` is guaranteed to be non-negative. * The function should handle edge cases gracefully and be efficient in terms of time and space complexity. * If the input is not a non-negative integer, raise a `ValueError` with an appropriate message. Notes * Ensure to validate input and handle any possible edge cases. * Emphasize maintaining a reasonable time complexity and O(1) space complexity.","solution":"def count_set_bits(n: int) -> int: Given a non-negative integer `n`, return the number of set bits (1-bits) in its binary representation. Parameters: n (int): A non-negative integer. Returns: int: The count of set bits in the binary representation of `n`. if not isinstance(n, int) or n < 0: raise ValueError(\\"The input must be a non-negative integer\\") count = 0 while n > 0: count += n & 1 n = n >> 1 return count"},{"question":"# Problem Statement: Given a list of strings, each representing a mathematical expression containing only non-negative integers, `+`, `-`, `*`, and `/`, create a function `evaluate_expressions` that evaluates each expression and returns a list of the results. Implement this function without using Python\'s `eval()` function for security reasons. # Function Signature: ```python def evaluate_expressions(expressions: List[str]) -> List[float]: ``` # Input: - `expressions`: A list of strings where each string is a valid mathematical expression containing non-negative integers and operators `+`, `-`, `*`, and `/`. The length of the list is `n` where 0 <= n <= 10^4. # Output: - Return a list of floating-point numbers representing the result of evaluating each expression in the input list. # Constraints: 1. Each expression in the list is guaranteed to be valid and can be evaluated left to right following the standard precedence rules for the operators. 2. Division should be treated as float division. 3. Expressions will not contain parentheses or negative numbers. # Example: ```python assert evaluate_expressions([\\"3+5\\", \\"10-2*2\\", \\"100/20\\", \\"3*6+8/4\\"]) == [8.0, 6.0, 5.0, 20.0] assert evaluate_expressions([\\"2+3*4\\", \\"3/2\\", \\"8*3/2+1\\"]) == [14.0, 1.5, 13.0] assert evaluate_expressions([\\"10\\", \\"5+3\\", \\"4*2/2-1\\"]) == [10.0, 8.0, 3.0] assert evaluate_expressions([]) == [] assert evaluate_expressions([\\"0/1\\", \\"1+2*3-4/2\\", \\"1*2+3-4/2\\"]) == [0.0, 5.0, 3.0] ``` # Notes: - You need to apply operator precedence properly (`*` and `/` before `+` and `-`). - Ensure the solution efficiently handles up to the upper limit of input size. - Handle edge cases such as a single number without operators, division by one, and more complex expressions with multiple operators. # Solution Criteria: - Your solution must parse and evaluate expressions accurately, conforming to mathematical rules and precedence. - The function should be robust, handling a variety of valid expressions, and remain efficient both in terms of time and space.","solution":"from typing import List def evaluate_expressions(expressions: List[str]) -> List[float]: def evaluate(expression: str) -> float: def apply_operator(operators, values): operator = operators.pop() right = values.pop() left = values.pop() if operator == \'+\': values.append(left + right) elif operator == \'-\': values.append(left - right) elif operator == \'*\': values.append(left * right) elif operator == \'/\': values.append(left / right) i, n = 0, len(expression) values = [] operators = [] while i < n: if expression[i].isdigit(): start = i while i < n and expression[i].isdigit(): i += 1 values.append(float(expression[start:i])) # Convert to float directly elif expression[i] in \\"+-*/\\": while (operators and operators[-1] in \\"*/\\" and expression[i] in \\"+-\\") or (operators and operators[-1] in \\"*/\\" and expression[i] in \\"*/\\"): apply_operator(operators, values) operators.append(expression[i]) i += 1 while operators: apply_operator(operators, values) return values[0] return [evaluate(expression) for expression in expressions]"},{"question":"# Scenario In computer graphics, working with colors often involves manipulating hexadecimal color codes. A common task is converting these codes to their RGB (red, green, blue) equivalents and vice versa. # Problem Create two functions: 1. `hex_to_rgb(hex_color: str) -> Tuple[int, int, int]`: This function should convert a hexadecimal color code to an RGB tuple. 2. `rgb_to_hex(r: int, g: int, b: int) -> str`: This function should convert an RGB tuple to a hexadecimal color code. # Requirements - Implement these functions to correctly perform the color conversions. - Raise a `ValueError` with an appropriate message if the input values are out of the valid range for colors. - For `hex_to_rgb`, ensure that the hexadecimal string starts with \'#\' and consists of exactly 6 hexadecimal digits. - For `rgb_to_hex`, ensure that the RGB values are each in the range 0 to 255. # Function Signatures ```python from typing import Tuple def hex_to_rgb(hex_color: str) -> Tuple[int, int, int]: ... def rgb_to_hex(r: int, g: int, b: int) -> str: ... ``` # Input and Output - `hex_to_rgb`: - **Input**: A string `hex_color` representing the hexadecimal color code. - **Output**: A tuple of three integers representing the RGB values. - `rgb_to_hex`: - **Input**: Three integers `r`, `g`, and `b`, each representing a color channel. - **Output**: A string representing the hexadecimal color code, prefixed with \'#\'. # Constraints - The RGB values must each be between 0 and 255, inclusive. - The hexadecimal color code must start with \'#\' and be exactly 7 characters long (including the \'#\'). - Handling of input validation for incorrect formats and out of range values is required. # Examples - `hex_to_rgb(\\"#34A2EB\\")` should return `(52, 162, 235)`. - `rgb_to_hex(52, 162, 235)` should return `\\"#34A2EB\\"`. - `hex_to_rgb(\\"#000000\\")` should return `(0, 0, 0)`. - `rgb_to_hex(0, 0, 0)` should return `\\"#000000\\"`. - `hex_to_rgb(\\"#FF5733\\")` should return `(255, 87, 51)`. - `rgb_to_hex(255, 87, 51)` should return `\\"#FF5733\\"`. - `hex_to_rgb(\\"34A2EB\\")` should raise a `ValueError` with the message \\"Hex color must start with \'#\' and be 7 characters long.\\" - `rgb_to_hex(300, 162, 235)` should raise a `ValueError` with the message \\"RGB values must be between 0 and 255.\\" - `hex_to_rgb(\\"#34A2EB53\\")` should raise a `ValueError` with the message \\"Hex color must be exactly 7 characters long.\\" # Testing Use Python\'s built-in `doctest` module to provide test cases demonstrating the usage and correctness of the functions.","solution":"from typing import Tuple def hex_to_rgb(hex_color: str) -> Tuple[int, int, int]: Converts a hexadecimal color code to an RGB tuple. Args: hex_color: A string representing the hexadecimal color code. Returns: A tuple (r, g, b) where r, g, and b are integers corresponding to the RGB values. Raises: ValueError: If the input string is not a valid hexadecimal color code. if not (isinstance(hex_color, str) and hex_color.startswith(\'#\') and len(hex_color) == 7): raise ValueError(\\"Hex color must start with \'#\' and be exactly 7 characters long.\\") try: r = int(hex_color[1:3], 16) g = int(hex_color[3:5], 16) b = int(hex_color[5:7], 16) except ValueError: raise ValueError(\\"Invalid hexadecimal color code.\\") return (r, g, b) def rgb_to_hex(r: int, g: int, b: int) -> str: Converts RGB values to a hexadecimal color code. Args: r: An integer representing the red component (0-255). g: An integer representing the green component (0-255). b: An integer representing the blue component (0-255). Returns: A string representing the hexadecimal color code, prefixed with \'#\'. Raises: ValueError: If any of the RGB values are out of the valid range. if not (0 <= r <= 255 and 0 <= g <= 255 and 0 <= b <= 255): raise ValueError(\\"RGB values must be between 0 and 255.\\") return f\\"#{r:02X}{g:02X}{b:02X}\\""},{"question":"# Question: Implement a Basic Calculator You are tasked with creating a function that performs basic arithmetic operations (+, -, *, /) based on user input. Requirements: * Implement a function named `basic_calculator(expression: str) -> float` where: * `expression` is a string representing the arithmetic expression in standard infix notation. * The function should: * Validate the `expression` for correctness (raise a `ValueError` for invalid inputs, such as unsupported characters or mismatched parentheses). * Correctly handle the following operations: addition (`+`), subtraction (`-`), multiplication (`*`), and division (`/`). * Respect the standard order of operations (PEMDAS/BODMAS rules). * Addition details: * Divisions should be treated as float divisions. * Maintain efficient time and space complexity. Constraints: * The expression will only contain non-negative integers and the basic operators mentioned above. * The expression can contain whitespace, which should be ignored. * No use of `eval()` or other direct execution functions. * You can assume no zero division errors will occur. Examples: ```python >>> basic_calculator(\\"3 + 5 * 2\\") 13.0 >>> basic_calculator(\\"10 + 20 / 5\\") 14.0 >>> basic_calculator(\\"3 + 5 / 5 * 2\\") 5.0 >>> basic_calculator(\\"(3 + 5) * 2\\") 16.0 >>> basic_calculator(\\" 3+ 5/5 * 2 \\") 5.0 ``` **Note**: Ensure that the function can correctly handle complex expressions with multiple operators and parentheses. Consider edge cases such as empty strings, incorrect parentheses, and unsupported characters.","solution":"import re def basic_calculator(expression: str) -> float: def evaluate(tokens): stack = [] num = 0 sign = \'+\' while tokens: token = tokens.pop(0) if token.isdigit(): num = int(token) if token == \'(\': num = evaluate(tokens) if not token.isdigit() or len(tokens) == 0: if sign == \'+\': stack.append(num) elif sign == \'-\': stack.append(-num) elif sign == \'*\': stack.append(stack.pop() * num) elif sign == \'/\': stack.append(stack.pop() / num) sign = token num = 0 if token == \')\': break return sum(stack) def validate(expression): # Remove whitespace and validate characters expression = expression.replace(\\" \\", \\"\\") if not re.match(r\'^[0-9+-*/()]+\', expression): raise ValueError(\'Invalid characters in expression.\') # Validate parentheses balance = 0 for char in expression: if char == \'(\': balance += 1 elif char == \')\': balance -= 1 if balance < 0: raise ValueError(\'Mismatched parentheses in expression.\') if balance != 0: raise ValueError(\'Mismatched parentheses in expression.\') return expression expression = validate(expression) tokens = re.findall(r\'d+|[+-*/()]\', expression) return evaluate(tokens)"},{"question":"# String Cyclic Rotation Validation Scenario: You are tasked with implementing an algorithm to determine whether one string is a cyclic rotation of another string. A string is said to be a cyclic rotation of another if it can be obtained by rotating the original string any number of times. Task: Write a function `is_cyclic_rotation` that checks if one string is a cyclic rotation of another string. The function should be mindful of edge cases and handle various input lengths correctly. Function Signature: ```python def is_cyclic_rotation(s1: str, s2: str) -> bool: pass ``` Input: - `s1` (str): The first string to be checked. - `s2` (str): The second string to be checked against the first string. Output: - Returns a boolean value: `True` if `s2` is a cyclic rotation of `s1`, otherwise `False`. Constraints: - The length of both strings should not exceed 10^5 characters. - Both strings should consist of printable ASCII characters. Performance Requirements: - The function should operate efficiently with a time complexity of at most O(n), where n is the length of the strings. Examples: ```python >>> is_cyclic_rotation(\\"waterbottle\\", \\"erbottlewat\\") True >>> is_cyclic_rotation(\\"hello\\", \\"llohe\\") True >>> is_cyclic_rotation(\\"hello\\", \\"olelh\\") False >>> is_cyclic_rotation(\\"\\", \\"\\") True >>> is_cyclic_rotation(\\"a\\", \\"a\\") True >>> is_cyclic_rotation(\\"abc\\", \\"cab\\") True >>> is_cyclic_rotation(\\"abcd\\", \\"dabc\\") True >>> is_cyclic_rotation(\\"abcd\\", \\"abcdabcd\\") False >>> is_cyclic_rotation(\\"123456789\\", \\"789123456\\") True ``` Ensure your function handles edge cases appropriately, such as empty strings or identical strings. Consider using efficient string manipulation techniques to meet the required performance criteria.","solution":"def is_cyclic_rotation(s1: str, s2: str) -> bool: Checks if s2 is a cyclic rotation of s1. if len(s1) != len(s2): return False if len(s1) == 0: return True return s2 in (s1 + s1)"},{"question":"# Description: Implement a function to determine if it is possible to form a string `s` by repeating a smaller substring `k` times. The function should return `True` if it is possible, otherwise `False`. # Task: You need to implement the function `can_form_repeated_substring(s: str) -> bool`, which checks if the input string `s` can be formed by repeating some smaller substring. # Input: - A string `s` consisting of lowercase English letters (1 <= len(s) <= 1000). # Output: - A boolean value `True` if it is possible to form the string by repeating some smaller substring, otherwise `False`. # Constraints: - The length of the string `s` will be between 1 and 1000 inclusive. - The string `s` will only contain lowercase English letters. # Example: ```python def can_form_repeated_substring(s: str) -> bool: # (Your logic here) pass print(can_form_repeated_substring(\\"abab\\")) # Output: True print(can_form_repeated_substring(\\"aba\\")) # Output: False print(can_form_repeated_substring(\\"abcabcabcabc\\")) # Output: True print(can_form_repeated_substring(\\"abcd\\")) # Output: False ``` # Instructions: 1. Iterate over possible lengths of the substring. For each length: - Check if the length is a divisor of the total length of `s`. - If it is, slice the substring and repeat it to see if it matches `s`. 2. Return `True` if you find a matching repeated substring, otherwise return `False`.","solution":"def can_form_repeated_substring(s: str) -> bool: Determines if the string s can be formed by repeating a smaller substring. n = len(s) for i in range(1, n // 2 + 1): if n % i == 0: substring = s[:i] if substring * (n // i) == s: return True return False"},{"question":"# Allocate Minimum Pages Context You are tasked with distributing books among students such that each student gets at least one book. The goal is to allocate books to students in a way that the maximum number of pages assigned to a student is minimized. Problem Statement Implement the function `allocate_minimum_pages` which determines the minimum value of the maximum number of pages assigned to a student under the given constraints. Function Signature `def allocate_minimum_pages(books: List[int], students: int) -> int:` Parameters * `books`: A list of integers representing the number of pages in each book. * `students`: An integer representing the number of students. Returns * An integer representing the minimum possible value of the maximum pages assigned to a student. Constraints * The length of the books list will be greater than or equal to the number of students. * All elements in `books` are positive integers. * `students` is a positive integer. Edge Cases * The number of books equals the number of students. * All books contain the same number of pages. Example ```python # Example 1 books = [12, 34, 67, 90] students = 2 assert allocate_minimum_pages(books, students) == 113 # Example 2 books = [10, 20, 30, 40, 50] students = 2 assert allocate_minimum_pages(books, students) == 90 # Example 3 books = [5, 10, 15, 20] students = 4 assert allocate_minimum_pages(books, students) == 20 ``` Additional Notes * Ensure to handle edge cases such as having exactly the same number of students as books and having books with the same number of pages. * Consider using a binary search approach to optimize the allocation.","solution":"from typing import List def allocate_minimum_pages(books: List[int], students: int) -> int: def is_valid_distribution(pages: int) -> bool: required_students = 1 current_pages = 0 for book in books: if current_pages + book > pages: required_students += 1 current_pages = book if required_students > students: return False else: current_pages += book return True if students > len(books): return -1 start, end = max(books), sum(books) result = end while start <= end: mid = (start + end) // 2 if is_valid_distribution(mid): result = mid end = mid - 1 else: start = mid + 1 return result"},{"question":"# Question You are developing a command-line tool that processes a list of files and performs various operations based on command-line arguments. One feature of your tool is the ability to list all Python files in a specified directory. To ensure this functionality works correctly, you should write robust unit tests for it. One of your unit test functions requires accurate mocking of the file system to simulate the presence of Python files without creating actual files on the disk. # Task Using the structure provided in the previous example snippet, write a Python function, `test_list_python_files`, to mock the file system contents and verify that your function correctly lists Python files in a directory using the `os` and `glob` modules. Requirements: - Create a mock directory with a mix of Python files (`.py`) and other file types. - Mock the `os.path.isfile`, `os.path.isdir`, and `glob.glob` methods to return controlled results. - Ensure the mock function checks that the correct list of files is returned. - Use the `unittest.mock` library to apply the mocks. - Verify that the function under test correctly filters and lists only Python files. - Handle scenarios where no Python files are present and the directory does not exist. Input and Output: - You don’t need to worry about the input and output format as it\'s a unit test configuration. - If the setup is correct, the unit test should pass without accessing the actual file system. Constraints: - Assume the directory to search in is specified by the variable `directory_path`. - The function to test can be named `list_python_files` which lists all `.py` files in a directory. - File system operations should be fully mocked. # Example: ```python import os import glob def list_python_files(directory_path): python_files = [] if os.path.isdir(directory_path): python_files = glob.glob(f\'{directory_path}/*.py\') return python_files ``` Create the mock unit test function `test_list_python_files` for the above example. # Solution ```python import unittest from unittest.mock import patch, MagicMock import os import glob class TestFileListing(unittest.TestCase): @patch(\'os.path.isdir\') @patch(\'glob.glob\') def test_list_python_files(self, mock_glob, mock_isdir): # Mock the isdir response to True mock_isdir.return_value = True # Mock the return value of glob.glob mock_glob.return_value = [\'test1.py\', \'test2.py\', \'not_a_python_file.txt\'] directory_path = \'mock_directory\' expected_files = [\'test1.py\', \'test2.py\'] # Call the function under test result = list_python_files(directory_path) # Verify the mocks were called as expected mock_isdir.assert_called_once_with(directory_path) mock_glob.assert_called_once_with(f\'{directory_path}/*.py\') # Check the function output self.assertEqual(result, expected_files) @patch(\'os.path.isdir\') def test_list_python_files_no_directory(self, mock_isdir): # Mock the isdir response to False mock_isdir.return_value = False directory_path = \'mock_directory\' # Call the function under test result = list_python_files(directory_path) # Verify the mocks were called as expected mock_isdir.assert_called_once_with(directory_path) # Check the function output self.assertEqual(result, []) if __name__ == \'__main__\': unittest.main() ```","solution":"import os import glob def list_python_files(directory_path): Lists all Python files in the given directory. Parameters: directory_path (str): The path to the directory to search for Python files. Returns: List[str]: A list of paths to Python files in the directory. if os.path.isdir(directory_path): python_files = glob.glob(f\'{directory_path}/*.py\') return [file for file in python_files if os.path.isfile(file)] return []"},{"question":"# Palindrome Permutation Design a function that determines if any permutation of a given string can form a palindrome. A palindrome is a word, phrase, or sequence of characters which reads the same forward and backward (ignoring spaces and punctuation). Your function should consider only alphanumeric characters and ignore the case of these characters. **Function Signature**: `def can_form_palindrome(s: str) -> bool:` # Requirements: 1. Ignore spaces, punctuation, and case when determining if characters can be permuted to form a palindrome. 2. A string can form a palindrome if at most one character occurs an odd number of times. # Input and Output Formats: * **Input**: A single string `s` consisting of alphanumeric characters, spaces, and punctuation. `s` can be an empty string. * **Output**: A boolean value indicating whether any permutation of the string can form a palindrome. # Constraints: * The input string can have a length between 0 and 1000 characters. # Examples: 1. `can_form_palindrome(\\"Tact Coa\\")` should return `True` because \\"Tact Coa\\" can be permuted to \\"taco cat\\", which is a palindrome. 2. `can_form_palindrome(\\"A man, a plan, a canal, Panama!\\")` should return `True` because \\"A man, a plan, a canal, Panama!\\" can be permuted to \\"amanap lanac a nalp a nam A\\", which is a palindrome. 3. `can_form_palindrome(\\"hello\\")` should return `False` because no permutation of \\"hello\\" can form a palindrome. 4. `can_form_palindrome(\\"\\")` should return `True` because an empty string is trivially a palindrome. Remember to handle edge cases such as empty strings, single characters, and strings with a mix of uppercase, lowercase, spaces, and punctuation. Ensure your solution is efficient and correctly handles various input scenarios.","solution":"def can_form_palindrome(s: str) -> bool: Determines if any permutation of the input string can form a palindrome. # Normalize the string to lowercase and filter out non-alphanumeric characters. normalized_s = \'\'.join(char.lower() for char in s if char.isalnum()) # Count the frequency of each character. char_count = {} for char in normalized_s: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 # Count how many characters have an odd frequency. odd_count = sum(1 for count in char_count.values() if count % 2 != 0) # A maximum of one character can have an odd frequency for it to be able to form a palindrome. return odd_count <= 1"},{"question":"# Problem Statement: You are provided with a string `s` consisting of lowercase alphabetical characters and an integer `k`. Your task is to write a function that replaces every character in the string `s` with the `k-th` character ahead in the alphabetical order. If this goes beyond \'z\', it should wrap around to \'a\'. # Function Signature: ```python def shift_string(s: str, k: int) -> str: pass ``` # Inputs: - A string `s` where `1 <= len(s) <= 100`, consisting of lowercase alphabetical characters. - An integer `k` where `1 <= k <= 25`, representing the number of positions each character in the string should be shifted. # Outputs: - A string, the modified string after each character has been shifted by `k` positions. # Constraints: - Characters in `s` must wrap around the end of the alphabet (i.e., if a shift goes beyond `z`, it continues from `a`). # Example: ```python # Example 1: shift_string(\\"abc\\", 1) # Expected Output: \\"bcd\\" # Example 2: shift_string(\\"xyz\\", 2) # Expected Output: \\"zab\\" ``` # Explanation: - In Example 1, \\"abc\\" shifted by 1 results in \\"bcd\\". - In Example 2, shifting \\"xyz\\" by 2 wraps around and results in \\"zab\\". # Performance Requirements: - Ensure your solution is efficient and handles the upper limit of string length smoothly.","solution":"def shift_string(s: str, k: int) -> str: shifted_string = \\"\\" for char in s: new_char = chr((ord(char) - ord(\'a\') + k) % 26 + ord(\'a\')) shifted_string += new_char return shifted_string"},{"question":"**Problem Statement:** You are given a linked list where each node contains an integer value. Your task is to write a function to rearrange the linked list such that all odd-positioned nodes are placed before the even-positioned nodes. The relative order among odd and even-positioned nodes should remain the same. # Function Signature ```python def rearrange_odd_even(head: ListNode) -> ListNode: pass ``` # Input * A pointer `head` to the first node of the singly linked list. The total number of nodes in the linked list is between 0 and 10^5, inclusive. * Each node contains an integer value within the range [-10^9, 10^9]. # Output * The function should return the head of the modified linked list. # Constraints * The function should use O(1) additional space. * The function should operate in O(n) time complexity. * The nodes should be considered in 1-indexed positions for rearrangement. # Example ```python # Helper class to build and visualize linked list class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def print_list(head): result = [] while head: result.append(head.val) head = head.next return result # Example usage: # Input: 1 -> 2 -> 3 -> 4 -> 5 node1 = ListNode(1) node2 = ListNode(2) node3 = ListNode(3) node4 = ListNode(4) node5 = ListNode(5) node1.next = node2 node2.next = node3 node3.next = node4 node4.next = node5 # Function call new_head = rearrange_odd_even(node1) # Output after rearrangement: 1 -> 3 -> 5 -> 2 -> 4 print(print_list(new_head)) # Output should be [1, 3, 5, 2, 4] ``` # Requirements * Create an additional helper class `ListNode` if necessary. * Ensure edge cases like an empty list, a single node list, and lists with even or odd numbers of nodes are handled properly. * Do not alter the node values, only rearrange the nodes. # Notes * Do not use additional data structures to store nodes. * Aim for a clear and efficient solution that maintains the original node values\' relative order within their odd and even categories.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def rearrange_odd_even(head: ListNode) -> ListNode: if not head or not head.next: return head odd = head even = head.next even_head = even while even and even.next: odd.next = even.next odd = odd.next even.next = odd.next even = even.next odd.next = even_head return head def print_list(head: ListNode): result = [] while head: result.append(head.val) head = head.next return result"},{"question":"# Simulated Annealing for Traveling Salesman Problem **Context:** Simulated annealing is a probabilistic technique for approximating the global optimum of a given function. It is particularly useful for solving combinatorial optimization problems like the Traveling Salesman Problem (TSP), where the goal is to find the shortest possible route visiting a set of cities exactly once and returning to the origin city. **Problem Statement:** Create a function `simulated_annealing_tsp` that implements the simulated annealing algorithm to find an approximate solution to the TSP. The function should take a 2D list of distances between cities and return a list representing the order of cities in the approximate shortest path. ```python def simulated_annealing_tsp(dist_matrix: list[list[float]], start_temp: float = 100.0, alpha: float = 0.99, stop_temp: float = 1e-3) -> list[int]: pass ``` **Function Definition:** * **Input**: * `dist_matrix` (list[list[float]]): A 2D list where `dist_matrix[i][j]` represents the distance between city `i` and city `j`. * `start_temp` (float, optional): The initial temperature for the annealing process. Default is 100.0. * `alpha` (float, optional): The cooling rate, a factor by which the temperature is multiplied in each iteration. Default is 0.99. * `stop_temp` (float, optional): The temperature at which the annealing process should stop. Default is `1e-3`. * **Output**: * Returns list[int]: The order of cities representing the approximate shortest path. **Constraints**: 1. `dist_matrix` should be a valid 2D square matrix with distances between cities. 2. The number of cities should be at least two. **Edge Cases to Consider**: 1. A `dist_matrix` that is not square. 2. A matrix with zero or negative distances (which should be handled as invalid input). # Example: ```python dist_matrix = [ [0, 10, 15, 20], [10, 0, 35, 25], [15, 35, 0, 30], [20, 25, 30, 0] ] solution = simulated_annealing_tsp(dist_matrix) print(solution) # Output: [0, 1, 3, 2, 0] or an equivalent shortest route ``` **Verification**: Develop a unit test class `TestSimulatedAnnealingTSP` with methods to test the simulated_annealing_tsp function across valid and boundary scenarios. ```python import unittest class TestSimulatedAnnealingTSP(unittest.TestCase): def test_basic_scenario(self): dist_matrix = [ [0, 10, 15, 20], [10, 0, 35, 25], [15, 35, 0, 30], [20, 25, 30, 0] ] solution = simulated_annealing_tsp(dist_matrix) self.assertEqual(len(solution), 5) self.assertEqual(solution[0], solution[-1]) for city in range(4): self.assertTrue(solution.count(city) == 1) def test_invalid_matrix(self): with self.assertRaises(ValueError): dist_matrix = [ [0, -10, 15], [10, 0, 25], [15, 35, 0] ] simulated_annealing_tsp(dist_matrix) def test_non_square_matrix(self): with self.assertRaises(ValueError): dist_matrix = [ [0, 10, 15], [10, 0, 25], [15, 35, 0], [20, 25, 30, 0] ] simulated_annealing_tsp(dist_matrix) if __name__ == \'__main__\': unittest.main() ``` This new question aligns with the format, complexity, and scope of the provided existing questions. It maintains the technical challenge, ensuring a comprehensive understanding of the simulated annealing algorithm and its application to solve the Traveling Salesman Problem (TSP).","solution":"import random import math def simulated_annealing_tsp(dist_matrix, start_temp=100.0, alpha=0.99, stop_temp=1e-3): def total_distance(path): return sum(dist_matrix[path[i]][path[i + 1]] for i in range(len(path) - 1)) def random_swap(path): i, j = random.sample(range(1, len(path) - 1), 2) # Avoid the first and last city path[i], path[j] = path[j], path[i] return path num_cities = len(dist_matrix) if any(len(row) != num_cities for row in dist_matrix): raise ValueError(\\"Distance matrix must be square\\") if any(any(dist < 0 for dist in row) for row in dist_matrix): raise ValueError(\\"Distance matrix must not contain negative values\\") # Initial solution current_path = list(range(num_cities)) + [0] current_dist = total_distance(current_path) best_path = list(current_path) best_dist = current_dist temp = start_temp while temp > stop_temp: candidate_path = random_swap(list(current_path)) candidate_dist = total_distance(candidate_path) if candidate_dist < current_dist or random.random() < math.exp((current_dist - candidate_dist) / temp): current_path, current_dist = candidate_path, candidate_dist if current_dist < best_dist: best_path, best_dist = current_path, current_dist temp *= alpha return best_path"},{"question":"# Question: User Authentication System You are required to implement a simple user authentication system. The system will manage user registrations and logins. All user data, including usernames and passwords, should be stored in a dictionary-like structure. Function Signatures: ```python def register_user(username: str, password: str) -> None: Registers a new user with a username and password. Args: username (str): The username for the new user. password (str): The password for the new user. Raises: ValueError: If the username is already taken. def login_user(username: str, password: str) -> bool: Authenticates a user with a username and password. Args: username (str): The username of the user. password (str): The password of the user. Returns: bool: True if the login is successful, False otherwise. ``` Input & Output Formats: - **Input**: For `register_user` - a string for the username and a string for the password. - **Output**: None for `register_user`. For `login_user` - a boolean indicating the success of the login attempt. Constraints: - Usernames must be unique. - Store user data in a dictionary where keys are usernames and values are passwords. - Passwords should not be stored or checked in plain text; for simplicity, you can use a basic encryption approach such as reversing the string (in real systems, proper hashing should be used). - If a username is already taken when calling `register_user`, raise a `ValueError` with the message \\"Username already taken.\\" Sample Usage: ```python register_user(\\"alice\\", \\"password123\\") assert login_user(\\"alice\\", \\"password123\\") == True assert login_user(\\"bob\\", \\"password123\\") == False try: register_user(\\"alice\\", \\"differentpassword\\") except ValueError as e: print(e) # Expected output: \\"Username already taken\\" ``` **Notes**: Ensure the system can handle basic registration and login workflow, including edge cases where users attempt to register with an already taken username or login with invalid credentials.","solution":"users_db = {} def encrypt_password(password: str) -> str: return password[::-1] # For simplicity, reversing the string as encryption. def register_user(username: str, password: str) -> None: Registers a new user with a username and password. Args: username (str): The username for the new user. password (str): The password for the new user. Raises: ValueError: If the username is already taken. if username in users_db: raise ValueError(\\"Username already taken\\") encrypted_password = encrypt_password(password) users_db[username] = encrypted_password def login_user(username: str, password: str) -> bool: Authenticates a user with a username and password. Args: username (str): The username of the user. password (str): The password of the user. Returns: bool: True if the login is successful, False otherwise. if username not in users_db: return False encrypted_password = encrypt_password(password) return users_db[username] == encrypted_password"},{"question":"# PCA for Dimensionality Reduction You have been given a dataset represented in a multi-dimensional feature space. Your task is to implement a feature transformation using Principal Component Analysis (PCA) to project the data into a lower-dimensional space that retains as much variance as possible. **Function Signature**: ```python def perform_pca( features: np.ndarray, desired_dimensions: int ) -> np.ndarray: ``` **Input**: - `features`: A 2D numpy array of shape `(n_samples, n_features)`, where `n_samples` is the number of samples and `n_features` is the number of dimensions. - `desired_dimensions`: An integer representing the number of dimensions to project the data onto. Note that `desired_dimensions` should be less than `n_features`. **Output**: - A 2D numpy array of shape `(n_samples, desired_dimensions)` containing the dataset projected onto the new PCA space. **Constraints**: - Ensure `desired_dimensions` is less than `n_features`. - All inputs must be provided in the correct formats and will always contain valid data. - Performance is crucial, optimize matrix operations as much as possible. Your implementation should use the following steps: 1. Compute the mean of the dataset and center the data by subtracting the mean. 2. Calculate the covariance matrix of the centered data. 3. Perform eigenvalue decomposition on the covariance matrix to find the principal components. 4. Sort the eigenvectors according to their corresponding eigenvalues in descending order. 5. Select the top `desired_dimensions` eigenvectors to form the projection matrix. 6. Project the data onto the new PCA space. # Example ```python import numpy as np features = np.array([ [2.5, 0.5], [2.2, 0.3], [3.1, 1.9], [2.3, 1.0], [4.5, 3.6], [5.2, 4.1] ]) desired_dimensions = 1 projected_data = perform_pca(features, desired_dimensions) print(projected_data) ``` Write your implementation for the `perform_pca` function below, ensuring adherence to the above specifications and requirements.","solution":"import numpy as np def perform_pca(features: np.ndarray, desired_dimensions: int) -> np.ndarray: Perform Principal Component Analysis (PCA) on the given feature data. Parameters: features (np.ndarray): A 2D numpy array of shape (n_samples, n_features). desired_dimensions (int): The number of dimensions to project the data onto. Returns: np.ndarray: The dataset projected onto the new PCA space. # Step 1: Compute the mean of the dataset and center the data mean = np.mean(features, axis=0) centered_data = features - mean # Step 2: Calculate the covariance matrix of the centered data covariance_matrix = np.cov(centered_data, rowvar=False) # Step 3: Perform eigenvalue decomposition on the covariance matrix eigenvalues, eigenvectors = np.linalg.eigh(covariance_matrix) # Step 4: Sort the eigenvectors according to their corresponding eigenvalues in descending order sorted_indices = np.argsort(eigenvalues)[::-1] sorted_eigenvectors = eigenvectors[:, sorted_indices] # Step 5: Select the top desired_dimensions eigenvectors to form the projection matrix projection_matrix = sorted_eigenvectors[:, :desired_dimensions] # Step 6: Project the data onto the new PCA space projected_data = np.dot(centered_data, projection_matrix) return projected_data"},{"question":"# Problem Statement You are developing a system for managing network devices, each of which has a unique IP address. To ensure efficient monitoring, you need to determine the longest sequence of consecutive active IP addresses given a list of active IPs. Write a function named `longest_consecutive_active_ips` that takes a list of strings representing the active IP addresses and returns an integer representing the length of the longest sequence of consecutive active IPs. # Input * `active_ips` (list of str): A list of strings where each string represents an active IP address in IPv4 format (e.g., \\"192.168.1.1\\"). # Output * An integer representing the length of the longest sequence of consecutive active IP addresses. # Examples ```python # Example 1 assert longest_consecutive_active_ips([\\"192.168.1.1\\", \\"192.168.1.2\\", \\"192.168.1.3\\", \\"192.168.2.1\\"]) == 3 # Example 2 assert longest_consecutive_active_ips([\\"10.0.0.1\\", \\"10.0.0.3\\", \\"10.0.0.2\\", \\"10.0.0.4\\", \\"10.0.0.5\\"]) == 5 # Example 3 assert longest_consecutive_active_ips([\\"172.16.0.1\\", \\"172.16.0.2\\", \\"172.16.0.8\\", \\"172.16.0.7\\"]) == 2 # Example 4 assert longest_consecutive_active_ips([\\"127.0.0.1\\", \\"127.0.0.3\\"]) == 1 # Example 5 assert longest_consecutive_active_ips([]) == 0 ``` # Constraints * All IP addresses are valid IPv4 addresses. * The length of the input list will be between 0 and 10^4. * The list will not contain duplicate IP addresses. # Performance Requirements * The algorithm should be able to handle the input list efficiently. # Additional Notes * If the input list is empty, the function should return 0. * IP addresses should be considered consecutive if their numeric representation is consecutive. For example, \\"192.168.1.1\\" and \\"192.168.1.2\\" are consecutive IPs.","solution":"def ip_to_int(ip): Converts an IPv4 address from its string representation to an integer. parts = ip.split(\'.\') return int(parts[0]) * (256**3) + int(parts[1]) * (256**2) + int(parts[2]) * 256 + int(parts[3]) def longest_consecutive_active_ips(active_ips): Returns the length of the longest sequence of consecutive active IP addresses. if not active_ips: return 0 # Convert IPs to integers ip_integers = sorted(ip_to_int(ip) for ip in active_ips) longest_streak = 1 current_streak = 1 for i in range(1, len(ip_integers)): if ip_integers[i] == ip_integers[i - 1] + 1: current_streak += 1 else: longest_streak = max(longest_streak, current_streak) current_streak = 1 longest_streak = max(longest_streak, current_streak) return longest_streak"},{"question":"# Coding Task: Simulated File System **Objective**: Implement a simple in-memory file system that supports basic operations such as creating files, writing data, reading data, and deleting files. Classes and Methods to Implement: 1. **`class FileSystem`**: - **Attributes**: - `storage` (Dictionary): A dictionary to store file names as keys and their content as values. - **Methods**: 1. **`__init__(self)`**: - Initializes the `storage` attribute as an empty dictionary. 2. **`create_file(self, name: str, content: str = \\"\\") -> None`**: - **Input**: - `name` (String): The name of the file to create. - `content` (String, optional): The initial content of the file (default is an empty string). - **Output**: - None - **Constraints**: - `name` must be a non-empty string. - **Exception Handling**: - Raise `ValueError` if `name` is an empty string or if a file with the same name already exists. 3. **`write_file(self, name: str, content: str) -> None`**: - **Input**: - `name` (String): The name of the file to write data to. - `content` (String): The content to write to the file. - **Output**: - None - **Constraints**: - `name` must be a non-empty string. - **Exception Handling**: - Raise `ValueError` if `name` is an empty string or if the file does not exist. 4. **`read_file(self, name: str) -> str`**: - **Input**: - `name` (String): The name of the file to read data from. - **Output**: - Returns the content of the file (String). - **Constraints**: - `name` must be a non-empty string. - **Exception Handling**: - Raise `ValueError` if `name` is an empty string or if the file does not exist. 5. **`delete_file(self, name: str) -> None`**: - **Input**: - `name` (String): The name of the file to delete. - **Output**: - None - **Constraints**: - `name` must be a non-empty string. - **Exception Handling**: - Raise `ValueError` if `name` is an empty string or if the file does not exist. **Example Usages**: ```python fs = FileSystem() # Create files fs.create_file(\\"file1\\", \\"hello\\") fs.create_file(\\"file2\\") # Write to file fs.write_file(\\"file1\\", \\" world\\") fs.write_file(\\"file2\\", \\"Python programming\\") # Read from file assert fs.read_file(\\"file1\\") == \\"hello world\\" assert fs.read_file(\\"file2\\") == \\"Python programming\\" # Delete file fs.delete_file(\\"file1\\") fs.delete_file(\\"file2\\") # Ensure file is deleted try: fs.read_file(\\"file1\\") except ValueError: print(\\"file1 does not exist\\") try: fs.read_file(\\"file2\\") except ValueError: print(\\"file2 does not exist\\") ``` **Notes**: - Ensure that your code maintains the integrity of the file system. - Provide appropriate documentation and doctests for each method. - Handle exceptions gracefully and provide informative error messages.","solution":"class FileSystem: def __init__(self): Initialize the FileSystem with an empty storage. self.storage = {} def create_file(self, name: str, content: str = \\"\\") -> None: Create a file with the given name and initial content. :param name: The name of the file to create. :param content: The initial content of the file. :raises ValueError: If the file name is empty or the file already exists. if not name: raise ValueError(\\"File name cannot be empty.\\") if name in self.storage: raise ValueError(\\"File already exists.\\") self.storage[name] = content def write_file(self, name: str, content: str) -> None: Write content to a file. :param name: The name of the file to write data to. :param content: The content to write to the file. :raises ValueError: If the file name is empty or the file does not exist. if not name: raise ValueError(\\"File name cannot be empty.\\") if name not in self.storage: raise ValueError(\\"File does not exist.\\") self.storage[name] += content def read_file(self, name: str) -> str: Read the content of a file. :param name: The name of the file to read data from. :return: The content of the file. :raises ValueError: If the file name is empty or the file does not exist. if not name: raise ValueError(\\"File name cannot be empty.\\") if name not in self.storage: raise ValueError(\\"File does not exist.\\") return self.storage[name] def delete_file(self, name: str) -> None: Delete a file by name. :param name: The name of the file to delete. :raises ValueError: If the file name is empty or the file does not exist. if not name: raise ValueError(\\"File name cannot be empty.\\") if name not in self.storage: raise ValueError(\\"File does not exist.\\") del self.storage[name]"},{"question":"# Scenario: A company wants to automate the process of optimizing their event schedule. The company hosts multiple sessions, and some sessions must be attended before others. This precedence of sessions can be represented as a Directed Acyclic Graph (DAG). You are tasked with writing a function to determine a valid schedule of sessions that respects these constraints. # Implement the Function: **Function Signature**: ```python def event_schedule(graph: List[List[int]], sessions: Dict[int, str]) -> List[str]: pass ``` **Input**: * A graph represented as an adjacency list: `graph` (List[List[int]]). * A dictionary mapping each node to its session name: `sessions` (Dict[int, str]). **Output**: * A list of session names in the order they should be scheduled. **Constraints**: * Session names will be unique. * The graph is guaranteed to be a Directed Acyclic Graph (DAG). # Example: **Input**: ```python graph = [[1, 3], [2], [3], [], [2, 5], []] sessions = {0: \\"Keynote\\", 1: \\"Workshop 1\\", 2: \\"Workshop 2\\", 3: \\"Networking\\", 4: \\"Panel Discussion\\", 5: \\"Closing Remarks\\"} ``` **Output**: ```python [\'Keynote\', \'Workshop 1\', \'Workshop 2\', \'Panel Discussion\', \'Networking\', \'Closing Remarks\'] ``` **Explanation**: The provided graph and session mapping imply that \\"Keynote\\" needs to be scheduled before \\"Workshop 1,\\" \\"Workshop 1\\" before \\"Workshop 2,\\" and so on. The topological sorting correctly determines the schedule order. # Tips: * Implement the depth-first search to perform the topological sort. * Handle recursions and stack management properly to avoid cyclic dependencies. * Ensure that the stack is correctly emptied to provide the final sorted order of sessions.","solution":"from typing import List, Dict def event_schedule(graph: List[List[int]], sessions: Dict[int, str]) -> List[str]: def dfs(node): nonlocal has_cycle, visited, stack if visited[node] == 1: has_cycle = True return if visited[node] == 2: return visited[node] = 1 # Mark as visiting for neighbor in graph[node]: if not has_cycle: dfs(neighbor) visited[node] = 2 # Mark as visited stack.append(node) n = len(graph) visited = [0] * n stack = [] has_cycle = False for i in range(n): if not has_cycle and visited[i] == 0: dfs(i) if has_cycle: return [] stack.reverse() # The topological order return [sessions[node] for node in stack]"},{"question":"# Coding Question: Check for Pandigital Numbers Context: A pandigital number contains each digit from 0 to 9 at least once. Identifying whether a number is pandigital can be useful in various domains such as cryptography, number theory, and algorithm challenges. Problem Statement: Write a Python function named `is_pandigital` that takes an integer `n` as input and returns `True` if the number is pandigital, otherwise returns `False`. Your function must validate the input to ensure it\'s a positive integer. Your input must adhere to the following constraints: - The input will always be a non-negative integer. - The input value will be less than or equal to ( 10^{18} ). Requirements: 1. If `n` is negative or not an integer, the function should raise appropriate exceptions: - For negative values, raise a `ValueError` with the message \\"Input value must be a positive integer\\". - For non-integer types, raise a `TypeError` with the message \\"Input value must be \'int\' type\\". Function Signature: ```python def is_pandigital(n: int) -> bool: pass ``` Examples: ```python print(is_pandigital(1234567890)) # Output: True print(is_pandigital(123456789)) # Output: False print(is_pandigital(9876543210)) # Output: True print(is_pandigital(1023456789)) # Output: True print(is_pandigital(1234506789)) # Output: True print(is_pandigital(1234567890)) # Output: True # Error scenarios print(is_pandigital(-1234567890)) # Raises ValueError print(is_pandigital(1234567890.123)) # Raises TypeError print(is_pandigital(\\"1234567890\\")) # Raises TypeError ```","solution":"def is_pandigital(n: int) -> bool: This function checks if the input number n is a pandigital number. A pandigital number contains each digit from 0 to 9 at least once. Parameters: n (int): The input number to be checked. Returns: bool: True if n is a pandigital number, otherwise False. Raises: ValueError: If the input number is negative. TypeError: If the input is not an integer. # Check if the input is not an integer if not isinstance(n, int): raise TypeError(\\"Input value must be \'int\' type\\") # Check if the input is a negative number if n < 0: raise ValueError(\\"Input value must be a positive integer\\") # Convert the number to a string to examine its digits num_str = str(n) # Check if the number\'s digit set is equal to {\'0\', \'1\', \'2\', \'3\', \'4\', \'5\', \'6\', \'7\', \'8\', \'9\'} return set(num_str) == set(\'0123456789\')"},{"question":"# Unique Subsets You are provided with an array of integers, and you need to determine all possible unique subsets of the given array. Note that the elements in each subset should be in non-decreasing order, and the solution should not have any duplicate subsets. Implement the function `unique_subsets(input_array: List[int]) -> List[List[int]]` that returns a list of lists, where each list is a unique subset of the input array. Input: - A list of integers `input_array` (0 ≤ |input_array| ≤ 10), where each element `-10 ≤ input_array[i] ≤ 10`. Output: - A list of lists, where each list is a unique subset of `input_array`, sorted in non-decreasing order of their elements. The entire list of lists should be sorted in increasing order by the lexicographic order of subsets. Constraints: - Subsets must be sorted in non-decreasing order. - The solution must not contain duplicate subsets. # Examples: ```python def test_unique_subsets(): assert unique_subsets([1, 2, 2]) == [[], [1], [1, 2], [1, 2, 2], [2], [2, 2]] assert unique_subsets([0]) == [[], [0]] assert unique_subsets([-1, -1, 2]) == [[], [-1], [-1, -1], [-1, -1, 2], [-1, 2], [2]] assert unique_subsets([1, 3, 2]) == [[], [1], [1, 2], [1, 2, 3], [1, 3], [2], [2, 3], [3]] assert unique_subsets([]) == [[]] print(\\"All tests passed.\\") if __name__ == \\"__main__\\": test_unique_subsets() ``` Explanation of the function\'s logic: 1. **Sorting**: Initially sort the input array, ensuring the elements in each subset are in non-decreasing order. 2. **Backtracking**: Use a backtracking function to explore all potential subsets, ensuring no duplicate subsets are added by skipping over duplicate elements during iteration. 3. **Result Storage**: Collect all unique subsets, sort them lexicographically, and return them as the final result. The function should handle edge cases like empty arrays and arrays with duplicate elements properly, ensuring no redundant subsets are produced.","solution":"from typing import List def unique_subsets(input_array: List[int]) -> List[List[int]]: Returns all unique subsets of the given array sorted in non-decreasing order, and the list of subsets is sorted lexicographically. def backtrack(start: int, path: List[int]): result.append(path[:]) for i in range(start, len(input_array)): if i > start and input_array[i] == input_array[i - 1]: continue path.append(input_array[i]) backtrack(i + 1, path) path.pop() input_array.sort() result = [] backtrack(0, []) return result"},{"question":"# Coding Assessment Question You are tasked with implementing a function that analyzes traffic data collected from a city\'s main intersections to determine peak traffic hours. The data is obtained from an API that provides traffic counts at each intersection for every hour of the day. Function Specification **Function Name**: `get_peak_traffic_hours` **Input Parameters**: 1. `intersections`: (list) A list of intersection names. 2. `date`: (str) Date in `YYYY-MM-DD` format. 3. `threshold`: (int) Optional parameter that specifies the minimum traffic count to be considered as peak traffic. Default is `1000`. **Output**: - Returns a dictionary where keys are intersection names and values are lists of hours during which the traffic count exceeded the specified threshold. **Constraints**: - The `date` should be in the past or present, not the future. - Only data available from the API\'s dataset should be considered. - Handle cases where the intersection data might not be available for the given date. Example Usage ```python def get_peak_traffic_hours(intersections: list, date: str, threshold=1000) -> dict: # Your implementation here pass # Example call peak_hours = get_peak_traffic_hours([\\"Main St & 1st Ave\\", \\"Elm St & 2nd Ave\\"], \\"2021-09-01\\", 1500) for intersection, hours in peak_hours.items(): print(f\\"{intersection}: {hours}\\") ``` # Requirements: 1. **Error Handling**: Your implementation should gracefully handle API errors, invalid dates, and cases where an intersection\'s data is not available. 2. **Data Processing**: Efficiently process the data to determine the peak traffic hours, avoiding unnecessary computations. 3. **Flexibility**: Allow the user to specify a custom threshold for peak traffic and ensure the function works for a variable number of intersections. 4. **Clear Documentation and Code**: Provide meaningful function and variable names, and ensure your code is well-documented. You have 2 hours to complete this task. Good luck!","solution":"import requests from datetime import datetime def get_peak_traffic_hours(intersections, date, threshold=1000): Returns a dictionary where keys are intersection names and values are lists of hours during which the traffic count exceeded the specified threshold. # Check if the input date is valid and not in future if not validate_date(date): raise ValueError(\\"Invalid date format or date is in the future.\\") # Initialize the result dictionary peak_hours = {intersection: [] for intersection in intersections} for intersection in intersections: try: # Make API call to fetch traffic data for the given intersection and date response = requests.get(f\\"https://api.trafficdata.com/{intersection}/{date}\\") data = response.json() traffic_counts = data[\'traffic_counts\'] for hour, count in traffic_counts.items(): if count > threshold: peak_hours[intersection].append(hour) except Exception as e: # If data for the intersection is not available or any other error occurs, continue print(f\\"Error fetching data for {intersection}: {e}\\") continue return peak_hours def validate_date(date_str): Validates if the input date is in \'YYYY-MM-DD\' format and is not in the future. try: input_date = datetime.strptime(date_str, \\"%Y-%m-%d\\") if input_date > datetime.now(): return False return True except ValueError: return False"},{"question":"# Prime Factorization Problem Context You are developing a utility function for a scientific calculator. One of the key features of this calculator is to compute the prime factorization of a given integer, which is a breakdown of the number into its prime factors. Problem Statement Write a Python function `prime_factorization` that computes the prime factorization of a given integer. The function should take a single parameter: - `n` (an integer) - the number to factorize. The function should return a list of integers representing the prime factors of `n` in non-decreasing order. Function Signature ```python def prime_factorization(n: int) -> List[int]: ``` Example ```python >>> prime_factorization(60) [2, 2, 3, 5] >>> prime_factorization(13) [13] >>> prime_factorization(1) [] >>> prime_factorization(100) [2, 2, 5, 5] ``` Constraints and Notes 1. If `n` is 1 or less, return an empty list. 2. Ensure the function handles large numbers efficiently. 3. Be mindful of edge cases, such as `n` being a prime number itself or very large composite numbers. 4. Use an efficient algorithm to minimize the number of operations, such as trial division up to the square root of `n`. Testing Include several test cases to validate your function, addressing the key edge cases and ensuring robustness for large inputs.","solution":"from typing import List def prime_factorization(n: int) -> List[int]: Returns the prime factorization of the given integer n as a list of prime factors in non-decreasing order. if n <= 1: return [] factors = [] # Check for number of 2s that divide n while n % 2 == 0: factors.append(2) n //= 2 # Check for odd factors from 3 to sqrt(n) factor = 3 while factor * factor <= n: while n % factor == 0: factors.append(factor) n //= factor factor += 2 if n > 2: factors.append(n) return factors"},{"question":"# Matrix Transposition # Context: In various mathematical and computational applications, matrix operations are frequently required. One common operation is the transpose of a matrix, which involves swapping its rows and columns. # Task: Your task is to implement a function `transpose_matrix(matrix: List[List[int]]) -> List[List[int]]` in Python. # Function Signature: ```python def transpose_matrix(matrix: List[List[int]]) -> List[List[int]]: ``` # Input: * `matrix` (List[List[int]]): A 2D list representing the matrix to be transposed. # Output: * A 2D list representing the transposed matrix. # Constraints: * The input matrix can be of any size from 1x1 up to 10^3 x 10^3. * Each element in the matrix is an integer within the range of -10^6 to 10^6. # Examples: ```python >>> transpose_matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) [[1, 4, 7], [2, 5, 8], [3, 6, 9]] >>> transpose_matrix([[1, 2], [3, 4], [5, 6]]) [[1, 3, 5], [2, 4, 6]] >>> transpose_matrix([[1]]) [[1]] >>> transpose_matrix([[]]) [[]] >>> transpose_matrix([[-1, -2, -3]]) [[-1], [-2], [-3]] ``` # Notes: 1. The input matrix may be empty or have a different number of rows and columns. 2. Handle various edge cases, such as non-square matrices and matrices filled with negative numbers effectively. 3. If the input matrix is empty, the output should also be an empty matrix. Good luck!","solution":"from typing import List def transpose_matrix(matrix: List[List[int]]) -> List[List[int]]: Transposes a given matrix. Parameters: matrix (List[List[int]]): The input 2D list representing the matrix to be transposed. Returns: List[List[int]]: The transposed matrix. if not matrix or not matrix[0]: # Checking if the matrix is empty or has empty rows return [[]] if matrix else [] return list(map(list, zip(*matrix)))"},{"question":"# Challenge: Unique Anagram Sets You are tasked with writing a function to count the number of unique sets of anagrams from a list of words. An anagram is a word formed by rearranging the letters of another word, using all the original letters exactly once. **Function Signature**: ```python def count_unique_anagram_sets(words: List[str]) -> int: pass ``` **Input**: - `words` (List[str]): A list of words consisting of lowercase alphabetic characters. **Output**: - Return the count of unique sets of anagrams. **Constraints**: - (1 leq len(words) leq 10^5) - (1 leq len(word) leq 100) for each word in `words` **Example**: ```python words = [\\"listen\\", \\"silent\\", \\"enlist\\", \\"hello\\", \\"ohlle\\"] print(count_unique_anagram_sets(words)) # Output: 2 ``` # Problem Context To determine unique sets of anagrams, you should: 1. Sort the letters of each word. 2. Use the sorted versions of the words to identify identical anagrams. 3. Count the number of unique sorted versions, which corresponds to the unique sets of anagrams. # Steps: 1. Create a helper function to sort the letters of a word. 2. Iterate through the list of words, transform each word by sorting its letters. 3. Use a set to collect the sorted versions, ensuring each unique sorted version is counted only once. 4. Return the size of the set, representing the number of unique anagram sets.","solution":"from typing import List def count_unique_anagram_sets(words: List[str]) -> int: sorted_words = [\'\'.join(sorted(word)) for word in words] unique_anagrams = set(sorted_words) return len(unique_anagrams)"},{"question":"# Coding Assessment Question: Context: Consider a scenario where you are developing a program for a weather monitoring system. The system gathers real-time weather data from multiple cities around the world and stores this information for further analysis. One of your tasks is to write a function that fetches and processes this weather data into a human-readable format. Task: Write a Python function named `fetch_and_process_weather_data` that retrieves weather information for a list of cities using a weather API. The function should then format the retrieved data and save it to a specified file in a structured and readable manner. Function Signature: ```python def fetch_and_process_weather_data(api_key: str, cities: list, output_file: str) -> None: ``` Inputs: * **api_key**: A string representing the API key for the weather API. * **cities**: A list of strings where each string is a city name you want to retrieve weather data for. * **output_file**: A string representing the filename where the processed weather data will be saved. Outputs: * This function should not return anything. Instead, it should save the formatted weather data in the specified file. Constraints: * Ensure efficient handling of multiple API requests. * Handle possible exceptions such as network errors, invalid city names, and file I/O errors. * The output file should contain the city name, current temperature, weather description, and humidity for each city in a readable format. Example: ```python fetch_and_process_weather_data(\\"YOUR_API_KEY\\", [\\"New York\\", \\"Los Angeles\\", \\"London\\"], \\"weather_data.txt\\") ``` After running the function, the `weather_data.txt` file should contain structured weather information for \\"New York\\", \\"Los Angeles\\", and \\"London\\", formatted in a human-readable way. For example: ``` City: New York Temperature: 22°C Weather: Clear sky Humidity: 55% City: Los Angeles Temperature: 26°C Weather: Sunny Humidity: 40% City: London Temperature: 17°C Weather: Partly cloudy Humidity: 70% ```","solution":"import requests def fetch_and_process_weather_data(api_key: str, cities: list, output_file: str) -> None: Fetches weather data for the specified cities and writes it to an output file in a readable format. Parameters: - api_key: str: The API key for the weather service. - cities: list: List of city names to fetch weather data for. - output_file: str: The file where the formatted weather data will be saved. base_url = \\"http://api.openweathermap.org/data/2.5/weather\\" results = [] for city in cities: try: response = requests.get(base_url, params={\\"q\\": city, \\"appid\\": api_key, \\"units\\": \\"metric\\"}) response.raise_for_status() data = response.json() city_name = data[\\"name\\"] temperature = data[\\"main\\"][\\"temp\\"] weather = data[\\"weather\\"][0][\\"description\\"] humidity = data[\\"main\\"][\\"humidity\\"] results.append(f\\"City: {city_name}nTemperature: {temperature}°CnWeather: {weather}nHumidity: {humidity}%n\\") except requests.RequestException as e: results.append(f\\"City: {city} - Error: {str(e)}n\\") except KeyError as e: results.append(f\\"City: {city} - Error: Invalid response structure - {str(e)}n\\") try: with open(output_file, \\"w\\") as file: file.write(\\"n\\".join(results)) except IOError as e: print(f\\"Failed to write to file {output_file}: {str(e)}\\")"},{"question":"Problem Statement Given a large text document containing multiple paragraphs, identify all unique words that are anagrams of each other. Group these words and return them as a list of lists sorted lexicographically within each group. Detailed Requirements: 1. Implement the function `group_anagrams` that processes the text document and groups anagram words together. 2. A word is defined as a sequence of alphanumeric characters, and words are case-insensitive, i.e., \'Word\' and \'word\' should be considered the same. 3. Punctuation marks and other non-alphanumeric characters should be ignored. 4. The function should identify anagrams and return them as a list of lists, each containing words that are anagrams of each other. Input - The function will take a single string input consisting of the text document. Output - The function should return a list of lists, where each internal list contains words that are anagrams of each other, sorted lexicographically within the group. Constraints - Words are limited to English letters (both uppercase and lowercase) and digits. - The maximum length of text can be (10^6) characters. Performance Expectations - Time Complexity: O(n log n) for sorting operations within each group. - Space Complexity: O(k) where k is the number of unique words. Example ```python def group_anagrams(text: str) -> list: # Implement the function to solve the problem. pass if __name__ == \\"__main__\\": document = \\"Listen Silent, Enlist! Tinsel; in Lets\\" print(group_anagrams(document)) ``` Expected output: ```python [[\'enlist\', \'listen\', \'silent\', \'tinsel\']] ```","solution":"import re from collections import defaultdict def group_anagrams(text: str) -> list: Process the text document and groups anagram words together. Arguments: text : str : a large text document containing multiple paragraphs. Returns: list of lists : each containing words that are anagrams of each other, sorted lexicographically within the group. # Normalize the text to lowercase and find all words using regex words = re.findall(r\'bw+b\', text.lower()) # Dictionary to hold sorted word as key and list of anagrams as values anagrams_dict = defaultdict(list) # Populate the dictionary with anagrams for word in words: sorted_word = \'\'.join(sorted(word)) anagrams_dict[sorted_word].append(word) # Collect results from the dictionary, each group sorted lexicographically result = [sorted(group) for group in anagrams_dict.values() if len(group) > 1] return sorted(result)"},{"question":"# Implement a Circular Buffer (Ring Buffer) Scenario: In many systems, a circular buffer (also called a ring buffer) is a useful data structure for managing a fixed-size buffer that wraps around. This is often used in scenarios where data from a continuous source needs to be processed in a manner that overwrites the oldest data when the buffer is full. Problem: You need to implement a `CircularBuffer` class that supports the following operations: 1. `write` - Adds a new element to the buffer. If the buffer is full, it should overwrite the oldest element. 2. `read` - Removes and returns the oldest element from the buffer. If the buffer is empty, it should raise an exception. Input and Output Formats: * **Input**: Operations on the `CircularBuffer` instance. * **Output**: The return values of the `read` operations or the raised exceptions, if any. Constraints: * You may assume that all inputs to `write` and `read` are valid. * The buffer should handle any types of elements (e.g., integers, strings). * The buffer size (capacity) will be set at initialization and will remain constant. * You should optimize for efficient read and write operations, ideally O(1). Example Usage: ```python # Create a circular buffer with a capacity of 3 buffer = CircularBuffer(3) # Write some values buffer.write(1) buffer.write(2) buffer.write(3) # Read the oldest value (should be 1) print(buffer.read()) # Output: 1 # Write another value (overwrites the oldest element: 2) buffer.write(4) # Read the next oldest values print(buffer.read()) # Output: 2 print(buffer.read()) # Output: 3 # Read the remaining value (should be 4) print(buffer.read()) # Output: 4 # Attempt to read from an empty buffer (should raise an exception) try: buffer.read() except IndexError as e: print(e) # Output: Buffer is empty ``` Method Signatures: ```python class CircularBuffer: def __init__(self, capacity: int): Initializes the circular buffer with a given capacity. :param capacity: The maximum number of elements the buffer can hold. :type capacity: int pass def write(self, value) -> None: Adds a new element to the circular buffer. If the buffer is full, it should overwrite the oldest element. :param value: The value to be added to the buffer. pass def read(self): Removes and returns the oldest element from the buffer. :return: The oldest element in the buffer. :raises IndexError: If the buffer is empty. pass ``` Additional Considerations: * Think about how to track the \\"oldest\\" and \\"newest\\" positions within the buffer. * Ensure to handle buffer wrap-around correctly. * Provide clear and informative error messages when exceptions are raised.","solution":"class CircularBuffer: def __init__(self, capacity: int): Initializes the circular buffer with a given capacity. :param capacity: The maximum number of elements the buffer can hold. :type capacity: int self.capacity = capacity self.buffer = [None] * capacity self.start = 0 # Points to the start (oldest element) self.end = 0 # Points to the end (newest element) self.size = 0 # Current number of elements in the buffer def write(self, value) -> None: Adds a new element to the circular buffer. If the buffer is full, it should overwrite the oldest element. :param value: The value to be added to the buffer. if self.size == self.capacity: self.start = (self.start + 1) % self.capacity else: self.size += 1 self.buffer[self.end] = value self.end = (self.end + 1) % self.capacity def read(self): Removes and returns the oldest element from the buffer. :return: The oldest element in the buffer. :raises IndexError: If the buffer is empty. if self.size == 0: raise IndexError(\\"Buffer is empty\\") value = self.buffer[self.start] self.start = (self.start + 1) % self.capacity self.size -= 1 return value"},{"question":"# Context Parsing and evaluating expressions is a basic yet important task in programming, involving the processing of operations and operands in a structured format. # Task Implement a class `ExpressionEvaluator` that can parse and evaluate mathematical expressions provided as strings. The expressions can include integers, the operators `+`, `-`, `*`, `/`, and parentheses `(`, `)`. # Your Task Function Implementations **Class**: `ExpressionEvaluator` 1. **__init__(self)** - **Functionality**: Initializes any required data structures or variables for the evaluator. 2. **evaluate(self, expression: str) -> int** - **Input**: A string `expression` representing the mathematical expression to be evaluated. - **Output**: Returns the integer result of evaluating the expression. - **Time Complexity**: Should be efficient enough to handle typical input sizes gracefully, with common sub-operations (parsing, evaluating) ideally in linear or near-linear time. Constraints - The length of the expression string will not exceed `10^4`. - The expression will be a valid mathematical expression containing only integers, operators (`+`, `-`, `*`, `/`), and parentheses. - Operators are applied with standard precedence and associativity. # Example ```python # Assuming the implementation is already done. evaluator = ExpressionEvaluator() # Evaluate a simple expression print(evaluator.evaluate(\\"3+5\\")) # Output: 8 # Evaluate an expression with parentheses print(evaluator.evaluate(\\"(2+3)*4\\")) # Output: 20 # Evaluate a complex expression print(evaluator.evaluate(\\"10+(2*3)-(3+2)/1\\")) # Output: 11 ``` # Commentary This question is designed to test the candidate\'s ability to implement an expression parser and evaluator, handling typical operator precedence and associativity, while also efficiently managing potentially complex nested expressions. This problem requires a fundamental understanding of algorithms, stacks, recursion, and string manipulation, making it suitable in complexity and scope for an assessment focused on programming and problem-solving skills.","solution":"class ExpressionEvaluator: def __init__(self): pass def evaluate(self, expression: str) -> int: def apply_operator(operators, values): operator = operators.pop() right = values.pop() left = values.pop() if operator == \'+\': values.append(left + right) elif operator == \'-\': values.append(left - right) elif operator == \'*\': values.append(left * right) elif operator == \'/\': values.append(int(left / right)) # Use int() for floor division def precedence(op): if op in (\'+\', \'-\'): return 1 if op in (\'*\', \'/\'): return 2 return 0 def evaluate_basic_expression(tokens): values = [] operators = [] i = 0 while i < len(tokens): if tokens[i] == \' \': i += 1 continue if tokens[i] == \'(\': operators.append(tokens[i]) elif tokens[i].isdigit(): val = 0 while (i < len(tokens) and tokens[i].isdigit()): val = (val * 10) + int(tokens[i]) i += 1 values.append(val) i -= 1 elif tokens[i] == \')\': while len(operators) != 0 and operators[-1] != \'(\': apply_operator(operators, values) operators.pop() else: while (len(operators) != 0 and precedence(operators[-1]) >= precedence(tokens[i])): apply_operator(operators, values) operators.append(tokens[i]) i += 1 while len(operators) != 0: apply_operator(operators, values) return values[-1] return evaluate_basic_expression(list(expression))"},{"question":"Implement a Custom LRU Cache You have been asked to implement a custom LRU (Least Recently Used) Cache for a caching system. The goal is to optimize page access time by ensuring the most frequently accessed pages are easily retrievable. When the cache reaches its maximum capacity, the least recently accessed page should be removed to make space for a new one. Implement an `LRUCache` class that supports the following operations: 1. `get(key: int) -> int`: Returns the value of the key if the key exists in the cache, otherwise returns -1. 2. `put(key: int, value: int) -> None`: Updates the value of the key if the key exists. Otherwise, adds the key-value pair to the cache. If the cache reaches its capacity, it should invalidate the least recently used item before inserting a new item. To achieve this, you should use a combination of a dictionary to support O(1) average time complexity for the `get` and `put` operations, and a doubly-linked list to maintain the order of access. # Input and Output Format Implement the `LRUCache` class with the following methods: - `__init__(self, capacity: int)`: Initialize the cache with a positive capacity. - `get(self, key: int) -> int`: Retrieve the value associated with the `key`. - `put(self, key: int, value: int) -> None`: Insert or update the `key` and its `value`. The cache should be tested with multiple operations in a sequence to validate its functionality. Example ```python class LRUCache: def __init__(self, capacity: int): self.capacity = capacity # Implement the appropriate data structures here def get(self, key: int) -> int: # Implement the get operation def put(self, key: int, value: int) -> None: # Implement the put operation # Test Cases cache = LRUCache(2) # capacity is 2 cache.put(1, 1) cache.put(2, 2) assert cache.get(1) == 1 # returns 1 cache.put(3, 3) # evicts key 2 assert cache.get(2) == -1 # returns -1 (not found) cache.put(4, 4) # evicts key 1 assert cache.get(1) == -1 # returns -1 (not found) assert cache.get(3) == 3 # returns 3 assert cache.get(4) == 4 # returns 4 ``` Provide the complete implementation of the `LRUCache` class.","solution":"class Node: def __init__(self, key, value): self.key = key self.value = value self.prev = None self.next = None class LRUCache: def __init__(self, capacity: int): self.capacity = capacity self.cache = {} self.head = Node(0, 0) self.tail = Node(0, 0) self.head.next = self.tail self.tail.prev = self.head def _remove(self, node): previous = node.prev next = node.next previous.next = next next.prev = previous def _add(self, node): previous = self.tail.prev previous.next = node self.tail.prev = node node.prev = previous node.next = self.tail def get(self, key: int) -> int: if key in self.cache: node = self.cache[key] self._remove(node) self._add(node) return node.value return -1 def put(self, key: int, value: int) -> None: if key in self.cache: self._remove(self.cache[key]) node = Node(key, value) self._add(node) self.cache[key] = node if len(self.cache) > self.capacity: lru = self.head.next self._remove(lru) del self.cache[lru.key]"},{"question":"# Trie: Auto-Complete Suggestion Function **Context**: You are building a search engine feature that provides auto-complete suggestions as users type in a query. You need to implement this functionality using a trie (prefix tree) data structure to store a list of words and efficiently suggest completions based on a given prefix. **Task**: Implement a class `Trie` with the following methods: - `insert(word: str) -> None`: Inserts the `word` into the trie. - `suggest(prefix: str) -> List[str]`: Returns a list of all words in the trie that start with the given `prefix`. The words should be returned in lexicographical order. **Input Format**: - For the `insert` method: - A single string `word` which represents the word to be inserted into the trie. - The string will contain only English lowercase letters. - The length of the string will be between 1 and 1000 characters. - For the `suggest` method: - A single string `prefix` which represents the prefix to search for. - The string will contain only English lowercase letters. - The length of the string will be between 1 and 1000 characters. **Output Format**: - For the `suggest` method, a list of strings each representing a word that starts with the given `prefix`, sorted in lexicographical order. **Constraints**: - You may assume that the `insert` method will only be called with valid English lowercase words. - The trie can contain up to 100,000 words. - There can be up to 10,000 calls to the `suggest` method. **Examples**: ```python trie = Trie() trie.insert(\\"hello\\") trie.insert(\\"hell\\") trie.insert(\\"heaven\\") trie.insert(\\"heavy\\") assert trie.suggest(\\"he\\") == [\\"heaven\\", \\"heavy\\", \\"hell\\", \\"hello\\"] assert trie.suggest(\\"hel\\") == [\\"hell\\", \\"hello\\"] assert trie.suggest(\\"hea\\") == [\\"heaven\\", \\"heavy\\"] assert trie.suggest(\\"hex\\") == [] ``` **Performance Requirements**: - Ensure the `insert` method runs efficiently for long words and large numbers of insertions. - The `suggest` method should perform efficiently for prefix searches, with an expected time complexity close to O(k + n), where `k` is the length of the prefix and `n` is the number of words starting with that prefix.","solution":"class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False class Trie: def __init__(self): self.root = TrieNode() def insert(self, word: str) -> None: node = self.root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.is_end_of_word = True def suggest(self, prefix: str): def dfs(node, path, results): if node.is_end_of_word: results.append(path) for char in sorted(node.children.keys()): dfs(node.children[char], path + char, results) node = self.root for char in prefix: if char in node.children: node = node.children[char] else: return [] results = [] dfs(node, prefix, results) return results"},{"question":"# Sum of Two Context and Objective You are developing a feature for a financial application where users can split a bill amount among two individuals such that both individuals\' contributions sum up to a specified target amount. The application needs a function that identifies whether there exist two distinct elements within a list of integers that, when added, sum up to a given target. Problem Statement Given a list of integers and a target number, write a function `find_pair_with_sum` that returns a tuple of two numbers from the list that add up to the target sum. If no such pair exists, return `None`. Function Signature ```python def find_pair_with_sum(nums: list[int], target: int) -> tuple[int, int] | None: pass ``` Input Constraints - `nums`: A list of integers. - `target`: An integer representing the target sum. Assume: - The list `nums` contains at least two integers. - If there are multiple valid pairs, you may return any one of them. Output - Return a tuple of two integers that sum up to the target. If no such pair exists, return `None`. Example ```python # Example 1: nums = [2, 7, 11, 15] target = 9 # 2 + 7 = 9 assert find_pair_with_sum(nums, target) == (2, 7) # Example 2: nums = [1, 2, 3, 4, 5] target = 10 # No two numbers add up to 10 assert find_pair_with_sum(nums, target) == None ``` Notes - You may assume the list of integers does not contain duplicate values. - Optimize for time complexity and aim for an O(n) solution. - Consider edge cases such as negative numbers and zero as part of the list.","solution":"def find_pair_with_sum(nums: list[int], target: int) -> tuple[int, int] | None: seen = {} for num in nums: complement = target - num if complement in seen: return (complement, num) seen[num] = True return None"},{"question":"# Problem Statement: You are given a string containing alpha-numeric characters and special characters. The task is to write a function `strip_and_sort` that strips all the special characters from the given string, converts all alphabetic characters to lowercase, and then sorts all the characters in increasing order of their ASCII values. # Functions to Implement: 1. `strip_and_sort(input_str: str) -> str` **Parameters**: - `input_str` (str): Input string containing alpha-numeric and special characters. **Returns**: - `sorted_str` (str): A new string containing the sorted alpha-numeric characters from the input string in increasing order of their ASCII values, with all alphabetic characters in lowercase. # Constraints: - The length of the string will not exceed 1000 characters. - You must output a string with only alpha-numeric characters sorted in increasing order of their ASCII values. # Example: ```python input_str = \\"He!lL7o W2or@lD!\\" print(strip_and_sort(input_str)) # Output should be \\"2dellooorw7\\" ``` # Hints: - You can use Python string methods to check if a character is alphanumeric. - Consider using Python list methods to accumulate and sort the eligible characters. - The `lower()` method can be used to handle the case conversion of alphabetic characters.","solution":"def strip_and_sort(input_str: str) -> str: Strips all special characters from the input string, converts all alphabetic characters to lowercase, and then sorts all the characters in increasing order of their ASCII values. Args: input_str (str): The input string consisting of alpha-numeric and special characters. Returns: str: A new string containing sorted alpha-numeric characters in increasing ASCII order, all in lowercase. # Filter out alphanumeric characters and convert alphabetic ones to lowercase alphanumeric_chars = [char.lower() for char in input_str if char.isalnum()] # Sort the characters by their ASCII values sorted_chars = sorted(alphanumeric_chars) # Join the sorted characters to form the resulting string sorted_str = \'\'.join(sorted_chars) return sorted_str"},{"question":"# Scenario You are developing an application for a library to manage book circulation and user memberships. One of your tasks is to create a system that can quickly retrieve information about which users currently have overdue books based on the current date. # Task Write a function `find_overdue_books(users: List[Dict[str, Union[str, List[str]]]], current_date: str) -> List[str]` that identifies users with overdue books. Assume dates are represented in the format \'YYYY-MM-DD\'. # Input Format * `users`: A list of dictionaries where each dictionary contains the following keys: * `name`: Name of the user (string). * `borrowed_books`: A list of strings where each string is in the format \'book_title:due_date\'. * `current_date`: A string representing the current date in \'YYYY-MM-DD\' format. # Output Format * Return a list of user names (strings) who have overdue books. The list should be sorted alphabetically. # Constraints * There are at most (10^4) users. * Each user can have at most (10^3) borrowed books. * The due dates and the current date are valid dates in the \'YYYY-MM-DD\' format. # Example ```python users = [ {\\"name\\": \\"Alice\\", \\"borrowed_books\\": [\\"Book1:2023-09-10\\", \\"Book2:2023-10-01\\"]}, {\\"name\\": \\"Bob\\", \\"borrowed_books\\": [\\"Book3:2023-10-05\\"]}, {\\"name\\": \\"Charlie\\", \\"borrowed_books\\": [\\"Book4:2023-08-30\\", \\"Book5:2023-09-15\\"]} ] current_date = \\"2023-10-01\\" print(find_overdue_books(users, current_date)) # Output: [\\"Charlie\\"] ```","solution":"from typing import List, Dict, Union from datetime import datetime def find_overdue_books(users: List[Dict[str, Union[str, List[str]]]], current_date: str) -> List[str]: overdue_users = [] # Convert current_date to datetime object for comparison current_date_dt = datetime.strptime(current_date, \'%Y-%m-%d\') for user in users: for book in user[\'borrowed_books\']: book_title, due_date_str = book.split(\':\') due_date_dt = datetime.strptime(due_date_str, \'%Y-%m-%d\') if due_date_dt < current_date_dt: overdue_users.append(user[\'name\']) # Once we know a user has an overdue book, no need to check the rest of their books break return sorted(overdue_users)"},{"question":"# Problem Statement You are given two strings `s1` and `s2`. Your task is to determine the minimum number of operations required to convert `s1` into `s2`. The allowable operations are as follows: 1. Insert a character 2. Delete a character 3. Replace a character Write a function `min_operations(s1: str, s2: str) -> int` that computes this minimum number of operations, also known as the edit distance or Levenshtein distance. # Function Signature ```python def min_operations(s1: str, s2: str) -> int: ``` # Input * `s1` (str): A string containing up to 1000 characters. * `s2` (str): A string containing up to 1000 characters. # Output * Returns an integer representing the minimum number of operations required to convert `s1` into `s2`. # Constraints * Both strings contain only lowercase English letters. * Length of `s1` and `s2` are both between 0 and 1000. # Example ```python print(min_operations(\\"kitten\\", \\"sitting\\")) # Output: 3 print(min_operations(\\"flaw\\", \\"lawn\\")) # Output: 2 ``` # Notes 1. Consider using dynamic programming to achieve an optimal solution. 2. Ensure you account for all possible operations (insert, delete, replace) at each step. 3. Pay attention to efficient memory usage, especially when dealing with large input strings. # Hint You may create a 2D array to store the results of subproblems and iteratively compute the edit distance from the base cases up to the final solution.","solution":"def min_operations(s1: str, s2: str) -> int: Returns the minimum number of operations required to convert s1 into s2. # Initialize the lengths of the strings m, n = len(s1), len(s2) # Create a table to store results of subproblems dp = [[0] * (n + 1) for _ in range(m + 1)] # Fill dp array for i in range(m + 1): for j in range(n + 1): # If s1 is empty, insert all characters of s2 if i == 0: dp[i][j] = j # If s2 is empty, remove all characters of s1 elif j == 0: dp[i][j] = i # If last characters are the same, ignore them and recur for the remaining substrings elif s1[i-1] == s2[j-1]: dp[i][j] = dp[i-1][j-1] # If last characters are different, consider all possibilities and find the minimum else: dp[i][j] = 1 + min(dp[i-1][j], # Remove dp[i][j-1], # Insert dp[i-1][j-1]) # Replace return dp[m][n]"},{"question":"# Question Context In algorithm design, certain problems require counting specific elements or occurrences in a data structure. Efficiently tracking and providing frequency information can optimize further processing and querying operations. Task Write a class `WordFrequency` that stores words and allows querying the frequency of any stored word. Class Signature ```python class WordFrequency: def __init__(self): # Initializes the data structure. def add_word(self, word: str) -> None: # Adds a word to the data structure. def get_frequency(self, word: str) -> int: # Returns the frequency of the given word. ``` Methods 1. `__init__`: Initializes the data structure. 2. `add_word`: Takes a single string `word` argument and adds it to the internal data structure. 3. `get_frequency`: Takes a single string `word` argument and returns the frequency of that word in the data structure. Example ```python wf = WordFrequency() wf.add_word(\\"hello\\") wf.add_word(\\"world\\") wf.add_word(\\"hello\\") assert wf.get_frequency(\\"hello\\") == 2 assert wf.get_frequency(\\"world\\") == 1 assert wf.get_frequency(\\"python\\") == 0 ``` Explanation * The `WordFrequency` class is initialized with an empty data structure. * When `add_word` is called, it increases the count of the given word in the internal data structure. * When `get_frequency` is called, it returns how many times the given word has been added. * If a word has not been added before, `get_frequency` should return `0`.","solution":"from collections import defaultdict class WordFrequency: def __init__(self): # Initializes the data structure with a defaultdict self.word_count = defaultdict(int) def add_word(self, word: str) -> None: # Adds a word to the data structure by incrementing its count self.word_count[word] += 1 def get_frequency(self, word: str) -> int: # Returns the frequency of the given word return self.word_count[word]"},{"question":"```markdown # [Question 2]: Class Hierarchy & Inheritance in Python Your task is to design a class hierarchy for representing various shapes and to implement methods for computing their areas and perimeters. Additionally, you need to write a test suite using `unittest` to ensure the correctness of your implementation. Task Requirements: 1. **Class Implementation** - Implement the following classes: * `Shape`: An abstract base class with methods `area()` and `perimeter()` that need to be overridden in derived classes. ```python from abc import ABC, abstractmethod class Shape(ABC): @abstractmethod def area(self): pass @abstractmethod def perimeter(self): pass ``` * `Circle`: A derived class that initializes with a radius and provides implementations for `area()` and `perimeter()`. * `Rectangle`: A derived class that initializes with a length and width, and provides implementations for `area()` and `perimeter()`. * `Square`: A derived class that inherits from `Rectangle` and initializes with a side length. 2. **Input/Output**: - Your classes should handle the following inputs and outputs: * `Circle(radius: float)` * `area() -> float` * `perimeter() -> float` * `Rectangle(length: float, width: float)` * `area() -> float` * `perimeter() -> float` * `Square(side_length: float)` * `area() -> float` * `perimeter() -> float` 3. **Testing**: - Write a test suite using `unittest` to verify the correctness of the areas and perimeters calculations for each class. - Example test cases: ```python import unittest class TestShapes(unittest.TestCase): def test_circle(self): circle = Circle(5) self.assertAlmostEqual(circle.area(), 78.53981633974483, places=5) self.assertAlmostEqual(circle.perimeter(), 31.41592653589793, places=5) def test_rectangle(self): rectangle = Rectangle(3, 4) self.assertEqual(rectangle.area(), 12) self.assertEqual(rectangle.perimeter(), 14) def test_square(self): square = Square(2) self.assertEqual(square.area(), 4) self.assertEqual(square.perimeter(), 8) if __name__ == \'__main__\': unittest.main() ``` 4. **Constraints**: - Ensure that your classes handle typical edge cases gracefully (e.g., zero or negative dimensions). - Use appropriate mathematical constants and functions from the `math` module where necessary. - Follow principles of object-oriented design to maintain code clarity and reusability. 5. **Performance**: - Your implementations should be efficient, avoiding unnecessary computations or memory usage. ```","solution":"from abc import ABC, abstractmethod import math class Shape(ABC): @abstractmethod def area(self): pass @abstractmethod def perimeter(self): pass class Circle(Shape): def __init__(self, radius: float): self.radius = radius def area(self): return math.pi * self.radius ** 2 def perimeter(self): return 2 * math.pi * self.radius class Rectangle(Shape): def __init__(self, length: float, width: float): self.length = length self.width = width def area(self): return self.length * self.width def perimeter(self): return 2 * (self.length + self.width) class Square(Rectangle): def __init__(self, side_length: float): super().__init__(side_length, side_length)"},{"question":"# Problem Statement Write a function that simulates a very basic file system. This file system supports creating and deleting files, as well as reading and writing to these files. Each file is represented as a dictionary entry where the key is the filename and the value is its content. # Requirements 1. Implement file creation, deletion, reading, and writing operations. 2. Ensure to handle cases where operations may fail due to incorrect filenames or unsupported operations. # Input * A list of commands, where each command is represented as a tuple. The first element of the tuple is the command (`\\"CREATE\\"`, `\\"DELETE\\"`, `\\"READ\\"`, `\\"WRITE\\"`), followed by necessary arguments for that command. - `\\"CREATE\\"`: `(\\"CREATE\\", filename)` - `\\"DELETE\\"`: `(\\"DELETE\\", filename)` - `\\"READ\\"`: `(\\"READ\\", filename)` - `\\"WRITE\\"`: `(\\"WRITE\\", filename, content)` # Output * A list of results from the commands. For each command, return: - `\\"CREATE\\"`: `True` if the file is successfully created, otherwise `False`. - `\\"DELETE\\"`: `True` if the file is successfully deleted, otherwise `False`. - `\\"READ\\"`: The content of the file if it exists, otherwise `None`. - `\\"WRITE\\"`: `True` if the content is successfully written, otherwise `False`. # Constraints 1. Filenames are unique and consist of alphanumeric characters without spaces. 2. The content of a file can be any string. 3. There can be at most 1000 commands. 4. Filenames and content strings are at most 100 characters long. # Example **Input**: ```python [ (\\"CREATE\\", \\"file1\\"), (\\"WRITE\\", \\"file1\\", \\"Hello World\\"), (\\"READ\\", \\"file1\\"), (\\"DELETE\\", \\"file1\\"), (\\"READ\\", \\"file1\\") ] ``` **Output**: ```python [True, True, \\"Hello World\\", True, None] ``` # Function Signature ```python def file_system(commands: list) -> list: pass ``` # Note 1. Your solution should be efficient and capable of executing the operations in a reasonable time even at the upper limit of constraints. 2. Consider edge cases such as operations on non-existent files and duplicate file creation attempts. 3. Ensure that your code is well-documented and easy to understand.","solution":"def file_system(commands: list) -> list: files = {} result = [] for command in commands: if command[0] == \\"CREATE\\": filename = command[1] if filename not in files: files[filename] = \\"\\" result.append(True) else: result.append(False) elif command[0] == \\"DELETE\\": filename = command[1] if filename in files: del files[filename] result.append(True) else: result.append(False) elif command[0] == \\"READ\\": filename = command[1] if filename in files: result.append(files[filename]) else: result.append(None) elif command[0] == \\"WRITE\\": filename = command[1] content = command[2] if filename in files: files[filename] = content result.append(True) else: result.append(False) return result"},{"question":"String Compression String compression is an important technique in data storage and transmission. Your task is to implement a function that compresses an input string by replacing consecutive repeating characters with the character followed by the count of repetitions. If the compressed string is not shorter than the original string, return the original string. Function Signature ```python def compress_string(s: str) -> str: pass ``` Input - `s` (str): A non-empty string consisting of uppercase and lowercase English letters. Output - Returns a compressed string if it is shorter than the original string, otherwise returns the original string. Constraints - The length of the string will not exceed 1000 characters. - The compression is case-sensitive, so \'a\' and \'A\' are considered different characters. # Examples ```python compress_string(\\"aabcccccaaa\\") # Returns \\"a2b1c5a3\\" compress_string(\\"abc\\") # Returns \\"abc\\" compress_string(\\"AAAABBBCCDAA\\") # Returns \\"A4B3C2D1A2\\" ``` # Requirements - Develop the `compress_string` function to implement the described compression mechanism. - Ensure the function handles edge cases, such as varying character cases, and properly evaluates whether to return the compressed string or the original string based on their lengths. - Validate your solution through provided examples or additional test cases ensuring the correct and optimized functionality of the compression. # Scenario As data storage grows and network transmissions require more efficiency, string compression plays a crucial role in optimizing space and bandwidth. By accurately compressing strings, significant improvements can be made in data handling processes. Implement an efficient solution to this problem and ensure it performs well within the given constraints while maintaining the integrity of the input data.","solution":"def compress_string(s: str) -> str: Compresses the string by replacing consecutive repeating characters with the character followed by the count of repetitions. If the compressed string is not shorter than the original string, returns the original string. compressed_parts = [] count = 1 for i in range(1, len(s)): if s[i] == s[i - 1]: count += 1 else: compressed_parts.append(s[i - 1] + str(count)) count = 1 # Append the last character and its count compressed_parts.append(s[-1] + str(count)) compressed_string = \'\'.join(compressed_parts) return compressed_string if len(compressed_string) < len(s) else s"},{"question":"Implement a Python function `next_happy_number` that takes an integer `n` as an argument. The function should return the smallest happy number that is greater than `n`. # Requirements: 1. A happy number is defined as a number which eventually reaches 1 when replaced by the sum of the square of each digit. 2. The function should handle edge cases such as very large input values and non-happy numbers being initially provided as input. 3. The returned result should be an integer representing the next happy number greater than `n`. # Input: - `n` (n >= 0): Integer for which the next greater happy number is to be found. # Output: - An integer representing the next happy number greater than `n`. # Function Signature ```python def next_happy_number(n: int) -> int: pass ``` # Example ```python # Example usage: # Find the smallest happy number greater than 7: print(next_happy_number(7)) # Output: 10 # Find the smallest happy number greater than 10: print(next_happy_number(10)) # Output: 13 # Find the smallest happy number greater than 20: print(next_happy_number(20)) # Output: 23 ``` # Constraints: - The input `n` must be a non-negative integer. - The function should be optimized to handle reasonably large input values. # Notes: - You may create helper functions (`is_happy_number`, `sum_of_squares_of_digits`) to assist with your implementation. - Ensure appropriate error handling for edge cases. - Make sure the function is efficient enough to handle large integers effectively.","solution":"def sum_of_squares_of_digits(num): Returns the sum of the squares of the digits of the given number. return sum(int(digit) ** 2 for digit in str(num)) def is_happy_number(num): Determines if a number is a happy number. seen = set() while num != 1 and num not in seen: seen.add(num) num = sum_of_squares_of_digits(num) return num == 1 def next_happy_number(n): Returns the smallest happy number greater than n. num = n + 1 while not is_happy_number(num): num += 1 return num"},{"question":"# Problem Statement: You are tasked with implementing a custom logging functionality for a software application. The custom logger should support logging messages at different levels (INFO, WARN, ERROR) and store them in a dictionary where the keys are the logging levels and the values are lists of messages log at those levels. Additionally, your logger should support retrieving all the messages for a specific level in order of their logging. # Your Task: Implement the class `CustomLogger` to handle adding and retrieving log messages. # Class Signature: ```python class CustomLogger: def __init__(self): Initializes an empty logger with three levels: INFO, WARN, and ERROR. pass def log(self, level: str, message: str) -> None: Logs a message at the specified level. Parameters: ----------- level: (str) the level at which to log the message, must be one of: \'INFO\', \'WARN\', \'ERROR\' message: (str) the message to log Raises: ------- ValueError: If the level is not one of \'INFO\', \'WARN\', \'ERROR\' pass def get_messages(self, level: str) -> list: Retrieves all messages logged at the specified level. Parameters: ----------- level: (str) the level for which to retrieve messages, must be one of: \'INFO\', \'WARN\', \'ERROR\' Returns: -------- list: a list of all messages logged at the specified level in order. Raises: ------- ValueError: If the level is not one of \'INFO\', \'WARN\', \'ERROR\' pass ``` # Input: - String `level`: logging level (\'INFO\', \'WARN\', \'ERROR\') - String `message`: the message to be logged # Output: - List of messages for the given level when using `get_messages` # Constraints: - The `level` must be one of \'INFO\', \'WARN\', \'ERROR\'. Raise a `ValueError` if an invalid level is provided. - Messages must be logged and retrieved in the order they were added. # Examples: ```python logger = CustomLogger() logger.log(\\"INFO\\", \\"This is an info message.\\") logger.log(\\"WARN\\", \\"This is a warning message.\\") logger.log(\\"ERROR\\", \\"This is an error message.\\") logger.log(\\"INFO\\", \\"Another info message.\\") assert logger.get_messages(\\"INFO\\") == [\\"This is an info message.\\", \\"Another info message.\\"] assert logger.get_messages(\\"WARN\\") == [\\"This is a warning message.\\"] assert logger.get_messages(\\"ERROR\\") == [\\"This is an error message.\\"] ``` # Notes: - Handle invalid logging levels appropriately by raising exceptions. - Ensure messages are logged in the order they are added and retrieved in the same order.","solution":"class CustomLogger: def __init__(self): self.logs = { \\"INFO\\": [], \\"WARN\\": [], \\"ERROR\\": [] } def log(self, level: str, message: str) -> None: if level not in self.logs: raise ValueError(f\\"Invalid logging level: {level}\\") self.logs[level].append(message) def get_messages(self, level: str) -> list: if level not in self.logs: raise ValueError(f\\"Invalid logging level: {level}\\") return self.logs[level]"},{"question":"Python List Operations You are given several operations to perform on a Python list. The goal is to practice and understand various list manipulation techniques to achieve the desired output. You will need to define three functions: `initialize_list`, `add_elements`, and `remove_elements`. Function Definitions: 1. **initialize_list(length: int, value: int) -> list** This function initializes a list with a specified length, where each element is set to a given value. - **Input**: `length` (int) – The number of elements in the list, and `value` (int) – The value to assign to each element. - **Output**: A list with the specified length and values. 2. **add_elements(lst: list, elements: list) -> list** This function adds a list of elements to the end of an existing list. - **Input**: `lst` (list) – The original list and `elements` (list) – The elements to be added. - **Output**: The modified list with the new elements appended to the end. 3. **remove_elements(lst: list, value: int) -> list** This function removes all instances of a specified value from the list. - **Input**: `lst` (list) – The list from which to remove elements and `value` (int) – The value to be removed. - **Output**: The list with the specified value removed. Constraints: - `length` should be non-negative. - The elements to add will always be a list of integers. - If the `value` to remove is not present in the list, return the list as is. Example Usage: ```python # Example for initialize_list list1 = initialize_list(5, 3) print(list1) # Output: [3, 3, 3, 3, 3] # Example for add_elements list2 = add_elements(list1, [1, 2]) print(list2) # Output: [3, 3, 3, 3, 3, 1, 2] # Example for remove_elements list3 = remove_elements(list2, 3) print(list3) # Output: [1, 2] ``` Context: You are developing a library for manipulating lists in Python. These functions will serve as basic utilities for more complex list operations that users may need.","solution":"def initialize_list(length: int, value: int) -> list: Initializes a list with a specified length, where each element is set to a given value. return [value] * length def add_elements(lst: list, elements: list) -> list: Adds a list of elements to the end of an existing list. return lst + elements def remove_elements(lst: list, value: int) -> list: Removes all instances of a specified value from the list. return [el for el in lst if el != value]"},{"question":"# Scenario You\'re tasked with developing a feature for a financial application that processes transaction records. Each transaction has a category associated with it. Your feature will summarize the total amounts spent in each category. # Task Implement a function `summarize_transactions` that summarizes the total amount of money spent per category given a list of transactions. # Function Signature ```python def summarize_transactions(transactions: List[Dict[str, Union[str, float]]]) -> Dict[str, float]: ``` # Input * `transactions`: A list of dictionaries where each dictionary represents a transaction and contains: * `category`: A string representing the transaction category. * `amount`: A float representing the amount of money spent in that transaction. # Output * Returns a dictionary where keys are unique transaction categories and values are the total amounts spent in each category. # Constraints * The function should handle input lists of size up to (10^5) efficiently. * Categories should be case-insensitive, meaning \'Food\' and \'food\' should be considered the same category. # Example ```python >>> transactions = [ {\\"category\\": \\"Food\\", \\"amount\\": 15.0}, {\\"category\\": \\"food\\", \\"amount\\": 10.0}, {\\"category\\": \\"Entertainment\\", \\"amount\\": 20.0}, {\\"category\\": \\"Food\\", \\"amount\\": 30.0}, {\\"category\\": \\"Utilities\\", \\"amount\\": 100.0} ] >>> summarize_transactions(transactions) {\'food\': 55.0, \'entertainment\': 20.0, \'utilities\': 100.0} ``` # Performance Requirements * The solution should run within reasonable time limits for the input size constraint. # Edge Cases * Ensure your function handles empty lists and categories with zero amounts without errors.","solution":"from typing import List, Dict, Union from collections import defaultdict def summarize_transactions(transactions: List[Dict[str, Union[str, float]]]) -> Dict[str, float]: summary = defaultdict(float) for transaction in transactions: category = transaction[\\"category\\"].strip().lower() amount = transaction[\\"amount\\"] summary[category] += amount return dict(summary)"},{"question":"# Longest Common Subsequence (LCS) Problem You are required to implement a function that finds the length of the longest common subsequence (LCS) between two given strings. Function Signature ```python def longest_common_subsequence(s1: str, s2: str) -> int: pass ``` Input: - `s1` (str): The first string, consisting of lowercase English letters. - `s2` (str): The second string, consisting of lowercase English letters. Output: - Returns an integer, the length of the longest common subsequence between `s1` and `s2`. Constraints: - ( 1 leq text{len}(s1) leq 1000 ) - ( 1 leq text{len}(s2) leq 1000 ) Requirements: - The function should be efficient with a time complexity of ( O(n times m) ) where `n` and `m` are the lengths of `s1` and `s2`, respectively. - Space complexity should be considered to handle larger input sizes effectively. Example: ```python s1 = \\"abcde\\" s2 = \\"ace\\" result = longest_common_subsequence(s1, s2) print(result) # Expected output: 3 (The longest common subsequence is \\"ace\\") ``` Scenario: Consider you are working on a text comparison tool, and you need to find similarities between two pieces of text. To quantify these similarities, you decide to calculate the length of the longest common subsequence between the two texts. For example, for the strings `s1 = \\"abcde\\"` and `s2 = \\"ace\\"`, the longest common subsequence is \\"ace\\", and its length is 3. Use your implemented function to determine the LCS length and verify the correctness with given test cases.","solution":"def longest_common_subsequence(s1: str, s2: str) -> int: Returns the length of the longest common subsequence between s1 and s2. # Get the lengths of the two input strings n = len(s1) m = len(s2) # Create a 2D array to store the lengths of LCS dp = [[0] * (m + 1) for _ in range(n + 1)] # Fill the dp array for i in range(1, n + 1): for j in range(1, m + 1): if s1[i - 1] == s2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) # The length of the longest common subsequence is in the bottom-right cell return dp[n][m]"},{"question":"# Context: You are developing a feature for a finance app that calculates the maximum profit from stock prices over a given range of days. The app needs to determine the best day to buy and the best day to sell to achieve maximum profit. # Problem Statement: Write a function `max_profit` that computes the maximum profit achievable from an array of stock prices, where you are allowed to buy and sell the stock only once. # Function Signature: ```python def max_profit(prices: list[int]) -> int: # Your implementation here ``` # Input: - A list of integers `prices` of length N (0 <= N <= 10^5) representing the stock prices on different days. # Output: - An integer representing the maximum profit. If no profit is possible, return 0. # Constraints: 1. The prices list may contain zero or more elements. 2. The function should handle very large inputs efficiently. # Examples: ```python assert max_profit([7, 1, 5, 3, 6, 4]) == 5 # Buy on day 2, sell on day 5: profit = 6-1 = 5 assert max_profit([7, 6, 4, 3, 1]) == 0 # No transaction is made, profit = 0 assert max_profit([1, 2, 3, 4, 5]) == 4 # Buy on day 1, sell on day 5: profit = 5-1 = 4 assert max_profit([7, 1, 5, 3, 6, 4, 10]) == 9 # Buy on day 2, sell on day 7: profit = 10-1 = 9 assert max_profit([]) == 0 ``` # Guidelines: - Implement an inline algorithm to ensure O(N) time complexity, where N is the length of the prices list. - Pay attention to edge cases such as an empty list or a list in strictly decreasing order. - Document your code with comments explaining the core logic and any assumptions made.","solution":"def max_profit(prices: list[int]) -> int: # If the list is empty or has only one element, no profit can be achieved if not prices or len(prices) < 2: return 0 # Initialize the minimum price to the first element and max profit to 0 min_price = prices[0] max_profit = 0 # Iterate through prices starting from the second element for price in prices[1:]: # Update the minimum price if a lower price is found if price < min_price: min_price = price # Calculate the potential profit by selling at the current price potential_profit = price - min_price # Update max profit if the current potential profit is greater if potential_profit > max_profit: max_profit = potential_profit return max_profit"},{"question":"# Problem Statement You are given a `List[int]` called `nums`, where the list is sorted in ascending order and then rotated at some pivot unknown to you beforehand (e.g., `[0, 1, 2, 4, 5, 6, 7]` might be rotated to `[4, 5, 6, 7, 0, 1, 2]`). You are also given an integer `target`. Write a function `search_rotated_sorted_array` to search in `nums`. If `target` is found, return its index; otherwise, return `-1`. You must write an algorithm with `O(log n)` runtime complexity. # Function Signature ```python def search_rotated_sorted_array(nums: List[int], target: int) -> int: ``` # Input - `nums`: List of integers (0 <= len(nums) <= 5000), sorted in ascending order and then possibly rotated. - `target`: An integer value to search for in the list. # Output - An integer representing the index if `target` is found, otherwise `-1`. # Example ```python nums = [4, 5, 6, 7, 0, 1, 2] target = 0 print(search_rotated_sorted_array(nums, target)) # Output should be 4 nums = [4, 5, 6, 7, 0, 1, 2] target = 3 print(search_rotated_sorted_array(nums, target)) # Output should be -1 nums = [1] target = 0 print(search_rotated_sorted_array(nums, target)) # Output should be -1 ``` # Notes The problem requires an efficient search strategy leveraging the rotated and sorted property of the list to achieve `O(log n)` runtime. Consider edge cases such as an empty list or the list having only one element. # Additional Context This problem tests your understanding of binary search, array manipulation, and handling special conditions due to the rotation of the array. The ability to write an efficient algorithm that reduces the time complexity is critical in solving this problem correctly.","solution":"from typing import List def search_rotated_sorted_array(nums: List[int], target: int) -> int: if not nums: return -1 left, right = 0, len(nums) - 1 while left <= right: mid = (left + right) // 2 if nums[mid] == target: return mid if nums[left] <= nums[mid]: # left to mid is sorted if nums[left] <= target < nums[mid]: right = mid - 1 else: left = mid + 1 else: # mid to right is sorted if nums[mid] < target <= nums[right]: left = mid + 1 else: right = mid - 1 return -1"},{"question":"# Task Scheduler for Dependent Jobs You are assigned to create a task scheduler that arranges the execution order of jobs based on their dependencies. Each job is dependent on other jobs and cannot start until all its dependencies have completed. The algorithm should determine a valid sequence in which to execute all jobs or identify that a valid sequence is not possible due to circular dependencies. Function Signature: ```python def schedule_jobs(jobs: dict) -> list: \'\'\' :param jobs: A dictionary where keys are job identifiers (integers) and values are lists of integers representing the job dependencies. :return: A list of integers representing the order in which the jobs can be executed. If it is not possible to determine such an order, return an empty list. \'\'\' ``` Input: * `jobs`: A dictionary where keys (`jobs.keys()`) are job identifiers and values (`jobs.values()`) are lists of job identifiers that must precede the key job. It is guaranteed that all job identifiers are unique. Output: * A list of integers representing a valid order to execute the jobs. If no such order is possible (i.e., there is a cycle in the dependencies), return an empty list. Constraints: * There are at most 1000 jobs in the dictionary. Example: ```python # Example 1: # Input: jobs = { 1: [2, 3], 2: [], 3: [2] } # Output: # [2, 3, 1] or [2, 1, 3] # Example 2: # Input: jobs = { 1: [2], 2: [3], 3: [4], 4: [] } # Output: # [4, 3, 2, 1] # Example 3: # Input: jobs = { 1: [2], 2: [1] } # Output: # [] ``` Implementation Notes: 1. Validate the input parameters to ensure they meet constraints. 2. Implement a topological sort to determine a valid execution order for the jobs, if possible. 3. Check for cycles in the dependency graph, which would make a valid execution order impossible. 4. Return a list with the sequence of job identifiers in the order they can be executed, or an empty list if no valid order exists. Implement the `schedule_jobs` function according to the above requirements.","solution":"def schedule_jobs(jobs): from collections import defaultdict, deque # Build the graph and compute in-degrees of each node graph = defaultdict(list) in_degree = {job: 0 for job in jobs} for job, dependencies in jobs.items(): for dependency in dependencies: graph[dependency].append(job) in_degree[job] += 1 # Initialize the queue with all jobs that have no dependencies queue = deque([job for job in jobs if in_degree[job] == 0]) sorted_order = [] while queue: current = queue.popleft() sorted_order.append(current) # Decrease the in-degree of each neighbour for neighbor in graph[current]: in_degree[neighbor] -= 1 # If in-degree becomes zero, add it to the queue if in_degree[neighbor] == 0: queue.append(neighbor) # If sorted_order contains all jobs, return it; otherwise, return an empty list if len(sorted_order) == len(jobs): return sorted_order else: return []"},{"question":"# Question: Implement a Custom Sorting Algorithm You are working on a project that involves sorting large datasets efficiently. To achieve this, you need to implement a custom sorting algorithm using the QuickSort technique. Ensure your implementation is optimized to handle diverse and large inputs accurately. Task Implement the function `quick_sort(arr: List[int]) -> List[int]` that takes a list of integers and returns a new list with all the elements sorted in ascending order using the QuickSort algorithm. Function Signature ```python from typing import List def quick_sort(arr: List[int]) -> List[int]: pass ``` Input * `arr`: a list of integers that need to be sorted. - Constraints: (1 leq len(arr) leq 10^5) - Each integer in the list can range from (-10^9) to (10^9) Output * Returns a new sorted list of integers in ascending order. Constraints 1. Your solution should perform well for large lists, focusing on efficiency. 2. Consider edge cases such as lists with duplicate elements, already sorted lists, and lists sorted in reverse order. Example ```python print(quick_sort([3, 6, 8, 10, 1, 2, 1])) # Expected output: [1, 1, 2, 3, 6, 8, 10] print(quick_sort([1])) # Expected output: [1] print(quick_sort([-5, -1, 0, -3, 2, 4, 1])) # Expected output: [-5, -3, -1, 0, 1, 2, 4] ``` Additional Requirements 1. **Performance**: Ensure the function runs efficiently for large lists up to (10^5) elements. 2. **Correctness**: Consider edge cases and ensure the function outputs correct results for a variety of input lists. 3. **In-place Sorting**: Although returning a new sorted list is required, minimize the usage of extra space by performing in-place partitioning wherever possible.","solution":"from typing import List def quick_sort(arr: List[int]) -> List[int]: Sorts the array using the QuickSort algorithm and returns a new sorted array. if len(arr) <= 1: return arr else: pivot = arr[len(arr) // 2] left = [x for x in arr if x < pivot] middle = [x for x in arr if x == pivot] right = [x for x in arr if x > pivot] return quick_sort(left) + middle + quick_sort(right)"},{"question":"# Coding Question: Implement a Merge Sort Algorithm for Linked List Context Merge Sort is an efficient, stable, and comparison-based sorting algorithm. It works by dividing the unsorted list into smaller sublists and then merges them back in a sorted manner. Sorting a linked list using Merge Sort involves different handling as compared to arrays due to the list\'s node-based structure. Task **Implement a function that performs a Merge Sort on a singly linked list. Your function should accept the head of the list and return the head of the sorted list.** Input * `head` (ListNode): A singly linked list where each node contains an integer value. Output * ListNode: The head of the singly linked list sorted in non-decreasing order. Requirements * The implementation should be efficient in terms of both time and space complexity. * Handle edge cases such as an empty list or a list with a single node. Constraints * The number of nodes in the linked list can be up to 10^5. * The value of each node is an integer in the range `[-10^5, 10^5]`. # Example ```python >>> class ListNode: ... def __init__(self, x): ... self.val = x ... self.next = None >>> def print_list(head): ... while head: ... print(head.val, end=\' \') ... head = head.next ... print() >>> # Helper function to create and link list nodes easily for testing >>> def linked_list_from_array(arr): ... head = ListNode(arr[0]) ... current = head ... for value in arr[1:]: ... current.next = ListNode(value) ... current = current.next ... return head >>> # Test Cases >>> head = linked_list_from_array([4, 2, 1, 3]) >>> sorted_head = merge_sort(head) >>> print_list(sorted_head) 1 2 3 4 >>> head = linked_list_from_array([10, 7, 5, 2]) >>> sorted_head = merge_sort(head) >>> print_list(sorted_head) 2 5 7 10 ``` # Implementation Notes 1. You might need helper functions to split the list, merge sorted sublists, and find the middle of the linked list. 2. Ensure that your function manages memory efficiently, especially for larger lists. 3. Avoid unnecessary operations to maintain optimal performance. ```python class ListNode: def __init__(self, x): self.val = x self.next = None def split_list(head): Split the linked list into two halves. fast = head slow = head prev = None while fast and fast.next: prev = slow slow = slow.next fast = fast.next.next mid = slow if prev: prev.next = None return head, mid def merge_lists(left, right): Merge two sorted linked lists. dummy = ListNode(0) tail = dummy while left and right: if left.val < right.val: tail.next = left left = left.next else: tail.next = right right = right.next tail = tail.next tail.next = left or right return dummy.next def merge_sort(head): Apply Merge Sort on the linked list. if not head or not head.next: return head left, right = split_list(head) sorted_left = merge_sort(left) sorted_right = merge_sort(right) return merge_lists(sorted_left, sorted_right) # Test cases if __name__ == \\"__main__\\": import doctest doctest.testmod() ```","solution":"class ListNode: def __init__(self, x): self.val = x self.next = None def split_list(head): Split the linked list into two halves. fast = head slow = head prev = None while fast and fast.next: prev = slow slow = slow.next fast = fast.next.next if prev: prev.next = None # Split the list into two halves return head, slow def merge_lists(left, right): Merge two sorted linked lists. dummy = ListNode(0) tail = dummy while left and right: if left.val < right.val: tail.next = left left = left.next else: tail.next = right right = right.next tail = tail.next tail.next = left or right return dummy.next def merge_sort(head): Apply Merge Sort on the linked list. if not head or not head.next: return head left, right = split_list(head) sorted_left = merge_sort(left) sorted_right = merge_sort(right) return merge_lists(sorted_left, sorted_right)"},{"question":"Problem Statement You need to create a helper function to calculate the edit distance (also known as Levenshtein distance) between two strings. The edit distance is a measure of similarity between two strings, defined as the minimum number of single-character edits (insertions, deletions, or substitutions) required to transform one string into the other. # Function Signature ```python def edit_distance(s1: str, s2: str) -> int: pass ``` # Input * `s1` (str): A string of length up to 1000 characters. * `s2` (str): A string of length up to 1000 characters. # Output * (int): The edit distance between the two input strings. # Constraints * Both input strings will consist of lowercase alphabetic characters. * The function should handle the input sizes efficiently within the given constraints. # Performance Requirements * Time Complexity should be O(n * m), where n is the length of `s1` and m is the length of `s2`. * Space Complexity should be O(n * m). # Examples 1. `edit_distance(\'kitten\', \'sitting\')` * Output: `3` * Explanation: The edit distance is 3 (kitten -> sitten -> sittin -> sitting). 2. `edit_distance(\'flaw\', \'lawn\')` * Output: `2` * Explanation: The edit distance is 2 (flaw -> law -> lawn). 3. `edit_distance(\'algorithm\', \'altruistic\')` * Output: `6` * Explanation: Many possible sequences of edits could change \'algorithm\' to \'altruistic\', and 6 is the minimum number of edits. # Instructions * Implement the function `edit_distance` that meets the above requirements. * Write efficient and clean code. * Do not use any external libraries or functions not built into the language.","solution":"def edit_distance(s1: str, s2: str) -> int: Returns the edit distance between two strings. n = len(s1) m = len(s2) # If one of the strings is empty if n == 0: return m if m == 0: return n # Initialize the matrix dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)] # Initialize the first row and first column for i in range(n + 1): dp[i][0] = i for j in range(m + 1): dp[0][j] = j # Compute the edit distance for i in range(1, n + 1): for j in range(1, m + 1): if s1[i - 1] == s2[j - 1]: dp[i][j] = dp[i - 1][j - 1] else: dp[i][j] = 1 + min(dp[i - 1][j], # Deletion dp[i][j - 1], # Insertion dp[i - 1][j - 1]) # Substitution return dp[n][m]"},{"question":"# Problem Description Create a Tic-Tac-Toe game evaluator that will determine the result of a given Tic-Tac-Toe board configuration. # Objective **Implement the function** `evaluate_tic_tac_toe` **that meets the following requirements**: - The function should determine if the given Tic-Tac-Toe board has a winner (\'X\' or \'O\'), or if the game is a draw, or if it is still in progress. - The board is provided as a 3x3 matrix. # Function Signature ```python def evaluate_tic_tac_toe(board: List[List[str]]) -> str: pass ``` # Input - `board` (List[List[str]]): A 3x3 matrix representing the Tic-Tac-Toe board. Each cell contains one of three characters: \'X\', \'O\', or \'\' (empty string). # Output - The function should return \'X\' if player X has won, \'O\' if player O has won, \'Draw\' if the game is a draw, or \'In progress\' if the game is still ongoing. # Constraints - The board will always be a 3x3 matrix. - Each cell will be either \'X\', \'O\', or an empty string (\'\'). # Examples ```python board1 = [ [\'X\', \'O\', \'X\'], [\'O\', \'X\', \'O\'], [\'O\', \'X\', \'\'] ] board2 = [ [\'X\', \'X\', \'X\'], [\'O\', \'O\', \'\'], [\'\', \'\', \'O\'] ] board3 = [ [\'O\', \'X\', \'X\'], [\'X\', \'O\', \'O\'], [\'X\', \'O\', \'X\'] ] print(evaluate_tic_tac_toe(board1)) # Expected Output: \'In progress\' print(evaluate_tic_tac_toe(board2)) # Expected Output: \'X\' print(evaluate_tic_tac_toe(board3)) # Expected Output: \'Draw\' ``` # Hints - Consider checking for all possible winning combinations: rows, columns, and both diagonals. - Determine if all spots are filled to check for a \'Draw\'. - If there are still empty spots and no winner, the game is \'In progress\'. --- This question maintains consistency with the existing set by focusing on developing an algorithm within a defined scope and moderate complexity. It requires checking different winning conditions and evaluating the game state, making it a suitable challenge in line with the original question set.","solution":"from typing import List def evaluate_tic_tac_toe(board: List[List[str]]) -> str: def check_winner(player): # Check rows and columns for i in range(3): if all([cell == player for cell in board[i]]) or all([board[j][i] == player for j in range(3)]): return True # Check diagonals if all([board[i][i] == player for i in range(3)]) or all([board[i][2-i] == player for i in range(3)]): return True return False if check_winner(\'X\'): return \'X\' if check_winner(\'O\'): return \'O\' # Check for draw or in progress if all([cell != \'\' for row in board for cell in row]): return \'Draw\' return \'In progress\'"},{"question":"# Coding Assessment Question **Scenario**: You are developing a travel application that calculates the shortest path between cities using a graph data structure. To achieve this, you need to implement Dijkstra\'s algorithm efficiently. The application must handle dynamically added cities and routes, so the underlying graph structure must be both flexible and performant. **Task**: Implement the `Graph` class with the following methods: 1. **add_city**: ```python def add_city(self, city: str) -> None: ``` - **Input**: - `city` (str): The name of the city to be added to the graph. - **Output**: None 2. **add_route**: ```python def add_route(self, city1: str, city2: str, distance: int) -> None: ``` - **Input**: - `city1` (str): The name of the first city. - `city2` (str): The name of the second city. - `distance` (int): The distance between the two cities. - **Output**: None 3. **find_shortest_path**: ```python def find_shortest_path(self, start_city: str, end_city: str) -> int: ``` - **Input**: - `start_city` (str): The name of the starting city. - `end_city` (str): The name of the ending city. - **Output**: The shortest distance between `start_city` and `end_city`. If no path exists, return `-1`. **Constraints**: - There can be at most `1000` cities. - Route distances will be positive integers not exceeding `10000`. **Example**: ```python graph = Graph() graph.add_city(\\"A\\") graph.add_city(\\"B\\") graph.add_city(\\"C\\") graph.add_city(\\"D\\") graph.add_route(\\"A\\", \\"B\\", 10) graph.add_route(\\"A\\", \\"C\\", 15) graph.add_route(\\"B\\", \\"D\\", 12) graph.add_route(\\"C\\", \\"D\\", 10) graph.add_route(\\"B\\", \\"C\\", 6) print(graph.find_shortest_path(\\"A\\", \\"D\\")) # Output: 22 print(graph.find_shortest_path(\\"A\\", \\"C\\")) # Output: 16 print(graph.find_shortest_path(\\"C\\", \\"B\\")) # Output: 6 print(graph.find_shortest_path(\\"D\\", \\"A\\")) # Output: -1 (assuming undirected graph) ```","solution":"import heapq from collections import defaultdict, deque class Graph: def __init__(self): self.graph = defaultdict(list) def add_city(self, city): # Adding a city implicitly by initializing its adjacency list if city not in self.graph: self.graph[city] = [] def add_route(self, city1, city2, distance): self.graph[city1].append((city2, distance)) self.graph[city2].append((city1, distance)) def find_shortest_path(self, start_city, end_city): if start_city not in self.graph or end_city not in self.graph: return -1 distances = {city: float(\'inf\') for city in self.graph} distances[start_city] = 0 priority_queue = [(0, start_city)] while priority_queue: current_distance, current_city = heapq.heappop(priority_queue) if current_city == end_city: return current_distance if current_distance > distances[current_city]: continue for neighbor, weight in self.graph[current_city]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return -1 if distances[end_city] == float(\'inf\') else distances[end_city]"},{"question":"# Coding Assessment Question Context You are working on a system that needs to maintain and manage a collection of user profiles. Each user profile contains a unique ID, their name, and their age. The system should be able to add new profiles, retrieve a profile by ID, and update the profile details based on the provided ID. Task Implement a class `UserProfileManager` that models this system. The class should provide methods for adding, retrieving, and updating user profiles. Implementation **Class `UserProfileManager` should implement:** 1. `add_user(user_id: int, name: str, age: int) -> None`: Adds a new user profile with the given `user_id`, `name`, and `age`. If `user_id` already exists, this method should do nothing. 2. `get_user(user_id: int) -> dict`: Retrieves the profile information as a dictionary `{\'user_id\': user_id, \'name\': name, \'age\': age}` for the user with the specified `user_id`. If `user_id` does not exist, return an empty dictionary. 3. `update_user(user_id: int, name: str, age: int) -> bool`: Updates the profile information for the user with the given `user_id`. Returns `True` if the update was successful, or `False` if `user_id` does not exist. Constraints - `1 <= user_id <= 10^6` - `1 <= len(name) <= 100` - `1 <= age <= 120` Input/Output Format - Input: User profile details as method arguments. - Output: Dictionary or Boolean value as described. Example ```python class UserProfileManager: def __init__(self): # Your implementation here def add_user(self, user_id: int, name: str, age: int) -> None: # Your implementation here def get_user(self, user_id: int) -> dict: # Your implementation here def update_user(self, user_id: int, name: str, age: int) -> bool: # Your implementation here # Example usage: manager = UserProfileManager() manager.add_user(1, \'Alice\', 30) print(manager.get_user(1)) # Output: {\'user_id\': 1, \'name\': \'Alice\', \'age\': 30} manager.update_user(1, \'Alice Smith\', 31) print(manager.get_user(1)) # Output: {\'user_id\': 1, \'name\': \'Alice Smith\', \'age\': 31} print(manager.get_user(2)) # Output: {} manager.add_user(2, \'Bob\', 25) print(manager.get_user(2)) # Output: {\'user_id\': 2, \'name\': \'Bob\', \'age\': 25} ``` The submitted code will be evaluated for correctness, efficiency, and adherence to problem constraints.","solution":"class UserProfileManager: def __init__(self): self.users = {} def add_user(self, user_id: int, name: str, age: int) -> None: if user_id not in self.users: self.users[user_id] = {\\"user_id\\": user_id, \\"name\\": name, \\"age\\": age} def get_user(self, user_id: int) -> dict: return self.users.get(user_id, {}) def update_user(self, user_id: int, name: str, age: int) -> bool: if user_id in self.users: self.users[user_id][\\"name\\"] = name self.users[user_id][\\"age\\"] = age return True return False"},{"question":"# Question: Implement Recursive Depth-First Search (DFS) for a Graph You are required to implement the Recursive Depth-First Search (DFS) algorithm to traverse a graph from a given starting vertex. The graph is represented as an adjacency list, and your implementation should return the order of vertices visited during the traversal. Requirements: 1. **Input**: * A dictionary representing the adjacency list of the graph, where each key is a vertex and its corresponding value is a list of adjacent vertices. * A starting vertex `start_vertex` value from which the traversal should begin. 2. **Output**: * A list of vertices in the order they are visited during the DFS traversal. 3. **Constraints**: * The graph can be either directed or undirected. * Vertices and edges are case-sensitive. * Handle cycles in the graph appropriately to avoid infinite loops. Example: ```python graph = { \'A\': [\'B\', \'C\'], \'B\': [\'D\', \'E\'], \'C\': [\'F\'], \'D\': [], \'E\': [\'F\'], \'F\': [] } start_vertex = \'A\' assert dfs_recursive(graph, start_vertex) == [\'A\', \'B\', \'D\', \'E\', \'F\', \'C\'] ``` Steps to Implement: 1. **Initialize Visited Set**: Use a set to keep track of visited vertices. 2. **DFS Helper Function**: Implement a recursive helper function that visits a vertex, marks it as visited, and recursively visits its unvisited neighbors. 3. **Call DFS**: Start the DFS traversal from the given `start_vertex`. 4. **Compile Result**: Collect vertices in the order they are visited and return the result. Tips: * Use a helper function with parameters for the current vertex and the visited set. * Ensure the order of visiting vertices follows the depth-first logic. * Test your function with different graph structures to cover various scenarios including cycles. ```python def dfs_recursive(graph, start_vertex): def dfs_helper(v, visited): visited.add(v) result.append(v) for neighbor in graph[v]: if neighbor not in visited: dfs_helper(neighbor, visited) visited = set() result = [] dfs_helper(start_vertex, visited) return result ```","solution":"def dfs_recursive(graph, start_vertex): Perform a recursive depth-first search (DFS) starting from start_vertex. Args: graph (dict): The adjacency list representing the graph. start_vertex: The starting vertex for the DFS traversal. Returns: list: A list of vertices in the order they are visited. def dfs_helper(v, visited): visited.add(v) result.append(v) for neighbor in graph.get(v, []): if neighbor not in visited: dfs_helper(neighbor, visited) visited = set() result = [] dfs_helper(start_vertex, visited) return result"},{"question":"# Question Editing Distance Calculation Challenge You are required to implement an algorithm that calculates the minimum edit distance (Levenshtein distance) between two strings. This metric represents the minimum number of single-character edits (insertions, deletions, or substitutions) required to change one string into the other. Function Signature ```python def edit_distance(str1: str, str2: str) -> int: ``` Input * `str1`: A string consisting of lowercase letters (1 ≤ len(str1) ≤ 1000). * `str2`: A string consisting of lowercase letters (1 ≤ len(str2) ≤ 1000). Output * Returns an integer representing the minimum edit distance between the two strings. Performance Requirements * The solution should aim for a time complexity of O(n * m) and a space complexity of O(n * m), where n and m are the lengths of the two input strings. Description and Steps 1. Create a 2D array (or matrix) `dp` where `dp[i][j]` represents the edit distance between the first `i` characters of `str1` and the first `j` characters of `str2`. 2. Initialize the base cases: * `dp[0][j] = j` for all `j` (transforming the empty string to `str2`). * `dp[i][0] = i` for all `i` (transforming `str1` to the empty string). 3. Fill the matrix by considering the cost of the last operation: * If the characters are the same, no new cost is incurred. * Otherwise, consider the cost of insertion, deletion, and substitution, and take the minimum. 4. Return `dp[len(str1)][len(str2)]`, which contains the minimum edit distance for the entire strings. # Example ```python print(edit_distance(\\"kitten\\", \\"sitting\\")) # Output: 3 print(edit_distance(\\"flaw\\", \\"lawn\\")) # Output: 2 print(edit_distance(\\"\\", \\"\\")) # Output: 0 print(edit_distance(\\"abc\\", \\"\\")) # Output: 3 ``` Considerations * Handling of edge cases such as one or both strings being empty. * Maintaining correctness for relatively large strings (up to the maximum allowed lengths). * Efficiently filling and accessing the 2D array to achieve the required performance constraints.","solution":"def edit_distance(str1: str, str2: str) -> int: n, m = len(str1), len(str2) dp = [[0] * (m + 1) for _ in range(n + 1)] # Initialize base cases for i in range(n + 1): dp[i][0] = i for j in range(m + 1): dp[0][j] = j # Fill the matrix for i in range(1, n + 1): for j in range(1, m + 1): if str1[i - 1] == str2[j - 1]: dp[i][j] = dp[i - 1][j - 1] else: insert = dp[i][j - 1] delete = dp[i - 1][j] substitute = dp[i - 1][j - 1] dp[i][j] = 1 + min(insert, delete, substitute) return dp[n][m]"},{"question":"# Coding Problem You are tasked with implementing a `LFUCache` (Least Frequently Used Cache) data structure which supports efficient retrieval and insertion of elements based on their usage frequency. Your implementation must adhere to the following specifications: Specifications 1. **Class Structure**: Implement the `LFUCache` class with the following methods: - `__init__(self, capacity: int) -> None` - `get(self, key: int) -> int` - `put(self, key: int, value: int) -> None` 2. **Cache Properties**: - The cache must maintain the property that when evicting elements, it removes the least frequently used element. If there is a tie, the least recently used of the tied elements should be removed. 3. **Functionality**: - `get(key: int) -> int`: Returns the value of the `key` if the key exists in the cache. Otherwise, returns -1. This operation should update the usage frequency of the key. - `put(key: int, value: int) -> None`: Updates the value of the `key` if the key exists. Otherwise, adds the `key-value` pair to the cache. If the cache is at full capacity, it should remove the least frequently used element before inserting the new pair. This operation should update the usage frequency of the key. 4. **Constraints**: - The cache capacity must be a positive integer. - The maximum capacity of the cache, `capacity`, will range from 1 to 10,000. - The key and value will be non-negative integers. 5. **Performance Requirements**: - Retrieval and insertion operations must have an average time complexity of O(1). Example Usage ```python lfu = LFUCache(2) lfu.put(1, 1) lfu.put(2, 2) assert lfu.get(1) == 1 lfu.put(3, 3) assert lfu.get(2) == -1 assert lfu.get(3) == 3 lfu.put(4, 4) assert lfu.get(1) == -1 assert lfu.get(3) == 3 assert lfu.get(4) == 4 ``` Notes * You are allowed to use additional data structures if necessary. * Consider edge cases such as operations on a full cache and retrieving elements not present in the cache.","solution":"class LFUCache: def __init__(self, capacity: int): self.capacity = capacity self.min_freq = 0 self.key_to_val = {} self.key_to_freq = {} self.freq_to_keys = {} def _update_freq(self, key): freq = self.key_to_freq[key] self.key_to_freq[key] += 1 self.freq_to_keys[freq].remove(key) if not self.freq_to_keys[freq]: if freq == self.min_freq: self.min_freq += 1 del self.freq_to_keys[freq] new_freq = freq + 1 if new_freq not in self.freq_to_keys: self.freq_to_keys[new_freq] = set() self.freq_to_keys[new_freq].add(key) def get(self, key: int) -> int: if key not in self.key_to_val: return -1 self._update_freq(key) return self.key_to_val[key] def put(self, key: int, value: int) -> None: if self.capacity == 0: return if key in self.key_to_val: self.key_to_val[key] = value self._update_freq(key) return if len(self.key_to_val) >= self.capacity: lfu_key = next(iter(self.freq_to_keys[self.min_freq])) del self.key_to_val[lfu_key] del self.key_to_freq[lfu_key] self.freq_to_keys[self.min_freq].remove(lfu_key) if not self.freq_to_keys[self.min_freq]: del self.freq_to_keys[self.min_freq] self.key_to_val[key] = value self.key_to_freq[key] = 1 self.min_freq = 1 if 1 not in self.freq_to_keys: self.freq_to_keys[1] = set() self.freq_to_keys[1].add(key)"},{"question":"# Question: Implementing Depth-First Search (DFS) in a Binary Tree Depth-First Search (DFS) is a fundamental tree traversal algorithm used in various applications such as graph traversal, maze solving, and path finding. In this task, you are required to implement DFS for a binary tree in both recursive and iterative ways. Implement the function `binary_tree_dfs(root)` that performs DFS traversal on a binary tree and returns a list of node values in the order they are visited. You need to implement both recursive and iterative (using stack) DFS within this function and return the results as a tuple containing two lists (recursive DFS result, iterative DFS result). **Input**: - `root` (TreeNode): The root node of the Binary Tree where TreeNode is defined as: ```python class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right ``` **Output**: - `(recursive_result, iterative_result)` (tuple of lists): The first list contains node values visited by recursive DFS, and the second list contains node values visited by iterative DFS. **Constraints**: - The binary tree node values are integers. - The number of nodes in the tree is at most 1000 to ensure feasible execution time. - Node values are unique within the tree. **Performance Requirements**: - Ensure the recursive DFS adheres to stack-depth limits in typical environments. - Optimize the iterative DFS using a stack to ensure O(n) time complexity. **Implementation Details**: - Implement a helper function for recursive DFS. - Use a stack explicitly for iterative DFS and manage the visitation of left and right child nodes appropriately. Example: ```python class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left = None self.right = right = None def binary_tree_dfs(root): def recursive_dfs(node): if not node: return [] # Visit left subtree, then root, then right subtree return recursive_dfs(node.left) + [node.value] + recursive_dfs(node.right) def iterative_dfs(node): if not node: return [] stack, result = [node], [] while stack: current = stack.pop() result.append(current.value) # Push right first so that left is processed first if current.right: stack.append(current.right) if current.left: stack.append(current.left) return result recursive_result = recursive_dfs(root) iterative_result = iterative_dfs(root) return recursive_result, iterative_result # Example Usage: if __name__ == \\"__main__\\": # Construct binary tree example root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) root.left.left = TreeNode(4) root.left.right = TreeNode(5) root.right.left = TreeNode(6) root.right.right = TreeNode(7) recursive_result, iterative_result = binary_tree_dfs(root) print(\\"Recursive DFS result:\\", recursive_result) print(\\"Iterative DFS result:\\", iterative_result) ``` **Hints**: - Ensure the recursive function handles the base case of an empty node (`None`). - Use a stack data structure for iterative DFS to mimic the call stack behavior in recursion. - Be careful with the order of pushing child nodes into the stack to maintain correct traversal sequence.","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def binary_tree_dfs(root): def recursive_dfs(node): if not node: return [] # Preorder: visit root, then left subtree, then right subtree return [node.value] + recursive_dfs(node.left) + recursive_dfs(node.right) def iterative_dfs(node): if not node: return [] stack, result = [node], [] while stack: current = stack.pop() result.append(current.value) # Push right first so that left is processed first if current.right: stack.append(current.right) if current.left: stack.append(current.left) return result recursive_result = recursive_dfs(root) iterative_result = iterative_dfs(root) return recursive_result, iterative_result"},{"question":"# Fibonacci Sequence Variants Context The Fibonacci sequence is a well-known sequence in mathematics, where each number is the sum of the two preceding ones, usually starting with 0 and 1. Many variations of this sequence exist by altering the initial terms or the rule for generating subsequent terms. These versions can serve different purposes in mathematical research, computer science, and problem-solving. Objective Write a Python class to implement two variants of the Fibonacci sequence: the standard Fibonacci sequence and a generalized Fibonacci sequence with custom initial terms and a custom recurrence relation. Your implementation should include methods to generate the nth number in each sequence and to create a list of the first n numbers in both sequences. Core Implementation Requirements 1. Implement a class `FibonacciSequence` with the following methods: - `__init__(self, initial_terms=[0, 1], coefficients=[1, 1])`: Initializes the sequence with given initial terms and recurrence relation coefficients. - `nth_standard_fibonacci(self, n)`: Returns the nth number in the standard Fibonacci sequence. - `nth_custom_fibonacci(self, n)`: Returns the nth number in the custom Fibonacci sequence using the initial terms and coefficients provided during initialization. - `generate_standard_sequence(self, n)`: Generates and returns the first n numbers in the standard Fibonacci sequence. - `generate_custom_sequence(self, n)`: Generates and returns the first n numbers in the custom Fibonacci sequence. Constraints - Ensure the initial terms and coefficients are provided as lists of positive integers. - The value of `n` should be a positive integer and should not significantly impact performance (e.g., `n <= 10^6`). Example Here\'s an example to illustrate the usage: ```python if __name__ == \\"__main__\\": # Standard Fibonacci sequence fib_seq = FibonacciSequence() print(fib_seq.nth_standard_fibonacci(10)) # Output: 55 print(fib_seq.generate_standard_sequence(10)) # Output: [0, 1, 1, 2, 3, 5, 8, 13, 21, 34] # Custom Fibonacci sequence with initial terms [2, 1] and coefficients [2, 3] custom_fib_seq = FibonacciSequence(initial_terms=[2, 1], coefficients=[2, 3]) print(custom_fib_seq.nth_custom_fibonacci(10)) # Custom output based on defined parameters print(custom_fib_seq.generate_custom_sequence(10)) # Custom sequence based on defined parameters ``` Your task is to complete the `FibonacciSequence` class meeting the specified requirements.","solution":"class FibonacciSequence: def __init__(self, initial_terms=[0, 1], coefficients=[1, 1]): self.initial_terms = initial_terms self.coefficients = coefficients def nth_standard_fibonacci(self, n): if n <= 0: raise ValueError(\\"n must be a positive integer\\") if n == 1: return self.initial_terms[0] if n == 2: return self.initial_terms[1] a, b = self.initial_terms[0], self.initial_terms[1] for _ in range(2, n): a, b = b, a + b return b def nth_custom_fibonacci(self, n): if n <= 0: raise ValueError(\\"n must be a positive integer\\") if n <= len(self.initial_terms): return self.initial_terms[n-1] terms = self.initial_terms[:] for i in range(len(self.initial_terms), n): next_term = sum(terms[-len(self.coefficients):]) terms.append(next_term) return terms[-1] def generate_standard_sequence(self, n): if n < 0: raise ValueError(\\"n must be a non-negative integer\\") if n == 0: return [] sequence = [self.initial_terms[0]] if n == 1: return sequence sequence.append(self.initial_terms[1]) for _ in range(2, n): sequence.append(sequence[-1] + sequence[-2]) return sequence def generate_custom_sequence(self, n): if n < 0: raise ValueError(\\"n must be a non-negative integer\\") if n <= len(self.initial_terms): return self.initial_terms[:n] sequence = self.initial_terms[:] for _ in range(len(self.initial_terms), n): next_term = sum(sequence[-len(self.coefficients):]) sequence.append(next_term) return sequence"},{"question":"# Question: String Pattern Matching with Wildcards You are required to develop a function that performs pattern matching on strings with wildcard characters. The pattern consists of two special characters: - `?` matches exactly one occurrence of any character. - `*` matches zero or more occurrences of any characters. Your task is to implement a function that determines whether a given string matches a given pattern, adhering to the following specifications: 1. **Recursive Matching**: Design the function using recursive techniques to handle the pattern matching. 2. **Efficient Computation**: Optimize the function to handle large input sizes efficiently. # Input * A string `text` of type `str` that represents the input text to be matched. * A string `pattern` of type `str` that represents the pattern containing wildcards. # Output * A boolean `True` if the text matches the pattern, otherwise `False`. # Constraints * The length of `text` and `pattern` can each be up to 1000 characters. * Wildcard characters `?` and `*` can appear anywhere in the `pattern`. # Examples ```python print(is_match(\\"adceb\\", \\"*a*b\\")) # Output: True print(is_match(\\"acdcb\\", \\"a*c?b\\")) # Output: False print(is_match(\\"abcdef\\", \\"?b*e?g\\")) # Output: False print(is_match(\\"aaa\\", \\"*a\\")) # Output: True ``` # Explanation 1. In the first example, the pattern \\"*a*b\\" matches the text \\"adceb\\" because the `*` can match any sequence of characters. 2. In the second example, the pattern \\"a*c?b\\" does not match the text \\"acdcb\\" because the last character does not match. 3. In the third example, the pattern \\"?b*e?g\\" does not match the text \\"abcdef\\" because the sequence \\"e?g\\" cannot be matched from the text. 4. In the fourth example, the pattern \\"*a\\" matches the text \\"aaa\\" because `*` can match any sequence of characters, including an empty sequence. Implement the function `is_match` in a way that follows these specifications and validates different scenarios, including edge cases and standard use cases. ```python def is_match(text: str, pattern: str) -> bool: # Your implementation here pass # Example usage and tests print(is_match(\\"adceb\\", \\"*a*b\\")) print(is_match(\\"acdcb\\", \\"a*c?b\\")) print(is_match(\\"abcdef\\", \\"?b*e?g\\")) print(is_match(\\"aaa\\", \\"*a\\")) ```","solution":"def is_match(text: str, pattern: str) -> bool: def helper(t_idx, p_idx): if p_idx == len(pattern): return t_idx == len(text) if p_idx < len(pattern) and pattern[p_idx] == \'*\': if helper(t_idx, p_idx + 1): return True if t_idx < len(text) and helper(t_idx + 1, p_idx): return True return False if t_idx < len(text) and (pattern[p_idx] == text[t_idx] or pattern[p_idx] == \'?\'): return helper(t_idx + 1, p_idx + 1) return False return helper(0, 0)"},{"question":"# Scenario: You are a software developer tasked with creating a basic text autocompletion feature for a messaging application. The autocompletion should suggest possible word completions based on a given prefix extracted from past messages sent by a user. # Task: Implement a function to build a Trie (prefix tree) from a list of words, and provide a method to return a list of all words in the Trie that start with a given prefix. This function will help in autocompleting user input in the messaging app. # Function Signature: ```python class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False class Trie: def __init__(self): self.root = TrieNode() def insert(self, word: str) -> None: Insert a word into the Trie. Parameters: - word (str): The word to be inserted into the Trie. def search(self, prefix: str) -> List[str]: Search for all words starting with the given prefix in the Trie. Parameters: - prefix (str): The prefix for which to suggest completions. Returns: - List[str]: A list of all words that start with the prefix. def autocomplete(words: List[str], prefix: str) -> List[str]: Build a Trie from a list of words, then return all suggestions for a given prefix. Parameters: - words (List[str]): List of words to build the Trie from. - prefix (str): The prefix to use for autocompletion. Returns: - List[str]: List of suggestions that match the given prefix. ``` # Constraints: - All words consist of lowercase English letters. - The length of words and prefix ranges from 1 to 100. - The total number of words is at most 10,000. - The maximum number of autocompletion suggestions should not exceed 20. # Performance: - Building the Trie should be efficiently handled within a linear or near-linear time complexity concerning the total number of characters in the word list. - Searching for completions should also be performed in a reasonable time, scaling well with the number of words and the average length of prefix. # Evaluation: - Your solution will be evaluated based on its correctness, efficiency, and the clarity of the Trie implementation. - Edge cases (e.g., no words matching the prefix, very common prefixes) should be appropriately managed.","solution":"from typing import List class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False class Trie: def __init__(self): self.root = TrieNode() def insert(self, word: str) -> None: Insert a word into the Trie. node = self.root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.is_end_of_word = True def _find_node(self, prefix: str) -> TrieNode: node = self.root for char in prefix: if char not in node.children: return None node = node.children[char] return node def _collect_words(self, node: TrieNode, prefix: str) -> List[str]: words = [] if node.is_end_of_word: words.append(prefix) for char, child_node in node.children.items(): words.extend(self._collect_words(child_node, prefix + char)) return words def search(self, prefix: str) -> List[str]: Search for all words starting with the given prefix in the Trie. node = self._find_node(prefix) if not node: return [] return self._collect_words(node, prefix) def autocomplete(words: List[str], prefix: str) -> List[str]: trie = Trie() for word in words: trie.insert(word) suggestions = trie.search(prefix) suggestions.sort() return suggestions[:20]"},{"question":"# Coding Assessment Question Prerequisites: Proficiency in string manipulation, regular expressions, and basic data structures (specifically dictionaries). Problem Statement: Implement a function `most_frequent_characters(s: str, k: int) -> List[str]` that returns a list of the `k` most frequent characters in the string `s`, sorted by their frequency in descending order. In case of a tie, characters should be listed in alphabetical order. Function Signature: ```python def most_frequent_characters(s: str, k: int) -> List[str]: pass ``` Input: - `s` (1 ≤ len(s) ≤ 10^5): A string consisting of valid ASCII characters. - `k` (1 ≤ k ≤ len(set(s))): An integer specifying the number of top frequent characters to return. Output: - A list of characters representing the `k` most frequent characters in `s`. Requirements: 1. **Frequency Calculation**: Implement an efficient method to calculate the frequency of characters. 2. **Tie-breaking**: Ensure characters are sorted alphabetically if they have the same frequency. Constraints: - Handle invalid inputs by raising appropriate Python exceptions: - If `s` is not a string, raise a `TypeError`. - If `k` is not an integer or not within the valid range, raise a `ValueError`. Examples: ```python assert most_frequent_characters(\\"aabbbccdd\\", 2) == [\'b\', \'a\'] # \'b\' appears 3 times, \'a\' twice assert most_frequent_characters(\\"zzxyyy\\", 3) == [\'y\', \'z\', \'x\'] # \'y\' appears 3 times, \'z\' twice, \'x\' once assert most_frequent_characters(\\"abcdabcdabcd\\", 4) == [\'a\', \'b\', \'c\', \'d\'] # All characters appear 3 times assert most_frequent_characters(\\"aaabbbcccdde\\", 1) == [\'a\'] # \'a\' appears 3 times ``` Note: - Ensure to include edge-case testing. - Optimize for both readability and performance. - Unit tests are highly recommended.","solution":"from typing import List from collections import Counter def most_frequent_characters(s: str, k: int) -> List[str]: if not isinstance(s, str): raise TypeError(\\"Input must be a string\\") if not isinstance(k, int) or not 1 <= k <= len(set(s)): raise ValueError(\\"Invalid value for k\\") count = Counter(s) sorted_characters = sorted(count.keys(), key=lambda x: (-count[x], x)) return sorted_characters[:k]"},{"question":"# Movie Rating Prediction Scenario: You are working on a movie recommendation system and need to predict the rating a user would give to a particular movie based on their previous ratings. For simplicity, each movie is represented by a unique movie ID and each user by a unique user ID. The ratings are given on a scale from 1 to 5. Question: Implement a function `predict_rating(user_ratings: dict[int, list[tuple[int, int]]], user_id: int, movie_id: int) -> float | None` that predicts the rating a user would give to a specific movie. The ratings are initially given as a dictionary where the key is a user ID and the value is a list of tuples, each containing a movie ID and the corresponding rating. Use collaborative filtering to make your prediction by considering the ratings of other users who have rated the same movies as the user in question. Provide your own implementation for any necessary helper functions. # Function Specification: Input: 1. `user_ratings` (`dict[int, list[tuple[int, int]]]`): The dictionary of user ratings. 2. `user_id` (`int`): The ID of the user for whom the prediction is being made. 3. `movie_id` (`int`): The ID of the movie for which the rating is to be predicted. Output: Should return: - The predicted rating (`float`) the user would give to the specified movie. - `None` if the prediction could not be made due to lack of sufficient data. # Constraints: - The list of ratings for a user can be empty. - The user and movie IDs are positive integers. - The ratings are integers between 1 and 5 inclusive. - The number of users can be up to (10^4), and the number of movies can also be up to (10^4). # Example: ```python user_ratings = { 1: [(101, 5), (102, 3), (103, 4)], 2: [(101, 4), (104, 2)], 3: [(102, 4), (103, 5)], 4: [(101, 2), (102, 4), (103, 3), (105, 5)] } user_id = 1 movie_id = 104 predicted_rating = predict_rating(user_ratings, user_id, movie_id) print(f\\"Predicted Rating for User {user_id} on Movie {movie_id}: {predicted_rating}\\") # Output: Predicted Rating for User 1 on Movie 104: 3.5 ``` **Note:** Ensure your implementation efficiently handles the data size constraints and considers edge cases such as the user or movie not being present in the given data.","solution":"from typing import Dict, List, Tuple def predict_rating(user_ratings: Dict[int, List[Tuple[int, int]]], user_id: int, movie_id: int) -> float | None: Predicts the rating a user would give to a particular movie based on collaborative filtering by other users\' ratings. Parameters: user_ratings (dict): A dictionary where the key is a user ID and the value is a list of tuples with movie ID and rating. user_id (int): The ID of the user for whom the prediction is being made. movie_id (int): The ID of the movie for which the rating is to be predicted. Returns: float: The predicted rating the user would give to the movie, or None if the prediction cannot be made. # Check if the user has rated any movies if user_id not in user_ratings or len(user_ratings[user_id]) == 0: return None # Gather all users who have rated the target movie users_who_rated_movie = [uid for uid in user_ratings if any(movie_id == mid for mid, rating in user_ratings[uid])] if not users_who_rated_movie: return None # Calculate the average rating for the target movie amongst these users movie_ratings = [] for uid in users_who_rated_movie: for mid, rating in user_ratings[uid]: if mid == movie_id: movie_ratings.append(rating) if not movie_ratings: return None # Predict the rating as the average rating of the target movie among users who have rated it predicted_rating = sum(movie_ratings) / len(movie_ratings) return predicted_rating"},{"question":"# Longest Substring Without Repeating Characters **Scenario**: Given a string, find the length of the longest substring which does not contain any repeating characters. This problem is a fundamental exercise in utilizing hashing techniques to optimize finding substrings of interest in strings. Task: Implement a function `length_of_longest_substring(s: str) -> int`. Given a string `s`, the function should return the length of the longest substring of `s` that does not have any repeating characters. Input: - `s`: A string with a length `0 <= len(s) <= 10^5` that contains upper-case letters, lower-case letters, digits, and/or symbols. Output: - An integer representing the length of the longest substring without repeating characters. Constraints: - The length of the input string, `s`, is between 0 and 100,000 characters. - The input string can contain a mix of upper-case letters, lower-case letters, digits, and symbols. Examples: - When `s` is `\\"abcabcbb\\"`, the function should return `3` (the substring `\\"abc\\"` is one of the longest substrings without repeating characters). - When `s` is `\\"bbbbb\\"`, the function should return `1` (the substring `\\"b\\"` is the longest without repeating characters). - When `s` is `\\"pwwkew\\"`, the function should return `3` (the substring `\\"wke\\"` is one of the longest substrings without repeating characters). # Performance requirements: - The function must efficiently process strings up to the maximum length, ensuring linear time complexity for the solution. # Notes: - Consider using a sliding window technique along with a hash set to track characters to achieve an optimal solution. - Ensure the function handles edge cases such as empty strings or strings with all identical characters. Example code snippet to be implemented: ```python def length_of_longest_substring(s: str) -> int: Return the length of the longest substring without repeating characters. # Your implementation here n = len(s) char_set = set() left_pointer = 0 result = 0 for right_pointer in range(n): while s[right_pointer] in char_set: char_set.remove(s[left_pointer]) left_pointer += 1 char_set.add(s[right_pointer]) result = max(result, right_pointer - left_pointer + 1) return result ```","solution":"def length_of_longest_substring(s: str) -> int: Return the length of the longest substring without repeating characters. n = len(s) char_set = set() left_pointer = 0 result = 0 for right_pointer in range(n): while s[right_pointer] in char_set: char_set.remove(s[left_pointer]) left_pointer += 1 char_set.add(s[right_pointer]) result = max(result, right_pointer - left_pointer + 1) return result"},{"question":"# Description You have been given a 2D grid representing a map where each cell can be either land (`1`) or water (`0`). Write a function `max_area_of_island` to identify the maximum area of an island in the grid. An island is composed of adjacent `1`s (horizontally or vertically) and is surrounded by `0`s (or the edges of the grid). You may assume all four edges of the grid are surrounded by water. Your solution should employ both Depth-First Search (DFS) and Breadth-First Search (BFS) approaches. # Function Signature ```python def max_area_of_island(grid: List[List[int]]) -> int: pass ``` # Input - A list of lists of integers, `grid`, where `grid[i][j]` is either `1` (land) or `0` (water) (1 ≤ len(grid), len(grid[0]) ≤ 50). # Output - An integer representing the size of the largest island. If no island is present, return 0. # Example ```python grid = [ [0,0,1,0,0,0,0,1,0,0,0,0,0], [0,0,0,0,0,0,0,1,1,1,0,0,0], [0,1,1,0,1,0,0,0,0,0,0,0,0], [0,1,0,0,1,1,0,0,1,0,1,0,0], [0,1,0,0,1,1,0,0,1,1,1,0,0], [0,0,0,0,0,0,0,0,0,0,1,0,0], [0,0,0,0,0,0,0,1,1,1,0,0,0], [0,0,0,0,0,0,0,1,1,0,0,0,0] ] print(max_area_of_island(grid)) # Output: 6 ``` # Constraints - Edge cases such as all water grid (no islands) or all land grid (one big island) should be handled gracefully. - Your function should be efficient and handle various grid configurations robustly. # Notes - Implement both DFS and BFS approaches within your function or as helper functions. - Ensure clean and modular code, using helper functions if necessary. - Clarify assumptions and edge cases in your implementation.","solution":"from typing import List def max_area_of_island(grid: List[List[int]]) -> int: # DFS method to explore the island def dfs(x, y): if x < 0 or x >= len(grid) or y < 0 or y >= len(grid[0]) or grid[x][y] == 0: return 0 grid[x][y] = 0 # Mark the cell as visited by setting it to 0 area = 1 for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: area += dfs(x + dx, y + dy) return area max_area = 0 for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == 1: max_area = max(max_area, dfs(i, j)) return max_area"},{"question":"# Question: Matrix Determinant Calculator Enhancement You are provided with a function that calculates the determinant of a square matrix. The existing implementation can handle 2x2 and 3x3 matrices but needs enhancement for robustness and error handling. Your Task Enhance the given function to: 1. Support matrices of any size (n x n). 2. Validate input to ensure the matrix is square. 3. Provide clear error messages for the following scenarios: - The input is not a matrix. - The matrix is not square. 4. Implement detailed unit tests to cover these scenarios. Function Signature ```python def matrix_determinant(matrix: list[list[float]]) -> float: ``` Input - `matrix`: A list of lists where each sub-list represents a row in the matrix. Each element is a float. Output - The determinant of the matrix as a float. Constraints - The matrix must be square (number of rows equals number of columns). - Elements of the matrix are floating point numbers. Examples ```python assert matrix_determinant([[1, 2], [3, 4]]) == -2.0 assert matrix_determinant([[6, 1, 1], [4, -2, 5], [2, 8, 7]]) == -306.0 # Error Scenarios try: matrix_determinant([[1, 2], [3, 4, 5]]) except ValueError as e: assert str(e) == \\"The matrix must be square\\" try: matrix_determinant([[1, 2], \\"Not a matrix\\"]) except ValueError as e: assert str(e) == \\"The input must be a list of lists\\" try: matrix_determinant([[1, 2], [3, \\"Non-numeric\\"]]) except ValueError as e: assert str(e) == \\"The matrix elements must be floats\\" ``` Enhance the function\'s robustness to handle matrices of any size while performing appropriate validation and error handling to maintain the integrity of the input data.","solution":"def matrix_determinant(matrix: list[list[float]]) -> float: Calculate the determinant of a square matrix. Args: matrix (list of list of float): A square matrix represented as a list of lists. Returns: float: Determinant of the matrix. Raises: ValueError: If the input is not a matrix or the matrix is not square. # Validate input is a list of lists if not isinstance(matrix, list) or not all(isinstance(row, list) for row in matrix): raise ValueError(\\"The input must be a list of lists\\") # Validate the matrix is square n = len(matrix) if any(len(row) != n for row in matrix): raise ValueError(\\"The matrix must be square\\") # Validate all elements are floats for row in matrix: if not all(isinstance(elem, (int, float)) for elem in row): raise ValueError(\\"The matrix elements must be floats\\") # Base case for 2x2 matrix if n == 2: return matrix[0][0] * matrix[1][1] - matrix[0][1] * matrix[1][0] determinant = 0 for c in range(n): determinant += ((-1) ** c) * matrix[0][c] * matrix_determinant(minor(matrix, 0, c)) return determinant def minor(matrix: list[list[float]], i: int, j: int) -> list[list[float]]: Helper function to calculate the minor of a matrix element. Args: matrix (list of list of float): The matrix. i (int): Row index. j (int): Column index. Returns: list of list of float: The minor of the matrix. return [row[:j] + row[j + 1:] for row in (matrix[:i] + matrix[i + 1:])]"},{"question":"# Coding Question: Implement a JSON Data Filter **Objective**: Write a Python function that reads a JSON file containing a list of user records and returns a filtered list based on a specific condition. To achieve this, your function should: 1. Read the JSON data from a file. 2. Filter the list of user records according to a specified condition (e.g., users above a certain age). 3. Return the filtered list. **Function Signature**: ```python def filter_users_by_age(file_path: str, age_threshold: int) -> list: pass ``` **Input**: - `file_path` (str): The path to the JSON file containing user records. - `age_threshold` (int): The age threshold for filtering users. **Output**: - `list`: A list of user records where each user is older than the given age threshold. **Constraints**: - The JSON file will have a structure similar to: ```json [ {\\"name\\": \\"Alice\\", \\"age\\": 30, \\"email\\": \\"alice@example.com\\"}, {\\"name\\": \\"Bob\\", \\"age\\": 24, \\"email\\": \\"bob@example.com\\"}, {\\"name\\": \\"Charlie\\", \\"age\\": 35, \\"email\\": \\"charlie@example.com\\"} ] ``` - You must handle potential errors, such as file not found or JSON decoding errors. - Ensure that the function works efficiently even with large JSON files. **Performance Requirements**: - The function should process the JSON data in a reasonable time, ensuring it can handle large files. - The filtering operation should be efficient. **Example**: ```python filtered_users = filter_users_by_age(\\"users.json\\", 30) print(filtered_users) # Should print the list of users above the age of 30, e.g., [{\\"name\\": \\"Alice\\", \\"age\\": 30, \\"email\\": \\"alice@example.com\\"}, {\\"name\\": \\"Charlie\\", \\"age\\": 35, \\"email\\": \\"charlie@example.com\\"}] ``` **Additional Notes**: - Ensure to handle edge cases, such as an empty list or all users being younger than the threshold age. - Validate the input data to make sure it conforms to the expected structure. **Testing**: - Test with various JSON files to verify the correctness and robustness of your implementation. - Consider edge cases, such as empty JSON files or records missing the expected fields.","solution":"import json def filter_users_by_age(file_path: str, age_threshold: int) -> list: Reads a JSON file containing a list of user records and returns a filtered list of users older than the specified age threshold. :param file_path: Path to the JSON file containing user records. :param age_threshold: Age threshold for filtering users. :return: A filtered list of user records where each user is older than the specified age threshold. try: with open(file_path, \'r\') as file: user_records = json.load(file) filtered_users = [user for user in user_records if user.get(\'age\', 0) > age_threshold] return filtered_users except FileNotFoundError: print(f\\"Error: The file {file_path} was not found.\\") return [] except json.JSONDecodeError: print(f\\"Error: The file {file_path} is not a valid JSON file.\\") return []"},{"question":"As a software engineer, managing and organizing data is a critical aspect of your projects, especially when working with large datasets or logs. One common task is parsing log entries to identify unique users who have accessed a particular service within a certain time frame. Identifying unique user accesses enables better monitoring, security auditing, and user analytics. # Function Description You are required to implement the function `unique_user_access(entries, start_time, end_time)`. # Input - `entries`: a list of tuples, where each tuple contains two elements: - the first element is a string representing the username (e.g., `\'user123\'`) - the second element is a float representing the access timestamp (e.g., `1609459200.0` which is the UNIX epoch time for January 1, 2021) - `start_time`: a float representing the start of the time frame (inclusive) - `end_time`: a float representing the end of the time frame (inclusive) # Output - Returns a set of unique usernames who have accessed the service between `start_time` and `end_time` inclusive. # Constraints - `start_time` and `end_time` will be valid floating-point numbers. - `end_time` will always be greater than or equal to `start_time`. - The `entries` list can be of varying lengths, and may contain thousands or even millions of log entries. - Usernames are case-sensitive and can be alphanumeric strings without spaces. # Examples ```python unique_user_access([(\'user123\', 1609459200.0), (\'user456\', 1609545600.0), (\'user123\', 1609632000.0)], 1609459200.0, 1609545600.0) # Output: {\'user123\', \'user456\'} unique_user_access([(\'user123\', 1609459200.0), (\'user456\', 1609545600.0), (\'User123\', 1609632000.0)], 1609459200.0, 1609459300.0) # Output: {\'user123\'} unique_user_access([(\'user123\', 1609459200.0), (\'user456\', 1609545600.0), (\'user123\', 1609632000.0)], 1609632000.0, 1609632100.0) # Output: {\'user123\'} unique_user_access([(\'user123\', 1609459200.0), (\'user456\', 1609545600.0)], 1609545601.0, 1609632000.0) # Output: set() unique_user_access([], 1609459200.0, 1609545600.0) # Output: set() ``` Pay attention to the potential edge cases such as overlapping time frames, identical usernames with different timestamps, and the handling of large datasets efficiently.","solution":"def unique_user_access(entries, start_time, end_time): Returns a set of unique usernames who have accessed the service between start_time and end_time inclusive. Args: - entries: list of tuples (username: str, timestamp: float) - start_time: float, start of the time frame (inclusive) - end_time: float, end of the time frame (inclusive) Returns: - set of unique usernames unique_users = set() for username, timestamp in entries: if start_time <= timestamp <= end_time: unique_users.add(username) return unique_users"},{"question":"# Coding Assessment Question: Implement a Min-Heap Scenario: A min-heap is a binary tree where the value of each node is less than or equal to the values of its children. The root of the heap is the smallest element. You are tasked with implementing a min-heap using a list to store its elements. Problem: Write a class called `MinHeap` that implements the following methods: 1. `insert(item: int)`: Adds an item to the heap. 2. `remove_min() -> int`: Removes and returns the smallest item from the heap. 3. `get_min() -> int | None`: Returns the smallest item without removing it. Returns `None` if the heap is empty. Input and Output Formats: * **insert(item: int)**: Adds `item` to the heap. Does not return anything. * **remove_min() -> int**: Removes and returns the smallest item from the heap. If the heap is empty, it should raise an `IndexError`. * **get_min() -> int | None**: Returns the smallest item without removing it. If the heap is empty, it should return `None`. Constraints: * All methods should maintain the heap property. * You may only use basic list operations (`append`, `pop`, list indexing). * The methods should have logarithmic time complexity. Example Usage: ```python heap = MinHeap() heap.insert(10) heap.insert(4) heap.insert(9) heap.insert(1) assert heap.get_min() == 1 assert heap.remove_min() == 1 assert heap.get_min() == 4 heap.insert(2) assert heap.get_min() == 2 heap.remove_min() heap.remove_min() heap.remove_min() assert heap.get_min() is None try: heap.remove_min() except IndexError: print(\\"Caught expected IndexError for remove_min from empty heap\\") ``` Implementation: Implement the class with appropriate methods to satisfy the above requirements.","solution":"class MinHeap: def __init__(self): self.heap = [] def insert(self, item: int): self.heap.append(item) self._heapify_up(len(self.heap) - 1) def remove_min(self) -> int: if not self.heap: raise IndexError(\\"remove_min from empty heap\\") if len(self.heap) == 1: return self.heap.pop() min_item = self.heap[0] self.heap[0] = self.heap.pop() self._heapify_down(0) return min_item def get_min(self) -> int | None: if not self.heap: return None return self.heap[0] def _heapify_up(self, index): parent_index = (index - 1) // 2 if index > 0 and self.heap[index] < self.heap[parent_index]: self.heap[index], self.heap[parent_index] = self.heap[parent_index], self.heap[index] self._heapify_up(parent_index) def _heapify_down(self, index): smallest = index left_child = 2 * index + 1 right_child = 2 * index + 2 if left_child < len(self.heap) and self.heap[left_child] < self.heap[smallest]: smallest = left_child if right_child < len(self.heap) and self.heap[right_child] < self.heap[smallest]: smallest = right_child if smallest != index: self.heap[index], self.heap[smallest] = self.heap[smallest], self.heap[index] self._heapify_down(smallest)"},{"question":"# Array Rotation Problem You have been assigned the task of implementing a function that rotates an array by a certain number of positions to the right. The function should efficiently handle both positive and negative rotation values, and it should perform necessary type checks to ensure it processes valid inputs. Function Signature ```python def rotate_array(arr: list, k: int) -> list: Rotate an array by k positions to the right. :param arr: List of integers. :param k: Number of positions to rotate (an integer, can be negative). :return: A list representing the rotated array. # Your code here ``` # Input * `arr`: A list of integers. * `k`: An integer representing the number of positions to rotate (can be negative). # Output * A list of integers representing the rotated array. # Constraints * The function should handle an empty array by returning an empty array. * The function should handle negative rotation values by rotating to the left. * Ensure the function runs efficiently even for large arrays. * The rotation should be done in-place or by creating a minimal number of new arrays. # Additional Requirements * Ensure the function raises appropriate exceptions for invalid inputs (e.g., non-integer k or non-list arr). * Ensure that the function does not modify the original array. # Example 1. **Input**: arr = [1, 2, 3, 4, 5], k = 2 **Output**: [4, 5, 1, 2, 3] 2. **Input**: arr = [1, 2, 3, 4, 5], k = -1 **Output**: [2, 3, 4, 5, 1] 3. **Input**: arr = [], k = 3 **Output**: [] # Implementation Note * Use slicing techniques to solve the problem effectively. * Handle edge cases such as empty arrays and rotation values greater than the length of the array. ```python def rotate_array(arr: list, k: int) -> list: if not isinstance(arr, list) or not all(isinstance(x, int) for x in arr): raise TypeError(\\"arr must be a list of integers.\\") if not isinstance(k, int): raise TypeError(\\"k must be an integer.\\") if len(arr) == 0: return arr k = k % len(arr) return arr[-k:] + arr[:-k] ``` This question and the corresponding sample solution provide an opportunity to test a candidate\'s ability to understand and manipulate data structures, handle edge cases, and perform type checking in Python, aligning well with the style, complexity, and scope of the provided sample question.","solution":"def rotate_array(arr: list, k: int) -> list: Rotate an array by k positions to the right. :param arr: List of integers. :param k: Number of positions to rotate (an integer, can be negative). :return: A list representing the rotated array. # Validate input array if not isinstance(arr, list) or not all(isinstance(x, int) for x in arr): raise TypeError(\\"arr must be a list of integers.\\") if not isinstance(k, int): raise TypeError(\\"k must be an integer.\\") # Handle empty array if len(arr) == 0: return arr # Normalize the rotation in case k is negative or greater than the length of the array k = k % len(arr) # Rotate the array return arr[-k:] + arr[:-k]"},{"question":"# Question: Array Rotation and De-duplication As a software engineer assigned to optimize data processing tasks, you need to implement two functions that handle array modifications. The first function will rotate an array to the right by a certain number of steps, and the second function will remove duplicate elements from an array while preserving the original order. Function 1: `rotate_array` Implement a function `rotate_array` that takes in two parameters: * `arr` (list): A list of integers. * `steps` (int): The number of positions to rotate the array to the right. The function should return a new list with the elements rotated accordingly. Function 2: `remove_duplicates` Implement a function `remove_duplicates` that takes in one parameter: * `arr` (list): A list of integers. The function should return a new list with duplicates removed, maintaining the order of first occurrences. # Constraints * `arr` should be a list of integers. * `steps` should be an integer. * If `steps` is negative, treat it as rotating to the left by the absolute value of `steps`. * Handle edge cases such as empty arrays and arrays with all identical elements. * Ensure the functions are efficient and can handle large arrays. # Examples ```python # Rotate array to the right by 2 steps print(rotate_array([1, 2, 3, 4, 5], 2)) # [4, 5, 1, 2, 3] # Remove duplicates from the array print(remove_duplicates([1, 2, 2, 3, 4, 4, 5])) # [1, 2, 3, 4, 5] ``` # Requirements Your functions should: 1. Handle invalid data types by raising a `TypeError`. 2. Ensure correctness and robustness for a variety of input values. 3. Perform rotations within an acceptable time complexity, preferably O(n). Start coding these functions, and ensure that all provided examples and edge cases are properly handled. Good luck!","solution":"def rotate_array(arr, steps): Rotates the array to the right by the given number of steps. Handles negative steps by rotating to the left. if not isinstance(arr, list) or not all(isinstance(x, int) for x in arr): raise TypeError(\\"arr must be a list of integers.\\") if not isinstance(steps, int): raise TypeError(\\"steps must be an integer.\\") n = len(arr) if n == 0: return arr steps = steps % n # Normalize steps to prevent full rotations return arr[-steps:] + arr[:-steps] def remove_duplicates(arr): Removes duplicates from the array while maintaining the order of the first occurrences. if not isinstance(arr, list) or not all(isinstance(x, int) for x in arr): raise TypeError(\\"arr must be a list of integers.\\") seen = set() result = [] for item in arr: if item not in seen: seen.add(item) result.append(item) return result"},{"question":"# In-Place Merge Sort Task **Objective:** Implement the Merge Sort algorithm to sort an array of integers using in-place techniques to minimize space complexity. The function should ensure that the list `arr` is sorted in ascending order, directly modifying the list in place. **Function Signature:** ```python def merge_sort_in_place(arr: List[int], l: int, r: int) -> None: ``` **Input:** - `arr`: A list of integers `arr` of size `n` where (1 leq n leq 10^6). - `l`: An integer representing the starting index (inclusive) of the list to be sorted. - `r`: An integer representing the ending index (inclusive) of the list to be sorted. **Output:** - The list `arr` should be sorted in ascending order between indices `l` and `r` through in-place modification. **Example:** ```python arr = [8, 3, -2, 7, 4, -6, 8] merge_sort_in_place(arr, 0, len(arr) - 1) print(arr) # Output: [-6, -2, 3, 4, 7, 8, 8] ``` **Constraints:** - The elements in `arr` can be both negative and positive integers. - You must implement an in-place merge sort which minimizes the extra space used. **Performance Requirements:** - The function should operate efficiently for large arrays (up to `10^6` elements). **Notes:** - Aim to achieve an overall time complexity of (O(n log n)) while keeping the space complexity as low as possible. - Handle edge cases involving negative and positive numbers properly. - Avoid using additional lists for merging; instead, perform merging directly in the given list. **Additional Guidance:** - Test your implementation against various edge cases, including small arrays, large arrays, and arrays with duplicate values. - Provide clear comments to describe the merging process and any helper functions you implement.","solution":"from typing import List def merge_sort_in_place(arr: List[int], l: int, r: int) -> None: if l < r: mid = (l + r) // 2 # Recursively sort first and second halves merge_sort_in_place(arr, l, mid) merge_sort_in_place(arr, mid + 1, r) # Merge the sorted halves merge(arr, l, mid, r) def merge(arr: List[int], l: int, mid: int, r: int) -> None: # Create temporary arrays to hold the left and right subarrays left = arr[l:mid + 1] right = arr[mid + 1:r + 1] i = j = 0 k = l # Merge the temp arrays back into arr[l..r] while i < len(left) and j < len(right): if left[i] <= right[j]: arr[k] = left[i] i += 1 else: arr[k] = right[j] j += 1 k += 1 # Copy the remaining elements of left[], if there are any while i < len(left): arr[k] = left[i] i += 1 k += 1 # Copy the remaining elements of right[], if there are any while j < len(right): arr[k] = right[j] j += 1 k += 1"},{"question":"# Coding Assessment Question Context: The Fibonacci sequence is a series of numbers where each number is the sum of the two preceding ones, starting from 0 and 1. That is, the sequence starts with 0, 1, and the next number is always the sum of the two previous numbers. Problem Statement: Given an integer `n`, find the `n`-th Fibonacci number. Function Signature: ```python def find_fibonacci(n: int) -> int: pass ``` Input: - An integer `n` (0 ≤ n ≤ 100), representing the position in the Fibonacci sequence. Output: - An integer, representing the `n`-th Fibonacci number. Example: 1. **Input**: `n = 10` **Output**: `55` 2. **Input**: `n = 20` **Output**: `6765` Constraints: - The function should handle all values of `n` within the given range efficiently. - You may use either iterative or recursive approaches to implement the function. Write the Python function to solve this problem.","solution":"def find_fibonacci(n: int) -> int: Returns the n-th Fibonacci number. Args: n: An integer, representing the position in the Fibonacci sequence. Returns: An integer, representing the n-th Fibonacci number. if n == 0: return 0 elif n == 1: return 1 a, b = 0, 1 for _ in range(2, n + 1): a, b = b, a + b return b"},{"question":"# Question: Implement a CSV File Processing System Background Your task is to implement a Python function that processes a CSV file containing user data. This function should read the CSV file, filter out inactive users, and return a list of email addresses belonging to active users only. Inactive users are those who have the status \\"inactive\\" in the CSV file. Requirements 1. **Function Name**: `filter_active_users` 2. **Inputs**: - A string representing the file path to the CSV file. 3. **Output**: - A list of email addresses (strings) of active users. 4. **Behavior**: - Read the CSV file from the given file path. - The CSV file contains three columns: \\"name\\", \\"email\\", and \\"status\\". - Filter out rows where the status is \\"inactive\\". - Return a list of email addresses for users whose status is not \\"inactive\\". Constraints - The row headers in the CSV file are always \\"name\\", \\"email\\", and \\"status\\". - Assume the CSV file is well-formatted and does not contain missing values. - The status can only be \\"active\\" or \\"inactive\\". - Efficiently handle the file operations considering performance and memory usage. Example Scenario 1. An example CSV file (`users.csv`): ``` name,email,status John Doe,john.doe@example.com,active Jane Smith,jane.smith@example.com,inactive Emily Davis,emily.davis@example.com,active ``` 2. Calling `filter_active_users(\'users.csv\')` should return: ```python [\'john.doe@example.com\', \'emily.davis@example.com\'] ``` ```python import csv def filter_active_users(file_path): active_emails = [] with open(file_path, mode=\'r\') as csvfile: reader = csv.DictReader(csvfile) for row in reader: if row[\'status\'] == \'active\': active_emails.append(row[\'email\']) return active_emails ``` Make sure to write clean and efficient code that adheres to the provided guidelines and requirements.","solution":"import csv def filter_active_users(file_path): This function processes a CSV file, filters out inactive users, and returns a list of email addresses belonging to active users. :param file_path: str, the path to the CSV file. :return: list of str, the email addresses of active users. active_emails = [] with open(file_path, mode=\'r\') as csvfile: reader = csv.DictReader(csvfile) for row in reader: if row[\'status\'] == \'active\': active_emails.append(row[\'email\']) return active_emails"},{"question":"# Fibonacci Series Generator and Sum Calculation Context You are asked to generate the first N numbers in the Fibonacci series and compute the sum of these numbers. Task 1. Implement a function, `generate_fibonacci(n: int) -> list` that generates the first N numbers in the Fibonacci series. 2. Implement a function, `sum_fibonacci(series: list) -> int` that calculates the sum of the Fibonacci series. Specifications 1. You have two functions to implement: ```python def generate_fibonacci(n: int) -> list: Generate the first N numbers of the Fibonacci series. Args: n: An integer, number of terms to generate Returns: list: A list of the first N Fibonacci numbers Raises: ValueError: If n is less than 1 def sum_fibonacci(series: list) -> int: Return the sum of the Fibonacci series. Args: series: A list of integers (Fibonacci numbers) Returns: int: The sum of the series Raises: ValueError: If input series is empty or contains non-integer values ``` Input and Output Formats * **Input**: * `n` - An integer greater than or equal to 1. * `series` - A list of integers. * **Output**: * For `generate_fibonacci`: Return a list containing the first N Fibonacci numbers. * For `sum_fibonacci`: Return the sum of the numbers in the list as an integer. Constraints * The integer n should be at least 1. Examples ```python assert generate_fibonacci(5) == [0, 1, 1, 2, 3] assert generate_fibonacci(8) == [0, 1, 1, 2, 3, 5, 8, 13] assert sum_fibonacci([0, 1, 1, 2, 3, 5, 8, 13]) == 33 assert sum_fibonacci([0, 1, 1, 2, 3, 5]) == 12 ```","solution":"def generate_fibonacci(n: int) -> list: Generate the first N numbers of the Fibonacci series. Args: n: An integer, number of terms to generate Returns: list: A list of the first N Fibonacci numbers Raises: ValueError: If n is less than 1 if n < 1: raise ValueError(\\"n must be at least 1\\") series = [] a, b = 0, 1 for _ in range(n): series.append(a) a, b = b, a + b return series def sum_fibonacci(series: list) -> int: Return the sum of the Fibonacci series. Args: series: A list of integers (Fibonacci numbers) Returns: int: The sum of the series Raises: ValueError: If input series is empty or contains non-integer values if not series or not all(isinstance(x, int) for x in series): raise ValueError(\\"Input series must be a non-empty list of integers\\") return sum(series)"},{"question":"# Question: Title: Unique Substrings Finder Write a Python function `unique_substrings(s: str, k: int) -> List[str]` that takes a string `s` and an integer `k` as input, and returns a list of all unique substrings of length `k` found within the given string `s`. Function Signature: ```python def unique_substrings(s: str, k: int) -> List[str]: ``` Input: - A string `s` (1 ≤ len(s) ≤ 10^5) - An integer `k` (1 ≤ k ≤ len(s)) Output: - A list of strings, each being a substring of length `k` from `s`. Constraints: 1. The function should handle inputs with maximum constraints efficiently. 2. Substrings should be returned in the order of their first occurrence in the original string `s`. 3. The function must handle cases where the same substring appears multiple times but only include them once in the result list. 4. If `k` is greater than the length of `s`, return an empty list. Example: ```python assert unique_substrings(\\"abacab\\", 3) == [\\"aba\\", \\"bac\\", \\"aca\\", \\"cab\\"] assert unique_substrings(\\"aaaaa\\", 2) == [\\"aa\\"] assert unique_substrings(\\"abcdef\\", 2) == [\\"ab\\", \\"bc\\", \\"cd\\", \\"de\\", \\"ef\\"] assert unique_substrings(\\"abcabc\\", 2) == [\\"ab\\", \\"bc\\", \\"ca\\"] assert unique_substrings(\\"abc\\", 4) == [] ``` Performance requirements: The function should be able to generate the list of unique substrings efficiently even for the maximum length of the string `s`. Scenario: Imagine working on a text analysis project where identifying all unique substrings of a specific length is crucial for patterns analysis. Efficiently determining these unique substrings can facilitate identifying common sequences, detecting plagiarism, or preparing data for further processing in natural language processing tasks. Ensure your function accurately extracts and lists unique substrings while adhering to the constraints specified.","solution":"from typing import List def unique_substrings(s: str, k: int) -> List[str]: if k > len(s): return [] seen = set() unique_subs = [] for i in range(len(s) - k + 1): substring = s[i:i+k] if substring not in seen: seen.add(substring) unique_subs.append(substring) return unique_subs"},{"question":"# Question You are given a list of non-negative integers where each integer represents the maximum number of steps you can jump forward from that position. Write a function to determine the minimum number of jumps required to reach the end of the list, starting from the first element. Task Write a function named `min_jumps(nums: List[int]) -> int` that takes a list of non-negative integers and returns the minimum number of jumps required to reach the end of the list. If it is not possible to reach the end, return `-1`. Input - `nums` (List[int]): A list of non-negative integers where each integer represents the maximum jump length from that position. Output - (int): The minimum number of jumps required to reach the end of the list, or `-1` if it is not possible. Constraints - `1 <= len(nums) <= 10^4` - `0 <= nums[i] <= 1000` # Example Consider the following list of integers: ``` [2, 3, 1, 1, 4] ``` The function call `min_jumps([2, 3, 1, 1, 4])` should return `2`, since the minimum number of jumps to reach the end is achieved by jumping 1 step to index 1 (value 3), and then 3 steps to the last index. If the input list is: ``` [3, 2, 1, 0, 4] ``` The function call `min_jumps([3, 2, 1, 0, 4])` should return `-1`, since it is not possible to reach the last index.","solution":"from typing import List def min_jumps(nums: List[int]) -> int: if len(nums) == 1: return 0 jumps = 0 current_jump_end = 0 farthest = 0 for i in range(len(nums) - 1): farthest = max(farthest, i + nums[i]) if i == current_jump_end: jumps += 1 current_jump_end = farthest if current_jump_end >= len(nums) - 1: break return jumps if current_jump_end >= len(nums) - 1 else -1"},{"question":"# Problem Statement You are given two non-negative integers represented as strings. Your task is to add these two numbers and return the result as a string. # Function Signature ```python def add_strings(num1: str, num2: str) -> str: pass ``` # Input - Two strings, `num1` and `num2`, representing non-negative integers (1 <= len(num1), len(num2) <= 10000). - The strings contain only digits (0-9) and do not have leading zeros except for the number \'0\' itself. # Output - A string representing the sum of `num1` and `num2`. # Example ```python assert add_strings(\\"123\\", \\"456\\") == \\"579\\" assert add_strings(\\"999\\", \\"1\\") == \\"1000\\" assert add_strings(\\"0\\", \\"0\\") == \\"0\\" ``` # Constraints - You must implement the addition without using built-in functions that directly convert the string to integers or directly perform arithmetic on large numbers. - Ensure the solution handles large inputs efficiently and correctly. # Performance - Aim for a time complexity of O(max(len(num1), len(num2))) for the addition operation. - Space complexity should be minimized, ideally O(max(len(num1), len(num2))) for the resultant string. # Context Efficiently performing arithmetic on large numbers represented as strings is a common task in various areas of computing, particularly in scenarios where the computational limits of built-in numerical types are exceeded. This problem assesses your understanding of string manipulation, numerical algorithms, and efficient handling of potentially large inputs. # Example Execution ```python add_strings(\\"123\\", \\"456\\") # Output: \\"579\\" add_strings(\\"999\\", \\"1\\") # Output: \\"1000\\" ```","solution":"def add_strings(num1: str, num2: str) -> str: Adds two numbers represented as strings and returns the result as a string. # Initialize pointers for both strings and a carry value i, j, carry = len(num1) - 1, len(num2) - 1, 0 result = [] # Loop through both strings from the end to the beginning while i >= 0 or j >= 0 or carry: # Get the current digits from the strings or 0 if out of bounds digit1 = int(num1[i]) if i >= 0 else 0 digit2 = int(num2[j]) if j >= 0 else 0 # Compute the sum of the digits and the carry total = digit1 + digit2 + carry carry = total // 10 result.append(total % 10) # Move the pointers i -= 1 j -= 1 # Convert result digits to a string and return return \'\'.join(map(str, result[::-1]))"},{"question":"# Code Challenge - Sum of Even Fibonacci Numbers You are to solve the following problem by implementing a function `sum_even_fibonacci_numbers`: Problem Description The Fibonacci sequence is defined as follows: - ( F(0) = 0 ) - ( F(1) = 1 ) - ( F(n) = F(n-1) + F(n-2) ) for ( n geq 2 ). Write a function that returns the sum of all even Fibonacci numbers up to a given limit. Function Signature ```python def sum_even_fibonacci_numbers(limit: int) -> int: ``` Input - `limit` (int): The upper bound for the Fibonacci numbers to be considered (1 ≤ limit ≤ 4,000,000). Output - Return an integer representing the sum of all even Fibonacci numbers that do not exceed the given limit. Example ```python def sum_even_fibonacci_numbers(limit: int) -> int: # Implement your solution here pass if __name__ == \\"__main__\\": print(sum_even_fibonacci_numbers(4000000)) # Expected Output: 4613732 ``` **Note**: The example output corresponds to the sum of even Fibonacci numbers less than or equal to 4,000,000. **Considerations**: - Ensure efficient calculation, minimizing the number of Fibonacci numbers generated. - The sequence will always start from 0 and 1.","solution":"def sum_even_fibonacci_numbers(limit: int) -> int: Returns the sum of all even Fibonacci numbers up to a given limit. a, b = 0, 1 sum_even = 0 while a <= limit: if a % 2 == 0: sum_even += a a, b = b, a + b return sum_even"},{"question":"# Problem Statement A company requires a function to manage employee data efficiently. Your task is to write a function that calculates the average age of employees within a given age range. The function will take a list of employee ages and a specified age range, then return the average age of employees whose ages fall within that range. If no ages fall within the specified range, the function should return 0. # Function Signature ```python def average_age(ages: List[int], lower: int, upper: int) -> float: pass ``` # Input - A list of integers `ages` representing the ages of employees (1 ≤ len(ages) ≤ 10^6, 1 ≤ ages[i] ≤ 100). - Two integers `lower` and `upper` representing the inclusive age range (1 ≤ lower ≤ upper ≤ 100). # Output - Return a float that represents the average age of employees within the specified age range. Round the result to 2 decimal places. # Constraints - Ensure the solution efficiently processes the list of ages. # Examples 1. **Example 1:** - Input: `ages = [23, 34, 45, 56, 23, 35, 40]`, `lower = 30`, `upper = 50` - Output: `38.5` - Explanation: The ages within range [30, 50] are 34, 45, 35, and 40. Average = (34 + 45 + 35 + 40) / 4 = 38.5. 2. **Example 2:** - Input: `ages = [22, 34, 46, 58, 29, 36, 41]`, `lower = 25`, `upper = 35` - Output: `31.5` - Explanation: The ages within range [25, 35] are 34 and 29. Average = (34 + 29) / 2 = 31.5. 3. **Example 3:** - Input: `ages = [15, 20, 25, 30, 35, 40]`, `lower = 50`, `upper = 60` - Output: `0` - Explanation: No ages fall within the range [50, 60]. # Performance Requirements Your solution should efficiently handle large lists of ages with linear time complexity, (O(n)), and constant space complexity, (O(1)).","solution":"from typing import List def average_age(ages: List[int], lower: int, upper: int) -> float: Calculates the average age of employees within a given age range. Parameters: ages (List[int]): List of employee ages. lower (int): The lower bound of the age range. upper (int): The upper bound of the age range. Returns: float: The average age of employees within the specified age range, rounded to 2 decimal places. If no ages fall within the range, returns 0. filtered_ages = [age for age in ages if lower <= age <= upper] if not filtered_ages: return 0.0 average = sum(filtered_ages) / len(filtered_ages) return round(average, 2)"},{"question":"# Problem Statement You are given a dictionary where the keys are string identifiers, and the values are integers that denote counts of items. Your goal is to transform this dictionary by summing up the values of keys that share a common prefix and return a new dictionary with these aggregated values. The prefix is determined by the first letter of each key. Your task is to implement the function `sum_by_prefix(d: dict[str, int]) -> dict[str, int]:` that efficiently sums up values by their prefixes. # Input Format - A single dictionary `d` with string keys and integer values. The keys represent identifiers and can contain alphanumeric characters (_i.e._, a-z, A-Z, 0-9). The values are non-negative integers (0 ≤ value ≤ 10^9). - The input dictionary may have up to 10^6 entries. # Output Format - Return a new dictionary with the first letter of the original keys as keys and the summed values as the values. # Constraints - Each key in the dictionary is a non-empty string of at most 100 characters. - Each value in the dictionary is a non-negative integer. # Example Input ```python d = { \\"apple\\": 10, \\"banana\\": 15, \\"avocado\\": 5, \\"grape\\": 10, \\"blueberry\\": 25, \\"grapefruit\\": 20 } ``` Output ```python { \\"a\\": 15, \\"b\\": 40, \\"g\\": 30 } ``` # Detailed Explanation - Keys `apple` and `avocado` share the prefix `a`, so their values (10 and 5) are summed up to get 15. - Keys `banana` and `blueberry` share the prefix `b`, so their values (15 and 25) are summed up to get 40. - Keys `grape` and `grapefruit` share the prefix `g`, so their values (10 and 20) are summed up to get 30. # Function Signature ```python from typing import Dict def sum_by_prefix(d: Dict[str, int]) -> Dict[str, int]: pass ``` # Requirements 1. You must implement the function `sum_by_prefix` to perform the aggregation efficiently, aiming for a time complexity of O(n), where n is the number of entries in the input dictionary. 2. Consider edge cases such as dictionaries with only one entry, or keys that start with uppercase and lowercase letters. Good luck!","solution":"from typing import Dict def sum_by_prefix(d: Dict[str, int]) -> Dict[str, int]: result = {} for key, value in d.items(): prefix = key[0] if prefix in result: result[prefix] += value else: result[prefix] = value return result"},{"question":"# Question: Palindrome Checker and Reverser You are given two individual tasks. Write two functions to achieve the following: Task 1: Check for Palindrome Write a function `is_palindrome(s: str) -> bool` that checks if the input string is a palindrome. A palindrome is a string that reads the same forward and backward, ignoring spaces, punctuation, and capitalization. **Input** - A string `s`. **Output** - Return `True` if the string is a palindrome, otherwise `False`. **Examples** ```python >>> is_palindrome(\\"A man, a plan, a canal, Panama!\\") True >>> is_palindrome(\\"Hello, World!\\") False >>> is_palindrome(\\"Madam, in Eden, I\'m Adam\\") True ``` Task 2: Reverse String Write a function `reverse_string(s: str) -> str` that returns the reverse of the input string. **Input** - A string `s`. **Output** - Return the reversed string. **Examples** ```python >>> reverse_string(\\"hello\\") \\"olleh\\" >>> reverse_string(\\"Able was I ere I saw Elba\\") \\"ablE was I ere I saw elbA\\" >>> reverse_string(\\"12345\\") \\"54321\\" ``` **Constraints**: - Both functions should raise a `ValueError` if the input string is empty or not a string. ```python def is_palindrome(s: str) -> bool: # your code here pass def reverse_string(s: str) -> str: # your code here pass ``` Use the following assertions to verify the correctness of your code: ```python assert is_palindrome(\\"A man, a plan, a canal, Panama!\\") == True assert is_palindrome(\\"Hello, World!\\") == False assert is_palindrome(\\"Madam, in Eden, I\'m Adam\\") == True assert reverse_string(\\"hello\\") == \\"olleh\\" assert reverse_string(\\"Able was I ere I saw Elba\\") == \\"ablE was I ere I saw elbA\\" assert reverse_string(\\"12345\\") == \\"54321\\" ```","solution":"import re def is_palindrome(s: str) -> bool: if not isinstance(s, str) or not s: raise ValueError(\\"Input must be a non-empty string\\") cleaned = re.sub(r\'[^A-Za-z0-9]\', \'\', s).lower() return cleaned == cleaned[::-1] def reverse_string(s: str) -> str: if not isinstance(s, str) or not s: raise ValueError(\\"Input must be a non-empty string\\") return s[::-1]"},{"question":"# Question: Implement a Function to Detect a Cycle in a Directed Graph **Context**: You are working on a project where you need to analyze task dependencies to identify circular dependencies. Your task is to create a function that detects if there is a cycle in a directed graph representing these dependencies. **Function Signature**: ```python def detect_cycle(graph: List[List[int]], v: int) -> bool: ``` **Input**: * `graph`: A 2D list where `graph[i]` represents the list of vertices that vertex `i` has a directed edge to. * `v`: An integer representing the number of vertices. **Output**: * Returns a boolean value: `True` if there is a cycle in the graph, and `False` otherwise. **Constraints**: * The graph is represented as an adjacency list. * The graph may have multiple components. **Performance Requirement**: * Your solution should run in O(V + E) time complexity. **Example**: ```python graph = [ [1], # Vertex 0 points to Vertex 1 [2], # Vertex 1 points to Vertex 2 [0, 3], # Vertex 2 points to Vertex 0 and Vertex 3 [] # Vertex 3 has no outgoing edges ] print(detect_cycle(graph, 4)) # Expected output: True graph = [ [1, 2], # Vertex 0 points to Vertex 1 and Vertex 2 [2], # Vertex 1 points to Vertex 2 [] # Vertex 2 has no outgoing edges ] print(detect_cycle(graph, 3)) # Expected output: False ``` **Explanation**: * In the first example, there is a cycle (0 -> 1 -> 2 -> 0) so the function should return `True`. * In the second example, there are no cycles in the graph so the function should return `False`. **Notes**: * You may use depth-first search (DFS) to detect cycles. * Consider using additional data structures to keep track of visited vertices and vertices currently in the DFS recursion stack.","solution":"from typing import List def detect_cycle(graph: List[List[int]], v: int) -> bool: def dfs(vertex, visited, rec_stack): visited[vertex] = True rec_stack[vertex] = True for neighbor in graph[vertex]: if not visited[neighbor]: if dfs(neighbor, visited, rec_stack): return True elif rec_stack[neighbor]: return True rec_stack[vertex] = False return False visited = [False] * v rec_stack = [False] * v for node in range(v): if not visited[node]: if dfs(node, visited, rec_stack): return True return False"},{"question":"# Manage Orders in Warehouse **Context**: You are tasked with developing a system to manage orders arriving at a warehouse. The system should add, remove, and display orders based on their priority. Each order consists of a unique order ID and priority level. Orders with higher priority levels should be processed before those with lower priority, but if two orders have the same priority, the one that arrived first should be processed first. **Task**: Implement an `OrderManager` class which supports the following operations: 1. `add_order(order_id: int, priority: int)`: Adds an order with the given ID and priority. 2. `remove_order(order_id: int)`: Removes the order with the given ID. If the order does not exist, do nothing. 3. `get_next_order() -> int`: Retrieves and removes the order ID of the highest-priority order. If no orders exist, return `-1`. 4. `get_all_orders() -> list`: Returns a list of all order IDs sorted by priority, with ties broken by the order of arrival. **Class Signature**: ```python class OrderManager: def __init__(self): pass def add_order(self, order_id: int, priority: int): pass def remove_order(self, order_id: int): pass def get_next_order(self) -> int: pass def get_all_orders(self) -> list: pass ``` **Input**: - `order_id` (int): A unique identifier for each order. - `priority` (int): An integer representing the order\'s priority level (higher value means higher priority). **Output**: - For `get_next_order`, return the ID of the highest-priority order, or `-1` if no orders are present. - For `get_all_orders`, return a list of order IDs sorted by priority and arrival order. **Constraints**: - Up to 100,000 orders can be added to the system. - `order_id` will always be unique. - The `priority` value can range from 0 to 100. **Examples**: ```python om = OrderManager() om.add_order(1, 2) om.add_order(2, 5) om.add_order(3, 5) om.add_order(4, 1) print(om.get_all_orders()) # Output: [2, 3, 1, 4] print(om.get_next_order()) # Output: 2 print(om.get_all_orders()) # Output: [3, 1, 4] om.remove_order(3) print(om.get_all_orders()) # Output: [1, 4] ``` **Notes**: - Use an appropriate data structure to efficiently manage orders\' addition, removal, and retrieval based on their priority and arrival time. - Consider edge cases such as removing non-existent orders and attempting to get the next order from an empty system. **Implementation Hint**: - A min-heap or a priority queue might be useful to manage and retrieve orders efficiently. **Testing**: - Ensure the implementation handles a mix of operations and correctly maintains the orders\' priorities and retrieval order.","solution":"import heapq from collections import defaultdict, deque class OrderManager: def __init__(self): self.order_map = {} # Map of order_id to (priority, arrival) self.orders_by_priority = defaultdict(deque) # Priority to deque of order_ids self.min_heap = [] # The heap storing (priority, arrival, order_id) self.next_arrival = 0 # Incremental arrival order def add_order(self, order_id: int, priority: int): if order_id not in self.order_map: self.order_map[order_id] = (priority, self.next_arrival) heapq.heappush(self.min_heap, (-priority, self.next_arrival, order_id)) self.orders_by_priority[priority].append(order_id) self.next_arrival += 1 def remove_order(self, order_id: int): if order_id in self.order_map: priority, arrival = self.order_map.pop(order_id) self.orders_by_priority[priority].remove(order_id) def get_next_order(self) -> int: while self.min_heap: priority, arrival, order_id = heapq.heappop(self.min_heap) if order_id in self.order_map and self.order_map[order_id] == (-priority, arrival): self.remove_order(order_id) return order_id return -1 def get_all_orders(self) -> list: all_orders = [] for priority in sorted(self.orders_by_priority.keys(), reverse=True): all_orders.extend(self.orders_by_priority[priority]) return all_orders"},{"question":"# Problem Statement You are given a list of `n` integers. Your task is to preprocess the array so that you can efficiently answer range queries to find the sum of all elements within a given subarray. # Functions to Implement You need to implement the following three functions: 1. `preprocess(arr: List[int]) -> List[int]`: - **Input**: - `arr`: A list of `n` integers. - **Output**: A list representing the prefix sums of the input array, where the i-th element of the output list is the sum of the first i elements of the input array. 2. `range_query(prefix_sums: List[int], left: int, right: int) -> int`: - **Input**: - `prefix_sums`: A list of prefix sums. - `left`: An integer representing the starting index of the subarray. - `right`: An integer representing the ending index of the subarray. - **Output**: An integer representing the sum of the subarray from `left` to `right`, inclusive. 3. `update(arr: List[int], prefix_sums: List[int], index: int, value: int) -> List[int]`: - **Input**: - `arr`: A list of `n` integers. - `prefix_sums`: A list of prefix sums. - `index`: The index at which the update is to be made. - `value`: The new value to be set at the specified index. - **Output**: An updated list of prefix sums after modifying the original array at the given index. # Example ```python arr = [1, 2, 3, 4, 5] prefix_sums = preprocess(arr) print(\\"Prefix Sums:\\", prefix_sums) # Output should be [1, 3, 6, 10, 15] result = range_query(prefix_sums, 1, 3) print(\\"Sum from index 1 to 3:\\", result) # Output should be 9 arr = [1, 2, 3, 4, 5] updated_prefix_sums = update(arr, prefix_sums, 2, 10) print(\\"Updated Prefix Sums:\\", updated_prefix_sums) # Output should be [1, 3, 13, 17, 22] ``` # Constraints - Ensure the prefix sums list is correctly computed. - Handle updates to the array efficiently. - The list will have `n` integers where `1 <= n <= 10^5`. # Notes - The `prepend` function should return a list such that the i-th element is the sum of the array elements from index 0 to i. - The `range_query` function should leverage the prefix sums to efficiently compute the desired sum in constant time. - The `update` function should adjust the prefix sums based on the change at the specified index, ensuring subsequent queries reflect the updated array.","solution":"from typing import List def preprocess(arr: List[int]) -> List[int]: prefix_sums = [0] * len(arr) if arr: prefix_sums[0] = arr[0] for i in range(1, len(arr)): prefix_sums[i] = prefix_sums[i - 1] + arr[i] return prefix_sums def range_query(prefix_sums: List[int], left: int, right: int) -> int: if left == 0: return prefix_sums[right] else: return prefix_sums[right] - prefix_sums[left - 1] def update(arr: List[int], prefix_sums: List[int], index: int, value: int) -> List[int]: difference = value - arr[index] arr[index] = value for i in range(index, len(arr)): prefix_sums[i] += difference return prefix_sums"},{"question":"# Coding Assessment Question Context You are developing a simple unit conversion tool for an engineering application. One essential feature is converting angles measured in degrees to their equivalent in radians. This is a foundational calculation widely used in various engineering computations. Task Implement a function `degrees_to_radians(degrees: float) -> float` that converts an angle measurement from degrees to radians. The function takes one parameter: 1. `degrees`: The angle in degrees (can be any real number). The mathematical formula for converting degrees to radians is: [ text{radians} = text{degrees} times frac{pi}{180} ] Where (pi) is approximately (3.141592653589793). Input and Output Format **Input**: * `degrees`: float - an angle in degrees. **Output**: * float - the equivalent angle in radians. Constraints * The input can be any floating-point number. * Ensure that the function handles both large and small, positive and negative values correctly. Examples ```python # Example 1 degrees = 180 degrees_to_radians(degrees) # Expected Output: 3.141592653589793 # Example 2 degrees = 45 degrees_to_radians(degrees) # Expected Output: 0.7853981633974483 # Example 3 degrees = -90 degrees_to_radians(degrees) # Expected Output: -1.5707963267948966 ``` Ensure your implementation is accurate and handles any valid degree input appropriately.","solution":"import math def degrees_to_radians(degrees: float) -> float: Converts an angle from degrees to radians. :param degrees: Angle in degrees. :returns: Equivalent angle in radians. return degrees * (math.pi / 180)"},{"question":"# Problem Statement You are required to implement a **Queue** data structure using a circular array. Implement additional functionality to support a `rear()` method that retrieves the last element in constant time. # Requirements 1. **Implementation Details**: - The queue should be implemented as a class `Queue` using a circular array (list in Python). - The array should have a fixed maximum size defined during initialization. 2. **Functional Requirements**: Implement the following methods: - `enqueue(self, data: T) -> None`: Adds an element to the end of the queue. - `dequeue(self) -> T | None`: Removes and returns the element from the front of the queue. - `front(self) -> T | None`: Returns the element at the front of the queue without removing it. - `rear(self) -> T | None`: Returns the element at the rear of the queue without removing it. - `is_empty(self) -> bool`: Returns `True` if the queue is empty, `False` otherwise. - `is_full(self) -> bool`: Returns `True` if the queue is full, `False` otherwise. - `__len__(self) -> int`: Returns the number of elements in the queue in O(1) time. # Input/Output Formats - The `enqueue` method should accept a data element of any type `T`. - The `dequeue`, `front`, and `rear` methods should return an element of type `T` or `None` if the queue is empty. - The `is_empty` and `is_full` methods should return a boolean value. - The `__len__` method should return an integer representing the number of elements in the queue. # Constraints - Ensure that the queue handles wrap-around correctly since it\'s implemented as a circular array. - The `__len__` method should operate in O(1) time complexity using an auxiliary variable. # Example Usage ```python queue = Queue(3) print(queue.is_empty()) # Output: True queue.enqueue(1) queue.enqueue(2) queue.enqueue(3) print(queue.is_full()) # Output: True print(len(queue)) # Output: 3 print(queue.front()) # Output: 1 print(queue.rear()) # Output: 3 print(queue.dequeue()) # Output: 1 queue.enqueue(4) print(queue.front()) # Output: 2 print(queue.rear()) # Output: 4 print(len(queue)) # Output: 3 print(queue.is_full()) # Output: True print(queue.is_empty()) # Output: False ``` # Additional Notes - You may assume any necessary imports and class definitions are provided. - The `__init__` method should initialize the queue with a fixed size and all elements set to `None`. - Handle edge cases such as operations on an empty or full queue. - Do not use any external Python libraries except for built-in types. This novel problem maintains the style, complexity, and scope of the initial stack question, introducing a new data structure (Queue) while ensuring comparable computational challenges and constraints.","solution":"from typing import Any, Optional class Queue: def __init__(self, max_size: int): self.max_size = max_size self.queue = [None] * max_size self.front_index = 0 self.rear_index = -1 self.size = 0 def enqueue(self, data: Any) -> None: if self.is_full(): raise Exception(\\"Queue is full\\") self.rear_index = (self.rear_index + 1) % self.max_size self.queue[self.rear_index] = data self.size += 1 def dequeue(self) -> Optional[Any]: if self.is_empty(): return None data = self.queue[self.front_index] self.queue[self.front_index] = None self.front_index = (self.front_index + 1) % self.max_size self.size -= 1 return data def front(self) -> Optional[Any]: if self.is_empty(): return None return self.queue[self.front_index] def rear(self) -> Optional[Any]: if self.is_empty(): return None return self.queue[self.rear_index] def is_empty(self) -> bool: return self.size == 0 def is_full(self) -> bool: return self.size == self.max_size def __len__(self) -> int: return self.size"},{"question":"# Anagram Difference Calculation You are tasked with implementing a function that calculates the minimum number of character deletions required to make two strings anagrams of each other. An anagram of a string is another string that contains the same characters, only the order of characters can be different. You need to write a function that takes two strings and returns an integer representing the number of deletions needed. # Function Signature ```python def anagram_difference(str1: str, str2: str) -> int: pass ``` # Input * `str1` (str): A string containing only lowercase alphabetical characters. * `str2` (str): A string containing only lowercase alphabetical characters. # Output * `result` (int): The minimum number of deletions required to make the two strings anagrams. # Constraints 1. Both strings will contain only lowercase alphabetical characters. 2. The length of each string will be in the range [1, 10^5]. # Example ```python print(anagram_difference(\\"abccde\\", \\"cabfd\\")) # Output: 3 print(anagram_difference(\\"abcdef\\", \\"fghijk\\")) # Output: 10 print(anagram_difference(\\"listen\\", \\"silent\\")) # Output: 0 ``` # Additional Info 1. **Explanation**: * In the first example, the characters required to be deleted from \\"abccde\\" are \'c\' and \'e\' (or delete \'d\' and one \'c\' from either side), and from \\"cabfd\\" are \'f\'. Thus, 3 deletions are needed. * In the second example, characters required to be deleted from \\"abcdef\\" are all characters of \\"fghijk\\". Thus, 6 (from \\"abcdef\\") + 4 (from \\"fghijk\\") = 10 deletions are needed. * In the third example, \\"listen\\" and \\"silent\\" are already anagrams, so no deletions are needed. Implement the function `anagram_difference` to achieve this functionality and ensure efficiency given the constraints.","solution":"from collections import Counter def anagram_difference(str1: str, str2: str) -> int: Returns the minimum number of character deletions required to make two strings anagrams of each other. # Count the frequency of characters in both strings counter1 = Counter(str1) counter2 = Counter(str2) # Find characters that are in str1 but not in str2 and vice versa, or those with different frequencies counter1.subtract(counter2) # The total deletions needed will be the sum of absolute values in the counter deletions = sum(abs(count) for count in counter1.values()) return deletions"},{"question":"# Coding Assessment Question **Background**: Graphs are a fundamental data structure in computer science, used to model pairwise relationships between objects. Breadth-First Search (BFS) is an algorithm for traversing or searching tree or graph data structures. It starts at an arbitrary node (considered as the root) and explores the neighbor nodes at the present depth level before moving on to nodes at the next depth level. **Task**: Write a function `bfs_path` in Python that performs a Breadth-First Search on a graph to find the shortest path between two given nodes. The graph is represented as an adjacency list, a dictionary where each key is a node and the corresponding value is a list of neighboring nodes. # Requirements: 1. **Function Signature**: ```python def bfs_path(graph: Dict[int, List[int]], start: int, goal: int) -> List[int]: ``` 2. **Input**: - `graph` (Dict[int, List[int]]): An adjacency list representing the graph. - `start` (int): The starting node for the BFS. - `goal` (int): The goal node to find the path to. 3. **Output**: - `List[int]`: The shortest path from `start` to `goal` as a list of nodes. If no path exists, return an empty list. 4. **Constraints**: - The graph is connected and undirected. - Node values are unique positive integers. - It is guaranteed that the graph has at least one node. 5. **Performance**: - The solution should have a time complexity of O(V + E) and space complexity of O(V), where V is the number of vertices and E is the number of edges in the graph. # Example: ```python graph = { 1: [2, 3], 2: [1, 4, 5], 3: [1, 6, 7], 4: [2], 5: [2], 6: [3], 7: [3] } start = 1 goal = 5 print(bfs_path(graph, start, goal)) # Expected output: [1, 2, 5] ``` # Notes: - Ensure your function correctly handles cases where the start and goal nodes are the same. - Write comprehensive test cases to check for edge cases where the graph has only one node or where there are multiple shortest paths.","solution":"from collections import deque from typing import Dict, List def bfs_path(graph: Dict[int, List[int]], start: int, goal: int) -> List[int]: if start == goal: return [start] queue = deque([(start, [start])]) visited = set() visited.add(start) while queue: current_node, path = queue.popleft() for neighbor in graph.get(current_node, []): if neighbor not in visited: if neighbor == goal: return path + [neighbor] queue.append((neighbor, path + [neighbor])) visited.add(neighbor) return []"},{"question":"# Scenario You are a software engineer working on image processing. Your current task involves manipulating pixel values of an image to alter its appearance. Specifically, you need to adjust the brightness of the image by a given factor, while ensuring that the pixel values remain within valid bounds. # Problem Statement Write a function `adjust_brightness(image: List[List[int]], factor: float) -> List[List[int]]` that takes a 2D list representing the pixel values of an image and a brightness adjustment factor. The function should return a new 2D list where each pixel value is multiplied by the factor, with all pixel values clamped to the range `[0, 255]`. # Function Signature ```python def adjust_brightness(image: List[List[int]], factor: float) -> List[List[int]]: ``` # Input * `image` (List[List[int]]): A 2D list of integers, where each integer represents a pixel value and is in the range `[0, 255]`. * `factor` (float): A floating-point number representing the brightness adjustment factor. # Output * A 2D list of integers with adjusted pixel values, clamped to the range `[0, 255]`. # Constraints 1. All pixel values in `image` are within the range `[0, 255]`. 2. `image` is not empty and contains at most `10^6` pixels. 3. `factor` is a non-negative float. # Examples ```python assert adjust_brightness([[100, 150, 200], [ 50, 80, 120]], 1.2) == [[120, 180, 240], [60, 96, 144]] assert adjust_brightness([[0, 255], [128, 128]], 0.5) == [[0, 127], [64, 64]] assert adjust_brightness([[10, 20, 30], [40, 50, 60]], 0.0) == [[0, 0, 0], [0, 0, 0]] ``` # Note * Ensure to handle edge cases where multiplying pixel values might exceed `255` or fall below `0` after clamping. * You should process the image efficiently for the maximum input constraints. # Additional Context When adjusting the brightness, ensure that each pixel value is correctly clamped to remain between `0` and `255` after the adjustment is applied. This will ensure the image remains valid for display.","solution":"from typing import List def adjust_brightness(image: List[List[int]], factor: float) -> List[List[int]]: def clamp(value: int) -> int: return max(0, min(255, value)) adjusted_image = [] for row in image: adjusted_row = [clamp(int(pixel * factor)) for pixel in row] adjusted_image.append(adjusted_row) return adjusted_image"},{"question":"# Question: Find the Missing Number in an Arithmetic Progression Background: In competitive programming, it\'s common to work with sequences and number series. Arithmetic Progression (AP) is a sequence of numbers with the difference between consecutive terms being constant. Given an AP with one number missing, determining the missing number efficiently can be crucial in solving various computational problems. Problem Statement: Write a function `find_missing_number` which takes a list of numbers representing an arithmetic progression with exactly one term missing, and returns the missing number. Function Signature: ```python def find_missing_number(ap_sequence: list) -> int: pass ``` Input: * A list `ap_sequence` of length `n` which represents an arithmetic progression with one term missing. The list is guaranteed to have at least 2 elements and at most 1000 elements. Output: * An integer representing the missing number in the arithmetic progression input list. Constraints: * The given list always represents a valid arithmetic progression with exactly one number missing. * The missing number is guaranteed to be within the original span of the sequence before the number was removed. Performance Requirements: * The function should run efficiently with respect to the input size. Example: ```python assert find_missing_number([1, 3, 5, 9, 11]) == 7 assert find_missing_number([2, 4, 6, 10]) == 8 assert find_missing_number([5, 10, 15, 25]) == 20 ``` Explanation: 1. In the first example, the sequence should be [1, 3, 5, 7, 9, 11], missing number is 7. 2. In the second example, the sequence should be [2, 4, 6, 8, 10], missing number is 8. 3. In the third example, the sequence should be [5, 10, 15, 20, 25], missing number is 20. Edge Cases: 1. **Minimum Length**: The sequence should always have at least two elements (minimum valid input). Additional Notes: 1. If the input list does not represent a valid arithmetic progression or has more than one term missing, the function should raise a `ValueError` with the message \\"Invalid arithmetic progression input\\". 2. The function should handle both positive and negative integers in the sequence. Write comprehensive test cases to validate your implementation.","solution":"def find_missing_number(ap_sequence: list) -> int: n = len(ap_sequence) # Calculate the common difference, assuming the missing number isn\'t at the very start or end total_sum = (n + 1) * (ap_sequence[0] + ap_sequence[-1]) // 2 actual_sum = sum(ap_sequence) # Missing number is the difference between expected sum of complete AP and actual sum of given AP missing_number = total_sum - actual_sum return missing_number"},{"question":"# Parantheses Matching You are tasked with writing a Python function that verifies whether the parentheses in an input string are properly matched. The function should handle three types of parentheses: round `()`, square `[]`, and curly `{}`. Input - A single input string that can contain any printable ASCII characters. Output - The function should return a boolean value indicating whether the parentheses in the string are matched correctly. Constraints - The input string length will be between 1 and 10,000 characters (inclusive). Example Input: `\\"([{}])\\"` Output: `True` Input: `\\"([{}]))\\"` Output: `False` Input: `\\"([)]\\"` Output: `False` Input: `\\"({[a+b]*c}/d)\\"` Output: `True` Implementation Requirements - The function should be named `are_parentheses_balanced(s: str) -> bool`. ```python def are_parentheses_balanced(s: str) -> bool: stack = [] opening = {\'(\': \')\', \'[\': \']\', \'{\': \'}\'} closing = {\')\': \'(\', \']\': \'[\', \'}\': \'{\'} for char in s: if char in opening: stack.append(char) elif char in closing: if not stack or stack[-1] != closing[char]: return False stack.pop() return len(stack) == 0 # You can test your function by calling # print(are_parentheses_balanced(\\"([{}])\\")) # True # print(are_parentheses_balanced(\\"([{}]))\\")) # False # print(are_parentheses_balanced(\\"([)]\\")) # False # print(are_parentheses_balanced(\\"({[a+b]*c}/d)\\")) # True ```","solution":"def are_parentheses_balanced(s: str) -> bool: stack = [] opening = {\'(\': \')\', \'[\': \']\', \'{\': \'}\'} closing = {\')\': \'(\', \']\': \'[\', \'}\': \'{\'} for char in s: if char in opening: stack.append(char) elif char in closing: if not stack or stack[-1] != closing[char]: return False stack.pop() return len(stack) == 0"},{"question":"# Problem: Implement a Trie for Efficient String Matching with Wildcards **Context**: You are provided with a class `Trie` that models a simple trie data structure used for efficient storage and retrieval of strings. Your task is to extend and implement this model to support string matching with wildcard characters. **Problem Statement**: Extend the `Trie` class to support the insertion of strings and implement a function `search_with_wildcards` which can retrieve whether a given pattern (containing wildcards) exists in the trie. The wildcard character is `\'*\'`, which stands for zero or more of any character. # Requirements * **Class Extension**: Extend `Trie` to `WildcardTrie`. * Implement string insertion with the method `insert(word: str) -> None`. * Implement a search with wildcards using the method `search_with_wildcards(pattern: str) -> bool`. - `\'*\'` can represent zero or more of any character. # Example ```python wildcard_trie = WildcardTrie() wildcard_trie.insert(\\"apple\\") wildcard_trie.insert(\\"app\\") wildcard_trie.insert(\\"application\\") wildcard_trie.insert(\\"apply\\") # Exact matches print(wildcard_trie.search_with_wildcards(\\"app\\")) # Should return True print(wildcard_trie.search_with_wildcards(\\"apple\\")) # Should return True print(wildcard_trie.search_with_wildcards(\\"appl\\")) # Should return False # Wildcard matches print(wildcard_trie.search_with_wildcards(\\"a*e\\")) # Should return True, matches \\"apple\\" print(wildcard_trie.search_with_wildcards(\\"*lication\\")) # Should return True, matches \\"application\\" print(wildcard_trie.search_with_wildcards(\\"ap*ly\\")) # Should return True, matches \\"apply\\" print(wildcard_trie.search_with_wildcards(\\"a**\\")) # Should return True, matches \\"app\\", \\"apple\\", \\"application\\", \\"apply\\" ``` # Constraints * The Trie should be case-sensitive. * Only lowercase letters will be used for strings and patterns. * Handle edge cases where the pattern is only wildcards or an empty string. **Note**: Care should be taken to optimize the search with wildcards to prevent excessive computation time. Ensure the solution leverages the strengths of the trie data structure. --- This problem requires understanding of advanced data structures (Trie) and efficient pattern matching algorithms. The implementation should reflect a clear handling of wildcard scenarios while maintaining optimal search performance.","solution":"class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False class WildcardTrie: def __init__(self): self.root = TrieNode() def insert(self, word: str) -> None: Insert a word into the trie. node = self.root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.is_end_of_word = True def search_with_wildcards(self, pattern: str) -> bool: Search for a pattern in the trie where \'*\' can represent zero or more of any character. def search(node, i): if i == len(pattern): return node.is_end_of_word if pattern[i] == \'*\': # Try advancing the pattern by moving to the next character in the word or keep *\'s place for child in node.children: if search(node.children[child], i) or search(node.children[child], i + 1): return True return search(node, i + 1) else: if pattern[i] in node.children: return search(node.children[pattern[i]], i + 1) else: return False return search(self.root, 0)"},{"question":"Circular Queue Implementation Create a class `CircularQueue` which implements a circular queue data structure. This class should support the following operations: enqueue, dequeue, peek, and is_empty. The goal is to manage the items in a queue with circular indexing to enable efficient memory use. # Class Signature ```python class CircularQueue: def __init__(self, capacity: int): pass def enqueue(self, value: int) -> bool: pass def dequeue(self) -> int: pass def peek(self) -> int: pass def is_empty(self) -> bool: pass ``` # Input 1. `capacity` (in `__init__`): An integer specifying the maximum number of elements the queue can hold before wrapping around. 2. `value` (in `enqueue`): An integer value to be added to the queue. # Output * `enqueue`: - Returns `True` if the value was successfully added to the queue, `False` if the queue is full. * `dequeue`: - Returns the integer value removed from the front of the queue. If the queue is empty, return `-1`. * `peek`: - Returns the integer value at the front of the queue without removing it. If the queue is empty, return `-1`. * `is_empty`: - Returns `True` if the queue is empty, `False` otherwise. # Constraints * `capacity` will be a positive integer. * `value` will be an integer within a range reasonable for typical integer operations in Python. # Example ```python cq = CircularQueue(3) print(cq.is_empty()) # Output: True print(cq.enqueue(1)) # Output: True print(cq.enqueue(2)) # Output: True print(cq.enqueue(3)) # Output: True print(cq.enqueue(4)) # Output: False (queue is full) print(cq.peek()) # Output: 1 print(cq.dequeue()) # Output: 1 print(cq.peek()) # Output: 2 print(cq.dequeue()) # Output: 2 print(cq.dequeue()) # Output: 3 print(cq.dequeue()) # Output: -1 (queue is empty) print(cq.is_empty()) # Output: True ``` # Note 1. Your implementation should handle the queue wrap-around efficiently. 2. Test your implementation thoroughly with edge cases and various capacities to ensure correctness and performance.","solution":"class CircularQueue: def __init__(self, capacity: int): self.capacity = capacity self.queue = [None] * capacity self.front = -1 self.rear = -1 def enqueue(self, value: int) -> bool: if (self.rear + 1) % self.capacity == self.front: return False # Queue is full if self.front == -1: self.front = 0 self.rear = 0 else: self.rear = (self.rear + 1) % self.capacity self.queue[self.rear] = value return True def dequeue(self) -> int: if self.front == -1: return -1 # Queue is empty value = self.queue[self.front] if self.front == self.rear: self.front = -1 self.rear = -1 else: self.front = (self.front + 1) % self.capacity return value def peek(self) -> int: if self.front == -1: return -1 # Queue is empty return self.queue[self.front] def is_empty(self) -> bool: return self.front == -1"},{"question":"Video Streaming Bandwidth Calculator Background You are working on optimizing the bandwidth utilization for a video streaming platform. The platform supports multiple quality levels for the videos, each defined by a specific bit rate. To ensure optimal streaming experience, you need a tool to dynamically calculate the total required bandwidth given a list of currently streaming videos with their respective quality levels. Task Implement a function `calculate_total_bandwidth` that computes the total bandwidth used based on the provided list of video streams and their quality levels. The function should also support adding and removing quality levels with their respective bit rates. Requirements 1. Define two dictionaries: * `base_quality_levels` which stores predefined quality levels and their bit rates (e.g., \'480p\': 1.5 Mbps, \'720p\': 3 Mbps). * `custom_quality_levels` which can store dynamically added quality levels and bit rates. 2. Implement the function `calculate_total_bandwidth` such that: * It calculates the total bandwidth required for the provided list of streams and their quality levels using both `base_quality_levels` and `custom_quality_levels`. * It allows adding new quality levels with their bit rates to the `custom_quality_levels`. * It provides an option to remove an existing quality level from `custom_quality_levels`. Function Signature ```python def calculate_total_bandwidth(operation: str, streams: list = None, quality_level: str = None, bit_rate: float = None) -> float: ``` Parameters * `operation` (str): One of \\"calculate\\", \\"add\\", or \\"remove\\". * `streams` (list): A list of tuples where each tuple contains a video and its quality level (applicable for \\"calculate\\" operation). * `quality_level` (str): The quality level to be added or removed. * `bit_rate` (float): The bit rate in Mbps to be specified for \\"add\\" operation. Constraints * Valid operations include \\"calculate\\", \\"add\\", and \\"remove\\". * When `operation` is \\"calculate\\", `streams` must be a non-empty list of tuples, with each tuple containing a quality level from the predefined or custom quality levels. * When `operation` is \\"add\\", `quality_level` must be a new quality level and `bit_rate` must be a positive float. * When `operation` is \\"remove\\", it should only be applicable for entries in `custom_quality_levels`. * Raise appropriate errors for unsupported quality levels and invalid operations. Example Usage ```python # Base quality levels base_quality_levels = { \'480p\': 1.5, \'720p\': 3.0, \'1080p\': 5.0 } # Calculate bandwidth for a list of streams using base quality levels streams_list = [(\'video1\', \'480p\'), (\'video2\', \'720p\'), (\'video3\', \'1080p\')] result = calculate_total_bandwidth(\\"calculate\\", streams_list) print(result) # Output: 9.5 Mbps # Add a new quality level \'1440p\' with a bit rate of 8 Mbps. calculate_total_bandwidth(\\"add\\", quality_level=\\"1440p\\", bit_rate=8.0) # Recalculate the bandwidth with the new quality level included in streams. streams_list.append((\'video4\', \'1440p\')) result = calculate_total_bandwidth(\\"calculate\\", streams_list) print(result) # Output: 17.5 Mbps # Remove the \'1440p\' quality level calculate_total_bandwidth(\\"remove\\", quality_level=\\"1440p\\") ``` Your task is to implement the function `calculate_total_bandwidth` according to the provided requirements and example usage.","solution":"# Base quality levels (fixed) base_quality_levels = { \'480p\': 1.5, \'720p\': 3.0, \'1080p\': 5.0 } # Custom quality levels (can be modified at runtime) custom_quality_levels = {} def calculate_total_bandwidth(operation: str, streams: list = None, quality_level: str = None, bit_rate: float = None) -> float: Calculate total bandwidth, add, or remove quality levels. Parameters: - operation (str): One of \\"calculate\\", \\"add\\", or \\"remove\\". - streams (list): A list of tuples where each tuple contains a video and its quality level (for \\"calculate\\"). - quality_level (str): The quality level to be added or removed. - bit_rate (float): The bit rate in Mbps to be specified for \\"add\\" operation. Returns: - float: Total bandwidth for \\"calculate\\" operation. if operation == \\"calculate\\": if streams is None or not isinstance(streams, list) or len(streams) == 0: raise ValueError(\\"Streams must be a non-empty list for calculate operation.\\") total_bandwidth = 0.0 for video, quality in streams: if quality in base_quality_levels: total_bandwidth += base_quality_levels[quality] elif quality in custom_quality_levels: total_bandwidth += custom_quality_levels[quality] else: raise ValueError(f\\"Unsupported quality level: {quality}\\") return total_bandwidth elif operation == \\"add\\": if quality_level is None or bit_rate is None: raise ValueError(\\"Both quality_level and bit_rate must be specified for add operation.\\") if not isinstance(bit_rate, (int, float)) or bit_rate <= 0: raise ValueError(\\"Bit rate must be a positive number.\\") if quality_level in base_quality_levels or quality_level in custom_quality_levels: raise ValueError(f\\"Quality level \'{quality_level}\' already exists.\\") custom_quality_levels[quality_level] = bit_rate elif operation == \\"remove\\": if quality_level is None: raise ValueError(\\"Quality level must be specified for remove operation.\\") if quality_level not in custom_quality_levels: raise ValueError(f\\"Quality level \'{quality_level}\' does not exist in custom quality levels.\\") del custom_quality_levels[quality_level] else: raise ValueError(\\"Unsupported operation: must be \'calculate\', \'add\', or \'remove\'.\\") return 0.0 # Default return for add and remove operations"},{"question":"# Coding Assessment Question Context: You are involved in developing a feature to analyze and merge overlapping intervals. Given a list of intervals, each represented as a tuple (start, end), you need to implement a solution that merges all overlapping intervals and returns a list of merged intervals. Task: 1. Implement a function `merge_intervals(intervals: list[tuple[int, int]]) -> list[tuple[int, int]]` that takes a list of intervals and returns a list of merged intervals. 2. Ensure that the intervals are merged such that no two intervals in the returned list overlap. Constraints: * The intervals are given as a list of tuples where each tuple consists of two integers (start, end) with start <= end. * The intervals may not be sorted. * Your solution should handle up to 10,000 intervals. * Optimize for both time and space efficiency. Example Input and Output: ```python >>> merge_intervals([(1, 3), (2, 4), (5, 7), (6, 8)]) [(1, 4), (5, 8)] >>> merge_intervals([(1, 10), (2, 6), (8, 10), (15, 18)]) [(1, 10), (15, 18)] >>> merge_intervals([(1, 2), (2, 3), (3, 4)]) [(1, 4)] ``` Notes: * Ensure the function handles cases where there are no intervals or only one interval. * The function should handle large numbers and efficiently merge a large list of intervals. * Ensure that the result list is sorted by the start of each interval. This question aligns with the existing set by requiring a blend of algorithmic problem-solving and efficiency in handling potentially large input sizes.","solution":"def merge_intervals(intervals): Merges overlapping intervals. Args: intervals (list[tuple[int, int]]): A list of intervals as tuples (start, end) Returns: list[tuple[int, int]]: A list of merged intervals. if not intervals: return [] # Sort intervals based on the starting time intervals.sort(key=lambda x: x[0]) merged = [intervals[0]] for current in intervals[1:]: last_merged = merged[-1] if current[0] <= last_merged[1]: # There is overlap, so merge the current interval merged[-1] = (last_merged[0], max(last_merged[1], current[1])) else: # No overlap, so add the current interval to the merged list merged.append(current) return merged"},{"question":"# Problem Statement Suppose you are designed a program that acts as a simple text editor. One of the operations allowed is to select all occurrences of a given substring within a text and replace them with another substring. Your goal is to implement such a function that performs this replacement accurately and efficiently. # Enhanced Requirements 1. Implement a function that finds all occurrences of the given substring `old` in the original `text` and replaces them with `new`. 2. Ensure that overlapping occurrences are properly handled. 3. Handle edge cases such as empty strings for `old` and `new`, and ensure the function does not get into infinite loops. 4. Your function should maintain the original order and integrity of the string. # Function Signature ```python def replace_substring(text: str, old: str, new: str) -> str: pass ``` # Expected Input and Output * **Input**: * A string `text` (0 <= len(text) <= 10^6) - The original text where replacements will be made. * A string `old` (0 <= len(old) <= 10^5) - The substring to be replaced. * A string `new` (0 <= len(new) <= 10^5) - The substring to replace with. * **Output**: * A string representing `text` where all occurrences of `old` have been replaced by `new`. * **Constraints**: * All input strings will contain ASCII characters only. * If `old` is an empty string, the function should return the original `text` unchanged. # Performance Requirements * The solution must be capable of handling the input within reasonable time limits, taking into consideration memory consumption and efficiency. # Example Usage ```python assert replace_substring(\\"the cat sat on the mat\\", \\"cat\\", \\"dog\\") == \\"the dog sat on the mat\\" assert replace_substring(\\"hello world\\", \\"o\\", \\"oo\\") == \\"helloo woorld\\" assert replace_substring(\\"aaaaaa\\", \\"aa\\", \\"a\\") == \\"aaa\\" assert replace_substring(\\"ababab\\", \\"ab\\", \\"ba\\") == \\"bababa\\" assert replace_substring(\\"text without old substring\\", \\"xyz\\", \\"abc\\") == \\"text without old substring\\" assert replace_substring(\\"empty old\\", \\"\\", \\"new\\") == \\"empty old\\" ``` # Hints 1. Utilize string methods effectively to identify and replace substrings. 2. Keep track of positions to avoid overlapping replacements. 3. Consider edge cases where the `old` substring might be at the start, end, or appear multiple times consecutively.","solution":"def replace_substring(text: str, old: str, new: str) -> str: Replaces all occurrences of the substring `old` within `text` with the substring `new`. if not old: return text # If old is an empty string, return the original text unchanged. return text.replace(old, new)"},{"question":"# Coding Question Context A programming competition is taking place, and participants are given a list of tasks with varying difficulties. Each task can be solved by a participant if their skill level matches or exceeds the difficulty level of the task. The objective is to maximize the number of tasks that can be assigned to participants such that each participant gets only one task. In this problem, you will write a program to determine the maximum number of tasks that can be distributed to participants based on their skill levels and task difficulties. Task You need to implement a function to solve this task distribution problem. 1. **max_tasks(skill_levels: list[int], task_difficulties: list[int]) -> int**: * This function should return the maximum number of tasks that can be assigned to participants. Input and Output Formats * `max_tasks`: * Input: Two lists of integers: `skill_levels` and `task_difficulties`, where `skill_levels[i]` represents the skill level of the i-th participant, and `task_difficulties[j]` represents the difficulty of the j-th task. * Output: An integer representing the maximum number of tasks that can be assigned to participants. Performance Requirements Ensure that your solution is efficient enough to handle lists with a length of up to 10^6 elements. Constraints * 1 ≤ len(skill_levels), len(task_difficulties) ≤ 10^6 * 1 ≤ skill_levels[i], task_difficulties[j] ≤ 10^6 Example ```python # Test case assert max_tasks([3, 4, 2, 1], [2, 2, 3, 4]) == 3 assert max_tasks([1, 1, 1], [3, 3, 3]) == 0 assert max_tasks([4, 5, 6], [2, 3, 4, 5, 6]) == 3 ``` In the first case, the optimal assignment is: - Participant with skill level 3 -> Task with difficulty 2 - Participant with skill level 4 -> Task with difficulty 3 - Participant with skill level 2 -> Task with difficulty 2 In the second case, no participant has the required skill level to solve any task. In the third case, the optimal assignment is: - Participant with skill level 4 -> Task with difficulty 2 - Participant with skill level 5 -> Task with difficulty 3 - Participant with skill level 6 -> Task with difficulty 4 Thus, the maximum number of tasks assigned is 3.","solution":"def max_tasks(skill_levels, task_difficulties): Returns the maximum number of tasks that can be assigned to participants based on their skill levels and task difficulties. skill_levels.sort() task_difficulties.sort() i = j = 0 max_assignments = 0 # Iterate through both lists to find assignable tasks while i < len(skill_levels) and j < len(task_difficulties): if skill_levels[i] >= task_difficulties[j]: max_assignments += 1 i += 1 j += 1 else: i += 1 return max_assignments"},{"question":"# Binary Tree Mirroring Context Mirroring a binary tree involves creating a new binary tree that is the mirror image of the original binary tree. This means that the left and right children of all non-leaf nodes are swapped. Your task is to implement a function that mirrors a given binary tree. The function should return the root of the mirrored binary tree. Task Implement a function `mirror_tree(root: TreeNode) -> TreeNode` where `TreeNode` is a class representing the nodes of a binary tree. This class has three attributes: `val`, `left`, and `right`. Input and Output Formats * **Input**: A binary tree represented as its root node `root`. * **Output**: The root node of the mirrored binary tree. Constraints * The number of nodes in the binary tree will be at most 1000. * The value of each node will be between -10^5 and 10^5. * A node might not have any children (it can be a leaf node). Example ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def mirror_tree(root: TreeNode) -> TreeNode: >>> a = TreeNode(1) >>> b = TreeNode(2) >>> c = TreeNode(3) >>> a.left = b >>> a.right = c >>> mirrored_root = mirror_tree(a) >>> mirrored_root.val 1 >>> mirrored_root.left.val 3 >>> mirrored_root.right.val 2 pass ``` Requirements * The function should modify the tree in place if possible. * The algorithm should run with a time complexity of O(n), where n is the number of nodes in the binary tree.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def mirror_tree(root: TreeNode) -> TreeNode: Mirrors the binary tree rooted at `root`. Args: root (TreeNode): The root node of the binary tree. Returns: TreeNode: The root node of the mirrored binary tree. if root is None: return None # Swap the left and right children root.left, root.right = root.right, root.left # Recursively mirror the subtrees mirror_tree(root.left) mirror_tree(root.right) return root"},{"question":"# Problem Statement You are tasked with enhancing a Binary Tree with several advanced functionalities. The provided implementation includes basic construction and traversal methods. Your goal is to add more sophisticated operations to further manipulate and analyze the tree data structure. # Requirements 1. Implement a function `is_balanced` that checks if a binary tree is height-balanced. In a height-balanced binary tree, the depths of the two subtrees of every node never differ by more than one. 2. Implement a function `find_lowest_common_ancestor` that determines the lowest common ancestor (LCA) for two given nodes in the binary tree. 3. Implement a function `path_sum` that determines if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum. # Provided Code You have the `Node` and `BinaryTree` classes with basic functionalities. You will need to extend the `BinaryTree` class with additional methods. # Function Signatures ```python def is_balanced(self) -> bool: pass def find_lowest_common_ancestor(self, node1: Node, node2: Node) -> Node: pass def path_sum(self, target_sum: int) -> bool: pass ``` # Input and Output Formats * **is_balanced**: - **Input**: No additional input. - **Output**: Boolean indicating if the tree is balanced. * **find_lowest_common_ancestor**: - **Input**: Two nodes within the tree. - **Output**: The node representing the lowest common ancestor. * **path_sum**: - **Input**: An integer representing the target sum. - **Output**: Boolean indicating if such a path exists. # Constraints 1. Your solution should handle large binary trees efficiently. 2. Consider edge cases like empty trees, trees with only one node, and unbalanced trees. 3. Ensure that for `find_lowest_common_ancestor`, both nodes are guaranteed to be present in the tree. 4. Assume the Binary Tree contains integer values for `path_sum`. # Scenario Jane is a data scientist working with hierarchical data structures represented by binary trees. She needs to ensure the tree is balanced for optimized performance, find common ancestors for certain queries, and check for specific value paths for her analysis. Implement the functions to assist Jane in her tasks. # Usage Example ```python binary_tree = BinaryTree() nodes = [10, 5, 15, 3, 7, 13, 17] for value in nodes: binary_tree.insert(value) print(binary_tree.is_balanced()) # Output: True node1 = binary_tree.find_node(3) node2 = binary_tree.find_node(15) print(binary_tree.find_lowest_common_ancestor(node1, node2)) # Output: 10 target_sum = 22 print(binary_tree.path_sum(target_sum)) # Output: True (Path: 10 -> 5 -> 7) ``` To implement the `is_balanced`, `find_lowest_common_ancestor`, and `path_sum` methods, add them to your `BinaryTree` class accordingly and test them with the provided scenarios.","solution":"class Node: def __init__(self, value): self.value = value self.left = None self.right = None class BinaryTree: def __init__(self): self.root = None def insert(self, value): if self.root is None: self.root = Node(value) else: self._insert(value, self.root) def _insert(self, value, current_node): if value < current_node.value: if current_node.left is None: current_node.left = Node(value) else: self._insert(value, current_node.left) else: if current_node.right is None: current_node.right = Node(value) else: self._insert(value, current_node.right) def find_node(self, value): return self._find_node(value, self.root) def _find_node(self, value, current_node): if current_node is None: return None elif current_node.value == value: return current_node elif value < current_node.value: return self._find_node(value, current_node.left) else: return self._find_node(value, current_node.right) def is_balanced(self): def check_height(node): if node is None: return 0 left_height = check_height(node.left) if left_height == -1: return -1 right_height = check_height(node.right) if right_height == -1: return -1 if abs(left_height - right_height) > 1: return -1 return max(left_height, right_height) + 1 return check_height(self.root) != -1 def find_lowest_common_ancestor(self, node1, node2): def lca_helper(node, node1, node2): if node is None or node == node1 or node == node2: return node left = lca_helper(node.left, node1, node2) right = lca_helper(node.right, node1, node2) if left and right: return node return left if left else right return lca_helper(self.root, node1, node2) def path_sum(self, target_sum): def has_path_sum(node, current_sum): if node is None: return False current_sum += node.value if node.left is None and node.right is None: return current_sum == target_sum return has_path_sum(node.left, current_sum) or has_path_sum(node.right, current_sum) return has_path_sum(self.root, 0)"},{"question":"# Coding Question: Find the Missing Number Context You are given an array containing `n` distinct numbers taken from the range `0` to `n`. This means the array has exactly `n` elements, and all the numbers from 0 to `n` are present except for one. Your task is to identify the missing number. This problem tests your ability to manipulate arrays and understand mathematical properties. Problem Statement Write a function `find_missing_number(arr: list) -> int` that returns the missing number in the given array `arr`. Input - A list `arr` of `n` distinct integers, where `0 <= n <= 10^6`. Output - An integer representing the missing number from the array. Constraints - Your implementation should handle both small and large arrays efficiently. - The time complexity of your solution must be O(n). - Extra space usage should be minimized. Example ```python def find_missing_number(arr: list) -> int: # Your implementation here # Examples to test your solution print(find_missing_number([3, 0, 1])) # Expected output: 2 print(find_missing_number([0, 1])) # Expected output: 2 print(find_missing_number([9,6,4,2,3,5,7,0,1])) # Expected output: 8 print(find_missing_number([0])) # Expected output: 1 ``` Additional Requirements - Ensure that you test your function on various edge cases including, but not limited to, arrays where the missing number is at the beginning, middle, or end of the range. - Your solution should gracefully handle an empty array, returning `0` if `arr` is empty (i.e., `n = 0`).","solution":"def find_missing_number(arr: list) -> int: Returns the missing number in the given array `arr`. The array contains n distinct numbers taken from the range 0 to n. n = len(arr) total_sum = n * (n + 1) / 2 array_sum = sum(arr) missing_number = total_sum - array_sum return int(missing_number)"},{"question":"# Coding Assessment Question Context: You are tasked with handling and sorting large lists of employee data efficiently. This is crucial for a company that periodically processes contact lists for different purposes. Task: Write a Python function `sort_employees(data: List[Tuple[str, str, str]]) -> List[Tuple[str, str, str]]` that sorts the employee data by their last names in alphabetical order. If two employees have the same last name, sort them by their first names. If both first and last names are identical, then sort them by their ID. 1. **Function Signature**: ```python def sort_employees(data: List[Tuple[str, str, str]]) -> List[Tuple[str, str, str]]: ``` 2. **Input**: - `data` (a list of tuples): Each tuple contains three strings `(ID, first_name, last_name)` representing an employee\'s ID, first name, and last name. 3. **Output**: - Returns a list of tuples sorted by last name, first name, and then ID. 4. **Constraints**: - `1 <= len(data) <= 10^5` - Each string in the tuple is non-empty and consists of upper and lowercase letters only. - IDs are unique within the data set. 5. **Performance Requirement**: - The function should efficiently handle large lists up to the maximum constraint. Examples: ```python # Example 1 employees = [ (\\"E123\\", \\"Alice\\", \\"Smith\\"), (\\"E124\\", \\"Bob\\", \\"Brown\\"), (\\"E125\\", \\"Charlie\\", \\"Smith\\"), (\\"E126\\", \\"Alice\\", \\"Johnson\\") ] assert sort_employees(employees) == [ (\\"E124\\", \\"Bob\\", \\"Brown\\"), (\\"E126\\", \\"Alice\\", \\"Johnson\\"), (\\"E123\\", \\"Alice\\", \\"Smith\\"), (\\"E125\\", \\"Charlie\\", \\"Smith\\") ] # Example 2 employees = [ (\\"E201\\", \\"David\\", \\"Anderson\\"), (\\"E202\\", \\"Eva\\", \\"Anderson\\"), (\\"E203\\", \\"John\\", \\"Doe\\"), (\\"E204\\", \\"Alice\\", \\"Cooper\\") ] assert sort_employees(employees) == [ (\\"E201\\", \\"David\\", \\"Anderson\\"), (\\"E202\\", \\"Eva\\", \\"Anderson\\"), (\\"E204\\", \\"Alice\\", \\"Cooper\\"), (\\"E203\\", \\"John\\", \\"Doe\\") ] ``` Notes: - You may use Python\'s built-in sorting functions. - Ensure your solution is clear and well-organized to handle the sorting as specified. - You are encouraged to write helper functions if necessary to keep the main function concise and readable.","solution":"from typing import List, Tuple def sort_employees(data: List[Tuple[str, str, str]]) -> List[Tuple[str, str, str]]: Sorts the list of employee tuples by their last name, then by first name, and then by ID. return sorted(data, key=lambda x: (x[2], x[1], x[0]))"},{"question":"# Question Description Develop a function to calculate the number of unique characters in a given string without using any pre-built string functions (except basic ones like `len()`), focusing on your ability to work with data structures. # Function Signature ```python def count_unique_characters(s: str) -> int: # Your code goes here ``` # Input - A string `s` with length `n` (1 <= n <= 10^5) consisting of English letters and/or digits. # Output - An integer representing the count of unique characters in the input string. # Constraints - Perform the operation efficiently to handle the upper limit within reasonable time. # Example ```python # Example 1: print(count_unique_characters(\\"apple\\")) # Output: 4 # Example 2: print(count_unique_characters(\\"banana\\")) # Output: 3 # Example 3: print(count_unique_characters(\\"123abc123\\")) # Output: 6 # Example 4: print(count_unique_characters(\\"aaaa\\")) # Output: 1 # Example 5: print(count_unique_characters(\\"abcdef\\")) # Output: 6 ``` # Notes * Avoid using high-level string or set operations. * Focus on basic data structures such as lists or dictionaries to achieve the result. * Ensure your function handles both alphabetic characters and numeric digits efficiently.","solution":"def count_unique_characters(s: str) -> int: Returns the number of unique characters in the given string s. char_count = {} for char in s: if char not in char_count: char_count[char] = 1 return len(char_count)"},{"question":"# Problem Statement: Custom JSON Parser You are required to implement a simple JSON-like parser that can decode a specific subset of JSON strings into Python dictionary objects. The subset you need to focus on includes strings, numbers, booleans, null values, arrays, and objects. Your parser must handle nested structures but can ignore complex features such as escape sequences in strings and white spaces outside string values. # Requirements: 1. **String Values**: Strings are surrounded by double quotes (`\\"`). 2. **Number Values**: Numbers can be integers or floats. 3. **Boolean Values**: `true` and `false` should be recognized as booleans. 4. **Null Values**: The literal `null` should be interpreted as Python\'s `None`. 5. **Array Values**: Arrays are enclosed in square brackets (`[ ]`). 6. **Object Values**: Objects are enclosed in curly braces (`{ }`) with key-value pairs separated by commas, and keys and values separated by colons (`:`). # Function Implementations: * `parse_value`: Identify the type of value (string, number, boolean, null, array, object) and direct to the corresponding parse function. * `parse_string`: Parse and return a string value. * `parse_number`: Parse and return a numeric value (integer or float). * `parse_boolean`: Parse and return a boolean value. * `parse_null`: Return `None` for null values. * `parse_array`: Parse and return a list of values. * `parse_object`: Parse and return a dictionary object. # Input Format: * The parser takes a single JSON-like string as input. # Output Format: * The output should be a Python object (dictionary) representing the parsed structure. # Performance Constraints: * The solution should handle JSON strings up to 5,000 characters. # Example: ```python json_string = \'{\\"name\\": \\"Alice\\", \\"age\\": 30, \\"is_student\\": false, \\"courses\\": [\\"math\\", \\"science\\"], \\"info\\": {\\"height\\": 5.5, \\"weight\\": null}}\' # Parsing the JSON string parsed_data = json_parser(json_string) print(parsed_data) # Output: # {\'name\': \'Alice\', \'age\': 30, \'is_student\': False, # \'courses\': [\'math\', \'science\'], \'info\': {\'height\': 5.5, \'weight\': None}} # Parsing a boolean value boolean_value = json_parser(\\"true\\") print(boolean_value) # Output: True # Parsing an array array_value = json_parser(\\"[1, 2, 3.5, false, null]\\") print(array_value) # Output: [1, 2, 3.5, False, None] ``` # Hint: You may use Python\'s `re` module to assist with pattern matching for different value types, especially for strings and numbers.","solution":"import re def json_parser(json_string): def parse_value(string): if string.startswith(\'\\"\'): return parse_string(string) elif string[0].isdigit() or (string[0] == \'-\' and string[1].isdigit()): return parse_number(string) elif string.startswith(\'true\') or string.startswith(\'false\'): return parse_boolean(string) elif string.startswith(\'null\'): return parse_null(string) elif string.startswith(\'[\'): return parse_array(string) elif string.startswith(\'{\'): return parse_object(string) else: raise ValueError(\\"Invalid JSON string\\") def parse_string(string): match = re.match(r\'\\"([^\\"]*)\\"\', string) if match: return match.group(1), string[len(match.group(0)):] raise ValueError(\\"Invalid string value\\") def parse_number(string): match = re.match(r\'-?d+(.d+)?\', string) if match: value = match.group(0) number = int(value) if \'.\' not in value else float(value) return number, string[len(value):] raise ValueError(\\"Invalid number value\\") def parse_boolean(string): if string.startswith(\'true\'): return True, string[4:] elif string.startswith(\'false\'): return False, string[5:] raise ValueError(\\"Invalid boolean value\\") def parse_null(string): if string.startswith(\'null\'): return None, string[4:] raise ValueError(\\"Invalid null value\\") def parse_array(string): array = [] string = string[1:].strip() while not string.startswith(\']\'): value, string = parse_value(string) array.append(value) string = string.strip() if string.startswith(\',\'): string = string[1:].strip() return array, string[1:] def parse_object(string): obj = {} string = string[1:].strip() while not string.startswith(\'}\'): key, string = parse_string(string) string = string.strip() if not string.startswith(\':\'): raise ValueError(\\"Invalid object value\\") string = string[1:].strip() value, string = parse_value(string) obj[key] = value string = string.strip() if string.startswith(\',\'): string = string[1:].strip() return obj, string[1:] result, remaining = parse_value(json_string.strip()) if remaining: raise ValueError(\\"Extra data after valid JSON\\") return result"},{"question":"# Problem Statement Write a function that simulates rolling two six-sided dice to compute the probabilities of each possible sum from 2 to 12. Given the number of simulations to run, calculate the resulting distribution and determine the mean, variance, and standard deviation of the sums obtained. # Function Signature ```python def dice_simulation(n_simulations: int) -> dict: pass ``` # Input 1. `n_simulations`: An integer representing the number of dice rolls to simulate. # Output Returns a dictionary with the following keys: ``` { \\"distribution\\": Dict[int, float], \\"mean\\": float, \\"variance\\": float, \\"std_dev\\": float } ``` Where: - `\\"distribution\\"`: Dictionary where keys are sums (from 2 to 12) and values are their corresponding probabilities. - `\\"mean\\"`: Mean of the sum distribution. - `\\"variance\\"`: Variance of the sum distribution. - `\\"std_dev\\"`: Standard deviation of the sum distribution. # Constraints * `n_simulations` should be a positive integer and reasonably large to simulate an accurate distribution. # Examples 1. Input: ```python n_simulations = 10000 ``` Output: ```python { \\"distribution\\": {2: 0.028, 3: 0.056, 4: 0.083, 5: 0.111, 6: 0.139, 7: 0.167, 8: 0.139, 9: 0.111, 10: 0.083, 11: 0.056, 12: 0.028}, \\"mean\\": 7.0, \\"variance\\": 5.833, \\"std_dev\\": 2.415 } ``` # Hints 1. Use libraries such as `random` to simulate the dice rolls. 2. Collect the sums of the dice rolls in a list and then compute the required statistics. 3. Ensure the number of simulations is large enough to approximate the theoretical probabilities accurately.","solution":"import random from collections import defaultdict import math def dice_simulation(n_simulations: int) -> dict: if n_simulations <= 0: raise ValueError(\\"Number of simulations must be a positive integer.\\") results = defaultdict(int) for _ in range(n_simulations): roll1 = random.randint(1, 6) roll2 = random.randint(1, 6) results[roll1 + roll2] += 1 total_rolls = sum(results.values()) distribution = {sum_: count / total_rolls for sum_, count in results.items()} mean = sum(sum_ * prob for sum_, prob in distribution.items()) variance = sum(((sum_ - mean) ** 2) * prob for sum_, prob in distribution.items()) std_dev = math.sqrt(variance) return { \\"distribution\\": distribution, \\"mean\\": mean, \\"variance\\": variance, \\"std_dev\\": std_dev }"},{"question":"# Description: You are tasked with creating a function that calculates the factorial of a given non-negative integer using an iterative approach. The goal is to ensure the function is efficient and handles edge cases gracefully. Implement the fastest and most reliable method to compute the factorial while ensuring your solution can manage large input values up to 20 correctly. # Objective: Write a function `compute_factorial(n: int) -> int` that returns the factorial of a non-negative integer `n`. Your function should validate the input and raise an error for negative values or non-integer inputs. # Input: * A non-negative integer value `n`, where `0 <= n <= 20`. # Output: * An integer representing the factorial of the input number `n`. # Requirements: * Implement the function using an iterative approach. * Ensure the solution is optimized for speed and handles edge cases effectively (e.g., `n = 0`). * Validate the input to ensure it is a non-negative integer. # Constraints: * Do not use any third-party libraries other than basic Python built-ins. Example: ``` >>> compute_factorial(5) 120 >>> compute_factorial(0) 1 >>> compute_factorial(1) 1 >>> compute_factorial(20) 2432902008176640000 >>> compute_factorial(-3) Traceback (most recent call last): ... ValueError: Input must be a non-negative integer >>> compute_factorial(\'4\') Traceback (most recent call last): ... TypeError: Input must be an integer ``` Test Cases to Validate: ```python assert compute_factorial(5) == 120 assert compute_factorial(0) == 1 assert compute_factorial(1) == 1 assert compute_factorial(20) == 2432902008176640000 try: compute_factorial(\'string\') except TypeError: print(\\"Caught TypeError as expected\\") try: compute_factorial(-3) except ValueError: print(\\"Caught ValueError as expected\\") ``` # Implementation Function Stub ```python def compute_factorial(n: int) -> int: if not isinstance(n, int): raise TypeError(\\"Input must be an integer\\") if n < 0: raise ValueError(\\"Input must be a non-negative integer\\") result = 1 for i in range(1, n + 1): result *= i return result ```","solution":"def compute_factorial(n: int) -> int: if not isinstance(n, int): raise TypeError(\\"Input must be an integer\\") if n < 0: raise ValueError(\\"Input must be a non-negative integer\\") result = 1 for i in range(1, n + 1): result *= i return result"},{"question":"# Problem Statement You are given two strings `s1` and `s2` of equal length consisting only of lowercase letters. You want to determine if you can make `s2` by shuffling exactly one non-empty substring of `s1`. A substring of a string is any sequence of consecutive characters within the string. Write a function `can_form_by_shuffling_substring(s1: str, s2: str) -> bool` that returns `True` if you can shuffle exactly one non-empty substring of `s1` to get `s2`, and `False` otherwise. **Constraints**: 1. Both strings have the same length. 2. Both strings consist only of lowercase English letters. **Input**: - `s1`: A string of length `n`. - `s2`: A string of length `n`. **Output**: - A boolean value representing whether `s2` can be formed by shuffling exactly one non-empty substring of `s1`. **Example**: ```python # Example 1 s1 = \\"abcde\\" s2 = \\"baecd\\" assert can_form_by_shuffling_substring(s1, s2) == True # Example 2 s1 = \\"abcde\\" s2 = \\"fghij\\" assert can_form_by_shuffling_substring(s1, s2) == False # Example 3 s1 = \\"aabbcc\\" s2 = \\"bbaacc\\" assert can_form_by_shuffling_substring(s1, s2) == True ``` **Explanation**: - In the first example, shuffling the substring `bcd` of `s1` gives `baecd`, which matches `s2`. - In the second example, no substring of `s1` can be shuffled to form `s2`. - In the third example, shuffling the entire string `s1` itself (or certain substrings like `aabbcc` entirely) would match `s2`.","solution":"def can_form_by_shuffling_substring(s1: str, s2: str) -> bool: from collections import Counter n = len(s1) counter_s2 = Counter(s2) # Slide a window to get each possible substring of the same length as s2 for start in range(n): for end in range(start + 1, n + 1): substring = s1[start:end] if Counter(substring) == counter_s2: return True return False"},{"question":"# Problem Statement Write a Python function that performs element-wise multiplication of two given matrices and returns the resultant matrix. **Function Signature**: ```python def matrix_multiply(mat1: List[List[int]], mat2: List[List[int]]) -> List[List[int]]: pass ``` **Input**: - Two lists of lists `mat1` and `mat2`, where each list of lists represents a matrix of integers. **Output**: - A list of lists where each element is the product of the corresponding elements in `mat1` and `mat2`. **Constraints**: - Both input matrices will have the same dimensions (m times n) where (1 leq m, n leq 1000). - Each element in the input matrices will be an integer within the range (-10^5) to (10^5). **Performance Requirements**: - The function should run efficiently with a time complexity of (O(m times n)). # Example ```python assert matrix_multiply([[1, 2], [3, 4]], [[5, 6], [7, 8]]) == [[5, 12], [21, 32]] assert matrix_multiply([[1, -2], [-3, 4]], [[-5, 6], [7, -8]]) == [[-5, -12], [-21, -32]] assert matrix_multiply([[0, 0], [0, 0]], [[0, 0], [0, 0]]) == [[0, 0], [0, 0]] ``` # Explanation The task is to multiply each element of the first input matrix (`mat1`) with the corresponding element of the second input matrix (`mat2`) and return the resultant matrix after performing element-wise multiplication. The dimensions of both matrices will be identical, ensuring each element in one matrix always has a corresponding element in the other matrix.","solution":"from typing import List def matrix_multiply(mat1: List[List[int]], mat2: List[List[int]]) -> List[List[int]]: rows = len(mat1) cols = len(mat1[0]) result = [[0] * cols for _ in range(rows)] for i in range(rows): for j in range(cols): result[i][j] = mat1[i][j] * mat2[i][j] return result"},{"question":"# Array Pair Sum Problem Scenario You are working on a financial analysis tool that needs to identify pairs of transactions that sum up to a specific value within a list of transaction amounts. This helps in identifying matching credits and debits. Task Write a function `find_pairs_with_sum` that takes a list of integers representing transaction amounts and an integer target sum, and returns a list of unique pairs (as tuples) that sum up to the target value. Each pair should be a tuple with the first element being smaller than or equal to the second element, and the pairs should be in ascending order. Function Definition ```python def find_pairs_with_sum(transactions: list[int], target: int) -> list[tuple[int, int]]: ``` Input - A list of integers `transactions` representing transaction amounts. - An integer `target` representing the sum to search for. - Example: `transactions = [1, 2, 3, 4, 5, 6], target = 7` Output - A list of unique tuples of two integers, each representing a pair of transaction amounts whose sum equals the target value. - Example: `[(1, 6), (2, 5), (3, 4)]` Constraints - Each transaction amount in the list must be an integer. - The length of the transactions list can range from 1 to 1000. - The transaction values can be positive and negative, but their absolute values will not exceed 1000. - The function should not return duplicate pairs (e.g., both `(1, 6)` and `(6, 1)` should not be present; only the first pair is valid). Performance Requirements - Design the solution to have a time complexity better than O(n^2) if possible, ideally O(n log n) or O(n). Validation Scenarios To validate your solution, it should pass these examples: ```python assert find_pairs_with_sum([1, 2, 3, 4, 5, 6], 7) == [(1, 6), (2, 5), (3, 4)] assert find_pairs_with_sum([1, -1, 2, -2, 3, -3], 1) == [(-2, 3), (-1, 2), (0, 1)] assert find_pairs_with_sum([1, 1, 1, 1], 2) == [(1, 1)] ``` Special Cases - The function should return an empty list if no pairs found. - The function should handle cases where multiple pairs match the target value without duplication. ```python assert find_pairs_with_sum([1, 1, 1, 1], 3) == [] assert find_pairs_with_sum([1, 2, 3], 6) == [] ```","solution":"def find_pairs_with_sum(transactions, target): Finds all unique pairs in the transactions list that sum up to the target value. Each pair is returned as a tuple (a, b) where a <= b. seen = set() pairs = set() for transaction in transactions: complement = target - transaction if complement in seen: pairs.add((min(transaction, complement), max(transaction, complement))) seen.add(transaction) return sorted(pairs)"},{"question":"# Question You are tasked with implementing a system that simulates the management of a fleet of autonomous delivery drones. Each drone can deliver a package to a specified destination within a given area. The system should: 1. Track the current position of each drone. 2. Update the drone\'s position as it moves towards the destination. 3. Handle multiple drones simultaneously without conflict. 4. Ensure each drone follows the shortest path to its destination, assuming a grid-like area where drones can move in four directions: up, down, left, and right. # Function Requirements initialize_fleet * **Input**: An integer `num_drones` representing the number of drones. * **Output**: A list of drone identifiers, each represented by a unique integer starting from 1. set_destination * **Input**: An integer `drone_id`, a tuple `(x, y)` representing the destination coordinates. * **Output**: None move_drones * **Input**: None * **Output**: A dictionary with drone identifiers as keys and their updated positions as values. get_positions * **Input**: None * **Output**: A dictionary with drone identifiers as keys and their current positions as values. # Constraints * Assume the grid is large enough to accommodate the coordinates used. * A drone can only move one step per call to `move_drones`. * All drones start at position `(0, 0)`. * Positions and destinations are defined by positive integers. # Example ```python # Initialize fleet with 3 drones fleet = initialize_fleet(3) print(fleet) # Output: [1, 2, 3] # Set destination for drone 1 set_destination(1, (2, 3)) # Set destination for drone 2 set_destination(2, (5, 5)) # Set destination for drone 3 set_destination(3, (1, 1)) # Move drones towards their destinations new_positions = move_drones() print(new_positions) # Output (example): {1: (1, 0), 2: (1, 0), 3: (1, 0)} # Get current positions positions = get_positions() print(positions) # Output (example): {1: (1, 0), 2: (1, 0), 3: (1, 0)} # Continue moving drones several times until they reach their destinations ``` Notes: * Ensure each drone moves one step closer to its destination according to the shortest path (Manhattan distance). * If multiple drones attempt to move to the same position at the same time, they should wait to continue until the path is clear. * Error handling should include cases like setting a destination for a non-existing drone or invalid coordinates.","solution":"class FleetManager: def __init__(self): self.drones = {} self.destinations = {} def initialize_fleet(self, num_drones): for i in range(1, num_drones + 1): self.drones[i] = (0, 0) self.destinations[i] = None return list(self.drones.keys()) def set_destination(self, drone_id, destination): if drone_id not in self.drones: raise ValueError(\\"Invalid drone ID\\") if not isinstance(destination, tuple) or not len(destination) == 2: raise ValueError(\\"Invalid destination format\\") self.destinations[drone_id] = destination def move_drones(self): for drone_id, position in self.drones.items(): destination = self.destinations.get(drone_id) if destination: x, y = position dest_x, dest_y = destination if x < dest_x: self.drones[drone_id] = (x + 1, y) elif x > dest_x: self.drones[drone_id] = (x - 1, y) elif y < dest_y: self.drones[drone_id] = (x, y + 1) elif y > dest_y: self.drones[drone_id] = (x, y - 1) return self.drones def get_positions(self): return self.drones"},{"question":"# Problem: Implement a Function for Finding Longest Common Prefix in a Set of Strings You are tasked with writing a function to find the longest common prefix among a set of strings. The longest common prefix is the greatest prefix that is shared among all the words. Function: `longest_common_prefix` Write a function `longest_common_prefix(strings: List[str]) -> str` that takes a list of strings and returns the longest common prefix. Input * `strings`: A list of words containing at least one word. Each word consists of lowercase letters only. Output * Returns the longest common prefix string shared among the list of words. If there is no common prefix, return an empty string `\\"\\"`. Example ```python >>> longest_common_prefix([\\"flower\\", \\"flow\\", \\"flight\\"]) \\"fl\\" >>> longest_common_prefix([\\"dog\\", \\"racecar\\", \\"car\\"]) \\"\\" ``` Constraints * The input list of words will have at least one word. * All words consist of only lowercase English letters. * The length of each word is between 1 and 200. * The total number of words is between 1 and 10^4. # Additional Notes * Consider the edge case where the list contains only one word. * Optimize for both time and space complexity as much as possible.","solution":"from typing import List def longest_common_prefix(strings: List[str]) -> str: if not strings: return \\"\\" # Start with the first word in the list as the prefix prefix = strings[0] for string in strings[1:]: # Reduce the prefix length until it matches the beginning of the string while string[:len(prefix)] != prefix and prefix: prefix = prefix[:len(prefix)-1] # If no common prefix, return empty string early if not prefix: return \\"\\" return prefix"},{"question":"# Problem Statement You have been tasked with writing a function that evaluates an arithmetic expression given as a string and returns its value. The string can contain basic arithmetic operators (`+`, `-`, `*`, `/`) and integer values. The expression may have spaces and should follow standard operator precedence rules. However, you must handle division with integer output (i.e., use floor division for positive and negative results). **Function Signature**: ```python def evaluate_expression(expression: str) -> int: Evaluate an arithmetic expression. @input: expression (a string containing the arithmetic expression) @returns: Integer value of the evaluated expression @example: >>> evaluate_expression(\\"3 + 5 / 2\\") 5 pass ``` # Requirements: 1. **Input Constraints**: - `expression`: a string, 1 ≤ len(expression) ≤ 10^4 - The expression will contain only integers, `+`, `-`, `*`, `/`, and spaces. 2. **Output**: - An integer value that represents the evaluated result of the expression. 3. **Performance**: - The function should process expressions with up to 10,000 characters efficiently given the constraints. # Description - Implement an arithmetic expression evaluator that adheres to the standard operator precedence rules. - To handle division, use floor division for all results (`//` in Python). # Edge Cases: - The expression may contain spaces between numbers and operators. - You should handle the possibility of negative results correctly. # Example You can validate your solution with the following examples: ```python print(evaluate_expression(\\"3 + 5 / 2\\")) # Expected Output: 5 print(evaluate_expression(\\"10 + 2 * 6\\")) # Expected Output: 22 print(evaluate_expression(\\"100 * 2 + 12\\")) # Expected Output: 212 print(evaluate_expression(\\"100 * ( 2 + 12 )\\")) # Expected Output: 1400 print(evaluate_expression(\\"100 * ( 2 + 12 ) / 14\\")) # Expected Output: 100 ``` # Hint: To evaluate the expression while considering operator precedence: - You might first convert the infix expression to a postfix (or Reverse Polish notation) format. - Alternatively, use a stack to handle operators and operands directly based on their precedence. # Note: - Negative numbers should be handled correctly. - Ensure that your implementation uses integer division results for `/` operations. --- This new question requires a focus on parsing and evaluating arithmetic expressions, which aligns with the complexity and areas covered by the sample question. It involves handling strings, stacks, and operator precedence, ensuring it fits seamlessly with the existing set of coding assessment questions.","solution":"def evaluate_expression(expression: str) -> int: Evaluate an arithmetic expression. def apply_operator(operators, values): operator = operators.pop() right = values.pop() left = values.pop() if operator == \'+\': values.append(left + right) elif operator == \'-\': values.append(left - right) elif operator == \'*\': values.append(left * right) elif operator == \'/\': values.append(int(left / right)) # floor division def precedence(op): if op == \'+\' or op == \'-\': return 1 if op == \'*\' or op == \'/\': return 2 return 0 def is_digit(c): return c.isdigit() values = [] operators = [] i = 0 while i < len(expression): if expression[i] == \' \': i += 1 continue elif is_digit(expression[i]): val = 0 while i < len(expression) and is_digit(expression[i]): val = val * 10 + int(expression[i]) i += 1 values.append(val) i -= 1 elif expression[i] == \'(\': operators.append(expression[i]) elif expression[i] == \')\': while len(operators) != 0 and operators[-1] != \'(\': apply_operator(operators, values) operators.pop() else: while (len(operators) != 0 and precedence(operators[-1]) >= precedence(expression[i])): apply_operator(operators, values) operators.append(expression[i]) i += 1 while len(operators) != 0: apply_operator(operators, values) return values[-1]"},{"question":"# Scenario You are developing a software for a car rental company that manages multiple vehicles. Each vehicle has its own unique ID and associated travel distances recorded weekly. To help maintain the vehicle fleet, managerial reports often require statistical measures of distances traveled by all vehicles. One such measure is the calculation of the median distance traveled. Given a list of travel distances for multiple vehicles, you need to implement a function that computes the median of these distances. # Task Your task is to implement a function `calculate_median` that takes a list of integers representing vehicle distances and returns the median of these distances. # Specification **Function Signature**: ```python def calculate_median(distances: list[int]) -> float: Calculates the median of a list of integers representing travel distances. Args: distances: A list of integers representing travel distances. Returns: float: The median value. ``` # Input * `distances` (List[int]): A non-empty list of integers representing the distances traveled by vehicles. # Output * `float`: The median of the list. # Constraints * The length of `distances` is between 1 and (10^6). # Examples ```python assert calculate_median([300, 600, 700, 200, 100]) == 300.0 assert calculate_median([200, 300, 600, 700]) == 450.0 assert calculate_median([100, 200, 300]) == 200.0 assert calculate_median([900]) == 900.0 assert calculate_median([50, 100, 150, 200, 250, 300, 350]) == 200.0 ``` # Notes 1. The input list `distances` will always be a non-empty list of integers. 2. The list does not need to be sorted prior to calling the `calculate_median` function. 3. The median of a list is defined as the middle number in a sorted, ascending or descending, list of numbers. If the length of the list is even, the median is the average of the two middle numbers.","solution":"def calculate_median(distances): Calculates the median of a list of integers representing travel distances. Args: distances: A list of integers representing travel distances. Returns: float: The median value. sorted_distances = sorted(distances) n = len(sorted_distances) mid = n // 2 if n % 2 == 1: # Odd number of elements, return the middle one return float(sorted_distances[mid]) else: # Even number of elements, return the average of the two middle ones return (sorted_distances[mid - 1] + sorted_distances[mid]) / 2"},{"question":"# Coding Assessment Question Scenario You are developing a data processing component for a text processing application. One of the requirements is to identify and resolve conflicts in a list of scheduled events. Events are considered conflicting if they have overlapping time ranges. Task Implement a function `remove_conflicts(events: List[Tuple[int, int]]) -> List[Tuple[int, int]]` following the signature: ```python def remove_conflicts(events: List[Tuple[int, int]]) -> List[Tuple[int, int]]: pass ``` Your implementation should remove the minimal number of events necessary to resolve all conflicts. If there is a conflict, prefer keeping the earlier events intact and removing subsequent overlapping events. Constraints * The input `events` will be a list of tuples where each tuple represents an event with a start and end time `(start, end)`. * Values for start and end times will be integers within the range `1 <= start < end <= 10^6`. * The function should return the list of non-conflicting events in the same format. * Minimally remove events to resolve conflicts, preserving as many events as possible. Input/Output Format * **Input**: A list of tuples. Each tuple contains two integers representing the start and end times of an event. * **Output**: A list of tuples representing the non-conflicting events. Edge cases to consider * No events in the input list * Multiple events with the same start time * All events having some overlap Performance Requirements * Time complexity should be O(n log n), considering sorting as part of the solution. * Space complexity should be O(n). Examples ```python remove_conflicts([(1, 3), (2, 4), (3, 5)]) -> [(1, 3), (3, 5)] remove_conflicts([(1, 2), (2, 3), (3, 4)]) -> [(1, 2), (2, 3), (3, 4)] remove_conflicts([(1, 4), (2, 3), (3, 5)]) -> [(1, 4)] remove_conflicts([(1, 10), (5, 6), (7, 8)]) -> [(1, 10)] remove_conflicts([]) -> [] ``` Implementation Develop your solution by considering all constraints and edge cases. Use an efficient sorting-based approach to identify and remove conflicting events to achieve the minimal removals necessary.","solution":"from typing import List, Tuple def remove_conflicts(events: List[Tuple[int, int]]) -> List[Tuple[int, int]]: # Sort events based on start time events.sort() # Initialize list of non-conflicting events result = [] # Iterate through events and add the ones that don\'t conflict prev_end = -1 for start, end in events: if start >= prev_end: result.append((start, end)) prev_end = end return result"},{"question":"# Problem Statement You are given an arbitrary string `s`. Your goal is to write a function that determines whether the string contains any palindromic substrings and returns the length of the longest palindromic substring found. A palindrome is a word, number, phrase, or other sequences of characters which reads the same backward as forward (ignoring spaces, punctuation, and capitalization). # Input Format 1. A string `s` with a maximum length of ( 10^3 ). # Output Format - An integer representing the length of the longest palindromic substring in `s`. - If there is no palindromic substring, return `0`. # Constraints - The string `s` consists of printable ASCII characters. - The length of the input string will be between ( 1 ) and ( 10^3 ). # Performance Requirements - Aim for a time complexity close to ( O(n^2) ). # Examples 1. **Input**: ``` \\"babad\\" ``` **Output**: ``` 3 ``` (Explanation: The longest palindromic substring is \\"bab\\" or \\"aba\\".) 2. **Input**: ``` \\"cbbd\\" ``` **Output**: ``` 2 ``` (Explanation: The longest palindromic substring is \\"bb\\".) 3. **Input**: ``` \\"abcde\\" ``` **Output**: ``` 1 ``` (Explanation: Each individual character is a palindrome of length 1.) 4. **Input**: ``` \\"\\" ``` **Output**: ``` 0 ``` 5. **Input**: ``` \\"abacdfgdcaba\\" ``` **Output**: ``` 3 ``` (Explanation: The longest palindromic substring is \\"aba\\".) # Function Signature ```python def longest_palindromic_substring_length(s: str) -> int: # Your code here ``` # Notes - Ensure that your solution is efficient and works within the given constraints. - Consider edge cases, such as an empty string or a string with a single character.","solution":"def longest_palindromic_substring_length(s: str) -> int: n = len(s) if n == 0: return 0 # Create a table to store results of subproblems dp = [[False] * n for _ in range(n)] # All substrings of length 1 are palindromic max_length = 1 for i in range(n): dp[i][i] = True start = 0 for i in range(n-1): if s[i] == s[i+1]: dp[i][i+1] = True start = i max_length = 2 for length in range(3, n+1): for i in range(n-length+1): j = i + length - 1 if s[i] == s[j] and dp[i+1][j-1]: dp[i][j] = True start = i max_length = length return max_length"},{"question":"# Coding Challenge: Find the Shortest Path in a Maze You are tasked with navigating a robot through a maze to a target position. The maze is represented by a binary grid, where `1` indicates an obstacle and `0` indicates a free space. Given the starting position, find the shortest path to the target position using the Breadth-First Search (BFS) algorithm. If the target position is unreachable, return `-1`. **Objective**: Implement a function to find the shortest path from the start position to the target position in a maze represented as a 2D grid. # Task **Method Signature**: ```python def shortest_path(maze: list[list[int]], start: tuple[int, int], target: tuple[int, int]) -> int: pass ``` **Inputs**: 1. `maze (list[list[int]])`: A 2D binary grid representing the maze. 2. `start (tuple[int, int])`: The starting position of the robot (row, column). 3. `target (tuple[int, int])`: The target position in the maze (row, column). **Outputs**: - **Returns**: The length of the shortest path from the start to the target. If the target is unreachable, return `-1`. **Constraints**: - The grid dimensions are `m x n` where `1 <= m, n <= 100`. - The start and target positions are within the bounds of the grid. - Move directions are up, down, left, and right. # Example Given the maze: ```python maze = [ [0, 0, 1, 0, 0], [0, 0, 0, 1, 0], [1, 1, 0, 1, 0], [0, 0, 0, 0, 0], [0, 1, 1, 1, 1], [0, 0, 0, 0, 0] ] start = (0, 0) target = (5, 4) ``` The function `shortest_path(maze, start, target)` should return `12`, as the shortest path from the start to the target has a length of 12. # Implementation Requirements - Implement the `shortest_path` function to use the Breadth-First Search algorithm. - Ensure that the pathfinding takes into account obstacles and only traverses valid positions. - Return `-1` if no valid path exists between the start and target positions. - Include edge test cases to validate the robustness of the solution, such as completely obstructed paths and small grid sizes.","solution":"from collections import deque def shortest_path(maze, start, target): Returns the length of the shortest path from start to target in a given maze using BFS. If the target is unreachable, returns -1. # Directions for movement: right, down, left, up directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] m, n = len(maze), len(maze[0]) # Edge case: if start is the same as target if start == target: return 0 # Initialize the BFS queue queue = deque([(start[0], start[1], 0)]) # (row, col, distance) visited = set() visited.add(start) while queue: x, y, dist = queue.popleft() for dx, dy in directions: new_x, new_y = x + dx, y + dy if 0 <= new_x < m and 0 <= new_y < n and (new_x, new_y) not in visited and maze[new_x][new_y] == 0: if (new_x, new_y) == target: return dist + 1 queue.append((new_x, new_y, dist + 1)) visited.add((new_x, new_y)) # If target is unreachable return -1"},{"question":"**Sample Test Cases for Fibonacci Sequences** **Objective**: Implement two separate functions to handle the Fibonacci sequence: one function to generate the first \'n\' Fibonacci numbers efficiently using memoization, and another function to determine if a given number is a Fibonacci number using a mathematical approach. **Problem Statement**: Write two functions: 1. `get_fibonacci_sequence(n: int) -> list` that generates the first `n` Fibonacci numbers. 2. `is_fibonacci_number(x: int) -> bool` that checks whether a given number `x` is a Fibonacci number. **Function Signatures**: ```python def get_fibonacci_sequence(n: int) -> list: pass def is_fibonacci_number(x: int) -> bool: pass ``` **Input**: 1. `n` (integer, 1 ≤ n ≤ 10^4): The number of Fibonacci numbers to generate. 2. `x` (integer, 1 ≤ x ≤ 10^18): The number to check if it is a Fibonacci number. **Output**: 1. List of integers containing the first `n` Fibonacci numbers. 2. Boolean value indicating whether `x` is a Fibonacci number (True or False). **Constraints**: - The `get_fibonacci_sequence` function should utilize memoization or other efficient techniques to avoid excessive recalculations. - The `is_fibonacci_number` function should leverage a mathematical property that checks if a number is a Fibonacci number in constant time. **Example**: ```python n = 10 result = get_fibonacci_sequence(n) print(result) # Result should be [0, 1, 1, 2, 3, 5, 8, 13, 21, 34] x = 21 result = is_fibonacci_number(x) print(result) # Result should be True x = 22 result = is_fibonacci_number(x) print(result) # Result should be False ``` **Explanation**: 1. For `n = 10`, the first ten Fibonacci numbers are [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]. 2. The number 21 is a Fibonacci number. The number 22 is not a Fibonacci number. # Implementation Notes **1. Generating Fibonacci Sequence**: The function `get_fibonacci_sequence` should create a list of the first `n` Fibonacci numbers. This function should efficiently generate the numbers using dynamic programming or another suitable efficient method to ensure quick execution even for large `n`. **2. Checking Fibonacci Number**: The function `is_fibonacci_number` should use the mathematical property that a number `x` is Fibonacci if and only if one or both of (5*x^2 + 4) or (5*x^2 - 4) is a perfect square. This method ensures constant time complexity for checking if a number is a Fibonacci number.","solution":"import math def get_fibonacci_sequence(n): Returns a list containing the first n Fibonacci numbers. if n == 1: return [0] elif n == 2: return [0, 1] fib_sequence = [0, 1] for i in range(2, n): next_fib = fib_sequence[i-1] + fib_sequence[i-2] fib_sequence.append(next_fib) return fib_sequence def is_fibonacci_number(x): Returns True if x is a Fibonacci number, False otherwise. def is_perfect_square(y): s = int(math.sqrt(y)) return s * s == y return is_perfect_square(5 * x * x + 4) or is_perfect_square(5 * x * x - 4)"},{"question":"# Reversible Linked List Challenge You have been hired as a software developer intern at a tech company that specializes in data structure optimizations. Your team is currently focused on linked list operations and has tasked you with implementing a function to reverse a singly linked list. Task Given a singly linked list, implement a function `reverse_linked_list` that reverses the list in place and returns the head of the reversed list. Function Signature ```python class ListNode: def __init__(self, value=0, next=None): self.value = value self.next = next def reverse_linked_list(head: ListNode) -> ListNode: Reverses a singly linked list. Parameters: head (ListNode): The head node of the singly linked list. Returns: ListNode: The new head node of the reversed linked list. ``` Requirements 1. **In-Place Reversal**: - Reversal must be performed in place, meaning no additional data structures (like lists or arrays) should be used. 2. **Linked List Structure**: - The resulting reversed list must maintain the correct linkage between nodes. Input and Output - **Input**: - A reference to the head node of a singly linked list. - **Output**: - A reference to the head node of the reversed linked list. Example ```python # Create a linked list 1 -> 2 -> 3 -> 4 -> None head = ListNode(1) head.next = ListNode(2) head.next.next = ListNode(3) head.next.next.next = ListNode(4) new_head = reverse_linked_list(head) # The reversed linked list should be 4 -> 3 -> 2 -> 1 -> None while new_head: print(new_head.value, end=\\" -> \\") new_head = new_head.next # Output: 4 -> 3 -> 2 -> 1 -> None ``` Constraints - The linked list can be of any reasonable length. - Node values are non-negative integers.","solution":"class ListNode: def __init__(self, value=0, next=None): self.value = value self.next = next def reverse_linked_list(head: ListNode) -> ListNode: Reverses a singly linked list. Parameters: head (ListNode): The head node of the singly linked list. Returns: ListNode: The new head node of the reversed linked list. previous = None current = head while current is not None: next_node = current.next # save the next node current.next = previous # reverse the link previous = current # move previous one step forward current = next_node # move current one step forward return previous"},{"question":"# Question: Implement a Function to Calculate Rectangle Properties Context: You are tasked with creating a function that either calculates the area or the perimeter of a rectangle given the other necessary properties. This calculation is often needed in various geometrical and engineering applications. Requirements: Implement a function `rectangle_properties` that: - Takes three parameters: the length of the rectangle (`length`), the width of the rectangle (`width`), and a string `property` that can either be `\'area\'` or `\'perimeter\'`. - Returns the value (float) of the requested property. Function Signature: ```python def rectangle_properties(length: float, width: float, property: str) -> float: ``` Input: - `length` (float): The length of the rectangle. It must be positive. - `width` (float): The width of the rectangle. It must be positive. - `property` (str): A string that can either be `\'area\'` or `\'perimeter\'`. Output: - Returns a float value which is the calculated area or perimeter of the rectangle. Constraints: - If `length` or `width` is not positive, raise a `ValueError` with the message \\"Dimensions must be positive\\". - If `property` is neither `\'area\'` nor `\'perimeter\'`, raise a `ValueError` with the message \\"Invalid property requested\\". Example: ```python result = rectangle_properties(length=5, width=10, property=\'area\') print(result) # Output: 50.0 result = rectangle_properties(length=5, width=10, property=\'perimeter\') print(result) # Output: 30.0 ``` Implement the function according to the above specifications and handle all errors appropriately.","solution":"def rectangle_properties(length: float, width: float, property: str) -> float: Calculates the specified property (\'area\' or \'perimeter\') of a rectangle given its length and width. Parameters: length (float): The length of the rectangle. Must be positive. width (float): The width of the rectangle. Must be positive. property (str): The property to calculate, either \'area\' or \'perimeter\'. Returns: float: The value of the requested property. Raises: ValueError: If dimensions are not positive or if an invalid property is requested. # Validate the dimensions if length <= 0 or width <= 0: raise ValueError(\\"Dimensions must be positive\\") # Calculate the requested property if property == \'area\': return length * width elif property == \'perimeter\': return 2 * (length + width) else: raise ValueError(\\"Invalid property requested\\")"},{"question":"# Scenario You are implementing a simulation for an online education platform that tracks students\' progress and dynamically suggests courses they should take next based on prerequisites. Each course has a list of prerequisites, and a course can only be taken once all its prerequisites have been completed. For this task, you need to manage course dependencies and determine the order in which a student should take courses. # Question Implement a topological sort algorithm to determine the order of courses a student should take based on the given prerequisites. Each course is represented by a unique integer. Given a list of courses and their prerequisites, construct the order in which the courses should be taken. Requirements 1. Implement the function `find_course_order(num_courses: int, prerequisites: List[Tuple[int, int]]) -> List[int]` to determine the course order. 2. The input `num_courses` is an integer representing the total number of courses. 3. The input `prerequisites` is a list of tuples where each tuple represents a prerequisite pair `[a, b]` indicating that course `a` must be taken before course `b`. 4. Return a list containing the courses in the order they should be taken. If there are multiple valid orders, any valid order is acceptable. If it is not possible to complete all courses due to a cycle, return an empty list. Example ```python # Define number of courses and their prerequisites num_courses = 6 prerequisites = [ (1, 2), (2, 3), (3, 4), (4, 5), (1, 5), ] # Determine course order course_order = find_course_order(num_courses, prerequisites) # Outputs print(f\\"Course order: {course_order}\\") ``` Constraints and Performance - `1 <= num_courses <= 1000` - Each prerequisite pair `[a, b]` is such that `0 <= a, b < num_courses` - The prerequisites list can have up to `4000` pairs - The solution should efficiently determine the course order, considering the possible constraints and dependencies between courses.","solution":"from typing import List, Tuple from collections import deque, defaultdict def find_course_order(num_courses: int, prerequisites: List[Tuple[int, int]]) -> List[int]: Determines the order of courses based on prerequisites using topological sorting. Parameters: - num_courses: int, the total number of courses. - prerequisites: List of tuples, where each tuple [a, b] indicates that course a must be taken before course b. Returns: - List of integers representing the order in which courses should be taken or an empty list if it\'s not possible due to a cycle. # Create adjacency list and in-degree array adj_list = defaultdict(list) in_degree = [0] * num_courses # Build the graph and in-degree array for a, b in prerequisites: adj_list[a].append(b) in_degree[b] += 1 # Initialize queue with courses having no prerequisites queue = deque([i for i in range(num_courses) if in_degree[i] == 0]) course_order = [] while queue: course = queue.popleft() course_order.append(course) # Decrease in-degree of neighboring nodes for neighbor in adj_list[course]: in_degree[neighbor] -= 1 # If in-degree goes to zero, add it to the queue if in_degree[neighbor] == 0: queue.append(neighbor) # If course_order contains all courses, return it, otherwise return an empty list return course_order if len(course_order) == num_courses else []"},{"question":"# Coding Assessment Question Context You are given a class `SparseMatrix` that represents matrices in a sparse format using a dictionary where keys are tuples representing the position of non-zero elements, and values represent the non-zero values. Problem Statement Implement the following function: ```python def multiply_sparse_matrices(mat_a: SparseMatrix, mat_b: SparseMatrix) -> SparseMatrix: Multiplies two sparse matrices mat_a and mat_b. Args: mat_a (SparseMatrix): The first sparse matrix to be multiplied. mat_b (SparseMatrix): The second sparse matrix to be multiplied. Returns: SparseMatrix: Resultant sparse matrix from multiplying mat_a and mat_b. pass ``` Definition Matrix multiplication follows the rule that each element of the resultant matrix is the dot product of corresponding row elements from `mat_a` and column elements from `mat_b`. Input `mat_a`, `mat_b`: Instances of the `SparseMatrix` class representing sparse matrices. Output - An instance of `SparseMatrix` representing the product of the two input matrices. Constraints - Both matrices are compatible for multiplication. - Elements of the matrices are non-zero integers. - Matrix dimensions can be large, and matrices are sparse, having most of their elements zero. Examples ```python # Example 1 # mat_a = | 1 0 | # | 0 3 | # as SparseMatrix: {(0, 0): 1, (1, 1): 3} # mat_b = | 0 2 | # | 4 0 | # as SparseMatrix: {(0, 1): 2, (1, 0): 4} mat_a = SparseMatrix({(0, 0): 1, (1, 1): 3}) mat_b = SparseMatrix({(0, 1): 2, (1, 0): 4}) result = multiply_sparse_matrices(mat_a, mat_b) # result should represent SparseMatrix: {(0, 1): 2, (1, 0): 12} assert result == SparseMatrix({(0, 1): 2, (1, 0): 12}) # Example 2 # mat_a = | 1 2 | # | 3 4 | # as SparseMatrix: {(0, 0): 1, (0, 1): 2, (1, 0): 3, (1, 1): 4} # mat_b = | 0 1 | # | 0 0 | # as SparseMatrix: {(0, 1): 1} mat_a = SparseMatrix({(0, 0): 1, (0, 1): 2, (1, 0): 3, (1, 1): 4}) mat_b = SparseMatrix({(0, 1): 1}) result = multiply_sparse_matrices(mat_a, mat_b) # result should represent SparseMatrix: {(0, 1): 1, (1, 1): 3} assert result == SparseMatrix({(0, 1): 1, (1, 1): 3}) ``` Notes 1. Ensure to handle the case where the matrices have different sparsity patterns and varying dimensions. 2. Optimize for performance considering the sparsity of the matrices.","solution":"class SparseMatrix: def __init__(self, matrix_dict): self.matrix_dict = matrix_dict def __eq__(self, other): return self.matrix_dict == other.matrix_dict def multiply_sparse_matrices(mat_a: SparseMatrix, mat_b: SparseMatrix) -> SparseMatrix: Multiplies two sparse matrices mat_a and mat_b. Args: mat_a (SparseMatrix): The first sparse matrix to be multiplied. mat_b (SparseMatrix): The second sparse matrix to be multiplied. Returns: SparseMatrix: Resultant sparse matrix from multiplying mat_a and mat_b. result = {} for (i, k), v in mat_a.matrix_dict.items(): for (k2, j), v2 in mat_b.matrix_dict.items(): if k == k2: if (i, j) not in result: result[(i, j)] = 0 result[(i, j)] += v * v2 # Remove zero-entries from the resultant dictionary if any result = {key: value for key, value in result.items() if value != 0} return SparseMatrix(result)"},{"question":"# Coding Assessment Question You are required to simulate a simplified file system in a hierarchical directory structure. Your task is to implement functionalities to add files, add directories, and display the structure in a tree-like format. 1. **Initialization**: Start with a root directory. 2. **Adding Directories**: - Users should be able to create a new directory at any level by specifying the path where the directory should be added. - Handle cases where the path is invalid (i.e., parent directory does not exist). 3. **Adding Files**: - Users should be able to add files by specifying the path where the file should be added. - Each file is considered as having a unique name. - Handle cases where the path is invalid. 4. **Displaying Structure**: - Implement a method to print the entire directory structure in a readable tree format. - For each directory, print its name followed by its contents (both files and subdirectories). Use proper indentation to represent the tree levels. # Function Signature: ```python class FileSystem: def __init__(self) -> None: ... def create_dir(self, path: str, dir_name: str) -> bool: ... def add_file(self, path: str, file_name: str) -> bool: ... def display(self) -> None: ... ``` # Your Task: Implement the `FileSystem` class and the necessary methods to manage directories and files according to the rules above. You should ensure that the structure is updated correctly when files or directories are added and display it in an organized manner. # Constraints: - Path strings use \'/\' as the directory separator and always start with \'/\'. - Filenames and directory names contain only alphanumeric characters and underscores. - If a directory or file is added at a non-existent path, the method should return `False`. Verification: - Test cases should include creating a hierarchy with multiple levels of directories and files. - Ensure that invalid paths are handled gracefully. - The `display` method should correctly visualize the structure, reflecting all created directories and added files. Example: ```python fs = FileSystem() fs.create_dir(\\"/\\", \\"home\\") fs.create_dir(\\"/home\\", \\"user\\") fs.add_file(\\"/home/user\\", \\"file1.txt\\") fs.add_file(\\"/home\\", \\"file2.txt\\") fs.display() ``` Output: ``` / home/ user/ file1.txt file2.txt ``` Compose the `FileSystem` class, ensuring proper structuring and functionality as described above.","solution":"class FileSystem: def __init__(self) -> None: self.root = {\'type\': \'dir\', \'content\': {}} def _find_node(self, path: str): if path == \\"/\\": return self.root path_parts = path.strip(\'/\').split(\'/\') node = self.root for part in path_parts: if part not in node[\'content\'] or node[\'content\'][part][\'type\'] != \'dir\': return None node = node[\'content\'][part] return node def create_dir(self, path: str, dir_name: str) -> bool: parent_node = self._find_node(path) if not parent_node or dir_name in parent_node[\'content\']: return False parent_node[\'content\'][dir_name] = {\'type\': \'dir\', \'content\': {}} return True def add_file(self, path: str, file_name: str) -> bool: parent_node = self._find_node(path) if not parent_node or file_name in parent_node[\'content\']: return False parent_node[\'content\'][file_name] = {\'type\': \'file\'} return True def display(self) -> None: def _display(node, indent): for item in sorted(node[\'content\']): if node[\'content\'][item][\'type\'] == \'dir\': print(\' \' * indent + item + \'/\') _display(node[\'content\'][item], indent + 4) else: print(\' \' * indent + item) print(\\"/\\") _display(self.root, 4)"},{"question":"# Coding Assessment Question Scenario You are leading a team to build a scheduling system for a set of interconnected tasks. Each task has specific dependencies which determine the order in which they can be executed. You need to ensure the tasks are scheduled optimally while respecting their dependencies. Task 1. **Function Implementation**: Implement a function `find_task_order` that determines the order of execution for a given list of tasks based on their dependencies. 2. **Detailed Steps**: - Define the function `find_task_order(tasks: List[str], dependencies: List[Tuple[str, str]]) -> List[str]`. - The `tasks` list contains the names of the tasks. - The `dependencies` list contains tuples where each tuple `(a, b)` means task `a` must be completed before task `b`. 3. **Requirements**: * The function should perform a topological sort to determine the valid order of task execution. * If there are multiple valid orders, return any one of them. * If no valid order exists due to a cycle in dependencies, return an empty list. 4. **Example**: ```python >>> tasks = [\\"A\\", \\"B\\", \\"C\\", \\"D\\"] >>> dependencies = [(\\"A\\", \\"B\\"), (\\"A\\", \\"C\\"), (\\"B\\", \\"D\\"), (\\"C\\", \\"D\\")] >>> print(find_task_order(tasks, dependencies)) [\\"A\\", \\"B\\", \\"C\\", \\"D\\"] or [\\"A\\", \\"C\\", \\"B\\", \\"D\\"] ``` Constraints * **Input**: - There will be no duplicate tasks. - Tasks and dependencies are guaranteed to form a valid Directed Acyclic Graph (DAG) under normal circumstances. * **Expected Output**: - A list representing the order in which tasks should be executed. Performance Requirements * The topological sorting should run in O(V + E) time complexity where V is the number of tasks and E is the number of dependencies. * The space complexity should also be O(V + E) due to the storage of the graph and in-degrees of the nodes.","solution":"from typing import List, Tuple from collections import deque def find_task_order(tasks: List[str], dependencies: List[Tuple[str, str]]) -> List[str]: # Initialize graph and in-degree count graph = {task: [] for task in tasks} in_degree = {task: 0 for task in tasks} # Build the graph and in-degree count from dependencies for pre, post in dependencies: graph[pre].append(post) in_degree[post] += 1 # Initialize the queue with tasks that have no dependencies queue = deque([task for task in tasks if in_degree[task] == 0]) task_order = [] while queue: task = queue.popleft() task_order.append(task) for dependent in graph[task]: in_degree[dependent] -= 1 if in_degree[dependent] == 0: queue.append(dependent) # If all tasks are not processed, return an empty list (cycle detection) if len(task_order) == len(tasks): return task_order else: return []"},{"question":"# Scenario You are given a list of customer orders, each containing a unique order ID and a price indicating the total amount of the order. Your task is to develop a system that automatically applies eligible discounts based on predefined conditions and outputs the final payable amount for each order. # Task Implement a function to compute the discounted prices for each order and print the final amount payable for each order. # Function Signature ```python def apply_discounts(orders: List[Order]) -> None: ``` # Input - `orders`: A list of `Order` objects, where each order has the following attributes: - `order_id`: Integer, the unique ID of the order. - `price`: Float, the total price of the order before discount. # Discount Rules - If the price is greater than 100, a discount of 10% is applied. - If the price is between 50 and 100 (inclusive), a discount of 5% is applied. - No discount is applied if the price is below 50. # Output - The function should print the final amount payable for each order after applying the discounts. # Constraints - All order IDs in `orders` are unique. - Prices are positive floats. - The number of orders `n` is between `1` and `50` (inclusive). # Example ```python orders = [ Order(order_id=1, price=120.0), Order(order_id=2, price=75.5), Order(order_id=3, price=42.0), Order(order_id=4, price=150.0), Order(order_id=5, price=99.99) ] apply_discounts(orders) ``` Expected Output ``` Order ID: 1, Final Payable Amount: 108.00 Order ID: 2, Final Payable Amount: 71.73 Order ID: 3, Final Payable Amount: 42.00 Order ID: 4, Final Payable Amount: 135.00 Order ID: 5, Final Payable Amount: 94.99 ``` **Note**: Ensure your implementation correctly applies the discounts according to the rules and accurately prints the final amounts in a clear format, rounding to two decimal places where necessary.","solution":"from typing import List class Order: def __init__(self, order_id: int, price: float): self.order_id = order_id self.price = price def apply_discounts(orders: List[Order]) -> None: for order in orders: if order.price > 100: discount = 0.10 elif 50 <= order.price <= 100: discount = 0.05 else: discount = 0.0 final_price = order.price * (1 - discount) print(f\\"Order ID: {order.order_id}, Final Payable Amount: {final_price:.2f}\\")"},{"question":"# Array Shuffling Validator Context In data analysis and machine learning, it\'s essential to ensure the randomness of data ordering to avoid biased training in models. A common method to achieve randomness in data ordering is shuffling. The randomness can be validated by statistical measures however, sometimes a simple validation check is required to ensure two lists have the same elements post shuffling. You need to determine if two lists are just shuffled versions of each other. To be considered a shuffle of each other, the lists must contain the same elements with the same frequency, just in a different order. Problem Statement You will write a function `is_shuffled_version` that takes two lists of integers and determines if one list is a shuffled version of the other. Input * `list1`: A list of integers. * `list2`: A list of integers. Output * A boolean value indicating whether `list2` is a shuffled version of `list1`. Constraints 1. Both lists will have the same length. 2. Both lists will contain only integers, and they can have duplicate values. Example Usage ```python list1 = [3, 1, 4, 1, 5, 9] list2 = [1, 9, 4, 1, 5, 3] assert is_shuffled_version(list1, list2) == True list1 = [1, 2, 3, 4, 5] list2 = [5, 4, 3, 2, 1] assert is_shuffled_version(list1, list2) == True list1 = [2, 2, 2, 2] list2 = [2, 2, 2, 2] assert is_shuffled_version(list1, list2) == True list1 = [1, 2, 3] list2 = [1, 2, 2] assert is_shuffled_version(list1, list2) == False list1 = [1] list2 = [2] assert is_shuffled_version(list1, list2) == False ``` Function Signature ```python def is_shuffled_version(list1: List[int], list2: List[int]) -> bool: pass ``` Notes * Consider using efficient data structures and algorithms to determine if the two lists contain the same elements with the same frequency. * Think about edge cases such as empty lists or lists with only one element.","solution":"def is_shuffled_version(list1, list2): This function checks if list2 is a shuffled version of list1. Params: list1: List of integers. list2: List of integers. Returns: A boolean value indicating whether list2 is a shuffled version of list1. # Handle the constraints where both lists must be of the same length if len(list1) != len(list2): return False # Use sorting to compare the elements and their frequencies return sorted(list1) == sorted(list2)"},{"question":"# Permutation and Combination Calculation **Scenario**: Permutation and combination calculations are fundamental in combinatorics, crucial for solving problems related to probability and various counting techniques. Your task is to implement efficient functions that compute the number of permutations and combinations given integers `n` and `r`. **Task**: Write two Python functions `permutations(n: int, r: int) -> int` and `combinations(n: int, r: int) -> int` that compute the number of permutations and combinations respectively for given integers `n` and `r`. **Specifications**: 1. `permutations(n, r)` should return the number of ways to arrange `r` items out of `n` distinct items, calculated as `n! / (n - r)!`. 2. `combinations(n, r)` should return the number of ways to choose `r` items out of `n` distinct items, calculated as `n! / (r! * (n - r)!)`. **Input Format**: - Two integers `n` and `r` where `0 ≤ r ≤ n ≤ 20`. **Output Format**: - Two possible integer outputs: - The number of permutations of `r` items from `n`. - The number of combinations of `r` items from `n`. **Example**: ```python permutations(5, 3) # Output: 60 combinations(5, 3) # Output: 10 permutations(6, 2) # Output: 30 combinations(6, 2) # Output: 15 ``` **Constraints and Assumptions**: - Ensure the functions handle edge cases where `r = 0` or `r = n`. - Assume the input values are within the specified range and will not cause integer overflow. - Use appropriate mathematical functions to avoid unnecessary recalculations. **Performance**: The functions should run efficiently within the constraints, ideally leveraging factorial calculations which can be precomputed to reduce redundant operations: **Note**: - Consider using the `math.factorial` function from Python\'s standard library to simplify the implementation. - Precompute factorials up to 20 to optimize computation for both permutations and combinations efficiently. Here\'s a potential implementation to consider: ```python import math def permutations(n: int, r: int) -> int: if r > n or r < 0 or n < 0: return 0 return math.factorial(n) // math.factorial(n - r) def combinations(n: int, r: int) -> int: if r > n or r < 0 or n < 0: return 0 return math.factorial(n) // (math.factorial(r) * math.factorial(n - r)) ``` Ensure to test your functions exhaustively to handle edge cases and verify correctness for all valid input values.","solution":"import math def permutations(n: int, r: int) -> int: if r > n or r < 0 or n < 0: return 0 return math.factorial(n) // math.factorial(n - r) def combinations(n: int, r: int) -> int: if r > n or r < 0 or n < 0: return 0 return math.factorial(n) // (math.factorial(r) * math.factorial(n - r))"},{"question":"# Question: You are developing a simple script to evaluate whether a given list of Python code snippets follow PEP 8 style guide conventions concerning variable names. Task: Write a function that analyzes a list of Python code snippets to determine if all variable names in each snippet follow the PEP 8 naming convention (i.e., they should be lowercase with words separated by underscores). 1. **Function: `evaluate_pep8_compliance(code_snippets: list) -> list`** - Input: - `code_snippets`: A list of strings, where each string is a Python code snippet. - Output: - A list of dictionaries, where each dictionary corresponds to a code snippet and contains: - `snippet`: The original code snippet. - `compliant`: A boolean indicating PEP 8 compliance with variable names. - `non_compliant_vars`: A list of variable names that do not comply with PEP 8 naming conventions. Implementation details: - Identify variable names in each snippet. - Check if each variable name follows the PEP 8 convention. - Handle potential edge cases, such as: - Empty snippets. - Snippets without any variable assignments. Examples: ```python evaluate_pep8_compliance([ \'x = 10ny = 20nz = x + y\', \'TemperatureFahrenheit = 98.6nbloodPressure = 120\', \'valid_variable = 1nanotherValidVariable = valid_variable + 1\' ]) # Output: # [ # {\'snippet\': \'x = 10ny = 20nz = x + y\', \'compliant\': True, \'non_compliant_vars\': []}, # {\'snippet\': \'TemperatureFahrenheit = 98.6nbloodPressure = 120\', \'compliant\': False, \'non_compliant_vars\': [\'TemperatureFahrenheit\', \'bloodPressure\']}, # {\'snippet\': \'valid_variable = 1nanotherValidVariable = valid_variable + 1\', \'compliant\': False, \'non_compliant_vars\': [\'anotherValidVariable\']} # ] evaluate_pep8_compliance([ \'a = 5nb_c = a + 7\', \'result = calculate_sum(3, 5)\', \'AnotherExample = 42nExampleTwo = HelloWorld\' ]) # Output: # [ # {\'snippet\': \'a = 5nb_c = a + 7\', \'compliant\': True, \'non_compliant_vars\': []}, # {\'snippet\': \'result = calculate_sum(3, 5)\', \'compliant\': True, \'non_compliant_vars\': []}, # {\'snippet\': \'AnotherExample = 42nExampleTwo = HelloWorld\', \'compliant\': False, \'non_compliant_vars\': [\'AnotherExample\', \'ExampleTwo\']} # ] ``` Ensure your solution is robust, efficiently handles various code structures, and correctly identifies variable names.","solution":"import re def evaluate_pep8_compliance(code_snippets: list) -> list: results = [] for snippet in code_snippets: # Split the snippet into lines lines = snippet.split(\'n\') non_compliant_vars = [] for line in lines: # Find variable assignments matches = re.findall(r\'b(w+)s*=\', line) for var in matches: # Check if the variable name is compliant with PEP 8 if not re.match(r\'^[a-z_][a-z0-9_]*\', var): non_compliant_vars.append(var) results.append({ \'snippet\': snippet, \'compliant\': len(non_compliant_vars) == 0, \'non_compliant_vars\': non_compliant_vars }) return results"},{"question":"# Coding Question Context Binary search is an efficient algorithm for finding an item from a sorted list of items. It works by repeatedly dividing in half the portion of the list that could contain the item until you narrow down the possible locations to just one. However, binary search requires that the list be sorted. Let\'s boost the skill of implementing such an algorithm but with a twist. Instead of searching for just a single integer, we will implement a function that will utilize binary search to find the smallest and largest index of a given target value in a sorted list of integers. This helps in finding the entire range of indices that contain the target value. Tasks 1. Implement a function `binary_search_range(arr: list, target: int) -> tuple` that takes in a sorted list of integers `arr` and an integer `target` and returns a tuple containing the smallest and largest index of the target in the list. If the target is not found, return `(-1, -1)`. # Function Signature ```python def binary_search_range(arr: list[int], target: int) -> tuple[int, int]: # your code here ``` # Requirements - The function should perform binary search to find the first and last occurrences of the target value. - If the target value is not found in the list, the function should return `(-1, -1)`. # Constraints - The input list may contain duplicate values leading to multiple occurrences of the target value. - The length of the list is between 1 and (10^5). - The values in the list and the target can be any integer within the range (-10^6) to (10^6). # Example Usage ```python # Test cases for binary_search_range binary_search_range([1, 2, 2, 2, 3, 4, 5], 2) # should return (1, 3) binary_search_range([5, 7, 7, 8, 8, 10], 8) # should return (3, 4) binary_search_range([5, 7, 7, 8, 8, 10], 6) # should return (-1, -1) binary_search_range([1, 1, 1, 1, 1], 1) # should return (0, 4) ``` Ensure your function handles edge cases effectively, and test it with various scenarios to verify correctness.","solution":"def binary_search_range(arr: list[int], target: int) -> tuple[int, int]: def find_first(arr, target): left, right = 0, len(arr) - 1 first_index = -1 while left <= right: mid = (left + right) // 2 if arr[mid] == target: first_index = mid right = mid - 1 # Continue searching in the left half elif arr[mid] < target: left = mid + 1 else: right = mid - 1 return first_index def find_last(arr, target): left, right = 0, len(arr) - 1 last_index = -1 while left <= right: mid = (left + right) // 2 if arr[mid] == target: last_index = mid left = mid + 1 # Continue searching in the right half elif arr[mid] < target: left = mid + 1 else: right = mid - 1 return last_index first = find_first(arr, target) last = find_last(arr, target) return (first, last) if first != -1 else (-1, -1)"},{"question":"# Dynamic Array Implementation You are tasked with implementing a `DynamicArray` data structure that increases its capacity as needed when elements are added beyond its initial capacity. Function Specifications 1. **Initialization**: Define an initializer accepting an integer `initial_capacity`, representing the initial capacity of the DynamicArray. 2. **Add**: Implement an `add(element)` method to insert an element at the end of the DynamicArray. If the current size exceeds the capacity, double the capacity and add the element. 3. **Size**: Implement a `size()` method that returns the current number of elements in the array. 4. **Capacity**: Implement a `capacity()` method that returns the current capacity of the DynamicArray. 5. **Get**: Implement a `get(index)` method that returns the element at a specified index. Raise an exception if the index is out of bounds. 6. **Set**: Implement a `set(index, element)` method that updates the element at the specified index with the new element. Raise an exception if the index is out of bounds. Input and Output Specifications **Input**: - `DynamicArray(initial_capacity)` constructor where `initial_capacity` is the initial capacity of the array. - `add(element)` where `element` is the element to be added. - `size()`, `capacity()`, `get(index)`, `set(index, element)` are methods with their respective inputs. **Output**: - `add(element)` should return the DynamicArray object for chaining operations. - `size()` should return the integer size of the array. - `capacity()` should return the integer capacity of the array. - `get(index)` should return the element at the specified index. - `set(index, element)` should return `True` if the operation is successful. # Example Test Cases ```python da = DynamicArray(3) assert da.size() == 0 assert da.capacity() == 3 da.add(1) da.add(2) da.add(3) assert da.size() == 3 assert da.capacity() == 3 da.add(4) assert da.size() == 4 assert da.capacity() == 6 assert da.get(0) == 1 assert da.get(3) == 4 try: da.get(4) except Exception as e: assert str(e) == \\"INDEX OUT OF BOUNDS\\" da.set(0, 10) assert da.get(0) == 10 try: da.set(4, 5) except Exception as e: assert str(e) == \\"INDEX OUT OF BOUNDS\\" assert da.size() == 4 ``` Implement the `DynamicArray` class according to these specifications and ensure your implementation passes all the given example test cases.","solution":"class DynamicArray: def __init__(self, initial_capacity): self.capacity_value = initial_capacity self.size_value = 0 self.array = [None] * self.capacity_value def add(self, element): if self.size_value >= self.capacity_value: self._resize() self.array[self.size_value] = element self.size_value += 1 return self def size(self): return self.size_value def capacity(self): return self.capacity_value def get(self, index): if index < 0 or index >= self.size_value: raise Exception(\\"INDEX OUT OF BOUNDS\\") return self.array[index] def set(self, index, element): if index < 0 or index >= self.size_value: raise Exception(\\"INDEX OUT OF BOUNDS\\") self.array[index] = element return True def _resize(self): self.capacity_value *= 2 new_array = [None] * self.capacity_value for i in range(self.size_value): new_array[i] = self.array[i] self.array = new_array"},{"question":"# Coding Question: Implement the following two functions for a `BinarySearchTree` class: 1. **Function to insert a value into the BST**: Implement a method `insert` which takes a value, inserts it into the correct position in the Binary Search Tree (BST), and returns the root of the tree. ```python class BinarySearchTree: def __init__(self, value: int, left: \'BinarySearchTree\' = None, right: \'BinarySearchTree\' = None): self.value = value self.left = left self.right = right def insert(self, value: int) -> \'BinarySearchTree\': Insert a value into the BST. Args: value: The value to be inserted into the BST. Returns: The root of the tree with the value inserted. >>> bst = BinarySearchTree(10) >>> bst = bst.insert(5) >>> bst = bst.insert(15) >>> bst.left.value 5 >>> bst.right.value 15 # Your implementation here ``` 2. **Function to find the lowest common ancestor (LCA) of two nodes**: Implement a method `lowest_common_ancestor` which takes two values and returns the value of the lowest common ancestor of the two nodes in the BST. ```python class BinarySearchTree: # existing methods... def lowest_common_ancestor(self, value1: int, value2: int) -> int: Find the lowest common ancestor of two nodes in the BST. Args: value1: The value of the first node. value2: The value of the second node. Returns: The value of the lowest common ancestor node. >>> bst = BinarySearchTree(10) >>> bst = bst.insert(5) >>> bst = bst.insert(1) >>> bst = bst.insert(7) >>> bst = bst.insert(15) >>> bst = bst.insert(12) >>> bst.lowest_common_ancestor(1, 7) 5 >>> bst.lowest_common_ancestor(12, 15) 15 # Your implementation here ``` # Constraints: * The tree node values are integers. * The tree is a valid Binary Search Tree. * The maximum number of nodes in the tree is not greater than 1000. # Examples: ```python bst = BinarySearchTree(10) bst = bst.insert(5) bst = bst.insert(1) bst = bst.insert(7) bst = bst.insert(15) bst = bst.insert(12) print(bst.lowest_common_ancestor(1, 7)) # Output: 5 print(bst.lowest_common_ancestor(12, 15)) # Output: 15 ``` # Additional Notes: * Ensure the `insert` method correctly handles insertion for maintaining the properties of a BST. * The `lowest_common_ancestor` method should operate efficiently, leveraging the BST properties for optimal time complexity.","solution":"class BinarySearchTree: def __init__(self, value: int, left: \'BinarySearchTree\' = None, right: \'BinarySearchTree\' = None): self.value = value self.left = left self.right = right def insert(self, value: int) -> \'BinarySearchTree\': Insert a value into the BST. Args: value: The value to be inserted into the BST. Returns: The root of the tree with the value inserted. if value < self.value: if self.left is None: self.left = BinarySearchTree(value) else: self.left.insert(value) else: if self.right is None: self.right = BinarySearchTree(value) else: self.right.insert(value) return self def lowest_common_ancestor(self, value1: int, value2: int) -> int: Find the lowest common ancestor of two nodes in the BST. Args: value1: The value of the first node. value2: The value of the second node. Returns: The value of the lowest common ancestor node. if value1 < self.value and value2 < self.value: return self.left.lowest_common_ancestor(value1, value2) elif value1 > self.value and value2 > self.value: return self.right.lowest_common_ancestor(value1, value2) else: return self.value"},{"question":"# Problem Statement Design a function to determine if a given string has all unique characters. This is a common problem in data validation, encoding, and ensuring data integrity where no repeated characters are allowed. # Function Signature ```python def has_unique_characters(s: str) -> bool: Given a string s, determines if the string has all unique characters. Args: s: str - A string input. Returns: bool - True if all characters are unique, False otherwise. Raises: TypeError: If the input is not a string Examples: >>> has_unique_characters(\\"abcdef\\") True >>> has_unique_characters(\\"hello\\") False >>> has_unique_characters(\\"\\") True >>> has_unique_characters(\\"Aa\\") True ``` # Constraints 1. The input will always be a string. 2. The function should raise a TypeError if the input is not a string. 3. The string can contain uppercase, lowercase letters, digits, and symbols. # Detailed Requirements and Examples 1. **Input** - Single string that can contain any ASCII characters. 2. **Output** - True if all characters in the input string are unique, False otherwise. 3. **Example Scenarios** ```python - has_unique_characters(\\"abcdef\\") -> True - has_unique_characters(\\"hello\\") -> False - has_unique_characters(\\"\\") -> True - has_unique_characters(\\"Aa\\") -> True ``` # Performance Requirements - Time complexity must be (O(n)), where (n) is the length of the string. - Space complexity should be (O(1)) if considering the constant character set size (e.g., ASCII). # Hints - Utilize data structures like sets to track characters efficiently. - Consider case sensitivity if necessary. # Error Handling - If the input is not a string, raise a TypeError.","solution":"def has_unique_characters(s: str) -> bool: Given a string s, determines if the string has all unique characters. Args: s: str - A string input. Returns: bool - True if all characters are unique, False otherwise. Raises: TypeError: If the input is not a string Examples: >>> has_unique_characters(\\"abcdef\\") True >>> has_unique_characters(\\"hello\\") False >>> has_unique_characters(\\"\\") True >>> has_unique_characters(\\"Aa\\") True if not isinstance(s, str): raise TypeError(\\"Input must be a string\\") seen_chars = set() for char in s: if char in seen_chars: return False seen_chars.add(char) return True"},{"question":"# Problem Description You are required to implement a function `calculate_popularity_score` that takes a dictionary representing songs and their play counts, and returns a list of tuples containing songs and their popularity scores. The popularity score for a song is calculated as the ratio of its play count to the total play count of all songs, represented as a percentage with two decimal places. # Input * A dictionary where each key is a string representing the song name and the value is an integer representing the number of times the song has been played. # Output * A list of tuples where each tuple contains a song name and its popularity score as a float, sorted in descending order of the popularity score. # Constraints * Dictionary size will not exceed 10^3. * Play count for each song will be a non-negative integer not exceeding 10^6. # Requirements * You must compute the popularity scores and sort the resulting list in descending order based on the score. * Ensure the popularity score is calculated as `play_count / total_play_count * 100`, and represented with two decimal places. # Function Signature ```python from typing import Dict, List, Tuple def calculate_popularity_score(song_plays: Dict[str, int]) -> List[Tuple[str, float]]: ``` # Example ```python song_plays = { \\"Song A\\": 150, \\"Song B\\": 300, \\"Song C\\": 50 } print(calculate_popularity_score(song_plays)) # Expected output: [(\'Song B\', 60.00), (\'Song A\', 30.00), (\'Song C\', 10.00)] ``` # Note * Handle cases where the dictionary is empty by returning an empty list. * Ensure that percentage values are correctly formatted to two decimal places.","solution":"from typing import Dict, List, Tuple def calculate_popularity_score(song_plays: Dict[str, int]) -> List[Tuple[str, float]]: Calculates the popularity score for each song in the given dictionary of song plays. Parameters: song_plays (Dict[str, int]): Dictionary with song names as keys and play counts as values. Returns: List[Tuple[str, float]]: List of tuples containing song names and their popularity scores, sorted in descending order of popularity scores. total_play_count = sum(song_plays.values()) if total_play_count == 0: return [] popularity_scores = [ (song, round((play_count / total_play_count) * 100, 2)) for song, play_count in song_plays.items() ] return sorted(popularity_scores, key=lambda x: x[1], reverse=True)"},{"question":"# Coding Assessment Question: Magic Square Permutations Background: A magic square is a 3x3 grid of distinct numbers from 1 to 9 such that the sums of numbers in each row, each column, and both main diagonals are equal. Consider a function `isMagicSquare(grid)` that returns `True` if the given 3x3 grid forms a magic square, and `False` otherwise. Your task is to find how many possible 3x3 grids using the numbers 1 to 9 form magic squares. Implement a function `countMagicSquares()` that returns this number. # Function Signature ```python def countMagicSquares() -> int: pass ``` # Output - An integer representing the total number of unique 3x3 magic squares that can be formed using the numbers from 1 to 9. # Constraints - The function does not take any input parameters. # Example ```python def test_countMagicSquares(): assert countMagicSquares() == 8, \\"Test case failed\\" print(\\"All test cases pass\\") ``` # Notes - There are only a finite number of permutations of a 3x3 grid with numbers 1 to 9. - Verify each permutation to check if it forms a magic square. - The order of the numbers and their arrangements must be considered when checking for a magic square. Detailed Instructions 1. Implement a helper function `isMagicSquare(grid)` that checks the magic square property. 2. Generate all possible 3x3 grids with numbers from 1 to 9. 3. Check each grid using the helper function. 4. Return the count of grids that satisfy the magic square property. # Helper Function Signature ```python def isMagicSquare(grid: List[List[int]]) -> bool: pass ``` # Example Usage ```python def test_isMagicSquare(): assert isMagicSquare([[2, 7, 6], [9, 5, 1], [4, 3, 8]]) == True, \\"Test case 1 failed\\" assert isMagicSquare([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == False, \\"Test case 2 failed\\" print(\\"All test cases pass\\") def test_countMagicSquares(): assert countMagicSquares() == 8, \\"Test case failed\\" print(\\"All test cases pass\\") ``` # Example ```python print(countMagicSquares()) # Output should be 8 ```","solution":"from itertools import permutations def isMagicSquare(grid): Checks if a 3x3 grid forms a magic square. # Check sums of rows, columns, and diagonals sums = [sum(row) for row in grid] + [sum(grid[i][j] for i in range(3)) for j in range(3)] + [sum(grid[i][i] for i in range(3))] + [sum(grid[i][2 - i] for i in range(3))] return all(s == 15 for s in sums) def countMagicSquares(): Returns the count of all possible 3x3 magic squares using numbers 1 to 9. magic_squares_count = 0 all_perms = permutations(range(1, 10)) for perm in all_perms: grid = [list(perm[i*3:(i+1)*3]) for i in range(3)] if isMagicSquare(grid): magic_squares_count += 1 return magic_squares_count"},{"question":"# Coding Question You are tasked with augmenting a matrix class to include matrix operations and special matrix properties. Your class should be capable of performing basic matrix arithmetic as well as determining if a matrix is symmetric and calculating its trace. # Problem Statement Write a Python class `Matrix` to represent a matrix and implement methods to add, subtract, and multiply matrices, check the symmetry, and compute the trace of the matrix. # Class Signature ```python class Matrix: def __init__(self, data): Initialize the matrix with a 2D list. Arguments: data -- a 2D list representing the matrix pass def add(self, other): Add two matrices. Arguments: other -- a Matrix object to be added Returns: A new Matrix object which is the sum of self and other pass def subtract(self, other): Subtract one matrix from another. Arguments: other -- a Matrix object to be subtracted Returns: A new Matrix object which is the difference of self and other pass def multiply(self, other): Multiply two matrices. Arguments: other -- a Matrix object to be multiplied Returns: A new Matrix object which is the product of self and other pass def is_symmetric(self): Check if the matrix is symmetric. Returns: True if the matrix is symmetric, else False pass def trace(self): Calculate the trace of the matrix. Returns: The trace of the matrix pass ``` # Input & Output * **Input**: - For `__init__`: A 2D list `data` representing the matrix. - For `add` and `subtract`: Another `Matrix` object. - For `multiply`: Another `Matrix` object. - For `is_symmetric` and `trace`: No additional input. * **Output**: - For `add`, `subtract`, and `multiply`: A new `Matrix` object. - For `is_symmetric`: A boolean value indicating whether the matrix is symmetric. - For `trace`: An integer or float representing the trace of the matrix. # Constraints - The matrices involved in addition and subtraction must be of the same dimensions. - For multiplication, the number of columns in the first matrix must equal the number of rows in the second. - The matrix dimensions will not exceed 100x100. - Assume all entries in the matrix are either integers or floats. # Example ```python m1 = Matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) m2 = Matrix([[9, 8, 7], [6, 5, 4], [3, 2, 1]]) # Matrix addition add_result = m1.add(m2) print(add_result.data) # Expected Output: [[10, 10, 10], [10, 10, 10], [10, 10, 10]] # Matrix subtraction sub_result = m1.subtract(m2) print(sub_result.data) # Expected Output: [[-8, -6, -4], [-2, 0, 2], [4, 6, 8]] # Matrix multiplication mult_result = m1.multiply(m2) print(mult_result.data) # Expected Output: [[30, 24, 18], [84, 69, 54], [138, 114, 90]] # Check symmetry symmetric = m1.is_symmetric() print(symmetric) # Expected Output: False # Calculate trace trace_result = m1.trace() print(trace_result) # Expected Output: 15 ```","solution":"class Matrix: def __init__(self, data): Initialize the matrix with a 2D list. Arguments: data -- a 2D list representing the matrix self.data = data def add(self, other): Add two matrices. Arguments: other -- a Matrix object to be added Returns: A new Matrix object which is the sum of self and other num_rows = len(self.data) num_cols = len(self.data[0]) result = [] for i in range(num_rows): row = [] for j in range(num_cols): row.append(self.data[i][j] + other.data[i][j]) result.append(row) return Matrix(result) def subtract(self, other): Subtract one matrix from another. Arguments: other -- a Matrix object to be subtracted Returns: A new Matrix object which is the difference of self and other num_rows = len(self.data) num_cols = len(self.data[0]) result = [] for i in range(num_rows): row = [] for j in range(num_cols): row.append(self.data[i][j] - other.data[i][j]) result.append(row) return Matrix(result) def multiply(self, other): Multiply two matrices. Arguments: other -- a Matrix object to be multiplied Returns: A new Matrix object which is the product of self and other result = [] num_rows = len(self.data) num_cols = len(other.data[0]) num_common = len(other.data) for i in range(num_rows): row = [] for j in range(num_cols): elem_sum = 0 for k in range(num_common): elem_sum += self.data[i][k] * other.data[k][j] row.append(elem_sum) result.append(row) return Matrix(result) def is_symmetric(self): Check if the matrix is symmetric. Returns: True if the matrix is symmetric, else False num_rows = len(self.data) num_cols = len(self.data[0]) if num_rows != num_cols: return False for i in range(num_rows): for j in range(i, num_cols): if self.data[i][j] != self.data[j][i]: return False return True def trace(self): Calculate the trace of the matrix. Returns: The trace of the matrix return sum(self.data[i][i] for i in range(len(self.data)))"},{"question":"# **Question**: Counting Valid Bracket Sequences A valid bracket sequence is defined as a sequence of brackets that is properly nested. For example, the sequences `\\"()\\"`, `\\"(())\\"` and `(()())` are valid bracket sequences, while `\\")(\\"`, `\\"(()\\"` and `\\")()\\"` are not. Your task is to implement a function `count_valid_bracket_sequences(n: int) -> int` that returns the number of valid bracket sequences of length `2 * n`. **Input Format** - A single integer `n`, representing the number of pairs of brackets in the sequence. **Output Format** - An integer representing the number of valid bracket sequences of length `2 * n`. **Constraints** - `0 <= n <= 15` - If the input is not an integer or is negative, raise a `ValueError` with an appropriate message. **Function Signature** ```python def count_valid_bracket_sequences(n: int) -> int: pass ``` **Examples** 1. `count_valid_bracket_sequences(3)` should return `5`, because there are 5 valid sequences with 3 pairs of brackets: - `\\"((()))\\"` - `\\"(()())\\"` - `\\"(())()\\"` - `\\"()(())\\"` - `\\"()()()\\"` 2. `count_valid_bracket_sequences(1)` should return `1`, because there is only 1 valid sequence with 1 pair of brackets: - `\\"()\\"` **Note**: The problem relates to computing the Catalan number, which gives the count of valid bracket sequences for the given `n`. Assume helper functions for calculating Catalan numbers can be used if necessary.","solution":"def count_valid_bracket_sequences(n: int) -> int: Returns the number of valid bracket sequences of length 2 * n. if not isinstance(n, int): raise ValueError(\\"Input must be an integer\\") if n < 0: raise ValueError(\\"Input must be non-negative\\") # Function to compute the nth Catalan number def catalan_number(n): if n == 0 or n == 1: return 1 catalan = [0] * (n + 1) catalan[0], catalan[1] = 1, 1 for i in range(2, n + 1): catalan[i] = 0 for j in range(i): catalan[i] += catalan[j] * catalan[i - j - 1] return catalan[n] return catalan_number(n)"},{"question":"Sorting a List with Custom Order # Context In many real-world scenarios, sorting a list requires a custom order not directly handled by built-in sorting algorithms. For example, sorting cards in a game by their rank or sorting events based on a specific priority order. The task is to write a function that sorts a list of numbers according to a user-defined order given as another list. # Task Write a Python function `custom_sort()` that accepts two lists: the first list contains the elements to be sorted, and the second list defines the custom order. The function should return a new list with the elements sorted as per the custom order. # Function Signature ```python def custom_sort(elements: list, custom_order: list) -> list: pass ``` # Input - `elements`: A list of integers to be sorted. - `custom_order`: A list of integers defining the custom order. It will contain all unique elements present in `elements`. # Output - A list of integers sorted according to the custom order. # Requirements - The function must adhere to the custom order precisely. - Elements not in the `custom_order` should be appended at the end in their original order. - Ensure error handling for invalid inputs (non-list types, empty lists, mismatched elements in lists). # Constraints 1. The function should raise a `TypeError` if either input is not a list. 2. The function should raise a `ValueError` if `custom_order` contains elements not in `elements` or vice-versa. 3. The function should consider the order specified and handle ties appropriately. # Example ```python result = custom_sort([4, 3, 2, 1, 5], [3, 1, 4, 2]) print(result) # Expected output: [3, 1, 4, 2, 5] result = custom_sort([7, 8, 5, 6, 3], [5, 6, 7]) print(result) # Expected output: [5, 6, 7, 8, 3] ``` # Notes - The function should traverse `elements` and arrange them according to `custom_order`. - Elements not specified in `custom_order` should preserve their relative order and appear after the custom-ordered elements. - Make sure to demonstrate the function with multiple examples covering different scenarios. # Reference: - [Python Sorting](https://docs.python.org/3/howto/sorting.html) Create your `custom_sort()` function and ensure it handles various edge cases to match the behavior described above.","solution":"def custom_sort(elements: list, custom_order: list) -> list: Sorts the list `elements` according to the custom order defined in `custom_order`. Any element not in `custom_order` will be put at the end in their original order. Raises: TypeError: If either input is not a list. ValueError: If elements in `custom_order` not found in `elements`, or vice versa. Returns: A new list sorted according to the custom order. if not isinstance(elements, list) or not isinstance(custom_order, list): raise TypeError(\\"Both inputs must be lists\\") if not elements or not custom_order: raise ValueError(\\"Both inputs lists must be non-empty\\") # Check that all elements in custom_order are in elements and vice versa elements_set = set(elements) custom_order_set = set(custom_order) if not custom_order_set.issubset(elements_set): raise ValueError(\\"custom_order contains elements not in elements\\") # Create a dictionary for the custom order priorities order_map = {val: index for index, val in enumerate(custom_order)} def sort_key(x): return order_map.get(x, len(custom_order) + elements.index(x)) sorted_list = sorted(elements, key=sort_key) return sorted_list"},{"question":"# Question: Implement an LRU Cache with Custom Expiry Time Background An LRU (Least Recently Used) cache is a data structure that stores a limited number of items. When the cache reaches its limit, it removes the least recently accessed item before adding a new item. In this task, you will create an LRU cache that not only handles least recently used eviction but also custom expiry times for each item. Task Implement an `LRUCache` class that supports the following methods: 1. `put(key, value, expiry_time)`: Add a new key-value pair to the cache with a custom expiry time. 2. `get(key)`: Retrieve the value of the key if it exists and hasn\'t expired. If the key does not exist or has expired, return `None`. 3. `remove(key)`: Remove the key from the cache if it exists. 4. `size()`: Return the current number of items in the cache. 5. `clear_expired()`: Clear all expired items from the cache. Function Signatures ```python class LRUCache: def __init__(self, capacity: int): ... def put(self, key: Any, value: Any, expiry_time: float) -> None: ... def get(self, key: Any) -> Any: ... def remove(self, key: Any) -> None: ... def size(self) -> int: ... def clear_expired(self) -> None: ... ``` Constraints * The `capacity` of the cache is a positive integer. * `key` is assumed to be immutable (e.g., an integer, string, or tuple). * The `expiry_time` is given in seconds as a float. * The cache should maintain O(1) time complexity for `put`, `get`, and `remove` operations. Example 1. **Input**: ```python import time cache = LRUCache(2) cache.put(1, \'A\', 5.0) # Key 1 with a value \'A\' and 5 seconds expiry cache.put(2, \'B\', 5.0) # Key 2 with a value \'B\' and 5 seconds expiry print(cache.get(1)) # Output: \'A\' time.sleep(6) cache.clear_expired() print(cache.get(1)) # Output: None (expired) cache.put(3, \'C\', 5.0) # This will evict key 2 due to capacity limit print(cache.get(2)) # Output: None (evicted) print(cache.get(3)) # Output: \'C\' cache.put(1, \'A\', 1.0) # Reinsert key 1 time.sleep(2) cache.clear_expired() print(cache.size()) # Output: 1 (only key 3 remains) ``` 2. **Output**: ```python \'A\' None None \'C\' 1 ``` Notes * Use a dictionary to store key-value-expiry triples and a doubly linked list to track the order of usage for LRU logic. * Ensure that the time of access is updated on every `get` and `put` operation. * Handle custom expiry and evictions appropriately, providing meaningful error messages and thorough test cases to validate the implementation. * You may use in-built libraries like `collections` and `time`. Good luck!","solution":"import time from collections import OrderedDict class LRUCache: def __init__(self, capacity: int): self.capacity = capacity self.cache = OrderedDict() def _is_expired(self, expiry_time): return time.time() > expiry_time def _remove_expired_keys(self): keys_to_remove = [key for key, (value, expiry_time) in self.cache.items() if self._is_expired(expiry_time)] for key in keys_to_remove: del self.cache[key] def put(self, key, value, expiry_time): self._remove_expired_keys() if key in self.cache: del self.cache[key] elif len(self.cache) >= self.capacity: self.cache.popitem(last=False) self.cache[key] = (value, time.time() + expiry_time) def get(self, key): self._remove_expired_keys() if key in self.cache: value, expiry_time = self.cache.pop(key) if not self._is_expired(expiry_time): self.cache[key] = (value, expiry_time) return value return None def remove(self, key): if key in self.cache: del self.cache[key] def size(self): self._remove_expired_keys() return len(self.cache) def clear_expired(self): self._remove_expired_keys()"},{"question":"# Maximum Flow with Ford-Fulkerson Algorithm Context You are working on optimizing the distribution of resources in a pipeline network. Each pipeline segment has a maximum capacity, and you need to determine the maximum flow of resources from the source node to the sink node in the network. To achieve this, you will implement the Ford-Fulkerson algorithm using Depth-First Search (DFS). Objectives 1. Write a function to build a graph from given vertices and edges. 2. Implement the Ford-Fulkerson algorithm to find the maximum flow in the constructed graph. Functions 1. **Graph Construction** ```python def build_flow_graph(vertices, edges): Build a graph from given vertices and edges for flow calculations. :param vertices: List of vertex identifiers :param edges: List of edges represented as tuples (vertex1, vertex2, capacity) :return: Representation of the graph suitable for flow calculations ``` 2. **Ford-Fulkerson Maximum Flow** ```python def ford_fulkerson_max_flow(graph, source, sink): Apply the Ford-Fulkerson algorithm to find the maximum flow from source to sink. :param graph: The graph as constructed by build_flow_graph :param source: The source vertex identifier :param sink: The sink vertex identifier :return: An integer representing the maximum flow value ``` Input - **Vertices**: A list of integers representing the vertex identifiers (e.g., [0, 1, 2, 3]). - **Edges**: A list of tuples representing the edges with capacities (e.g., [(0, 1, 15), (0, 2, 10), (1, 3, 10), (2, 3, 15)]). - **Source**: An integer representing the source vertex identifier. - **Sink**: An integer representing the sink vertex identifier. Output - An integer representing the maximum flow from the source to the sink. - Print the step-by-step execution trace of the Ford-Fulkerson algorithm. Constraints * There will be no more than 100 vertices and 1000 edges. * Capacities are guaranteed to be positive integers. Example ```python vertices = [0, 1, 2, 3] edges = [(0, 1, 15), (0, 2, 10), (1, 3, 10), (2, 3, 15)] source = 0 sink = 3 graph = build_flow_graph(vertices, edges) max_flow = ford_fulkerson_max_flow(graph, source, sink) print(max_flow) ``` Expected output: ``` Maximum Flow: 20 ``` Note: The exact execution traces including the paths and flow updates will vary depending on the DFS implementation details.","solution":"def build_flow_graph(vertices, edges): Build a graph from given vertices and edges for flow calculations. :param vertices: List of vertex identifiers :param edges: List of edges represented as tuples (vertex1, vertex2, capacity) :return: Representation of the graph suitable for flow calculations graph = {vertex: {} for vertex in vertices} for v1, v2, capacity in edges: if v2 not in graph[v1]: graph[v1][v2] = 0 if v1 not in graph[v2]: graph[v2][v1] = 0 graph[v1][v2] += capacity return graph def ford_fulkerson_max_flow(graph, source, sink): Apply the Ford-Fulkerson algorithm to find the maximum flow from source to sink. :param graph: The graph as constructed by build_flow_graph :param source: The source vertex identifier :param sink: The sink vertex identifier :return: An integer representing the maximum flow value def dfs(source, sink, visited): stack = [(source, float(\'Inf\'))] paths = {source: []} while stack: u, flow = stack.pop() for v in graph[u]: if v not in visited and graph[u][v] > 0: visited.add(v) stack.append((v, min(flow, graph[u][v]))) paths[v] = paths[u] + [(u, v)] if v == sink: return paths[v], stack[-1][1] return None, 0 max_flow = 0 visited = set() path, path_flow = dfs(source, sink, visited) while path is not None: max_flow += path_flow # Update the capacities in the reverse direction: for u, v in path: graph[u][v] -= path_flow graph[v][u] += path_flow visited = set() path, path_flow = dfs(source, sink, visited) return max_flow"},{"question":"# Coding Assessment Question Objective: Demonstrate your understanding of string manipulation and search algorithms by implementing a function that finds the first non-repeating character in a string. Scenario: In many software applications, it is crucial to identify unique elements within a dataset. Suppose you\'re tasked with developing a solution to find the first non-repeating character in a given string. This function will be highly beneficial in text processing and data analysis applications where unique identification is required. Requirements: 1. **Function Name**: `first_non_repeating_char` 2. **Input**: A single string `s` (1 ≤ len(s) ≤ 10^5) consisting of lowercase English letters. 3. **Output**: A single character which is the first non-repeating character in the string. If every character repeats, return `None`. 4. **Constraints**: Your algorithm should be efficient enough to handle the upper limit of the input size. 5. **Performance**: Aim for a solution that operates in linear time, O(n), where `n` is the length of the string. Example: ```python >>> first_non_repeating_char(\\"leetcode\\") \'l\' >>> first_non_repeating_char(\\"loveleetcode\\") \'v\' >>> first_non_repeating_char(\\"aabb\\") None >>> first_non_repeating_char(\\"swiss\\") \'w\' ``` Edge Cases to Consider: - Ensure your function handles the smallest inputs correctly (e.g., single character string). - Ensure efficiency with large inputs close to the upper bound of size 100000. - Consider and handle cases where no characters are non-repeating. ```python def first_non_repeating_char(s: str) -> str: # Your implementation here pass # Test cases print(first_non_repeating_char(\\"leetcode\\")) # Expected: \'l\' print(first_non_repeating_char(\\"loveleetcode\\")) # Expected: \'v\' print(first_non_repeating_char(\\"aabb\\")) # Expected: None print(first_non_repeating_char(\\"swiss\\")) # Expected: \'w\' ```","solution":"def first_non_repeating_char(s: str) -> str: from collections import Counter # Count the frequency of each character in the string char_count = Counter(s) # Iterate through the string and return the first character with a count of 1 for char in s: if char_count[char] == 1: return char # If no non-repeating character is found, return None return None"},{"question":"# Coding Assessment Question: Optimizing Online Bookstore Recommendation System **Scenario**: You are tasked with improving the recommendation system of an online bookstore. The current system recommends books based on a static user profile. To provide more dynamic and personalized recommendations, you are to enhance the system to adjust recommendations based on recent user interactions, such as book views and purchases. **Objective**: You need to implement a function `dynamic_recommendation_system` which will take user interactions and dynamically adjust the list of recommended books based on the recent activities of the user. You will also need to implement helper functions to calculate the user\'s interest level in different genres and adjust the recommendations accordingly. Input: - `user`: A `User` object representing the user whose recommendations are to be updated. - `recent_interactions`: A list of `BookInteraction` objects representing the recent activities of the user. - `genres_weights`: A dictionary mapping genre names to their respective weights. The `User` and `BookInteraction` class definitions, along with initial genre weights, are provided. You will be extending these with your dynamic recommendation logic. Output: - A list of strings representing the updated recommendations for the user. ```python from collections import defaultdict # Example User class. class User: def __init__(self, user_id: str, profile_genres: dict[str, float], recommendations: list[str]) -> None: self.user_id = user_id self.profile_genres = profile_genres # A dictionary of genres and their weights in the user\'s profile. self.recommendations = recommendations # A list of recommended book titles. # Example BookInteraction class. class BookInteraction: def __init__(self, book_title: str, genre: str, interaction_type: str) -> None: self.book_title = book_title self.genre = genre self.interaction_type = interaction_type # \\"view\\" or \\"purchase\\" class BookstoreRecommendationSystem: def __init__(self, genres_weights: dict[str, float]) -> None: self.genres_weights = genres_weights def dynamic_recommendation_system(self, user: User, recent_interactions: list[BookInteraction]) -> list[str]: Core recommendation function that adjusts recommendations dynamically based on user interactions. self.update_user_profile_genres(user, recent_interactions) self.adjust_recommendations(user) return user.recommendations def update_user_profile_genres(self, user: User, recent_interactions: list[BookInteraction]) -> None: Helper function to update the user\'s genre profile based on recent interactions. genre_interaction_counts = defaultdict(int) for interaction in recent_interactions: genre_interaction_counts[interaction.genre] += 1 if interaction.interaction_type == \\"view\\" else 2 for genre, count in genre_interaction_counts.items(): if genre in user.profile_genres: user.profile_genres[genre] += count * self.genres_weights.get(genre, 1.0) else: user.profile_genres[genre] = count * self.genres_weights.get(genre, 1.0) def adjust_recommendations(self, user: User) -> None: Helper function to adjust the list of recommendations for the user based on updated profile genres. sorted_genres = sorted(user.profile_genres.items(), key=lambda item: item[1], reverse=True) # Placeholder: Implement logic to adjust recommendations based on sorted genres. # For example, fetch top books from these genres and update the list. pass # Example usage: if __name__ == \\"__main__\\": genres_weights = { \\"fiction\\": 1.0, \\"non-fiction\\": 1.2, \\"romance\\": 0.8, \\"mystery\\": 1.5, \\"science-fiction\\": 1.3 } initial_recommendations = [\\"BookA\\", \\"BookB\\", \\"BookC\\"] initial_profile_genres = {\\"fiction\\": 1.0, \\"romance\\": 0.5} user = User(\\"user123\\", initial_profile_genres, initial_recommendations) recent_interactions = [ BookInteraction(\\"BookD\\", \\"mystery\\", \\"view\\"), BookInteraction(\\"BookE\\", \\"science-fiction\\", \\"purchase\\"), BookInteraction(\\"BookF\\", \\"romance\\", \\"view\\") ] recommendation_system = BookstoreRecommendationSystem(genres_weights) updated_recommendations = recommendation_system.dynamic_recommendation_system(user, recent_interactions) print(f\\"Updated Recommendations: {updated_recommendations}\\") ``` Constraints: 1. The `genres_weights` map will always have positive weights greater than 0. 2. Each `BookInteraction` will belong to a valid genre listed in the `genres_weights`. 3. Ensure the recommendation adjustments handle edge cases appropriately. 4. Recent interactions should have a significant impact on the recommendations. Requirements: - Correctly implement `dynamic_recommendation_system`, `update_user_profile_genres`, and `adjust_recommendations` methods based on the provided scenario and specifications. - Ensure your solution is tested for correctness and edge cases using the class provided. **Note**: This question assesses your ability to enhance a recommendation algorithm dynamically based on user behavior and interactions.","solution":"from collections import defaultdict # Example User class. class User: def __init__(self, user_id: str, profile_genres: dict[str, float], recommendations: list[str]) -> None: self.user_id = user_id self.profile_genres = profile_genres # A dictionary of genres and their weights in the user\'s profile. self.recommendations = recommendations # A list of recommended book titles. # Example BookInteraction class. class BookInteraction: def __init__(self, book_title: str, genre: str, interaction_type: str) -> None: self.book_title = book_title self.genre = genre self.interaction_type = interaction_type # \\"view\\" or \\"purchase\\" class BookstoreRecommendationSystem: def __init__(self, genres_weights: dict[str, float]) -> None: self.genres_weights = genres_weights def dynamic_recommendation_system(self, user: User, recent_interactions: list[BookInteraction]) -> list[str]: Core recommendation function that adjusts recommendations dynamically based on user interactions. self.update_user_profile_genres(user, recent_interactions) self.adjust_recommendations(user) return user.recommendations def update_user_profile_genres(self, user: User, recent_interactions: list[BookInteraction]) -> None: Helper function to update the user\'s genre profile based on recent interactions. genre_interaction_counts = defaultdict(int) for interaction in recent_interactions: genre_interaction_counts[interaction.genre] += 1 if interaction.interaction_type == \\"view\\" else 2 for genre, count in genre_interaction_counts.items(): if genre in user.profile_genres: user.profile_genres[genre] += count * self.genres_weights.get(genre, 1.0) else: user.profile_genres[genre] = count * self.genres_weights.get(genre, 1.0) def adjust_recommendations(self, user: User) -> None: Helper function to adjust the list of recommendations for the user based on updated profile genres. sorted_genres = sorted(user.profile_genres.items(), key=lambda item: item[1], reverse=True) # Placeholder: Implement logic to adjust recommendations based on sorted genres. # For example, fetch top books from these genres and update the list. # For now, replacing the recommendations with Dummy logic for testing user.recommendations = [f\\"TopBookFrom{genre[0]}\\" for genre in sorted_genres[:3]] # just a placeholder logic # Example usage: if __name__ == \\"__main__\\": genres_weights = { \\"fiction\\": 1.0, \\"non-fiction\\": 1.2, \\"romance\\": 0.8, \\"mystery\\": 1.5, \\"science-fiction\\": 1.3 } initial_recommendations = [\\"BookA\\", \\"BookB\\", \\"BookC\\"] initial_profile_genres = {\\"fiction\\": 1.0, \\"romance\\": 0.5} user = User(\\"user123\\", initial_profile_genres, initial_recommendations) recent_interactions = [ BookInteraction(\\"BookD\\", \\"mystery\\", \\"view\\"), BookInteraction(\\"BookE\\", \\"science-fiction\\", \\"purchase\\"), BookInteraction(\\"BookF\\", \\"romance\\", \\"view\\") ] recommendation_system = BookstoreRecommendationSystem(genres_weights) updated_recommendations = recommendation_system.dynamic_recommendation_system(user, recent_interactions) print(f\\"Updated Recommendations: {updated_recommendations}\\")"},{"question":"# Coding Assessment Question Context You are developing a function to merge and sort multiple sorted lists into one sorted list. The merging should be performed in an optimal manner to minimize time complexity. Task Write a function `merge_k_sorted_lists` that takes a list of sorted lists and returns a single sorted list containing all the elements of the input lists. You should implement an efficient solution that utilizes a min-heap (priority queue) to achieve the best possible performance. Constraints - Each input list is sorted in non-decreasing order. - The total number of elements across all lists will not exceed (10^6). - The number of lists (k) will be between 1 and 10^3. - The individual integers within the lists will range from (-10^9) to (10^9). Function Signature ```python import heapq from typing import List def merge_k_sorted_lists(lists: List[List[int]]) -> List[int]: pass ``` Expected Input and Output ```python >>> merge_k_sorted_lists([[1, 4, 5], [1, 3, 4], [2, 6]]) [1, 1, 2, 3, 4, 4, 5, 6] >>> merge_k_sorted_lists([[], [1, 2, 3], [4, 5]]) [1, 2, 3, 4, 5] >>> merge_k_sorted_lists([[10, 20, 30], [15, 25], [5, 35]]) [5, 10, 15, 20, 25, 30, 35] >>> merge_k_sorted_lists([[10], [20, 30, 40]]) [10, 20, 30, 40] >>> merge_k_sorted_lists([[], [], []]) [] >>> merge_k_sorted_lists([[1, 3, 7], [2, 4, 5], [6, 8]]) [1, 2, 3, 4, 5, 6, 7, 8] ``` Performance Requirements - Your implementation should utilize a min-heap to maintain efficiency. - Aim for O(n log k) time complexity, where (n) is the total number of elements and (k) is the number of lists. - Ensure that the solution efficiently handles edge cases, such as empty input lists and lists with varying lengths.","solution":"import heapq from typing import List def merge_k_sorted_lists(lists: List[List[int]]) -> List[int]: Merge k sorted lists into one sorted list using a min-heap for efficiency. Args: lists: A list of k sorted lists. Returns: A single sorted list containing all elements from the k sorted lists. # Min-heap to track the smallest element in each list min_heap = [] # Initialize the heap with the first element from each list along with its list index and element index for i, lst in enumerate(lists): if lst: # List is not empty heapq.heappush(min_heap, (lst[0], i, 0)) # Result list to store the merged sorted elements result = [] while min_heap: # Extract the smallest element from the heap val, list_idx, ele_idx = heapq.heappop(min_heap) result.append(val) # If there are more elements in the same list, push the next element to the heap if ele_idx + 1 < len(lists[list_idx]): heapq.heappush(min_heap, (lists[list_idx][ele_idx + 1], list_idx, ele_idx + 1)) return result"},{"question":"# Coding Assessment Question **Context**: Given a string representing a mathematical expression, your task is to evaluate the expression and return the result. This problem requires handling basic arithmetic operations while respecting the order of operations (PEMDAS/BODMAS rules). # Problem Statement: Write a function `evaluate_expression(expression: str) -> float` that takes a string `expression` and evaluates it, returning a floating-point result. The function should correctly interpret parentheses and the basic arithmetic operators: addition (`+`), subtraction (`-`), multiplication (`*`), division (`/`). # Input Format: - `expression`: A string containing a valid mathematical expression with length `n (1 ≤ n ≤ 100)`. The expression may include spaces, which should be ignored. # Output Format: - Returns the evaluated result as a floating-point number. # Constraints: - The expression will not contain any variables, only numbers and operators. - Division by zero will not occur in the input expression. - The function should handle nested parentheses correctly and apply the correct order of operations. # Example: ```python evaluate_expression(\\"3 + 5 * 2\\") # Output: 13.0 evaluate_expression(\\"(1 + 2) * 3 - 4 / 2\\") # Output: 7.0 evaluate_expression(\\"3.5 + (2.5 * 2)\\") # Output: 8.5 ``` # Performance Requirements: - Ensure that your solution is robust to different expressions, handling spaces and nested parentheses properly. - Aim to maintain a time complexity that ensures quick evaluation for strings up to the specified length. # Note: - You can assume that the input will always be a syntactically correct mathematical expression.","solution":"def evaluate_expression(expression: str) -> float: Evaluates a mathematical expression given as a string and returns the result as a floating-point number. The function handles basic arithmetic operations and respects the order of operations (PEMDAS/BODMAS rule). import re # Remove spaces expression = expression.replace(\' \', \'\') def evaluate_simple_expression(expr): Evaluates a simple expression without parentheses. return eval(expr) def evaluate(expr): Recursively evaluates an expression with nested parentheses. # Find and evaluate parentheses first while \'(\' in expr: expr = re.sub(r\'([^()]+)\', lambda x: str(evaluate_simple_expression(x.group()[1:-1])), expr) # Evaluate the remaining simple expression return evaluate_simple_expression(expr) return float(evaluate(expression))"},{"question":"# Python Coding Challenge Context: You are given a task involving the manipulation and reversal of strings within a list. Objective: Write a function `reverse_words_in_list(words_list: List[str]) -> List[str]` that takes a list of strings and returns a new list where each string in the original list is reversed. Input: The input is a single list of strings `words_list` where each string consists of lowercase alphabetical characters. Output: The output should be a new list of strings where each string is the reversed version of the corresponding string in the input list. Constraints: - Each string in the list will have a length in the range ( 1 leq text{len}(string) leq 100 ). - The list will have a length in the range ( 1 leq text{len}(words_list) leq 10^3 ). Examples: ```python >>> reverse_words_in_list([\\"hello\\", \\"world\\"]) [\\"olleh\\", \\"dlrow\\"] >>> reverse_words_in_list([\\"python\\", \\"is\\", \\"fun\\"]) [\\"nohtyp\\", \\"si\\", \\"nuf\\"] >>> reverse_words_in_list([\\"abcd\\", \\"efgh\\"]) [\\"dcba\\", \\"hgfe\\"] >>> reverse_words_in_list([\\"a\\", \\"b\\", \\"c\\"]) [\\"a\\", \\"b\\", \\"c\\"] ``` Performance Requirement: Ensure that your solution handles the upper limits efficiently. Good luck!","solution":"from typing import List def reverse_words_in_list(words_list: List[str]) -> List[str]: Takes a list of strings and returns a new list where each string is reversed. :param words_list: List of strings where each string consists of lowercase alphabetical characters. :return: List of strings where each string is the reversed version of the corresponding string in the input list. return [word[::-1] for word in words_list]"},{"question":"# Scenario A developer is working on a program that performs basic operations on a sequence of integers received as input. The task is to implement a functionality that returns certain statistical properties and transformations of the sequence. # Task Description Implement a function `process_sequence` that takes a list of integers `sequence` and returns a dictionary containing the following keys and their corresponding values: - `sorted`: The list of integers sorted in ascending order. - `max_value`: The highest integer in the sequence. - `min_value`: The lowest integer in the sequence. - `average`: The average of all the integers in the sequence. - `median`: The median value of the sequence. # Function Signature ```python def process_sequence(sequence: list[int]) -> dict: pass ``` # Input * A list of integers `sequence` where: - 1 ≤ len(sequence) ≤ 10^4 - -10^6 ≤ sequence[i] ≤ 10^6 for all valid `i` # Output * A dictionary with the following structure: ```python { \'sorted\': List[int], \'max_value\': int, \'min_value\': int, \'average\': float, \'median\': float } ``` # Constraints * The input list will contain at least one element. # Example Example 1 ```python sequence = [3, 1, 4, 1, 5, 9, 2] print(process_sequence(sequence)) # Output: # { # \'sorted\': [1, 1, 2, 3, 4, 5, 9], # \'max_value\': 9, # \'min_value\': 1, # \'average\': 3.5714285714285716, # \'median\': 3.0 # } ``` Example 2 ```python sequence = [7, 3, 3, 1, 2] print(process_sequence(sequence)) # Output: # { # \'sorted\': [1, 2, 3, 3, 7], # \'max_value\': 7, # \'min_value\': 1, # \'average\': 3.2, # \'median\': 3.0 # } ``` # Notes * The average should be computed as a floating point number. * The median is also expected to be a floating point number.","solution":"def process_sequence(sequence: list[int]) -> dict: Takes a list of integers and returns a dictionary containing: - sorted: The list of integers sorted in ascending order. - max_value: The highest integer in the sequence. - min_value: The lowest integer in the sequence. - average: The average of all the integers in the sequence. - median: The median value of the sequence. # Sort the sequence sorted_sequence = sorted(sequence) # Calculate max and min values max_value = max(sequence) min_value = min(sequence) # Calculate average average = sum(sequence) / len(sequence) # Calculate median n = len(sequence) mid = n // 2 if n % 2 == 0: # even length median = (sorted_sequence[mid - 1] + sorted_sequence[mid]) / 2 else: # odd length median = sorted_sequence[mid] return { \'sorted\': sorted_sequence, \'max_value\': max_value, \'min_value\': min_value, \'average\': average, \'median\': median }"},{"question":"# Question: Implement a Simple Markdown to HTML Converter Context Markdown is a lightweight markup language commonly used to format README files and write messages in forums and online communities. In this task, you will implement a simplified Markdown to HTML converter. Objective Write a class `MarkdownConverter` with methods to convert basic Markdown formatted text into HTML. The Markdown syntax you need to support includes: - Headers (from `#` to ``) - Bold text (`**bold**` or `__bold__`) - Italic text (`*italic*` or `_italic_`) - Unordered lists (lines starting with `- `) - Inline code (`code` inside backticks `` ` ``) Methods to Implement * `convert_header(line: str) -> str`: Converts a Markdown header line to an HTML header. * `convert_bold_italic(line: str) -> str`: Converts Markdown bold and italic formatting to HTML. * `convert_list(lines: List[str]) -> str`: Converts Markdown unordered list lines to HTML. * `convert_code(line: str) -> str`: Converts Markdown inline code to HTML. * `convert_markdown(markdown: str) -> str`: Converts the entire Markdown text to HTML. Input and Output * **Input**: * For `convert_header`: A single string line containing a Markdown header. * For `convert_bold_italic`: A single string line containing Markdown bold and/or italic text. * For `convert_list`: A list of string lines representing an unordered list. * For `convert_code`: A single string line containing Markdown inline code. * For `convert_markdown`: A string containing multiple lines of Markdown text. * **Outputs**: * For `convert_header`: A string containing the corresponding HTML header. * For `convert_bold_italic`: A string containing the corresponding HTML formatted text. * For `convert_list`: A string containing the corresponding HTML unordered list. * For `convert_code`: A string containing the corresponding HTML code. * For `convert_markdown`: A string containing the full HTML converted from Markdown. Constraints * Only valid Markdown syntax as outlined in the given rules is used in the inputs. * All line inputs are valid and within expected bounds. * Methods should handle single lines and multi-line inputs appropriately. Examples ```python converter = MarkdownConverter() # Header conversion assert converter.convert_header(\'# Header 1\') == \'<h1>Header 1</h1>\' assert converter.convert_header(\' Header 6\') == \'<h6>Header 6</h6>\' # Bold and italic conversion assert converter.convert_bold_italic(\'This is **bold** text\') == \'This is <b>bold</b> text\' assert converter.convert_bold_italic(\'This is *italic* text\') == \'This is <i>italic</i> text\' assert converter.convert_bold_italic(\'This is __bold__ and _italic_\') == \'This is <b>bold</b> and <i>italic</i>\' # Unordered list conversion assert converter.convert_list([\'- Item 1\', \'- Item 2\', \'- Item 3\']) == \'<ul><li>Item 1</li><li>Item 2</li><li>Item 3</li></ul>\' # Inline code conversion assert converter.convert_code(\'This is `inline code`\') == \'This is <code>inline code</code>\' # Full markdown conversion markdown_text = \'\'\'# Title This is a paragraph with **bold** and _italic_ text. Here is a list: - Item 1 - Item 2 - Item 3 Here is `inline code`.\'\'\' expected_html = \'\'\'<h1>Title</h1> <p>This is a paragraph with <b>bold</b> and <i>italic</i> text.</p> <p>Here is a list:</p> <ul><li>Item 1</li><li>Item 2</li><li>Item 3</li></ul> <p>Here is <code>inline code</code>.</p>\'\'\' assert converter.convert_markdown(markdown_text) == expected_html ```","solution":"import re class MarkdownConverter: def convert_header(self, line: str) -> str: match = re.match(r\'^(#{1,6})s+(.*)\', line) if match: header_level = len(match.group(1)) header_text = match.group(2) return f\\"<h{header_level}>{header_text}</h{header_level}>\\" return line def convert_bold_italic(self, line: str) -> str: line = re.sub(r\'**(.*?)**\', r\'<b>1</b>\', line) line = re.sub(r\'__(.*?)__\', r\'<b>1</b>\', line) line = re.sub(r\'*(.*?)*\', r\'<i>1</i>\', line) line = re.sub(r\'_(.*?)_\', r\'<i>1</i>\', line) return line def convert_list(self, lines: list[str]) -> str: list_items = \'\'.join(f\\"<li>{line[2:]}</li>\\" for line in lines if line.startswith(\'- \')) return f\\"<ul>{list_items}</ul>\\" def convert_code(self, line: str) -> str: return re.sub(r\'`(.*?)`\', r\'<code>1</code>\', line) def convert_markdown(self, markdown: str) -> str: sections = markdown.split(\'n\') html = [] list_buffer = [] in_list = False for line in sections: if line.startswith(\'#\'): if in_list: html.append(self.convert_list(list_buffer)) list_buffer = [] in_list = False html.append(self.convert_header(line)) elif line.startswith(\'- \'): list_buffer.append(line) in_list = True elif line.strip() == \\"\\": if in_list: html.append(self.convert_list(list_buffer)) list_buffer = [] in_list = False html.append(\\"<br>\\") else: if in_list: html.append(self.convert_list(list_buffer)) list_buffer = [] in_list = False line = self.convert_bold_italic(line) line = self.convert_code(line) html.append(f\\"<p>{line}</p>\\") if in_list: html.append(self.convert_list(list_buffer)) return \'n\'.join(html)"},{"question":"# Scenario: You need to implement a self-balancing Binary Search Tree (BST) to manage a dynamic set of elements while maintaining order and optimizing search operations. The BST should support efficient insertions and deletions while ensuring the tree remains balanced. You are particularly required to focus on creating a function to **insert** a value and a function to **delete** a value from the tree. # Requirements: 1. **Insert operation** should add a new value while maintaining the BST properties and keeping the tree balanced. 2. **Delete operation** should remove a given value, if it exists, while keeping the tree balanced. # Function Specification: 1. **Insert Function**: ```python def insert(self, val: int) -> None: Inserts a value into the self-balancing BST. Parameters: val (int): Value to be inserted. # Your implementation here ``` 2. **Delete Function**: ```python def delete(self, val: int) -> None: Deletes a value from the self-balancing BST if it exists. Parameters: val (int): Value to be deleted. # Your implementation here ``` # Constraints: - **Tree Size**: 1 <= size of the tree <= 10^5 - **Value Range**: All values in the tree are integers within the range [-10^9, 10^9] # Performance Requirements: - Insert and delete operations should maintain logarithmic time complexity relative to the number of elements in the tree, ensuring the tree remains balanced. # Example Usage: ```python # Initialize the self-balancing BST tree = SelfBalancingBST() # Insert elements into the tree tree.insert(10) tree.insert(5) tree.insert(20) # Check if an element exists in the tree (pseudocode) exists = tree.contains(5) # Should return True # Delete an element from the tree tree.delete(5) # Verify the element is deleted exists = tree.contains(5) # Should return False ``` Ensure that the operations insert and delete follow the constraints and perform efficiently, maintaining the tree\'s balance.","solution":"class TreeNode: def __init__(self, key): self.left = None self.right = None self.val = key self.height = 1 # Height of this node for AVL balancing class SelfBalancingBST: def __init__(self): self.root = None def insert(self, key): def _insert(node, key): if not node: return TreeNode(key) if key < node.val: node.left = _insert(node.left, key) else: node.right = _insert(node.right, key) node.height = 1 + max(self.get_height(node.left), self.get_height(node.right)) balance = self.get_balance(node) # Left Left Case if balance > 1 and key < node.left.val: return self.right_rotate(node) # Right Right Case if balance < -1 and key > node.right.val: return self.left_rotate(node) # Left Right Case if balance > 1 and key > node.left.val: node.left = self.left_rotate(node.left) return self.right_rotate(node) # Right Left Case if balance < -1 and key < node.right.val: node.right = self.right_rotate(node.right) return self.left_rotate(node) return node self.root = _insert(self.root, key) def delete(self, key): def _delete(node, key): if not node: return node if key < node.val: node.left = _delete(node.left, key) elif key > node.val: node.right = _delete(node.right, key) else: if not node.left: return node.right elif not node.right: return node.left temp = self.get_min_value_node(node.right) node.val = temp.val node.right = _delete(node.right, temp.val) node.height = 1 + max(self.get_height(node.left), self.get_height(node.right)) balance = self.get_balance(node) # Left Left Case if balance > 1 and self.get_balance(node.left) >= 0: return self.right_rotate(node) # Left Right Case if balance > 1 and self.get_balance(node.left) < 0: node.left = self.left_rotate(node.left) return self.right_rotate(node) # Right Right Case if balance < -1 and self.get_balance(node.right) <= 0: return self.left_rotate(node) # Right Left Case if balance < -1 and self.get_balance(node.right) > 0: node.right = self.right_rotate(node.right) return self.left_rotate(node) return node self.root = _delete(self.root, key) def left_rotate(self, z): y = z.right T2 = y.left y.left = z z.right = T2 z.height = 1 + max(self.get_height(z.left), self.get_height(z.right)) y.height = 1 + max(self.get_height(y.left), self.get_height(y.right)) return y def right_rotate(self, z): y = z.left T3 = y.right y.right = z z.left = T3 z.height = 1 + max(self.get_height(z.left), self.get_height(z.right)) y.height = 1 + max(self.get_height(y.left), self.get_height(y.right)) return y def get_min_value_node(self, node): if node is None or node.left is None: return node return self.get_min_value_node(node.left) def get_height(self, node): if not node: return 0 return node.height def get_balance(self, node): if not node: return 0 return self.get_height(node.left) - self.get_height(node.right) def contains(self, key): def _contains(node, key): if not node: return False if key == node.val: return True elif key < node.val: return _contains(node.left, key) else: return _contains(node.right, key) return _contains(self.root, key)"}]'),F={name:"App",components:{PoemCard:C},data(){return{searchQuery:"",visibleCount:4,poemsData:S,isLoading:!1}},computed:{filteredPoems(){const r=this.searchQuery.trim().toLowerCase();return r?this.poemsData.filter(e=>e.question&&e.question.toLowerCase().includes(r)||e.solution&&e.solution.toLowerCase().includes(r)):this.poemsData},displayedPoems(){return this.searchQuery.trim()?this.filteredPoems:this.filteredPoems.slice(0,this.visibleCount)},hasMorePoems(){return!this.searchQuery.trim()&&this.visibleCount<this.poemsData.length}},methods:{async loadMore(){this.isLoading=!0,await new Promise(r=>setTimeout(r,1e3)),this.visibleCount+=4,this.isLoading=!1}}},O={class:"search-container"},R={class:"card-container"},N={key:0,class:"empty-state"},L=["disabled"],z={key:0},P={key:1};function D(r,e,l,p,s,a){const m=g("PoemCard");return n(),i("section",null,[e[4]||(e[4]=t("div",{class:"top-banner"},[t("div",{class:"top-banner-title"},[t("div",{class:"top-banner-title-text"},"🤔prompts chat🧠")])],-1)),t("div",O,[e[3]||(e[3]=t("span",{class:"search-icon"},"🔍",-1)),_(t("input",{type:"text",class:"search-input","onUpdate:modelValue":e[0]||(e[0]=o=>s.searchQuery=o),placeholder:"Search..."},null,512),[[y,s.searchQuery]]),s.searchQuery?(n(),i("button",{key:0,class:"clear-search",onClick:e[1]||(e[1]=o=>s.searchQuery="")}," ✕ ")):u("",!0)]),t("div",R,[(n(!0),i(b,null,v(a.displayedPoems,(o,f)=>(n(),w(m,{key:f,poem:o},null,8,["poem"]))),128)),a.displayedPoems.length===0?(n(),i("div",N,' No results found for "'+d(s.searchQuery)+'". ',1)):u("",!0)]),a.hasMorePoems?(n(),i("button",{key:0,class:"load-more-button",disabled:s.isLoading,onClick:e[2]||(e[2]=(...o)=>a.loadMore&&a.loadMore(...o))},[s.isLoading?(n(),i("span",P,"Loading...")):(n(),i("span",z,"See more"))],8,L)):u("",!0)])}const j=h(F,[["render",D],["__scopeId","data-v-958f2395"]]),B=JSON.parse('{"title":"","description":"","frontmatter":{"page":true},"headers":[],"relativePath":"drive/37.md","filePath":"drive/37.md"}'),Y={name:"drive/37.md"},V=Object.assign(Y,{setup(r){return(e,l)=>(n(),i("div",null,[x(j)]))}});export{B as __pageData,V as default};
