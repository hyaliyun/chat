import{_ as c,o as n,c as i,a as t,m as h,t as d,C as g,M as _,U as y,f as u,F as b,p as v,e as w,q as x}from"./chunks/framework.B1z0IdBH.js";const k={name:"PoemCard",props:{poem:{type:Object,required:!0}}},T={class:"poem-container"},q={class:"review"},I={class:"review-title"},N={class:"review-content"};function E(r,e,l,p,a,s){return n(),i("div",T,[t("div",q,[t("div",I,[e[0]||(e[0]=t("span",{class:"icon"},"question:",-1)),h(d(l.poem.question),1)]),e[2]||(e[2]=t("div",{class:"divider"},null,-1)),t("p",N,[e[1]||(e[1]=t("span",{class:"icon"},"answer:",-1)),h(d(l.poem.solution),1)])])])}const A=c(k,[["render",E],["__scopeId","data-v-f1a3b3cb"]]),O=JSON.parse('[{"question":"**Objective**: Demonstrate your understanding of dynamic programming and integer partitioning. # Problem Statement You are given a positive integer `n`. Your task is to write a Python function `count_partitions(n)` that returns the number of distinct ways to partition `n` into a sum of positive integers. Each partition should be a non-increasing sequence of integers. # Function Signature ```python def count_partitions(n: int) -> int: ``` # Input * An integer `n` where (1 leq n leq 100). # Output * An integer representing the number of distinct ways to partition `n`. # Constraints * Time complexity should be (O(n^2)). * Space complexity should be (O(n^2)). # Example ```python assert count_partitions(4) == 5 assert count_partitions(7) == 15 ``` # Explanation For `n = 4`, the possible partitions are: ``` 4 3 + 1 2 + 2 2 + 1 + 1 1 + 1 + 1 + 1 ``` For `n = 7`, the possible partitions are: ``` 7 6 + 1 5 + 2 5 + 1 + 1 4 + 3 4 + 2 + 1 4 + 1 + 1 + 1 3 + 3 + 1 3 + 2 + 2 3 + 2 + 1 + 1 3 + 1 + 1 + 1 + 1 2 + 2 + 2 + 1 2 + 2 + 1 + 1 + 1 2 + 1 + 1 + 1 + 1 + 1 1 + 1 + 1 + 1 + 1 + 1 + 1 ``` # Implementation Note You may refer to the dynamic programming table approach for the integer partition problem. Make sure to follow proper initialization and controlled looping for accurate results. **Hint**: Use a 2-dimensional dynamic programming table where `dp[i][j]` represents the number of ways to partition `i` using integers up to `j`.","solution":"def count_partitions(n: int) -> int: # Initialize the dp table dp = [[0] * (n + 1) for _ in range(n + 1)] # Base case: There is one way to partition the number 0 (using no numbers) for i in range(n + 1): dp[0][i] = 1 # Fill the dp table for i in range(1, n + 1): for j in range(1, n + 1): if j > i: dp[i][j] = dp[i][i] else: dp[i][j] = dp[i][j - 1] + dp[i - j][j] # The number of ways to partition n using any numbers up to n return dp[n][n]"},{"question":"# Separate Chaining Hash Table Extension As a software developer, you are responsible for maintaining and upgrading a library that implements a separate chaining hash table. The current implementation supports basic insertion, deletion, and retrieval of key-value pairs. To assess your understanding and skills, implement the following additional functionalities to the `SeparateChainingHashTable`: 1. **Resize**: Implement a method to resize the hash table when the load factor exceeds a specified threshold to maintain efficient operations. 2. **Keys**: Provide a method to return all keys in the hash table. 3. **Values**: Provide a method to return all values in the hash table. # Task Extend the `SeparateChainingHashTable` class with the following methods: Methods to Implement: 1. `resize(new_size: int) -> None`: Resizes the hash table to a new bucket size and rehashes all existing entries. 2. `keys() -> list`: Returns a list of all keys currently stored in the hash table. 3. `values() -> list`: Returns a list of all values currently stored in the hash table. # Constraints & Requirements: * For the sake of this exercise, assume the initial implementation is provided and the following constraints hold: - Keys are unique and hashable. - The size of the hash table should double when resized and rehashed. * The load factor (number of elements/number of buckets) threshold for resizing should be specified as a parameter or class variable (e.g., 0.75). # Example Usage: ```python # Initialize hash table with default size table = SeparateChainingHashTable() # Insert elements table.put(\'key1\', \'value1\') table.put(\'key2\', \'value2\') table.put(\'key3\', \'value3\') # Retrieve keys and values print(table.keys()) # Output: [\'key1\', \'key2\', \'key3\'] print(table.values()) # Output: [\'value1\', \'value2\', \'value3\'] # Induce resize by putting more elements table.put(\'key4\', \'value4\') table.put(\'key5\', \'value5\') # Resize should be triggered internally if the load factor exceeds the threshold # Verify if all elements are still accessible print(table.get(\'key1\')) # Output: \'value1\' print(table.get(\'key5\')) # Output: \'value5\' ``` # Implementation Hints: - Ensure `resize` adjusts the size of `_table` and rehashes all existing nodes to their new positions. - `keys` and `values` should traverse all buckets and linked lists to collect the required information.","solution":"class SeparateChainingHashTable: def __init__(self, size=10, load_factor_threshold=0.75): self.initial_size = size self._size = size self._load_factor_threshold = load_factor_threshold self._table = [[] for _ in range(size)] self._num_elements = 0 def _hash(self, key): return hash(key) % self._size def put(self, key, value): hash_index = self._hash(key) for item in self._table[hash_index]: if item[0] == key: item[1] = value return self._table[hash_index].append([key, value]) self._num_elements += 1 if self._num_elements / self._size > self._load_factor_threshold: self.resize(self._size * 2) def get(self, key): hash_index = self._hash(key) for item in self._table[hash_index]: if item[0] == key: return item[1] return None def delete(self, key): hash_index = self._hash(key) for i, item in enumerate(self._table[hash_index]): if item[0] == key: del self._table[hash_index][i] self._num_elements -= 1 return True return False def resize(self, new_size): old_table = self._table self._table = [[] for _ in range(new_size)] self._size = new_size old_num_elements = self._num_elements self._num_elements = 0 for bucket in old_table: for key, value in bucket: self.put(key, value) self._num_elements = old_num_elements def keys(self): keys = [] for bucket in self._table: for key, _ in bucket: keys.append(key) return keys def values(self): values = [] for bucket in self._table: for _, value in bucket: values.append(value) return values"},{"question":"# AVL Tree Coding Challenge Context: You have been hired to improve the implementation of a database indexing system by incorporating a self-balancing AVL Tree. This will ensure efficient search, insertion, and deletion operations, crucial for the performance of the system. Problem Statement: Implement a function for the AVL Tree that: 1. Inserts elements and maintains tree balance. 2. Removes elements while ensuring the tree remains balanced after deletion. Function Signatures: ```python class TreeNode: def __init__(self, key): self.key = key self.left = None self.right = None ``` ```python class AvlTree: def __init__(self): self.node = None self.height = -1 self.balance = 0 def insert(self, key: int) -> None: pass def delete(self, key: int) -> None: pass def in_order_traverse(self) -> list: pass ``` Requirements: - **Insert Function**: Given an integer, insert it into the AVL Tree and preserve its balance. - **Delete Function**: Given an integer key, delete it from the AVL Tree and maintain balance. - **In-Order Traversal Function**: Implement an in-order traversal that returns the elements in sorted order. Constraints: - Input keys are unique integers. - AVL Tree must remain balanced after each insertion and deletion. - The number of operations (insertions and deletions) will not exceed 10^6 in aggregate. Example: ```python avl = AvlTree() avl.insert(10) avl.insert(20) avl.insert(30) avl.insert(15) print(avl.in_order_traverse()) # Output: [10, 15, 20, 30] avl.delete(20) print(avl.in_order_traverse()) # Output: [10, 15, 30] ``` Performance: - Your solution should efficiently handle large inputs and maintain a balanced tree after multiple operations.","solution":"class TreeNode: def __init__(self, key): self.key = key self.left = None self.right = None self.height = 1 class AvlTree: def __init__(self): self.root = None def insert(self, key: int) -> None: self.root = self._insert(self.root, key) def _insert(self, node, key): if not node: return TreeNode(key) elif key < node.key: node.left = self._insert(node.left, key) else: node.right = self._insert(node.right, key) node.height = 1 + max(self._get_height(node.left), self._get_height(node.right)) balance = self._get_balance(node) if balance > 1 and key < node.left.key: return self._right_rotate(node) if balance < -1 and key > node.right.key: return self._left_rotate(node) if balance > 1 and key > node.left.key: node.left = self._left_rotate(node.left) return self._right_rotate(node) if balance < -1 and key < node.right.key: node.right = self._right_rotate(node.right) return self._left_rotate(node) return node def delete(self, key: int) -> None: self.root = self._delete(self.root, key) def _delete(self, node, key): if not node: return node elif key < node.key: node.left = self._delete(node.left, key) elif key > node.key: node.right = self._delete(node.right, key) else: if node.left is None: return node.right elif node.right is None: return node.left temp_val = self._get_min_value_node(node.right) node.key = temp_val.key node.right = self._delete(node.right, temp_val.key) node.height = 1 + max(self._get_height(node.left), self._get_height(node.right)) balance = self._get_balance(node) if balance > 1 and self._get_balance(node.left) >= 0: return self._right_rotate(node) if balance < -1 and self._get_balance(node.right) <= 0: return self._left_rotate(node) if balance > 1 and self._get_balance(node.left) < 0: node.left = self._left_rotate(node.left) return self._right_rotate(node) if balance < -1 and self._get_balance(node.right) > 0: node.right = self._right_rotate(node.right) return self._left_rotate(node) return node def _get_min_value_node(self, node): if node is None or node.left is None: return node return self._get_min_value_node(node.left) def _get_height(self, node): if not node: return 0 return node.height def _get_balance(self, node): if not node: return 0 return self._get_height(node.left) - self._get_height(node.right) def _left_rotate(self, z): y = z.right T2 = y.left y.left = z z.right = T2 z.height = 1 + max(self._get_height(z.left), self._get_height(z.right)) y.height = 1 + max(self._get_height(y.left), self._get_height(y.right)) return y def _right_rotate(self, z): y = z.left T3 = y.right y.right = z z.left = T3 z.height = 1 + max(self._get_height(z.left), self._get_height(z.right)) y.height = 1 + max(self._get_height(y.left), self._get_height(y.right)) return y def in_order_traverse(self) -> list: result = [] self._in_order_traverse(self.root, result) return result def _in_order_traverse(self, node, result): if not node: return self._in_order_traverse(node.left, result) result.append(node.key) self._in_order_traverse(node.right, result)"},{"question":"# Special Digit Powers Context In number theory, there exist certain numbers whose digits, when raised to consecutive powers starting from 1, sum up to the number itself. Task Write a function `special_digit_powers(low, high)` that returns a list of numbers within the range `[low, high]` (inclusive) such that the number equals the sum of its digits raised to powers corresponding to their positions. Input - An integer `low` representing the lower bound of the range (inclusive). - An integer `high` representing the upper bound of the range (inclusive). Output - A list of integers that meet the condition described; the integers should be in ascending order. Constraints - `0 <= low <= high <= 10^4` Examples 1. `special_digit_powers(1, 10)` should return `[1, 2, 3, 4, 5, 6, 7, 8, 9]` because all single-digit numbers trivially satisfy the property. 2. `special_digit_powers(1, 100)` should return `[1, 2, 3, 4, 5, 6, 7, 8, 9, 89]` because 89 = 8^1 + 9^2. Edge Cases - When `low` is greater than `high`, the function should return an empty list. - When `low` or `high` are negative, the function should ignore these and return appropriate results based on positive integers within the range. Performance Requirements - Ensure the function works efficiently within the given constraints. - Minimize redundant computations where possible.","solution":"def special_digit_powers(low, high): Returns a list of special digit power numbers within the range [low, high]. def is_special_num(num): Check if a number is a special digit power number. str_num = str(num) return num == sum(int(digit) ** (idx + 1) for idx, digit in enumerate(str_num)) return [num for num in range(low, high + 1) if is_special_num(num)]"},{"question":"# Context You are working on a social network application where users are represented as nodes in a graph. Each user node can have multiple connections to other users. To efficiently test new features on a replica of the social network, you need to create an exact copy of the entire graph. # Problem Statement Write a function `clone_social_network` that creates an exact copy of a given undirected graph representing the social network. The graph is represented using instances of the `UndirectedGraphNode` class. ```python class UndirectedGraphNode: def __init__(self, label: int): self.label = label self.neighbors = [] def add_neighbor(self, node: \'UndirectedGraphNode\'): self.neighbors.append(node) ``` # Requirements * Implement a function `clone_social_network(node: \'UndirectedGraphNode\') -> \'UndirectedGraphNode\'` which takes the root node of an undirected graph and returns the root node of a new cloned graph. * Maintain the original structure and connections in the cloned graph. * Ensure nodes are uniquely identified by their labels. * Ensure the algorithm works efficiently for large graphs. # Input Format * The input node can be `None`, indicating an empty graph. * Each node\'s label is unique and is an integer. * Each node can have zero or more neighbors (other nodes). # Output Format * The function should return the root node of the cloned graph. # Example ```python # Assuming the following graph structure: # 1 - 2 # | # 3 node1 = UndirectedGraphNode(1) node2 = UndirectedGraphNode(2) node3 = UndirectedGraphNode(3) node1.add_neighbor(node2) node1.add_neighbor(node3) cloned_node1 = clone_social_network(node1) assert cloned_node1 is not node1 assert cloned_node1.label == 1 assert len(cloned_node1.neighbors) == 2 assert cloned_node1.neighbors[0].label in {2, 3} assert cloned_node1.neighbors[1].label in {2, 3} ``` # Constraints * Do not use any external libraries. * The function should handle graphs with up to 10^3 nodes without significant performance degradation. * Minimize the use of memory.","solution":"class UndirectedGraphNode: def __init__(self, label: int): self.label = label self.neighbors = [] def add_neighbor(self, node: \'UndirectedGraphNode\'): self.neighbors.append(node) def clone_social_network(node: \'UndirectedGraphNode\') -> \'UndirectedGraphNode\': if node is None: return None # A dictionary to keep track of cloned nodes cloned_nodes = {} def clone(node: \'UndirectedGraphNode\') -> \'UndirectedGraphNode\': if node in cloned_nodes: return cloned_nodes[node] # Clone the node cloned_node = UndirectedGraphNode(node.label) cloned_nodes[node] = cloned_node # Clone all the neighbors for neighbor in node.neighbors: cloned_node.add_neighbor(clone(neighbor)) return cloned_node return clone(node)"},{"question":"You are given a list of integers `lst` and an integer `N`. Your task is to create a new list where each integer appears at most `N` times, while preserving the original order. # Requirements * Implement a function `constrain_frequencies(lst, N)`: * **Input**: - `lst` (List of integers): The input list of numbers. - `N` (Integer): The maximum allowed frequency for any number in the output list. * **Output**: - A list of integers where every number appears no more than `N` times, maintaining the original order. # Constraints * 1 <= len(lst) <= 10^5 * -10^6 <= element in lst <= 10^6 * 1 <= N <= len(lst) # Example ```python def constrain_frequencies(lst, N): # Your implementation here # Example usage input_lst = [1, 2, 3, 1, 2, 1, 2, 3] N = 2 print(constrain_frequencies(input_lst, N)) # Output: [1, 2, 3, 1, 2, 3] ``` # Explanation In the example, each number in the input list appears at most twice in the output. The occurrences are controlled while preserving the input\'s order. # Hints - You may find using a dictionary or a similar data structure useful to keep track of elements and their occurrences efficiently.","solution":"def constrain_frequencies(lst, N): Returns a new list where each integer in the input list appears at most N times. Parameters: lst (list): The input list of integers. N (int): The maximum allowed frequency for any number in the output list. Returns: list: A list of integers where each number appears no more than N times, maintaining the original order. from collections import defaultdict frequency_dict = defaultdict(int) constrained_list = [] for num in lst: if frequency_dict[num] < N: constrained_list.append(num) frequency_dict[num] += 1 return constrained_list"},{"question":"Sum of Digits Raised to Consecutive Powers **Scenario:** Given a range of numbers, identify all numbers within this range that can be expressed as the sum of their digits raised to consecutive powers, starting from the first power. For example, the number 89 has this property because 8^1 + 9^2 = 89. **Task:** Write a function `sum_dig_pow(low, high)` that returns a list of numbers within the range `[low, high]` that have this property. **Function Signature:** ```python def sum_dig_pow(low: int, high: int) -> List[int]: pass ``` **Input:** - `low`: an integer representing the lower bound of the range (inclusive). - `high`: an integer representing the upper bound of the range (inclusive). **Output:** - A list of integers that satisfy the specified property within the given range. **Constraints:** - 1 <= low <= high <= 10^6 **Example:** ```python # Example 1 assert sum_dig_pow(1, 10) == [1, 2, 3, 4, 5, 6, 7, 8, 9] # Example 2 assert sum_dig_pow(1, 100) == [1, 2, 3, 4, 5, 6, 7, 8, 9, 89] ``` **Performance Requirements:** - The solution should be optimized to handle ranges up to 10^6 efficiently. **Hints:** - Consider breaking down the problem into smaller tasks such as digit extraction and power summation. - Be mindful of the computational cost associated with the power calculations for each digit.","solution":"def sum_dig_pow(low, high): Returns a list of numbers within the range [low, high] that can be expressed as the sum of their digits raised to consecutive powers starting from 1. def is_eureka_number(n): digits = list(map(int, str(n))) return n == sum(digit ** (idx + 1) for idx, digit in enumerate(digits)) return [num for num in range(low, high + 1) if is_eureka_number(num)] # Example Usage: # print(sum_dig_pow(1, 100)) # Output: [1, 2, 3, 4, 5, 6, 7, 8, 9, 89]"},{"question":"# Scenario You are tasked to build a system that ensures data integrity by comparing cloned versions of data trees. Your function should verify if two binary trees are structurally identical and have the same node values. Implement a function that checks for this equality. # Function Signature ```python def is_identical_tree(tree1: \'TreeNode\', tree2: \'TreeNode\') -> bool: pass ``` # Input/Output * **Input**: * `tree1`: The root node of the first binary tree. * `tree2`: The root node of the second binary tree. * **Output**: * `bool`: Returns `True` if both trees are structurally identical and have the same node values, else `False`. # Constraints * The number of nodes in each tree is in the range [0, 10^4]. * Node values are integers and may include negative numbers. # Performance Requirements - Your solution should be efficient with respect to both time and space complexity, ideally O(min(N, M)) for time and O(min(height1, height2)) for space. # Example ```python # Definition for a binary tree node. class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right # Example 1: # Tree 1: 1 Tree 2: 1 # / / # 2 3 2 3 # Both trees are identical. tree1 = TreeNode(1, TreeNode(2), TreeNode(3)) tree2 = TreeNode(1, TreeNode(2), TreeNode(3)) print(is_identical_tree(tree1, tree2)) # Output: True # Example 2: # Tree 1: 1 Tree 2: 1 # / / # 2 1 1 2 # Trees are not identical. tree1 = TreeNode(1, TreeNode(2), TreeNode(1)) tree2 = TreeNode(1, TreeNode(1), TreeNode(2)) print(is_identical_tree(tree1, tree2)) # Output: False ``` *Assume the TreeNode class is provided and you need to write the `is_identical_tree` function.*","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_identical_tree(tree1: TreeNode, tree2: TreeNode) -> bool: # Both trees are empty if tree1 is None and tree2 is None: return True # One tree is empty, the other is not if tree1 is None or tree2 is None: return False # Check if the current nodes\' values are equal and recursively check left and right subtrees return (tree1.val == tree2.val and is_identical_tree(tree1.left, tree2.left) and is_identical_tree(tree1.right, tree2.right))"},{"question":"**Title**: Implement Efficient Large Power Modulo Calculation **Prompt**: You are tasked with implementing a function that calculates ( ( text{base} ^ text{exponent} ) % text{mod} ). This function must be efficient enough to handle very large values of `base` and `exponent`, potentially on the order of ( 10^{18} ) or more. **Function Signature**: ```python def large_power_mod(base: int, exponent: int, mod: int) -> int: pass ``` **Detailed Requirements**: 1. **Inputs**: - `base` (int): The base number to be raised to the power of `exponent`. - `exponent` (int): The exponent to which the `base` is raised. It will be non-negative. - `mod` (int): The modulo value by which the final result is reduced, greater than 1. 2. **Output**: - Returns the value ( ( text{base} ^ text{exponent} ) % text{mod} ) as an integer. 3. **Constraints**: - (0 leq text{base} leq 10^{18}) - (0 leq text{exponent} leq 10^{18}) - (2 leq text{mod} leq 10^{18}) 4. **Performance Requirement**: Your implementation must run in ( O(log(text{exponent})) ) time complexity. **Examples**: ```python # Example 1 assert large_power_mod(2, 10, 1000) == 24 # Example 2 assert large_power_mod(3, 13, 50) == 23 # Example 3 assert large_power_mod(5, 0, 7) == 1 # Any number raised to 0 is 1 ``` **Scenario**: In cryptographic systems, such as RSA, operations often rely on modular exponentiation to handle large integers efficiently. These systems require calculations like ( a^b % n ) where ( b ) can be very large, making direct computation impractical. Your task is to implement a function that can support such cryptographic requirements efficiently. **Notes**: - Thoroughly test your function for edge cases, such as the smallest and largest inputs within the given constraints. - Consider the mathematical properties and efficiency limitations in your implementation.","solution":"def large_power_mod(base: int, exponent: int, mod: int) -> int: if mod == 1: return 0 result = 1 base = base % mod while exponent > 0: if (exponent % 2) == 1: result = (result * base) % mod exponent = exponent >> 1 base = (base * base) % mod return result"},{"question":"# Maximum Sum of Contiguous Subarray with Indices You are required to extend the provided algorithm to not only find the maximum sum of a contiguous subarray in a given integer array but also return the starting and ending indices of that subarray. Write a function `max_subarray_with_indices` that takes a list of integers as input and returns a tuple containing the maximum sum, the starting index, and the ending index of the subarray. If the array is empty, return a tuple of (0, -1, -1). Input - A list of integers with at least one element. Output - A tuple (max_sum, start_index, end_index) representing the maximum sum of a contiguous subarray and its indices. Constraints - The input array can contain both positive and negative integers. - The input array will have a size of at most 10^6 elements. # Example ```python # Example 1 input_array = [1, 2, -3, 4, 5, -7, 23] # Expected output: (25, 3, 6) # Explanation: The subarray [4, 5, -7, 23] has the maximum sum of contiguous subarray which is 25 and the indices are from 3 to 6 (0-based index). # Example 2 input_array = [-1, -2, -3, -4] # Expected output: (-1, 0, 0) # Explanation: The subarray containing the maximum sum is [-1] with sum -1 and indices from 0 to 0. ``` You need to implement the function as described below: ```python def max_subarray_with_indices(array): # Implement the algorithm to find max sum with indices pass ``` Guidelines - Ensure you consider edge cases such as an array with all negative numbers. - Optimize your solution to run in O(n) time complexity and O(1) space complexity. - Handle cases where the input array is empty.","solution":"def max_subarray_with_indices(array): if not array: return (0, -1, -1) max_sum = current_sum = array[0] start = end = temp_start = 0 for i in range(1, len(array)): if current_sum + array[i] > array[i]: current_sum += array[i] else: current_sum = array[i] temp_start = i if current_sum > max_sum: max_sum = current_sum start = temp_start end = i return (max_sum, start, end)"},{"question":"# Objective Write a function that applies the Atbash cipher to a given string. The function should convert each alphabetical character to its \\"mirror\\" counterpart in the alphabet, while preserving case and leaving non-alphabetical characters unchanged. # Function Signature ```python def atbash_cipher(text: str) -> str: pass ``` # Input * `text` (string): The input string to be encrypted/decrypted using the Atbash cipher. # Output * `return` (string): The result of applying the Atbash cipher to the input string. # Constraints * The input string `text` can have a length between 1 and 10^4 characters. * The characters in the input string can include any printable ASCII characters. # Examples ```python assert atbash_cipher(\\"Attack at dawn\\") == \\"Zggzxp zg wzdm\\" assert atbash_cipher(\\"Hello, World!\\") == \\"Svool, Dliow!\\" assert atbash_cipher(\\"XYZ xyz\\") == \\"CBA cba\\" assert atbash_cipher(\\"12345\\") == \\"12345\\" assert atbash_cipher(\\"\\") == \\"\\" ``` # Instructions * Implement the `atbash_cipher` function by mapping each letter to its opposite in the alphabet while respecting the case. * Retain all non-alphabet characters in their original form. * Ensure your implementation handles edge cases and large input efficiently.","solution":"def atbash_cipher(text: str) -> str: Apply the Atbash cipher to a given string by converting each alphabetical character to its \\"mirror\\" counterpart in the alphabet while preserving case and leaving non-alphabetical characters unchanged. result = [] for char in text: if \'A\' <= char <= \'Z\': # For uppercase letters result.append(chr(ord(\'Z\') - ord(char) + ord(\'A\'))) elif \'a\' <= char <= \'z\': # For lowercase letters result.append(chr(ord(\'z\') - ord(char) + ord(\'a\'))) else: result.append(char) # Non-alphabetic characters remain unchanged return \'\'.join(result)"},{"question":"# Assessment Question Scenario: You are working on creating a feature for a text processing application that ensures a user-provided string only contains unique characters, preserving the order of their first appearance. This feature could help in cases, such as ensuring unique tags or keywords in search queries. Problem Statement: Write a function `remove_reoccurring_characters` that takes a single string as input and returns a new string with all duplicate characters removed, preserving the order of their first appearance. Input: * A string ( s ) (1 ≤ |s| ≤ 10^5) containing ASCII characters. Output: * A new string with all reoccurring characters removed, preserving the order of their first appearance. Constraints: * The function must run in linear time with respect to the length of the string. * Consider case sensitivity (i.e., \'A\' and \'a\' should be treated as distinct characters). Example: ```python assert remove_reoccurring_characters(\\"programming\\") == \\"progamin\\" assert remove_reoccurring_characters(\\"ababcabcd\\") == \\"abcd\\" assert remove_reoccurring_characters(\\"google\\") == \\"gole\\" assert remove_reoccurring_characters(\\"\\") == \\"\\" ``` Implement the function `remove_reoccurring_characters(s: str) -> str`.","solution":"def remove_reoccurring_characters(s: str) -> str: Removes duplicate characters from the input string, preserving the order of their first appearance. :param s: Input string containing ASCII characters :return: String with duplicates removed seen = set() result = [] for char in s: if char not in seen: seen.add(char) result.append(char) return \'\'.join(result)"},{"question":"# Question You have been tasked with writing an efficient version of the selection sort algorithm that not only sorts the array but also makes it adaptive to the initial order of the elements. The goal is to reduce unnecessary comparisons when the array is already sorted or partially sorted. **Requirements**: * Implement a function `adaptive_selection_sort(arr)`. * The function should take a list of integers `arr` as input and return a list of integers sorted in ascending order. * The function should utilize selection sort principles but with added checks to reduce the number of comparisons when elements are already in the correct places. # Constraints * The input list length, n, will be (0 leq n leq 10^4). * Elements in the list will be within the range of [-10^6, 10^6]. # Performance Requirements * Aim to minimize the total number of comparisons, especially when the list is already sorted or partially sorted, potentially achieving better than O(n^2) performance in these cases. # Input * `arr` (list of int): A list of integers that needs to be sorted. # Output * (list of int): The list sorted in ascending order. # Examples Example 1 # Input ```python arr = [64, 25, 12, 22, 11] ``` # Output ```python [11, 12, 22, 25, 64] ``` Example 2 # Input ```python arr = [5, 4, 3, 2, 1] ``` # Output ```python [1, 2, 3, 4, 5] ``` Example 3 # Input ```python arr = [1, 2, 3, 4, 5] ``` # Output ```python [1, 2, 3, 4, 5] ``` # Notes * Consider adding checks to skip unnecessary comparisons when entire sections of the list are already in order. * Consider how you might detect a sorted subarray and reduce the number of comparisons accordingly.","solution":"def adaptive_selection_sort(arr): n = len(arr) for i in range(n): min_index = i is_sorted = True for j in range(i + 1, n): if arr[j] < arr[min_index]: min_index = j if arr[j] < arr[j - 1]: is_sorted = False if is_sorted: break arr[i], arr[min_index] = arr[min_index], arr[i] return arr"},{"question":"# Segment Tree Coding Challenge You are required to implement a function that builds and manipulates a segment tree to perform efficient range queries and updates on an array. Function Signature ```python class SegmentTree: def __init__(self, arr: List, function: Callable[[Any, Any], Any]): pass def update(self, index: int, value: Any): pass def query(self, left: int, right: int) -> Any: pass ``` # Description 1. **Initialization**: The constructor should take in an array `arr` and a commutative function `function` (e.g., max, sum). The segment tree should be constructed from the given array based on this function. 2. **Update Method**: The `update` method should update the element at a specific index `index` to `value` and ensure that the tree remains consistent. 3. **Query Method**: The `query` method should return the result of the commutative function applied to the range from `left` to `right` inclusive. # Constraints * The array size does not exceed (10^5). * The update and query operations should be performed in (O(log n)) time. * Only valid commutative functions will be provided. # Example ```python # Sum function mytree = SegmentTree([1, 2, 3, 4, 5], lambda a, b: a + b) print(mytree.query(1, 3)) # Output: 9 mytree.update(1, 10) print(mytree.query(1, 3)) # Output: 17 # Max function mytree = SegmentTree([1, 2, 3, 4, 5], max) print(mytree.query(1, 3)) # Output: 4 mytree.update(2, 7) print(mytree.query(1, 3)) # Output: 7 ``` # Implementation Notes * Ensure proper handling of arrays with various sizes. * Consider edge cases like querying a single element range and empty arrays (if applicable). * Optimize the tree construction and updating mechanisms to work within the expected time complexity.","solution":"from typing import List, Callable, Any class SegmentTree: def __init__(self, arr: List[Any], function: Callable[[Any, Any], Any]): self.n = len(arr) self.arr = arr self.function = function self.tree = [0] * (2 * self.n) self._build() def _build(self): # Initialize leaves for i in range(self.n): self.tree[self.n + i] = self.arr[i] # Initialize internal nodes for i in range(self.n - 1, 0, -1): self.tree[i] = self.function(self.tree[2 * i], self.tree[2 * i + 1]) def update(self, index: int, value: Any): # Update the leaf node pos = self.n + index self.tree[pos] = value # Update internal nodes while pos > 1: pos //= 2 self.tree[pos] = self.function(self.tree[2 * pos], self.tree[2 * pos + 1]) def query(self, left: int, right: int) -> Any: # Make range inclusive on both ends left += self.n right += self.n + 1 res = None while left < right: if left % 2: if res is None: res = self.tree[left] else: res = self.function(res, self.tree[left]) left += 1 if right % 2: right -= 1 if res is None: res = self.tree[right] else: res = self.function(res, self.tree[right]) left //= 2 right //= 2 return res"},{"question":"# Hash Table Implementation with Advanced Collision Handling Context You are tasked to improve the given `HashTable` implementation by incorporating a more advanced collision resolution technique. Specifically, you are to replace the linear probing scheme with quadratic probing. Additionally, implement a strategy to manage hash table resizing by reducing its size when the load factor becomes too low. Requirements 1. **Quadratic Probing**: Update the `_rehash` method to use quadratic probing for resolving collisions. 2. **Resizable Hash Table**: Implement resizing mechanism to reduce the table size when the load factor falls below 1/3, akin to the dynamic resizing on high load. 3. **Performance Constraints**: Ensure that the put, get, and delete operations still generally perform in O(1) time complexity. Function Details - `put(self, key, value)`: Insert a key-value pair into the hash table. - `get(self, key)`: Retrieve the value associated with the key. - `del_(self, key)`: Delete a key-value pair from the hash table. - `__resize(self, new_size)`: Change the size of the internal arrays to `new_size` and rehash all existing key-value pairs. - `hash(self, key)`: Compute the initial hash value for a key. - `_rehash(self, old_hash, attempt)`: Compute the next hash using quadratic probing. - Handling resizing when load factor crosses specified thresholds. **Input and Output Format** - **Input**: The methods should handle basic key-value operations. - **Output**: The functionalities should work seamlessly ensuring efficient resizing and collision resolution. **Constraints** - Handle large datasets to ensure efficient memory usage. - Manage collisions efficiently to maintain the expected O(1) performance. ```python class AdvancedHashTable(HashTable): def __init__(self): super().__init__(self.MIN_SIZE) def _rehash(self, old_hash, attempt): Quadratic probing function. `attempt` is the number of failed attempts. return (old_hash + attempt ** 2) % self.size def put(self, key, value): ... # Implement inseration with resizing on high load factor. if len(self) >= (self.size * 2) / 3: self.__resize(self.size * 2) def del_(self, key): ... # Implement deletion with resizing on low load factor. if len(self) <= (self.size // 3): self.__resize(max(self.MIN_SIZE, self.size // 2)) def __resize(self, new_size): Resize hashtable to be of new_size ... # Rehash all keys to fit into the new size hash table. # Usage Example: # hashtable = AdvancedHashTable() # hashtable.put(1, \'one\') # hashtable.put(2, \'two\') # print(hashtable.get(1)) # Should output \'one\' # hashtable.del_(1) # print(hashtable.get(1)) # Should output None ``` Implement the above methods to enhance the given hash table with quadratic probing and dynamic resizing capabilities.","solution":"class HashTable: MIN_SIZE = 8 def __init__(self, size=MIN_SIZE): self.size = size self.table = [None] * size self.keys = [None] * size self.count = 0 def hash(self, key): return hash(key) % self.size def _rehash(self, old_hash, attempt): Quadratic probing function. `attempt` is the number of failed attempts. return (old_hash + attempt ** 2) % self.size def put(self, key, value): idx = self.hash(key) attempt = 1 while self.keys[idx] is not None and self.keys[idx] != key: idx = self._rehash(idx, attempt) attempt += 1 if self.keys[idx] is None: self.count += 1 self.keys[idx] = key self.table[idx] = value if self.count >= (self.size * 2) / 3: self.__resize(self.size * 2) def get(self, key): idx = self.hash(key) attempt = 1 while self.keys[idx] is not None: if self.keys[idx] == key: return self.table[idx] idx = self._rehash(idx, attempt) attempt += 1 return None def del_(self, key): idx = self.hash(key) attempt = 1 while self.keys[idx] is not None: if self.keys[idx] == key: self.keys[idx] = None self.table[idx] = None self.count -= 1 if self.count <= self.size // 3 and self.size > self.MIN_SIZE: self.__resize(max(self.MIN_SIZE, self.size // 2)) return idx = self._rehash(idx, attempt) attempt += 1 def __resize(self, new_size): old_table = self.table old_keys = self.keys self.size = new_size self.table = [None] * new_size self.keys = [None] * new_size self.count = 0 for key, value in zip(old_keys, old_table): if key is not None: self.put(key, value)"},{"question":"# Coding Challenge Problem Statement You are given an array of words and an array of symbols. Your task is to display each word with their matched symbol surrounded by square brackets. If a word matches more than one symbol, choose the one with the longest length. Write a function `bracketed_words(words: List[str], symbols: List[str]) -> Tuple[str]` that takes an array of words and an array of symbols, and returns a tuple of words where each word has the appropriate symbol from the symbols list bracketed. Input - `words`: List of strings where each element represents a word. - `symbols`: List of strings where each element represents a symbol. Output - A tuple of strings where each word has the appropriate symbol from the symbols list bracketed. Constraints - The length of each word is at most 1000. - The length of each symbol is at most 100. - You can assume only lowercase and uppercase English alphabets in words and symbols. - If no symbol matches a word, return the word as it is in the output. - If the word matches more than one symbol, choose the one with the longest length. Example ```python words = [\'Amazon\', \'Microsoft\', \'Google\'] symbols = [\'i\', \'Am\', \'cro\', \'Na\', \'le\', \'abc\'] result = bracketed_words(words, symbols) print(result) # Output: (\'[Am]azon\', \'Mi[cro]soft\', \'Goog[le]\') ``` Implementation Implement the function `bracketed_words` to solve the problem efficiently.","solution":"from typing import List, Tuple def bracketed_words(words: List[str], symbols: List[str]) -> Tuple[str]: Returns a tuple of words where each word has the appropriate symbol from the symbols list bracketed. If a word matches more than one symbol, choose the one with the longest length. result = [] for word in words: matched_symbol = \\"\\" # Find the longest matching symbol for symbol in symbols: if symbol in word and len(symbol) > len(matched_symbol): matched_symbol = symbol # Replace the symbol in the word with the bracketed version if matched_symbol: word = word.replace(matched_symbol, f\'[{matched_symbol}]\', 1) result.append(word) return tuple(result)"},{"question":"# Probabilistic Primality Testing As an up-and-coming software engineer at a tech firm specializing in cryptographic solutions, you have been assigned a task to implement a reliable method for testing the primality of large integers. Your algorithm should be efficient enough to handle extremely large numbers while maintaining an acceptable rate of accuracy. You need to implement the **Rabin-Miller Primality Test** with the following requirements: **Function Signature:** ```python def is_prime(n: int, k: int) -> bool: ``` **Input:** 1. `n (int)`: The number to be tested for primality. ( n geq 1 ). 2. `k (int)`: The number of iterations to determine the accuracy of the test. **Output:** - **True** if ( n ) is probably prime. - **False** if ( n ) is guaranteed to be composite. **Constraints:** - ( 1 leq n leq 2^{63} - 1 ) - ( 1 leq k leq 10^6 ) **Performance Requirements:** - The function must efficiently handle large values of ( n ) up to the given constraint. **Details:** You should base your primality test on the provided pseudo-code and algorithm analysis. The function must: 1. Handle small values of ( n ) directly (return True for 2, 3 and False for 1, all other values should proceed with the test). 2. Utilize randomness to pick witnesses and avoid trivial factors. 3. Consider the use of built-in modular exponentiation for efficiency. Consider the following edge cases: - Small prime and composite numbers. - Large pseudo-primes generated by specific forms. - Extreme values of ( n ) closer to the limit. **Example:** ```python print(is_prime(5, 10)) # Expected output: True (since 5 is prime) print(is_prime(15, 10)) # Expected output: False (15 is composite) print(is_prime(13, 5)) # Expected output: True (since 13 is prime) ``` Implement the `is_prime` function with the above specifics. Ensure that it is properly robust to handle edge cases and large inputs efficiently.","solution":"import random def is_prime(n: int, k: int) -> bool: Perform the Rabin-Miller Primality Test on a given number n. n: Number to be tested for primality k: Number of iterations for accuracy Returns True if n is probably prime, otherwise False. if n <= 1: return False if n <= 3: return True if n % 2 == 0: return False # Write (n-1) as 2^r * d r, d = 0, n - 1 while d % 2 == 0: r += 1 d //= 2 # Witness loop def miller_test(a): x = pow(a, d, n) if x == 1 or x == n - 1: return True for _ in range(r - 1): x = pow(x, 2, n) if x == n - 1: return True return False for _ in range(k): a = random.randint(2, n - 2) if not miller_test(a): return False return True"},{"question":"You will implement a function to determine the height of a binary tree. The height of a binary tree is the number of levels it has. An empty tree has a height of 0, a tree with only one node has a height of 1, and so on. # Function Definition ```python def height(root: TreeNode) -> int: This function takes the root of a binary tree and returns the height of the tree. Parameters: - root (TreeNode): The root node of the binary tree. Returns: - int: The height of the tree. ``` # Input - `root`: A TreeNode, representing the root of the binary tree. # Output - An integer representing the height of the binary tree. # Constraints 1. The tree may be empty (root is `None`). 2. Nodes in the tree contain integer values. # Example ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right # Example tree: # 1 # / # 2 3 # / # 4 5 # # height = 3 root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) root.left.left = TreeNode(4) root.left.right = TreeNode(5) assert height(root) == 3 ``` # Description 1. If the tree is empty (`root` is `None`), the height is 0. 2. Otherwise, the height can be determined recursively by taking the maximum height of the left and right subtrees and adding one to account for the current level. 3. Consider edge cases such as an empty tree or a tree with only one node.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def height(root: TreeNode) -> int: if root is None: return 0 left_height = height(root.left) right_height = height(root.right) return max(left_height, right_height) + 1"},{"question":"# Stooge Sort - Implementation and Analysis Given an array of integers, implement Stooge Sort to sort the array in non-decreasing order. After implementing the sort function, analyze its performance on various test cases. Function Signature ```python def stoogesort(arr: List[int], l: int, h: int) -> None: # Your implementation here ``` # Input * **arr**: List[int] - An array of integers to be sorted. * **l**: int - The starting index of the array or sub-array to sort. * **h**: int - The ending index of the array or sub-array to sort. # Output * The function modifies the input array `arr` in-place to sort the elements in non-decreasing order. # Constraints * The given list `arr` will have at most `1000` elements where `-10^6 <= arr[i] <= 10^6`. # Example ```python arr = [1, 3, 64, 5, 7, 8] n = len(arr) stoogesort(arr, 0, n-1) print(arr) # Output should be [1, 3, 5, 7, 8, 64] ``` # Your Task 1. Implement the Stooge Sort algorithm as described. 2. Test your implementation with the given example and analyze the time complexity and performance with larger randomized datasets. 3. Provide an analysis of its performance for different sizes of input data. Additionally, extend your answer by constructing special cases such as: * An empty array. * An array with only one element. * An array that is already sorted. * An array that has all identical elements. Discuss how Stooge Sort performs with these edge cases in terms of both efficiency and correctness.","solution":"from typing import List def stoogesort(arr: List[int], l: int, h: int) -> None: Sorts the array using Stooge Sort algorithm. if l >= h: return # If the element at l is greater than the element at h, swap them if arr[l] > arr[h]: arr[l], arr[h] = arr[h], arr[l] # If there are more than two elements in the array, recursively sort the array if h - l + 1 > 2: t = (h - l + 1) // 3 # Recursively sort the initial 2/3 elements stoogesort(arr, l, h - t) # Recursively sort the final 2/3 elements stoogesort(arr, l + t, h) # Recursively sort the initial 2/3 elements again to ensure it is fully sorted stoogesort(arr, l, h - t)"},{"question":"You are working at a search engine company as part of the search optimization team. Your task is to write a function that finds the last occurrence of a specific search query within an array of previously recorded search queries. The array is sorted in increasing order. Write a function `find_last_occurrence(queries: List[int], target: int) -> int` that returns the index of the last occurrence of the given `target` in the list `queries`. If the `target` is not found, the function should return `-1`. Input: - `queries`: A list of integers sorted in increasing order. - `target`: An integer representing the search query you need to find. Output: - An integer representing the index of the last occurrence of `target` in `queries`. If `target` is not found, return `-1`. Constraints: - The length of the `queries` is between `0` and `10^5`. - The integer values in `queries` are between `-10^9` and `10^9`. - Expect a running time of `O(log n)` or better. Example: ```python assert find_last_occurrence([1, 2, 2, 2, 3, 4, 5], 2) == 3 assert find_last_occurrence([1, 2, 3, 4, 5], 6) == -1 assert find_last_occurrence([1, 2, 2, 5], 5) == 3 assert find_last_occurrence([], 5) == -1 assert find_last_occurrence([2, 2, 2, 2], 2) == 3 assert find_last_occurrence([1, 2, 4, 4, 4, 5], 4) == 4 ``` Notes: - Optimize your function for large input sizes. - Ensure proper handling of edge cases such as empty arrays and arrays where the target element does not exist.","solution":"from typing import List def find_last_occurrence(queries: List[int], target: int) -> int: Returns the index of the last occurrence of target in queries. If target is not found, returns -1. left, right = 0, len(queries) - 1 result = -1 while left <= right: mid = (left + right) // 2 if queries[mid] == target: result = mid left = mid + 1 # Keep searching in the right half for the last occurrence elif queries[mid] < target: left = mid + 1 else: right = mid - 1 return result"},{"question":"**Scenario**: You are tasked with writing a function to help a friend manage their personal budget. They want to identify two purchases that together cost a specific target amount of money. Each purchase is represented as an integer value in an array. You need to write a function that finds the indices of the two purchases that add up to the given target. # Function Signature: ```python def two_sum(array: List[int], target: int) -> Tuple[int, int]: ``` # Input: - `array`: A list of integers representing the values of the purchases. (e.g., [2, 7, 11, 15]) - `target`: An integer representing the target sum for the two purchases. (e.g., 9) # Output: - A tuple of two integers representing the indices of the two purchases that add up to the target. If no such indices exist, return `None`. # Constraints: - You may assume that each input would have exactly one solution, and you may not use the same element twice. - The array length will vary from 2 to 10^5. - Each element in the array will range from -10^9 to 10^9. # Performance Requirements: - The function should run in O(n) time complexity. - The function should use O(n) additional space. # Examples: ```python # Example 1: array = [2, 7, 11, 15] target = 9 # Because array[0] + array[1] = 2 + 7 = 9, the function should return (0, 1) # Example 2: array = [3, 2, 4] target = 6 # Because array[1] + array[2] = 2 + 4 = 6, the function should return (1, 2) # Example 3: array = [3, 3] target = 6 # Because array[0] + array[1] = 3 + 3 = 6, the function should return (0, 1) ``` # Additional Notes: - Think about edge cases such as arrays with negative numbers, or when the array contains very large or very small numbers. - Ensure your code is efficient and handles large input sizes within the given constraints.","solution":"from typing import List, Tuple, Optional def two_sum(array: List[int], target: int) -> Optional[Tuple[int, int]]: Finds two indices in the array such that the corresponding values add up to the target. Args: array (List[int]): List of integers representing the values of purchases. target (int): The target sum for the two purchases. Returns: Optional[Tuple[int, int]]: A tuple of two indices if the target can be met, otherwise None. index_map = {} for i, num in enumerate(array): complement = target - num if complement in index_map: return (index_map[complement], i) index_map[num] = i return None"},{"question":"**Scenario**: You are given a set of tasks, each with a different priority. Your task is to implement a class to handle these tasks in a way that always allows you to quickly access and remove the task with the lowest priority. # Problem Statement Design and implement a `MinPriorityQueue` class that represents a priority queue where each element is associated with a priority value which allows retrieval of the element with the lowest priority in constant time. Your `MinPriorityQueue` class should manage task objects where each task has an associated priority. # Requirements 1. **Methods**: - `__init__`: Constructs an empty priority queue or initializes it with given tasks and their priorities. - `push(item, priority)`: Inserts a task with a given priority into the priority queue. - `pop()`: Removes and returns the task with the lowest priority. - `size()`: Returns the current size of the priority queue. 2. **Expected Input and Output Formats**: - `push(item, priority)`: `item` is a string or object representing the task, `priority` is an integer. - `pop()`: Returns the `item` with the lowest priority. - `size()`: Returns an integer representing the number of elements in the priority queue. 3. **Constraints**: - The queue should handle tasks efficiently and ensure that insertions and deletions conform to the expected behavior of a priority queue with minimal complexity. - Your implementation should raise appropriate errors when attempting to pop from an empty queue. # Example Usage ```python pq = MinPriorityQueue() pq.push(\\"task1\\", 5) pq.push(\\"task2\\", 3) pq.push(\\"task3\\", 8) print(pq.size()) # Output: 3 print(pq.pop()) # Output: \\"task2\\" print(pq.size()) # Output: 2 ``` Implement the `MinPriorityQueue` class using a linear array for storing tasks and their priorities.","solution":"import heapq class MinPriorityQueue: def __init__(self): Initializes an empty priority queue. self._queue = [] self._index = 0 def push(self, item, priority): Inserts a task with a given priority into the priority queue. heapq.heappush(self._queue, (priority, self._index, item)) self._index += 1 def pop(self): Removes and returns the task with the lowest priority. Raises IndexError if the priority queue is empty. if not self._queue: raise IndexError(\\"pop from an empty priority queue\\") return heapq.heappop(self._queue)[2] def size(self): Returns the current size of the priority queue. return len(self._queue)"},{"question":"You are given an array of integers representing profits and losses over days. You are tasked with finding the maximum profit that can be made by selling and buying on those days. Write a function to determine the maximum sum of a contiguous subsequence in the given array. # Function Signature ```python def max_contiguous_subsequence_sum(arr: List[int]) -> int: ``` # Input * `arr` (List[int]): A list of integers representing daily profits and losses. The length of the array is at most 10^5. # Output * Returns an integer, the maximum sum of contiguous subsequence. # Constraints * The array may contain both positive and negative integers. * The array can also be empty, in which case the function should return 0. * The elements within the array can be anywhere from -10^4 to 10^4. # Examples ```python assert max_contiguous_subsequence_sum([-2, 3, 8, -1, 4]) == 14 # 3 + 8 - 1 + 4 assert max_contiguous_subsequence_sum([-1, 1, 0]) == 1 # 1 assert max_contiguous_subsequence_sum([-1, -3, -4]) == -1 # -1 (maximum single element) assert max_contiguous_subsequence_sum([-2, 3, 8, -12, 8, 4]) == 12 # 8 + 4 assert max_contiguous_subsequence_sum([]) == 0 # Empty array ``` # Notes * Think about the problem in terms of dynamic programming and how greedy choice can lead to optimal solutions. * Consider edge cases such as single-element arrays or those with all negative/zero values.","solution":"from typing import List def max_contiguous_subsequence_sum(arr: List[int]) -> int: Returns the maximum sum of a contiguous subsequence in the given array. if not arr: return 0 max_current = max_global = arr[0] for num in arr[1:]: max_current = max(num, max_current + num) if max_current > max_global: max_global = max_current return max_global"},{"question":"**Scenario**: In a complex real-time monitoring system, you need to efficiently count the number of active bits (set bits) in large data blocks represented as unsigned integers. This is crucial for performance optimization in updating and managing real-time analytics. **Task**: Implement a function to count the number of \'1\' bits in the binary representation of an unsigned integer using Brian Kernighan\'s Algorithm. Ensure to implement both the recursive and iterative approaches. Function Signature: ```python def count_ones_recur(n: int) -> int: pass def count_ones_iter(n: int) -> int: pass ``` Input: - `n` (int): A non-negative integer that represents the data block. (0 ≤ n ≤ 2^32 - 1) Output: - Return an integer: The count of \'1\' bits in the binary representation of `n`. Constraints: - The functions must handle very large unsigned integers efficiently. - Do not use built-in functions like `bin()` to convert the number to binary format. Performance Requirements: - Ensure the solution has a time complexity of O(k), where k is the number of set bits. - The iterative function should utilize constant space. Examples: 1. `count_ones_recur(11)` should return `3` (binary representation: 1011) 2. `count_ones_iter(11)` should return `3` Implement your solution below, adhering to the constraints and ensuring efficient performance for large inputs.","solution":"def count_ones_recur(n: int) -> int: Recursively count the number of \'1\' bits in the binary representation of n using Brian Kernighan\'s Algorithm. if n == 0: return 0 return 1 + count_ones_recur(n & (n - 1)) def count_ones_iter(n: int) -> int: Iteratively count the number of \'1\' bits in the binary representation of n using Brian Kernighan\'s Algorithm. count = 0 while n: n &= n - 1 count += 1 return count"},{"question":"You are given a pattern string and a corresponding string. You need to write a function that checks whether the string follows the exact pattern. Following the pattern means that there is a direct one-to-one mapping between characters in the pattern and non-empty words in the string. This relationship must be a bijection, meaning no two characters in the pattern map to the same word and no two words map to the same character. # Function Signature ```python def follows_pattern(pattern: str, input_str: str) -> bool: :param pattern: A string of lowercase alphabets. :param input_str: A string of lowercase words separated by single spaces. :return: A boolean indicating whether input_str follows the pattern. ``` # Input * `pattern` - A non-empty string containing lowercase English letters. Maximum length 10^4. * `input_str` - A non-empty string containing lowercase English words separated by single spaces. Maximum length 10^4. # Output * Return `True` if the input string follows the pattern; otherwise, return `False`. # Examples 1. Input: `pattern = \\"abba\\", input_str = \\"dog cat cat dog\\"` Output: `True` 2. Input: `pattern = \\"abba\\", input_str = \\"dog cat cat fish\\"` Output: `False` 3. Input: `pattern = \\"aaaa\\", input_str = \\"dog cat cat dog\\"` Output: `False` 4. Input: `pattern = \\"abba\\", input_str = \\"dog dog dog dog\\"` Output: `False` # Constraints * Each word in the input string is a sequence of lowercase letters. * Both `pattern` and `input_str` lengths are at most 10^4. # Requirements * Thoroughly handle all edge cases. * Ensure that the solution is efficient in terms of time and space complexity. # Example Explanation For the first example: * Mapping is established as follows: \'a\' -> \\"dog\\" and \'b\' -> \\"cat\\". * The pattern matches the structure of the input string exactly. For the second example: * When \'b\' is supposed to map to \\"cat\\", it maps correctly. However, the next \'b\' maps to \\"fish\\", which violates the pattern.","solution":"def follows_pattern(pattern: str, input_str: str) -> bool: Check if the input_str follows the pattern. :param pattern: A string of lowercase alphabets. :param input_str: A string of lowercase words separated by single spaces. :return: A boolean indicating whether input_str follows the pattern. words = input_str.split() # Patterns and words must have the same length if len(pattern) != len(words): return False char_to_word = {} word_to_char = {} for char, word in zip(pattern, words): if char not in char_to_word: if word in word_to_char: return False char_to_word[char] = word word_to_char[word] = char elif char_to_word[char] != word: return False return True"},{"question":"The Fibonacci numbers form a sequence where each number is the sum of the two preceding ones, starting from 0 and 1. That is: - F(0) = 0 - F(1) = 1 - F(n) = F(n-1) + F(n-2) for n >= 2 You are required to implement a function to compute the n-th Fibonacci number using the most efficient method in terms of both time and space complexity. # Input and Output - **Input**: An integer n (0 <= n <= 10^5) - **Output**: An integer representing the n-th Fibonacci number. # Constraints - Input value n will always be a non-negative integer. - You need to handle large values of n, hence optimization is key. # Example - **Example 1**: - Input: 5 - Output: 5 - **Example 2**: - Input: 10 - Output: 55 - **Example 3**: - Input: 100 - Output: 354224848179261915075 # Requirements 1. Implement the function using the most efficient approach (iterative preferred). 2. Ensure your implementation handles large inputs efficiently. 3. Your code should not have high time or space complexity. # Function Signature ```python def find_fibonacci(n: int) -> int: pass ```","solution":"def find_fibonacci(n: int) -> int: Computes the n-th Fibonacci number using an iterative approach. if n <= 1: return n a, b = 0, 1 for _ in range(2, n + 1): a, b = b, a + b return b"},{"question":"# Euler\'s Totient Function Implementation You are given the task to implement Euler\'s totient function. The function counts the number of integers up to a given number `n` that are coprime with `n`. Two numbers are coprime if their greatest common divisor (GCD) equals 1. # Function Signature ```python def euler_totient(n: int) -> int: ``` # Input - An integer `n` (1 ≤ n ≤ 10^6). # Output - Return the value of the totient function ϕ(n), which is the count of integers from `1` to `n` that are coprime with `n`. # Constraints - The value of `n` will be a positive integer within the range [1, 1,000,000]. # Example ```python euler_totient(1) # returns 1 euler_totient(6) # returns 2 euler_totient(10) # returns 4 euler_totient(19) # returns 18 ``` # Description 1. Initialize `result` to `n`. 2. Loop from `2` to `√n`. For each number i: - Check if `i` is a factor of `n`. - If so, repeatedly divide `n` by `i`. - Decrease `result` by `result // i`. 3. If after the loop, `n` is greater than `1`, decrement `result` by `result // n`. 4. Return `result`. # Notes - Consider edge cases where `n` is small and where `n` is a prime number. - Ensure that the implementation efficiently handles large values of `n` within the constraint.","solution":"def euler_totient(n: int) -> int: Computes the Euler\'s Totient Function of the given integer n. The function returns the number of integers from 1 to n that are coprime with n. if n == 1: return 1 result = n p = 2 # Check for every number from 2 to √n while p * p <= n: if n % p == 0: # If p is a factor, then consider it in the result while n % p == 0: n //= p result -= result // p p += 1 # If n is a prime number > 1 if n > 1: result -= result // n return result"},{"question":"You are given an undirected graph represented as an adjacency list. Each key is a node and its value is a list of nodes directly connected to it. Implement two functions: 1. `dfs_with_paths(graph, start)` that performs a **Depth-First Search** traversal of the graph starting from the `start` node and returns all possible paths discovered during the search as a list of lists. Each path should represent a complete traversal path from the start node until no new nodes can be visited following DFS principles. 2. `bfs_shortest_path(graph, start, end)` that performs a **Breadth-First Search** to find the shortest path between the `start` node and the `end` node. If a path exists, return the path as a list of nodes. If no path exists, return an empty list. **Input/Output Formats**: - **Input**: - `graph`: Dictionary representing the graph\'s adjacency list. - `start`: Node from which to start the traversal. - `end`: Target node for BFS shortest path function. - **Output**: - `dfs_with_paths(graph, start)`: List of lists, where each list represents a full path discovered by DFS. - `bfs_shortest_path(graph, start, end)`: List of nodes representing the shortest path from `start` to `end`. Return an empty list if no path exists. **Constraints**: - The graph does not contain any parallel edges or self-loops. - Nodes in the graph are represented by integers or strings. # Example ```python graph = { \'A\': [\'B\', \'C\'], \'B\': [\'A\', \'D\', \'E\'], \'C\': [\'A\', \'F\'], \'D\': [\'B\'], \'E\': [\'B\', \'F\'], \'F\': [\'C\', \'E\'] } # Example 1 (DFS paths) assert dfs_with_paths(graph, \'A\') == [[\'A\', \'C\', \'F\', \'E\', \'B\', \'D\'], [\'A\', \'B\', \'E\', \'F\', \'C\', \'A\']] # Example 2 (BFS shortest path) assert bfs_shortest_path(graph, \'A\', \'F\') == [\'A\', \'C\', \'F\'] ``` # Explanation 1. `dfs_with_paths` explores all paths starting from `A` and includes complete traversals, listing them as separate paths. 2. `bfs_shortest_path` finds the shortest path from `A` to `F`, which, in this case, is [`A`, `C`, `F`].","solution":"def dfs_with_paths(graph, start): Perform a DFS traversal on the graph starting from the start node and return all paths discovered. def dfs(node, path, visited, all_paths): visited.add(node) path.append(node) is_end = True # To determine if this node is a leaf for neighbor in graph.get(node, []): if neighbor not in visited: dfs(neighbor, path[:], set(visited), all_paths) is_end = False if is_end: all_paths.append(path) all_paths = [] dfs(start, [], set(), all_paths) return all_paths def bfs_shortest_path(graph, start, end): Perform a BFS traversal to find the shortest path from start to end in the graph. Return the path as a list. If no path exists, return an empty list. from collections import deque queue = deque([[start]]) visited = set([start]) while queue: path = queue.popleft() node = path[-1] if node == end: return path for neighbor in graph.get(node, []): if neighbor not in visited: new_path = path + [neighbor] queue.append(new_path) visited.add(neighbor) return []"},{"question":"Given a singly linked list, write a function to remove elements in a specified range of indices inclusive of the start and end. Improve upon the existing function by: 1. **Ensuring validation** of indices before performing the removal. 2. Handling **edge cases** where the list is empty or indices are invalid. 3. Writing a function that takes a list head and index range, returning the new head of the modified list. # Requirements * **Input & Output Format**: * Input: A singly linked list head node, a start index (integer), and an end index (integer). * Output: The head node of the modified list. * **Constraints & Limitations**: * The list can be empty (`None`). * 0 ≤ start ≤ end < size of list. * List nodes contain integer values. # Function Signature ```python def remove_range(head, start, end): pass ``` # Context Imagine you\'re designing a playlist manager where users can remove a consecutive set of songs from a playlist by specifying the start and end positions. Your function should handle the list of songs effectively, even in boundary scenarios.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def remove_range(head, start, end): Removes elements from the linked list within the index range [start, end]. :param head: The head of the linked list. :param start: The start index. :param end: The end index. :return: The head of the modified linked list. if not head or start > end: return head dummy = ListNode(0) dummy.next = head current = dummy index = 0 # Move current to just before the start index while current and index < start: current = current.next index += 1 if not current or not current.next: return dummy.next node_before_removal = current # Move current to the end index while current and index <= end: current = current.next index += 1 if node_before_removal and current: node_before_removal.next = current.next return dummy.next"},{"question":"# Reverse Every K Nodes in a Linked List Scenario: You are working on a text editor with an undo feature which uses a linked list to store user actions. However, you need to reverse the order of every k consecutive actions. This requires reversing segments of a linked list where each segment contains exactly k nodes. Task: Write a function that takes a singly linked list and an integer `k`, and reverses every k nodes in the list. If the number of nodes not divisible by k remains at the end, they should remain as is. Function Signature: ```python class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverse_k_group(head: ListNode, k: int) -> ListNode: pass ``` Input: - `head`: The head of a singly linked list. - `k` (int): The number of nodes in each segment to be reversed. Output: - Return the head of the modified list after reversing every k nodes. Constraints: - The length of the list is at most 10000. - k is a positive integer between 1 and 10000. - Content of the linked list will fit in a 32-bit integer. Example: ```python # Example list is represented as: 1 -> 2 -> 3 -> 4 -> 5 # k = 2 # After reversing every 2 nodes: 2 -> 1 -> 4 -> 3 -> 5 head = ListNode(1, ListNode(2, ListNode(3, ListNode(4, ListNode(5))))) k = 2 new_head = reverse_k_group(head, k) # Traverse the new list and print elements: # Expected Output: 2 -> 1 -> 4 -> 3 -> 5 ``` Note: - Implement the function by thinking both iteratively and recursively. - Make sure to handle edge cases like when the list length is less than k or when k is 1.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverse_k_group(head: ListNode, k: int) -> ListNode: if not head or k == 1: return head def reverse_linked_list(start: ListNode, end: ListNode) -> ListNode: prev, curr = None, start while curr != end: curr_next = curr.next curr.next = prev prev = curr curr = curr_next return prev dummy = ListNode(0) dummy.next = head group_prev = dummy while True: kth = group_prev for _ in range(k): kth = kth.next if not kth: return dummy.next group_next = kth.next start, end = group_prev.next, kth.next reverse_linked_list(start, end) group_prev.next, start.next = kth, group_next group_prev = start"},{"question":"You are provided with an array of words and an array of symbols. You need to update each word in the array by surrounding the longest matching symbol found in it with square brackets. If a word contains multiple symbols, the one with the longest length should be selected. If a word does not contain any symbols, it should remain unchanged. Your solution needs to be efficient, possibly leveraging data structures to optimize the search process. **Input Format**: 1. `words` - A list of strings representing the words. 2. `symbols` - A list of strings representing the symbols. **Output Format**: 1. A list of strings where each word has the longest matched symbol surrounded by square brackets. **Constraints**: * Each word and symbol can contain up to 100 characters. * The number of words can be up to 10,000. * The number of symbols can be up to 1,000. **Example**: ```python words = [\'Amazon\', \'Microsoft\', \'Google\'] symbols = [\'i\', \'Am\', \'cro\', \'Na\', \'le\', \'abc\'] Output: [\'[Am]azon\', \'Mi[cro]soft\', \'Goog[le]\'] ``` **Function Signature**: ```python def highlight_symbols(words: list[str], symbols: list[str]) -> list[str]: pass ``` **Notes**: * Ensure that your solution is efficient and consider using suitable data structures to improve performance. * Account for edge cases like overlapping symbols and words without any matching symbols.","solution":"def highlight_symbols(words: list[str], symbols: list[str]) -> list[str]: Updates each word by surrounding the longest matching symbol found in it with square brackets. If a word contains multiple symbols, the longest one is selected. # Sort the symbols list by the length of the symbols in descending order symbols.sort(key=len, reverse=True) updated_words = [] for word in words: longest_symbol = \\"\\" for symbol in symbols: if symbol in word: if len(symbol) > len(longest_symbol): longest_symbol = symbol if longest_symbol: word = word.replace(longest_symbol, f\'[{longest_symbol}]\', 1) updated_words.append(word) return updated_words"},{"question":"You are given a class template that performs various matrix operations, including inversion. The inversion method `invert_matrix` employs a process involving the calculation of the matrix of minors, convert it to a cofactor matrix, and then apply adjugation and scale it by the reciprocal of the determinant. Your task is to implement an efficient matrix inversion method within this class. # Function Signature ```python def invert_matrix(self, m: List[List[int]]) -> List[List[float]]: pass ``` # Input - `m`: A list of list of integers representing an n x n matrix. # Output - Returns a list of list of floats representing the inverse of the matrix m if it is invertible. - Returns a list of list containing special error codes: - `[-1]` if the input is not an n x n matrix. - `[-2]` if the matrix is not square. - `[-3]` if the matrix is smaller than 2x2. - `[-4]` if the matrix is singular. # Constraints - The matrix size `n` will be such that 2 ≤ n ≤ 50. - Matrix elements will be integers in the range [-1000, 1000]. # Example ```python # Example input m = [ [4, 7], [2, 6] ] # Expected output # [ # [0.6, -0.7], # [-0.2, 0.4] # ] m2 = [ [1, 2, 3], [0, 1, 4], [5, 6, 0] ] # Expected output # [ # [-24, 18, 5], # [20, -15, -4], # [-5, 4, 1] # ] ``` # Requirements 1. Account for edge cases such as non-square matrices, matrices with zero determinants, and matrices smaller than 2x2. 2. Ensure your implementation efficiently handles large input sizes within the constraint limits. 3. Use fractions for intermediate calculations to avoid floating-point inaccuracies where necessary. # Notes You are not allowed to use third-party libraries for matrix inversions. Implement all the necessary steps as described in the provided code snippet using base Python.","solution":"from typing import List import copy class MatrixOperations: def invert_matrix(self, m: List[List[int]]) -> List[List[float]]: # Check if the matrix is not empty and is a square matrix if not m or not all(len(row) == len(m) for row in m): return [[-2]] n = len(m) # Check if the matrix size is smaller than 2x2 if n < 2: return [[-3]] # Calculate the determinant of the matrix det = self._determinant(m) if det == 0: return [[-4]] # Use the adjugate method to find the inverse adj = self._adjugate(m) inv = [[adj[i][j] / det for j in range(n)] for i in range(n)] return inv def _determinant(self, m: List[List[int]]) -> int: if len(m) != len(m[0]): raise ValueError(\\"Determinant can only be calculated for a square matrix\\") n = len(m) if n == 1: return m[0][0] if n == 2: return m[0][0] * m[1][1] - m[0][1] * m[1][0] det = 0 for c in range(n): det += ((-1) ** c) * m[0][c] * self._determinant(self._minor(m, 0, c)) return det def _minor(self, m: List[List[int]], i: int, j: int) -> List[List[int]]: return [row[:j] + row[j+1:] for row in (m[:i] + m[i+1:])] def _adjugate(self, m: List[List[int]]) -> List[List[int]]: adj = [] for i in range(len(m)): adj_row = [] for j in range(len(m)): minor = self._minor(m, i, j) adj_row.append(((-1) ** (i + j)) * self._determinant(minor)) adj.append(adj_row) return self._transpose(adj) def _transpose(self, m: List[List[int]]) -> List[List[int]]: return [list(row) for row in zip(*m)]"},{"question":"You are given a square matrix `mat` of dimension `d x d` and an integer value `n`. Implement a function to compute the nth power of the matrix using matrix exponentiation principles. Use efficient matrix multiplication and identity matrix helper functions to aid in this computation. Function Signature: ```python def matrix_power(mat: List[List[int]], n: int) -> List[List[int]]: pass ``` Input: - `mat`: A 2D list representing a square matrix (d x d) where 1 <= d <= 100. - `n`: An integer (0 <= n <= 10^9), representing the exponent to which the matrix is to be raised. Output: - Return a 2D list representing the resulting matrix after raising `mat` to the power `n`. Constraints: - The elements of the matrix `mat` will be integers ranging from -10^3 to 10^3. Example: ```python # Example 1 mat = [ [1, 2], [3, 4] ] n = 3 print(matrix_power(mat, n)) # Output: [[37, 54], [81, 118]] # Example 2 mat = [ [2, 0], [0, 2] ] n = 10 print(matrix_power(mat, n)) # Output: [[1024, 0], [0, 1024]] ``` Explanation: - In the first example, matrix raised to 3 results in: `[[37, 54], [81, 118]]` - In the second example, power of 10 for a diagonal matrix to base 2 results in: `[[1024, 0], [0, 1024]]` Consider edge cases where `n` is 0 which should return the identity matrix of dimension `d x d`.","solution":"from typing import List def matrix_power(mat: List[List[int]], n: int) -> List[List[int]]: Raises the given square matrix `mat` to the power `n` using matrix exponentiation. def matrix_multiply(A: List[List[int]], B: List[List[int]]) -> List[List[int]]: Multiplies two matrices A and B. d = len(A) result = [[0] * d for _ in range(d)] for i in range(d): for j in range(d): for k in range(d): result[i][j] += A[i][k] * B[k][j] return result def identity_matrix(d: int) -> List[List[int]]: Returns an identity matrix of dimension d x d. return [[1 if i == j else 0 for j in range(d)] for i in range(d)] def matrix_exponentiate(base: List[List[int]], exponent: int) -> List[List[int]]: Exponentiates the base matrix to the given exponent using exponentiation by squaring. result = identity_matrix(len(base)) while exponent > 0: if exponent % 2 == 1: result = matrix_multiply(result, base) base = matrix_multiply(base, base) exponent //= 2 return result return matrix_exponentiate(mat, n)"},{"question":"You are given a directed graph represented by a class `Graph`. Your task is to implement the function `transitive_closure` that returns the transitive closure matrix of the graph. The transitive closure of a graph is a matrix `T` where `T[i][j]` is 1 if there is a path from vertex `i` to vertex `j`, and 0 otherwise. # Input 1. The graph is initialized with a specified number of vertices. 2. Edges are added using the `add_edge(source, target)` method. # Output The function `transitive_closure` should return a 2D list (matrix) representing the transitive closure of the graph. # Example ```python # Example usage: graph = Graph(4) graph.add_edge(0, 1) graph.add_edge(1, 2) graph.add_edge(2, 3) closure = graph.transitive_closure() print(closure) # Output should be: # [ # [1, 1, 1, 1], # [0, 1, 1, 1], # [0, 0, 1, 1], # [0, 0, 0, 1] # ] ``` # Constraints: - The number of vertices `V` will be between 1 and 200. - The number of edges `E` will be between 0 and 1000. - All vertex indices are valid (0 ≤ source, target < V). # Requirements: - Time complexity should be efficient relative to V and E. - Consider edge cases such as disconnected graphs, self-loops, and node with no outgoing edges.","solution":"class Graph: def __init__(self, vertices): self.V = vertices self.graph = [[0] * vertices for _ in range(vertices)] def add_edge(self, source, target): self.graph[source][target] = 1 def transitive_closure(self): closure = [row[:] for row in self.graph] V = self.V for k in range(V): for i in range(V): for j in range(V): closure[i][j] = closure[i][j] or (closure[i][k] and closure[k][j]) for i in range(V): closure[i][i] = 1 return closure"},{"question":"# Context You have been tasked with implementing a search function using Jump Search to quickly locate items in a large, sorted list of records such as product IDs in an e-commerce database. # Task Write a function `jump_search(arr, target)` that takes in a sorted array `arr` and an integer `target`, and returns the index of the `target` in the array. If the target is not found, return -1. # Input * A sorted list of integers `arr` where 1 ≤ len(arr) ≤ 10^6. * An integer `target` to search for. # Output * An integer representing the index of `target` in the array, or -1 if the target is not present. # Constraints * The array must be sorted in non-decreasing order. * You must optimize your solution to handle large `arr` efficiently. * Aim for a time complexity of O(√n), where n is the length of the array. # Examples ```python # Example 1 arr = [3, 6, 9, 12, 15, 18, 21, 24, 27, 30] target = 12 print(jump_search(arr, target)) # Output: 3 # Example 2 arr = [1, 4, 7, 9, 9, 16, 18, 20, 22, 25] target = 10 print(jump_search(arr, target)) # Output: -1 # Example 3 arr = [] target = 5 print(jump_search(arr, target)) # Output: -1 ``` # Notes * Make sure to handle edge cases such as an empty array, the target being the largest/smallest element, or not present in the array. * Consider the performance for very large arrays up to the size limit. * Do not assume any specific range for the elements in the array beyond what the constraints specify.","solution":"import math def jump_search(arr, target): Perform jump search to find the target in a sorted array. Args: arr (list of int): Sorted list of integers. target (int): The integer to search for. Returns: int: The index of target in arr, or -1 if target is not found. n = len(arr) if n == 0: return -1 # Optimal jump size is the square root of the array length step = int(math.sqrt(n)) prev = 0 # Finding the block where target is present while arr[min(step, n) - 1] < target: prev = step step += int(math.sqrt(n)) if prev >= n: return -1 # Performing linear search within the identified block for index in range(prev, min(step, n)): if arr[index] == target: return index return -1"},{"question":"# Merge Two Sorted Linked Lists **Scenario**: You are given two linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Write a function to merge two such linked lists and return it as a new list in the same reverse order. **Function Signature**: ```python def merge_two_list(l1: Node, l2: Node) -> Node: ``` # Input: * `l1` and `l2` are the heads of the two sorted linked lists. # Output: * Return the head of the merged sorted linked list in reverse order. # Constraints: * Both `l1` and `l2` cannot be `None` simultaneously. * A list can have zero or more nodes. * The value of each node is a non-negative integer. # Example: ```python # Given these linked lists: # 1->2->4, 1->3->4 # Resulting list should be: # 1->1->2->3->4->4 ``` # Implementation Requirements: * Write an efficient solution with O(n + m) complexity. * Consider edge cases such as when one or both input lists are empty. **Note**: Do not mutate the input lists, create a new list for the result.","solution":"class Node: def __init__(self, val=0, next=None): self.val = val self.next = next def merge_two_list(l1: Node, l2: Node) -> Node: # Create a dummy node to facilitate the merge process dummy = Node() current = dummy # Traverse both lists and merge them in sorted order while l1 and l2: if l1.val < l2.val: current.next = l1 l1 = l1.next else: current.next = l2 l2 = l2.next current = current.next # Attach the remaining nodes, if any if l1: current.next = l1 if l2: current.next = l2 # The head of the merged list is the next element of the dummy node return dummy.next"},{"question":"# Question: You are given a string `s` which may contain letters, numbers, and other characters. Your task is to implement a function `is_palindrome_optimized` that checks whether the given string is a palindrome, considering only alphanumeric characters and ignoring cases. # Function Signature: `def is_palindrome_optimized(s: str) -> bool:` # Input: - `s` (1 <= |s| <= 10^5): A string that may contain alphanumeric characters and punctuation. # Output: - Returns `True` if the given string is a palindrome ignoring non-alphanumeric characters and case sensitivity. - Returns `False` otherwise. # Constraints: - You should aim for O(n) time complexity and O(1) space complexity. # Examples: 1. Input: `\\"A man, a plan, a canal: Panama\\"` Output: `True` 2. Input: `\\"race a car\\"` Output: `False` 3. Input: `\\" \\"` Output: `True` 4. Input: `\\"No \'x\' in Nixon\\"` Output: `True` # Hints: - You might want to use a two-pointer approach to achieve O(1) additional space complexity. - Make sure to account for non-alphanumeric characters.","solution":"def is_palindrome_optimized(s: str) -> bool: Checks whether the given string is a palindrome, considering only alphanumeric characters and ignoring cases. left, right = 0, len(s) - 1 while left < right: # Move left pointer forward if not alphanumeric. while left < right and not s[left].isalnum(): left += 1 # Move right pointer backward if not alphanumeric. while left < right and not s[right].isalnum(): right -= 1 # Check characters at left and right index if s[left].lower() != s[right].lower(): return False # Move both pointers towards the center. left += 1 right -= 1 return True"},{"question":"Scenario You are developing software that processes license keys for a virtual product. The process involves formatting user keys by removing non-alphanumeric characters and adding delimiters to enhance readability. The requirement is to group the cleaned characters into fixed-size sections delimited by hyphens. Task Implement a function `format_license_key` that reformats a string based on the following rules: 1. Remove all existing non-alphanumeric characters. 2. Group the remaining characters into sections, each containing exactly k characters, starting from the right side. 3. Add a hyphen (`-`) between each group. Function Signature ```python def format_license_key(key: str, k: int) -> str: pass ``` Input * `key` (str): A string containing the original license key which may include non-alphanumeric characters. * `k` (int): An integer representing the size of each group of characters. Output * (str): A string representing the reformatted license key. Constraints * 1 <= len(key) <= 10^5 * 1 <= k <= 10^5 Example ```python # Example 1: key = \\"2-4A0r7-4k\\" k = 4 print(format_license_key(key, k)) # Expected Output: \\"24A0-R74K\\" # Example 2: key = \\"--a-a-a-a--\\" k = 2 print(format_license_key(key, k)) # Expected Output: \\"AA-AA\\" ``` Ensure your implementation performs efficiently and handles edge cases correctly. Document your code for clarity.","solution":"def format_license_key(key: str, k: int) -> str: Reformats a license key by removing non-alphanumeric characters and grouping the remaining characters into k-sized sections delimited by hyphens. Parameters: key (str): The original license key which may include non-alphanumeric characters. k (int): The size of each character group. Returns: str: The reformatted license key. # Remove all non-alphanumeric characters and convert to uppercase cleaned_key = \'\'.join(c for c in key if c.isalnum()).upper() # Reverse the cleaned key to easily group from the end cleaned_key = cleaned_key[::-1] # Group the characters into k-sized sections groups = [cleaned_key[i:i+k] for i in range(0, len(cleaned_key), k)] # Reverse each group and join with hyphens formatted_key = \'-\'.join(group[::-1] for group in groups[::-1]) return formatted_key"},{"question":"Implement a function that applies a transformation to a given square matrix based on a specified type of operation. The transformation types you should support are \'rotate_clockwise\', \'rotate_counterclockwise\', \'top_left_invert\', and \'bottom_left_invert\'. Your function should handle these transformations efficiently. # Function Signature ```python def transform_matrix(matrix: List[List[int]], operation: str) -> List[List[int]]: pass ``` # Input - `matrix`: A `List[List[int]]` representing a square matrix of size `n x n` where `1 <= n <= 15, 1 <= matrix[i][j] <= 100`. - `operation`: A `str` representing the type of transformation to apply. The valid operations are: - \'rotate_clockwise\' - \'rotate_counterclockwise\' - \'top_left_invert\' - \'bottom_left_invert\' # Output - A new `List[List[int]]` representing the transformed matrix. # Example ```python matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] print(transform_matrix(matrix, \'rotate_clockwise\')) # Output: # [ # [7, 4, 1], # [8, 5, 2], # [9, 6, 3] # ] print(transform_matrix(matrix, \'rotate_counterclockwise\')) # Output: # [ # [3, 6, 9], # [2, 5, 8], # [1, 4, 7] # ] print(transform_matrix(matrix, \'top_left_invert\')) # Output: # [ # [1, 4, 7], # [2, 5, 8], # [3, 6, 9] # ] print(transform_matrix(matrix, \'bottom_left_invert\')) # Output: # [ # [9, 6, 3], # [8, 5, 2], # [7, 4, 1] # ] ``` # Constraints - The input matrix is guaranteed to be square. - The size of the matrix will not exceed 15x15 to ensure performance is reasonable within these constraints. # Notes - Make sure to handle edge cases such as a single element matrix. - Ensure the solution accurately reflects the transformation outlined in the algorithm.","solution":"from typing import List def transform_matrix(matrix: List[List[int]], operation: str) -> List[List[int]]: n = len(matrix) if operation == \'rotate_clockwise\': return [[matrix[n - j - 1][i] for j in range(n)] for i in range(n)] elif operation == \'rotate_counterclockwise\': return [[matrix[j][n - i - 1] for j in range(n)] for i in range(n)] elif operation == \'top_left_invert\': return [[matrix[j][i] for j in range(n)] for i in range(n)] elif operation == \'bottom_left_invert\': return [[matrix[n - j - 1][n - i - 1] for j in range(n)] for i in range(n)] else: raise ValueError(\\"Invalid operation\\")"},{"question":"# Selection Sort - Binary Search Enhancement Selection sort is a basic algorithm with suboptimal performance for larger datasets. Your task is to improve the selection sort by incorporating binary search during the selection phase to find the minimum element more efficiently. # Task Implement the function `enhanced_selection_sort` which sorts an array of integers using an optimized selection with binary search. The function should follow these specifications: Function Signature ```python def enhanced_selection_sort(arr: List[int], simulation: bool = False) -> List[int]: pass ``` Input - `arr`: A list of integers to be sorted. - `simulation` (optional): A boolean value indicating whether to print each iteration of the array during sorting. Defaults to `False`. Output - Returns the sorted list of integers in non-decreasing order. Constraints - Do not use Python\'s built-in sort functions. - You may assume the list contains at most `10^5` elements and each element is within the range `-10^9` to `10^9`. # Example ```python arr = [64, 25, 12, 22, 11] print(enhanced_selection_sort(arr)) # Output: [11, 12, 22, 25, 64] ``` # Implementation Details 1. Implement a `binary_search_min` helper function: - This function should perform a modified binary search to find the position of the minimum element in the unsorted section of the list. 2. Incorporate the `binary_search_min` function into the selection sort process to select the minimum element more efficiently than the linear approach. 3. Ensure your implementation maintains the overall O(n^2) time complexity but optimizes the inner loop selection step. # Edge Cases - Handle cases of already sorted lists. - Handle empty lists should return an empty list. - Handle lists with identical elements. # Performance - Must process within 1-second time frame for the upper limit of `10^5` elements.","solution":"from typing import List def binary_search_min(arr: List[int], start: int, end: int) -> int: Perform a binary search to find the index of the minimum element in the array between indices start and end. min_index = start min_value = arr[start] for i in range(start + 1, end + 1): if arr[i] < min_value: min_index = i min_value = arr[i] return min_index def enhanced_selection_sort(arr: List[int], simulation: bool = False) -> List[int]: Sort the array using an enhanced selection sort with binary search for finding the minimum element in the unsorted section. n = len(arr) for i in range(n): # Find the minimum element\'s index using binary search method min_idx = binary_search_min(arr, i, n - 1) # Swap the found minimum element with the first element arr[i], arr[min_idx] = arr[min_idx], arr[i] if simulation: print(arr) return arr"},{"question":"Scenario A project planner uses a directed graph to represent tasks in a project and their dependencies. Each task is a node, and a directed edge from task A to task B means that task A must be completed before task B can start. The planner needs to check whether the graph of tasks contains any cycles to prevent project deadlock. Task Write a function `contains_cycle(graph)` that takes in a directed graph represented as a dictionary and returns `True` if there is a cycle in the graph and `False` otherwise. Use Depth-First Search (DFS) and vertex states to accomplish this. Implementation Requirements 1. Implement a helper function `is_in_cycle(graph, traversal_states, vertex)` that should: * Use states (WHITE, GRAY, BLACK) to identify cycles during DFS traversal. * Return `True` if the vertex is part of a cycle. * Recursively traverse neighbors, updating their states accordingly. 2. Implement the main function `contains_cycle(graph)` which should: * Initialize traversal states for all vertices. * Call the helper function for each vertex not yet fully explored to start a DFS visit. * Return `True` if any DFS visit confirms a cycle, `False` otherwise. Example ```python graph = { \'A\': [\'B\', \'C\'], \'B\': [\'D\'], \'C\': [\'F\'], \'D\': [\'E\', \'F\'], \'E\': [\'B\'], \'F\': [] } assert contains_cycle(graph) == True graph_no_cycle = { \'A\': [\'B\', \'C\'], \'B\': [\'D\'], \'C\': [\'F\'], \'D\': [\'E\'], \'E\': [], \'F\': [] } assert contains_cycle(graph_no_cycle) == False ``` Input Format * `graph`: Dictionary where keys are strings representing vertices and values are lists of strings representing directed edges. Output Format * Boolean value, `True` if there is a cycle in the graph, `False` otherwise. Constraints * Graph contains no more than 1000 vertices. * Each vertex name is a string of no more than 10 characters.","solution":"WHITE = 0 # Vertex has not been visited yet GRAY = 1 # Vertex is in the current DFS traversal stack BLACK = 2 # Vertex and its descendants have been fully explored def is_in_cycle(graph, traversal_states, vertex): Helper function to check if the current vertex is part of a cycle. Uses DFS and vertex states to track the traversal. if traversal_states[vertex] == GRAY: return True if traversal_states[vertex] == BLACK: return False # Mark the vertex as being processed in the current stack traversal_states[vertex] = GRAY for neighbor in graph.get(vertex, []): if is_in_cycle(graph, traversal_states, neighbor): return True # Mark the vertex as fully processed traversal_states[vertex] = BLACK return False def contains_cycle(graph): Checks if the directed graph contains any cycles. traversal_states = {vertex: WHITE for vertex in graph} for vertex in graph: if traversal_states[vertex] == WHITE: if is_in_cycle(graph, traversal_states, vertex): return True return False"},{"question":"# Context Bogo Sort is a notoriously inefficient sorting algorithm that works by generating random permutations of the input array until the array happens to be sorted. Despite its impractical nature, it is an excellent educational tool for illustrating the importance of algorithm efficiency. # Task You are required to implement a function that sorts an array of integers using the Bogo Sort algorithm and tracks the number of iterations it takes to sort the array. Additionally, to better understand its inefficiency, you will implement a function to stop the algorithm if it exceeds a certain number of iterations to prevent indefinite execution. # Function Specification ```python def bogo_sort_with_limit(arr, max_iterations): Sorts an array using the Bogo Sort algorithm, but stops if the number of iterations exceeds the limit. Args: arr (list of int): The list of integers to be sorted. max_iterations (int): The maximum number of iterations to shuffle and check the array. Returns: tuple: - list of int: The (potentially unsorted) list of integers after the process. - int: The number of iterations performed before stopping. - bool: A boolean indicating whether the array was successfully sorted within the iteration limit. ``` # Input * `arr`: A list of integers that you need to sort. * `max_iterations`: An integer specifying the maximum number of iterations to try to sort the array. # Output * A tuple containing: * The list of integers after the sorting process (whether sorted or not). * The number of iterations performed before stopping. * A boolean indicating whether the array is sorted (`True`) or not (`False`). # Constraints * The input list can contain between 1 and 1000 integers. * The values of the integers range from -10000 to 10000. * To prevent indefinite execution, the maximum number of iterations will be capped at 1000000. # Example ```python # Example 1 arr = [3, 1, 2] max_iterations = 10000 result = bogo_sort_with_limit(arr, max_iterations) # Output could be: ([1, 2, 3], some_number_between_1_and_10000, True) # Example 2 arr = [5, 4, 3, 2, 1] max_iterations = 10 result = bogo_sort_with_limit(arr, max_iterations) # Output could be: ([5, 4, 3, 2, 1], 10, False) ``` Write an efficient implementation for the specified function.","solution":"import random def is_sorted(arr): Helper function to check if the array is sorted. for i in range(len(arr) - 1): if arr[i] > arr[i + 1]: return False return True def bogo_sort_with_limit(arr, max_iterations): Sorts an array using the Bogo Sort algorithm, but stops if the number of iterations exceeds the limit. Args: arr (list of int): The list of integers to be sorted. max_iterations (int): The maximum number of iterations to shuffle and check the array. Returns: tuple: - list of int: The (potentially unsorted) list of integers after the process. - int: The number of iterations performed before stopping. - bool: A boolean indicating whether the array was successfully sorted within the iteration limit. iterations = 0 while not is_sorted(arr) and iterations < max_iterations: random.shuffle(arr) iterations += 1 return arr, iterations, is_sorted(arr)"},{"question":"# Question Given a pattern and a string `s`, determine if the string `s` follows the same pattern. Implement the function `word_pattern(pattern: str, s: str) -> bool` to check if `s` follows the pattern. **Input:** * `pattern` – a string containing only lowercase letters. * `s` – a string containing words separated by single spaces. **Output:** * Return `True` if string `s` follows the given pattern. Otherwise, return `False`. **Constraints:** * The input string `pattern` only contains lowercase English letters. * The input string `s` only contains lowercase English alphabets and spaces separating words. * Both `pattern` and `s` will not be empty. # Scenarios 1. **Example 1:** **Input:** `pattern = \\"abba\\"`, `s = \\"dog cat cat dog\\"` **Output:** `True` **Explanation:** \'a\' -> \'dog\', \'b\' -> \'cat\', both \'a\' and \'dog\' & \'b\' and \'cat\' are bijective mapping. 2. **Example 2:** **Input:** `pattern = \\"abba\\"`, `s = \\"dog cat cat fish\\"` **Output:** `False` **Explanation:** Pattern expectation \'a\' -> \'dog\', \'b\' -> \'cat\' breaks as \'a\' next maps to \'fish\' instead. 3. **Example 3:** **Input:** `pattern = \\"aaaa\\"`, `s = \\"dog cat cat dog\\"` **Output:** `False` **Explanation:** \'a\' should only map to \'dog\' but other words create conflicts in bijection. 4. **Example 4:** **Input:** `pattern = \\"abba\\"`, `s = \\"dog dog dog dog\\"` **Output:** `False` **Explanation:** \'b\' should map to another unique value but does not. # Notes: - Consider mismatch lengths for early outcomes, handle malformed cases. - Optimize the lookup and storage mechanisms effectively. Implement the `word_pattern` function to validate such conditions in Python. ```python def word_pattern(pattern: str, s: str) -> bool: # Your implementation here pass ```","solution":"def word_pattern(pattern: str, s: str) -> bool: words = s.split() if len(pattern) != len(words): return False char_to_word_mapping = {} word_to_char_mapping = {} for char, word in zip(pattern, words): if char in char_to_word_mapping: if char_to_word_mapping[char] != word: return False else: if word in word_to_char_mapping: return False char_to_word_mapping[char] = word word_to_char_mapping[word] = char return True"},{"question":"# Scenario You are asked to develop a utility to help sort integers for a system recording students\' grades. Each grade is an integer within a known range. # Problem Statement Implement the function `pigeonhole_sort` which takes a list of integers representing students\' grades and sorts them in non-decreasing order. ```python def pigeonhole_sort(arr): # Your code here ``` # Input A list of integers `arr` where each integer denotes a grade. The list size is `n`, and each grade falls within the known range `[Min, Max]`. # Output Return the sorted list of integers in non-decreasing order. # Constraints - 1 <= n <= 10^6 - -10^6 <= grade <= 10^6 # Example ```python grades = [5, 3, 2, 8, 6, 1, 4, 1] sorted_grades = pigeonhole_sort(grades) print(sorted_grades) # Output: [1, 1, 2, 3, 4, 5, 6, 8] ``` # Notes - Ensure your solution handles edge cases such as all elements being the same or the presence of negative values. - Consider the best situations to apply this algorithm. If the range is significantly larger than the number of elements, it may not be the most efficient sorting method.","solution":"def pigeonhole_sort(arr): if not arr: return arr _min = min(arr) _max = max(arr) size = _max - _min + 1 pigeonholes = [0] * size for number in arr: pigeonholes[number - _min] += 1 result = [] for i in range(size): while pigeonholes[i] > 0: result.append(i + _min) pigeonholes[i] -= 1 return result"},{"question":"Scenario You are tasked with developing a system that identifies errors in a data reporting process. Specifically, each reported dataset should include each number exactly twice, except for one number which may appear either once or three times. Your task is to find this one number that does not adhere to the expected occurrence frequency within a dataset. Task Write a function that finds the unique number in an array where every other element appears exactly twice. Function Signature ```python def find_unique_number(nums): Returns the single number that appears an odd number of times. If all numbers appear twice, returns 0. :type nums: List[int] :rtype: int ``` Input Format * A list of integers `nums` where: * 0 <= len(nums) <= 10^5 * Each integer is between -10^9 and 10^9. Output Format * An integer which is the single number that appears an odd number of times. * If all numbers appear exactly twice, return 0. Constraints * The function should run in O(n) time complexity. * The function should use constant O(1) extra space. Example Test Cases *Example 1* ```python assert find_unique_number([2, 2, 1]) == 1 ``` *Example 2* ```python assert find_unique_number([4, 1, 2, 1, 2]) == 4 ``` *Example 3* ```python assert find_unique_number([1, 1, 2, 2, 3, 3]) == 0 ``` *Example 4* ```python assert find_unique_number([5]) == 5 ``` Additional Information * You may assume that the input list is not empty if the problem states otherwise. * The algorithm is expected to be efficient and handle large datasets effectively.","solution":"def find_unique_number(nums): Returns the single number that appears an odd number of times. If all numbers appear twice, returns 0. :type nums: List[int] :rtype: int unique_number = 0 for num in nums: unique_number ^= num return unique_number"},{"question":"**Context**: Suppose you are working on a product that processes large datasets stored in a sorted array. Your task is to implement an efficient search algorithm to quickly locate specific values from these arrays. **Problem**: Given a sorted array of integers and a target/ search_key, design a Python function `find_position` implementing the Interpolation Search algorithm. # Function Signature ```python from typing import List def find_position(array: List[int], search_key: int) -> int: pass ``` # Input * `array` (List[int]): A sorted list of integers in ascending order. Constraints - The list may contain up to 10^6 elements. * `search_key` (int): The integer value to be searched in the array. # Output * Return an integer: - The index of `search_key` in the array if found. - Return `-1` if the `search_key` is not present. # Constraints: * The array is guaranteed to be sorted. * Time Complexity: Your implementation should optimally handle the input size by leveraging the properties of Interpolation Search. # Examples 1. Given: `array = [-25, -12, -1, 10, 12, 15, 20, 41, 55]`, `search_key = -1` * Output: 2 2. Given: `array = [5, 10, 12, 14, 17, 20, 21]`, `search_key = 55` * Output: -1 3. Given: `array = [5, 10, 12, 14, 17, 20, 21]`, `search_key = -5` * Output: -1 # Additional Requirements: * Ensure your code handles edge cases such as empty arrays or arrays with one element. * Your implementation should ideally avoid excessive use of memory and ensure a constant space complexity O(1). **Challenge**: Can you optimize your solution for uniformly as well as non-uniformly distributed datasets by integrating the core principles of interpolation search?","solution":"from typing import List def find_position(array: List[int], search_key: int) -> int: Perform interpolation search on a sorted array to find the position of search_key. Parameters: array (List[int]): A sorted list of integers search_key (int): The integer value to search for Returns: int: The index of search_key in array, or -1 if search_key is not found low = 0 high = len(array) - 1 while low <= high and search_key >= array[low] and search_key <= array[high]: # Avoid division by zero and get interpolation position if array[high] == array[low]: pos = low if array[low] == search_key else -1 else: pos = low + ((high - low) // (array[high] - array[low]) * (search_key - array[low])) if pos < low or pos > high: return -1 # Check if search_key is found if array[pos] == search_key: return pos # If search_key is larger, search in the upper part if array[pos] < search_key: low = pos + 1 # If search_key is smaller, search in the lower part else: high = pos - 1 return -1"},{"question":"Objective Design and implement a function to build a segment tree capable of efficiently performing range minimum queries on an array, and updating elements in the array. Problem Statement You are given an array of integers. You need to implement a Segment Tree data structure that supports the following operations: 1. **Build**: Construct a segment tree for the array to support range minimum queries. 2. **Query**: Given a range [L, R], return the minimum value in this range. 3. **Update**: Update the value at a specific index and adjust the segment tree accordingly. Implementation Requirements 1. Implement a class `SegmentTreeMin` with the following methods: * `__init__(self, arr)` - Initializes the segment tree with the given array. Constructs the segment tree using range minimum as the function. * `query(self, L, R)` - Returns the minimum value in the range [L, R]. * `update(self, index, value)` - Updates the element at the specified index to the given value and adjusts the segment tree. 2. Expected input and output formats: * **Initialization**: * Input: `arr` as a list of integers. * **Query**: * Input: Two integers L and R denoting the range. * Output: An integer representing the minimum value in the range [L, R]. * **Update**: * Input: An integer index and an integer value. * Action: Update the element at the specified index to the given value. 3. Constraints: * 1 ≤ length of arr ≤ 10^5 * -10^9 ≤ arr[i] ≤ 10^9 for 0 ≤ i < length of arr * 0 ≤ L ≤ R < length of arr * 0 ≤ index < length of arr Example Usage ```python # Example Usage: arr = [2, 5, 1, 4, 9, 3] segment_tree = SegmentTreeMin(arr) # Perform range queries assert segment_tree.query(1, 3) == 1 # minimum value between index 1 and 3 assert segment_tree.query(0, 5) == 1 # minimum value between index 0 and 5 # Perform updates segment_tree.update(2, 8) # update index 2 to value 8 assert segment_tree.query(1, 3) == 4 # minimum value between index 1 and 3 after update ``` Important Notes * You need to handle edge cases like out-of-bound queries and updates appropriately. * The solution should be optimized for performance considering the constraints. Implement the `SegmentTreeMin` class as described above and ensure it passes the provided example usage and constraints.","solution":"class SegmentTreeMin: def __init__(self, arr): self.n = len(arr) self.tree = [0] * (2 * self.n) self.build(arr) def build(self, arr): # Initialize leaves in the segment tree for i in range(self.n): self.tree[self.n + i] = arr[i] # Build the tree by calculating parents for i in range(self.n - 1, 0, -1): self.tree[i] = min(self.tree[i * 2], self.tree[i * 2 + 1]) def update(self, index, value): # Update the value at the original index pos = self.n + index self.tree[pos] = value # Adjust the segment tree while pos > 1: pos //= 2 self.tree[pos] = min(self.tree[2 * pos], self.tree[2 * pos + 1]) def query(self, L, R): # Get the minimum value in range [L, R] L += self.n R += self.n mn = float(\'inf\') while L <= R: if L % 2 == 1: mn = min(mn, self.tree[L]) L += 1 if R % 2 == 0: mn = min(mn, self.tree[R]) R -= 1 L //= 2 R //= 2 return mn # Example Usage: # arr = [2, 5, 1, 4, 9, 3] # segment_tree = SegmentTreeMin(arr) # print(segment_tree.query(1, 3)) # Output: 1 # segment_tree.update(2, 8) # print(segment_tree.query(1, 3)) # Output: 4"},{"question":"# Fibonacci Sequence Generator Objective Implement a function that computes the nth Fibonacci number using dynamic programming to ensure efficient computation. Background In mathematics, the Fibonacci numbers form a sequence in which each number is the sum of the two preceding ones, typically starting with 0 and 1. Specifically: * F(0) = 0 * F(1) = 1 * F(n) = F(n-1) + F(n-2) for n > 1 Given an integer n, the goal is to compute the nth Fibonacci number. Function Signature ```python def fibonacci(n: int) -> int: # Your implementation here ``` Input * An integer `n` (0 <= n <= 10^5) Output * An integer representing the nth Fibonacci number. Constraints * Your solution should efficiently handle large values of `n` up to 10^5. * The solution should run with a time complexity of O(n) and space complexity of O(1). Examples ```python assert fibonacci(0) == 0 assert fibonacci(1) == 1 assert fibonacci(10) == 55 assert fibonacci(50) == 12586269025 assert fibonacci(100) == 354224848179261915075 ``` Notes * Ensure your function validates the input and handles edge cases appropriately. * Avoid using recursion due to potential stack overflow and inefficiency for large n.","solution":"def fibonacci(n: int) -> int: Returns the nth Fibonacci number using dynamic programming. if n < 0: raise ValueError(\\"Input must be a non-negative integer.\\") if n == 0: return 0 elif n == 1: return 1 a, b = 0, 1 for _ in range(2, n+1): a, b = b, a + b return b"},{"question":"# Shell Sort Implementation and Analysis You have been tasked with implementing Shell Sort. Shell Sort is an optimization over insertion sort that allows the exchange of far-apart elements to speed up the sorting process. The algorithm uses a gap sequence to sort sublists of the array, which reduces the array to fewer passes. **Function Signature**: ```python def shell_sort(arr: List[int]) -> List[int]: ``` **Objective**: - Implement the function that sorts the given list of integers `arr` using the Shell Sort algorithm. **Input**: - A list of integers, `arr` (0 <= len(arr) <= 10^4, -10^9 <= arr[i] <= 10^9) **Output**: - A new list of integers sorted in ascending order. **Constraints**: - You must use the Shell Sort algorithm. - The time complexity of your solution can be worse than O(n log n) but must use an optimized gap sequence for average case performance. - Do not use built-in sorting functions. **Example**: ```python assert shell_sort([23, 12, 1, 8, 34, 54, 2, 3]) == [1, 2, 3, 8, 12, 23, 34, 54] assert shell_sort([9, 8, 3, 7, 5, 6, 4, 1]) == [1, 3, 4, 5, 6, 7, 8, 9] assert shell_sort([-1, -10, 3, 9, 0]) == [-10, -1, 0, 3, 9] assert shell_sort([1, 1, 1, 1, 1]) == [1, 1, 1, 1, 1] ``` Ensure your function efficiently handles edge cases and performs well for reasonably large lists.","solution":"from typing import List def shell_sort(arr: List[int]) -> List[int]: Sorts a list of integers using the Shell Sort algorithm. n = len(arr) gap = n // 2 while gap > 0: for i in range(gap, n): temp = arr[i] j = i # Using insertion sort for the current sub-array with given gap while j >= gap and arr[j - gap] > temp: arr[j] = arr[j - gap] j -= gap arr[j] = temp gap //= 2 return arr"},{"question":"Enhanced Heap Sort with Custom Comparators Heap Sort is a popular algorithm for sorting arrays. This problem will require you to implement an enhanced version of Max Heap Sort which also considers a custom comparator function to determine the order of the elements. Task Implement a function `enhanced_max_heap_sort(arr, comparator)` that sorts an array of integers in ascending order using Max Heap Sort with a custom comparator function. Function Signature ```python def enhanced_max_heap_sort(arr, comparator): pass ``` Input * `arr`: A list of integers, `arr`, with a length between 1 and 10^5. * `comparator`: A function `comparator(x, y)` that returns: - a negative number if x should come before y - zero if the order of x and y does not matter - a positive number if x should come after y Output * The function should return the sorted list of integers in ascending order considering the custom comparator. Constraints * The comparator will be consistent and not produce contradictory results. * The solution must maintain the original max heap properties, altered to respect the comparator. Example ```python def custom_comparator(x, y): return x - y arr = [10, 3, 7, 4, 11] sorted_arr = enhanced_max_heap_sort(arr, custom_comparator) print(sorted_arr) # Output: [3, 4, 7, 10, 11] ``` Explanation The custom comparator function simply returns the difference between two numbers, which means the default comparison criteria (comparison by value) is maintained. The `enhanced_max_heap_sort` function should utilize this comparator to sort the array. Notes Ensure to handle: 1. Conversion of the provided array into a heap structure using the comparator. 2. A correctly modified heapify process to maintain heap properties with the custom comparator. 3. Efficient sorting keeping the time complexity within O(n log n).","solution":"def enhanced_max_heap_sort(arr, comparator): def heapify(heap, n, i, comparator): largest = i left = 2 * i + 1 right = 2 * i + 2 if left < n and comparator(heap[left], heap[largest]) > 0: largest = left if right < n and comparator(heap[right], heap[largest]) > 0: largest = right if largest != i: heap[i], heap[largest] = heap[largest], heap[i] heapify(heap, n, largest, comparator) def build_max_heap(heap, comparator): n = len(heap) for i in range(n // 2 - 1, -1, -1): heapify(heap, n, i, comparator) def heap_sort(heap, comparator): n = len(heap) build_max_heap(heap, comparator) for i in range(n-1, 0, -1): heap[i], heap[0] = heap[0], heap[i] heapify(heap, i, 0, comparator) heap_sort(arr, comparator) return arr"},{"question":"**Context:** You are working as a software developer at a company that processes loads of hierarchical data structures resembling binary trees. Your task is to implement code to determine the minimum depth of these binary trees. This metric is critical for evaluating the performance and efficiency of various data processing tasks. **Question:** Given the root of a binary tree, your task is to implement two functions: 1. **min_depth_recursive(root)**: Implement a recursive function to find the minimum depth of the binary tree. 2. **min_depth_iterative(root)**: Implement an iterative function using BFS (breadth-first search) to find the minimum depth. The minimum depth is defined as the number of nodes along the shortest path from the root node down to the nearest leaf node. **Function Signatures:** ```python def min_depth_recursive(root: TreeNode) -> int: pass def min_depth_iterative(root: TreeNode) -> int: pass ``` **Input:** - `root`: A `TreeNode` object representing the root of the binary tree. **Output:** - Returns an integer representing the minimum depth of the binary tree. **Constraints:** - The number of nodes in the tree is in the range [0, 1000]. - The depth of the tree will not exceed 1000. **Performance Requirements:** - Aim for a time complexity of O(N) for both implementations. - Ensure space complexity is optimized for both functions. **Edge Cases:** - Handle the case where the tree is empty (`root` is `None`). - Consider trees with varying structures, including extremely unbalanced trees. **Scenario:** An example input consists of a binary tree: ``` 3 / 9 20 / 15 7 ``` For this tree, the minimum depth is 2, corresponding to the path `[3, 20, 15]`. **Example:** ```python # Given binary tree [3, 9, 20, None, None, 15, 7] tree_root = TreeNode(3) tree_root.left = TreeNode(9) tree_root.right = TreeNode(20) tree_root.right.left = TreeNode(15) tree_root.right.right = TreeNode(7) print(min_depth_recursive(tree_root)) # Output: 2 print(min_depth_iterative(tree_root)) # Output: 2 ``` Implement both functions to demonstrate your understanding of recursion and iterative tree traversal algorithms.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def min_depth_recursive(root: TreeNode) -> int: if root is None: return 0 if not root.left and not root.right: return 1 if not root.left: return min_depth_recursive(root.right) + 1 if not root.right: return min_depth_recursive(root.left) + 1 return min(min_depth_recursive(root.left), min_depth_recursive(root.right)) + 1 from collections import deque def min_depth_iterative(root: TreeNode) -> int: if root is None: return 0 queue = deque([(root, 1)]) while queue: node, depth = queue.popleft() if not node.left and not node.right: return depth if node.left: queue.append((node.left, depth + 1)) if node.right: queue.append((node.right, depth + 1)) return 0"},{"question":"# Matrix Multiplication Coding Question Scenario: You are working on a scientific computing project that involves numerous calculations involving two-dimensional matrices. Your task is to implement a function that multiplies two matrices, both represented as lists of lists. The function should take two matrices as input and return their product. This demonstrates a fundamental understanding of nested loops and handling two-dimensional data structures. Task: Write a function `matrix_multiply` that takes two matrices (as lists of lists) and returns their product. You should assume that the elements of the matrices are integers, and you must handle the edge case where the number of columns in the first matrix does not match the number of rows in the second matrix. Input: - Two matrices, `multiplicand` and `multiplier`, represented as lists of lists of integers. Output: - A matrix represented as a list of lists of integers which is the product of the input matrices. Constraints: - Each matrix can have up to 100 rows and 100 columns. - The elements of the matrices are limited to the range [-1000, 1000]. Performance Requirements: - Ensure that your implementation is efficient in terms of both time and space. Function Signature: ```python def matrix_multiply(multiplicand: list, multiplier: list) -> list: pass ``` Example: ```python # Example 1 multiplicand = [ [1, 2], [3, 4] ] multiplier = [ [2, 0], [1, 2] ] result = matrix_multiply(multiplicand, multiplier) print(result) # Output: [[4, 4], [10, 8]] # Example 2 multiplicand = [ [1, 0, 2], [-1, 3, 1] ] multiplier = [ [3, 1], [2, 1], [1, 0] ] result = matrix_multiply(multiplicand, multiplier) print(result) # Output: [[5, 1], [4, 2]] ``` **Note:** Handle edge cases where dimensions of matrices are not compatible, by raising an appropriate exception with a meaningful error message.","solution":"def matrix_multiply(multiplicand: list, multiplier: list) -> list: Multiplies two matrices. :param multiplicand: List of lists representing the first matrix :param multiplier: List of lists representing the second matrix :returns: List of lists representing the product of the two matrices :raises ValueError: If the matrices have incompatible dimensions for multiplication # Get dimensions of the matrices rows_multiplicand = len(multiplicand) cols_multiplicand = len(multiplicand[0]) rows_multiplier = len(multiplier) cols_multiplier = len(multiplier[0]) # Check if multiplication is possible if cols_multiplicand != rows_multiplier: raise ValueError(\\"Incompatible dimensions for matrix multiplication\\") # Initialize the result matrix with zeros result = [[0] * cols_multiplier for _ in range(rows_multiplicand)] # Perform matrix multiplication for i in range(rows_multiplicand): for j in range(cols_multiplier): for k in range(cols_multiplicand): result[i][j] += multiplicand[i][k] * multiplier[k][j] return result"},{"question":"# Histogram Representation from a List Objective: Given a list of integers, implement a function that computes the histogram of the input list. The histogram for a list contains the frequency count of each unique element in the list. Task Description: Write a function `generate_histogram` that takes a list of integers as input and returns a dictionary representing the histogram of the list. Function Signature: ```python def generate_histogram(input_list: list) -> dict: ``` Input: * `input_list` (list): A list of integers which may have duplicates and is not sorted. Output: * `dict`: A dictionary where keys are the unique integers from the list and values are their respective counts (frequencies). Constraints: * The elements of the list can range from negative to positive integers. * The input list can be empty, in which case the output should be an empty dictionary. Examples: ```python Example 1: Input: [1, 2, 2, 3, 3, 3] Output: {1: 1, 2: 2, 3: 3} Example 2: Input: [5, 5, 6] Output: {5: 2, 6: 1} Example 3: Input: [] Output: {} ``` Scenario: Imagine you are a data analyst who needs to analyze survey results recorded as numerical values. Your task is to generate a histogram that will help visualize the frequency distribution of these survey responses. Implement the `generate_histogram` function to facilitate this analysis.","solution":"def generate_histogram(input_list): Generates a histogram from a list of integers. Args: input_list (list): List of integers. Returns: dict: A dictionary representing the histogram of the list. histogram = {} for num in input_list: if num in histogram: histogram[num] += 1 else: histogram[num] = 1 return histogram"},{"question":"# Zigzag Level Order Traversal of a Binary Tree **Problem Statement:** You are given a binary tree, implement a function `zigzag_level(root)` that returns the zigzag level order traversal of its nodes\' values. (i.e., from left to right, then right to left for the next level and alternate between). **Function Signature:** ```python def zigzag_level(root): # your code here ``` **Input Format:** - A binary tree rooted at `root`, where `root` is an instance of a TreeNode. **Output Format:** - A list of lists where each inner list contains the node values at each level of the tree in zigzag order. **Constraints:** 1. The number of nodes in the tree is in the range [0, 1000]. 2. -100 <= Node.val <= 100 **Scenario:** You are tasked with writing software that visualizes organizational structures. Each level of the hierarchy needs to be displayed in a zigzag pattern to highlight different managerial levels. The function `zigzag_level(root)` will help in processing the organizational tree as required. **Example:** Consider the binary tree represented as follows: ``` 1 / 2 3 / / 4 5 6 7 ``` The zigzag level order traversal output should be: ``` [ [1], [3, 2], [4, 5, 6, 7] ] ``` **Notes:** - Ensure you handle edge cases such as empty trees, trees with a single node, and trees that do not have two children at each node.","solution":"from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def zigzag_level(root): if not root: return [] results = [] current_level = deque([root]) left_to_right = True while current_level: level_values = [] next_level = deque() while current_level: node = current_level.popleft() level_values.append(node.val) if node.left: next_level.append(node.left) if node.right: next_level.append(node.right) if not left_to_right: level_values.reverse() results.append(level_values) current_level = next_level left_to_right = not left_to_right return results"},{"question":"Context You are working on developing an autocomplete system that supports adding words into the system and searches with support for wildcard characters. The system must efficiently handle numerous add and search operations, especially with wildcard support. Task Implement a data structure `WordDictionary` that supports the following operations: 1. **`add_word(word: str) -> None`**: Adds a word into the data structure. 2. **`search(word: str) -> bool`**: Returns `True` if the word (including wildcard characters \'.\') exists in the data structure, `False` otherwise. A wildcard character `\'.\'` can match any single letter. Expected Input and Output * `add_word(\\"bad\\")`: Adds the word \\"bad\\" to the dictionary. * `search(\\"bad\\")`: Returns `True`. * `search(\\"b..\\")`: Returns `True`. * `search(\\"..d\\")`: Returns `True`. * `search(\\"pad\\")`: Returns `False`. Constraints * All words are lowercase. * Word lengths are within the range [1, 25]. * There will be at most `10^5` calls to `add_word` and `search`. Function Signature ```python class WordDictionary: def __init__(self): # Initialize your data structure here. def add_word(self, word: str) -> None: # Adds a word into the data structure. def search(self, word: str) -> bool: # Returns if the word is in the data structure (supports \'.\' wildcard). ``` Example Submission ```python class TrieNode(object): def __init__(self, letter, is_terminal=False): self.children = dict() self.letter = letter self.is_terminal = is_terminal class WordDictionary(object): def __init__(self): self.root = TrieNode(\\"\\") def add_word(self, word): cur = self.root for letter in word: if letter not in cur.children: cur.children[letter] = TrieNode(letter) cur = cur.children[letter] cur.is_terminal = True def search(self, word, node=None): cur = node if not cur: cur = self.root for i, letter in enumerate(word): if letter == \\".\\": if i == len(word) - 1: for child in cur.children.values(): if child.is_terminal: return True return False for child in cur.children.values(): if self.search(word[i+1:], child): return True return False if letter not in cur.children: return False cur = cur.children[letter] return cur.is_terminal ```","solution":"class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False class WordDictionary: def __init__(self): self.root = TrieNode() def add_word(self, word: str) -> None: node = self.root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.is_end_of_word = True def search(self, word: str) -> bool: return self._search_in_node(word, self.root) def _search_in_node(self, word: str, node: TrieNode) -> bool: for i, char in enumerate(word): if char == \'.\': for child in node.children.values(): if self._search_in_node(word[i + 1:], child): return True return False else: if char not in node.children: return False node = node.children[char] return node.is_end_of_word"},{"question":"# Stack Operations on Balanced Parentheses As a developer, you need to create a function that verifies if a given string of parentheses is balanced or not. A string containing just the characters `\'(\'`, `\')\'`, `\'{\'`, `\'}\'`, `\'[\'`, and `\']\'` is considered balanced if the following conditions are met: 1. For every opening bracket, there is a closing bracket of the same type. 2. The brackets must close in the correct order. # Your task Implement a function: ```python def is_balanced(expr: str) -> bool: # Your code here ``` **Input**: - A single string `expr` containing the characters `\'(\'`, `\')\'`, `\'{\'`, `\'}\'`, `\'[\'`, and `\']\'`. **Output**: - Return `True` if the string is balanced, otherwise return `False`. **Constraints**: - The length of the input string is between 0 and 10^4. # Example ```python assert is_balanced(\\"(){}[]\\") == True assert is_balanced(\\"([{}])\\") == True assert is_balanced(\\"({[)])\\") == False assert is_balanced(\\"({[\\") == False assert is_balanced(\\")\\") == False ``` # Additional Notes 1. Consider using one of the provided stack implementations (`ArrayStack` or `LinkedListStack`) to manage the parentheses. 2. Ensure that your solution handles edge cases such as an empty string or strings starting with closing brackets (`\')\'`, `\'}\'`, `\']\'`).","solution":"def is_balanced(expr: str) -> bool: Function to check if the given string of parentheses is balanced. Parameters: expr (str): The string containing the characters \'()\', \'{}\', \'[]\'. Returns: bool: True if the string is balanced, False otherwise. # Stack to keep track of opening parentheses stack = [] # Dictionary to keep matched pairs matching_pairs = {\'(\': \')\', \'{\': \'}\', \'[\': \']\'} for char in expr: if char in matching_pairs: # If it\'s an opening parenthesis stack.append(char) elif char in matching_pairs.values(): # If it\'s a closing parenthesis if not stack or matching_pairs[stack.pop()] != char: return False # If stack is empty, all opening parentheses were matched return not stack"},{"question":"# Matrix Exponentiation Coding Challenge Context In graph theory, the k-th power of the adjacency matrix of a graph gives information about the number of paths of length k between vertices. In cryptographic algorithms, matrix exponentiation is widely used for key generation and transformations. Objective Implement a function that computes the k-th power of a given square matrix using matrix exponentiation by squaring. Function Definition ```python def matrix_exponentiation_kth_power(matrix: list, k: int) -> list: Compute the k-th power of a given square matrix. Args: - matrix (list of lists of ints): square matrix of size n x n. - k (int): the exponent to raise the matrix to. Returns: - list of lists of ints: resulting matrix after exponentiation. Constraints: - Matrix should be non-empty and square (n x n). - k should be a non-negative integer. - Matrix elements and k fit within standard 32-bit integer ranges. The function should have a complexity of O(n^3 log k) where n is matrix dimension. ``` Example ```python >>> matrix = [ [2, 0], [0, 2] ] >>> k = 3 >>> matrix_exponentiation_kth_power(matrix, k) [ [8, 0], [0, 8] ] ``` Constraints 1. The input matrix will be a valid square matrix of integer values. 2. The exponent k will be a non-negative integer. 3. The matrix dimensions and k will be bounded by reasonable computational limits (matrix dimension <= 100, k <= 1000). Hints 1. Consider the base cases: k = 0 or any matrix multiplied by the identity matrix. 2. Use efficient matrix multiplication as shown in the provided snippets. 3. Recursive squaring can help in reducing the problem size logarithmically.","solution":"def matrix_multiply(A, B): Multiplies two matrices A and B. n = len(A) result = [[0] * n for _ in range(n)] for i in range(n): for j in range(n): for k in range(n): result[i][j] += A[i][k] * B[k][j] return result def matrix_exponentiation_kth_power(matrix, k): Compute the k-th power of a given square matrix using exponentiation by squaring. def matrix_identity(size): identity = [[0 if i != j else 1 for j in range(size)] for i in range(size)] return identity def matrix_power(matrix, power): if power == 0: return matrix_identity(len(matrix)) if power == 1: return matrix if power % 2 == 0: half_power = matrix_power(matrix, power // 2) return matrix_multiply(half_power, half_power) else: return matrix_multiply(matrix, matrix_power(matrix, power - 1)) return matrix_power(matrix, k)"},{"question":"# Removing Duplicate Characters in a String **Objective:** You are required to write a function that removes any duplicate characters in a given string while preserving the order of their first occurrences. Input: A single string `s` made up of ASCII characters. Output: A string containing the first occurrence of each character from the input string in the order of their first appearance. Constraints: * 1 <= len(s) <= 10^5 * The string consists of printable ASCII characters. Example: Input: ```plaintext \\"google\\" ``` Output: ```plaintext \\"gole\\" ``` Input: ```plaintext \\"programming\\" ``` Output: ```plaintext \\"progamin\\" ``` Requirements: 1. The function should have an optimal time complexity of O(n). 2. Avoid excessive use of memory beyond what is required for the set of characters and final output string. Function Signature: ```python def remove_duplicate_characters(s: str) -> str: pass ``` Test your function with multiple test cases to ensure full coverage of edge cases and performance benchmarks.","solution":"def remove_duplicate_characters(s: str) -> str: Returns a string with duplicate characters removed while preserving the order of their first occurrences. seen = set() result = [] for char in s: if char not in seen: seen.add(char) result.append(char) return \'\'.join(result)"},{"question":"# Coin Change Problem Context You are tasked with creating a dynamic coin counter for a bank that needs to fulfill customer requests for specific amounts using certain denominations. Customers can specify the desired amount and the available denominations of coins to produce that amount. Problem Statement Write a function `count(coins, value)` that computes the number of distinct ways to combine the given coin denominations to reach the specified value. The order in which coins are combined does not matter. Input * `coins`: A list of distinct positive integers representing available coin denominations. * `value`: An integer representing the target amount of money. Output * An integer representing the number of ways to make up `value` using any number of coins from `coins`. Constraints * All coin denominations provided are positive integers. * The value is a non-negative integer. * There is an infinite supply of each coin denomination. Expected Performance The solution should efficiently handle given constraints by employing dynamic programming, keeping time complexity at O(n * m) and space complexity at O(n). Example ```python assert count([1, 2, 3], 4) == 4 # Explanation: There are four ways to make change for 4 using coins [1, 2, 3]: # [1, 1, 1, 1], [1, 1, 2], [2, 2], and [1, 3]. assert count([2, 5, 3, 6], 10) == 5 # Explanation: There are five ways to make change for 10 using coins [2, 5, 3, 6]: # [2, 2, 2, 2, 2], [2, 2, 3, 3], [2, 2, 6], [2, 3, 5], and [5, 5]. ``` Solution Approach You’ll implement a dynamic programming approach to solve this problem, where you maintain a dp array to track combinations of ways for each value up to the target value.","solution":"def count(coins, value): Returns the number of ways to make change for `value` using provided `coins` denominations. # Initialize a list to store the number of ways to make change for each amount from 0 to value dp = [0] * (value + 1) dp[0] = 1 # Base case: There is one way to make the amount 0, which is using no coins # Iterate through each coin in coins for coin in coins: # Update dp for current coin for i in range(coin, value + 1): dp[i] += dp[i - coin] return dp[value]"},{"question":"# Regular Expression Matching with Dynamic Programming Objective Implement a function `bool is_match(const char *s, const char *p)` to determine if the input string `s` matches the pattern `p`, where pattern `p` contains characters followed by the special characters `.` and `*`. Specification - `\\".\\"` - Matches any single character. - `\\"*\\"` - Matches zero or more of the preceding element. The matching should cover the entire input string (not partial). Input - `s`: A string consisting of lower case alphabets. - `p`: A string consisting of lower case alphabets, `.` and `*`. Output - Return `True` if the string matches the given pattern, otherwise return `False`. Examples ```python print(is_match(\\"aa\\",\\"a\\")) # False print(is_match(\\"aa\\",\\"aa\\")) # True print(is_match(\\"aaa\\",\\"aa\\")) # False print(is_match(\\"aa\\", \\"a*\\")) # True print(is_match(\\"aa\\", \\".*\\")) # True print(is_match(\\"ab\\", \\".*\\")) # True print(is_match(\\"aab\\", \\"c*a*b\\")) # True ``` Exercise Requirements - Implement the `is_match` function. - Your solution must use dynamic programming to solve the problem efficiently. - Consider edge cases like empty strings or patterns and handle them gracefully. - The solution must run within O(n times m) time complexity. Constraints - 1 <= len(s), len(p) <= 1000","solution":"def is_match(s, p): Returns True if string s matches pattern p, otherwise False. Pattern p can include \'.\' which matches any single character and \'*\' which matches zero or more of the preceding element. m, n = len(s), len(p) # dp[i][j] will be True if the first i characters in s and the first j characters in p match. dp = [[False] * (n + 1) for _ in range(m + 1)] # Base case: empty string matches empty pattern dp[0][0] = True # Handle patterns like a*, a*b*, a*b*c* etc. for j in range(2, n + 1): if p[j - 1] == \'*\': dp[0][j] = dp[0][j - 2] for i in range(1, m + 1): for j in range(1, n + 1): # If characters match or pattern has a \'.\' character if p[j - 1] == s[i - 1] or p[j - 1] == \'.\': dp[i][j] = dp[i - 1][j - 1] # If pattern has a \'*\' character elif p[j - 1] == \'*\': dp[i][j] = dp[i][j - 2] # Treat zero occurrence of the preceding element if p[j - 2] == s[i - 1] or p[j - 2] == \'.\': dp[i][j] = dp[i][j] or dp[i - 1][j] return dp[m][n]"},{"question":"# Gnome Sort Implementation and Analysis You are required to implement the `gnome_sort` algorithm to sort an array of integers. Additionally, analyze the performance and limitations of the Gnome Sort algorithm. Input * A list of integers which can include negative numbers, zeros, and duplicates. Output * A sorted list of integers in non-decreasing order. Constraints * The length of the list is between 0 and 1000 inclusive. * The integer values in the list are between -10^6 and 10^6 inclusive. Functional Requirements 1. Implement the gnome sort algorithm as described. 2. Ensure your implementation handles edge cases gracefully, such as empty arrays, single element arrays, and arrays with duplicate elements. 3. You must not use any helper functions or additional data structures except for the array to sort. 4. The algorithm should operate in-place, modifying the input list directly. Example ```python assert gnome_sort([]) == [] assert gnome_sort([5]) == [5] assert gnome_sort([34, 2, 78, 12, 23]) == [2, 12, 23, 34, 78] assert gnome_sort([1, 2, 2, 2, 3]) == [1, 2, 2, 2, 3] assert gnome_sort([3, 1, -2, 0]) == [-2, 0, 1, 3] assert gnome_sort([9, 7, 5, 3, 1]) == [1, 3, 5, 7, 9] ``` Performance * The function should ideally finish execution within a few seconds for the input constraints provided. * Discuss the best and worst case time complexities in your implementation\'s comments for clarity.","solution":"def gnome_sort(arr): Sorts an array of integers using the Gnome Sort algorithm. Parameters: arr (list): List of integers to be sorted. Returns: list: The sorted list of integers. pos = 0 n = len(arr) while pos < n: if pos == 0 or arr[pos] >= arr[pos - 1]: pos += 1 else: arr[pos], arr[pos - 1] = arr[pos - 1], arr[pos] pos -= 1 return arr # Performance Analysis: # Best Case Time Complexity: O(n) - when the list is already sorted # Worst Case Time Complexity: O(n^2) - when the list is sorted in reverse order # Average Time Complexity: O(n^2) # Space Complexity: O(1) - since it is an in-place sorting algorithm"},{"question":"<|Analysis Begin|> # Core Identification * **Algorithm/Data Structure**: One Edit Distance Algorithm * **Type**: String Manipulation * **Main Purpose**: To determine whether two strings are one edit distance apart. # Complexity * **Time Complexity**: O(n), where n is the length of the shorter string. The algorithm makes a single pass over the string in the worst case. * **Space Complexity**: O(1), since no additional space proportional to the input size is used, apart from a few variables. # Principles * **Operational Steps**: 1. Check the length difference between the two strings. 2. If the difference is more than 1, return `False`. 3. Iterate over the characters of the shorter string: * If characters differ, check the rest of the strings to see if only one change (either insertion, deletion, or substitution) makes them equal. 4. If end of the shorter string is reached, return `True` if the length difference is 1. # Characteristics & Applications * **Properties**: Determines if two strings are exactly one modification (insert, delete, or change) away. * **Common Use Cases**: - Spell checkers to suggest corrections. - Version control systems for detecting near version changes. * **Strengths/Limitations**: * **Strengths**: Fast and efficient for small modifications, straightforward implementation. * **Limitations**: Only works for a single edit; doesn\'t generalize to multiple edits easily. # Implementation Challenges * **Edge Cases**: - Strings with the same length but more than one character different. - One string being empty while the other has one character. - Length difference between strings of more than one. - Both strings being equal. * **Performance Bottlenecks**: None particularly, given the linear complexity. * **Error Scenarios**: - Miscounting the number of edits required. - Incorrect handling of insert versus delete operations. * **Optimization Points**: Existing solution is optimal for the problem\'s constraints. # Enhancements An improvement on the existing logic can involve better string manipulations and considering more efficient comparisons. <|Analysis End|> <|Question Begin|> # Coding Assessment Question **Description**: You are tasked to implement a function that determines if two given strings are one edit distance apart. Two strings are considered one edit distance apart if you can: - Insert exactly one character into one string to make them equal to the other string. - Remove exactly one character from one string to make them equal to the other string. - Replace exactly one character in one string to make them equal to the other string. **Function Signature**: ```python def is_one_edit_distance(s: str, t: str) -> bool: pass ``` **Input**: - `s` (string): A string of lowercase English letters. - `t` (string): A string of lowercase English letters. **Output**: - Return a boolean value (`True` or `False`) indicating if the two strings are one edit distance apart. **Constraints**: - `0 <= len(s), len(t) <= 10^4` - `s` and `t` consist of lowercase English letters only. **Examples**: 1. `is_one_edit_distance(\\"abc\\", \\"ab\\")` should return `True` 2. `is_one_edit_distance(\\"abc\\", \\"adc\\")` should return `True` 3. `is_one_edit_distance(\\"abc\\", \\"abcd\\")` should return `True` 4. `is_one_edit_distance(\\"abc\\", \\"abcde\\")` should return `False` 5. `is_one_edit_distance(\\"abc\\", \\"def\\")` should return `False` 6. `is_one_edit_distance(\\"a\\", \\"a\\")` should return `False` **Explanation**: 1. For the input example above, removing \'c\' from \\"abc\\" or adding \'c\' to \\"ab\\" makes the strings equal. 2. Replacing \'b\' with \'d\' in \\"abc\\" makes it \\"adc\\". 3. Adding \'d\' to \\"abc\\" makes it \\"abcd\\". 4. Adding more than one character or removing more than one character renders them more than one edit distance apart. 5. Requires more than one character change to match. 6. Strings are not considered one edit distance apart if they are already equal. **Notes**: - Consider edge cases, such as one or both strings being empty. - Aim for a solution with linear time complexity O(n) and constant space complexity O(1).","solution":"def is_one_edit_distance(s: str, t: str) -> bool: # Get lengths of both strings len_s, len_t = len(s), len(t) # If length difference is more than 1, immediately return False if abs(len_s - len_t) > 1: return False # Ensure s is the shorter string or of equal length if len_s > len_t: s, t = t, s len_s, len_t = len_t, len_s # Variables to track the number of edits found found_difference = False # Pointers for both strings i, j = 0, 0 while i < len_s and j < len_t: if s[i] != t[j]: if found_difference: return False found_difference = True # If lengths are same, move both pointers if len_s == len_t: i += 1 else: i += 1 j += 1 return True if found_difference or len_s != len_t else False"},{"question":"# Problem Scenario You are tasked with implementing a function for a spell-checking application that needs to verify if two given phrases are anagrams. The phrases may contain alphabetic characters and spaces, while being of various lengths. Ignore spaces during the comparison and assume that the characters can be in any case (i.e., treat \'A\' as equivalent to \'a\'). # Objective Create a function `are_anagrams(phrase1: str, phrase2: str) -> bool` that returns `True` if the given phrases are anagrams of each other, and `False` otherwise. # Expected Input and Output Formats * **Input**: - Two strings `phrase1` and `phrase2` each which may contain letters and spaces. * **Output**: - A boolean value `True` if the phrases are anagrams, `False` otherwise. # Constraints 1. The input strings can have lengths in the range [0, 100000]. 2. Both strings will only contain alphabetic letters (A-Z, a-z) and spaces. 3. Comparison should be case-insensitive. # Performance Requirements Your implementation should be efficient in terms of time and space complexity, ideally running in linear time relative to the input size. # Example Cases *Example 1*: ```python print(are_anagrams(\\"Listen\\", \\"Silent\\")) # Output: True ``` *Example 2*: ```python print(are_anagrams(\\"Triangle\\", \\"integral\\")) # Output: True ``` *Example 3*: ```python print(are_anagrams(\\"Apple\\", \\"Plead Up\\")) # Output: False ```","solution":"def are_anagrams(phrase1: str, phrase2: str) -> bool: Returns True if the two phrases are anagrams of each other, ignoring spaces and case. # Remove spaces and convert to lowercase stripped_phrase1 = \'\'.join(phrase1.split()).lower() stripped_phrase2 = \'\'.join(phrase2.split()).lower() # Check if sorted characters are the same return sorted(stripped_phrase1) == sorted(stripped_phrase2)"},{"question":"# String Reversal Challenge **Objective**: Implement a function to reverse a given string. Assess and compare multiple methods in terms of complexity and performance. # Input - A single string `s`, where `1 <= len(s) <= 10^5`. # Output - The reversed string. # Constraints - Function should handle edge cases like empty strings and single character strings. - Consider performance and memory usage when choosing the method. # Functions to Implement 1. **Recursive Approach**: ```python def recursive_reverse(s: str) -> str: pass ``` 2. **Iterative Approach**: ```python def iterative_reverse(s: str) -> str: pass ``` 3. **Pythonic Approach**: ```python def pythonic_reverse(s: str) -> str: pass ``` 4. **Ultra-Pythonic Approach**: ```python def ultra_pythonic_reverse(s: str) -> str: pass ``` # Task Implement all four methods and test them under various conditions to understand their performance trade-offs. Provide clear documentation and comments on your code about which approach to use under different scenarios. # Example: ```python >>> print(recursive_reverse(\\"hello\\")) \'olleh\' >>> print(iterative_reverse(\\"world\\")) \'dlrow\' >>> print(pythonic_reverse(\\"example\\")) \'elpmaxe\' >>> print(ultra_pythonic_reverse(\\"data\\")) \'atad\' ``` # Performance: - Ensure the solutions handle the maximum input size efficiently. - Discuss and analyze the time and space complexities for each implemented function.","solution":"def recursive_reverse(s: str) -> str: Reverses the string `s` using a recursive approach. if len(s) == 0: return s else: return s[-1] + recursive_reverse(s[:-1]) def iterative_reverse(s: str) -> str: Reverses the string `s` using an iterative approach. reversed_str = [] for char in s: reversed_str.insert(0, char) return \'\'.join(reversed_str) def pythonic_reverse(s: str) -> str: Reverses the string `s` using Python slicing. return s[::-1] def ultra_pythonic_reverse(s: str) -> str: Reverses the string `s` using the `reversed` function and `join`. return \'\'.join(reversed(s))"},{"question":"You are given a non-negative number represented as an array of digits, where each digit is in the range 0–9 and the most significant digit is at the head of the list. Write a function that increments this number by one. Your task is to provide an implementation of this function that efficiently handles large lists of digits. The function should modify the input list in place without using extra space for the resultant list. # Function Signature ```python def increment_digits(digits: List[int]) -> List[int]: pass ``` # Input - `digits` (List[int]): A list of integers where each integer is between 0-9, representing the digits of a non-negative number. # Output - Returns the modified list of digits after incrementing by one. # Constraints - The input list may be empty, representing the number zero. # Requirements - Ensure an in-place modification approach (space complexity O(1)). - Achieve linear time complexity (O(n)). # Example 1. Given input: `[1, 2, 3]` - Output: `[1, 2, 4]` 2. Given input: `[9, 9, 9]` - Output: `[1, 0, 0, 0]` 3. Given input: `[0]` - Output: `[1]` # Edge Cases - Handling empty input lists. - Handling lists with multiple zeros only. - Handling lists where all digits are nine.","solution":"def increment_digits(digits): Increment a number represented by a list of digits by one. The number is modified in place. :param digits: List[int] - List of digits representing a non-negative number :return: List[int] - The same list of digits incremented by one n = len(digits) # Handle empty input if n == 0: return [1] # Process from the last digit towards the first for i in reversed(range(n)): if digits[i] < 9: digits[i] += 1 return digits # Return early since no further carry is needed digits[i] = 0 # Set the current digit to 0 and carry the 1 to the next digit # If all digits were 9, we need an extra digit at the beginning return [1] + digits"},{"question":"# Coding Challenge: Pathfinding in a Directed Graph Problem Statement You are given a directed graph represented by the `DirectedGraph` class, and you need to determine if there is a path from a given source node to a target node using Depth-First Search (DFS). Function Signature ```python def has_path(graph: DirectedGraph, start: str, end: str) -> bool: ``` Input * `graph`: An instance of `DirectedGraph` class. * `start`: A string representing the name of the starting node. * `end`: A string representing the name of the target node. Output * Returns a boolean `True` if there is a path from the `start` node to the `end` node, `False` otherwise. Constraints * Assume all node names are unique and non-empty strings. * The graph may be disconnected, and no assumptions should be made about node connectivity except those expressed in the adjacency list. Example ```python # Example usage: graph_data = { \'A\': [\'B\', \'C\'], \'B\': [\'D\'], \'C\': [], \'D\': [\'E\'], \'E\': [] } graph = DirectedGraph(graph_data) print(has_path(graph, \'A\', \'E\')) # Output: True print(has_path(graph, \'A\', \'C\')) # Output: True print(has_path(graph, \'E\', \'A\')) # Output: False ``` Detailed Requirements * Implement the function `has_path` using DFS. * Handle cases where either `start` or `end` node do not exist in the graph. * Ensure that the solution can handle graphs with a large number of nodes and edges efficiently. Edge Cases to Consider * The start node is the same as the end node. * One or both of the nodes are not present in the graph. * The graph contains cycles. Assumptions * You can use the classes provided in the code snippet above to represent and manage the graph structure.","solution":"class DirectedGraph: def __init__(self, adj_list): self.adj_list = adj_list def has_path(graph: DirectedGraph, start: str, end: str) -> bool: if start not in graph.adj_list or end not in graph.adj_list: return False def dfs(node, goal, visited): if node == goal: return True visited.add(node) for neighbor in graph.adj_list.get(node, []): if neighbor not in visited: if dfs(neighbor, goal, visited): return True return False return dfs(start, end, set())"},{"question":"Graph Traversal Problem # Context You are given an unweighted, undirected graph represented as an adjacency list. The graph is presented through a dictionary where keys are nodes and values are lists of neighbors of the corresponding nodes. # Task Implement two functions to traverse the graph using Depth First Search (DFS) and Breadth First Search (BFS). You must handle the traversal iteratively for both methods. # Requirements 1. Implement the function `dfs_traverse(graph, start)` that traverses the graph using DFS. 2. Implement the function `bfs_traverse(graph, start)` that traverses the graph using BFS. # Input and Output Formats Input - `graph`: A dictionary representing the adjacency list of the graph. - Example: `graph = {\'A\': [\'B\', \'C\'], \'B\': [\'A\', \'D\', \'E\'], \'C\': [\'A\', \'F\'], \'D\': [\'B\'], \'E\': [\'B\', \'F\'], \'F\': [\'C\', \'E\']}` - `start`: The starting node for the traversal. Ensure that the `start` node exists in the graph. Output - Both functions should return a set of all visited nodes. # Constraints and Considerations - The graph is connected, i.e., there is a path between any pair of vertices. - Nodes are uniquely identifiable (e.g., through letters or numbers). - You must ensure the traversal does not enter an infinite loop in the presence of cycles. - Aim for the optimal time and space complexity as discussed. # Example ```python graph = { \'A\': [\'B\', \'C\'], \'B\': [\'A\', \'D\', \'E\'], \'C\': [\'A\', \'F\'], \'D\': [\'B\'], \'E\': [\'B\', \'F\'], \'F\': [\'C\', \'E\'] } start = \'A\' print(dfs_traverse(graph, start)) # Example output: {\'A\', \'B\', \'D\', \'E\', \'F\', \'C\'} print(bfs_traverse(graph, start)) # Example output: {\'A\', \'B\', \'C\', \'D\', \'E\', \'F\'} ```","solution":"def dfs_traverse(graph, start): Traverse the graph using Depth First Search (DFS) algorithm. Args: graph: dict - adjacency list of the graph start: any - starting node for the traversal Returns: set - set of visited nodes in the graph during the traversal visited = set() stack = [start] while stack: node = stack.pop() if node not in visited: visited.add(node) stack.extend(neigh for neigh in graph[node] if neigh not in visited) return visited def bfs_traverse(graph, start): Traverse the graph using Breadth First Search (BFS) algorithm. Args: graph: dict - adjacency list of the graph start: any - starting node for the traversal Returns: set - set of visited nodes in the graph during the traversal visited = set() queue = [start] while queue: node = queue.pop(0) if node not in visited: visited.add(node) queue.extend(neigh for neigh in graph[node] if neigh not in visited) return visited"},{"question":"# Scenario: You are given a series of operations to perform on a doubly linked list. Your task is to implement functions to handle insertion, deletion, and traversal operations. The output of the operations should reflect the current state of the list after each operation. # Task: Implement a `DoublyLinkedList` class with the following methods: 1. `append(value)`: Insert a node with the given value at the end of the list. 2. `prepend(value)`: Insert a node with the given value at the beginning of the list. 3. `delete(value)`: Delete the first node with the given value from the list. 4. `print_list()`: Print the values of nodes in the list from head to tail. # Constraints: - Input values for node insertion/deletion will be non-negative integers. - The delete operation will only be called if the value exists in the list. # Example: ```python # Initialize the list dll = DoublyLinkedList() # Perform operations dll.append(3) dll.prepend(1) dll.append(4) dll.prepend(0) dll.delete(3) dll.print_list() # Expected output: 0 1 4 ``` # Implementation Details: - The `DoublyLinkedList` class: - Should use the `DoublyLinkedListNode` class provided. - Each operation should properly maintain the `next` and `prev` references of the nodes. - Ensure efficient handling of edge cases such as empty list operations and single-element list operations. # Notes: - Do not use built-in Python list methods for managing the linked list; implement the logic using nodes and pointers. - Efficiently handle operations reflecting the principles of doubly linked lists.","solution":"class DoublyLinkedListNode: def __init__(self, value): self.value = value self.next = None self.prev = None class DoublyLinkedList: def __init__(self): self.head = None self.tail = None def append(self, value): new_node = DoublyLinkedListNode(value) if not self.head: self.head = new_node self.tail = new_node return self.tail.next = new_node new_node.prev = self.tail self.tail = new_node def prepend(self, value): new_node = DoublyLinkedListNode(value) if not self.head: self.head = new_node self.tail = new_node return self.head.prev = new_node new_node.next = self.head self.head = new_node def delete(self, value): current = self.head while current: if current.value == value: if current.prev: current.prev.next = current.next if current.next: current.next.prev = current.prev if current == self.head: self.head = current.next if current == self.tail: self.tail = current.prev return current = current.next def print_list(self): current = self.head while current: print(current.value, end=\' \') current = current.next print()"},{"question":"Objective Design a function that determines if two given strings are anagrams of each other, with enhancements to handle all alphanumeric characters and mixed case. Problem Statement Given two strings `s1` and `s2`, write a function `is_anagram(s1, s2)` that checks whether the strings are anagrams. This time, your implementation should be case insensitive and handle any alphanumeric characters (not just lower-case a-z). Input * Two strings `s1` and `s2`. * Both strings will contain alphanumeric characters only (a-zA-Z0-9). Output * A boolean value `True` if `s1` and `s2` are anagrams, `False` otherwise. Constraints * The length of the strings will be between 1 and 10^5 characters. Requirements * Ensure your implementation has a time complexity of O(n). * Optimize for space, making sure your solution handles character sets efficiently. Example ```python >>> is_anagram(\\"Apple123\\", \\"3Pleap21\\") True >>> is_anagram(\\"hello\\", \\"billion\\") False >>> is_anagram(\\"Listen\\", \\"Silent\\") True ``` Notes * Consider character case insensitivity. * Ensure to include checks for different edge cases such as mixed characters and differing string lengths.","solution":"def is_anagram(s1, s2): This function checks whether two input strings s1 and s2 are anagrams. The function is case insensitive and considers all alphanumeric characters. from collections import Counter # Normalize the input strings by converting them to lowercase normalized_s1 = s1.lower() normalized_s2 = s2.lower() # Count the frequency of each character in both strings return Counter(normalized_s1) == Counter(normalized_s2)"},{"question":"You are given a positive integer `n`. Your task is to write a function that returns all possible combinations of its factors, excluding 1 and `n` itself. The factors should also be sorted in non-decreasing order. Input Format - One single integer `n` (> 1). Output Format - A list of lists, where each sublist represents a unique combination of factors of `n`. Constraints 1. The factors in each combination should be in non-decreasing order. 2. Factors should be checked from the integer value `2` onwards up to the square root of `n`. 3. The factor pairs should not include `1` and `n` itself. Example: # Example 1: Input: ```python n = 12 ``` Output: ```python [ [2, 6], [2, 2, 3], [3, 4] ] ``` # Example 2: Input: ```python n = 32 ``` Output: ```python [ [2, 16], [2, 2, 8], [2, 2, 2, 4], [2, 2, 2, 2, 2], [2, 4, 4], [4, 8] ] ``` # Example 3: Input: ```python n = 37 ``` Output: ```python [] ``` Write the following two functions `get_factors` and `recursive_get_factors` adhering to the above specifications. Function Definitions: 1. **Iterative Implementation** ```python def get_factors(n): # Your code here ``` 2. **Recursive Implementation** ```python def recursive_get_factors(n): # Your code here ``` Ensure your implementation is efficient and accounts for the edge cases mentioned.","solution":"def get_factors(n): Returns all possible combinations of factors of n (excluding 1 and n itself), such that the factors in each combination are in non-decreasing order. def backtrack(start, num, path, result): while start * start <= num: if num % start == 0: result.append(path + [start, num // start]) backtrack(start, num // start, path + [start], result) start += 1 result = [] backtrack(2, n, [], result) return result def recursive_get_factors(n): def find_factors(start, num): factors = [] while start * start <= num: if num % start == 0: factors.append([start, num // start]) for sub in find_factors(start, num // start): factors.append([start] + sub) start += 1 return factors return find_factors(2, n)"},{"question":"# Question You are a professional programmer who needs to design a solution for a security company. The company wants to create a system to help robbers determine the maximum amount of money they can rob from houses arranged linearly without triggering an alarm. The constraints stipulate that adjacent houses have a security system connected which will automatically contact the police if two adjacent houses are broken into on the same night. Problem Implement a function `max_rob_amount` which, given a list of non-negative integers representing the amount of money stashed in each house, returns the maximum amount of money one can rob tonight without alerting the police. **Function Signature**: ```python def max_rob_amount(houses: List[int]) -> int: pass ``` Input - `houses (List[int])`: A list of integers where each integer is the amount of money stashed in a house. - 0 ≤ len(houses) ≤ 1000 - 0 ≤ houses[i] ≤ 10^4 Output - **int**: The maximum amount of money that can be robbed without triggering an alarm. Constraints - The robber cannot rob two adjacent houses. - The list may be empty, in which case the function should return 0. Examples ```python assert max_rob_amount([1, 2, 3, 1]) == 4 assert max_rob_amount([2, 7, 9, 3, 1]) == 12 assert max_rob_amount([]) == 0 assert max_rob_amount([10]) == 10 assert max_rob_amount([10, 1, 10]) == 20 ``` **Explanation of Examples**: 1. In the first example, the maximum amount is `1 + 3 = 4`. 2. In the second example, the maximum amount is `2 + 9 + 1 = 12`. 3. The third example has an empty list, thus the return is `0`. 4. The fourth example has just one house, so the maximum amount is the money in that house which is `10`. 5. In the fifth example, robbing the first and third house yields the maximum amount, `10 + 10 = 20`. **Additional Notes**: - Edge cases include scenarios with an empty list or a single house. - Consider the time complexity and attempt to solve the problem in O(n) time with O(1) space for efficiency.","solution":"from typing import List def max_rob_amount(houses: List[int]) -> int: Returns the maximum amount of money that can be robbed without triggering alarms in adjacent houses. # Base case: if there are no houses, return 0 if not houses: return 0 # Base case: if there is only one house, return the amount in that house if len(houses) == 1: return houses[0] prev1 = 0 # Max amount we can rob from the first i-1 houses prev2 = 0 # Max amount we can rob from the first i-2 houses for amount in houses: current = max(prev1, prev2 + amount) prev2 = prev1 prev1 = current return prev1"},{"question":"# Coding Assessment: Improving the Nearest Neighbor Algorithm Problem Statement You are provided with an implementation of the nearest neighbor classification algorithm. Your task is to improve and extend the provided code in the following ways: 1. **Optimize Distance Calculation**: Modify the distance computation function to handle large dimensional vectors efficiently. 2. **Implement `k-NN`**: Extend the `nearest_neighbor` function to `k_nearest_neighbors`, which returns the majority class among the k-nearest neighbors. 3. **Handle Edge Cases**: Ensure the solution properly handles cases where the query point is identical to one or more points in the dataset. 4. **Error Handling**: Add appropriate error handling to manage cases of incorrect input format or inconsistent data. Function Signature ```python def k_nearest_neighbors(x: tuple, tSet: dict, k: int) -> any: Find the majority class among the k-nearest neighbors of the point x. Args: x (tuple): A query vector. tSet (dict): Training dataset where keys are tuples representing points in the vector space, and values are the class labels. k (int): The number of nearest neighbors to consider. Returns: The majority class label among the k-nearest neighbors. ``` Constraints - Assume the input points in `tSet` and the query point `x` lie in the same d-dimensional space where ( 1 leq d leq 100 ). - ( k ) can range from 1 to the number of elements in `tSet`. - If multiple classes have the same majority vote, return any one of them. Input/Output Formats - **Input**: - `x`: A tuple representing a point in d-dimensional space. - `tSet`: A dictionary with points as keys (tuples of length d), and corresponding class labels as values. - `k`: An integer representing the number of nearest neighbors to consider. - **Output**: - The class label (from the values of `tSet`) determined by the majority vote of the k-nearest neighbors. Sample Input ```python x = (1, 2) tSet = {(0, 0): \'A\', (0, 1): \'A\', (1, 1): \'B\', (2, 3): \'B\'} k = 2 ``` Sample Output ```python \'B\' ```","solution":"from collections import Counter import math def euclidean_distance(p1, p2): Computes the Euclidean distance between two points p1 and p2. p1 and p2 are tuples of the same length. return math.sqrt(sum((a - b) ** 2 for a, b in zip(p1, p2))) def k_nearest_neighbors(x: tuple, tSet: dict, k: int) -> any: Find the majority class among the k-nearest neighbors of the point x. Args: x (tuple): A query vector. tSet (dict): Training dataset where keys are tuples representing points in the vector space, and values are the class labels. k (int): The number of nearest neighbors to consider. Returns: The majority class label among the k-nearest neighbors. if not isinstance(x, tuple) or not all(isinstance(i, (int, float)) for i in x): raise ValueError(\\"Query point x must be a tuple of numbers.\\") if not isinstance(tSet, dict) or not all(isinstance(keys, tuple) for keys in tSet): raise ValueError(\\"Training dataset tSet must be a dictionary with tuples as keys.\\") if not isinstance(k, int) or k <= 0 or k > len(tSet): raise ValueError(\\"Parameter k must be an integer between 1 and the number of elements in tSet.\\") # Use a list to store distances and corresponding labels distances = [] for point, label in tSet.items(): if not isinstance(point, tuple) or len(point) != len(x): raise ValueError(\\"All points in tSet must be tuples of the same length as x.\\") distance = euclidean_distance(x, point) distances.append((distance, label)) # Sort the list by distance distances.sort(key=lambda pair: pair[0]) # Select the k nearest neighbors k_nearest_labels = [label for _, label in distances[:k]] # Return the majority class majority_class = Counter(k_nearest_labels).most_common(1)[0][0] return majority_class"},{"question":"// **Scenario/Context**// You\'ve been hired by a tech company working on a low-level data processing system. Part of your task is to analyze binary representations of integers to identify certain patterns. Specifically, you\'ve been asked to determine the longest distance between two consecutive 1\'s in the binary form of a given positive integer. Your function `find_longest_binary_gap` will help in achieving this task by performing the following: **Objective**: Implement a function `find_longest_binary_gap(N)` that takes a positive integer N as input and returns the longest distance between two consecutive 1\'s in the binary representation of N. If there are no consecutive 1\'s, return 0. **Input format**: - A single positive integer N (1 ≤ N ≤ 10^9). **Output format**: - A single integer representing the longest distance between consecutive 1\'s. **Constraints**: - Ensure your solution is optimized for large values of N. - No need for error handling of invalid inputs (assume inputs are positive integers). **Examples**: Example 1: - Input: `22` - Output: `2` - Explanation: Binary representation of 22 is `10110`. The distances between consecutive 1\'s are 2 and 1. The longest distance is 2. Example 2: - Input: `5` - Output: `2` - Explanation: Binary representation of 5 is `101`. The only distance between consecutive 1\'s is 2. Example 3: - Input: `8` - Output: `0` - Explanation: Binary representation of 8 is `1000`. No consecutive 1\'s exist, hence the output is 0. ```python def find_longest_binary_gap(N): last = None max_gap = 0 position = 0 while N > 0: if N & 1: if last is not None: max_gap = max(max_gap, position - last) last = position position += 1 N >>= 1 return max_gap # Test cases print(find_longest_binary_gap(22)) # Expected output: 2 print(find_longest_binary_gap(5)) # Expected output: 2 print(find_longest_binary_gap(8)) # Expected output: 0 print(find_longest_binary_gap(0)) # Expected output: 0 print(find_longest_binary_gap(1)) # Expected output: 0 ``` **Explanation**: In the example implementation above: 1. We initialize `last` to `None` to keep track of the position of the last seen 1. 2. We initialize `max_gap` to 0 to store the maximum gap found. 3. We iterate through each bit of the number using bitwise operations. 4. If the current bit is 1, and `last` is not `None`, we calculate the gap and update `max_gap` if the current gap is larger. 5. We update `last` to the current position of the bit. 6. We shift the number to the right to check the next bit.","solution":"def find_longest_binary_gap(N): Returns the longest distance between two consecutive 1\'s in the binary representation of a positive integer N. last = None max_gap = 0 position = 0 while N > 0: if N & 1: if last is not None: max_gap = max(max_gap, position - last) last = position position += 1 N >>= 1 return max_gap"},{"question":"# Binary Heap Implementation and Application You are required to complete and extend the `BinaryHeap` class provided earlier by implementing additional functionalities to demonstrate a comprehensive understanding of this data structure. Instructions 1. **Implement the Following Methods**: * `Heapify` a given array of integers into a valid min heap. * `kth_smallest` to find the k-th smallest element in the heap. 2. **Constraints**: * All inserts and removals must follow the min heap property. * Handle the edge cases like inserting/removing from an empty heap gracefully. 3. **Input and Output Specifications**: * `heapify(arr: List[int]) -> None`: This method should convert the input list `arr` into a valid min heap. * `kth_smallest(k: int) -> int`: This method should return the k-th smallest element in the current heap. Return -1 if `k` is out of range. 4. **Performance Requirements**: * The `heapify` operation should be optimized with O(N) complexity if possible. * The `kth_smallest` operation should not exceed O(k log N) complexity. Scenario Your company needs an efficient way to manage dynamic sets of numerical data for a priority task scheduler. Implementing these methods will ensure the scheduler can instantly fetch and process the minimal task, as well as ascertain the priority of tasks effectively based on their size. Here is the skeleton of the class that you need to complete: ```python class BinaryHeap(AbstractHeap): def __init__(self): self.current_size = 0 self.heap = [0] def perc_up(self, i): while i // 2 > 0: if self.heap[i] < self.heap[i // 2]: self.heap[i], self.heap[i // 2] = self.heap[i // 2], self.heap[i] i = i // 2 def insert(self, val): self.heap.append(val) self.current_size += 1 self.perc_up(self.current_size) def min_child(self, i): if 2 * i + 1 > self.current_size: return 2 * i if self.heap[2 * i] > self.heap[2 * i + 1]: return 2 * i + 1 return 2 * i def perc_down(self, i): while 2 * i <= self.current_size: min_child = self.min_child(i) if self.heap[i] > self.heap[min_child]: self.heap[i], self.heap[min_child] = self.heap[min_child], self.heap[i] i = min_child def remove_min(self): min_val = self.heap[1] self.heap[1] = self.heap[self.current_size] self.current_size -= 1 self.heap.pop() self.perc_down(1) return min_val def heapify(self, arr): Convert the input list into a valid min heap. # Your code here def kth_smallest(self, k): Find and return the k-th smallest element in the heap. # Your code here ``` Your solution should be comprehensive, maintaining the integrity and efficiency expected of a min heap. Test your implementation with varied scenarios to ensure its robustness.","solution":"class BinaryHeap: def __init__(self): self.current_size = 0 self.heap = [0] def perc_up(self, i): while i // 2 > 0: if self.heap[i] < self.heap[i // 2]: self.heap[i], self.heap[i // 2] = self.heap[i // 2], self.heap[i] i = i // 2 def insert(self, val): self.heap.append(val) self.current_size += 1 self.perc_up(self.current_size) def min_child(self, i): if 2 * i + 1 > self.current_size: return 2 * i if self.heap[2 * i] > self.heap[2 * i + 1]: return 2 * i + 1 return 2 * i def perc_down(self, i): while 2 * i <= self.current_size: min_child = self.min_child(i) if self.heap[i] > self.heap[min_child]: self.heap[i], self.heap[min_child] = self.heap[min_child], self.heap[i] i = min_child def remove_min(self): if self.current_size == 0: return None # Graceful handling of empty heap removal min_val = self.heap[1] self.heap[1] = self.heap[self.current_size] self.current_size -= 1 self.heap.pop() if self.current_size > 0: self.perc_down(1) return min_val def heapify(self, arr): Convert the input list into a valid min heap. self.current_size = len(arr) self.heap = [0] + arr[:] i = self.current_size // 2 while i > 0: self.perc_down(i) i -= 1 def kth_smallest(self, k): Find and return the k-th smallest element in the heap. if k > self.current_size or k <= 0: return -1 # Handle edge case where k is out of range temp_heap = BinaryHeap() temp_heap.heap = self.heap[:] temp_heap.current_size = self.current_size result = -1 for _ in range(k): result = temp_heap.remove_min() return result"},{"question":"# Question: Advanced Counting Sort Implementation You are provided with the specification of the Counting Sort algorithm. Your task is to implement an enhanced version of Counting Sort which can also handle arrays containing negative integers alongside positive integers, while maintaining stability. Problem Statement: Implement a function `enhanced_counting_sort(arr: List[int]) -> List[int]` that sorts an array of integers, including negative and positive numbers. The function should leverage the counting sort algorithm principles and handle edge cases effectively. Input: - `arr`: A list of integers (both negative and positive numbers included). Output: - A list of integers sorted in non-decreasing order. Constraints: - The array can contain a mix of negative and positive integers. - The array has a length `n` where `1 <= n <= 10^6`. - Each integer in the array falls within a range where the difference between the maximum and minimum value is `<= 10^6`. Example: ```python assert enhanced_counting_sort([4, 2, -3, 6, -1, 2]) == [-3, -1, 2, 2, 4, 6] assert enhanced_counting_sort([0, -5, 3, -5, 2, 1]) == [-5, -5, 0, 1, 2, 3] ``` Note: - Your function should handle edge cases such as arrays with all negative numbers, all positive numbers, a single element, and an empty array. *Include necessary optimizations to improve performance in terms of both time and space complexity.* You are NOT allowed to use any built-in sort functions.","solution":"from typing import List def enhanced_counting_sort(arr: List[int]) -> List[int]: if not arr: return [] min_val = min(arr) max_val = max(arr) # Range of numbers range_of_numbers = max_val - min_val + 1 # Initializing count array count = [0] * range_of_numbers # Putting count of each element for num in arr: count[num - min_val] += 1 # Cumulative count for i in range(1, len(count)): count[i] += count[i - 1] # Stability is maintained by placing elements in a new array output = [0] * len(arr) for num in reversed(arr): output[count[num - min_val] - 1] = num count[num - min_val] -= 1 return output"},{"question":"# Merge Sort Coding Challenge Context Merge Sort is a classic sorting algorithm known for its efficiency and stability. Your objective is to implement the Merge Sort algorithm which sorts an array in ascending order. Your implementation should follow the divide-and-conquer approach of recursively splitting an array into halves and then merging those halves in sorted order. Task Implement the `merge_sort` function to sort an array of integers. Ensure that your merge procedure correctly merges the split arrays back into the original array to avoid excess space usage. Function Signature ```python def merge_sort(arr: list[int]) -> list[int]: pass ``` Input * A list of integers, `arr` (1 <= len(arr) <= 10^5). Output * A list of integers sorted in non-decreasing order. Constraints * Your solution should have a time complexity of O(n log(n)). * You should aim for the most efficient space usage possible, ensuring at least an in-place modification of the list during the merge phase. Example ```python arr = [38, 27, 43, 3, 9, 82, 10] sorted_arr = merge_sort(arr) print(sorted_arr) # Output: [3, 9, 10, 27, 38, 43, 82] ``` Notes * Assume the input list contains only integers. * Focus on correct index handling and efficient merging to avoid common pitfalls such as out-of-bound errors or unnecessary space consumption.","solution":"def merge_sort(arr): Performs merge sort on the given array. Args: arr (list): List of integers to be sorted. Returns: list: Sorted list of integers. if len(arr) <= 1: return arr def merge(left, right): result = [] i = j = 0 # Merge the two arrays into result while i < len(left) and j < len(right): if left[i] < right[j]: result.append(left[i]) i += 1 else: result.append(right[j]) j += 1 # Append any remaining items in the arrays result.extend(left[i:]) result.extend(right[j:]) return result def merge_sort_rec(sub_arr): if len(sub_arr) <= 1: return sub_arr mid = len(sub_arr) // 2 left = merge_sort_rec(sub_arr[:mid]) right = merge_sort_rec(sub_arr[mid:]) return merge(left, right) return merge_sort_rec(arr)"},{"question":"# Context As part of a software system\'s performance optimization module, you are required to write a function that calculates the Greatest Common Divisor (GCD) using bitwise operations. # Task Implement a function `bitwise_gcd` that computes the GCD of two non-negative integers using bitwise operations. # Specifications: 1. **Function Signature**: ```python def bitwise_gcd(a: int, b: int) -> int: ``` 2. **Inputs**: - `a` (int): A non-negative integer. - `b` (int): A non-negative integer. 3. **Outputs**: - Returns the GCD of `a` and `b`. # Constraints: 1. The inputs `a` and `b` are guaranteed to be non-negative integers. 2. The function should be optimized to run in logarithmic time. # Example: ```python print(bitwise_gcd(34, 17)) # Output: 17 print(bitwise_gcd(40, 64)) # Output: 8 ``` # Performance Requirements: - Time complexity: O(log(min(a, b))) - Space complexity: O(1) # Notes: 1. Do not use built-in functions for GCD. 2. Utilize bitwise operations wherever possible to enhance performance. 3. Consider edge cases where one or both numbers might be zero. You can make use of a helper function, `trailing_zero`, to count the trailing zero bits in a given integer, which can be utilized in the main `bitwise_gcd` function.","solution":"def trailing_zero(x): Returns the number of trailing zero bits in x. For example, trailing_zero(8) returns 3 because the binary representation of 8 is 1000. if x == 0: return 32 return (x & -x).bit_length() - 1 def bitwise_gcd(a, b): Computes the GCD of two non-negative integers using bitwise operations. if a == 0: return b if b == 0: return a shift = trailing_zero(a | b) a >>= trailing_zero(a) while b != 0: b >>= trailing_zero(b) if a > b: a, b = b, a b -= a return a << shift"},{"question":"# Matrix Transformation: Horizontal and Vertical Reflections Scenario You are given a 2D grid representing a matrix. You need to implement two functions to reflect this matrix horizontally and vertically, respectively. The horizontal reflection means flipping the matrix along its horizontal midline, and the vertical reflection means flipping the matrix along its vertical midline. Task Write two functions, `horizontal_reflect(matrix)` and `vertical_reflect(matrix)`, that perform these transformations. Function Prototypes ```python def horizontal_reflect(matrix: List[List[int]]) -> List[List[int]]: pass def vertical_reflect(matrix: List[List[int]]) -> List[List[int]]: pass ``` Input - `matrix`: A list of lists, where each list represents a row of integers. The matrix is guaranteed to have at least one row and one column. Output - Both functions should return a new matrix (list of lists) representing the transformed matrix. Example ```python matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] # Horizontal reflection output_h = horizontal_reflect(matrix) # Output: # [ # [7, 8, 9], # [4, 5, 6], # [1, 2, 3] # ] # Vertical reflection output_v = vertical_reflect(matrix) # Output: # [ # [3, 2, 1], # [6, 5, 4], # [9, 8, 7] # ] ``` Constraints 1. The matrix will have dimensions `m x n` where `1 ≤ m, n ≤ 100`. 2. The elements of the matrix are integers in the range `-10^9` to `10^9`.","solution":"from typing import List def horizontal_reflect(matrix: List[List[int]]) -> List[List[int]]: return matrix[::-1] def vertical_reflect(matrix: List[List[int]]) -> List[List[int]]: return [row[::-1] for row in matrix]"},{"question":"**Question**: # Context: You are given a list of unique integers which needs to be sorted using an unconventional sorting algorithm called Stooge Sort. This task will help reinforce your understanding of recursive algorithms by implementing one of the less practical sorts known in theoretical computer science. # Task: Write a function `stooge_sort(arr)` that takes in a list of integers `arr` and sorts it using the Stooge Sort algorithm. # Function Signature: ```python def stooge_sort(arr: List[int]) -> List[int]: ``` # Input: - A list `arr` of unique integers where (1 leq text{len(arr)} leq 100). # Output: - A list of integers sorted in non-decreasing order. # Example: ```python arr = [5, 4, 3, 2, 1] stoogesort(arr) # returns [1, 2, 3, 4, 5] ``` # Constraints: - You must implement this using the Stooge Sort algorithm. - The input list will have no more than 100 integers to keep computation feasible given the high complexity of the algorithm. # Notes: - You are not to use any built-in sorting functions except for comparison and swapping. # Performance: - Given the nature of Stooge Sort, the expected time complexity is (O(n^{2.709})). Ensure your solution adheres to this, focusing primarily on correct implementation of the algorithm as described.","solution":"def stooge_sort(arr): Sorts the list arr using the Stooge Sort algorithm. def stoogesort(a, l, h): if l >= h: return if a[l] > a[h]: a[l], a[h] = a[h], a[l] if h - l + 1 > 2: t = (h - l + 1) // 3 stoogesort(a, l, h - t) stoogesort(a, l + t, h) stoogesort(a, l, h - t) stoogesort(arr, 0, len(arr) - 1) return arr"},{"question":"# Question: Implement Red-Black Tree Lookup You are tasked with implementing a function to search for a specific value in a Red-Black Tree. Implement the `search` method in the `RBTree` class, which should return a node with the given value if it exists, or `None` if it does not. Your implementation of `search` should follow the standard approach for binary search tree lookups, taking into account that the tree is balanced and color properties do not affect the lookup. Method Signature ```python def search(self, value: int) -> RBNode: # your code here ``` # Input - An integer `value`, which is the value to be searched in the Red-Black Tree. # Output - An `RBNode` instance if the node with the given value exists in the tree. - `None` if a node with the given value does not exist. # Constraints - `value` will be a valid integer. - The tree may contain up to 10^6 nodes. - The value of the nodes in the tree falls within the integer range. # Example ```python tree = RBTree() nodes = [11, 2, 14, 1, 7, 15, 5, 8, 4] for value in nodes: tree.insert(RBNode(value, 1)) result = tree.search(7) assert result.val == 7 result = tree.search(10) assert result is None ``` # Notes - Focus on implementing an efficient binary search within the balanced Red-Black Tree. - Ensure correct handling of edge cases such as searching for the root node or a non-existent node. - You can assume that the provided `RBTree` and `RBNode` classes and their methods work correctly.","solution":"class RBNode: def __init__(self, val, color, left=None, right=None, parent=None): self.val = val self.color = color self.left = left self.right = right self.parent = parent class RBTree: def __init__(self): self.nil = RBNode(0, 0) # Our nil node, treated as black and used for leaves self.root = self.nil def insert(self, z): y = self.nil x = self.root while x != self.nil: y = x if z.val < x.val: x = x.left else: x = x.right z.parent = y if y == self.nil: self.root = z elif z.val < y.val: y.left = z else: y.right = z z.left = self.nil z.right = self.nil z.color = 1 # New node is always red self.insert_fixup(z) def insert_fixup(self, z): # Omitting fixup details for brevity pass def search(self, value): current = self.root while current != self.nil and current.val != value: if value < current.val: current = current.left else: current = current.right if current == self.nil: return None else: return current"},{"question":"You are tasked with designing a route planner for a transportation network. Given a list of stations and the cost to travel from one station to another, you must determine the minimum cost to travel from the first station to the final station. Problem Statement Implement a function named `min_cost` that calculates the minimum cost to travel from station 0 to station N-1. The costs between stations are provided in a matrix where the matrix value represents the travel cost from station `i` to station `j`. The matrix will be structured as follows: - `cost[i][j]` will contain the cost of traveling from station `i` to station `j` (where `i < j`). - Values where `i >= j` will be represented by -1 or `INF` (indicating no path). Function Signature ```python def min_cost(cost: List[List[float]]) -> float: pass ``` # Input - `cost`: A 2D list (matrix) of size `N x N` containing travel costs between stations. # Output - Return the minimum cost to travel from station 0 to station N-1. # Constraints - 2 <= N <= 1000 (number of stations). - 0 <= cost[i][j] <= 1000 (travel cost values between valid stations). - `cost[i][i]` = 0, `cost[i][j]` = `INF` for `i > j`. # Example ```python costs = [ [ 0, 15, 80, 90], # cost[i][j] is the cost of [-1, 0, 40, 50], # going from i --> j [-1, -1, 0, 70], [-1, -1, -1, 0] ] # cost[i][j] = -1 or `INF` for i >= j print(min_cost(costs)) # Output: 65 ``` # Instructions 1. Ensure your function adheres to the specified input and output formats. 2. Consider edge cases such as a single station or where multiple paths have the same minimal cost. 3. Pay special attention to performance given constraints up to N = 1000. 4. Document and comment on your code to explain the key steps and logic you use.","solution":"from typing import List def min_cost(cost: List[List[float]]) -> float: N = len(cost) # Initialize the min_costs array with infinity for all stations except the first one min_costs = [float(\'inf\')] * N min_costs[0] = 0 # Loop through each station and update the costs to reach subsequent stations for i in range(N): for j in range(i + 1, N): if cost[i][j] != -1 and cost[i][j] != float(\'inf\'): min_costs[j] = min(min_costs[j], min_costs[i] + cost[i][j]) return min_costs[N-1]"},{"question":"# Question: Advanced Palindrome Check with Restrictions Context: You are working on a text processing tool that deals with alphanumeric palindromes. In addition to the standard inputs, your tool must also handle cases where certain characters need to be excluded, and certain transformations need to be applied before checking for palindrome properties. Task: Write a function `is_advanced_palindrome(s: str, exclusions: set, transform: callable) -> bool` that checks if the given string `s` is a palindrome based on the following conditions: 1. Only alphanumeric characters should be considered. 2. Characters listed in `exclusions` should be ignored. 3. The function `transform` should be applied to each character of the string before comparison. Your solution should aim to maintain linear time complexity, O(n), where n is the length of the string. Function Specification: ```python def is_advanced_palindrome(s: str, exclusions: set, transform: callable) -> bool: :param s: str: Input string to be checked :param exclusions: set: Characters to be excluded :param transform: callable: Function to be applied on each character before comparison :return: bool: True if the string is an advanced palindrome, False otherwise ``` Input Format: - `s` : a string containing alphanumeric characters and possibly some special characters. - `exclusions` : a set of characters to be excluded from palindrome checking. - `transform` : a function that takes in a single character and returns a transformed character. Output Format: - A boolean value, `True` if the string `s` is an advanced palindrome, `False` otherwise. Constraints: - The length of `s` will not exceed 10^6. - The `exclusions` set will not contain more than 100 characters. - The `transform` function will always return a single character. Example: ```python def simple_transform(c): return c.lower() print(is_advanced_palindrome(\\"A man, a plan, a canal: Panama\\", set(), simple_transform)) # should return True print(is_advanced_palindrome(\\"race a car\\", set([\'e\']), simple_transform)) # should return True print(is_advanced_palindrome(\\"hello\\", set(), simple_transform)) # should return False ```","solution":"def is_advanced_palindrome(s: str, exclusions: set, transform: callable) -> bool: :param s: str: Input string to be checked :param exclusions: set: Characters to be excluded :param transform: callable: Function to be applied on each character before comparison :return: bool: True if the string is an advanced palindrome, False otherwise transformed_chars = [] for char in s: if char.isalnum() and char not in exclusions: transformed_chars.append(transform(char)) return transformed_chars == transformed_chars[::-1]"},{"question":"Scenario: You are tasked with creating a utility to help mathematicians with computing GCD, LCM, and analyzing binary representations. You need to write an efficient function to compute the **product of LCM and GCD** for two given positive integers using advanced bitwise operations combined with the conventional Euclid method. Task: Write a function `product_lcm_gcd(a: int, b: int) -> int` that returns the product of the least common multiple (LCM) and the greatest common divisor (GCD) for two given positive integers `a` and `b`. Function Signature: ```python def product_lcm_gcd(a: int, b: int) -> int: pass ``` Inputs: * Two positive integers `a` and `b` (1 <= a, b <= 10^9) Outputs: * A single integer, the product of LCM and GCD of `a` and `b`. Constraints: * You must handle large integers efficiently. * You need to use the `gcd` or `gcd_bit` function for GCD calculation. Example: # Example 1: Input: ```python a = 12 b = 18 ``` Output: ```python 216 ``` Explanation: GCD of 12 and 18 is 6, LCM is 36. Product is 6 * 36 = 216. # Example 2: Input: ```python a = 48 b = 180 ``` Output: ```python 8640 ``` Explanation: GCD of 48 and 180 is 12, LCM is 720. Product is 12 * 720 = 8640. Performance Requirements: Your solution should compute the result efficiently within allowable memory and time constraints for given input range. # Evaluation Criteria: * Correctness of the function implementation. * Efficiency in terms of time and space complexity. * Handling of edge cases as specified.","solution":"def gcd(a: int, b: int) -> int: while b: a, b = b, a % b return a def lcm(a: int, b: int, gcd_value: int) -> int: return a // gcd_value * b def product_lcm_gcd(a: int, b: int) -> int: gcd_value = gcd(a, b) lcm_value = lcm(a, b, gcd_value) return gcd_value * lcm_value"},{"question":"**Scenario**: You are a software engineer at a company managing large organizational trees. Your task is to implement a function to find the lowest common ancestor (LCA) of two employees in the hierarchy. The hierarchy is represented as a Binary Search Tree (BST) where each node contains an employee ID. # Task Implement a function `find_lowest_common_ancestor` that takes the root of the BST, and two employee IDs `p_id` and `q_id`. The function should return the node representing their lowest common ancestor. # Input and Output * **Input** - `root`: The root node of the binary search tree (BST). - `p_id`: An integer representing the first employee ID. - `q_id`: An integer representing the second employee ID. * **Output** - Return the node that represents the lowest common ancestor of `p_id` and `q_id`. # Constraints * Both `p_id` and `q_id` are unique and exist in the BST. * The BST nodes do not contain any duplicate employee IDs. * The tree is not necessarily balanced. # Function Signature ```python class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def find_lowest_common_ancestor(root, p_id, q_id): :param root: TreeNode :param p_id: int :param q_id: int :return: TreeNode ``` # Examples Example 1 ```python # Tree Structure # 6 # / # 2 8 # / / # 0 4 7 9 # / # 3 5 root = TreeNode(6) root.left = TreeNode(2) root.right = TreeNode(8) root.left.left = TreeNode(0) root.left.right = TreeNode(4) root.left.right.left = TreeNode(3) root.left.right.right = TreeNode(5) root.right.left = TreeNode(7) root.right.right = TreeNode(9) p_id = 2 q_id = 8 print(find_lowest_common_ancestor(root, p_id, q_id).val) # Output: 6 ``` Example 2 ```python # Tree Structure # 6 # / # 2 8 # / / # 0 4 7 9 # / # 3 5 root = TreeNode(6) root.left = TreeNode(2) root.right = TreeNode(8) root.left.left = TreeNode(0) root.left.right = TreeNode(4) root.left.right.left = TreeNode(3) root.left.right.right = TreeNode(5) root.right.left = TreeNode(7) root.right.right = TreeNode(9) p_id = 2 q_id = 4 print(find_lowest_common_ancestor(root, p_id, q_id).val) # Output: 2 ```","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def find_lowest_common_ancestor(root, p_id, q_id): Returns the lowest common ancestor of nodes with values p_id and q_id. current = root while current: # If both p_id and q_id are smaller than current\'s value, LCA is in the left subtree if p_id < current.val and q_id < current.val: current = current.left # If both p_id and q_id are greater than current\'s value, LCA is in the right subtree elif p_id > current.val and q_id > current.val: current = current.right else: # We have found the split point, i.e., the LCA node. return current"},{"question":"# Longest Common Substring with Unique Character Constraint **Context:** In the context of bioinformatics, you need to compare genetic sequences to find the longest segment where they match. Sometimes, one sequence contains entirely unique genetic identifiers, thus allowing certain optimizations. **Task:** Implement a function `longest_common_substring(s1: str, s2: str) -> str` that finds the longest common substring between two given strings `s1` and `s2`, where `s2` contains all distinct characters. Return the longest common substring. **Input**: - `s1`: a string of length `n` (1 ≤ n ≤ 10^5). - `s2`: a string of length `m` (1 ≤ m ≤ 10^5), containing all distinct characters. **Output**: - A string representing the longest common substring. If multiple longest substrings exist, return the first one found. **Constraints**: - The algorithm should run in O(n log n) time. - If no common substring exists, return an empty string. **Examples**: ```python assert longest_common_substring(\\"abcdef\\", \\"ghijkl\\") == \\"\\" assert longest_common_substring(\\"abcdef\\", \\"cde\\") == \\"cde\\" assert longest_common_substring(\\"aabcdeffgh\\", \\"ghijklmnop\\") == \\"gh\\" ``` **Notes**: - You may assume that the strings contain ASCII characters.","solution":"def longest_common_substring(s1, s2): Finds the longest common substring between two given strings s1 and s2. def is_common_substring(length): Helper function to check if there is a common substring with a given length. substrings = {s1[i:i+length] for i in range(len(s1) - length + 1)} for i in range(len(s2) - length + 1): if s2[i:i+length] in substrings: return s2[i:i+length] return None left, right = 0, min(len(s1), len(s2)) longest_substr = \\"\\" while left <= right: mid = (left + right) // 2 substring = is_common_substring(mid) if substring: longest_substr = substring left = mid + 1 else: right = mid - 1 return longest_substr"},{"question":"# Question: Efficient Pattern Matching with KMP Algorithm You are tasked with implementing a method that leverages the Knuth-Morris-Pratt (KMP) string matching algorithm to efficiently find and report the start indices of all occurrences of a given pattern within a text. Function Signature ```python def knuth_morris_pratt(text: Sequence[str], pattern: Sequence[str]) -> List[int]: ``` Input * `text` (Sequence[str]): The text in which you need to search the pattern. * `pattern` (Sequence[str]): The subsequence pattern you are searching for within the text. Output * List of integer indices indicating where the pattern starts in the text. Constraints * `text` and `pattern` will only contain lowercase alphabetical characters (`a-z`). * Length of `text` (`N`) will be in the range `[0, 10000]`. * Length of `pattern` (`M`) will be in the range `[0, 10000]`. Requirements * Your implementation must not exceed O(N + M) time complexity. * You should build and utilize the pi table as described in the KMP algorithm. Example ```python >>> knuth_morris_pratt(\'hello there hero\', \'hero\') [12] >>> knuth_morris_pratt(\'abracadabra\', \'abra\') [0, 7] >>> knuth_morris_pratt(\'aaaaa\', \'aa\') [0, 1, 2, 3] ``` Edge Cases to Consider * Empty `text` or `pattern` should return an empty list. * Ensure proper handling when `pattern` is longer than `text`. * Overlapping occurrences, e.g., `knuth_morris_pratt(\'aaaaa\', \'aa\')` should properly handle overlapping matches. Implement the `knuth_morris_pratt` function to efficiently resolve the pattern search problem using the KMP algorithm principles.","solution":"from typing import Sequence, List def knuth_morris_pratt(text: Sequence[str], pattern: Sequence[str]) -> List[int]: Implements the KMP algorithm to find all start indices of the substring \'pattern\' in \'text\'. def build_pi_table(pattern: str) -> List[int]: Constructs the prefix-suffix table for the KMP algorithm. m = len(pattern) pi = [0] * m k = 0 for q in range(1, m): while k > 0 and pattern[k] != pattern[q]: k = pi[k - 1] if pattern[k] == pattern[q]: k += 1 pi[q] = k return pi n = len(text) m = len(pattern) if m == 0 or n == 0 or m > n: return [] pi = build_pi_table(pattern) q = 0 # length of matched characters result = [] for i in range(n): while q > 0 and pattern[q] != text[i]: q = pi[q - 1] if pattern[q] == text[i]: q += 1 if q == m: result.append(i - m + 1) q = pi[q - 1] return result"},{"question":"# Matrix Multiplication Challenge Task: Write a function `generalized_multiply(matrices: List[List[List[int]]]) -> List[List[int]]` that takes a list of matrices (each matrix represented as a 2D list of integers) and returns the result of their chained multiplication. Requirements: 1. The function should multiply the matrices in the order they are provided. 2. It should handle incompatible matrix dimensions by raising an exception. 3. Optimize for performance where possible. Input: * A list of `n` matrices, where each matrix `[i]` is a List[List[int]]. * Each matrix will have at least 1 row and 1 column. * The number of matrices will be at least 2. Output: * A single matrix represented as a List[List[int]]. Constraints: * Vertices of the matrices are constrained to integers between -100 and 100. * Number of rows and columns for any matrix will not exceed 100. Example: ```python # Example 1 matrices = [ [[1, 2], [3, 4]], [[5, 6], [7, 8]] ] print(generalized_multiply(matrices)) # Output should be # [[19, 22], # [43, 50]] # Example 2 matrices = [ [[1, 0, 2], [0, 1, 1]], [[1, 2], [0, 1], [4, 0]] ] print(generalized_multiply(matrices)) # Output should be # [[9, 2], # [4, 1]] ``` Additional Considerations: * An empty list of matrices should result in an appropriate error or exception. * Consider edge cases such as a single element matrix.","solution":"from typing import List def matrix_multiply(A: List[List[int]], B: List[List[int]]) -> List[List[int]]: Multiplies two matrices A and B. # Check matrix dimensions if len(A[0]) != len(B): raise ValueError(\\"Incompatible matrix dimensions for multiplication\\") # Resultant matrix dimensions will be len(A) x len(B[0]) result = [[0] * len(B[0]) for _ in range(len(A))] # Matrix multiplication for i in range(len(A)): for j in range(len(B[0])): for k in range(len(B)): result[i][j] += A[i][k] * B[k][j] return result def generalized_multiply(matrices: List[List[List[int]]]) -> List[List[int]]: Multiplies a list of matrices in the given order. if not matrices or len(matrices) < 2: raise ValueError(\\"There must be at least two matrices to multiply\\") result = matrices[0] for matrix in matrices[1:]: result = matrix_multiply(result, matrix) return result"},{"question":"Maximum Sum Subarray Objective Implement a function that finds the maximum sum of a contiguous subarray in a given integer array. Description Given an integer array `array`, implement the function `max_subarray(array)` that computes the maximum sum of a contiguous subarray. Function Signature ```python def max_subarray(array): # Your code here ``` Input * An integer array `array` of size `n` where `1 <= n <= 10^4` and `-10^5 <= array[i] <= 10^5`. Output * An integer, which is the maximum sum of a contiguous subarray. Constraints * The input array will always contain at least one element. * Aim for an algorithm that runs in O(n) time complexity. Example **Input** ```python [1, 2, -3, 4, 5, -7, 23] ``` **Output** ```python 25 ``` Scenario Consider the array as a series of daily temperature changes. You need to find the period where the temperature rise was the maximum. Your task is to write a function that helps determine this.","solution":"def max_subarray(array): Returns the maximum sum of a contiguous subarray. max_current = max_global = array[0] for i in range(1, len(array)): max_current = max(array[i], max_current + array[i]) if max_current > max_global: max_global = max_current return max_global"},{"question":"You are required to implement a Fibonacci number generator with efficient computation for large values of `n`. Your primary objective is to handle both performance and memory usage effectively. # Requirements 1. Implement a function `optimized_fib(n: int) -> int` that computes the n-th Fibonacci number. 2. The function should compute the result in at most O(n) time and O(1) auxiliary space. 3. Handle edge cases such as n = 0 or n < 0 with appropriate error handling or assertions. 4. Ensure the function is efficient enough to handle values of `n` up to 10^6 without significant performance degradation. # Function Signature ```python def optimized_fib(n: int) -> int: pass ``` # Input - An integer `n` (0 <= n <= 10^6) # Output - An integer representing the n-th Fibonacci number. # Constraints - The function must run within O(n) time complexity. - The function must use O(1) auxiliary space. - Handle edge cases appropriately. # Examples ```python print(optimized_fib(10)) # Output: 55 print(optimized_fib(50)) # Output: 12586269025 print(optimized_fib(100)) # Output: 354224848179261915075 ``` # Notes - You are encouraged to use an iterative approach to meet the space complexity constraint. - Avoid recursion to prevent stack overflow issues for large values of `n`.","solution":"def optimized_fib(n: int) -> int: if n < 0: raise ValueError(\\"n must be a non-negative integer.\\") elif n == 0: return 0 elif n == 1: return 1 a, b = 0, 1 for _ in range(2, n + 1): a, b = b, a + b return b"},{"question":"# Question: Count the Number of \'1\' Bits Using Brian Kernighan\'s Algorithm Given an unsigned integer, write a function `count_ones(n)` that returns the number of \'1\' bits it has (also known as the Hamming weight). Implement the function using Brian Kernighan\'s Algorithm iteratively for optimal performance. Input: - A single unsigned integer n (0 <= n <= 2^32 - 1). Output: - The number of \'1\' bits in the binary representation of n. Constraints: 1. The input integer n should always be treated as a 32-bit unsigned integer. 2. You must use the iterative approach of Brian Kernighan\'s Algorithm. Example: - Input: 11 - Binary representation of 11 is `00000000000000000000000000001011` - Output: 3 - Input: 128 - Binary representation of 128 is `00000000000000000000000010000000` - Output: 1 Performance Requirements: - Your function should run in O(k) time complexity, where k is the number of \'1\' bits in the binary representation of n.","solution":"def count_ones(n): Returns the number of \'1\' bits in the binary representation of n using Brian Kernighan\'s Algorithm. count = 0 while n: n &= (n - 1) count += 1 return count"},{"question":"Problem Statement You have been provided with an unsorted array of integers and a target integer. Your task is to implement a function `linear_search` that searches for the target integer in the array and returns the index of the first occurrence of the target. If the target integer is not in the array, the function should return -1. # Function Signature ```python def linear_search(array: list[int], query: int) -> int: Find the index of the given element in the array. There are no restrictions on the order of the elements in the array. If the element couldn\'t be found, return -1. Parameters: array (list[int]): A list of integers where the search will be performed. query (int): The integer element to search for in the array. Returns: int: The index of the element in the array, or -1 if it is not found. ``` # Input and Output - **Input**: - `array`: A list of integers (1 <= len(array) <= 10^6). - `query`: An integer, the target element to find (-10^6 <= query <= 10^6). - **Output**: - An integer representing the index of the first occurrence of the target element in the array, or -1 if the element is not found. # Constraints - You are not allowed to sort the array. - Aim for a time complexity of O(n) and space complexity of O(1). # Examples ```python # Example 1: array = [4, 2, 3, 1, 5] query = 3 print(linear_search(array, query)) # Output: 2 # Example 2: array = [10, 20, 30, 40, 50] query = 25 print(linear_search(array, query)) # Output: -1 # Example 3: array = [] query = 1 print(linear_search(array, query)) # Output: -1 ``` # Explanation - In Example 1, the target integer `3` is found at index `2`. - In Example 2, the target integer `25` is not in the array, hence the function returns `-1`. - In Example 3, the array is empty, so the function returns `-1`. Performance Requirements Ensure the function handles arrays with up to 1,000,000 elements efficiently without excessive use of memory.","solution":"def linear_search(array: list[int], query: int) -> int: Find the index of the given element in the array. There are no restrictions on the order of the elements in the array. If the element couldn\'t be found, return -1. Parameters: array (list[int]): A list of integers where the search will be performed. query (int): The integer element to search for in the array. Returns: int: The index of the element in the array, or -1 if it is not found. for index, value in enumerate(array): if value == query: return index return -1"},{"question":"# Bitonic Sort Implementation with Edge Case Handling Problem Description: You are required to implement the bitonic sort algorithm to sort an array of integers in either increasing or decreasing order. Ensure that the input array size is always a power of two. If the size of the input array is not a power of two, raise an appropriate exception. Additionally, optimize the sorting algorithm for better performance in non-parallel environments. Function Signature: ```python def bitonic_sort(arr: List[int], reverse: bool = False) -> List[int]: pass ``` Input: * **arr**: A list of integers, where the length of the list is a power of two (e.g., 2, 4, 8, 16, ...). * **reverse**: A boolean indicating the desired order of sorting. - `True` for increasing order. - `False` for decreasing order. Output: * The function should return a sorted list of integers based on the `reverse` parameter. Constraints: * The length of the array must be a power of two. If not, raise a `ValueError` with the message \\"The size of input should be power of two\\". * Aim to optimize the implementation for better performance while maintaining correctness. Example: ```python bitonic_sort([3, 7, 4, 8, 6, 2, 1, 5], reverse=True) # Output should be [1, 2, 3, 4, 5, 6, 7, 8] bitonic_sort([3, 7, 4, 8, 6, 2, 1, 5], reverse=False) # Output should be [8, 7, 6, 5, 4, 3, 2, 1] bitonic_sort([1, 5, 3, 2]) # Output should be a ValueError with the message \\"The size of input should be power of two\\" ``` Notes: * Implement the core bitonic sort logic. * Ensure error handling and optimizations where needed. * Test your implementation with various input cases to ensure correctness and efficiency.","solution":"from typing import List def bitonic_compare(arr: List[int], i: int, j: int, direction: bool) -> None: if (direction and arr[i] > arr[j]) or (not direction and arr[i] < arr[j]): arr[i], arr[j] = arr[j], arr[i] def bitonic_merge(arr: List[int], low: int, cnt: int, direction: bool) -> None: if cnt > 1: k = cnt // 2 for i in range(low, low + k): bitonic_compare(arr, i, i + k, direction) bitonic_merge(arr, low, k, direction) bitonic_merge(arr, low + k, k, direction) def bitonic_sort_rec(arr: List[int], low: int, cnt: int, direction: bool) -> None: if cnt > 1: k = cnt // 2 bitonic_sort_rec(arr, low, k, True) # Sort in ascending order bitonic_sort_rec(arr, low + k, k, False) # Sort in descending order bitonic_merge(arr, low, cnt, direction) def bitonic_sort(arr: List[int], reverse: bool = False) -> List[int]: def is_power_of_two(n: int) -> bool: return n > 0 and (n & (n - 1)) == 0 if not is_power_of_two(len(arr)): raise ValueError(\\"The size of input should be power of two\\") bitonic_sort_rec(arr, 0, len(arr), reverse) return arr"},{"question":"# Problem Description: You are required to implement a Binary Search Tree (BST) Iterator in Python that performs an in-order traversal over the nodes of the BST. This iterator should allow fetching the next smallest element in the BST iteratively using only O(h) memory, where h is the height of the tree. # Requirements: Implement the following methods: 1. `__init__(self, root)`: The constructor which initializes the iterator with the root of the BST. 2. `has_next(self)`: Returns `True` if there are further nodes to be visited, `False` otherwise. 3. `next(self)`: Returns the next smallest element in the BST. # Input and Output: - `__init__(self, root)`: * Input: A reference to the root of a BST. * Output: None. - `has_next(self)`: * Input: None. * Output: A boolean, `True` if there are nodes left to visit, else `False`. - `next(self)`: * Input: None. * Output: An integer, the value of the next smallest element in the BST. # Constraints: - The number of nodes in the tree is between 0 and 100,000. - Node values are unique integers. # Scenario: Consider a scenario where you are given a previously constructed BST. You need to iterate over its elements in ascending order, extracting one node value at a time and potentially processing it (e.g., printing, storing for further use). Ensure that your iterator operates efficiently with respect to both time and space. # Example: Suppose the input tree is: ``` 7 / 3 15 / 9 20 ``` Your BSTIterator would be used as follows: ```python root = TreeNode(7, TreeNode(3), TreeNode(15, TreeNode(9), TreeNode(20))) iterator = BSTIterator(root) results = [] while iterator.has_next(): results.append(iterator.next()) assert results == [3, 7, 9, 15, 20] ``` Implement your solution in the following provided structure: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right class BSTIterator: def __init__(self, root: TreeNode): # Your code here def has_next(self) -> bool: # Your code here def next(self) -> int: # Your code here ```","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right class BSTIterator: def __init__(self, root: TreeNode): self.stack = [] self._leftmost_inorder(root) def _leftmost_inorder(self, root): while root: self.stack.append(root) root = root.left def has_next(self) -> bool: return len(self.stack) > 0 def next(self) -> int: topmost_node = self.stack.pop() if topmost_node.right: self._leftmost_inorder(topmost_node.right) return topmost_node.val"},{"question":"**Context**: You are given an array of integers where each integer represents a color code: 0 for red, 1 for white, and 2 for blue. Your task is to sort the array such that all objects of the same color are adjacent, and the colors are in the order red (0), white (1), and blue (2). You must sort this in-place without using any library sort functions. **Function Signature**: ```python def sort_colors(nums: List[int]) -> None: Sorts the given array with 0s, 1s, and 2s in-place in the order red (0), white (1), and blue (2). **Constraints**: * The array consists of only 0s, 1s, and 2s. * The solution should have a linear time complexity (O(n)) and a constant space complexity (O(1)). **Example**: ```python Input: nums = [2, 0, 2, 1, 1, 0] Output: [0, 0, 1, 1, 2, 2] ``` **Edge Cases to Consider**: 1. The array is empty. 2. The array contains only one type of color. 3. The array is already sorted. Write a function `sort_colors(nums)` to solve this problem ensuring all edge cases are handled appropriately.","solution":"from typing import List def sort_colors(nums: List[int]) -> None: Sorts the given array with 0s, 1s, and 2s in-place in the order red (0), white (1), and blue (2). red, white, blue = 0, 0, len(nums) - 1 while white <= blue: if nums[white] == 0: nums[red], nums[white] = nums[white], nums[red] red += 1 white += 1 elif nums[white] == 1: white += 1 else: nums[white], nums[blue] = nums[blue], nums[white] blue -= 1"},{"question":"# Cycle Sort Implementation and Edge Case Handling Cycle Sort is a unique in-place sorting algorithm that minimizes the number of writes to the array while sorting it. Given its specific behavior and challenges, implement the `cycle_sort` function from scratch and ensure it handles various edge cases correctly. Function Signature ```python def cycle_sort(arr: List[int]) -> List[int]: ``` # Input * `arr` (List[int]): An unsorted list of integers. # Output * (List[int]): The sorted list. # Constraints * Do not use any built-in sort functions. * Minimize the number of writes to the array. # Performance * Ensure the implementation maintains the expected average and worst-case time complexities of O(N^2). # Example Scenario 1. A typical scenario where the list is unsorted. ```python assert cycle_sort([4, 3, 2, 1]) == [1, 2, 3, 4] ``` 2. Handle a case with duplicate values. ```python assert cycle_sort([4, 3, 3, 1]) == [1, 3, 3, 4] ``` 3. Already sorted list should remain unchanged. ```python assert cycle_sort([1, 2, 3, 4]) == [1, 2, 3, 4] ``` # Additional Requirements * Consider an array with all identical elements. While no changes should be made, ensure the function effectively handles this scenario without unnecessary cycles. * Evaluate your solution for efficiency and correctness by creating various relevant tests. # Guidance * Be mindful of how you handle cycles and place elements, as mismanagement can lead to incorrect sorting. * Aim to achieve the sorting with the minimum number of element writes to conform to the core principle of Cycle Sort.","solution":"from typing import List def cycle_sort(arr: List[int]) -> List[int]: n = len(arr) # Traverse the array elements and put each element to its correct position for cycle_start in range(0, n - 1): item = arr[cycle_start] # Find where to put the item pos = cycle_start for i in range(cycle_start + 1, n): if arr[i] < item: pos += 1 # If the item is already in the correct position if pos == cycle_start: continue # Skip duplicate elements while item == arr[pos]: pos += 1 # Write the item to its correct position arr[pos], item = item, arr[pos] # Rotate the rest of the cycle while pos != cycle_start: pos = cycle_start for i in range(cycle_start + 1, n): if arr[i] < item: pos += 1 while item == arr[pos]: pos += 1 arr[pos], item = item, arr[pos] return arr"},{"question":"# Binary Tree Construction from Traversals You are given the preorder and postorder traversal arrays of a full binary tree (a binary tree where every node has either 0 or 2 children). Your task is to write a function `construct_tree(pre: List[int], post: List[int]) -> Optional[TreeNode]` that constructs this tree and returns the root node. Input * `pre`: List of integers representing the preorder traversal of the tree. * `post`: List of integers representing the postorder traversal of the tree. The tree is guaranteed to be full, meaning every node has either two or zero children. Output * A `TreeNode` object representing the root of the full binary tree. Construct the binary tree from these traversal arrays and return its root node. Implement the tree nodes as follows: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` Constraints * `1 <= len(pre), len(post) <= 1000` * The elements of `pre` and `post` are unique and consist of distinct integers. Example ```python pre = [1, 2, 4, 8, 9, 5, 3, 6, 7] post = [8, 9, 4, 5, 2, 6, 7, 3, 1] # Constructed tree should be: # 1 # / # 2 3 # / / # 4 5 6 7 # / #8 9 root = construct_tree(pre, post) # The tree\'s inorder traversal should be: # 8, 4, 9, 2, 5, 1, 6, 3, 7 ``` # Note Make sure to handle potential edge cases such as trees with a single node or invalid input arrays which do not represent a full binary tree. # Grading Criteria Your solution will be evaluated based on: 1. **Correctness**: The constructed tree matches the given traversals. 2. **Efficiency**: Implementation optimizes search operations where possible. 3. **Coding Style**: Code readability, proper variable naming, and adherence to Python conventions.","solution":"from typing import List, Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def construct_tree(pre: List[int], post: List[int]) -> Optional[TreeNode]: if not pre or not post: return None root = TreeNode(pre[0]) if len(pre) == 1: return root # Find the index of the left subtree root in postorder L = post.index(pre[1]) + 1 root.left = construct_tree(pre[1:L+1], post[:L]) root.right = construct_tree(pre[L+1:], post[L:-1]) return root"},{"question":"You are asked to implement a function that determines whether a directed graph contains a cycle. The graph is represented as an adjacency list. Each node in the graph represents a task, and an edge A -> B means that task A must be completed before task B starts. If there is a cycle in the graph, some tasks are interdependent and cannot be completed. Function Signature: ```python def is_cyclic_graph(graph: Dict[str, List[str]]) -> bool: pass ``` Input: * `graph (Dict[str, List[str]])`: A dictionary representing the directed graph. Output: * `bool`: Returns `True` if there is a cycle in the graph, `False` otherwise. Constraints: * The graph will not contain more than 1000 vertices. * Each vertex name (key in the dictionary) is a string. * Each adjacency list (value in the dictionary) is a list of strings. Example: ```python graph = { \'A\': [\'B\', \'C\'], \'B\': [\'D\'], \'C\': [\'F\'], \'D\': [\'E\', \'F\'], \'E\': [\'B\'], \'F\': [] } print(is_cyclic_graph(graph)) # Output: True graph2 = { \'A\': [\'B\'], \'B\': [\'C\'], \'C\': [] } print(is_cyclic_graph(graph2)) # Output: False ``` # Explanation: 1. In the first example, there is a cycle: A -> B -> D -> E -> B. 2. In the second example, there is no cycle. # Notes: 1. You are encouraged to think about the algorithms\' efficiency. 2. Make sure your solution handles various edge cases, such as a graph with no edges, self-loops, or disconnected components. 3. Avoid direct cycle-detection packages or library functions; focus on implementing your own logic.","solution":"from typing import List, Dict def is_cyclic_graph(graph: Dict[str, List[str]]) -> bool: Returns True if there is a cycle in the directed graph, False otherwise. visited = set() rec_stack = set() def dfs(node): if node in rec_stack: return True if node in visited: return False # Mark this node as visited and add to rec_stack visited.add(node) rec_stack.add(node) for neighbor in graph.get(node, []): if dfs(neighbor): return True # Remove from recursion stack before returning rec_stack.remove(node) return False for node in graph: if dfs(node): return True return False"},{"question":"You are tasked with improving a code review tool by implementing a function that verifies the correctness of bracket sequences in a given string. The brackets must close in the correct order, and every opening bracket must have a corresponding closing bracket of the same type. # Function Signature ```python def verify_brackets_sequence(s: str) -> bool: ``` # Input - `s` (string): A string containing only the following characters: `(`, `)`, `{`, `}`, `[`, and `]`. The string length `n` (where `0 <= n <= 10^4`). # Output - Returns `True` if the string has valid bracket sequence, `False` otherwise. # Constraints - The string contains only the characters `(){}[]`. - The function should run in O(n) time and O(n) space complexity. # Examples ```python verify_brackets_sequence(\\"()\\") -> True verify_brackets_sequence(\\"()[]{}\\") -> True verify_brackets_sequence(\\"(]\\") -> False verify_brackets_sequence(\\"([)]\\") -> False verify_brackets_sequence(\\"{[]}\\") -> True ``` # Explanation - The first example is valid because the brackets are correctly balanced. - The second example is also valid as each type of bracket is correctly paired. - The third example is invalid because `(` does not properly close before `]`. - The fourth example is invalid because while `[` starts before `)`, it closes incorrectly. - The fifth example is valid as each opening bracket has a corresponding closing bracket with correct nesting. # Implementation Notes 1. Utilize a stack to keep track of opening brackets encountered. 2. Use a dictionary to map each closing bracket to its corresponding opening bracket. 3. Check for matching brackets, ensuring the character sequences correctly nest.","solution":"def verify_brackets_sequence(s: str) -> bool: Verifies if the given string `s` has a valid bracket sequence. Args: s (str): A string containing only `(){}[]`. Returns: bool: True if the string has a valid bracket sequence, False otherwise. stack = [] bracket_map = {\')\': \'(\', \'}\': \'{\', \']\': \'[\'} for char in s: if char in bracket_map.values(): stack.append(char) elif char in bracket_map.keys(): if not stack or stack[-1] != bracket_map[char]: return False stack.pop() else: # Should never reach here since input is constrained to be (){}[] return False return not stack"},{"question":"# Question Scenario You are working on an e-commerce platform\'s data processing module, which needs to sort user ages efficiently to provide demographic analytics. Given that the users\' ages range roughly between 18 and 100 years and the number of users is around 1000, to maintain performance and resource usage, an efficient sorting algorithm is sought. Problem Statement Implement a sorting function using Pigeonhole Sort for an array of integers containing ages of the users. The ages are guaranteed to be between 18 and 100. Function Signature Function Name: `pigeonhole_sort_ages` Input: * A list of integers `ages` (18 ≤ ages[i] ≤ 100 for all `i`, 0 ≤ i < n where n is the size of the list, 0 ≤ n ≤ 1000). Output: * Return a list of sorted user ages. Constraints * Do not use any built-in sorting functions. * Minimize memory usage while maintaining efficient sorting performance. Example ```python assert pigeonhole_sort_ages([23, 32, 45, 19, 23, 45, 100, 18, 19]) == [18, 19, 19, 23, 23, 32, 45, 45, 100] assert pigeonhole_sort_ages([]) == [] assert pigeonhole_sort_ages([50]) == [50] ```","solution":"def pigeonhole_sort_ages(ages): Sorts a list of user ages using Pigeonhole Sort. Parameters: ages (list of integers): The ages to be sorted (18 ≤ age ≤ 100). Returns: list of integers: Sorted list of ages. if not ages: return [] # Define range for ages min_age = 18 max_age = 100 age_range = max_age - min_age + 1 # Create pigeonholes (buckets) for each possible age pigeonholes = [0] * age_range # Populate the pigeonholes for age in ages: pigeonholes[age - min_age] += 1 # Retrieve sorted ages from pigeonholes sorted_ages = [] for age in range(age_range): sorted_ages.extend([age + min_age] * pigeonholes[age]) return sorted_ages"},{"question":"# Bubble Sort Optimization Challenge Bubble Sort is a simple sorting algorithm that repeatedly steps through the list to be sorted, compares adjacent items, and swaps them if they are in the wrong order. The pass through the list is repeated until no swaps are needed, indicating that the list is sorted. # Objective Your task is to optimize the given Bubble Sort algorithm to improve its performance. Specifically, you must modify the algorithm to reduce unnecessary comparisons and perform early termination when the list is already sorted. # Specifications 1. Implement a function `optimized_bubble_sort(arr: List[int]) -> List[int]` that sorts the array `arr` in ascending order. 2. Aim to minimize the number of comparisons and swaps. # Input * A list of integers, `arr` with 1 <= len(arr) <= 10^3. # Output * The sorted list of integers in ascending order. # Example ```python assert optimized_bubble_sort([5, 1, 4, 2, 8]) == [1, 2, 4, 5, 8] assert optimized_bubble_sort([64, 34, 25, 12, 22, 11, 90]) == [11, 12, 22, 25, 34, 64, 90] assert optimized_bubble_sort([3, 0, 2, 5, -1, 4, 1]) == [-1, 0, 1, 2, 3, 4, 5] ``` # Constraints * You can assume that all integers in the input list can be handled by Python\'s built-in integer type. * Aim for the most efficient solution with the lowest number of passes and comparisons. # Scenario Imagine you are working on a rudimentary sorting utility for educational purposes. You\'ve implemented Bubble Sort, but you notice that it\'s inefficient. By implementing the `optimized_bubble_sort` function, your goal is to observe significant performance improvements, especially with already sorted lists or partially sorted lists. # Note * Do not confuse the function `optimized_bubble_sort` with any library-provided implementations. Write your function from scratch while leveraging an optimized approach.","solution":"def optimized_bubble_sort(arr): An optimized bubble sort that reduces the number of comparisons and performs early termination if the array is already sorted. Parameters: arr (list): List of integers to sort Returns: list: Sorted list of integers in ascending order n = len(arr) for i in range(n): swapped = False # Flag to detect any swap # Perform the bubble sort for the remaining unsorted part of the array for j in range(0, n - i - 1): if arr[j] > arr[j + 1]: arr[j], arr[j + 1] = arr[j + 1], arr[j] # Swap swapped = True # Set the flag since a swap happened # If no elements were swapped, the array is already sorted if not swapped: break return arr"},{"question":"# Radix Sort Implementation Implement the `radix_sort` function for sorting a list of non-negative integers. Your implementation should be able to handle a list of integers and sort them in non-decreasing order using the radix sort algorithm specified above. Function Signature ```python def radix_sort(arr: list[int], simulation: bool = False) -> list[int]: ``` # Input * `arr` (list of int): List of non-negative integers that need to be sorted. * `simulation` (bool): If set to `True`, the function should print the array\'s state at each iteration of digit-level sorting (default is `False`). # Output * A new list containing the sorted integers in non-decreasing order. # Constraints * The list can contain up to `10^6` integers. * Each integer in the list can be as large as `10^9`. # Performance Requirements * Time complexity should be as efficient as possible, ideally O(nk) where n is the number of elements in the list, and k is the number of digits in the largest number in the list. * The solution should be optimized to handle large inputs efficiently. # Example ```python >>> radix_sort([170, 45, 75, 90, 802, 24, 2, 66], False) [2, 24, 45, 66, 75, 90, 170, 802] >>> radix_sort([170, 45, 75, 90, 802, 24, 2, 66], True) iteration 0 : 170 45 75 90 802 24 2 66 iteration 1 : 170 90 802 2 24 45 75 66 iteration 2 : 2 24 45 66 75 90 170 802 [2, 24, 45, 66, 75, 90, 170, 802] ``` Ensure you test your implementation with a variety of test cases considering various edge cases including empty lists, lists with repetitive numbers, and very large lists.","solution":"def counting_sort(arr, exp, simulation, iter_num): n = len(arr) output = [0] * n count = [0] * 10 # Store count of occurrences in count[] for i in range(n): index = arr[i] // exp count[index % 10] += 1 # Change count[i] so that it contains the actual # position of this digit in output[] for i in range(1, 10): count[i] += count[i - 1] # Build the output array i = n - 1 while i >= 0: index = arr[i] // exp output[count[index % 10] - 1] = arr[i] count[index % 10] -= 1 i -= 1 # Copy the output array to arr[], so that arr now # contains sorted numbers according to the current digit for i in range(n): arr[i] = output[i] if simulation: print(f\\"iteration {iter_num} : {\' \'.join(map(str, arr))}\\") def radix_sort(arr, simulation=False): Perform radix sort on a list of non-negative integers. :param arr: List of non-negative integers that needs to be sorted. :param simulation: Bool, if True, the function prints the array\'s state at each iteration. :return: Sorted list of integers. if len(arr) == 0: return [] max1 = max(arr) exp = 1 iter_num = 0 while max1 // exp > 0: counting_sort(arr, exp, simulation, iter_num) exp *= 10 iter_num += 1 return arr"},{"question":"**Context**: In many real-world applications, such as managing hierarchical data like file systems or organizational structures, understanding the maximum depth of a given binary tree is essential. # Problem Given a binary tree, implement a function to find its maximum depth. # Detailed Requirements * **Function Signature**: `def max_height(root: TreeNode) -> int:` * **Inputs**: - `root` is the root of the binary tree. A TreeNode class is provided with the following structure: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` * **Outputs**: - Return an integer representing the maximum depth of the tree. # Example Example 1: ```python # Input Tree: # 3 # / # 9 20 # / # 15 7 tree = TreeNode(3) tree.left = TreeNode(9) tree.right = TreeNode(20, TreeNode(15), TreeNode(7)) assert max_height(tree) == 3 ``` Example 2: ```python # Input Tree: # 1 # # 2 tree = TreeNode(1) tree.right = TreeNode(2) assert max_height(tree) == 2 ``` # Constraints * Ensure your solution can handle large trees efficiently. * Consider both the recursive and iterative methods to solve the problem as part of the assessment. # Additional Notes * Make sure to handle edge cases such as an empty tree, where the root is `None`. * Comment on any design choices and optimizations made in your implementation.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def max_height(root: TreeNode) -> int: Returns the maximum depth of a given binary tree. if not root: return 0 else: left_depth = max_height(root.left) right_depth = max_height(root.right) return max(left_depth, right_depth) + 1"},{"question":"You are responsible for maintaining a database where each entry lists performance metrics over time. To better analyze trends, you need to determine the length of the Longest Increasing Subsequence (LIS) of time-based metric entries. # Task Implement the function `longest_increasing_subsequence(sequence)` that takes a list of integers and returns the length of the longest increasing subsequence. # Input * `sequence` (List[int]): A list of integers representing performance metrics over time. The length of the sequence is denoted by `n`. # Output * Returns an integer indicating the length of the longest increasing subsequence. # Constraints * `1 ≤ n ≤ 10^5` * `-10^9 ≤ sequence[i] ≤ 10^9` # Examples 1. Input: `[10, 9, 2, 5, 3, 7, 101, 18]` - Output: `4` - Explanation: The longest increasing subsequence is `[2, 3, 7, 101]`. 2. Input: `[0, 1, 0, 3, 2, 3]` - Output: `4` - Explanation: The longest increasing subsequence is `[0, 1, 2, 3]`. 3. Input: `[7, 7, 7, 7, 7, 7, 7]` - Output: `1` - Explanation: The longest increasing subsequence is `[7]` (one unique value). # Constraints and Performance * The solution must handle up to `10^5` integers. * Optimize for both time and space complexity. # Additional Information * Consider using dynamic programming with segment trees to improve time complexity. * Handle edge cases such as empty lists or lists with identical elements effectively. # Function Signature ```python def longest_increasing_subsequence(sequence: List[int]) -> int: # Your implementation here ```","solution":"from typing import List import bisect def longest_increasing_subsequence(sequence: List[int]) -> int: Find the length of the longest increasing subsequence. Parameters: sequence (List[int]): Time-based metric entries Returns: int: Length of the longest increasing subsequence if not sequence: return 0 # List to store the smallest tail element of all increasing subsequences of length i+1 lis = [] for num in sequence: pos = bisect.bisect_left(lis, num) if pos == len(lis): lis.append(num) else: lis[pos] = num return len(lis)"},{"question":"Given a stack implemented as a Python list, implement a function `optimized_switch_pairs` that switches successive pairs of numbers starting from the bottom of the stack using minimal additional space (constant space). For example, if the stack initially stores these values: ``` bottom [3, 8, 17, 9, 1, 10] top ``` Your function should switch the first pair (3, 8), the second pair (17, 9), and so on: ``` bottom [8, 3, 9, 17, 10, 1] top ``` For an odd number of values in the stack, the value at the top of the stack is not moved: ``` bottom [3, 8, 17, 9, 1] top ``` After switching pairs, output would be: ``` bottom [8, 3, 9, 17, 1] top ``` # Implement this function: ```python def optimized_switch_pairs(stack): pass # Your implementation ``` # Input: * `stack` (list): A list representing the stack, where the first element corresponds to the bottom of the stack, and the last element corresponds to the top of the stack. # Output: * The function should return a list representing the stack after pairs are switched. # Constraints: * Do not use additional data structures such as stacks or queues (constant space complexity allowed). * The input stack will contain integers only. * The stack can contain up to 10^5 elements. # Example: ```python stack = [3, 8, 17, 9, 1, 10] print(optimized_switch_pairs(stack)) # Output: [8, 3, 9, 17, 10, 1] stack = [3, 8, 17, 9, 1] print(optimized_switch_pairs(stack)) # Output: [8, 3, 9, 17, 1] ``` Notes: * Consider both optimal time and space requirements. * Write clean, readable, and efficient code.","solution":"def optimized_switch_pairs(stack): This function switches successive pairs of numbers in the given stack. The input stack is a list where the first element corresponds to the bottom of the stack, and the last element corresponds to the top of the stack. The function modifies the stack in place and returns it. n = len(stack) for i in range(0, n - 1, 2): stack[i], stack[i + 1] = stack[i + 1], stack[i] return stack"},{"question":"You are tasked with implementing an efficient sorting algorithm suitable for sorting a list where the number of elements and the range of their values are similar. The given list contains integer values that may include both positive and negative numbers. Your goal is to implement the Pigeonhole Sort algorithm and ensure it correctly handles a variety of test cases. # Function Signature ```python def pigeonhole_sort(arr: List[int]) -> List[int]: ``` # Input * `arr`: a list of integers, where the number of elements and the difference between the minimum and maximum values are approximately the same. # Output * Returns a new list of integers sorted in non-decreasing order. # Constraints * `1 <= len(arr) <= 10^5` * `-10^5 <= arr[i] <= 10^5` for all valid `i` # Examples 1. Input: `[8, 3, 2, 7, 4]` Output: `[2, 3, 4, 7, 8]` 2. Input: `[-5, -2, 0, 3, 1]` Output: `[-5, -2, 0, 1, 3]` 3. Input: `[10, 0, 5, -10, -5]` Output: `[-10, -5, 0, 5, 10]` # Notes 1. Pay attention to edge cases such as arrays with negative numbers, very small or very large arrays, and arrays where all elements are the same. 2. Ensure the algorithm is efficient with respect to both time and space based on the provided constraints. 3. You may assume the input list to always have at least one element.","solution":"def pigeonhole_sort(arr): Sorts the given list using the Pigeonhole Sort algorithm. :param arr: List[int] - The list of integers to sort. :return: List[int] - The sorted list of integers in non-decreasing order. if len(arr) <= 1: return arr # Find minimum and maximum values in arr min_val = min(arr) max_val = max(arr) # Calculate the range of elements size = max_val - min_val + 1 # Create holes initialized with zeroes holes = [0] * size # Populate the holes for number in arr: holes[number - min_val] += 1 # Reconstruct the sorted array from the holes sorted_arr = [] for index, count in enumerate(holes): sorted_arr.extend([min_val + index] * count) return sorted_arr"},{"question":"# Scenario You have been tasked with implementing a spell-checker and auto-completion system for an educational software. The system needs to support adding words to a dictionary and searching for words, including wildcard searches using \'.\' to represent any character. # Task Complete the implementation of the `WordDictionary` class to support the following functionalities: 1. **add_word(word: str)**: Adds the word to the dictionary. 2. **search(word: str) -> bool**: Returns `True` if the word (or a pattern with \'.\') is in the dictionary, `False` otherwise. Implement these methods: ```python class WordDictionary: def __init__(self): Initialize your data structure. pass def add_word(self, word: str): Adds a word into the data structure. pass def search(self, word: str) -> bool: Returns if the word is in the data structure. A word could contain the dot character \'.\' to represent any one letter. pass ``` # Input/Output Formats - **add_word(word: str)**: - **Input**: `word` as a non-empty string consisting of lowercase English letters. - **Output**: None. - **search(word: str) -> bool**: - **Input**: `word` as a non-empty string consisting of lowercase English letters and \'.\' character. - **Output**: `True` if the word/pattern is in the dictionary, `False` otherwise. # Constraints - `word.length <= 5000` - Number of add and search operations <= 10^4 Provide the implementation for the given class to efficiently support these operations.","solution":"class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False class WordDictionary: def __init__(self): Initialize your data structure. self.root = TrieNode() def add_word(self, word: str): Adds a word into the data structure. current_node = self.root for char in word: if char not in current_node.children: current_node.children[char] = TrieNode() current_node = current_node.children[char] current_node.is_end_of_word = True def search(self, word: str) -> bool: Returns if the word is in the data structure. A word could contain the dot character \'.\' to represent any one letter. return self._search_recursive(word, 0, self.root) def _search_recursive(self, word, index, current_node): if index == len(word): return current_node.is_end_of_word char = word[index] if char == \'.\': for child in current_node.children.values(): if self._search_recursive(word, index + 1, child): return True return False else: if char not in current_node.children: return False return self._search_recursive(word, index + 1, current_node.children[char])"},{"question":"Problem Statement You are tasked with writing a function that determines whether a given integer is a prime number. A prime number is an integer greater than 1 that has no positive divisors other than 1 and itself. **Function Signature**: `def is_prime(n: int) -> bool:` **Input**: - A single integer `n` (0 <= `|n|` <= 10^12). **Output**: - Return `True` if `n` is a prime number, otherwise return `False`. Constraints: 1. Solve the problem with time complexity better than O(n). 2. Implement any initial checks to optimize your approach, specifically targeting obvious non-prime conditions early on. Example Scenarios - Input: `n = 29` Output: `True` - Input: `n = 15` Output: `False` - Input: `n = 1` Output: `False` Explanation - `29` is a prime number since it is only divisible by `1` and `29`. - `15` is not a prime number because it has divisors other than `1` and itself (e.g., `3` and `5`). - `1` is not a prime number by definition as it does not meet the requirement of having exactly two distinct positive divisors. Ensure your solution efficiently handles the upper constraint of very large values of `n`.","solution":"def is_prime(n: int) -> bool: Determine whether a given integer is a prime number. **Parameters** n: int The integer to check (0 <= |n| <= 10^12). **Returns** bool True if n is a prime number, False otherwise. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True"},{"question":"# Context You are working on improving a sorting library used in a high-frequency trading application, where sorting speed is crucial due to the massive volume of data being processed in real-time. One of the core sorting algorithms in your library is Quick Sort, and you aim to optimize its performance by addressing common pitfalls. # Task Implement a version of Quick Sort with the following requirements: 1. Optimize the pivot selection process. 2. Convert the recursive implementation to an iterative one to avoid recursion overhead. 3. Include thorough handling of edge cases. # Function Signature ```python def optimized_quick_sort(arr: list) -> list: pass ``` # Input * `arr`: A list of integers. Length can be up to 10^6. # Output * A list of integers sorted in ascending order. # Constraints * The algorithm should run efficiently within the given constraints. * Consider edge cases like empty lists, single-element lists, lists with duplicates, already sorted lists, and reverse sorted lists. # Requirements: 1. Implement an efficient pivot selection method (e.g., median-of-three). 2. Ensure the implementation is iterative instead of recursive. 3. Performance considerations should aim for O(n log(n)) average time complexity and O(log(n)) space complexity.","solution":"def optimized_quick_sort(arr): def partition(low, high): # Median-of-three pivot selection mid = (low + high) // 2 pivot_candidates = [(arr[low], low), (arr[mid], mid), (arr[high], high)] pivot_candidates.sort() pivot_value, pivot_index = pivot_candidates[1] arr[pivot_index], arr[high] = arr[high], arr[pivot_index] pivot = arr[high] i = low - 1 for j in range(low, high): if arr[j] < pivot: i += 1 arr[i], arr[j] = arr[j], arr[i] arr[i + 1], arr[high] = arr[high], arr[i + 1] return i + 1 def quick_sort_iterative(low, high): # Stack for storing sublist ranges stack = [(low, high)] while stack: low, high = stack.pop() if low < high: pivot_index = partition(low, high) # Push left and right sublists into stack stack.append((low, pivot_index - 1)) stack.append((pivot_index + 1, high)) if len(arr) <= 1: return arr quick_sort_iterative(0, len(arr) - 1) return arr"},{"question":"Implement a function `find_min_swaps_to_sort(arr)` that calculates and returns the minimum number of swaps required to sort an array using the Cocktail Shaker Sort algorithm. The function must adhere to the principles of the Cocktail Shaker Sort. # Input - `arr`: A list of integers, where 1 ≤ len(arr) ≤ 1000 and -10^5 ≤ arr[i] ≤ 10^5 # Output - An integer representing the minimum number of swaps required to sort the array. # Constraints - The implemented solution must follow the Cocktail Shaker Sort principles. - Avoid using other sorting algorithms for the main sorting logic. # Example ```python def find_min_swaps_to_sort(arr): # Write your code here # Example Usage arr = [5, 3, 2, 8, 1, 4] print(find_min_swaps_to_sort(arr)) # Output: <Minimum number of swaps> arr = [1, 2, 3, 4, 5] print(find_min_swaps_to_sort(arr)) # Output: 0 ``` # Notes - The Cocktail Shaker Sort should be implemented within the function. - Ensure you handle edge cases appropriately, such as arrays of length 0 or 1. - Document any assumptions or additional helper functions if needed.","solution":"def find_min_swaps_to_sort(arr): Returns the minimum number of swaps required to sort the array using the Cocktail Shaker Sort algorithm. n = len(arr) swapped = True start = 0 end = n - 1 swap_count = 0 while swapped: swapped = False # Traverse the list from left to right for i in range(start, end): if arr[i] > arr[i + 1]: arr[i], arr[i + 1] = arr[i + 1], arr[i] swap_count += 1 swapped = True if not swapped: break swapped = False end -= 1 # Traverse the list from right to left for i in range(end - 1, start - 1, -1): if arr[i] > arr[i + 1]: arr[i], arr[i + 1] = arr[i + 1], arr[i] swap_count += 1 swapped = True start += 1 return swap_count"},{"question":"**Scenario**: You are tasked with implementing a function that encrypts and decrypts messages using the Atbash cipher. This simple substitution cipher maps each letter of the alphabet to its reverse counterpart (i.e., \'A\' is mapped to \'Z\', \'B\' to \'Y\', etc.). Non-alphabetic characters should remain unchanged. **Task**: Implement a function `atbash_cipher` that takes a string input and returns the Atbash cipher transformation. # Input - A single string `s` where (1 leq text{len}(s) leq 10^4). The string may contain uppercase and lowercase English letters, spaces, and punctuation. # Output - A string where each letter is replaced with its Atbash equivalent, and all other characters remain unchanged. # Example 1. Input: `\\"Attack at dawn\\"` Output: `\\"Zggzxp zg wzdm\\"` 2. Input: `\\"Hello, World!\\"` Output: `\\"Svool, Dliow!\\"` **Constraints**: - Your solution should have a time complexity of O(n), where n is the length of the input string. - The function should correctly handle mixed cases and non-alphabetic characters. # Notes: - The function `atbash_cipher` should be self-contained and should not rely on any external libraries or functions. ```python def atbash_cipher(s): # Implement the function body pass # You can implement your test cases to validate your solution. print(atbash_cipher(\\"Attack at dawn\\")) # Expected: Zggzxp zg wzdm print(atbash_cipher(\\"Hello, World!\\")) # Expected: Svool, Dliow! ```","solution":"def atbash_cipher(s): Encrypts or Decrypts the given string using the Atbash cipher. Parameters: s (str): The input string to be ciphered. Returns: str: The ciphered string using Atbash cipher. # Define the translation dictionaries for lowercase and uppercase letters lower = \'abcdefghijklmnopqrstuvwxyz\' upper = \'ABCDEFGHIJKLMNOPQRSTUVWXYZ\' atbash_lower = {lower[i]: lower[25 - i] for i in range(26)} atbash_upper = {upper[i]: upper[25 - i] for i in range(26)} result = [] for char in s: if char in atbash_lower: result.append(atbash_lower[char]) elif char in atbash_upper: result.append(atbash_upper[char]) else: result.append(char) return \'\'.join(result)"},{"question":"# ZigZag Iterator for Multiple Lists Context You are given multiple lists of integers. Your task is to implement a `ZigZagIterator`, which will iterate over all provided lists in a \\"zigzag\\" order, picking an element from each list in turn. Your Task Implement the `ZigZagIterator` class with the following methods: - `__init__(self, *args: List[int]) -> None`: Initializes the iterator with multiple lists. - `next(self) -> int`: Returns the next element in the zigzag iteration. - `has_next(self) -> bool`: Returns `True` if there are remaining elements, otherwise `False`. Input Format - Lists are non-empty and can have different lengths. - Methods are called in the following order: `__init__`, `has_next`, `next`. Output Format - `next` returns the next integer in the zigzag order. - `has_next` returns a boolean indicating if there are more elements to iterate. # Constraints - The iterator must be able to handle up to 10^6 total elements across all lists. - All integer elements are within the range of -10^9 to 10^9. # Example ```python v1 = [1, 2] v2 = [3, 4, 5, 6] v3 = [7, 8, 9] it = ZigZagIterator(v1, v2, v3) results = [] while it.has_next(): results.append(it.next()) print(results) # Output: [1, 3, 7, 2, 4, 8, 5, 9, 6] ```","solution":"from collections import deque class ZigZagIterator: def __init__(self, *args): self.queue = deque() for lst in args: if lst: self.queue.append((iter(lst), len(lst))) def next(self): if self.has_next(): iter_lst, remaining = self.queue.popleft() next_value = next(iter_lst) if remaining > 1: self.queue.append((iter_lst, remaining - 1)) return next_value raise StopIteration def has_next(self): return len(self.queue) > 0"},{"question":"# FizzBuzz Variations Problem Statement You are required to implement a function to solve a variation of the FizzBuzz problem. In this variation, you will receive a list of numbers, and for each number, you should return: * \\"Fizz\\" if the number is divisible by 3. * \\"Buzz\\" if the number is divisible by 5. * \\"FizzBuzz\\" if the number is divisible by both 3 and 5. * The number itself if it is not divisible by either 3 or 5. # Function Signature ```python def custom_fizzbuzz(nums: List[int]) -> List[Union[int, str]]: pass ``` # Input * `nums`: List of integers, the list can be empty, but each integer is guaranteed to be positive. # Output * A list of the same length as the input list, with numbers replaced according to the rules outlined above. # Example ```python Input: custom_fizzbuzz([1, 2, 3, 4, 5, 15, 20, 21]) Output: [1, 2, \\"Fizz\\", 4, \\"Buzz\\", \\"FizzBuzz\\", \\"Buzz\\", \\"Fizz\\"] ``` # Constraints * None of the elements in the input list will be less than 1. * The input list can be large; aim to achieve optimal time and space complexity. # Performance Requirements Your solution should be efficient with a linear time complexity, i.e., O(n), where n is the length of the input list.","solution":"from typing import List, Union def custom_fizzbuzz(nums: List[int]) -> List[Union[int, str]]: result = [] for num in nums: if num % 3 == 0 and num % 5 == 0: result.append(\\"FizzBuzz\\") elif num % 3 == 0: result.append(\\"Fizz\\") elif num % 5 == 0: result.append(\\"Buzz\\") else: result.append(num) return result"},{"question":"# Randomized Set Implementation: Design and implement a class `EnhancedRandomizedSet` that supports the following operations in average O(1) time: 1. **insert(val: int) -> bool**: Inserts an item val to the data structure if not already present. Returns `True` if the item was inserted, otherwise `False`. 2. **remove(val: int) -> bool**: Removes an item val from the data structure if present. Returns `True` if the item was removed, otherwise `False`. 3. **getRandom() -> int**: Returns a random element from the current set of elements. Each element must have the same probability of being returned. 4. **getAll() -> List[int]**: Returns a list of all current elements in the data structure in any order. Constraints - All operations should be implemented in such a way that they average O(1) time complexity. - The set will contain at most 10^5 elements. - You can assume the values are within the range [-10^9, 10^9]. Example Usage ```python rs = EnhancedRandomizedSet() assert rs.insert(1) == True assert rs.insert(1) == False assert rs.insert(2) == True assert rs.insert(3) == True assert rs.remove(1) == True assert rs.remove(1) == False assert rs.getRandom() in [2, 3] assert rs.getRandom() in [2, 3] assert set(rs.getAll()) == {2, 3} assert rs.insert(4) == True assert set(rs.getAll()) == {2, 3, 4} ``` In your implementation, you should cover appropriate edge cases and ensure that the operations meet the specified time complexity.","solution":"import random class EnhancedRandomizedSet: def __init__(self): self.data_list = [] self.data_map = {} def insert(self, val: int) -> bool: if val in self.data_map: return False self.data_map[val] = len(self.data_list) self.data_list.append(val) return True def remove(self, val: int) -> bool: if val not in self.data_map: return False last_elem = self.data_list[-1] idx_to_remove = self.data_map[val] self.data_list[idx_to_remove] = last_elem self.data_map[last_elem] = idx_to_remove self.data_list.pop() del self.data_map[val] return True def getRandom(self) -> int: return random.choice(self.data_list) def getAll(self) -> list: return self.data_list[:]"},{"question":"# Scenario You are given an unordered array of integers which may be small, already partially sorted, or reverse sorted. Your task is to implement a function `custom_insertion_sort` that performs the insertion sort algorithm on this array. The function should also simulate and print the array at each step of the sorting process. # Requirements 1. Implement the `custom_insertion_sort` function to sort an array of integers. 2. The function should print the state of the array during each sorting iteration. 3. Handle edge cases such as empty arrays and arrays with one element. 4. Optimize the function to handle subarray lengths of up to 10,000 elements efficiently. # Function Signature ```python def custom_insertion_sort(arr: List[int], simulation: bool = False) -> List[int]: # Your code here ``` # Input and Output Formats - **Input**: * `arr`: A list of integers (`List[int]`), unsorted. * `simulation`: A boolean flag (`bool`) indicating whether to print intermediate steps (`True`) or not (`False`). - **Output**: * A list of integers (`List[int]`), sorted in non-decreasing order. * Print the state of the array in each iteration if `simulation` is `True`. # Example ```python # Example 1 arr = [4, 3, 2, 1] custom_insertion_sort(arr, simulation=True) # Expected print output: # iteration 0 : 4 3 2 1 # iteration 1 : 3 4 2 1 # iteration 2 : 2 3 4 1 # iteration 3 : 1 2 3 4 # Example 2 arr = [1, 2, 3, 4] custom_insertion_sort(arr, simulation=True) # Expected print output: # iteration 0 : 1 2 3 4 # iteration 1 : 1 2 3 4 # iteration 2 : 1 2 3 4 # iteration 3 : 1 2 3 4 ``` # Constraints 1. The length of the input list will not exceed 10,000 elements. 2. The integer values will be within the range [-10^6, 10^6].","solution":"from typing import List def custom_insertion_sort(arr: List[int], simulation: bool = False) -> List[int]: Perform insertion sort on the array, print the array at each step if simulation is True. :param arr: List[int] - List of integers to be sorted. :param simulation: bool - Flag to indicate whether to print the array at each step. :return: List[int] - Sorted list of integers. n = len(arr) for i in range(1, n): key = arr[i] j = i - 1 while j >= 0 and key < arr[j]: arr[j + 1] = arr[j] j -= 1 arr[j + 1] = key if simulation: print(f\'iteration {i} : {\\" \\".join(map(str, arr))}\') return arr"},{"question":"# Context You have implemented a basic version of an algorithm to filter values in an array based on given limits. Now, your task is to refine and enhance this algorithm to handle additional complexities and optimize its performance. # Task Write a Python function `optimized_limit(arr, min_lim=None, max_lim=None)` that filters an array `arr` to include only those elements that fall between `min_lim` and `max_lim`. If `min_lim` or `max_lim` is not provided (i.e., `None`), the function should appropriately handle this scenario. # Requirements: * The input array `arr` is a list of integers. * The parameters `min_lim` and `max_lim` are integers or `None`. * The function should handle edge cases such as empty arrays gracefully. * The function should return a new list of integers that are within the given range. * The function needs to maintain the order of elements as in the original array. # Constraints: * The length of the input array `arr` will be at most `10^6`. * Each integer in `arr` will be between `-10^9` and `10^9`. # Expected Input/Output: * **Input**: * `arr`: A list of integers. * `min_lim`: Minimum limit as an integer or `None`. * `max_lim`: Maximum limit as an integer or `None`. * **Output**: * A list of integers filtered based on the given limits. # Example: ```python # Example 1 arr = [1, 2, 3, 4, 5] min_lim = None max_lim = 3 print(optimized_limit(arr, min_lim, max_lim)) # Output: [1, 2, 3] # Example 2 arr = [10, 15, 20, 25, 30] min_lim = 15 max_lim = 25 print(optimized_limit(arr, min_lim, max_lim)) # Output: [15, 20, 25] # Example 3 arr = [1, 3, 5, 7, 9] min_lim = 4 max_lim = None print(optimized_limit(arr, min_lim, max_lim)) # Output: [5, 7, 9] # Example 4 arr = [] min_lim = 5 max_lim = 10 print(optimized_limit(arr, min_lim, max_lim)) # Output: [] ``` # Performance Requirements: The implementation should have a time complexity of O(n) and a space complexity of O(n).","solution":"def optimized_limit(arr, min_lim=None, max_lim=None): Filters an array to include only those elements that fall between min_lim and max_lim. Parameters: arr (list): A list of integers. min_lim (int or None): Minimum limit as an integer or None. max_lim (int or None): Maximum limit as an integer or None. Returns: list: A new list of integers that are within the given range. if min_lim is None and max_lim is None: return arr[:] # Return a copy of the original list elif min_lim is None: return [x for x in arr if x <= max_lim] elif max_lim is None: return [x for x in arr if x >= min_lim] else: return [x for x in arr if min_lim <= x <= max_lim]"},{"question":"# Binary Tree to Doubly Linked List Converter You are tasked with transforming a binary tree into a sorted doubly linked list (DLL) in place. Given the root node of a binary tree, convert it into a sorted doubly linked list where the nodes\' left pointers act as previous pointers and right pointers act as next pointers. # Function Signature ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def bin_tree_to_list(root: TreeNode) -> TreeNode: Given the root of a binary tree, convert it into a sorted doubly linked list in-place and return the head node of the list. Args: root (TreeNode): The root node of the binary tree. Returns: TreeNode: The head node of the resulting doubly linked list. pass ``` # Input - You are provided with the root node of a binary tree, `root`. # Output - Return the head node of the converted doubly linked list. # Constraints - You may assume that the tree can have up to `10^4` nodes. - The tree can be unbalanced. - Values of the nodes in the binary tree are distinct integers within the range `[-10^4, 10^4]`. # Example **Example 1:** ``` Input: [4, 2, 5, 1, 3] Explanation: The binary tree [4, 2, 5, 1, 3] will be converted into the doubly linked list [1 <-> 2 <-> 3 <-> 4 <-> 5]. ``` **Example 2:** ``` Input: [1, None, 2, None, 3] Explanation: The binary tree [1, None, 2, None, 3] will be converted into the doubly linked list [1 <-> 2 <-> 3]. ``` # Guidelines - Ensure your code handles edge cases such as an empty tree or skewed trees correctly. - The function should modify the tree in-place and not use additional structures for holding nodes. - Optimize to ensure minimal computational overhead in traversal and pointer adjustments.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def bin_tree_to_list(root: TreeNode) -> TreeNode: Given the root of a binary tree, convert it into a sorted doubly linked list in-place and return the head node of the list. Args: root (TreeNode): The root node of the binary tree. Returns: TreeNode: The head node of the descending doubly linked list. if not root: return None # Helper function to recursively convert to doubly linked list def tree_to_doubly_list(node): nonlocal last, head if not node: return tree_to_doubly_list(node.left) # Connect previous node (last) with the current node (node) if last: last.right = node node.left = last else: # This condition is met when processing the leftmost node head = node last = node tree_to_doubly_list(node.right) head, last = None, None tree_to_doubly_list(root) return head"},{"question":"Intersection of Two Singly Linked Lists Problem Description You are given the heads of two singly linked-lists `h1` and `h2`. Write a function `find_intersection(h1, h2)` that finds the node at which the two lists intersect. If the two linked lists have no intersection at all, return `None`. In the provided example, consider the following linked lists: ``` 1 -> 3 -> 5 7 -> 9 -> 11 / 2 -> 4 -> 6 ``` The function should return the node with value 7, as it is the point of intersection. Function Signature ```python class Node: def __init__(self, val=None): self.val = val self.next = None def find_intersection(h1: Node, h2: Node) -> Node: pass ``` Input * Two linked list heads, `h1` and `h2`. Output * The first common node of the two lists if they intersect, otherwise `None`. Constraints * The linked lists are non-cyclic. * Both lists can be extremely large. * Memory usage should be minimized. Example ```python # Helper code to create the linked lists and nodes a1 = Node(1) b1 = Node(3) c1 = Node(5) d = Node(7) a2 = Node(2) b2 = Node(4) c2 = Node(6) e = Node(9) f = Node(11) a1.next = b1 b1.next = c1 c1.next = d a2.next = b2 b2.next = c2 c2.next = d d.next = e e.next = f assert find_intersection(a1, a2).val == 7 ``` Notes * Be mindful of edge cases such as no intersection, intersection at head nodes, and different lengths of the linked lists. * Aim for optimal time and space complexity.","solution":"class Node: def __init__(self, val=None): self.val = val self.next = None def find_intersection(h1: Node, h2: Node) -> Node: def get_length(head): length = 0 while head: length += 1 head = head.next return length len1 = get_length(h1) len2 = get_length(h2) # Align the start of both lists by skipping the extra nodes in the longer list while len1 > len2: h1 = h1.next len1 -= 1 while len2 > len1: h2 = h2.next len2 -= 1 # Traverse both lists together to find the intersection point while h1 and h2: if h1 == h2: return h1 h1 = h1.next h2 = h2.next return None"},{"question":"# Polynomial Arithmetic: Simplification and Evaluation Context You are tasked with extending the functionality of the provided `Polynomial` and `Monomial` classes. Specifically, you need to focus on implementing an efficient polynomial simplification method and an evaluation function that allows for the substitution of variables within the polynomials. Task 1. Implement a method `simplify` for the `Polynomial` class. This method should merge like terms in the polynomial, resulting in a simplified form. 2. Implement a method `evaluate` in the `Polynomial` class that allows for the substitution of variables with given values and returns the polynomial evaluation result. Function Definitions ```python class Polynomial: def simplify(self) -> Polynomial: Simplify the polynomial by merging like terms. Returns: Polynomial: A new simplified polynomial. pass def evaluate(self, substitutions: Dict[int, Union[int, float, Fraction]]) -> Union[int, float, Fraction]: Evaluate the polynomial by substituting given values for the variables. Args: substitutions (Dict[int, Union[int, float, Fraction]]): Dictionary mapping variable indices to their values. Returns: Union[int, float, Fraction]: The resulting value of the polynomial after substitution. pass ``` Inputs/Outputs 1. **simplify**: - Input: `Polynomial` object with potentially non-simplified terms. - Output: New `Polynomial` object with merged like terms. 2. **evaluate**: - Input: - `Polynomial` object. - `substitutions`: Dictionary where keys are variable indices and values are their respective substitutions. - Output: Single numerical value (integer, float, or fraction) representing the result of the substitution and evaluation. Constraints - Ensure the `simplify` method performs in reasonable time even for polynomials with several hundred terms. - The `evaluate` method should be able to handle a mix of integer, float, and rational values for coefficients and substitutions. Example ```python # Creating polynomials poly_1 = Polynomial([Monomial({1: 2}, 3), Monomial({1: 2}, 4), Monomial({2: 1}, 5)]) poly_2 = poly_1.simplify() print(poly_2) # Output should be Polynomial([Monomial({1: 2}, 7), Monomial({2: 1}, 5)]) result = poly_2.evaluate({1: 2, 2: 3}) print(result) # Output should be a numerical value after substituting variables ``` Notes - Ensure the `simplify` method merges monomials with the same variables but combines their coefficients correctly. - For the `evaluate` method, make sure all variables in the polynomial are assigned a value, otherwise raise a `ValueError`.","solution":"from fractions import Fraction from typing import Dict, Union, List class Monomial: def __init__(self, variables: Dict[int, int], coefficient: Union[int, float, Fraction]): self.variables = variables # Dictionary mapping variable index to its exponent self.coefficient = coefficient def __eq__(self, other): if not isinstance(other, Monomial): return False return self.variables == other.variables and self.coefficient == other.coefficient def __hash__(self): return hash((frozenset(self.variables.items()), self.coefficient)) def __add__(self, other): if self.variables == other.variables: return Monomial(self.variables, self.coefficient + other.coefficient) raise ValueError(\\"Can\'t add monomials with different variables\\") def evaluate(self, substitutions: Dict[int, Union[int, float, Fraction]]) -> Union[int, float, Fraction]: product = self.coefficient for var, exp in self.variables.items(): if var in substitutions: product *= substitutions[var] ** exp else: raise ValueError(f\\"Variable x{var} not provided in substitutions\\") return product class Polynomial: def __init__(self, monomials: List[Monomial]): self.monomials = monomials def simplify(self) -> \'Polynomial\': combined = {} for monomial in self.monomials: vars_tuple = frozenset(monomial.variables.items()) if vars_tuple in combined: combined[vars_tuple] = combined[vars_tuple] + monomial else: combined[vars_tuple] = monomial simplified_monomials = list(combined.values()) return Polynomial(simplified_monomials) def evaluate(self, substitutions: Dict[int, Union[int, float, Fraction]]) -> Union[int, float, Fraction]: total = 0 for monomial in self.monomials: total += monomial.evaluate(substitutions) return total"},{"question":"# Question Scenario You are the lead developer for a search engine algorithm team. Your task is to optimize the indexing of pages which is managed through a binary search tree (BST). To efficiently handle page deletions and replacements, you need to implement a function that finds the inorder predecessor of a given node in the BST. Task Implement the function `predecessor(root, node)` that takes in the root of a BST and a target node, and returns the inorder predecessor of the target node within the BST. If the target node has no predecessor, return `None`. Function Signature ```python def predecessor(root: TreeNode, node: TreeNode) -> Optional[TreeNode]: ``` Input - `root` (TreeNode): The root node of the BST. - `node` (TreeNode): The target node whose predecessor needs to be found. Output - Returns the inorder predecessor (TreeNode) of the target node. If no predecessor exists, return `None`. Constraints - Values of nodes are unique. - Your solution should have O(h) time complexity, where h is the height of the tree, and O(1) space complexity. Example ```python # Given BST: # 20 # / # 10 30 # / # 25 35 root = TreeNode(20) root.left = TreeNode(10) root.right = TreeNode(30) root.right.left = TreeNode(25) root.right.right = TreeNode(35) target_node = root.right # Node with value 30 predecessor_node = predecessor(root, target_node) print(predecessor_node.val) # Should output 25 ``` Edge Cases - If the node with the smallest value in the BST is given, the function should return `None`. - If the BST is empty (`root` is `None`).","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def predecessor(root: TreeNode, node: TreeNode) -> TreeNode: if not root: return None if node.left: curr = node.left while curr.right: curr = curr.right return curr pred = None curr = root while curr: if node.value > curr.value: pred = curr curr = curr.right elif node.value < curr.value: curr = curr.left else: break return pred"},{"question":"# Anagram Grouping Challenge Problem Description You are given an array of strings. Your task is to group the strings that are anagrams of each other together in list format. Each group should contain at least one string and all strings in each group should be present in the original array. Input * A list of strings `arr` where each string `str` has up to 100 lowercase English letters. * The length of the list does not exceed 10^4. Output * A list of lists `result` where each list contains strings that are anagrams of each other. Constraints * Each string consists of lowercase letters only. * The input list can be empty, in which case the output should also be an empty list. Example ```python Input: [\\"eat\\", \\"tea\\", \\"tan\\", \\"ate\\", \\"nat\\", \\"bat\\"] Output: [ [\\"eat\\", \\"tea\\", \\"ate\\"], [\\"tan\\", \\"nat\\"], [\\"bat\\"] ] ``` Performance Requirement * The solution should be efficient in terms of time and space complexity, ideally making sure to handle the sorting and hash map efficiently. Task Implement the function: ```python def group_anagrams(arr): # your code here ``` Remember to include edge cases, performance considerations, and provide a robust solution for varying input string lengths and counts.","solution":"from collections import defaultdict def group_anagrams(arr): Groups anagrams from the input list of strings. # Dictionary to hold groups of anagrams anagram_dict = defaultdict(list) for word in arr: # Sort the word and use it as a key sorted_word = \'\'.join(sorted(word)) anagram_dict[sorted_word].append(word) # Return the list of groups return list(anagram_dict.values())"},{"question":"Problem Statement You are given a list of strings representing geographic coordinates. Write a function `validate_coordinates(coords_list)` that takes in this list and returns a list of boolean values indicating whether each coordinate string is valid according to the following rules: 1. Latitude and longitude must be separated by a comma and a space. 2. Latitude can be a float between -90 and 90. 3. Longitude can be a float between -180 and 180. 4. The string should contain no characters other than digits, comma, period, minus sign, and space. # Function Signature ```python def validate_coordinates(coords_list: List[str]) -> List[bool]: ``` # Input - `coords_list`: A list of strings, each representing a coordinate. # Output - A list of boolean values where each element is `True` if the corresponding coordinate string is valid, and `False` otherwise. # Constraints - The length of `coords_list` will be between 1 and 1000. - Each string in `coords_list` will have a maximum length of 100 characters. # Examples ```python # Example 1 input = [\\"23.32353342, -32.543534534\\", \\"43.91343345, 143\\"] output = [True, True] # Example 2 input = [\\"23.234, - 23.4234\\", \\"N23.43345, E32.6457\\"] output = [False, False] ``` # Notes - A valid coordinate must strictly follow the format without any extra or missing characters or spaces. - The function should handle edge cases such as missing components, invalid characters, and out-of-range values. Craft a function implementation that efficiently validates each coordinate string in the `coords_list` and meets all outlined requirements.","solution":"import re from typing import List def validate_coordinates(coords_list: List[str]) -> List[bool]: def is_valid_coordinate(coord: str) -> bool: pattern = re.compile(r\'^(-?d+(.d+)?), (-?d+(.d+)?)\') match = pattern.match(coord) if not match: return False lat, lon = float(match.group(1)), float(match.group(3)) return -90 <= lat <= 90 and -180 <= lon <= 180 return [is_valid_coordinate(coord) for coord in coords_list]"},{"question":"# Coding Assessment: Find the Lowest Common Ancestor in a Binary Search Tree **Objective**: Given a binary search tree (BST) and two nodes `p` and `q`, write a function to find their lowest common ancestor (LCA). **Function Signature**: ```python def lowest_common_ancestor(root, p, q): :type root: Node :type p: Node :type q: Node :rtype: Node ``` **Input**: - `root`: The root node of the binary search tree. - `p`: The first node. - `q`: The second node. **Output**: - Returns the lowest common ancestor node of `p` and `q`. **Constraints**: - All `Node` values are unique. - Nodes `p` and `q` will exist in the tree. **Performance Requirements**: - Aim for O(h) time complexity and O(1) space complexity where h is the height of the tree. **Scenario**: Imagine you are working for a genealogical research institute, and you need to find common ancestors in family trees represented as BSTs. Your task is to implement the `lowest_common_ancestor` function efficiently. **Example**: For the BST shown below: ``` _______6______ / ___2__ ___8__ / / 0 4 7 9 / 3 5 ``` - Finding LCA of nodes 2 and 8 returns node 6. - Finding LCA of nodes 2 and 4 returns node 2. **Hint**: Make use of the BST properties to navigate down the tree efficiently and determine the LCA.","solution":"class Node: def __init__(self, key): self.left = None self.right = None self.val = key def lowest_common_ancestor(root, p, q): Find the lowest common ancestor of nodes p and q in a BST. :type root: Node :type p: Node :type q: Node :rtype: Node # Start from the root of the tree current = root # Traverse the tree while current: # If both p and q are greater than current, LCA lies in the right if p.val > current.val and q.val > current.val: current = current.right # If both p and q are smaller than current, LCA lies in the left elif p.val < current.val and q.val < current.val: current = current.left else: # We have found the split point, i.e., the LCA node. return current"},{"question":"# Jump Search Algorithm | Advanced Coding Assessment Given a sorted array of integers and a target value, implement the Jump Search algorithm to find the index of the target value in the array. If the target value is not present in the array, the function should return `-1`. Function Signature ```python def jump_search(arr, target): ``` Input * `arr`: A sorted list of integers (0 <= len(arr) <= 10^6). * `target`: An integer value to search for in the array. Output * Returns the index of the `target` value if found in the array; otherwise returns `-1`. Constraints 1. The array can have up to 10^6 elements. 2. Elements in the array are distinct. 3. The array is sorted in ascending order. # Example ```python # Example 1 arr = [0, 1, 3, 5, 20, 25, 30, 35] target = 25 assert jump_search(arr, target) == 5 # Example 2 arr = [0, 1, 3, 5, 20, 25, 30, 35] target = 40 assert jump_search(arr, target) == -1 # Example 3 arr = [] target = 1 assert jump_search(arr, target) == -1 ``` # Performance Requirements * The implementation should efficiently handle large arrays up to the specified limit (`10^6` elements). Write a well-documented function that adheres to the given constraints and performs optimally for the expected input sizes.","solution":"import math def jump_search(arr, target): Perform Jump Search on a sorted array to find the index of the target. :param arr: List of sorted integers. :param target: Integer to search for in the array. :return: Index of the target if found, otherwise -1. n = len(arr) if n == 0: return -1 # Optimal jump size step = int(math.sqrt(n)) prev = 0 # Finding the block where element is present while prev < n and arr[min(n, prev + step) - 1] < target: prev += step # Performing linear search within the block for i in range(prev, min(n, prev + step)): if arr[i] == target: return i return -1"},{"question":"# Question Title: Efficiently Finding GCD and LCM Using Custom Functions # Question Description: You are tasked with implementing a set of functions to compute the Greatest Common Divisor (GCD), Least Common Multiple (LCM), and trailing zeros in the binary representation of integers using advanced bitwise operations. This challenge checks your ability to manage edge cases and optimize complex bitwise operations for fundamental mathematical computations. # Requirements: 1. **Function Implementation**: * Implement the function `extended_gcd(a: int, b: int) -> int` using bitwise operations to compute the GCD of two integers. This function should handle error cases similarly to `gcd`. * Implement the function `optimized_lcm(a: int, b: int) -> int` to compute the LCM of two integers using `extended_gcd`. * Implement the function `count_trailing_zeros(x: int) -> int` to count the number of trailing zeros in the binary representation of a positive integer using bitwise operations. 2. **Input/Output**: * **Input**: Integer values for `a`, `b`, and `x`. * **Output**: * `extended_gcd` should return an integer representing the GCD. * `optimized_lcm` should return an integer representing the LCM. * `count_trailing_zeros` should return an integer representing the number of trailing zeros in binary representation. 3. **Edge Cases**: * Inputs should be validated to ensure non-negative integers (for all functions). * Proper error handling for zero and non-integer inputs. * Ensure that the functions work efficiently with large integer inputs. # Constraints: * `0 <= a, b, x <= 10^9` # Function Signatures: ```python def extended_gcd(a: int, b: int) -> int: pass def optimized_lcm(a: int, b: int) -> int: pass def count_trailing_zeros(x: int) -> int: pass ``` # Example Cases: Example 1: ```python assert extended_gcd(18, 24) == 6 assert optimized_lcm(18, 24) == 72 assert count_trailing_zeros(40) == 3 ``` Example 2: ```python assert extended_gcd(48, 180) == 12 assert optimized_lcm(48, 180) == 720 assert count_trailing_zeros(96) == 5 ``` Example 3: ```python assert extended_gcd(0, 16) == 16 assert optimized_lcm(0, 16) == 0 assert count_trailing_zeros(1) == 0 ``` # Notes: * Approach the problem by utilizing bitwise operations to craft efficient and error-resilient solutions. * Verification of edge cases is key, ensure your functions handle zero inputs gracefully.","solution":"def extended_gcd(a: int, b: int) -> int: Returns the Greatest Common Divisor (GCD) of two integers a and b using bitwise operations. if a == 0: return b if b == 0: return a shift = 0 while ((a | b) & 1) == 0: a >>= 1 b >>= 1 shift += 1 while (a & 1) == 0: a >>= 1 while b != 0: while (b & 1) == 0: b >>= 1 if a > b: a, b = b, a b = b - a return a << shift def optimized_lcm(a: int, b: int) -> int: Returns the Least Common Multiple (LCM) of two integers a and b using the GCD from extended_gcd. if a == 0 or b == 0: return 0 gcd = extended_gcd(a, b) return abs(a * b) // gcd def count_trailing_zeros(x: int) -> int: Returns the number of trailing zeros in the binary representation of x using bitwise operations. if x == 0: return 0 count = 0 while (x & 1) == 0: x >>= 1 count += 1 return count"},{"question":"**Prime Number Reversal Game** **Context**: In the game of Prime Number Reversal, the player is provided with a list of integers. For each integer, the player needs to determine whether reversing the digits of the integer gives a prime number. The game judges the player\'s performance based on correctly identifying the prime status of the reversed numbers in the list. **Task**: Write a function `prime_reversal(numbers)` that takes a list of integers as input and returns a list of boolean values. Each boolean value should indicate whether the reversed digit sequence of the corresponding integer in the input list is a prime number. **Function Signature**: ```python def prime_reversal(numbers: List[int]) -> List[bool]: pass ``` **Input**: - `numbers`: A list of integers. (1 <= len(numbers) <= 10^5) **Output**: - A list of boolean values where each value corresponds to whether the reversed digit sequence of the integer in \'numbers\' is a prime number. **Constraints**: - Each integer in the list will be in the range from 1 to 10^9. - Performance requirement: The solution should be efficient in terms of both time and space complexities, handling the upper limits within reasonable execution time. **Example**: ```python prime_reversal([13, 17, 29, 31, 37, 97]) # Output: [True, False, False, False, False, True] ``` **Explanation**: - Reversed of 13 is 31, which is prime. - Reversed of 17 is 71, which is prime. - Reversed of 29 is 92, which is not prime. - Reversed of 31 is 13, which is prime. - Reversed of 37 is 73, which is prime. - Reversed of 97 is 79, which is prime. **Notes**: 1. You may reuse the `prime_check(n)` function provided in the snippets for verifying the primality of numbers. 2. Consider edge cases like numbers having leading zeros after reversal.","solution":"from typing import List def is_prime(n: int) -> bool: Check if a number is a prime number. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def prime_reversal(numbers: List[int]) -> List[bool]: Check if the reversed digit sequence of each number in the list is a prime number. results = [] for number in numbers: reversed_number = int(str(number)[::-1]) results.append(is_prime(reversed_number)) return results"},{"question":"You are tasked with implementing an extended version of the classic binary search algorithm. The new function will not only find the index of the target value in a sorted array but will also handle lists with duplicates and return all indices of the target value. Additionally, the function should confirm whether the array is sorted before performing the search. If the array is not sorted, the function should return `-1`. # Function Signature ```python def extended_binary_search(array: List[int], target: int) -> List[int]: pass ``` # Input * `array: List[int]` - A list of integers that should be sorted in ascending order. * `target: int` - An integer value to search for in the array. # Output * `List[int]` - A list of integers representing all indices of the target value in the input array. If the array is not sorted, return `[-1]`. If the target value is not found, return an empty list `[]`. # Constraints * The array can contain up to `10^6` elements. * The target value can be any arbitrary integer. # Examples Example 1: ```python # Input array = [1, 2, 2, 2, 3, 4, 5] target = 2 # Output [1, 2, 3] ``` Example 2: ```python # Input array = [1, 2, 3, 4, 5] target = 6 # Output [] ``` Example 3: ```python # Input array = [1, 3, 2, 4, 5] target = 3 # Output [-1] ``` # Requirements * Ensure that the input array is sorted. * Use an efficient approach to handle the cases with duplicates and large inputs, maintaining the time complexity as close to O(log(n)) as possible, except for confirming array sorting. * Handle edge cases gracefully, such as empty arrays or single-element arrays. Your task is to implement the `extended_binary_search` function as specified. Ensure to include error handling for unsorted arrays and optimize the performance for large arrays.","solution":"from typing import List def extended_binary_search(array: List[int], target: int) -> List[int]: if not array: return [] # Check if the array is sorted for i in range(len(array) - 1): if array[i] > array[i + 1]: return [-1] # Helper function to find the first occurrence of target def find_first(array, target): low, high = 0, len(array) - 1 first_occurrence = -1 while low <= high: mid = (low + high) // 2 if array[mid] == target: first_occurrence = mid high = mid - 1 # look on the left side elif array[mid] < target: low = mid + 1 else: high = mid - 1 return first_occurrence # Helper function to find the last occurrence of target def find_last(array, target): low, high = 0, len(array) - 1 last_occurrence = -1 while low <= high: mid = (low + high) // 2 if array[mid] == target: last_occurrence = mid low = mid + 1 # look on the right side elif array[mid] < target: low = mid + 1 else: high = mid - 1 return last_occurrence first_index = find_first(array, target) if first_index == -1: return [] last_index = find_last(array, target) return list(range(first_index, last_index + 1))"},{"question":"# Question: Transitive Closure of a Directed Graph You are given a directed graph with `n` vertices numbered from `0` to `n-1`. Implement a function `find_transitive_closure` to compute the transitive closure of the given directed graph. The transitive closure matrix, `T`, is defined as: - `T[i][j] = 1` if there is a path from vertex `i` to vertex `j`. - `T[i][j] = 0` otherwise. # Function Signature ```python def find_transitive_closure(n: int, edges: List[Tuple[int, int]]) -> List[List[int]]: ``` # Input - `n` (1 ≤ n ≤ 100): An integer representing the number of vertices in the graph. - `edges`: A list of tuples representing directed edges in the form `(u, v)` where `u` and `v` are integers (0 ≤ u, v < n). # Output - A `n x n` matrix `T` representing the transitive closure of the given graph. # Example ```python n = 4 edges = [(0, 1), (1, 2), (2, 3)] print(find_transitive_closure(n, edges)) ``` Expected Output: ```python [[1, 1, 1, 1], [0, 1, 1, 1], [0, 0, 1, 1], [0, 0, 0, 1]] ``` # Constraints - The graph will not contain self-loops and parallel edges for simplicity. - Your implementation should run within acceptable limits for `n = 100`. # Notes Consider edge cases where: - The graph has no edges, resulting in an identity matrix. - The graph has multiple disjoint components.","solution":"from typing import List, Tuple def find_transitive_closure(n: int, edges: List[Tuple[int, int]]) -> List[List[int]]: # Initialize the transitive closure matrix T with 0s and 1s on the diagonal T = [[0] * n for _ in range(n)] for i in range(n): T[i][i] = 1 # Add edges to the transitive closure matrix for (u, v) in edges: T[u][v] = 1 # Use Floyd-Warshall algorithm to compute the transitive closure for k in range(n): for i in range(n): for j in range(n): T[i][j] = T[i][j] or (T[i][k] and T[k][j]) return T"},{"question":"Problem Statement As a software engineer, you are tasked with improving the efficiency of web-based search functionalities. One of the key features is to allow users to search through a list of product names quickly. Given the current implementation of the Linear Search algorithm, you\'re asked to build an optimized version to handle large volumes of data. Task Implement a function `linear_search_optimized` that follows the original linear search principles but incorporates a slight optimization to check bounds and mid-way early termination for better average-case performance. Function Signature ```python def linear_search_optimized(array: list, query: any) -> int: pass ``` Input * `array` (list): A list of elements to search from. Not necessarily sorted. * `query` (any): The element to be searched within the array. Output * `index` (int): The index of the `query` within `array`, if found. Otherwise, return `-1`. Constraints * The function should handle empty lists and various data types within the list. * Aim for optimizations that can reduce unnecessary comparisons. Example ```python assert linear_search_optimized([4, 2, 5, 1, 3], 5) == 2 assert linear_search_optimized([4, 2, 5, 1, 3], 6) == -1 assert linear_search_optimized([], 5) == -1 assert linear_search_optimized([1, 2, 3, 4, 5], 1) == 0 assert linear_search_optimized([1, 2, 3, 4, 5], 5) == 4 ``` Notes * **Edge Cases**: Your implementation should handle an empty list efficiently. * **Performance**: Although Linear Search is inherently O(n), try to minimize redundant checks and improve its practical performance within this constraint through early termination techniques.","solution":"def linear_search_optimized(array, query): Searches for the query in the array using an optimized linear search. Parameters: array (list): The list to search through. query (any): The element to search for. Returns: int: The index of the found element, or -1 if not found. # Check bounds and perform early termination if possible n = len(array) for i in range(n): if array[i] == query: return i # Early termination: if the element is not found till middle if i >= n // 2 and query not in array[i + 1:]: break return -1"},{"question":"# Context You\'ve been tasked to implement an optimized separate chaining hash table for a dynamic storage solution. The current implementation does not support resizing automatically based on load factors, which could lead to performance degradation. Your goal is to enhance the `SeparateChainingHashTable` implementation to support dynamic resizing to maintain efficient performance. # Task Please implement automatic resizing of the `SeparateChainingHashTable` class such that the hash table resizes itself (doubles the size) whenever the load factor exceeds 75%. Ensure that existing key-value pairs remain accessible correctly after resizing. Additionally, improve the hash function for a better distribution of hash values. # Input/Output Format You need to enhance the provided `SeparateChainingHashTable` class by adding the following functionalities: 1. Implement an improved `hash` function called `improved_hash`. 2. Implement automatic resizing in the `put` method. **Method Description**: - **improved_hash(self, key)**: An improved hash function. - **resize(self)**: Resizes the hash table and rehashes all keys. ```python class SeparateChainingHashTable(object): # __existing_methods__ def improved_hash(self, key): # Implement an improved hash function here. pass def resize(self): # Implement resizing functionality here. pass def put(self, key, value): # Enhance this method to support dynamic resizing. pass ``` Additional constraints: - Load factor threshold for resizing: 75%. - New table size should be twice the current size when resizing. # Constraints - Assume keys are always strings. - Values can be of any type. - You can use Python\'s built-in `hash` function, but you should build upon it for `improved_hash`. # Example ```python # Create a new hash table with initial size 11 table = SeparateChainingHashTable() # Insert values to force resizing for i in range(1, 9): table.put(f\'key-{i}\', f\'value-{i}\') # Print table size after potential resizes print(table.size) # Expected to be 22 if resizing is triggered correctly. ``` Your implementation should pass the comprehensive test cases included in the script, ensuring correctness and efficiency.","solution":"class SeparateChainingHashTable(object): def __init__(self, initial_size=11): self.table = [[] for _ in range(initial_size)] self.size = initial_size self.num_elements = 0 def improved_hash(self, key): # Use built-in hash function but ensure non-negative and within table size return hash(key) % self.size def resize(self): # Double the size of table and rehash all elements new_size = self.size * 2 new_table = [[] for _ in range(new_size)] old_table = self.table self.table = new_table self.size = new_size self.num_elements = 0 for chain in old_table: for key, value in chain: self.put(key, value) # Rehashing all elements def put(self, key, value): if self.num_elements / self.size > 0.75: self.resize() hash_key = self.improved_hash(key) chain = self.table[hash_key] for i, (k, v) in enumerate(chain): if k == key: chain[i] = (key, value) return chain.append((key, value)) self.num_elements += 1 def get(self, key): hash_key = self.improved_hash(key) chain = self.table[hash_key] for k, v in chain: if k == key: return v return None def remove(self, key): hash_key = self.improved_hash(key) chain = self.table[hash_key] for i, (k, v) in enumerate(chain): if k == key: del chain[i] self.num_elements -= 1 return True return False"},{"question":"# Question **Context**: You are tasked with providing a pair of functions to be used in a simple e-mail message compression algorithm. The algorithm will use Run-Length Encoding (RLE) to compress repetitive character sequences within messages for storage efficiency and then decompress them back to the original message when required. **Task**: Implement the following two functions: 1. **encode_message(message)**: - **Input**: A string `message` consisting of ASCII characters. - **Output**: A string that represents the RLE compressed version of the input `message`. - **Example**: ```python encode_message(\\"AAAABBBCCDAA\\") # should return \\"4A3B2C1D2A\\" ``` 2. **decode_message(encoded_message)**: - **Input**: A string `encoded_message` that is the RLE compressed version of a message. - **Output**: The original uncompressed message. - **Example**: ```python decode_message(\\"4A3B2C1D2A\\") # should return \\"AAAABBBCCDAA\\" ``` **Constraints**: - The `message` and `encoded_message` will contain only printable ASCII characters. - The functions should handle edge cases like empty strings correctly. - Assume that the `encoded_message` input is a valid RLE string. **Performance Requirement**: - The implementation should be efficient, ideally O(n) time complexity for both functions. **Additional Notes**: - Ensure your solution passes all edge and stress test cases. - Avoid unnecessary use of extra memory and ensure that your solution reads and writes to memory efficiently.","solution":"def encode_message(message): RLE encode the given message. Args: message (str): The message to be encoded. Returns: str: The RLE encoded message. if not message: return \\"\\" encoded_message = [] count = 1 for i in range(1, len(message)): if message[i] == message[i - 1]: count += 1 else: encoded_message.append(f\\"{count}{message[i - 1]}\\") count = 1 # Append the last sequence encoded_message.append(f\\"{count}{message[-1]}\\") return \\"\\".join(encoded_message) def decode_message(encoded_message): RLE decode the given encoded message. Args: encoded_message (str): The RLE encoded message to be decoded. Returns: str: The original uncompressed message. if not encoded_message: return \\"\\" decoded_message = [] count = 0 for char in encoded_message: if char.isdigit(): count = count * 10 + int(char) else: decoded_message.append(char * count) count = 0 return \\"\\".join(decoded_message)"},{"question":"# Matrix Inversion Function Scenario You are tasked with building on an existing module that inverts (n times n) matrices. This function is crucial in numerical linear algebra for solving systems of linear equations, among other applications. You\'ll implement a matrix inversion function that encapsulates the steps outlined: calculation of minors, cofactors, adjugation, and inversion. Problem Statement Implement a function `invert_matrix(matrix)` that inverts a given (n times n) matrix. The matrix inversion is defined such that for matrix (A), (B = A^{-1}) is the inverse matrix where (A cdot B = I_n). Input Format * `matrix`: A list of lists where each inner list represents a row of the matrix (A). * All elements of the matrix are integers. Output Format * Return the inverted matrix as a list of lists where each inner list represents a row of the matrix (A^{-1}). Constraints * The input matrix will always be square ((n times n)). * (2 le n le 10). * The input matrix will only contain integers that are valid for the inversion process. Examples 1. **Input**: ```python [ [4, 7], [2, 6] ] ``` **Output**: ```python [ [0.6, -0.7], [-0.2, 0.4] ] ``` 2. **Input**: ```python [ [1, 2, 3], [0, 1, 4], [5, 6, 0] ] ``` **Output**: ```python [ [-24, 18, 5], [20, -15, -4], [-5, 4, 1] ] ``` Constraints Make sure to handle the following in your implementation: * Invalid matrices (non-square, singular matrices) should return an appropriate error code in the form `[[Error code]]`. Use the helper functions provided (like `get_determinant`, `get_minor`, `transpose_and_multiply`) if needed to simplify your implementation.","solution":"def get_determinant(matrix): Calculates the determinant of a (n x n) matrix. n = len(matrix) if n == 1: return matrix[0][0] if n == 2: return matrix[0][0]*matrix[1][1] - matrix[0][1]*matrix[1][0] determinant = 0 for c in range(n): determinant += ((-1)**c) * matrix[0][c] * get_determinant(get_minor(matrix, 0, c)) return determinant def get_minor(matrix, i, j): Returns the minor of the matrix after removing the ith row and jth column. return [row[:j] + row[j+1:] for row in (matrix[:i] + matrix[i+1:])] def transpose_and_multiply(matrix, constant): Transposes the matrix and multiplies by a constant. return [[element * constant for element in row] for row in zip(*matrix)] def invert_matrix(matrix): Inverts a given n x n matrix. n = len(matrix) determinant = get_determinant(matrix) if determinant == 0: return [[None]] cofactors = [] for r in range(n): cofactorRow = [] for c in range(n): minor = get_minor(matrix, r, c) cofactorRow.append(((-1)**(r+c)) * get_determinant(minor)) cofactors.append(cofactorRow) adjugate = transpose_and_multiply(cofactors, 1/determinant) return adjugate"},{"question":"# Coordinate Validation Challenge Objective Write a function `is_valid_coordinate` that determines if a given string represents a valid geographical coordinate. The valid formats and rules are specified below. Requirements - A valid coordinate should follow the pattern: * `\\"latitude, longitude\\"` - **Latitude** should be a float or integer between -90 and 90, inclusive. - **Longitude** should be a float or integer between -180 and 180, inclusive. - Coordinates can only contain digits, or these symbols: \\"-\\", \\".\\", \\",\\". - The comma should be immediately followed by a space separating latitude and longitude, i.e., `\\", \\"` (comma followed by a space). Implementation Rules - The function should return `True` if the input string is a valid coordinate; otherwise, it should return `False`. Input Format - A single string containing the geographical coordinate. Output Format - A boolean value: `True` or `False`. Constraints - The input string can be of arbitrary length but typically fits within a reasonable size for a coordinate string. Function Signature ```python def is_valid_coordinate(coordinate: str) -> bool: # Your implementation here ``` Examples ```python # Valid coordinates print(is_valid_coordinate(\\"-23, 25\\")) # Output: True print(is_valid_coordinate(\\"43.91343345, 143\\")) # Output: True print(is_valid_coordinate(\\"4, -3\\")) # Output: True # Invalid coordinates print(is_valid_coordinate(\\"23.234, - 23.4234\\")) # Output: False print(is_valid_coordinate(\\"N23.43345, E32.6457\\")) # Output: False print(is_valid_coordinate(\\"6.325624, 43.34345.345\\")) # Output: False print(is_valid_coordinate(\\"0, 1,2\\")) # Output: False ``` *Consider various edge cases such as missing numbers, extra delimiters, improperly placed signs, etc.*","solution":"def is_valid_coordinate(coordinate: str) -> bool: try: # Split the coordinate by \', \' to get latitude and longitude lat_str, lon_str = coordinate.split(\', \') # Convert latitude and longitude to float lat = float(lat_str) lon = float(lon_str) # Check if latitude and longitude are within the valid range if -90 <= lat <= 90 and -180 <= lon <= 180: return True else: return False except ValueError: # Raised if conversion to float fails or split fails return False except Exception: # Catch any other exception that might occur return False"},{"question":"# Question: Combination Sum IV Given an integer array `nums` with all positive numbers and no duplicates, write a function to find the number of possible combinations that add up to a positive integer `target`. Function Signature: ```python def combination_sum(nums: List[int], target: int) -> int: ``` Input: - `nums`: A list of positive integers without duplicates, (1 leq len(nums) leq 200). - `target`: A positive integer, (1 leq target leq 1000). Output: - Return an integer representing the number of possible combinations that add up to `target`. Example: ```python nums = [1, 2, 3] target = 4 combination_sum(nums, target) # Output: 7 ``` Explanation: The possible combination ways are: - (1, 1, 1, 1) - (1, 1, 2) - (1, 2, 1) - (1, 3) - (2, 1, 1) - (2, 2) - (3, 1) (Note that different sequences are counted as different combinations.) Constraints: - All elements in `nums` are positive. - No duplicates exist in `nums`. Follow-Up: Consider the scenario where negative numbers are allowed in the given array. Think about: - How does this change the problem? - What limitations need to be added to the question to allow negative numbers? Implement the function `combination_sum` and test it with the provided examples and additional test cases of your own.","solution":"from typing import List def combination_sum(nums: List[int], target: int) -> int: # Create a list to store the number of combinations for each value from 0 to target dp = [0] * (target + 1) # There is one way to make sum 0, which is to use no elements dp[0] = 1 # Iterate through each value up to the target for total in range(1, target + 1): # Check each number in nums for num in nums: # If the current total is greater than or equal to num if total >= num: # Increment the number of combinations for the current total dp[total] += dp[total - num] # Return the number of combinations for the target return dp[target]"},{"question":"Advanced Stack Operations You are tasked with implementing a stack manipulation function that enforces each value in the stack to appear twice consecutively, bottom to top. You should consider the efficiency and performance of your implementation, ensuring that it operates within O(n) time complexity where n is the number of elements in the stack. Requirements: 1. Implement the function `duplicate_elements(stack)`, where: - **Input**: `stack` is a list of integers representing a stack where the first element in the list is the bottom of the stack, and the last element is the top. - **Output**: The function should return the modified stack with each element duplicated. 2. You must use only one auxiliary data structure (either a stack or a queue). 3. Ensure your solution handles edge cases effectively (e.g., empty stack, single-element stack). Constraints: - 0 ≤ len(stack) ≤ 10^5 - -10^3 ≤ stack[i] ≤ 10^3 Example: ```python # Example Usage: stack = [3, 7, 1, 14, 9] print(duplicate_elements(stack)) # Expected output: [3, 3, 7, 7, 1, 1, 14, 14, 9, 9] stack = [] print(duplicate_elements(stack)) # Expected output: [] stack = [1] print(duplicate_elements(stack)) # Expected output: [1, 1] ``` Notes: - Maintain an optimal balance between clarity and efficiency. - Focus on ensuring robustness, handling edge cases, and avoiding unnecessary operations.","solution":"def duplicate_elements(stack): This function takes a stack (represented as a list) and duplicates each element, where each value in the stack appears twice consecutively from bottom to top. Parameters: stack (list of int): The input stack. Returns: list of int: The modified stack with each element duplicated. if not stack: return stack result_stack = [] for element in stack: result_stack.append(element) result_stack.append(element) return result_stack"},{"question":"You are tasked with implementing an efficient word dictionary that allows for adding and searching words. The unique feature is that the search can include the wildcard character \'.\' which matches any single letter. Implement the `WordDictionary` class: * `WordDictionary()` Initializes the WordDictionary object. * `void add_word(word)` Adds the word `word` to the dictionary. * `bool search(word)` Returns `true` if `word` can be found in the dictionary (e.g., \\"pad\\" -> false, \\"bad\\" -> true, \\".ad\\" -> true, \\"b..\\" -> true). # Constrains: * All words are inserted and searched in lowercase letters. * The number of calls to `add_word` and `search` is at most ( 3 times 10^4 ). * The length of each word is at most 10. # Input and Output Formats: * **add_word**: * **Input**: A single string word. * **Output**: None * **search**: * **Input**: A single string word. * **Output**: A boolean value indicating whether the word can be found in the dictionary. ```python class WordDictionary: def __init__(self): # Initializes the WordDictionary object pass def add_word(self, word: str) -> None: # Adds the word to the dictionary. pass def search(self, word: str) -> bool: # Returns true if the word can be found in the dictionary. pass ``` # Examples: ```python wordDictionary = WordDictionary() wordDictionary.add_word(\\"bad\\") wordDictionary.add_word(\\"dad\\") wordDictionary.add_word(\\"mad\\") print(wordDictionary.search(\\"pad\\")) # Output: False print(wordDictionary.search(\\"bad\\")) # Output: True print(wordDictionary.search(\\".ad\\")) # Output: True print(wordDictionary.search(\\"b..\\")) # Output: True ``` # Additional Notes: Consider the edge cases where: * The word being added or searched is an empty string. * The search pattern contains multiple wildcards in various positions.","solution":"class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False class WordDictionary: def __init__(self): self.root = TrieNode() def add_word(self, word: str) -> None: current_node = self.root for char in word: if char not in current_node.children: current_node.children[char] = TrieNode() current_node = current_node.children[char] current_node.is_end_of_word = True def search(self, word: str) -> bool: def dfs(node, word, index): if index == len(word): return node.is_end_of_word if word[index] == \'.\': for child in node.children: if dfs(node.children[child], word, index + 1): return True return False else: if word[index] in node.children: return dfs(node.children[word[index]], word, index + 1) else: return False return dfs(self.root, word, 0)"},{"question":"# Shell Sort Analysis and Enhancement Problem Context Shell sort is an in-place comparison-based sorting algorithm that is a generalization of insertion sort. Though simple, it\'s often not used in practice due to its suboptimal run time characteristics with the basic gap sequence. However, by enhancing the gap sequence, substantial performance improvements can be made. Task Given the current implementation of the Shell Sort algorithm, enhance the gap sequence for improved performance. Specifications * **Function to Implement**: `optimized_shell_sort(arr: List[int]) -> List[int]` * **Input**: A list of integers `arr` that needs to be sorted in non-decreasing order. * **Output**: Return the sorted list. * **Constraints**: - The length of the array `n` is between 1 and 10^4. - Array elements\' values range from -10^6 to 10^6. Requirements 1. Implement an optimized version of the Shell Sort using an enhanced gap sequence. 2. Ensure the solution handles edge cases such as empty lists, single-element lists, and already sorted lists. 3. Aim for better performance than the basic Shell Sort. Example ``` python def optimized_shell_sort(arr): \'\'\' Function to sort an array using an optimized Shell Sort algorithm \'\'\' gaps = [701, 301, 132, 57, 23, 10, 4, 1] # Example of a better gap sequence n = len(arr) for gap in gaps: for i in range(gap, n): temp = arr[i] j = i while j >= gap and arr[j - gap] > temp: arr[j] = arr[j - gap] j -= gap arr[j] = temp return arr # Example usage: arr = [12, 34, 54, 2, 3] print(optimized_shell_sort(arr)) # Output: [2, 3, 12, 34, 54] ``` Implement and test your solution thoroughly to ensure its correctness and improved performance. Note: Though Sample Gap sequence provided, feel free to explore or research more advanced sequences for even better optimization.","solution":"def optimized_shell_sort(arr): Function to sort an array using an optimized Shell Sort algorithm # Example of a better gap sequence found to work well in practice gaps = [701, 301, 132, 57, 23, 10, 4, 1] n = len(arr) for gap in gaps: for i in range(gap, n): temp = arr[i] j = i while j >= gap and arr[j - gap] > temp: arr[j] = arr[j - gap] j -= gap arr[j] = temp return arr"},{"question":"You are given an array of integers that represent a collection of elements in a database. Your task is to implement a function to find the index of a target element using linear search, and additionally return the number of comparisons made during the search process. This will help analyze the efficiency of the search operation. # Function Signature ```python def enhanced_linear_search(array: list, query: int) -> tuple: Find the index of the given element in the array along with the number of comparisons made. Parameters: array (List[int]): A list of integers to be searched. query (int): The target element to search for in the array. Returns: tuple: A tuple where - the first element is the index of the target element if found, otherwise -1, - the second element is the number of comparisons made. ``` # Input * `array`: A list of integers, where -1 ≤ element ≤ 10^6, and the length of the array can be in the range [0, 10^4]. * `query`: An integer, -1 ≤ query ≤ 10^6. # Output * A tuple `(index, comparisons)`: * `index`: The index of the query element if it exists in the array, otherwise -1. * `comparisons`: The number of comparisons made during the search process. # Constraints * The algorithm should handle arrays of different sizes, including edge cases like empty arrays. * Ensure the function runs efficiently within the provided constraints. * No built-in search functions are allowed. # Example ```python print(enhanced_linear_search([4, 2, 3, 1, 5], 3)) # Output: (2, 3) print(enhanced_linear_search([4, 2, 3, 1, 5], 6)) # Output: (-1, 5) print(enhanced_linear_search([], 3)) # Output: (-1, 0) ``` In the first example, the query element `3` is found at index `2` after `3` comparisons. In the second example, the query element `6` is not found, requiring `5` comparisons. In the third example, the array is empty, so the function directly returns `(-1, 0)`.","solution":"def enhanced_linear_search(array: list, query: int) -> tuple: Find the index of the given element in the array along with the number of comparisons made. Parameters: array (List[int]): A list of integers to be searched. query (int): The target element to search for in the array. Returns: tuple: A tuple where - the first element is the index of the target element if found, otherwise -1, - the second element is the number of comparisons made. comparisons = 0 for index, element in enumerate(array): comparisons += 1 if element == query: return (index, comparisons) return (-1, comparisons)"},{"question":"# Pattern to Substring Matching Implementation Problem Statement You are tasked with implementing a function that determines if a string follows a specified pattern. In this context, following the pattern means there is a bijection between each character in the pattern and a non-empty substring in the string. Each character in the pattern must map to exactly one substring, and different characters in the pattern must map to different substrings. Function Signature ```python def pattern_match(pattern: str, string: str) -> bool: ``` # Input and Output Formats * **Input**: - `pattern`: A string containing only lowercase letters, representing the pattern. - `string`: A string containing only lowercase letters, representing the text to be checked against the pattern. * **Output**: - Return a boolean value: - `True`: If the string follows the pattern. - `False`: Otherwise. # Constraints * Both `pattern` and `string` contain only lowercase letters. * The length of `pattern` (m) and the length of `string` (n) adhere to the following limits: - 1 <= m, n <= 20 # Examples ```python assert pattern_match(\\"abab\\", \\"redblueredblue\\") == True assert pattern_match(\\"aaaa\\", \\"asdasdasdasd\\") == True assert pattern_match(\\"aabb\\", \\"xyzabcxzyabc\\") == False ``` # Notes - You may assume the inputs are valid and adhere to the above constraints. - The function should be implemented using recursive backtracking to explore different possibilities for matching the pattern to substrings in the string. # Implementation Guidelines - Use a helper function with recursion to try different mappings for each character in the pattern to substrings in the string. - Maintain a dictionary to store the current mappings between pattern characters and substrings. - Ensure that no two characters in the pattern map to the same substring unless they are the same character. Good luck!","solution":"def pattern_match(pattern: str, string: str) -> bool: def backtrack(p_index, s_index, mapping, used): if p_index == len(pattern) and s_index == len(string): return True if p_index == len(pattern) or s_index == len(string): return False current_pattern_char = pattern[p_index] if current_pattern_char in mapping: mapped_string = mapping[current_pattern_char] if not string.startswith(mapped_string, s_index): return False return backtrack(p_index + 1, s_index + len(mapped_string), mapping, used) for i in range(s_index, len(string)): candidate = string[s_index:i + 1] if candidate in used: continue mapping[current_pattern_char] = candidate used.add(candidate) if backtrack(p_index + 1, s_index + len(candidate), mapping, used): return True del mapping[current_pattern_char] used.remove(candidate) return False return backtrack(0, 0, {}, set())"},{"question":"Is this a Palindrome? Given the following function definitions, your task is to write a new function `is_palindrome_optimized` which determines if a given string is a palindrome. This function should consider only alphanumeric characters and ignore cases. **Context**: You\'ll encounter various test cases examining your function\'s efficiency and correctness. Imagine writing a content filter that determines whether titles of articles are palindromes. **Function Signature**: ```python def is_palindrome_optimized(s: str) -> bool: pass ``` **Input**: * `s`: a string with length up to 10,000. It may include alphanumeric characters, spaces, and punctuation marks. **Output**: * Return `True` if `s` is a palindrome, `False` otherwise. **Constraints**: * The function should handle an input string effectively, ensuring minimal space usage. * Ignore non-alphanumeric characters and treat uppercase and lowercase as equal. **Example**: ```python assert is_palindrome_optimized(\\"A man, a plan, a canal: Panama\\") == True assert is_palindrome_optimized(\\"race a car\\") == False assert is_palindrome_optimized(\\"\\") == True assert is_palindrome_optimized(\\" \\") == True assert is_palindrome_optimized(\\"ab_a\\") == True ``` Examine edge cases thoroughly and optimize your function for both time and space complexities.","solution":"def is_palindrome_optimized(s: str) -> bool: Determines if a given string is a palindrome, considering only alphanumeric characters and ignoring case. filtered_chars = [char.lower() for char in s if char.isalnum()] return filtered_chars == filtered_chars[::-1]"},{"question":"As a software engineer, you are tasked with ensuring the integrity of configurations encoded in a proprietary format. Here, brackets are used extensively to denote different levels of configurations. The encoded strings use three types of brackets: `()`, `{}`, and `[]`. You need to write a function to validate whether an input string containing these brackets is correctly balanced. Function Specification * Function Name: `validate_configuration` * Input: A single string `config_string` containing just the characters `()`, `{}`, `[]`. * Output: Returns `True` if the string is valid, `False` otherwise. Constraints 1. The input string will have a maximum length of 10^4. 2. The input string will only consist of the characters `()`, `{}`, `[]`. Performance Requirement The solution should run in O(n) time complexity and use O(n) space complexity where n is the length of the input string. Example Scenarios Example 1: * Input: `config_string = \\"([]){()}\\"` * Output: `True` Example 2: * Input: `config_string = \\"[(])({})\\"` * Output: `False` Example 3: * Input: `config_string = \\"((\\" * Output: `False` Edge Cases 1. Duplicate openings without corresponding closings. 2. Mixed nested formats. 3. Empty string. Implement the `validate_configuration` function: ```python def validate_configuration(config_string: str) -> bool: stack = [] dic = {\\")\\": \\"(\\", \\"}\\": \\"{\\", \\"]\\": \\"[\\"} for char in config_string: if char in dic.values(): stack.append(char) elif char in dic: if not stack or dic[char] != stack.pop(): return False return not stack # You can use the provided function signature to test your examples. ```","solution":"def validate_configuration(config_string: str) -> bool: Validates whether the input configuration string is correctly balanced. Parameters: config_string (str): A string containing only \'()\', \'{}\', and \'[]\'. Returns: bool: True if the string is valid, False otherwise. stack = [] matching_brackets = {\\")\\": \\"(\\", \\"}\\": \\"{\\", \\"]\\": \\"[\\"} for char in config_string: if char in matching_brackets.values(): stack.append(char) elif char in matching_brackets: if not stack or stack.pop() != matching_brackets[char]: return False return not stack"},{"question":"# Question: Implement a MinStack You are to implement a stack that, in addition to the regular stack operations (push, pop, and peek), has an operation `get_min` which returns the minimum element in the stack. Both `push`, `pop`, `get_min` and `peek` operations should all run in O(1) time. Function Specifications 1. `__init__(self)`: Initializes the stack. 2. `push(self, value: int) -> None`: Adds a new item to the top of the stack. 3. `pop(self) -> int`: Removes the top item from the stack and returns it. 4. `peek(self) -> int`: Returns the top item from the stack but does not remove it. 5. `get_min(self) -> int`: Returns the minimum element in the stack in O(1) time. Constraints - Assume that the stack operations will always be valid, i.e., no pop or get_min operations will be called on an empty stack. # Example ```python stack = MinStack() stack.push(3) stack.push(5) print(stack.get_min()) # Output: 3 stack.push(2) stack.push(1) print(stack.get_min()) # Output: 1 stack.pop() print(stack.get_min()) # Output: 2 stack.pop() print(stack.peek()) # Output: 5 ``` # Notes - Ensure your solution follows the O(1) time complexity requirement for `push`, `pop`, `peek`, and `get_min` operations. - The stack should handle integer values.","solution":"class MinStack: def __init__(self): self.stack = [] self.min_stack = [] def push(self, value: int) -> None: self.stack.append(value) if not self.min_stack or value <= self.min_stack[-1]: self.min_stack.append(value) def pop(self) -> int: value = self.stack.pop() if value == self.min_stack[-1]: self.min_stack.pop() return value def peek(self) -> int: return self.stack[-1] def get_min(self) -> int: return self.min_stack[-1]"},{"question":"Given the implementation of a directed graph in the provided code snippet, you are required to extend its functionality to handle the following additional features: **Objective**: 1. **Find Transitive Closure**: Leverage the provided `transitive_closure` method. 2. **Add Additional Functionalities**: a. Add a method to detect if there is a **cycle** in the graph. b. Add a method to find the **strongly connected components**. c. Optimize the transitive closure algorithm by using an iterative approach instead of recursive DFS for better performance. **Function Signatures**: 1. `def detect_cycle(self) -> bool` 2. `def strongly_connected_components(self) -> List[List[int]]` # Input Format * The input graph will be created using the `add_edge` method. * The number of vertices will be provided at the initialization of the `Graph` object. # Output Format 1. `detect_cycle` should return `True` if there is a cycle in the graph, else `False`. 2. `strongly_connected_components` should return a list of lists, where each inner list contains vertices that form a strongly connected component. # Constraints 1. The graph can have at most 100 vertices. 2. The number of edges can be up to 10,000. 3. The vertices are 0-indexed. # Example ```python # Example usage g = Graph(4) g.add_edge(0, 1) g.add_edge(1, 2) g.add_edge(2, 0) g.add_edge(2, 3) g.add_edge(3, 3) print(g.detect_cycle()) # Output: True print(g.strongly_connected_components()) # Output: [[0, 1, 2], [3]] print(g.transitive_closure()) # Output: [[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1], [0, 0, 0, 1]] ```","solution":"class Graph: def __init__(self, vertices): self.vertices = vertices self.graph = [[] for _ in range(vertices)] def add_edge(self, u, v): self.graph[u].append(v) def transitive_closure(self): closure = [[0]*self.vertices for _ in range(self.vertices)] for i in range(self.vertices): self.dfs_util(i, i, closure) return closure def dfs_util(self, s, v, closure): closure[s][v] = 1 for neighbor in self.graph[v]: if closure[s][neighbor] == 0: self.dfs_util(s, neighbor, closure) def detect_cycle(self): visited = [False] * self.vertices rec_stack = [False] * self.vertices def cycle_util(v): visited[v] = True rec_stack[v] = True for neighbor in self.graph[v]: if not visited[neighbor]: if cycle_util(neighbor): return True elif rec_stack[neighbor]: return True rec_stack[v] = False return False for node in range(self.vertices): if not visited[node]: if cycle_util(node): return True return False def strongly_connected_components(self): stack = [] visited = [False] * self.vertices def fill_order(v): visited[v] = True for neighbor in self.graph[v]: if not visited[neighbor]: fill_order(neighbor) stack.append(v) def dfs(v, visited, component): visited[v] = True component.append(v) for neighbor in self.graph_inv[v]: if not visited[neighbor]: dfs(neighbor, visited, component) # Fill vertices in stack according to their finishing times for i in range(self.vertices): if not visited[i]: fill_order(i) # Create a reversed graph self.graph_inv = [[] for _ in range(self.vertices)] for i in range(self.vertices): for neighbor in self.graph[i]: self.graph_inv[neighbor].append(i) # Process all vertices in order defined by stack visited = [False] * self.vertices components = [] while stack: i = stack.pop() if not visited[i]: component = [] dfs(i, visited, component) components.append(component) return components"},{"question":"# Implementing Circular Buffer for ArrayQueue Context: You are given a partial implementation of a queue data structure using an array (`ArrayQueue` class). Currently, this implementation enlarges the array whenever it runs out of space, which can be inefficient. To optimize memory and improve performance, you need to implement a circular buffer in the `ArrayQueue` class. Task: Refactor the `ArrayQueue` class to use a circular buffer instead of resizing the array each time it reaches its capacity. Your implementation should: 1. Maintain the FIFO order. 2. Efficiently manage memory without resizing the array multiple times. 3. Ensure that all operations (enqueue, dequeue, peek) remain O(1). Function Specification: Implement the following functions in the `ArrayQueue` class: 1. `__init__(self, capacity=10)`: Initialize the queue with a fixed capacity. 2. `enqueue(self, value)`: Add a new item to the rear of the queue. 3. `dequeue(self)`: Remove and return the front item from the queue. 4. `peek(self)`: Return the front item without removing it. **Constraints:** - Use a circular buffer to manage the elements. - Avoid resizing the array once it is full. If the queue is full, the program should raise an appropriate error. Input and Output: - The input parameter for `enqueue` is an integer (value to be added). - The `dequeue` and `peek` methods return an integer. - If attempting to `dequeue` or `peek` an element from an empty queue, raise an `IndexError`. - If attempting to `enqueue` an element in a full queue, raise an `OverflowError`. Example: ```python queue = ArrayQueue(3) queue.enqueue(10) queue.enqueue(20) queue.enqueue(30) print(queue.dequeue()) # Output: 10 queue.enqueue(40) print(queue.peek()) # Output: 20 print(queue.dequeue()) # Output: 20 ``` Implement the `ArrayQueue` class to fulfill the requirements above.","solution":"class ArrayQueue: def __init__(self, capacity=10): Initialize the queue with a fixed capacity. self.capacity = capacity self.queue = [None] * capacity self.front = 0 self.rear = 0 self.size = 0 def enqueue(self, value): Add a new item to the rear of the queue. if self.size == self.capacity: raise OverflowError(\\"Queue is full.\\") self.queue[self.rear] = value self.rear = (self.rear + 1) % self.capacity self.size += 1 def dequeue(self): Remove and return the front item from the queue. if self.size == 0: raise IndexError(\\"Queue is empty.\\") value = self.queue[self.front] self.queue[self.front] = None self.front = (self.front + 1) % self.capacity self.size -= 1 return value def peek(self): Return the front item without removing it. if self.size == 0: raise IndexError(\\"Queue is empty.\\") return self.queue[self.front]"},{"question":"You are given two 2-dimensional matrices, and you need to write a function to compute their product. A matrix is represented as a list of lists, where each sublist corresponds to a row in the matrix. # Function Signature ```python def multiply_matrices(multiplicand: list, multiplier: list) -> list: ``` # Input - `multiplicand` (List[List[int]]): A 2D list representing the first matrix. - `multiplier` (List[List[int]]): A 2D list representing the second matrix. # Output A 2D list representing the product of the two matrices. # Constraints - The number of columns in `multiplicand` should be equal to the number of rows in `multiplier`. - `1 <= len(multiplicand), len(multiplicand[0]), len(multiplier), len(multiplier[0]) <= 100`. - Matrix elements will be integers in the range [-100, 100]. # Performance Requirements - Algorithms with less than cubic time complexity are recommended to handle larger matrices efficiently. # Example Example 1 Input: ```python multiplicand = [ [1, 2], [3, 4] ] multiplier = [ [2, 0], [1, 2] ] ``` Output: ```python [ [4, 4], [10, 8] ] ``` Example 2 Input: ```python multiplicand = [ [2, 0], [1, 3] ] multiplier = [ [1, 4], [2, 5] ] ``` Output: ```python [ [2, 8], [7, 19] ] ``` # Notes You must handle any edge cases that could lead to exceptions, such as matrices with incompatible dimensions. Additionally, you should consider both the time and space complexity of your solution.","solution":"def multiply_matrices(multiplicand: list, multiplier: list) -> list: Multiplies two 2D matrices. Args: multiplicand (list of list of int): The first matrix. multiplier (list of list of int): The second matrix. Returns: list of list of int: The resulting matrix product. # Get the dimensions of the matrices rows_multiplicand = len(multiplicand) cols_multiplicand = len(multiplicand[0]) rows_multiplier = len(multiplier) cols_multiplier = len(multiplier[0]) # Check if multiplication is possible if cols_multiplicand != rows_multiplier: raise ValueError(\\"Number of columns in multiplicand must be equal to number of rows in multiplier\\") # Initialize the result matrix with zeros result = [[0 for _ in range(cols_multiplier)] for _ in range(rows_multiplicand)] # Perform matrix multiplication for i in range(rows_multiplicand): for j in range(cols_multiplier): for k in range(cols_multiplicand): result[i][j] += multiplicand[i][k] * multiplier[k][j] return result"},{"question":"Implement Insertion Sort using Search Insert Context Given an array of integers, you are required to sort it using the insertion sort algorithm. However, to optimize the insertion point search, you should use the provided `search_insert` function that employs binary search to find the correct index to insert the element. Task Write a function `insertion_sort_with_search_insert` that takes an array of integers and sorts it in non-decreasing order using insertion sort. Utilize the provided `search_insert` function for determining the insertion point of each element. Input and Output Formats * Input: * A list of integers `array`. * Output: * A list of integers sorted in non-decreasing order. Example ```python array = [12, 11, 13, 5, 6] print(insertion_sort_with_search_insert(array)) # Output: [5, 6, 11, 12, 13] ``` Constraints * Assume that the length of the array (n) is such that (0 leq n leq 10^4). * The values in the array are integers within the range ([-10^4, 10^4]). * Aim for a more efficient solution using binary search for the insertion point. Function Signature ```python def insertion_sort_with_search_insert(array: List[int]) -> List[int]: # your code here ```","solution":"from typing import List def search_insert(sorted_array: List[int], target: int) -> int: Uses binary search to find the insert position for the target in the sorted_array. left, right = 0, len(sorted_array) while left < right: mid = (left + right) // 2 if sorted_array[mid] < target: left = mid + 1 else: right = mid return left def insertion_sort_with_search_insert(array: List[int]) -> List[int]: Sorts an array of integers using insertion sort and binary search for the insertion point. sorted_list = [] for num in array: insert_position = search_insert(sorted_list, num) sorted_list.insert(insert_position, num) return sorted_list"},{"question":"# Objective: Using your understanding of the Newton-Raphson method, develop a function to determine the cube root of a positive integer ( N ) with a precision factor ( P ). # Function Signature ```python def cube_root(n: int, epsilon: float = 0.001) -> float: pass ``` # Input 1. **n (int)**: A positive integer whose cube root is to be found. 2. **epsilon (float)**: A small positive float representing the acceptable error margin (default is ( 0.001 )). # Output - **float**: An approximation of the cube root of ( n ) such that the maximum absolute error is less than ( epsilon ). # Constraints 1. ( n ) is a positive integer ( (1 leq n leq 10^6) ). 2. ( epsilon ) is a small positive float ( (0 < epsilon < 1) ). # Example ```python cube_root(8, 0.001) # Output should be close to 2.0 cube_root(27, 0.001) # Output should be close to 3.0 ``` # Explanation The function should leverage the concept of the Newton-Raphson method but adjusted for finding the cube root instead of the square root. Implement appropriate adjustments to the iterative formula and ensure convergence checks consider the cube of the guess value. Ensure you handle: - Initial guess setup. - Proper convergence criteria. - Testing with various edge cases (e.g., small, large integers).","solution":"def cube_root(n: int, epsilon: float = 0.001) -> float: Apply Newton-Raphson method to find the cube root of a positive integer n with precision epsilon. :param n: The integer whose cube root is to be found. :param epsilon: The acceptable error margin. :return: The cube root of n. # Initial guess can be n / 3 guess = n / 3.0 while True: t = (2.0 * guess + n / (guess * guess)) / 3.0 if abs(t - guess) < epsilon: return round(t, 10) # rounding result for more consistent returns guess = t"},{"question":"# Combination Sum Problem Problem Statement: Given an integer array `nums` with all positive numbers and no duplicates, find the number of possible combinations that add up to a positive integer `target`. Implement the following function in both Top-Down and Bottom-Up dynamic programming approaches: ```python def combination_sum(nums, target): pass ``` # Input: - `nums`: a list of distinct positive integers `[num1, num2, ..., numn]`. - `target`: an integer representing the target sum. # Output: - Return an integer representing the number of possible combinations that add up to `target`. # Constraints: - All elements of `nums` are unique positive integers. - 1 ≤ len(nums) ≤ 200 - 1 ≤ nums[i], target ≤ 1000 # Example: ```python # Example 1 nums = [1, 2, 3] target = 4 combination_sum(nums, target) # Output: 7 # Explanation: The possible combination ways are: # (1, 1, 1, 1) # (1, 1, 2) # (1, 2, 1) # (1, 3) # (2, 1, 1) # (2, 2) # (3, 1) # Example 2 nums = [2, 3, 5] target = 8 combination_sum(nums, target) # Output: 6 # Explanation: The possible combination ways are: # (2, 2, 2, 2) # (2, 3, 3) # (3, 2, 2) # (5, 3) # (3, 5) # (2, 2, 3, 1) ``` # Follow-up: 1. What if negative numbers are allowed in the given array? How does it change the problem? 2. What limitations do we need to add to the question to allow negative numbers? **Note:** - Consider including necessary performance requirements or constraints. - Ensure that your solution properly handles edge cases.","solution":"def combination_sum_top_down(nums, target): Top-down dynamic programming approach to find the number of possible combinations that add up to the target. memo = {} def dp(tar): if tar in memo: return memo[tar] if tar == 0: return 1 if tar < 0: return 0 count = 0 for num in nums: count += dp(tar - num) memo[tar] = count return count return dp(target) def combination_sum_bottom_up(nums, target): Bottom-up dynamic programming approach to find the number of possible combinations that add up to the target. dp = [0] * (target + 1) dp[0] = 1 for tar in range(1, target + 1): for num in nums: if tar - num >= 0: dp[tar] += dp[tar - num] return dp[target]"},{"question":"# Priority Task Scheduler You have been tasked to implement a task scheduler where tasks are executed based on their priority. The scheduler uses a priority queue data structure to manage the tasks. Implement the following methods in the `PriorityQueue` class: 1. `peek()`: This method returns the task with the highest priority without removing it from the queue. 2. `change_priority(item, new_priority)`: This method changes the priority of a specific item in the queue. If the item is not found in the queue, raise a `ValueError`. # Function Signatures: ```python def peek(self) -> \'data\': pass def change_priority(self, item: \'data\', new_priority: int) -> None: pass ``` # Constraints: - Both `item` and `new_priority` will be integers. - The queue may contain duplicate items, assume the first occurrence should have its priority changed. - You may assume `change_priority` will only be called with valid `item` already present in the queue. - Maximum size of the queue is 10^6 elements. # Performance Requirements: - `peek` should perform in O(1) time complexity. - `change_priority` can have a complexity up to O(n) due to traversal to find the item. # Example: Here’s how the Priority Queue class is expected to function: ```python pq = PriorityQueue([4, 2, 5, 3, 1], [40, 20, 50, 10, 30]) print(pq.peek()) # Output: 1, since 1 has the lowest priority (30) pq.change_priority(2, 45) print(pq.peek()) # Output: 4, because changing priority of 2 altered the order. ``` Implement the `peek` and `change_priority` methods to complete the Priority Queue.","solution":"import heapq class PriorityQueue: def __init__(self, items, priorities): self._queue = [(priorities[i], items[i]) for i in range(len(items))] heapq.heapify(self._queue) self._item_map = {items[i]: (priorities[i], i) for i in range(len(items))} def peek(self) -> \'data\': Returns the task with the highest priority without removing it from the queue. if not self._queue: return None return self._queue[0][1] def change_priority(self, item: \'data\', new_priority: int) -> None: Changes the priority of a specific item in the queue. If the item is not found in the queue, raise a ValueError. if item not in self._item_map: raise ValueError(f\'Item {item} not found in the queue.\') # Remove the old entry priority, index = self._item_map.pop(item) self._queue.remove((priority, item)) heapq.heapify(self._queue) # Insert the new entry heapq.heappush(self._queue, (new_priority, item)) self._item_map[item] = (new_priority, index)"},{"question":"Inorder Successor in Binary Search Tree Given a binary search tree (BST) and a node, write a function to find the inorder successor of the given node. The successor of a node `p` is the node with the smallest key greater than `p.val`. You need to implement the following function: ```python def inorder_successor(root: Optional[TreeNode], p: TreeNode) -> Optional[TreeNode]: pass ``` Input - `root` (TreeNode): The root of the BST. - `p` (TreeNode): The node in the BST for which we need to find the inorder successor. Do not assume any node values or count constraints other than there will be no duplicate values in the tree. Output - (TreeNode): The inorder successor of node `p`. If there\'s no successor, return `None`. Constraints 1. The function should have a time complexity of O(h) where h is the height of the BST. 2. You must use O(1) additional space. Example Consider the below BST: ``` 5 / 3 7 / / 2 4 6 8 ``` 1. If `p` is the node with value `3`, then the function should return the node with value `4`. 2. If `p` is the node with value `5`, then the function should return the node with value `6`. 3. If `p` is the node with value `8`, then the function should return `None` as there is no successor. Note You can define the `TreeNode` class as: ```python class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None ```","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def inorder_successor(root, p): Find the inorder successor of node p in the BST rooted at root. :param root: TreeNode, the root of the BST :param p: TreeNode, the node whose inorder successor is to be found :return: TreeNode, the inorder successor of p or None if there is no successor successor = None while root: if p.val < root.val: successor = root root = root.left else: root = root.right return successor"},{"question":"# Shell Sort Algorithm Implementation Problem Statement You are given an array of integers `arr`. Implement the Shell Sort algorithm to sort this array in ascending order. Shell Sort is an enhancement over Insertion Sort, with a more advanced mechanism of sorting by initially considering elements that are far apart. Requirements 1. Write a function `shell_sort(arr)` that takes a list of integers `arr` as input and returns the sorted list in ascending order. 2. Your function should perform sorting in-place, i.e., without using extra memory for another array. 3. The sorting should be implemented following the Shell Sort algorithm. Input and Output Formats - **Input**: A list of integers of length `n` where (1 leq n leq 10^5). Each integer `arr[i]` is within the range (|arr[i]| leq 10^6). - **Output**: A list of integers sorted in ascending order. Constraints 1. Optimize for average and worst-case performance. 2. Clearly handle edge cases like empty arrays or arrays with single elements. # Example ```python arr = [64, 34, 25, 12, 22, 11, 90] print(shell_sort(arr)) # Expected Output: [11, 12, 22, 25, 34, 64, 90] ``` # Additional Notes - Carefully choose a gap sequence to optimize the algorithm\'s performance. - Ensure that your implementation works efficiently even for the upper limit of input size.","solution":"def shell_sort(arr): Performs in-place Shell Sort on a list of integers. Parameters: arr (list): A list of integers to be sorted. Returns: list: Sorted list of integers in ascending order. n = len(arr) gap = n // 2 while gap > 0: for i in range(gap, n): temp = arr[i] j = i while j >= gap and arr[j - gap] > temp: arr[j] = arr[j - gap] j -= gap arr[j] = temp gap //= 2 return arr"},{"question":"The Union-Find data structure is essential for various algorithms dealing with connected components. You are provided with a simplified implementation that can add elements, find their root representative of their set, and unite two sets. # Problem Statement: You\'re tasked with implementing a modified version of the Union-Find data structure which can efficiently track and merge disjoint sets of elements. Additionally, utilize this structure to solve another problem involving counting the number of islands in a grid. # Part 1: Union-Find Implementation Implement the Union-Find class with the following functionality: * `add(element)`: Adds a new element as a separate disjoint set. * `root(element)`: Identifies and returns the root of the set containing the element. * `unite(element1, element2)`: Merges the sets containing `element1` and `element2`. # Part 2: Number of Islands Implement a function `num_islands(positions: List[List[int]], m: int, n: int) -> List[int]` which takes a list of positions (each position is a pair of coordinates `[i, j]` where land is added) and returns a list representing the number of islands after each addLand operation. An island is defined as a connected group of \'1\'s (land) horizontally or vertically, but not diagonally. # Example: ```python positions = [[0, 0], [0, 1], [1, 2], [2, 1]] m, n = 3, 3 output = num_islands(positions, m, n) print(output) # Expected output: [1, 1, 2, 3] ``` # Constraints: * Assume positions are always valid within the grid boundaries. * `m` and `n` `[1 <= m, n <= 1000]`. * Positions length can be up to `m * n`. ```python class Union: def __init__(self): # Initialize Union-Find data structure pass def add(self, element): # Add a new element as a separate disjoint set pass def root(self, element): # Find the root of the set containing the element pass def unite(self, element1, element2): # Merge the sets containing element1 and element2 pass def num_islands(positions: List[List[int]], m: int, n: int) -> List[int]: # Implement the function that utilizes Union-Find to count the number of islands pass ``` * Note: You are required to implement both `Union` class methods and the `num_islands` function.","solution":"class Union: def __init__(self): self.parent = {} self.rank = {} def add(self, element): if element not in self.parent: self.parent[element] = element self.rank[element] = 0 def root(self, element): if self.parent[element] != element: self.parent[element] = self.root(self.parent[element]) return self.parent[element] def unite(self, element1, element2): root1 = self.root(element1) root2 = self.root(element2) if root1 != root2: if self.rank[root1] > self.rank[root2]: self.parent[root2] = root1 elif self.rank[root1] < self.rank[root2]: self.parent[root1] = root2 else: self.parent[root2] = root1 self.rank[root1] += 1 def num_islands(positions, m, n): def get_neighbors(x, y): for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n: yield nx, ny union = Union() grid = [[0] * n for _ in range(m)] island_count = 0 results = [] for x, y in positions: if grid[x][y] == 1: results.append(island_count) continue grid[x][y] = 1 union.add((x, y)) island_count += 1 for nx, ny in get_neighbors(x, y): if grid[nx][ny] == 1: if union.root((x, y)) != union.root((nx, ny)): union.unite((x, y), (nx, ny)) island_count -= 1 results.append(island_count) return results"},{"question":"# Topological Sort Implementation # Context You are tasked with designing a task scheduling system for a project consisting of multiple tasks, where certain tasks depend on the completion of others. Specifically, this involves creating a topological sort function for a directed acyclic graph (DAG) representing task dependencies. Each node represents a task, and each directed edge indicates a dependency. # Task Write a function `topological_sort` that takes a dictionary `graph` representing a DAG and returns a list of nodes in a valid topological order. If the graph contains a cycle, raise a `ValueError`. # Function Signature ```python def topological_sort(graph: Dict[int, List[int]]) -> List[int]: ``` # Input * `graph`: A dictionary where keys are task identifiers (integers), and values are lists of identifiers representing dependent tasks. # Output * A list of task identifiers in a valid topological order. # Constraints * The input graph is guaranteed to have unique integer task identifiers. * The graph contains no self-loops or multiple edges between the same pair of vertices. # Requirements * Time complexity should be O(V + E). * Space complexity should be O(V). * Properly detect and handle cycles by raising a `ValueError`. # Example ```python # Example graph graph = { 5: [2, 0], 4: [0, 1], 3: [1], 2: [3], 1: [], 0: [] } # Expected output: [5, 4, 2, 3, 1, 0] or any other valid topological order try: order = topological_sort(graph) print(\\"Topological Order:\\", order) except ValueError as e: print(\\"Error:\\", e) ``` **Note:** Any valid topological sort order will be accepted for the correct output.","solution":"from typing import List, Dict def topological_sort(graph: Dict[int, List[int]]) -> List[int]: def visit(node): if node in temporary_mark: raise ValueError(\\"Graph has a cycle\\") if node not in permanent_mark: temporary_mark.add(node) for neighbor in graph.get(node, []): visit(neighbor) temporary_mark.remove(node) permanent_mark.add(node) result.append(node) result = [] temporary_mark = set() permanent_mark = set() for node in graph: if node not in permanent_mark: visit(node) result.reverse() return result"},{"question":"# Question: Optimized Linear Search with Early Exit Strategy Context You are working with a dataset that is frequently updated and requires constant search operations. The dataset is not sorted, and you often have to find if certain values exist within this dataset. Given the large size of the dataset, performance is critical. Implement an optimized version of the linear search algorithm that incorporates an \\"early exit\\" strategy to improve performance when the target value is frequently found towards the beginning of the array. Task Write a function, `optimized_linear_search`, that performs a linear search on an array to find the target value but terminates early if the target is found in the first few elements, reducing the overall number of comparisons. Function Signature ```python def optimized_linear_search(array: list, query: int, early_exit_threshold: int) -> int: ``` Input * `array`: A list of integers where we need to search for the target value. * `query`: An integer representing the target value to search for within the array. * `early_exit_threshold`: An integer representing the number of initial elements to check before deciding to exit early if the element is not found within these initial elements. Output * Returns the index of the target value within the array if found. * Returns -1 if the target value is not found or if it is not found within the early exit threshold and the search is terminated early. Constraints * The array can be larger than 10^5 elements. * The early_exit_threshold will be a positive integer less than or equal to the length of the array. Example ```python array = [1, 3, 5, 7, 9, 2, 4, 6, 8, 10] query = 5 early_exit_threshold = 3 assert optimized_linear_search(array, query, early_exit_threshold) == 2 query = 8 early_exit_threshold = 5 assert optimized_linear_search(array, query, early_exit_threshold) == -1 ``` Explanation In the first example, the function finds the target value `5` at index `2` while within the `early_exit_threshold` of `3`. In the second example, the target value `8` is beyond the `early_exit_threshold` and thus the function returns `-1` indicating that the search terminated early within the first `5` elements without finding the target.","solution":"def optimized_linear_search(array: list, query: int, early_exit_threshold: int) -> int: Perform a linear search with an early exit strategy. Parameters: array (list): The list of integers to search within. query (int): The target value to search for. early_exit_threshold (int): The number of elements to check before exiting early. Returns: int: The index of the target value if found, otherwise -1. # Iterate through the array up to the early exit threshold for i in range(early_exit_threshold): if array[i] == query: return i # If query was not found within the early exit threshold, return -1 return -1"},{"question":"# Decoding Ways Problem Problem Statement You are given an encoded message containing only digits. The encoding uses the following rules: - \'A\' -> 1 - \'B\' -> 2 - ... - \'Z\' -> 26 Given an encoded message, determine the total number of ways to decode it. Write a function named `decode_ways` to solve this problem. Function Signature ```python def decode_ways(enc_mes: str) -> int: pass ``` Input: - `enc_mes` (string): A non-empty string containing only digits. Output: - Returns an integer representing the total number of ways to decode the message. Constraints: - The input string will contain only the characters \'0\'-\'9\'. Example: ```python assert decode_ways(\\"12\\") == 2 # \\"12\\" can be decoded as \\"AB\\" (1 2) or \\"L\\" (12) assert decode_ways(\\"226\\") == 3 # \\"226\\" can be decoded as \\"BZ\\" (2 26), \\"VF\\" (22 6), or \\"BBF\\" (2 2 6) assert decode_ways(\\"\\") == 0 # An empty string cannot be decoded assert decode_ways(\\"06\\") == 0 # \\"06\\" is invalid ``` Notes: Consider edge cases such as invalid sequences starting with zero, multiple \'0\'s in a row, or strings that only contain single digit valid numbers. Use an efficient algorithm to ensure your solution handles large input sizes within a reasonable time frame.","solution":"def decode_ways(enc_mes: str) -> int: if not enc_mes or enc_mes[0] == \'0\': return 0 n = len(enc_mes) dp = [0] * (n + 1) dp[0] = 1 for i in range(1, n + 1): if enc_mes[i-1] != \'0\': dp[i] += dp[i-1] if i > 1 and enc_mes[i-2:i] >= \'10\' and enc_mes[i-2:i] <= \'26\': dp[i] += dp[i-2] return dp[n]"},{"question":"You are tasked with implementing a variation of the Merge Sort algorithm. This variation, called \\"Iterative Merge Sort,\\" avoids recursion by using an iterative approach to divide the array and then merge the parts. Your task is to write a function that sorts an input list of integers using the Iterative Merge Sort algorithm. Function Signature ```python def iterative_merge_sort(arr: List[int]) -> List[int]: pass ``` Input * A list of integers, `arr`, where `1 <= len(arr) <= 10^5` and `-10^9 <= arr[i] <= 10^9`. Output * A new list of integers sorted in ascending order. Constraints * The algorithm should run in O(n log(n)) time complexity. * The algorithm should use O(n) additional space for the merged arrays. * You must not use recursion. Example ```python arr = [38, 27, 43, 3, 9, 82, 10] print(iterative_merge_sort(arr)) # Output: [3, 9, 10, 27, 38, 43, 82] arr = [1, 3, 2, 5, 4, 6] print(iterative_merge_sort(arr)) # Output: [1, 2, 3, 4, 5, 6] arr = [5] print(iterative_merge_sort(arr)) # Output: [5] arr = [] print(iterative_merge_sort(arr)) # Output: [] ``` Description 1. Implement an iterative version of Merge Sort. 2. Use an auxiliary function to merge two sorted subarrays into a single sorted subarray. 3. Your implementation should handle edge cases such as empty arrays and arrays with a single element. Hints * Use a loop to divide the array into progressively smaller subarrays until each has one element. * Gradually merge the subarrays back together in sorted order by iterating through pairs of subarrays. Good luck!","solution":"def iterative_merge_sort(arr): if not arr: # Edge case: empty array return arr n = len(arr) width = 1 while width < n: for i in range(0, n, 2 * width): left = arr[i:i + width] right = arr[i + width:i + 2 * width] arr[i:i + 2 * width] = merge(left, right) width *= 2 return arr def merge(left, right): result = [] l = r = 0 while l < len(left) and r < len(right): if left[l] < right[r]: result.append(left[l]) l += 1 else: result.append(right[r]) r += 1 result.extend(left[l:]) result.extend(right[r:]) return result"},{"question":"# Context You have been given the implementation of a basic Binary Search Tree (BST) in Python. This BST supports insertion, search, size calculation, and traversals (preorder, inorder, postorder). # Problem Implement a function that checks if a given Binary Search Tree (BST) is height-balanced. A height-balanced BST is defined such that the depth of two subtrees of every node never differs by more than one. # Function Signature ```python def is_balanced(bst: BST) -> bool: Determines whether the given Binary Search Tree (bst) is height-balanced. Args: - bst (BST): The BST instance to check. Returns: - bool: True if the BST is height-balanced, False otherwise. ``` # Input Format * The input function `is_balanced` will receive a BST instance populated with nodes. # Output Format * The output should be a boolean value indicating whether the BST is height-balanced or not. # Constraints * The BST can have up to 10^4 nodes. * You may assume the BST implementation provided is correct and does not contain duplicate values. # Example ```python # Given the BST example from the provided code snippet # We are using the provided tree: bst = BST() bst.insert(10) bst.insert(15) bst.insert(6) bst.insert(4) bst.insert(9) bst.insert(12) bst.insert(24) bst.insert(7) bst.insert(20) bst.insert(30) bst.insert(18) # Check if the BST is balanced print(is_balanced(bst)) # Expected output: False ``` # Additional Notes * Ensure to handle different edge cases including: - Empty BST. - Single-node BST. - Varied tree depths.","solution":"class Node: def __init__(self, key): self.left = None self.right = None self.value = key class BST: def __init__(self): self.root = None def insert(self, key): if self.root is None: self.root = Node(key) else: self._insert(self.root, key) def _insert(self, node, key): if key < node.value: if node.left is None: node.left = Node(key) else: self._insert(node.left, key) else: if node.right is None: node.right = Node(key) else: self._insert(node.right, key) def is_balanced(bst: BST) -> bool: def check_height(node): if node is None: return 0 left_height = check_height(node.left) if left_height == -1: return -1 right_height = check_height(node.right) if right_height == -1: return -1 if abs(left_height - right_height) > 1: return -1 return max(left_height, right_height) + 1 return check_height(bst.root) != -1"},{"question":"Problem Statement Design a function to perform Run-Length Encoding (RLE) and another to decode an RLE-encoded string. Implement the `encode_rle` and `decode_rle` functions based on RLE as described below: # Requirements 1. **Encoding Function `encode_rle(input: str) -> str`**: - Input: A string `input` containing the data to be encoded. - Output: A string representing the encoded data using RLE. - Constraints: - The input string will contain only alphabetic characters. 2. **Decoding Function `decode_rle(input: str) -> str`**: - Input: A string `input` containing the RLE-encoded data. - Output: A string representing the original data before encoding. - Constraints: - The encoded input string is valid and follows the format generated by `encode_rle`. # Performance Requirements - Both functions must run in linear time O(n) with respect to the length of the input string. - The space complexity should also be linear O(n), where n is the length of the input string. # Example ```python input_data = \\"AAABBBCCDAA\\" encoded_data = encode_rle(input_data) # encoded_data should be \\"3A3B2C1D2A\\" decoded_data = decode_rle(encoded_data) # decoded_data should be \\"AAABBBCCDAA\\" ``` # Edge Cases - Empty string as input should return an empty string. - Single character strings should return the character followed by 1 (e.g., \\"A\\" -> \\"1A\\"). # Function Signatures ```python def encode_rle(input: str) -> str: pass def decode_rle(input: str) -> str: pass ```","solution":"def encode_rle(input: str) -> str: if not input: return \\"\\" result = [] count = 1 current_char = input[0] for char in input[1:]: if char == current_char: count += 1 else: result.append(f\\"{count}{current_char}\\") current_char = char count = 1 result.append(f\\"{count}{current_char}\\") return \\"\\".join(result) def decode_rle(input: str) -> str: if not input: return \\"\\" result = [] count = \\"\\" for char in input: if char.isdigit(): count += char else: result.append(char * int(count)) count = \\"\\" return \\"\\".join(result)"},{"question":"# Question: Implement an Optimized Quick Sort You are given an array of integers that needs to be sorted in ascending order. Your task is to implement an optimized version of the quick sort algorithm. **Function Signature:** ```python def optimized_quick_sort(arr: List[int]) -> List[int]: pass ``` # Requirements: 1. Implement the optimized quick sort algorithm. 2. Optimize the pivot selection process to avoid worst-case scenarios. 3. Use in-place sorting. # Constraints: * The input array will have at most 10^6 elements. * Elements in the array will be integers within the range [-10^9, 10^9]. * The function should handle cases efficiently where the array is already sorted or reverse sorted. # Input: * An array of integers `arr`. # Output: * A sorted array of integers `arr`. # Example: ```python assert optimized_quick_sort([3, 6, 8, 10, 1, 2, 1]) == [1, 1, 2, 3, 6, 8, 10] assert optimized_quick_sort([1, 2, 3, 4, 5, 6, 7]) == [1, 2, 3, 4, 5, 6, 7] assert optimized_quick_sort([-1, -5, 3, 0, 2, 1, -4]) == [-5, -4, -1, 0, 1, 2, 3] ``` Additional Notes: * Utilize randomization or the median-of-three rule for pivot selection. * Avoid using extra space beyond the input array and the recursion stack.","solution":"from typing import List import random def optimized_quick_sort(arr: List[int]) -> List[int]: Sorts an array of integers in ascending order using an optimized version of quick sort. def quick_sort_helper(arr, low, high): if low < high: # Obtain the partition index pi = partition(arr, low, high) # Recursively sort elements before partition and after partition quick_sort_helper(arr, low, pi - 1) quick_sort_helper(arr, pi + 1, high) def partition(arr, low, high): # Randomly pick pivot and swap with the last element (high) pivot_index = random.randint(low, high) arr[pivot_index], arr[high] = arr[high], arr[pivot_index] pivot = arr[high] i = low - 1 for j in range(low, high): if arr[j] <= pivot: i += 1 arr[i], arr[j] = arr[j], arr[i] arr[i + 1], arr[high] = arr[high], arr[i + 1] return i + 1 # Start the quicksort process quick_sort_helper(arr, 0, len(arr) - 1) return arr"},{"question":"Cocktail Shaker Sort Enhancements **Background**: Cocktail shaker sort is a variation of the bubble sort algorithm that traverses the list in both directions alternatively to sort the elements. Your task is to enhance and implement a variant of **cocktail shaker sort** with a focus on efficiency improvements. **Problem Statement**: Implement an enhanced version of `cocktail_shaker_sort` that includes the following optimizations: 1. **Minimize Unnecessary Comparisons**: Track the last swapped position to reduce the number of inspected elements in subsequent passes. 2. **Bidirectional Swaps in a Single Pass**: Attempt to optimize comparisons and swaps within a single pass in both forward and backward directions to enhance performance further. **Function Signature**: ```python def enhanced_cocktail_shaker_sort(arr: list[int]) -> list[int]: Sorts an array using an optimized version of the cocktail shaker sort. Parameters: arr (list of int): The list of integers to be sorted. Returns: list of int: The sorted list. ``` **Input**: - A list of integers `arr` where `0 <= len(arr) <= 10^5`. **Output**: - The sorted list of integers in ascending order. **Constraints**: - Aim for as few comparisons and swaps as possible. - Ensure the implementation is efficient for relatively large inputs. # Example: ```python # Input arr = [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5] # Output sorted_arr = enhanced_cocktail_shaker_sort(arr) print(sorted_arr) # [1, 1, 2, 3, 3, 4, 5, 5, 5, 6, 9] ``` **Notes**: - You may assume that the list contains only integer values. - Implement your solution to handle the worst-case efficiently while focusing on reducing the number of operations.","solution":"def enhanced_cocktail_shaker_sort(arr: list[int]) -> list[int]: Sorts an array using an optimized version of the cocktail shaker sort. Parameters: arr (list of int): The list of integers to be sorted. Returns: list of int: The sorted list. if not arr: return arr n = len(arr) start = 0 end = n - 1 swapped = True while swapped: swapped = False # Forward pass new_end = end for i in range(start, end): if arr[i] > arr[i + 1]: arr[i], arr[i + 1] = arr[i + 1], arr[i] swapped = True new_end = i end = new_end if not swapped: break swapped = False # Backward pass new_start = start for i in range(end, start, -1): if arr[i] < arr[i - 1]: arr[i], arr[i - 1] = arr[i - 1], arr[i] swapped = True new_start = i start = new_start return arr"},{"question":"# Decoding Encoded Strings The encoding rule is: `k[encoded_string]`, where the `encoded_string` inside the square brackets is repeated exactly `k` times. You need to implement a function that can decode such strings according to this rule. Function Signature ```python def decode_string(s: str) -> str: :param s: str: A string encoded with the k[encoded_string] rules. :return: str: The decoded string. ``` Input * A single string `s` that is guaranteed to be valid (i.e., no extra white spaces, well-formed square brackets, etc.). * Example inputs: `\\"3[a]2[bc]\\"`, `\\"3[a2[c]]\\"`, `\\"2[abc]3[cd]ef\\"`. Output * The function should return a single decoded string. * Example outputs: `\\"aaabcbc\\"`, `\\"accaccacc\\"`, `\\"abcabccdcdcdef\\"`. Constraints * The input string will not contain digits other than those for the repeat counts. * The input string can have a maximum length of 10000 characters. Performance * Ensure the function runs efficiently with a time complexity of O(N) and a space complexity of O(N), where N is the length of the input string. Test Cases 1. Input: `\\"3[a]2[bc]\\"` Output: `\\"aaabcbc\\"` 2. Input: `\\"3[a2[c]]\\"` Output: `\\"accaccacc\\"` 3. Input: `\\"2[abc]3[cd]ef\\"` Output: `\\"abcabccdcdcdef\\"` 4. Input: `\\"\\"` Output: `\\"\\"` 5. Input: `\\"10[a]\\"` Output: `\\"aaaaaaaaaa\\"` Provide a codable solution to decode the given encoded string according to the specified rules.","solution":"def decode_string(s: str) -> str: Decodes the encoded string based on the k[encoded_string] rules. :param s: str: A string encoded with the k[encoded_string] rules. :return: str: The decoded string. stack = [] current_string = \'\' current_num = 0 for char in s: if char.isdigit(): current_num = current_num * 10 + int(char) elif char == \'[\': stack.append((current_string, current_num)) current_string = \'\' current_num = 0 elif char == \']\': prev_string, repeat_num = stack.pop() current_string = prev_string + current_string * repeat_num else: current_string += char return current_string"},{"question":"# Decode Ways Objective: You are given an encoded message containing digits. Each digit maps to a letter (\'A\' -> 1, \'B\' -> 2, ..., \'Z\' -> 26). Your task is to determine the total number of ways to decode the message. Input: A non-empty string `s` comprised of digits. Output: An integer representing the total number of ways to decode the message. Constraints: - `1 <= len(s) <= 100` - The string contains only digits and does not contain leading zeros. Requirements: Implement the function `num_decodings(s)` to meet the criteria specified. The function should handle edge cases efficiently and provide the correct count of decodings. Example: - Input: `s = \\"12\\"` - Output: `2` (Explanation: \\"12\\" could be decoded as \\"AB\\" (1 2) or \\"L\\" (12)). - Input: `s = \\"226\\"` - Output: `3` (Explanation: \\"226\\" could be decoded as \\"BZ\\" (2 26), \\"VF\\" (22 6), or \\"BBF\\" (2 2 6)). Additional Note: Consider edge cases such as: - `s` containing \'0\'s that are not part of \'10\' or \'20\'. - Messages with varying lengths. - Any message that cannot be decoded should return 0.","solution":"def num_decodings(s): Determines the total number of ways to decode the given message. :param s: A non-empty string comprised of digits :return: An integer representing the total number of ways to decode the message if not s or s[0] == \'0\': # The message cannot start with \'0\' return 0 n = len(s) dp = [0] * (n + 1) # dp[i] means the number of ways to decode the substring s[:i] dp[0] = 1 # Base case: empty string for i in range(1, n + 1): if s[i - 1] != \'0\': # Single character decoding dp[i] += dp[i - 1] if i > 1 and \'10\' <= s[i - 2:i] <= \'26\': # Two character decoding dp[i] += dp[i - 2] return dp[n]"},{"question":"# Palindrome Linked List Detection Problem Statement Given a singly linked list, write a function to determine if the linked list is a palindrome. A palindrome is a sequence that reads the same forward and backward. Function signature ```python def is_palindrome_linked_list(head) -> bool: pass ``` Input - The `head` parameter represents the head node of a singly linked list. Each node has an integer `val` and a reference to the next node `next`. Output - Returns `True` if the linked list is a palindrome, `False` otherwise. Constraints - The number of nodes in the list is in the range [0, 10^5]. - -10^5 <= Node.val <= 10^5 Example 1. Input: * 1 -> 2 -> 2 -> 1 2. Output: * `True` 3. Input: * 1 -> 2 4. Output: * `False` Notes - Solve the problem with O(N) time complexity and O(1) additional space complexity if possible. - Consider edge cases such as empty lists or single-node lists. Scenario Imagine you are developing an application to analyze DNA sequences. To verify if a given DNA strand\'s base sequences form a palindrome, you convert the sequence into a linked list and use your function to check. This ensures that data integrity aligns forward and backward, significantly essential in genetic studies. # Evaluation Criteria - Correctness: Ensuring the correct determination of the palindrome property. - Efficiency: Implementing a solution with optimal time and space complexity. - Edge Case Handling: Appropriately managing scenarios like zero or single elements.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def is_palindrome_linked_list(head) -> bool: # Function to reverse a linked list and return the new head def reverse_list(node): prev = None while node: nxt = node.next node.next = prev prev = node node = nxt return prev # Find the midpoint of the linked list using the slow and fast pointers slow = fast = head while fast and fast.next: slow = slow.next fast = fast.next.next # Reverse the second half of the linked list head_second_half = reverse_list(slow) copy_head_second_half = head_second_half # Compare the first half with the reversed second half while head_second_half: if head.val != head_second_half.val: return False head = head.next head_second_half = head_second_half.next # Restore the original list (optional but generally good practice) reverse_list(copy_head_second_half) return True"},{"question":"**Question**: A company needs to sort their extensive list of product IDs in ascending order for quick lookup. They have chosen to implement Quick Sort for this task due to its efficiency on average. Your goal is to implement the Quick Sort algorithm in Python. **Function Signature**: ```python def quick_sort(arr: List[int]) -> List[int]: pass ``` **Input/Output Formats**: - **Input**: - `arr`: A list of integers (product IDs) which need to be sorted. - Example: `[34, 7, 23, 32, 5, 62]` - **Output**: - A new list with the integers sorted in ascending order. - Example: `[5, 7, 23, 32, 34, 62]` **Constraints**: - The length of `arr` will be at most (10^5). - Each integer in `arr` will be in the range ([-10^9, 10^9]). **Performance Requirements**: - The implementation should aim for an average case time complexity of (O(n log n)). - Ensure that your solution handles the worst case scenario (selecting bad pivots) gracefully.","solution":"from typing import List def quick_sort(arr: List[int]) -> List[int]: Sort the array of integers using the Quick Sort algorithm and return the sorted array. if len(arr) <= 1: return arr pivot = arr[len(arr) // 2] left = [x for x in arr if x < pivot] middle = [x for x in arr if x == pivot] right = [x for x in arr if x > pivot] return quick_sort(left) + middle + quick_sort(right)"},{"question":"# Encode and Decode List of Strings Task You are required to implement two functions: `encode` and `decode` to handle encoding and decoding of a list of strings. Function Specifications 1. `encode(strs: List[str]) -> str`: - **Input**: A list of strings (`strs`). - **Output**: A single string that encodes the list of strings. 2. `decode(s: str) -> List[str]`: - **Input**: A single string (`s`) that represents the encoded list of strings. - **Output**: The original list of strings. # Constraints - The input list of strings contains only ASCII characters and is non-null. - The length of each string is at most 100. Example ```python # Example 1: strs = [\\"hello\\", \\"world\\"] encoded_string = encode(strs) print(encoded_string) # Output: \'5:hello5:world\' decoded_list = decode(encoded_string) print(decoded_list) # Output: [\\"hello\\", \\"world\\"] # Example 2: strs = [\\"\\", \\"foo\\", \\"bar\\"] encoded_string = encode(strs) print(encoded_string) # Output: \'0:3:foo3:bar\' decoded_list = decode(encoded_string) print(decoded_list) # Output: [\\"\\", \\"foo\\", \\"bar\\"] ``` Performance Requirements - Your implementation must handle large datasets efficiently. - The solution should not use any additional data structures that exceed O(n) space complexity. Notes - Ensure to handle edge cases such as empty strings, strings containing delimiter characters, and long input. - Do not use built-in serialization libraries for the encode/decode functions.","solution":"def encode(strs): Encodes a list of strings into a single string. :param List[str] strs: List of strings to be encoded. :return: A single string representation of the encoded list of strings. :rtype: str return \'\'.join(f\'{len(s)}:{s}\' for s in strs) def decode(s): Decodes a single string into a list of strings. :param str s: A single string representation of the encoded list of strings. :return: The original list of strings. :rtype: List[str] i, n = 0, len(s) decoded = [] while i < n: j = i while s[j].isdigit(): j += 1 length = int(s[i:j]) decoded.append(s[j+1:j+1+length]) i = j + 1 + length return decoded"},{"question":"**Context:** You are working with a highly inefficient sorting algorithm known as Bogo Sort. Although impractical for real applications due to its random nature and excessive time complexity, Bogo Sort is a useful academic example to illustrate the importance of choosing efficient algorithms. **Task:** Implement the Bogo Sort algorithm as a function. Your function should take an unsorted list of integers and attempt to sort it by repeatedly shuffling the list and checking if it is sorted. Additionally, implement a function to check if the array is sorted, as this will aid in the shuffling process. # Function Signature: ```python def bogo_sort(arr: list) -> list: pass ``` # Input: * `arr` (list of int): The list of integers to be sorted. # Output: * `list of int`: The sorted list of integers. # Constraints: * The length of `arr` will be at most 10 to prevent the function from running indefinitely on larger lists. # Example: ```python assert bogo_sort([3, 2, 4, 1]) == [1, 2, 3, 4] assert bogo_sort([1, 2, 3, 4]) == [1, 2, 3, 4] ``` > **Note**: While implementing this function, consider that Bogo Sort could take a significant amount of time due to its nature, especially for arrays close to the upper limit of the constraint. **Bonus Challenge**: Implement an optional simulation mode that prints each iteration of shuffling and checking in a human-readable format. # Function Signature for Simulation Mode: ```python def bogo_sort(arr: list, simulation: bool = False) -> list: pass ``` **Example with Simulation Mode**: ```python bogo_sort([3, 2, 1], True) # Expected console output: # iteration 0: 3 2 1 # iteration 1: 1 3 2 # iteration 2: 1 2 3 ```","solution":"import random def is_sorted(arr): for i in range(len(arr) - 1): if arr[i] > arr[i + 1]: return False return True def bogo_sort(arr, simulation=False): def shuffle(arr): random.shuffle(arr) return arr iteration = 0 while not is_sorted(arr): if simulation: print(f\\"iteration {iteration}: {arr}\\") arr = shuffle(arr) iteration += 1 if simulation: print(f\\"iteration {iteration} (sorted): {arr}\\") return arr"},{"question":"You are working with an e-commerce company that needs to sort product ratings to display the most positively reviewed products at the top of their listings. You have been asked to write an efficient function to sort these ratings using the Cocktail Shaker Sort algorithm. Write a function `cocktail_shaker_sort` that takes an array of integers representing product ratings, and returns the array sorted in ascending order. Implement the Cocktail Shaker Sort algorithm to do so. # Function Signature ```python def cocktail_shaker_sort(arr: list[int]) -> list[int]: ``` # Input * An array `arr` of integers, where `1 <= len(arr) <= 10^5`. Each integer rating will be between `-10^3` and `10^3`. # Output * Return the sorted array in ascending order of the ratings. # Constraints * The function must use the Cocktail Shaker Sort algorithm. # Example Example 1: **Input**: `[3, 0, 2, 5, -1, 4, 1]` **Output**: `[-1, 0, 1, 2, 3, 4, 5]` Example 2: **Input**: `[1, 2, 3, 4, 5, 6, 7, 8, 9]` **Output**: `[1, 2, 3, 4, 5, 6, 7, 8, 9]` Example 3: **Input**: `[4, 3, 2, 1]` **Output**: `[1, 2, 3, 4]` # Notes * The provided function must handle edge cases, such as already sorted arrays and arrays with identical elements efficiently. * The performance constraints ensure that the function should handle up to 100,000 elements efficiently.","solution":"def cocktail_shaker_sort(arr: list[int]) -> list[int]: Sorts an array of integers using the Cocktail Shaker Sort algorithm and returns the sorted array. if not arr: return [] n = len(arr) start = 0 end = n - 1 swapped = True while swapped: swapped = False for i in range(start, end): if arr[i] > arr[i + 1]: arr[i], arr[i + 1] = arr[i + 1], arr[i] swapped = True if not swapped: break swapped = False end -= 1 for i in range(end, start, -1): if arr[i] < arr[i - 1]: arr[i], arr[i - 1] = arr[i - 1], arr[i] swapped = True start += 1 return arr"},{"question":"# Binary Search Tree Extended - Range Query **Problem Statement:** You are required to enhance the functionality of the provided Binary Search Tree (BST) implementation by adding a method `range_query` that retrieves all the values in the tree within a given range `[low, high]`. **Function Signature:** ```python def range_query(self, low: int, high: int) -> List[int]: ``` **Input:** - `low` (int) - the lower bound of the range (inclusive). - `high` (int) - the upper bound of the range (inclusive). **Output:** - Returns a List of integers containing all the elements of the tree that lie within the given range `[low, high]`. **Constraints:** - `low <= high` - The tree holds integer values, 0 <= tree size <= 1000. - The BST is not necessarily balanced. **Example:** Given BST (Same as provided): ``` 10 / 6 15 / / 4 9 12 24 / / 7 20 30 / 18 ``` 1. `range_query(5, 15)` should return `[6, 7, 9, 10, 12, 15]` 2. `range_query(18, 24)` should return `[18, 20, 24]` 3. `range_query(25, 50)` should return `[30]` **Tasks:** 1. **Extend the `BST` class** to include the `range_query` method. 2. **Write robust test cases** to validate your implementation, covering edge cases like empty trees, single-node trees, and full ranges. --- Create an appropriate **unit test** within the provided test framework to validate your implementation of the `range_query` function. **Note**: Ensure your solution adheres to expected time complexity constraints.","solution":"class TreeNode: def __init__(self, key): self.left = None self.right = None self.val = key class BinarySearchTree: def __init__(self): self.root = None def insert(self, key): if self.root is None: self.root = TreeNode(key) else: self._insert(self.root, key) def _insert(self, root, key): if key < root.val: if root.left is None: root.left = TreeNode(key) else: self._insert(root.left, key) else: if root.right is None: root.right = TreeNode(key) else: self._insert(root.right, key) def range_query(self, low, high): result = [] self._range_query_helper(self.root, low, high, result) return result def _range_query_helper(self, node, low, high, result): if node is None: return if low <= node.val: self._range_query_helper(node.left, low, high, result) if low <= node.val <= high: result.append(node.val) if node.val <= high: self._range_query_helper(node.right, low, high, result)"},{"question":"Context You are designing an efficient software interface to compute the reachability matrix for any given directed graph. Reachability in graphs is crucial for understanding information flow, identifying critical nodes, and simplifying complex network structures. Task Implement a method to compute the transitive closure of a directed graph using the given graph data structure and methods. The graph will be provided as an adjacency list, and your task is to provide the reachability matrix indicating direct or indirect paths between graph nodes. Function Signature ```python def transitive_closure(vertices: int, edges: List[Tuple[int, int]]) -> List[List[int]]: pass ``` Input * `vertices` (int): The number of vertices in the graph (V). Vertices are labeled from 0 to (V-1). * `edges` (List[Tuple[int, int]]): A list of tuples representing directed edges in the graph where each tuple (u, v) means there is an edge from vertex (u) to vertex (v). Output * List[List[int]]: A 2D list (matrix) of size (V times V) representing the transitive closure of the graph where matrix[i][j] is 1 if there is a path from vertex (i) to vertex (j), otherwise 0. Constraints 1. (1 leq V leq 100) 2. (0 leq text{len(edges)} leq V(V-1)) Example ```python vertices = 4 edges = [(0, 1), (1, 2), (2, 0), (2, 3)] # returns: # [ # [1, 1, 1, 1], # [1, 1, 1, 1], # [1, 1, 1, 1], # [0, 0, 0, 1] # ] transitive_closure(vertices, edges) ``` Explanation In the given example graph: - Vertex 0 can reach itself, 1 (direct), 2 (through 1), and 3 (through 1 and 2). - Vertex 1 can reach itself, 0 (through 2), 1 (itself), 2 (direct), and 3 (through 2). - Vertex 2 can reach itself, 0 (direct), 1 (through 0), 2 (itself), 3 (direct). - Vertex 3 can only reach itself (no other paths available). Notes Be careful with the initialization of the closure matrix and make sure to test edge cases such as isolated vertices or densely connected graphs. Ensure that the graph structure handles indices correctly and does not contain invalid vertices.","solution":"from typing import List, Tuple def transitive_closure(vertices: int, edges: List[Tuple[int, int]]) -> List[List[int]]: Returns the transitive closure matrix for a given directed graph. The transitive closure of a graph is a matrix where matrix[i][j] is 1 if there is a path from vertex i to vertex j, and 0 otherwise. # Initialize the reachability matrix reach = [[0 for _ in range(vertices)] for _ in range(vertices)] # Add direct edges to the reachability matrix for u, v in edges: reach[u][v] = 1 # Every vertex can reach itself for i in range(vertices): reach[i][i] = 1 # Update the matrix based on the transitive property for k in range(vertices): for i in range(vertices): for j in range(vertices): reach[i][j] = reach[i][j] or (reach[i][k] and reach[k][j]) return reach"},{"question":"Hash tables are a fundamental data structure, providing efficient key-value lookups. You will implement a `ResizableHashTable` class that supports dynamic resizing, and provide clear instructions for the operations `put`, `get`, and `del_`, ensuring it works efficiently even as the number of entries grows. The `ResizableHashTable` should follow these rules: 1. **Insertion (`put`)**: Insert a key-value pair. If the key already exists, update its value. 2. **Lookup (`get`)**: Retrieve the value associated with a given key. Return `None` if the key does not exist. 3. **Deletion (`del_`)**: Remove a key-value pair by its key. If the key is not found, return `None`. 4. **Resizing**: Double the size of the table when it exceeds the two-thirds capacity. The `ResizableHashTable` inherits `HashTable`\'s behaviors and implements additional resizing logic. Implement these functions: ```python class ResizableHashTable(HashTable): def put(self, key, value): Insert or update the key-value pair. Resize the table when needed. # Your code here def __resize(self): Double the table size and rehash all current entries. # Your code here ``` # Constraints * Key values are non-negative integers. * The table initially has a size of 8 (e.g., `MIN_SIZE = 8`). # Input/Output Format * **put(key: int, value: Any) -> None** * Insert the `key` with `value` into the hash table. * **get(key: int) -> Any** * Return the value associated with the `key`. * Return `None` if the key does not exist. * **del_(key: int) -> None** * Remove the `key` and its value from the hash table. * Return `None` if the key does not exist. # Example ```python ht = ResizableHashTable() ht.put(10, \'Value10\') print(ht.get(10)) # Output: \'Value10\' ht.put(10, \'Value20\') print(ht.get(10)) # Output: \'Value20\' ht.del_(10) print(ht.get(10)) # Output: None ``` Test your implementation thoroughly to ensure it handles edge cases, such as trying to get or delete non-existent keys, and resizing efficiently when needed. # Note Ensure your implementation is efficient and handles operations in average O(1) time complexity, and resizing in O(n).","solution":"class HashTable: def __init__(self, size=8): self.size = size self.table = [None] * size self.entries = 0 self.MIN_SIZE = 8 def hash_function(self, key): return key % self.size def put(self, key, value): index = self.hash_function(key) while self.table[index] is not None and self.table[index][0] != key: index = (index + 1) % self.size if self.table[index] is None: self.entries += 1 self.table[index] = (key, value) def get(self, key): index = self.hash_function(key) while self.table[index] is not None: if self.table[index][0] == key: return self.table[index][1] index = (index + 1) % self.size return None def del_(self, key): index = self.hash_function(key) while self.table[index] is not None: if self.table[index][0] == key: self.table[index] = None self.entries -= 1 return index = (index + 1) % self.size return None class ResizableHashTable(HashTable): def put(self, key, value): super().put(key, value) if self.entries >= (2 * self.size // 3): self.__resize() def __resize(self): old_table = self.table self.size *= 2 self.table = [None] * self.size self.entries = 0 for item in old_table: if item is not None: super().put(item[0], item[1])"},{"question":"# Stack Data Structure Implementation and Use Case Background You have learnt about the stack abstract data type (ADT) and its different implementations. Stacks are widely used in various applications like expression evaluation and backtracking algorithms. In this assessment, you are required to implement both array-based and linked-list-based stacks and then solve a practical problem using one of these implementations. Task 1. **Implement Two Stack Classes**: - `ArrayStack`: Use a dynamic array to implement stack operations. - `LinkedListStack`: Use linked nodes to implement stack operations. 2. **Practical Application**: Next Greater Element - Given an array of integers, find the next greater element for each element in the array. The next greater element for an element x in the array is the first greater element on the right side of x in the array. If no such element exists, output -1 for that position. - Implement the function `next_greater_element(arr: List[int]) -> List[int]`. Requirements 1. **ArrayStack Class**: - Implement the stack operations: `push(item)`, `pop()`, `peek()`, `is_empty()`. - Ensure dynamic resizing works correctly. 2. **LinkedListStack Class**: - Implement the stack operations: `push(item)`, `pop()`, `peek()`, `is_empty()`. 3. **Next Greater Element Function**: - Use one of your stack implementations to solve the problem. - Input: `arr` (a list of integers) - Output: A list of integers where each element is the next greater element or -1 if no such element exists. Constraints - The input array `arr` will have a length between 1 and 10^4. - Each element in `arr` can be between -10^5 and 10^5. Example ``` Input: [4, 5, 2, 25] Output: [5, 25, 25, -1] Input: [13, 7, 6, 12] Output: [-1, 12, 12, -1] ``` Function Signature ```python from typing import List class ArrayStack: # Your implementation here class LinkedListStack: # Your implementation here def next_greater_element(arr: List[int]) -> List[int]: # Your implementation here ```","solution":"from typing import List, Optional class ArrayStack: def __init__(self): self._data = [] def push(self, item): self._data.append(item) def pop(self): if self.is_empty(): raise IndexError(\\"pop from empty stack\\") return self._data.pop() def peek(self): if self.is_empty(): return None return self._data[-1] def is_empty(self): return len(self._data) == 0 class LinkedListStack: class Node: def __init__(self, value=None, next_node=None): self.value = value self.next = next_node def __init__(self): self.head = None def push(self, item): new_node = self.Node(item, self.head) self.head = new_node def pop(self): if self.is_empty(): raise IndexError(\\"pop from empty stack\\") value = self.head.value self.head = self.head.next return value def peek(self): if self.is_empty(): return None return self.head.value def is_empty(self): return self.head is None def next_greater_element(arr: List[int]) -> List[int]: stack = ArrayStack() # You can switch to LinkedListStack() if desired result = [-1] * len(arr) for i in range(len(arr) - 1, -1, -1): while not stack.is_empty() and stack.peek() <= arr[i]: stack.pop() if not stack.is_empty(): result[i] = stack.peek() stack.push(arr[i]) return result"},{"question":"Implement a Queue using Two Stacks Consider a scenario where you are implementing a queue but with a constraint that you can only use stacks to manage the elements. The goal is to simulate the behavior of a queue (FIFO - First In, First Out) with stacks (LIFO - Last In, First Out). Requirements: 1. **enqueue**: Adds an element to the end of the queue. 2. **dequeue**: Removes the element from the front of the queue. 3. **peek**: Returns the element at the front of the queue without removing it. 4. **is_empty**: Checks if the queue is empty or not. Implement this queue using two stacks to maintain the order and functionality specified. # Input and Output Formats * **enqueue(x)**: Inputs an integer x, adds it to the end of the queue. * **dequeue()**: Removes and returns the element at the front of the queue. * **peek()**: Returns the element at the front without removing it. * **is_empty()**: Returns a boolean indicating whether the queue is empty. # Constraints: * All operations should be efficient and designed keeping in mind space and time complexities. * The queue operations should maintain their average time complexity of O(1). # Example ```python queue = MyQueue() queue.enqueue(1) queue.enqueue(2) print(queue.peek()) # Output: 1 print(queue.dequeue()) # Output: 1 print(queue.is_empty()) # Output: False ``` # Implementation Note: * Use two stacks to handle the enqueue and dequeue operations efficiently. * Think about how to transfer elements between the two stacks to maintain the queue order.","solution":"class MyQueue: def __init__(self): Initialize your data structure here. self.stack1 = [] self.stack2 = [] def _transfer(self): Transfer all elements from stack1 to stack2. This is used to reverse the order for correct dequeue and peek operations. while self.stack1: self.stack2.append(self.stack1.pop()) def enqueue(self, x): Adds an element to the end of the queue. self.stack1.append(x) def dequeue(self): Removes the element from the front of the queue and returns that element. if not self.stack2: self._transfer() return self.stack2.pop() def peek(self): Get the front element. if not self.stack2: self._transfer() return self.stack2[-1] def is_empty(self): Returns whether the queue is empty. return not self.stack1 and not self.stack2"},{"question":"Given a string representing a well-formed Roman numeral, write a function `convert_roman_to_int(roman: str) -> int` that converts the Roman numeral into its corresponding integer value. # Guidelines: 1. Roman numerals are represented by seven different symbols: `I, V, X, L, C, D, M`. 2. The value of each symbol is: - `I` = 1 - `V` = 5 - `X` = 10 - `L` = 50 - `C` = 100 - `D` = 500 - `M` = 1000 3. Roman numerals are usually written largest to smallest from left to right. However, numeral combinations such as `IV` (4) and `IX` (9) means that there are exceptions where a smaller numeral appears before a larger numeral. # Input: - The function will receive a string `roman` which is a valid Roman numeral between 1 and 3999. # Output: - Return an integer representing the equivalent of the Roman numeral. # Constraints: - The input will be a valid Roman numeral string from 1 to 3999, thus no need for input validation for this problem\'s scope. - Performance should be optimal within the given range. # Examples: ```python assert convert_roman_to_int(\\"III\\") == 3 assert convert_roman_to_int(\\"IV\\") == 4 assert convert_roman_to_int(\\"IX\\") == 9 assert convert_roman_to_int(\\"LVIII\\") == 58 assert convert_roman_to_int(\\"MCMXCIV\\") == 1994 ``` # Scenario: Imagine you are designing a software system for a museum that accepts visitor input using Roman numerals. Your task is to ensure these inputs are correctly parsed into integers so that further operations (e.g., ticket pricing, age calculation) can be performed accurately. **Note:** Make sure your function efficiently handles the requirements and constraints specified. Consider simplifying steps while ensuring the correct conversion logic.","solution":"def convert_roman_to_int(roman): Convert a well-formed Roman numeral to an integer. :param roman: A string representing a Roman numeral. :return: An integer corresponding to the Roman numeral. # Mapping of Roman numerals to their integer values roman_to_int_map = { \'I\': 1, \'V\': 5, \'X\': 10, \'L\': 50, \'C\': 100, \'D\': 500, \'M\': 1000, \'IV\': 4, \'IX\': 9, \'XL\': 40, \'XC\': 90, \'CD\': 400, \'CM\': 900 } i = 0 num = 0 while i < len(roman): # Check if the current character and the next character form a subtractive combination if i+1 < len(roman) and roman[i:i+2] in roman_to_int_map: num += roman_to_int_map[roman[i:i+2]] i += 2 else: num += roman_to_int_map[roman[i]] i += 1 return num"},{"question":"# Heap Sort Implementation and Analysis As a data scientist, you are working on a feature that requires the efficient sorting of large datasets. Given your understanding of the Heap Sort algorithm, we would like you to implement a function that sorts an array using a max heap, and another using a min heap. Additionally, you should analyze the performance of your implementations at various stages to ensure they meet the required time complexity. Requirements 1. Implement two functions, `max_heap_sort_with_simulation` and `min_heap_sort_with_simulation`, that sort arrays using max heap and min heap, respectively. 2. Both functions should be able to print the array at each iteration of the sorting process if a `simulation` flag is set to `True`. 3. Ensure your functions handle edge cases gracefully. Function Signatures ```python def max_heap_sort_with_simulation(arr, simulation=False): Sort an array using the max heap sort algorithm with optional simulation output. :param arr: List of integers to sort. :param simulation: Boolean flag for printing the array at each iteration. :return: Sorted list in ascending order. pass def min_heap_sort_with_simulation(arr, simulation=False): Sort an array using the min heap sort algorithm with optional simulation output. :param arr: List of integers to sort. :param simulation: Boolean flag for printing the array at each iteration. :return: Sorted list in ascending order. pass ``` Example ```python arr = [3, 1, 5, 2, 4] # Using max heap sorted_max_heap = max_heap_sort_with_simulation(arr, simulation=True) print(\\"Max Heap Sorted Array:\\", sorted_max_heap) # Output should show the array at each step and then: # Max Heap Sorted Array: [1, 2, 3, 4, 5] # Using min heap sorted_min_heap = min_heap_sort_with_simulation(arr, simulation=True) print(\\"Min Heap Sorted Array:\\", sorted_min_heap) # Output should show the array at each step and then: # Min Heap Sorted Array: [1, 2, 3, 4, 5] ``` Constraints 1. Assume the array consists of integers only. 2. Time complexity should be O(n log n). 3. Space complexity should be O(1). Performance Checks 1. Ensure the functions correctly handle arrays with a single element. 2. Ensure performance remains optimal for larger arrays. Provide a well-commented implementation and discuss any considerations or challenges faced during the coding process.","solution":"def max_heapify(arr, n, i, simulation): largest = i left = 2 * i + 1 right = 2 * i + 2 if left < n and arr[largest] < arr[left]: largest = left if right < n and arr[largest] < arr[right]: largest = right if largest != i: arr[i], arr[largest] = arr[largest], arr[i] if simulation: print(arr) max_heapify(arr, n, largest, simulation) def max_heap_sort_with_simulation(arr, simulation=False): n = len(arr) for i in range(n // 2 - 1, -1, -1): max_heapify(arr, n, i, simulation) for i in range(n-1, 0, -1): arr[i], arr[0] = arr[0], arr[i] if simulation: print(arr) max_heapify(arr, i, 0, simulation) return arr def min_heapify(arr, n, i, simulation): smallest = i left = 2 * i + 1 right = 2 * i + 2 if left < n and arr[smallest] > arr[left]: smallest = left if right < n and arr[smallest] > arr[right]: smallest = right if smallest != i: arr[i], arr[smallest] = arr[smallest], arr[i] if simulation: print(arr) min_heapify(arr, n, smallest, simulation) def min_heap_sort_with_simulation(arr, simulation=False): n = len(arr) for i in range(n // 2 - 1, -1, -1): min_heapify(arr, n, i, simulation) for i in range(n-1, 0, -1): arr[i], arr[0] = arr[0], arr[i] if simulation: print(arr) min_heapify(arr, i, 0, simulation) arr.reverse() return arr"},{"question":"Merging Multiple Sorted Linked Lists Objective Implement a function to merge k sorted linked lists into one sorted linked list efficiently. Function Signature ```python class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def merge_k_lists(lists: List[ListNode]) -> ListNode: pass ``` Input - `lists`: A list of `k` sorted linked lists (where `k` >= 1, and each list can be of length 0 or greater). - Each node of the linked lists is an instance of `ListNode`, defined with `val` (integer value) and `next` (pointer to the next node). Output - A single linked list containing all the nodes from the input lists merged into sorted order. Constraints - The number of nodes in total across all k lists is in the range `[0, 10^5]`. Example ```python # Example 1: l1 = ListNode(1, ListNode(4, ListNode(5))) l2 = ListNode(1, ListNode(3, ListNode(4))) l3 = ListNode(2, ListNode(6)) lists = [l1, l2, l3] result = merge_k_lists(lists) # Output: 1 -> 1 -> 2 -> 3 -> 4 -> 4 -> 5 -> 6 # The function should return the head of the linked list composed of nodes in the order: [1, 1, 2, 3, 4, 4, 5, 6] ``` Performance Requirements - The implementation should aim for an optimal time complexity of O(N log k), where N is the total number of nodes across all lists and k is the number of lists. - Space complexity should be optimized, ideally O(k). Additional Notes - Consider edge cases such as empty input lists, lists with single nodes, and very large `k` values. - Ensure to maintain the stability of the merge process, preserving the original relative order of nodes where possible.","solution":"import heapq class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def merge_k_lists(lists: list) -> ListNode: min_heap = [] # Push the head of each list along with its index onto the heap for i, li in enumerate(lists): if li: heapq.heappush(min_heap, (li.val, i, li)) dummy = ListNode() current = dummy while min_heap: val, i, node = heapq.heappop(min_heap) current.next = ListNode(val) current = current.next if node.next: heapq.heappush(min_heap, (node.next.val, i, node.next)) return dummy.next"},{"question":"# Context You are given a sorted list of unique integers and need to summarize the range they cover. This task is common in various scenarios, including summarizing continuous ranges in data logs, efficient representation of sequential events, or interval summarization in reports. # Objective Implement a function `summarize_ranges` that takes a list of sorted unique integers as input and returns a list of strings that consolidate consecutive numbers into ranges. # Function Signature ```python def summarize_ranges(array: List[int]) -> List[str]: pass ``` # Input - `array`: A sorted list of unique integers `[a1, a2, ..., an]` where `0 <= ai <= 10^4`. # Output - A list containing ranges as strings in the format `\\"start-end\\"` for groups of consecutive numbers, and single numbers as `\\"start\\"` where there is no range. # Constraints 1. The input list is sorted in non-decreasing order. 2. The input list contains no duplicates. 3. Length of the input list is between 1 and 1000 inclusive. # Example ```python assert summarize_ranges([0, 1, 2, 4, 5, 7]) == [\'0-2\', \'4-5\', \'7\'] assert summarize_ranges([1, 2, 3, 7, 8, 10]) == [\'1-3\', \'7-8\', \'10\'] assert summarize_ranges([5, 6, 7, 8]) == [\'5-8\'] assert summarize_ranges([1]) == [\'1\'] assert summarize_ranges([2, 4, 6, 8]) == [\'2\', \'4\', \'6\', \'8\'] ```","solution":"from typing import List def summarize_ranges(array: List[int]) -> List[str]: if not array: return [] ranges = [] start = array[0] end = array[0] for num in array[1:]: if num == end + 1: end = num else: if start == end: ranges.append(f\\"{start}\\") else: ranges.append(f\\"{start}-{end}\\") start = num end = num if start == end: ranges.append(f\\"{start}\\") else: ranges.append(f\\"{start}-{end}\\") return ranges"},{"question":"# Problem: Longest Increasing Subsequence with Optimizations # Task: Given an unsorted array of integers, write a function to find the length of the longest increasing subsequence using an optimized approach involving sorting and segment trees. # Function Signature: ```python def optimized_longest_increasing_subsequence(sequence: List[int]) -> int: ``` # Input: * `sequence`: A list of integers representing the unsorted sequence. - Length: (1 leq n leq 10^5) - Element values: (1 leq text{sequence}[i] leq 10^9) # Output: * An integer representing the length of the longest increasing subsequence. # Constraints: * Your solution should be efficient enough to handle the given constraints (both time and space). # Objective: * Efficiently compute the length of the longest increasing subsequence while utilizing optimized segment tree operations and canonical sorting techniques. # Scenario: You are designing a gaming score system where you need to determine the longest increasing scoring sequence. To ensure the system performance, you need to implement an optimized algorithm to compute this sequence length efficiently. # Example: ```python # Example 1 assert optimized_longest_increasing_subsequence([10,9,2,5,3,7,101,18]) == 4 # The longest increasing subsequence is [2,3,7,101] # Example 2 assert optimized_longest_increasing_subsequence([1,3,6,7,9,4,10,5,6]) == 6 # The longest increasing subsequence is [1,3,4,5,6,10] # Example 3 assert optimized_longest_increasing_subsequence([]) == 0 # No elements in the sequence. ``` # Notes: 1. Consider sorting the sequence logically to simplify the segment tree operations. 2. Carefully manage the segment tree to update and query subsequence lengths efficiently. Happy Coding!","solution":"from bisect import bisect_left from typing import List def optimized_longest_increasing_subsequence(sequence: List[int]) -> int: if not sequence: return 0 subsequence = [] for num in sequence: pos = bisect_left(subsequence, num) if pos == len(subsequence): subsequence.append(num) else: subsequence[pos] = num return len(subsequence)"},{"question":"# Question: Given the analysis of the above matrix transformation functions, your task is to implement an efficient function `rotate_matrix` that performs a 90-degree clockwise rotation on an `n x m` matrix. Additionally, you need to handle edge cases such as non-uniform row lengths by maintaining uniformity in the result. Function Signature: ```python def rotate_matrix(matrix: List[List[int]]) -> List[List[int]]: ``` # Input: - `matrix`: A list of lists where each inner list represents a row of the matrix. # Output: - A new matrix that has been rotated 90 degrees clockwise. # Constraints: - Each row of the matrix may have a different length, but every element is an integer. - The function should handle matrices up to size 1000 x 1000 efficiently. - If the input matrix is empty, the output should also be an empty matrix. # Example: The following examples illustrate the expected behavior of the function: ```python # Example 1 matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] print(rotate_matrix(matrix)) # Output: # [ # [7, 4, 1], # [8, 5, 2], # [9, 6, 3] # ] # Example 2 matrix = [ [1, 2], [3, 4, 5], [6, 7] ] print(rotate_matrix(matrix)) # Output: # [ # [6, 3, 1], # [7, 4, 2], # [None, 5, None] # ] ``` Notes: - Assume `None` values in the rotated matrix where original rows were not uniform. This means while rotating, if any row of the matrix is shorter, fill the extra spaces with `None`. - Ensure optimal performance for large matrices. Good luck!","solution":"from typing import List def rotate_matrix(matrix: List[List[int]]) -> List[List[int]]: if not matrix: return [] # Find the maximum length of the rows in the matrix max_length = max(len(row) for row in matrix) # Normalize the matrix by adding None to rows with length less than max_length normalized_matrix = [row + [None] * (max_length - len(row)) for row in matrix] # Perform the 90-degree clockwise rotation rotated_matrix = [] for col in range(max_length): new_row = [] for row in range(len(normalized_matrix) - 1, -1, -1): new_row.append(normalized_matrix[row][col]) rotated_matrix.append(new_row) return rotated_matrix"},{"question":"You are given a singly linked list where each node contains an integer value. Your task is to write two functions to remove duplicate values from this linked list. Function 1: `remove_dups(head)` This function should remove duplicates using an additional data structure (e.g., a hashset). Function 2: `remove_dups_without_set(head)` This function should remove duplicates without using any additional data structure. # Requirements: 1. **Function 1** should aim for a time complexity of O(N) and space complexity of O(N). 2. **Function 2** should aim for a time complexity of O(N^2) and space complexity of O(1). # Input: - `head` (Node): Reference to the head of the linked list. # Output: - Modify the linked list in place to remove duplicates. No explicit return is necessary. # Constraints: - The linked list can have up to 10^5 nodes. - Each node value is an integer between -10^9 and 10^9. # Example: Consider the following singly linked list: ``` 1 -> 2 -> 3 -> 1 -> 2 -> 4 ``` After removing duplicates using `remove_dups`: ``` 1 -> 2 -> 3 -> 4 ``` After removing duplicates using `remove_dups_without_set`: ``` 1 -> 2 -> 3 -> 4 ``` # Implementation: To verify your implementation, write the following helper functions: 1. **print_linked_list(head)**: Prints the values in the linked list in order. 2. **create_linked_list(values)**: Creates a linked list from a list of values and returns the head node.","solution":"class Node: def __init__(self, value): self.value = value self.next = None def remove_dups(head): if not head: return seen = set() current = head seen.add(current.value) while current.next: if current.next.value in seen: current.next = current.next.next else: seen.add(current.next.value) current = current.next def remove_dups_without_set(head): if not head: return current = head while current: runner = current while runner.next: if runner.next.value == current.value: runner.next = runner.next.next else: runner = runner.next current = current.next def print_linked_list(head): if not head: print(\\"None\\") return current = head while current: print(current.value, end=\\" -> \\" if current.next else \\"\\") current = current.next print() def create_linked_list(values): if not values: return None head = Node(values[0]) current = head for value in values[1:]: current.next = Node(value) current = current.next return head"},{"question":"# Context You have been given the task of implementing an efficient data handling system for a large-scale database. The system needs to handle frequent insertions, deletions, and searches efficiently, even as the data grows. Given the requirements, a balanced multiway tree like the B-Tree is well-suited for this purpose. # Task Implement additional functionality for the B-Tree data structure. Specifically, you need to implement a function to count the number of keys within a given range `[low, high]` in the B-Tree. # Function Signature ```python def count_keys_in_range(tree: BTree, low: int, high: int) -> int: Counts the number of keys in the range [low, high] inclusive in the given B-Tree. :param tree: BTree object, representing the root of B-Tree. :param low: int, lower bound of range. :param high: int, upper bound of range. :return: int, number of keys in the specified range. ``` # Input - `tree`: An instance of `BTree` which represents the B-Tree. - `low`: An integer representing the lower bound of the range. - `high`: An integer representing the upper bound of the range. # Output - Returns an integer representing the number of keys in the specified range `[low, high]`. # Constraints - Assume that `low` <= `high`. - The number of nodes in the B-Tree does not exceed 10^5. # Example ```python # Example Usage btree = BTree(t_val=3) btree.insert_key(10) btree.insert_key(20) btree.insert_key(5) btree.insert_key(6) btree.insert_key(12) print(count_keys_in_range(btree, 6, 15)) # Output should be 3 (6, 10, 12) ``` # Notes - You should perform an in-order traversal of the B-Tree to ensure that keys are checked in a sorted manner. - Take into account edge cases such as empty trees or ranges that do not encompass any keys.","solution":"class BTreeNode: def __init__(self, t, leaf=False): self.t = t self.leaf = leaf self.keys = [] self.children = [] class BTree: def __init__(self, t): self.root = BTreeNode(t, True) self.t = t def insert_key(self, key): root = self.root if len(root.keys) == (2 * self.t - 1): temp = BTreeNode(self.t, False) temp.children.append(self.root) self._split_child(temp, 0) self._insert_non_full(temp, key) self.root = temp else: self._insert_non_full(root, key) def _insert_non_full(self, node, key): i = len(node.keys) - 1 if node.leaf: node.keys.append(None) while i >= 0 and key < node.keys[i]: node.keys[i + 1] = node.keys[i] i -= 1 node.keys[i + 1] = key else: while i >= 0 and key < node.keys[i]: i -= 1 i += 1 if len(node.children[i].keys) == (2 * self.t - 1): self._split_child(node, i) if key > node.keys[i]: i += 1 self._insert_non_full(node.children[i], key) def _split_child(self, parent, index): t = self.t child = parent.children[index] new_child = BTreeNode(child.t, child.leaf) parent.children.insert(index + 1, new_child) parent.keys.insert(index, child.keys[t - 1]) new_child.keys = child.keys[t:(2 * t - 1)] child.keys = child.keys[0:(t - 1)] if not child.leaf: new_child.children = child.children[t:(2 * t)] child.children = child.children[0:t] def count_keys_in_range(tree: BTree, low: int, high: int) -> int: def count_keys_in_node(node, low, high): count = 0 i = 0 while i < len(node.keys) and node.keys[i] < low: i += 1 while i < len(node.keys) and node.keys[i] <= high: count += 1 i += 1 if not node.leaf: for child in node.children: count += count_keys_in_node(child, low, high) return count return count_keys_in_node(tree.root, low, high)"},{"question":"# Context When dealing with very large sorted datasets, finding an element efficiently is crucial. A classic solution to this problem is the Binary Search algorithm, which reduces the search space by half iteratively or recursively, resulting in a logarithmic time complexity. This is extremely useful in scenarios requiring frequent lookups, such as database indexing or dictionary implementations. # Task Given a sorted array of integers and a target value, you need to implement the Binary Search algorithm to find the index of the target value. If the target value is not found, return -1. You need to implement both iterative and recursive versions of the binary search algorithm. # Function Signature ```python def binary_search_iterative(array: List[int], target: int) -> int: pass def binary_search_recursive(array: List[int], low: int, high: int, target: int) -> int: pass ``` # Input * `array` (List[int]): A list of sorted integers. * `target` (int): The integer value to search for. * For the recursive function, additionally: * `low` (int): The starting index of the search range. * `high` (int): The ending index of the search range. # Output * `int`: The index of the target value in the array. If the target is not found, return -1. # Constraints * `0 <= len(array) <= 10^5` * `-10^9 <= array[i], target <= 10^9` * The array is sorted in ascending order. # Examples Iterative Version ```python assert binary_search_iterative([1, 2, 3, 4, 5], 3) == 2 assert binary_search_iterative([1, 2, 3, 4, 5], 6) == -1 assert binary_search_iterative([], 1) == -1 ``` Recursive Version ```python assert binary_search_recursive([1, 2, 3, 4, 5], 0, 4, 3) == 2 assert binary_search_recursive([1, 2, 3, 4, 5], 0, 4, 6) == -1 assert binary_search_recursive([], 0, -1, 1) == -1 ``` # Notes * Ensure your implementation handles edge cases such as empty arrays and target values not present in the array. * Consider both performance and clarity in your implementation.","solution":"from typing import List def binary_search_iterative(array: List[int], target: int) -> int: Perform an iterative binary search to find the index of the target in the array. Parameters: array (List[int]): The sorted list of integers. target (int): The integer value to search for. Returns: int: The index of the target if found, otherwise -1. low, high = 0, len(array) - 1 while low <= high: mid = (low + high) // 2 if array[mid] == target: return mid elif array[mid] < target: low = mid + 1 else: high = mid - 1 return -1 def binary_search_recursive(array: List[int], low: int, high: int, target: int) -> int: Perform a recursive binary search to find the index of the target in the array. Parameters: array (List[int]): The sorted list of integers. low (int): The starting index for the current search range. high (int): The ending index for the current search range. target (int): The integer value to search for. Returns: int: The index of the target if found, otherwise -1. if low > high: return -1 mid = (low + high) // 2 if array[mid] == target: return mid elif array[mid] < target: return binary_search_recursive(array, mid + 1, high, target) else: return binary_search_recursive(array, low, mid - 1, target)"},{"question":"# Bit Flip Transformation Objective Write a function to determine the minimal number of bit positions that need to be flipped to convert an integer ( A ) to integer ( B ). Challenge Given two integers ( A ) and ( B ): 1. Identify how many bits differ between their binary representations. 2. Calculate the minimal count of bit flips required to make both integers identical. Implementation Create a function `bit_flip_count(A: int, B: int) -> int`: * **Input**: * A: An integer with value ≥ 0. * B: An integer with value ≥ 0. * **Output**: * An integer representing the minimal number of bit flips needed to transform ( A ) into ( B ). Example: 1. **Input**: ( A = 29 ), ( B = 15 ) * **Binary Representation**: * ( 29 -> 11101 ) * ( 15 -> 01111 ) * **Output**: `2` flips (positions 2 and 4 need flipping). Constraints * The integer values of ( A ) and ( B ) will be in the range [0, ( 2^{31} - 1 )]. Requirements * The solution should run efficiently with a time complexity of O(k), where k is the number of bits in the representation of the integers (up to 31 bits for the given range). Performance Expectations * Handle edge cases without significant performance penalties. Function Signature ```python def bit_flip_count(A: int, B: int) -> int: pass ```","solution":"def bit_flip_count(A: int, B: int) -> int: Calculate the minimal number of bit flips required to transform integer A into integer B. Parameters: A (int): The first integer. B (int): The second integer. Returns: int: The number of bit positions that need to be flipped to convert A to B. # XOR A and B to find the differing bits XOR = A ^ B # Count the number of 1 bits in the XOR result count = 0 while XOR: count += XOR & 1 # Add 1 if the least significant bit is 1 XOR >>= 1 # Right shift the XOR result by 1 return count"},{"question":"Given a number, write a function to find the next higher number which has the exact same set of digits as the original number. If no such number exists (i.e., the number is the highest permutation of its digits), return -1. # Function Signature ```python def next_bigger(num: int) -> int: Given a number, find the next higher number which has the same set of digits. :param num: An integer number to find the next permutation for. :return: The next higher number with the same digits, or -1 if no such number exists. ``` # Input/Output * **Input**: A single integer number `num` where ( 1 leq text{num} leq 10^9 ). * **Output**: An integer representing the next higher number with the same digits or -1 if no such number exists. # Examples * `next_bigger(38276)` -> 38627 * `next_bigger(12345)` -> 12354 * `next_bigger(54321)` -> -1 * `next_bigger(99999)` -> -1 # Constraints * You should consider typical edge cases like single digit numbers and numbers with repeated digits. * Your solution should aim for a time complexity of ( O(n) ), where `n` is the number of digits in the input number. # Additional Notes Write your function to handle the algorithm steps as follows: 1. Find the longest non-increasing suffix from the end of the number. 2. Locate the pivot where the first number is just before the suffix. 3. Find the smallest number in the suffix greater than the pivot, and swap them. 4. Reverse the suffix to get the next smallest lexicographic permutation.","solution":"def next_bigger(num: int) -> int: Given a number, find the next higher number which has the same set of digits. :param num: An integer number to find the next permutation for. :return: The next higher number with the same digits, or -1 if no such number exists. # Convert number to list of digits digits = list(str(num)) length = len(digits) # Find the longest non-increasing suffix i = length - 1 while i > 0 and digits[i - 1] >= digits[i]: i -= 1 if i == 0: return -1 # The number is the highest permutation of its digits # Let digits[i - 1] be the pivot. Find the smallest number in the suffix greater than the pivot j = length - 1 while digits[j] <= digits[i - 1]: j -= 1 # Swap the pivot with that smallest number digits[i - 1], digits[j] = digits[j], digits[i - 1] # Reverse the suffix digits[i:] = digits[i:][::-1] # Convert list of digits back to number next_number = int(\\"\\".join(digits)) return next_number"},{"question":"You are tasked with implementing a classification system using the Nearest Neighbor algorithm. Given a vector (x) and a training set (tSet), your objective is to find the closest neighbor to (x) in (tSet) using Euclidean distance, and return the label associated with that neighbor in (tSet). # Function Signature ```python def nearest_neighbor(x: Tuple[float, ...], tSet: Dict[Tuple[float, ...], Any]) -> Any: ``` # Input * `x`, a tuple representing a vector. * `tSet`, a dictionary wherein the keys are tuples representing vectors, and the values are their corresponding labels. # Output * Return the label of the vector in `tSet` that is closest to `x`. # Constraints 1. The length of tuples in `x` and keys in `tSet` are equal. 2. The training set `tSet` is non-empty. 3. All elements in the vectors are floats. 4. The implementation should be efficient enough to handle up to 10,000 vectors in `tSet`. # Example ```python x = (1.0, 2.0) tSet = { (2.0, 3.0): \\"Class_A\\", (3.0, 4.0): \\"Class_B\\", (1.1, 2.1): \\"Class_C\\" } assert nearest_neighbor(x, tSet) == \\"Class_C\\" ``` # Additional Notes * Ensure your function handles edge cases where (x) and vectors in (tSet) are identical. * Document your code and include comments explaining the logic.","solution":"import math from typing import Tuple, Dict, Any def euclidean_distance(p: Tuple[float, ...], q: Tuple[float, ...]) -> float: Calculate the Euclidean distance between two points p and q. return math.sqrt(sum((pi - qi) ** 2 for pi, qi in zip(p, q))) def nearest_neighbor(x: Tuple[float, ...], tSet: Dict[Tuple[float, ...], Any]) -> Any: Find the label of the closest vector to x in tSet using Euclidean distance. Parameters: x (Tuple[float, ...]): The input vector. tSet (Dict[Tuple[float, ...], Any]): The training set where the keys are vectors and the values are labels. Returns: Any: The label of the closest vector in tSet. # Initialize minimum distance to a large value and closest_label to None min_distance = float(\'inf\') closest_label = None # Iterate through each vector-label pair in the training set for vector, label in tSet.items(): # Compute the Euclidean distance between x and the current vector distance = euclidean_distance(x, vector) # Update the minimum distance and closest_label if a closer vector is found if distance < min_distance: min_distance = distance closest_label = label return closest_label"},{"question":"# **Context: Keyboard Row Words Validation** **Background:** You are building a text validation tool for a typing tutor application. The tool will help users practice typing words that can be formed using letters from a single row of the QWERTY keyboard. This ensures users focus on a specific set of keys during their practice session. **Task:** Implement a function `find_keyboard_row(words)` that returns only the words that can be typed using letters from one row of the QWERTY keyboard. The rows on an American QWERTY keyboard are defined as: 1. \\"QWERTYUIOP\\" 2. \\"ASDFGHJKL\\" 3. \\"ZXCVBNM\\" **Input:** * A list of strings `words` where each string represents a word. **Output:** * A list of strings, filtered to include only the words that can be typed using one of the specified rows of the keyboard. **Constraints:** * Function should be case-insensitive i.e., \\"Hello\\" and \\"hello\\" should be treated the same. * All input words contain only alphabetic characters. * List input size can range from 0 to 10^4 **Examples:** ```python Input: find_keyboard_row([\\"Hello\\", \\"Alaska\\", \\"Dad\\", \\"Peace\\"]) Output: [\\"Alaska\\", \\"Dad\\"] Input: find_keyboard_row([\\"type\\", \\"row\\", \\"python\\"]) Output: [\\"type\\", \\"row\\"] ``` **Performance Requirements:** The solution should be efficient in terms of time and space complexity, aiming for O(n * m) time complexity and O(m) space complexity where n is the number of words and m is the length of the longest word in input.","solution":"def find_keyboard_row(words): Filters the list of words to include only those that can be typed using one row of the QWERTY keyboard. rows = [ set(\\"QWERTYUIOPqwertyuiop\\"), set(\\"ASDFGHJKLasdfghjkl\\"), set(\\"ZXCVBNMzxcvbnm\\") ] result = [] for word in words: for row in rows: if set(word).issubset(row): result.append(word) break return result"},{"question":"A sequel-themed amusement park has a ride that displays numbers upside down using mechanical seven-segment displays. The park\'s engineers need a program to check if the scores displayed on the ride are the same when viewed upside down. Define and implement a function `is_strobogrammatic_ride_score(score: str) -> bool` to determine if a given ride score, represented as a string, is strobogrammatic. # Function Signature ```python def is_strobogrammatic_ride_score(score: str) -> bool: pass ``` # Input - A single string `score` where each character is a digit (\'0\'-\'9\'). # Output - Returns `True` if the number is strobogrammatic, and `False` otherwise. # Constraints - The string `score`\'s length will be between 1 and 10^5. - The input string will only contain numeric characters. # Example ```python is_strobogrammatic_ride_score(\\"69\\") # Returns True is_strobogrammatic_ride_score(\\"88\\") # Returns True is_strobogrammatic_ride_score(\\"962\\") # Returns False is_strobogrammatic_ride_score(\\"818\\") # Returns True ``` # Scenario Consider that you are working on the software for the ride\'s display system. You need to ensure the scores displayed are visually symmetric when viewed upside down to enhance the ride\'s magical experience. Your function will be integrated into the ride\'s software to validate all scores before they are displayed. Note: Optimize for performance given the potential large size of the input.","solution":"def is_strobogrammatic_ride_score(score: str) -> bool: Determines if the input score is strobogrammatic, meaning it looks the same when viewed upside down. :param score: A string representing a numeric score :return: True if the score is strobogrammatic, False otherwise strobogrammatic_pairs = {\'0\': \'0\', \'1\': \'1\', \'6\': \'9\', \'8\': \'8\', \'9\': \'6\'} left, right = 0, len(score) - 1 while left <= right: if score[left] not in strobogrammatic_pairs or strobogrammatic_pairs[score[left]] != score[right]: return False left += 1 right -= 1 return True"},{"question":"# Binary Exponentiation: Function Implementation Scenario You have been tasked to implement an efficient power function for a mathematical software library. The function should calculate the exponentiation of two integers using binary exponentiation, and optionally use modulo operation to keep the results manageable. This function must be efficient and handle large exponents gracefully. Your Task Write two functions, `power_iter(a: int, n: int, mod: int = None)` and `power_recur(a: int, n: int, mod: int = None)`, that implement the binary exponentiation algorithm in an iterative and recursive manner respectively. Input and Output * **Input**: * `a` (an integer) - the base number. * `n` (a non-negative integer) - the exponent. * `mod` (an optional integer) - the modulo. * **Output**: * The result of `a` raised to the power `n`, optionally modulo `mod`. Constraints * Do not use the built-in exponentiation functions (like `pow()` or `**`). * Assume all inputs are integers. * `mod` if provided, will be guaranteed to be a positive integer. Performance Requirements * Time Complexity must be O(log(n)). * Space Complexity for the iterative version must be O(1). * Space Complexity for the recursive version must be O(log(n)). Example Usage ```python # Iterative example print(power_iter(2, 10)) # Expected output: 1024 print(power_iter(2, 10, 1000)) # Expected output: 24 # Recursive example print(power_recur(2, 10)) # Expected output: 1024 print(power_recur(2, 10, 1000)) # Expected output: 24 ``` Notes * Be mindful of handling base cases such as power of 0. * Ensure both versions produce the same results for the same inputs.","solution":"def power_iter(a, n, mod=None): Calculate a^n using iterative binary exponentiation. If mod is provided, then calculate (a^n) % mod. result = 1 base = a if mod is not None: base %= mod while n > 0: if n % 2 == 1: result = result * base if mod is not None: result %= mod base = base * base if mod is not None: base %= mod n //= 2 return result def power_recur(a, n, mod=None): Calculate a^n using recursive binary exponentiation. If mod is provided, then calculate (a^n) % mod. if n == 0: return 1 half = power_recur(a, n // 2, mod) half = (half * half) % mod if mod is not None else half * half if n % 2 == 0: return half else: return (half * a) % mod if mod is not None else half * a"},{"question":"# Question: Find the Greatest Common Divisor using Bitwise Operations **Context**: You are working on an optimization project where performance and efficiency are key. Specifically, you need to compute the greatest common divisor (GCD) of two non-negative integers using the most efficient method possible. This needs to take into account memory usage and speed, given possible large integers. **Task**: Using the principles provided in the given algorithms, implement a function `efficient_gcd(a, b)` that calculates the GCD of two non-negative integers using bitwise operations. **Function Signature**: ```python def efficient_gcd(a: int, b: int) -> int: Given two non-negative integers `a` and `b`, return their greatest common divisor using bitwise operations. :param a: non-negative integer :param b: non-negative integer :return: GCD of `a` and `b` ``` **Input**: - Two non-negative integers `a` and `b`, where `0 <= a, b <= 10^9`. **Output**: - Return an integer that is the greatest common divisor of `a` and `b`. **Constraints**: - If both `a` and `b` are zero, return zero. - The implementation must utilize bitwise operations to calculate the GCD efficiently. **Examples**: 1. `efficient_gcd(48, 18) -> 6` 2. `efficient_gcd(54, 24) -> 6` 3. `efficient_gcd(0, 0) -> 0` 4. `efficient_gcd(0, 5) -> 5` 5. `efficient_gcd(7, 0) -> 7` **Performance Considerations**: - Aim to implement a solution with optimal time and space complexity. - Ensure the solution handles large integer values efficiently and within time constraints. **Note**: Provide clear comments and ensure your code is well-structured to facilitate readability and understanding.","solution":"def efficient_gcd(a, b): Given two non-negative integers `a` and `b`, return their greatest common divisor using bitwise operations. if a == 0: return b if b == 0: return a # `a` and `b` are both even if (a & 1) == 0 and (b & 1) == 0: return efficient_gcd(a >> 1, b >> 1) << 1 # `a` is even, `b` is odd if (a & 1) == 0: return efficient_gcd(a >> 1, b) # `a` is odd, `b` is even if (b & 1) == 0: return efficient_gcd(a, b >> 1) # `a` and `b` are both odd, reduce larger number if a > b: return efficient_gcd(a - b, b) return efficient_gcd(a, b - a)"},{"question":"# Linked List Node Insertion Challenge **Objective**: You are provided with a singly linked list structure. Your task is to write a function that inserts a node with a given value after a node with a specified value. This task will assess your understanding of linked list manipulations, especially insertion operations. **Function Specification**: ```python def insert_after_value(head: Node, target_value: int, new_value: int) -> Node: Inserts a new node with value new_value immediately after the first node that has the value target_value in the linked list starting at head. Parameters: head (Node): The head node of the singly linked list. target_value (int): The value of the node after which the new node will be inserted. new_value (int): The value of the new node to be inserted. Returns: Node: The head node of the potentially modified list. Raises: ValueError: If the target_value node is not found in the list. pass ``` # Input Format - `head`: Head of the singly linked list. - `target_value`: Integer representing the value of the node after which the new node should be inserted. - `new_value`: Integer representing the value of the new node to be inserted. # Output Format The function should return the head node of the linked list after the insertion operation. # Constraints - Do not create any extra nodes except the node to be inserted. - You can assume that all values in the linked list are unique. # Example **Initial List**: `1 -> 2 -> 3 -> 4` **Function Call**: `insert_after_value(head, 2, 5)` **Modified List**: `1 -> 2 -> 5 -> 3 -> 4` # Scenario Consider a system where you need to manage customer orders in a sequence. Imagine nodes store the order processing sequence. If a high priority order comes in just after another specific order, it should be inserted immediately without re-arranging the entire list. Write the function to implement this. # Hint Ensure that you traverse the list to find the `target_value` node and appropriately insert the new node in a single pass. Handle edge cases where the target node does not exist. **Edge Cases to Consider**: - Target value does not exist in the list. - The list is empty (i.e., head is None). **Function to run preliminary tests**: ```python class TestSuite(unittest.TestCase): def test_insert_after_value(self): head = Node(1) head.next = Node(2) head.next.next = Node(3) head.next.next.next = Node(4) # Insert 5 after 2 head = insert_after_value(head, 2, 5) self.assertEqual([1, 2, 5, 3, 4], get_list_values(head)) # Insert 6 after 4 (tail) head = insert_after_value(head, 4, 6) self.assertEqual([1, 2, 5, 3, 4, 6], get_list_values(head)) # Insert 0 at beginning (should raise an error) with self.assertRaises(ValueError): insert_after_value(head, 0, 7) def get_list_values(head): values = [] current = head while current: values.append(current.val) current = current.next return values ```","solution":"class Node: def __init__(self, value=0, next=None): self.value = value self.next = next def insert_after_value(head: Node, target_value: int, new_value: int) -> Node: Inserts a new node with value new_value immediately after the first node that has the value target_value in the linked list starting at head. Parameters: head (Node): The head node of the singly linked list. target_value (int): The value of the node after which the new node will be inserted. new_value (int): The value of the new node to be inserted. Returns: Node: The head node of the potentially modified list. Raises: ValueError: If the target_value node is not found in the list. current = head while current is not None: if current.value == target_value: new_node = Node(new_value) new_node.next = current.next current.next = new_node return head current = current.next raise ValueError(f\\"Node with value {target_value} not found\\")"},{"question":"Scenario You are developing a pathfinding tool used to analyze the connectivity of nodes in a directed graph. You need to implement a method that determines the transitive closure of the graph. Given the graph as input, you should return a matrix that indicates which nodes are reachable from each other. Requirements **Input Format**: - An integer `n` representing the number of vertices in the graph. - A list of tuples `edges`, where each tuple `(a, b)` represents a directed edge from vertex `a` to vertex `b`. **Output Format**: - A 2D list (or matrix) of size `n x n`, where the element at row `i` and column `j` is `1` if vertex `j` is reachable from vertex `i` and `0` otherwise. **Constraints**: - `1 <= n <= 100` (The upper limit constraint checks for efficiency). - Each vertex is labeled with a unique integer from `0` to `n-1`. Example: ```python # Input n = 4 edges = [(0, 1), (1, 2), (2, 3)] # Output [ [1, 1, 1, 1], [0, 1, 1, 1], [0, 0, 1, 1], [0, 0, 0, 1] ] ``` Task Implement the function `find_transitive_closure(n: int, edges: List[Tuple[int, int]]) -> List[List[int]]` that performs the above mentioned task. ```python def find_transitive_closure(n, edges): # Your code here ```","solution":"def find_transitive_closure(n, edges): # Initialize the adjacency matrix closure = [[0] * n for _ in range(n)] # Populate the adjacency matrix with the given edges for a, b in edges: closure[a][b] = 1 # Each node is reachable from itself for i in range(n): closure[i][i] = 1 # Use Floyd-Warshall algorithm to compute the transitive closure for k in range(n): for i in range(n): for j in range(n): closure[i][j] = closure[i][j] or (closure[i][k] and closure[k][j]) return closure"},{"question":"# Coin Change Combinations **Objective**: Write a function that calculates the number of ways to make change for a given value using a set of given coin denominations. **Function Signature**: ```python def count_ways(coins: List[int], value: int) -> int: ``` Input: * `coins` (List[int]): A list of integers representing the denominations of the available coins. * `value` (int): An integer representing the target value of change. Output: * Returns an integer representing the number of ways to make the target value using the given coin denominations. Constraints: * All coin denominations and the value are positive integers. * 0 ≤ value ≤ 10^5 * 1 ≤ len(coins) ≤ 100 Performance Requirements: * The solution should run in O(n * m) time and use O(n) space where `n` is the value and `m` is the number of coin denominations. Example: ```python # Example 1 coins = [1, 2, 3] value = 4 assert count_ways(coins, value) == 4 # [1, 1, 1, 1], [1, 1, 2], [2, 2], [1, 3] # Example 2 coins = [2, 5, 3, 6] value = 10 assert count_ways(coins, value) == 5 # [2, 2, 2, 2, 2], [2, 2, 3, 3], [2, 2, 6], [2, 3, 5], [5, 5] ``` Scenario: Imagine you are participating in a fundraising event where you need to help your team calculate the number of ways to distribute a specific total amount of money using different denominations of coins or currency notes. Your task is to write a program that efficiently calculates the number of ways to make the target total to aid in strategic planning.","solution":"from typing import List def count_ways(coins: List[int], value: int) -> int: Calculates the number of ways to make change for a given value using a set of given coin denominations. :param coins: List[int] - denominations of the available coins :param value: int - target value to make change for :return: int - number of ways to make the target value using the given coin denominations dp = [0] * (value + 1) dp[0] = 1 for coin in coins: for i in range(coin, value + 1): dp[i] += dp[i - coin] return dp[value]"},{"question":"Context: You are given a singly linked list where each node contains a unique identifier. You need to implement a function to find the k-th to last node of the list. This problem assesses your ability to handle list traversal and optimal searching techniques in a linked list. Function Description: Implement the function `find_kth_to_last` which returns the k-th to last element in the linked list. The function should be optimized for both time and space complexity. ```python class Node(): def __init__(self, val=None): self.val = val self.next = None def find_kth_to_last(head, k): :param head: Node, the head node of the singly linked list :param k: int, the k-th index from the end (1-based) :return: Node, the k-th to last node of the list :raises: IndexError if k is out of bounds # Your code here ``` Input: * `head`: A non-empty singly linked list node of at least one node. * `k`: A positive integer representing the k-th to last node to find, 1-based index. Output: * The function should return the Node which is k-th to last in the list. Constraints: * 1 ≤ k ≤ length of the list * The linked list contains between 1 and 10^5 nodes Example: Consider a linked list represented as `1 -> 2 -> 3 -> 4 -> 5`, and `k = 2`. * The function `find_kth_to_last(head, 2)` should return the node with value `4` (node 4). # Additional Notes: * Ensure code robustness by validating inputs and edge cases. * Aim for an optimal solution with O(n) time complexity and O(1) space complexity.","solution":"class Node(): def __init__(self, val=None): self.val = val self.next = None def find_kth_to_last(head, k): :param head: Node, the head node of the singly linked list :param k: int, the k-th index from the end (1-based) :return: Node, the k-th to last node of the list :raises: IndexError if k is out of bounds # Initialize two pointers, both will start at head slow = head fast = head # Move fast pointer k steps ahead for _ in range(k): if fast is None: raise IndexError(\\"k is out of bounds\\") fast = fast.next # Move both slow and fast pointers until fast reaches the end while fast is not None: slow = slow.next fast = fast.next # slow is now pointing to the k-th to last node return slow"},{"question":"# Question: Finding the nth Digit in Contiguous Sequence You are given a number `n` and you need to find the nth digit in the sequence of all natural numbers written together contiguously. Natural numbers are sequences such as \\"123456789101112...\\" and so forth. For example: - The 3rd digit in the sequence is `3`. - The 11th digit in the sequence is `0` because the sequence is \\"12345678910\\". Write a function `find_nth_digit(n)` that takes a single integer `n` and returns the nth digit in the contiguous sequence of all natural numbers. Constraints: - 1 ≤ n ≤ 2 * 10^9 Performance Requirements: - The function should handle large values of `n` efficiently with a time complexity of O(log n). Function Signature: ```python def find_nth_digit(n: int) -> int: # Your implementation here ``` Input: - An integer `n`, where `1 ≤ n ≤ 2 * 10^9`. Output: - An integer representing the nth digit in the contiguous sequence of natural numbers. Example: ```python assert find_nth_digit(3) == 3 assert find_nth_digit(11) == 0 assert find_nth_digit(12) == 1 ``` You must write code to accomplish this without explicitly generating the full sequence of numbers, thereby demonstrating logical construction and mathematical manipulation skills.","solution":"def find_nth_digit(n: int) -> int: # Initialize the length of the current digit block length = 1 # Initialize the count of numbers and the starting point of the block count = 9 start = 1 # Determine the block where the nth digit is located while n > length * count: n -= length * count length += 1 count *= 10 start *= 10 # Determine the actual number and the digit within that number start += (n - 1) // length s = str(start) return int(s[(n - 1) % length])"},{"question":"Given a Binary Search Tree (BST) and a node, implement a function `successor` to find the in-order successor of the given node in the BST. The in-order successor of a node in a BST is the next node in in-order traversal. Write code demonstrating comprehension of BST properties and in-order traversal. # Function Signature ```python def successor(root: TreeNode, node: TreeNode) -> Optional[TreeNode]: ``` # Input * `root`: A `TreeNode` object representing the root of the BST. * `node`: A `TreeNode` object representing the node for which to find the in-order successor. # Output * Return a `TreeNode` object representing the in-order successor of the given node. If there is no successor, return `None`. # Constraints * Each node will have a `val` attribute representing its value, a `left` attribute pointing to its left child, and a `right` attribute pointing to its right child. * The given node is guaranteed to be a valid node in the BST. * The BST contains unique values. # Example ```plaintext Input: 20 / 10 30 / 5 15 35 40 Node = 30 Output: TreeNode with value 35 ``` # Scenario Imagine you are implementing a feature in a software system that needs to process and retrieve data in sorted order from a BST efficiently. One of the core functionalities is to quickly identify the next element in sorted order given any starting node. This task ensures you understand and can implement this functionality correctly. # Notes * Carefully consider edge cases where the node has no right subtree. * Ensure the solution runs efficiently for large BSTs. Good luck!","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def successor(root: TreeNode, node: TreeNode) -> TreeNode: def findMin(node: TreeNode) -> TreeNode: while node.left: node = node.left return node if node.right: return findMin(node.right) succ = None current = root while current: if node.val < current.val: succ = current current = current.left elif node.val > current.val: current = current.right else: break return succ"},{"question":"# Question: Linked List Palindrome Validation You are tasked with implementing an algorithm to check whether a singly linked list is a palindrome. A palindrome is a sequence that reads the same forwards and backwards. Function Signature ```python class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def is_palindrome(head: ListNode) -> bool: ``` Input * `head`: A ListNode representing the head of a singly linked list. Output * Returns `True` if the linked list is a palindrome, `False` otherwise. Constraints * The number of nodes in the list is in the range `[1, 10^5]`. * `0 <= Node.val <= 9` * Implement an efficient solution with an optimal balance of time and space complexity. Example ```python class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def create_linked_list(values): head = ListNode(values[0]) current = head for val in values[1:]: current.next = ListNode(val) current = current.next return head # Example 1 head = create_linked_list([1, 2, 2, 1]) assert is_palindrome(head) == True # Example 2 head = create_linked_list([1, 2]) assert is_palindrome(head) == False ``` Consider edge cases and optimize to handle large lists efficiently.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def is_palindrome(head: ListNode) -> bool: Checks if the linked list is a palindrome. # Step 1: Use slow and fast pointers to find the middle of the linked list slow = fast = head while fast and fast.next: slow = slow.next fast = fast.next.next # Step 2: Reverse the second half of the linked list prev = None while slow: next_node = slow.next slow.next = prev prev = slow slow = next_node # Step 3: Compare the first half and the reversed second half nodes first_half, second_half = head, prev while second_half: # Only need to compare until the end of second half if first_half.val != second_half.val: return False first_half = first_half.next second_half = second_half.next return True def create_linked_list(values): head = ListNode(values[0]) current = head for val in values[1:]: current.next = ListNode(val) current = current.next return head"},{"question":"# Regular Expression Matching with Wildcards You are tasked to implement a function named `is_match` which performs wildcard string matching with support for two special characters: `\'.\'` and `\'*\'`. - `\'.\'` Matches any single character. - `\'*\'` Matches zero or more of the preceding element. The entire input string must be matched against the pattern string, meaning partial matches are not acceptable. Your implementation should leverage a dynamic programming approach. You are expected to write a robust function that meets the following prototype: ```python def is_match(s: str, p: str) -> bool: ``` # Input - `s`: A non-null, potentially empty string. (`0 <= len(s) <= 30`) - `p`: A non-null, potentially empty pattern string consisting of lowercase letters and the characters `\'.\'` and `\'*\'`. (`0 <= len(p) <= 30`) # Output - Return a boolean value indicating whether the input string `s` matches the pattern string `p`. # Examples ```python assert is_match(\\"aa\\", \\"a\\") == False assert is_match(\\"aa\\", \\"aa\\") == True assert is_match(\\"aaa\\", \\"aa\\") == False assert is_match(\\"aa\\", \\"a*\\") == True assert is_match(\\"aa\\", \\".*\\") == True assert is_match(\\"ab\\", \\".*\\") == True assert is_match(\\"aab\\", \\"c*a*b\\") == True ``` # Constraints - `\'*\'` character must always be preceded by a valid character. - Perform input validations to handle edge cases effectively. # Additional Requirements Your solution should: - Be efficient in terms of time and space complexity. - Consider edge cases such as empty strings, patterns with only special characters, and handling successive special characters.","solution":"def is_match(s: str, p: str) -> bool: # Create a DP table where dp[i][j] indicates whether s[:i] matches p[:j] dp = [[False] * (len(p) + 1) for _ in range(len(s) + 1)] dp[0][0] = True # Both s and p are empty, so they match # Fill in the column for the patterns like a*, a*b*, a*b*c* which can match an empty string for j in range(1, len(p) + 1): if p[j - 1] == \\"*\\" and j > 1: dp[0][j] = dp[0][j - 2] for i in range(1, len(s) + 1): for j in range(1, len(p) + 1): if p[j - 1] == s[i - 1] or p[j - 1] == \\".\\": dp[i][j] = dp[i - 1][j - 1] elif p[j - 1] == \\"*\\" and j > 1: dp[i][j] = dp[i][j - 2] # Matches zero of the previous element if p[j - 2] == s[i - 1] or p[j - 2] == \\".\\": dp[i][j] = dp[i][j] or dp[i - 1][j] # Matches one or more of the previous element return dp[len(s)][len(p)]"},{"question":"You are tasked with implementing basic bit manipulation functions that perform operations on individual bits of an integer. Specifically, you need to write four functions (`get_bit`, `set_bit`, `clear_bit`, and `update_bit`) that will allow you to retrieve, set, clear, and update specific bits of a given integer. Function Signatures ```python def get_bit(num: int, i: int) -> bool: Determine whether the bit at index i in the integer num is set (1) or not (0). Args: num (int): The input integer. i (int): The bit index. Returns: bool: True if the bit at index i is 1, False otherwise. pass def set_bit(num: int, i: int) -> int: Set the bit at index i in the integer num to 1. Args: num (int): The input integer. i (int): The bit index. Returns: int: The new integer after setting the bit. pass def clear_bit(num: int, i: int) -> int: Clear the bit at index i in the integer num (set to 0). Args: num (int): The input integer. i (int): The bit index. Returns: int: The new integer after clearing the bit. pass def update_bit(num: int, i: int, bit: int) -> int: Update the bit at index i in the integer num to the provided bit value (either 0 or 1). Args: num (int): The input integer. i (int): The bit index. bit (int): The value to set the bit to (must be 0 or 1). Returns: int: The new integer after updating the bit. pass ``` Constraints 1. `i` is a non-negative integer and should be less than the bit-width of integer in the given language\'s implementation. 2. `num` can be any integer (including negative values). 3. `bit` must be either 0 or 1. 4. Ensure your solution handles invalid bit indices appropriately without causing exceptions. Additional Info - Use direct bit manipulation techniques. - Avoid using any built-in functions for direct bit manipulations (like `bitset` libraries). Example ```python # Example Usage # Consider a 32-bit representation for the examples num = 0b0110 # Binary representation: 0110 print(get_bit(num, 1)) # Output: True (2nd bit is 1) print(set_bit(num, 0)) # Output: 7 (Binary: 0111) print(clear_bit(num, 2)) # Output: 2 (Binary: 0010) print(update_bit(num, 3, 1)) # Output: 14 (Binary: 1110) print(update_bit(num, 1, 0)) # Output: 4 (Binary: 0100) ``` Implement these functions ensuring they perform correctly on both positive and negative integer inputs while respecting the constraints and expected behaviors.","solution":"def get_bit(num: int, i: int) -> bool: Determine whether the bit at index i in the integer num is set (1) or not (0). Args: num (int): The input integer. i (int): The bit index. Returns: bool: True if the bit at index i is 1, False otherwise. if i < 0: raise ValueError(\\"Bit index must be non-negative\\") return (num & (1 << i)) != 0 def set_bit(num: int, i: int) -> int: Set the bit at index i in the integer num to 1. Args: num (int): The input integer. i (int): The bit index. Returns: int: The new integer after setting the bit. if i < 0: raise ValueError(\\"Bit index must be non-negative\\") return num | (1 << i) def clear_bit(num: int, i: int) -> int: Clear the bit at index i in the integer num (set to 0). Args: num (int): The input integer. i (int): The bit index. Returns: int: The new integer after clearing the bit. if i < 0: raise ValueError(\\"Bit index must be non-negative\\") return num & ~(1 << i) def update_bit(num: int, i: int, bit: int) -> int: Update the bit at index i in the integer num to the provided bit value (either 0 or 1). Args: num (int): The input integer. i (int): The bit index. bit (int): The value to set the bit to (must be 0 or 1). Returns: int: The new integer after updating the bit. if i < 0: raise ValueError(\\"Bit index must be non-negative\\") if bit not in (0, 1): raise ValueError(\\"Bit value must be 0 or 1\\") mask = ~(1 << i) return (num & mask) | (bit << i)"},{"question":"# Matrix Transformation In this task, you will implement a series of matrix transformations. Specifically, you will write functions to rotate a matrix 90 degrees clockwise, rotate it 90 degrees counterclockwise, mirror it diagonally from the top-left to the bottom-right corner, and mirror it diagonally from the bottom-left to the top-right corner. Function Definitions 1. **rotate_clockwise(matrix)**: - **Input**: A list of lists `matrix` representing an n x n matrix. - **Output**: A new list of lists representing the matrix rotated 90 degrees clockwise. 2. **rotate_counterclockwise(matrix)**: - **Input**: A list of lists `matrix` representing an n x n matrix. - **Output**: A new list of lists representing the matrix rotated 90 degrees counterclockwise. 3. **top_left_invert(matrix)**: - **Input**: A list of lists `matrix` representing an n x n matrix. - **Output**: A new list of lists representing the matrix mirrored from the top-left to the bottom-right corner. 4. **bottom_left_invert(matrix)**: - **Input**: A list of lists `matrix` representing an n x n matrix. - **Output**: A new list of lists representing the matrix mirrored from the bottom-left to the top-right corner. Constraints * The input matrix will always be an n x n matrix where 1 <= n <= 100. * The matrix elements will be integers. Example ```python matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9], ] # Function calls print(rotate_clockwise(matrix)) # Output: # [[7, 4, 1], # [8, 5, 2], # [9, 6, 3]] print(rotate_counterclockwise(matrix)) # Output: # [[3, 6, 9], # [2, 5, 8], # [1, 4, 7]] print(top_left_invert(matrix)) # Output: # [[1, 4, 7], # [2, 5, 8], # [3, 6, 9]] print(bottom_left_invert(matrix)) # Output: # [[9, 6, 3], # [8, 5, 2], # [7, 4, 1]] ``` Additional Information - You are required to implement these functions in a way that doesn\'t modify the original matrix. - Ensure to appropriately handle edge cases such as empty matrices or single element matrices.","solution":"def rotate_clockwise(matrix): Rotate the given n x n matrix 90 degrees clockwise. n = len(matrix) return [[matrix[n - j - 1][i] for j in range(n)] for i in range(n)] def rotate_counterclockwise(matrix): Rotate the given n x n matrix 90 degrees counterclockwise. n = len(matrix) return [[matrix[j][n - i - 1] for j in range(n)] for i in range(n)] def top_left_invert(matrix): Mirror the given n x n matrix diagonally from the top-left to the bottom-right corner. n = len(matrix) return [[matrix[j][i] for j in range(n)] for i in range(n)] def bottom_left_invert(matrix): Mirror the given n x n matrix diagonally from the bottom-left to the top-right corner. n = len(matrix) return [[matrix[n - j - 1][n - i - 1] for j in range(n)] for i in range(n)]"},{"question":"# Coding Challenge: Optimizing the Bellman-Ford Algorithm Problem Statement You are given a directed weighted graph represented as an edge list. Each edge is represented as a triplet `(u, v, w)` where `u` is the start vertex, `v` is the end vertex, and `w` is the weight of the edge. Implement a function that utilizes the Bellman-Ford algorithm to find the shortest path from a chosen source node to all other nodes. Your implementation should additionally detect any negative-weight cycles. Function Signature ```python def optimized_bellman_ford(num_vertices, edges, source): Determines single-source shortest paths from the given source vertex to all other vertices. Parameters: - num_vertices (int): The total number of vertices in the graph. - edges (List[Tuple[int, int, int]]): The list of edges in the graph. - source (int): The source vertex from which to calculate shortest paths. Returns: - distances (List[float]): The list of minimum distances from source to each vertex. - has_negative_cycle (bool): Boolean indicating the presence of a negative-weight cycle. ``` Your implementation should follow these constraints: - **Input Constraints**: - `num_vertices` is an integer in the range [1, 1000]. - `edges` is a list of tuples (u, v, w) where: - `u` and `v` are integers in the range [0, num_vertices - 1] - `w` is an integer. Requirements: 1. Initialize the distance to all vertices as infinite except the source vertex which should be 0. 2. Relax all edges |V|-1 times. 3. Check for the presence of negative-weight cycles. 4. Return the calculated shortest distances and whether a negative-weight cycle exists. Example ```python edges = [(0, 1, 4), (0, 2, 5), (1, 2, -3), (2, 3, 4), (3, 1, -1)] num_vertices = 4 source = 0 # Example Call distances, has_negative_cycle = optimized_bellman_ford(num_vertices, edges, source) # Expected Output # distances = [0, 4, 1, 5] # has_negative_cycle = False ``` Notes: - Ensure your function handles all provided constraints efficiently and correctly.","solution":"def optimized_bellman_ford(num_vertices, edges, source): Determines single-source shortest paths from the given source vertex to all other vertices. Parameters: - num_vertices (int): The total number of vertices in the graph. - edges (List[Tuple[int, int, int]]): The list of edges in the graph. - source (int): The source vertex from which to calculate shortest paths. Returns: - distances (List[float]): The list of minimum distances from source to each vertex. - has_negative_cycle (bool): Boolean indicating the presence of a negative-weight cycle. # Step 1: Initialize distances from source to all other vertices distances = [float(\'inf\')] * num_vertices distances[source] = 0 # Step 2: Relax edges repeatedly for _ in range(num_vertices - 1): for u, v, w in edges: if distances[u] != float(\'inf\') and distances[u] + w < distances[v]: distances[v] = distances[u] + w # Step 3: Check for negative-weight cycles has_negative_cycle = False for u, v, w in edges: if distances[u] != float(\'inf\') and distances[u] + w < distances[v]: has_negative_cycle = True break return distances, has_negative_cycle"},{"question":"# Coding Assessment: Implement a Custom Stack Operation **Context:** You have been provided with the basic implementation of stack operations using both array and linked list internal representations. Now, extend the given ArrayStack and LinkedListStack classes by adding a new operation `min_element` that returns the minimum element present in the stack in constant time O(1). **Problem Statement:** You need to implement a method `min_element` in both `ArrayStack` and `LinkedListStack` classes. This method should return the smallest element in the stack without removing any elements. If the stack is empty, this method should raise an `IndexError` with the message \\"Stack is empty\\". **Function Signature:** ```python def min_element(self) -> int: pass ``` **Constraints:** - The element type will be integers. - The stack implementation should maintain its O(1) time complexity for push, pop, peek, and is_empty operations. **Example:** ```python # ArrayStack Example array_stack = ArrayStack() array_stack.push(3) array_stack.push(5) array_stack.push(2) array_stack.push(1) print(array_stack.min_element()) # Output: 1 array_stack.pop() print(array_stack.min_element()) # Output: 2 # LinkedListStack Example linked_list_stack = LinkedListStack() linked_list_stack.push(4) linked_list_stack.push(6) linked_list_stack.push(1) linked_list_stack.push(7) print(linked_list_stack.min_element()) # Output: 1 linked_list_stack.pop() print(linked_list_stack.min_element()) # Output: 1 ``` **Note:** - The `min_element` method must always return the minimum element in O(1) time. Write your solution by subclassing `ArrayStack` and `LinkedListStack` and implementing the `min_element` method for both.","solution":"class ArrayStack: def __init__(self): self.stack = [] self.min_stack = [] def push(self, value): self.stack.append(value) if not self.min_stack or value <= self.min_stack[-1]: self.min_stack.append(value) def pop(self): if not self.stack: raise IndexError(\\"Pop from an empty stack\\") value = self.stack.pop() if value == self.min_stack[-1]: self.min_stack.pop() return value def peek(self): return self.stack[-1] if self.stack else None def is_empty(self): return len(self.stack) == 0 def min_element(self): if not self.min_stack: raise IndexError(\\"Stack is empty\\") return self.min_stack[-1] class LinkedListStack: class Node: def __init__(self, value, next_node=None): self.value = value self.min_value = value self.next_node = next_node def __init__(self): self.top = None def push(self, value): if not self.top: self.top = self.Node(value) else: new_node = self.Node(value, self.top) new_node.min_value = min(value, self.top.min_value) self.top = new_node def pop(self): if not self.top: raise IndexError(\\"Pop from an empty stack\\") value = self.top.value self.top = self.top.next_node return value def peek(self): return self.top.value if self.top else None def is_empty(self): return self.top is None def min_element(self): if not self.top: raise IndexError(\\"Stack is empty\\") return self.top.min_value"},{"question":"# Description: Implement a class `ResizableHashTable` which extends the provided `HashTable` class, to include dynamic resizing and improve performance with a more sophisticated rehashing strategy. # Requirements: 1. Override the `put` method to ensure the hash table doubles in size when the load factor exceeds 0.7. 2. Override the rehashing method to implement *quadratic probing* instead of linear probing. 3. Implement methods for returning all keys and values as lists. # Class Definition: ```python class ResizableHashTable(HashTable): def __init__(self): super().__init__() def put(self, key, value): # Override this to include a resizing mechanism pass def _rehash(self, old_hash): # Override this to implement quadratic probing pass def keys(self): # Implement this method to return all keys pass def values(self): # Implement this method to return all values pass ``` # Input and Output: * `put(key, value)`: Adds or updates the key-value pair. * `keys() -> List`: Returns a list of all stored keys. * `values() -> List`: Returns a list of all stored values. # Example: ```python ht = ResizableHashTable() ht.put(1, \'one\') ht.put(2, \'two\') print(ht.keys()) # Output: [1, 2] print(ht.values()) # Output: [\'one\', \'two\'] # Adding more elements to trigger resizing and observe key and value maintenance over resize. for i in range(3, 10): ht.put(i, str(i)) print(ht.keys()) # Output should include all keys from 1 to 9 print(ht.values()) # Output should include values \'one\' to \'nine\' ``` # Constraints: * The size of the hash table should be a power of 2. * Handle collisions efficiently using quadratic probing. * Store and manage large number of keys and values without performance degradation. # Performance: * Aim for O(1) average time complexity for put, get, and deletion operations. * Ensure scalability without significant performance bottlenecks.","solution":"class ResizableHashTable: def __init__(self): self.size = 4 # starting with a small size self.table = [None] * self.size self.item_count = 0 def _hash(self, key): return hash(key) % self.size def _rehash(self, old_hash, i): # Quadratic probing formula return (old_hash + i * i) % self.size def put(self, key, value): if self.item_count / self.size > 0.7: self._resize() initial_hash = self._hash(key) position = initial_hash i = 1 while self.table[position] is not None and self.table[position][0] != key: position = self._rehash(initial_hash, i) i += 1 if self.table[position] is None: self.item_count += 1 self.table[position] = (key, value) def _resize(self): old_table = self.table self.size *= 2 self.table = [None] * self.size self.item_count = 0 for item in old_table: if item is not None: self.put(item[0], item[1]) def keys(self): return [item[0] for item in self.table if item is not None] def values(self): return [item[1] for item in self.table if item is not None] def get(self, key): initial_hash = self._hash(key) position = initial_hash i = 1 while self.table[position] is not None: if self.table[position][0] == key: return self.table[position][1] position = self._rehash(initial_hash, i) i += 1 return None"},{"question":"# RSA Encryption Implementation As part of your cryptography coursework, you are required to implement a secure communication mechanism using the RSA algorithm. Your task is to complete the following two functions for RSA encryption and decryption. Requirements: 1. **Function Signature**: - `generate_key_pair(k: int, seed: Optional[int] = None) -> Tuple[int, int, int]` - `rsa_encrypt(plaintext: int, e: int, n: int) -> int` - `rsa_decrypt(ciphertext: int, d: int, n: int) -> int` 2. **Function Descriptions**: - `generate_key_pair(k, seed)`: Generates RSA key pair for the specified bit length `k`. The optional `seed` parameter helps in generating reproducible prime numbers. - **Input**: - `k`: Bit length for prime numbers `p` and `q`. - `seed`: (Optional) Seed for random number generator. - **Output**: - A tuple `(n, e, d)` where: - `n` is the modulus. - `e` is the public exponent. - `d` is the private exponent. - `rsa_encrypt(plaintext, e, n)`: Encrypts the plaintext using the given public key `(e, n)`. - **Input**: - `plaintext`: The integer to be encrypted. - `e`: Public exponent. - `n`: Modulus. - **Output**: - Encrypted integer (ciphertext). - `rsa_decrypt(ciphertext, d, n)`: Decrypts the ciphertext using the given private key `(d, n)`. - **Input**: - `ciphertext`: The encrypted integer to be decrypted. - `d`: Private exponent. - `n`: Modulus. - **Output**: - Decrypted integer (original plaintext). 3. **Constraints**: - Ensure that `k` is sufficiently large (e.g., `k >= 16`). - Handle edge cases where prime numbers may not be generated properly. - Use Python’s built-in `pow` function for modular exponentiation. 4. **Performance Requirements**: - The implementation should be efficient to handle standard bit-length keys (e.g., 1024 bits) within reasonable time constraints. Example ```python # Generate RSA key pair n, e, d = generate_key_pair(16) # Encrypt and decrypt a message plaintext = 20 ciphertext = rsa_encrypt(plaintext, e, n) assert rsa_decrypt(ciphertext, d, n) == plaintext ```","solution":"import random from typing import Tuple, Optional from sympy import isprime, gcd def generate_prime(bit_length: int, seed: Optional[int] = None) -> int: if seed is not None: random.seed(seed) while True: prime_candidate = random.getrandbits(bit_length) if isprime(prime_candidate): return prime_candidate def generate_key_pair(k: int, seed: Optional[int] = None) -> Tuple[int, int, int]: p = generate_prime(k // 2, seed) q = generate_prime(k // 2, seed + 1 if seed is not None else None) n = p * q phi = (p - 1) * (q - 1) e = 65537 # Common choice for e # Ensure e is coprime with phi while gcd(e, phi) != 1: e = random.randrange(2, phi) # Compute d, the modular inverse of e d = pow(e, -1, phi) return n, e, d def rsa_encrypt(plaintext: int, e: int, n: int) -> int: return pow(plaintext, e, n) def rsa_decrypt(ciphertext: int, d: int, n: int) -> int: return pow(ciphertext, d, n)"},{"question":"# Context In a number system where a number is represented as an array of its individual digits (with the most significant digit at the start), you are required to increment the number by one and return the resulting array of digits. **Function to Implement**: ```python def increment_number(digits): :type digits: List[int] :rtype: List[int] pass ``` # Input - A list of non-negative integers where each integer `0 <= digits[i] <= 9`. - The list may be empty, in which case it represents the number `0`. # Output - A list of non-negative integers that represent the number incremented by one. # Constraints and Limitations - You must handle the carry-over correctly when a digit becomes `10`. - You should handle edge cases smoothly, such as when all digits are `9`. - Performance should be optimal with an expected time complexity of O(n) and space complexity of O(1) or O(n). # Example ```python # Example 1 digits = [1, 2, 3] print(increment_number(digits)) # Output: [1, 2, 4] # Example 2 digits = [9, 9, 9] print(increment_number(digits)) # Output: [1, 0, 0, 0] # Example 3 digits = [] print(increment_number(digits)) # Output: [1] ``` Write the `increment_number` function to achieve this.","solution":"def increment_number(digits): Increment the given number represented by a list of digits by one. if not digits: return [1] n = len(digits) for i in range(n - 1, -1, -1): if digits[i] < 9: digits[i] += 1 return digits digits[i] = 0 return [1] + digits"},{"question":"**Problem Statement:** You are given two strings `s` and `t` consisting of only lowercase letters. String `t` is generated by shuffling string `s` and then adding one more letter at a random position. Your task is to write a function to find the letter that was added in `t`. **Function Signature:** ```python def find_difference(s: str, t: str) -> str: ``` **Input:** - `s`: A string of length `n` with lowercase letters (`0 ≤ n ≤ 10^5`). - `t`: A string of length `n + 1` with lowercase letters. **Output:** - Returns a single character which is the letter added to `t`. **Example:** ```python s = \\"abcd\\" t = \\"abecd\\" output = find_difference(s, t) # Returns \'e\' ``` **Constraints:** 1. The characters in both strings are lowercase English letters. 2. String `t` is generated by shuffling string `s` and adding one additional letter at a random position, producing a valid input scenario. **Performance Requirements:** - The solution should operate in O(n) time complexity and O(1) space complexity. **Scenario/Context:** Imagine you are creating a tool to help data engineers quickly identify discrepancies in datasets. The efficient detection of added elements can streamline debugging and integrity checks. Implementing the `find_difference` function accurately will prepare you for handling similar tasks in real-world data operation scenarios.","solution":"def find_difference(s: str, t: str) -> str: Finds the letter that was added to t. # Initialize a variable to store the result using XOR operation. result = 0 # XOR all characters in s for char in s: result ^= ord(char) # XOR all characters in t for char in t: result ^= ord(char) # The result will be the ASCII value of the added character return chr(result)"},{"question":"# Scenario: You are given a dataset that needs to be sorted for a dataset visualization application to ensure that data trends are presented correctly in an ascending order. To achieve this efficiently, you decide to implement the Comb Sort algorithm. # Task: Write a function `comb_sort_improved(arr: list) -> list` that sorts a given list of integers `arr` in ascending order using the Comb Sort algorithm. # Input: * `arr`: A list of integers. The length of the list (`n`) can be from 0 to 10^5. Individual integers can range from -10^9 to 10^9. # Output: * A list of integers sorted in ascending order. # Constraints: * Your solution should be optimized in terms of both time and space, aiming for a better-than O(N^2) performance on average cases. # Requirements: * The implemented function should be efficient with respect to time and space complexity. * Consider different edge cases like an empty array, an array with one element, or an already sorted array. * Comment on the choice of the shrink factor if you choose to modify it. # Example: ```python def comb_sort_improved(arr: list) -> list: # Your implementation here # Example usage print(comb_sort_improved([5, 3, 2, 8, 1, 4])) # Output: [1, 2, 3, 4, 5, 8] print(comb_sort_improved([1, 2, 3, 4, 5])) # Output: [1, 2, 3, 4, 5] print(comb_sort_improved([])) # Output: [] ``` # Explanation: In the first example, the unsorted list `[5, 3, 2, 8, 1, 4]` is sorted to `[1, 2, 3, 4, 5, 8]`. The second and third examples handle edge cases where the list is already sorted or empty respectively.","solution":"def comb_sort_improved(arr: list) -> list: Sorts a list of integers using the Comb Sort algorithm. Args: - arr (list): List of integers to be sorted. Returns: - list: Sorted list of integers in ascending order. n = len(arr) gap = n shrink_factor = 1.3 # Common shrink factor used for Comb Sort sorted = False while not sorted: # Update the gap for the next step gap = int(gap / shrink_factor) if gap <= 1: gap = 1 sorted = True i = 0 while i + gap < n: if arr[i] > arr[i + gap]: arr[i], arr[i + gap] = arr[i + gap], arr[i] sorted = False i += 1 return arr"},{"question":"# Question: Problem Statement You are tasked with implementing a custom `Queue` data structure using two stacks. The `Queue` should support the following operations efficiently: - `enqueue(x)`: Adds the element `x` to the rear of the queue. - `dequeue()`: Removes the element from the front of the queue and returns it. - `peek()`: Returns the element at the front of the queue without removing it. - `is_empty()`: Returns `True` if the queue is empty, `False` otherwise. Your implementation should leverage two instances of the `Stack` class provided in the snippets (either `ArrayStack` or `LinkedListStack`). You must ensure that the operations are efficient and that the queue maintains a first-in-first-out (FIFO) order. Requirements - Implement the `Queue` class with the methods described above. - The `Queue` class should internally use two stack instances (`ArrayStack` or `LinkedListStack`). - Write an `enqueue` operation that is O(1) and a `dequeue` operation that is amortized O(1). - Handle edge cases such as attempting to `dequeue` or `peek` from an empty queue. Input/Output Formats - `enqueue(x)` has no return value. - `dequeue()` returns the front element. - `peek()` returns the front element. - `is_empty()` returns a boolean value. Constraints - The queue should support a sufficiently large number of operations within reasonable time limits. Example ```python queue = Queue() queue.enqueue(1) queue.enqueue(2) queue.enqueue(3) print(queue.dequeue()) # Output: 1 print(queue.peek()) # Output: 2 print(queue.is_empty()) # Output: False queue.enqueue(4) print(queue.dequeue()) # Output: 2 print(queue.dequeue()) # Output: 3 print(queue.dequeue()) # Output: 4 print(queue.is_empty()) # Output: True ``` Additional Notes - Avoid using built-in Python list methods like `append` and `pop` directly to implement the queue methods.","solution":"class Stack: def __init__(self): self.items = [] def is_empty(self): return len(self.items) == 0 def push(self, item): self.items.append(item) def pop(self): if self.is_empty(): raise IndexError(\\"Pop from an empty stack\\") return self.items.pop() def peek(self): if self.is_empty(): raise IndexError(\\"Peek from an empty stack\\") return self.items[-1] class Queue: def __init__(self): self.in_stack = Stack() self.out_stack = Stack() def enqueue(self, x): self.in_stack.push(x) def dequeue(self): if self.out_stack.is_empty(): while not self.in_stack.is_empty(): self.out_stack.push(self.in_stack.pop()) if self.out_stack.is_empty(): raise IndexError(\\"Dequeue from an empty queue\\") return self.out_stack.pop() def peek(self): if self.out_stack.is_empty(): while not self.in_stack.is_empty(): self.out_stack.push(self.in_stack.pop()) if self.out_stack.is_empty(): raise IndexError(\\"Peek from an empty queue\\") return self.out_stack.peek() def is_empty(self): return self.in_stack.is_empty() and self.out_stack.is_empty()"},{"question":"# Instructions You are given an array of integers `array` and an integer `k`. Your goal is to rotate the array to the right by `k` steps. You need to implement one of the three versions shown below and ensure that your implementation handles all edge cases efficiently. # Function Signature ```python def rotate_array(array: List[int], k: int) -> List[int]: pass ``` # Input - `array`: List of integers where `0 ≤ len(array) ≤ 10^5`. - `k`: An integer where `0 ≤ k ≤ 10^5`. # Output - The function should return a new list with elements rotated to the right by `k` steps. # Constraints - You must handle the function within O(n) time complexity. - Space complexity should be O(1) for in-place modification or O(n) if creating a new array. # Example ```python # Example 1: array = [1,2,3,4,5,6,7] k = 3 rotate_array(array, k) # Output: [5,6,7,1,2,3,4] # Example 2: array = [10, 20, 30, 40, 50] k = 2 rotate_array(array, k) # Output: [40,50,10,20,30] # Example 3: array = [] k = 5 rotate_array(array, k) # Output: [] ``` # Note 1. Ensure that you handle edge cases such as when `array` is empty or when `k` is larger than the length of the array. 2. Consider using modulo operation to minimize redundant rotations. # Additional Requirements 1. Write test cases validating edge scenarios. 2. Analyze the performance and explain any optimizations applied.","solution":"def rotate_array(array, k): Rotates an array to the right by k steps. n = len(array) if n == 0: return array k = k % n # handle cases where k is greater than array length return array[-k:] + array[:-k] # slicing to create the rotated array"},{"question":"You are tasked with building a custom data structure for managing browser history using a stack. A user is able to visit a new page, go back to the previous page, and view the current page\'s URL. Implement `BrowserHistory` using a stack by completing the methods defined in the interface below. # Requirements * **push(url)**: Add a new URL to the browser history. * **pop()**: Remove the most recently visited URL from the browser history. * **peek()**: Return the current page\'s URL without removing it. * **is_empty()**: Check if the browser history is empty. # Constraints * You must use the `ArrayStack` class provided in the above snippet for your stack implementation. * The stack should manage URLs which are strings. * Error handling: * If `pop()` or `peek()` are called when the stack is empty, raise a `ValueError` with an appropriate message. # Input/Output Formats * The methods do not return any values except for `peek()` (returns the current URL) and `is_empty()` (returns a boolean). # Class Definition Implement the `BrowserHistory` class with the following methods: ```python class BrowserHistory: def __init__(self): # Initialize a stack for history using ArrayStack self.history = ArrayStack() def push(self, url): Add a new URL to the browser history. :param url: str pass def pop(self): Remove the most recently visited URL from the browser history. :raises ValueError: if the browser history is empty. pass def peek(self): Return the current page\'s URL without removing it. :return: str :raises ValueError: if the browser history is empty. pass def is_empty(self): Check if the browser history is empty. :return: bool pass ``` # Example ```python history = BrowserHistory() print(history.is_empty()) # True history.push(\\"https://www.example.com\\") history.push(\\"https://www.example.com/about\\") print(history.peek()) # \\"https://www.example.com/about\\" history.pop() print(history.peek()) # \\"https://www.example.com\\" history.pop() print(history.is_empty()) # True try: history.pop() except ValueError as ve: print(ve) # \\"Browser history is empty\\" ``` # Performance Requirements * Your implementations should have O(1) time complexity for `push`, `pop`, `peek`, and `is_empty` operations.","solution":"class ArrayStack: def __init__(self): self.stack = [] def push(self, item): self.stack.append(item) def pop(self): if self.is_empty(): raise ValueError(\\"Stack is empty\\") return self.stack.pop() def peek(self): if self.is_empty(): raise ValueError(\\"Stack is empty\\") return self.stack[-1] def is_empty(self): return len(self.stack) == 0 class BrowserHistory: def __init__(self): # Initialize a stack for history using ArrayStack self.history = ArrayStack() def push(self, url): Add a new URL to the browser history. :param url: str self.history.push(url) def pop(self): Remove the most recently visited URL from the browser history. :raises ValueError: if the browser history is empty. self.history.pop() def peek(self): Return the current page\'s URL without removing it. :return: str :raises ValueError: if the browser history is empty. return self.history.peek() def is_empty(self): Check if the browser history is empty. :return: bool return self.history.is_empty()"},{"question":"<|Analysis Begin|> # Core Identification * **Algorithm/Data Structure**: This algorithm is a specialized case of dynamic programming, inspired by Lagrange\'s four-square theorem and Legendre\'s three-square theorem. * **Complexity**: - **Time Complexity**: The primary time complexity is O(√n) due to the loop checking sums of two perfect squares. The initial while loop typically operates in constant time. - **Space Complexity**: The algorithm has a constant space complexity of O(1), as it only uses a few additional variables. * **Principles**: The algorithm first simplifies the problem by examining if the input number is a perfect square. It then checks the number against Legendre\'s three-square theorem criteria and reduces it if possible. Finally, it searches for combinations of sums of squares that fit the criteria defined by Lagrange’s four-square theorem. # Characteristics & Applications * **Properties**: - The function primarily checks for combinations of perfect squares that result in the smallest possible number—between 1 and 4. - If the number can be reduced by removing factors of 4, it simplifies the checks. - Utilizes both theoretical theorems to efficiently narrow down possibilities. * **Common Use Cases**: - Problems like sum decomposition, where breaking down a number into summands from a specific set (perfect squares) is necessary. - Algorithms in computer graphics, combinatory problems, or number theory-based puzzles. * **Strengths/Limitations**: - **Strengths**: Efficiently narrows down possibilities using mathematical facts, ensuring that it never checks more than necessary. - **Limitations**: Primarily limited to numbers where properties of squares apply and lacks generalization to larger decompositions. # Implementation Challenges * **Edge Cases**: - Non-perfection in numerical checks due to floating-point arithmetic. - Handling minimal inputs (e.g., 0 or 1). * **Performance Bottlenecks**: - The double loop within the last part of the function potentially causing redundant recalculations, though still within O(√n). * **Error Scenarios**: - Dependencies on mathematical properties may be misinterpreted for extremely large inputs. - Incorrect simplification when the number fails the modulus checks. * **Optimization Points**: - Potentially leverage memoization or cache previous computations. - Check if high-level language constructs (like sets for quick lookup) could speed data retrieval. <|Analysis End|> <|Question Begin|> # Minimum Perfect Squares Sum Context In number theory, particularly when dealing with sums of squares, Lagrange\'s four-square theorem tells us that any natural number can be represented as a sum of four integer squares. We can leverage this fact to design an efficient algorithm to find the smallest number of perfect squares that sum to a given integer. Task Implement a function `num_perfect_squares(number: int) -> int` that returns the minimum number of perfect squares that sum to the specified input integer. # Implementation Details 1. **Input**: A single integer `number` where `1 ≤ number ≤ 10^4`. 2. **Output**: An integer between 1 and 4 representing the smallest number of perfect squares required to sum to the input integer. Requirements 1. If `number` is a perfect square, return 1. 2. Simplify the number by removing multiples of 4 before further checks. 3. Utilize Legendre\'s three-square theorem to potentially limit the result to 3 squares if applicable. 4. Finally, check combinations of sums of perfect squares up to the specified range efficiently to determine the minimal count. # Example ```python num_perfect_squares(9) # Output: 1 num_perfect_squares(10) # Output: 2 num_perfect_squares(12) # Output: 3 num_perfect_squares(31) # Output: 4 ``` # Constraints - Avoid unnecessary brute-forcing; use mathematical properties and theorems to narrow possibilities. - Ensure efficient handling of upper constraints (up to 10,000 in value). Implement the function within the provided constraints and theoretical guidance.","solution":"import math def num_perfect_squares(number: int) -> int: Find the minimum number of perfect squares that sum up to the given number. Returns an integer between 1 to 4. # Check if the number itself is a perfect square if int(math.isqrt(number)) ** 2 == number: return 1 # Remove 4^k factors from the number while number % 4 == 0: number //= 4 # Check if the number is of the form 8*b + 7 if number % 8 == 7: return 4 # Check if the number can be expressed as a sum of two squares for i in range(1, int(math.isqrt(number)) + 1): if int(math.isqrt(number - i*i)) ** 2 == number - i*i: return 2 # If none of the above, the number can be expressed as a sum of three squares return 3"},{"question":"**Scenario**: You\'re tasked with creating a library to assist data scientists in preparing their data for machine learning models. One of the functions you need to implement is a sorting function that efficiently handles small to medium-sized datasets and can provide a detailed output of each step for educational purposes. **Task**: Write a function `detailed_insertion_sort` that sorts an array of integers using the insertion sort algorithm. This function should both return the sorted array and, if a flag `detailed` is set to `True`, print each step in the sorting process with the current state of the array. You need to handle edge cases like an empty array and a single-element array. # Function Signature ```python def detailed_insertion_sort(arr, detailed=False): pass ``` # Input * `arr` (List[int]): A list of integers you need to sort. * `detailed` (bool): A flag that determines whether to print the detailed steps or not. # Output * `List[int]`: The sorted list of integers. # Performance Requirements * Optimize for small and nearly sorted arrays. * The implementation should handle arrays of size up to 10,000 elements efficiently. # Constraints * The elements of the array are integers within the range [-10^6, 10^6]. # Example ```python # Example 1 input_arr = [4, 3, 2, 10, 12, 1, 5, 6] output_arr = detailed_insertion_sort(input_arr, detailed=True) # Expected detailed output: # Iteration 1: [3, 4, 2, 10, 12, 1, 5, 6] # Iteration 2: [2, 3, 4, 10, 12, 1, 5, 6] # Iteration 3: [2, 3, 4, 10, 12, 1, 5, 6] # Iteration 4: [2, 3, 4, 10, 12, 1, 5, 6] # Iteration 5: [1, 2, 3, 4, 10, 12, 5, 6] # Iteration 6: [1, 2, 3, 4, 5, 10, 12, 6] # Iteration 7: [1, 2, 3, 4, 5, 6, 10, 12] # Final output: [1, 2, 3, 4, 5, 6, 10, 12] # Example 2 input_arr = [3, 1] output_arr = detailed_insertion_sort(input_arr, detailed=False) # Expected output: [1, 3] ```","solution":"def detailed_insertion_sort(arr, detailed=False): Sorts an array of integers using the insertion sort algorithm. Parameters: arr (list[int]): A list of integers to sort. detailed (bool): If True, prints each step of the sorting process. Returns: list[int]: The sorted list of integers. for i in range(1, len(arr)): key = arr[i] j = i - 1 while j >= 0 and key < arr[j]: arr[j + 1] = arr[j] j -= 1 arr[j + 1] = key if detailed: print(f\\"Iteration {i}: {arr}\\") return arr"},{"question":"# Problem Description Given a binary tree, write a function to invert it. The inversion process exchanges the left and right child nodes recursively. You need to implement a function `invert_tree` that takes the root node of the binary tree and inverts the entire tree. # Function Signature ```python def invert_tree(root: TreeNode) -> TreeNode: pass ``` # Input * A `TreeNode` object called `root` that represents the root of the binary tree. * The `TreeNode` class is defined as follows: ```python class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right ``` # Output * Return the root node of the inverted binary tree. # Constraints 1. The number of nodes in the tree is in the range `[0, 10^4]`. 2. The tree\'s node values are in the range `[-10^4, 10^4]`. # Example Example 1 Input: ```plaintext 4 / 2 7 / / 1 3 6 9 ``` Output: ```plaintext 4 / 7 2 / / 9 6 3 1 ``` # Notes: 1. Your solution should handle the case where the binary tree is empty (i.e., root is `None`). 2. Consider the characteristics and edge cases discussed in the analysis. # Performance - Your solution is expected to have a time complexity of O(N) and space complexity that efficiently uses O(h) for the recursive stack, where N is the number of nodes and h is the height of the tree.","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def invert_tree(root: TreeNode) -> TreeNode: if root is None: return None # Swap the left and right subtree root.left, root.right = root.right, root.left # Recursively invert the subtrees invert_tree(root.left) invert_tree(root.right) return root"},{"question":"# Matrix Multiplication Algorithm You are tasked with implementing a function that multiplies two matrices and returns their product. This function should specifically handle the multiplication of two-dimensional matrices (lists of lists). **Function Signature:** ```python def matrix_multiply(multiplicand: list, multiplier: list) -> list: :param multiplicand: List[List[int]] -- The first matrix in the multiplication (also called the left matrix). :param multiplier: List[List[int]] -- The second matrix in the multiplication (also called the right matrix). :return: List[List[int]] -- The resulting matrix after multiplication. ``` # Input: * `multiplicand` -- A 2D list where each inner list represents a row in the matrix. The number of columns in the `multiplicand` should be equal to the number of rows in the `multiplier`. * `multiplier` -- A 2D list where each inner list represents a row in the matrix. The number of rows should be equal to the number of columns in the `multiplicand`. # Output: * Returns the resulting matrix as a 2D list where each element is the product of the corresponding rows and columns from the `multiplicand` and `multiplier`. # Constraints: * The elements of the matrix are integers. * The number of columns in the `multiplicand` matrix must equal the number of rows in the `multiplier` matrix. * If the `multiplicand` and `multiplier` matrices are incompatible for multiplication, throw an exception with an appropriate error message. # Example: ```python multiplicand = [ [1, 2], [3, 4] ] multiplier = [ [2, 0], [1, 2] ] result = matrix_multiply(multiplicand, multiplier) # Expected result: # [ # [4, 4], # [10, 8] # ] ``` # Notes: * Make sure your implementation can handle edge cases such as mismatched matrix dimensions. * Consider optimizing your implementation for performance if possible.","solution":"def matrix_multiply(multiplicand: list, multiplier: list) -> list: Multiplies two matrices and returns their product. :param multiplicand: List[List[int]] -- The first matrix in the multiplication. :param multiplier: List[List[int]] -- The second matrix in the multiplication. :return: List[List[int]] -- The resulting matrix after multiplication. if len(multiplicand[0]) != len(multiplier): raise ValueError(\\"Number of columns in the multiplicand must be equal to the number of rows in the multiplier.\\") result = [[0] * len(multiplier[0]) for _ in range(len(multiplicand))] for i in range(len(multiplicand)): for j in range(len(multiplier[0])): for k in range(len(multiplier)): result[i][j] += multiplicand[i][k] * multiplier[k][j] return result"},{"question":"# Scenario: You have been tasked to write an efficient function to sort an array of integers. The existing bubble sort is too slow for the given inputs. You\'ll use an optimized version called Comb Sort to address this. # Problem Statement: Implement a function `comb_sort(arr)` that takes a list of integers `arr` and sorts it using the comb sort algorithm. The function should sort the list in ascending order and return the sorted list. # Input: - A single list of integers `arr` where 1 <= len(arr) <= 10^4 and -10^6 <= arr[i] <= 10^6 for all elements `arr[i]`. # Output: - A list of integers sorted in ascending order. # Constraints: - Your solution should work within the time complexity constraints of Comb Sort. - Ensure your solution handles edge cases such as empty lists, lists with a single element, or lists with all identical elements. # Example: ```python assert comb_sort([4, 3, 2, 1]) == [1, 2, 3, 4] assert comb_sort([34, -2, 3, 11, 5, 5 , 0]) == [-2, 0, 3, 5, 5, 11, 34] assert comb_sort([]) == [] assert comb_sort([1]) == [1] assert comb_sort([1, 1, 1]) == [1, 1, 1] ```","solution":"def comb_sort(arr): Sorts a list using the comb sort algorithm. def get_next_gap(gap): # Shrink gap by shrink factor 1.3 gap = (gap * 10) // 13 if gap < 1: return 1 return gap n = len(arr) gap = n swapped = True while gap != 1 or swapped: gap = get_next_gap(gap) swapped = False for i in range(n - gap): if arr[i] > arr[i + gap]: arr[i], arr[i + gap] = arr[i + gap], arr[i] swapped = True return arr"},{"question":"# Question Description You are required to implement a Markov Chain simulator. The simulator will use a dictionary-based Markov Chain to generate a sequence of states, given an initial state. # Function Implementation Function 1: next_state Create a function `next_state(chain: dict, current_state: str) -> str` that: * Accepts the following parameters: - `chain`: A dictionary representing the Markov Chain, where keys are states, and values are dictionaries of states and their transition probabilities. - `current_state`: A string representing the current state in the Markov Chain. * Returns a string representing the next state chosen randomly based on the transition probabilities for the current state. Function 2: iterating_markov_chain Create a function `iterating_markov_chain(chain: dict, state: str) -> list` that: * Accepts the following parameters: - `chain`: A dictionary representing the Markov Chain. - `state`: A string representing the initial state. * Returns a list of states representing the sequence of states starting from `state`, following the Markov Chain for a given number of iterations. Additional Requirements * You will receive an integer `iterations` specifying the number of state transitions to perform. * Ensure the probabilities within the state transitions add up to 1. * Return the sequence of states as a list after `iterations` transitions. # Input and Output Formats * **Input**: - `chain`: A dictionary of dictionaries representing the state transitions. - `state`: A string for the initial state. - `iterations`: An integer for the number of transitions. * **Output**: - A list of strings representing the state sequence after the specified number of transitions. # Constraints * All probabilities will be valid floating-point numbers summing to 1. * The Markov Chain will have at least one state and one valid transition. * States will be represented as non-empty strings with no spaces. # Example Input ```python chain = { \'A\': {\'A\': 0.6, \'B\': 0.4}, \'B\': {\'A\': 0.3, \'B\': 0.7} } initial_state = \'A\' iterations = 5 ``` Output ```python [\'A\', \'B\', \'B\', \'A\', \'B\', \'B\'] ``` # Scenario You are building a text generator that predicts the next word based on the current word. This can be represented by a Markov Chain where each word is a state, and the transitions between words are governed by the probabilities of sequences occurring in a corpus. Implementing the functions above will help you simulate the text generation by predicting possible word sequences given an initial word.","solution":"import random def next_state(chain, current_state): Selects the next state based on the transition probabilities defined in the chain for the current state. transitions = chain[current_state] states = list(transitions.keys()) probabilities = list(transitions.values()) return random.choices(states, probabilities)[0] def iterating_markov_chain(chain, state, iterations): Generates a sequence of states by iterating through the Markov Chain starting from the initial state. states_sequence = [state] current_state = state for _ in range(iterations): current_state = next_state(chain, current_state) states_sequence.append(current_state) return states_sequence"},{"question":"# BinaryHeap Extended Operations As a developer for a priority queue system, you are assigned to enhance the existing `BinaryHeap` class to add two main functionalities: 1. Implement a `find_min` method that returns the minimum element in the heap without removing it. 2. Implement a `heap_sort` method that sorts an array of integers using the heap data structure. Function Signatures: ```python def find_min(self) -> int: Return the minimum element from the min-heap without removing it. Returns: int: The minimum element in the heap. def heap_sort(arr: List[int]) -> List[int]: Sort an array of integers using the heap data structure. Args: arr (List[int]): List of integers to be sorted. Returns: List[int]: Sorted list of integers. ``` Requirements: - **find_min**: - This function should return the smallest element in the heap without modifying the heap. - It operates in O(1) time complexity. - **heap_sort**: - This function should take a list of integers and return a new list with the integers sorted in non-decreasing order. - Must use the heap data structure for sorting. - Operates in O(N log N) time complexity where N is the number of elements in the list. Constraints: 1. The `find_min` method should not alter the heap structure. 2. The `heap_sort` function should efficiently manage the heap operations to ensure optimal performance. Example: ```python # Example of using BinaryHeap to find the minimum element heap = BinaryHeap() heap.insert(5) heap.insert(3) heap.insert(8) heap.insert(1) # Expected output: 1 print(heap.find_min()) # Example of using heap_sort to sort a list arr = [4, 10, 3, 5, 1] # Expected output: [1, 3, 4, 5, 10] print(heap_sort(arr)) ``` Implement and test these methods in the `BinaryHeap` class to ensure they work correctly.","solution":"import heapq class BinaryHeap: def __init__(self): self.heap = [] def insert(self, val: int): heapq.heappush(self.heap, val) def find_min(self) -> int: Return the minimum element from the min-heap without removing it. Returns: int: The minimum element in the heap. if not self.heap: raise IndexError(\\"find_min(): empty heap\\") return self.heap[0] def heap_sort(arr): Sort an array of integers using the heap data structure. Args: arr (List[int]): List of integers to be sorted. Returns: List[int]: Sorted list of integers. heap = [] for num in arr: heapq.heappush(heap, num) sorted_arr = [] while heap: sorted_arr.append(heapq.heappop(heap)) return sorted_arr"},{"question":"Stutter Stack Elements You are given a stack that needs to be modified such that each of its elements is replaced by two occurrences of that element. You need to implement two functions, `first_stutter` and `second_stutter`, both of which achieve this task but with different auxiliary data structures. Function Signature ```python def first_stutter(stack: List[int]) -> List[int]: pass def second_stutter(stack: List[int]) -> List[int]: pass ``` # Input - A stack represented as a list of integers. # Output - A modified stack list where each element appears twice consecutively. # Constraints - The input list may contain between 0 and 10^5 elements. - The elements are integers within the range of -10^5 to 10^5. # Performance Requirements - **Time Complexity**: O(n) where n is the size of the stack. - **Space Complexity**: O(n) due to the use of auxiliary data structures. # Example ```python stack = [3, 7, 1, 14, 9] # First method using an auxiliary stack print(first_stutter(stack)) # Output: [3, 3, 7, 7, 1, 1, 14, 14, 9, 9] # Second method using an auxiliary queue print(second_stutter(stack)) # Output: [3, 3, 7, 7, 1, 1, 14, 14, 9, 9] ``` # Instructions 1. Implement the `first_stutter` function using an auxiliary stack. 2. Implement the `second_stutter` function using an auxiliary queue. 3. Ensure that your solution handles edge cases like empty stacks or single-element stacks gracefully.","solution":"from typing import List from collections import deque def first_stutter(stack: List[int]) -> List[int]: This function modifies the given stack list such that each element is replaced by two occurrences of that element using an auxiliary stack. aux_stack = [] while stack: element = stack.pop() aux_stack.append(element) aux_stack.append(element) while aux_stack: stack.append(aux_stack.pop()) return stack def second_stutter(stack: List[int]) -> List[int]: This function modifies the given stack list such that each element is replaced by two occurrences of that element using an auxiliary queue. aux_queue = deque() while stack: element = stack.pop() aux_queue.appendleft(element) aux_queue.appendleft(element) while aux_queue: stack.append(aux_queue.popleft()) return stack"},{"question":"You are given a matrix represented as a 2D grid with m rows and n columns initialized with these three possible values: - `-1`: A wall or obstacle. - `0` : A gate. - `INF`: An empty room, represented by the number 2147483647, indicating that it is farthest from any gate. Your task is to write a function that populates each empty room (`INF`) with the distance to its nearest gate. If it is impossible to reach a gate, the value should remain `INF`. Given the following example grid: ``` INF -1 0 INF INF INF INF -1 INF -1 INF -1 0 -1 INF INF ``` Your function should modify the grid in place to: ``` 3 -1 0 1 2 2 1 -1 1 -1 2 -1 0 -1 3 4 ``` # Function Signature ```python def walls_and_gates(rooms): pass ``` # Input - `rooms` [List[List[int]]]: A 2D list representing the grid. # Output - The function should modify the `rooms` grid in-place with the distances updated. # Constraints - Any cell value will be either `-1`, `0`, or `INF`. - You may assume the number of rows and columns in the grid does not exceed 200. # Performance Requirements Ensure that your solution is optimized to handle the worst-case scenario within constraints. # Hint Consider using Breadth-First Search (BFS) from each gate to achieve level-based shortest path computation.","solution":"from collections import deque def walls_and_gates(rooms): if not rooms: return INF = 2147483647 m, n = len(rooms), len(rooms[0]) queue = deque() # Collect all gates\' positions for i in range(m): for j in range(n): if rooms[i][j] == 0: # gate found queue.append((i, j)) # Directions for moving up, down, left, right directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] while queue: i, j = queue.popleft() for d in directions: ni, nj = i + d[0], j + d[1] if 0 <= ni < m and 0 <= nj < n and rooms[ni][nj] == INF: rooms[ni][nj] = rooms[i][j] + 1 queue.append((ni, nj))"},{"question":"Context Consider a scenario where you are working on a low-level embedded system where memory efficiency and fast bit manipulations are crucial. Given binary representations of numbers, you often need to insert bits at specific positions. Problem Statement Implement two functions, `insert_one_bit` and `insert_mult_bits`, that insert one bit and multiple bits respectively into specified positions of a binary number. Function Signatures ```python def insert_one_bit(num: int, bit: int, i: int) -> int: pass def insert_mult_bits(num: int, bits: int, length: int, i: int) -> int: pass ``` Input and Output Formats 1. For `insert_one_bit`: - **Input**: - `num`: an integer representing the binary number. - `bit`: an integer representing the bit to be inserted (0 or 1). - `i`: an integer representing the 0-based position at which the bit should be inserted. - **Output**: an integer representing the new binary number after bit insertion. 2. For `insert_mult_bits`: - **Input**: - `num`: an integer representing the binary number. - `bits`: an integer representing the sequence of bits to be inserted. - `length`: an integer representing the number of bits in `bits`. - `i`: an integer representing the 0-based position at which the bits should be inserted. - **Output**: an integer representing the new binary number after bit insertion. Specifications - All positions (`i`) are zero-based and valid within the range of the binary number. - The inserted bits should shift the existing bits to the left to make space for the new bits. - You are not allowed to use any built-in functions for directly manipulating bits. Constraints - `0 <= num <= 2^31 - 1` - `bit` is either `0` or `1` - `0 <= i <= 32` - `1 <= length <= 32` Examples ```python print(insert_one_bit(21, 1, 2)) # Expected Output: 45 (Binary: 10101 -> 101101) print(insert_mult_bits(5, 7, 3, 1)) # Expected Output: 47 (Binary: 101 -> 101111) ``` Performance Requirements Your solution should be efficient and work within constant time operations, O(1), with respect to bit length manipulation.","solution":"def insert_one_bit(num: int, bit: int, i: int) -> int: Inserts a single bit into the binary representation of num at position i. :param num: integer representing binary number :param bit: the bit to insert (0 or 1) :param i: the position to insert the bit :return: new number with bit inserted # Create a mask to shift the part after the insertion position mask = (1 << i) - 1 before = num & mask after = num & ~mask return (after << 1) | (bit << i) | before def insert_mult_bits(num: int, bits: int, length: int, i: int) -> int: Inserts multiple bits into the binary representation of num at position i. :param num: integer representing binary number :param bits: the bits to insert :param length: the number of bits in bits :param i: the position to insert the bits :return: new number with bits inserted # Create a mask for the insertion position mask = (1 << i) - 1 before = num & mask after = num & ~mask return (after << length) | (bits << i) | before"},{"question":"Question Prompt Design and implement a function that sorts an array using the Heap Sort algorithm. Specifically, implement the heap sort using a modified version of the Min Heap data structure, but also allow an optional simulation mode that outputs the state of the array at each iteration of the heapify process. The function signature should be: ```python def custom_heap_sort(arr, simulation=False): # Your implementation here ``` Requirements: 1. **Input**: - An array of integers `arr` that needs to be sorted. - An optional boolean `simulation` (default value is `False`), which, when set to `True`, outputs the state of the array after every iteration of the heapify process. 2. **Output**: - The function should return the sorted array in ascending order. - If `simulation` is `True`, it should print the state of the array at each iteration. 3. **Performance**: - Your implementation should have a time complexity of O(n log n). - Your implementation should be done in-place, with a space complexity of O(1). Edge Cases to Consider: - The input array can be empty. - The input array can have one element. - The input array can have all elements being the same. Example: ```python # Example usage: arr = [4, 10, 3, 5, 1] sorted_arr = custom_heap_sort(arr, simulation=True) print(sorted_arr) # Output should be: [1, 3, 4, 5, 10] ``` Notes: - Do not use built-in sorting functions. - Remember to handle edge cases. - Focus on optimizing the heapify process and minimizing unnecessary swaps.","solution":"def heapify(arr, n, i, simulation): smallest = i l = 2 * i + 1 r = 2 * i + 2 if l < n and arr[l] < arr[smallest]: smallest = l if r < n and arr[r] < arr[smallest]: smallest = r if smallest != i: arr[i], arr[smallest] = arr[smallest], arr[i] if simulation: print(arr) heapify(arr, n, smallest, simulation) def custom_heap_sort(arr, simulation=False): n = len(arr) # Build a min heap for i in range(n // 2 - 1, -1, -1): heapify(arr, n, i, simulation) # Extract elements from heap one by one for i in range(n - 1, 0, -1): arr[i], arr[0] = arr[0], arr[i] heapify(arr, i, 0, simulation) arr.reverse() # Convert to ascending order return arr"},{"question":"# Problem Description You are given a directed graph represented as an adjacency list, and you need to determine whether there exists a path from a given source node to a target node. The graph is implemented using a class `Graph`, which contains methods to add edges and perform a depth-first search (DFS) traversal. # Requirements 1. Implement the depth-first search (DFS) traversal in the Graph class to check if there exists a path from the source to the target node. 2. Handle typical edge cases and ensure optimal performance for large graphs with up to `10^5` vertices and edges. # Function Signature ```python def is_reachable(self, source: int, target: int) -> bool: ``` # Input - `source` (int): A node in the graph representing the starting point. - `target` (int): A node in the graph representing the destination point. # Output - (bool): Return `True` if there is a path from `source` to `target`, `False` otherwise. # Constraints - 1 <= number of vertices <= 100,000 - 0 <= number of edges <= 200,000 - Graph is connected. - Node values are within the range 0 to V-1 where V is the number of vertices. # Usage The Graph class and its methods should be implemented as follows: ```python class Graph: # existing methods def is_reachable(self, source: int, target: int) -> bool: # Your implementation here ``` # Example Given the graph: ``` 0 -> 1 0 -> 2 1 -> 2 2 -> 0 2 -> 3 3 -> 3 ``` For `is_reachable(1, 3)`, the output should be `True`. For `is_reachable(3, 1)`, the output should be `False`. # Note - Initialize an instance of the Graph class and add edges using `add_edge(source, target)`. - Implement the `is_reachable` method, ensuring it utilizes DFS to determine if a path exists.","solution":"class Graph: def __init__(self, vertices): self.V = vertices self.adj = [[] for _ in range(vertices)] def add_edge(self, source, target): self.adj[source].append(target) def is_reachable(self, source: int, target: int) -> bool: visited = [False] * self.V def dfs(v): if v == target: return True visited[v] = True for neighbour in self.adj[v]: if not visited[neighbour]: if dfs(neighbour): return True return False return dfs(source)"},{"question":"# Question: Encode and Decode Strings Given a list of strings, design an algorithm to encode it into a single string and decode that string back into the original list of strings. This problem assesses your ability to manipulate strings and handle efficient data serialization and deserialization. **Function Signatures**: ```python def encode(strs: List[str]) -> str: pass def decode(s: str) -> List[str]: pass ``` # Constraints * The input list can contain any number of strings (0 <= len(strs) <= 10^4). * Each string can be of any length (0 <= len(string) <= 100). * Strings consist of printable ASCII characters. # Input Format * **encode**: A list of strings, `strs`, which needs to be encoded into a single string: ```python strs = [\\"hello\\", \\"world\\"] ``` * **decode**: An encoded string, `s`, representing a list of strings: ```python s = \\"5:hello5:world\\" ``` # Output Format * **encode**: Return a single string that is the encoded representation of the input list. * **decode**: Return a list of strings that represents the decoded version of the input string. # Example: Example 1 ```python # Input strs = [\\"lint\\", \\"code\\", \\"love\\", \\"you\\"] # Process encoded_string = encode(strs) decoded_list = decode(encoded_string) # Output encoded_string => \\"4:lint4:code4:love3:you\\" decoded_list => [\\"lint\\", \\"code\\", \\"love\\", \\"you\\"] ``` # Performance Requirements The implemented solution should handle both encoding and decoding in linear time relative to the input size.","solution":"def encode(strs): Encodes a list of strings to a single string. encoded_str = \'\' for string in strs: encoded_str += f\\"{len(string)}:{string}\\" return encoded_str def decode(s): Decodes a single string to a list of strings. decoded_list = [] i = 0 while i < len(s): j = i # Find the length of the next string while s[j] != \':\': j += 1 length = int(s[i:j]) decoded_list.append(s[j+1:j+1+length]) i = j + 1 + length return decoded_list"},{"question":"Search in Rotated Sorted Array **Context**: You are building a search functionality for a system that logs records in a cyclic manner on a continuous time window basis. Due to the cyclic nature of records, your sorted array may be rotated around some unknown pivot. **Task**: Implement a function `search_rotated_array` that finds the index of a given target value in a rotated sorted array. If the target value is not present, the function should return -1. **Function Signature**: ```python def search_rotated_array(array: List[int], target: int) -> int: pass ``` **Inputs**: - `array` (List[int]): A list of integers sorted in ascending order and then rotated. - `target` (int): The target value to search for in the array. **Outputs**: - Returns the index of the target value in the array if found. Otherwise, returns -1. **Constraints**: - The array must be rotated and contain distinct integers. - You must aim for O(log n) time complexity. - The length of the array `n` will be between 1 and 10^4. **Example**: ```python print(search_rotated_array([4, 5, 6, 7, 0, 1, 2], 0)) # Output: 4 print(search_rotated_array([4, 5, 6, 7, 0, 1, 2], 3)) # Output: -1 print(search_rotated_array([1], 0)) # Output: -1 ``` **Additional Notes**: - Consider edge cases like an array being rotated to its original sorted order. - Ensure your solution is optimized for performance and handles recursive depth properly.","solution":"from typing import List def search_rotated_array(array: List[int], target: int) -> int: n = len(array) left, right = 0, n - 1 while left <= right: mid = (left + right) // 2 if array[mid] == target: return mid # Check if the left half is sorted if array[left] <= array[mid]: if array[left] <= target < array[mid]: right = mid - 1 else: left = mid + 1 # Otherwise, the right half must be sorted else: if array[mid] < target <= array[right]: left = mid + 1 else: right = mid - 1 return -1"},{"question":"Implementing and Testing Tarjan\'s Algorithm Context Given a directed graph with vertices and edges represented as an adjacency list, implement Tarjan\'s algorithm to find all strongly connected components (SCCs) of the graph. Your implementation should accurately identify SCCs and work efficiently. Function Signature ```python def tarjan_scc(adjacency_list): Implements Tarjan\'s Algorithm to find all strongly connected components in a directed graph. Input: - adjacency_list: A dictionary where keys are vertices and values are lists of adjacent vertices. Output: - A list of lists, where each inner list represents a strongly connected component in the graph. # Example Input: # adjacency_list = { # 0: [1], # 1: [2], # 2: [0, 3], # 3: [4], # 4: [5], # 5: [3] # } # tarjan_scc(adjacency_list) # Expected Output: [[3, 4, 5], [0, 1, 2]] ``` Constraints and Notes 1. **Input Type**: The input is a directed graph represented as an adjacency list, where keys are vertex identifiers (integers) and values are lists of adjacent vertices. 2. **Output Type**: The output should be a list of lists, where each inner list contains the vertices of a single SCC. 3. **Constraints**: - The vertices are numbered 0 to n-1 without gaps. - No self-loops or multiple edges between the same pair of vertices. 4. **Performance**: Ensure that your algorithm runs in O(V + E) time complexity. # Requirements * Implement Tarjan\'s algorithm within the provided function signature. * Consider edge cases like empty graphs, fully connected graphs, and graphs with disconnected components. * Write a set of test cases to validate your implementation against various graph configurations.","solution":"def tarjan_scc(adjacency_list): Implements Tarjan\'s Algorithm to find all strongly connected components in a directed graph. Input: - adjacency_list: A dictionary where keys are vertices and values are lists of adjacent vertices. Output: - A list of lists, where each inner list represents a strongly connected component in the graph. index = 0 stack = [] indices = {} low_link = {} on_stack = {} sccs = [] def strongconnect(v): nonlocal index indices[v] = index low_link[v] = index index += 1 stack.append(v) on_stack[v] = True for w in adjacency_list.get(v, []): if w not in indices: strongconnect(w) low_link[v] = min(low_link[v], low_link[w]) elif on_stack[w]: low_link[v] = min(low_link[v], indices[w]) if low_link[v] == indices[v]: scc = [] while stack: w = stack.pop() on_stack[w] = False scc.append(w) if w == v: break sccs.append(scc) for v in adjacency_list: if v not in indices: strongconnect(v) return sccs"},{"question":"# Context An online educational platform uses an interactive programming challenge where students are asked to identify the single character added to a string after it has been shuffled and an additional character inserted. # Challenge Given two strings `s` and `t` which consist of only lowercase letters. String `t` is generated by random shuffling of string `s` and then appending one more letter at a random position. Your task is to write a function to find the letter that was added to `t`. # Function Definition ```python def find_difference(s: str, t: str) -> str: # Implement the function here ``` # Input * `s` (string): a string of lowercase letters, length n. * `t` (string): a string of lowercase letters, length n+1. # Output * (char): the single letter that was added to `t`. # Constraints * Both strings consist of lowercase letters (a-z). * Only one letter will be different. # Performance Requirements * Time complexity should be O(n). * Space complexity should be O(1). # Example Example 1: ```text Input: s = \\"abcd\\" t = \\"abecd\\" Output: \'e\' ``` Example 2: ```text Input: s = \\"xyz\\" t = \\"zxyk\\" Output: \'k\' ``` # Note To solve this challenge, make use of bitwise XOR operations which can help in contrasting the subtle differences between the characters in `s` and `t`. This approach ensures efficiency without additional storage needs.","solution":"def find_difference(s: str, t: str) -> str: Find the letter that was added to string t. result = 0 for char in s + t: result ^= ord(char) return chr(result)"},{"question":"**Problem Statement**: You have been tasked with implementing a function that calculates the Least Common Multiple (LCM) of an array of integers using a combination of Euclid\'s algorithm for GCD and the provided LCM formula. You must also handle various edge cases gracefully, such as non-integer inputs or an empty list. **Function Signature**: ```python def lcm_array(arr): Computes the Least Common Multiple (LCM) of a list of integers. Parameters: arr (List[int]): A list of non-negative integers Returns: int: The LCM of the list of numbers. Raises: ValueError: If the array contains non-integer values or is empty. ``` **Input**: - `arr`: A list of non-negative integers. **Output**: - Return the LCM of the integer list. **Constraints**: - The input list will have at least one element. - Elements in the list will be non-negative integers. - You should handle invalid inputs by raising a `ValueError`. **Examples**: - Input: `[3, 4, 5]` Output: `60` - Input: `[7, 13, 29]` Output: `2639` - Input: `[0, 5]` Output: `0` **Additional Context**: The LCM of an array can be computed by repeated pairwise LCM calculations. For two numbers `a` and `b`, the LCM is computed as: [ text{LCM}(a, b) = frac{|a times b|}{text{GCD}(a, b)} ] Implement a helper function for GCD using Euclid\'s algorithm and the main function to handle the entire array.","solution":"import math from functools import reduce def gcd(a, b): Calculates the Greatest Common Divisor (GCD) of two numbers using Euclid\'s algorithm. while b: a, b = b, a % b return a def lcm(a, b): Calculates the Least Common Multiple (LCM) of two numbers using the relationship LCM(a, b) = abs(a * b) // GCD(a, b). if a == 0 or b == 0: return 0 return abs(a * b) // gcd(a, b) def lcm_array(arr): Computes the Least Common Multiple (LCM) of a list of integers. Parameters: arr (List[int]): A list of non-negative integers Returns: int: The LCM of the list of numbers. Raises: ValueError: If the array contains non-integer values or is empty. if not arr: raise ValueError(\\"Array must not be empty\\") for num in arr: if not isinstance(num, int) or num < 0: raise ValueError(\\"All elements in array must be non-negative integers\\") # Reduce the list by computing the LCM iteratively return reduce(lcm, arr)"},{"question":"**Context**: In the field of digital communications, determining how different two message strings are can be crucial for error detection and correction. The difference can be quantified by counting the number of bits that differ between two binary representations of the messages. **Question**: Write a function `count_flips_to_convert` to determine the minimum number of bits you need to flip to convert one integer into another. # Function Signature: ```python def count_flips_to_convert(a: int, b: int) -> int: # Your implementation here ``` # Input: * Two non-negative integers, `a` and `b`. # Output: * An integer representing the minimal number of bits needed to be flipped to convert integer `a` to integer `b`. # Constraints: * `0 <= a, b <= 2^31 - 1` # Examples: 1. **Input**: `a = 29`, `b = 15` - **Output**: `2` - **Explanation**: `29` in binary is `11101`, and `15` in binary is `01111`. The differing bits are at positions 1 and 4 (counting from the right), so 2 bits need to be flipped. 2. **Input**: `a = 0`, `b = 0` - **Output**: `0` - **Explanation**: No bits need to be flipped since both are 0. 3. **Input**: `a = 1024`, `b = 1` - **Output**: `2` - **Explanation**: `1024` in binary is `10000000000`, and `1` in binary is `1`. The differing bits are at the last position and the 11th position. # Additional Notes: * Consider edge cases where `a` and `b` are the same. * Ensure your function is efficient and follows the constraints provided.","solution":"def count_flips_to_convert(a: int, b: int) -> int: Returns the number of bits that need to be flipped to convert integer a to integer b. # XOR the two numbers to find differing bits differing_bits = a ^ b # Count the number of 1s in the binary representation of differing_bits return bin(differing_bits).count(\'1\')"},{"question":"**Problem Statement:** You are given a list of non-negative integers where each integer represents a digit of a non-negative number. The list is arranged such that the most significant digit is at the head of the list. Your task is to write a function that increments the number represented by the list by one and returns the resulting list of digits. **Function Signature:** ```python def increment_number(digits: List[int]) -> List[int]: pass ``` **Input:** - `digits`: A list of integers `List[int]`, where each integer is in the range of 0 to 9. **Output:** - A list of integers `List[int]` representing the number incremented by one. **Constraints:** - The input list will contain at least one digit. - The number represented by the input list is non-negative. **Examples:** ```python assert increment_number([1, 2, 3]) == [1, 2, 4] assert increment_number([4, 3, 9, 9]) == [4, 4, 0, 0] assert increment_number([9, 9, 9]) == [1, 0, 0, 0] ``` **Explanation:** 1. For the input `[1, 2, 3]`, adding 1 results in `[1, 2, 4]`. 2. For the input `[4, 3, 9, 9]`, adding 1 results in `[4, 4, 0, 0]` because of the carry-over. 3. For the input `[9, 9, 9]`, adding 1 produces a carry-over through every digit resulting in `[1, 0, 0, 0]`. **Important Points to Consider:** - The function should handle edge cases such as the input list containing only the digit `9`. - Ensure optimal performance with a time complexity of O(n) where n is the length of the list. - Attempt to minimize space complexity by modifying the list in place if possible, avoiding unnecessary use of memory.","solution":"from typing import List def increment_number(digits: List[int]) -> List[int]: n = len(digits) # Start from the last digit and proceed backwards for i in range(n-1, -1, -1): if digits[i] < 9: digits[i] += 1 return digits else: digits[i] = 0 # If all digits are 9, we need an extra leading 1 return [1] + digits"},{"question":"**Finding Two Minimum Elements Indices That Sum Up to a Target** # Problem Statement You are given an array of integers and a target number. Your task is to write a function `min_two_sum_indices` that returns the indices of two numbers in the array such that their sum is equal to a specific target. If there are multiple pairs, return the pair with the smallest indices. The solution must be efficient with a focus on time complexity. # Function Signature ```python def min_two_sum_indices(nums: List[int], target: int) -> Tuple[int, int]: pass ``` # Input * `nums`: A list of integers (e.g., `[2, 7, 11, 15]`). * `target`: An integer representing the target sum (e.g., `9`). # Output * A tuple containing two integers representing the indices of the two numbers that add up to the target (e.g., `(0, 1)`). # Constraints 1. The length of `nums` will be at most `10^4`. 2. Each element in `nums` will be an integer in the range `[-10^9, 10^9]`. 3. There will always be exactly one solution. # Examples Example 1 * Input: `nums = [2, 7, 11, 15]`, `target = 9` * Output: `(0, 1)` Example 2 * Input: `nums = [3, 2, 4]`, `target = 6` * Output: `(1, 2)` Example 3 * Input: `nums = [3, 3]`, `target = 6` * Output: `(0, 1)` # Notes * It is guaranteed that there is exactly one solution. * An efficient solution is required, ideally O(n) time complexity with O(n) auxiliary space. # Additional Challenge If you\'re confident with the standard implementation, try optimizing the space complexity of your solution.","solution":"from typing import List, Tuple def min_two_sum_indices(nums: List[int], target: int) -> Tuple[int, int]: Returns a tuple containing the indices of the two numbers in the array that add up to the target. Arguments: nums -- list of integers target -- integer Returns: tuple containing two integers representing the indices of the two numbers that add up to the target. num_to_index = {} for i, num in enumerate(nums): complement = target - num if complement in num_to_index: return (num_to_index[complement], i) num_to_index[num] = i # per the problem statement, we are guaranteed that there is exactly one solution return (-1, -1) # This shouldn\'t be reached"},{"question":"# Matrix Multiplication Coding Challenge Problem Statement Matrix multiplication is a common operation in various computational fields. In this task, you are required to write a function `multiply` that takes two 2D lists of integers, representing matrices, and returns their product. Function Signature ```python def multiply(multiplicand: list[list[int]], multiplier: list[list[int]]) -> list[list[int]]: ``` Input 1. `multiplicand`: A list of lists of integers representing the first matrix (A). Its dimensions are (m times n). 2. `multiplier`: A list of lists of integers representing the second matrix (B). Its dimensions are (n times p). Output The function should return a 2D list of integers representing the matrix product (C), where (C[i][j]) is the dot product of the (i)-th row of (A) and the (j)-th column of (B). The dimensions of (C) will be (m times p). Constraints * `1 <= m, n, p <= 100` (You can assume no empty matrices) * Elements of matrices are integers within the range (-10^3) to (10^3). Example ```python # Example 1: multiplicand = [ [1, 2], [3, 4] ] multiplier = [ [5, 6], [7, 8] ] # Returns [ # [19, 22], # [43, 50] # ] # Example 2: multiplicand = [ [2, 0], [1, 1] ] multiplier = [ [3, 2], [5, 4] ] # Returns [ # [6, 4], # [8, 6] # ] ``` Notes * If the number of columns of the `multiplicand` matrix does not equal the number of rows of the `multiplier` matrix, your function should raise an exception with the message \\"Multiplicand matrix not compatible with Multiplier matrix.\\" * Focus on the correctness and efficiency of your implementation.","solution":"def multiply(multiplicand: list[list[int]], multiplier: list[list[int]]) -> list[list[int]]: # Get the dimensions of the input matrices m, n = len(multiplicand), len(multiplicand[0]) n2, p = len(multiplier), len(multiplier[0]) # Check if matrices are compatible for multiplication if n != n2: raise ValueError(\\"Multiplicand matrix not compatible with Multiplier matrix.\\") # Create output matrix with dimensions m x p initialized to zeroes result = [[0] * p for _ in range(m)] # Perform matrix multiplication for i in range(m): for j in range(p): for k in range(n): result[i][j] += multiplicand[i][k] * multiplier[k][j] return result"},{"question":"# Question You are tasked with implementing a modified version of the combination sum problem. Given a set of candidate numbers (C) (without duplicates) and a target number (T), find all unique **combinations** in (C) where the candidate numbers **at most once each** sum to (T). Unlike the original problem, each candidate number may be used only once. # Function Signature ```python def combination_sum_no_repeat(candidates: List[int], target: int) -> List[List[int]]: pass ``` # Input - `candidates`: A list of distinct integers (1 <= len(candidates) <= 20). - `target`: A positive integer (1 <= target <= 50). # Output - Return a list of lists, where each list is a unique combination of numbers in `candidates` that add up to the `target`. # Constraints - Each number in the candidates list can be used **only once** in the combination. - No duplicate combinations should be returned. # Example Example 1: ```python candidates = [2, 3, 6, 7] target = 7 ``` Output: ```python [ [7] ] ``` Example 2: ```python candidates = [2, 3, 5] target = 8 ``` Output: ```python [ [3, 5] ] ``` # Instructions: - Ensure your solution optimally handles the input constraints. - Consider edge cases like empty lists and a target that can\'t be formed by any combination.","solution":"from typing import List def combination_sum_no_repeat(candidates: List[int], target: int) -> List[List[int]]: Returns all unique combinations in candidates where the candidate numbers add up to target. Each candidate number may be used only once in the combination. def backtrack(start, path, target): if target == 0: result.append(path) return if target < 0: return for i in range(start, len(candidates)): # avoid duplicates by skipping the same element in the same position if i > start and candidates[i] == candidates[i - 1]: continue backtrack(i + 1, path + [candidates[i]], target - candidates[i]) candidates.sort() result = [] backtrack(0, [], target) return result"},{"question":"# Question Statement You are tasked with enhancing a library for cryptographic functions, specifically focusing on primality testing. Implement the `is_prime()` function as described, using the Rabin-Miller algorithm, which determines whether a given number ( n ) is prime. # Requirements: 1. **Function Name**: `is_prime` 2. **Input**: - An integer ( n ) where ( n geq 2 ). - An integer ( k ) representing the number of iterations for accuracy (higher ( k ) means more reliable results). 3. **Output**: - A boolean value: `True` if ( n ) is probably prime, `False` if it is definitely composite. # Constraints: - The function must handle very large integers efficiently. - Aim for a time complexity of O(k * log^3(n)). # Example: ```python print(is_prime(31, 5)) # Expected output: True (31 is prime) print(is_prime(25, 5)) # Expected output: False (25 is composite) print(is_prime(2, 5)) # Expected output: True (2 is prime) print(is_prime(1, 5)) # Expected output: False (1 is not prime) ``` # Explanation: - For ( n = 31 ) with ( k = 5 ), the function performs 5 iterations to test 31 for primality. Given prime ( n ), it should return `True`. - For ( n = 25 ) and ( k = 5 ), 25 should quickly be identified as composite and return `False`. - Handle edge cases where ( n ) is at the lower bound of valid prime numbers (e.g., 2). **Note**: Ensure the function is robust, optimized for large values, and handles all edge cases effectively. # Tips: - Use modular exponentiation for efficient power calculations. - Consider special handling for edge cases involving small values of ( n ).","solution":"import random def is_prime(n, k): Determine if a number n is prime using the Rabin-Miller algorithm with k iterations. :param n: The number to test for primality. Must be n >= 2. :param k: The number of iterations for accuracy. :return: True if n is probably prime, False if it is definitely composite. # Edge case for small n if n <= 1: return False if n <= 3: return True if n % 2 == 0: return False # Function to perform modular exponentiation def power_mod(base, exp, mod): result = 1 base = base % mod while exp > 0: if exp % 2 == 1: result = (result * base) % mod exp = exp >> 1 base = (base * base) % mod return result # Write n - 1 as d * 2^r r, d = 0, n - 1 while d % 2 == 0: d //= 2 r += 1 # Witness loop: perform k trials for _ in range(k): a = random.randint(2, n - 2) x = power_mod(a, d, n) if x == 1 or x == n - 1: continue for _ in range(r - 1): x = power_mod(x, 2, n) if x == n - 1: break else: return False return True"},{"question":"# Three Sum Problem Write a function `three_sum(nums: List[int]) -> Set[Tuple[int, int, int]]` that takes a list of integers and returns a set of unique triplets (three-element tuples) such that the sum of the elements in each triplet is zero. The solution should avoid duplicate triplets. Function Signature ```python def three_sum(nums: List[int]) -> Set[Tuple[int, int, int]]: ``` Input * `nums`: A list of integers (`List[int]`), where `3 <= len(nums) <= 10^4` and `-10^4 <= nums[i] <= 10^4`. Output * A set of tuples, where each tuple contains exactly three integers that add up to zero. No two tuples should be identical. Example ```python nums = [-1, 0, 1, 2, -1, -4] output = {(-1, -1, 2), (-1, 0, 1)} ``` Constraints * The solution must not include duplicate triplets. * The input list may contain duplicates, and it can have positive, negative, or zero integers. Requirements * Ensure the output is a set of tuples, each tuple containing integers in ascending order. * Optimize the solution for both time and space complexities, considering the input constraints. # Scenario You are working on a financial application that needs to identify patterns in transaction data. One aspect involves finding groups of three transactions that sum to zero, which might indicate a balance of losses and gains. Your algorithm will be vital for identifying these triplets efficiently, ensuring accurate and fast analysis especially with large and potentially repetitive datasets.","solution":"from typing import List, Set, Tuple def three_sum(nums: List[int]) -> Set[Tuple[int, int, int]]: nums.sort() result = set() for i in range(len(nums)): if i > 0 and nums[i] == nums[i-1]: continue left, right = i+1, len(nums)-1 while left < right: current_sum = nums[i] + nums[left] + nums[right] if current_sum == 0: result.add((nums[i], nums[left], nums[right])) while left < right and nums[left] == nums[left + 1]: left += 1 while left < right and nums[right] == nums[right - 1]: right -= 1 left += 1 right -= 1 elif current_sum < 0: left += 1 else: right -= 1 return result"},{"question":"# Pigeonhole Sort Implementation and Analysis Background Pigeonhole sort is a non-comparison integer sorting algorithm known for its efficiency in situations where the range of values in the input list is not significantly larger than the list length. It distributes elements into \\"holes\\" based on their value and then retrieves them in sorted order. Task You are required to implement the pigeonhole sort algorithm given an array of integers. You must handle various edge cases and ensure the algorithm works efficiently within its constraints. Requirements 1. **Function Signature**: `def pigeonhole_sort(arr: List[int]) -> List[int]:` 2. **Input**: A list of integers, `arr`, where `len(arr) <= 10^5` and each integer in the list satisfies `-10^6 <= element <= 10^6`. 3. **Output**: A new sorted list of integers. Constraints - The function should maintain a time complexity of O(n + Range). - The function should maintain a space complexity of O(Range). Performance Requirements - Ensure handling of edge cases such as an array with a single element, duplicate values, and very large or very small numbers. Example ```python # Example 1 input = [8, 3, 10, 5, 1, 4] output = [1, 3, 4, 5, 8, 10] # Example 2 input = [5, 5, 5, 5] output = [5, 5, 5, 5] # Example 3 input = [1] output = [1] ``` Your implementation must consider the edge cases and ensure the algorithm operates within the defined time and space complexity constraints.","solution":"def pigeonhole_sort(arr): Implements the pigeonhole sort algorithm to sort a list of integers. :param arr: List[int] - a list of integers :return: List[int] - the sorted list of integers if len(arr) == 0: return [] min_value = min(arr) max_value = max(arr) size = max_value - min_value + 1 holes = [0] * size for number in arr: holes[number - min_value] += 1 sorted_arr = [] for index in range(size): while holes[index] > 0: sorted_arr.append(index + min_value) holes[index] -= 1 return sorted_arr"},{"question":"# Scenario You are implementing a feature for a new website\'s signup page that enforces strong password policies. To ensure the security of user accounts, you must validate passwords according to the given requirements. If a password does not meet these criteria, you must determine the minimum number of additional characters required to make it strong. # Function Specification **Function Name**: `strong_password` **Input**: 1. An integer `n`: The length of the password 2. A string `password`: The password string typed by the user **Output**: * An integer: The minimum number of characters that need to be added to make the password strong. **Constraints**: * (1 leq n leq 100) * The password will consist of characters from the sets: - `numbers = \\"0123456789\\"` - `lower_case = \\"abcdefghijklmnopqrstuvwxyz\\"` - `upper_case = \\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\\"` - `special_characters = \\"!@#%^&*()-+\\"` # Examples **Example 1**: ```python n = 3 password = \\"Ab1\\" ``` **Output**: ```python 3 ``` **Explanation**: The password \\"Ab1\\" needs three more characters to reach the minimum required length of 6. She can add characters like hk, making it \\"Ab1hk\\". **Example 2**: ```python n = 11 password = \\"#Algorithms\\" ``` **Output**: ```python 1 ``` **Explanation**: The password \\"#Algorithms\\" needs at least one digit to meet all the requirements. Adding any digit will make the password strong. # Constraints * Handle all password lengths and character scenarios specified. * Ensure performance and efficiency up to the constraint limits. # Notes Write a function `strong_password(n, password)` to solve the problem using the outlined requirements. Test edge cases and larger inputs to ensure robustness.","solution":"def strong_password(n, password): Determines the minimum number of characters that need to be added to make the password strong. # Sets of required character types numbers = set(\\"0123456789\\") lower_case = set(\\"abcdefghijklmnopqrstuvwxyz\\") upper_case = set(\\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\\") special_characters = set(\\"!@#%^&*()-+\\") # Flags to determine if the password contains the required character types has_number = False has_lower = False has_upper = False has_special = False # Check what types of characters are present in the password for char in password: if char in numbers: has_number = True elif char in lower_case: has_lower = True elif char in upper_case: has_upper = True elif char in special_characters: has_special = True # Count the number of missing types missing_types = 4 - sum([has_number, has_lower, has_upper, has_special]) # The minimum length requirement is 6 min_password_length = 6 # Calculate the minimum number of characters needed to add characters_to_add = max(missing_types, min_password_length - n) return characters_to_add"},{"question":"Implement Rabin-Karp for Multiple Pattern Matching Given a list of patterns and a large text, implement the Rabin-Karp algorithm to find the starting index of each pattern in the text. If a pattern is not found, return `None` for that pattern. Function Signature ```python def multi_pattern_rabin_karp(patterns, text): Finds the starting index of each pattern in the given text. :param patterns: List of strings, the patterns to search for. :param text: String, the text to search within. :return: List of integers, starting indices of each pattern. If a pattern is not found, return None for that pattern. ``` # Input * `patterns`: List of non-empty strings, 1 <= len(patterns[i]) <= 10^4 * `text`: Non-empty string, 1 <= len(text) <= 10^5 # Output * A list of integers, the starting indices of the patterns in the text. If a pattern is not found, the corresponding entry should be `None`. # Constraints * The text and all patterns consist only of lowercase English letters. # Example ```python patterns = [\\"abc\\", \\"bca\\", \\"xyz\\"] text = \\"abcabcabcxyz\\" print(multi_pattern_rabin_karp(patterns, text)) # Output: [0, 1, 9] ``` # Guidelines * Ensure to handle edge cases where the pattern or the text might be empty. * Optimize the hash function to minimize collisions. * You can assume the ASCII values for lowercase English letters are used. * Aim for an efficient solution within the provided constraints.","solution":"def multi_pattern_rabin_karp(patterns, text): Finds the starting index of each pattern in the given text. :param patterns: List of strings, the patterns to search for. :param text: String, the text to search within. :return: List of integers, starting indices of each pattern. If a pattern is not found, return None for that pattern. def hash_func(s, prime=101): Simple hash function for a string. h = 0 for char in s: h = h * prime + ord(char) return h def recalculate_hash(old_hash, left_char, right_char, pattern_len, prime=101): Recalculate hash by sliding the window new_hash = old_hash - ord(left_char) * (prime ** (pattern_len - 1)) new_hash = new_hash * prime + ord(right_char) return new_hash def rabin_karp_search(pattern, text): Search a single pattern in text using Rabin-Karp m, n = len(pattern), len(text) if m > n: return None pattern_hash = hash_func(pattern) text_hash = hash_func(text[:m]) for i in range(n - m + 1): if pattern_hash == text_hash: if text[i:i+m] == pattern: # Verify to handle hash collision return i if i < n - m: text_hash = recalculate_hash(text_hash, text[i], text[i+m], m) return None results = [] for pattern in patterns: results.append(rabin_karp_search(pattern, text)) return results"},{"question":"Scenario You are tasked with an efficient search of elements in a matrix where each row and each column is sorted in non-decreasing order. Given the constraints of the systems handling the matrices, optimizing the search operation is crucial to maintaining performance standards. Problem Statement Write a function `search_in_sorted_matrix(matrix, key)` that takes a matrix `matrix` and a single integer `key` as input, and returns the position (row and column) of the `key` in the matrix if it is present. Otherwise, return `None`. The matrix is guaranteed to have each of its rows and columns sorted in non-decreasing order. Function Signature ```python def search_in_sorted_matrix(matrix, key): # your code here ``` Expected Input and Output Formats * **Input**: * `matrix`: A list of lists (2D list), where each list represents a row in the matrix. * `key`: An integer to search in the matrix. * **Output**: * A tuple `(row, column)` representing the 1-based index of the found key. * If the key is not found, return `None`. Example ```python matrix = [ [2, 5, 7], [4, 8, 13], [9, 11, 15], [12, 17, 20] ] key = 13 result = search_in_sorted_matrix(matrix, key) print(result) # Output: (2, 3) key = 10 result = search_in_sorted_matrix(matrix, key) print(result) # Output: None ``` Constraints * The matrix dimensions are between 1x1 and 1000x1000. * The key may or may not be present in the matrix. * Time complexity should be O(m+n) where `m` is the number of rows and `n` is the number of columns. * Space complexity should be O(1).","solution":"def search_in_sorted_matrix(matrix, key): Searches for the key in a sorted matrix and returns the position (1-based) if found. If not found, returns None. :param matrix: List[List[int]] - A 2D list with rows and columns sorted in non-decreasing order. :param key: int - The integer to search in the matrix. :return: tuple or None - (row, column) if the key is found, otherwise None. if not matrix or not matrix[0]: return None row_count = len(matrix) col_count = len(matrix[0]) # Start from the top right corner row = 0 col = col_count - 1 while row < row_count and col >= 0: if matrix[row][col] == key: return (row + 1, col + 1) elif matrix[row][col] > key: col -= 1 else: row += 1 return None"},{"question":"**Task**: Write a Python function to determine if there is a path between two nodes in a directed graph using Depth-First Search (DFS). **Scenario**: Imagine you are a software developer working on a navigation system for a delivery company. The delivery routes are represented as a directed graph where intersections are nodes, and streets are directed edges connecting these nodes. You need to determine if there is a delivery route from a specified starting point to a destination. **Function Signature**: ```python def is_path_available(vertex_count: int, edges: List[Tuple[int, int]], source: int, target: int) -> bool: pass ``` **Input**: - `vertex_count`: An integer representing the number of vertices in the graph. - `edges`: A list of tuples, where each tuple `(source, target)` represents a directed edge from `source` to `target`. - `source`: An integer representing the starting node. - `target`: An integer representing the destination node. **Output**: - Returns `True` if there is a path from `source` to `target`, `False` otherwise. **Constraints**: - `1 <= vertex_count <= 10^5` - `0 <= source, target < vertex_count` - `0 <= len(edges) <= 10^6` **Performance Requirements**: - The solution should be efficient to handle large inputs within a reasonable time. **Example**: ```python vertex_count = 5 edges = [(0, 1), (1, 2), (2, 3), (3, 4), (4, 0)] source = 0 target = 3 # Expected output: True (0 -> 1 -> 2 -> 3 is a valid path) vertex_count = 5 edges = [(0, 1), (1, 2), (2, 3), (3, 4)] source = 0 target = 4 # Expected output: True (0 -> 1 -> 2 -> 3 -> 4 is a valid path) vertex_count = 5 edges = [(0, 1), (1, 2), (2, 3)] source = 0 target = 4 # Expected output: False (No path from 0 to 4) ``` **Instructions**: 1. Implement the function `is_path_available` using DFS. 2. Consider edge cases such as disconnected graphs or self-loops. 3. Ensure that your implementation handles large graphs efficiently.","solution":"from typing import List, Tuple def is_path_available(vertex_count: int, edges: List[Tuple[int, int]], source: int, target: int) -> bool: Determines if there is a path between source and target in a directed graph using DFS. # Create adjacency list for the graph graph = {i: [] for i in range(vertex_count)} for u, v in edges: graph[u].append(v) # Perform DFS from the source node def dfs(v): if v == target: return True visited.add(v) for neighbor in graph[v]: if neighbor not in visited: if dfs(neighbor): return True return False visited = set() return dfs(source)"},{"question":"# Question: Filter List with Occurrence Limit You are tasked with writing a function `filter_list_limit_occurrences` to filter a given list such that each element appears at most N times, preserving the original order of elements. Function Signature ```python def filter_list_limit_occurrences(lst: List[int], n: int) -> List[int]: ``` Input * `lst` (List[int]): A list of integers. * `n` (int): A positive integer representing the maximum number of times any element should appear in the returned list. Output * Returns a new list where each element from the input list appears at most `n` times. Constraints * The list length will be in the range [0, 10^5]. * The integers in the list will be in the range [0, 10^9]. * `n` will be in the range [0, 10^5]. Examples 1. **Example 1** ```python input_list = [1, 2, 3, 1, 2, 1, 2, 3] n = 2 ``` Output: ```python [1, 2, 3, 1, 2, 3] ``` 2. **Example 2** ```python input_list = [1, 1, 1, 1] n = 2 ``` Output: ```python [1, 1] ``` 3. **Example 3** ```python input_list = [] n = 1 ``` Output: ```python [] ``` Guidelines 1. Ensure that your implementation runs efficiently on large inputs. 2. Consider edge cases such as empty lists, n = 0, and lists with all identical elements. 3. Do not use any built-in filtering or counting methods; write the logic yourself. Use the following template to write your solution: ```python def filter_list_limit_occurrences(lst: List[int], n: int) -> List[int]: counts = collections.defaultdict(int) result = [] for num in lst: if counts[num] < n: result.append(num) counts[num] += 1 return result ``` Good luck!","solution":"from typing import List import collections def filter_list_limit_occurrences(lst: List[int], n: int) -> List[int]: counts = collections.defaultdict(int) result = [] for num in lst: if counts[num] < n: result.append(num) counts[num] += 1 return result"},{"question":"# Question: Generate Expressions to Match Target Given a string `num` that contains only digits (\'0\'-\'9\') and an integer `target`, you are required to write a function `generate_expressions(num, target)` which adds binary operators (`+`, `-`, `*`) between the digits so as to evaluate the constructed expression to the target value. # Requirements: 1. **Function Signature**: ```python def generate_expressions(num: str, target: int) -> List[str]: ``` 2. **Parameters**: - `num`: A string that contains only digits (0-9) and is non-empty. - `target`: An integer which the expression should evaluate to. 3. **Returns**: - A list of strings where each string represents a valid expression formed by adding \'+\' , \'-\' , \'*\' between digits which evaluates to `target`. # Constraints: - The length of `num` will be less than or equal to 10. - Leading zeros must be appropriately handled (e.g., \\"105\\" can become \\"1*0+5\\" but \\"1*05\\" is invalid). - The order of results does not matter. # Example: ```python generate_expressions(\\"123\\", 6) # Expected Output: [\\"1+2+3\\", \\"1*2*3\\"] generate_expressions(\\"232\\", 8) # Expected Output: [\\"2*3+2\\", \\"2+3*2\\"] generate_expressions(\\"105\\", 5) # Expected Output: [\\"1*0+5\\", \\"10-5\\"] generate_expressions(\\"00\\", 0) # Expected Output: [\\"0+0\\", \\"0-0\\", \\"0*0\\"] generate_expressions(\\"3456237490\\", 9191) # Expected Output: [] ``` **Note**: - Ensure that the function correctly handles the possibility of multiple solutions and edge cases (repeated zeros). - Efficiency considerations must keep the function within acceptable runtime for given constraints.","solution":"from typing import List def generate_expressions(num: str, target: int) -> List[str]: def helper(index, prev_operand, current_operand, value, string): if index == len(num): if value == target and current_operand == 0: results.append(\\"\\".join(string[1:])) return # Extend the current_operand by one digit current_operand = current_operand * 10 + int(num[index]) str_op = str(current_operand) # NO leading zeroes should be added if current_operand > 0: helper(index + 1, prev_operand, current_operand, value, string) # ADDITION string.append(\'+\') string.append(str_op) helper(index + 1, current_operand, 0, value + current_operand, string) string.pop() string.pop() # SUBTRACTION if len(string) > 0: # cannot put a unary minus at the beginning string.append(\'-\') string.append(str_op) helper(index + 1, -current_operand, 0, value - current_operand, string) string.pop() string.pop() # MULTIPLICATION if len(string) > 0: string.append(\'*\') string.append(str_op) helper(index + 1, current_operand * prev_operand, 0, value - prev_operand + (current_operand * prev_operand), string) string.pop() string.pop() results = [] helper(0, 0, 0, 0, []) return results"},{"question":"# Coding Challenge: Optimized Square Root Calculation As a software developer, your task is to implement a function that calculates the square root of a given positive integer `N` with a specified precision factor `P` using an efficient numerical method. Your function should follow these requirements: * Input: * `N` (positive integer): The number whose square root needs to be determined. * `P` (positive float): The precision factor, which should determine the maximum allowable error in the output. * Output: * A float which is the estimated square root of `N`, such that the difference between the actual square root and the estimated value should be within `P`. **Function Signature**: ```python def square_root(N: int, P: float) -> float: pass ``` # Constraints: * `1 <= N <= 10^9` * `0 < P <= 0.1` # Performance Requirements: * The implementation should converge quickly, ideally in logarithmic time relative to `N`. # Example: ```python assert abs(square_root(5, 0.001) - 2.236) < 0.001 assert abs(square_root(10, 0.0001) - 3.1623) < 0.0001 ``` # Additional Context: You may assume that the inputs provided will be valid and within the specified constraints. Ensure that your solution does not run into infinite loops and handles edge cases appropriately, such as extremely large values of `N`.","solution":"def square_root(N: int, P: float) -> float: Returns the square root of N with a specified precision P using binary search. if N == 0 or N == 1: return N low = 0 high = N mid = (low + high) / 2.0 while abs(mid * mid - N) > P: if mid * mid < N: low = mid else: high = mid mid = (low + high) / 2.0 return mid"},{"question":"You are tasked to design an algorithm and implement two functions, `encode` and `decode`, that will help in encoding a list of strings to a single string, and then decodes it back to the original list. This is particularly useful for scenarios where you need to send lists of strings over the network or store them efficiently. # Function Descriptions: **1. `encode`:** Convert a list of strings into a single encoded string. - **Input**: List of strings `strs` where each string can contain any printable characters. - **Output**: A single encoded string. **2. `decode`:** Convert an encoded string back into the original list of strings. - **Input**: An encoded string `s` produced by the `encode` function. - **Output**: List of original strings. # Constraints: - The list of strings (in `strs`) can be empty. - Each string in the list can be of arbitrary length and can contain any characters including numbers and colons. # Requirements: - Your solution should efficiently handle lists with a large number of strings. - Ensure that the original list of strings is accurately restored after encoding and decoding. - The encoding should be implemented in a way that no information is lost, and decoding should be straightforward. # Example: ```python # Example usage strs = [\\"hello\\", \\"world\\", \\"foo\\", \\"bar\\"] encoded_string = encode(strs) print(encoded_string) # Example: \\"5:hello5:world3:foo3:bar\\" decoded_list = decode(encoded_string) print(decoded_list) # Output: [\\"hello\\", \\"world\\", \\"foo\\", \\"bar\\"] ``` # Edge Cases: - Encoding and decoding an empty list, `[]`. - Encoding and decoding strings that contain colons, numbers, and special characters. Implement the `encode` and `decode` functions: ```python def encode(strs): Encodes a list of strings to a single string. :type strs: List[str] :rtype: str res = \'\' for string in strs: res += str(len(string)) + \\":\\" + string return res def decode(s): Decodes a single string to a list of strings. :type s: str :rtype: List[str] strs = [] i = 0 while i < len(s): index = s.find(\\":\\", i) size = int(s[i:index]) strs.append(s[index+1: index+1+size]) i = index+1+size return strs ```","solution":"def encode(strs): Encodes a list of strings to a single string. :type strs: List[str] :rtype: str res = \'\' for string in strs: res += str(len(string)) + \\":\\" + string return res def decode(s): Decodes a single string to a list of strings. :type s: str :rtype: List[str] strs = [] i = 0 while i < len(s): index = s.find(\\":\\", i) size = int(s[i:index]) strs.append(s[index+1: index+1+size]) i = index+1+size return strs"},{"question":"You are provided with two functions designed to compute the exponentiation of given integers, optionally modulo another integer: 1. **Iterative Version**: `power(a: int, n: int, mod: int = None)` 2. **Recursive Version**: `power_recur(a: int, n: int, mod: int = None)` # Task Implement a function `validate_exponentiation(a: int, n: int, mod: int = None) -> bool` that checks if both the iterative and recursive versions of the given exponentiation functions produce the same result for given inputs and computes within the specified complexity. # Function Signature ```python def validate_exponentiation(a: int, n: int, mod: int = None) -> bool: pass ``` # Input * `a`: An integer base (0 ≤ `a` ≤ 10^9). * `n`: An integer exponent (0 ≤ `n` ≤ 10^9). * `mod`: An optional integer for modulo operation (1 ≤ `mod` ≤ 10^9). # Output * Return `True` if both the iterative `power` and recursive `power_recur` functions compute the same result; otherwise, return `False`. # Constraints 1. If `mod` is not provided, compute the exponentiation without modulus. 2. The functions should handle edge cases gracefully, such as when `a` or `n` is zero. # Example ```python assert validate_exponentiation(2, 10) == True assert validate_exponentiation(2, 10, 1000) == True assert validate_exponentiation(0, 0) == True # both should return 1 assert validate_exponentiation(100, 0, 10) == True # both should return 1 ``` # Notes * You can reuse the `power` and `power_recur` function implementations provided in the code snippets. * Make sure to adequately handle any edge cases as mentioned above.","solution":"def power(a: int, n: int, mod: int = None) -> int: Iterative version to compute a^n % mod if n == 0: return 1 if mod is None else 1 % mod result = 1 base = a if mod is None else a % mod while n > 0: if n % 2 == 1: result = (result * base) % mod if mod else result * base base = (base * base) % mod if mod else base * base n = n // 2 return result def power_recur(a: int, n: int, mod: int = None) -> int: Recursive version to compute a^n % mod if n == 0: return 1 if mod is None else 1 % mod half = power_recur(a, n // 2, mod) half = (half * half) % mod if mod else half * half if n % 2 == 0: return half else: return (half * a) % mod if mod else half * a def validate_exponentiation(a: int, n: int, mod: int = None) -> bool: iter_result = power(a, n, mod) recur_result = power_recur(a, n, mod) return iter_result == recur_result"},{"question":"# Flatten Nested Arrays Context: You are working on a data processing task that requires flattening complex nested arrays into a single-level array. This is essential for ensuring consistent input for downstream algorithms that expect flat arrays. Problem Statement: Write a function `custom_flatten` that takes a nested array as input and returns a flattened version. Your implementation should follow the recursion principles and be able to handle arbitrary levels of nesting. # Function Signature: ```python def custom_flatten(input_arr): pass ``` # Input Format: * `input_arr`: A list which may contain nested lists of arbitrary depth, and other elements (integers, strings, etc.). # Output Format: * Return a single list containing all the elements in `input_arr`, flattened into one dimension. Maintain the order of elements as they appear in the original input list. # Constraints: * Function should handle deeply nested arrays efficiently. * The elements within the arrays can be of mixed data types, including other lists. # Performance Requirements: * Aim for a time complexity of O(n), where n is the total number of elements including those in sub-arrays. * Space complexity should be considered both in terms of additional data structures used and recursion depth. # Example: ```python # Example 1 input_arr = [1, [2, 3], [[4, 5], 6], [7], 8] assert custom_flatten(input_arr) == [1, 2, 3, 4, 5, 6, 7, 8] # Example 2 input_arr = [[1, 2, [3]], 4, [5, [6, 7]]] assert custom_flatten(input_arr) == [1, 2, 3, 4, 5, 6, 7] # Example 3 input_arr = [[], [[[3]], 2], 1, [0], [[]]] assert custom_flatten(input_arr) == [3, 2, 1, 0] # Edge Case input_arr = [] assert custom_flatten(input_arr) == [] ``` **Note**: Feel free to optimize your solution to handle deeply nested structures to avoid recursion limit issues.","solution":"def custom_flatten(input_arr): Recursively flattens a nested array into a single-level list. Args: input_arr (list): The nested list to flatten. Returns: list: The flattened list. result = [] for element in input_arr: if isinstance(element, list): result.extend(custom_flatten(element)) else: result.append(element) return result"},{"question":"# Insertion Sort with Simulation **Context**: A market analyst is analyzing daily stock prices. He needs to see the progression of stock prices being sorted using Insertion Sort to understand the movement patterns better. **Problem Statement**: Implement a function `insertion_sort_with_simulation` that sorts an array of integers using the Insertion Sort algorithm and prints the array after every iteration showing the sorted progress. **Function Signature**: ```python def insertion_sort_with_simulation(arr: List[int], simulation: bool) -> List[int]: ``` **Input**: - `arr`: A list of integers representing stock prices. - `simulation`: A boolean indicating if the simulation should be displayed. **Output**: - Returns the sorted list of integers. **Constraints**: - The array length can be up to 1000 elements. - Each element can vary between -10^6 to 10^6. **Performance Requirements**: - The function should run efficiently within the provided constraints. **Example**: ```python prices = [4, 3, 2, 10, 12] sorted_prices = insertion_sort_with_simulation(prices, simulation=True) # Expected Output: # iteration 0 : 4 3 2 10 12 # iteration 1 : 3 4 2 10 12 # iteration 2 : 2 3 4 10 12 # iteration 3 : 2 3 4 10 12 # iteration 4 : 2 3 4 10 12 print(sorted_prices) # [2, 3, 4, 10, 12] ``` **Note**: - If `simulation` is True, the function should print the array in each iteration step. - If `simulation` is False, simply return the sorted array without printing intermediate steps.","solution":"from typing import List def insertion_sort_with_simulation(arr: List[int], simulation: bool) -> List[int]: Sorts a list of integers using Insertion Sort and prints the array after every iteration if simulation is True. Parameters: arr (List[int]): A list of integers representing stock prices to be sorted. simulation (bool): A boolean indicating if the simulation should be displayed. Returns: List[int]: The sorted list of integers. n = len(arr) for i in range(1, n): key = arr[i] j = i - 1 while j >= 0 and key < arr[j]: arr[j + 1] = arr[j] j -= 1 arr[j + 1] = key if simulation: print(f\\"iteration {i} : {\' \'.join(map(str, arr))}\\") return arr"},{"question":"# Problem: Reversing a Sublist of a Singly Linked List Context You are working on a text editor\'s undo-redo feature which relies heavily on manipulating segments of actions stored in a singly linked list. To implement a new feature, you need to reverse a specific sublist within a singly linked list. Problem Statement Write a function that reverses a sublist of a singly linked list from position `left` to position `right` (positions are 1-based). The function should modify the list in-place and return the head of the modified list. Function Signature ```python def reverse_sublist(head, left, right): :type head: ListNode :type left: int :type right: int :rtype: ListNode ``` Input Parameters - `head`: The head of a singly linked list. - `left`, `right`: Two integers representing the left and right bounds (inclusive) for the range of nodes to reverse. Output - Return the head of the modified linked list. Constraints - The function should perform in O(n) time complexity. - You may assume that `1 ≤ left ≤ right ≤ n` (where `n` is the length of the list). Example ```python # Assume the ListNode class is defined as: class ListNode: def __init__(self, x): self.val = x self.next = None # Example usage: # Input: 1 -> 2 -> 3 -> 4 -> 5 -> NULL, left = 2, right = 4 # Output: 1 -> 4 -> 3 -> 2 -> 5 -> NULL head = ListNode(1) head.next = ListNode(2) head.next.next = ListNode(3) head.next.next.next = ListNode(4) head.next.next.next.next = ListNode(5) reversed_head = reverse_sublist(head, 2, 4) # The reversed_head should be the head of the linked list: 1 -> 4 -> 3 -> 2 -> 5 -> NULL ``` Considerations - Ensure the function handles edge cases like when `left` equals `right` (i.e., no actual reversal needed). - Handle cases where the sublist to reverse includes nodes at the head or tail of the list.","solution":"class ListNode: def __init__(self, x): self.val = x self.next = None def reverse_sublist(head, left, right): if left == right: return head dummy_node = ListNode(0) dummy_node.next = head pre = dummy_node for _ in range(left - 1): pre = pre.next current = pre.next for _ in range(right - left): temp = current.next current.next = temp.next temp.next = pre.next pre.next = temp return dummy_node.next"},{"question":"# Problem Description You are tasked with developing a small cryptographic protocol simulation. Your mission is to write a function that determines both the Euler\'s totient function and all primitive roots of a given integer ( n ). **Function Signature** ```python def crypto_simulation(n: int) -> Tuple[int, List[int]]: ``` # Input - A single integer ( n ) where ( 1 leq n leq 10^6 ). # Output - A tuple containing: * An integer representing the Euler\'s totient function ϕ(n). * A list of integers which are the primitive roots of ( n ). # Constraints - Euler\'s totient function should be calculated in ( O(sqrt{n}) ) time. - Finding primitive roots should be optimized but it is acceptable if it remains ( O(n^2 log n) ) for the scope of this task. # Requirements - The function must be efficient and handle up to the upper limit constraints. - Consider edge cases and common pitfalls in number theory. - Input validity is guaranteed. # Example ```python >>> crypto_simulation(7) (6, [3, 5]) >>> crypto_simulation(10) (4, []) ``` # Implementation Tips * Use Euler\'s totient function where necessary. * Ensure all generated numbers are coprime with ( n ). * Take advantage of modular arithmetic properties. * Validate the primitive root condition based on the calculated order. # Hints * Remember that primitive roots only exist for specific values of ( n ). * If ( φ(n) ) is essential, precompute it efficiently before proceeding to find the roots. * Modular exponentiation can be useful in checking powers and orders. Complete the function implementation based on the provided insights and context above.","solution":"from typing import Tuple, List def gcd(a: int, b: int) -> int: while b != 0: a, b = b, a % b return a def euler_totient(n: int) -> int: result = n p = 2 while p * p <= n: if n % p == 0: while n % p == 0: n //= p result -= result // p p += 1 if n > 1: result -= result // n return result def powmod(base: int, exp: int, mod: int) -> int: res = 1 base = base % mod while exp > 0: if exp % 2 == 1: res = (res * base) % mod exp = exp >> 1 base = (base * base) % mod return res def find_primitive_roots(n: int) -> List[int]: if n == 1: return [] # Special cases where primitive roots exist if n == 2: return [1] if n == 4: return [3] if n % 2 == 0: return [] phi_n = euler_totient(n) primes = set() d = 2 phi_tmp = phi_n while d * d <= phi_tmp: if phi_tmp % d == 0: primes.add(d) while phi_tmp % d == 0: phi_tmp //= d d += 1 if phi_tmp > 1: primes.add(phi_tmp) def is_primitive_root(candidate: int) -> bool: for prime in primes: if powmod(candidate, phi_n // prime, n) == 1: return False return True primitive_roots = [] for i in range(2, n): if gcd(i, n) == 1 and is_primitive_root(i): primitive_roots.append(i) return primitive_roots def crypto_simulation(n: int) -> Tuple[int, List[int]]: phi_n = euler_totient(n) primitive_roots = find_primitive_roots(n) return (phi_n, primitive_roots)"},{"question":"# Question: Efficient Combination Calculation with Constraints You are tasked with designing an efficient function to calculate combinations ( text{C}(n, r) ) (the number of ways to choose ( r ) items from ( n ) distinct items without replacement). Considering large inputs and optimizing performance, you need to implement this using dynamic programming techniques. # Function Signature: ```python def combination_dp(n: int, r: int) -> int: pass ``` # Input: - ( n ) (0 <= ( n ) <= 1000): an integer representing the total number of items. - ( r ) (0 <= ( r ) <= 1000): an integer representing the number of items to choose. # Output: - An integer representing ( text{C}(n, r) ). # Constraints: - Your solution should handle large values of ( n ) and ( r ) efficiently. - Implementations avoiding recursion for minimal stack usage will be preferred. - Consider time and space complexity carefully to ensure the solution is optimal. # Example: ```python assert combination_dp(5, 2) == 10 assert combination_dp(10, 5) == 252 ``` # Notes: - Optimize for time complexity and avoid large overheads where possible. - Your implementation should be able to handle edge cases where ( r = 0 ) or ( r = n ).","solution":"def combination_dp(n: int, r: int) -> int: Calculate C(n, r) using dynamic programming. # Handle the edge cases if r > n: return 0 if r == 0 or r == n: return 1 # Initialize a table to store combination values C = [[0 for x in range(r + 1)] for y in range(n + 1)] # Calculate value of Binomial Coefficient in bottom up manner for i in range(n + 1): for j in range(min(i, r) + 1): # Base Cases if j == 0 or j == i: C[i][j] = 1 else: C[i][j] = C[i - 1][j - 1] + C[i - 1][j] return C[n][r]"},{"question":"# Question You are tasked with writing a function that adds one to a number represented as a list of its digits. However, this time, you need to handle lists that can be very large and might contain thousands of digits efficiently. Your function should increment the list in place without converting it to a string or re-creating a new list except in necessary circumstances. Function Signature ```python def increment_large_number(digits: List[int]) -> List[int]: pass ``` Input * `digits`: A list of non-negative integers where each element (0<= x <= 9) represents a single digit of the number. The array is big-endian, so the most significant digit is the first element. Output * Return a list of integers representing the incremented number. If the resulting number necessitates an additional digit, ensure this is reflected in your result. Constraints * The function must operate in O(n) time where n is the number of digits. * The function should use at most O(1) additional space beyond the input list. Examples 1. `increment_large_number([1, 2, 3])` should return `[1, 2, 4]`. 2. `increment_large_number([9, 9, 9])` should return `[1, 0, 0, 0]`. 3. `increment_large_number([2, 9])` should return `[3, 0]`. # Additional Requirements Your function should handle cases where all digits are 9 efficiently without re-creating the list until necessary.","solution":"from typing import List def increment_large_number(digits: List[int]) -> List[int]: # Start from the end of the list. n = len(digits) for i in range(n-1, -1, -1): if digits[i] < 9: digits[i] += 1 return digits # Set this digit to 0 if it is 9. digits[i] = 0 # If we are here, it means all the digits were 9. # We need an additional digit at the beginning. return [1] + [0] * n"},{"question":"Scenario You are working on a data analysis project where you frequently need to identify the most common elements in various datasets. To facilitate this, you need to implement a function that finds the mode of an array (the element that appears most frequently). Problem Statement Write a Python function `top_1(arr: list) -> list` that takes a list of integers as input and returns a list of the most frequent element(s). If there are multiple elements with the same highest frequency, your function should return all of them in the order they first appear in the list. Input and Output Formats - **Input**: - `arr`: A list of integers. It can be empty. - **Output**: - A list of integers containing the most frequent element(s). If the input list is empty, return an empty list. Constraints - Do not use any libraries for frequency counting like `collections.Counter`. - The elements of `arr` are guaranteed to be integers. - Handle lists of various lengths, including very short and very long lists. Example ```python print(top_1([1, 1, 2, 2, 3, 4])) # Output: [1, 2] print(top_1([1, 2, 3, 4, 5, 6, 7, 8])) # Output: [1, 2, 3, 4, 5, 6, 7, 8] print(top_1([])) # Output: [] print(top_1([4, 4, 4, 6, 6])) # Output: [4] ``` Performance Requirements Ensure that your solution runs efficiently with a time complexity of O(n) and space complexity of O(n), where n is the number of elements in the input list.","solution":"def top_1(arr): Returns a list of the most frequent element(s) in the input list. If the input list is empty, returns an empty list. if not arr: return [] frequency = {} max_count = 0 # First pass: calculate frequencies and determine the highest frequency for number in arr: if number in frequency: frequency[number] += 1 else: frequency[number] = 1 if frequency[number] > max_count: max_count = frequency[number] # Second pass: collect all elements with the highest frequency result = [] for number in arr: if frequency[number] == max_count and number not in result: result.append(number) return result"},{"question":"**Context**: Sorting algorithms are central to computer science education, with various algorithms illustrating different principles and efficiency characteristics. Bogo Sort is an intentionally inefficient sorting algorithm often used for illustrative purposes to explain the concept of permutations and algorithmic inefficiency. **Task**: Implement a function that utilizes a deterministic yet inefficient sorting mechanism inspired by Bogo Sort for educational purposes. The function should accept an array of integers and return it sorted. You should include checks for sortedness and implement shuffling based on permutation generation (not purely random shuffling). # Function Signature: ```python def educational_sort(arr: list[int]) -> list[int]: pass ``` # Inputs: - `arr` (0 <= len(arr) <= 7): An array of integers to be sorted. # Outputs: - Return a list of integers sorted in non-decreasing order. # Requirements: - You should not use built-in sorting methods (`sorted`, `sort`, etc.). - The sorting should be based on permutation generation rather than pure random shuffling. - Efficiency is not the focus; understanding the mechanics of brute force permutation sort is. # Example: ```python # input arr = [3, 1, 2] # function call sorted_arr = educational_sort(arr) # should return sorted_arr -> [1, 2, 3] ```","solution":"import itertools def educational_sort(arr: list[int]) -> list[int]: Sorts the list using a deterministic yet inefficient sorting mechanism based on permutation generation. def is_sorted(lst): Returns True if the list is sorted, else False. for i in range(len(lst) - 1): if lst[i] > lst[i + 1]: return False return True # Generate all permutations and check if any of them is sorted for permutation in itertools.permutations(arr): if is_sorted(permutation): return list(permutation)"},{"question":"You are given two compatible two-dimensional matrices. Your task is to implement a function to perform matrix multiplication and return their product. # Function Signature ```python def multiply(multiplicand: list, multiplier: list) -> list: pass ``` # Expected Input and Output * **Input**: - `multiplicand`: A list of lists representing the first matrix, where each inner list is a row of integers. - `multiplier`: A list of lists representing the second matrix, where each inner list is a row of integers. * **Output**: - A list of lists representing the product of the matrices. Each inner list in the output should be a row of the resultant matrix. # Constraints 1. Each matrix element will be an integer. 2. The number of columns in the first matrix will be equal to the number of rows in the second matrix. # Example ```python # Example Input multiplicand = [ [1, 2], [3, 4] ] multiplier = [ [5, 6], [7, 8] ] # Expected Output # [ # [19, 22], # [43, 50] # ] output = multiply(multiplicand, multiplier) print(output) # Output should be: [[19, 22], [43, 50]] ``` # Edge Cases to Consider * Matrices with dimensions greater than 1x1 but with sparse (mostly zero) elements. * Handling incompatible matrix sizes should raise an appropriate Exception with a clear message. # Performance Requirements The solution should handle matrices of size up to 100x100 efficiently though higher efficiency can be achieved with more advanced algorithms like Strassen\'s algorithm, keeping the space complexity to O(N^2) and optimizing for runtime. Your function should be efficient, should raise meaningful exceptions in case of errors, and should be well-documented.","solution":"def multiply(multiplicand: list, multiplier: list) -> list: Multiplies two compatible 2D matrices and returns the result. :param multiplicand: List of lists where each inner list is a row of integers in the first matrix. :param multiplier: List of lists where each inner list is a row of integers in the second matrix. :return: List of lists representing the product of the matrices. if len(multiplicand[0]) != len(multiplier): raise ValueError(\\"Incompatible matrices for multiplication. Number of columns in multiplicand must equal the number of rows in multiplier.\\") # Resultant matrix will of dimensions multiplicand_rows x multiplier_columns result = [[0 for _ in range(len(multiplier[0]))] for _ in range(len(multiplicand))] # Matrix multiplication for i in range(len(multiplicand)): for j in range(len(multiplier[0])): for k in range(len(multiplier)): result[i][j] += multiplicand[i][k] * multiplier[k][j] return result"},{"question":"# Path Finding in a Graph You are tasked with extending and optimizing a graph traversal utility. You need to implement a function to find the longest path in a given directed graph between two nodes using Depth-First Search (DFS) principles. The graph is represented as an adjacency list. # Function Signature: ```python def find_longest_path(graph: Dict[str, List[str]], start: str, end: str) -> List[str]: ``` # Input: - `graph`: A dictionary where keys are node names and values are lists of adjacent nodes. - `start`: The starting node. - `end`: The ending node. # Output: - A list of nodes representing the longest path from `start` to `end`. - Return an empty list if no path exists. # Constraints: - Assume that there are no negative cycles in the graph. - Nodes names are unique strings. - The graph can contain cycles. # Performance Requirements: - Optimize for large graphs with up to 10^4 nodes and 10^5 edges. - Minimize memory usage where possible. # Example: ```python graph = { \'A\': [\'B\', \'C\'], \'B\': [\'C\', \'D\'], \'C\': [\'D\'], \'D\': [\'C\'], \'E\': [\'F\'], \'F\': [\'C\'] } start = \'A\' end = \'D\' print(find_longest_path(graph, start, end)) # Output: [\'A\', \'B\', \'C\', \'D\'] ``` # Explanation: The longest path from \'A\' to \'D\' is `[\'A\', \'B\', \'C\', \'D\']`.","solution":"def find_longest_path(graph, start, end): def dfs(node, path): if node == end: path.append(node) return path if node in visited: return [] visited.add(node) max_path = [] for neighbor in graph.get(node, []): candidate_path = dfs(neighbor, path + [node]) if len(candidate_path) > len(max_path): max_path = candidate_path visited.remove(node) return max_path visited = set() return dfs(start, [])"},{"question":"You are tasked with writing a function to determine the number of ways a given positive integer \'n\' can be decomposed into sums of smaller non-negative integers. This decomposition must take into account all possible combinations and order does not matter. # Function Signature ```python def number_of_decompositions(n: int) -> int: pass ``` # Input * An integer `n` (1 ≤ n ≤ 50) representing the number to be decomposed. # Output * An integer representing the number of ways `n` can be decomposed into sums of smaller non-negative integers. # Constraints * You must use dynamic programming to solve the problem. * The solution should have a time complexity of O(n^2). * Handle edge cases such as the smallest (n = 1) and the largest allowed inputs efficiently. # Examples Example 1: ```python Input: 4 Output: 5 Explanation: The number 4 can be decomposed as: 4 = 4 4 = 3 + 1 4 = 2 + 2 4 = 2 + 1 + 1 4 = 1 + 1 + 1 + 1 ``` Example 2: ```python Input: 7 Output: 15 Explanation: The number 7 can be decomposed as: 7 = 7 7 = 6 + 1 7 = 5 + 2 7 = 5 + 1 + 1 7 = 4 + 3 7 = 4 + 2 + 1 7 = 4 + 1 + 1 + 1 7 = 3 + 3 + 1 7 = 3 + 2 + 2 7 = 3 + 2 + 1 + 1 7 = 3 + 1 + 1 + 1 + 1 7 = 2 + 2 + 2 + 1 7 = 2 + 2 + 1 + 1 + 1 7 = 2 + 1 + 1 + 1 + 1 + 1 7 = 1 + 1 + 1 + 1 + 1 + 1 + 1 ``` # Submission Requirements * The solution must be efficient, readable, and well-documented. * The implementation must include handling any edge cases and should be optimized for performance where feasible.","solution":"def number_of_decompositions(n: int) -> int: Returns the number of distinct ways to decompose a given positive integer n into sums of smaller or equal integers. dp = [0] * (n + 1) dp[0] = 1 # There\'s one way to decompose 0 - using an empty sum. for i in range(1, n + 1): for j in range(i, n + 1): dp[j] += dp[j - i] return dp[n]"},{"question":"**Pattern Match Challenge** # Problem Statement: You are given a pattern and a string `str`. You need to determine if `str` follows the same pattern. Here, \\"follows the same pattern\\" means a full match such that there is a bijection between a letter in the pattern and a non-empty substring in `str`. # Function Signature: ```python def pattern_match(pattern: str, string: str) -> bool: pass ``` # Inputs: - `pattern`: A string representing the pattern containing only lowercase letters (1 ≤ length ≤ 12). - `string`: A string containing only lowercase letters (1 ≤ length ≤ 20). # Outputs: - Returns `True` if the given string matches the pattern, otherwise `False`. # Constraints: - Each letter in the pattern must map to a non-empty substring in `str`. - Different letters in the pattern must map to different substrings. - The same letter must map to the same substring wherever it appears in the pattern. # Examples: 1. `pattern = \\"abab\\", str = \\"redblueredblue\\"` -> `True` 2. `pattern = \\"aaaa\\", str = \\"asdasdasdasd\\"` -> `True` 3. `pattern = \\"aabb\\", str = \\"xyzabcxzyabc\\"` -> `False` 4. `pattern = \\"abc\\", str = \\"abcd\\"` -> `True` 5. `pattern = \\"ab\\", str = \\"\\"` -> `False` # Description: Implement a function that efficiently determines if `str` follows the structure defined by the given `pattern`. Consider multiple ways of splitting `str` to match the `pattern` while maintaining the constraints provided. Ensure to account for edge cases such as empty strings and patterns, and handle them appropriately in your solution. # Performance Requirements: Given the constraints, your implementation should strive for efficiency to handle the upper limits of input sizes effectively. # Hints: - Consider using a recursive, backtracking approach. - Use a dictionary to keep track of the current mappings between the pattern characters and substrings of `str`. - Ensure to backtrack if a mapping does not lead to a valid solution.","solution":"def pattern_match(pattern, string): def backtrack(p_index, s_index, mapping, mapped): if p_index == len(pattern) and s_index == len(string): return True if p_index == len(pattern) or s_index == len(string): return False pattern_char = pattern[p_index] if pattern_char in mapping: substr = mapping[pattern_char] if string.startswith(substr, s_index): return backtrack(p_index + 1, s_index + len(substr), mapping, mapped) else: return False for end in range(s_index + 1, len(string) + 1): substr = string[s_index:end] if substr in mapped: continue mapping[pattern_char] = substr mapped.add(substr) if backtrack(p_index + 1, end, mapping, mapped): return True del mapping[pattern_char] mapped.remove(substr) return False return backtrack(0, 0, {}, set())"},{"question":"Write a function `count_flips_to_convert(a: int, b: int) -> int` that takes two non-negative integers `a` and `b`, and returns the minimal number of bit flips needed to convert integer `a` to integer `b`. Input * Two non-negative integers `a` and `b` where `0 <= a, b <= 2^31 - 1`. Output * Return an integer representing the minimum number of bit flips needed to convert `a` to `b`. # Constraints * The integers will not exceed 31 bits (standard for non-negative integers within 32-bit systems). # Example ```python # Example 1: a = 29 # Binary: 11101 b = 15 # Binary: 01111 # The number of bits that are different: 11101 (a) vs 01111 (b) =|...| # The minimal number of flips required is 2 print(count_flips_to_convert(a, b)) # Output: 2 # Example 2: a = 10 # Binary: 1010 b = 20 # Binary: 10100 # The number of bits that are different: 1010 vs 10100 =|00110 # The minimal number of flips required is 3 print(count_flips_to_convert(a, b)) # Output: 3 ``` Edge Cases * When `a` equals `b`, the result should be 0 since no flips are needed. * For extreme values like 0 and 2^31 - 1, the algorithm should still correctly compute the number of flips.","solution":"def count_flips_to_convert(a: int, b: int) -> int: Returns the minimal number of bit flips needed to convert integer a to integer b. # XOR a and b to find the differing bits differing_bits = a ^ b # Count the number of 1s in the result, which represents the number of differing bits count = 0 while differing_bits: count += differing_bits & 1 differing_bits >>= 1 return count"},{"question":"**Scenario**: Imagine you are a gardener, and you have a list of garden ornaments that need to be arranged by their heights in non-decreasing order. Recently, another gardener messed up the arrangement, and now some of the heights are out of order. Your job is to re-sort them using a simple method that mimics how you\'d handle it manually. Implement a function `gnome_sort(arr: List[int]) -> List[int]` that sorts an array of integers using the Gnome Sort algorithm. **Function Signature**: ```python from typing import List def gnome_sort(arr: List[int]) -> List[int]: pass ``` **Input**: * `arr`: A list of integers that represent the heights of garden ornaments. **Output**: * The function should return a new list of integers sorted in non-decreasing order. **Constraints**: * 0 ≤ len(arr) ≤ 10^5 * -10^6 ≤ arr[i] ≤ 10^6 for any valid index `i` **Example**: ```python assert gnome_sort([34, 2, 10, -9]) == [-9, 2, 10, 34] assert gnome_sort([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5] assert gnome_sort([]) == [] assert gnome_sort([9]) == [9] ``` # Additional Notes: 1. Focus on implementing the Gnome Sort algorithm as described. 2. Ensure your solution handles various edge cases efficiently. 3. Test your solution with arrays of different sizes and content to validate performance.","solution":"from typing import List def gnome_sort(arr: List[int]) -> List[int]: index = 0 while index < len(arr): if index == 0 or arr[index] >= arr[index - 1]: index += 1 else: arr[index], arr[index - 1] = arr[index - 1], arr[index] index -= 1 return arr"},{"question":"# Question: Implementation of B-Tree with Enhanced Search Functionality Context: A database management system (DBMS) often relies on efficient data structures for indexing to manage large-scale data operations. One commonly implemented data structure is the B-tree. In this exercise, you are to enhance the given B-tree implementation by adding a range search feature. Requirements: 1. **New Method**: Implement a method `find_range(self, low_key, high_key)`, which finds and returns all keys in the B-tree that fall within the given range [low_key, high_key]. Ensure your function handles inclusive ranges and returns results in a sorted order. 2. **Input and Output**: - **Input**: `low_key (int)`, `high_key (int)` - **Output**: `List[int]` containing all keys in the range `[low_key, high_key]`, sorted. 3. **Constraints**: - Assume the B-tree operates under the same rules as defined in the provided class (Minimum `t=2`, Maximum `t=4`). - You can leverage existing methods within the provided B-tree class for node operations. 4. **Performance**: - Aim for the most efficient traversal while maintaining the logarithmic time operations where possible. - Your solution should be robust and handle edge cases, such as empty trees, non-existing ranges, etc. Example: ```python # Example to illustrate the expected usage: btree = BTree(t_val=3) keys_to_insert = [10, 20, 5, 6, 12, 30, 7, 17] for key in keys_to_insert: btree.insert_key(key) # Perform range search result = btree.find_range(6, 17) print(result) # Expected Output: [6, 7, 10, 12, 17] ``` Note: You don\'t need to modify the base implementation of the provided B-tree class unless it is essential for your `find_range` method. Implement your function within the confines of the existing class structure to demonstrate your comprehension of tree traversal and manipulation.","solution":"class BTreeNode: def __init__(self, t, leaf=False): self.t = t # Minimum degree (defines the range for the number of keys) self.leaf = leaf # True if this node is a leaf, otherwise False self.keys = [] # List of keys in this node self.children = [] # List of child nodes class BTree: def __init__(self, t_val): self.root = BTreeNode(t_val, True) self.t = t_val def insert_key(self, key): root = self.root if len(root.keys) == (2 * self.t) - 1: new_node = BTreeNode(self.t, False) new_node.children.insert(0, root) self._split_child(new_node, 0) self._insert_non_full(new_node, key) self.root = new_node else: self._insert_non_full(root, key) def _split_child(self, parent, index): t = self.t node_to_split = parent.children[index] new_node = BTreeNode(t, node_to_split.leaf) parent.children.insert(index + 1, new_node) parent.keys.insert(index, node_to_split.keys[t - 1]) new_node.keys = node_to_split.keys[t:(2*t - 1)] node_to_split.keys = node_to_split.keys[0:t - 1] if not node_to_split.leaf: new_node.children = node_to_split.children[t:(2*t)] node_to_split.children = node_to_split.children[0:t] def _insert_non_full(self, node, key): if node.leaf: node.keys.append(key) node.keys.sort() else: i = len(node.keys) - 1 while i >= 0 and key < node.keys[i]: i -= 1 i += 1 if len(node.children[i].keys) == (2*self.t) - 1: self._split_child(node, i) if key > node.keys[i]: i += 1 self._insert_non_full(node.children[i], key) def find_range(self, low_key, high_key): Finds and returns all keys in the B-tree that fall within the range [low_key, high_key]. Keys are returned in sorted order. result = [] self._find_range_recursive(self.root, low_key, high_key, result) return result def _find_range_recursive(self, node, low_key, high_key, result): i = 0 # Traverse the node and its children to collect keys in the range. while i < len(node.keys) and node.keys[i] < low_key: if not node.leaf: self._find_range_recursive(node.children[i], low_key, high_key, result) i += 1 while i < len(node.keys) and node.keys[i] <= high_key: if not node.leaf: self._find_range_recursive(node.children[i], low_key, high_key, result) result.append(node.keys[i]) i += 1 if not node.leaf: self._find_range_recursive(node.children[i], low_key, high_key, result)"},{"question":"# Question: Optimized Combination Calculation You are tasked with writing an optimized function to calculate the binomial coefficient, commonly known as combinations `nCr`, which determines how many ways we can choose `r` items from a set of `n` items. You must write a function `combination_optimized(n: int, r: int) -> int` that returns the value of `nCr`. Constraints: - You should handle cases where `0 <= r <= n` efficiently. - The function should be optimized to handle larger values of `n` and `r` up to `1000`. Expected Function Signature: ```python def combination_optimized(n: int, r: int) -> int: pass ``` # Example ```python assert combination_optimized(5, 2) == 10 assert combination_optimized(6, 3) == 20 assert combination_optimized(0, 0) == 1 assert combination_optimized(1000, 0) == 1 ``` # Explanation: - For `n = 5` and `r = 2`, there are 10 ways to choose 2 items from 5. - For `n = 6` and `r = 3`, there are 20 ways to choose 3 items from 6. - For `n = 0` and `r = 0`, there is exactly 1 way to choose nothing from nothing. - For `n = 1000` and `r = 0`, there is exactly 1 way to choose nothing from 1000 items. # Note: Optimize the function to ensure it can compute values efficiently for larger inputs by leveraging techniques such as memoization or dynamic programming.","solution":"def combination_optimized(n: int, r: int) -> int: Calculate the binomial coefficient nCr in an optimized manner. Args: n (int): Total number of items. r (int): Number of items to choose. Returns: int: The number of ways to choose r items from n items. # Early return for trivial cases if r > n: return 0 if r == 0 or r == n: return 1 # Use symmetry property nCr = nC(n-r) r = min(r, n - r) # Calculate nCr using an iterative approach numerator = 1 denominator = 1 for i in range(1, r + 1): numerator *= (n - (r - i)) denominator *= i return numerator // denominator"},{"question":"# Question: Algebraic Expression Manipulation Context: You are tasked with implementing a class for symbolic algebra manipulation. This class should handle monomials and polynomials efficiently to support several operations such as addition, subtraction, multiplication, and division. The goal is to process symbolic algebraic expressions as real-world applications in physics, engineering, and computer algebra systems often require such operations. Your task is to implement additional functionality to handle polynomial differentiation efficiently. # Task: 1. **Differentiate a Polynomial**: Write a function `differentiate` inside the Polynomial class that: * Differentiates the polynomial with respect to a given variable (a_i). Implementation Details: * **Function Signature**: ```python class Polynomial: ... def differentiate(self, variable: int) -> Polynomial: pass ``` * **Input**: - `variable` (a_i): an integer representing the variable with respect to which differentiation should be performed. * **Output**: - Returns a new `Polynomial` object representing the differentiated polynomial. * **Constraints**: - Assume the polynomial is valid. - The `Monomial` class and its methods will be available. - Assume that all variables in the polynomial are indexed by integers starting from 1. * **Performance Requirements**: - The function should handle differentiation efficiently for moderately sized polynomials. Examples: ```python p = Polynomial([Monomial({1: 3}, 4), Monomial({2: 2, 1: 1}, -1), Monomial({1: 0}, 5)]) dp_da1 = p.differentiate(1) print(dp_da1) # Expected result for derivative with respect to variable a1 ``` Ensure that your implementation efficiently handles polynomials with multiple terms and degrees, and maintains proper simplification of the resulting polynomial after differentiation.","solution":"class Monomial: def __init__(self, exponents, coefficient): self.exponents = exponents # Dictionary with variables as keys and their respective exponents as values self.coefficient = coefficient def differentiate(self, variable): if variable not in self.exponents or self.exponents[variable] == 0: return None # Derivative of constant w.r.t variable is zero new_exponents = dict(self.exponents) new_exponents[variable] -= 1 new_coefficient = self.coefficient * self.exponents[variable] if new_exponents[variable] == 0: del new_exponents[variable] # Remove the variable if its exponent has become zero return Monomial(new_exponents, new_coefficient) def __repr__(self): return f\\"{self.coefficient}*{\' \'.join([f\'a{i}^{exp}\' for i, exp in self.exponents.items()])}\\" class Polynomial: def __init__(self, monomials): self.monomials = monomials # A list of Monomial objects def differentiate(self, variable): differentiated_monomials = [] for monomial in self.monomials: differentiated_monomial = monomial.differentiate(variable) if differentiated_monomial: differentiated_monomials.append(differentiated_monomial) return Polynomial(differentiated_monomials) def __repr__(self): return \\" + \\".join([repr(monomial) for monomial in self.monomials]) # Example usage: p = Polynomial([Monomial({1: 3}, 4), Monomial({2: 2, 1: 1}, -1), Monomial({}, 5)]) dp_da1 = p.differentiate(1) print(dp_da1)"},{"question":"**Bucket Sort with Advanced Implementation** You are tasked with implementing a version of the Bucket Sort algorithm which must be optimized to handle both evenly and unevenly distributed data efficiently. For this task, you need to design and code the bucket sort function that can sort an array of integers. Your function should: 1. Distribute elements into a reasonable number of buckets. 2. Utilize an efficient internal sorting algorithm within each bucket. 3. Merge the buckets to obtain the sorted array. **Function Signature** ```python def bucket_sort(arr: List[int]) -> List[int]: pass ``` # Input - A list of integers `arr` where `1 <= len(arr) <= 10^5` and `-10^6 <= arr[i] <= 10^6` for all `i`. # Output - A sorted list of integers in non-decreasing order. # Constraints - Your implementation should aim to run in an average time complexity of O(n + k). # Additional Requirements 1. Handle cases with negative numbers appropriately. 2. Minimize the potential worst-case scenario by optimizing bucket distribution and sorting. 3. Consider large inputs and edge cases during implementation. # Example ```python assert bucket_sort([3, -1, 4, 1, -5, 9, 2, 6, 5, 3, 5]) == [-5, -1, 1, 2, 3, 3, 4, 5, 5, 6, 9] assert bucket_sort([10, -20, 15, 30, -25, 25]) == [-25, -20, 10, 15, 25, 30] assert bucket_sort([]) == [] assert bucket_sort([5]) == [5] assert bucket_sort([3, 3, 3, 3, 3]) == [3, 3, 3, 3, 3] ``` # Notes - Carefully design the bucket indexing mechanism to ensure even distribution. - Choose an appropriate internal sorting algorithm to use within each bucket based on expected bucket sizes. - Thoroughly test your implementation with a variety of input cases, including edge conditions and large arrays, to ensure robustness and performance.","solution":"from typing import List def bucket_sort(arr: List[int]) -> List[int]: if not arr: return [] # Finding the minimum and maximum values in the array min_val = min(arr) max_val = max(arr) # Number of buckets bucket_count = len(arr) # Create buckets and distribute elements buckets = [[] for _ in range(bucket_count)] for num in arr: idx = int((num - min_val) / (max_val - min_val + 1) * (bucket_count - 1)) buckets[idx].append(num) # Sort each bucket and concatenate the results sorted_arr = [] for bucket in buckets: sorted_arr.extend(sorted(bucket)) return sorted_arr"},{"question":"Given three different implementations of computing the n-th Fibonacci number, your task is to implement a function that computes the n-th Fibonacci number in an optimal manner, i.e., with the best possible time and space complexity. Your function should be efficient even for large values of n, such as n = 10^6. **Function Signature:** ```python def optimal_fib(n: int) -> int: pass ``` **Input:** - An integer `n` (0 <= n <= 10^6). **Output:** - An integer representing the n-th Fibonacci number. **Constraints:** - Large numbers should be handled efficiently. - Your implementation should have a time complexity of O(log n) or O(n) and optimally handle memory usage. **Performance Requirements:** - The solution should work efficiently even for large values of n up to 10^6. **Example:** ```python optimal_fib(10) # should return 55 optimal_fib(20) # should return 6765 optimal_fib(50) # should return 12586269025 optimal_fib(1000000) # should return a very large fibonacci number ``` **Note:** - Consider edge cases for small values of n (0 and 1) and ensure your solution properly handles very large Fibonacci numbers within reasonable execution time and without causing overflow errors in languages that do not support arbitrary-precision integers.","solution":"def optimal_fib(n: int) -> int: Computes the n-th Fibonacci number using matrix exponentiation. The time complexity is O(log n). if n == 0: return 0 if n == 1: return 1 def multiply_matrices(A, B): return [ [A[0][0] * B[0][0] + A[0][1] * B[1][0], A[0][0] * B[0][1] + A[0][1] * B[1][1]], [A[1][0] * B[0][0] + A[1][1] * B[1][0], A[1][0] * B[0][1] + A[1][1] * B[1][1]] ] def matrix_power(matrix, power): result = [[1, 0], [0, 1]] # Identity matrix base = matrix while power > 0: if power % 2 == 1: result = multiply_matrices(result, base) base = multiply_matrices(base, base) power //= 2 return result F = [[1, 1], [1, 0]] result_matrix = matrix_power(F, n - 1) return result_matrix[0][0] # Note: The result may need to be handled using modular arithmetic if the language\'s integer size is limited, # but Python handles arbitrarily large integers, so it\'s not required here."},{"question":"You are provided with two integers, `X` and `Y`. Your task is to determine the minimal number of bits you would need to flip to convert integer `X` to integer `Y`. # Description * **Input**: Two integers `X` and `Y`. * **Output**: An integer representing the minimal number of bits that need to be flipped. # Constraints * The integers `X` and `Y` are non-negative and can be large, but within the integer range supported by standard programming languages (e.g., 32-bit or 64-bit integers). # Example ```python # Example 1 Input: X = 29, Y = 15 Output: 2 # Example 2 Input: X = 0, Y = 15 Output: 4 # Example 3 Input: X = 1024, Y = 2047 Output: 10 ``` # Implementation Implement the function `count_flips_to_convert(x, y)` where: * `x`: An integer representing the initial number. * `y`: An integer representing the target number. **Function Signature**: ```python def count_flips_to_convert(x: int, y: int) -> int: # Write your code here pass ``` # Additional Notes * Ensure that your solution is optimal and can handle edge cases efficiently. * Consider readability and maintainability of your code. * Think of any potential improvements or optimizations to your initial solution.","solution":"def count_flips_to_convert(x: int, y: int) -> int: Returns the minimal number of bits needed to flip to convert integer X to integer Y. # XOR the two numbers to find the bits that are different xor_result = x ^ y # Count the number of 1\'s in the binary representation of the xor result flip_count = bin(xor_result).count(\'1\') return flip_count"},{"question":"# Pigeonhole Sort Implementation You are tasked with implementing the Pigeonhole Sort algorithm for a given list of integers. The algorithm should sort the list in ascending order. Function Signature ```python def pigeonhole_sort(arr: List[int]) -> List[int]: ``` # Input - A list of integers `arr` with length `n` (1 <= n <= 1000). - The integers can be both positive and negative. # Output A sorted list in ascending order. # Constraints - You can assume all the elements of `arr` fit within a reasonable integer range. - Optimize for time complexity over space complexity where possible. # Requirements - The implementation must use the pigeonhole sort technique as described. - Handling edge cases such as empty lists, lists with a single element, or all elements being the same. # Examples ```python assert pigeonhole_sort([1, 5, 3, 2, 5, 0, -1]) == [-1, 0, 1, 2, 3, 5, 5] assert pigeonhole_sort([5, 4, 3, 2, 1]) == [1, 2, 3, 4, 5] assert pigeonhole_sort([9, 8, 7, 7, 8, 9, 7]) == [7, 7, 7, 8, 8, 9, 9] ``` Notes - Consider the range of the array values to efficiently use the pigeonhole sort\'s mechanism. - Ensure the implemented function handles all edge cases effectively.","solution":"def pigeonhole_sort(arr): Sort a list of integers using the Pigeonhole Sort algorithm. if not arr: # If the list is empty return [] min_val = min(arr) max_val = max(arr) size = max_val - min_val + 1 holes = [0] * size for num in arr: holes[num - min_val] += 1 sorted_arr = [] for i in range(size): while holes[i] > 0: sorted_arr.append(i + min_val) holes[i] -= 1 return sorted_arr # Example usage: # sorted_list = pigeonhole_sort([1, 5, 3, 2, 5, 0, -1]) # print(sorted_list) # Output should be [-1, 0, 1, 2, 3, 5, 5]"},{"question":"**Context**: You have been tasked with optimizing a sorting function used in a small-scale application where the performance of sorting different sized datasets must be analyzed and improved where possible. Task: Implement an optimized version of Bubble Sort, called `optimized_bubble_sort`, that stops early if the array becomes sorted before completing all possible iterations. # Function Signature `def optimized_bubble_sort(arr)` Expected Input and Output: * **Input Format**: A list of integers, `arr`, where `0 <= len(arr) <= 10^4` and `-10^9 <= arr[i] <= 10^9`. * **Output Format**: A sorted list of integers in ascending order. Constraints: * Your implementation should handle cases efficiently where the array is already sorted or nearly sorted. * You are allowed to use swaps and comparisons only. You should not use additional data structures (like extra arrays). Performance Requirements: * Your function should aim to perform better than the typical O(N^2) time complexity in cases where the array is already sorted or nearly sorted. # Examples: **Example 1**: ```python arr = [64, 34, 25, 12, 22, 11, 90] print(optimized_bubble_sort(arr)) # Output: [11, 12, 22, 25, 34, 64, 90] ``` **Example 2**: ```python arr = [1, 2, 3, 4, 5] print(optimized_bubble_sort(arr)) # Output: [1, 2, 3, 4, 5] # early termination should occur as it\'s already sorted ``` **Example 3**: ```python arr = [] print(optimized_bubble_sort(arr)) # Output: [] ``` # Requirements: 1. Implement the `optimized_bubble_sort` function. 2. Ensure that the function handles edge cases and avoids unnecessary iterations for already sorted arrays. # Hint: To detect whether the array is already sorted, keep track of whether any swaps are made in each pass. If no swaps are made during a pass, then the array is sorted, and you can terminate early.","solution":"def optimized_bubble_sort(arr): Optimized bubble sort that stops if the array is already sorted. n = len(arr) for i in range(n): swapped = False for j in range(0, n-i-1): if arr[j] > arr[j+1]: arr[j], arr[j+1] = arr[j+1], arr[j] swapped = True if not swapped: break return arr"},{"question":"# Scenario You are tasked with creating a custom hash table for a simple inventory system. This hash table should allow for the dynamic resizing of the table as more items are added, and handle collisions through a specific resolution strategy. # Task Implement a class `DynamicHashTable`, which supports dynamic resizing and collision resolution using linear probing. You will be provided with an initial implementation of a fixed-size hash table. Your implementation should build on this and ensure optimal performance as more elements are added. # Requirements Class Definition * **Class Name**: `DynamicHashTable` * **Initializer**: Should initialize with a specified minimum size or default to 8. Methods to Implement 1. **put(self, key, value)**: Insert or update the key-value pair. 2. **get(self, key)**: Retrieve the value associated with the key, or return `None` if the key is not found. 3. **del_(self, key)**: Remove the key-value pair from the hash table. 4. **__resize(self)**: Resize the hash table when the load factor exceeds 2/3. Additional Constraints * Use linear probing for collision resolution. * Ensure that resizing occurs when 2/3 of the table is filled. # Expected Outcome Your implementation should efficiently handle key-value insertions, updates, lookups, and deletions, and dynamically adjust its size to maintain performance. # Example Usage ```python hash_table = DynamicHashTable() hash_table.put(1, \'apple\') hash_table.put(2, \'banana\') print(hash_table.get(1)) # Output: \'apple\' hash_table.put(1, \'orange\') print(hash_table.get(1)) # Output: \'orange\' hash_table.del_(1) print(hash_table.get(1)) # Output: None ```","solution":"class DynamicHashTable: def __init__(self, min_size=8): self.min_size = min_size self.size = min_size self.count = 0 self.table = [None] * self.size def __hash(self, key): return hash(key) % self.size def __resize(self): old_table = self.table self.size *= 2 self.table = [None] * self.size self.count = 0 for item in old_table: if item is not None: self.put(item[0], item[1]) def put(self, key, value): if self.count >= 2 * self.size // 3: self.__resize() idx = self.__hash(key) while self.table[idx] is not None: if self.table[idx][0] == key: self.table[idx] = (key, value) return idx = (idx + 1) % self.size self.table[idx] = (key, value) self.count += 1 def get(self, key): idx = self.__hash(key) start_idx = idx while self.table[idx] is not None: if self.table[idx][0] == key: return self.table[idx][1] idx = (idx + 1) % self.size if idx == start_idx: break return None def del_(self, key): idx = self.__hash(key) start_idx = idx while self.table[idx] is not None: if self.table[idx][0] == key: self.table[idx] = None self.count -= 1 self.__rehash_from(idx) return idx = (idx + 1) % self.size if idx == start_idx: break def __rehash_from(self, deleted_idx): idx = (deleted_idx + 1) % self.size while self.table[idx] is not None: key, value = self.table[idx] self.table[idx] = None self.count -= 1 self.put(key, value) idx = (idx + 1) % self.size"},{"question":"# Scenario Your company is involved in a project to design a cost-efficient network for a newly established city. The network should connect all the key points in the city (e.g., buildings, parks, museums) with the minimal total length of cables. You have been tasked to write a program that calculates the minimum total length of cables required to connect all key points without any redundant connections. # Problem Statement Write a function `minimum_cable_length(graph)` that takes as input an undirected graph representing the city\'s key points and their direct connections, along with their respective cable lengths. Nodes are represented by strings (e.g., \'a\', \'b\', \'c\'), and edges are represented as lists within a dictionary. Your function should return the total minimum cable length needed to connect all key points using Prim\'s algorithm. # Input Format - `graph`: A dictionary where keys are node identifiers (string), and values are lists of lists. Each list within the value represents a connection in the form `[distance, adjacent_node]`. # Output Format - A single integer representing the total minimum cable length required. # Constraints - The graph is connected and undirected. - Node identifiers are strings. - There are no negative edge weights. - Edge weights are positive integers. # Example ```python graph = { \'a\': [ [3, \'b\'], [8,\'c\'] ], \'b\': [ [3, \'a\'], [5, \'d\'] ], \'c\': [ [8, \'a\'], [2, \'d\'], [4, \'e\'] ], \'d\': [ [5, \'b\'], [2, \'c\'], [6, \'e\'] ], \'e\': [ [4, \'c\'], [6, \'d\'] ] } print(minimum_cable_length(graph)) # Expected output: 14 ``` # Notes - Use a priority queue to ensure that at each step, the edge with the smallest weight is considered first. - Keep track of visited nodes to avoid cycles. - Initialize the algorithm with an arbitrary starting node.","solution":"import heapq def minimum_cable_length(graph): Returns the minimum total cable length required to connect all key points in the given graph using Prim\'s algorithm. :param graph: Dictionary representing the graph where keys are node identifiers and values are lists of [distance, adjacent_node] pairs. :return: Integer representing the total minimum cable length. # Initialize priority queue, visited set, and total cable length pq = [] visited = set() total_length = 0 # Start with an arbitrary node (pick the first key in the graph) start_node = next(iter(graph)) visited.add(start_node) # Push all edges from the starting node into the priority queue for edge in graph[start_node]: heapq.heappush(pq, (edge[0], edge[1])) while pq: # Select the edge with the minimum distance distance, node = heapq.heappop(pq) if node not in visited: visited.add(node) total_length += distance # Push all edges from the newly added node to the priority queue for edge in graph[node]: if edge[1] not in visited: heapq.heappush(pq, (edge[0], edge[1])) return total_length"},{"question":"Shortest Distance to Gates Using Breadth-First Search **Context**: You are an engineer working on a grid-based maze game prototype. The game contains multiple gates and rooms, and your task is to calculate the shortest distance from each room to the nearest gate. The grid has walls that block movement. **Problem Statement**: Given an `m x n` 2D grid of integers initialized with these values: - `-1`: A wall that cannot be passed through. - `0`: A gate. - `INF`: Infinity where `2^31 - 1 = 2147483647` represents an empty room. Write a function `walls_and_gates(grid)` that fills each empty room with the distance to its nearest gate. If it is impossible to reach a gate from an empty room, it should remain as `INF`. **Function Signature**: ```python def walls_and_gates(grid: List[List[int]]) -> None: pass ``` **Input**: - A 2D list `grid` of integers where `1 <= m, n <= 200`. **Output**: - The function modifies `grid` in-place to represent distances to the nearest gate. **Constraints**: - Walls (`-1`) and gates (`0`) are unchanged. - Performance should be optimized for large grids. **Example**: ```python grid = [ [2147483647, -1, 0, 2147483647], [2147483647, 2147483647, 2147483647, -1], [2147483647, -1, 2147483647, -1], [0, -1, 2147483647, 2147483647] ] walls_and_gates(grid) # After running your function, grid should be: # [ # [3, -1, 0, 1], # [2, 2, 1, -1], # [1, -1, 2, -1], # [0, -1, 3, 4] # ] ``` **Performance Requirements**: - Your function should complete in O(m * n) time. - Avoid excessive use of memory. **Hint**: - Use Breadth-First Search (BFS) for an optimized solution.","solution":"from collections import deque from typing import List def walls_and_gates(grid: List[List[int]]) -> None: if not grid or not grid[0]: return m, n = len(grid), len(grid[0]) INF = 2147483647 queue = deque() # Initialize the queue with all gates\' positions for i in range(m): for j in range(n): if grid[i][j] == 0: queue.append((i, j)) # Directions for moving up, down, left and right directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] # Perform BFS from all gates simultaneously while queue: x, y = queue.popleft() for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] == INF: grid[nx][ny] = grid[x][y] + 1 queue.append((nx, ny))"},{"question":"A delivery drone moves in a 2-dimensional plane starting from the origin (0, 0). The movements of the drone are represented by a string consisting of the characters \'R\' (Right), \'L\' (Left), \'U\' (Up), and \'D\' (Down). Your task is to write a function `is_drone_back(moves: str) -> bool` that determines whether the series of moves brings the drone back to its original position. # Constraints - The input string `moves` will have a length of at most (10^4). - The string `moves` contains only the characters \'R\', \'L\', \'U\', \'D\'. # Input Format - A single string `moves` representing the sequence of the drone\'s movements. # Output Format - Return `True` if the drone ends up back at its original position after all the moves, otherwise return `False`. # Example Example 1: **Input**: \\"UDLR\\" **Output**: `True` **Explanation**: The sequence results in moving up, down, left, and right, which brings the drone back to the original point (0, 0). Example 2: **Input**: \\"UUDDLRL\\" **Output**: `False` **Explanation**: The sequence results in an unequal number of moves in opposite directions, so the drone does not return to the starting point. # Additional Notes - Your function should handle edge cases, such as an empty input string, which should return `True` since the drone hasn\'t moved and is still at its starting point. - Ensure performance is within acceptable limits for an input string of the maximum length. # Function Signature ```python def is_drone_back(moves: str) -> bool: pass ```","solution":"def is_drone_back(moves: str) -> bool: Determines if the series of moves brings the drone back to its original position. Parameters: moves (str): A string containing the movements of the drone. Returns: bool: True if the drone ends up back at the starting position (0, 0), otherwise False. horizontal = 0 vertical = 0 for move in moves: if move == \'R\': horizontal += 1 elif move == \'L\': horizontal -= 1 elif move == \'U\': vertical += 1 elif move == \'D\': vertical -= 1 return horizontal == 0 and vertical == 0"},{"question":"# Binary Tree Subtree Check Scenario: You are working on a software that needs to determine structural similarities between different hierarchical data. One of the application scenarios is to detect if a certain subset of a large dataset matches another smaller dataset in structure and contents. Objective: Implement a function `is_subtree(big, small)` that determines if the smaller binary tree `small` is a subtree of the larger binary tree `big`. Function Signature: ```python def is_subtree(big: Optional[TreeNode], small: Optional[TreeNode]) -> bool: ``` Inputs: * `big` - The root node of the larger binary tree. (Type: Optional[TreeNode]) * `small` - The root node of the smaller binary tree to check if it is a subtree. (Type: Optional[TreeNode]) Outputs: * Returns `True` if `small` is a subtree of `big`, `False` otherwise. (Type: bool) Constraints: * Both trees are composed of nodes with integer values. * The number of nodes in both trees is between 0 and 10000. * TreeNodes may have either `None` or integer values for `left` and `right` attributes. Example: **Example 1:** ```plaintext Given big: 3 / 4 5 / 1 2 Given small: 4 / 1 2 is_subtree(big, small) returns True. ``` **Example 2:** ```plaintext Given big: 3 / 4 5 / 1 2 / 0 Given small: 4 / 1 2 is_subtree(big, small) returns False. ``` Note: Consider performance optimization techniques for handling large discrepancies in tree sizes. Follow-Up: Discuss how your solution would handle scenarios where one tree is significantly larger than the other, and suggest any potential optimizations.","solution":"from typing import Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_subtree(big: Optional[TreeNode], small: Optional[TreeNode]) -> bool: if not small: return True if not big: return False if is_identical(big, small): return True return is_subtree(big.left, small) or is_subtree(big.right, small) def is_identical(tree1: Optional[TreeNode], tree2: Optional[TreeNode]) -> bool: if not tree1 and not tree2: return True if not tree1 or not tree2: return False if tree1.val != tree2.val: return False return is_identical(tree1.left, tree2.left) and is_identical(tree1.right, tree2.right)"},{"question":"# Scenario You are developing a navigation system for a large metropolitan area represented as a directed graph. Each intersection is represented as a vertex, and each directed road as an edge. You must determine if there is a navigable path (sequence of roads) between any two given intersections. # Problem Statement Implement a method to determine if there is a path between two given intersections (nodes) in a directed graph using a depth-first search (DFS) algorithm. # Requirements 1. **Input**: - An instance of a Graph class, `G` with `V` vertices. - Two integers, `source` and `target`, representing the intersections between which to determine the path. 2. **Output**: - A boolean value: `True` if there is a path from the `source` to the `target`, or `False` otherwise. # Function Signature ```python def is_path_exists(G: Graph, source: int, target: int) -> bool: pass ``` # Constraints - 1 ≤ V ≤ 1000 (number of intersections) - 1 ≤ E ≤ 5000 (number of roads) - 0 ≤ source, target < V # Example ```python # Define graph g = Graph(4) g.add_edge(0, 1) g.add_edge(0, 2) g.add_edge(1, 2) g.add_edge(2, 0) g.add_edge(2, 3) g.add_edge(3, 3) # Check paths print(is_path_exists(g, 1, 3)) # Output: True print(is_path_exists(g, 3, 1)) # Output: False ``` # Instructions 1. Implement the helper function `dfs` and `dfsutil` if necessary within the `is_path_exists` function scope. 2. Use depth-first search to determine if there is a path between the source and target nodes. 3. Ensure your solution handles edge cases effectively, such as graphs with no roads or isolated nodes.","solution":"class Graph: def __init__(self, V): self.V = V self.adj = [[] for _ in range(V)] def add_edge(self, u, v): self.adj[u].append(v) def is_path_exists(G: Graph, source: int, target: int) -> bool: def dfs(v, visited): visited[v] = True if v == target: return True for neighbor in G.adj[v]: if not visited[neighbor]: if dfs(neighbor, visited): return True return False visited = [False] * G.V return dfs(source, visited)"},{"question":"# Priority Task Manager You are tasked with developing a Priority Task Manager in Python, which utilizes a priority queue to manage a list of tasks. Each task has an associated priority to determine its importance. Implement the necessary methods to handle the task queue as described below: **Task**: Implement a class `PriorityTaskManager` that supports the following operations using a priority queue (as described in the analysis section): 1. **`add_task(task: str, priority: int)`:** Adds a new task with the specified priority to the manager. 2. **`remove_highest_priority_task() -> str`:** Removes and returns the task with the highest priority from the manager. Raises an Exception if there are no tasks. 3. **`get_highest_priority_task() -> str`:** Returns the task with the highest priority without removing it from the manager. Raises an Exception if there are no tasks. 4. **`get_task_count() -> int`:** Returns the number of tasks currently in the task manager. **Input and Output**: ```python class PriorityTaskManager: def __init__(self): Initialize empty task manager. pass def add_task(self, task: str, priority: int): Add a task with the given priority. pass def remove_highest_priority_task(self) -> str: Remove and return the task with the highest priority. pass def get_highest_priority_task(self) -> str: Return the task with the highest priority without removing it. pass def get_task_count(self) -> int: Return the count of tasks. pass ``` **Constraints**: - Tasks will be strings and are unique. - Priorities are integers (higher value means higher priority). - Consecutive calls to `remove_highest_priority_task` or `get_highest_priority_task` should raise an exception if the task manager is empty. **Performance Requirements**: - Focus on correctly implementing the priority queue operations; exact performance optimizations are secondary in this foundational exercise. **Example**: ```python manager = PriorityTaskManager() manager.add_task(\\"Task A\\", 10) manager.add_task(\\"Task B\\", 5) print(manager.get_highest_priority_task()) # Output: \\"Task A\\" print(manager.get_task_count()) # Output: 2 print(manager.remove_highest_priority_task()) # Output: \\"Task A\\" print(manager.get_task_count()) # Output: 1 print(manager.remove_highest_priority_task()) # Output: \\"Task B\\" print(manager.get_task_count()) # Output: 0 ```","solution":"import heapq class PriorityTaskManager: def __init__(self): Initialize empty task manager. self._task_queue = [] def add_task(self, task: str, priority: int): Add a task with the given priority. heapq.heappush(self._task_queue, (-priority, task)) def remove_highest_priority_task(self) -> str: Remove and return the task with the highest priority. if not self._task_queue: raise Exception(\\"No tasks in the manager.\\") return heapq.heappop(self._task_queue)[1] def get_highest_priority_task(self) -> str: Return the task with the highest priority without removing it. if not self._task_queue: raise Exception(\\"No tasks in the manager.\\") return self._task_queue[0][1] def get_task_count(self) -> int: Return the count of tasks. return len(self._task_queue)"},{"question":"# Scenario: You are developing a machine learning recommendation system. A key task involves computing similarities between user profiles based on their interaction histories. One approach to this is calculating the cosine similarity between vectors representing each user\'s interactions. # Task: Implement a function `cosine_similarity` that computes the cosine similarity between two given 1-dimensional lists. Each list represents a user profile and contains the same number of interaction counts in different categories. The similarity measure should be a value between -1 and 1. # Function Signature: ```python def cosine_similarity(vec1: List[int], vec2: List[int]) -> float: pass ``` # Input: - **vec1**: A list of integers representing the first user\'s interaction counts. - **vec2**: A list of integers representing the second user\'s interaction counts. # Output: - **float**: Representing the cosine similarity between the two vectors. # Constraints: - Both lists will have the same length, ranging from 1 to 10^6. - Each element in the lists will be an integer within the range [-10^6, 10^6]. # Requirements: 1. Your solution should handle edge cases effectively, such as zero vectors. 2. Ensure efficient computation, particularly for the upper constraints. # Example: ```python assert abs(cosine_similarity([1, 1, 1], [1, 2, -1]) - 0.47140452079103173) < 1e-9 ```","solution":"from typing import List import math def cosine_similarity(vec1: List[int], vec2: List[int]) -> float: Computes the cosine similarity between two vectors. Args: vec1 (List[int]): first user interaction vector. vec2 (List[int]): second user interaction vector. Returns: float: cosine similarity between vec1 and vec2. # Calculate dot product dot_product = sum(v1 * v2 for v1, v2 in zip(vec1, vec2)) # Calculate magnitudes magnitude_vec1 = math.sqrt(sum(v1**2 for v1 in vec1)) magnitude_vec2 = math.sqrt(sum(v2**2 for v2 in vec2)) # Avoid division by zero if magnitude_vec1 == 0 or magnitude_vec2 == 0: return 0.0 # Calculate cosine similarity return dot_product / (magnitude_vec1 * magnitude_vec2)"},{"question":"# Dijkstra\'s Modified Assessment You are working as a software engineer at a delivery company. Your task is to develop a software module that finds the shortest delivery routes between warehouses in a city. Each warehouse is identified by a unique ID, and routes between them are represented with positive weights (time to travel). Problem Description The module must be able to compute the shortest time to travel from a given warehouse (source) to all other warehouses. Given a directed graph with non-negative weights, implement the modified Dijkstra\'s algorithm to achieve this. Function Specification You need to implement the function: ```python def find_shortest_paths(n, edges, source): Compute the shortest time to travel from the source warehouse to all other warehouses. Parameters: n (int): Number of warehouses (vertices). edges (List[Tuple[int, int, int]]): List of directed routes (u, v, w) where u is the starting warehouse, v is the ending warehouse, and w is the travel time. source (int): The source warehouse ID. Returns: List[int]: Shortest travel times from the source warehouse to all other warehouses, where the value at index i represents the shortest time to warehouse i. If a warehouse is not reachable, the distance should remain infinity. pass ``` Input Format * `n`: Number of warehouses (vertices) in the graph. * `edges`: List of tuples representing directed routes, where each tuple contains three integers `(u, v, w)`: * `u`: Start warehouse ID. * `v`: End warehouse ID. * `w`: Travel time (positive integer). * `source`: The ID of the source warehouse. Output Format * Returns a list of integers representing the minimum travel time from the `source` warehouse to each warehouse. * If a warehouse is not reachable, the distance should be represented as `infinity` (use `float(\\"inf\\")` in Python). Constraints * `1 ≤ n ≤ 100` * `0 ≤ u, v < n` * `0 ≤ w ≤ 1000` Example Input: ```python n = 4 edges = [(0, 1, 1), (0, 2, 4), (1, 2, 2), (1, 3, 6), (2, 3, 3)] source = 0 ``` Output: ```python [0, 1, 3, 6] ``` Explanation From warehouse `0`: * The shortest path to warehouse `0` is `0` (itself). * The shortest path to warehouse `1` is `1` (direct edge). * The shortest path to warehouse `2` is `3` (0 -> 1 -> 2). * The shortest path to warehouse `3` is `6` (0 -> 1 -> 2 -> 3).","solution":"import heapq def find_shortest_paths(n, edges, source): Compute the shortest time to travel from the source warehouse to all other warehouses. Parameters: n (int): Number of warehouses (vertices). edges (List[Tuple[int, int, int]]): List of directed routes (u, v, w) where u is the starting warehouse, v is the ending warehouse, and w is the travel time. source (int): The source warehouse ID. Returns: List[int]: Shortest travel times from the source warehouse to all other warehouses, where the value at index i represents the shortest time to warehouse i. If a warehouse is not reachable, the distance should remain infinity. # Create an adjacency list graph = {i: [] for i in range(n)} for u, v, w in edges: graph[u].append((v, w)) # Initialize distances with infinity and set the source distance to zero distances = [float(\\"inf\\")] * n distances[source] = 0 # Priority queue to fetch the minimum distance pq = [(0, source)] # (distance, node) tuples while pq: current_dist, current_node = heapq.heappop(pq) # If the distance in pq is not the current known distance, we discard it if current_dist > distances[current_node]: continue # Explore neighbors for neighbor, weight in graph[current_node]: distance = current_dist + weight # If a shorter path to the neighbor is found if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(pq, (distance, neighbor)) return distances"},{"question":"# Matrix Multiplication Implementation Challenge **Context**: You are working on a project dealing with image processing where you need to perform multiple matrix multiplications for various transformations. To optimize and automate this task, you need to write a function that handles the matrix multiplication of two matrices while ensuring the dimensions are compatible. **Task**: Write a Python function `matrix_multiply` that takes two two-dimensional matrices (lists of lists) and returns their product. **Function Signature**: ```python def matrix_multiply(A: List[List[float]], B: List[List[float]]) -> List[List[float]]: pass ``` **Input**: * `A` (List[List[float]]): a matrix represented as a list of `n` lists, each of which contains `m` floats. * `B` (List[List[float]]): a matrix represented as a list of `m` lists, each of which contains `p` floats. **Output**: * `result` (List[List[float]]): the resulting matrix represented as a list of `n` lists, each of which contains `p` floats. **Constraints**: * The number of columns in matrix `A` must be equal to the number of rows in matrix `B`. * Matrices can have floating-point numbers. **Requirements**: * Ensure the function raises an exception if the matrices cannot be multiplied due to dimension mismatch. * Aim for an efficient solution, considering the time and space complexities. **Example**: ```python A = [ [1.0, 2.0, 3.0], [4.0, 5.0, 6.0] ] B = [ [7.0, 8.0], [9.0, 10.0], [11.0, 12.0] ] matrix_multiply(A, B) # Output should be: # [ # [58.0, 64.0], # [139.0, 154.0] # ] ``` **Additional Information**: * Focus on clarity and correctness of your implementation. * Handle floating-point operations carefully to avoid precision issues. * Think about potential edge cases such as empty matrices or non-compatible matrices and handle them appropriately.","solution":"from typing import List def matrix_multiply(A: List[List[float]], B: List[List[float]]) -> List[List[float]]: Multiplies two matrices A and B. Args: A: First matrix as a list of lists (n x m). B: Second matrix as a list of lists (m x p). Returns: result: the resulting matrix as a list of lists (n x p). Raises: ValueError: If the number of columns in A is not equal to the number of rows in B. # Number of rows in A, columns in A, rows in B, columns in B rows_a = len(A) cols_a = len(A[0]) rows_b = len(B) cols_b = len(B[0]) # Verify the dimensions are compatible for multiplication if cols_a != rows_b: raise ValueError(\\"The number of columns in A must be equal to the number of rows in B.\\") # Initialize the result matrix with zeros result = [[0.0] * cols_b for _ in range(rows_a)] # Perform the matrix multiplication for i in range(rows_a): for j in range(cols_b): for k in range(cols_a): result[i][j] += A[i][k] * B[k][j] return result"},{"question":"Efficient Anagram Comparison Given two strings `s` and `t`, determine if string `t` is an anagram of string `s`. Assume that both strings contain only lowercase alphabets. The goal is to implement this functionality efficiently. Functional Requirements * Implement the function `is_anagram(s: str, t: str) -> bool`: Input * Two strings, `s` and `t`. Output * Return `True` if `t` is an anagram of `s`, otherwise `False`. Constraints * Both strings will contain only lowercase alphabetical characters (a-z). Example ```python assert is_anagram(\\"anagram\\", \\"nagaram\\") == True assert is_anagram(\\"rat\\", \\"car\\") == False ``` Performance Requirements * Aim for a time complexity of O(n) where n is the length of the strings. * Optimize space complexity where possible as the character set size is fixed. Hints * Consider using a single hash map to track character counts and detect imbalances early. * Think about how the counts of characters can cancel each other out when processing both strings together.","solution":"from collections import Counter def is_anagram(s: str, t: str) -> bool: Determines if string t is an anagram of string s. s: string t: string returns: boolean indicating whether t is an anagram of s # Counter for both strings return Counter(s) == Counter(t)"},{"question":"You are working on a data processing system where you need to identify an anomaly. You are given an array of integers where every element appears exactly three times except one, which appears exactly once. Your task is to find and return that single one. **Context**: To ensure the efficiency of your algorithm, consider constraints on runtime and extra memory usage. **Requirements**: - Achieve linear runtime complexity (O(n)). - Do not use any extra memory for storing counts of occurrences. # Function Signature ```python def find_unique(nums: List[int]) -> int: pass ``` # Input - `nums` (List[int]): A list of integers where every element appears exactly three times except for one, which appears exactly once. The list is non-empty and contains at least one integer. # Output - `int`: The single integer that appears exactly once in the input list. # Constraints - You must implement the algorithm using constant extra space. - The function should handle lists of up to 10^6 elements efficiently. # Example ```python assert find_unique([2, 2, 3, 2]) == 3 assert find_unique([0, 1, 0, 1, 0, 1, 99]) == 99 ``` # Notes - The input list can contain both positive and negative integers. - The expected solution should leverage bitwise operations to achieve the desired efficiency.","solution":"from typing import List def find_unique(nums: List[int]) -> int: Finds the unique element in a list where every element except one appears exactly three times. once = 0 twice = 0 for num in nums: # `twice` stores bits that appear 2 times twice |= once & num # `once` stores bits that appear 1 time once ^= num # Find common bits that are there in both `once` and `twice` common_bits = once & twice # Remove `common_bits` from `once` and `twice` once &= ~common_bits twice &= ~common_bits return once"},{"question":"Optimizing the Logistics Network You are tasked with developing an efficient logistics network for a package delivery service. The network should be optimized such that the cost of laying down the connections (represented as edges in a graph) is minimized while still connecting all the distribution centers (represented as vertices). Given the number of distribution centers `n` and the number of possible connections `m`, along with the connections and their respective costs, write a function to compute the minimum cost required to connect all centers using Kruskal’s algorithm. # Function Signature ```python def minimum_connecting_cost(n: int, m: int, connections: List[Tuple[int, int, int]]) -> int: ``` # Input - `n` (int): The number of distribution centers. - `m` (int): The number of possible connections. - `connections` (List[Tuple[int, int, int]]): A list of tuples where each tuple consists of three integers `u`, `v`, and `w`, representing a connection between distribution center `u` and `v` with a cost `w`. # Output - Returns an integer which is the sum of the minimum cost to connect all distribution centers. # Constraints - 1 ≤ n ≤ 10^5 - 1 ≤ m ≤ 10^6 - 1 ≤ w ≤ 10^5 - Distribution centers are indexed from 1 to n. - There could be multiple connections between the same pair of distribution centers, always with different costs. # Example Input ```python n = 5 m = 6 connections = [ (1, 2, 3), (1, 3, 8), (2, 4, 5), (3, 4, 2), (3, 5, 4), (4, 5, 6) ] ``` Output ```python 14 ``` # Notes - You are expected to use Kruskal’s algorithm and the Disjoint Set data structure you\'ve learnt about. - Ensure that your solution is efficient and handles large inputs within the provided constraints.","solution":"from typing import List, Tuple def minimum_connecting_cost(n: int, m: int, connections: List[Tuple[int, int, int]]) -> int: # Kruskal\'s algorithm to find the minimum cost to connect all nodes # Sort edges by cost connections.sort(key=lambda x: x[2]) # Disjoint Set data structure to manage connected components parent = list(range(n + 1)) rank = [0] * (n + 1) def find(u): if parent[u] != u: parent[u] = find(parent[u]) return parent[u] def union(u, v): root_u = find(u) root_v = find(v) if root_u != root_v: if rank[root_u] > rank[root_v]: parent[root_v] = root_u elif rank[root_u] < rank[root_v]: parent[root_u] = root_v else: parent[root_v] = root_u rank[root_u] += 1 total_cost = 0 edge_count = 0 for u, v, w in connections: if find(u) != find(v): union(u, v) total_cost += w edge_count += 1 if edge_count == n - 1: # If we have connected n-1 edges, we are done break # If we haven\'t connected enough edges, return -1 (or could raise an Exception as it means it\'s a disconnected graph) return total_cost if edge_count == n - 1 else -1"},{"question":"# Pythagorean Theorem Application You are given a function that determines the length of the third side of a right-angled triangle when given the lengths of the other two sides. This function makes use of the Pythagorean Theorem `a^2 + b^2 = c^2`. Task Write a function `find_third_side(opposite, adjacent, hypotenuse)` that takes three arguments, where one is the unknown side indicated by the string `\\"?\\"`, and the other two are numeric values representing the known side lengths. The function should return the length of the unknown side as a floating-point number rounded to two decimal places. Input and Output Formats * Input parameters: * `opposite` (float or string \\"?\\"): The length of the side opposite to the right angle. * `adjacent` (float or string \\"?\\"): The length of the side adjacent to the right angle. * `hypotenuse` (float or string \\"?\\"): The length of the hypotenuse. * Output: * A floating-point number representing the length of the unknown side rounded to two decimal places. Constraints * Only one of `opposite`, `adjacent`, or `hypotenuse` will be the string \\"?\\". * All provided numeric side lengths will be positive numbers. Example ```python assert find_third_side(3, 4, \\"?\\") == 5.00 assert find_third_side(\\"?\\", 4, 5) == 3.00 assert find_third_side(3, \\"?\\", 5) == 4.00 ``` # Implementation Guidelines 1. Validate the inputs to ensure only one of the inputs is \\"?\\" and the others are positive numbers. 2. Use the Pythagorean Theorem to calculate the unknown side: * If the hypotenuse is unknown, use `c = sqrt(a^2 + b^2)` * If one leg is unknown, use `a = sqrt(c^2 - b^2)` or `b = sqrt(c^2 - a^2)` 3. Return the calculated side\'s length rounded to two decimal places. 4. Handle any potential mathematical errors (e.g., the square root of a negative number) by raising a `ValueError`.","solution":"import math def find_third_side(opposite, adjacent, hypotenuse): Determines the length of the unknown side of a right-angled triangle using the Pythagorean theorem. :param opposite: Length of the side opposite the right angle, or \'?\' if unknown. :param adjacent: Length of the side adjacent to the right angle, or \'?\' if unknown. :param hypotenuse: Length of the hypotenuse, or \'?\' if unknown. :return: Length of the unknown side rounded to two decimal places. if hypotenuse == \\"?\\": if opposite == \\"?\\" or adjacent == \\"?\\": raise ValueError(\\"Exactly one side must be unknown.\\") opp, adj = float(opposite), float(adjacent) return round(math.sqrt(opp**2 + adj**2), 2) elif opposite == \\"?\\": if hypotenuse == \\"?\\" or adjacent == \\"?\\": raise ValueError(\\"Exactly one side must be unknown.\\") hyp, adj = float(hypotenuse), float(adjacent) if hyp <= adj: raise ValueError(\\"Hypotenuse must be greater than the other sides.\\") return round(math.sqrt(hyp**2 - adj**2), 2) elif adjacent == \\"?\\": if hypotenuse == \\"?\\" or opposite == \\"?\\": raise ValueError(\\"Exactly one side must be unknown.\\") hyp, opp = float(hypotenuse), float(opposite) if hyp <= opp: raise ValueError(\\"Hypotenuse must be greater than the other sides.\\") return round(math.sqrt(hyp**2 - opp**2), 2) else: raise ValueError(\\"Exactly one side must be unknown.\\")"},{"question":"# Priority Queue Implementation Challenge # Context: You are tasked with implementing a priority queue for a system that manages tasks based on their priority. As new tasks (with their priorities) come in, they need to be inserted into the correct position in the priority queue. Tasks with higher priorities should be handled first. # Requirements: Implement the `PriorityQueue` class with the following methods: 1. **size(self) -> int**: Return the number of elements in the priority queue. 2. **push(self, item, priority=None)**: Insert an item with the given priority into the queue. If no priority is provided, the item\'s value will be used as its priority. 3. **pop(self) -> int**: Remove and return the item with the lowest priority from the queue. # Input: * For **`push(self, item, priority=None)`**: * `item` (int): The item to be inserted into the queue. * `priority` (Optional[int]): The priority of the item (defaults to the item value if None). * For **`pop(self)`**: * No inputs. # Output: * For **`size(self)`**: * Return the size of the queue as an integer. * For **`push(self, item, priority=None)`**: * No output. * For **`pop(self)`**: * Return the integer item with the lowest priority. If the queue is empty, raise an `IndexError`. # Constraints: * The number of `push` and `pop` operations will not exceed 10000. * The integer value of `item` and `priority` (if provided) will be between -100000 and 100000. # Example: ```python pq = PriorityQueue() pq.push(4, 2) pq.push(6, 3) print(pq.size()) # Output: 2 print(pq.pop()) # Output: 4 print(pq.size()) # Output: 1 pq.push(7) print(pq.pop()) # Output: 7 ``` # Note: * Ensure that edge cases like popping from an empty queue and inserting elements with the same priorities are handled correctly. * Consider common performance pitfalls and inefficient operations in your implementation.","solution":"import heapq class PriorityQueue: def __init__(self): self._queue = [] self._index = 0 def size(self) -> int: return len(self._queue) def push(self, item, priority=None): if priority is None: priority = item heapq.heappush(self._queue, (priority, self._index, item)) self._index += 1 def pop(self) -> int: if not self._queue: raise IndexError(\\"pop from empty priority queue\\") return heapq.heappop(self._queue)[2] # The following is an example usage of the `PriorityQueue` class. pq = PriorityQueue() pq.push(4, 2) pq.push(6, 3) print(pq.size()) # Output: 2 print(pq.pop()) # Output: 4 print(pq.size()) # Output: 1 pq.push(7) print(pq.pop()) # Output: 7"},{"question":"# Doubly Linked List Deletion Operations Scenario You are tasked with implementing deletion operations for a doubly linked list in a system that requires frequent updates to the elements. Efficiently handle deletions at arbitrary positions, including edge cases such as the head or the tail of the list. Requirements Implement the function `delete_node(node)` which deletes a given node from the doubly linked list. # Function Signature ```python def delete_node(node: \'DoublyLinkedListNode\') -> None: pass ``` * **Input**: * `node` - The node to be deleted from the doubly linked list (assume it is always part of the list). * **Output**: * None. The function should modify the linked list in place. # Constraints * Handle edge cases such as deleting the head or the tail of the list. * Optimize for readability and correctness. Example ```python # Initialize nodes node1 = DoublyLinkedListNode(1) node2 = DoublyLinkedListNode(2) node3 = DoublyLinkedListNode(3) # Set up the doubly linked list connections node1.next = node2 node2.prev = node1 node2.next = node3 node3.prev = node2 # Deleting the middle node delete_node(node2) # Expected state: # node1 <-> node3 assert node1.next == node3 assert node3.prev == node1 ```","solution":"class DoublyLinkedListNode: def __init__(self, data): self.data = data self.next = None self.prev = None def delete_node(node: \'DoublyLinkedListNode\') -> None: Deletes the given node from a doubly linked list. # If node is the head (prev is None) if node.prev is None: if node.next: # If there is a next node, update its prev to None node.next.prev = None else: node.prev.next = node.next # If node is the tail (next is None) if node.next is None: if node.prev: # If there is a previous node, update its next to None node.prev.next = None else: node.next.prev = node.prev # Clear the node\'s next and prev pointers node.prev = None node.next = None"},{"question":"# Queue Implementations: Call Center Simulator You are tasked with implementing a call center simulator which manages incoming and outgoing calls using queue data structures. The call center handles calls in the order they are received, ensuring no call is answered out of turn. **Requirements**: 1. Implement a `CallCenter` class using both `ArrayQueue` and `LinkedListQueue`. 2. Provide methods to: - `receive_call(call_id: int)`: Simulates receiving a call and adds it to the waiting queue. - `answer_call() -> int`: Answers the next call in the queue and returns the call id. - `current_call() -> int`: Returns the call id of the call currently at the front of the queue, without removing it. - `pending_calls() -> int`: Returns the number of calls currently waiting in the queue. # Specifications: 1. Your `CallCenter` class should allow switching between `ArrayQueue` and `LinkedListQueue` implementations at initialization. 2. Ensure that the operations handle edge cases such as answering calls from an empty queue. 3. Maintain performance efficiency and ensure no memory overflow for large number of calls. # Input Format: - Calls are represented by unique integers (call ids). # Output Format: - Implementations should return integers for calls answered/currently pending. - Raise appropriate exceptions when attempting to answer a call from an empty queue. # Example Usage: ```python call_center = CallCenter(queue_type=\'array\') call_center.receive_call(101) call_center.receive_call(102) assert call_center.current_call() == 101 assert call_center.answer_call() == 101 assert call_center.answer_call() == 102 assert call_center.pending_calls() == 0 call_center.answer_call() # should raise exception ```","solution":"class ArrayQueue: def __init__(self): self.queue = [] def enqueue(self, item): self.queue.append(item) def dequeue(self): if self.is_empty(): raise IndexError(\\"Queue is empty\\") return self.queue.pop(0) def front(self): if self.is_empty(): raise IndexError(\\"Queue is empty\\") return self.queue[0] def is_empty(self): return len(self.queue) == 0 def size(self): return len(self.queue) class Node: def __init__(self, value): self.value = value self.next = None class LinkedListQueue: def __init__(self): self.head = None self.tail = None self._size = 0 def enqueue(self, item): new_node = Node(item) if self.tail: self.tail.next = new_node self.tail = new_node if not self.head: self.head = new_node self._size += 1 def dequeue(self): if self.is_empty(): raise IndexError(\\"Queue is empty\\") value = self.head.value self.head = self.head.next if self.head is None: self.tail = None self._size -= 1 return value def front(self): if self.is_empty(): raise IndexError(\\"Queue is empty\\") return self.head.value def is_empty(self): return self.head is None def size(self): return self._size class CallCenter: def __init__(self, queue_type=\'array\'): if queue_type == \'array\': self.queue = ArrayQueue() elif queue_type == \'linkedlist\': self.queue = LinkedListQueue() else: raise ValueError(\\"Unsupported queue type\\") def receive_call(self, call_id): self.queue.enqueue(call_id) def answer_call(self): return self.queue.dequeue() def current_call(self): return self.queue.front() def pending_calls(self): return self.queue.size()"},{"question":"# Task Description You are given two functions each for converting integers to their byte array representations and vice versa using big-endian and little-endian formats. Your task is to enhance these functions to handle signed integers (both positive and negative). In addition, you need to write a helper function that can determine if a system is big-endian or little-endian. # Requirements 1. **Function Signature**: - `def signed_int_to_bytes_big_endian(num: int) -> bytes` - `def signed_int_to_bytes_little_endian(num: int) -> bytes` - `def signed_bytes_big_endian_to_int(bytestr: bytes) -> int` - `def signed_bytes_little_endian_to_int(bytestr: bytes) -> int` - `def detect_endianness() -> str` 2. **Conversion Function Criteria**: - Handle both positive and negative integers. - For a positive integer, the output should be the same as the provided functions. - For a negative integer, use two\'s complement representation. 3. **Endianness Detection Function**: - The function should return `\\"big\\"` if the system is big-endian, else `\\"little\\"`. # Example ```python signed_int_to_bytes_big_endian(-12345) # should return the correct two\'s complement byte array signed_int_to_bytes_little_endian(-12345) # should return the correct two\'s complement byte array signed_bytes_big_endian_to_int(b\'xffxffxcfxc7\') # should return -12345 signed_bytes_little_endian_to_int(b\'xc7xcfxffxff\') # should return -12345 detect_endianness() # should return \'big\' or \'little\' ``` # Constraints 1. Assume standard 4-byte integers (32 bits). 2. Function must handle edge cases including zero and minimum/maximum integer values. 3. Do not use any external libraries (only built-in Python functions and data types are allowed). # Performance The functions should perform efficiently with regards to both time and space. This means avoiding unnecessary computations and data structures.","solution":"import struct def signed_int_to_bytes_big_endian(num: int) -> bytes: Convert a signed integer to 4 bytes using big-endian format. return num.to_bytes(4, byteorder=\'big\', signed=True) def signed_int_to_bytes_little_endian(num: int) -> bytes: Convert a signed integer to 4 bytes using little-endian format. return num.to_bytes(4, byteorder=\'little\', signed=True) def signed_bytes_big_endian_to_int(bytestr: bytes) -> int: Convert 4 bytes in big-endian format to a signed integer. return int.from_bytes(bytestr, byteorder=\'big\', signed=True) def signed_bytes_little_endian_to_int(bytestr: bytes) -> int: Convert 4 bytes in little-endian format to a signed integer. return int.from_bytes(bytestr, byteorder=\'little\', signed=True) def detect_endianness() -> str: Determine if the system is big-endian or little-endian. return \'little\' if struct.unpack(\'<I\', struct.pack(\'=I\', 1))[0] == 1 else \'big\'"},{"question":"Scenario You are developing a word searching feature for an application that allows users to search for words with a literal representation or using a pattern where `.` can substitute any letter. To do this efficiently, you will utilize a dynamic data structure. Two potential approaches include a Trie-based structure and a Dictionary-based structure. Task Implement the two classes `WordDictionary` and `WordDictionary2` as described. Your implementation should support the following operations: 1. `add_word(word: str) -> None`: Adds a word to the data structure. 2. `search(word: str) -> bool`: Searches for a word in the data structure, where `.` can match any letter. Each class should be able to: - Add words efficiently. - Support search operations that can handle both literal and pattern-based inputs. Input and Output Format - `add_word` takes a single string input and returns void. - `search` takes a single string input and returns a boolean indicating if the word was found. Constraints - All input words and search patterns will consist of lowercase English letters only. - Input words and patterns will not exceed length 100. - You\'ll be given up to 10^5 add/search operations. Example ```python wd = WordDictionary() wd.add_word(\\"bad\\") wd.add_word(\\"dad\\") wd.add_word(\\"mad\\") assert wd.search(\\"pad\\") == False assert wd.search(\\"bad\\") == True assert wd.search(\\".ad\\") == True assert wd.search(\\"b..\\") == True wd2 = WordDictionary2() wd2.add_word(\\"bad\\") wd2.add_word(\\"dad\\") wd2.add_word(\\"mad\\") assert wd2.search(\\"pad\\") == False assert wd2.search(\\"bad\\") == True assert wd2.search(\\".ad\\") == True assert wd2.search(\\"b..\\") == True ``` - Your implementation should correctly handle various edge cases and perform efficiently given the constraints. - Ensure your solution and code comments enhance readability and maintainability.","solution":"class WordDictionary: def __init__(self): Initialize your data structure here. self.trie = {} def add_word(self, word: str) -> None: Adds a word into the data structure. node = self.trie for char in word: if char not in node: node[char] = {} node = node[char] node[\'\'] = True # Mark the end of a word def search(self, word: str) -> bool: Returns if the word is in the data structure. A word could contain the dot character \'.\' to represent any one letter. def dfs(node, i): if i == len(word): return \'\' in node # Check if it\'s an end of a word char = word[i] if char == \'.\': for key in node: if key != \'\' and dfs(node[key], i + 1): return True return False elif char in node: return dfs(node[char], i + 1) else: return False return dfs(self.trie, 0) class WordDictionary2: def __init__(self): Initialize your data structure here. self.words = [] def add_word(self, word: str) -> None: Adds a word into the data structure. self.words.append(word) def search(self, word: str) -> bool: Returns if the word is in the data structure. A word could contain the dot character \'.\' to represent any one letter. import re pattern = \\"^\\" + word.replace(\\".\\", \\"[a-z]\\") + \\"\\" regex = re.compile(pattern) for w in self.words: if regex.match(w): return True return False"},{"question":"Optimized Circular Buffer Queue Context You are designing a queue to manage tasks for a high-performance server handling millions of requests. The static array implementation from the provided code is potentially inefficient due to its dynamic resizing. Therefore, you decide to implement a queue with a fixed-size circular buffer, leveraging the provided abstract queue interface. Task Implement an **OptimizedCircularQueue** class that extends the `AbstractQueue`. This class should use a fixed-size circular buffer (array) to manage the queue operations efficiently, avoiding dynamic resizing. Requirements - Extend the `AbstractQueue` class. - Implement the methods: `__iter__`, `enqueue`, `dequeue`, and `peek`. - Use a fixed-size array (circular buffer) for storage. - Handle the wrap-around behavior in the circular buffer. - Ensure constant time complexity for enqueuing and dequeuing operations. # Function Signature: ```python class OptimizedCircularQueue(AbstractQueue): def __init__(self, capacity: int): pass def __iter__(self): pass def enqueue(self, value): pass def dequeue(self): pass def peek(self): pass ``` Constraints: - Input `capacity` will be a positive integer (1 ≤ capacity ≤ 10^6). - Enqueue and dequeue operations will be called in a balanced manner to keep space utilization below or equal to the capacity limit. - Handle edge cases appropriately (e.g., operations on an empty queue). Example ```python queue = OptimizedCircularQueue(5) queue.enqueue(1) queue.enqueue(2) print(queue.dequeue()) # Output: 1 print(queue.peek()) # Output: 2 queue.enqueue(3) queue.enqueue(4) queue.enqueue(5) queue.enqueue(6) print(queue.dequeue()) # Output: 2 ```","solution":"class AbstractQueue: def __iter__(self): raise NotImplementedError def enqueue(self, value): raise NotImplementedError def dequeue(self): raise NotImplementedError def peek(self): raise NotImplementedError class OptimizedCircularQueue(AbstractQueue): def __init__(self, capacity: int): self.capacity = capacity self.queue = [None] * capacity self.head = 0 self.tail = 0 self.size = 0 def __iter__(self): start = self.head count = self.size while count > 0: yield self.queue[start] start = (start + 1) % self.capacity count -= 1 def enqueue(self, value): if self.size == self.capacity: raise OverflowError(\\"Queue is full\\") self.queue[self.tail] = value self.tail = (self.tail + 1) % self.capacity self.size += 1 def dequeue(self): if self.size == 0: raise IndexError(\\"Dequeue from an empty queue\\") value = self.queue[self.head] self.queue[self.head] = None # Optional: clear the slot self.head = (self.head + 1) % self.capacity self.size -= 1 return value def peek(self): if self.size == 0: raise IndexError(\\"Peek from an empty queue\\") return self.queue[self.head]"},{"question":"Krishnamurthy Number Checker with Optimizations Write a Python function `is_krishnamurthy(n: int) -> bool` to check if a given number is a Krishnamurthy number. The function should be optimized by precomputing the factorials of digits 0 through 9. Input: * An integer `n` (0 <= n <= 2^31 - 1) Output: * Return `True` if `n` is a Krishnamurthy number, otherwise return `False`. Example: ```python assert is_krishnamurthy(145) == True assert is_krishnamurthy(40585) == True assert is_krishnamurthy(357) == False assert is_krishnamurthy(1) == True assert is_krishnamurthy(2) == True ``` Constraints and Limitations: * You must use precomputed factorials for digits 0 to 9. * Ensure the function runs efficiently even for the largest possible input values. * Handle any invalid input types by raising an appropriate error.","solution":"def is_krishnamurthy(n: int) -> bool: Check if a given number is a Krishnamurthy number. A Krishnamurthy number is a number whose sum of the factorial of its digits is equal to the number itself. Args: n (int): The number to be checked. Returns: bool: True if the number is a Krishnamurthy number, False otherwise. if not isinstance(n, int) or n < 0: raise ValueError(\\"Input must be a non-negative integer.\\") # Precompute the factorials of digits 0 through 9 factorials = [1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880] # Compute the sum of the factorial of the digits of n total = 0 for digit in str(n): total += factorials[int(digit)] return total == n"},{"question":"Scenario You have been tasked with implementing a library that includes multiple sorting algorithms to be used in various parts of your company\'s software. As part of this library, one of the requirements is to have a basic implementation of Exchange Sort for educational purposes and for handling very small sets of data where simplicity is preferred over performance. Task Write a function `exchange_sort(arr)` that takes a list of integers `arr` as input and returns a sorted list using the Exchange Sort algorithm. Constraints 1. Do not use built-in sort functions. 2. The input list `arr` can contain up to 1000 integer elements. 3. The integers can be positive, negative, and zero. 4. Aim to handle edge cases gracefully, such as empty or single-element arrays. Input/Output Format - **Input**: A list of integers `arr`. - **Output**: A sorted list of integers. Example ```python # Example 1 arr = [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5] # Expected Output: [1, 1, 2, 3, 3, 4, 5, 5, 5, 6, 9] # Example 2 arr = [10, -10, 0, 5, -5] # Expected Output: [-10, -5, 0, 5, 10] # Example 3 arr = [] # Expected Output: [] # Example 4 arr = [7] # Expected Output: [7] ``` Please provide a detailed and efficient implementation considering the edge cases and limitations discussed.","solution":"def exchange_sort(arr): Sorts a list of integers using the Exchange Sort algorithm. Parameters: arr (list): A list of integers. Returns: list: The sorted list of integers. n = len(arr) if n <= 1: return arr for i in range(n - 1): for j in range(i + 1, n): if arr[i] > arr[j]: # Swap the elements arr[i], arr[j] = arr[j], arr[i] return arr"},{"question":"# Question: Bit Index Manipulations Design a class `BitManipulator` which facilitates bit manipulation on an integer. Implement the following methods to handle common bit operations: 1. **get_bit(self, num: int, i: int) -> int**: - Fetch the value of the bit at position `i` in the integer `num`. - **Input**: An integer `num` and a bit index `i`. - **Output**: The bit value at the specified index (0 or 1). 2. **set_bit(self, num: int, i: int) -> int**: - Set the bit at position `i` to 1 in the integer `num`. - **Input**: An integer `num` and a bit index `i`. - **Output**: The integer `num` with the bit at index `i` set to 1. 3. **clear_bit(self, num: int, i: int) -> int**: - Clear the bit at position `i` (set to 0) in the integer `num`. - **Input**: An integer `num` and a bit index `i`. - **Output**: The integer `num` with the bit at index `i` cleared to 0. 4. **update_bit(self, num: int, i: int, bit: int) -> int**: - Update the bit at position `i` in the integer `num` to the value `bit` (0 or 1). - **Input**: An integer `num`, a bit index `i`, and a bit value `bit` (0 or 1). - **Output**: The integer `num` with the bit at index `i` updated to the specified value. # Examples: ```python manipulator = BitManipulator() # Example, get_bit print(manipulator.get_bit(5, 0)) # Output: 1 (binary 5 is 101) # Example, set_bit print(manipulator.set_bit(5, 1)) # Output: 7 (binary 7 is 111) # Example, clear_bit print(manipulator.clear_bit(5, 0)) # Output: 4 (binary 4 is 100) # Example, update_bit print(manipulator.update_bit(5, 1, 0)) # Output: 5 (binary 5 is 101) print(manipulator.update_bit(5, 2, 1)) # Output: 5 (binary 101 is already set) ``` # Constraints and Requirements: - All indices `i` are assumed to be non-negative. - Assume the integer `num` is represented using a standard 32-bit signed integer. - The bit value `bit` for the `update_bit` function can only be 0 or 1. Implement this functionality in a Python class without importing any external libraries.","solution":"class BitManipulator: def get_bit(self, num: int, i: int) -> int: Fetch the value of the bit at position `i` in the integer `num`. return (num >> i) & 1 def set_bit(self, num: int, i: int) -> int: Set the bit at position `i` to 1 in the integer `num`. return num | (1 << i) def clear_bit(self, num: int, i: int) -> int: Clear the bit at position `i` (set to 0) in the integer `num`. return num & ~(1 << i) def update_bit(self, num: int, i: int, bit: int) -> int: Update the bit at position `i` in the integer `num` to the value `bit` (0 or 1). mask = ~(1 << i) return (num & mask) | (bit << i)"},{"question":"Implement a Red-Black Tree Deletion Context You have been hired as a developer for a new database engine that uses Red-Black Trees for indexing to ensure efficient data storage and retrieval. One of your tasks is to implement the deletion operation in a Red-Black Tree. Problem Statement Using the provided Red-Black Tree implementation, complete the missing functionality for the `delete` and related `delete_fixup` functions ensuring the tree maintains all the Red-Black properties after a deletion operation. Function Signature ```python class RBTree: def delete(self, node): # Your code here def delete_fixup(self, node): # Your code here ``` Input - `node` (RBNode): The node to be deleted from the Red-Black Tree. Output - The Red-Black Tree should remain balanced and uphold all the Red-Black Tree properties after the deletion takes place. Constraints 1. The function should handle all necessary edge cases including cases where the node has one child, both children, or is a leaf node. 2. Implement the `delete_fixup` function to handle the necessary fixes after a node deletion to maintain Red-Black Tree properties. 3. Efficiency is crucial; ensure the solution adheres to O(log n) time complexity for deletions. Example Consider the Red-Black Tree before deletion (showing values only for simplification): ``` 11B / 2R 14B / 1B 7B 15R / 5R 8R / 4B ``` Deleting node with value `14` results in the following valid Red-Black Tree: ``` 11B / 2R 15B / 1B 7R / 5B 8B / 4B ```","solution":"class RBNode: def __init__(self, key, color, left=None, right=None, parent=None): self.key = key self.color = color self.left = left self.right = right self.parent = parent class RBTree: def __init__(self): self.nil = RBNode(None, \\"black\\") self.root = self.nil def delete(self, node): if node is None or node == self.nil: return y = node y_original_color = y.color if node.left == self.nil: x = node.right self._transplant(node, node.right) elif node.right == self.nil: x = node.left self._transplant(node, node.left) else: y = self._minimum(node.right) y_original_color = y.color x = y.right if y.parent == node: x.parent = y else: self._transplant(y, y.right) y.right = node.right y.right.parent = y self._transplant(node, y) y.left = node.left y.left.parent = y y.color = node.color if y_original_color == \\"black\\": self.delete_fixup(x) def delete_fixup(self, x): while x != self.root and x.color == \\"black\\": if x == x.parent.left: w = x.parent.right if w.color == \\"red\\": w.color = \\"black\\" x.parent.color = \\"red\\" self.left_rotate(x.parent) w = x.parent.right if w.left.color == \\"black\\" and w.right.color == \\"black\\": w.color = \\"red\\" x = x.parent else: if w.right.color == \\"black\\": w.left.color = \\"black\\" w.color = \\"red\\" self.right_rotate(w) w = x.parent.right w.color = x.parent.color x.parent.color = \\"black\\" w.right.color = \\"black\\" self.left_rotate(x.parent) x = self.root else: w = x.parent.left if w.color == \\"red\\": w.color = \\"black\\" x.parent.color = \\"red\\" self.right_rotate(x.parent) w = x.parent.left if w.right.color == \\"black\\" and w.left.color == \\"black\\": w.color = \\"red\\" x = x.parent else: if w.left.color == \\"black\\": w.right.color = \\"black\\" w.color = \\"red\\" self.left_rotate(w) w = x.parent.left w.color = x.parent.color x.parent.color = \\"black\\" w.left.color = \\"black\\" self.right_rotate(x.parent) x = self.root x.color = \\"black\\" def _transplant(self, u, v): if u.parent == None: self.root = v elif u == u.parent.left: u.parent.left = v else: u.parent.right = v v.parent = u.parent def _minimum(self, node): while node.left != self.nil: node = node.left return node def left_rotate(self, x): y = x.right x.right = y.left if y.left != self.nil: y.left.parent = x y.parent = x.parent if x.parent == None: self.root = y elif x == x.parent.left: x.parent.left = y else: x.parent.right = y y.left = x x.parent = y def right_rotate(self, x): y = x.left x.left = y.right if y.right != self.nil: y.right.parent = x y.parent = x.parent if x.parent == None: self.root = y elif x == x.parent.right: x.parent.right = y else: x.parent.left = y y.right = x x.parent = y"},{"question":"# Sorting a List of Tuples using Gnome Sort Context: You are working on an antique shop\'s inventory system which requires sorting a list of items. Each item in the inventory system is represented as a tuple containing the item name and price. You decide to use Gnome Sort due to its simplicity and adaptive nature, particularly suited for this small-scale, nearly sorted list. Write a function `gnome_sort_tuples(arr)` that sorts a list of tuples based on the item prices in ascending order using the Gnome Sort algorithm. Function Signature: ```python def gnome_sort_tuples(arr: List[Tuple[str, int]]) -> List[Tuple[str, int]]: pass ``` Input: * `arr` (List[Tuple[str, int]]): A list of tuples where each tuple contains a string (item\'s name) and an integer (item\'s price). Output: * Returns a list of tuples sorted based on item prices in ascending order. Constraints: * The list may be empty. * Ensure the algorithm handles edge cases such as all elements having the same price. * The function should run in-place (i.e., with O(1) extra space). Example: 1. Input: `[(\\"apple\\", 50), (\\"banana\\", 30), (\\"cherry\\", 40)]` Output: `[(\\"banana\\", 30), (\\"cherry\\", 40), (\\"apple\\", 50)]` 2. Input: `[(\\"apple\\", 20), (\\"banana\\", 20), (\\"cherry\\", 20)]` Output: `[(\\"apple\\", 20), (\\"banana\\", 20), (\\"cherry\\", 20)]` 3. Input: `[(\\"apple\\", 100)]` Output: `[(\\"apple\\", 100)]` Notes: * You can assume that item prices are unique or equal; no duplicates of (name, price) pairs. * Ensure to consider edge cases such as lists with a single element or already sorted lists.","solution":"from typing import List, Tuple def gnome_sort_tuples(arr: List[Tuple[str, int]]) -> List[Tuple[str, int]]: Sorts a list of tuples based on the item prices in ascending order using the Gnome Sort algorithm. index = 0 while index < len(arr): if index == 0 or arr[index][1] >= arr[index - 1][1]: index += 1 else: arr[index], arr[index - 1] = arr[index - 1], arr[index] index -= 1 return arr"},{"question":"# Scenario You are working on a large-scale database application, where you need to support efficient range queries on a set of data. Given the nature of your application, you frequently need to process requests like finding the range sum or range maximum in a dynamic array. To achieve this efficiently, you decide to use segment trees. # Objective Implement a class `SegmentTree` that can build a segment tree and support range queries using a provided associative function. # Task - Implement the `SegmentTree` class with the following methods: - `__init__(self, arr, function)`: Constructs the segment tree from the input list using the provided associative function. - `query(self, L, R)`: Returns the result of the associative function applied from index L to index R (inclusive) in the array. # Input - An integer array `arr` where 1 <= len(arr) <= 10^6 and -10^9 <= arr[i] <= 10^9. - A function `function` which takes two arguments of the same type as elements of `arr` and returns a value of the same type. Example functions can be `min`, `max`, `sum`. # Output - For each call to the `query(L, R)` method, return the result based on the associative function over the specified range. # Constraints - The `query` method must run in O(log N) time. # Example ```python # Example usage: # Function to use in the segment tree def combine(x, y): return x + y # Creating the segment tree seg_tree = SegmentTree([1, 3, 5, 7, 9, 11], combine) # Querying the sum from index 1 to 3 print(seg_tree.query(1, 3)) # Output should be 15 (3+5+7) # Querying the sum from index 0 to 5 print(seg_tree.query(0, 5)) # Output should be 36 (1+3+5+7+9+11) ```","solution":"class SegmentTree: def __init__(self, arr, function): Constructs a segment tree from the input list using the provided associative function. :param arr: List[int], input array to build the segment tree from. :param function: Callable[[T, T], T], associative function to use for segment tree operations. self.n = len(arr) self.function = function self.tree = [0] * (2 * self.n) # Build the tree for i in range(self.n): self.tree[self.n + i] = arr[i] for i in range(self.n - 1, 0, -1): self.tree[i] = self.function(self.tree[i * 2], self.tree[i * 2 + 1]) def query(self, L, R): Returns the result of the associative function applied from index L to index R (inclusive) in the array. :param L: int, left index of the range. :param R: int, right index of the range. :return: int or float, result of the associative function over the specified range. L += self.n R += self.n result = None # Initialize result with an identity element while L <= R: if L % 2 == 1: result = self.tree[L] if result is None else self.function(result, self.tree[L]) L += 1 if R % 2 == 0: result = self.tree[R] if result is None else self.function(result, self.tree[R]) R -= 1 L //= 2 R //= 2 return result"},{"question":"# Problem Context You are working on a data processing project where you need to filter numerical data based on specified range constraints. The data is represented as a list of integers. Your task is to implement a function that returns a subset of this list, containing only the values within the specified minimum and maximum limits. If either of the limits is not provided, the function should still return the array filtered by the available limit. # Problem Statement Write a function `range_filter(arr, min_val, max_val)` that filters the input list `arr` within the given range `[min_val, max_val]`. # Function Signature ```python def range_filter(arr: List[int], min_val: int = None, max_val: int = None) -> List[int]: ``` # Input * `arr`: A list of integers representing the data to be filtered (1 <= len(arr) <= 10^6). * `min_val`: An integer representing the minimum value of the range; if not provided, it defaults to `None`. * `max_val`: An integer representing the maximum value of the range; if not provided, it defaults to `None`. # Output * A list of integers containing only the values from `arr` within the specified range `[min_val, max_val]`. # Constraints * If both `min_val` and `max_val` are `None`, return the original array. * You may assume that all elements in the array and the limit values are integers. # Examples ```python assert range_filter([1, 2, 3, 4, 5], None, 3) == [1, 2, 3] assert range_filter([10, 20, 30, 40, 50], 25, None) == [30, 40, 50] assert range_filter([5, 4, 3, 2, 1], 2, 4) == [4, 3, 2] assert range_filter([], None, 10) == [] assert range_filter([1, 2, 3, 4, 5], None, None) == [1, 2, 3, 4, 5] ``` # Additional Notes * Make sure to handle edge cases such as empty arrays and cases where no limits are provided. * Implement the solution with a focus on readability and efficiency.","solution":"from typing import List, Optional def range_filter(arr: List[int], min_val: Optional[int] = None, max_val: Optional[int] = None) -> List[int]: Filters the input list \'arr\' to only include values within the range [min_val, max_val]. :param arr: List of integers to be filtered. :param min_val: Minimum value of the range (inclusive). Defaults to None. :param max_val: Maximum value of the range (inclusive). Defaults to None. :return: List of integers within the specified range. return [x for x in arr if (min_val is None or x >= min_val) and (max_val is None or x <= max_val)]"},{"question":"# Question: Extended Integer to Roman Numeral Conversion You are tasked with enhancing and implementing a function that converts an integer to its corresponding Roman numeral representation. The initial range of conversion (1 to 3999) is to be maintained, but the solution needs to handle a larger scope of robust inputs and validation. Below are the specifics for the enhanced function: Function Signature ```python def extended_int_to_roman(num: int) -> str: ``` Input * **num (int)**: An integer within the range from 1 to 3999. Output * **str**: The Roman numeral representation as a string. Constraints * Your function must: * Return a string with the Roman numeral representation of the input integer. * Handle inputs outside the range of 1 to 3999 by raising a `ValueError` with a descriptive message. * Ensure that the input is a positive integer. If not, raise a `TypeError` or `ValueError` as appropriate with a descriptive message. * Maintain the constant time complexity O(1) for valid inputs within the range. # Implementation Requirements 1. Verify that `num` is within the acceptable range. 2. Include type checks to ensure `num` is an integer and is positive. 3. Maintain constant time conversion logic for valid inputs. # Example Scenarios 1. If input `num` is `1987`, the function should return `\\"MCMLXXXVII\\"`. 2. If input `num` is `3999`, the function should return `\\"MMMCMXCIX\\"`. 3. If input `num` is `0` or any number greater than `3999`, raise a `ValueError`. 4. If input `num` is `-100` or \\"`two\\"`, raise appropriate errors. This extended task allows for demonstrating comprehension on input validation, error management, and maintaining efficiency in processing.","solution":"def extended_int_to_roman(num: int) -> str: Converts an integer to its Roman numeral representation. Raises ValueError for numbers outside the range 1 to 3999. Raises TypeError for non-integer inputs. if not isinstance(num, int): raise TypeError(\\"Input must be an integer.\\") if num < 1 or num > 3999: raise ValueError(\\"Input must be a positive integer within the range 1 to 3999.\\") val = [ 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1 ] syb = [ \\"M\\", \\"CM\\", \\"D\\", \\"CD\\", \\"C\\", \\"XC\\", \\"L\\", \\"XL\\", \\"X\\", \\"IX\\", \\"V\\", \\"IV\\", \\"I\\" ] roman_num = \'\' i = 0 while num > 0: for _ in range(num // val[i]): roman_num += syb[i] num -= val[i] i += 1 return roman_num"},{"question":"# Unique Permutations with Caching **Objective:** Write a function that generates all possible unique permutations of a list of numbers that may contain duplicates using a more optimized backtracking approach. # Function Signature ```python def permute_unique(nums: List[int]) -> List[List[int]]: ``` # Input * `nums`: A list of integers which may contain duplicates, e.g., `[1, 1, 2]`. # Output * Return a list of unique permutations where each permutation is represented as a list of integers, e.g., `[[1, 1, 2], [1, 2, 1], [2, 1, 1]]`. # Constraints * 0 ≤ len(nums) ≤ 10 * -10 ≤ nums[i] ≤ 10 # Performance Requirements * The function should efficiently handle inputs approaching the maximum size constraints. * Ensure that duplicate permutations are not present in the final output. # Scenario You are developing a feature for an application that requires generating unique permutations of a dataset, which might have duplicate entries. Given the constraints, an optimized backtracking approach is preferred for its better handling of the input size. # Example ```python #Example 1: input: [1,1,2] output: [ [1,1,2], [1,2,1], [2,1,1] ] #Example 2: input: [1,2,3] output: [ [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1] ] ``` Implement the `permute_unique` function to achieve the desired results using an optimized approach.","solution":"from typing import List def permute_unique(nums: List[int]) -> List[List[int]]: def backtrack(start): if start == len(nums): result.append(nums[:]) return seen = set() for i in range(start, len(nums)): if nums[i] in seen: continue seen.add(nums[i]) nums[start], nums[i] = nums[i], nums[start] backtrack(start + 1) nums[start], nums[i] = nums[i], nums[start] result = [] nums.sort() # Sort the numbers to handle duplicates backtrack(0) return result"},{"question":"# Stack Stutter - Advanced Duplication Task **Objective**: Write a Python function to duplicate each element in a stack while ensuring minimal auxiliary space usage. Function Prototype: ```python def advanced_stutter(stack): pass ``` Input: - The function receives a single input: - `stack`: A list representing a stack where the top element is at the last index. Output: - The function returns: - A list (stack) where every element from the original stack is duplicated following its initial order. Constraints: - Do not use additional data structures with O(n) auxiliary space. - Handle edge cases efficiently like empty or single-element stacks. Examples: ```python # Example 1: stack = [3, 7, 1, 14, 9] print(advanced_stutter(stack)) # Output: [3, 3, 7, 7, 1, 1, 14, 14, 9, 9] # Example 2: stack = [] print(advanced_stutter(stack)) # Output: [] # Example 3: stack = [5] print(advanced_stutter(stack)) # Output: [5, 5] ``` **Scenario**: Imagine you\'re developing a simulation where each stack-based process operation needs duplication of its tasks before execution. Efficient memory management is crucial given the constraints of the system\'s resources.","solution":"def advanced_stutter(stack): This function duplicates each element in a stack (list) with minimal auxiliary space usage. index = 0 original_length = len(stack) while index < original_length: stack.insert(index * 2 + 1, stack[index * 2]) index += 1 return stack"},{"question":"Interpolation Search with Additional Features Given the Python implementation of the interpolation search algorithm, enhance its functionality to handle additional scenarios related to practical use cases of this algorithm. **Objective**: 1. Implement a function `optimized_interpolation_search` that incorporates additional edge case handling and optimizations for non-uniform distributions. 2. Add a feature that enables the function to handle arrays where elements might repeat and ensure it returns the first occurrence of the `search_key`, if present. # Requirements 1. **Function Signature**: `def optimized_interpolation_search(array: List[int], search_key: int) -> int:` 2. **Input**: - A sorted array of integers (`array`). - An integer value to search (`search_key`). 3. **Output**: - Index of the first occurrence of `search_key` in `array` if found. - Return -1 if `search_key` is not found in the array. 4. **Constraints**: - The input array can include repeated elements. - Handle edge cases where the `search_key` is out of the array\'s bounds, for instance, smaller than the smallest or larger than the largest element. - Ensure that the function does not degrade performance too drastically for non-uniformly distributed arrays. # Example ```python >>> optimized_interpolation_search([1, 2, 2, 2, 3, 4, 5], 2) 1 >>> optimized_interpolation_search([10, 12, 15, 20, 20, 21, 22], 20) 3 >>> optimized_interpolation_search([-10, -5, 0, 3, 8, 13, 15], 7) -1 >>> optimized_interpolation_search([5, 5, 5, 5, 5], 5) 0 ``` # Notes: - Implement the function to handle the given requirements effectively. - You can refactor or build upon the initial `interpolation_search` implementation provided earlier.","solution":"from typing import List def optimized_interpolation_search(array: List[int], search_key: int) -> int: low, high = 0, len(array) - 1 while low <= high and search_key >= array[low] and search_key <= array[high]: if low == high: if array[low] == search_key: return low return -1 if array[low] == array[high]: if array[low] == search_key: return low return -1 pos = low + ((high - low) * (search_key - array[low]) // (array[high] - array[low])) if array[pos] == search_key: # Find the first occurrence while pos > low and array[pos - 1] == search_key: pos -= 1 return pos if array[pos] < search_key: low = pos + 1 else: high = pos - 1 return -1"},{"question":"# Sorting Algorithm Enhancement **Objective**: Enhance the given Exchange Sort algorithm to improve its performance and reliability. Implement a sorting function that adopts an optimized sorting approach such as Merge Sort or Quick Sort. **Scenario**: Your software development team often works with datasets that vary in size from small to large. The existing Exchange Sort implementation becomes a performance bottleneck with larger datasets, and a more efficient sorting solution is required to handle these scenarios. **Task**: - Implement a function named `optimized_sort` that uses either Merge Sort or Quick Sort. - The function should accept a list of integers and return a sorted list. - Your implementation should aim for a more favorable time complexity than O(n^2). **Function Signature**: ```python def optimized_sort(arr: list) -> list: pass ``` **Input**: - `arr`: A list of integers of size `n` where 1 <= n <= 10000. **Output**: - A sorted list of integers. **Constraints**: - Your solution should handle edge cases such as empty input, arrays with a single element, and arrays with repeated elements. - Aim for a time complexity of O(n log n) on average cases. **Performance Requirements**: - The solution should perform the sorting operation efficiently enough to handle an array of size 10,000 elements within reasonable execution times. **Example**: ```python # Example Input arr = [5, 2, 9, 1, 5, 6] # Example Output print(optimized_sort(arr)) # Output: [1, 2, 5, 5, 6, 9] ``` Ensure your implementation is well-tested with various types of input arrays to validate correctness and performance.","solution":"def optimized_sort(arr): Perform optimized sort using Quick Sort. Args: arr (list): List of integers to sort. Returns: list: Sorted list of integers. if len(arr) <= 1: return arr pivot = arr[len(arr) // 2] left = [x for x in arr if x < pivot] middle = [x for x in arr if x == pivot] right = [x for x in arr if x > pivot] return optimized_sort(left) + middle + optimized_sort(right)"},{"question":"# Question: Implement an Efficient Nearest Neighbor Algorithm **Context:** You are working on a machine learning problem where you need to classify points based on their nearest neighbors in a training set. The current implementation calculates the Euclidean distance to each point in the training set to find the nearest neighbor. Your task is to implement a similar function but with improved performance and additional error handling. **Task:** Implement a function `efficient_nearest_neighbor` that takes two arguments: - `x`: A tuple representing the input point. - `tSet`: A dictionary representing the training set where keys are tuples (points) and values are labels. The function should return the label of the closest point in the training set to the input point using Euclidean distance. **Constraints:** - You may assume each point in the training set has the same dimension as the input point `x`. **Function Signature:** ```python def efficient_nearest_neighbor(x, tSet): # Your code here pass ``` # Input: - `x`: A tuple of integers or floats representing the coordinates of the input point, e.g., (2.5, 3.0). - `tSet`: A dictionary where keys are tuples of integers or floats (points), and values are labels (can be any data type). # Output: - The label of the point in the training set that is the nearest neighbor to `x`. # Example: ```python x = (1, 2) tSet = { (2, 3): \'A\', (1, 1): \'B\', (4, 5): \'C\' } print(efficient_nearest_neighbor(x, tSet)) # Output should be \'B\' because point (1, 1) is closest to (1, 2) ``` **Additional Requirements:** - Handle empty training set by returning `None`. - Ensure error handling for dimension mismatch between the input point and training set points. **Performance Considerations:** - An efficient implementation would ideally preprocess the training set to allow faster nearest neighbor searches.","solution":"import math def euclidean_distance(p1, p2): return math.sqrt(sum((a-b)**2 for a, b in zip(p1, p2))) def efficient_nearest_neighbor(x, tSet): Returns the label of the nearest neighbor to the point `x` in the training set `tSet`. Parameters: x (tuple): The input point. tSet (dict): The training set where keys are tuples (points) and values are labels. Returns: Any: The label of the nearest neighbor. if not tSet: return None if not all(len(point) == len(x) for point in tSet.keys()): raise ValueError(\\"All points in the training set must have the same dimension as the input point.\\") nearest_neighbor = None min_distance = float(\'inf\') for point, label in tSet.items(): distance = euclidean_distance(x, point) if distance < min_distance: min_distance = distance nearest_neighbor = label return nearest_neighbor"},{"question":"You have been provided with a sorted list of integers. Your task is to write a function that uses an iterative and a recursive approach to implement Binary Search. You should write both versions and handle edge cases gracefully as discussed. # Function Definitions 1. **iterative_binary_search** * **Input**: * `array` - A list of sorted integers. * `target` - An integer value to search for. * **Output**: * The index of the `target` in `array` if found, otherwise `None`. 2. **recursive_binary_search** * **Input**: * `array` - A list of sorted integers. * `low` - The starting index of the current search segment. * `high` - The ending index of the current search segment. * `target` - An integer value to search for. * **Output**: * The index of the `target` in `array` if found, otherwise `-1`. # Examples 1. **Iterative Approach** ```python iterative_binary_search([1, 2, 3, 4, 5], 3) ``` * Output: `2` ```python iterative_binary_search([1, 2, 3, 4, 5], 6) ``` * Output: `None` 2. **Recursive Approach** ```python recursive_binary_search([1, 2, 3, 4, 5], 0, 4, 3) ``` * Output: `2` ```python recursive_binary_search([1, 2, 3, 4, 5], 0, 4, 6) ``` * Output: `-1` # Constraints * `1 <= len(array) <= 10^5` * `-10^6 <= target, array[i] <= 10^6` for all elements of the `array`. # Important Notes * Ensure both functions handle edge cases. * Pay attention to the base case in the recursive implementation. * Your code should be efficient and concise.","solution":"def iterative_binary_search(array, target): Uses an iterative approach to find the target in a sorted array. :param array: List[int] - A sorted list of integers. :param target: int - An integer value to search for. :return: int or None - The index of the target in array if found, otherwise None. low, high = 0, len(array) - 1 while low <= high: mid = (low + high) // 2 if array[mid] == target: return mid elif array[mid] < target: low = mid + 1 else: high = mid - 1 return None def recursive_binary_search(array, low, high, target): Uses a recursive approach to find the target in a sorted array segment. :param array: List[int] - A sorted list of integers. :param low: int - The starting index of the current search segment. :param high: int - The ending index of the current search segment. :param target: int - An integer value to search for. :return: int or -1 - The index of the target in array if found, otherwise -1. if low > high: return -1 mid = (low + high) // 2 if array[mid] == target: return mid elif array[mid] < target: return recursive_binary_search(array, mid + 1, high, target) else: return recursive_binary_search(array, low, mid - 1, target)"},{"question":"# Integer Decomposition Problem You are given a positive integer `n`, and you need to determine the number of distinct ways to decompose `n` into sums of other positive integers. This problem is often referred to as the partitioning of an integer where the order of addition does not matter (i.e., 4 = 3 + 1 is considered the same as 4 = 1 + 3). Input - An integer `n` (1 ≤ n ≤ 100). Output - A single integer representing the number of distinct decompositions of `n`. Constraints - `1 ≤ n ≤ 100` Example *Example 1:* ```plaintext Input: 4 Output: 5 Explanation: 4 can be decomposed as follows: 4=4, 4=3+1, 4=2+2, 4=2+1+1, 4=1+1+1+1 ``` *Example 2:* ```plaintext Input: 7 Output: 15 Explanation: 7 can be decomposed as follows in 15 ways: 7=7, 7=6+1, 7=5+2, 7=5+1+1, 7=4+3, 7=4+2+1, 7=4+1+1+1, 7=3+3+1, 7=3+2+2, 7=3+2+1+1, 7=3+1+1+1+1, 7=2+2+2+1, 7=2+2+1+1+1, 7=2+1+1+1+1+1, 7=1+1+1+1+1+1+1 ``` Task Implement the following function to complete the task: ```python def int_decompose(n: int) -> int: Calculate number of distinct decompositions for the given integer. n -- integer (1 ≤ n ≤ 100) pass ``` *Note*: Your implementation should focus on efficient dynamic programming techniques to ensure optimal performance given the constraints.","solution":"def int_decompose(n: int) -> int: Calculate number of distinct decompositions for the given integer. n -- integer (1 ≤ n ≤ 100) # Initialize a list to store the number of ways to partition each number dp = [0] * (n + 1) dp[0] = 1 for i in range(1, n + 1): for j in range(i, n + 1): dp[j] += dp[j - i] return dp[n]"},{"question":"# Question: Matrix Transformation Implementation You have been provided with a matrix transformation module that consists of several functions to rotate and invert matrices. Write a Python function `matrix_transform(matrix: List[List[int]], transformation: str) -> List[List[int]]` which takes a `matrix` and a `transformation` type as input and returns the transformed matrix. The transformation can be one of the following: - \'rotate_clockwise\' - \'rotate_counterclockwise\' - \'top_left_invert\' - \'bottom_left_invert\' # Function Signature ```python from typing import List def matrix_transform(matrix: List[List[int]], transformation: str) -> List[List[int]]: # Your code here pass ``` # Input - `matrix`: a list of lists where each inner list represents a row in the matrix. It\'s guaranteed that `matrix` is not empty and is a square matrix (i.e., width == height). - `transformation`: a string representing the type of transformation to apply. # Output - The function should return a new matrix which is the result of applying the specified transformation. # Constraints - The matrix is an N x N (square) matrix. - 1 <= N <= 1000 - Matrix elements are integers. # Example ```python # Given a 3x3 matrix matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] # Applying \'rotate_clockwise\' output = matrix_transform(matrix, \'rotate_clockwise\') print(output) # Expected output: # [ # [7, 4, 1], # [8, 5, 2], # [9, 6, 3] # ] # Applying \'top_left_invert\' output = matrix_transform(matrix, \'top_left_invert\') print(output) # Expected output: # [ # [1, 4, 7], # [2, 5, 8], # [3, 6, 9] # ] ``` # Note Ensure your solution is optimized to handle matrices up to the maximum constraint efficiently.","solution":"from typing import List def rotate_clockwise(matrix: List[List[int]]) -> List[List[int]]: N = len(matrix) return [[matrix[N - j - 1][i] for j in range(N)] for i in range(N)] def rotate_counterclockwise(matrix: List[List[int]]) -> List[List[int]]: N = len(matrix) return [[matrix[j][N - i - 1] for j in range(N)] for i in range(N)] def top_left_invert(matrix: List[List[int]]) -> List[List[int]]: N = len(matrix) return [[matrix[j][i] for j in range(N)] for i in range(N)] def bottom_left_invert(matrix: List[List[int]]) -> List[List[int]]: N = len(matrix) return [[matrix[N - j - 1][i] for j in range(N)] for i in range(N)] def matrix_transform(matrix: List[List[int]], transformation: str) -> List[List[int]]: if transformation == \'rotate_clockwise\': return rotate_clockwise(matrix) elif transformation == \'rotate_counterclockwise\': return rotate_counterclockwise(matrix) elif transformation == \'top_left_invert\': return top_left_invert(matrix) elif transformation == \'bottom_left_invert\': return bottom_left_invert(matrix) else: raise ValueError(f\\"Unknown transformation: {transformation}\\")"},{"question":"# Problem: KMP Algorithm Application in DNA Sequence Search Researchers are often required to find patterns within DNA sequences for analysis. You are tasked with implementing the Knuth-Morris-Pratt (KMP) string matching algorithm to locate patterns within a DNA sequence. Function Signature ```python def find_dna_patterns(dna_sequence: str, motif: str) -> List[int]: Given a DNA sequence and a motif (pattern), return a list of start indices where the motif is found in the sequence. Args: dna_sequence: A string representing the DNA sequence to search within. motif: A string representing the motif to search for in the DNA sequence. Returns: List of integers representing the start indices of where the motif is found within the DNA sequence. Example: >>> find_dna_patterns(\\"ACGTACGTACG\\", \\"ACG\\") [0, 4, 8] Constraints: - Both dna_sequence and motif will only contain the characters A, C, G, and T. - Length of dna_sequence <= 10^6 - Length of motif <= 10^5 ``` Requirements: * **Input Format**: * `dna_sequence`: A string of characters containing only \'A\', \'C\', \'G\', and \'T\'. * `motif`: A string pattern of characters containing only \'A\', \'C\', \'G\', and \'T\'. * **Output Format**: * A list of integers indicating the starting indices of every occurrence of the motif in the DNA sequence. * **Constraints**: * The length of `dna_sequence` will be no more than 1,000,000. * The length of `motif` will be no more than 100,000. * **Performance requirements**: * The solution should efficiently handle large inputs utilizing O(N + M) time complexity. Example: For the given input DNA sequence \\"ACGTACGTACG\\" and motif \\"ACG\\": ```python print(find_dna_patterns(\\"ACGTACGTACG\\", \\"ACG\\")) ``` The corresponding output should be: ```python [0, 4, 8] ```","solution":"from typing import List def compute_lps_array(pattern: str) -> List[int]: Computes the Longest Prefix Suffix (LPS) array with pattern as parameter. LPS array is used to skip characters while matching. length = 0 # length of the previous longest prefix suffix lps = [0] * len(pattern) i = 1 while i < len(pattern): if pattern[i] == pattern[length]: length += 1 lps[i] = length i += 1 else: if length != 0: length = lps[length - 1] else: lps[i] = 0 i += 1 return lps def find_dna_patterns(dna_sequence: str, motif: str) -> List[int]: Given a DNA sequence and a motif (pattern), return a list of start indices where the motif is found in the sequence. if not dna_sequence or not motif: return [] n = len(dna_sequence) m = len(motif) lps = compute_lps_array(motif) indices = [] i = 0 # index for dna_sequence j = 0 # index for motif while i < n: if motif[j] == dna_sequence[i]: i += 1 j += 1 if j == m: indices.append(i - j) j = lps[j - 1] elif i < n and motif[j] != dna_sequence[i]: if j != 0: j = lps[j - 1] else: i += 1 return indices"},{"question":"# Prime Number Verification and Count You are tasked with writing a function that not only verifies whether given numbers are prime but also counts the number of prime numbers within a specified range. Function 1: `is_prime(n)` Implement the provided algorithm to check if a number `n` is a prime number. **Input:** * Integer `n` (1 ≤ |n| ≤ 10^6) **Output:** * Boolean - `True` if `n` is prime, else `False`. Function 2: `count_primes_in_range(start, end)` Write a function to count the number of prime numbers between two given integers [inclusive] using the `is_prime` function from above. **Input:** * Integer `start` (1 ≤ start ≤ 10^6) * Integer `end` (1 ≤ end ≤ 10^6) **Output:** * Integer - count of prime numbers within the range `[start, end]`. # Example: ```python def is_prime(n): # Your implementation here def count_primes_in_range(start, end): # Your implementation here # Example Usage print(is_prime(17)) # Output: True print(count_primes_in_range(10, 20)) # Output: 4 (11, 13, 17, 19 are prime) ``` # Constraints: 1. The solution for both functions must be efficient. 2. `count_primes_in_range` should leverage the `is_prime` function effectively. # Notes: * Ensure your implementation can handle edge cases, such as where `end` is less than `start`. * Aim for an optimized solution factoring in the constraints.","solution":"import math def is_prime(n): Returns True if n is a prime number, else False. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def count_primes_in_range(start, end): Returns the count of prime numbers in the range [start, end]. if start > end: return 0 count = 0 for num in range(start, end + 1): if is_prime(num): count += 1 return count"},{"question":"You are given a list of integers and are required to generate a histogram representation of the list. The histogram should be a dictionary where keys are the unique integers from the list, and the values are the counts of each integer\'s occurrences in the input list. # Function Signature ```python def get_histogram(input_list: list) -> dict: Generate a histogram representation of the input list. :param input_list: List[int] - a list of integers. :return: Dict[int, int] - a dictionary representing the histogram. ``` # Input and Output **Input**: * `input_list`: A list of integers, where integers can be repeated. **Output**: * A dictionary where the keys are the unique integers from the input list and the values are the counts of occurrences of each integer. # Constraints * The list can be empty. * The integers in the list can be positive or negative. * The integers are within the range of a standard 32-bit integer. # Example ```python # Example 1 input_list = [3, 3, 2, 1] print(get_histogram(input_list)) # Output: {1: 1, 2: 1, 3: 2} # Example 2 input_list = [2, 3, 5, 5, 5, 6, 4, 3, 7] print(get_histogram(input_list)) # Output: {2: 1, 3: 2, 4: 1, 5: 3, 6: 1, 7: 1} # Example 3 input_list = [] print(get_histogram(input_list)) # Output: {} ``` # Description In this task, you need to demonstrate your understanding of dictionary operations and iterating through the list to compute the frequency of each unique element. Ensure that your solution efficiently handles lists of various lengths and distributions of elements.","solution":"def get_histogram(input_list: list) -> dict: Generate a histogram representation of the input list. :param input_list: List[int] - a list of integers. :return: Dict[int, int] - a dictionary representing the histogram. histogram = {} for item in input_list: if item in histogram: histogram[item] += 1 else: histogram[item] = 1 return histogram"},{"question":"# Task: Implement a Doubly Linked List You have been hired to enhance the functionality of a simple appointment scheduling system. One of the key data structures used in this system is a doubly linked list, which allows for efficient insertion and deletion of appointments. Your task is to implement the `DoublyLinkedListNode` and `DoublyLinkedList` classes with necessary functionalities. DoublyLinkedListNode class: - **Attributes**: - `value`: stores the value of the node. - `next`: stores the reference to the next node. - `prev`: stores the reference to the previous node. DoublyLinkedList class: - **Attributes**: - `head`: points to the head node of the list. - `tail`: points to the tail node of the list. - **Methods**: 1. `insert_at_head(value)`: Insert a new node with the given value at the head of the list. 2. `insert_at_tail(value)`: Insert a new node with the given value at the tail of the list. 3. `delete(value)`: Delete the first node with the specified value from the list. 4. `display_forward()`: Display the list elements from head to tail. 5. `display_backward()`: Display the list elements from tail to head. Input/Output Formats: - The input to the methods will be values that are to be inserted or deleted. - The `display_forward` and `display_backward` methods should not take any inputs and should print the list elements in the specified order. Constraints: - Values for the `insert` operations can be any integer values. - `delete` operations should safely handle the case where the value to be deleted is not present. - The list can be empty initially or after deletions. Example: ```python dll = DoublyLinkedList() dll.insert_at_head(10) dll.insert_at_tail(20) dll.insert_at_head(5) dll.display_forward() # Output: 5 10 20 dll.display_backward() # Output: 20 10 5 dll.delete(10) dll.display_forward() # Output: 5 20 dll.delete(5) dll.delete(20) dll.display_forward() # Output: (empty) ``` Please implement the `DoublyLinkedListNode` and `DoublyLinkedList` classes with the methods described above.","solution":"class DoublyLinkedListNode: def __init__(self, value): self.value = value self.next = None self.prev = None class DoublyLinkedList: def __init__(self): self.head = None self.tail = None def insert_at_head(self, value): new_node = DoublyLinkedListNode(value) new_node.next = self.head if self.head: self.head.prev = new_node self.head = new_node if not self.tail: self.tail = new_node def insert_at_tail(self, value): new_node = DoublyLinkedListNode(value) new_node.prev = self.tail if self.tail: self.tail.next = new_node self.tail = new_node if not self.head: self.head = new_node def delete(self, value): current = self.head while current: if current.value == value: if current.prev: current.prev.next = current.next if current.next: current.next.prev = current.prev if current == self.head: self.head = current.next if current == self.tail: self.tail = current.prev return current = current.next def display_forward(self): current = self.head elements = [] while current: elements.append(current.value) current = current.next return elements def display_backward(self): current = self.tail elements = [] while current: elements.append(current.value) current = current.prev return elements"},{"question":"# Scenario: You are assigned the task of developing a library that includes an iterator for traversing a Binary Search Tree (BST). The iterator should allow users to perform in-order traversal (i.e., accessing nodes\' values in ascending order) without using recursion. Your implementation should particularly manage memory usage efficiently by avoiding redundant tree traversal. # Task: Implement the `BSTIterator` class which allows in-order traversal of a binary search tree using an explicit stack instead of recursion. # Function Signatures: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right class BSTIterator: def __init__(self, root: TreeNode): Initialize your data structure with the root of the BST. :param root: The root node of the BST. pass def has_next(self) -> bool: Returns true if there exists a number in the BST iterator. :return: Boolean indicating if there are more elements. pass def next(self) -> int: Returns the next smallest number in the BST. :return: The next smallest number. pass ``` # Constraints and Limitations: * The BST will have at most 10^5 nodes. * The values in the Binary Search Tree will range from -10^9 to 10^9. * The iterator should be implemented such that the `next()` function runs in average O(1) time and uses O(h) space where h is the height of the tree. * You should assume that the BST will not be modified (i.e., nodes will not be added or removed) during the iteration process. # Performance Requirement: * Ensure that the space complexity does not exceed O(h) where h is the height of the BST. * The `next()` function should aim for an average time complexity of O(1). # Example: ```python # Let us construct a BST and initialize the iterator # # 7 # / # 3 15 # / # 9 20 # # iterator = BSTIterator(root) # iterator.next() -> 3 # iterator.next() -> 7 # iterator.has_next() -> True # iterator.next() -> 9 # iterator.has_next() -> True # iterator.next() -> 15 # iterator.has_next() -> True # iterator.next() -> 20 # iterator.has_next() -> False ``` Implement the `BSTIterator` class with the details provided above.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right class BSTIterator: def __init__(self, root: TreeNode): Initialize your data structure with the root of the BST. :param root: The root node of the BST. self.stack = [] self._leftmost_inorder(root) def _leftmost_inorder(self, node): Helper function to push all the leftmost nodes of the current subtree to the stack. :param node: Current node in the BST. while node: self.stack.append(node) node = node.left def has_next(self) -> bool: Returns true if there exists a number in the BST iterator. :return: Boolean indicating if there are more elements. return len(self.stack) > 0 def next(self) -> int: Returns the next smallest number in the BST. :return: The next smallest number. topmost_node = self.stack.pop() if topmost_node.right: self._leftmost_inorder(topmost_node.right) return topmost_node.val"},{"question":"# Linked List Intersection Detection **Problem Statement**: You are given two singly linked lists that potentially share a common tail. Write a function `find_intersection(headA, headB)` which returns the intersected node. If the two linked lists have no intersection at all, return `None`. **Function Signature**: ```python def find_intersection(headA: Node, headB: Node) -> Node: ``` # Input - `headA`: The head of the first singly linked list. - `headB`: The head of the second singly linked list. # Output - Return the reference to the intersecting node if exists, else return `None`. # Constraints - Do not use additional data structures (O(1) space). - The linked lists are non-empty and could be of different lengths. - Assume that links are such that there is no cycle in the linked lists. # Example ```python class Node: def __init__(self, value = None): self.val = value self.next = None # List 1: 1 -> 3 -> 5 # # 7 -> 9 -> 11 # / # List 2: 2 -> 4 -> 6 node1 = Node(1) node3 = Node(3) node5 = Node(5) node7 = Node(7) node9 = Node(9) node11 = Node(11) node2 = Node(2) node4 = Node(4) node6 = Node(6) node1.next = node3 node3.next = node5 node5.next = node7 node7.next = node9 node9.next = node11 node2.next = node4 node4.next = node6 node6.next = node7 assert find_intersection(node1, node2).val == 7 ``` # Explanation In this example, the shared node is 7, where both list 1 and list 2 meet. Your implementation should return the actual node reference that corresponds to this value (7), not the value itself. **Notes**: - Ensure to handle edge cases like non-intersecting lists efficiently. - The comparison between nodes should be based on the node itself, not just the value it holds.","solution":"class Node: def __init__(self, value=None): self.val = value self.next = None def get_length(head): length = 0 while head is not None: head = head.next length += 1 return length def find_intersection(headA: Node, headB: Node) -> Node: # Step 1: Get lengths of both lists lengthA = get_length(headA) lengthB = get_length(headB) # Step 2: Move the head of the longer list forward by the difference in lengths if lengthA > lengthB: for _ in range(lengthA - lengthB): headA = headA.next else: for _ in range(lengthB - lengthA): headB = headB.next # Step 3: Move both heads forward until they intersect or reach the end of lists while headA is not None and headB is not None: if headA == headB: return headA headA = headA.next headB = headB.next return None"},{"question":"Scenario Imagine you are developing a text editor that includes a real-time code validation feature, specifically checking for balanced brackets in the code. You need to ensure that any use of parentheses, curly braces, and square brackets are properly matched and balanced, as this is critical for code correctness and readability. # Task Write a function called `is_valid` that determines if a given string containing just the characters \'(\', \')\', \'{\', \'}\', \'[\' and \']\' is valid. The brackets must close in the correct order. # Requirements * The function should take a single string input: `s` (1 <= len(s) <= 10^4), which consists only of the characters \'(\', \')\', \'{\', \'}\', \'[\' and \']\'. * The function should return `True` if the string is valid, `False` otherwise. # Constraints * An empty string is considered valid. * The function should run efficiently enough to handle the upper constraint on string length. # Example Input and Output ```python assert is_valid(\\"()\\") == True assert is_valid(\\"()[]{}\\") == True assert is_valid(\\"(]\\") == False assert is_valid(\\"([)]\\") == False assert is_valid(\\"{[]}\\") == True assert is_valid(\\"\\") == True assert is_valid(\\"((({{{[[[}}}])))\\") == False ``` # Edge Cases to Consider * An input with only one type of bracket correctly balanced. * An input with an interleaved sequence of different types of brackets. Your function will be tested for both correctness and efficiency using multiple test cases, including edge cases and performance scenarios. # Definition ```python def is_valid(s: str) -> bool: # Your code here ```","solution":"def is_valid(s: str) -> bool: Determines if the given string of brackets is valid. Args: s (str): A string containing just the characters \'(\', \')\', \'{\', \'}\', \'[\' and \']\'. Returns: bool: True if the string is valid, False otherwise. stack = [] mapping = {\')\': \'(\', \'}\': \'{\', \']\': \'[\'} for char in s: if char in mapping: top_element = stack.pop() if stack else \'#\' if mapping[char] != top_element: return False else: stack.append(char) return not stack"},{"question":"You are given a directed graph data structure that supports adding nodes and edges. Using this structure, implement a function to check if there is a **path** between two given nodes in the graph. # Function Signature: ```python def is_path(graph, start_node, end_node): Determine if there is a path between start_node and end_node in the given graph. :param graph: DirectedGraph instance :param start_node: str, name of the start node :param end_node: str, name of the end node :return: bool, True if there is a path, False otherwise ``` # Input: * `graph`: An instance of `DirectedGraph`. * `start_node`: String name of the start node. * `end_node`: String name of the end node. # Output: * `True` if there is a path from `start_node` to `end_node`, `False` otherwise. # Constraints: * Node names are unique in the graph. * Both `start_node` and `end_node` exist in the graph. * There are no restrictions on the number of nodes or edges. # Example: ```python graph_dict = { \\"A\\": [\\"B\\", \\"C\\"], \\"B\\": [\\"C\\", \\"D\\"], \\"C\\": [\\"E\\"], \\"D\\": [], \\"E\\": [\\"B\\"], \\"F\\": [\\"C\\"] } graph = DirectedGraph(graph_dict) print(is_path(graph, \\"A\\", \\"E\\")) # Should return True print(is_path(graph, \\"A\\", \\"F\\")) # Should return False ```","solution":"class DirectedGraph: def __init__(self, graph_dict=None): self.graph_dict = graph_dict if graph_dict else {} def add_node(self, node): if node not in self.graph_dict: self.graph_dict[node] = [] def add_edge(self, from_node, to_node): if from_node in self.graph_dict: self.graph_dict[from_node].append(to_node) else: self.graph_dict[from_node] = [to_node] def is_path(graph, start_node, end_node): Determine if there is a path between start_node and end_node in the given graph. :param graph: DirectedGraph instance :param start_node: str, name of the start node :param end_node: str, name of the end node :return: bool, True if there is a path, False otherwise visited = set() return dfs(graph.graph_dict, start_node, end_node, visited) def dfs(graph_dict, current_node, end_node, visited): if current_node == end_node: return True if current_node in visited: return False visited.add(current_node) for neighbor in graph_dict.get(current_node, []): if dfs(graph_dict, neighbor, end_node, visited): return True return False"},{"question":"You are tasked with designing a data structure that supports a set of operations in average constant time. Specifically, you need to implement a `RandomizedSet` that complies with the following requirements: 1. **Insert**: A method to insert an element into the set if it is not already present. 2. **Remove**: A method to remove an element from the set if it is present. 3. **Get Random Element**: A method to return a random element from the set. Each element should have an equal probability of being returned. # Specifications 1. Define a class `RandomizedSet` with the following methods: - `insert(val: int) -> bool`: Inserts `val` into the set. Returns `True` if the element was successfully inserted (i.e., it was not already present), and `False` otherwise. - `remove(val: int) -> bool`: Removes `val` from the set. Returns `True` if the element was removed (i.e., it was present), and `False` otherwise. - `getRandom() -> int`: Returns a random element from the current set of elements. Each element must have the same probability of being returned. 2. Your implementation should ensure each operation (insert, remove, getRandom) runs in average O(1) time. 3. Consider edge cases like attempting to remove a non-existent element and ensure random retrieval is uniformly distributed across existing elements. # Input/Output Format - **Input**: - For `insert(val: int) -> bool`: An integer `val` to be inserted. - For `remove(val: int) -> bool`: An integer `val` to be removed. - For `getRandom() -> int`: No input. - **Output**: - For `insert(val: int) -> bool`: Boolean indicating whether the element was successfully inserted. - For `remove(val: int) -> bool`: Boolean indicating whether the element was successfully removed. - For `getRandom() -> int`: Random integer from the current set. # Example ```python rs = RandomizedSet() print(rs.insert(1)) # True print(rs.insert(1)) # False print(rs.insert(2)) # True print(rs.remove(1)) # True print(rs.remove(1)) # False print(rs.getRandom()) # 2 (since only 2 is in the set now) ``` # Constraints - The values for insertion are confined within a reasonable integer range. - Ensure your code handles edge cases like duplicate insertions and the deletion of non-existing items efficiently. - Aim for an average time complexity of O(1) for all operations.","solution":"import random class RandomizedSet: def __init__(self): self.val_to_index = {} self.values = [] def insert(self, val: int) -> bool: Inserts a value to the set. Returns true if the set did not already contain the specified element. if val in self.val_to_index: return False self.val_to_index[val] = len(self.values) self.values.append(val) return True def remove(self, val: int) -> bool: Removes a value from the set. Returns true if the set contained the specified element. if val not in self.val_to_index: return False # Move the last element to the spot of the element to delete last_element = self.values[-1] idx_to_remove = self.val_to_index[val] self.values[idx_to_remove] = last_element self.val_to_index[last_element] = idx_to_remove # Remove the last element self.values.pop() del self.val_to_index[val] return True def getRandom(self) -> int: Get a random element from the set. return random.choice(self.values)"},{"question":"# Question You are given an array where each element represents the price of a given stock on a specific day. If you are only permitted to complete at most one transaction (i.e., buy and sell one share of the stock), design an algorithm to find the maximum profit you can achieve. Write a function `max_profit(prices: List[int]) -> int` that takes as input a list of integers `prices` where `prices[i]` is the stock price on day `i´ and returns the maximum profit you can achieve from this transaction. If no profit is possible, return `0`. # Input * `prices` - List of integers where `1 <= len(prices) <= 10^5` and `0 <= prices[i] <= 10^4`. # Output * An integer representing the maximum profit possible. If no profit is possible, return 0. # Constraints * You must buy before you can sell. * Only one transaction is allowed (buy one and sell one share). # Example 1. **Example 1:** * Input: `[7, 1, 5, 3, 6, 4]` * Output: `5` 2. **Example 2:** * Input: `[7, 6, 4, 3, 1]` * Output: `0` # Notes * In example 1, buying on day 2 (price = 1) and selling on day 5 (price = 6) yields maximum profit = 6 - 1 = 5. * In example 2, no transaction is done and the maximum profit is 0.","solution":"def max_profit(prices): Returns the maximum profit from a single buy-sell transaction of stocks. If no profit is possible, returns 0. if not prices: return 0 min_price = float(\'inf\') max_profit = 0 for price in prices: if price < min_price: min_price = price elif price - min_price > max_profit: max_profit = price - min_price return max_profit"},{"question":"You are given an array of integers. You need to write a function that will return a list containing the mode(s) of the array, i.e., the most frequent element(s). If there are multiple values with the same maximum frequency, all such values should be returned in ascending order. Your goal is to demonstrate your understanding of hashmaps (dictionaries), iteration, and sorting. **Input**: - An array of integers, `arr`, where the length of `arr` (1 ≤ len(arr) ≤ 10^5) **Output**: - A list of integers, containing the mode(s) of the array in ascending order. **Constraints**: - The elements of the array will be integers where `-10^5 ≤ arr[i] ≤ 10^5`. - The array will always contain at least one element. # Function Signature ```python def find_modes(arr: list) -> list: ``` Example ```python find_modes([1, 1, 2, 2, 3, 4]) # Should return [1, 2] find_modes([1, 2, 3, 4, 4, 3, 2, 1]) # Should return [1, 2, 3, 4] find_modes([4, 6, 4, 6, 4]) # Should return [4] find_modes([]) # Should return [] ``` # Hints 1. Use a dictionary to count occurrences of each element. 2. Identify the maximum count. 3. Collect all elements which have this count. 4. Return the collected elements sorted in ascending order.","solution":"def find_modes(arr): Returns the mode(s) of the array in ascending order. if not arr: return [] from collections import defaultdict # Dictionary to store the frequency of elements freq = defaultdict(int) # Calculate the frequencies of each element for num in arr: freq[num] += 1 # Determine the maximum frequency max_freq = max(freq.values()) # Collect all elements with the maximum frequency modes = [num for num, count in freq.items() if count == max_freq] # Return the list sorted in ascending order return sorted(modes)"},{"question":"A message containing letters from A-Z is being encoded into numbers using the following mapping: ``` \'A\' -> 1 \'B\' -> 2 ... \'Z\' -> 26 ``` Given an encoded message containing digits, your task is to determine the total number of ways to decode it. For example, Given an encoded message `\\"12\\"`, it could be decoded as `\\"AB\\"` (from 1 and 2) or `\\"L\\"` (from 12). The number of ways to decode `\\"12\\"` is 2. Input - A string `enc_mes` (1 ≤ `|enc_mes|` ≤ 1000), consisting of only digits. Output - An integer representing the number of possible decoding ways. Constraints - The encoded message will not start with \'0\'. - No two consecutive zeros will occur (\'00\' is invalid). Example 1 Input: ``` \\"12\\" ``` Output: ``` 2 ``` Example 2 Input: ``` \\"226\\" ``` Output: ``` 3 ``` Example 3 Input: ``` \\"0\\" ``` Output: ``` 0 ``` Example 4 Input: ``` \\"10\\" ``` Output: ``` 1 ``` Note - For any invalid messages, your function should return 0. Implement the function `num_decodings(enc_mes: str) -> int` to solve this problem.","solution":"def num_decodings(enc_mes: str) -> int: if not enc_mes or enc_mes[0] == \'0\': return 0 n = len(enc_mes) dp = [0] * (n + 1) dp[0] = 1 dp[1] = 1 for i in range(2, n + 1): single_digit = int(enc_mes[i-1:i]) double_digit = int(enc_mes[i-2:i]) if single_digit >= 1: dp[i] += dp[i-1] if 10 <= double_digit <= 26: dp[i] += dp[i-2] return dp[n]"},{"question":"# Question: Enhanced Binary Search Tree Scenario You are tasked with designing an enhanced version of a Binary Search Tree (BST) that not only supports insertion, searching, size computation, and traversal, but also incorporates the ability to delete nodes and efficiently retrieve the (k)-th smallest element in the BST. Objective Implement the following additional methods: 1. `delete(data)`: Deletes a node containing `data` from the BST. 2. `kth_smallest(k)`: Returns the (k)-th smallest element in the BST. Requirements 1. **Delete Method**: * Input: A single integer `data`. * Output: No return value; the tree is modified to remove the node containing `data`. * Operation: Adjust the tree structure to maintain BST properties after deletion. 2. **kth_smallest Method**: * Input: A single integer `k`, where (1 leq k leq text{size of BST}). * Output: The (k)-th smallest element in the BST. * Operation: Efficient retrieval considering the tree structure. Function Signatures ```python def delete(self, data): # Your implementation here def kth_smallest(self, k): # Your implementation here ``` Constraints * The BST will not contain duplicate elements. * The value of `k` will always be valid within the range. Testing Provide a robust set of unit tests to validate the implementation, similar to the ones provided for the existing insert, search, and size methods. Your tests should cover various scenarios, including edge cases like deleting leaf nodes, deleting nodes with one child, deleting nodes with two children, as well as querying the smallest and largest elements. # Example Given the BST: ``` 10 / 6 15 / / 4 9 12 24 / / 7 20 30 / 18 ``` * `delete(15)` should result in the tree being modified to: ``` 10 / 6 18 / / 4 9 12 24 / / 7 20 30 ``` * `kth_smallest(3)` should return `7`.","solution":"class Node: def __init__(self, key): self.left = None self.right = None self.val = key self.size = 1 # size of the subtree rooted with this node class BinarySearchTree: def __init__(self): self.root = None def insert(self, key): if not self.root: self.root = Node(key) else: self._insert(self.root, key) def _insert(self, root, key): if key < root.val: if root.left: self._insert(root.left, key) else: root.left = Node(key) else: if root.right: self._insert(root.right, key) else: root.right = Node(key) root.size = 1 + (root.left.size if root.left else 0) + (root.right.size if root.right else 0) def delete(self, data): self.root = self._delete(self.root, data) def _delete(self, root, key): if not root: return root if key < root.val: root.left = self._delete(root.left, key) elif key > root.val: root.right = self._delete(root.right, key) else: if not root.left: return root.right elif not root.right: return root.left temp_val = self._min_value_node(root.right) root.val = temp_val.val root.right = self._delete(root.right, temp_val.val) root.size = 1 + (root.left.size if root.left else 0) + (root.right.size if root.right else 0) return root def _min_value_node(self, node): current = node while current.left: current = current.left return current def kth_smallest(self, k): return self._kth_smallest(self.root, k).val def _kth_smallest(self, root, k): left_size = root.left.size if root.left else 0 if k <= left_size: return self._kth_smallest(root.left, k) elif k == left_size + 1: return root else: return self._kth_smallest(root.right, k - left_size - 1) def inorder(self): result = [] self._inorder(self.root, result) return result def _inorder(self, root, result): if root: self._inorder(root.left, result) result.append(root.val) self._inorder(root.right, result)"},{"question":"# Question You are provided with the implementation of the Misra-Gries algorithm, which helps in finding frequent items in a list that appear at least `n/k` times. # Task Your task is to extend the functionality of this algorithm to handle additional scenarios and edge cases more efficiently. # Requirements 1. **Implement** the function `misras_gries_advanced(array, k=2)` that handles all edge cases and optimizes the existing algorithm. 2. **Input**: - `array` (list of integers) – List of integers where the frequency of items needs to be determined. - `k` (integer) – A threshold parameter. 3. **Output**: - A dictionary mapping of items to their frequencies, where each item appears at least `n/k` times. Return `None` if no such items are found. 4. **Constraints**: - `k` should be a positive integer greater than 1. - The `array` may contain negative numbers but will not contain non-integer values. # Testing the Extended Function Test your implementation with the following cases: 1. `misras_gries_advanced([1, 4, 4, 4, 5, 4, 4])` should return `{\'4\': 5}` 2. `misras_gries_advanced([0, 0, 0, 1, 1, 1, 1])` should return `{\'1\': 4}` 3. `misras_gries_advanced([0, 0, 0, 0, 1, 1, 1, 2, 2], 3)` should return `{\'0\': 4, \'1\': 3}` 4. `misras_gries_advanced([0, 0, 0, 1, 1, 1])` should return `None` 5. Add edge case tests such as: - An empty list. - A list with unique elements. - Invalid values of `k`. # Performance Requirements * Your implementation should maintain the time complexity of O(n) and should aim for the space complexity of O(k).","solution":"def misras_gries_advanced(array, k=2): if not isinstance(k, int) or k <= 1: raise ValueError(\\"The value of k must be a positive integer greater than 1.\\") n = len(array) if n == 0: return None # Step 1: Identify potential candidates using Misra-Gries algorithm candidates = {} for num in array: if num in candidates: candidates[num] += 1 elif len(candidates) < k - 1: candidates[num] = 1 else: for key in list(candidates.keys()): candidates[key] -= 1 if candidates[key] == 0: del candidates[key] # Step 2: Verify the actual frequencies of the candidates verified_candidates = {} for num in array: if num in candidates: if num in verified_candidates: verified_candidates[num] += 1 else: verified_candidates[num] = 1 # Filter out the elements that do not meet the frequency criteria result = {key: count for key, count in verified_candidates.items() if count >= n // k} return result if result else None"},{"question":"# Trie Implementation **Context:** You\'ve been assigned the task of implementing a Trie data structure for a team working on an autocomplete and spell-checker feature for a large text editor. Efficiently managing storage and retrieval of strings is paramount to the product\'s performance. **Task:** Implement a `Trie` class with the following methods: * `insert(word: str) -> None`: Inserts a word into the trie. * `search(word: str) -> bool`: Returns `True` if the word is in the trie, `False` otherwise. * `starts_with(prefix: str) -> bool`: Returns `True` if there is any word in the trie that starts with the given prefix, `False` otherwise. **Requirements:** - You may assume that all inputs consist of lowercase letters \'a\' to \'z\' only. - Your solution should handle edge cases such as insertion/searching of empty strings. - Aim for optimal space usage while maintaining efficient time complexity. **Input/Output Example:** Example 1: ```python trie = Trie() trie.insert(\\"apple\\") trie.search(\\"apple\\") # returns True trie.search(\\"app\\") # returns False trie.starts_with(\\"app\\") # returns True trie.insert(\\"app\\") trie.search(\\"app\\") # returns True ``` Example 2: ```python trie = Trie() trie.insert(\\"\\") trie.search(\\"\\") # returns True trie.starts_with(\\"\\") # returns True ``` **Constraints:** - Words can have a length between 0 and 100. - The total number of words inserted can be up to 10000. **Performance:** Ensure that your implementation is optimized to handle large inputs within the given constraints.","solution":"class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False class Trie: def __init__(self): self.root = TrieNode() def insert(self, word: str) -> None: node = self.root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.is_end_of_word = True def search(self, word: str) -> bool: node = self.root for char in word: if char not in node.children: return False node = node.children[char] return node.is_end_of_word def starts_with(self, prefix: str) -> bool: node = self.root for char in prefix: if char not in node.children: return False node = node.children[char] return True"},{"question":"You are given an array of integers and two types of operations that you can perform on it: 1. Compute the sum of the first `i` elements. 2. Update the value of a specified element in the array. Your task is to implement a `Fenwick Tree` (Binary Indexed Tree) class that supports these operations efficiently. The operations should be performed in logarithmic time complexity. # Function Signatures Implement the following methods in the `Fenwick_Tree` class: 1. **`__init__(self, array: List[int]) -> None`** * Constructor to initialize the tree with the given array. 2. **`query(self, i: int) -> int`** * Returns the sum of the first `i` elements of the array. * Input: `i` (0-based index) * Output: sum of elements from `0` to `i` 3. **`update(self, i: int, value: int) -> None`** * Updates the value of the element at the specified index `i` to `value`. * Input: `i` (0-based index), `value` (new value to be set at index `i`) # Input/Output - **Input**: The constructor will take a list of integers. - Example: `fenwick_tree = Fenwick_Tree([1, 7, 3, 0, 7, 8, 3, 2, 6, 2])` - **Output**: 1. `query(i: int) -> int`: Returns the sum of the first `i` elements. - Example: `fenwick_tree.query(4)` should return `1 + 7 + 3 + 0 + 7 = 18` 2. `update(i: int, value: int) -> None`: Updates the element at index `i` to `value`. - Example: After `fenwick_tree.update(3, 9)`, the array should be updated to `[1, 7, 3, 9, 7, 8, 3, 2, 6, 2]` # Constraints - You can assume the array length will not exceed 10^5. - Each element in the array is an integer in the range of -10^9 to 10^9. # Example: ```python fenwick_tree = Fenwick_Tree([1, 7, 3, 0, 7, 8, 3, 2, 6, 2]) # Query the first 5 elements print(fenwick_tree.query(4)) # Output: 18 # Update the 4th element to 9 fenwick_tree.update(3, 9) # Query the first 5 elements again print(fenwick_tree.query(4)) # Output: 27 ``` Implement the `Fenwick_Tree` class with the described methods.","solution":"class Fenwick_Tree: def __init__(self, array): Initializes the Fenwick Tree with the given array. self.n = len(array) self.tree = [0] * (self.n + 1) self.array = array[:] for idx in range(self.n): self.add(idx + 1, self.array[idx]) def add(self, idx, value): Helper function to update the Fenwick Tree at a specified index with the given value. while idx <= self.n: self.tree[idx] += value idx += idx & -idx def query(self, i): Returns the sum of the first i elements (0-based index). i += 1 # converting to 1-based index total = 0 while i > 0: total += self.tree[i] i -= i & -i return total def update(self, i, value): Updates the value of the element at the specified index i to value. i += 1 # converting to 1-based index diff = value - self.array[i - 1] self.array[i - 1] = value while i <= self.n: self.tree[i] += diff i += i & -i"},{"question":"# Context: In a given stack, we need to ensure that every element is duplicated exactly once while retaining the original order of elements. Implement the function that achieves this with a given stack using either an auxiliary stack or queue. # Task: Write a function named `optimalStutter` that takes a stack (represented as a Python list where the last element is the top of the stack) and duplicates each element in the stack. # Function Signature: ```python def optimalStutter(stack: list) -> list: ``` # Input: - A list of integers representing the stack. # Output: - The modified stack where each element occurs twice in the same order as they appeared initially. # Constraints: - The input stack can have a maximum size of 1000 elements. - The function should return a list which is the stack after the stutter operation. # Performance Requirements: - Your solution should have a linear time complexity, O(n), where n is the number of elements in the stack. - The space complexity should reasonably use auxiliary storage but strive for optimal usage. # Example: Input: ```python stack = [3, 7, 1, 14, 9] ``` Output: ```python [3, 3, 7, 7, 1, 1, 14, 14, 9, 9] ``` Implementation Note: The function should handle an empty stack gracefully and return an empty list. Additionally, it should work correctly for stacks with a single element or very large elements up to the defined limits. # Hint: Think about how you can leverage a queue or another stack to get the job done efficiently while maintaining the order.","solution":"def optimalStutter(stack: list) -> list: This function duplicates each element in the stack and retains the original order. # Initialize an auxiliary stack to perform the stutter operation aux_stack = [] # Process each element in the original stack and push it twice to the auxiliary stack while stack: element = stack.pop() aux_stack.append(element) aux_stack.append(element) # Restore the original order back to the stack from auxiliary stack while aux_stack: stack.append(aux_stack.pop()) return stack"},{"question":"# Question: Advanced Graph Traversal Analysis You are given a social network graph where nodes represent users, and edges represent friendships between users. Your task is to analyze the structure of the social network by utilizing the given depth first search (DFS) and breadth first search (BFS) traversal algorithms. # Scenario: As a data scientist at a social media company, you need to perform network analysis to identify various user clusters and ensure connectivity within the platform. Using both DFS and BFS, write functions to determine the number of distinct clusters (connected components) in the graph and verify the connectivity from an arbitrary starting user. # Task: 1. Implement a function `count_clusters(graph)` that counts the number of distinct user clusters within the social network. 2. Write a function `check_connectivity(graph, start)` that verifies if all users can be reached starting from a given user using both DFS and BFS. # Input Specification: - `graph` is represented as a dictionary where keys are user IDs, and values are lists of friends (user IDs). - `start` is an integer representing the starting user ID. # Output Specification: 1. `count_clusters(graph)` should return an integer representing the number of distinct clusters. 2. `check_connectivity(graph, start)` should return a tuple of two boolean values, where the first boolean indicates connectivity using DFS and the second indicates connectivity using BFS. # Example: ```python # Example graph social_network = { 1: [2, 3], 2: [1, 4], 3: [1], 4: [2], 5: [6], 6: [5] } # Example usage print(count_clusters(social_network)) # Output: 2 (two clusters: {1,2,3,4} and {5,6}) print(check_connectivity(social_network, 1)) # Output: (True, True) all users can be reached from user 1 within the first cluster print(check_connectivity(social_network, 5)) # Output: (True, True) all users can be reached from user 5 within the second cluster ``` # Constraints: - The graph is undirected. - Assume that the graph input is always valid (i.e., user IDs are unique and properly connected).","solution":"def count_clusters(graph): Counts the number of distinct user clusters (connected components) in the graph. visited = set() cluster_count = 0 def dfs(node): stack = [node] while stack: u = stack.pop() for v in graph[u]: if v not in visited: visited.add(v) stack.append(v) for node in graph: if node not in visited: cluster_count += 1 visited.add(node) dfs(node) return cluster_count def check_connectivity(graph, start): Verifies if all users can be reached starting from the given user using both DFS and BFS. Returns a tuple of two boolean values. def dfs(): visited = set() stack = [start] while stack: node = stack.pop() if node not in visited: visited.add(node) for neighbor in graph[node]: if neighbor not in visited: stack.append(neighbor) return visited def bfs(): visited = set() queue = [start] while queue: node = queue.pop(0) if node not in visited: visited.add(node) for neighbor in graph[node]: if neighbor not in visited: queue.append(neighbor) return visited dfs_result = dfs() bfs_result = bfs() return (len(dfs_result) == len(graph), len(bfs_result) == len(graph))"},{"question":"# Single Source Shortest Path with Negative Weights **Scenario**: You are tasked with developing a transportation system which must handle varying travel times, including potential delays (represented as positive weights) and potential time-saving shortcuts (represented as negative weights). However, any cycle of time-saving shortcuts leading to unrealistic negative travel is undesirable. **Task**: Implement the Bellman-Ford algorithm to determine if the given transportation graph contains any negative-weight cycle reachable from the source node. If there is a negative-weight cycle, the result should indicate that no valid shortest-path solution exists. **Function Signature**: ```python def detect_negative_cycle(graph: Dict[str, Dict[str, int]], source: str) -> bool: ``` **Input Format**: - `graph`: A dictionary representing a directed weighted graph where keys are node identifiers and values are dictionaries of adjacent nodes with edge weights. - `source`: A string representing the source node. **Output Format**: - Return `True` if no negative-weight cycle is detected, otherwise return `False`. **Constraints**: - The graph will contain a maximum of 100 nodes. - Edge weights can be negative. **Example**: ```python graph = { \'a\': {\'b\': 6, \'e\': 7}, \'b\': {\'c\': 5, \'d\': -4, \'e\': 8}, \'c\': {\'b\': -2}, \'d\': {\'a\': 2, \'c\': 7}, \'e\': {\'b\': -3} } source = \'a\' print(detect_negative_cycle(graph, source)) # Expected output: True graph = { \'a\': {\'b\': 1}, \'b\': {\'c\': -1}, \'c\': {\'a\': -1} } source = \'a\' print(detect_negative_cycle(graph, source)) # Expected output: False ``` **Explanation**: 1. In the first example, the algorithm correctly identifies that there is no negative-weight cycle reachable from the source, \'a\'. 2. In the second example, the algorithm identifies the negative-weight cycle b -> c -> a -> b as reachable from the source, \'a\', thus returning False.","solution":"def detect_negative_cycle(graph, source): Determines if the given transportation graph contains any negative-weight cycle reachable from the source node. Args: graph (dict): A dictionary representing a directed weighted graph where keys are node identifiers and values are dictionaries of adjacent nodes with edge weights. source (str): A string representing the source node. Returns: bool: True if no negative-weight cycle is detected, otherwise False. # Initialize the distance to all nodes as infinity and to source as 0 distances = {node: float(\'inf\') for node in graph} distances[source] = 0 # Bellman-Ford algorithm step 1: relax edges up to |V|-1 times for _ in range(len(graph) - 1): for u in graph: for v in graph[u]: if distances[u] + graph[u][v] < distances[v]: distances[v] = distances[u] + graph[u][v] # Bellman-Ford algorithm step 2: check for negative-weight cycles for u in graph: for v in graph[u]: if distances[u] + graph[u][v] < distances[v]: return False # Negative-weight cycle found return True # No negative-weight cycle found"},{"question":"Context You have recently learned about various sorting algorithms and their applications. One of the more obscure and inefficient sorting algorithms is Stooge Sort. It sorts an array recursively by sorting overlapping subarrays. Task Write a function `stooge_sort(arr: List[int]) -> List[int]` that takes a list of integers and sorts it using the Stooge Sort algorithm. Input - A list of integers, `arr`, where 1 <= len(arr) <= 1000. - No constraints on the values of the integers themselves (they can be positive, negative, or zero). Output - A list of integers sorted in non-decreasing order. Function Signature ```python from typing import List def stooge_sort(arr: List[int]) -> List[int]: pass ``` Example ```python assert stooge_sort([1, 64, 3, 5, 7, 8]) == [1, 3, 5, 7, 8, 64] assert stooge_sort([5, 4, 3, 2, 1]) == [1, 2, 3, 4, 5] assert stooge_sort([12, -3, 45, 0, 10]) == [-3, 0, 10, 12, 45] ``` Constraints and Limits - **Performance Requirement**: Although Stooge Sort itself is inefficient, your implementation should not exceed a reasonable stack recursion limit imposed by Python. - Consider edge cases, such as already sorted arrays and arrays of length one.","solution":"from typing import List def stooge_sort(arr: List[int]) -> List[int]: def stooge_sort_rec(arr: List[int], l: int, h: int): if l >= h: return # Swap if the first element is larger than the last element if arr[l] > arr[h]: arr[l], arr[h] = arr[h], arr[l] # If there are more than 2 elements in the array if h - l + 1 > 2: t = (h - l + 1) // 3 stooge_sort_rec(arr, l, h - t) stooge_sort_rec(arr, l + t, h) stooge_sort_rec(arr, l, h - t) stooge_sort_rec(arr, 0, len(arr) - 1) return arr"},{"question":"# Question: Find the k-th Smallest Element in a Binary Search Tree Given a binary search tree (BST), implement an efficient algorithm to find the k-th smallest element in it. Input * `root`: The root node of the binary search tree. * `k`: An integer representing the position (1-indexed) of the smallest element you want to find in the BST. Output * An integer which is the k-th smallest element in the BST. Constraints * The binary search tree can have up to (10^4) nodes. * 1 ≤ k ≤ Number of nodes in the tree. Example ```python # Example Tree: # 8 # / # 3 10 # / # 1 6 14 # / / # 4 7 13 # Input n1 = Node(8) n2 = Node(3) n3 = Node(10) n4 = Node(1) n5 = Node(6) n6 = Node(14) n7 = Node(4) n8 = Node(7) n9 = Node(13) n1.left, n1.right = n2, n3 n2.left, n2.right = n4, n5 n3.right = n6 n5.left, n5.right = n7, n8 n6.left = n9 print(kth_smallest(n1, 3)) # Output should be 4 class Solution: def kth_smallest(self, root, k): # To be implemented; should also return 4 ``` Requirements 1. Provide both an **iterative** and a **recursive** approach. 2. Your solution should handle edge cases robustly. Performance Requirements 1. Time complexity should be nearly the same as O(k) for balanced trees. 2. Space complexity should ideally be O(h) where h is the tree height, mitigated for large h in an iterative solution.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def kth_smallest_recursive(root, k): Find kth smallest element in BST using recursion. def inorderTraversal(node): if not node: return [] return inorderTraversal(node.left) + [node.val] + inorderTraversal(node.right) return inorderTraversal(root)[k-1] def kth_smallest_iterative(root, k): Find kth smallest element in BST using iteration. stack = [] while True: while root: stack.append(root) root = root.left root = stack.pop() k -= 1 if k == 0: return root.val root = root.right"},{"question":"# Coding Challenge You are given an array of integers that needs to be sorted in ascending order. Implement a function `optimized_quick_sort` that sorts the array using the Quick Sort algorithm. Your implementation should include: - The core quick sort mechanism. - A pivot selection strategy to improve average-case performance (e.g., median-of-three). - Tail call optimization to handle the recursion depth more efficiently. - An optional parameter to switch simulation on/off, which prints the array\'s state at each iteration. Function Signature ```python def optimized_quick_sort(arr: List[int], simulation: bool = False) -> List[int]: ``` Input - `arr`: A list of integers to be sorted. - `simulation`: A boolean flag (default is False). If set to True, the function should print the state of the array at each iteration. Output - A sorted list of integers in ascending order. Constraints - Ensure your solution handles arrays with length from 0 to 10^5. - Optimize to minimize performance bottlenecks and handle recursion effectively. Performance Requirements - Your implementation should aim for an average-case time complexity of O(n log(n)) and should minimize space usage to O(log(n)) due to the recursive nature. Example ```python input_array = [10, 7, 8, 9, 1, 5] # Invoking the function with simulation turned off sorted_array = optimized_quick_sort(input_array) print(sorted_array) # Output should be [1, 5, 7, 8, 9, 10] # Invoking the function with simulation turned on optimized_quick_sort(input_array, simulation=True) # Example output: # iteration 0 : 10 7 8 9 1 5 # iteration 1 : 1 5 7 8 9 10 ``` You can utilize the `quick_sort` snippet provided for reference but your implementation should improve upon it using the guidelines given above.","solution":"from typing import List def median_of_three(arr, low, high): mid = (low + high) // 2 pivot_candidates = [(arr[low], low), (arr[mid], mid), (arr[high], high)] pivot_candidates.sort() return pivot_candidates[1][1] def partition(arr, low, high): pivot_index = median_of_three(arr, low, high) arr[high], arr[pivot_index] = arr[pivot_index], arr[high] pivot = arr[high] i = low - 1 for j in range(low, high): if arr[j] < pivot: i += 1 arr[i], arr[j] = arr[j], arr[i] arr[i+1], arr[high] = arr[high], arr[i+1] return i+1 def quick_sort_helper(arr, low, high, simulation, depth=0): while low < high: p = partition(arr, low, high) # Perform tail recursion if simulation: print(f\\"Iteration at depth {depth}: {arr}\\") if p - low < high - p: quick_sort_helper(arr, low, p - 1, simulation, depth + 1) low = p + 1 else: quick_sort_helper(arr, p + 1, high, simulation, depth + 1) high = p - 1 def optimized_quick_sort(arr: List[int], simulation: bool = False) -> List[int]: if not arr: return arr quick_sort_helper(arr, 0, len(arr) - 1, simulation) return arr"},{"question":"# Question: Reconstructing a Full Binary Tree from Preorder and Postorder Traversals **Context**: You are a software engineer tasked with restoring the original structure of a full binary tree from given traversal data. You\'ve been provided two sequences that represent the preorder and postorder traversals of the tree. Your job is to reconstruct the tree and output its inorder traversal. **Objective**: Write a Python function to reconstruct the full binary tree from its preorder and postorder traversal lists and return the inorder traversal of the tree. **Function Signature**: ```python def reconstruct_inorder(preorder: list, postorder: list) -> list: pass ``` **Input**: - `preorder`: A list of integers representing the preorder traversal of the tree. (1 <= len(preorder) <= 1000) - `postorder`: A list of integers representing the postorder traversal of the tree. (1 <= len(postorder) <= 1000) **Output**: - A list of integers representing the inorder traversal of the reconstructed tree. **Constraints**: - It is guaranteed that the provided `preorder` and `postorder` lists represent a full binary tree. - The elements in the input lists are distinct integers. **Example**: ```python preorder = [1, 2, 4, 5, 3, 6, 7] postorder = [4, 5, 2, 6, 7, 3, 1] print(reconstruct_inorder(preorder, postorder)) # Output: [4, 2, 5, 1, 6, 3, 7] ``` **Notes**: - Focus on implementing an optimal solution considering time complexity. - Ensure your solution handles edge cases, such as a minimal tree with a single node. - Do not assume the input to be valid only; validate the sequences as per the rules of a full binary tree. Good luck!","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def buildTree(preorder, postorder): if not preorder or not postorder: return None root_val = preorder.pop(0) root = TreeNode(root_val) if preorder: left_root_val = preorder[0] left_subtree_size = postorder.index(left_root_val) + 1 root.left = buildTree(preorder[:left_subtree_size], postorder[:left_subtree_size]) root.right = buildTree(preorder[left_subtree_size:], postorder[left_subtree_size:-1]) return root def inorderTraversal(root): if root is None: return [] return inorderTraversal(root.left) + [root.val] + inorderTraversal(root.right) def reconstruct_inorder(preorder, postorder): root = buildTree(preorder, postorder) return inorderTraversal(root)"},{"question":"# Question: Implement a Path Joiner In many applications, you need a robust way to join path segments together, making sure there are no redundant slashes and leading/trailing white spaces are handled properly. Implement the function `join_with_slash(base, suffix)` that: 1. Takes two strings: - `base`: The base part of the path. - `suffix`: The suffix part to be appended. 2. Returns a combined path with a single forward slash (/) separating `base` and `suffix`, ensuring: - No redundant slashes. - Trimming of leading slashes from `suffix`. - No trailing white spaces in the combined path. # Input - `base` (str): A non-empty string representing the base path. - `suffix` (str): A non-empty string representing the suffix path to be appended. # Output - (str): A string representing the correctly joined path. # Constraints - Both `base` and `suffix` are strings containing alphanumeric characters, forward slashes, and possibly white spaces. - The resulting path should not have redundant slashes. # Example ```python # Example 1 base = \\"http://algorithms.com\\" suffix = \\"part\\" print(join_with_slash(base, suffix)) # Output: \\"http://algorithms.com/part\\" # Example 2 base = \\"/path/to/dir/\\" suffix = \\"/file\\" print(join_with_slash(base, suffix)) # Output: \\"/path/to/dir/file\\" # Example 3 base = \\"base/\\" suffix = \\"/subdir\\" print(join_with_slash(base, suffix)) # Output: \\"base/subdir\\" ``` # Instructions - Ensure the function handles edge cases where slashes are present at either or both ends of the inputs. - The function should also handle any trailing white spaces in `suffix`. - Do not use any library functions specifically for URL or path joining (like `os.path.join` or `urllib.parse.urljoin`).","solution":"def join_with_slash(base, suffix): Joins a base and suffix path with a single forward slash ensuring no redundant slashes and trims any leading slashes from the suffix. Returns the correctly joined path. :param base: str, non-empty base part of the path. :param suffix: str, non-empty suffix part to be appended. :return: str, correctly joined path. # Strip any leading and trailing whitespace from suffix suffix = suffix.strip() # Remove leading slash from suffix if present if suffix.startswith(\\"/\\"): suffix = suffix[1:] # Ensure base does not end with a slash if base.endswith(\\"/\\"): base = base.rstrip(\\"/\\") return f\\"{base}/{suffix}\\""},{"question":"Implement MST using Kruskal\'s Algorithm with Disjoint Set Optimization Context You are a software engineer at a networking company, and you need to design a system that finds the minimum cost path to connect all the data centers in a given network. The network is represented as an undirected graph, with the data centers as nodes and the connections between them as weighted edges. Task Implement the Kruskal\'s Minimum Spanning Tree (MST) algorithm using a Disjoint Set data structure to optimize the connection of data centers with minimum cost. Function Signature ```python def kruskal_mst(vertex_count: int, edges: List[Tuple[int, int, int]]) -> int: :param vertex_count: An integer representing the number of data centers. :param edges: A list of tuples, where each tuple contains three integers (source, target, weight). Each tuple represents a weighted edge between two nodes (data centers). :return: An integer representing the sum of the weights of the edges in the MST. ``` Input 1. `vertex_count`: An integer `V`, where `V` is the number of vertices in the graph (data centers). 2. `edges`: A list of tuples `[(u1, v1, w1), (u2, v2, w2), ...]` representing the edges, where each tuple `(u, v, w)` means an edge between `u` and `v` with weight `w`. Output Return an integer representing the sum of the weights of the edges in the Minimum Spanning Tree (MST). Constraints * `1 <= vertex_count <= 1000` * `0 <= len(edges) <= 100000` * Weights of edges (w) will be integers such that `1 <= w <= 10000` * The graph may contain multiple edges between the same vertices. Performance Requirements * The algorithm should handle up to 100000 edges efficiently within reasonable time limits. Examples Example 1: ```python vertex_count = 4 edges = [(0, 1, 10), (0, 2, 6), (0, 3, 5), (1, 3, 15), (2, 3, 4)] print(kruskal_mst(vertex_count, edges)) # Output should be 19 ``` Example 2: ```python vertex_count = 3 edges = [(0, 1, 3), (1, 2, 1), (0, 2, 3)] print(kruskal_mst(vertex_count, edges)) # Output should be 4 ``` Notes * Vertices are zero-indexed. * Ensure to implement the Disjoint Set data structure with path compression and union by rank to optimize performance. * Consider edge cases such as disconnected graphs. Good luck and Happy Coding!","solution":"class DisjointSet: def __init__(self, vertex_count): self.parent = list(range(vertex_count)) self.rank = [0] * vertex_count def find(self, u): if self.parent[u] != u: self.parent[u] = self.find(self.parent[u]) # Path compression return self.parent[u] def union(self, u, v): root_u = self.find(u) root_v = self.find(v) if root_u != root_v: # Union by rank if self.rank[root_u] > self.rank[root_v]: self.parent[root_v] = root_u elif self.rank[root_u] < self.rank[root_v]: self.parent[root_u] = root_v else: self.parent[root_v] = root_u self.rank[root_u] += 1 def kruskal_mst(vertex_count, edges): :param vertex_count: An integer representing the number of data centers. :param edges: A list of tuples, where each tuple contains three integers (source, target, weight). Each tuple represents a weighted edge between two nodes (data centers). :return: An integer representing the sum of the weights of the edges in the MST. # Sort edges based on their weight edges.sort(key=lambda edge: edge[2]) # Initialize the disjoint set ds = DisjointSet(vertex_count) mst_weight = 0 mst_edges = 0 for u, v, weight in edges: if ds.find(u) != ds.find(v): ds.union(u, v) mst_weight += weight mst_edges += 1 # if we have selected vertex_count - 1 edges, we have a complete MST if mst_edges == vertex_count - 1: break # If the number of edges in MST is less than vertex_count - 1, it means it\'s a disconnected graph. if mst_edges != vertex_count - 1: raise ValueError(\\"Graph is not connected\\") return mst_weight"},{"question":"# Zigzag Level Order Traversal **Context**: You are working as a software engineer on a tree data visualization application. Your task is to implement a function that returns the zigzag level order traversal of a binary tree to help users visualize the tree\'s structure more intuitively. **Problem Statement**: Given the root node of a binary tree, write a function `zigzag_level(root)` that performs a zigzag level order traversal of its nodes\' values. # Input - `root`: The root node of a binary tree. Each node contains an integer value and pointers to its left and right children. # Output - A list of lists: Each sublist contains the integers of a single level in the zigzag traversal order. # Example Given binary tree [3, 9, 20, null, null, 15, 7]: ``` 3 / 9 20 / 15 7 ``` The function `zigzag_level(root)` should return: ``` [ [3], [20, 9], [15, 7] ] ``` # Constraints - The number of nodes in the binary tree will be in the range `[0, 2000]`. - Node values will be integer values `-100 ≤ Node.val ≤ 100`. # Requirements - **Complexity**: The solution should have a time complexity of O(n) and a space complexity of O(w), where n is the number of nodes and w is the maximum width of the binary tree. - **Edge Cases**: The function should handle cases where the tree is empty, contains one node, or is highly unbalanced. # Function Signature ```python def zigzag_level(root) -> List[List[int]]: pass ```","solution":"from typing import List, Optional class TreeNode: def __init__(self, val: int, left: \'TreeNode\' = None, right: \'TreeNode\' = None): self.val = val self.left = left self.right = right def zigzag_level(root: Optional[TreeNode]) -> List[List[int]]: if not root: return [] result = [] current_level = [root] left_to_right = True while current_level: level_values = [node.val for node in current_level] if not left_to_right: level_values.reverse() result.append(level_values) next_level = [] for node in current_level: if node.left: next_level.append(node.left) if node.right: next_level.append(node.right) current_level = next_level left_to_right = not left_to_right return result"},{"question":"# Question Design a modified version of the `OrderedStack` class that supports a `sort()` method. This method will ensure that all elements within the stack are in ascending order from bottom to top without using auxiliary data structures (i.e., you cannot use additional stacks or lists but may only rearrange the existing elements within the same stack instance). Instructions 1. Implement the `sort()` method in the `OrderedStack` class. 2. The existing stack methods must remain functional after the sorting operation. # Expected Method Signature ```python def sort(self): # Your code here ``` # Input and Output * The stack may contain any number of elements before calling `sort()`. * After calling `sort()`, elements within the stack should be ordered such that the smallest element is at the bottom of the stack, and the largest is at the top. # Constraints * Do not use any additional lists, stacks, or other data structures. * The existing public interface of the `OrderedStack` class should not be modified except for adding the `sort()` method. # Example Assume you have the following operations: ```python stack = OrderedStack() stack.push(5) stack.push(1) stack.push(3) stack.sort() ``` After calling `sort()`, the stack\'s elements should be ordered as [1, 3, 5] (from bottom to top). Important Note Ensure that the `sort()` method correctly handles empty stacks and stacks with a single element without raising errors.","solution":"class OrderedStack: def __init__(self): self.stack = [] def push(self, item): self.stack.append(item) def pop(self): if not self.stack: return None return self.stack.pop() def peek(self): if not self.stack: return None return self.stack[-1] def is_empty(self): return len(self.stack) == 0 def sort(self): if self.is_empty(): return # Helper function to insert an element in sorted order def sorted_insert(value): if self.is_empty() or value > self.peek(): self.push(value) else: temp = self.pop() sorted_insert(value) self.push(temp) # Sort the stack using recursive sorted_insert if not self.is_empty(): value = self.pop() self.sort() sorted_insert(value)"},{"question":"# Linked List Rotation Challenge **Objective**: Implement a function that rotates a singly linked list to the right by a given number of positions and returns the modified list. **Function Signature**: ```python def rotate_right(head, k): :type head: ListNode :type k: int :rtype: ListNode ``` # Instructions 1. The function `rotate_right` should take in: - `head`: the head node of a singly linked list, where each node is an instance of the class `ListNode`. - `k`: a non-negative integer representing the number of positions to rotate the list to the right. 2. The function should return the head of the newly rotated linked list. # Constraints: 1. `k` can be zero, and the list should remain unchanged. 2. If the linked list is empty or contains only one node, return it as is. 3. If `k` is greater than the length of the list, the function should still perform the rotations as expected (handle using modulo operation). # Requirements: - Time complexity should be O(N), where N is the number of nodes in the list. - Space complexity should be O(1). # Example: Given a linked list: `1 -> 2 -> 3 -> 4 -> 5` and `k = 2`, the output should be: `4 -> 5 -> 1 -> 2 -> 3`. # Additional Notes: - Properly handle edge cases: 1. `k = 0` 2. `head = None` 3. `head` consisting of a single node - Ensure to break the cycle made while rotating the list into a proper linked list. - Consider the efficiency and correctness of your implementation. **Reference Implementation**: Reference the problem statement\'s provided code for a clear understanding of the function requirements and the ListNode class structure. Happy Coding!","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def rotate_right(head, k): if not head or k == 0: return head # Calculate the length of the linked list length = 1 tail = head while tail.next: tail = tail.next length += 1 # Make the linked list circular tail.next = head # Find the new tail, which is (length - k % length - 1) nodes from the head steps_to_new_tail = length - k % length - 1 new_tail = head for _ in range(steps_to_new_tail): new_tail = new_tail.next # The new head is the node after the new tail new_head = new_tail.next # Break the circle new_tail.next = None return new_head"},{"question":"# Coding Challenge: Advanced GCD and Binary Algorithms Scenario: Your task is to implement a combined function to compute both the Greatest Common Divisor (GCD) and the Least Common Multiple (LCM) of two non-negative integers using efficient algorithms. Additionally, provide a function to count the trailing zeros in the binary representation of a number and use it to implement an optimized GCD calculation using bitwise operations. Function Definitions: 1. **gcd_bitwise(a, b)**: - Compute the GCD of `a` and `b` using bitwise operations. - Inputs: two non-negative integers `a` and `b` - Output: an integer representing the GCD of `a` and `b` 2. **lcm(a, b)**: - Compute the LCM of `a` and `b`. - Use the calculated GCD from the `gcd_bitwise` to compute the LCM. - Inputs: two non-negative integers `a` and `b` - Output: an integer representing the LCM of `a` and `b` 3. **trailing_zero_count(x)**: - Compute the number of trailing zeros in the binary representation of `x`. - Input: a non-negative integer `x` - Output: an integer representing the number of trailing zeros Requirements: * Implement all three functions. * Ensure that all edge cases and performance considerations are addressed. * Constraints: - (0 leq a, b, x leq 10^9) * Note: Do not use direct division or multiplication in `gcd_bitwise`. Example: ```python # Function Calls: print(gcd_bitwise(40, 60)) # Output: 20 print(lcm(40, 60)) # Output: 120 print(trailing_zero_count(40)) # Output: 3 # Explanation: # GCD(40, 60) = 20 # LCM(40, 60) = (40 * 60) / GCD(40, 60) = 120 # Trailing Zero Count of 40 (binary 101000) is 3 ```","solution":"def trailing_zero_count(x): Calculate the number of trailing zeros in the binary representation of x. if x == 0: return 32 # Assuming 32-bit integer for zero handling count = 0 while (x & 1) == 0: x >>= 1 count += 1 return count def gcd_bitwise(a, b): Calculate the GCD of a and b using bitwise operations. if a == 0: return b if b == 0: return a shift = trailing_zero_count(a | b) a >>= trailing_zero_count(a) while b != 0: b >>= trailing_zero_count(b) if a > b: a, b = b, a b -= a return a << shift def lcm(a, b): Calculate the LCM of a and b using the GCD from gcd_bitwise. if a == 0 or b == 0: return 0 gcd = gcd_bitwise(a, b) return (a // gcd) * b"},{"question":"# Bracket the Longest Matching Symbol Problem Statement You\'re given two arrays: one containing words and another containing symbols. You need to highlight the longest matching symbols within each word by surrounding them with square brackets. Each word must be processed to replace the longest matching symbol. If a word matches more than one symbol, choose the one with the longest length. If there are no matches, the word remains unchanged. Input and Output * **Input**: * `words`: A list of strings containing the words. * `symbols`: A list of strings containing the symbols. * **Output**: * A list of strings where each word has its longest matching symbol bracketed with square brackets. Constraints * Each word could match at most one symbol. * Symbols in the `symbols` array are unique. * If a symbol match is found, only the first occurrence should be bracketed. * If no symbol matches a word, the word should remain unchanged. * `1 <= len(words), len(symbols) <= 1000` * Each word will consist of lowercase or uppercase English letters only. Example Given the following input: ```python words = [\'Amazon\', \'Microsoft\', \'Google\'] symbols = [\'i\', \'Am\', \'cro\', \'Na\', \'le\', \'abc\'] ``` The expected output is: ```python [\'[Am]azon\', \'Mi[cro]soft\', \'Goog[le]\'] ``` Function Signature ```python def bracket_longest_symbol(words: list, symbols: list) -> list: pass ``` Implementation Guidelines 1. **Trie Construction**: Consider constructing a trie for the symbols to facilitate efficient searching. 2. **Word Matching**: For each word, traverse and use the trie to identify the longest matching symbol. 3. **Replacement**: Replace the identified longest match with the symbol surrounded by square brackets.","solution":"def bracket_longest_symbol(words, symbols): def create_trie(symbols): trie = {} for symbol in symbols: current = trie for char in symbol: if char not in current: current[char] = {} current = current[char] current[\'*\'] = symbol return trie def find_longest_match(trie, word): max_length = 0 max_symbol = \'\' for i in range(len(word)): current = trie j = i while j < len(word) and word[j] in current: current = current[word[j]] j += 1 if \'*\' in current and j - i > max_length: max_length = j - i max_symbol = current[\'*\'] return max_symbol trie = create_trie(symbols) results = [] for word in words: symbol = find_longest_match(trie, word) if symbol: word = word.replace(symbol, f\'[{symbol}]\', 1) results.append(word) return results"},{"question":"As a data scientist, you are tasked to develop an application that requires matrix inversion for solving linear algebra problems. You are given a helper function to invert an n x n matrix which follows the cofactor method to find the inverse. Your objective is to optimize and ensure that the function handles special scenarios and edge cases. # Requirements: 1. **Function Signature**: ```python def optimized_invert_matrix(matrix: List[List[int]]) -> List[List[int]]: ``` 2. **Input**: - `matrix`: A 2D list (or nested list) of integers representing an n x n matrix where 2 ≤ n ≤ 10. 3. **Output**: - A 2D list representing the inverse of the input matrix if it exists, otherwise raise an appropriate exception if the matrix is not invertible. 4. **Constraints**: - The matrix elements are integers. - Raise an exception `ValueError` with respective messages if: - The matrix is not square. - The matrix is singular (determinant is zero). - Implement optimization techniques where possible to handle matrices efficiently. # Example: ```python # Given matrix matrix = [ [4, 7], [2, 6] ] # Expected output # The inverse matrix [ [0.6, -0.7], [-0.2, 0.4] ] ``` # Instructions: 1. Write the function `optimized_invert_matrix(matrix)` accordingly. 2. Ensure the function handles edge cases such as non-square matrices and singular matrices. 3. In your implementation, you can consider alternative algorithms like LUP decomposition for optimization. 4. Provide proper documentation and comments to explain your approach and the optimizations made. # Additional Notes: - You are not allowed to use numpy or other external libraries dealing directly with matrices. - Use the provided helper functions and scaffold the new function within. - Optimize for clarity and efficiency.","solution":"from typing import List def determinant(matrix: List[List[int]]) -> int: n = len(matrix) if n == 1: return matrix[0][0] if n == 2: return matrix[0][0] * matrix[1][1] - matrix[0][1] * matrix[1][0] det = 0 for c in range(n): sub_matrix = [ [matrix[r][cc] for cc in range(n) if cc != c] for r in range(1, n) ] det += ((-1) ** c) * matrix[0][c] * determinant(sub_matrix) return det def get_matrix_of_minors(matrix: List[List[int]]) -> List[List[int]]: n = len(matrix) minors = [] for r in range(n): minors_row = [] for c in range(n): sub_matrix = [ [matrix[rr][cc] for cc in range(n) if cc != c] for rr in range(n) if rr != r ] minors_row.append(determinant(sub_matrix)) minors.append(minors_row) return minors def transpose(matrix: List[List[int]]) -> List[List[int]]: return list(map(list, zip(*matrix))) def get_cofactor_matrix(matrix: List[List[int]]) -> List[List[int]]: n = len(matrix) minors = get_matrix_of_minors(matrix) return [[(((-1) ** (r + c)) * minors[r][c]) for c in range(n)] for r in range(n)] def optimized_invert_matrix(matrix: List[List[int]]) -> List[List[int]]: if not matrix or not all(len(row) == len(matrix) for row in matrix): raise ValueError(\\"The input matrix must be square.\\") n = len(matrix) det = determinant(matrix) if det == 0: raise ValueError(\\"The matrix is singular and cannot be inverted.\\") cofactor_matrix = get_cofactor_matrix(matrix) adjugate_matrix = transpose(cofactor_matrix) inverse_matrix = [[adjugate_matrix[r][c] / det for c in range(n)] for r in range(n)] return inverse_matrix"},{"question":"# Scenario A server application needs to transmit a list of user messages (strings) reliably over the network to a client application. The messages vary in length and can contain any characters, including spaces. You need to encode this list into a single string that can be sent over the network and then decode it back into the original list of messages on the receiving end. # Problem Statement Write two functions, `encode` and `decode`: 1. `encode(strs)`: Encodes a list of strings (`strs`) to a single string. - **Input**: `strs` is a list of strings. - **Output**: A single encoded string representing the list. 2. `decode(s)`: Decodes a single string (`s`) to a list of strings. - **Input**: `s` is an encoded string. - **Output**: A list of original strings. # Requirements - **Constraints**: - Input strings can include any characters. - The list of strings can have variable lengths including zero-length strings and an empty list. - **Performance Requirements**: - Both functions should run in O(N) time complexity where N is the number of characters in all strings for `encode` and in the encoded string for `decode`. # Function Signatures ```python def encode(strs: List[str]) -> str: pass def decode(s: str) -> List[str]: pass ``` # Example: ```python assert decode(encode([\\"hello\\", \\"world\\"])) == [\\"hello\\", \\"world\\"] assert decode(encode([\\"a\\", \\"\\"])) == [\\"a\\", \\"\\"] assert decode(encode([])) == [] ```","solution":"def encode(strs): Encodes a list of strings to a single string. :param strs: List[str], a list of strings :return: str, the encoded string return \'\'.join(f\'{len(s)}:{s}\' for s in strs) def decode(s): Decodes a single string to a list of strings. :param s: str, the encoded string :return: List[str], the original list of strings strs, i = [], 0 while i < len(s): j = s.index(\':\', i) length = int(s[i:j]) i = j + 1 + length strs.append(s[j+1:i]) return strs"},{"question":"Problem Statement You are given a list of integers and you need to determine how many of them are prime numbers. Implement a function that takes a list of integers and returns a count of the prime numbers in the list. Function Signature ```python def count_primes(nums: List[int]) -> int: Count the number of prime numbers in the list \'nums\'. Args: nums: List[int] - A list of integers. Returns: int - The count of prime numbers in the list. ``` Input & Output Format * **Input**: A list `nums` of integers (1 ≤ len(nums) ≤ 10^5) where each integer `num` satisfies 1 ≤ num ≤ 10^7. * **Output**: An integer representing the number of prime numbers in the input list. Example ```python assert count_primes([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == 4 assert count_primes([11, 13, 17, 19, 23, 29]) == 6 ``` Constraints - Optimize for both time and space efficiency. - Use helper functions to modularize the code where applicable.","solution":"from math import isqrt from typing import List def is_prime(n: int) -> bool: Helper function to check if a number is prime. Args: n: int - An integer. Returns: bool - True if \'n\' is a prime number, False otherwise. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def count_primes(nums: List[int]) -> int: Count the number of prime numbers in the list \'nums\'. Args: nums: List[int] - A list of integers. Returns: int - The count of prime numbers in the list. count = 0 for num in nums: if is_prime(num): count += 1 return count"},{"question":"# B-Tree Comprehensive Manipulation You are provided with the implementation details of a B-tree, an efficient multi-way tree data structure that maintains sorted data and allows searches, sequential access, insertions, and deletions in logarithmic time. To assess your understanding, complete the following tasks: # Objective Implement the following missing or additional functionalities in the provided B-tree class: 1. **Update Key**: Write a method to update an existing key in the B-Tree to a new value preserving the B-Tree properties. 2. **Count Keys**: Write a method to count the total number of keys currently present in the B-Tree. # Function Specifications 1. **Update Key Function**: - **Function Signature**: `def update_key(self, old_key: int, new_key: int) -> bool:` - **Input**: `old_key` (integer), `new_key` (integer) - **Output**: Returns `True` if the key was successfully updated, `False` otherwise. - **Constraints**: - Both `old_key` and `new_key` must be integers. - The `old_key` must already exist in the tree. - The tree should remain a valid B-Tree after the update. 2. **Count Keys Function**: - **Function Signature**: `def count_keys(self) -> int:` - **Output**: Returns the total number of keys present in the B-Tree. # Implementation Hints - Utilize existing B-Tree structure and methods for inserting and deleting nodes. - Ensure that the key update does not violate B-Tree properties (splitting/merging as needed). - Efficiently traverse the tree to count all keys. ```python class BTree: # Existing BTree class implementation def update_key(self, old_key: int, new_key: int) -> bool: Update an existing key to a new value while maintaining B-Tree properties. # Your code here pass def count_keys(self) -> int: Count the total number of keys in the B-Tree. # Your code here pass ``` # Example Usage ```python btree = BTree(t_val=3) keys_to_insert = [10, 20, 5, 6, 12, 30, 7, 17] for key in keys_to_insert: btree.insert_key(key) print(\\"Original Tree:\\") btree.traverse_tree() print(\\"nCount of keys:\\", btree.count_keys()) # Update 6 to 15 if btree.update_key(6, 15): print(\\"Key updated successfully.\\") else: print(\\"Key update failed.\\") print(\\"Updated Tree:\\") btree.traverse_tree() print(\\"nCount of keys:\\", btree.count_keys()) ``` The output should display the traversed tree before and after the key update, and the count of keys. --- # Performance Considerations - Ensure your implementation handles edge cases efficiently. - Update operation should maintain the balance of the B-Tree. Happy Coding!","solution":"class BTreeNode: def __init__(self, t, leaf=False): self.t = t # Minimum degree (defines the range for number of keys) self.leaf = leaf # True if leaf node, False otherwise self.keys = [] # List of keys in the node self.children = [] # List of child pointers def traverse(self): A function to traverse all nodes in a subtree rooted with this node # Print keys in this node for i in range(len(self.keys)): # If this is not leaf, then before printing key[i], traverse the subtree rooted with child children[i]. if not self.leaf: self.children[i].traverse() print(f\\" {self.keys[i]}\\", end=\\"\\") # Print the subtree rooted with last child if not self.leaf: self.children[len(self.keys)].traverse() def search(self, k): A function to search a key in the subtree rooted with this node. i = 0 # Find the first key greater than or equal to k while i < len(self.keys) and k > self.keys[i]: i += 1 # If the found key is equal to k, return this node if i < len(self.keys) and self.keys[i] == k: return self # If the key is not found here and this is a leaf node if self.leaf: return None # Go to the appropriate child return self.children[i].search(k) def count_keys(self): A function to count all keys in the subtree rooted with this node. count = len(self.keys) if not self.leaf: for child in self.children: count += child.count_keys() return count class BTree: def __init__(self, t): self.t = t # Minimum degree (defines the range for number of keys) self.root = None # Root node def traverse_tree(self): Function to traverse the tree if self.root: self.root.traverse() print() def search_key(self, k): Function to search a key in the tree if self.root: return self.root.search(k) return None def count_keys(self): Function to count the total number of keys in the tree if self.root: return self.root.count_keys() return 0 def insert_key(self, k): Function to insert a new key in the tree # If tree is empty if self.root is None: # Allocate memory for root self.root = BTreeNode(self.t, True) self.root.keys.append(k) # Insert key else: # If root is full, then tree grows in height if len(self.root.keys) == 2 * self.t - 1: s = BTreeNode(self.t, False) s.children.append(self.root) # Old root becomes child of new root self._split_child(s, 0, self.root) i = 0 if s.keys[0] < k: i += 1 self._insert_non_full(s.children[i], k) self.root = s else: self._insert_non_full(self.root, k) def _insert_non_full(self, x, k): Helper function to insert a new key in a node which is not full i = len(x.keys) - 1 if x.leaf: x.keys.append(None) while i >= 0 and k < x.keys[i]: x.keys[i + 1] = x.keys[i] i -= 1 x.keys[i + 1] = k else: while i >= 0 and k < x.keys[i]: i -= 1 i += 1 if len(x.children[i].keys) == 2 * self.t - 1: self._split_child(x, i, x.children[i]) if k > x.keys[i]: i += 1 self._insert_non_full(x.children[i], k) def _split_child(self, x, i, y): Helper function to split the child y of node x at index i z = BTreeNode(y.t, y.leaf) x.children.insert(i + 1, z) x.keys.insert(i, y.keys[self.t - 1]) z.keys = y.keys[self.t:(2 * self.t - 1)] y.keys = y.keys[0:(self.t - 1)] if not y.leaf: z.children = y.children[self.t:(2 * self.t)] y.children = y.children[0:self.t] def update_key(self, old_key: int, new_key: int) -> bool: Update an existing key to a new value while maintaining B-Tree properties. # Search for the node containing the old key node = self.search_key(old_key) if node: # Remove the old key and insert the new key node.keys.remove(old_key) self.insert_key(new_key) return True return False"},{"question":"# Function to Implement Implement a function `calculate_min_depth(root)` that calculates the minimum depth of a binary tree. Your function should demonstrate understanding of both recursive and iterative tree traversal methods. # Input and Output Format * **Input**: A binary tree represented by its root node. The classes should be defined as follows: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` * **Output**: An integer representing the minimum depth of the binary tree. # Constraints * The tree can have a maximum of 10,000 nodes. * Node values can range from -1000 to 1000. # Performance Requirements Your solution must handle large test cases efficiently, keeping both time and space complexity in mind. # Example ```python # Example tree: # 10 # / # 12 15 # / # 25 30 # # 100 root = TreeNode(10) root.left = TreeNode(12) root.right = TreeNode(15) root.left.left = TreeNode(25) root.left.left.right = TreeNode(100) root.left.right = TreeNode(30) assert calculate_min_depth(root) == 3 # The minimum depth is from root (10) to the leaf node (15) through (10 -> 15) ```","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def calculate_min_depth(root): Function to calculate the minimum depth of a binary tree. if not root: return 0 from collections import deque queue = deque([(root, 1)]) while queue: node, depth = queue.popleft() if not node.left and not node.right: return depth if node.left: queue.append((node.left, depth + 1)) if node.right: queue.append((node.right, depth + 1))"},{"question":"Scenario: You are working on a content management system where user activities are tracked through a series of actions. These actions are linked together in a chronological list but sometimes due to coding errors, loops can occur causing cyclic references. Your task is to determine if such a cycle is present in the action list of a given user. Question: Implement a function `is_cyclic(head)` that determines if the linked list starting from `head` contains a cycle. **Function Signature**: ```python class Node: def __init__(self, x): self.val = x self.next = None def is_cyclic(head: Node) -> bool: pass ``` **Input**: - `head: Node`: The starting node of a linked list, containing integer values, with each node pointing to the next node. **Output**: - `bool`: Return `True` if there is a cycle in the linked list. Otherwise, `False`. **Constraints**: - The linked list can be empty. - Nodes contain integer values. - Aim to solve this problem using O(1) space complexity. **Examples**: 1. Given linked list: 1 -> 2 -> 3 -> 4 -> 2 (cycle back to node 2), `is_cyclic(head)` should return `True`. 2. Given linked list: 1 -> 2 -> 3 -> 4, `is_cyclic(head)` should return `False`. **Edge Cases to Consider**: - An empty list (`head` is `None`). - List with only one node and no cycle. - List with several nodes with no cycle. - List where the cycle includes multiple nodes or just two nodes.","solution":"class Node: def __init__(self, x): self.val = x self.next = None def is_cyclic(head: Node) -> bool: slow = head fast = head while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: return True return False"},{"question":"You are working as a software engineer tasked with optimizing the cargo space of automated delivery drones. Each drone has a maximum weight capacity, and you have a list of items with specified weights and values. Your goal is to write a function that calculates the maximum value of items that can be carried by a drone without exceeding its weight limit. # Function Signature: ```python def calculate_max_value(items, capacity): :param items: List of tuples, where each tuple contains two integers representing the value and weight of an item. [(value1, weight1), (value2, weight2), ...] :param capacity: Integer representing the maximum weight capacity of the drone. :return: Maximum value that can be achieved without exceeding the weight limit. ``` # Input: - `items`: A list of tuples, where each tuple (value, weight) represents the value and weight of an item. - `capacity`: An integer representing the maximum weight capacity of the drone. # Output: - An integer representing the maximum value of items that can be carried without exceeding the weight limit. # Constraints: - The number of items, n, will be between 1 and 1000. - The capacity will be between 1 and 10000. - Each item\'s value and weight will be positive integers less than or equal to 1000. # Example: ```python items = [(60, 5), (50, 3), (70, 4), (30, 2)] capacity = 5 calculate_max_value(items, capacity) # Output: 80 (items valued 50 and 30 can both be fit in the knapsack) ``` # Notes: - Consider edge cases such as when the capacity is zero or when all items are too heavy to fit in the knapsack. - Efficiently utilize the dynamic programming approach described to achieve optimal performance.","solution":"def calculate_max_value(items, capacity): Calculates the maximum value of items that can be carried by the drone without exceeding its weight limit using the knapsack dynamic programming algorithm. :param items: List of tuples, where each tuple contains two integers representing the value and weight of an item. [(value1, weight1), (value2, weight2), ...] :param capacity: Integer representing the maximum weight capacity of the drone. :return: Maximum value that can be achieved without exceeding the weight limit. n = len(items) dp = [[0] * (capacity + 1) for _ in range(n + 1)] for i in range(1, n + 1): value, weight = items[i - 1] for w in range(capacity + 1): if weight <= w: dp[i][w] = max(dp[i - 1][w], dp[i - 1][w - weight] + value) else: dp[i][w] = dp[i - 1][w] return dp[n][capacity]"},{"question":"# Question: Implement an Enhanced RandomizedSet with Count Function Design and implement an enhanced version of the `RandomizedSet` which includes an additional method `count()`. The `count()` method should return the number of elements in the set. The class should still support all the following operations in average O(1) time: 1. `insert(val)`: Inserts an item `val` to the set if not already present. 2. `remove(val)`: Removes an item `val` from the set if present. 3. `get_random()`: Returns a random element from the set. 4. `count()`: Returns the count of the current elements in the set. Implement the class with the specified functionalities. Input Format - You do not need to handle input or output from standard input. - Your class should be called `EnhancedRandomizedSet`. Output Format - The `insert`, `remove`, and `count` methods should return `True`/`False` or the number of elements in the set as expected. - The `get_random` method should return a random element from the set. Constraints - All elements inserted are integers. - Assume all integers are within the range of 32-bit signed integers. - Assume elements to be inserted are unique or duplicates are not to be inserted. Example Usage ```python rs = EnhancedRandomizedSet() print(rs.insert(1)) # Should return True print(rs.insert(2)) # Should return True print(rs.count()) # Should return 2 print(rs.get_random()) # Should return either 1 or 2 print(rs.remove(1)) # Should return True print(rs.count()) # Should return 1 print(rs.remove(3)) # Should return False (not in the set) print(rs.get_random()) # Should return 2 (only element left) ```","solution":"import random class EnhancedRandomizedSet: def __init__(self): self.vals = [] self.vals_map = {} def insert(self, val): if val in self.vals_map: return False self.vals_map[val] = len(self.vals) self.vals.append(val) return True def remove(self, val): if val not in self.vals_map: return False last_val = self.vals[-1] idx = self.vals_map[val] self.vals[idx] = last_val self.vals_map[last_val] = idx self.vals.pop() del self.vals_map[val] return True def get_random(self): return random.choice(self.vals) def count(self): return len(self.vals)"},{"question":"**Anagram Checker for Case-Insensitive Strings** You\'re given two strings `s1` and `s2` and you need to determine if they are anagrams of each other. Two strings are anagrams if they use the same characters in the same frequency; however, your function should be case-insensitive. For example, \'Apple\' and \'pplAe\' are anagrams, but \'Apple\' and \'applf\' are not. # Function Signature ```python def anagram_case_insensitive(s1: str, s2: str) -> bool: pass ``` # Input * `s1` (String): The first input string. 1 ≤ len(s1) ≤ 10^5 * `s2` (String): The second input string. 1 ≤ len(s2) ≤ 10^5 # Output * `bool`: Return `True` if the strings are anagrams, and `False` otherwise. # Constraints * The input strings will consist of ASCII characters. # Requirements * Ensure that the anagram check is case-insensitive. * Achieve the solution with a linear time complexity, i.e., O(n). # Examples 1. `anagram_case_insensitive(\\"CinEma\\", \\"IceMan\\")` -> `True` 2. `anagram_case_insensitive(\\"Hello\\", \\"oLleh\\")` -> `True` 3. `anagram_case_insensitive(\\"Test\\", \\"Tess\\")` -> `False` 4. `anagram_case_insensitive(\\"Listen\\", \\"Silent\\")` -> `True` 5. `anagram_case_insensitive(\\"apple\\", \\"applee\\")` -> `False` # Constraints Handling * Consider all alphabetic characters as equivalent regardless of case. * Non-alphabetic characters can be part of the strings and should be considered in the frequency count. # Edge Cases * Test with empty strings (though constrained by minimum length). * Test with strings of differing lengths returning false immediately. * Test with mixed-case strings to confirm case-insensitivity.","solution":"def anagram_case_insensitive(s1: str, s2: str) -> bool: Determines if two strings are anagrams of each other, case insensitive. Args: s1 : str : The first input string s2 : str : The second input string Returns: bool : True if the strings are anagrams, False otherwise s1 = s1.lower() s2 = s2.lower() if len(s1) != len(s2): return False from collections import Counter return Counter(s1) == Counter(s2)"},{"question":"Background Bitonic Sort is a fast, parallelizable sorting algorithm that works efficiently on arrays of sizes which are a power of two. The main idea is to divide the array into sub-arrays, sort them in opposing orders, and then merge them to form a bitonic sequence that can be recursively sorted. Problem Statement You are required to implement a function that sorts an array using the Bitonic Sort algorithm. Your implementation should handle both ascending and descending order based on a provided parameter and should raise an error if the array size is not a power of two. Function Signature ```python def custom_bitonic_sort(arr: List[int], ascending: bool=True) -> List[int]: Sorts the array using Bitonic Sort algorithm. :param arr: List[int] - List of integers to be sorted :param ascending: bool - Flag to indicate if array should be sorted in ascending order (default: True) :return: List[int] - Sorted list of integers :raises ValueError: If the array size is not a power of two ``` Input - `arr` : A list of integers whose length is a power of two (1 ≤ len(arr) ≤ 2^20) - `ascending` : A boolean flag indicating if the array should be sorted in ascending order (default is `True`) Output - A list of integers sorted in the specified order. Example ```python custom_bitonic_sort([3, 7, 4, 8, 6, 2, 1, 5], True) # Output: [1, 2, 3, 4, 5, 6, 7, 8] custom_bitonic_sort([3, 7, 4, 8, 6, 2, 1, 5], False) # Output: [8, 7, 6, 5, 4, 3, 2, 1] ``` Constraints - Do not use any built-in sort functions. - Your implementation should raise an error if the input array\'s size is not a power of two, using the following: ```python if not (len(arr) and (not(len(arr) & (len(arr) - 1)))): raise ValueError(\\"The size of input should be a power of two\\") ```","solution":"from typing import List def bitonic_compare_and_swap(arr: List[int], direction: bool, start: int, length: int): half = length // 2 for i in range(start, start + half): if (arr[i] > arr[i + half]) == direction: arr[i], arr[i + half] = arr[i + half], arr[i] def bitonic_merge(arr: List[int], direction: bool, start: int, length: int): if length > 1: bitonic_compare_and_swap(arr, direction, start, length) half = length // 2 bitonic_merge(arr, direction, start, half) bitonic_merge(arr, direction, start + half, half) def bitonic_sort_recursive(arr: List[int], direction: bool, start: int, length: int): if length > 1: half = length // 2 bitonic_sort_recursive(arr, True, start, half) bitonic_sort_recursive(arr, False, start + half, half) bitonic_merge(arr, direction, start, length) def custom_bitonic_sort(arr: List[int], ascending: bool = True) -> List[int]: n = len(arr) if not (n > 0 and (not (n & (n - 1)))): raise ValueError(\\"The size of input should be a power of two\\") bitonic_sort_recursive(arr, ascending, 0, n) return arr"},{"question":"# Context You are working for a text processing company and need to ensure that two given strings are isomorphic. Two strings are considered isomorphic if the characters in the first string can be mapped to characters in the second string such that the structure of the two strings remains identical. # Problem Statement Implement a function `is_isomorphic(s: str, t: str) -> bool` that checks whether two given strings `s` and `t` are isomorphic. Two strings `s` and `t` are isomorphic if the characters in `s` can be replaced to get `t`. All occurrences of a character must be replaced with another character while preserving the order of characters, and no two characters may map to the same character but a character may map to itself. # Input - `s` (str): A string of length *n*. - `t` (str): A string of length *m*. # Output - (bool): Return `True` if the strings are isomorphic, otherwise return `False`. # Constraints 1. `1 <= len(s), len(t) <= 5 * 10^4` 2. Strings `s` and `t` consist of any characters from the ASCII character set. # Examples ```python # Example 1 Input: s = \\"egg\\", t = \\"add\\" Output: True # Example 2 Input: s = \\"foo\\", t = \\"bar\\" Output: False # Example 3 Input: s = \\"paper\\", t = \\"title\\" Output: True # Example 4 Input: s = \\"ab\\", t = \\"aa\\" Output: False # Example 5 Input: s = \\"a\\", t = \\"a\\" Output: True ``` # Notes - You should ensure that your solution works efficiently, with a time complexity of O(n) and a space complexity of O(n), where n is the length of the input strings. - Make sure your function handles edge cases such as strings of different lengths or strings containing non-alphabet characters.","solution":"def is_isomorphic(s: str, t: str) -> bool: Function to determine if two strings s and t are isomorphic. if len(s) != len(t): return False mapping_s_to_t = {} mapping_t_to_s = {} for char_s, char_t in zip(s, t): if char_s in mapping_s_to_t: if mapping_s_to_t[char_s] != char_t: return False else: mapping_s_to_t[char_s] = char_t if char_t in mapping_t_to_s: if mapping_t_to_s[char_t] != char_s: return False else: mapping_t_to_s[char_t] = char_s return True"},{"question":"# Problem Description You are tasked with implementing two classes, `SinglyLinkedList` and `DoublyLinkedList` with a set of specific methods. These linked lists should support dynamic operations like insertion, deletion, and access. Your implementation should be efficient and handle edge cases properly. # Requirements 1. **Class**: `SinglyLinkedList` 2. **Methods**: - `insert_at_head(value: int) -> None`: Insert a node with the given `value` at the head of the list. - `insert_at_tail(value: int) -> None`: Insert a node with the given `value` at the tail of the list. - `delete_value(value: int) -> bool`: Delete the first node with the given `value`. Return `True` if deletion was successful, `False` otherwise. - `find(value: int) -> bool`: Return `True` if a node with the given `value` exists, `False` otherwise. 3. **Class**: `DoublyLinkedList` 4. **Methods**: - `insert_at_head(value: int) -> None`: Insert a node with the given `value` at the head of the list. - `insert_at_tail(value: int) -> None`: Insert a node with the given `value` at the tail of the list. - `delete_value(value: int) -> bool`: Delete the first node with the given `value`. Return `True` if deletion was successful, `False` otherwise. - `find(value: int) -> bool`: Return `True` if a node with the given `value` exists, `False` otherwise. # Constraints - Values (integers) for nodes are in the range 1 to 10^7. - Perform at most 10^6 operations on the linked list. # Input/Output * You do not need to handle any inputs from stdin or outputs to stdout. Just ensure the methods have the correct input and output types. # Example ```python # Singly Linked List Example sll = SinglyLinkedList() sll.insert_at_head(5) sll.insert_at_tail(10) print(sll.find(5)) # Should output: True print(sll.delete_value(5)) # Should output: True print(sll.find(5)) # Should output: False # Doubly Linked List Example dll = DoublyLinkedList() dll.insert_at_head(5) dll.insert_at_tail(10) print(dll.find(5)) # Should output: True print(dll.delete_value(5)) # Should output: True print(dll.find(5)) # Should output: False ``` # Notes - Aim for clean and efficient code. - Handle edge cases such as inserting/deleting from an empty list or a single element list. - Ensure that the operations on the head and tail are specifically optimized.","solution":"class SinglyLinkedList: class Node: def __init__(self, value): self.value = value self.next = None def __init__(self): self.head = None def insert_at_head(self, value: int) -> None: new_node = self.Node(value) new_node.next = self.head self.head = new_node def insert_at_tail(self, value: int) -> None: new_node = self.Node(value) if not self.head: self.head = new_node else: current = self.head while current.next: current = current.next current.next = new_node def delete_value(self, value: int) -> bool: current = self.head if current and current.value == value: self.head = current.next return True previous = None while current: if current.value == value: previous.next = current.next return True previous = current current = current.next return False def find(self, value: int) -> bool: current = self.head while current: if current.value == value: return True current = current.next return False class DoublyLinkedList: class Node: def __init__(self, value): self.value = value self.next = None self.prev = None def __init__(self): self.head = None self.tail = None def insert_at_head(self, value: int) -> None: new_node = self.Node(value) if not self.head: self.head = self.tail = new_node else: new_node.next = self.head self.head.prev = new_node self.head = new_node def insert_at_tail(self, value: int) -> None: new_node = self.Node(value) if not self.tail: self.head = self.tail = new_node else: new_node.prev = self.tail self.tail.next = new_node self.tail = new_node def delete_value(self, value: int) -> bool: current = self.head while current: if current.value == value: if current.prev: current.prev.next = current.next if current.next: current.next.prev = current.prev if current == self.head: self.head = current.next if current == self.tail: self.tail = current.prev return True current = current.next return False def find(self, value: int) -> bool: current = self.head while current: if current.value == value: return True current = current.next return False"},{"question":"# Matrix Chain Multiplication - Dynamic Programming Matrix Chain Multiplication is a well-known problem in computer science for determining the most efficient way to multiply a given sequence of matrices. The task is to find the optimal order of matrix multiplications that minimizes the number of scalar multiplications. # Problem Statement Given an array of integers where the `i-th` integer denotes the number of rows/columns in the `i-th` matrix in the sequence, write a function to determine the minimum number of matrix multiplications required to multiply the chain of matrices. # Input * `array` — A list of integers representing the dimensions of the matrices (1 ≤ len(array) ≤ 100). # Output * The minimum number of scalar multiplications required. * The optimal parenthesization of matrices to achieve this minimal cost (as a string). # Constraints * Each matrix Ai has dimensions array[i-1] x array[i] for i from 1 to len(array)-1. * The elements of `array` are positive integers. # Function Signature ```python def matrix_chain_multiplication(array: List[int]) -> Tuple[int, str]: pass ``` # Example ```plaintext Input: [30, 35, 15, 5, 10, 20, 25] Output: (15125, \'((A1 (A2 A3)) ((A4 A5) A6))\') ``` # Explanation For the input `[30, 35, 15, 5, 10, 20, 25]`, the optimal order to multiply the matrices ``` A1: 30 x 35 A2: 35 x 15 A3: 15 x 5 A4: 5 x 10 A5: 10 x 20 A6: 20 x 25 ``` is `((A1 (A2 A3)) ((A4 A5) A6))`, which requires 15125 scalar multiplications. # Requirements 1. Implement a dynamic programming solution to solve the problem. 2. Ensure to handle edge cases appropriately based on the constraints given. 3. Optimize both space and time complexity where possible.","solution":"from typing import List, Tuple def matrix_chain_multiplication(array: List[int]) -> Tuple[int, str]: n = len(array) # Initialize the cost matrix m = [[0 for _ in range(n)] for _ in range(n)] # Matrix to store the k index where the partition occurs s = [[0 for _ in range(n)] for _ in range(n)] # l is the chain length for l in range(2, n): for i in range(1, n-l+1): j = i+l-1 m[i][j] = float(\'inf\') for k in range(i, j): q = m[i][k] + m[k+1][j] + array[i-1]*array[k]*array[j] if q < m[i][j]: m[i][j] = q s[i][j] = k # Function to construct optimal parenthesization def get_optimal_order(s, i, j): if i == j: return f\\"A{i}\\" else: return f\\"({get_optimal_order(s, i, s[i][j])} {get_optimal_order(s, s[i][j] + 1, j)})\\" optimal_cost = m[1][n-1] optimal_order = get_optimal_order(s, 1, n-1) return optimal_cost, optimal_order"},{"question":"# Problem Scenario In a game for kids, the concept of \'Magic Numbers\' is used to add an element of fun. A magic number is a number that, when you keep summing the digits and reducing it recursively until a single-digit, turns out to be 1. You need to implement a function to check whether a given number is a magic number to use in the game\'s validation logic. # Task Write a function `is_magic_number(n: int) -> bool` to determine if a given number `n` is a magic number. # Function Specifications - **Function Name**: `is_magic_number` - **Input Parameters**: An integer `n` - **Output**: Return `True` if `n` is a magic number, otherwise return `False` # Input Constraints - `1 <= n <= 10^9` # Examples ```python assert is_magic_number(50113) == True assert is_magic_number(1234) == True assert is_magic_number(199) == True assert is_magic_number(111) == False ``` # Explanation 1. For `n = 50113`, the process would be 5+0+1+1+3=10 => 1+0=1, returning `True`. 2. For `n = 1234`, the process would be 1+2+3+4=10 => 1+0=1, returning `True`. 3. For `n = 199`, the process would be 1+9+9=19 => 1+9=10 => 1+0=1, returning `True`. 4. For `n = 111`, the process would be 1+1+1=3, returning `False`. **Note**: Avoid using built-in functions for repetitive disk operations or converting a number into a string. Focus on the efficient handling of digits through arithmetic operations. # Test Your Function Ensure your function passes the provided examples and additional edge cases such as single-digit numbers and large numbers.","solution":"def is_magic_number(n: int) -> bool: Returns True if the given number n is a magic number, otherwise returns False. def digit_sum(num): total = 0 while num > 0: total += num % 10 num //= 10 return total while n >= 10: n = digit_sum(n) return n == 1"},{"question":"# Graph Path Finder You need to implement a path-finding algorithm to determine if there exists a path between two nodes in a directed graph. Given the graph class definitions provided, your task is to add a method `has_path` to the `DirectedGraph` class, which checks if there\'s a path from a start node to an end node. Function Signature ```python def has_path(self, start_node: str, end_node: str) -> bool: Determine if there exists a path from start_node to end_node in the graph. :param start_node: The name of the starting node. :param end_node: The name of the ending node. :return: True if a path exists, otherwise False. ``` Input - `start_node`: A string representing the name of the starting node. - `end_node`: A string representing the name of the ending node. Output - Returns `True` if a path exists from `start_node` to `end_node`; otherwise, returns `False`. Constraints - The `start_node` and `end_node` will always be present in the graph. - The graph can contain self-loops and multiple edges between two nodes. Implementation Notes - Consider using Depth-First Search (DFS) or Breadth-First Search (BFS) to traverse the graph. - Make sure to handle cycles in the graph to avoid infinite loops. Example ```python graph_data = { \\"A\\": [\\"B\\"], \\"B\\": [\\"C\\"], \\"C\\": [\\"D\\"], \\"D\\": [], \\"E\\": [\\"F\\"], \\"F\\": [\\"G\\"], \\"G\\": [\\"E\\"] } graph = DirectedGraph(graph_data) print(graph.has_path(\\"A\\", \\"D\\")) # Output: True print(graph.has_path(\\"A\\", \\"F\\")) # Output: False print(graph.has_path(\\"E\\", \\"G\\")) # Output: True print(graph.has_path(\\"G\\", \\"E\\")) # Output: True print(graph.has_path(\\"C\\", \\"A\\")) # Output: False ``` Implement your solution inside the `DirectedGraph` class provided: ```python class DirectedGraph: def __init__(self, load_dict={}): self.nodes = [] self.edges = [] self.adjacency_list = {} if load_dict and isinstance(load_dict, dict): for vertex in load_dict: node_from = self.add_node(vertex) self.adjacency_list[node_from] = [] for neighbor in load_dict[vertex]: node_to = self.add_node(neighbor) self.adjacency_list[node_from].append(node_to) self.add_edge(vertex, neighbor) def add_node(self, node_name): try: return self.nodes[self.nodes.index(node_name)] except ValueError: node = Node(node_name) self.nodes.append(node) return node def add_edge(self, node_name_from, node_name_to): try: node_from = self.nodes[self.nodes.index(node_name_from)] node_to = self.nodes[self.nodes.index(node_name_to)] self.edges.append(DirectedEdge(node_from, node_to)) except ValueError: pass def has_path(self, start_node, end_node): # implement this method pass ```","solution":"class DirectedGraph: def __init__(self, load_dict={}): self.nodes = [] self.edges = [] self.adjacency_list = {} if load_dict and isinstance(load_dict, dict): for vertex in load_dict: node_from = self.add_node(vertex) self.adjacency_list[node_from] = [] for neighbor in load_dict[vertex]: node_to = self.add_node(neighbor) self.adjacency_list[node_from].append(node_to) self.add_edge(vertex, neighbor) def add_node(self, node_name): if node_name not in self.nodes: self.nodes.append(node_name) return node_name def add_edge(self, node_name_from, node_name_to): if node_name_from not in self.adjacency_list: self.adjacency_list[node_name_from] = [] if node_name_to not in self.adjacency_list[node_name_from]: self.adjacency_list[node_name_from].append(node_name_to) def has_path(self, start_node, end_node): Determine if there exists a path from start_node to end_node in the graph. :param start_node: The name of the starting node. :param end_node: The name of the ending node. :return: True if a path exists, otherwise False. visited = set() def dfs(node): if node in visited: return False if node == end_node: return True visited.add(node) for neighbor in self.adjacency_list.get(node, []): if dfs(neighbor): return True return False return dfs(start_node)"},{"question":"# Trie-based Word Search and Manipulation Objective Implement a **Trie** data structure and utilize it to build a word search and manipulation system. Tasks 1. **Insert Words**: Implement functionality to insert multiple words into the trie. 2. **Search Words**: Implement functionality to search for the existence of specific words. 3. **Prefix Search**: Implement functionality to check if there is any word in the trie that starts with a given prefix. Function Signatures ```python class Trie: def __init__(self): self.root = TrieNode() def insert(self, word: str) -> None: Inserts a word into the trie. :param word: str - The word to be inserted. pass def search(self, word: str) -> bool: Returns True if the word is in the trie. :param word: str - The word to be searched. :return: bool pass def starts_with(self, prefix: str) -> bool: Returns True if there is any word in the trie that starts with the given prefix. :param prefix: str - The prefix to be searched for. :return: bool pass ``` Requirements 1. **Insert**: - Assume all inputs are lower-case letters (a-z). - Insert the provided word into the trie. 2. **Search**: - Return True if the word exists in the trie, else False. 3. **Prefix Search**: - Return True if any word in the trie starts with the given prefix, else False. Constraints - Words will be non-empty strings consisting of only lowercase \'a\' to \'z\'. - All inputs are valid string inputs. Example Usage ```python trie = Trie() # Insert words into the trie trie.insert(\\"apple\\") trie.insert(\\"app\\") # Search for words trie.search(\\"apple\\") # Returns True trie.search(\\"app\\") # Returns True trie.search(\\"appl\\") # Returns False # Check for prefixes trie.starts_with(\\"app\\") # Returns True trie.starts_with(\\"apl\\") # Returns False ``` # Additional Requirements - Handle edge cases where: - Insertion of an empty string should be ignored. - Searches for prefixes or words that do not exist. - Optimize for minimum memory utilization while ensuring fast lookup.","solution":"class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False class Trie: def __init__(self): self.root = TrieNode() def insert(self, word: str) -> None: if not word: return # Ignore empty word insertion current_node = self.root for char in word: if char not in current_node.children: current_node.children[char] = TrieNode() current_node = current_node.children[char] current_node.is_end_of_word = True def search(self, word: str) -> bool: if not word: return False current_node = self.root for char in word: if char not in current_node.children: return False current_node = current_node.children[char] return current_node.is_end_of_word def starts_with(self, prefix: str) -> bool: if not prefix: return False current_node = self.root for char in prefix: if char not in current_node.children: return False current_node = current_node.children[char] return True"},{"question":"# Path Sum Problem in Binary Tree You are given a binary tree and a sum. Your task is to write a function that finds all root-to-leaf paths where each path\'s sum equals the given sum. You need to implement three versions of this function: one using recursive DFS, one using iterative DFS with a stack, and one using BFS with a queue. Function Signature ```python def path_sum(root, sum): Find all root-to-leaf paths where each path\'s sum equals the given sum using recursive DFS. Parameters: root (TreeNode): The root node of the binary tree. sum (int): The target sum for the paths. Returns: List[List[int]]: A list of lists, where each inner list is a path from root to leaf whose nodes\' values sum up to the given sum. pass def path_sum2(root, sum): Find all root-to-leaf paths where each path\'s sum equals the given sum using iterative DFS with a stack. Parameters: root (TreeNode): The root node of the binary tree. sum (int): The target sum for the paths. Returns: List[List[int]]: A list of lists, where each inner list is a path from root to leaf whose nodes\' values sum up to the given sum. pass def path_sum3(root, sum): Find all root-to-leaf paths where each path\'s sum equals the given sum using BFS with a queue. Parameters: root (TreeNode): The root node of the binary tree. sum (int): The target sum for the paths. Returns: List[List[int]]: A list of lists, where each inner list is a path from root to leaf whose nodes\' values sum up to the given sum. pass ``` # Input * `root`: The root node of the binary tree. Each node contains an integer value, left child, and right child. * `sum`: An integer representing the target sum for the paths. # Output * List of lists of integers. Each list represents a path from the root to a leaf such that the sum of the values of the nodes along the path equals the given sum. # Constraints * The number of nodes in the tree is between 1 and 5000. * -1000 <= Node value <= 1000 * 0 <= sum <= 10000 # Example ```python # Assume TreeNode is a class with attributes: val, left, right. tree = TreeNode(5) tree.left = TreeNode(4) tree.right = TreeNode(8) tree.left.left = TreeNode(11) tree.left.left.left = TreeNode(7) tree.left.left.right = TreeNode(2) tree.right.left = TreeNode(13) tree.right.right = TreeNode(4) tree.right.right.left = TreeNode(5) tree.right.right.right = TreeNode(1) target_sum = 22 print(path_sum(tree, target_sum)) # Expected output: [[5, 4, 11, 2], [5, 8, 4, 5]] print(path_sum2(tree, target_sum)) # Expected output: [[5, 4, 11, 2], [5, 8, 4, 5]] print(path_sum3(tree, target_sum)) # Expected output: [[5, 4, 11, 2], [5, 8, 4, 5]] ``` Your task is to implement the three versions of the `path_sum` function using different algorithmic approaches (recursive DFS, iterative DFS, BFS).","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def path_sum(root, sum): def dfs(node, current_sum, path): if not node: return current_sum += node.val path.append(node.val) if not node.left and not node.right and current_sum == sum: result.append(path[:]) dfs(node.left, current_sum, path) dfs(node.right, current_sum, path) path.pop() result = [] dfs(root, 0, []) return result def path_sum2(root, sum): if not root: return [] result = [] stack = [(root, root.val, [root.val])] while stack: node, current_sum, path = stack.pop() if not node.left and not node.right and current_sum == sum: result.append(path) if node.right: stack.append((node.right, current_sum + node.right.val, path + [node.right.val])) if node.left: stack.append((node.left, current_sum + node.left.val, path + [node.left.val])) return result def path_sum3(root, sum): if not root: return [] from collections import deque result = [] queue = deque([(root, root.val, [root.val])]) while queue: node, current_sum, path = queue.popleft() if not node.left and not node.right and current_sum == sum: result.append(path) if node.left: queue.append((node.left, current_sum + node.left.val, path + [node.left.val])) if node.right: queue.append((node.right, current_sum + node.right.val, path + [node.right.val])) return result"},{"question":"Scenario In a distributed file storage system, you need to manage file paths in a consistent manner. Your task is to implement a function that will take an input file path and convert it to its absolute path, expanding any user-specific paths (like `~` for the home directory) to their full equivalents. This will help ensure that all nodes in the system refer to files in a uniform format. Task Write a function called `resolve_file_path` that takes a single string argument representing a file path and returns the absolute path string. Input * A single string `file_path` which can be a relative, absolute, or user-specific path. Output * Return a single string representing the absolute path of the input file. Constraints * You should assume the environment supports Python\'s standard libraries. * Handle both Unix-style (using `/`) and Windows-style (using ``) paths. * Max length of `file_path` will not exceed 1024 characters. * The function should not perform any kind of file existence check or file operations beyond path resolution. Example ```python def resolve_file_path(file_path): # Your implementation here # Example usage: print(resolve_file_path(\\"~/documents/report.txt\\")) # Output: \\"/home/user/documents/report.txt\\" (or equivalent absolute path on non-Unix systems) print(resolve_file_path(\\"./reports/yearly/2023_summary.txt\\")) # Output will be absolute path for the provided relative path print(resolve_file_path(\\"C:UsersUserDesktopfile.txt\\")) # Output will be absolute path (handled appropriately for Windows paths) ``` Ensure your function handles different types of paths accurately and consistently across platforms.","solution":"import os def resolve_file_path(file_path): Resolves a given file path to its absolute path, expanding any user-specific paths. Parameters: file_path (str): The input file path (relative, absolute, or user-specific). Returns: str: The absolute path to the input file. return os.path.abspath(os.path.expanduser(file_path))"},{"question":"You are given a string containing only digits `0-9` and an integer target value. Your task is to return all feasible expressions that can be formed by inserting binary operators (`+`, `-`, `*`) between the digits such that the expression evaluates to the target value. # Input Format - A string `num` which only contains digits from `0-9`. - An integer `target`. # Output Format - A list of strings, where each string is a valid expression that evaluates to the given target. # Constraints - The length of `num` will be between 1 and 10. - The numerical value in expressions (before evaluation) will always fit within a 32-bit signed integer. # Example Example 1: Input: ``` num = \\"123\\" target = 6 ``` Output: ``` [\\"1+2+3\\", \\"1*2*3\\"] ``` Example 2: Input: ``` num = \\"105\\" target = 5 ``` Output: ``` [\\"1*0+5\\", \\"10-5\\"] ``` Example 3: Input: ``` num = \\"00\\" target = 0 ``` Output: ``` [\\"0+0\\", \\"0-0\\", \\"0*0\\"] ``` Example 4: Input: ``` num = \\"3456237490\\" target = 9191 ``` Output: ``` [] ``` # Your Task Implement the function `add_operators(num: str, target: int) -> List[str]` that returns all valid expressions formed by inserting binary operators (+, -, *) between the digits of `num` which evaluate exactly to `target`. # Note: 1. **Leading zeros** in the numbers included in the expressions should be handled properly. For example, `105` should not be represented as `1*05` (which is invalid). 2. The list of output expressions can be in any order. Hints: - Use Depth-First Search (DFS) with backtracking to explore all possible operator insertions and evaluate them. - Be careful with operator precedence for multiplication in particular.","solution":"from typing import List def add_operators(num: str, target: int) -> List[str]: def dfs(pos, expr, prev_op, curr_value): if pos == len(num): if curr_value == target: result.append(expr) return for i in range(pos, len(num)): if i != pos and num[pos] == \'0\': break curr_str = num[pos:i + 1] curr_num = int(curr_str) if pos == 0: dfs(i + 1, curr_str, curr_num, curr_num) else: dfs(i + 1, expr + \'+\' + curr_str, curr_num, curr_value + curr_num) dfs(i + 1, expr + \'-\' + curr_str, -curr_num, curr_value - curr_num) dfs(i + 1, expr + \'*\' + curr_str, prev_op * curr_num, curr_value - prev_op + (prev_op * curr_num)) result = [] dfs(0, \\"\\", 0, 0) return result"},{"question":"You are tasked with the implementation of an Ordered Stack that ensures all elements in the stack are in non-decreasing order with the highest element on top. # Requirements: 1. Implement the Ordered Stack class. 2. The `push` method must insert the new element in such a way that the order of elements is maintained. 3. All standard stack operations (`push`, `pop`, `peek`, `is_empty`, `size`) should be supported. # Function Definitions: - **`__init__(self)`**: Initialize an empty Ordered Stack. - **`is_empty(self)`**: Returns `True` if the stack is empty, `False` otherwise. - **`push(self, item)`**: Inserts the given item in such a way that the order in the stack is maintained. - **`pop(self)`**: Removes and returns the item from the top of the stack. Raises `IndexError` if the stack is empty. - **`peek(self)`**: Returns the item at the top of the stack without removing it. Raises `IndexError` if the stack is empty. - **`size(self)`**: Returns the number of items in the stack. # Input/Output Format: - The `push` method accepts an integer as an input. - The `pop` and `peek` methods return the top item from the stack. - The `is_empty` method returns a boolean value. # Constraints: - Elements pushed in the stack are limited to integer values. - The design should handle up to 10^4 elements. # Example: ```python s = OrderedStack() s.push(3) s.push(5) s.push(1) print(s.pop()) # Output should be 5 print(s.peek()) # Output should be 3 print(s.size()) # Output should be 2 print(s.is_empty()) # Output should be False ``` Implement the `OrderedStack` class following the requirements listed above.","solution":"class OrderedStack: def __init__(self): self.stack = [] def is_empty(self): return len(self.stack) == 0 def push(self, item): # Find the position where the item needs to be inserted pos = 0 while pos < len(self.stack) and self.stack[pos] < item: pos += 1 self.stack.insert(pos, item) def pop(self): if self.is_empty(): raise IndexError(\\"pop from empty stack\\") return self.stack.pop() def peek(self): if self.is_empty(): raise IndexError(\\"peek from empty stack\\") return self.stack[-1] def size(self): return len(self.stack)"},{"question":"# Background You are working on a new web application that includes a messaging service. Messages need to be queued for processing in the order they are received. To accomplish this, you need to implement a queue data structure. You can use either an array-based or a linked list-based approach. # Task You will implement two types of queue classes: `CircularArrayQueue` and `LinkedListQueueWithIterator`, each with the given functionality described below. # Functionality 1. **CircularArrayQueue** (to improve upon the dynamic array-based implementation): - **enqueue(item) -> None**: Add `item` to the end of the queue. - **dequeue() -> Any**: Remove the item from the front of the queue and return it. - **peek() -> Any**: Return the item at the front of the queue without removing it. - **is_empty() -> bool**: Return True if the queue is empty, False otherwise. - **size() -> int**: Return the number of items in the queue. 2. **LinkedListQueueWithIterator** (to add robust iteration over existing `LinkedListQueue`): - **enqueue(item) -> None**: Add `item` to the end of the queue. - **dequeue() -> Any**: Remove the item from the front of the queue and return it. - **peek() -> Any**: Return the item at the front of the queue without removing it. - **is_empty() -> bool**: Return True if the queue is empty, False otherwise. - **size() -> int**: Return the number of items in the queue. - Implement iteration protocol to make the queue iterable using Python\'s `__iter__` and `__next__` methods. **Input Constraints**: - You can assume the input types will always match the expected types (i.e., valid elements for enqueue, no dequeue or peek on an empty queue). - The size of the queue will not exceed 10000 elements at any point. # Example ```python # CircularArrayQueue Example q = CircularArrayQueue(capacity=5) q.enqueue(1) q.enqueue(2) print(q.dequeue()) # 1 print(q.dequeue()) # 2 print(q.is_empty()) # True # LinkedListQueueWithIterator Example q = LinkedListQueueWithIterator() q.enqueue(\\"first\\") q.enqueue(\\"second\\") for item in q: print(f\\"Message: {item}\\") # Outputs: # Message: first # Message: second ``` # Implementation Use the structure from the given code snippets to implement these classes. Do not reuse the classes directly but create the new ones enhancing upon them.","solution":"class CircularArrayQueue: def __init__(self, capacity=10000): self.capacity = capacity self.queue = [None] * capacity self.front = 0 self.rear = -1 self.count = 0 def enqueue(self, item): if self.count == self.capacity: raise OverflowError(\\"Queue is full\\") self.rear = (self.rear + 1) % self.capacity self.queue[self.rear] = item self.count += 1 def dequeue(self): if self.is_empty(): raise IndexError(\\"Dequeue from empty queue\\") item = self.queue[self.front] self.queue[self.front] = None self.front = (self.front + 1) % self.capacity self.count -= 1 return item def peek(self): if self.is_empty(): raise IndexError(\\"Peek from empty queue\\") return self.queue[self.front] def is_empty(self): return self.count == 0 def size(self): return self.count class Node: def __init__(self, value=None): self.value = value self.next = None class LinkedListQueueWithIterator: def __init__(self): self.front = None self.rear = None self.count = 0 def enqueue(self, item): new_node = Node(item) if self.rear: self.rear.next = new_node self.rear = new_node if not self.front: self.front = new_node self.count += 1 def dequeue(self): if self.is_empty(): raise IndexError(\\"Dequeue from empty queue\\") item = self.front.value self.front = self.front.next if not self.front: self.rear = None self.count -= 1 return item def peek(self): if self.is_empty(): raise IndexError(\\"Peek from empty queue\\") return self.front.value def is_empty(self): return self.front is None def size(self): return self.count def __iter__(self): self.current = self.front return self def __next__(self): if self.current: item = self.current.value self.current = self.current.next return item else: raise StopIteration"},{"question":"# RSA Encryption Enhancement The provided RSA encryption implementation has a modular exponentiation mechanism in place but can be inefficient, especially in generating prime numbers and finding modular inverses. To assess your understanding of RSA and algorithm optimization, enhance the provided key generation algorithm. Task: 1. **Optimize**: Replace the `gen_prime` function with a more efficient prime generation algorithm, such as the Miller-Rabin primality test. 2. **Improve**: Replace the `modinv` function with an implementation using the Extended Euclidean Algorithm. 3. **Detail**: Ensure your implementation properly handles edge cases and performs effectively with large bit sizes. Restrictions: - The bit length of `n` will be provided and you should ensure both primes `p` and `q` are of appropriate sizes such that `n = p * q`. - Use cryptographically strong random number generation. - Ensure all calculations operate within feasible execution limits. Input: - An integer `k` representing the bit length of `n`. - An optional integer `seed` for reproducible random number generation. Output: - A tuple `(n, e, d)` representing the RSA public modulus, encryption exponent, and decryption exponent. Example: ```python def generate_key_enhanced(k, seed=None): # Your optimized implementation here pass n, e, d = generate_key_enhanced(16) print(n, e, d) # Output: tuple with n, e, d as defined ``` **Note**: - Validate your enhanced implementation with multiple test cases. - Ensure you handle edge cases where `p % e == 1` or `q % e == 1`.","solution":"import random def is_prime(n, k=5): # Miller-Rabin primality test if n <= 1: return False if n <= 3: return True if n % 2 == 0: return False r, s = 0, n - 1 while s % 2 == 0: r += 1 s //= 2 for _ in range(k): a = random.randint(2, n - 2) x = pow(a, s, n) if x == 1 or x == n - 1: continue for _ in range(r - 1): x = pow(x, 2, n) if x == n - 1: break else: return False return True def gen_prime(bit_length): while True: prime_candidate = random.getrandbits(bit_length) prime_candidate |= (1 << bit_length - 1) | 1 if is_prime(prime_candidate): return prime_candidate def egcd(a, b): if a == 0: return b, 0, 1 g, x1, y1 = egcd(b % a, a) x = y1 - (b // a) * x1 y = x1 return g, x, y def modinv(a, m): g, x, y = egcd(a, m) if g != 1: raise ValueError(\\"Modular inverse does not exist\\") return x % m def generate_key_enhanced(k, seed=None): if seed is not None: random.seed(seed) e = 65537 # Commonly used prime exponent half_k = k // 2 while True: p = gen_prime(half_k) q = gen_prime(half_k) if p != q and (p - 1) % e != 0 and (q - 1) % e != 0: break n = p * q phi = (p - 1) * (q - 1) d = modinv(e, phi) return (n, e, d)"},{"question":"# Maximum Path Sum in a Binary Tree Given a binary tree where each node contains an integer value, write a function `max_path_sum` to find the maximum path sum. The path can start and end at any node in the tree. Input: * A binary tree where each node contains an integer value. Output: * An integer representing the maximum path sum. Function Signature: ```python def max_path_sum(root: TreeNode) -> int: ``` Constraints: * The number of nodes in the tree is in the range `[0, 3000]`. * `-1000 <= Node.val <= 1000` Example: # Input: ``` 1 / 2 3 ``` # Output: ``` 6 ``` # Explanation: The path that yields the maximum sum is `2 -> 1 -> 3`. # Edge Cases to Consider: 1. Empty tree (should return 0 or negative infinity depending on prompt requirements). 2. Single-node tree. 3. Trees with all negative values. Ensure your function handles these edge cases and optimally updates and tracks the maximum path sum using recursion and post-order traversal.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def max_path_sum(root: TreeNode) -> int: def helper(node): if not node: return 0 # Recursively get the max sum of paths in left and right subtrees left_max_sum = max(0, helper(node.left)) right_max_sum = max(0, helper(node.right)) # Calculate the maximum path sum passing through the current node current_max_sum = node.val + left_max_sum + right_max_sum # Update the global max sum nonlocal max_sum max_sum = max(max_sum, current_max_sum) # Return the maximum sum of the path where this node is the highest ancestor return node.val + max(left_max_sum, right_max_sum) max_sum = float(\'-inf\') helper(root) return max_sum"},{"question":"# **Directed Graph Strongly Connected Component Detection** You are given the basic structure of a directed graph and the implementation of an algorithm to determine if the graph is Strongly Connected. A strongly connected graph is a set of vertices where there is a path between any two vertices (both ways). # **Task** Your task is to implement the following functions within a `DirectedGraph` class: 1. **add_edge(self, source: int, target: int)** - Adds a directed edge from `source` to `target`. 2. **dfs(self) -> bool** - Conducts a DFS starting from node 0 and checks if all nodes are reachable. 3. **dfs_util(self, source: int, visited: List[bool])** - Helper utility function for `dfs`. 4. **reverse_graph(self) -> \'DirectedGraph\'** - Returns a new graph object which is the reversal of the current graph. 5. **is_strongly_connected(self) -> bool** - Uses `dfs` and `reverse_graph` to check if the graph is strongly connected. # **Input Formats** 1. `self.add_edge(self, source, target)` - `source` and `target` are integers representing the nodes where `1 <= source, target <= n`. 2. `dfs(self) -> bool` - Returns `True` if all nodes can be visited starting from node `0`, otherwise `False`. 3. `dfs_util(self, source, visited)` - Recursive utility function for `dfs`. 4. `reverse_graph(self) -> \'DirectedGraph\'` - Returns a new `DirectedGraph` instance with reversed edges. 5. `is_strongly_connected(self) -> bool` - Returns `True` if the graph is strongly connected, otherwise `False`. # **Constraints** - Number of vertices (V): `1 <= V <= 1000` - Number of edges (E): `0 <= E <= 5000` - Graph edges have directed relationships. # **Performance Requirements** - Time Complexity: O(V + E) - Space Complexity: O(V + E) # **Example Usage** ```python # Create a graph with 5 vertices graph = DirectedGraph(5) # Add edges graph.add_edge(0, 1) graph.add_edge(1, 2) graph.add_edge(2, 3) graph.add_edge(3, 0) graph.add_edge(2, 4) graph.add_edge(4, 2) # Test if the graph is strongly connected print(graph.is_strongly_connected()) # Expected output: True # Create another graph with 3 vertices graph2 = DirectedGraph(3) graph2.add_edge(0, 1) graph2.add_edge(1, 2) # Test if this graph is strongly connected print(graph2.is_strongly_connected()) # Expected output: False ```","solution":"class DirectedGraph: def __init__(self, num_vertices): self.num_vertices = num_vertices self.adj_list = {i: [] for i in range(num_vertices)} def add_edge(self, source, target): self.adj_list[source].append(target) def dfs_util(self, source, visited): visited[source] = True for neighbor in self.adj_list[source]: if not visited[neighbor]: self.dfs_util(neighbor, visited) def dfs(self): visited = [False] * self.num_vertices self.dfs_util(0, visited) return all(visited) def reverse_graph(self): reversed_graph = DirectedGraph(self.num_vertices) for src in range(self.num_vertices): for dest in self.adj_list[src]: reversed_graph.add_edge(dest, src) return reversed_graph def is_strongly_connected(self): # Step 1: Perform DFS from a starting vertex if not self.dfs(): return False # Step 2: Reverse the graph reversed_graph = self.reverse_graph() # Step 3: Perform DFS on the reversed graph if not reversed_graph.dfs(): return False return True"},{"question":"# Question: Binary Tree Balance Checker --- Context In many data structures such as AVL Trees or Red-Black Trees, maintaining a balance property is crucial for ensuring optimal performance during operations like insertion, deletion, and search. A binary tree is balanced if the height of its left and right subtrees differs by no more than one at any node. You are tasked with implementing an efficient algorithm to check whether a given binary tree is balanced. Task Implement a function `is_balanced(root)` that determines if a given binary tree is balanced. Use the optimized approach with O(N) time complexity. Function Signature ```python class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def is_balanced(root: TreeNode) -> bool: # Your code here ``` Input - `root`: A `TreeNode` object representing the root of the binary tree. Output - Returns `True` if the binary tree is balanced, otherwise returns `False`. Constraints - The number of nodes in the tree is in the range [0, 10^4]. - The values of the nodes are arbitrary integers. Examples ```python # Example 1: # Given the following binary tree # 1 # / # 2 3 # / # 4 5 # / # 8 # is_balanced(TreeNode(1, TreeNode(2, TreeNode(4, TreeNode(8)), TreeNode(5)), TreeNode(3))) -> False # Example 2: # Given the following binary tree # 1 # / # 2 3 # / # 4 5 # is_balanced(TreeNode(1, TreeNode(2, TreeNode(4), TreeNode(5)), TreeNode(3))) -> True ``` Notes - You can assume that the `TreeNode` class is already defined as shown in the provided function signature.","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def is_balanced(root: TreeNode) -> bool: def check_balance(node): if not node: return 0, True left_height, left_balanced = check_balance(node.left) right_height, right_balanced = check_balance(node.right) current_height = max(left_height, right_height) + 1 is_balanced = left_balanced and right_balanced and abs(left_height - right_height) <= 1 return current_height, is_balanced _, balanced = check_balance(root) return balanced"},{"question":"Implement a Circular Doubly Linked List Objective You are required to implement a Circular Doubly Linked List (CDLL). A Circular Doubly Linked List is a more advanced form of the doubly linked list where the last node points to the first node, forming a circle. You must write a class with methods to perform various operations on the CDLL. Requirements 1. **Class Definition**: Define a node class and a CDLL class with necessary attributes. 2. **Operations**: * `append(value)`: Adds a node with the given value to the end of the list. * `prepend(value)`: Adds a node with the given value to the start of the list. * `delete(value)`: Deletes the first node with the specified value. * `display()`: Prints the list\'s elements from head to tail. Input and Output * The `append` and `prepend` methods will take an integer value as input and add it to the list. * The `delete` method will take an integer value and remove the first occurrence of a node containing that value. * The `display` method will print the list elements in a single line separated by spaces. Constraints and Limitations * The values are non-negative integers. * Your methods should handle edge cases such as empty list, single-element list, and performing delete operations on non-existent values gracefully. Performance Requirements * Ensure that all operations (append, prepend, delete) work in constant time, O(1), if the position of the operation is specified accurately. Example ```python cdll = CircularDoublyLinkedList() cdll.append(10) cdll.append(20) cdll.prepend(5) cdll.display() # Output: 5 10 20 cdll.delete(10) cdll.display() # Output: 5 20 ```","solution":"class Node: def __init__(self, value): self.value = value self.next = None self.prev = None class CircularDoublyLinkedList: def __init__(self): self.head = None def append(self, value): new_node = Node(value) if not self.head: self.head = new_node new_node.next = new_node new_node.prev = new_node else: tail = self.head.prev tail.next = new_node new_node.prev = tail new_node.next = self.head self.head.prev = new_node def prepend(self, value): new_node = Node(value) if not self.head: self.head = new_node new_node.next = new_node new_node.prev = new_node else: tail = self.head.prev tail.next = new_node new_node.prev = tail new_node.next = self.head self.head.prev = new_node self.head = new_node def delete(self, value): if not self.head: return current = self.head while True: if current.value == value: if current.next == current: # Single node self.head = None else: current.prev.next = current.next current.next.prev = current.prev if current == self.head: # If the head is to be deleted self.head = current.next return current = current.next if current == self.head: break def display(self): if not self.head: print(\\"\\") return result = [] current = self.head while True: result.append(str(current.value)) current = current.next if current == self.head: break print(\\" \\".join(result))"},{"question":"# Diffie-Hellman Key Exchange Enhancement Due to the reliance on the security of the Diffie-Hellman key exchange algorithm, it\'s essential to handle large primes and ensure efficient calculations. Given the snippets above, your task is to implement an enhanced version of the Diffie-Hellman Key Exchange that ensures optimal performance, proper handling of edge cases, and necessary improvements where applicable. Requirements: 1. **Secure Primality Check**: Enhance the `prime_check` function to handle very large numbers efficiently (e.g., using the Miller-Rabin primality test). 2. **Optimized Order Finding**: Modify the `find_order` function to use more efficient techniques for large numbers. 3. **Complete Diffie-Hellman Exchange**: - Implement the complete Diffie-Hellman key exchange process. - Ensure proper random number generation for private keys. - Validate input primes and primitive roots with the enhanced primality and root checking functions. Input and Output: - **Input**: A large prime number `p`, and its primitive root `a`. - **Output**: Securely shared key between two parties, Alice and Bob. Constraints: - `p` should be a large prime (10^8 < p < 10^10). - `a` must be a primitive root of `p`. Steps and Functions: 1. **Secure Primality Check**: Implement or use an existing library for the Miller-Rabin test. 2. **Optimized Order Finding**: Use efficient techniques suitable for large numbers. 3. **Diffie-Hellman Process**: - Include private key generation. - Public key calculation. - Shared key derivation. - Proper validation and error handling. Example Execution: ```python p = 263167 * (10**7) + 1 # Example large prime a = 2 # Example primitive root # Enhanced Diffie-Hellman Function secure_shared_key = enhanced_diffie_hellman_key_exchange(a, p) # Output the shared key print(f\\"Securely Shared Key: {secure_shared_key}\\") ``` Use the provided snippets as a basis and enhance them accordingly.","solution":"import random # Miller-Rabin Primality Test for secure primality check def miller_rabin_test(n, k=40): if n <= 1: return False if n <= 3: return True if n % 2 == 0: return False r, s = 0, n - 1 while s % 2 == 0: r += 1 s //= 2 for _ in range(k): a = random.randint(2, n - 2) x = pow(a, s, n) if x == 1 or x == n - 1: continue for _ in range(r - 1): x = pow(x, 2, n) if x == n - 1: break else: return False return True # Function to find modular inverse using Extended Euclidean Algorithm def modular_inverse(a, m): m0, x0, x1 = m, 0, 1 if m == 1: return 0 while a > 1: q = a // m m, a = a % m, m x0, x1 = x1 - q * x0, x0 return x1 + m0 if x1 < 0 else x1 # Function to find order of an element using Pollard\'s Rho algorithm def pollards_rho_order(a, p): if pow(a, (p - 1) // 2, p) == 1: return 2 if pow(a, 2 * (p - 1) // 3, p) == 1: return 3 return p - 1 # Diffie-Hellman Key Exchange implementation def enhanced_diffie_hellman_key_exchange(a, p): if not miller_rabin_test(p): raise ValueError(\\"Provided number is not a prime.\\") order = pollards_rho_order(a, p) if order != p - 1: raise ValueError(\\"Provided number is not a primitive root.\\") alice_private_key = random.randint(2, p - 2) bob_private_key = random.randint(2, p - 2) alice_public_key = pow(a, alice_private_key, p) bob_public_key = pow(a, bob_private_key, p) alice_shared_key = pow(bob_public_key, alice_private_key, p) bob_shared_key = pow(alice_public_key, bob_private_key, p) assert alice_shared_key == bob_shared_key, \\"Shared keys do not match.\\" return alice_shared_key"},{"question":"# Question You are given a directed graph represented by its number of vertices and a list of edges. A graph is strongly connected if there is a path from any vertex to every other vertex. Your task is to implement the method `is_strongly_connected` that determines whether the graph is strongly connected. Input 1. `vertex_count`: An integer `v` representing the number of vertices in the graph (0 ≤ v ≤ 10^4). 2. A list of tuples `(u, v)` where each tuple represents a one-way edge from vertex `u` to vertex `v` (0 ≤ u, v < vertex_count). Output - Return `True` if the graph is strongly connected, otherwise return `False`. Constraints - You may assume that the graph does not contain self-loops (edges from a vertex to itself). Example ```python # Example 1: vertex_count = 5 edges = [(0, 1), (1, 2), (2, 3), (3, 4), (4, 0)] # Output: True (there exists a path between every pair of vertices) # Example 2: vertex_count = 4 edges = [(0, 1), (1, 2), (2, 3)] # Output: False (there is no path from vertex 3 to vertex 0) ``` Explanation - Construct a directed graph using the given list of edges. - Implement the function `is_strongly_connected` to check if the graph is strongly connected. - Utilize DFS to traverse the original graph and its reverse to determine strong connectivity.","solution":"from collections import defaultdict, deque def is_strongly_connected(vertex_count, edges): if vertex_count == 0: return True graph = defaultdict(list) reverse_graph = defaultdict(list) for u, v in edges: graph[u].append(v) reverse_graph[v].append(u) def bfs(start, graph): visited = set() q = deque([start]) while q: node = q.popleft() if node not in visited: visited.add(node) for neighbor in graph[node]: if neighbor not in visited: q.append(neighbor) return visited start_node = next(iter(graph), None) if start_node is None: return True visited_from_start = bfs(start_node, graph) if len(visited_from_start) != vertex_count: return False visited_in_reverse = bfs(start_node, reverse_graph) if len(visited_in_reverse) != vertex_count: return False return True"},{"question":"# Decoding Numeric Strings Context/Scenario: Imagine you are building a text messaging application that encodes messages using a mapping from letters to numbers (A=1, B=2, .., Z=26). You need to decode numeric strings back into possible letter combinations. To ensure the robustness of your decoding algorithm, you must consider various conditions of the encoded message, such as leading zeros, invalid subsequences, and valid multiple digit interpretations. Task: Write a function `decode_message(encoded_message: str) -> int` to determine the total number of ways to decode a given encoded message. Input: * `encoded_message`: A string containing digits representing an encoded message. Output: * An integer representing the number of ways to decode the message. Constraints: 1. The string will only contain digits (\'0\'-\'9\'). 2. The string length will not exceed 100. Example: ```python assert decode_message(\\"12\\") == 2 # \\"AB\\" (1 2) or \\"L\\" (12) assert decode_message(\\"226\\") == 3 # \\"BBF\\" (2 2 6), \\"VF\\" (22 6), \\"BZ\\" (2 26) assert decode_message(\\"06\\") == 0 # Invalid since a message cannot start with \'0\' ``` Performance: Ensure that your function runs efficiently even for the maximum input size.","solution":"def decode_message(encoded_message): Returns the total number of ways to decode the given numeric string as a message. if not encoded_message or encoded_message[0] == \'0\': return 0 n = len(encoded_message) dp = [0] * (n + 1) dp[0] = 1 # Base case: an empty string can be decoded in 1 way for i in range(1, n + 1): # Check if the single digit is valid (i.e., 1-9) if encoded_message[i-1] != \'0\': dp[i] += dp[i-1] # Check if the two digits form a valid number (i.e., 10-26) if i > 1 and \'10\' <= encoded_message[i-2:i] <= \'26\': dp[i] += dp[i-2] return dp[n]"},{"question":"Implement a Doubly Linked List in Python Description You are required to implement a `DoublyLinkedList` class in Python. This class should manage doubly linked list nodes as described. Requirements 1. Implement the `DoublyLinkedListNode` class with the following attributes: - `value`: The value of the node. - `next`: A pointer to the next node in the list. - `prev`: A pointer to the previous node in the list. 2. Implement the `DoublyLinkedList` class with the following methods: - `insert_at_head(value)`: Inserts a new node with the given value at the head of the list. - `insert_at_tail(value)`: Inserts a new node with the given value at the tail of the list. - `delete_node(node)`: Deletes the specified node from the list. - `find(value) -> DoublyLinkedListNode`: Searches for the first node with the specified value and returns it. - `display_forward() -> List`: Returns a list of values representing the linked list contents from head to tail. - `display_backward() -> List`: Returns a list of values representing the linked list contents from tail to head. Constraints - You may assume that the values used in the nodes are all unique. - The `delete_node` method must handle edge cases such as deleting the head, the tail, and a single-node list correctly. - The linked list should handle empty list scenarios gracefully. Example ```python dll = DoublyLinkedList() dll.insert_at_head(10) dll.insert_at_tail(20) dll.insert_at_tail(30) dll.delete_node(dll.find(20)) assert dll.display_forward() == [10, 30] assert dll.display_backward() == [30, 10] node = dll.find(30) assert node.value == 30 dll.delete_node(node) assert dll.display_forward() == [10] assert dll.display_backward() == [10] ```","solution":"class DoublyLinkedListNode: def __init__(self, value): self.value = value self.next = None self.prev = None class DoublyLinkedList: def __init__(self): self.head = None self.tail = None def insert_at_head(self, value): new_node = DoublyLinkedListNode(value) if self.head is None: self.head = new_node self.tail = new_node else: new_node.next = self.head self.head.prev = new_node self.head = new_node def insert_at_tail(self, value): new_node = DoublyLinkedListNode(value) if self.tail is None: self.head = new_node self.tail = new_node else: new_node.prev = self.tail self.tail.next = new_node self.tail = new_node def delete_node(self, node): if node.prev: node.prev.next = node.next else: # node is the head self.head = node.next if node.next: node.next.prev = node.prev else: # node is the tail self.tail = node.prev node.next = None node.prev = None def find(self, value): current = self.head while current is not None: if current.value == value: return current current = current.next return None def display_forward(self): result = [] current = self.head while current is not None: result.append(current.value) current = current.next return result def display_backward(self): result = [] current = self.tail while current is not None: result.append(current.value) current = current.prev return result"},{"question":"You are given an array of integers where every element appears exactly three times except for one element, which appears exactly once. Your task is to find and return the single integer that appears only once. Write a function `findUniqueNumber` that takes a list of integers `nums` as an input and returns the integer that only appears once. # Input * A list of integers `nums` of size `n` (1 ≤ n ≤ 3 * 10^4), where each integer can be between -2^31 and 2^31 - 1. # Output * An integer that appears only once in the input list. # Constraints * Your algorithm should have linear runtime complexity. * You should not use extra memory beyond a few integer variables (constant space complexity). # Example ```python def findUniqueNumber(nums): # implementation here pass # Example test cases print(findUniqueNumber([2, 2, 3, 2])) # Output: 3 print(findUniqueNumber([0, 1, 0, 1, 0, 1, 99])) # Output: 99 ``` # Explanation In the first example: * All integers except `3` appear exactly three times. In the second example: * All integers except `99` appear exactly three times. Write your function to meet the specified constraints and requirements.","solution":"def findUniqueNumber(nums): Find the single integer that appears only once while all other integers appear exactly three times. ones, twos = 0, 0 for num in nums: # Update the value of ones and twos using XOR and AND operations ones = (ones ^ num) & ~twos twos = (twos ^ num) & ~ones return ones"},{"question":"Coding Assessment Question You are given a binary array (array containing only 0s and 1s). Your task is to write a Python function `max_ones_index(arr)` that identifies the index of the zero that, when replaced with one, results in the longest sequence of consecutive ones in the array. # Function Signature ```python def max_ones_index(arr: List[int]) -> int: pass ``` # Input - A list of integers `arr` containing only 0s and 1s, where `1 <= len(arr) <= 10^5`. # Output - Returns the index of a zero in the array that, when replaced by a one, produces the longest run of consecutive ones. - If the array contains no zeros, return -1. # Constraints - At least one zero must exist in the array for the function to work as intended. - You need to solve this problem in O(n) time complexity and O(1) space complexity. # Example ```python assert max_ones_index([1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1]) == 3 assert max_ones_index([1, 1, 0, 1, 0, 1]) == 2 assert max_ones_index([1, 1, 1, 1]) == -1 ``` Explanation: - In the first example, replacing the zero at index 3 yields the longest sequence of continuous ones with length 10. - In the second example, replacing the zero at index 2 yields a maximum sequence of 3 continuous ones. - In the third example, as there is no zero, it returns -1.","solution":"from typing import List def max_ones_index(arr: List[int]) -> int: max_count = 0 # To keep track of the maximum sequence of 1s found max_index = -1 # To keep track of the index of 0 giving the maximum sequence of 1s left = -1 # To keep track of the last zero\'s index in the current window count = 0 # To store the current length of the sequence of 1s for i in range(len(arr)): if arr[i] == 1: count += 1 else: count = i - left left = i if count > max_count: max_count = count max_index = left return max_index"},{"question":"Coding Assessment Question: Implementing a Sorting Algorithm with Efficiency Improvements # Scenario You are a software engineer at a startup where memory efficiency is crucial due to limited resources. Your task is to improve the current selection sort implementation by introducing optimizations while maintaining its simplicity and ensuring correctness. # Goal Write a Python function that implements an optimized version of the selection sort algorithm. # Function Signature ```python def optimized_selection_sort(arr): ``` # Input * `arr`: A list of integers where the length can range from 0 to 100,000. # Output * The function should return a new list which is `arr` sorted in ascending order. # Constraints * Sorting should be done in-place, minimizing memory overhead. * Your implementation should attempt to reduce unnecessary comparisons. # Performance Requirements * The solution must be optimized for time complexity without sacrificing simplicity. * The final optimized solution should still respect O(n^2) in the worst case, but attempt to make optimizations that improve performance on average. # Additional Instructions * Consider edge cases such as empty arrays or already-sorted arrays. * Include comments to explain the logic of the optimizations you implement. * Do not use Python\'s in-built sort functions or any other libraries. # Example ```python print(optimized_selection_sort([64, 25, 12, 22, 11])) # Output: [11, 12, 22, 25, 64] print(optimized_selection_sort([1, 2, 3, 4, 5])) # Output: [1, 2, 3, 4, 5] print(optimized_selection_sort([])) # Output: [] print(optimized_selection_sort([5, 4, 3, 2, 1])) # Output: [1, 2, 3, 4, 5] ``` # Hint for Optimization You might want to look into techniques like minimizing the swapping operations or handling already sorted or partially sorted data more efficiently.","solution":"def optimized_selection_sort(arr): Optimized version of the selection sort algorithm that performs sorting in-place with minimal memory overhead. n = len(arr) # Traverse through all array elements for i in range(n): # Initially set the first unsorted element as the minimum min_index = i already_sorted = True # Find the minimum element in remaining unsorted array for j in range(i+1, n): if arr[j] < arr[min_index]: min_index = j if arr[j] < arr[j-1]: already_sorted = False # Skip swapping if the i-th element is already the minimum element if min_index != i: # Swap the found minimum element with the first element arr[i], arr[min_index] = arr[min_index], arr[i] # If no elements were out of order, the array is already sorted if already_sorted: break return arr"},{"question":"# Scenario You have been tasked with developing a system that can generate all possible abbreviated forms of words. This could be useful for creating unique identifiers or simplifying lengthy names into shorter forms. # Task Implement the function `generate_abbreviations(word)` which takes a single input: * **word**: A string representing the word to be abbreviated (0 <= length of word <= 20). The function should return a list of all possible abbreviations for the given word. Each abbreviation can replace a sequence of one or more characters with their count of characters, but the abbreviation should still uniquely represent the original word. # Input * A single string `word`. # Output * A list of strings where each string is a valid abbreviation of `word`. # Constraints * The input string `word` will only contain lowercase English letters and will not exceed 20 characters in length. * Ensure that the solution generates all unique abbreviations. # Example Example 1 * Input: `\\"word\\"` * Output: `[\'word\', \'wor1\', \'wo1d\', \'wo2\', \'w1rd\', \'w1r1\', \'w2d\', \'w3\', \'1ord\', \'1or1\', \'1o1d\', \'1o2\', \'2rd\', \'2r1\', \'3d\', \'4\']` Example 2 * Input: `\\"ab\\"` * Output: `[\'ab\', \'1b\', \'a1\', \'2\']` # Performance Requirements Optimize your solution to handle the edge cases and aim to minimize both time and space complexity.","solution":"def generate_abbreviations(word): Generate all possible abbreviations for a given word. :param word: str :return: List of valid abbreviations def backtrack(pos, cur_abbr, count): if pos == len(word): if count > 0: cur_abbr += str(count) result.append(cur_abbr) else: # Include the character at pos backtrack(pos + 1, cur_abbr + (str(count) if count > 0 else \'\') + word[pos], 0) # Abbreviate the character at pos backtrack(pos + 1, cur_abbr, count + 1) result = [] backtrack(0, \\"\\", 0) return result"},{"question":"# Coding Problem: Priority Management for Task Scheduler Context You are building a task scheduler to handle various system tasks based on their urgency. The scheduler utilizes a min-heap for managing the task priorities efficiently. Task Implement a `TaskScheduler` class which extends a given `BinaryHeap` class. Your implementation should fulfill the following requirements: Core Methods 1. **add_task(priority, task_id)**: Adds a task identified by `task_id` with a given `priority` (lower number indicates higher priority). 2. **pop_next_task()**: Removes and returns the task id of the highest-priority task. Constraints - Task priorities are integers. - Task ids are unique strings. - Ensure efficient insertion and removal processes. - Handle the scenario with an empty task list gracefully when `pop_next_task` is called. Expected Methods and Format ```python class TaskScheduler(BinaryHeap): def __init__(self): super().__init__() def add_task(self, priority: int, task_id: str) -> None: Add a task into the scheduler. Args: - priority (int): The priority of the task. - task_id (str): The unique identifier of the task. Returns: - None pass def pop_next_task(self) -> str: Remove and return the next task id based on priority in the scheduler. Returns: - str: The task_id of the highest priority task. pass ``` Example ```python scheduler = TaskScheduler() scheduler.add_task(2, \'task_1\') scheduler.add_task(1, \'task_2\') scheduler.add_task(3, \'task_3\') assert scheduler.pop_next_task() == \'task_2\' assert scheduler.pop_next_task() == \'task_1\' assert scheduler.pop_next_task() == \'task_3\' ``` Performance Expectations - Both `add_task` and `pop_next_task` should run in O(log N). - The solution should handle a large number of tasks efficiently.","solution":"import heapq class BinaryHeap: def __init__(self): self.heap = [] def push(self, item): heapq.heappush(self.heap, item) def pop(self): if self.heap: return heapq.heappop(self.heap) return None class TaskScheduler(BinaryHeap): def __init__(self): super().__init__() def add_task(self, priority: int, task_id: str) -> None: Add a task into the scheduler. Args: - priority (int): The priority of the task. - task_id (str): The unique identifier of the task. Returns: - None self.push((priority, task_id)) def pop_next_task(self) -> str: Remove and return the next task id based on priority in the scheduler. Returns: - str: The task_id of the highest priority task. next_task = self.pop() if next_task: return next_task[1] return None # or raise an exception if you prefer"},{"question":"You are given a Segment Tree implementation that allows range queries and point updates with a commutative function. Your task is to extend the SegmentTree class to support a new type of query and perform various tasks as described below. # Tasks 1. **Extend the SegmentTree class to support range updates with a given commutative function**: - Implement a method `range_update(l, r, val)` that updates all elements from index `l` to `r` inclusive by applying the commutative function `fn` with `val`. 2. **Create a method to find the k-th smallest element within a range**: - Define a method `kth_smallest(l, r, k)` that finds the k-th smallest element within the range `[l, r]`. Assume the segment tree is constructed with an integer array. # Function Signatures ```python def range_update(self, l: int, r: int, val: Any) -> None: Apply \'fn\' on all elements from index l to r (inclusive) with \'val\'. pass def kth_smallest(self, l: int, r: int, k: int) -> int: Find the k-th smallest element in the range [l, r]. Assumes integer elements. pass ``` # Example ```python # Example initialization mytree = SegmentTree([1, 3, 5, 7, 9, 11], lambda a, b: a + b) # Example range update mytree.range_update(1, 3, 2) # Add 2 to each element from index 1 to 3 print(mytree.query(0, 5)) # Output should reflect the range update # Example finding the k-th smallest element print(mytree.kth_smallest(0, 5, 3)) # Find the 3rd smallest element in the range [0, 5] ``` # Constraints - Function `fn` will always be commutative and consider valid. - Array `arr` will have at most `10^5` elements. - Values in `arr` are integers within the range of `[-10^9, 10^9]`. Note: Ensure the solutions are efficient and handle edge cases correctly.","solution":"import bisect class SegmentTree: def __init__(self, arr, fn): n = len(arr) self.n = n self.tree = [0] * (2 * n) self.fn = fn for i in range(n): self.tree[n + i] = arr[i] for i in range(n - 1, 0, -1): self.tree[i] = self.fn(self.tree[2 * i], self.tree[2 * i + 1]) def update(self, index, val): index += self.n self.tree[index] = val while index > 1: index //= 2 self.tree[index] = self.fn(self.tree[2 * index], self.tree[2 * index + 1]) def query(self, l, r): l += self.n r += self.n + 1 res = 0 while l < r: if l % 2: res = self.fn(res, self.tree[l]) l += 1 if r % 2: r -= 1 res = self.fn(res, self.tree[r]) l //= 2 r //= 2 return res def range_update(self, l, r, val): for i in range(l, r + 1): self.update(i, self.fn(self.tree[self.n + i], val)) def kth_smallest(self, l, r, k): # Extract the subarray [l, r] and sort it to find the k-th smallest element subarray = [self.tree[self.n + i] for i in range(l, r + 1)] subarray.sort() return subarray[k - 1] # Example usage (for reference): # mytree = SegmentTree([1, 3, 5, 7, 9, 11], lambda a, b: a + b) # mytree.range_update(1, 3, 2) # Add 2 to each element from index 1 to 3 # print(mytree.query(0, 5)) # Output should reflect the range update # print(mytree.kth_smallest(0, 5, 3)) # Find the 3rd smallest element in the range [0, 5]"},{"question":"# Word Pattern Matching In a language processing application, it\'s often necessary to determine if a given text abides by a specified pattern. This pattern detection can be crucial for tasks such as text validation, input matching, and protocol adherence. Given a pattern and a string `text`, your task is to write a function that determines if `text` follows the same pattern. **Function Signature**: ```python def word_pattern(pattern: str, text: str) -> bool: pass ``` **Input**: - A string `pattern` containing only lowercase letters. - A string `text`, where words are separated by a single space. **Output**: - Return `True` if the text follows the same pattern, `False` otherwise. **Constraints**: - The pattern will not exceed 1000 characters. - The text will not exceed 1000 words. - Each word in `text` is separated by a single space and contains only lowercase letters. **Performance Requirements**: - The function should handle inputs efficiently within O(n) time complexity where n is the length of the text. **Examples**: 1. Input: `pattern = \\"abba\\"`, `text = \\"dog cat cat dog\\"` Output: `True` 2. Input: `pattern = \\"abba\\"`, `text = \\"dog cat cat fish\\"` Output: `False` 3. Input: `pattern = \\"aaaa\\"`, `text = \\"dog cat cat dog\\"` Output: `False` 4. Input: `pattern = \\"abba\\"`, `text = \\"dog dog dog dog\\"` Output: `False` **Scenario**: You\'re developing a text matching engine that needs to validate whether given text input follows a predefined pattern. The pattern matching ensures that the template specified is adhered to without any mismatches. **Edge Cases to Consider**: - Patterns with repetitive characters. - Text with repetitive words. - Different lengths of pattern and text (e.g., pattern with 4 characters but text with 3 words). Write the function `word_pattern` implementing the described behavior.","solution":"def word_pattern(pattern: str, text: str) -> bool: words = text.split() if len(pattern) != len(words): return False char_to_word = {} word_to_char = {} for p, w in zip(pattern, words): if p not in char_to_word: if w in word_to_char: return False char_to_word[p] = w word_to_char[w] = p else: if char_to_word[p] != w: return False return True"},{"question":"# Red-Black Tree: Range Sum Query Context A Red-Black Tree is a self-balancing binary search tree where nodes can be red or black. To maintain balance, the tree uses rotations and changes in the color of nodes. You are required to implement a function to perform a range sum query on this RB Tree. Objective Given a Red-Black Tree and a range [low, high], write a function to calculate the sum of all node values within this range, inclusive of boundaries. Input and Output Format * **Function signature**: `def range_sum(rb_tree: RBTree, low: int, high: int) -> int:` * **Input**: * `rb_tree` (RBTree): An instance of the Red-Black Tree. * `low` (int): The lower bound of the range. * `high` (int): The upper bound of the range. * **Output**: * Returns an integer representing the sum of all values in the range [low, high]. Constraints 1. All node values are distinct integers. 2. You may assume that the bounds `low` and `high` are within the range of existing node values in the tree. Example ```python # Example usage: rb = RBTree() values = [10, 5, 1, 7, 40, 50] for val in values: rb.insert(RBNode(val, 1)) print(range_sum(rb, 5, 40)) # Expected output: 62 (5 + 7 + 10 + 40) print(range_sum(rb, 7, 50)) # Expected output: 107 (7 + 10 + 40 + 50) ``` Notes 1. The function should maintain the properties of the Red-Black Tree post-query. 2. You may use helper functions as needed.","solution":"class RBNode: def __init__(self, data, color, left=None, right=None, parent=None): self.data = data self.color = color # 0 for black, 1 for red self.left = left self.right = right self.parent = parent class RBTree: def __init__(self): self.TNULL = RBNode(0, 0) self.root = self.TNULL def insert(self, key): node = RBNode(key, 1, self.TNULL, self.TNULL, None) self._insert(node) def _insert(self, node): # Insert a regular BST node first parent, current = None, self.root while current != self.TNULL: parent = current if node.data < current.data: current = current.left else: current = current.right node.parent = parent if parent is None: self.root = node elif node.data < parent.data: parent.left = node else: parent.right = node if node.parent is None: node.color = 0 return self._fix_insert(node) def _fix_insert(self, node): # Red-Black Tree balancing code after insertion pass def _range_sum(self, node, low, high): if node == self.TNULL: return 0 sum_left = self._range_sum(node.left, low, high) sum_right = self._range_sum(node.right, low, high) current_value = node.data if low <= node.data <= high else 0 return sum_left + sum_right + current_value def range_sum(rb_tree, low, high): return rb_tree._range_sum(rb_tree.root, low, high)"},{"question":"Rotate Linked List **Objective**: Implement a function to rotate a singly linked list to the right by k places. **Function Signature**: ```python def rotate_right(head: ListNode, k: int) -> ListNode: pass ``` **Input/Output Formats**: * Input: * `head`: The head node of a singly linked list. * `k`: A non-negative integer representing the number of positions to rotate the list. * Output: * Returns the head node of the rotated linked list. **Constraints**: * The linked list can have between 0 and 10^4 nodes. * -The value of each node is an integer within the range of -10^4 to 10^4. * `k` is a non-negative integer and can be large. **Performance Requirements**: * Solution must run in O(n) time complexity, where n is the number of nodes in the linked list. * Solution must use O(1) extra space. **Scenario**: Consider a list of integers where each integer is part of a node in a singly linked list. This function needs to adjust the ordering of these nodes by rotating the list to the right `k` times. This can be particularly useful for data that needs reordering or cyclic shifts efficiently, such as in certain network operations or scheduling systems. **Example**: ```python # Example of ListNode class for reference class ListNode: def __init__(self, x): self.val = x self.next = None # Additional Example # Given the linked list: 1 -> 2 -> 3 -> 4 -> 5 and k = 2, # The function should return: 4 -> 5 -> 1 -> 2 -> 3 # Example: head = ListNode(1) head.next = ListNode(2) head.next.next = ListNode(3) head.next.next.next = ListNode(4) head.next.next.next.next = ListNode(5) k = 2 rotated_head = rotate_right(head, k) # This should result in the linked list starting with node 4 -> node 5 -> node 1 -> node 2 -> node 3 ``` **Edge Cases to Consider**: * Empty list. * `k` being a multiple of the list length. * Single element list. * `k` being zero. Your implementation should handle these cases efficiently.","solution":"class ListNode: def __init__(self, x): self.val = x self.next = None def rotate_right(head: ListNode, k: int) -> ListNode: if not head or not head.next or k == 0: return head # First, determine the length of the linked list length = 1 current = head while current.next: current = current.next length += 1 # Connect the last node to the head to create a circular linked list current.next = head # Compute the effective rotation needed k = k % length steps_to_new_head = length - k # Find the new head and tail new_tail = head for _ in range(steps_to_new_head - 1): new_tail = new_tail.next new_head = new_tail.next # Break the circular linked list new_tail.next = None return new_head"},{"question":"# FizzBuzz Advanced Variation The classic FizzBuzz problem involves replacing certain numbers based on their divisibility by 3 and 5. In this advanced variation, you will write a function that processes an array where each element can be either an integer or a string. The function should perform the following operations: 1. For each integer in the array, replace it with: - \\"Fizz\\" if it is a multiple of 3. - \\"Buzz\\" if it is a multiple of 5. - \\"FizzBuzz\\" if it is a multiple of both 3 and 5. 2. For each string in the array, replace it with its reverse. 3. Return the modified array. # Input and Output Format **Input**: A list `arr` of mixed integers and strings. **Output**: A list with the same size as `arr`, where: - Integers are replaced according to the FizzBuzz rules. - Strings are replaced by their reverse. # Constraints - The length of `arr` will be between 1 and 10^5 - Integers in the array will be between 1 and 10^9 - Strings will contain only ASCII characters and will have a length between 1 and 100 # Function Signature ```python def fizzbuzz_advanced(arr: List[Union[int, str]]) -> List[Union[int, str]]: ``` # Example ```python # Example 1: input_array = [3, 5, 15, \\"hello\\", \\"world\\"] output_array = fizzbuzz_advanced(input_array) print(output_array) # Output: [\\"Fizz\\", \\"Buzz\\", \\"FizzBuzz\\", \\"olleh\\", \\"dlrow\\"] # Example 2: input_array = [1, 2, \\"abc\\", 9, 10, \\"xyz\\"] output_array = fizzbuzz_advanced(input_array) print(output_array) # Output: [1, 2, \\"cba\\", \\"Fizz\\", \\"Buzz\\", \\"zyx\\"] ``` **Note**: Pay attention to performance requirements given constraint sizes.","solution":"from typing import List, Union def fizzbuzz_advanced(arr: List[Union[int, str]]) -> List[Union[str, int]]: result = [] for element in arr: if isinstance(element, int): if element % 15 == 0: result.append(\\"FizzBuzz\\") elif element % 3 == 0: result.append(\\"Fizz\\") elif element % 5 == 0: result.append(\\"Buzz\\") else: result.append(element) elif isinstance(element, str): result.append(element[::-1]) return result"},{"question":"You have been given an implementation of the Interpolation Search algorithm. Your task is to implement a function that uses this algorithm to find multiple search keys in a sorted array. Specifically, you need to return a list of indices corresponding to each search key. If a search key is not present in the array, -1 should be returned for that key. # Function Signature ```python def multi_interpolation_search(array: List[int], search_keys: List[int]) -> List[int]: ``` # Input * `array`: A sorted list (in ascending order) of integers. (1 ≤ len(array) ≤ 10^5) * `search_keys`: A list of integers representing the keys to be searched in `array`. (1 ≤ len(search_keys) ≤ 10^3) # Output * A list of integers where each element is the index of the corresponding search key in the input `array`. If a search key is not found, return -1 for that search key. # Constraints * The `array` list will always be sorted in non-decreasing order. * The integer values in both `array` and `search_keys` will be between -10^6 and 10^6 inclusive. # Example ```python >>> multi_interpolation_search([5, 10, 12, 14, 17, 20, 21], [10, 55, 12, -5]) [1, -1, 2, -1] >>> multi_interpolation_search([-25, -12, -1, 10, 12, 15, 20, 41, 55], [41, 10, -1]) [7, 3, 2] ``` # Explanation * For the first example, the search keys `10`, `55`, `12` and `-5` are searched in the array `[5, 10, 12, 14, 17, 20, 21]`. - The index of `10` is `1`. - The index of `55` is `-1` (not present in `array`). - The index of `12` is `2`. - The index of `-5` is `-1` (not present in `array`). * For the second example, the search keys `41`, `10`, and `-1` are searched in the array `[-25, -12, -1, 10, 12, 15, 20, 41, 55]`. - The index of `41` is `7`. - The index of `10` is `3`. - The index of `-1` is `2`. Note: Use the provided `interpolation_search` function within your implementation to accomplish this task.","solution":"from typing import List def interpolation_search(array: List[int], key: int) -> int: low = 0 high = len(array) - 1 while low <= high and array[low] <= key <= array[high]: if low == high: if array[low] == key: return low return -1 pos = low + ((high - low) // (array[high] - array[low]) * (key - array[low])) if array[pos] == key: return pos if array[pos] < key: low = pos + 1 else: high = pos - 1 return -1 def multi_interpolation_search(array: List[int], search_keys: List[int]) -> List[int]: results = [] for key in search_keys: index = interpolation_search(array, key) results.append(index) return results"},{"question":"# Coding Challenge: Incrementing a Digit Array Problem Description You are given a non-negative number represented as a list of digits in a big-endian format (most significant digit at the head of the list). Write a function to increment the number by one. Function Signature ```python def increment_digit_array(digits: List[int]) -> List[int]: ``` Input Format * A list of integers `digits` where each integer is between 0 and 9, inclusive. * Example Input: `[1, 2, 3]` Output Format * A list of integers representing the incremented number. * Example Output: `[1, 2, 4]` Constraints * The input list will not be empty and will contain only non-negative integers. * The number will not have leading zeros except for the number 0 itself, which is represented by `[0]`. Performance Requirements * The algorithm should run in O(n) time, where n is the number of digits in the list. * The space complexity should be optimized as O(1) if possible. Example Scenarios * Example 1: - Input: `[1, 2, 3]` - Output: `[1, 2, 4]` * Example 2: - Input: `[9, 9, 9]` - Output: `[1, 0, 0, 0]` Additional Notes Your solution should handle edge cases such as carry propagation correctly. **Hint**: Work from the least significant digit to the most significant digit and carefully manage the carry.","solution":"from typing import List def increment_digit_array(digits: List[int]) -> List[int]: This function takes a list of digits representing a non-negative number and returns a new list representing the number incremented by one. n = len(digits) carry = 1 # We are incrementing by 1 for i in range(n-1, -1, -1): new_digit = digits[i] + carry if new_digit == 10: digits[i] = 0 carry = 1 else: digits[i] = new_digit carry = 0 break if carry: digits.insert(0, 1) return digits"},{"question":"# Find the Smallest Element Greater Than Target Problem Statement You are given a list of sorted lowercase letters and a target lowercase letter. Your task is to find the smallest letter in the list that is larger than the given target. The list of letters is circular, which means that if the target is greater than all elements in the list, the search should wrap around and return the smallest element in the list. Function Signature ```python def find_next_letter(letters: List[str], target: str) -> str: ``` Input * `letters`: A list of sorted lowercase letters. Example: `[\'c\', \'f\', \'j\']` * `target`: A single lowercase letter. Example: `\'a\'` Output * Return the smallest letter in the list that is larger than the given target. Constraints * The length of `letters` is in the range [2, 10^4]. * `letters` contains only lowercase letters. * `target` is a single lowercase letter. * The letters in `letters` are sorted in increasing order. * The letters in `letters` may wrap around. Example ```python # Example 1 letters = [\\"c\\", \\"f\\", \\"j\\"] target = \\"a\\" output = \\"c\\" # Example 2 letters = [\\"c\\", \\"f\\", \\"j\\"] target = \\"c\\" output = \\"f\\" # Example 3 letters = [\\"c\\", \\"f\\", \\"j\\"] target = \\"d\\" output = \\"f\\" ``` Guidelines 1. The solution should handle edge cases where the target is greater than the largest element in the list or smaller than the smallest element. 2. The algorithm should be efficient and handle the upper constraint limits effectively. 3. Consider using optimized search techniques like binary search if possible.","solution":"from typing import List def find_next_letter(letters: List[str], target: str) -> str: Returns the smallest letter in the list that is larger than the given target. Since the list is circular, if the target is greater than all elements in the list, the search should wrap around and return the smallest element in the list. left, right = 0, len(letters) - 1 # If target is greater than or equal to the last letter or less than the first letter if target >= letters[-1] or target < letters[0]: return letters[0] # Binary search while left <= right: mid = (left + right) // 2 if letters[mid] > target: right = mid - 1 else: left = mid + 1 return letters[left]"},{"question":"**Decoding Encoded Messages** You are working on a language decoding application. The app receives messages encoded as digits \'1\' through \'26\', which map to letters \'A\' through \'Z\' (\'1\' -> \'A\', \'2\' -> \'B\', ..., \'26\' -> \'Z\'). Your task is to implement a function that determines the number of ways to decode an encoded message. The encoded message can only use digits \'0\'-\'9\'. An encoded message containing \'0\' is invalid unless the \'0\' is part of \'10\' or \'20\'. Each character or pair of characters must map to a letter as follows: \'A\' -> 1 \'B\' -> 2 ... \'Z\' -> 26 **Function Prototype:** ```python def num_decodings(encoded_message: str) -> int: ``` **Input:** * `encoded_message` (str): A string of digits representing an encoded message (1 ≤ len(encoded_message) ≤ 100). **Output:** * (int): The number of ways to decode the given message. **Constraints:** * The encoded message will not be empty and will not start with \'0\'. * The mapping is only valid for `1` to `26`. **Examples:** 1. `num_decodings(\\"12\\")` should return `2` (can be decoded as \\"AB\\" or \\"L\\"). 2. `num_decodings(\\"226\\")` should return `3` (can be decoded as \\"BZ\\", \\"VF\\", or \\"BBF\\"). 3. `num_decodings(\\"06\\")` should return `0` (invalid message). **Edge Cases to Consider:** * `num_decodings(\\"\\")` should return `0` (empty string). * `num_decodings(\\"0\\")` should return `0` (invalid input). * `num_decodings(\\"10\\")` should return `1` (can only be decoded as \\"J\\"). Implement your solution using dynamic programming to ensure optimal performance.","solution":"def num_decodings(encoded_message: str) -> int: if not encoded_message or encoded_message[0] == \'0\': return 0 n = len(encoded_message) dp = [0] * (n + 1) dp[0] = 1 # base case: an empty string has one way to be decoded for i in range(1, n + 1): if encoded_message[i-1] != \'0\': dp[i] += dp[i-1] if i > 1 and encoded_message[i-2] == \'1\' or (encoded_message[i-2] == \'2\' and encoded_message[i-1] <= \'6\'): dp[i] += dp[i-2] return dp[n]"},{"question":"Increment a Large Number Represented as an Array **Scenario**: You are working with a large integer represented as an array of its digits. Each digit is an element of the array, and the number is stored in a big-endian fashion, meaning the most significant digit is at the head of the list. Your task is to add one to this number and return the resulting array of digits. # Function Signature ```python def increment_array_number(digits: List[int]) -> List[int]: pass ``` # Input * `digits`: A list of non-negative integers where each integer is a digit (0-9). * 1 <= len(digits) <= 10^5 # Output * Return a list of integers representing the incremented number. # Constraints * The input array will not contain leading zeros. * You must handle the addition in place whenever possible to achieve O(1) space complexity. * The solution should run in O(n) time complexity. # Example Example 1: ```python Input: [1, 2, 3] Output: [1, 2, 4] Explanation: 123 + 1 = 124 ``` Example 2: ```python Input: [9, 9, 9] Output: [1, 0, 0, 0] Explanation: 999 + 1 = 1000 ``` Example 3: ```python Input: [0] Output: [1] Explanation: 0 + 1 = 1 ``` # Notes * Do not use built-in functions for large number arithmetic. * Consider edge cases such as zero, single digit increment, and overflow requiring an additional digit. * Aim for clear and efficient code implementing the solution in-place when possible.","solution":"from typing import List def increment_array_number(digits: List[int]) -> List[int]: Increments a large number represented as an array of digits. n = len(digits) # Start from the last digit and move backwards for i in range(n-1, -1, -1): if digits[i] < 9: # If the current digit is not 9, just increment it by one digits[i] += 1 return digits else: # If the current digit is 9, set it to 0 and continue to the next digit digits[i] = 0 # If all the digits are 9, we need an extra digit at the beginning return [1] + digits"},{"question":"# FizzBuzz Divisibility Function You are required to implement the famous FizzBuzz problem, which uses a simple iteration and modulus operation to determine certain replacements in an output sequence. Function Signature: `def fizzbuzz(n: int) -> list:` Input: - `n` (int): A positive integer greater than zero. Output: - `list`: A list of integers and strings where: * Each multiple of 3 is replaced by \'Fizz\'. * Each multiple of 5 is replaced by \'Buzz\'. * Each multiple of both 3 and 5 is replaced by \'FizzBuzz\'. * Other numbers remain unchanged as integers. Constraints: - The function must handle the divisibility conditions without manual conditions (use modulus operations). - The function should return values complying with the given rules precisely. - Raise an appropriate error if the provided value for `n` is not valid (e.g., if less than 1, raise a `ValueError`). Example: ```python assert fizzbuzz(1) == [1] assert fizzbuzz(5) == [1, 2, \'Fizz\', 4, \'Buzz\'] assert fizzbuzz(15) == [1, 2, \'Fizz\', 4, \'Buzz\', \'Fizz\', 7, 8, \'Fizz\', \'Buzz\', 11, \'Fizz\', 13, 14, \'FizzBuzz\'] ``` Implement the `fizzbuzz` function to complete this task.","solution":"def fizzbuzz(n: int) -> list: Returns a list of integers and strings based on the FizzBuzz rules: - Multiples of 3 are replaced by \'Fizz\' - Multiples of 5 are replaced by \'Buzz\' - Multiples of both 3 and 5 are replaced by \'FizzBuzz\' if n < 1: raise ValueError(\\"Input must be a positive integer greater than zero.\\") result = [] for i in range(1, n+1): if i % 15 == 0: result.append(\'FizzBuzz\') elif i % 3 == 0: result.append(\'Fizz\') elif i % 5 == 0: result.append(\'Buzz\') else: result.append(i) return result"},{"question":"You are climbing a stair case. It takes `steps` number of steps to reach to the top. Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top? Implement the function `climb_stairs(steps: int) -> int` that determines the number of distinct ways to reach the top. # Input: * An integer `steps` (1 ≤ steps ≤ 10^5) representing the number of steps to reach the top. # Output: * An integer representing the number of distinct ways to reach the top. # Constraints: 1. You can assume that `steps` is a positive integer. 2. Your solution should be efficient enough to handle large values for `steps` up to 100,000. # Examples: 1. **Input:** steps = 2 **Output:** 2 **Explanation:** There are two ways to climb to the top: 1+1, 2. 2. **Input:** steps = 3 **Output:** 3 **Explanation:** There are three ways to climb to the top: 1+1+1, 1+2, 2+1. 3. **Input:** steps = 5 **Output:** 8 **Explanation:** There are eight ways to climb to the top: 1+1+1+1+1, 1+1+1+2, 1+1+2+1, 1+2+1+1, 2+1+1+1, 2+1+2, 1+2+2, 2+2+1. --- # Implementation: Implement the following function in Python: ```python def climb_stairs(steps: int) -> int: # Your implementation here pass ``` # Performance Requirements: * Time Complexity: O(n) * Space Complexity: O(1)","solution":"def climb_stairs(steps: int) -> int: if steps == 1: return 1 # Initialize the base cases first, second = 1, 2 # Compute the number of ways to reach each step from 3 to steps for i in range(3, steps + 1): third = first + second first = second second = third return second if steps > 1 else first"},{"question":"Question: Write a function called `highlight_matching_symbols` which takes in an array of words and an array of symbols. The goal of the function is to return an array where every word is modified to highlight certain symbols within the word by surrounding them with square brackets `[ ]`. Important criteria for the function are: 1. Each word should have only one symbol bracketed. 2. If a word contains multiple symbols, choose the one with the longest length. You should implement the Trie data structure to aid with efficient matching of symbols in the words. Function Signature: ```python def highlight_matching_symbols(words: List[str], symbols: List[str]) -> List[str]: pass ``` Input: - `words`: A list of strings, where each string is a word. - `symbols`: A list of strings, where each string is a symbol. Output: - Return a list of strings where each word has the matched symbol (if any) surrounded with square brackets `[ ]`. Constraints: - Length of words array: 1 <= |words| <= 10^3 - Length of symbols array: 1 <= |symbols| <= 10^3 - Length of individual word or symbol <= 100 Example: ```python words = [\'Amazon\', \'Microsoft\', \'Google\'] symbols = [\'i\', \'Am\', \'cro\', \'Na\', \'le\', \'abc\'] highlight_matching_symbols(words, symbols) # Output: [\'[Am]azon\', \'Mi[cro]soft\', \'Goog[le]\'] ``` You are required to use an efficient algorithm that would ideally run faster than O(N^2).","solution":"from typing import List, Dict # Define the TrieNode class class TrieNode: def __init__(self): self.children: Dict[str, TrieNode] = {} self.word = None class Trie: def __init__(self): self.root = TrieNode() # Function to insert words into the trie def insert(self, word: str): current = self.root for letter in word: if letter not in current.children: current.children[letter] = TrieNode() current = current.children[letter] current.word = word # Function to search the longest matching word in the trie from a given word def search_longest(self, word: str) -> str: current = self.root max_length_word = \\"\\" for letter in word: if letter in current.children: current = current.children[letter] if current.word and len(current.word) > len(max_length_word): max_length_word = current.word else: break return max_length_word def highlight_matching_symbols(words: List[str], symbols: List[str]) -> List[str]: trie = Trie() # Insert all symbols into the trie for symbol in symbols: trie.insert(symbol) modified_words = [] for word in words: # Search for the longest matching symbol in the current word longest_match = \\"\\" for i in range(len(word)): match = trie.search_longest(word[i:]) if match and len(match) > len(longest_match): longest_match = match # If a match is found, modify the word accordingly if longest_match: index = word.find(longest_match) modified_word = word[:index] + \\"[\\" + longest_match + \\"]\\" + word[index + len(longest_match):] modified_words.append(modified_word) else: modified_words.append(word) return modified_words"},{"question":"# Matrix Transformation Challenge Imagine you are working on an application that requires various transformations of matrix data. You need to implement a set of functions to rotate the matrices both clockwise and counterclockwise, and to invert them along various diagonals. Function Signature * `def rotate_clockwise(matrix: List[List[int]]) -> List[List[int]]` * `def rotate_counterclockwise(matrix: List[List[int]]) -> List[List[int]]` * `def top_left_invert(matrix: List[List[int]]) -> List[List[int]]` * `def bottom_left_invert(matrix: List[List[int]]) -> List[List[int]]` Input and Output Formats * **Input**: A matrix represented as a list of lists of integers. * **Output**: A new matrix which is the rotated or inverted version of the input matrix. Constraints * The input matrix will have at least one row and one column (i.e., it will not be empty). * The input matrix can be non-square, with different numbers of rows and columns. # Task Implement the following functions: 1. `rotate_clockwise(matrix: List[List[int]]) -> List[List[int]]`: This should produce a matrix rotated 90 degrees clockwise. 2. `rotate_counterclockwise(matrix: List[List[int]]) -> List[List[int]]`: This should produce a matrix rotated 90 degrees counterclockwise. 3. `top_left_invert(matrix: List[List[int]]) -> List[List[int]]`: This should transpose the upper triangle of the matrix. 4. `bottom_left_invert(matrix: List[List[int]]) -> List[List[int]]`: This should reverse and transpose the lower triangle of the matrix. # Example Consider the following initial matrix: ```python matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9], ] ``` The expected outputs are: 1. Rotate Clockwise: ```python [ [7, 4, 1], [8, 5, 2], [9, 3, 0], ] ``` 2. Rotate Counterclockwise: ```python [ [3, 6, 9], [2, 5, 8], [1, 4, 7], ] ``` 3. Top Left Invert: ```python [ [1, 4, 7], [2, 5, 8], [3, 6, 9], ] ``` 4. Bottom Left Invert: ```python [ [9, 6, 3], [8, 5, 2], [7, 4, 1], ] ``` Performance Requirements * The algorithms should be efficient with a time complexity not exceeding O(n * m), where n is the number of rows and m is the number of columns. * Use additional space efficiently, ideally not exceeding O(n * m) for creating new matrices.","solution":"from typing import List def rotate_clockwise(matrix: List[List[int]]) -> List[List[int]]: Rotates matrix 90 degrees clockwise. return [list(row) for row in zip(*matrix[::-1])] def rotate_counterclockwise(matrix: List[List[int]]) -> List[List[int]]: Rotates matrix 90 degrees counterclockwise. return [list(row) for row in zip(*matrix)][::-1] def top_left_invert(matrix: List[List[int]]) -> List[List[int]]: Transposes the upper triangle of the matrix. return [[matrix[j][i] for j in range(len(matrix))] for i in range(len(matrix[0]))] def bottom_left_invert(matrix: List[List[int]]) -> List[List[int]]: Reverses and transposes the lower triangle of the matrix. return [[matrix[len(matrix) - 1 - j][len(matrix[0]) - 1 - i] for j in range(len(matrix))] for i in range(len(matrix[0]))]"},{"question":"You are given an array of integers and you need to perform a series of range queries. To optimize these queries, you need to implement a **Segment Tree**. Segment Tree Requirements 1. **Building the Tree**: Write a method to build the segment tree using a custom function (e.g., sum, max). 2. **Range Query**: Write a method to process range queries using the segment tree. 3. **Update Value**: Write a method to update the value at a given index and reflect this change in the tree. Here\'s a template for the `SegmentTree` class: ```python class SegmentTree: def __init__(self, arr, function): self.segment = [0 for x in range(3 * len(arr) + 3)] self.arr = arr self.fn = function self.make_tree(0, 0, len(arr) - 1) def make_tree(self, i, l, r): # Implement this method to build the segment tree pass def __query(self, i, L, R, l, r): # Implement this method to handle internal query logic pass def query(self, L, R): # Public method to perform range query return self.__query(0, 0, len(self.arr) - 1, L, R) def update(self, index, value): # Implement this method to update the value at index and reflect in the tree pass ``` # Expected Input and Output Formats: Input - The constructor takes two arguments: * `arr`: A list of integers. * `function`: A function (like sum, max) that operates on two values and returns one value. - `query` Method: * Takes two arguments, `L`, `R` for the range. * Returns the aggregate result (like sum or max) over the range `arr[L:R+1]`. - `update` Method: * Takes two arguments, `index` to be updated and `value` for the new value. Output - Result of range queries as per the custom function applied to the array range. Constraints - `1 <= len(arr) <= 10^5` - The range values `L, R` are within the bounds of the array. - The update method will only be called for valid indices. # Example ```python # Sum function Segment Tree arr = [1, 2, 3, 4, 5] segment_tree = SegmentTree(arr, sum) print(segment_tree.query(1, 3)) # Output: 9 (2+3+4) segment_tree.update(2, 8) print(segment_tree.query(1, 3)) # Output: 14 (2+8+4) # Max function Segment Tree arr = [1, 2, 3, 4, 5] segment_tree = SegmentTree(arr, max) print(segment_tree.query(1, 3)) # Output: 4 segment_tree.update(2, 8) print(segment_tree.query(1, 3)) # Output: 8 ```","solution":"class SegmentTree: def __init__(self, arr, function): self.arr = arr self.fn = function self.n = len(arr) self.segment = [0] * (4 * self.n) self.build(0, 0, self.n - 1) def build(self, node, start, end): if start == end: # Leaf node will have a single element self.segment[node] = self.arr[start] else: mid = (start + end) // 2 # Recursively build the segment tree self.build(2 * node + 1, start, mid) self.build(2 * node + 2, mid + 1, end) # Internal node will have the result of the function self.segment[node] = self.fn(self.segment[2 * node + 1], self.segment[2 * node + 2]) def __query(self, node, start, end, L, R): if R < start or L > end: # range represented by a node is completely outside the given range return None if L <= start and end <= R: # range represented by a node is completely inside the given range return self.segment[node] # range represented by a node is partially inside and partially outside the given range mid = (start + end) // 2 left_query = self.__query(2 * node + 1, start, mid, L, R) right_query = self.__query(2 * node + 2, mid + 1, end, L, R) if left_query is None: return right_query if right_query is None: return left_query return self.fn(left_query, right_query) def query(self, L, R): return self.__query(0, 0, self.n - 1, L, R) def update_value(self, node, start, end, idx, value): if start == end: # Leaf node self.segment[node] = value else: mid = (start + end) // 2 if start <= idx <= mid: # If idx is in the left child, recur self.update_value(2 * node + 1, start, mid, idx, value) else: # If idx is in the right child, recur self.update_value(2 * node + 2, mid + 1, end, idx, value) # Internal node will have the result of the function self.segment[node] = self.fn(self.segment[2 * node + 1], self.segment[2 * node + 2]) def update(self, idx, value): self.update_value(0, 0, self.n - 1, idx, value) self.arr[idx] = value"},{"question":"Calculating Combinations Efficiently You are tasked with writing a function that calculates the number of ways to choose r items from n distinct items (combinatorial selection). This is commonly represented as `nCr` or the binomial coefficient. Requirements: - Implement the solution optimally with dynamic programming techniques. - Employ memoization to avoid redundant calculations. Implementation Details: 1. **Function Signature**: ```python def combination_memo(n: int, r: int) -> int: ``` 2. **Input**: * `n` (int): The total number of items (0 <= n <= 1000). * `r` (int): The number of items to choose (0 <= r <= 1000). 3. **Output**: * Returns the number of combinations `nCr`. 4. **Constraints**: * You must handle cases where `r > n` (return 0). * Optimize for both time and space complexity. 5. **Examples**: ```python assert combination_memo(5, 2) == 10 assert combination_memo(6, 0) == 1 assert combination_memo(20, 10) == 184756 assert combination_memo(5, 8) == 0 ``` Scenario: A robotics team is selecting members for a specific task. They need to decide how many different ways they can choose a subset of the members for different project groups. Your function will help them efficiently compute these combinations for any given values of `n` and `r`.","solution":"def combination_memo(n: int, r: int) -> int: Calculate the number of combinations (nCr) using dynamic programming with memoization. # Quickly handle the straightforward cases if r > n: return 0 if r == 0 or r == n: return 1 # Initialize memoization array memo = [[0 for _ in range(r + 1)] for _ in range(n + 1)] # Fill the memoization array for i in range(n + 1): for j in range(min(i, r) + 1): if j == 0 or j == i: memo[i][j] = 1 # Base cases: nC0 = nCn = 1 else: memo[i][j] = memo[i - 1][j - 1] + memo[i - 1][j] return memo[n][r]"},{"question":"You\'ve been tasked to extend a factorial calculation function to handle a list of integers, each potentially requiring the result to be taken modulo some number. **Task**: Write a function `factorial_list(numbers: List[int], mod: int = None) -> List[int]` that takes a list of non-negative integers and an optional positive integer `mod`. The function should return a list of factorials of each input number, applying the modulo operation if `mod` is provided. **Input**: - A list `numbers` containing non-negative integers (0 ≤ `numbers[i]` ≤ 1000). - An optional integer `mod` representing a positive modulus (1 ≤ `mod` ≤ 10^9). **Output**: - A list of integers representing the factorial of each number in the input list, with each result taken modulo `mod` if provided. **Constraints**: - Do not use external libraries for factorial calculation. - Ensure the function handles large numbers efficiently with modulo arithmetic, preventing overflow. **Example**: ```python factorial_list([0, 1, 2, 3, 5], mod=100) ``` should return `[1, 1, 2, 6, 20]`. Provide solutions using both iterative and recursive approach for the factorial calculation as parts of your answer. **Performance Requirements**: - Your solution should efficiently handle the upper bounds for input constraints. - Consider edge cases and ensure input validation is encompassed within your solution.","solution":"from typing import List, Optional def factorial(n: int, mod: Optional[int] = None) -> int: result = 1 for i in range(1, n + 1): result *= i if mod: result %= mod return result def factorial_list(numbers: List[int], mod: Optional[int] = None) -> List[int]: return [factorial(num, mod) for num in numbers]"},{"question":"# Linear Search Algorithm in Arrays - Student Implementation Task Objective: Implement a linear search algorithm to find the index of a specified element in an array. # Problem Statement: You are given an array of integers and a target integer. Your task is to write a function named `linear_search` that implements the linear search algorithm to find the index of the target in the array. If the target is not found, the function should return -1. # Function Signature: ```python def linear_search(array: list[int], target: int) -> int: pass ``` # Input: - `array` (list of int): A list of integers where you need to search for the target. - `target` (int): An integer value you are searching for in the array. # Output: - Returns an integer representing the index of the target in the array, or -1 if the target is not found. # Constraints: - The array length will be between 1 and 10^5. - The array elements will be between -10^6 and 10^6. - The target will be between -10^6 and 10^6. # Example: ```python assert linear_search([2, 3, 5, 7, 11], 7) == 3 assert linear_search([1, 2, 3, 4, 5], 6) == -1 assert linear_search([], 1) == -1 assert linear_search([7, 8, 9, 10], 7) == 0 assert linear_search([10, 20, 30, 40], 40) == 3 ``` # Performance Requirement: Ensure that your implementation handles the worst-case scenario efficiently within the given constraints. # Note: 1. Pay attention to edge cases like empty arrays or arrays where the target element might not be present. 2. The order of elements in the array is not guaranteed to be sorted.","solution":"def linear_search(array: list[int], target: int) -> int: This function implements the linear search algorithm to find the index of the target in the array. If the target is not found, the function returns -1. Parameters: array (list[int]): The list of integers to search within. target (int): The integer value to search for. Returns: int: The index of the target if found, otherwise -1. for index, element in enumerate(array): if element == target: return index return -1"},{"question":"Implement a variant of the Comb Sort algorithm that includes additional optimizations for performance. In this task, you will write a function `optimized_comb_sort` to sort an array. You should consider key factors such as the shrink factor and initial gap size to ensure the algorithm efficiently handles various input sizes and types. Function Signature ```python def optimized_comb_sort(arr: list) -> list: pass ``` Input - `arr`: a list of integers that needs to be sorted. Output - The function should return a sorted list of integers. Constraints 1. The length of the array, `N`, can be up to `10^5`. 2. The array can contain both positive and negative integers, including zero. Requirements 1. Implement a Comb Sort algorithm. 2. Optimize the shrink factor (can be configurable or tested to get an optimal value). 3. Ensure efficient handling of edge cases (empty array, single element array, pre-sorted array, etc.). Example ```python # Example test case print(optimized_comb_sort([3, 6, 2, 5, 8, 1])) # Output: [1, 2, 3, 5, 6, 8] print(optimized_comb_sort([10, -5, 3, 2, 0])) # Output: [-5, 0, 2, 3, 10] print(optimized_comb_sort([1, 1, 1, 1])) # Output: [1, 1, 1, 1] print(optimized_comb_sort([])) # Output: [] ``` In your implementation, thoroughly test your function against edge cases and ensure the performance is optimized for an array size up to `10^5`.","solution":"def optimized_comb_sort(arr: list) -> list: Sorts an array using an optimized comb sort algorithm. Parameters: arr (list): List of integers to be sorted. Returns: list: Sorted list of integers. def get_next_gap(gap): # Shrink factor 1.3 is found to be a good trade-off for performance # Comb sort\'s shrinking factor: 1.3, could be considered optimal from empirical observations new_gap = int(gap / 1.3) if new_gap < 1: return 1 return new_gap n = len(arr) gap = n swapped = True # Continues the sorting while gap size is reduced and swaps are needed while gap != 1 or swapped: gap = get_next_gap(gap) swapped = False for i in range(0, n - gap): if arr[i] > arr[i + gap]: arr[i], arr[i + gap] = arr[i + gap], arr[i] swapped = True return arr"},{"question":"# Remove Duplicates from an Array You are given an array which may contain duplicate elements. Your task is to write a function `remove_duplicates` that takes this array as input and returns a new array with all duplicate elements removed. Requirements: 1. The order of elements must be preserved as their first occurrence in the input array. 2. The function should handle arrays of any data type (integers, strings, booleans, etc.). # Function Signature ```python def remove_duplicates(array): pass ``` # Input - `array` (list): A list of elements, which can include integers, strings, booleans, etc. # Output - `list`: A list with duplicates removed, preserving the original order of first occurrence. # Constraints - The function should be efficient for reasonably large arrays (up to 10^4 elements). - The function should handle arrays with mixed data types. # Example ```python # Example 1 input: [1, 1, 2, 2, 3, 4, 4, \\"hey\\", \\"hey\\", \\"hello\\", True, True] output: [1, 2, 3, 4, \\"hey\\", \\"hello\\"] # Example 2 input: [] output: [] # Example 3 input: [1, 2, 3, 4, 5] output: [1, 2, 3, 4, 5] ```","solution":"def remove_duplicates(array): Removes duplicate elements from the list while preserving the order of their first occurrence. seen = set() result = [] for item in array: if item not in seen: result.append(item) seen.add(item) return result"},{"question":"# Combination Sum Problem You are provided with an integer array `nums` containing distinct positive numbers, and a positive integer `target`. Your task is to write two functions that determine the number of unique combinations from `nums` that add up to `target`. Each number in `nums` can be used an unlimited number of times. 1. **Function**: `combination_sum_topdown(nums, target)` - **Description**: This function should use a top-down dynamic programming approach with memoization. - **Input**: - `nums`: a list of positive integers without duplicates. - `target`: a positive integer that indicates the sum to form combinations. - **Output**: An integer representing the number of unique combinations that add up to `target`. 2. **Function**: `combination_sum_bottom_up(nums, target)` - **Description**: This function should use a bottom-up dynamic programming approach. - **Input**: - `nums`: a list of positive integers without duplicates. - `target`: a positive integer that indicates the sum to form combinations. - **Output**: An integer representing the number of unique combinations that add up to `target`. # Example Given the input: - `nums = [1, 2, 3]` - `target = 4` The combinations that add up to 4 are: - (1, 1, 1, 1) - (1, 1, 2) - (1, 2, 1) - (1, 3) - (2, 1, 1) - (2, 2) - (3, 1) The output for both functions should be `7`. # Follow-up Questions: 1. What if negative numbers are allowed in the given array? How does it change the problem? 2. What limitation would you need to add to the question to allow negative numbers? # Constraints - Each number in nums is a distinct positive integer. - target is a positive integer.","solution":"def combination_sum_topdown(nums, target): def helper(remaining, memo): if remaining == 0: return 1 if remaining < 0: return 0 if remaining in memo: return memo[remaining] count = 0 for num in nums: count += helper(remaining - num, memo) memo[remaining] = count return count return helper(target, {}) def combination_sum_bottom_up(nums, target): dp = [0] * (target + 1) dp[0] = 1 for i in range(1, target + 1): for num in nums: if i - num >= 0: dp[i] += dp[i - num] return dp[target]"},{"question":"# Question: K-th Smallest Element in a Sorted Matrix You are given an `n x n` matrix which is sorted row-wise and column-wise in non-decreasing order. Implement a function to find the K-th smallest element in the matrix. # Function Definition ```python def kth_smallest(matrix: List[List[int]], k: int) -> int: pass ``` # Input * `matrix`: A list of lists of integers representing a sorted matrix where `matrix[i][j]` ≤ `matrix[i][j+1]` and `matrix[i][j]` ≤ `matrix[i+1][j]`. * `k`: An integer representing the position of the smallest element you must find. # Output * Returns the k-th smallest element in the matrix. # Constraints * `1 <= n <= 300` * `1 <= matrix[i][j] <= 10^9` * All elements in the matrix are distinct. * It is guaranteed that 1 ≤ k ≤ n^2. # Example ```python matrix = [ [1, 5, 9], [10, 11, 13], [12, 13, 15] ] k = 8 # kth_smallest(matrix, k) should return 13 ``` # Requirements 1. **Efficiency**: Consider utilizing a min-heap or a binary search to achieve the optimal performance. 2. **Correctness**: Ensure that your algorithm correctly identifies the k-th smallest element. # Additional Notes - Discuss how to manage the matrix traversal or selection process. - Highlight edge cases, such as the smallest or largest k, why those edge cases matter, and how your approach handles them.","solution":"import heapq from typing import List def kth_smallest(matrix: List[List[int]], k: int) -> int: Given an n x n matrix which is sorted row-wise and column-wise in non-decreasing order, returns the k-th smallest element in the matrix. n = len(matrix) # min-heap to keep track of the smallest elements in the matrix min_heap = [] # Initialize the heap with the first element of each row for i in range(min(n, k)): heapq.heappush(min_heap, (matrix[i][0], i, 0)) # Extract-min k-1 times from the heap to get the k-th smallest element for _ in range(k - 1): val, r, c = heapq.heappop(min_heap) if c + 1 < n: heapq.heappush(min_heap, (matrix[r][c + 1], r, c + 1)) # The root of the heap is now the k-th smallest element return heapq.heappop(min_heap)[0]"},{"question":"Problem Statement You are tasked with improving the `ResizableHashTable` class provided in the code snippets by implementing a more efficient collision resolution strategy, namely **quadratic probing**. Unlike linear probing, which advances one slot at a time, quadratic probing uses a quadratic function to determine the next slot. Requirements * **Function to Implement**: You need to modify or implement methods of the `ResizableHashTable` class to use quadratic probing. * **Input and Output**: * You need to modify the `put`, `get`, and `del_` methods to incorporate quadratic probing during collision handling. * No additional methods need to be called. Constraints * The initial size of the hash table should remain 8. * The resize threshold should remain at 2/3rds full. Performance Goals * Ensure that the average case complexity of insertion, retrieval, and deletion operations remains (O(1)) and improves collision resolution. Example Suppose the hash table has 8 slots and the keys inserted are prone to collisions: * Keys to insert: [10, 22, 31, 4, 15, 28, 17, 22] (value could be same as key for simplicity). Expected entries in the table after using quadratic probing and resizing if necessary: ``` Index: 0 1 2 3 4 5 6 7 [10, None, 22, 31, 4, None, 15, None] Now resize occurs, as occupancy has come to 2/3 of the current size. Index after resize to a size of 16: [10, None, None, None, 4, 15, None, None, None, 17, 31, 28, None, 22, None, None] ``` Task * Modify the methods of the `ResizableHashTable` class: 1. `put` 2. `get` 3. `del_` # Notes * Ensure that `__resize` method consistently adapts the new sizes and allocations, employing the new quadratic probing for collision resolution. **Hint**: Quadratic probing employs the formula (hash_ = (initial_hash + i^2) % size) where (i) starts from 1 and increments with each collision.","solution":"class ResizableHashTable: def __init__(self): self.size = 8 self.table = [None] * self.size self.count = 0 def put(self, key, value): if self.count >= self.size * 2 / 3: self.__resize() idx = self.__probe(key) if self.table[idx] is None: self.count += 1 self.table[idx] = (key, value) def get(self, key): idx = self.__probe(key, find_existing=True) if idx is not None and self.table[idx] is not None: return self.table[idx][1] return None def del_(self, key): idx = self.__probe(key, find_existing=True) if idx is not None and self.table[idx] is not None: self.table[idx] = None self.count -= 1 return True return False def __hash(self, key): return key % self.size def __probe(self, key, find_existing=False): initial_hash = self.__hash(key) idx = initial_hash i = 1 while True: if self.table[idx] is None: if find_existing: return None else: return idx elif self.table[idx][0] == key: return idx idx = (initial_hash + i * i) % self.size i += 1 def __resize(self): old_table = self.table self.size *= 2 self.table = [None] * self.size self.count = 0 for item in old_table: if item is not None: self.put(item[0], item[1])"},{"question":"You are tasked with creating a function that multiplies two non-negative integers represented as strings and returns the product as a string. This needs to be achieved without converting the entire string to an integer at any point. ```python def multiply(num1: \\"str\\", num2: \\"str\\") -> \\"str\\": # Your implementation here pass ``` Input * `num1`: A non-negative integer string with length < 110. * `num2`: A non-negative integer string with length < 110. Output * The product of the two integer strings as a string. Constraints * The input strings `num1` and `num2` will contain only digits (`0-9`). * They will not have leading zeros. Example ```python assert multiply(\\"2\\", \\"3\\") == \\"6\\" assert multiply(\\"123\\", \\"456\\") == \\"56088\\" assert multiply(\\"100\\", \\"1000\\") == \\"100000\\" assert multiply(\\"0\\", \\"345\\") == \\"0\\" ``` # Guidelines 1. **Efficiency**: Ensure the algorithm runs efficiently within the constraints. The nesting must be managed properly. 2. **No Direct Conversion**: Do not use any built-in library functions to handle big integers or conversion of strings directly to integers. 3. **Edge Cases**: Consider edge cases like multiplication by \'0\', very large numbers, and ensure your function handles all specified constraints. 4. **Performance**: Optimize the algorithm to manage space and time complexity effectively. # Hints - Consider the positional value of each digit when creating your intermediate sums. - You might need to handle carries in a manner similar to manual multiplication.","solution":"def multiply(num1: str, num2: str) -> str: if num1 == \\"0\\" or num2 == \\"0\\": return \\"0\\" # Initialize result array to hold the intermediate sums result = [0] * (len(num1) + len(num2)) # Reverse the strings to facilitate positional multiplications num1, num2 = num1[::-1], num2[::-1] # Multiply each digit of both numbers and add for i in range(len(num1)): for j in range(len(num2)): product = (int(num1[i]) * int(num2[j])) result[i + j] += product # Carry for next position (just as manually done in multiplication) result[i + j + 1] += result[i + j] // 10 result[i + j] %= 10 # Remove leading zeros and convert array to string while result[-1] == 0: result.pop() return \'\'.join(map(str, result[::-1]))"},{"question":"Problem Statement You are tasked with extending a Markov Chain simulator. Given an initial Markov Chain and a series of initial states, you are to simulate and return a finite sequence of states until a specific condition is met. # Functions to Implement 1. **next_finite_state(chain, initial_state, steps)** - **Input**: A Markov chain `chain` (dictionary structure as presented), an `initial_state` (string), and an integer `steps` defining the number of states to generate. - **Output**: A list containing a sequence of `steps` states starting from the `initial_state`. # Constraints 1. Assume `steps` will always be a positive integer. 2. Assume the provided Markov chain is non-empty and all probabilities are valid (sum to 1). 3. The solution should efficiently handle a Markov chain with states <= 1000. # Example ```python chain = { \'A\': {\'A\': 0.6, \'E\': 0.4}, \'E\': {\'A\': 0.7, \'E\': 0.3} } initial_state = \'A\' steps = 5 next_finite_state(chain, initial_state, steps) ``` Output: ```python [\'A\', \'A\', \'E\', \'A\', \'E\'] ``` # Notes - The output list should contain exactly `steps` elements. - Each element is determined by the transition probabilities defined in the Markov chain for the previous state.","solution":"import random def next_finite_state(chain, initial_state, steps): Simulates the finite sequence of states for a given Markov chain starting from an initial state for a specified number of steps. Parameters: chain (dict): A Markov chain represented by a dictionary where keys are states and values are dictionaries of transition probabilities to other states. initial_state (str): The starting state of the Markov chain. steps (int): The number of states to generate in the sequence. Returns: list: A list of states representing the sequence of steps generated by the Markov chain. current_state = initial_state states_sequence = [current_state] for _ in range(steps - 1): # Get the next state probabilities dictionary for the current state next_state_probabilities = chain[current_state] # Unpack next states and their probabilities states = list(next_state_probabilities.keys()) probabilities = list(next_state_probabilities.values()) # Use random.choices to randomly select the next state based on the transition probabilities next_state = random.choices(states, probabilities)[0] # Append the chosen next state to the sequence states_sequence.append(next_state) # Update current state current_state = next_state return states_sequence"},{"question":"# Path/URL Separator Validation **Scenario**: You are developing a file management system that accepts paths from different environments and needs to identify directory and file components reliably. Given diverse formatting, it\'s crucial to handle both UNIX-style paths and URLs that use `/` as separators while ensuring no misinterpretation of edge cases. **Task**: Write a function `validate_and_split(path: str) -> Tuple[str, str]` that accomplishes the following: - Validates the components being correctly separated by `/`. - Ensures paths conform to basic expected structures (not containing multiple types of separators, not being empty). **Function Signature**: `validate_and_split(path: str) -> Tuple[str, str]` **Input**: - A string `path`, representing a file path or URL. **Output**: - A tuple `(dir_path, file_name)` where: * `dir_path` is the directory path excluding the final component. * `file_name` is the final component. **Constraints**: - If `path` is an empty string, the function should return `(\\"\\", \\"\\")`. - Ensure no processing for uncommon path formats (mixed separators like `/` and ``). **Example**: ```python assert validate_and_split(\\"https://example.com/test.py\\") == (\\"https://example.com\\", \\"test.py\\") assert validate_and_split(\\"algorithms/unix/test.py\\") == (\\"algorithms/unix\\", \\"test.py\\") assert validate_and_split(\\"fileonly\\") == (\\"\\", \\"fileonly\\") assert validate_and_split(\\"\\") == (\\"\\", \\"\\") ``` **Further Notes**: - Handle cases sensitively where input is not well-formed, and assume the function is used within a well-validated user interface.","solution":"from typing import Tuple def validate_and_split(path: str) -> Tuple[str, str]: if not path: return (\\"\\", \\"\\") components = path.split(\'/\') dir_path = \'/\'.join(components[:-1]) file_name = components[-1] return (dir_path, file_name)"},{"question":"Context You have been hired by a company to enhance their text analysis software. They want to add a feature that checks if two given phrases are anagrams of each other. Your task is to implement this feature. Task Implement a function `are_anagrams(phrase1: str, phrase2: str) -> bool` that determines if two given phrases are anagrams of each other. The comparison should be case insensitive and should ignore all non-alphabetic characters. Input and Output * **Input**: * `phrase1` (string): The first phrase to be compared. * `phrase2` (string): The second phrase to be compared. * **Output**: * Returns `True` if `phrase1` and `phrase2` are anagrams, `False` otherwise. Constraints * Both input strings will contain a mix of alphabetic and non-alphabetic characters. * The function should be case insensitive. * Ignore all non-alphabetic characters in both phrases for the comparison. Examples ```python assert are_anagrams(\\"A decimal point\\", \\"I\'m a dot in place\\") == True assert are_anagrams(\\"The eyes\\", \\"They see!\\") == True assert are_anagrams(\\"Hello, World\\", \\"World Hello!!!\\") == True assert are_anagrams(\\"Apple\\", \\"Pleap\\") == True assert are_anagrams(\\"Apple\\", \\"Cherry\\") == False assert are_anagrams(\\"Hello\\", \\"Ola\\") == False ``` Hint Consider filtering out non-alphabetic characters and using a common method to handle both upper and lower case letters. Note: The `assert` statements are provided for example purposes. Your function should simply return True or False without printing or asserting.","solution":"def are_anagrams(phrase1: str, phrase2: str) -> bool: Determines if two given phrases are anagrams of each other. Comparison is case insensitive and ignores non-alphabetic characters. def clean_phrase(phrase): return \'\'.join(char.lower() for char in phrase if char.isalpha()) clean1 = clean_phrase(phrase1) clean2 = clean_phrase(phrase2) return sorted(clean1) == sorted(clean2)"},{"question":"# Question: Problem Statement: You are given a linked list and tasked with finding the first node of a cycle in it (if it exists). Write a function `find_cycle_start` that detects where the cycle begins. Input: - A linked list represented by its head node. Each node contains an integer value (`val`) and a pointer to the next node (`next`). Output: - The value of the first node where the cycle begins. If there is no cycle, return `None`. Example: ```python # Create linked list: 1 -> 2 -> 3 -> 4 -> 5 -> 3 (cycle at node with value 3) head = ListNode(1) second = ListNode(2) third = ListNode(3) fourth = ListNode(4) fifth = ListNode(5) head.next = second second.next = third third.next = fourth fourth.next = fifth fifth.next = third # Creating the cycle output = find_cycle_start(head) print(output) # Should return 3 ``` Constraints: - Nodes are labeled with integer values. - The list length is between 0 and 10000. - The node values are unique. Function Signature: ```python class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def find_cycle_start(head: ListNode) -> int: pass ``` Notes: - `ListNode` class is provided containing `val` (integer) and `next` (pointer to next node). - Ensure your solution handles edge cases effectively. Evaluation Criteria: - Correctness: Ensure that the implementation correctly identifies the cycle\'s start node. - Efficiency: The solution must work within O(n) time complexity and O(1) space complexity. - Robust validation through unit tests covering: - Lists with no cycles. - Lists with cycles of various lengths. - Large lists with/without cycles.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def find_cycle_start(head: ListNode) -> int: def detect_cycle(head): slow, fast = head, head while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: return slow return None if not head: return None intersection = detect_cycle(head) if not intersection: return None ptr1, ptr2 = head, intersection while ptr1 != ptr2: ptr1 = ptr1.next ptr2 = ptr2.next return ptr1.val"},{"question":"You are assigned to implement a prime-checking utility as part of a broader cryptographic application. A prime number is defined as a number that is greater than 1 and is not divisible by any number other than 1 and itself. Function Requirements You need to implement the function `find_primes_in_range(start, end)` which returns a list of all prime numbers within a given range `[start, end]`. The function should utilize an efficient algorithm for checking primality to ensure performance. Input * `start`: An integer `start` (1 <= start <= end). * `end`: An integer `end` (start <= end <= 10^6). Output * A list of integers containing all prime numbers within the range `[start, end]`. Constraints * Performance should be optimized for the specified range. * You can assume that the inputs are valid and `start` is less than or equal to `end`. Example ```python >>> find_primes_in_range(10, 50) [11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47] >>> find_primes_in_range(1, 10) [2, 3, 5, 7] ``` Guidelines 1. Use the `prime_check(n)` function provided to check if numbers are prime. 2. Ensure edge cases, such as very small ranges (e.g., `start` == `end`) and ranges containing no primes are handled correctly. 3. Consider performance optimizations, especially since the maximum possible range size is substantial (up to 10^6).","solution":"def is_prime(n): Check if a number is prime. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def find_primes_in_range(start, end): Returns a list of all prime numbers within the range [start, end]. primes = [] for num in range(start, end + 1): if is_prime(num): primes.append(num) return primes"},{"question":"# Context In performance-critical applications, you might need to choose between different implementations of a data structure based on specific constraints. One such scenario involves implementing a Queue Abstract Data Type (ADT) which supports a variety of operations and usage patterns. Two common implementations are available - using arrays and linked lists. # Task Implement a `CircularQueue` based on a circular array (ring buffer), which enhances space efficiency by reusing empty slots in the array, unlike the straightforward dynamic array which may need frequent resizing. # Requirements * **Input/Output Specifications**: * **enqueue(item)**: Adds a new item to the rear of the queue. If the queue is full, it should raise an `OverflowError`. * **dequeue()**: Removes and returns the front item from the queue. If the queue is empty, it should raise an `IndexError`. * **is_empty()**: Returns `True` if the queue is empty, otherwise `False`. * **is_full()**: Returns `True` if the queue is full, otherwise `False`. * **peek()**: Returns the front item from the queue without dequeuing it. If the queue is empty, it should raise an `IndexError`. * **size()**: Returns the number of items in the queue. * **Constraints**: * The queue should have a maximum capacity defined at initialization and not dynamically resize. * The operations should respect the following time complexities: * `enqueue`: O(1) * `dequeue`: O(1) * `peek`: O(1) * `is_empty`: O(1) * `is_full`: O(1) * `size`: O(1) * **CircularQueue Class Signature**: ```python class CircularQueue: def __init__(self, capacity: int): Initializes the queue with a given capacity. pass def enqueue(self, item): Adds item to the rear of the queue. pass def dequeue(self): Removes and returns front item of the queue. pass def is_empty(self) -> bool: Returns True if the queue is empty, otherwise False. pass def is_full(self) -> bool: Returns True if the queue is full, otherwise False. pass def peek(self): Returns front item without removing it. pass def size(self) -> int: Returns number of elements in the queue. pass ``` Implement these methods and ensure that your implementation handles all edge cases efficiently.","solution":"class CircularQueue: def __init__(self, capacity: int): Initializes the queue with a given capacity. self.capacity = capacity self.queue = [None] * capacity self.front = -1 self.rear = -1 self.count = 0 def enqueue(self, item): Adds item to the rear of the queue. if self.is_full(): raise OverflowError(\\"Queue is full\\") if self.is_empty(): self.front = 0 self.rear = (self.rear + 1) % self.capacity self.queue[self.rear] = item self.count += 1 def dequeue(self): Removes and returns front item of the queue. if self.is_empty(): raise IndexError(\\"Queue is empty\\") item = self.queue[self.front] self.queue[self.front] = None self.front = (self.front + 1) % self.capacity self.count -= 1 if self.count == 0: # Reset pointers when queue becomes empty self.front = -1 self.rear = -1 return item def is_empty(self) -> bool: Returns True if the queue is empty, otherwise False. return self.count == 0 def is_full(self) -> bool: Returns True if the queue is full, otherwise False. return self.count == self.capacity def peek(self): Returns front item without removing it. if self.is_empty(): raise IndexError(\\"Queue is empty\\") return self.queue[self.front] def size(self) -> int: Returns number of elements in the queue. return self.count"},{"question":"# Scenario You are working on a system that processes a dynamically changing network of interactions represented as singly-linked lists. These lists can occasionally form cycles, which need to be detected and managed correctly to avoid infinite loops during processing. # Problem Statement Write a function `find_cycle_start(head)` that, given the head of a singly linked list, detects if the list contains a cycle and if so, returns the node at the start of the cycle. If the list does not contain a cycle, the function should return `None`. Aim to accomplish this with O(n) time complexity and O(1) space complexity. # Function Signature ```python class Node: def __init__(self, x): self.val = x self.next = None def find_cycle_start(head: Node) -> Node: # Your implementation here pass ``` # Input * `head`: The head of the singly linked list (Node). # Output * Return the node where the cycle begins. If there is no cycle, return `None`. # Constraints * The number of nodes in the linked list can be in the range [0, 10^4]. * The values of the nodes are arbitrary but unique. # Examples 1. Input: A -> B -> C -> D -> E -> C (where C is the start of the cycle) Output: C (node) 2. Input: A -> B -> C -> D -> E Output: None Implement this function in Python, ensuring correctness and efficiency. Consider edge cases and use additional helper functions as required.","solution":"class Node: def __init__(self, x): self.val = x self.next = None def find_cycle_start(head: Node) -> Node: if not head or not head.next: return None slow = head fast = head # Detect cycle using slow and fast pointers while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: break # If no cycle found, return None if not fast or not fast.next: return None # Move slow to head, keep fast at meeting point. Each moves one step. slow = head while slow != fast: slow = slow.next fast = fast.next return slow"},{"question":"# Climbing Stairs Variation You are given a staircase problem, but with a twist. This time, you can climb the stairs by taking 1, 2, or 3 steps at a time. Given a staircase with `n` steps, find out how many distinct ways you can climb to the top using these steps. Write a function `climb_stairs_variation` that takes an integer `steps` and returns the number of distinct ways to climb to the top. Function Signature ```python def climb_stairs_variation(steps: int) -> int: pass ``` Input and Output * **Input**: - `steps` (int): A positive integer representing the total number of steps. * **Output**: - An integer representing the total number of distinct ways to climb to the top using 1, 2, or 3 steps at a time. Constraints * 1 <= steps <= 10^4 Example 1. **climb_stairs_variation(3)** should return 4. - Explanation: The four ways to climb 3 steps are: 1. 1 step + 1 step + 1 step 2. 1 step + 2 steps 3. 2 steps + 1 step 4. 3 steps 2. **climb_stairs_variation(4)** should return 7. - Explanation: The seven ways to climb 4 steps are: 1. 1 step + 1 step + 1 step + 1 step 2. 1 step + 1 step + 2 steps 3. 1 step + 2 steps + 1 step 4. 2 steps + 1 step + 1 step 5. 2 steps + 2 steps 6. 1 step + 3 steps 7. 3 steps + 1 step Implementation Details * Consider edge cases such as when `steps` is 1, 2, or 3. * Aim for a solution that has a time complexity of O(n) and a space complexity of O(1).","solution":"def climb_stairs_variation(steps: int) -> int: Returns the number of distinct ways to climb to the top using 1, 2, or 3 steps at a time. if steps == 1: return 1 if steps == 2: return 2 if steps == 3: return 4 # Initialize three variables to keep track of ways to climb for the last three positions a, b, c = 1, 2, 4 for i in range(4, steps + 1): total_ways = a + b + c a, b, c = b, c, total_ways return c"},{"question":"# Question You have been hired by a company that specializes in historical cryptography. They need a function that can encode and decode messages using the Atbash cipher. Task Implement a function `atbash(s)` that takes a string `s` consisting of alphabetic and potentially non-alphabetic characters (including spaces, punctuation, etc.) and returns the Atbash cipher translation of that string. Function Signature ```python def atbash(s: str) -> str: ``` Input * `s` (1 ≤ |s| ≤ 10^5): The input string to be encoded/decoded. The string will contain: * Alphabetic characters (both upper and lower case). * Non-alphabetic characters (e.g., spaces, punctuation). Output * A string that represents the Atbash cipher translation of the input string `s`. Examples ```python print(atbash(\\"Attack at dawn\\")) # Output: \\"Zggzxp zg wzdm\\" print(atbash(\\"Hello, World!\\")) # Output: \\"Svool, Dliow!\\" print(atbash(\\"abcdefghijklmnopqrstuvwxyz\\")) # Output: \\"zyxwvutsrqponmlkjihgfedcba\\" print(atbash(\\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\\")) # Output: \\"ZYXWVUTSRQPONMLKJIHGFEDCBA\\" ``` Constraints * The function must handle an input string of length up to 10^5 efficiently. * The function should maintain the case of alphabetic characters and return non-alphabetic characters unchanged. * Ensure that the function runs within a reasonable time frame for the upper limit input size.","solution":"def atbash(s: str) -> str: def translate_char(c): if \'a\' <= c <= \'z\': return chr(ord(\'a\') + (ord(\'z\') - ord(c))) elif \'A\' <= c <= \'Z\': return chr(ord(\'A\') + (ord(\'Z\') - ord(c))) else: return c return \'\'.join(translate_char(c) for c in s)"},{"question":"**Question**: You are given a list of integers that needs to be sorted in ascending order. Your task is to implement the Quick Sort algorithm, which sorts the list in-place. Ensure your implementation is efficient and handles edge cases properly. **Function Signature**: ```python def quick_sort(arr: List[int], simulation: bool=False) -> List[int]: Sorts the array using quick sort algorithm. Args: arr (List[int]): A list of integers to be sorted. simulation (bool): If true, print the array at each iteration. Returns: List[int]: The sorted list. ``` **Input**: - A list of integers `arr` (0 <= len(arr) <= 10^5, -10^5 <= arr[i] <= 10^5 for any i in range(len(arr))). - A boolean `simulation` which is optional and by default `False`. If set to `True`, the function should print the state of the array at each iteration step of the main algorithm. This is to help understand the sorting process. **Output**: - The list of integers sorted in ascending order. **Constraints**: - You must sort the array **in-place**. - Your solution should have an average time complexity of O(n log n). - Do not use any extra space for another array. - You cannot use Python\'s built-in sort function. **Example**: ```python # Example 1 arr = [3, 6, 8, 10, 1, 2, 1] assert quick_sort(arr) == [1, 1, 2, 3, 6, 8, 10] # Example 2 arr = [] assert quick_sort(arr) == [] # Example 3 arr = [1] assert quick_sort(arr) == [1] ``` Your implementation should correctly handle edge cases like empty arrays or arrays with a single element. Consider potential issues with recursion depth and pivot selection to avoid performance degradation.","solution":"def quick_sort(arr, simulation=False): def _quick_sort(items, low, high): if low < high: pivot_index = partition(items, low, high) _quick_sort(items, low, pivot_index - 1) _quick_sort(items, pivot_index + 1, high) if simulation: print(items) def partition(items, low, high): pivot = items[high] i = low - 1 for j in range(low, high): if items[j] <= pivot: i = i + 1 items[i], items[j] = items[j], items[i] items[i + 1], items[high] = items[high], items[i + 1] return i + 1 _quick_sort(arr, 0, len(arr) - 1) return arr"},{"question":"# Question You are given a class definition representing a node in a binary tree: ```python class TreeNode: def __init__(self, val): self.val = val self.left = None self.right = None ``` Your task is to write a function `bin_tree_to_list` that takes the root of a binary tree and transforms it into a sorted doubly linked list in place. The elements should follow the in-order traversal of the tree. The left pointer of the tree node should act as the previous pointer and the right pointer should act as the next pointer in the doubly linked list. # Constraints 1. The values in the tree nodes will be unique. 2. The given tree will always be a valid binary search tree. 3. You may assume the tree has at most 10^4 nodes. # Function Signature ```python def bin_tree_to_list(root: TreeNode) -> TreeNode: pass ``` # Example Input: ```python root = TreeNode(4) root.left = TreeNode(2) root.right = TreeNode(5) root.left.left = TreeNode(1) root.left.right = TreeNode(3) ``` Execution: ```python head = bin_tree_to_list(root) # This would convert the tree to a doubly linked list: # 1 <-> 2 <-> 3 <-> 4 <-> 5 ``` Output: ``` 1 -> 2 -> 3 -> 4 -> 5 -> None ``` # Notes - Ensure that the resulting linked list preserves the in-order sequence of the binary search tree. - Write helper functions if needed. - You are allowed to modify the structure of the tree.","solution":"class TreeNode: def __init__(self, val): self.val = val self.left = None self.right = None def bin_tree_to_list(root: TreeNode) -> TreeNode: def tree_to_doubly_list(node): nonlocal first, last if not node: return # Recursively convert the left subtree tree_to_doubly_list(node.left) # Handle the current node if last: # Link the previous node (last) with the current one (node) last.right = node node.left = last else: # This must be the smallest node which becomes the head of the doubly linked list first = node last = node # Recursively convert the right subtree tree_to_doubly_list(node.right) if not root: return None first, last = None, None tree_to_doubly_list(root) return first"},{"question":"Scenario You are a software developer at a company that develops educational applications. Your team is building a feature to allow students to decode messages encoded as sequences of numbers where each number between 1 and 26 corresponds to a letter in the alphabet (\'A\' to \'Z\'). Task Write a function `num_decodings` that determines the total number of ways to decode a given encoded message. Implement the function using dynamic programming for efficient computation. # Function Signature ```python def num_decodings(enc_mes: str) -> int: ``` # Input * `enc_mes` (str): A non-empty string containing only numeric characters (0-9). # Output * (int): The total number of ways to decode the input string. # Constraints * The input will not start with \'0\'. * The input will contain numbers between \'1\' and \'26\' inclusively. # Examples ```python # Example 1 assert num_decodings(\\"12\\") == 2 # Explanation: \\"12\\" can be decoded as \\"AB\\" (1 2) or \\"L\\" (12). # Example 2 assert num_decodings(\\"226\\") == 3 # Explanation: \\"226\\" can be decoded as \\"BZ\\" (2 26), \\"VF\\" (22 6), or \\"BBF\\" (2 2 6). # Example 3 assert num_decodings(\\"0\\") == 0 # Explanation: \\"0\\" cannot be decoded. # Example 4 assert num_decodings(\\"06\\") == 0 # Explanation: \\"06\\" cannot be decoded because \'06\' is not a valid character and \'0\' cannot standalone. # Example 5 assert num_decodings(\\"102\\") == 1 # Explanation: \\"102\\" can be decoded only as \\"JB\\" (10 2) ``` # Performance Requirements * The implementation should run in linear time, O(n), where n is the length of the string. * The space complexity should be optimized to O(1) where feasible. Notes * Handle edge cases such as strings containing \'0\' which cannot form valid single characters unless paired with preceding \'1\' or \'2\'. * Consider sequences exceeding \'26\' such as \'27\' must be processed correctly.","solution":"def num_decodings(enc_mes: str) -> int: if not enc_mes or enc_mes[0] == \'0\': return 0 n = len(enc_mes) dp = [0] * (n + 1) dp[0] = 1 dp[1] = 1 for i in range(2, n + 1): if enc_mes[i - 1] != \'0\': dp[i] += dp[i - 1] if enc_mes[i - 2] == \'1\' or (enc_mes[i - 2] == \'2\' and enc_mes[i - 1] <= \'6\'): dp[i] += dp[i - 2] return dp[n]"},{"question":"**Scenario**: You have been hired to develop a decoding mechanism for a messaging system that uses a unique number encoding where \'A\' maps to 1, \'B\' maps to 2, ..., and \'Z\' maps to 26. The encoded messages are strings of numbers, and you need to determine the number of ways a message can be decoded. **Objective**: Write a function `count_decodings(encoded_message: str) -> int` that takes an encoded message and returns the total number of ways to decode it. # Specifications - **Input**: - `encoded_message`: a string representing the encoded message which contains only digits (0-9). - **Output**: - An integer representing the total number of possible decodings. # Constraints: 1. `1 <= len(encoded_message) <= 100` 2. The encoded_message can have digits \'0\'-\'9\'. 3. \'0\' cannot be decoded individually, but MUST be part of \'10\' or \'20\'. # Examples: ```python assert count_decodings(\\"12\\") == 2 # Can be decoded as \\"AB\\" (1 2) or \\"L\\" (12) assert count_decodings(\\"226\\") == 3 # Can be decoded as \\"BZ\\" (2 26), \\"VF\\" (22 6), \\"BBF\\" (2 2 6) assert count_decodings(\\"0\\") == 0 # \'0\' cannot be decoded assert count_decodings(\\"10\\") == 1 # Can only be \\"J\\" (10) assert count_decodings(\\"06\\") == 0 # \'06\' is invalid ``` # Performance: Your solution should be able to handle the upper constraint efficiently. # Required Function: ```python def count_decodings(encoded_message: str) -> int: # Implementation here ```","solution":"def count_decodings(encoded_message: str) -> int: Returns the total number of ways to decode the given encoded_message. if not encoded_message or encoded_message[0] == \'0\': return 0 n = len(encoded_message) dp = [0] * (n + 1) dp[0] = 1 dp[1] = 1 if encoded_message[0] != \'0\' else 0 for i in range(2, n + 1): single_digit = int(encoded_message[i - 1]) two_digit = int(encoded_message[i - 2:i]) if 1 <= single_digit <= 9: dp[i] += dp[i - 1] if 10 <= two_digit <= 26: dp[i] += dp[i - 2] return dp[n]"},{"question":"# Advanced Graph Traversal: Bi-Directional Search Context: You are given an undirected graph and need to find the shortest path from a starting node to a target node. While traditional BFS ensures finding the shortest path in unweighted graphs, for very large graphs, it can be more efficient to use a bi-directional search. Problem Statement: Implement a function `bi_directional_search(graph, start, target)` that performs a bi-directional BFS to find the shortest path from the `start` node to the `target` node. Function Signature: ```python def bi_directional_search(graph: dict, start: int, target: int) -> list: pass ``` Input: * `graph`: A dictionary where each key is a node, and the value is a list of nodes connected to the key node. * `start`: The starting node (an integer). * `target`: The target node (an integer). Output: * A list of nodes representing the shortest path from `start` to `target`. If no path is found, return an empty list. Constraints: * Both `start` and `target` are guaranteed to be in the graph. * The graph is undirected and connected. Example: ```python graph = { 1: [2, 4], 2: [1, 3], 3: [2, 4, 5], 4: [1, 3], 5: [3] } start = 1 target = 5 assert bi_directional_search(graph, start, target) == [1, 4, 3, 5] ``` Performance Requirements: * The solution should be efficient in both time and space complexities, leveraging the bi-directional search mechanism. Notes: * Address edge cases like graph cycles, disconnections, and minimum node graph. * Ensure the function handles large graphs efficiently by optimizing the queue operations akin to BFS.","solution":"from collections import deque def bi_directional_search(graph, start, target): Performs a bi-directional BFS to find the shortest path from start to target. if start == target: return [start] # Initialize BFS queues for forward and backward search forward_queue = deque([start]) backward_queue = deque([target]) # Initialize visited and parent_dict dictionaries for path reconstruction forward_visited = {start: None} backward_visited = {target: None} while forward_queue and backward_queue: if found_path(forward_queue, forward_visited, backward_visited, graph, direction=True): return reconstruct_path(forward_visited, backward_visited, meeting_node) if found_path(backward_queue, backward_visited, forward_visited, graph, direction=False): return reconstruct_path(forward_visited, backward_visited, meeting_node) # If the queues are exhausted and no path is found return [] def found_path(current_queue, current_visited, opposite_visited, graph, direction): global meeting_node current_length = len(current_queue) for _ in range(current_length): current_node = current_queue.popleft() for neighbor in graph[current_node]: if neighbor in opposite_visited: meeting_node = neighbor current_visited[neighbor] = current_node if direction else current_node return True if neighbor not in current_visited: current_visited[neighbor] = current_node if direction else current_node current_queue.append(neighbor) return False def reconstruct_path(forward_visited, backward_visited, meeting_node): # Reconstruct the path from start to meeting node path = [] node = meeting_node while node is not None: path.append(node) node = forward_visited[node] path = path[::-1] # Reverse to get path from start to meeting node # Continue reconstructing the path from meeting node to target node = backward_visited[meeting_node] while node is not None: path.append(node) node = backward_visited[node] return path"},{"question":"You are given a function `magic_number(n)` which determines whether a given integer `n` is a magic number. A number is defined to be magic if, by summing its digits repetitively until the result is a single digit, the final number equals 1. Given the definition of the magic number: - A number is a magic number if the iterative sum of its digits eventually equals 1. Your task is to write an equivalent function `is_magic_number(n)` that: 1. Takes an integer `n` (which could be positive, negative, or zero) as input. 2. Returns `True` if `n` is a magic number and `False` otherwise. 3. Handles edge cases like 0 and negative numbers. # Function Signature ```python def is_magic_number(n: int) -> bool: ``` # Constraints - `-10^9 <= n <= 10^9` - If `n` is negative, consider the absolute value. - Efficiently handle very large numbers within the given constraints. # Examples ```python assert is_magic_number(50113) == True # Explanation: 5+0+1+1+3=10 => 1+0=1 assert is_magic_number(1234) == True # Explanation: 1+2+3+4=10 => 1+0=1 assert is_magic_number(199) == True # Explanation: 1+9+9=19 => 1+9=10 => 1+0=1 assert is_magic_number(111) == False # Explanation: 1+1+1=3 assert is_magic_number(-50113) == True # Explanation: Abs(-50113)=50113, similar steps as above assert is_magic_number(0) == False # Explanation: 0 summation results in itself ``` # Notes - Ensure your implementation handles negative inputs correctly by converting them to positive. - Consider edge cases for inputs like zero to return the correct boolean result. - The solution should be optimized for performance given the constraints.","solution":"def is_magic_number(n: int) -> bool: Determines if a number is a magic number. A number is considered magic if the iterative sum of its digits until the result is a single digit equals 1. def sum_of_digits(x: int) -> int: Returns the sum of the digits of x return sum(int(digit) for digit in str(x)) n = abs(n) # Consider the absolute value for negative numbers while n > 9: n = sum_of_digits(n) return n == 1"},{"question":"# Scenario: Your company’s internal software occasionally needs to cycle through a list of tasks represented as an array. Each time a new task execution cycle starts, the starting point changes based on some seed value \'k.\' You have been tasked to write an efficient function to rotate the task list to accommodate this requirement. # Task: Write a function `rotate_array(arr, k)` that rotates an array `arr` of `n` elements to the right by `k` steps. # Requirements: 1. The function should be efficient. 2. It should be able to handle edge cases such as empty arrays and `k` being larger than the size of the array. 3. The function should modify the array `arr` in place. # Input: * `arr` (List[int]): A list of integers representing the task list [1 <= len(arr) <= 10^5]. * `k` (int): The number of steps to rotate the list [0 <= k <= 10^9]. # Output: * The function will not return a value; it should modify the input list in place. # Constraints: * Ensure time complexity is minimized. * Aim for linear time complexity, and avoid using extra space unnecessarily. # Examples: ```python # Example 1: arr = [1, 2, 3, 4, 5, 6, 7] k = 3 rotate_array(arr, k) print(arr) # Output: [5, 6, 7, 1, 2, 3, 4] # Example 2: arr = [-1, -100, 3, 99] k = 2 rotate_array(arr, k) print(arr) # Output: [3, 99, -1, -100] # Example 3: arr = [1, 2] k = 3 rotate_array(arr, k) print(arr) # Output: [2, 1] # Example 4: arr = [] k = 1 rotate_array(arr, k) print(arr) # Output: [] ``` # Notes: * It is recommended to use in-place modifications using reversing techniques. * Handle edge cases where k is zero or greater than the length of the array naturally through modulo operations.","solution":"def rotate_array(arr, k): Rotates the given array in place to the right by k steps. if not arr: return n = len(arr) k %= n # To handle cases where k is larger than the array length. # Reverse the entire array arr.reverse() # Reverse the first k elements arr[:k] = reversed(arr[:k]) # Reverse the remaining elements arr[k:] = reversed(arr[k:])"},{"question":"**Interleaving String Verification** Context: You are designing a string validation utility for a text processing library. One of the requirements is to ensure that a given string can be created by interleaving two other strings while maintaining the character order of both input strings. Problem Statement: Write a function `is_merge(s, part1, part2)` that determines if the string `s` can be formed by interleaving `part1` and `part2` while preserving the order of characters in `part1` and `part2`. The function should follow these rules: 1. Characters from `part1` and `part2` do not overlap in their positions in `s`. 2. The order of characters in `part1` and `part2` should be maintained in `s`. Input: * `s` (string): The target string to be validated. * `part1` (string): The first part string. * `part2` (string): The second part string. Output: * Return `True` if `s` can be formed by interleaving `part1` and `part2` while preserving their order, otherwise return `False`. Constraints: * The lengths of `s`, `part1`, and `part2` are up to 10^5. * All strings contain only lowercase alphabetic characters (\'a\'-\'z\'). Examples: 1. **Example 1**: ``` Input: s = \\"codewars\\", part1 = \\"cdw\\", part2 = \\"oears\\" Output: True Explanation: \\"codewars\\" can be formed by interleaving \\"cdw\\" and \\"oears\\". ``` 2. **Example 2**: ``` Input: s = \\"abc\\", part1 = \\"ab\\", part2 = \\"bc\\" Output: False Explanation: \\"abc\\" cannot be formed by interleaving \\"ab\\" and \\"bc\\". ``` 3. **Example 3**: ``` Input: s = \\"\\", part1 = \\"\\", part2 = \\"\\" Output: True Explanation: An empty string can be formed by interleaving two empty strings. ``` Expectations: * Implement both a recursive and an iterative approach within your solution. * Ensure your solution handles edge cases like empty strings and string length mismatches effectively. * Consider optimizing performance using memoization or a dynamic programming table if necessary.","solution":"def is_merge(s, part1, part2): Determines if the string `s` can be formed by interleaving `part1` and `part2` while preserving the order of characters in `part1` and `part2`. memo = {} def can_merge(i, j, k): if (i, j, k) in memo: return memo[(i, j, k)] if i == len(part1) and j == len(part2) and k == len(s): return True if k == len(s): return False if i < len(part1) and part1[i] == s[k] and can_merge(i + 1, j, k + 1): memo[(i, j, k)] = True return True if j < len(part2) and part2[j] == s[k] and can_merge(i, j + 1, k + 1): memo[(i, j, k)] = True return True memo[(i, j, k)] = False return False return can_merge(0, 0, 0)"},{"question":"Scenario You are developing a data processing system for a weather data analytics company. One of your tasks involves cleaning the temperature data recorded daily. The data contains the minimum and maximum daily temperatures. You need to ensure that the temperature values fall within a reasonable range before further processing. Task Write a function `filter_temperatures` that takes a list of temperature readings, a minimum allowable temperature, and a maximum allowable temperature. The function should return a list of temperatures that fall within the specified range (inclusive). If either minimum or maximum temperature is not provided, the function should ignore those constraints. Function Signature ```python def filter_temperatures(temperatures: list, min_temp: float = None, max_temp: float = None) -> list: ``` Input - `temperatures`: A list of float values representing daily temperature readings. - `min_temp`: A float representing the minimum allowable temperature (inclusive). If `None`, there is no lower limit. - `max_temp`: A float representing the maximum allowable temperature (inclusive). If `None`, there is no upper limit. Output - A list of float values representing the filtered temperatures within the specified range. Constraints - The list `temperatures` can have up to 10^6 elements. - Each temperature value is a float ranging between -100.0 to 100.0. - Performance should be linear, O(n). Example ```python print(filter_temperatures([12.1, -5.0, 20.0, 35.5, 50.0], None, 25.0)) # Output: [12.1, -5.0, 20.0] print(filter_temperatures([12.1, -5.0, 20.0, 35.5, 50.0], -5.0, 35.5)) # Output: [12.1, -5.0, 20.0, 35.5] ``` Edge Cases to Consider 1. An empty list as input. 2. All elements being outside the specified range. 3. Only `min_temp` or only `max_temp` provided. You must handle these edge cases properly to ensure the function is robust.","solution":"def filter_temperatures(temperatures: list, min_temp: float = None, max_temp: float = None) -> list: Filters the list of temperatures to include only those within the specified range. :param temperatures: List of float values representing daily temperature readings. :param min_temp: Minimum allowable temperature (inclusive). If None, no lower limit is applied. :param max_temp: Maximum allowable temperature (inclusive). If None, no upper limit is applied. :return: List of temperatures that fall within the specified range. filtered_temps = [] for temp in temperatures: if (min_temp is None or temp >= min_temp) and (max_temp is None or temp <= max_temp): filtered_temps.append(temp) return filtered_temps"},{"question":"# Task Based on the provided `DirectedGraph` structure, your task is to implement an algorithm that detects cycles in the directed graph. A cycle exists if there is a path that starts and ends at the same node. # Requirements 1. Implement a function `has_cycle(graph: DirectedGraph) -> bool`. 2. The function must return `True` if there is a cycle in the given `graph`, otherwise `False`. # Input and Output * **Input**: An instance of `DirectedGraph`. * **Output**: A boolean value indicating whether there is a cycle in the graph. # Constraints * The number of nodes (V) in the graph will be in the range `[0, 1000]`. * The number of edges (E) in the graph will be in the range `[0, 2000]`. # Example Scenario Consider the graph dictionary: ```python graph_dict = { \\"A\\": [\\"B\\"], \\"B\\": [\\"C\\"], \\"C\\": [\\"A\\"], # Cycle here: A -> B -> C -> A \\"D\\": [\\"E\\"], \\"E\\": [] } ``` Creating a `DirectedGraph` with this dictionary and passing it to `has_cycle` should return `True`. # Sample Test Cases ```python # Test Case 1 graph_dict_1 = { \\"A\\": [\\"B\\"], \\"B\\": [\\"C\\"], \\"C\\": [\\"A\\"], # Cycle here: A -> B -> C -> A } graph_1 = DirectedGraph(graph_dict_1) assert has_cycle(graph_1) == True # Test Case 2 graph_dict_2 = { \\"A\\": [\\"B\\"], \\"B\\": [\\"C\\"], \\"C\\": [] } graph_2 = DirectedGraph(graph_dict_2) assert has_cycle(graph_2) == False # Test Case 3 graph_dict_3 = {} graph_3 = DirectedGraph(graph_dict_3) assert has_cycle(graph_3) == False ``` * Make sure your implementation works well under the given constraints and handles edge cases such as empty graphs.","solution":"class DirectedGraph: def __init__(self, adjacency_list): self.graph = adjacency_list def has_cycle(graph: DirectedGraph) -> bool: def dfs(v, visited, rec_stack): visited.add(v) rec_stack.add(v) for neighbor in graph.graph.get(v, []): if neighbor not in visited: if dfs(neighbor, visited, rec_stack): return True elif neighbor in rec_stack: return True rec_stack.remove(v) return False visited, rec_stack = set(), set() for node in graph.graph: if node not in visited: if dfs(node, visited, rec_stack): return True return False"},{"question":"You are tasked to write a function that employs the `search_insert` helper method to efficiently insert elements into an already sorted list such that the list remains sorted after each insertion. # Task Description Write a function `insert_and_sort(sorted_list, values)` that takes a sorted list of integers (`sorted_list`) and a list of values (`values`) to insert. The function should return the updated sorted list after inserting all values. # Function Specification - **Input**: - `sorted_list`: A list of integers, sorted in non-decreasing order. - `values`: A list of integers to be inserted into `sorted_list`. - **Output**: - A list of integers, which is the updated sorted list after inserting each value from `values`. # Constraints - Both lists can contain between 0 and 10^5 elements. - Each integer in the lists can range from -10^6 to 10^6. - Maintain the insertion order from `values` but ensure sorted order in `sorted_list`. # Example ```python def search_insert(array, val): low = 0 high = len(array) - 1 while low <= high: mid = low + (high - low) // 2 if val > array[mid]: low = mid + 1 else: high = mid - 1 return low def insert_and_sort(sorted_list, values): for val in values: position = search_insert(sorted_list, val) sorted_list.insert(position, val) return sorted_list # Example print(insert_and_sort([1, 3, 5, 6], [5, 2, 7, 0])) # Output: [0, 1, 2, 3, 5, 5, 6, 7] ``` **Edge Cases**: - Empty `sorted_list` and/or `values`. - All elements in `values` are larger/smaller than any element in `sorted_list`.","solution":"def search_insert(array, val): Helper function to find the insertion point for `val` in `array`. Uses binary search for efficiency. low = 0 high = len(array) - 1 while low <= high: mid = low + (high - low) // 2 if val > array[mid]: low = mid + 1 else: high = mid - 1 return low def insert_and_sort(sorted_list, values): Inserts each value from `values` into `sorted_list` so that `sorted_list` remains sorted. for val in values: position = search_insert(sorted_list, val) sorted_list.insert(position, val) return sorted_list"},{"question":"# Rotate a Singly Linked List Scenario: You are given a singly linked list and an integer `k`. Your task is to rotate the list to the right by `k` places. For example, if the list is 1 -> 2 -> 3 -> 4 -> 5 -> NULL and `k` is 2, the rotated list should be 4 -> 5 -> 1 -> 2 -> 3 -> NULL. Function Signature: ```python class ListNode: def __init__(self, x): self.val = x self.next = None def rotate_right(head: ListNode, k: int) -> ListNode: pass ``` Input: * `head` (ListNode): The head of the singly linked list. * `k` (int): The number of positions to rotate the list. Output: * Returns the head of the rotated list. Constraints: * The linked list can have 0 or more nodes. * `k` is a non-negative integer. Performance Requirements: * The solution should run in O(n) time complexity. * The solution should use O(1) additional space. Example: ```python # Example 1 list1 = ListNode(1) list1.next = ListNode(2) list1.next.next = ListNode(3) list1.next.next.next = ListNode(4) list1.next.next.next.next = ListNode(5) result = rotate_right(list1, 2) # Expected Output: 4 -> 5 -> 1 -> 2 -> 3 -> NULL # Example 2 list1 = ListNode(0) list1.next = ListNode(1) list1.next.next = ListNode(2) result = rotate_right(list1, 4) # Expected Output: 2 -> 0 -> 1 -> NULL ``` Note: * Implement the function ensuring you handle any edge cases such as when the list is empty or when `k` is zero or matches the length of the list.","solution":"class ListNode: def __init__(self, x): self.val = x self.next = None def rotate_right(head: ListNode, k: int) -> ListNode: if not head or k == 0: return head # Find the length of the linked list length = 1 current = head while current.next: current = current.next length = length + 1 # Avoid rotating more than the length of the list k = k % length if k == 0: return head # Find the new end of the list after rotation current.next = head # Connect the end to the head to make it circular steps_to_new_head = length - k new_tail = head for i in range(steps_to_new_head - 1): new_tail = new_tail.next new_head = new_tail.next new_tail.next = None # Break the circular link return new_head"},{"question":"You are tasked to implement a more efficient version of Dijkstra\'s Algorithm by utilizing a priority queue. The given graph is represented using an adjacency list to handle larger graphs efficiently. Input: 1. An integer, `V`, representing the number of vertices in the graph. 2. An integer, `E`, representing the number of edges in the graph. 3. An array of tuples, `edges`, where each tuple consists of three integers `(u, v, w)` representing an edge from vertex `u` to vertex `v` with a weight `w`. 4. An integer, `src`, representing the source vertex from which distances are calculated. Output: - A list of integers where the ith element represents the shortest distance from the source vertex to vertex `i`. Constraints: - 1 <= V <= 10^5 - 1 <= E <= 10^6 - 0 <= u, v < V - 0 <= w <= 10^5 - The input graph does not contain negative weights. # Function Signature ```python from typing import List, Tuple def dijkstras_algorithm(V: int, E: int, edges: List[Tuple[int, int, int]], src: int) -> List[int]: ``` # Requirements - Use an adjacency list to represent the graph. - Use a priority queue to improve the efficiency of selecting the minimum distance vertex. # Example ```python V = 5 E = 6 edges = [ (0, 1, 2), (0, 2, 4), (1, 2, 1), (1, 3, 7), (2, 4, 3), (3, 4, 1) ] src = 0 print(dijkstras_algorithm(V, E, edges, src)) ``` Output: ``` [0, 2, 3, 9, 6] ``` # Explanation - The shortest distance from vertex 0 to 1 is 2. - The shortest distance from vertex 0 to 2 is 3 (0 -> 1 -> 2). - The shortest distance from vertex 0 to 3 is 9 (0 -> 1 -> 2 -> 4 -> 3). - The shortest distance from vertex 0 to 4 is 6 (0 -> 1 -> 2 -> 4).","solution":"from typing import List, Tuple import heapq def dijkstras_algorithm(V: int, E: int, edges: List[Tuple[int, int, int]], src: int) -> List[int]: # Step 1: Create adjacency list representation of the graph graph = [[] for _ in range(V)] for u, v, w in edges: graph[u].append((v, w)) # If the graph is undirected, uncomment the next line # graph[v].append((u, w)) # Step 2: Initialize distances and the priority queue dist = [float(\'inf\')] * V dist[src] = 0 priority_queue = [(0, src)] # (distance, vertex) while priority_queue: current_dist, current_vertex = heapq.heappop(priority_queue) if current_dist > dist[current_vertex]: continue for neighbor, weight in graph[current_vertex]: distance = current_dist + weight if distance < dist[neighbor]: dist[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return dist"},{"question":"# Question: You are given an array of integers. Your task is to implement a Max Priority Queue with the following operations using max heap: `insert`, `extract_max`, and `get_max` which must all run in O(log n) time complexity. Function Specifications: - **insert(arr, key)**: Takes two parameters, the current priority queue `arr` and an integer `key` to insert into the max priority queue. - **Input**: `arr` - a list of integers representing the current max priority queue. `key` - an integer to insert into the priority queue. - **Output**: The updated priority queue list. - **extract_max(arr)**: Takes one parameter, the current priority queue `arr` and removes and returns the maximum element from the max priority queue. - **Input**: `arr` - a list of integers representing the current max priority queue. - **Output**: A tuple containing the updated priority queue list and the maximum element. - **get_max(arr)**: Takes one parameter, the current priority queue `arr` and returns the maximum element without removing it. - **Input**: `arr` - a list of integers representing the current max priority queue. - **Output**: An integer representing the maximum element. Constraints: 1. The priority queue must remain a valid max heap after each operation. 2. Handle edge cases like empty priority queue for `extract_max` and `get_max`. 3. Your implementation should not use any pre-built library functions for the heap operations. Example: ```python arr = [] arr = insert(arr, 10) arr = insert(arr, 5) arr = insert(arr, 30) print(get_max(arr)) # Output: 30 arr, max_element = extract_max(arr) print(max_element) # Output: 30 print(arr) # Output: [10, 5] ```","solution":"def insert(arr, key): Inserts a key into the priority queue. arr.append(key) _sift_up(arr, len(arr) - 1) return arr def extract_max(arr): Extracts the maximum key from the priority queue. if len(arr) == 0: return arr, None max_element = arr[0] arr[0] = arr[-1] arr.pop() _sift_down(arr, 0) return arr, max_element def get_max(arr): Returns the maximum key from the priority queue. if len(arr) == 0: return None return arr[0] def _sift_up(arr, index): Helper function to sift-up the element at the given index to correct position. parent_index = (index - 1) // 2 while index > 0 and arr[parent_index] < arr[index]: arr[parent_index], arr[index] = arr[index], arr[parent_index] index = parent_index parent_index = (index - 1) // 2 def _sift_down(arr, index): Helper function to sift-down the element at the given index to correct position. max_index = index left_child = 2 * index + 1 right_child = 2 * index + 2 size = len(arr) if left_child < size and arr[left_child] > arr[max_index]: max_index = left_child if right_child < size and arr[right_child] > arr[max_index]: max_index = right_child if index != max_index: arr[index], arr[max_index] = arr[max_index], arr[index] _sift_down(arr, max_index)"},{"question":"# RSA Implementation and Encryption/Decryption Implement the RSA algorithm by completing the three functions: `generate_key(bits, seed)`, `encrypt(data, e, n)`, and `decrypt(data, d, n)`. You will follow the principles of RSA encryption/decryption as described. **Function Specifications**: 1. **generate_key(bits, seed)**: * **Input**: `bits` (int): Number of bits in the modulus `n`. `seed` (optional, int): Seed for random number generation. * **Output**: Tuple `(int, int, int)`, representing `(n, e, d)`: * `n`: Modulus for both public and private keys. * `e`: Public exponent (encryption key). * `d`: Private exponent (decryption key). 2. **encrypt(data, e, n)**: * **Input**: * `data` (int): The data to be encrypted. * `e` (int): Public exponent. * `n` (int): Modulus. * **Output**: `E` (int): The encrypted data. 3. **decrypt(data, d, n)**: * **Input**: * `data` (int): The encrypted data. * `d` (int): Private exponent. * `n` (int): Modulus. * **Output**: `data` (int): The decrypted original data. **Example Case**: ```python # Generating keys n, e, d = generate_key(16, seed=42) # Example Data data = 20 # Encrypting the Data encrypted_data = encrypt(data, e, n) # Decrypting the Data decrypted_data = decrypt(encrypted_data, d, n) # Asserting the correctness assert decrypted_data == data ``` **Constraints**: * The bit length of `n` must typically be large (1024, 2048 bits in practice), but for the purposes of this exercise, you can use `16` or `32` bits. * The primes ( p ) and ( q ) used in key generation must be generated randomly but should still be reproducible using the given seed for unit testing. * You must handle edge cases where `p` or `q` might be incorrectly generated ensuring `p-1` and `q-1` are co-prime with ( e ).","solution":"import random from sympy import isprime, mod_inverse def generate_prime(bits, rng): while True: candidate = rng.getrandbits(bits) if isprime(candidate): return candidate def generate_key(bits, seed=None): rng = random.Random(seed) p = generate_prime(bits // 2, rng) q = generate_prime(bits // 2, rng) n = p * q phi = (p - 1) * (q - 1) e = 65537 # Common choice for e if phi % e == 0: raise ValueError(\\"e is not coprime with phi\\") d = mod_inverse(e, phi) return n, e, d def encrypt(data, e, n): return pow(data, e, n) def decrypt(data, d, n): return pow(data, d, n)"},{"question":"# Question: Implement a Circular Singly Linked List **Scenario**: You are designing a data structure for a music player that maintains a playlist of songs. To allow continuous play after the last song, the list should be circular—i.e., the next pointer of the last node should point to the head of the list. **Task**: Implement a Circular Singly Linked List class in Python with the following functionalities: 1. **Insert at Head**: Insert a new node at the beginning of the list. 2. **Insert at Tail**: Insert a new node at the end of the list. 3. **Delete from Head**: Remove the node at the beginning of the list. 4. **Delete from Tail**: Remove the node at the end of the list. 5. **Search**: Find whether a value exists in the list and return its position. If it doesn\'t exist, return -1. 6. **Traverse**: Return a list of all values in the list, starting from the head and ending at the node just before the head again (completing the circle). **Input and Output Formats**: - `insert_at_head(value)`: Inserts a node with the given value at the head. No return value. - `insert_at_tail(value)`: Inserts a node with the given value at the tail. No return value. - `delete_from_head()`: Removes the node at the head. No return value. - `delete_from_tail()`: Removes the node at the tail. No return value. - `search(value)`: Returns the 0-based position of the node containing the value. Returns -1 if the value does not exist. - `traverse()`: Returns a list of node values starting from head to the node just before the head again. **Constraints**: - The list can contain any number of elements, including zero. - Assume the values are unique for simplicity. **Example**: ```python # Usage cll = CircularSinglyLinkedList() cll.insert_at_head(10) cll.insert_at_head(20) cll.insert_at_tail(30) print(cll.traverse()) # Output: [20, 10, 30] print(cll.search(10)) # Output: 1 print(cll.search(40)) # Output: -1 cll.delete_from_head() print(cll.traverse()) # Output: [10, 30] cll.delete_from_tail() print(cll.traverse()) # Output: [10] ``` Implement the `CircularSinglyLinkedList` class with the specified methods.","solution":"class Node: def __init__(self, value): self.value = value self.next = None class CircularSinglyLinkedList: def __init__(self): self.head = None def insert_at_head(self, value): new_node = Node(value) if self.head is None: self.head = new_node self.head.next = self.head else: temp = self.head while temp.next != self.head: temp = temp.next temp.next = new_node new_node.next = self.head self.head = new_node def insert_at_tail(self, value): new_node = Node(value) if self.head is None: self.head = new_node self.head.next = self.head else: temp = self.head while temp.next != self.head: temp = temp.next temp.next = new_node new_node.next = self.head def delete_from_head(self): if self.head is None: return if self.head.next == self.head: self.head = None else: temp = self.head while temp.next != self.head: temp = temp.next temp.next = self.head.next self.head = self.head.next def delete_from_tail(self): if self.head is None: return if self.head.next == self.head: self.head = None else: temp = self.head while temp.next.next != self.head: temp = temp.next temp.next = self.head def search(self, value): if self.head is None: return -1 temp = self.head index = 0 while True: if temp.value == value: return index temp = temp.next index += 1 if temp == self.head: break return -1 def traverse(self): if self.head is None: return [] result = [] temp = self.head while True: result.append(temp.value) temp = temp.next if temp == self.head: break return result"},{"question":"**Title**: Efficient Calculation of Euler\'s Totient Function for Multiple Queries Context An encryption algorithm you\'re designing requires frequent calculation of Euler\'s totient function for a range of numbers. Writing an efficient implementation is crucial to ensure the performance of your encryption process does not degrade. Problem Statement Write a function `euler_totient_sieve(m)` that computes Euler\'s totient function for every integer from 1 to `m` (inclusive) and returns a list where the `i-th` element at index `i` contains the value of ϕ(i). The function should use an optimized algorithm to compute the totient function efficiently for all numbers in the given range. Input Format - An integer `m` (1 ≤ m ≤ 10^6) Output Format - A list of integers, where the `i-th` element at index `i` is the value of ϕ(i) for 1 ≤ i ≤ m. Constraints - Your solution should be optimized to handle the upper limit efficiently. - You may assume the input `m` is always within the specified range. Example Input: ``` m = 10 ``` Output: ``` [0, 1, 1, 2, 2, 4, 2, 6, 4, 6, 4] ``` Explanation - The output list represents the totient function for each number from 0 to `m` inclusive. - φ(1) = 1 - φ(2) = 1 - φ(3) = 2 - φ(4) = 2 - φ(5) = 4 - φ(6) = 2 - ... Implementation Notes Ensure that your solution runs efficiently, leveraging a sieve-based approach that can compute the totient function values for all numbers up to `m` in O(m log log m) time complexity.","solution":"def euler_totient_sieve(m): This function computes Euler\'s totient function for every integer from 1 to m inclusive using a sieve method and returns a list where the i-th element is the value of ϕ(i). phi = list(range(m + 1)) for i in range(2, m + 1): if phi[i] == i: # i is a prime number for j in range(i, m + 1, i): phi[j] = phi[j] * (i - 1) // i return phi"},{"question":"Scenario You have a dataset represented as an array of integers. You need to identify the most frequent element(s) in this dataset to understand common trends. If there\'s a tie for the most frequent element, return all such elements in a list. If the array is empty, return an empty list. # Task Write a function `mode_finder(array)` that returns a list of the most frequent element(s) in the input array. # Input * The input is a list of integers: `array`. # Output * The output is a list of integers representing the most frequent elements. # Constraints * The input array can contain a range of integer values both positive and negative. * The array length can be up to 10^6 elements. # Example ```python def mode_finder(array): pass print(mode_finder([1, 1, 2, 2, 3, 4])) # Output: [1, 2] print(mode_finder([])) # Output: [] print(mode_finder([1, 2, 3, 3, 4, 4, 5, 5])) # Output: [3, 4, 5] ``` # Notes - Ensure your solution handles large input efficiently. - Pay attention to edge cases such as empty arrays and arrays with all unique elements.","solution":"from collections import Counter def mode_finder(array): Returns the most frequent element(s) in the input array. If there is a tie, returns all such elements in a list. If the array is empty, returns an empty list. if not array: return [] count = Counter(array) max_freq = max(count.values()) modes = [key for key, freq in count.items() if freq == max_freq] return modes # Examples # print(mode_finder([1, 1, 2, 2, 3, 4])) # Output: [1, 2] # print(mode_finder([])) # Output: [] # print(mode_finder([1, 2, 3, 3, 4, 4, 5, 5])) # Output: [3, 4, 5]"},{"question":"Fenwick Tree Implementation and Usage Context You have been hired by a company that processes large amounts of data and frequently needs to perform both sum queries and update operations efficiently. The company has chosen to use a data structure called Fenwick Tree (Binary Indexed Tree) due to its efficiency in handling such operations. Task Implement a Fenwick Tree class that supports both point updates and prefix sum queries efficiently. Use the guidelines below to structure your class. Class Specification 1. **Class Name**: `FenwickTree` 2. **Methods**: * `__init__(self, data: List[int]) -> None`: Initialize the tree with an array of integers. * `update(self, index: int, value: int) -> None`: Update the element at the given index with the specified value. * `sum(self, index: int) -> int`: Return the sum of elements from the beginning of the array up to the specified index. * `range_sum(self, start: int, end: int) -> int`: Return the sum of elements within the specified range `[start, end]`. Input and Output Formats * **Initialization**: A list of integers `data` that initialize the Fenwick Tree. * **Update**: Parameters `index` (0-based) and `value` which specify the index to be updated and the new value. * **Prefix Sum**: Parameter `index` (0-based) to calculate the prefix sum up to that index. * **Range Sum**: Parameters `start` and `end` (0-based) to calculate the sum of elements in the given range. Constraints * 0 <= index, start, end < len(data) * 1 <= len(data) <= 10^5 * -10^9 <= data[i], value <= 10^9 Example ```python data = [3, 2, -1, 6, 5, 4, -3, 3, 7, 2, 3] # Initialize Fenwick Tree ft = FenwickTree(data) # Perform sum query print(ft.sum(5)) # Output should be 19 # Range sum query print(ft.range_sum(1, 3)) # Output should be 7 # Update element ft.update(3, 10) # Perform sum query again after update print(ft.sum(5)) # Output should be 23 ```","solution":"class FenwickTree: def __init__(self, data): Initialize the Fenwick Tree with the given data. self.size = len(data) self.tree = [0] * (self.size + 1) for i, value in enumerate(data): self.update(i, value) def update(self, index, value): Update the element at the given index with the given value. index += 1 while index <= self.size: self.tree[index] += value index += index & -index def sum(self, index): Return the sum of elements from the beginning of the array up to the specified index. index += 1 result = 0 while index > 0: result += self.tree[index] index -= index & -index return result def range_sum(self, start, end): Return the sum of elements within the specified range [start, end]. return self.sum(end) - self.sum(start - 1)"},{"question":"**Stooge Sort Analysis and Implementation** **Background and Context:** Stooge Sort is a recursive sorting algorithm known for its educational and theoretical appeal due to its high time complexity. You are tasked with improving skills in understanding and implementing recursive algorithms with Stooge Sort as the base algorithm. **Problem Statement:** You are given an array of integers. Your task is to implement the Stooge Sort algorithm and ensure it sorts the array in non-decreasing order. You must then analyze its performance and propose at least one optimization or alternative sorting algorithm that performs better for large datasets. **Function Specifications:** ```python def stoogesort(arr, l, h): Sorts the subarray arr[l..h] in non-decreasing order using the Stooge Sort algorithm. Parameters: arr (list): The array of integers to be sorted. l (int): The starting index of the subarray. h (int): The ending index of the subarray. Returns: None: The function sorts the array in place. pass ``` **Input Format:** * A single list `arr` containing `n` integers, where `1 ≤ n ≤ 1000`. **Output Format:** * Modify the input list `arr` so that its elements are sorted in non-decreasing order. **Constraints:** * You must use the recursive Stooge Sort algorithm as described. * After sorting, print the sorted array using a single line, with each element separated by a space. **Example:** ```python array = [3, 1, 5, 2, 4] stoogesort(array, 0, len(array) - 1) print(array) # Output: [1, 2, 3, 4, 5] ``` **Performance Analysis:** After implementing the Stooge Sort: 1. Evaluate its performance on arrays of various sizes (e.g., 10, 100, 500, 1000 elements). 2. Identify the most notable performance bottlenecks. 3. Propose an alternative sorting algorithm (e.g., Merge Sort, Quick Sort) that can handle large datasets more efficiently. 4. Illustrate through examples or code comparisons how the alternative algorithm improves performance over Stooge Sort. **Additional Notes:** * Consider edge cases such as an already sorted array or an array with only one element. * Provide comments within your code explaining the steps of your implementation. * Discuss scenarios where Stooge Sort might be applicable despite its high time complexity.","solution":"def stoogesort(arr, l, h): if l >= h: return # If the first element is greater than the last, swap them if arr[l] > arr[h]: arr[l], arr[h] = arr[h], arr[l] # If there are more than two elements in the array if h - l + 1 > 2: t = (h - l + 1) // 3 # Recursively sort the initial 2/3 of the array stoogesort(arr, l, h - t) # Recursively sort the final 2/3 of the array stoogesort(arr, l + t, h) # Recursively sort the initial 2/3 of the array again stoogesort(arr, l, h - t) def optimize_sort(arr): arr.sort()"},{"question":"Your task is to implement a Circular Buffer (or Circular Queue) that optimizes the ArrayQueue discussed above. A circular queue is a linear data structure that follows the FIFO principle and connects the end of the queue back to the beginning, forming a circle. # Requirements: 1. **Class Name**: `CircularQueue` 2. **Initialization**: - `__init__(self, capacity)` where `capacity` is the maximum size of the queue. 3. **Methods**: - `enqueue(self, value)`: Adds `value` to the rear of the queue. Raises an `OverflowError` if the queue is full. - `dequeue(self)`: Removes and returns the front item from the queue. Raises an `IndexError` if the queue is empty. - `peek(self)`: Returns the front item without removing it. Raises an `IndexError` if the queue is empty. - `is_empty(self)`: Returns `True` if the queue is empty, otherwise `False`. - `is_full(self)`: Returns `True` if the queue is full, otherwise `False`. - `__len__(self)`: Returns the number of items in the queue. # Constraints: - The capacity (`n`) is a positive integer, and `1 <= n <= 10^5` - Operations should be performed in O(1) time. # Example Usage: ```python cq = CircularQueue(5) cq.enqueue(1) cq.enqueue(2) cq.enqueue(3) print(cq.dequeue()) # Output: 1 print(cq.peek()) # Output: 2 cq.enqueue(4) cq.enqueue(5) cq.enqueue(6) print(cq.is_full()) # Output: True print(len(cq)) # Output: 4 ```","solution":"class CircularQueue: def __init__(self, capacity): self.capacity = capacity self.queue = [None] * capacity self.front = 0 self.rear = -1 self.count = 0 def enqueue(self, value): if self.is_full(): raise OverflowError(\\"Queue is full\\") self.rear = (self.rear + 1) % self.capacity self.queue[self.rear] = value self.count += 1 def dequeue(self): if self.is_empty(): raise IndexError(\\"Queue is empty\\") value = self.queue[self.front] self.queue[self.front] = None self.front = (self.front + 1) % self.capacity self.count -= 1 return value def peek(self): if self.is_empty(): raise IndexError(\\"Queue is empty\\") return self.queue[self.front] def is_empty(self): return self.count == 0 def is_full(self): return self.count == self.capacity def __len__(self): return self.count"},{"question":"# Binary Search in Different Context Problem Statement You are tasked with developing a function that performs binary search on a sorted integer array, but with an added twist. Instead of a simple array, you need to work with an array that is circularly rotated. The goal is to find the index of a target value within this rotated array using an efficient algorithm. Function Signature ```python def circular_binary_search(array: List[int], target: int) -> int: pass ``` Input - `array` (List[int]): A list of integers sorted in ascending order but rotated at some pivot point. For example, [4, 5, 6, 7, 0, 1, 2]. - `target` (int): The integer value you need to find the index of in the `array`. Output - Returns the index of `target` if it is present in the array, otherwise returns -1. Constraints - The array contains no duplicate elements. - All integers are between -10^4 and 10^4. - The length of the array is between 1 and 10^4. Scenario Consider an array where the initial sorted array has been rotated around an unknown pivot point. The array might look something like this after rotation: ```python original_array = [0, 1, 2, 4, 5, 6, 7] rotated_array = [4, 5, 6, 7, 0, 1, 2] ``` You need to implement the search mechanism to efficiently find the index of `target` within such rotated arrays. Example ```python assert circular_binary_search([4, 5, 6, 7, 0, 1, 2], 0) == 4 assert circular_binary_search([4, 5, 6, 7, 0, 1, 2], 3) == -1 ```","solution":"from typing import List def circular_binary_search(array: List[int], target: int) -> int: Performs a binary search on a circularly rotated sorted array to find the index of the target value. Parameters: array (List[int]): Rotated sorted array of integers. target (int): The value to search for. Returns: int: The index of the target if found, otherwise -1. if not array: return -1 left, right = 0, len(array) - 1 while left <= right: mid = (left + right) // 2 # Check if the target is at the mid position if array[mid] == target: return mid # Determine which segment is sorted if array[left] <= array[mid]: # Left segment is sorted if array[left] <= target < array[mid]: right = mid - 1 else: left = mid + 1 else: # Right segment is sorted if array[mid] < target <= array[right]: left = mid + 1 else: right = mid - 1 return -1"},{"question":"# Anagram Verification **Objective**: Write a function `is_anagram_optimized(s: str, t: str) -> bool` that determines if the string `t` is an anagram of the string `s`. # Input: * Two strings `s` and `t` of lowercase alphabets only. # Output: * A boolean value `true` if `t` is an anagram of `s`, and `false` otherwise. # Constraints: * Each input string contains only lowercase English letters (`\'a\'` to `\'z\'`). * The lengths of the strings range from 0 to 100,000. # Performance: * The solution should have a time complexity of O(n), where n is the length of the strings. * The solution should have a space complexity of O(1), excluding input space requirements. # Requirements: * Implement the optimization that returns `false` immediately if the two strings are of different lengths. * Iterate through the characters to populate the frequency counts using a single dictionary and adjust counts accordingly to enhance the efficiency. # Example 1: ```plaintext Input: s = \\"anagram\\", t = \\"nagaram\\" Output: true ``` # Example 2: ```plaintext Input: s = \\"rat\\", t = \\"car\\" Output: false ``` # Example 3: ```plaintext Input: s = \\"\\", t = \\"\\" Output: true ```","solution":"def is_anagram_optimized(s: str, t: str) -> bool: Determines if string t is an anagram of string s. if len(s) != len(t): return False count = [0] * 26 for char in s: count[ord(char) - ord(\'a\')] += 1 for char in t: count[ord(char) - ord(\'a\')] -= 1 if count[ord(char) - ord(\'a\')] < 0: return False return True"},{"question":"Context In an effort to create a unique and compact representation of strings, a system uses abbreviations. The abbreviation of a string is formed by replacing substrings of it with their length whenever possible. For instance, the word \\"word\\" can be abbreviated as \\"w2d\\" (replacing \\"or\\" with \\"2\\") or simply \\"4\\" (replacing the entire word). Problem Statement Write a function `generate_abbreviations(word: str) -> List[str]` that takes a string `word` and returns a list of all possible abbreviations of the word. # Input * `word`: A string consisting of lowercase English letters, where `1 <= len(word) <= 20`. # Output * A list of strings, where each string is a possible abbreviation of the input `word`. # Constraints * The returned list can be in any order. * Ensure your solution handles edge cases efficiently. # Example ```python assert generate_abbreviations(\\"word\\") == [ \'word\', \'wor1\', \'wo1d\', \'wo2\', \'w1rd\', \'w1r1\', \'w2d\', \'w3\', \'1ord\', \'1or1\', \'1o1d\', \'1o2\', \'2rd\', \'2r1\', \'3d\', \'4\' ] assert generate_abbreviations(\\"\\") == [] assert generate_abbreviations(\\"a\\") == [\'a\', \'1\'] assert generate_abbreviations(\\"ab\\") == [\'ab\', \'a1\', \'1b\', \'2\'] ``` # Notes 1. Your function should perform efficiently on the upper constraint. 2. Consider boundary cases like an empty string, strings with repeated characters, etc. **Your task is to implement the function `generate_abbreviations` as described.**","solution":"from typing import List def generate_abbreviations(word: str) -> List[str]: Function to generate all possible abbreviations of a given word. result = [] def backtrack(position, curr, count): if position == len(word): if count > 0: curr += str(count) result.append(curr) else: # Abbreviate this position backtrack(position + 1, curr, count + 1) # Do not abbreviate this position if count > 0: curr += str(count) backtrack(position + 1, curr + word[position], 0) backtrack(0, \\"\\", 0) return sorted(result)"},{"question":"# Shell Sort Function Implementation **Objective**: Implement the Shell Sort algorithm for sorting an array of integers. **Context**: Shell Sort is an efficient sorting algorithm that extends insertion sort by comparing and sorting elements separated by a gap, which progressively decreases. # Task Description: Write a Python function `shell_sort(arr)` that takes a list of integers `arr` and sorts it in ascending order using the Shell Sort algorithm. # Function Signature: ```python def shell_sort(arr: List[int]) -> List[int]: ``` # Input: - A single list `arr` of integers such that 1 ≤ len(arr) ≤ 10^5 - The list may include both positive and negative integers and may contain duplicates. # Output: - A list containing the elements of `arr`, sorted in ascending order. # Example: ```python shell_sort([12, 34, 54, 2, 3]) ``` Expected Output: `[2, 3, 12, 34, 54]` # Constraints: - The sorting must be done in-place (i.e., O(1) additional space). - Aim to use optimal gap sequences for better performance. # Performance Requirements: - The implemented algorithm should handle large input sizes efficiently, utilizing optimal gap sequences to approximate O(n log² n) performance for most real-world distributions.","solution":"from typing import List def shell_sort(arr: List[int]) -> List[int]: Sorts a list of integers in ascending order using the Shell Sort algorithm. n = len(arr) gap = n // 2 while gap > 0: for i in range(gap, n): temp = arr[i] j = i while j >= gap and arr[j - gap] > temp: arr[j] = arr[j - gap] j -= gap arr[j] = temp gap //= 2 return arr"},{"question":"**Scenario**: You work for a cybersecurity firm analyzing logs to find anomalies. Every log entry is represented by an integer. In a particular batch, every log appears exactly three times, except for a suspect single log entry that occurs only once. For security reasons, you want to extract and flag this single occurrence for further investigation. Implement an efficient algorithm to perform this extraction. **Objective**: Write a function `find_unique_log(logs)` that efficiently identifies and returns the single unique log entry in a list where every other entry appears exactly three times. **Function Signature**: ```python def find_unique_log(logs: List[int]) -> int: pass ``` **Input**: - `logs`: A list of integers, where all but one integer appears exactly three times. **Output**: - An integer representing the unique log entry that appears exactly once. **Constraints**: - The solution must have a linear runtime complexity, O(n). - The solution should not use extra memory, specifically no hash tables or sets. - All integers in the input list should be within the range of standard 32-bit signed integers. **Example**: ```python assert find_unique_log([2, 2, 3, 2]) == 3 assert find_unique_log([0, 1, 0, 1, 0, 1, 99]) == 99 assert find_unique_log([30000, 500, 100, 30000, 100, 30000, 100]) == 500 ``` **Performance Requirements**: - Ensure your solution is efficient in terms of both time and space as specified in the constraints. **Hints**: - Utilize bitwise operations to achieve the desired results without additional space overhead.","solution":"def find_unique_log(logs): Identifies and returns the single unique log entry that appears only once in a list where every other entry appears exactly three times. one = 0 # Will hold XOR of all elements appearing once two = 0 # Will hold XOR of all elements appearing twice for log in logs: # Update `one` with the current log: one = (one ^ log) & ~two # Update `two` with the current log: two = (two ^ log) & ~one return one"},{"question":"# Linked List Implementation Challenge You are tasked with implementing a **Doubly Linked List** due to its bidirectional traversal capability. The list should support the following operations: 1. **Insertion at the beginning, end, and any specified position.** 2. **Deletion from the beginning, end, and any specified position.** 3. **Traversal from the beginning and the end.** Your task is to implement the following methods for the `DoublyLinkedList` class: 1. `def add_at_head(self, value):` – Inserts a node with the given `value` at the beginning of the list. 2. `def add_at_tail(self, value):` – Inserts a node with the given `value` at the end of the list. 3. `def add_at_position(self, position, value):` – Inserts a node with the given `value` at the specified `position` index in the list. 4. `def remove_head(self):` – Removes the node at the beginning of the list. 5. `def remove_tail(self):` – Removes the node at the end of the list. 6. `def remove_at_position(self, position):` – Removes the node at the specified `position` index in the list. Each method must handle all edge cases such as operations on an empty list or invalid positions. Constraints: - All values will be integers. - The specified position will always be within the current size of the list except for the `add_at_position`. Example: ```python dll = DoublyLinkedList() dll.add_at_head(1) dll.add_at_tail(2) dll.add_at_position(1, 3) # List becomes: 1 <-> 3 <-> 2 dll.remove_at_position(1) # List becomes: 1 <-> 2 dll.remove_tail() # List becomes: 1 dll.remove_head() # List becomes: empty ``` Performance Requirements: - Optimize for O(1) insertions and deletions when the position is known. - Consider time complexity of O(n) for traversals and searches. Write your implementation for the methods in the `DoublyLinkedList` class. DoublyLinkedList Class Skeleton ```python class DoublyLinkedListNode(object): def __init__(self, value): self.value = value self.next = None self.prev = None class DoublyLinkedList(object): def __init__(self): self.head = None self.tail = None def add_at_head(self, value): pass def add_at_tail(self, value): pass def add_at_position(self, position, value): pass def remove_head(self): pass def remove_tail(self): pass def remove_at_position(self, position): pass ```","solution":"class DoublyLinkedListNode(object): def __init__(self, value): self.value = value self.next = None self.prev = None class DoublyLinkedList(object): def __init__(self): self.head = None self.tail = None def add_at_head(self, value): new_node = DoublyLinkedListNode(value) if not self.head: # List is empty self.head = self.tail = new_node else: new_node.next = self.head self.head.prev = new_node self.head = new_node def add_at_tail(self, value): new_node = DoublyLinkedListNode(value) if not self.tail: # List is empty self.head = self.tail = new_node else: new_node.prev = self.tail self.tail.next = new_node self.tail = new_node def add_at_position(self, position, value): if position == 0: self.add_at_head(value) return new_node = DoublyLinkedListNode(value) current = self.head for _ in range(position - 1): if current is not None: current = current.next else: raise IndexError(\\"Position out of range\\") if current is self.tail: self.add_at_tail(value) else: new_node.next = current.next new_node.prev = current current.next.prev = new_node current.next = new_node def remove_head(self): if not self.head: raise IndexError(\\"List is empty\\") if self.head == self.tail: self.head = self.tail = None else: self.head = self.head.next self.head.prev = None def remove_tail(self): if not self.tail: raise IndexError(\\"List is empty\\") if self.head == self.tail: self.head = self.tail = None else: self.tail = self.tail.prev self.tail.next = None def remove_at_position(self, position): if not self.head: raise IndexError(\\"List is empty\\") if position == 0: self.remove_head() return current = self.head for _ in range(position): if current is not None: current = current.next else: raise IndexError(\\"Position out of range\\") if current == self.tail: self.remove_tail() else: current.prev.next = current.next if current.next: current.next.prev = current.prev"},{"question":"# Question You are building a file management system that requires constant access to various files using their paths. To ensure consistency and reliability across different operating systems and environments, you need to standardize the file paths to their absolute forms. Task: Write a function `resolve_full_path` that takes a list of relative or user-relative file paths and returns a list of their absolute paths. Function Signature: ```python def resolve_full_path(file_paths: List[str]) -> List[str]: pass ``` Input: * `file_paths`: A list of strings, where each string is a file path. (1 <= len(file_paths) <= 1000) * Each file path can be a relative path or a user-relative path. Output: * Returns a list of strings where each string is the absolute path corresponding to the input. Constraints: * Use the Python standard library for path resolution. * Consider edge cases where paths might not exist or are incorrectly formatted. Example: ```python file_paths = [\\"~/documents/file1.txt\\", \\"../file2.txt\\", \\"./file3.txt\\"] result = resolve_full_path(file_paths) # Output might be: # [\'/home/user/documents/file1.txt\', \'/home/user/[parent_directory]/file2.txt\', \'/home/user/current_directory/file3.txt\'] ``` Notes: * Make sure the resulting paths are fully qualified and do not depend on the current working directory.","solution":"import os from typing import List def resolve_full_path(file_paths: List[str]) -> List[str]: Takes a list of relative or user-relative file paths and returns a list of their absolute paths. absolute_paths = [os.path.abspath(os.path.expanduser(path)) for path in file_paths] return absolute_paths"},{"question":"# Task: Implement Resizing in Separate Chaining Hash Table Objective: Enhance the given implementation of a Separate Chaining Hash Table to include dynamic resizing. When the load factor (number of key-value pairs / number of buckets) exceeds a certain threshold, you need to resize the hash table by doubling its size and rehashing all existing keys. Function Implementation: You need to add the following functionalities to the `SeparateChainingHashTable` class: 1. `resize()`: This method should: - Double the size of the hash table. - Rehash all existing keys and redistribute them in the new hash table. 2. Modify the `put` method to call `resize` when the load factor exceeds 0.75. Expected Input and Output Formats: 1. **Input**: - The existing methods `put`, `get`, and `del_` will form the base of your testing. No direct user input is required. 2. **Output**: - The hash table should function correctly and maintain O(1) average complexity even after resizing. Constraints: - **Performance**: Ensure the resize operation is efficient. - **Table Size**: Start with a base size of 11 and grow as necessary. Example Scenario: 1. Insert elements until the load factor crosses 0.75. 2. Trigger a resize operation. 3. Verify if existing and new elements can be correctly inserted, retrieved, and deleted. Implement the solution below: ```python class Node(object): def __init__(self, key=None, value=None, next=None): self.key = key self.value = value self.next = next class SeparateChainingHashTable(object): _empty = None def __init__(self, size=11): self.size = size self._len = 0 self._table = [self._empty] * size def put(self, key, value): if self._len / self.size > 0.75: self.resize() hash_ = self.hash(key) node_ = self._table[hash_] if node_ is self._empty: self._table[hash_] = Node(key, value) else: while node_.next is not None: if node_.key == key: node_.value = value return node_ = node_.next if node_.key == key: node_.value = value else: node_.next = Node(key, value) self._len += 1 def get(self, key): hash_ = self.hash(key) node_ = self._table[hash_] while node_ is not self._empty: if node_.key == key: return node_.value node_ = node_.next return None def del_(self, key): hash_ = self.hash(key) node_ = self._table[hash_] pre_node = None while node_ is not None: if node_.key == key: if pre_node is None: self._table[hash_] = node_.next else: pre_node.next = node_.next self._len -= 1 return pre_node = node_ node_ = node_.next def hash(self, key): return hash(key) % self.size def __len__(self): return self._len def __getitem__(self, key): return self.get(key) def __delitem__(self, key): return self.del_(key) def __setitem__(self, key, value): self.put(key, value) def resize(self): new_size = self.size * 2 new_table = SeparateChainingHashTable(new_size) for node in self._table: while node is not self._empty: new_table.put(node.key, node.value) node = node.next self.size = new_size self._table = new_table._table ```","solution":"class Node(object): def __init__(self, key=None, value=None, next=None): self.key = key self.value = value self.next = next class SeparateChainingHashTable(object): _empty = None def __init__(self, size=11): self.size = size self._len = 0 self._table = [self._empty] * size def put(self, key, value): if self._len / self.size > 0.75: self.resize() hash_ = self.hash(key) node_ = self._table[hash_] if node_ is self._empty: self._table[hash_] = Node(key, value) else: while node_.next is not None: if node_.key == key: node_.value = value return node_ = node_.next if node_.key == key: node_.value = value else: node_.next = Node(key, value) self._len += 1 def get(self, key): hash_ = self.hash(key) node_ = self._table[hash_] while node_ is not self._empty: if node_.key == key: return node_.value node_ = node_.next return None def del_(self, key): hash_ = self.hash(key) node_ = self._table[hash_] pre_node = None while node_ is not None: if node_.key == key: if pre_node is None: self._table[hash_] = node_.next else: pre_node.next = node_.next self._len -= 1 return pre_node = node_ node_ = node_.next def hash(self, key): return hash(key) % self.size def __len__(self): return self._len def __getitem__(self, key): return self.get(key) def __delitem__(self, key): return self.del_(key) def __setitem__(self, key, value): self.put(key, value) def resize(self): new_size = self.size * 2 new_table = SeparateChainingHashTable(new_size) for node in self._table: while node is not self._empty: new_table.put(node.key, node.value) node = node.next self.size = new_size self._table = new_table._table self._len = new_table._len"},{"question":"# Scenario You are working with a data integrity team that verifies whether certain hierarchical data structures (binary trees in this case) are identical. This is crucial for ensuring data consistency after operations like backups, transfers, or transformations. Your task is to implement a function that can accurately compare two binary trees. # Task Write a Python function `are_trees_identical(tree1, tree2)` that compares two binary trees and returns `True` if they are identical, otherwise returns `False`. # Function Signature ```python def are_trees_identical(tree1: Optional[TreeNode], tree2: Optional[TreeNode]) -> bool: ``` # Input - `tree1`: `TreeNode` object representing the root of the first tree. - `tree2`: `TreeNode` object representing the root of the second tree. # Output - Returns `True` if both trees are structurally identical and have the same node values. - Returns `False` otherwise. # Constraints - Node values are integers. - The structure of the trees is represented using a `TreeNode` class with the following definition: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` # Examples ```python # Example 1 # Tree 1: # 1 # / # 2 3 # Tree 2: # 1 # / # 2 3 tree1 = TreeNode(1, TreeNode(2), TreeNode(3)) tree2 = TreeNode(1, TreeNode(2), TreeNode(3)) assert are_trees_identical(tree1, tree2) == True # Example 2 # Tree 1: # 1 # / # 2 1 # Tree 2: # 1 # / # 1 2 tree1 = TreeNode(1, TreeNode(2), TreeNode(1)) tree2 = TreeNode(1, TreeNode(1), TreeNode(2)) assert are_trees_identical(tree1, tree2) == False ``` # Notes - You should handle cases where one or both trees are empty. - Consider the efficiency of your solution, ensuring it handles deep trees within reasonable time and space limits.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def are_trees_identical(tree1: TreeNode, tree2: TreeNode) -> bool: # If both trees are empty, they are identical if tree1 is None and tree2 is None: return True # If one of the trees is empty but not the other, they are not identical if tree1 is None or tree2 is None: return False # If the values of the current nodes do not match, they are not identical if tree1.val != tree2.val: return False # Recursively check the left and right subtrees return (are_trees_identical(tree1.left, tree2.left) and are_trees_identical(tree1.right, tree2.right))"},{"question":"# Decoding Encoded Strings You are working on a messaging application that uses a specific encoding format to compress messages. The encoding rule is: `k[encoded_string]`, where the `encoded_string` inside the square brackets is being repeated exactly `k` times. Note that `k` is a guaranteed positive integer. Additionally, square brackets are always well-formed, and it is guaranteed that encoded strings do not contain any digits apart from the repeat number. You need to write a function that takes an encoded string and returns the decoded string. **Function Signature:** ```python def decode_string(s: str) -> str: :param s: str - encoded string :return: str - decoded string ``` **Input:** - `s` - a valid encoded string. **Output:** - The decoded string. **Constraints:** - The input string `s` has a length in the range [1, 30]. - The input string `s` is guaranteed to be valid; there are no extra white spaces and the square brackets are well-formed. - The encoded string does not contain digits, except for the repeat counts. **Examples:** 1. `s = \\"3[a]2[bc]\\"` returns `\\"aaabcbc\\"` 2. `s = \\"3[a2[c]]\\"` returns `\\"accaccacc\\"` 3. `s = \\"2[abc]3[cd]ef\\"` returns `\\"abcabccdcdcdef\\"` # **Challenges:** - Handle nested encoding efficiently. - Ensure that large repeat counts comprising multiple digits are correctly processed. - The solution should correctly handle concatenated sequences and standalone characters. Implementing this function will test your understanding of stack data structures and parsing techniques for handling nested patterns.","solution":"def decode_string(s: str) -> str: stack = [] current_num = 0 current_str = \\"\\" for char in s: if char.isdigit(): current_num = current_num * 10 + int(char) elif char == \'[\': stack.append((current_str, current_num)) current_str = \\"\\" current_num = 0 elif char == \']\': last_str, num = stack.pop() current_str = last_str + num * current_str else: current_str += char return current_str"},{"question":"Context You are given a graph representing a network of water pipes, where each pipe has a specified capacity. The objective is to determine the maximum amount of water that can flow from the source (starting point) to the sink (ending point) by implementing the Edmonds-Karp algorithm, which uses BFS to find augmenting paths. Problem Statement Implement a function `maximum_flow_bfs(adjacency_matrix)` that calculates the maximum flow in a given flow network. The flow network is represented by an `n x n` adjacency matrix where `adjacency_matrix[i][j]` represents the capacity of the edge from node `i` to node `j`. The source node is the first node (index 0), and the sink node is the last node (index n-1). Input * `adjacency_matrix`: A 2D list of integers where `adjacency_matrix[i][j]` indicates the capacity of the edge from node `i` to node `j`. The value is `0` if there is no direct edge between nodes `i` and `j`. Output * An integer representing the maximum flow possible from the source node to the sink node. Constraints * The adjacency matrix will have dimensions `n x n` where `1 <= n <= 100`. * Capacities are non-negative integers and given in the range `[0, 1000]`. Example ```python graph = [ [0, 16, 13, 0, 0, 0], [0, 0, 10, 12, 0, 0], [0, 4, 0, 0, 14, 0], [0, 0, 9, 0, 0, 20], [0, 0, 0, 7, 0, 4], [0, 0, 0, 0, 0, 0] ] assert maximum_flow_bfs(graph) == 23 ``` Implement the function `maximum_flow_bfs(adjacency_matrix)`.","solution":"from collections import deque def bfs(residual_graph, source, sink, parent): visited = [False] * len(residual_graph) queue = deque([source]) visited[source] = True while queue: u = queue.popleft() for v, capacity in enumerate(residual_graph[u]): if not visited[v] and capacity > 0: queue.append(v) visited[v] = True parent[v] = u if v == sink: return True return False def maximum_flow_bfs(adjacency_matrix): source = 0 sink = len(adjacency_matrix) - 1 parent = [-1] * len(adjacency_matrix) max_flow = 0 residual_graph = [row[:] for row in adjacency_matrix] while bfs(residual_graph, source, sink, parent): path_flow = float(\'Inf\') s = sink while s != source: path_flow = min(path_flow, residual_graph[parent[s]][s]) s = parent[s] v = sink while v != source: u = parent[v] residual_graph[u][v] -= path_flow residual_graph[v][u] += path_flow v = parent[v] max_flow += path_flow return max_flow"},{"question":"# Tree Traversal and Printing You are given a dictionary that represents a tree structure with multiple nested elements. Each entry in the dictionary has a key and an associated list of elements. The elements can either be strings or integers, where integers are considered as values representing deeper levels of the tree (though they simulate another nested dictionary). Your task is to write a function that prints this tree structure in a hierarchical format. Your function should be capable of handling multiple levels of depth. Each level in the tree should be indicated by an indentation. # Function Signature ```python def custom_tree_print(tree: dict) -> None: pass ``` # Input - `tree`: Dictionary representing the nested tree structure. - For example: ```json { \\"a\\": [\\"Adam\\", \\"Book\\", 4], \\"b\\": [\\"Bill\\", \\"Computer\\", 5, \\"TV\\", 6, \\"Jill\\", \\"Sports\\", 1], \\"c\\": [\\"Bill\\", \\"Sports\\", 3], \\"d\\": [\\"Adam\\", \\"Computer\\", 3, \\"Quin\\", \\"Computer\\", 3], \\"e\\": [\\"Quin\\", \\"Book\\", 5, \\"TV\\", 2], \\"f\\": [\\"Adam\\", \\"Computer\\", 7] } ``` # Expected Output The function should print the tree in a hierarchical structure maintaining their order of appearance, like: ``` a -> Adam -> Book -> 4 b -> Bill -> Computer -> 5 -> TV -> 6 -> Jill -> Sports -> 1 c -> Bill -> Sports -> 3 d -> Adam -> Computer -> 3 -> Quin -> Computer -> 3 e -> Quin -> Book -> 5 -> TV -> 2 f -> Adam -> Computer -> 7 ``` # Constraints and Performance Requirements: - The keys in the dictionary are unique. - Assume all values in nested lists are either strings or integers. - The function should handle large trees efficiently within O(N) time complexity, where N is the total nodes in the dictionary. # Example Given the input: ```python tree = { \\"a\\": [\\"Adam\\", \\"Book\\", 4], \\"b\\": [\\"Bill\\", \\"Computer\\", 5, \\"TV\\", 6, \\"Jill\\", \\"Sports\\", 1], \\"c\\": [\\"Bill\\", \\"Sports\\", 3], \\"d\\": [\\"Adam\\", \\"Computer\\", 3, \\"Quin\\", \\"Computer\\", 3], \\"e\\": [\\"Quin\\", \\"Book\\", 5, \\"TV\\", 2], \\"f\\": [\\"Adam\\", \\"Computer\\", 7] } custom_tree_print(tree) ``` The output should be: ``` a -> Adam -> Book -> 4 b -> Bill -> Computer -> 5 -> TV -> 6 -> Jill -> Sports -> 1 c -> Bill -> Sports -> 3 d -> Adam -> Computer -> 3 -> Quin -> Computer -> 3 e -> Quin -> Book -> 5 -> TV -> 2 f -> Adam -> Computer -> 7 ```","solution":"def custom_tree_print(tree): Prints the tree structure as defined in the hierarchical format. for key, values in tree.items(): print(f\\"{key} -> {\' -> \'.join(map(str, values))}\\")"},{"question":"# Question: Bit Insertion Challenge You are given two functions `insert_one_bit` and `insert_mult_bits` that manipulate bits within a number. Your task is to extend and improve these functions to handle various scenarios and then write a function `bit_insertion_handler`. # Function Signature ```python def insert_one_bit(num: int, bit: int, pos: int) -> int: pass def insert_mult_bits(num: int, bits: int, length: int, pos: int) -> int: pass def bit_insertion_handler(num: int, action: str, bits_or_bit: int, length: int, pos: int) -> int: \'\'\' Handles the bit insertion by determining if single or multiple bits operation should be performed. Parameters: num : int - The original number to manipulate. action : str - Either \\"single\\" for single bit insertion or \\"multiple\\" for multiple bits insertion. bits_or_bit : int - The bit to insert (for single bit) or bits to insert (for multiple bits). length : int - The length of bits (ignored for single bit insertion). pos : int - The position in the bit representation of num where insertion should take place. Returns: int - The resulting number after bit insertion. \'\'\' pass ``` # Constraints: 1. For `insert_one_bit(num, bit, pos)`: - `num` is a non-negative integer. - `bit` is either 0 or 1. - `pos` is a non-negative integer. 2. For `insert_mult_bits(num, bits, length, pos)`: - `num` is a non-negative integer. - `bits` is a non-negative integer representing the bits to insert. - `length` is a non-negative integer indicating the length of `bits`. - `pos` is a non-negative integer. 3. For `bit_insertion_handler`: - If `action` is `\\"single\\"`, call `insert_one_bit`. - If `action` is `\\"multiple\\"`, call `insert_mult_bits` with the appropriate parameters and conditions met. # Example: ```python # Single bit insertion assert insert_one_bit(21, 1, 2) == 45 assert insert_one_bit(21, 0, 2) == 41 # Multiple bits insertion assert insert_mult_bits(5, 7, 3, 1) == 47 assert insert_mult_bits(5, 7, 3, 3) == 61 # Handling assert bit_insertion_handler(21, \\"single\\", 1, 0, 2) == 45 assert bit_insertion_handler(5, \\"multiple\\", 7, 3, 1) == 47 ``` Make sure your functions handle edge cases such as inserting beyond the size of the bit-length naturally without error.","solution":"def insert_one_bit(num: int, bit: int, pos: int) -> int: Insert a single bit at the specified position of the number. mask = 1 << pos return (num & ~mask) | ((bit & 1) << pos) def insert_mult_bits(num: int, bits: int, length: int, pos: int) -> int: Insert multiple bits at the specified position of the number. mask = ((1 << length) - 1) << pos return (num & ~mask) | ((bits & ((1 << length) - 1)) << pos) def bit_insertion_handler(num: int, action: str, bits_or_bit: int, length: int, pos: int) -> int: Handles the bit insertion by determining if single or multiple bits operation should be performed. if action == \\"single\\": return insert_one_bit(num, bits_or_bit, pos) elif action == \\"multiple\\": return insert_mult_bits(num, bits_or_bit, length, pos) else: raise ValueError(\\"Invalid action specified\\")"},{"question":"# Counting Sort Implementation with Negative Numbers **Scenario**: You are a software engineer tasked with developing a sorting algorithm for a logistics company. They need to sort cargo weights efficiently. The weights can be positive or negative but always within a reasonable range. **Objective**: Implement a function `counting_sort_with_negatives` that uses the Counting Sort algorithm to sort an array of integers that may include negative values. Your implementation should address any edge cases and ensure that the sorting is stable. **Input and Output Formats**: - **Input**: A list of integers, `arr`, which may contain negative and positive numbers. - **Output**: A list of integers sorted in non-decreasing order. **Constraints**: - The size of the input list, `n`, can be up to 10^6. - The range of integer values in the array is reasonably small such that `max(arr) - min(arr) <= 10^6`. - Your implementation should aim for linear time complexity, i.e., O(n + k). **Function Signature**: ```python def counting_sort_with_negatives(arr: list[int]) -> list[int]: pass ``` **Example**: ```python print(counting_sort_with_negatives([-5, -10, 0, -3, 8, 5, -1, 10])) # Output: [-10, -5, -3, -1, 0, 5, 8, 10] print(counting_sort_with_negatives([3, 3, 2, 1, 0, -1, -2, -3])) # Output: [-3, -2, -1, 0, 1, 2, 3, 3] print(counting_sort_with_negatives([])) # Output: [] ``` # Points for Consideration 1. **Edge cases**: - Test with an empty array. - Arrays with all identical elements. - Arrays with either all positive or all negative numbers. 2. **Optimizations**: - Efficient handling of negative values. - Minimize space usage where possible. Your task is to write a well-documented and efficient implementation addressing the points mentioned above. Ensure your code runs efficiently for large inputs while being easy to understand and maintain.","solution":"def counting_sort_with_negatives(arr: list[int]) -> list[int]: if not arr: return [] min_val = min(arr) max_val = max(arr) range_of_elements = max_val - min_val + 1 # Initialize count array count_arr = [0] * range_of_elements # Store the frequency of each element for num in arr: count_arr[num - min_val] += 1 # Modify count array to store the actual position of elements for i in range(1, len(count_arr)): count_arr[i] += count_arr[i - 1] # Initialize the output array output_arr = [0] * len(arr) # Build the output array by placing elements in their correct position # Ensure stable sorting by moving elements in reverse order for num in reversed(arr): output_arr[count_arr[num - min_val] - 1] = num count_arr[num - min_val] -= 1 return output_arr"},{"question":"# Problem: Mountain Climbing Ways Imagine you are climbing a mystical mountain which consists of several levels. Each level can be reached by either moving up 1 or 2 levels at a time from the previous level. You are given the total number of levels, `levels`. Your task is to determine how many distinct ways you can reach the top level. Write a function `number_of_ways_to_climb(levels)` that will compute the number of distinct ways to reach the top level of the mountain, given the following constraints: * **Input**: * `levels` (int) - A positive integer representing the total levels of the mountain (1 ≤ levels ≤ 10^6). * **Output**: * The function should return an integer which is the number of distinct ways to reach the top level. Example: ```python print(number_of_ways_to_climb(2)) # Output: 2 print(number_of_ways_to_climb(3)) # Output: 3 print(number_of_ways_to_climb(5)) # Output: 8 ``` # Constraints: * Your implementation should handle large values efficiently. * Consider both time and space complexity in your solution. **Scenario Context**: You are a star athlete training to climb a prestigious mystical mountain with multiple routes to the top. Counting and optimizing your distinct ways to reach the top helps in planning a strategic ascent. # Edge cases to consider: 1. Minimal value for `levels` (i.e., 1). 2. Large values for `levels`, testing the efficiency of your algorithm. # Performance Expectations: Your final solution should compute the result in linear time with consideration to optimize space complexity to O(1), ensuring it can handle the upper input constraints efficiently.","solution":"def number_of_ways_to_climb(levels): Returns the number of distinct ways to climb to the top of the mountain consisting of the given levels. if levels == 1: return 1 if levels == 2: return 2 previous, current = 1, 2 for _ in range(3, levels + 1): new_current = previous + current previous = current current = new_current return current"},{"question":"ZigZag Iterator for Multiple Lists You are required to implement a `ZigZagIterator` class that can iterate over multiple lists of integers in a zigzag manner. The iterator should traverse each element of the lists in turn, starting from the first list. Once all elements of one list are visited, it should continue with the remaining elements of the other lists in the order they were passed to the constructor. # Implementation Details: 1. **Constructor**: The constructor should accept a list of lists. 2. **Methods**: - `next()`: Should return the next element in zigzag order. If there are no more elements to return, it should raise an appropriate exception. - `has_next()`: Should return a boolean indicating whether there are any more elements to iterate over. # Input and Output Formats: - **Input**: Multiple lists of integers (e.g., `v1, v2, ..., vn` where each `vi` is a list of integers). - **Output**: The elements of these lists should be printed in zigzag order. # Example: ```python class ZigZagIterator: def __init__(self, lists): :type lists: List[List[int]] # Your implementation here def next(self): :rtype: int # Your implementation here def has_next(self): :rtype: bool # Your implementation here # Example usage: l1 = [1, 2, 3] l2 = [4, 5, 6, 7] l3 = [8, 9] it = ZigZagIterator([l1, l2, l3]) while it.has_next(): print(it.next()) ``` **Output**: ``` 1 4 8 2 5 9 3 6 7 ``` # Constraints: - All input lists are non-null. - Total number of elements across all lists will not exceed 10^5. - Each list will have at most 10^5 elements. # Notes: - Handle edge cases where one or more lists might be empty. - Ensure that the lists are exhausted in a round-robin fashion.","solution":"from collections import deque class ZigZagIterator: def __init__(self, lists): :type lists: List[List[int]] self.queue = deque([(lst, 0) for lst in lists if lst]) def next(self): :rtype: int if not self.has_next(): raise Exception(\\"No more elements.\\") lst, idx = self.queue.popleft() element = lst[idx] if idx + 1 < len(lst): self.queue.append((lst, idx + 1)) return element def has_next(self): :rtype: bool return bool(self.queue)"},{"question":"# Question: You are tasked with writing a function `reverse_pairs(stack)` that takes a stack as input and switches successive pairs of elements from the bottom of the stack. The function should return the modified stack. Utilize only a single queue (collections.deque) as auxiliary storage. Function Signature: ```python def reverse_pairs(stack: list) -> list: pass ``` Input: * `stack` (list): A stack of integers, where the \\"top\\" of the stack is the last element in the list. Output: * `list`: The modified stack with successive pairs switched. # Example: 1. **Input**: `stack = [3, 8, 17, 9, 1, 10]` **Output**: `[8, 3, 9, 17, 10, 1]` 2. **Input**: `stack = [3, 8, 17, 9, 1]` **Output**: `[8, 3, 9, 17, 1]` Constraints: * The stack can have up to 10,000 elements. * You should not use any other auxiliary storage apart from a queue. Notes: * Be sure to handle the cases where the stack has an odd number of elements. * The top element should remain in place if the stack has an odd count. * You may assume the stack contains only integers.","solution":"from collections import deque def reverse_pairs(stack: list) -> list: queue = deque() temp_stack = [] while stack: temp_stack.append(stack.pop()) while temp_stack: queue.append(temp_stack.pop()) while queue: first = queue.popleft() if queue: second = queue.popleft() stack.append(second) stack.append(first) else: stack.append(first) return stack"},{"question":"# Hailstone Sequence Analysis and Implementation Challenge Problem Statement Given a positive integer `n`, generate its hailstone sequence and also identify and return the length of the sequence and the maximum value reached within the sequence. A hailstone sequence is defined as follows: - If `n == 1`, the sequence ends. - If `n` is even, the next number in the sequence is `n/2`. - If `n` is odd, the next number in the sequence is `3*n + 1`. Task Write a function `hailstone_extended(n)` which takes one positive integer `n` as the input and returns a tuple containing three elements: 1. The generated hailstone sequence as a list of integers. 2. The length of the hailstone sequence. 3. The maximum value reached in the sequence. Input: - `n` (an integer, 1 ≤ n ≤ 10^6) Output: - A tuple `(sequence, length, max_value)` where: * `sequence` is a list of integers representing the hailstone sequence starting at `n` and ending at 1. * `length` is the number of elements in the sequence. * `max_value` is the largest integer value encountered in the sequence. Examples: ```python # Example 1 print(hailstone_extended(5)) # Expected Output: ([5, 16, 8, 4, 2, 1], 6, 16) # Example 2 print(hailstone_extended(1)) # Expected Output: ([1], 1, 1) # Example 3 print(hailstone_extended(10)) # Expected Output: ([10, 5, 16, 8, 4, 2, 1], 7, 16) ``` Constraints: - Ensure your code handles large sequences efficiently to avoid performance bottlenecks.","solution":"def hailstone_extended(n): Generate the hailstone sequence for a given integer n. Args: n (int): A positive integer (1 ≤ n ≤ 10^6) Returns: tuple: A tuple (sequence, length, max_value) where sequence is a list of integers representing the hailstone sequence, length is the number of elements in the sequence, max_value is the largest integer value encountered in the sequence. sequence = [] max_value = n while n != 1: sequence.append(n) if n % 2 == 0: n = n // 2 else: n = 3 * n + 1 max_value = max(max_value, n) sequence.append(1) # the sequence always ends at 1 return sequence, len(sequence), max_value"},{"question":"# Question Description You are given an array of k linked lists, each linked list is sorted in ascending order. Your task is to merge all the linked lists into one sorted linked list and return it. To accomplish this task, you will use a min-heap (priority queue) to efficiently extract the minimum element from the current heads of the linked lists at each step. # Function Signature ```python class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def merge_k_sorted_lists(lists: List[ListNode]) -> ListNode: pass ``` # Input - `lists`: A list of k linked list heads, where each linked list is already sorted in ascending order. - Each ListNode contains an integer value and a next pointer. # Output - Return the head of the merged and sorted linked list. # Constraints - The number of linked lists, `k`, should be at most 200. - The total number of nodes in all linked lists is at most 10,000. - The node values are within the integer range. # Requirements - Your implementation should handle edge cases like empty input lists. - Maintain a time complexity constraint of O(N log k) and space complexity of O(k). # Example ```python # Example 1: # Input: lists = [[1->4->5], [1->3->4], [2->6]] # Output: [1->1->2->3->4->4->5->6] node1 = ListNode(1, ListNode(4, ListNode(5))) node2 = ListNode(1, ListNode(3, ListNode(4))) node3 = ListNode(2, ListNode(6)) lists = [node1, node2, node3] result = merge_k_sorted_lists(lists) # Output: a single linked list 1->1->2->3->4->4->5->6 # Example 2: # Input: lists = [] # Output: [] lists = [] result = merge_k_sorted_lists(lists) # Output: a single linked list which is empty ``` Implement the `merge_k_sorted_lists` function by efficiently merging the linked lists using a min-heap.","solution":"import heapq class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def __lt__(self, other): # Define less than for ListNode to be able to compare nodes in the heap return self.val < other.val def merge_k_sorted_lists(lists): Merges k sorted linked lists into one sorted linked list. :param lists: List of ListNode, each representing the head of a sorted linked list. :return: ListNode representing the head of the merged sorted linked list. if not lists: return None min_heap = [] # Initialize the heap for l in lists: if l: heapq.heappush(min_heap, l) # Dummy head to simplify the merge process dummy = ListNode() current = dummy while min_heap: # Extract the smallest node from the heap smallest_node = heapq.heappop(min_heap) # Add the smallest node to the merged linked list current.next = smallest_node current = current.next # If there is a next node in the extracted node’s list, add it to the heap if smallest_node.next: heapq.heappush(min_heap, smallest_node.next) return dummy.next"},{"question":"# Scenario You are developing a script for a tool that processes files provided by users. The tool should reliably handle paths provided in various formats and convert them to absolute paths to avoid errors due to relative path usage or home directory shortcuts. # Task Implement a function that takes a list of file paths and converts each of them to their absolute path. Ensure your code handles edge cases such as paths with `~` and already absolute paths. # Function Signature ```python def convert_to_absolute_paths(paths: List[str]) -> List[str]: pass ``` # Input - `paths`: A list of strings, where each string is a file path. The list contains at least one path and paths can be relative, absolute, or include the `~` symbol for the user’s home directory. # Output - Returns a list of strings, where each string is the absolute path corresponding to the input paths. # Constraints - Paths are non-empty strings. - The file paths are compatible with the `os.path` operations in Python. # Example ```python # Example invocation input_paths = [\\"~/documents/file.txt\\", \\"/etc/config\\", \\"subdir/file.txt\\"] output = convert_to_absolute_paths(input_paths) ``` If the home directory is `/home/user`, then the output might look like: ```python [\\"/home/user/documents/file.txt\\", \\"/etc/config\\", \\"/absolute/path/to/subdir/file.txt\\"] ``` Note: The exact output depends on the home directory and the current working directory for relative paths.","solution":"from typing import List import os def convert_to_absolute_paths(paths: List[str]) -> List[str]: Takes a list of file paths and converts each of them to their absolute path. Parameters: paths (List[str]): A list of file paths (relative, absolute, or with `~`). Returns: List[str]: A list of absolute paths. return [os.path.abspath(os.path.expanduser(path)) for path in paths]"},{"question":"Design a class for storing and efficiently searching words. The class should allow adding words (strings) and searching using literal strings or pattern strings containing the wildcard character \'.\' which can represent any letter. Your task is to implement a `WordDictionary` class supporting the following methods: 1. `addWord(word: str) -> None` - Adds a word to the data structure. 2. `search(word: str) -> bool` - Returns `True` if the word (literal or pattern) exists in the data structure, otherwise `False`. # Requirements - Implement the `WordDictionary` class using a trie (prefix tree). - Optimize the search function to handle pattern strings efficiently. - Ensure each method runs in O(n) time complexity, where `n` is the length of the word. # Constraints 1. All input strings (words or patterns) will be lowercase letters. 2. The length of any word or pattern will not exceed 100. 3. The number of add and search operations will not exceed 1000. # Example ```python word_dict = WordDictionary() word_dict.add_word(\\"bad\\") word_dict.add_word(\\"dad\\") word_dict.add_word(\\"mad\\") print(word_dict.search(\\"pad\\")) # Output: False (no word \\"pad\\" added) print(word_dict.search(\\"bad\\")) # Output: True (word \\"bad\\" exists) print(word_dict.search(\\".ad\\")) # Output: True (\\".\\" can represent \\"b\\", \\"d\\", \\"m\\") print(word_dict.search(\\"b..\\")) # Output: True (\\"..\\" can represent \\"ad\\", \\"ed\\", etc.) ``` # Implementation Challenge 1. Handle edge cases such as searching for non-existent words or patterns with multiple wildcards efficiently. 2. Use appropriate data structures and algorithms to optimize performance and minimize memory usage.","solution":"class WordDictionary: def __init__(self): Initialize the WordDictionary. self.trie = {} def addWord(self, word: str) -> None: Adds a word to the data structure. node = self.trie for char in word: if char not in node: node[char] = {} node = node[char] node[\'#\'] = True def search(self, word: str) -> bool: Returns if the word (literal or pattern using \'.\' as any character) exists in the data structure. def dfs(node, i): Depth-first search to handle \'.\' wildcard. if i == len(word): return \'#\' in node if word[i] == \'.\': for char in node: if char != \'#\' and dfs(node[char], i + 1): return True return False if word[i] in node: return dfs(node[word[i]], i + 1) return False return dfs(self.trie, 0)"},{"question":"# Question: Implement and Extend a Randomized Set Context: You are tasked with enhancing a data structure that supports insert, remove, and get_random operations in O(1) average time. Your task is to implement and extend this data structure to include two additional operations. The new operations are to retrieve the smallest and largest elements in the set efficiently. Instructions: 1. Implement a `RandomizedSet` class with the following methods: * `insert(val)`: Inserts an item `val` to the set if not already present. Returns `True` if the element was not present and `False` otherwise. * `remove(val)`: Removes an item `val` from the set if present. Returns `True` if the element was present and `False` otherwise. * `get_random()`: Returns a random element from the current set of elements. Each element must have the same probability of being returned. * `get_min()`: Returns the smallest element in the set. * `get_max()`: Returns the largest element in the set. 2. Ensure that all operations (`insert`, `remove`, `get_random`, `get_min`, and `get_max`) have an average time complexity of O(1). 3. Follow these constraints: * All elements in the set will be unique integers. * The set can be initially empty, and elements are dynamically added and removed. Expected Methods Signature: ```python class RandomizedSet: def __init__(self): # Initialize your data structure here pass def insert(self, val: int) -> bool: # Inserts a value to the set pass def remove(self, val: int) -> bool: # Removes a value from the set pass def get_random(self) -> int: # Returns a random element from the set pass def get_min(self) -> int: # Returns the smallest element in the set pass def get_max(self) -> int: # Returns the largest element in the set pass ``` Example Scenario: ```python rs = RandomizedSet() assert rs.insert(1) == True assert rs.insert(2) == True assert rs.insert(3) == True assert rs.insert(4) == True assert rs.remove(3) == True assert rs.get_random() in {1, 2, 4} assert rs.get_min() == 1 assert rs.get_max() == 4 assert rs.remove(1) == True assert rs.get_min() == 2 assert rs.get_max() == 4 ``` Consider all edge cases, such as operations on an empty set, when implementing your solution.","solution":"import random class RandomizedSet: def __init__(self): Initialize your data structure here. self.value_map = {} self.value_list = [] self.min_val = None self.max_val = None def insert(self, val: int) -> bool: Inserts a value to the set. Returns true if the set did not already contain the specified element. if val in self.value_map: return False self.value_map[val] = len(self.value_list) self.value_list.append(val) if self.min_val is None or val < self.min_val: self.min_val = val if self.max_val is None or val > self.max_val: self.max_val = val return True def remove(self, val: int) -> bool: Removes a value from the set. Returns true if the set contained the specified element. if val not in self.value_map: return False idx = self.value_map[val] last_element = self.value_list[-1] self.value_list[idx] = last_element self.value_map[last_element] = idx self.value_list.pop() del self.value_map[val] if len(self.value_list) == 0: self.min_val = None self.max_val = None else: if val == self.min_val or val == self.max_val: self.min_val = min(self.value_list) self.max_val = max(self.value_list) return True def get_random(self) -> int: Get a random element from the set. return random.choice(self.value_list) def get_min(self) -> int: Retrieves the minimum element from the set. return self.min_val def get_max(self) -> int: Retrieves the maximum element from the set. return self.max_val"},{"question":"Scenario You are working on a software project that involves processing linked lists. Currently, your task includes implementing a function that verifies whether a given singly linked list of integers is palindromic. A palindromic list reads the same forwards and backwards. Function Description You need to implement the following function: ```python def is_palindrome(head: ListNode) -> bool: # Your code here ``` Where: - `head` is the head node of the singly linked list. Input Format - `head`: a `ListNode`, which is the starting node of the linked list. Output Format - Return `True` if the linked list is a palindrome, `False` otherwise. Constraints - The number of nodes in the list is in the range [0, 10^5]. - `-10^5 <= Node.val <= 10^5`. Example **Example 1:** ``` Input: 1 -> 2 -> 2 -> 1 Output: True Explanation: The list reads forwards as [1, 2, 2, 1] and backwards as [1, 2, 2, 1], so it is a palindrome. ``` **Example 2:** ``` Input: 1 -> 2 Output: False Explanation: The list reads forwards as [1, 2] and backwards as [2, 1], so it is not a palindrome. ``` What to Consider 1. Handle empty lists and single node lists properly. 2. Optimize for both time and space complexity. 3. Ensure your solution can handle large lists. You may use the given code snippets as inspiration but the final implementation must efficiently check for palindrome properties in the most optimal way possible.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def is_palindrome(head: ListNode) -> bool: if not head or not head.next: return True # Find the middle of the linked list slow = fast = head while fast and fast.next: slow = slow.next fast = fast.next.next # Reverse the second half of the list prev = None while slow: temp = slow.next slow.next = prev prev = slow slow = temp # Compare the two halves left, right = head, prev while right: if left.val != right.val: return False left = left.next right = right.next return True"},{"question":"# Two Unique Numbers in Array Given an array of integers `nums`, exactly two elements in this array appear only once, and all the other elements appear exactly twice. Your task is to write a function `find_unique_numbers` to identify the two elements that appear only once. **Function Signature**: ```python def find_unique_numbers(nums: List[int]) -> List[int]: pass ``` # Input - `nums`: A list of integers where exactly two elements appear once and all others appear exactly twice. # Output - A list of two integers that appear only once in the input list. The order of the result is not important, and it can be either `[a, b]` or `[b, a]`. # Constraints 1. The length of `nums` will be at least 2. 2. The integers in `nums` are not necessarily sorted. 3. You must accomplish this in O(N) time complexity and O(1) space complexity. # Example ```python assert find_unique_numbers([1, 2, 1, 3, 2, 5]) in [[3, 5], [5, 3]] assert find_unique_numbers([4, 1, 2, 1, 2, 3]) in [[4, 3], [3, 4]] assert find_unique_numbers([-1, 0, 0, -2]) in [[-1, -2], [-2, -1]] ``` # Notes * To solve this problem, you are required to use bit manipulation and the XOR operation. * Ensure edge cases such as very small arrays and the presence of negative numbers are handled properly. Additional Context The provided algorithm uses bit manipulation to segregate and identify the unique numbers. Understanding the XOR operation and its properties is crucial. The detailed steps provided in the solution outline can help guide the implementation. ```python def find_unique_numbers(nums): # isolate a^b from pairs using XOR ab = 0 for n in nums: ab ^= n # isolate right most bit from a^b right_most = ab & (-ab) # isolate a and b from a^b a, b = 0, 0 for n in nums: if n & right_most: a ^= n else: b ^= n return [a, b] ```","solution":"from typing import List def find_unique_numbers(nums: List[int]) -> List[int]: # XOR all numbers to get a^b, where a and b are the unique numbers ab = 0 for n in nums: ab ^= n # Find the rightmost set bit right_most = ab & -ab # Divide numbers into two groups based on the rightmost set bit a, b = 0, 0 for n in nums: if n & right_most: a ^= n else: b ^= n return [a, b]"},{"question":"# Coursework Assessment Question Problem Statement Given the provided implementation of a directed graph (`DirectedGraph`), implement a function to find all nodes reachable from a given starting node using Depth-First Search (DFS). Your function should return the list of reachable nodes in the order they are first discovered by the DFS. Ensure your solution handles cycles in the graph, and visits each node no more than once. Function Signature ```python def find_reachable_nodes(graph: DirectedGraph, start_node: str) -> list: Given a directed graph and a starting node, return all nodes reachable from the start node using DFS. Args: graph (DirectedGraph): A directed graph instance. start_node (str): The name of the node to start DFS from. Returns: list: List of node names reachable from start_node in DFS order. pass ``` Input and Output * **Input**: * `graph`: An instance of `DirectedGraph` representing the graph. * `start_node`: A string representing the name of the starting node for DFS. * **Output**: * A list of strings, each representing the name of a reachable node in the order they were discovered by DFS. Constraints * Nodes\' names within the graph are unique strings. * The `start_node` will always be a valid node name present in the graph. * The graph may contain cycles. Example ```python # Example graph structure: graph_data = { \'A\': [\'B\', \'C\'], \'B\': [\'C\', \'D\'], \'C\': [], \'D\': [\'A\'] } graph = DirectedGraph(graph_data) result = find_reachable_nodes(graph, \'A\') print(result) # Output: [\'A\', \'B\', \'C\', \'D\'] ``` Explanation * From node \'A\', you can reach \'B\', \'C\', and \'D\'. * \'A\' -> \'B\', \'A\' -> \'C\', \'A\' -> \'D\'. * The order depends on DFS priority which typically returns traversed paths. # Notes * Consider iterative implementations to avoid recursion limits with deep graphs. * Ensure you handle graph cycles and avoid revisiting nodes. * Maintain optimal time complexity by minimizing redundant operations.","solution":"class DirectedGraph: def __init__(self, adjacency_list): self.adjacency_list = adjacency_list def get_neighbors(self, node): return self.adjacency_list.get(node, []) def find_reachable_nodes(graph: DirectedGraph, start_node: str) -> list: visited = set() reachable_nodes = [] def dfs(node): if node not in visited: visited.add(node) reachable_nodes.append(node) for neighbor in graph.get_neighbors(node): dfs(neighbor) dfs(start_node) return reachable_nodes"},{"question":"# Run-Length Encoding and Decoding Implementation Objective Test your understanding of compression algorithms by implementing Run-Length Encoding (RLE) for data compression and its inverse for decompression. Problem Statement You are given a string and you need to implement two functions: 1. `encode_rle` to compress the given string using Run-Length Encoding. 2. `decode_rle` to decompress a string encoded using Run-Length Encoding. Function Signatures ```python def encode_rle(input: str) -> str: pass def decode_rle(input: str) -> str: pass ``` Input * `encode_rle`: * A string consisting of lowercase alphabetic characters (`a-z`) and digits (`0-9`). * `decode_rle`: * A string in the encoded Run-Length format `[count][character]`, where `count` is a series of digits and `character` is a single lowercase alphabetic character (`a-z`). Output * `encode_rle`: * A string representing the input in Run-Length encoded format. * `decode_rle`: * A string representing the original uncompressed data. Constraints * The input strings will be non-empty. * The counts for the characters in the encoded string are always valid positive integers. Example *Example 1*: ```python input = \\"aaabbcccc\\" encoded = encode_rle(input) print(encoded) # Output: \\"3a2b4c\\" decoded = decode_rle(encoded) print(decoded) # Output: \\"aaabbcccc\\" ``` *Example 2*: ```python input = \\"hheellloooo\\" encoded = encode_rle(input) print(encoded) # Output: \\"2h2e3l4o\\" decoded = decode_rle(encoded) print(decoded) # Output: \\"hheellloooo\\" ``` Edge Case ```python input = \\"a\\" encoded = encode_rle(input) print(encoded) # Output: \\"1a\\" decoded = decode_rle(encoded) print(decoded) # Output: \\"a\\" ``` Your goal is to ensure both functions handle all cases efficiently and correctly. Implement the functions to provide accurate compression and decompression.","solution":"def encode_rle(input: str) -> str: Compresses the given string using Run-Length Encoding. if not input: return \\"\\" encoded = [] i = 0 while i < len(input): count = 1 while i + 1 < len(input) and input[i] == input[i + 1]: i += 1 count += 1 encoded.append(f\\"{count}{input[i]}\\") i += 1 return \'\'.join(encoded) def decode_rle(input: str) -> str: Decompresses a string encoded using Run-Length Encoding. decoded = [] i = 0 while i < len(input): count = 0 while i < len(input) and input[i].isdigit(): count = count * 10 + int(input[i]) i += 1 char = input[i] decoded.append(char * count) i += 1 return \'\'.join(decoded)"},{"question":"# Maximum Flow Problem Background You are given a network of pipes represented as a graph where: - Each node represents a junction. - Each edge represents a pipe with a certain capacity. - The first node (index 0) is the source from which water is sent. - The last node (index n-1) is the sink where water is collected. Your task is to determine the maximum amount of water that can flow from the source to the sink using Depth-First Search (DFS) for path finding. Function Signature ```python def maximum_flow_dfs(adjacency_matrix: list[list[int]]) -> int: Given an n x n adjacency matrix representing the capacities of the edges in a flow network, return the maximum flow from the source node (node 0) to the sink node (node n-1). Parameters: adjacency_matrix (list[list[int]]): The adjacency matrix of the flow network. Returns: int: The maximum flow from the source to the sink node. ``` Input - An integer (n) (2 ≤ n ≤ 100) representing the number of nodes. - An (n times n) adjacency matrix where the value at (matrix[i][j]) represents the capacity of the edge from node (i) to node (j). If there is no edge between (i) and (j), the value is 0. Output - An integer representing the maximum flow from the source node (0) to the sink node (n-1). Example ```python graph = [ [0, 16, 13, 0, 0, 0], [0, 0, 10, 12, 0, 0], [0, 4, 0, 0, 14, 0], [0, 0, 9, 0, 0, 20], [0, 0, 0, 7, 0, 4], [0, 0, 0, 0, 0, 0] ] assert maximum_flow_dfs(graph) == 23 ``` Constraints - The capacities are non-negative integers. - There is always a path from the source to the sink. Notes - Focus on providing a clear, efficient implementation. - Consider edge cases, such as graphs with zero capacity edges, no direct path, and multiple paths with different capacities. - Ensure to properly handle the residual capacities and correctly find the augmenting paths using DFS.","solution":"def dfs(capacity, flow, source, sink, visited): stack = [source] parents_map = {source: None} while stack: current_node = stack.pop() if current_node == sink: break for neighbor, cap in enumerate(capacity[current_node]): if cap - flow[current_node, neighbor] > 0 and neighbor not in visited: stack.append(neighbor) visited.add(neighbor) parents_map[neighbor] = current_node if neighbor == sink: break path = [] if sink in parents_map: node = sink while node is not None: path.append(node) node = parents_map[node] path.reverse() return path def maximum_flow_dfs(adjacency_matrix): n = len(adjacency_matrix) flow = {(i, j): 0 for i in range(n) for j in range(n)} max_flow = 0 source, sink = 0, n - 1 while True: visited = set() visited.add(source) path = dfs(adjacency_matrix, flow, source, sink, visited) if not path: break path_flow = float(\'Inf\') for i in range(len(path) - 1): u, v = path[i], path[i + 1] path_flow = min(path_flow, adjacency_matrix[u][v] - flow[u, v]) for i in range(len(path) - 1): u, v = path[i], path[i + 1] flow[u, v] += path_flow flow[v, u] -= path_flow max_flow += path_flow return max_flow"},{"question":"Scenario You are working on a text editor application that helps users compare different versions of documents. To track changes and suggest corrections effectively, you need to calculate the edit distance between two text strings—representing different versions of a document. Task Write a function `edit_distance` that takes two strings, `word_a` and `word_b`, and returns the minimum number of operations needed to convert `word_a` into `word_b`. An operation is defined as either: * **Insertion** of a character. * **Deletion** of a character. * **Substitution** of one character for another. Function Signature ```python def edit_distance(word_a: str, word_b: str) -> int: ... ``` Input * `word_a`: A string of length n (0 <= n <= 1000). * `word_b`: A string of length m (0 <= m <= 1000). Output * Return an integer representing the minimum number of operations required to convert `word_a` into `word_b`. Constraints * Strings may contain any printable ASCII characters. * Function must handle large strings efficiently within O(n * m) time complexity. Example ```python assert edit_distance(\\"FOOD\\", \\"MONEY\\") == 4 assert edit_distance(\\"intention\\", \\"execution\\") == 5 assert edit_distance(\\"\\", \\"abc\\") == 3 assert edit_distance(\\"aaa\\", \\"aaa\\") == 0 ``` You should ensure edge cases such as empty strings and identical strings are handled correctly. Focus on optimizing your solution and considering the memory usage for large inputs.","solution":"def edit_distance(word_a: str, word_b: str) -> int: n = len(word_a) m = len(word_b) # Create a table to store results of subproblems dp = [[0] * (m + 1) for _ in range(n + 1)] # Fill dp[][] in bottom up manner for i in range(n + 1): for j in range(m + 1): # If first string is empty, only option is to # insert all characters of second string if i == 0: dp[i][j] = j # Min. operations = j # If second string is empty, only option is to # remove all characters of first string elif j == 0: dp[i][j] = i # Min. operations = i # If last characters are same, ignore last character # and recur for remaining string elif word_a[i-1] == word_b[j-1]: dp[i][j] = dp[i-1][j-1] # If the last character is different, consider all # possibilities and find the minimum else: dp[i][j] = 1 + min(dp[i][j-1], # Insert dp[i-1][j], # Remove dp[i-1][j-1]) # Replace return dp[n][m]"},{"question":"# Coding Challenge **Context**: In certain geometrical problems, you need to compute the missing side length of a right-angled triangle. However, your current implementation is expected to handle incorrect input gracefully and optimize certain edge cases. **Task**: Write a function `calculate_missing_side(opposite, adjacent, hypotenuse)` that determines the missing side length of a right-angled triangle, given the lengths of the other two sides. Extend the given implementation to handle and validate input more effectively. # Function Signature ```python def calculate_missing_side(opposite: str, adjacent: str, hypotenuse: str) -> str: pass ``` # Input & Output * Inputs: * `opposite`, `adjacent`, `hypotenuse` (of type `str`): The lengths of the sides of the right-angled triangle. Use \\"?\\" to denote the unknown side. * Output: * Returns a string indicating the length of the missing side named appropriately (\\"Opposite\\", \\"Adjacent\\", or \\"Hypotenuse\\"). # Constraints * Only one of the inputs will be a \\"?\\". * All provided side lengths will be non-negative floats in string format. * Ensure robust error handling for cases such as non-numeric sides, impossible triangles (e.g., negative length for a known side). # Examples 1. `calculate_missing_side(\\"3\\", \\"4\\", \\"?\\")` should return `\\"Hypotenuse = 5.0\\"` 2. `calculate_missing_side(\\"3\\", \\"?\\", \\"5\\")` should return `\\"Adjacent = 4.0\\"` 3. `calculate_missing_side(\\"?\\", \\"4\\", \\"5\\")` should return `\\"Opposite = 3.0\\"` # Additional Requirements 1. Ensure that the input sides form a valid triangle. 2. Provide meaningful error messages for invalid inputs. 3. Optimize performance and memory use as much as possible.","solution":"import math def calculate_missing_side(opposite: str, adjacent: str, hypotenuse: str) -> str: Determine the length of the missing side of a right-angled triangle. Parameters: opposite (str): The length of the opposite side or \\"?\\" if unknown. adjacent (str): The length of the adjacent side or \\"?\\" if unknown. hypotenuse (str): The length of the hypotenuse or \\"?\\" if unknown. Returns: str: The name and length of the missing side. known_sides = [opposite, adjacent, hypotenuse] # Ensure exactly one side is unknown if known_sides.count(\\"?\\") != 1: raise ValueError(\\"Exactly one side must be unknown (denoted by \'?\').\\") try: if opposite != \\"?\\": opposite = float(opposite) if adjacent != \\"?\\": adjacent = float(adjacent) if hypotenuse != \\"?\\": hypotenuse = float(hypotenuse) except ValueError: raise ValueError(\\"All side lengths must be numeric values or \'?\'.\\") # Ensuring non-negative length if ((opposite != \\"?\\" and opposite < 0) or (adjacent != \\"?\\" and adjacent < 0) or (hypotenuse != \\"?\\" and hypotenuse < 0)): raise ValueError(\\"Side lengths cannot be negative.\\") if hypotenuse == \\"?\\": hypotenuse = math.sqrt(opposite ** 2 + adjacent ** 2) return f\\"Hypotenuse = {hypotenuse:.1f}\\" elif adjacent == \\"?\\": if hypotenuse <= opposite: raise ValueError(\\"Hypotenuse must be the largest side.\\") adjacent = math.sqrt(hypotenuse ** 2 - opposite ** 2) return f\\"Adjacent = {adjacent:.1f}\\" else: if hypotenuse <= adjacent: raise ValueError(\\"Hypotenuse must be the largest side.\\") opposite = math.sqrt(hypotenuse ** 2 - adjacent ** 2) return f\\"Opposite = {opposite:.1f}\\""},{"question":"# Question Ternary Search Function Write a function `ternary_search_recursive` that takes in four parameters: the array `arr`, the left index `left`, the right index `right`, and the key to search for `key`. This function should use a recursive ternary search algorithm to find the key in the sorted array `arr`. The function should return the index of the key if it is found, otherwise, return -1. Constraints * The array `arr` is guaranteed to be sorted in ascending order. * The function should handle typical edge cases such as empty array and single-element arrays. * The function must use a recursive instead of an iterative approach. Input * An integer array `arr` sorted in ascending order. (0 ≤ len(arr) ≤ 10^6) * Two integers `left` and `right` representing the search range within the array. * An integer `key` representing the target value to search for. Output * An integer representing the index of the target value in the array. If the target value is not found, return -1. Example 1 ```python arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] left = 0 right = len(arr) - 1 key = 5 assert ternary_search_recursive(arr, left, right, key) == 4 ``` Example 2 ```python arr = [1, 3, 5, 7, 9] left = 0 right = len(arr) - 1 key = 4 assert ternary_search_recursive(arr, left, right, key) == -1 ``` Example 3 ```python arr = [10, 20, 30, 40, 50] left = 0 right = len(arr) - 1 key = 50 assert ternary_search_recursive(arr, left, right, key) == 4 ``` Implementation Define the function `ternary_search_recursive` as described. Use recursion to implement the ternary search logic. ```python def ternary_search_recursive(arr, left, right, key): Recursive ternary search function to find the key in the sorted array. Parameters: arr (list of int): The sorted array in which to search. left (int): The starting index of the search range. right (int): The ending index of the search range. key (int): The target value to search for. Returns: int: Index of the target value if found, otherwise -1. # Your code here ```","solution":"def ternary_search_recursive(arr, left, right, key): Recursive ternary search function to find the key in the sorted array. Parameters: arr (list of int): The sorted array in which to search. left (int): The starting index of the search range. right (int): The ending index of the search range. key (int): The target value to search for. Returns: int: Index of the target value if found, otherwise -1. if left > right: return -1 third = (right - left) // 3 mid1 = left + third mid2 = right - third if arr[mid1] == key: return mid1 if arr[mid2] == key: return mid2 if key < arr[mid1]: return ternary_search_recursive(arr, left, mid1 - 1, key) elif key > arr[mid2]: return ternary_search_recursive(arr, mid2 + 1, right, key) else: return ternary_search_recursive(arr, mid1 + 1, mid2 - 1, key) return -1 # Default return if the element is not found"},{"question":"# Coding Challenge: Implement Run-Length Encoding Enhancements You are given the implementation of the Run-Length Encoding (RLE) algorithm. Your task is to enhance this algorithm to handle specific constraints and extend its functionality. **Task 1: Enhanced Encoding** 1. Update the encoding function to handle both lowercase and uppercase letters. Currently, assume input consists of only a-z. 2. If the repeating characters form a sequence of 10 or more, split the group such that each compressed unit does not exceed 9 repetitions (for ease of representation). **Task 2: Enhanced Decoding** 1. Update the decoding function to handle the enhanced encoded format. 2. Return an appropriate error message (like \\"invalid input\\") for any malformed encoded input. # Function Signatures ```python def enhanced_encode_rle(input: str) -> str: pass def enhanced_decode_rle(input: str) -> str: pass ``` # Example ```python # Example Input/Output for Enhanced Encoding: print(enhanced_encode_rle(\\"AAABBBBCCCCC\\")) # Output: \\"3A4B5C\\" print(enhanced_encode_rle(\\"AAAAAAAAAAB\\")) # Output: \\"9A1A1B\\" # Example Input/Output for Enhanced Decoding: print(enhanced_decode_rle(\\"3A4B5C\\")) # Output: \\"AAABBBBCCCCC\\" print(enhanced_decode_rle(\\"9A1A1B\\")) # Output: \\"AAAAAAAAAAB\\" print(enhanced_decode_rle(\\"9A11B\\")) # Output: \\"invalid input\\" ``` # Notes - You do not need to worry about input containing invalid characters for the encode function. - Ensure you handle edge cases effectively in both functions. - Aim to keep the complexity of your solution within O(n) time and O(1) additional space.","solution":"def enhanced_encode_rle(input: str) -> str: if not input: return \\"\\" encoded = [] prev_char = input[0] count = 1 for char in input[1:]: if char == prev_char: count += 1 if count == 10: encoded.append(f\\"9{prev_char}\\") count = 1 else: encoded.append(f\\"{count}{prev_char}\\") prev_char = char count = 1 if count > 0: encoded.append(f\\"{count}{prev_char}\\") return \'\'.join(encoded) def enhanced_decode_rle(input: str) -> str: if not input: return \\"\\" decoded = [] length = len(input) i = 0 while i < length: if i + 1 < length and input[i].isdigit() and input[i+1].isalpha(): count = int(input[i]) char = input[i+1] decoded.append(char * count) i += 2 else: return \\"invalid input\\" return \'\'.join(decoded)"},{"question":"You have been assigned the task of improving the functionality of a Binary Search Tree (BST) to support additional operations efficiently. The current BST implementation includes methods for insertion, searching, size calculation, and traversals (i.e., preorder, inorder, and postorder). Your task is to implement the following functionalities in the given Binary Search Tree code: 1. **Find Minimum**: Implement a method to find and return the minimum value node in the BST. 2. **Find Maximum**: Implement a method to find and return the maximum value node in the BST. 3. **Delete Node**: Implement a method to delete a node with a specific value from the BST, ensuring the tree remains a valid BST after the deletion. # Requirements * Extend the existing `BST` class with the following methods: - `find_min(self) -> Optional[Node]`: Finds and returns the node with the minimum value in the BST. - `find_max(self) -> Optional[Node]`: Finds and returns the node with the maximum value in the BST. - `delete(self, data: int) -> bool`: Deletes a node with the value `data` from the tree. Returns `True` if the node was successfully deleted, `False` if the node was not found. # Input and Output Formats * `find_min` and `find_max` return a `Node` or `None` if the tree is empty. * `delete` returns a boolean indicating the success of the deletion. * Constraints: - Each element in the BST will be a unique integer. # Performance Requirements Ensure the methods are implemented with average case O(log N) complexity to maintain efficiency typical to BST operations. # Example Usage ```python # Initialize tree and insert some values tree = BST() tree.insert(10) tree.insert(5) tree.insert(20) tree.insert(3) tree.insert(7) # Find minimum and maximum min_node = tree.find_min() # Should return Node with value 3 max_node = tree.find_max() # Should return Node with value 20 # Delete a node deletion_success = tree.delete(5) # Should return True found_after_deletion = tree.search(5) # Should return False ``` # Unit Testing Ensure your implementation passes the following unit tests: ```python import unittest class TestBSTExtensions(unittest.TestCase): def setUp(self): self.tree = BST() self.tree.insert(10) self.tree.insert(15) self.tree.insert(6) self.tree.insert(4) self.tree.insert(9) self.tree.insert(12) self.tree.insert(24) self.tree.insert(7) self.tree.insert(20) self.tree.insert(30) self.tree.insert(18) def test_find_min(self): min_node = self.tree.find_min() self.assertIsNotNone(min_node) self.assertEqual(min_node.data, 4) def test_find_max(self): max_node = self.tree.find_max() self.assertIsNotNone(max_node) self.assertEqual(max_node.data, 30) def test_delete(self): self.assertTrue(self.tree.delete(6)) self.assertFalse(self.tree.search(6)) self.assertFalse(self.tree.delete(50)) if __name__ == \'__main__\': unittest.main() ```","solution":"class Node: def __init__(self, key): self.left = None self.right = None self.value = key class BST: def __init__(self): self.root = None def insert(self, key): if self.root is None: self.root = Node(key) else: self._insert(self.root, key) def _insert(self, root, key): if key < root.value: if root.left is None: root.left = Node(key) else: self._insert(root.left, key) else: if root.right is None: root.right = Node(key) else: self._insert(root.right, key) def search(self, key): return self._search(self.root, key) def _search(self, root, key): if root is None or root.value == key: return root is not None if key < root.value: return self._search(root.left, key) return self._search(root.right, key) def find_min(self): current = self.root while current and current.left: current = current.left return current def find_max(self): current = self.root while current and current.right: current = current.right return current def delete(self, data): self.root, deleted = self._delete(self.root, data) return deleted def _delete(self, root, data): if root is None: return root, False if data < root.value: root.left, deleted = self._delete(root.left, data) elif data > root.value: root.right, deleted = self._delete(root.right, data) else: if root.left is None: return root.right, True elif root.right is None: return root.left, True temp = self._find_min(root.right) root.value = temp.value root.right, _ = self._delete(root.right, temp.value) deleted = True return root, deleted def _find_min(self, node): current = node while current.left: current = current.left return current"},{"question":"A country is planning to gather supplies for a space mission. They have a set of supply packages, each with a certain value and weight. Given a spaceship\'s load capacity, the goal is to select the supply packages in a way that maximizes the total value without exceeding the load capacity. Write a function `maximize_supply_value(items, capacity)` that determines the maximum value of supply packages that can be included in the spaceship. The function should use a dynamic programming approach similar to the 0/1 Knapsack problem. # Function Signature ```python def maximize_supply_value(items: List[Tuple[int, int]], capacity: int) -> int: :param items: A list of tuples where each tuple contains two integers (value, weight) representing the value and weight of a supply package. :param capacity: An integer representing the load capacity of the spaceship. :return: An integer representing the maximum value of supply packages that can be included in the spaceship. pass ``` # Input - `items` : A list of tuples `[(value1, weight1), (value2, weight2), ..., (valueN, weightN)]`, where: - `valuei` (1 ≤ `valuei` ≤ 1000) is an integer representing the value of the i-th supply package. - `weighti` (1 ≤ `weighti` ≤ 1000) is an integer representing the weight of the i-th supply package. - `capacity` : An integer (0 ≤ `capacity` ≤ 10^5) representing the maximum load capacity of the spaceship. # Output - An integer representing the maximum value of supply packages that can be included in the spaceship without exceeding the load capacity. # Example ```python items = [(60, 5), (50, 3), (70, 4), (30, 2)] capacity = 5 print(maximize_supply_value(items, capacity)) # Output: 80 ``` # Constraints 1. All supply packages must have a positive value and weight. 2. The function should run within a reasonable time frame for large capacities and item sets (up to 1000 items). # Notes - Be sure to handle edge cases like no items list or zero capacity. - Implement the function using a dynamic programming approach.","solution":"from typing import List, Tuple def maximize_supply_value(items: List[Tuple[int, int]], capacity: int) -> int: :param items: A list of tuples where each tuple contains two integers (value, weight) representing the value and weight of a supply package. :param capacity: An integer representing the load capacity of the spaceship. :return: An integer representing the maximum value of supply packages that can be included in the spaceship. # Initialize a DP array to store the max value at each capacity from 0 to the given capacity dp = [0] * (capacity + 1) for value, weight in items: # Traverse the dp array from right to left for c in range(capacity, weight - 1, -1): dp[c] = max(dp[c], dp[c - weight] + value) return dp[capacity]"},{"question":"Given a nested array (an array that may contain other arrays as elements), you need to write a function `custom_flatten` that returns a single, flat array containing all the elements of the nested arrays in a depth-first order. # Input Format * `input_arr`: A list which may contain nested lists (the elements can be integers, floats, strings, or other lists). # Output Format * Returns a single list containing all the elements from the nested list in a depth-first traversal fashion. # Constraints * Arrays may be nested to an arbitrary depth. * The function should treat strings as atomic and should not break them into individual characters. * Python’s recursion limit should be taken into consideration — if necessary, an iterative approach should be used to handle deep nesting. # Example Input ```python input_arr = [1, [2, 3], [4, [5]], \\"string\\", [6, [7, [8, 9]]], [\\"string\\", 10]] ``` Output ```python [1, 2, 3, 4, 5, \\"string\\", 6, 7, 8, 9, \\"string\\", 10] ``` # Function Signature ```python def custom_flatten(input_arr): # Your code here pass ``` # Guidelines 1. The function should correctly handle deeply nested arrays. 2. Ensure that strings are not split into individual characters. 3. Aim for a solution that is efficient in terms of both time and space complexity. # Implementation Evaluation Your implementation will be evaluated based on: * Correctness: The output should match the expected flat list for different nested structures. * Efficiency: Your approach should be optimized for both time and space, keeping deep recursion in mind. * Readability: Your code should be well-organized and commented.","solution":"def custom_flatten(input_arr): Flatten a nested list into a single list containing all the elements in depth-first order. Parameters: input_arr (list): A potentially nested list containing integers, floats, strings, or other lists. Returns: list: A flat list with all elements ordered in depth-first traversal. def flatten_helper(arr): for item in arr: if isinstance(item, list): yield from flatten_helper(item) else: yield item return list(flatten_helper(input_arr))"},{"question":"# Removing Duplicates from an Unsorted Linked List Context You are an engineer at a data cleaning company. Your team often handles linked lists containing numerous records. However, these lists frequently contain duplicate entries that must be removed while keeping the order of first occurrences. Your task is to implement the removal of duplicates from two perspectives: efficiently with extra space and more space conservatively but less time-efficient. Objective Write two functions to remove duplicates from an unsorted linked list: 1. `remove_dups(head)` using O(N) time complexity and O(N) space complexity. 2. `remove_dups_without_set(head)` using O(N^2) time complexity and O(1) space complexity. Function Signatures ```python def remove_dups(head: Node) -> None: # implement your solution here def remove_dups_without_set(head: Node) -> None: # implement your solution here ``` Input and Output Formats * **Input**: A singly linked list with nodes containing integer values. * **Output**: None (The linked list is modified in place). Constraints * Implement the operations in-place on the linked list. * Avoid any errors arising from null references. * Handle all edge scenarios mentioned in the analysis. Example ```python class Node: def __init__(self, val=None): self.val = val self.next = None # Helper function to print the linked list. def print_linked_list(head: Node) -> None: current = head while current: print(current.val, end=\\" -> \\" if current.next else \\"\\") current = current.next print() # Helper function to create a linked list from a list. def create_linked_list(values: list) -> Node: if not values: return None head = Node(values[0]) current = head for val in values[1:]: current.next = Node(val) current = current.next return head # Test Example lst = [1, 2, 3, 2, 4, 1, 5] head = create_linked_list(lst) remove_dups(head) print_linked_list(head) # Expected output: 1 -> 2 -> 3 -> 4 -> 5 head = create_linked_list(lst) remove_dups_without_set(head) print_linked_list(head) # Expected output: 1 -> 2 -> 3 -> 4 -> 5 ```","solution":"class Node: def __init__(self, val=None): self.val = val self.next = None def remove_dups(head: Node) -> None: if head is None: return seen_values = set() current = head prev = None while current: if current.val in seen_values: # Skip the current node prev.next = current.next else: # Add the value to the set and move prev pointer seen_values.add(current.val) prev = current current = current.next def remove_dups_without_set(head: Node) -> None: if head is None: return current = head while current: runner = current while runner.next: if runner.next.val == current.val: runner.next = runner.next.next else: runner = runner.next current = current.next # Helper function to create a linked list from a list. def create_linked_list(values: list) -> Node: if not values: return None head = Node(values[0]) current = head for val in values[1:]: current.next = Node(val) current = current.next return head # Helper function to convert a linked list back to a list. def linked_list_to_list(head: Node) -> list: values = [] current = head while current: values.append(current.val) current = current.next return values"},{"question":"<|Analysis Begin|> # Algorithm/Data Structure Analysis: Core Identification: * **Name**: Interval Manipulation and Merging * **Type**: Custom Data Structure and Sorting/Merging Algorithm * **Main Purpose**: Represent real number intervals and perform operations such as merging overlapping intervals. Complexity: * **Time Complexity**: * Iterating through intervals for merging has a complexity of O(n log n) due to the sort operation. * Access, slicing, and containment checks in the interval itself are O(1). * **Space Complexity**: O(n) for storing the intervals. Principles: * **Core Operational Steps**: * Define intervals with a start and end. * Check if an item is within an interval. * Merge overlapping intervals by sorting based on start time and then merging. Characteristics & Applications: * **Properties**: * An interval is a contiguous range `[start, end)`. * Contains methods for basic operations like containment checks, merging, slicing, and iteration. * **Common Use Cases**: * Time range operations in scheduling applications. * Range-based data filtering or bucketing. * Mathematical computations involving continuous ranges. * **Strengths/Limitations**: * **Strengths**: Efficient containment checks and merging operations, intuitive method names. * **Limitations**: May have unnecessary complexity for very simple applications. Implementation Challenges: * **Edge Cases**: * Empty intervals. * Overlapping intervals. * Single element intervals merging with multi-element intervals. * Handling negative intervals. * **Performance Bottlenecks**: * Sorting operation in merge which is O(n log n). * Iteration over large ranges can be costly. * **Error Scenarios**: * Incorrect interval definitions where `start` is greater than `end`. * Non-integer start and end which might be required for strict integer interval applications. * **Optimization Points**: * Consider using more efficient data structures like balanced trees for dynamic interval management. * Optimize merging by reducing redundant operations during comparison. <|Analysis End|> <|Question Begin|> # Interval Management and Merging Intervals are an important concept in mathematics and computer science where you need to manage ranges efficiently. In this question, you will leverage your understanding of intervals, sorting, and merging algorithms to implement a function that processes a list of intervals, performs specific operations, and manages the intervals efficiently. Task: You need to implement the following function: ```python def process_intervals(intervals, new_interval): Merge a new interval into existing intervals and return the updated list. Parameters: intervals (List[List[int]]): A list of intervals where each interval is represented as a list [start, end). new_interval (List[int]): A single interval to be merged into the list [start, end). Returns: List[List[int]]: The updated list of non-overlapping intervals after merging the new interval. ``` Constraints: 1. Each interval is a list [start, end) such that `start <= end`. 2. `intervals` is a list of such non-overlapping sorted intervals. 3. The `new_interval` must be merged such that the resulting list remains sorted and non-overlapping. 4. The intervals can include negative values. Examples: 1. **Example 1:** ```python intervals = [[1, 3], [5, 7], [8, 12]] new_interval = [4, 6] print(process_intervals(intervals, new_interval)) # Expected Output: [[1, 3], [4, 7], [8, 12]] ``` 2. **Example 2:** ```python intervals = [[1, 2], [3, 5], [6, 7], [8, 10], [12, 16]] new_interval = [4, 9] print(process_intervals(intervals, new_interval)) # Expected Output: [[1, 2], [3, 10], [12, 16]] ``` 3. **Example 3:** ```python intervals = [[1, 5]] new_interval = [2, 3] print(process_intervals(intervals, new_interval)) # Expected Output: [[1, 5]] ``` 4. **Example 4:** ```python intervals = [] new_interval = [4, 8] print(process_intervals(intervals, new_interval)) # Expected Output: [[4, 8]] ``` Performance Requirements: - Ensure that your implementation efficiently handles sorting and merging operations with optimal time complexity. - Consider edge cases like when `intervals` is empty or all intervals are merged into a single range.","solution":"def process_intervals(intervals, new_interval): Merge a new interval into existing intervals and return the updated list. Parameters: intervals (List[List[int]]): A list of intervals where each interval is represented as a list [start, end). new_interval (List[int]): A single interval to be merged into the list [start, end). Returns: List[List[int]]: The updated list of non-overlapping intervals after merging the new interval. if not intervals: return [new_interval] merged = [] i, n = 0, len(intervals) # Add all the intervals before new_interval while i < n and intervals[i][1] < new_interval[0]: merged.append(intervals[i]) i += 1 # Merge all overlapping intervals with new_interval while i < n and intervals[i][0] <= new_interval[1]: new_interval = [min(new_interval[0], intervals[i][0]), max(new_interval[1], intervals[i][1])] i += 1 # Add the merged interval merged.append(new_interval) # Add the remaining intervals while i < n: merged.append(intervals[i]) i += 1 return merged"},{"question":"You are given a list of floating-point numbers with values uniformly distributed in the range [0, 1). Your task is to implement the `bucket_sort` algorithm as described, using the `next_sort` function for sorting individual buckets. This question aims to evaluate your understanding of the bucket sort technique, especially how to handle partitioning and sorting within buckets. Function Signature ```python def bucket_sort(arr: List[float]) -> List[float]: ``` Input * `arr` (List[float]): A list of floating-point numbers in the range [0, 1). Output * Returns a list of `float`, which is the sorted version of the input list `arr`. Constraints * 1 <= len(arr) <= 10^4 * Each element of `arr` is in the range [0, 1) # Requirements 1. Implement the `bucket_sort` function, which utilizes `next_sort` as the sorting method for each bucket. 2. Ensure that the function can handle various edge cases such as empty arrays and arrays with identical elements. 3. Consider the scenarios where performance might degrade and ensure optimized partitioning and sorting. # Examples ```python # Example 1 arr = [0.78, 0.17, 0.39, 0.26, 0.72, 0.94, 0.21, 0.12, 0.23, 0.68] bucket_sort(arr) # Output: [0.12, 0.17, 0.21, 0.23, 0.26, 0.39, 0.68, 0.72, 0.78, 0.94] # Example 2 arr = [0.4, 0.1, 0.2, 0.3] bucket_sort(arr) # Output: [0.1, 0.2, 0.3, 0.4] # Example 3 arr = [] bucket_sort(arr) # Output: [] ``` Notes * The sorting within each bucket is performed using insertion sort (`next_sort`) as provided. * Ensure that your solution is efficient and handles the constraints effectively.","solution":"from typing import List # This function simulates the sorting mechanism within each bucket. # In this example, let\'s use a simple insertion sort for sorting the buckets. def next_sort(arr: List[float]) -> List[float]: for i in range(1, len(arr)): key = arr[i] j = i - 1 while j >= 0 and key < arr[j]: arr[j + 1] = arr[j] j -= 1 arr[j + 1] = key return arr def bucket_sort(arr: List[float]) -> List[float]: if not arr: return [] n = len(arr) # Create n empty buckets buckets = [[] for _ in range(n)] # Insert elements into their respective buckets for num in arr: index = int(num * n) # Finding appropriate bucket buckets[index].append(num) # Sort individual buckets and concatenate sorted_arr = [] for bucket in buckets: next_sort(bucket) sorted_arr.extend(bucket) return sorted_arr"},{"question":"# Scenario You are given a financial dataset that contains the daily profit/loss of a company over a period. You need to analyze this data to find the best period to realize the maximum profit by summing the daily profits and avoiding the days with losses. # Task Write a function `max_contiguous_subsequence_sum` that implements Kadane\'s Algorithm to find the maximum sum of any contiguous subsequence within a given list of integers representing the daily profit/loss. # Function Signature ```python def max_contiguous_subsequence_sum(arr: list[int]) -> int: ``` # Input * A list `arr` of integers where each integer represents the daily profit (positive number) or loss (negative number). The list can have a length from 0 to (10^5), and the integer values range between (-10^4) and (10^4). # Output * An integer representing the maximum sum of any contiguous subsequence in the given list. # Constraints * The function should run in (O(n)) time complexity and use (O(1)) extra space. # Examples Example 1: ```python arr = [-2, 3, 8, -1, 4] print(max_contiguous_subsequence_sum(arr)) # Output: 14 ``` Example 2: ```python arr = [-1, 1, 0] print(max_contiguous_subsequence_sum(arr)) # Output: 1 ``` Example 3: ```python arr = [-1, -3, -4] print(max_contiguous_subsequence_sum(arr)) # Output: -1 ``` Example 4: ```python arr = [] print(max_contiguous_subsequence_sum(arr)) # Output: 0 ``` # Notes 1. If the input list is empty, the function should return 0. 2. Consider handling arrays with negative integers thoughtfully.","solution":"def max_contiguous_subsequence_sum(arr: list[int]) -> int: if not arr: return 0 max_current = max_global = arr[0] for i in range(1, len(arr)): max_current = max(arr[i], max_current + arr[i]) if max_current > max_global: max_global = max_current return max_global"},{"question":"# Problem: Generate Unique Subsets with Specific Constraints You are given a list of distinct integers, `nums`, and an integer `k`. Write a function `unique_k_length_subsets(nums, k)` that returns all unique subsets of length exactly `k` from the given integers. **Function Signature**: ```python def unique_k_length_subsets(nums: List[int], k: int) -> Set[Tuple[int]]: ``` **Input**: - `nums`: A list of distinct integers (1 <= len(nums) <= 16), e.g., `[1, 2, 3, 4]` - `k`: An integer (0 <= k <= len(nums)), representing the length of each subset, e.g., `2` **Output**: - A set of tuples, where each tuple represents a unique subset of length `k`, e.g., `{(1, 2), (1, 3), (2, 4), (1, 4)}` **Constraints**: - The function should return a set containing all unique subsets of length `k`. - The subsets should be generated using a bit manipulation approach as described in the analysis. - Subsets are not required to be in any specific order. **Examples**: 1. `unique_k_length_subsets([1, 2, 3], 2)` should return `{(1, 2), (1, 3), (2, 3)}` 2. `unique_k_length_subsets([1, 2, 3, 4], 3)` should return `{(1, 2, 3), (1, 2, 4), (1, 3, 4), (2, 3, 4)}` 3. `unique_k_length_subsets([1, 2, 3], 0)` should return `{()}` (the empty subset) 4. `unique_k_length_subsets([1, 2, 3, 4], 4)` should return `{(1, 2, 3, 4)}` # Additional Notes: - Consider edge cases such as when `k` is 0 or equal to the length of `nums`. - The output set should not contain any duplicate subsets. - You may assume that `nums` will always contain distinct integers.","solution":"from typing import List, Set, Tuple def unique_k_length_subsets(nums: List[int], k: int) -> Set[Tuple[int]]: from itertools import combinations # Using combinations to generate all unique subsets of length k result = set(combinations(nums, k)) return result"},{"question":"# Objective Your task is to implement a function that finds the first occurrence of a given element in a sorted (increasing order) array using the Binary Search algorithm. # Function Signature ```python def first_occurrence(array: List[int], query: int) -> int: ``` # Input * `array` (List[int]): A list of integers sorted in increasing order. * `query` (int): The element whose first occurrence index is to be found. # Output * (int): The index of the first occurrence of `query` in `array`. If the `query` is not found in the array, return -1. # Constraints * The length of `array` will be between 0 and 10^6. * `query` will be an integer within the range of elements in the array. # Performance Requirements Your solution should be efficient with a logarithmic time complexity (O(log n)). # Example ```python assert first_occurrence([1, 2, 2, 2, 3, 4, 5], 2) == 1 assert first_occurrence([1, 2, 3, 4, 5], 6) == -1 assert first_occurrence([], 3) == -1 assert first_occurrence([1, 1, 1, 1, 1], 1) == 0 ``` # Scenario Consider the situation where you are given a large log of timestamps indicating specific events occurring over time. These timestamps are sorted in chronological order. If you want to find the first occurrence of a specific event, you can use this binary search technique to quickly retrieve the index without needing to scan through the entire list. # Notes * Ensure your code handles edge cases such as an empty array. * Test for performance to confirm the algorithm handles the upper limits of input sizes efficiently.","solution":"from typing import List def first_occurrence(array: List[int], query: int) -> int: Finds the first occurrence of query in a sorted array using Binary Search. Parameters: array (List[int]): A list of sorted integers. query (int): The target element to find. Returns: int: The index of the first occurrence of query, or -1 if not found. left, right = 0, len(array) - 1 result = -1 while left <= right: mid = left + (right - left) // 2 if array[mid] == query: result = mid right = mid - 1 # Keep searching in the left half elif array[mid] < query: left = mid + 1 else: right = mid - 1 return result"},{"question":"# Problem Context Let\'s enhance a text editor\'s undo feature by utilizing a Doubly Linked List for efficient command storage and retrieval. # Task You need to implement a doubly linked list where each node stores an editor command. The list should support the following functionalities: 1. **Add Command**: Add a new command to the end of the list. 2. **Undo Command**: Retrieve and remove the most recent command. 3. **Retrieve Command**: Fetch a command by its index without removing it. # Input and Output * Function 1: `add_command(command: str) -> None` - **Input**: `command` - a string representing an editor command. - **Output**: None * Function 2: `undo_command() -> str` - **Output**: The most recent command which was removed. - **Error**: If there are no commands to undo, return \\"No commands to undo\\". * Function 3: `retrieve_command(index: int) -> str` - **Input**: `index` - the 0-based position of the command to fetch. - **Output**: The command at the given index. - **Error**: If the index is out of range, return \\"Index out of range\\". # Constraints - The list will never contain more than 10,000 commands. - All commands are non-empty strings of length up to 100. - The operations should be implemented efficiently to handle up to 10,000 commands. # Example Scenario ```python dll = DoublyLinkedList() dll.add_command(\\"open file\\") dll.add_command(\\"edit line\\") dll.add_command(\\"save file\\") print(dll.undo_command()) # Output: save file print(dll.retrieve_command(1)) # Output: edit line print(dll.undo_command()) # Output: edit line print(dll.undo_command()) # Output: open file print(dll.undo_command()) # Output: No commands to undo print(dll.retrieve_command(0)) # Output: Index out of range ``` Implement the `DoublyLinkedList` class to perform these operations.","solution":"class Node: def __init__(self, command): self.command = command self.next = None self.prev = None class DoublyLinkedList: def __init__(self): self.head = None self.tail = None self.size = 0 def add_command(self, command: str) -> None: new_node = Node(command) if self.tail: self.tail.next = new_node new_node.prev = self.tail self.tail = new_node else: self.head = self.tail = new_node self.size += 1 def undo_command(self) -> str: if self.tail is None: return \\"No commands to undo\\" command = self.tail.command if self.tail.prev: self.tail = self.tail.prev self.tail.next = None else: # If there\'s only one element self.head = self.tail = None self.size -= 1 return command def retrieve_command(self, index: int) -> str: if index < 0 or index >= self.size: return \\"Index out of range\\" current = self.head for _ in range(index): current = current.next return current.command"},{"question":"# Ternary Search Challenge You are given a code snippet of a Ternary Search algorithm above. Based on your understanding of the algorithm, you need to implement a modified ternary search to handle both sorted and nearly sorted arrays. A nearly sorted array is one where each element is at most `k` positions away from its target position in the sorted array. # Requirements 1. Write a function `nearly_sorted_ternary_search(arr, key, k)` that searches for `key` in `arr` where `arr` is nearly sorted with elements displaced at most `k` positions. 2. The function should return the index of `key` if found, otherwise return -1. 3. If no `k` or arr is empty, the function should handle accordingly and return -1. # Input - An `array` of randomly ordered integers where each element is at most `k` positions away from its target position. - An `integer key` that needs to be searched. - An integer `k` which represents the maximum displacement of each element. # Output - An integer representing the index of the key if found, otherwise -1. # Constraints - **Time Complexity**: Should be more efficient than O(N) linear search by utilizing the nearly sorted property. - **Space Complexity**: O(1) for auxiliary space. # Example ```python # Example Usage: arr = [3, 2, 10, 4, 40] key = 4 k = 2 print(nearly_sorted_ternary_search(arr, key, k)) # Output: 3 ``` # Explanation: In the above example, the element `4` is present at index `3`, so the function returns `3`. # Function Signature ```python def nearly_sorted_ternary_search(arr, key, k): # Your code here ``` # Notes - Ensure your solution is robust and handle edge cases such as empty arrays, or arrays with minimal displacement. - Explain how your approach takes advantage of the nearly sorted property.","solution":"def nearly_sorted_ternary_search(arr, key, k): Searches for the `key` in a nearly sorted array `arr` where each element is at most `k` positions away from its target position. Returns the index of the `key` if found, otherwise returns -1. :param arr: List[int] - The nearly sorted array :param key: int - The key to search for :param k: int - The maximum displacement each element can have :return: int - The index of the key if found, otherwise -1 if not arr or k <= 0: return -1 n = len(arr) # We\'ll make use of ternary search but with a modified search range def ternary_search(left, right): while left <= right: if left > right: return -1 mid1 = left + (right - left) // 3 mid2 = right - (right - left) // 3 if arr[mid1] == key: return mid1 if arr[mid2] == key: return mid2 if key < arr[mid1]: right = mid1 - 1 elif key > arr[mid2]: left = mid2 + 1 else: left = mid1 + 1 right = mid2 - 1 return -1 for i in range(n): # Perform local check within the range expected for nearly sorted array left = max(0, i - k) right = min(n - 1, i + k) index = ternary_search(left, right) if index != -1: return index return -1"},{"question":"# Cycle Detection in Directed Graphs **Context**: You are tasked with designing a system for deadlock detection in a distributed environment. Each process is represented by a vertex in a directed graph and there is a directed edge from A to B if process A is waiting for process B to release a resource. **Problem**: Given a directed graph represented as an adjacency list (dictionary), write a function to determine if the graph contains a cycle. **Function Signature**: ```python def contains_cycle(graph: dict) -> bool: ``` **Input**: * `graph`: A dictionary where keys are vertices (strings) and values are lists of vertices (strings) to which there are directed edges. Example: ```python graph = { \'A\': [\'B\', \'C\'], \'B\': [\'D\'], \'C\': [\'F\'], \'D\': [\'E\', \'F\'], \'E\': [\'B\'], \'F\': [] } ``` **Output**: * Returns `True` if there is a cycle in the graph, otherwise `False`. **Constraints**: * The input graph can have up to 10,000 vertices. * The graph is directed and can be disconnected. **Performance Requirements**: * The solution should have a time complexity of O(V + E) and space complexity of O(V). Write a code for the function `contains_cycle` based on the provided context and specifications.","solution":"def contains_cycle(graph: dict) -> bool: def dfs(vertex, visited, stack): visited[vertex] = True stack[vertex] = True for neighbor in graph.get(vertex, []): if not visited[neighbor]: if dfs(neighbor, visited, stack): return True elif stack[neighbor]: return True stack[vertex] = False return False visited = {vertex: False for vertex in graph} stack = {vertex: False for vertex in graph} for vertex in graph: if not visited[vertex]: if dfs(vertex, visited, stack): return True return False"},{"question":"# Coding Challenge: Implement Balanced Binary Search Tree Objective: Your task is to implement a balanced version of the Binary Search Tree (BST), specifically an AVL tree, to ensure its height remains balanced for all operations. Requirements: 1. **Insert**: Add a value to the AVL tree maintaining the balance. 2. **Search**: Check if a value exists in the tree. 3. **Size**: Compute the number of elements in the tree. 4. **Rotation Functions**: Implement left and right rotation functions to maintain balance in AVL tree. 5. **Balance Factor**: Compute the balance factor to decide on rotations. 6. **Height Update**: Maintain height property for each node to facilitate rotation decisions. 7. **Traversals**: Inorder, Preorder, Postorder traversal methods for the AVL tree. Input/Output Specifications: * **insert(value)**: Inserts the value into the AVL tree. * **Input**: An integer `value`. * **Output**: None. * **search(value)**: Searches for the value in the AVL tree. * **Input**: An integer `value`. * **Output**: Boolean `True` if value exists, otherwise `False`. * **size()**: Returns the current size of the AVL tree. * **Output**: Integer representing the number of elements. * **inorder(), preorder(), postorder()**: * **Output**: Prints elements according to respective traversal method. Constraints: * Maximum number of elements `N` is 1000. * All operations should run efficiently with O(log N) complexity for balanced trees. Example Scenario: ```plaintext # Create AVL tree and insert values avl = AVLTree() avl.insert(50) avl.insert(40) avl.insert(70) avl.insert(30) avl.insert(60) # Size of the tree print(avl.size()) # Output: 5 # Search for elements print(avl.search(40)) # Output: True print(avl.search(80)) # Output: False # Inorder Traversal avl.inorder() # Output: 30 40 50 60 70 # Preorder Traversal avl.preorder() # Output: 50 40 30 70 60 # Postorder Traversal avl.postorder() # Output: 30 40 60 70 50 ``` **Note:** Ensure the tree remains balanced after each insertion. Implementation Hint: * Use class-based implementation similar to the provided BST code snippet. * Ensure height and balance factors are maintained and used for rotation decisions.","solution":"class AVLNode: def __init__(self, value): self.value = value self.left = None self.right = None self.height = 1 class AVLTree: def __init__(self): self.root = None self.node_count = 0 def insert(self, value): self.root = self._insert(self.root, value) def _insert(self, node, value): if not node: self.node_count += 1 return AVLNode(value) elif value < node.value: node.left = self._insert(node.left, value) else: node.right = self._insert(node.right, value) node.height = 1 + max(self._get_height(node.left), self._get_height(node.right)) balance = self._get_balance(node) if balance > 1 and value < node.left.value: return self._right_rotate(node) if balance < -1 and value > node.right.value: return self._left_rotate(node) if balance > 1 and value > node.left.value: node.left = self._left_rotate(node.left) return self._right_rotate(node) if balance < -1 and value < node.right.value: node.right = self._right_rotate(node.right) return self._left_rotate(node) return node def search(self, value): return self._search(self.root, value) def _search(self, node, value): if not node: return False if value == node.value: return True elif value < node.value: return self._search(node.left, value) else: return self._search(node.right, value) def size(self): return self.node_count def _get_height(self, node): if not node: return 0 return node.height def _get_balance(self, node): if not node: return 0 return self._get_height(node.left) - self._get_height(node.right) def _left_rotate(self, z): y = z.right T2 = y.left y.left = z z.right = T2 z.height = 1 + max(self._get_height(z.left), self._get_height(z.right)) y.height = 1 + max(self._get_height(y.left), self._get_height(y.right)) return y def _right_rotate(self, z): y = z.left T3 = y.right y.right = z z.left = T3 z.height = 1 + max(self._get_height(z.left), self._get_height(z.right)) y.height = 1 + max(self._get_height(y.left), self._get_height(y.right)) return y def inorder(self): result = [] self._inorder(self.root, result) return result def _inorder(self, node, result): if not node: return self._inorder(node.left, result) result.append(node.value) self._inorder(node.right, result) def preorder(self): result = [] self._preorder(self.root, result) return result def _preorder(self, node, result): if not node: return result.append(node.value) self._preorder(node.left, result) self._preorder(node.right, result) def postorder(self): result = [] self._postorder(self.root, result) return result def _postorder(self, node, result): if not node: return self._postorder(node.left, result) self._postorder(node.right, result) result.append(node.value)"},{"question":"Scenario In the context of a personal assistant software, you need to develop a feature that provides suggestions based on user input. You decide to use a trie data structure to efficiently manage and retrieve words based on prefixes. Task Implement a `Trie` class with the following methods: 1. **Insert** 2. **Search** 3. **StartsWith** Use the following function prototypes: ```python class Trie: def __init__(self): # Initializes the Trie object pass def insert(self, word: str) -> None: # Inserts a word into the trie. pass def search(self, word: str) -> bool: # Returns if the word is in the trie. pass def starts_with(self, prefix: str) -> bool: # Returns if there is any word in the trie that starts with the given prefix. pass ``` Constraints * Input strings are comprised of lowercase letters (\'a\' - \'z\') only. * The system needs to handle up to 10^4 words in the trie. Examples ```python # Initialization trie = Trie() # Insert words trie.insert(\\"apple\\") trie.insert(\\"app\\") # Search words assert trie.search(\\"apple\\") == True # returns True assert trie.search(\\"app\\") == True # returns True assert trie.search(\\"appl\\") == False # returns False # Check prefixes assert trie.starts_with(\\"app\\") == True # returns True assert trie.starts_with(\\"apl\\") == False # returns False ``` Additional Context Make sure your implementation is efficient and handles edge cases, such as empty strings and non-existent nodes, appropriately.","solution":"class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False class Trie: def __init__(self): self.root = TrieNode() def insert(self, word: str) -> None: node = self.root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.is_end_of_word = True def search(self, word: str) -> bool: node = self.root for char in word: if char not in node.children: return False node = node.children[char] return node.is_end_of_word def starts_with(self, prefix: str) -> bool: node = self.root for char in prefix: if char not in node.children: return False node = node.children[char] return True"},{"question":"**Context:** You are developing a text application where you need to ensure the words provided can be typed using letters of alphabet from only one specific row of a QWERTY keyboard. Your objective is to write a function that filters out such words from a given list. **Task:** Implement a function `filter_keyboard_row` that accepts a list of words and returns a list of words that can be typed using letters from only one row of an American QWERTY keyboard. **Function Signature:** ```python def filter_keyboard_row(words: List[str]) -> List[str]: ``` **Input:** * `words` (List[str]): A list of words composed of alphabetic characters. **Output:** * List[str]: A list of words that can be typed using letters from only one row of the keyboard. **Example:** ```python assert filter_keyboard_row([\\"Hello\\", \\"Alaska\\", \\"Dad\\", \\"Peace\\"]) == [\\"Alaska\\", \\"Dad\\"] assert filter_keyboard_row([\\"qaz\\", \\"wsx\\", \\"edc\\"]) == [\\"wsx\\", \\"edc\\"] ``` **Constraints:** * The words contain only alphabetic characters. * The function must be case insensitive. * Each word can be from length 0 up to 100 characters. * The number of words can be from 0 up to 10,000.","solution":"from typing import List def filter_keyboard_row(words: List[str]) -> List[str]: Filter words that can be typed using letters from only one row of an American QWERTY keyboard. row1 = set(\\"qwertyuiop\\") row2 = set(\\"asdfghjkl\\") row3 = set(\\"zxcvbnm\\") result = [] for word in words: lower_word = set(word.lower()) if lower_word.issubset(row1) or lower_word.issubset(row2) or lower_word.issubset(row3): result.append(word) return result"},{"question":"# Heap Sort Implementation **Context**: You are tasked with implementing a variant of heap sort specifically required to sort a list in descending order using a min-heap. As a refresher, a min-heap is a complete binary tree where each parent node is less than or equal to its children. **Task**: Implement a function `min_heap_sort_desc` that sorts an array in descending order using the min-heap structure. Function Signature ```python def min_heap_sort_desc(arr: List[int]) -> List[int]: pass ``` Input * A list of integers, `arr` (0 ≤ len(arr) ≤ 10^4, -10^6 ≤ arr[i] ≤ 10^6). Output * A list of integers sorted in descending order. Examples ```python arr = [4, 10, 3, 5, 1] print(min_heap_sort_desc(arr)) # Output: [10, 5, 4, 3, 1] arr = [] print(min_heap_sort_desc(arr)) # Output: [] arr = [1, 2, 3] print(min_heap_sort_desc(arr)) # Output: [3, 2, 1] ``` Constraints and Notes * Your solution should aim to have a time complexity of O(n log(n)) and a space complexity of O(1). * Ensure to handle edge cases such as empty arrays, arrays with one element, and arrays with duplicate elements correctly. Requirements 1. Implement a min-heap construction and processing as part of the sorting procedure. 2. The sorted result must be obtained strictly by using the properties of the min-heap and not through any direct sorting functions like `sort()`. 3. Provide robust checks within your `min_heap_sort_desc` function to ensure correct heap properties are maintained during conversions.","solution":"import heapq from typing import List def min_heap_sort_desc(arr: List[int]) -> List[int]: Sorts an array in descending order using the min-heap structure. # Convert the list into a min-heap heapq.heapify(arr) # Extract elements one by one from the min-heap and build the result list in descending order sorted_desc = [] while arr: smallest = heapq.heappop(arr) sorted_desc.insert(0, smallest) return sorted_desc"},{"question":"Given a list of integers `array` and an integer `N`, write a function `limit_occurrences` to create a new list that contains each number of the list at most `N` times without reordering. Your implementation should be efficient, aiming for (O(n)) time complexity where (n) is the length of the list. You are required to maintain the original order of elements. Function Signature ```python def limit_occurrences(array: List[int], n: int) -> List[int]: pass ``` # Input - `array`: A list of integers (e.g., `[1, 2, 3, 1, 2, 1, 2, 3]`). - `n`: A non-negative integer specifying the maximum allowed occurrences for each element. # Output - A list of integers where each element appears at most `N` times, maintaining the original order. # Constraints - The input list `array` can have a length up to (10^5). - All elements in `array` are integers. - (0 leq N leq 10^5). # Examples 1. Input: `array=[1, 2, 3, 1, 2, 1, 2, 3]`, `n=2` Output: `[1, 2, 3, 1, 2, 3]` 2. Input: `array=[1, 1, 1, 1]`, `n=2` Output: `[1, 1]` 3. Input: `array=[1, 2, 3, 4, 5]`, `n=1` Output: `[1, 2, 3, 4, 5]` 4. Input: `array=[]`, `n=2` Output: `[]` # Additional Requirements 1. Provide a solution with (O(n)) time complexity. 2. Handle edge cases such as empty lists and `n` being zero. 3. Avoid using additional libraries or any built-in functions that simplify the task directly. Write the function `limit_occurrences` that fulfills the above requirements.","solution":"from typing import List def limit_occurrences(array: List[int], n: int) -> List[int]: Returns a new list that contains each number of the list at most N times without reordering. Parameters: array (List[int]): The input list of integers. n (int): The maximum number of occurrences allowed for each integer. Returns: List[int]: A list with each integer appearing at most N times. counts = {} result = [] for num in array: if num not in counts: counts[num] = 0 if counts[num] < n: counts[num] += 1 result.append(num) return result"},{"question":"You are given a sorted array of integers and a target value. Your task is to implement the ternary search algorithm to find the index of the target value in the sorted array. If the target value is not present in the array, return -1. Make sure your implementation handles various edge cases and performs efficiently for large input sizes. # Function Signature ```python def ternary_search(arr: List[int], target: int) -> int: pass ``` # Input - `arr` (List[int]): A sorted list of integers (0 <= len(arr) <= 10^5, -10^9 <= arr[i] <= 10^9). - `target` (int): The integer value to search for in the array (-10^9 <= target <= 10^9). # Output - Returns the index of `target` in `arr` if found. If `target` is not in `arr`, returns -1. # Constraints - The function must complete in O(log3(N)) time complexity. - Do not use any additional data structures that increase space complexity beyond O(1). # Example ```python assert ternary_search([-10, -3, 0, 5, 9, 12], 9) == 4 assert ternary_search([-10, -3, 0, 5, 9, 12], 2) == -1 assert ternary_search([], 1) == -1 assert ternary_search([1, 2, 3, 4, 5], 4) == 3 ``` # Notes - Your implementation should be robust and handle various edge cases such as an empty array or a target that is out of the array bounds. - Avoid redundant operations to keep the function efficient.","solution":"from typing import List def ternary_search(arr: List[int], target: int) -> int: Perform a ternary search on a sorted list to find the target value. Parameters: arr (List[int]): A sorted list of integers. target (int): The integer value to search for in the array. Returns: int: The index of the target in the array if found, otherwise -1. def search(left: int, right: int) -> int: if left > right: return -1 one_third = left + (right - left) // 3 two_thirds = right - (right - left) // 3 if arr[one_third] == target: return one_third if arr[two_thirds] == target: return two_thirds if target < arr[one_third]: return search(left, one_third - 1) elif target > arr[two_thirds]: return search(two_thirds + 1, right) else: return search(one_third + 1, two_thirds - 1) return search(0, len(arr) - 1)"},{"question":"Objective Write a function that calculates the number of digits of an integer n using a mathematical approach. Description Implement a function `num_digits` which determines the number of digits in the given integer `n`. Function Signature ```python def num_digits(n: int) -> int: pass ``` Input * A single integer `n` where `-10^9 <= n <= 10^9`. Output * An integer representing the number of digits in `n`. Examples 1. `num_digits(12345)` should return `5` 2. `num_digits(-987)` should return `3` 3. `num_digits(0)` should return `1` 4. `num_digits(-1000)` should return `4` Constraints * The function should handle negative numbers as well. * The function should return 1 for input `0`. * Ensure that the function performs efficiently with O(1) time complexity. Context You are given a scientific calculator that uses logarithm to find the number of digits in a number. However, it\'s crucial that the function can correctly process both positive and negative numbers and also handle special cases like zero correctly.","solution":"def num_digits(n: int) -> int: Returns the number of digits in the integer n. # Convert n to a positive number by taking the absolute value n = abs(n) # Edge case for zero if n == 0: return 1 # Calculate the number of digits by repeatedly dividing by 10 digits = 0 while n > 0: n //= 10 digits += 1 return digits"},{"question":"You are tasked with calculating the number of ways to choose `r` items from `n` items, often referred to as combinations or \\"n choose r\\". Given the constraints of large inputs, you must implement an efficient algorithm without using in-built combinatorial functions. Write a function `efficient_combination(n: int, r: int) -> int` which calculates nCr using dynamic programming principles. # Function Signature ```python def efficient_combination(n: int, r: int) -> int: pass ``` # Input * An integer `n` (0 <= n <= 1000). * An integer `r` (0 <= r <= n). # Output * Return an integer representing the number of ways to choose `r` items from `n` items. # Constraints * You should use a dynamic programming approach to ensure the solution runs in polynomial time complexity. * Consider edge cases where `n` or `r` is 0. # Performance Requirements Your implementation should run efficiently even for the maximum inputs. # Example ```python assert efficient_combination(5, 2) == 10 assert efficient_combination(6, 0) == 1 assert efficient_combination(5, 5) == 1 assert efficient_combination(1000, 500) == 27028814571 ``` Hints: - Utilize the relationship `nCr = (n-1)C(r-1) + (n-1)Cr`. - Implement memoization or use a bottom-up dynamic programming table to avoid redundant calculations.","solution":"def efficient_combination(n: int, r: int) -> int: if r > n: return 0 if r == 0 or r == n: return 1 # Create a 2D array to store intermediate results C = [[0 for _ in range(r + 1)] for _ in range(n + 1)] # Calculate the values of combinations using dynamic programming for i in range(n + 1): for j in range(min(i, r) + 1): if j == 0 or j == i: C[i][j] = 1 else: C[i][j] = C[i-1][j-1] + C[i-1][j] return C[n][r]"},{"question":"You have to implement a function `reverse_vowel` that takes a string `s` and returns the same string but with all the vowels (\'a\', \'e\', \'i\', \'o\', \'u\', both uppercase and lowercase) reversed. # Function Signature: ```python def reverse_vowel(s: str) -> str: ``` # Input: * A single string `s`. The length of `s` will be in the range `0 <= len(s) <= 10^5`. # Output: * The function should return a string with the vowels reversed. # Constraints: * The string will only contain printable ASCII characters. # Example: ```python assert reverse_vowel(\\"hello\\") == \\"holle\\" assert reverse_vowel(\\"leetcode\\") == \\"leotcede\\" assert reverse_vowel(\\"aA\\") == \\"Aa\\" ``` # Explanation: * In the first example, \'e\' and \'o\' are the vowels and swapping them gives \\"holle\\". * In the second example, the vowels \'e\', \'e\', \'o\' and \'e\' are reversed to \'e\', \'o\', \'e\', and \'e\', resulting in \\"leotcede\\". * In the third example, the capital \'A\' and lowercase \'a\' are swapped. # Edge Cases to Consider: * The input string is empty. * The input string contains no vowels. * The input string consists entirely of vowels.","solution":"def reverse_vowel(s: str) -> str: vowels = set(\'aeiouAEIOU\') s_list = list(s) left, right = 0, len(s) - 1 while left < right: if s_list[left] in vowels and s_list[right] in vowels: s_list[left], s_list[right] = s_list[right], s_list[left] left += 1 right -= 1 if s_list[left] not in vowels: left += 1 if s_list[right] not in vowels: right -= 1 return \'\'.join(s_list)"},{"question":"# Priority Queue Implementation Challenge A priority queue is a data structure that stores elements along with their priorities and allows for efficient retrieval of the element with the highest or lowest priority. In this task, you\'ll build a priority queue specifically designed to maintain elements sorted in descending order of their priorities, with the lowest priority element being at the end of the list. **Your Task:** 1. Create a class called `PriorityQueueNode` to represent the nodes within the priority queue. Each instance should have two attributes: `data` and `priority`. 2. Implement a class called `PriorityQueue` that provides the following functionalities: - `__init__(self, items=None, priorities=None)`: - Initializes the priority queue optionally with a list of items and their corresponding priorities. - If no priorities are provided, use the item values as their priorities. - `size(self)`: - Returns the current size of the priority queue. - `push(self, item, priority=None)`: - Inserts an item into the priority queue at the appropriate position based on its priority. If no priority is provided, the item\'s value is used as its priority. - `pop(self)`: - Removes and returns the item with the lowest priority from the queue. **Requirements:** - The `push` operation should insert the item in the correct position to maintain the current order of the queue. - The `pop` operation should remove the item with the lowest priority efficiently. - You should handle edge cases where the queue might be empty when attempting to pop an item. **Input:** You will create instances of `PriorityQueue` and use its methods. ```python pq = PriorityQueue() pq.push(10, 1) pq.push(20, 5) pq.push(15, 3) pq.size() # Should return 3 pq.pop() # Should return 10 pq.pop() # Should return 15 pq.size() # Should return 1 ``` **Output:** The corresponding methods should return the items and the current size of the priority queue as described above. Consider the following additional constraints: - The priority queue should handle any type of comparable priorities (integers, floats, etc.). - The size of the priority queue at any point will not exceed 10^5 elements.","solution":"class PriorityQueueNode: def __init__(self, data, priority): self.data = data self.priority = priority class PriorityQueue: def __init__(self, items=None, priorities=None): self.queue = [] if items and priorities: for item, priority in zip(items, priorities): self.push(item, priority) elif items: for item in items: self.push(item) def size(self): return len(self.queue) def push(self, item, priority=None): if priority is None: priority = item new_node = PriorityQueueNode(item, priority) index = len(self.queue) for i, node in enumerate(self.queue): if priority > node.priority: index = i break self.queue.insert(index, new_node) def pop(self): if self.size() == 0: raise IndexError(\\"pop from empty priority queue\\") return self.queue.pop().data"},{"question":"You are tasked with implementing a custom data structure named `RandomizedSet` that supports inserting, removing, and retrieving random elements in average constant time, O(1). # Requirements: Your implementation should include three primary functions: * `insert(val)`: Inserts an item `val` to the set if not already present. * `remove(val)`: Removes an item `val` from the set if present. * `random_element()`: Returns a random element from the current set of elements. # Function Signature: ```python class RandomizedSet: def __init__(self): # Initializes the data structure pass def insert(self, val: int) -> None: # Inserts `val` to the set if not already present pass def remove(self, val: int) -> None: # Removes `val` from the set if present pass def random_element(self) -> int: # Returns a random element from the current set of elements pass ``` # Detailed Requirements: * You may assume that all `val` values will be unique integers within an acceptable data range for dictionary keys. * All operations (insert, remove, random selection) must function in average O(1) time. * The `RandomizedSet` class should internally manage a list and a dictionary to ensure that operations meet the required performance standards. # Constraints: * Assume you will call these methods multiple times within the test suite. * Performance will be evaluated based on handling up to `n` = 10^5 operations. # Example Usage: ```python rset = RandomizedSet() rset.insert(1) # Inserts 1 rset.insert(2) # Inserts 2 print(rset.random_element()) # Could return either 1 or 2 randomly rset.remove(1) # Removes 1 print(rset.random_element()) # Should return 2 as 1 was removed ``` # Edge Cases to Consider: * Inserting a value already present should not change the set. * Removing a non-existing value should not affect the set. * Random element should return each element with equal probability. Ensure your implementation passes all edge cases and constraints efficiently.","solution":"import random class RandomizedSet: def __init__(self): self.data_dict = {} self.data_list = [] def insert(self, val: int) -> bool: if val in self.data_dict: return False self.data_dict[val] = len(self.data_list) self.data_list.append(val) return True def remove(self, val: int) -> bool: if val not in self.data_dict: return False idx = self.data_dict[val] last_element = self.data_list[-1] self.data_list[idx] = last_element self.data_dict[last_element] = idx self.data_list.pop() del self.data_dict[val] return True def random_element(self) -> int: return random.choice(self.data_list)"},{"question":"You are given an unsorted list of integers. Your task is to write a function `custom_merge_sort(arr)` that sorts this list in non-decreasing order using the Merge Sort algorithm. Your implementation should demonstrate a deep understanding of divide and conquer technique and proper handling of edge cases. # Function Signature: ```python def custom_merge_sort(arr: list) -> list: ``` # Input: - `arr`: A list of integers, which can be empty or contain up to 10^5 elements. # Output: - A list of integers sorted in non-decreasing order. # Constraints: - The elements in the array can include negative and positive integers. - The algorithm should maintain a time complexity of O(n log n). - Avoid using Python\'s built-in sort function (`sorted()` or `sort()`). - Focus on writing the merge_sort algorithm from scratch. # Performance Requirements: - The implementation should strive for optimized space usage, but it can still depend on additional storage for temporary arrays. - Ensure the solution performs well for large datasets given the constraints. # Example: ```python # Example 1: input_list = [38, 27, 43, 3, 9, 82, 10] output_list = custom_merge_sort(input_list) print(output_list) # Output: [3, 9, 10, 27, 38, 43, 82] # Example 2: input_list = [] output_list = custom_merge_sort(input_list) print(output_list) # Output: [] # Example 3: input_list = [-5, -1, -6, 0, 12, 9, -3] output_list = custom_merge_sort(input_list) print(output_list) # Output: [-6, -5, -3, -1, 0, 9, 12] ``` # Detailed Requirements: 1. **Base Case Handling**: Ensure that an empty array or an array with a single element is handled correctly. 2. **Divide and Conquer**: Use a recursive approach to split the array into halves until sub-arrays have at most one element. 3. **Merge Sub-arrays**: Implement a helper `merge` function that combines two sorted sub-arrays into a single sorted array. 4. **Edge Cases**: Consider arrays with duplicate elements, negative integers, and the smallest possible arrays. Good luck! Remember to test your function with various inputs to ensure its correctness and efficiency.","solution":"def custom_merge_sort(arr): Sorts an unsorted list of integers using the Merge Sort algorithm. if len(arr) <= 1: return arr def merge(left, right): sorted_arr = [] i = j = 0 # Merge the two lists while preserving sorted order while i < len(left) and j < len(right): if left[i] <= right[j]: sorted_arr.append(left[i]) i += 1 else: sorted_arr.append(right[j]) j += 1 # Collect the remaining elements sorted_arr.extend(left[i:]) sorted_arr.extend(right[j:]) return sorted_arr middle = len(arr) // 2 left = custom_merge_sort(arr[:middle]) right = custom_merge_sort(arr[middle:]) return merge(left, right)"},{"question":"# Integer and Byte Array Conversion Functions Given the fundamental need to handle data conversions between integers and byte arrays, particularly in contexts requiring communication between systems with differing endian formats, your task is to implement utility functions for these conversions. Problem Statement You are required to implement two functions: 1. **int_to_bytes(num, endian=\'big\')**: Convert an integer to a byte array. 2. **bytes_to_int(bytestr, endian=\'big\')**: Convert a byte array to an integer. **Function Signatures**: ```python def int_to_bytes(num: int, endian: str = \'big\') -> bytes: pass def bytes_to_int(bytestr: bytes, endian: str = \'big\') -> int: pass ``` Requirements 1. **int_to_bytes(num, endian)**: - **Input**: An integer `num` (0 <= num < 2**64), and an `endian` string (\'big\' or \'little\'). - **Output**: A byte array representing the integer. - **Examples**: - `int_to_bytes(305419896, \'big\')` should return `b\'x12x34x56x78\'`. - `int_to_bytes(305419896, \'little\')` should return `b\'x78x56x34x12\'`. 2. **bytes_to_int(bytestr, endian)**: - **Input**: A byte array `bytestr`, and an `endian` string (\'big\' or \'little\'). - **Output**: An integer representing the byte array. - **Examples**: - `bytes_to_int(b\'x12x34x56x78\', \'big\')` should return `305419896`. - `bytes_to_int(b\'x78x56x34x12\', \'little\')` should return `305419896`. Constraints 1. The `endian` parameter should be default to `\'big\'`. 2. Handle all edge cases including empty byte arrays and the number zero. Performance - Ensure the implementation itself should run efficiently in O(N) time complexity, where N is the number of bytes derived from the integer or provided in the byte array. Example ```python assert int_to_bytes(4660, \'big\') == b\'x12x34\' assert int_to_bytes(4660, \'little\') == b\'x34x12\' assert bytes_to_int(b\'x12x34\', \'big\') == 4660 assert bytes_to_int(b\'x34x12\', \'little\') == 4660 ```","solution":"def int_to_bytes(num: int, endian: str = \'big\') -> bytes: Converts an integer to a byte array. Args: num: The integer to convert. endian: The byte order (\'big\' or \'little\'). Returns: The byte array representation of the integer. return num.to_bytes((num.bit_length() + 7) // 8 or 1, byteorder=endian) def bytes_to_int(bytestr: bytes, endian: str = \'big\') -> int: Converts a byte array to an integer. Args: bytestr: The byte array to convert. endian: The byte order (\'big\' or \'little\'). Returns: The integer representation of the byte array. return int.from_bytes(bytestr, byteorder=endian)"},{"question":"Context You are developing a word processing application that features word search and autocomplete functionalities. To ensure the utility is efficient and robust, you have decided to implement a Trie (Prefix Tree). Task Implement a class `WordDictionary` that supports the following methods: 1. `add_word(word: str)` which adds a word to the data structure. 2. `search(word: str) -> bool` which searches for a word in the data structure. `.` can be used in the search string as a wildcard that matches any one letter. Input and Output Formats - **add_word(word: str)**: Adds a word to the dictionary. - **Input**: A non-empty string consisting of lowercase alphabets (`a` to `z`). - **Output**: None - **search(word: str) -> bool**: Returns boolean indicating the existence of the word in the dictionary. - **Input**: A non-empty string consisting of lowercase alphabets and/or the `.` wildcard. - **Output**: True if the word is in the dictionary (considering wildcards), otherwise False. Constraints - The length of each word added or searched will be in the range [1, 100]. - There can be up to 10⁵ add_word and search operations combined. - Memory usage should be optimized, and performance should be considered, especially for searches with wildcards. Example ```python # Initialization word_dict = WordDictionary() # Adding words word_dict.add_word(\\"bad\\") word_dict.add_word(\\"dad\\") word_dict.add_word(\\"mad\\") # Searching for words print(word_dict.search(\\"pad\\")) # Output: False print(word_dict.search(\\"bad\\")) # Output: True print(word_dict.search(\\".ad\\")) # Output: True print(word_dict.search(\\"b..\\")) # Output: True ``` Additional Requirements - Handle edge cases such as searching for an empty string or attempting to add a duplicate word. - Optimize the `search` method to handle cases with multiple wildcards efficiently.","solution":"class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False class WordDictionary: def __init__(self): self.root = TrieNode() def add_word(self, word: str) -> None: node = self.root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.is_end_of_word = True def search(self, word: str) -> bool: def search_in_node(word, node): for i, char in enumerate(word): if char == \'.\': for child in node.children: if search_in_node(word[i+1:], node.children[child]): return True return False elif char not in node.children: return False node = node.children[char] return node.is_end_of_word return search_in_node(word, self.root)"},{"question":"# Question: Implement a function that finds if there is a path between two nodes in a directed graph. Function Signature: ```python def is_path(graph: DirectedGraph, start: str, end: str) -> bool: pass ``` Input: - `graph`: An instance of the DirectedGraph class. - `start`: A string representing the starting node\'s name. - `end`: A string representing the ending node\'s name. Output: - Returns a boolean indicating whether a path exists from `start` to `end`. Constraints: - Node names are unique strings. - The graph can be disconnected. - Nodes and edges have already been added to the graph. Performance Requirements: - Your solution should be efficient enough to handle graphs with up to 10^4 nodes and 10^5 edges. # Example: ```python # Create a graph instance graph_data = { \'A\': [\'B\', \'C\'], \'B\': [\'D\'], \'C\': [\'E\'], \'D\': [\'E\'], \'E\': [], } graph = DirectedGraph(graph_data) # Check paths print(is_path(graph, \'A\', \'E\')) # Should return True print(is_path(graph, \'A\', \'D\')) # Should return True print(is_path(graph, \'A\', \'F\')) # Should return False ``` # Scenario: Imagine you are developing a navigation system for a city with many one-way streets (represented as directed edges). You need to determine if there is a route from one location to another using the path rules. Required Implementation: Implement the `is_path` function using appropriate graph traversal algorithms. Handle edge cases like non-existent nodes and disconnected graphs. Aim for clarity and efficiency.","solution":"class DirectedGraph: def __init__(self, adjacency_list): self.adjacency_list = adjacency_list def is_path(graph: DirectedGraph, start: str, end: str) -> bool: Determines if there is a path from start to end in a directed graph. if start not in graph.adjacency_list or end not in graph.adjacency_list: return False visited = set() stack = [start] while stack: current = stack.pop() if current == end: return True if current not in visited: visited.add(current) stack.extend(graph.adjacency_list.get(current, [])) return False"},{"question":"# Question: Scenario: You are given an undirected graph representing a network of computers connected to each other. The graph is represented as an adjacency list where each key is a computer and the value is a list of directly connected computers. Your task is to implement functions that determine whether the network is fully connected and to identify any isolated components. Task: 1. Write a function `is_fully_connected(graph)` that checks if the entire network is fully connected using BFS. 2. Write a function `find_components(graph)` that identifies and returns all isolated components in the network using DFS. Input: * `graph` (dict): A dictionary where keys are nodes (integers or strings representing computers) and values are lists of directly connected nodes. Output: * `is_fully_connected(graph)` should return a boolean indicating if the entire graph is fully connected. * `find_components(graph)` should return a list of sets, where each set represents all nodes in an isolated component. Constraints: * Nodes are uniquely identifiable and non-empty. * There are no self-loops or parallel edges. * The size of the graph does not exceed 1000 nodes. Example: ```python # Example graph graph = { 1: [2, 3], 2: [1, 3], 3: [1, 2], 4: [5], 5: [4], 6: [] # Node 6 is isolated } # Sample Outputs print(is_fully_connected(graph)) # Output: False print(find_components(graph)) # Output: [{1, 2, 3}, {4, 5}, {6}] ``` Performance Requirements: The implementation should be efficient in terms of time and space complexity, suitable for graphs with up to 1000 nodes. Good luck, and make sure to test your code against the provided example and any edge cases you can think of!","solution":"def is_fully_connected(graph): Returns True if the graph is fully connected, else False. if not graph: return True start = next(iter(graph)) visited = set() queue = [start] while queue: node = queue.pop(0) if node not in visited: visited.add(node) queue.extend(neighbor for neighbor in graph[node] if neighbor not in visited) return len(visited) == len(graph) def find_components(graph): Returns a list of sets, where each set contains all nodes in an isolated component. def dfs(node, visited, component): stack = [node] while stack: n = stack.pop() if n not in visited: visited.add(n) component.add(n) stack.extend(neighbor for neighbor in graph[n] if neighbor not in visited) visited = set() components = [] for node in graph: if node not in visited: component = set() dfs(node, visited, component) components.append(component) return components"},{"question":"**Scenario**: Imagine you are developing a tree visualization tool that displays binary trees in a structured format. To help users understand the structure of their trees, your tool needs a function to perform a **preorder traversal** on a binary tree. **Task**: Implement a function `preorder_traversal` that performs a preorder traversal given the root of a binary tree and returns a list of values in preorder sequence. # Function Signature: ```python def preorder_traversal(root: \'Node\') -> List[int]: pass ``` # Input: * `root` - an instance of the `Node` class representing the root of the binary tree. # Output: * A list of integers representing the preorder traversal of the tree. # Constraints: * The maximum number of nodes is (10^4). * Node values are unique integer values. # Performance Requirements: * The function must run in O(n) time complexity and use no more than O(n) additional space. # Example: Given the binary tree: ``` 1 / 2 3 / 4 5 ``` The preorder traversal should return `[1, 2, 4, 5, 3]`. # Additional Requirements: Ensure to handle edge cases such as: * An empty tree (returning an empty list). * A single node tree (returning a list with one element).","solution":"class Node: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def preorder_traversal(root): Performs a preorder traversal and returns a list of values. :param root: The root node of the binary tree. :return: List of integers representing the preorder traversal. if root is None: return [] result = [] stack = [root] while stack: node = stack.pop() result.append(node.value) # Push right first so that left is processed first if node.right: stack.append(node.right) if node.left: stack.append(node.left) return result"},{"question":"You are tasked with verifying and extending the implementation of Tarjan\'s Strongly Connected Components (SCC) algorithm provided above. The goal is to create a robust function that can be used in various applications requiring SCC detection in directed graphs. # Task Description Implement a function `find_sccs(graph)` that accepts a directed graph represented as a dictionary and returns a list of strongly connected components. Each SCC in the list should be represented as a list of vertices. The input graph dictionary has vertices as keys and lists of adjacent vertices as values. # Function Signature ```python def find_sccs(graph: dict) -> list: ``` # Input * `graph`: A dictionary where keys are vertices (nodes) and values are lists of adjacent vertices. # Output * A list of lists, with each inner list representing a strongly connected component. Each SCC should be sorted in ascending order of vertices. # Constraints * The graph contains at most (10^4) vertices. * The graph contains at most (10^5) edges. * Vertices are represented as integers. # Example ```python graph = { 0: [1], 1: [2], 2: [0, 3], 3: [4], 4: [5], 5: [3, 6], 6: [] } print(find_sccs(graph)) # Output: [[0, 1, 2], [3, 4, 5], [6]] ``` # Additional Notes * Carefully handle edge cases such as graphs with no edges, self-loops, or disconnected components. * Ensure that your implementation does not modify the input graph. * Aim for a linear time complexity O(V + E) and linear space complexity O(V).","solution":"def find_sccs(graph): Find strongly connected components in a directed graph using Tarjan\'s algorithm. index = 0 stack = [] indices = {} lowlinks = {} on_stack = {} sccs = [] def strongconnect(node): nonlocal index indices[node] = index lowlinks[node] = index index += 1 stack.append(node) on_stack[node] = True for neighbor in graph.get(node, []): if neighbor not in indices: strongconnect(neighbor) lowlinks[node] = min(lowlinks[node], lowlinks[neighbor]) elif on_stack[neighbor]: lowlinks[node] = min(lowlinks[node], indices[neighbor]) if lowlinks[node] == indices[node]: scc = [] while True: w = stack.pop() on_stack[w] = False scc.append(w) if w == node: break sccs.append(sorted(scc)) for node in graph: if node not in indices: strongconnect(node) return sorted(sccs)"},{"question":"Scenario You are working on an e-commerce platform\'s search system. The search engine logs user behavior in a BST where nodes represent search queries, and the values denote the search popularity ranking of these queries. You need to frequently retrieve the k-th most popular search query to analyze user behavior patterns. Objective Write a function `find_kth_popular` that efficiently retrieves the k-th most popular search query in a large BST. Function Signature ```python def find_kth_popular(root: \'TreeNode\', k: int) -> int: pass ``` Input * `root`: The root node of a BST representing search queries. * `k`: An integer denoting the k-th position (1-indexed). Output * Return the value of the k-th most popular search query. Constraints * The total number of nodes in the BST does not exceed 10,000. * 1 <= k <= number of nodes in the BST. Example Given the following BST: ``` 100 / 50 150 / / 25 75 125 175 ``` 1. `find_kth_popular(root, 2)` should return 50 (the second most popular search). 2. `find_kth_popular(root, 5)` should return 125 (the fifth most popular search). Notes * Your solution should aim to optimize time and space complexity. * Consider edge cases where k exceeds the number of nodes. Testing Ensure your function passes various test cases, including edge cases. ```python # Tester code if __name__ == \'__main__\': n1 = Node(100) n2 = Node(50) n3 = Node(150) n4 = Node(25) n5 = Node(75) n6 = Node(125) n7 = Node(175) n1.left, n1.right = n2, n3 n2.left, n2.right = n4, n5 n3.left, n3.right = n6, n7 assert find_kth_popular(n1, 1) == 25 assert find_kth_popular(n1, 2) == 50 assert find_kth_popular(n1, 3) == 75 assert find_kth_popular(n1, 4) == 100 assert find_kth_popular(n1, 5) == 125 assert find_kth_popular(n1, 6) == 150 assert find_kth_popular(n1, 7) == 175 ```","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def find_kth_popular(root: \'TreeNode\', k: int) -> int: def inorder_traversal(node): if not node: return [] return inorder_traversal(node.left) + [node.val] + inorder_traversal(node.right) sorted_vals = inorder_traversal(root) return sorted_vals[k-1] # Alternatively, instead of generating a list of all values, we can use an in-place traversal # to find the k-th element without storing the entire tree values def find_kth_popular_inplace(root: \'TreeNode\', k: int) -> int: def inorder(node): if not node or inorder.counter >= k: return inorder(node.left) if inorder.counter < k: inorder.counter += 1 if inorder.counter == k: inorder.result = node.val inorder(node.right) inorder.counter = 0 inorder.result = None inorder(root) return inorder.result"},{"question":"Coding Assessment Question # Scenario You have been given the task of implementing a function to analyze the structure of a binary search tree (BST) and determine its sparsity by counting the number of empty branches. This is crucial for understanding how full or sparse the BST is. # Problem Statement Write a function `num_empty` that counts the number of empty branches (null pointers) in a given binary search tree (BST). An empty branch is defined as a null left or right child of a node. Each leaf node of the BST is considered to have two empty branches. # Function Signature ```python def num_empty(root: \'Node\') -> int: # implementation here ``` # Constraints 1. You are given the root of a binary search tree (`Node`), where `None` indicates that there is no node. 2. If the tree is empty (`root` is `None`), it should return `1` as there is one implicit empty branch. 3. The given BST may contain duplicate values. 4. The height of the tree can be large, so consider the implications on the call stack for recursive solutions. # Input and Output Formats - **Input**: The input to the function is `root`, which is the root of a binary search tree. - **Output**: The function should return an integer representing the number of empty branches in the tree. # Examples ```python # Example 1 # Tree: 9 # / # 6 12 # / / # 3 8 10 15 # # 7 18 # Explanation: The tree has 10 empty branches as visualized in the example. tree.insert(9) tree.insert(6) tree.insert(12) tree.insert(3) tree.insert(8) tree.insert(10) tree.insert(15) tree.insert(7) tree.insert(18) assert num_empty(tree.root) == 10 # Example 2 # Tree: 5 # / # 3 None # / # None 4 # Explanation: The tree has 4 empty branches: # - The right child of the root. # - Both left and right child of node 3. # - Both left and right child of node 4. tree.insert(5) tree.insert(3) tree.insert(4) assert num_empty(tree.root) == 4 ``` # Notes: - Ensure you have a proper understanding of binary search tree operations and traversal techniques. - Test your implementation against various edge cases to confirm it works as expected.","solution":"class Node: A node in a binary search tree. def __init__(self, data): self.data = data self.left = None self.right = None class BST: A binary search tree. def __init__(self): self.root = None def insert(self, data): if self.root is None: self.root = Node(data) else: self._insert(data, self.root) def _insert(self, data, node): if data < node.data: if node.left is None: node.left = Node(data) else: self._insert(data, node.left) else: if node.right is None: node.right = Node(data) else: self._insert(data, node.right) def num_empty(root): Counts the number of empty branches (null pointers) in a given binary search tree. if root is None: return 1 empty_branches = 0 if root.left is None: empty_branches += 1 else: empty_branches += num_empty(root.left) if root.right is None: empty_branches += 1 else: empty_branches += num_empty(root.right) return empty_branches"},{"question":"# Decoding Nested Encoded Strings Context You are given an encoded string where some substrings are repeated according to a specific pattern. Your task is to write a function to decode this string. This problem is a common scenario in data compression and transmission, ensuring efficient data use by exploiting repetition without redundancy. Problem Statement Given an encoded string, your task is to return its decoded version. The encoding rule follows patterns in the form `k[encoded_string]`, where `k` is a positive integer representing the number of times the `encoded_string` should be repeated. The encoded string may contain other nested encoded substrings. Input * A single string `s`, which follows the encoding rules and is valid. Output * Return the decoded string corresponding to `s`. Examples ``` Example 1: Input: s = \\"3[a]2[bc]\\" Output: \\"aaabcbc\\" Example 2: Input: s = \\"3[a2[c]]\\" Output: \\"accaccacc\\" Example 3: Input: s = \\"2[abc]3[cd]ef\\" Output: \\"abcabccdcdcdef\\" ``` Constraints * The input string `s` contains only lowercase English letters, digits, and square brackets. * The input string `s` is guaranteed to be well-formed according to the described encoding rule. * The input string does not contain any extra spaces. Requirements * The solution should efficiently handle nested and sequential patterns. * Consider performance implications for deeply nested structures. * Ensure an optimal approach for O(n) time complexity where n is the length of the input string.","solution":"def decode_string(s: str) -> str: Decodes the given encoded string according to the described encoding rule. :param s: The encoded string :return: The decoded string stack = [] current_num = 0 current_str = \'\' for char in s: if char.isdigit(): current_num = current_num * 10 + int(char) elif char == \'[\': stack.append((current_str, current_num)) current_str = \'\' current_num = 0 elif char == \']\': last_str, num = stack.pop() current_str = last_str + current_str * num else: current_str += char return current_str"},{"question":"You are tasked with implementing a secure communication channel using the Diffie-Hellman key exchange algorithm. This algorithm allows two parties, Alice and Bob, to establish a shared secret over an unsecured channel by leveraging properties of prime numbers and primitive roots. # Objective Create a function named `diffie_hellman_key_exchange(a: int, p: int, option: int = None) -> bool` that simulates the process of generating, exchanging, and establishing a shared secret key between Alice and Bob, given: - `a`: an integer which should be a primitive root modulo p. - `p`: a large prime integer. - `option`: an optional parameter for debugging purposes, if set, the function should print intermediate steps. # Input/Output Formats - **Input**: - `a`: an integer representing the primitive root. - `p`: a large prime number. - `option`: an optional integer for verbosity. - **Output**: - Returns `True` if the shared key exchange is successful, `False` otherwise. # Constraints - Ensure `p` is a prime number. If not, return `False`. - Ensure `a` is a primitive root of `p`. If not, return `False`. - Assume that `a` and `p` are within the appropriate range for large prime numbers typically used in cryptographic applications. # Requirements 1. Implement all necessary helper functions: - `prime_check(num: int) -> bool` - `find_primitive_root(n: int) -> list` - `alice_private_key(p: int) -> int` - `alice_public_key(a_pr_k: int, a: int, p: int) -> int` - `bob_private_key(p: int) -> int` - `bob_public_key(b_pr_k: int, a: int, p: int) -> int` - `alice_shared_key(b_pu_k: int, a_pr_k: int, p: int) -> int` - `bob_shared_key(a_pu_k: int, b_pr_k: int, p: int) -> int` 2. Ensure that `diffie_hellman_key_exchange` function integrates these helper functions correctly and adheres to the process outlined. # Example ```python # Example of initiating diffie-hellman key exchange # Given a large prime p and its primitive root a a = 2 p = 11 assert diffie_hellman_key_exchange(a, p) == True ```","solution":"from random import randint from sympy import isprime, primitive_root def prime_check(num: int) -> bool: return isprime(num) def find_primitive_root(n: int) -> list: try: return [primitive_root(n)] except ValueError: return [] def alice_private_key(p: int) -> int: return randint(2, p-1) def alice_public_key(a_pr_k: int, a: int, p: int) -> int: return pow(a, a_pr_k, p) def bob_private_key(p: int) -> int: return randint(2, p-1) def bob_public_key(b_pr_k: int, a: int, p: int) -> int: return pow(a, b_pr_k, p) def alice_shared_key(b_pu_k: int, a_pr_k: int, p: int) -> int: return pow(b_pu_k, a_pr_k, p) def bob_shared_key(a_pu_k: int, b_pr_k: int, p: int) -> int: return pow(a_pu_k, b_pr_k, p) def diffie_hellman_key_exchange(a: int, p: int, option: int = None) -> bool: if not prime_check(p): if option: print(\\"The provided number p is not a prime.\\") return False primitive_roots = find_primitive_root(p) if not primitive_roots or a not in primitive_roots: if option: print(\\"The provided number a is not a primitive root of p.\\") return False # Alice\'s private and public keys a_pr_k = alice_private_key(p) a_pu_k = alice_public_key(a_pr_k, a, p) if option: print(f\\"Alice\'s private key: {a_pr_k}\\") print(f\\"Alice\'s public key: {a_pu_k}\\") # Bob\'s private and public keys b_pr_k = bob_private_key(p) b_pu_k = bob_public_key(b_pr_k, a, p) if option: print(f\\"Bob\'s private key: {b_pr_k}\\") print(f\\"Bob\'s public key: {b_pu_k}\\") # Shared keys alice_shared = alice_shared_key(b_pu_k, a_pr_k, p) bob_shared = bob_shared_key(a_pu_k, b_pr_k, p) if option: print(f\\"Alice\'s shared key: {alice_shared}\\") print(f\\"Bob\'s shared key: {bob_shared}\\") return alice_shared == bob_shared"},{"question":"**Context**: You are tasked to manage booking times for a conference room that has fixed time slots. Given a list of booked intervals, you need to ensure there are no overlapping bookings by merging any overlapping time slots. Additionally, attendees need queries to check whether their requested time slot falls into any booked interval. **Question**: Write a class `IntervalScheduler` that encapsulates the functionality of booking intervals and checking if a time falls into any interval. Implement the following methods: 1. **add_interval(start, end)**: Add a new booking interval. 2. **merge_intervals()**: Merge all overlapping intervals in the current list of bookings. 3. **is_time_booked(time)**: Check if the given time falls into any of the existing intervals. **Input Format**: - For `add_interval(start, end)`, start and end are integers where `start <= end`. - For `is_time_booked(time)`, time is a single integer. **Output Format**: - `merge_intervals()`: This should update the list of intervals to a merged state. - `is_time_booked(time)`: Return `True` if the time is within any booked interval, otherwise `False`. **Constraints**: - All interval boundaries and queried times are integers. - Intervals are half-open: [start, end) # Example: ```python scheduler = IntervalScheduler() scheduler.add_interval(1, 3) scheduler.add_interval(2, 4) scheduler.add_interval(5, 7) scheduler.add_interval(6, 8) scheduler.merge_intervals() # After merging, intervals should be [1, 4], [5, 8] print(scheduler.is_time_booked(3)) # True print(scheduler.is_time_booked(4)) # False print(scheduler.is_time_booked(6)) # True ``` **Note**: Ensure your implementation optimizes for performance, particularly for the merge operation.","solution":"class IntervalScheduler: def __init__(self): self.intervals = [] def add_interval(self, start, end): Add a new booking interval. self.intervals.append((start, end)) def merge_intervals(self): Merge all overlapping intervals. if not self.intervals: return self.intervals.sort() merged = [self.intervals[0]] for current in self.intervals[1:]: last = merged[-1] if current[0] <= last[1]: # Overlapping intervals merged[-1] = (last[0], max(last[1], current[1])) else: merged.append(current) self.intervals = merged def is_time_booked(self, time): Check if the given time falls into any booked interval. for start, end in self.intervals: if start <= time < end: return True return False"},{"question":"# FizzBuzz Alternative Challenge You are tasked to transform the classic FizzBuzz problem into a more extensible and generalized version. **Scenario**: In a kingdom, the Royal Programmer is assigned to develop an advanced version of the FizzBuzz using more diverse and extended rules based on multiple divisors and corresponding words. **Function Specification**: Write a function `advanced_fizzbuzz(n: int, rules: List[Tuple[int, str]]) -> List[Union[int, str]]`. The function should take: 1. An integer `n` indicating the range of numbers from 1 to `n`. 2. A list of tuples `rules`, each containing an integer and a corresponding replacement string. For example, `(3, \\"Fizz\\")` means numbers divisible by 3 should be replaced by \\"Fizz\\". The function should return a list of numbers from 1 to `n`, replacing multiples of any of the given divisors with their respective strings. If a number is a multiple of several divisors, concatenate their strings in the order provided in the rules. **Input**: - `n`: An integer 1 ≤ n ≤ 10^5. - `rules`: A list of tuples where each tuple contains an integer and a string. The integers are positive. **Output**: - Returns a list of either integers or strings. **Constraints**: - Ensure the function runs efficiently within the provided constraints. - Each string replacement must exactly follow the order as given in the rules list. **Example**: ```python # Example 1: n = 15 rules = [(3, \\"Fizz\\"), (5, \\"Buzz\\")] # Output: [1, 2, \\"Fizz\\", 4, \\"Buzz\\", \\"Fizz\\", 7, 8, \\"Fizz\\", \\"Buzz\\", 11, \\"Fizz\\", 13, 14, \\"FizzBuzz\\"] # Example 2: n = 10 rules = [(2, \\"Hello\\"), (5, \\"World\\")] # Output: [1, \\"Hello\\", 3, \\"Hello\\", \\"HelloWorld\\", \\"Hello\\", 7, \\"Hello\\", 9, \\"HelloWorld\\"] ``` **Implementation Note**: 1. Validate `n` to ensure it is within the allowable range. 2. Validate rules to ensure tuples contain positive integers and non-empty strings. 3. Follow the order of the rules for replacements if multiple divisors match. ```python def advanced_fizzbuzz(n: int, rules: List[Tuple[int, str]]) -> List[Union[int, str]]: # Your implementation here pass ```","solution":"from typing import List, Tuple, Union def advanced_fizzbuzz(n: int, rules: List[Tuple[int, str]]) -> List[Union[int, str]]: result = [] for i in range(1, n + 1): replacement = \'\' for divisor, word in rules: if i % divisor == 0: replacement += word if replacement == \'\': result.append(i) else: result.append(replacement) return result"},{"question":"You are tasked with creating a function that converts an integer to a Roman numeral. The input integer will be in the range from 1 to 3999, inclusive. Your function should follow the standard Roman numeral convention and output the corresponding Roman numeral string. # Input Format - A single integer `num`, where 1 ≤ `num` ≤ 3999. # Output Format - A string representing the Roman numeral form of the input integer. # Constraints - The input integer will always be within the range [1, 3999]. # Requirements - Your function must run in constant time O(1). - Avoid using loops and minimize the use of conditional statements. - Consider properties and applications of Roman numerals in your design. # Example ```python Input: 3549 Output: \\"MMMDXLIX\\" Input: 9 Output: \\"IX\\" ``` # Task Implement the following function: ```python def int_to_roman(num): :type num: int :rtype: str # Your implementation here ``` # Hints - Leverage predefined mappings for thousands, hundreds, tens, and units. - Concatenate the results from these mappings to obtain the final Roman numeral string. Good luck!","solution":"def int_to_roman(num): Convert an integer to a Roman numeral. :type num: int :rtype: str val = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1] syb = [\\"M\\", \\"CM\\", \\"D\\", \\"CD\\", \\"C\\", \\"XC\\", \\"L\\", \\"XL\\", \\"X\\", \\"IX\\", \\"V\\", \\"IV\\", \\"I\\"] roman_num = \'\' i = 0 while num > 0: for _ in range(num // val[i]): roman_num += syb[i] num -= val[i] i += 1 return roman_num"},{"question":"**Scenario**: You have been hired by a tech company to optimize their database sorting functionality. The database primarily stores numerical records which need to be sorted frequently for reporting purposes. The current implementation uses Quick Sort but exhibits poor performance with certain datasets such as those that are already sorted or contain many duplicate values. **Task**: Write a function that implements the Quick Sort algorithm incorporating optimizations to handle edge cases and improve performance. Specifically: 1. Use the median-of-three rule for selecting the pivot element. 2. Switch to Insertion Sort for subarrays smaller than a specified threshold for better performance on nearly sorted arrays. **Function Signature**: ```python def optimized_quick_sort(arr): # Your implementation here pass ``` **Expected Input and Output Formats**: * Input: An unsorted list of integers `arr`. * Output: A sorted list `arr`. **Constraints**: * The input list can contain duplicates. * The length of the input list is at most 10,000. **Performance Requirements**: * The average-case time complexity should remain O(n log n). **Implementation Details**: 1. **Median-of-three rule for pivot selection**: Instead of always picking the last element as the pivot, choose the median of the first, middle, and last elements. This can help with the poor performance on sorted or nearly sorted inputs. 2. **Insertion Sort for small subarrays**: For subarrays smaller than a threshold (e.g., 10 elements), use Insertion Sort instead of Quick Sort as it has less overhead and performs better on small datasets. **Execution Example**: ```python arr = [3, 6, 9, 1, 0, 2, 8, 4, 7, 5] optimized_quick_sort(arr) # Output: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] ```","solution":"def insertion_sort(arr, left, right): for i in range(left + 1, right + 1): key = arr[i] j = i - 1 while j >= left and arr[j] > key: arr[j + 1] = arr[j] j -= 1 arr[j + 1] = key def median_of_three(arr, low, high): mid = (low + high) // 2 if arr[low] > arr[mid]: arr[low], arr[mid] = arr[mid], arr[low] if arr[low] > arr[high]: arr[low], arr[high] = arr[high], arr[low] if arr[mid] > arr[high]: arr[mid], arr[high] = arr[high], arr[mid] arr[mid], arr[high] = arr[high], arr[mid] return arr[high] def partition(arr, low, high): pivot = median_of_three(arr, low, high) i = low - 1 for j in range(low, high): if arr[j] <= pivot: i += 1 arr[i], arr[j] = arr[j], arr[i] arr[i + 1], arr[high] = arr[high], arr[i + 1] return i + 1 def quick_sort(arr, low, high): threshold = 10 if low < high: if high - low < threshold: insertion_sort(arr, low, high) else: pi = partition(arr, low, high) quick_sort(arr, low, pi - 1) quick_sort(arr, pi + 1, high) def optimized_quick_sort(arr): if not arr: return [] quick_sort(arr, 0, len(arr) - 1) return arr"},{"question":"Determine if a Number is a Power of Four Scenario: You have been asked to extend a utility function that determines if a given integer is a power of four. Powers of four have several applications in computer science, especially concerning certain optimizations in memory and data structures. Task: Write a function `is_power_of_four(n)` that returns whether a given integer `n` is a power of four. Requirements: 1. The function should take an integer `n` as input. 2. It should return `True` if `n` is a power of four, otherwise `False`. Input: - An integer `n` (can be positive, negative, or zero). Output: - A boolean value indicating if `n` is a power of four. Constraints: - Time Complexity should be O(1). - Space Complexity should be O(1). Example: ```python assert is_power_of_four(1) == True assert is_power_of_four(16) == True assert is_power_of_four(64) == True assert is_power_of_four(15) == False assert is_power_of_four(0) == False assert is_power_of_four(-4) == False ``` Notes: - Powers of Four include numbers like 1, 4, 16, 64, etc. - A number `n` is a power of four if only one bit is set in its binary representation and the count of zeroes after that bit should be even.","solution":"def is_power_of_four(n): Returns True if n is a power of four, otherwise False. if n <= 0: return False if (n & (n - 1)) != 0: # Check if it\'s a power of two return False # Check if the only set bit is at the correct position for a power of four return (n & 0xAAAAAAAA) == 0"},{"question":"**Problem Description:** You are tasked with implementing a function to compute the binomial coefficient C(n, k) using dynamic programming to avoid the pitfalls of deep recursion. The binomial coefficient is defined as the number of ways to choose k elements from n elements without regard to the order. It is mathematically represented as: [ C(n, k) = frac{n!}{k!(n-k)!} ] Your function should take in two non-negative integers, n and k, with ( n geq k ), and return the binomial coefficient computed iteratively. **Function Signature:** ```python def iterative_binomial_coefficient(n: int, k: int) -> int: pass ``` **Input:** - `n`: A non-negative integer (0 ≤ n ≤ 1000) - `k`: A non-negative integer such that ( 0 ≤ k ≤ n ) **Output:** - An integer representing the binomial coefficient C(n, k) **Constraints:** - The function should handle edge cases where ( n geq k ). - You must ensure that the function runs efficiently even for large values of n within the given constraints. **Example:** ```python assert iterative_binomial_coefficient(5, 0) == 1 assert iterative_binomial_coefficient(8, 2) == 28 assert iterative_binomial_coefficient(500, 300) == 2.6764655799490136e+148 # Just an example; actual number can be huge ``` **Performance Requirements:** - Time Complexity: O(n * k) using dynamic programming approach. - Space Complexity: O(n) using a single-dimensional array. **Brief Scenario:** You are working for a company that needs to calculate binomial coefficients frequently for large values of n and k. Recursion can become inefficient and unmanageable due to stack overflow issues. An iterative approach would ensure robust performance across all input ranges. Implement the `iterative_binomial_coefficient` function to meet these requirements.","solution":"def iterative_binomial_coefficient(n: int, k: int) -> int: Computes the binomial coefficient C(n, k) using an iterative dynamic programming approach. if k > n: return 0 # Since C(n, k) = C(n, n-k) if k > n - k: k = n - k # Create an array to store solutions to subproblems C = [0] * (k + 1) C[0] = 1 # Base case # Calculate value of Binomial Coefficient in bottom-up manner for i in range(1, n + 1): # Compute next row of Pascal\'s triangle using the previous row j = min(i, k) while j > 0: C[j] += C[j - 1] j -= 1 return C[k]"},{"question":"A strobogrammatic number is a number that looks the same when rotated 180 degrees (looked at upside down). The strobogrammatic digits are: `0`, `1`, `8`, `6` and `9`. Your task is to write a function that finds all strobogrammatic numbers that lie within a given numeric range `[low, high]`. # Function Signature ```python def find_strobogrammatic_numbers(low: str, high: str) -> List[str]: :param low: str - The lower bound of the range. :param high: str - The upper bound of the range. :return: List[str] - A list of all strobogrammatic numbers in the range [low, high]. ``` # Input Constraints - `low` and `high` are non-negative integers represented as strings. - `1 <= len(low) <= len(high) <= 15` - `low` and `high` are guaranteed to represent valid integers with `low <= high`. # Example ```python # Example 1 low = \\"10\\" high = \\"100\\" assert find_strobogrammatic_numbers(low, high) == [\\"11\\", \\"69\\", \\"96\\", \\"88\\"] # Example 2 low = \\"50\\" high = \\"100\\" assert find_strobogrammatic_numbers(low, high) == [\\"69\\", \\"96\\", \\"88\\"] ``` # Requirements 1. **Generate Strobogrammatic Numbers**: Implement the generation of strobogrammatic numbers using pairs (0,0), (1,1), (6,9), (9,6), (8,8). 2. **Filter Range**: Ensure that the generated strobogrammatic numbers fall within the specified range `[low, high]`. 3. **Edge Cases**: Consider edge cases like overlapping ranges, and single-digit constraints. 4. **Performance**: Optimize for performance to handle cases close to the upper limit of the constraints efficiently.","solution":"from typing import List def find_strobogrammatic_numbers(low: str, high: str) -> List[str]: def is_valid(num): if num.startswith(\'0\') and len(num) > 1: return False if int(num) < int(low) or int(num) > int(high): return False return True def build_strobogrammatic(n, final_length): if n == 0: return [\\"\\"] if n == 1: return [\\"0\\", \\"1\\", \\"8\\"] prev = build_strobogrammatic(n - 2, final_length) result = [] for num in prev: if n != final_length: result.append(\\"0\\" + num + \\"0\\") result.append(\\"1\\" + num + \\"1\\") result.append(\\"6\\" + num + \\"9\\") result.append(\\"8\\" + num + \\"8\\") result.append(\\"9\\" + num + \\"6\\") return result result = [] for length in range(len(low), len(high) + 1): result += build_strobogrammatic(length, length) result = [num for num in result if is_valid(num)] result.sort(key=int) return result"},{"question":"# Context: You are tasked with implementing a simple nearest neighbor classifier to classify the position of a new point in a 2D coordinate system based on a given labelled training set of points. Each point in the training set has a label, and the classifier should determine the label of the closest point in the training set based on Euclidean distance. # Problem Statement: Write a function `classify_point` that takes in a 2D point and a training set dictionary where the keys are 2D points (as tuples), and the values are labels (any type) assigned to these points. Your function should use the nearest neighbor algorithm to classify the input point based on the closest point in the training set. # Function Signature ```python def classify_point(point: tuple, training_set: dict) -> str: pass ``` # Input: - `point`: A tuple of two floats representing the 2D point to be classified. - `training_set`: A dictionary where keys are tuples of two floats and values are labels (strings) assigned to these keys. # Output: - A string representing the label of the nearest point. # Constraints: - All input vectors are guaranteed to be 2D points. - At least one point will be present in the training set. # Example: ```python training_set = { (1.0, 2.0): \'A\', (2.0, 3.0): \'B\', (4.0, 2.0): \'C\' } print(classify_point((3.0, 3.0), training_set)) # Output: \'B\' ``` # Requirements: 1. The function must not use any external libraries apart from the standard library. 2. Consider edge cases where distances might be very close to each other. 3. Your function should handle the mentioned constraints and ensure performance is optimal for a reasonably sized training set (up to 10,000 points).","solution":"import math def classify_point(point, training_set): Classifies the input point based on the closest point in the training set using Euclidean distance. :param point: A tuple (x, y) representing the point to be classified. :param training_set: A dictionary where keys are tuples (x, y) of training points and values are their labels. :return: The label of the nearest neighbor point. min_distance = float(\'inf\') nearest_label = None px, py = point for (tx, ty), label in training_set.items(): distance = math.sqrt((px - tx) ** 2 + (py - ty) ** 2) if distance < min_distance: min_distance = distance nearest_label = label return nearest_label"},{"question":"# Question: Implement Bogo Sort and Assess its Efficiency You are required to implement the Bogo Sort algorithm while taking into account provided constraints and required optimizations. Despite its impracticality, Bogo Sort serves as an interesting exercise in understanding inefficiencies in algorithm design. Task - Implement the `bogo_sort` function, which sorts an array using the Bogo Sort algorithm. - The function should return the sorted array. - Implement proper checks to handle edge cases and simulate how the array changes with each shuffle if `simulation` is enabled. Function Signature ```python def bogo_sort(arr: List[int], simulation: bool = False) -> List[int]: ``` Input - `arr`: A list of integers (0 < len(arr) ≤ 10) - `simulation`: A boolean flag, when `True` prints the array at each iteration. Output - A sorted list of integers. Example ```python Input: [3, 1, 2, 4], simulation=True Output: [1, 2, 3, 4] ``` Simulation output (example): ``` iteration 0: 3 1 2 4 iteration 1: 3 2 1 4 iteration 2: 1 3 4 2 ... iteration N: 1 2 3 4 ``` Constraints - The length of the array will not be greater than 10. - You must consider and handle edge cases, for example: * An empty array should return an empty array. * An already sorted array should be identified quickly. * Arrays with all identical elements. Notes - While this question primarily focuses on implementing Bogo Sort, ensure that you cover the algorithm\'s peculiarities and inefficiencies. - Performance and space complexity are not the priority for this question due to the inherently inefficient nature of the algorithm.","solution":"import random from typing import List def bogo_sort(arr: List[int], simulation: bool = False) -> List[int]: Sorts an array using the highly inefficient BogoSort algorithm. Also simulates the sorting process if the `simulation` flag is enabled. Parameters: arr (List[int]): The list of integers to sort. simulation (bool): If True, prints the array at each shuffle iteration. Returns: List[int]: The sorted list of integers. def is_sorted(arr: List[int]) -> bool: return all(arr[i] <= arr[i + 1] for i in range(len(arr) - 1)) iteration = 0 while not is_sorted(arr): if simulation: print(f\\"iteration {iteration}: {arr}\\") random.shuffle(arr) iteration += 1 if simulation: print(f\\"iteration {iteration}: {arr}\\") return arr"},{"question":"You are required to implement a **ZigZag Iterator** that can handle an arbitrary number of lists, not just two. The iterator should interleave elements from each list in a round-robin fashion. Function Signature: ```python class ZigZagIterator: def __init__(self, lists: List[List[int]]): :type lists: List[List[int]] Initialize your data structure here. pass def next(self) -> int: :rtype: int Returns the next element in the ZigZag order. pass def has_next(self) -> bool: :rtype: bool Returns true if the iterator has more elements. pass ``` Input: - The constructor will receive multiple lists of integers. - The `next()` method is expected to return the next integer in the interleaved order from the input lists. - The `has_next()` method is expected to return `True` if there are still elements remaining in any of the lists, otherwise `False`. Output: - The `next()` method should return integers in the interleaved order until all elements from all lists are exhausted. - The `has_next()` method should return `True` as long as there are remaining elements in any of the lists. Example: ```python lists = [ [1, 2, 3], [4, 5, 6, 7], [8, 9] ] it = ZigZagIterator(lists) result = [] while it.has_next(): result.append(it.next()) print(result) # Should print: [1, 4, 8, 2, 5, 9, 3, 6, 7] ``` Constraints: - Number of lists, k: (1 leq k leq 1000) - Length of each list, n: (0 leq n leq 1000) You need to ensure that your implementation of the `ZigZagIterator` handles different lengths of lists efficiently and correctly, maintaining the round-robin order as demonstrated.","solution":"from collections import deque from typing import List class ZigZagIterator: def __init__(self, lists: List[List[int]]): self.queue = deque() for lst in lists: if lst: # Only add non-empty lists self.queue.append(iter(lst)) def next(self) -> int: if not self.has_next(): raise StopIteration(\\"No more elements.\\") current_iter = self.queue.popleft() next_elem = next(current_iter) self.queue.append(current_iter) # Add it back for the next round return next_elem def has_next(self) -> bool: # Check if there\'s any list that still has elements left while self.queue: current_iter = self.queue[0] try: next_elem = next(current_iter) self.queue[0] = iter([next_elem] + list(current_iter)) return True except StopIteration: self.queue.popleft() return False"},{"question":"You are given a singly linked list where each node contains a single character. Your task is to write a function that removes duplicate characters. You need to implement two variants of this function: Function 1 Remove duplicates by using additional space. Function 2 Remove duplicates without using any additional data structures (no hashsets, arrays, etc.). # Input Format - A linked list where each node contains a single character. - The function signature will be: ```python def remove_dups(head: Node) -> None: ``` ```python def remove_dups_without_set(head: Node) -> None: ``` # Constraints - The characters in the linked list are case-sensitive. - The input linked list can have at most 10^4 nodes. # Output Format - There is no return value. The linked list should be modified in place. # Examples Example 1 Input: ``` A -> A -> B -> C -> D -> C -> F -> G ``` Output after remove_dups: ``` A -> B -> C -> D -> F -> G ``` Output after remove_dups_without_set: ``` A -> B -> C -> D -> F -> G ``` Example 2 Input: ``` H -> I -> J -> I -> K -> L -> K ``` Output after remove_dups: ``` H -> I -> J -> K -> L ``` Output after remove_dups_without_set: ``` H -> I -> J -> K -> L ``` # Explanation - Both implementations will give the same final result but with different time efficiency profiles. The function remove_dups should be efficient with O(N) time complexity and O(N) space complexity, while remove_dups_without_set will have O(N^2) time complexity and O(1) space complexity. Make sure your implementation correctly modifies the linked list in place and correctly deals with edge cases such as empty lists or lists without any duplicates. # Edge Cases to Consider - An empty linked list. - A linked list with no duplicates. - A linked list with only duplicates.","solution":"class Node: def __init__(self, value: str): self.value = value self.next = None def remove_dups(head: Node) -> None: if not head: return # Using a set to keep track of seen characters seen = set() current = head seen.add(current.value) while current.next: if current.next.value in seen: # Remove the node by skipping it current.next = current.next.next else: seen.add(current.next.value) current = current.next def remove_dups_without_set(head: Node) -> None: current = head while current: runner = current while runner.next: if runner.next.value == current.value: # Remove the node by skipping it runner.next = runner.next.next else: runner = runner.next current = current.next"},{"question":"# Scenario You are working for a transportation company that needs to optimize the cost of getting cargo from the main hub to a destination hub using a network of intermediate stations. Each route between stations has a specific cost and some routes are not possible, indicated by a cost of -1. Your task is to develop an algorithm that will determine the minimum cost to get from the starting hub (station 0) to the final destination (station N-1). # Task Given the cost matrix as described, implement a function `min_cost_to_reach_last_station(cost: List[List[int]]) -> int` to compute the minimal transportation cost from station 0 to station N-1. The function should handle matrices where infeasible routes are denoted by -1. Input Format - A 2D list `cost` of size `N x N` where `cost[i][j]` is the cost of moving from station i to station j for `i < j`. Values where `i > j` or `i == j` are irrelevant and will be set to -1 or 0 respectively. Output Format - An integer representing the minimal cost to reach station N-1 from station 0. If no feasible path exists, return `float(\\"inf\\")`. Constraints - `2 <= N <= 100` (Number of stations) - The cost matrix values will be within the constraints of non-negative integers or -1 for no direct route. Example ```python cost = [ [0, 15, 80, 90], [-1, 0, 40, 50], [-1, -1, 0, 70], [-1, -1, -1, 0] ] assert min_cost_to_reach_last_station(cost) == 65 # Minimum cost path: 0 -> 1 -> 3 ``` # Additional Notes - Ensure your solution handles edge cases like absence of feasible paths and highly variable costs efficiently. - The provided matrix is always valid and square.","solution":"from typing import List def min_cost_to_reach_last_station(cost: List[List[int]]) -> int: n = len(cost) min_cost = [float(\'inf\')] * n min_cost[0] = 0 for i in range(n - 1): for j in range(i + 1, n): if cost[i][j] != -1 and min_cost[i] != float(\'inf\'): min_cost[j] = min(min_cost[j], min_cost[i] + cost[i][j]) return min_cost[-1]"},{"question":"You are tasked with implementing the Merge Sort algorithm to sort an array of integers in ascending order. The implementation needs to be efficient both in terms of time and space complexity. # Expected Input and Output: * **Input**: A list `arr` of `n` integers where `1 <= n <= 10^5` and each integer is between `-10^6` and `10^6`. * **Output**: A new list sorted in ascending order. # Constraints: * The input list, `arr`, should not be modified by the sorting operation. * The implementation should be efficient in terms of both time and space with a time complexity of O(n log n) and space complexity of O(n). # Performance Requirements: * Ensure the algorithm handles large lists up to 100,000 elements efficiently. * The function should be stable, maintaining the relative order of equal integers. # Function Signature: ```python def efficient_merge_sort(arr: List[int]) -> List[int]: pass ``` # Example: ```python # Example 1 input_arr = [38, 27, 43, 3, 9, 82, 10] output_arr = efficient_merge_sort(input_arr) print(output_arr) # Output: [3, 9, 10, 27, 38, 43, 82] # Example 2 input_arr = [1, 20, -4, 6, 0] output_arr = efficient_merge_sort(input_arr) print(output_arr) # Output: [-4, 0, 1, 6, 20] ```","solution":"from typing import List def efficient_merge_sort(arr: List[int]) -> List[int]: if len(arr) <= 1: return arr def merge_sort_helper(arr): if len(arr) <= 1: return arr mid = len(arr) // 2 left_half = merge_sort_helper(arr[:mid]) right_half = merge_sort_helper(arr[mid:]) return merge(left_half, right_half) def merge(left, right): sorted_array = [] i = j = 0 while i < len(left) and j < len(right): if left[i] <= right[j]: sorted_array.append(left[i]) i += 1 else: sorted_array.append(right[j]) j += 1 while i < len(left): sorted_array.append(left[i]) i += 1 while j < len(right): sorted_array.append(right[j]) j += 1 return sorted_array return merge_sort_helper(arr)"},{"question":"# Objective: You are provided with the implementation of an `UndirectedGraphNode` class and a graph cloning function using BFS, iterative DFS, and recursive DFS. Your task is to enhance the graph cloning function to handle a new requirement. # Problem Statement: You need to clone an undirected graph such that the node labels in the cloned graph are incremented by a given integer value `k`. # Function Signature: ```python def clone_graph_with_increment(node: UndirectedGraphNode, k: int) -> UndirectedGraphNode: pass ``` # Input: * `node`: An `UndirectedGraphNode` which points to the original graph\'s starting node. * `k`: An integer value by which to increment all node labels in the cloned graph. # Output: * Returns the starting node of the cloned graph with incremented labels. # Constraints: * The original graph may contain up to `10^4` nodes. * Node labels are unique and can range from `-10^4` to `10^4`. * The given graph may contain cycles and self-loops. # Example: ```python # Serialized graph: {0,1,2#1,2#2,2} # Visually: # 1 # / # / # 0 --- 2 # / # _/ graph_node = ... # Create the graph according to the provided structure k = 5 cloned_graph_node = clone_graph_with_increment(graph_node, k) # The expected cloned graph should have labels incremented by 5 # i.e., {5,6,7#6,7#7,7} # Visually: # 6 # / # / # 5 --- 7 # / # _/ ``` # Tips: * Ensure that the new graph maintains the same structure (neighbors) as the original graph. * Handle self-loops and cycles appropriately to prevent infinite loops. # Additional Note: Utilize one of the BFS, iterative DFS, or recursive DFS cloning techniques provided as a foundation for this task. Implement the label increment within the chosen method ensuring the correct graph structure is maintained post-cloning.","solution":"from collections import deque class UndirectedGraphNode: def __init__(self, x): self.label = x self.neighbors = [] def clone_graph_with_increment(node: UndirectedGraphNode, k: int) -> UndirectedGraphNode: if not node: return None # A dictionary to map original nodes to their clones cloned_nodes = {} # Use BFS for cloning the graph def bfs_clone(node): queue = deque([node]) # Create the clone for the starting node cloned_nodes[node] = UndirectedGraphNode(node.label + k) while queue: curr_node = queue.popleft() curr_clone = cloned_nodes[curr_node] for neighbor in curr_node.neighbors: if neighbor not in cloned_nodes: # Create and store the clone for this neighbor if it doesn\'t exist cloned_nodes[neighbor] = UndirectedGraphNode(neighbor.label + k) queue.append(neighbor) # Append the cloned neighbor to the current cloned node\'s neighbors curr_clone.neighbors.append(cloned_nodes[neighbor]) # Start BFS to clone the entire graph bfs_clone(node) # Return the clone of the starting node return cloned_nodes[node]"},{"question":"# Coding Task: Convert Integers to Bytes Representation with Endianness Scenario Your task is to implement more efficient functions to handle the conversion between integers and their byte representations respecting endianness. You are provided with basic implementations and analysis of their strengths and weaknesses. Now, optimize and correct them if necessary. Implement functions with specifications provided below: Functions Specifications 1. **Function Name**: `int_to_bytes(num: int, endianness: str) -> bytes` - **Inputs**: - `num` (int): A non-negative integer to be converted. - `endianness` (str): A string specifying the endianness, either \\"big\\" for big-endian or \\"little\\" for little-endian. - **Output**: A byte representation of the given integer in the specified endianness. - **Constraints**: 0 ≤ num ≤ 2^64 - 1. The endianness input is guaranteed to be either \\"big\\" or \\"little\\". 2. **Function Name**: `bytes_to_int(bytestr: bytes, endianness: str) -> int` - **Inputs**: - `bytestr`: A byte array representing the number. - `endianness`: A string specifying the endianness, either \\"big\\" or \\"little\\". - **Output**: The integer representation of the byte array in the specified endianness. - **Constraints**: bytestr is a valid byte array for the purposes of this function. The endianness input is guaranteed to be either \\"big\\" or \\"little\\". Performance Requirements - The solution should aim for O(n) time complexity for a number with n bits. - Try to create efficient solutions without using excessive memory.","solution":"def int_to_bytes(num: int, endianness: str) -> bytes: Converts a non-negative integer to its byte representation in the specified endianness. Args: num (int): A non-negative integer to be converted. endianness (str): A string specifying the endianness, either \\"big\\" or \\"little\\". Returns: bytes: The byte representation of the given integer in the specified endianness. if endianness not in [\'big\', \'little\']: raise ValueError(\\"Endianness must be either \'big\' or \'little\'\\") # Calculate the minimum number of bytes required to represent the integer num_bytes = (num.bit_length() + 7) // 8 # Equivalent to math.ceil(num.bit_length() / 8) # Special case for zero if num == 0: num_bytes = 1 return num.to_bytes(num_bytes, endianness) def bytes_to_int(bytestr: bytes, endianness: str) -> int: Converts a byte array to its integer representation in the specified endianness. Args: bytestr (bytes): A byte array representing the number. endianness (str): A string specifying the endianness, either \\"big\\" or \\"little\\". Returns: int: The integer representation of the byte array in the specified endianness. if endianness not in [\'big\', \'little\']: raise ValueError(\\"Endianness must be either \'big\' or \'little\'\\") return int.from_bytes(bytestr, endianness)"},{"question":"# Linked List Deduplication # Problem Statement: Given a singly linked list, write a function `remove_duplicates(head)` to remove duplicate values from the linked list. Implement both versions of the solution: 1. Using an auxiliary data structure to track existing values. 2. Without using any auxiliary data structure, ensuring the entire operation is performed in-place. # Input: * `head`: The head node of the singly linked list. * Class `Node` is predefined as: ```python class Node: def __init__(self, value=None): self.value = value self.next = None ``` # Output: * The function should return the head of the modified linked list. # Constraints: * The values in the linked list nodes are strings. * The linked list has at most `10^4` nodes. # Performance Requirements: 1. First solution should have O(N) time complexity. 2. Second solution should have O(N^2) time complexity but run with O(1) space complexity. # Example: Consider the linked list `A -> A -> B -> C -> D -> C -> F -> G`. * After deduplication using the first method (with auxiliary data structure): * `A -> B -> C -> D -> F -> G` * After deduplication using the second method (without auxiliary data structure): * `A -> B -> C -> D -> F -> G` # Function Signature: ```python def remove_duplicates(head: Node) -> Node: pass def remove_duplicates_without_extra_space(head: Node) -> Node: pass ```","solution":"class Node: def __init__(self, value=None): self.value = value self.next = None def remove_duplicates(head: Node) -> Node: Remove duplicates using auxiliary data structure if not head or not head.next: return head seen = set() current = head seen.add(current.value) while current.next: if current.next.value in seen: current.next = current.next.next else: seen.add(current.next.value) current = current.next return head def remove_duplicates_without_extra_space(head: Node) -> Node: Remove duplicates without using extra space if not head or not head.next: return head current = head while current: runner = current while runner.next: if runner.next.value == current.value: runner.next = runner.next.next else: runner = runner.next current = current.next return head"},{"question":"Job Requirements Implement a function `def intersection(h1: Node, h2: Node) -> Optional[Node]:` which takes two singly linked lists and returns the node where they intersect. If the two linked lists do not intersect, return `None`. To help you understand the problem, consider the example below: ```python class Node: def __init__(self, val: int): self.val = val self.next = None # Example: # List1: 1 -> 3 -> 5 -> 7 -> 9 -> 11 # ^ # / # List2: 2 -> 4 -> 6 --| # # Here, the intersection point is the node with the value 7. a1 = Node(1) b1 = Node(3) c1 = Node(5) d = Node(7) a2 = Node(2) b2 = Node(4) c2 = Node(6) e = Node(9) f = Node(11) a1.next = b1 b1.next = c1 c1.next = d a2.next = b2 b2.next = c2 c2.next = d d.next = e e.next = f print(intersection(a1, a2).val) # should return 7 ``` Constraints 1. The linked lists must be singly linked. 2. No cycles exist within the linked lists. 3. Node values may not uniquely identify nodes; the node object itself (reference) is the identifier. 4. The function should handle lists of arbitrary lengths, including edge cases like empty lists or lists with large length differences. Input/Output Formats - **Input**: Two linked list head nodes, `h1` and `h2`. - **Output**: The node where the intersection starts or `None` if there is no intersection. Performance Requirements - The solution should run in linear time, ( O(n + m) ). - The solution should utilize constant space, ( O(1) ). Implement your solution by strictly following the guidelines and the method signature provided. Don\'t use additional data structures like arrays or hash maps for marking nodes. Good luck!","solution":"class Node: def __init__(self, val: int): self.val = val self.next = None def get_length_and_tail(node: Node) -> tuple: length = 0 while node: length += 1 if not node.next: return length, node node = node.next return length, None def intersection(h1: Node, h2: Node) -> Node: if not h1 or not h2: return None len1, tail1 = get_length_and_tail(h1) len2, tail2 = get_length_and_tail(h2) if tail1 is not tail2: return None longer = h1 if len1 > len2 else h2 shorter = h2 if len1 > len2 else h1 for _ in range(abs(len1 - len2)): longer = longer.next while longer is not shorter: longer = longer.next shorter = shorter.next return longer"},{"question":"Problem: Flatten Nested Arrays # Context Imagine you are working on a data processing pipeline that reads hierarchical data structures (nested lists, arrays) and needs to process them in a simplified manner. To perform further operations efficiently, you want to flatten these nested arrays into a single-dimensional array. # Task Write a function that flattens a nested array into a single list containing all the elements of the original array in the same order. # Function Signature You need to implement the following function: ```python def flatten(input_arr): This function takes a multi-dimensional nested array as input and returns a single list with all the elements flattened. Args: input_arr (list): A list which can contain nested lists, integers, strings, or other data types. Returns: list: A single flattened list containing all the elements. pass ``` # Input - `input_arr`: A list which may contain nested lists with various data types. # Output - A single list containing all the elements from the nested structures, in the same order. # Constraints - The input list can be nested up to a reasonable depth (within typical system recursion limits). - Elements of the list can be of any data type but strings should not be treated as lists of characters. # Example ```python flatten([1, [2, 3, [4, 5]], [6, [7, 8]], 9]) # Expected output: [1, 2, 3, 4, 5, 6, 7, 8, 9] flatten([\'a\', [\'b\', \'c\', [\'d\']], \'e\']) # Expected output: [\'a\', \'b\', \'c\', \'d\', \'e\'] ``` # Performance - Ensure that the function has a time complexity of O(n), where n is the total number of elements. - Consider space complexity implications and make sure to handle deep nesting properly, keeping in mind Python\'s recursion limits.","solution":"def flatten(input_arr): This function takes a multi-dimensional nested array as input and returns a single list with all the elements flattened. Args: input_arr (list): A list which can contain nested lists, integers, strings, or other data types. Returns: list: A single flattened list containing all the elements. result = [] def _flatten(arr): for element in arr: if isinstance(element, list): _flatten(element) else: result.append(element) _flatten(input_arr) return result"},{"question":"# Problem: Anagram Verification for Mixed Cases Given two strings, determine if they are anagrams of each other. This time, consider the case insensitivity of the characters, including both lowercase and uppercase letters. # Function Signature: ```python def are_anagrams(str1: str, str2: str) -> bool: ``` # Input: * `str1` (string): The first input string of length `n` (0 <= n <= 10^5). * `str2` (string): The second input string of length `m` (0 <= m <= 10^5). # Output: * Returns `True` if str1 and str2 are anagrams of each other, `False` otherwise. # Examples: ```python are_anagrams(\\"Listen\\", \\"Silent\\") -> True are_anagrams(\\"Triangle\\", \\"Integral\\") -> True are_anagrams(\\"Apple\\", \\"Pleap\\") -> False are_anagrams(\\"Hello\\", \\"Olelh\\") -> True are_anagrams(\\"Hello\\", \\"heLLo\\") -> True are_anagrams(\\"Not\\", \\"Anagram\\") -> False ``` # Constraints: * This problem is case-insensitive. * The function should be optimized for performance to handle large inputs efficiently. # Requirements: * Your function must handle edge cases such as empty strings and mixed-case characters. * Aim for a time complexity of O(n) and space complexity of O(1), where n is the length of the strings. # Additional Notes: You may use additional helper functions if required, but the main implementation should maintain efficient complexity.","solution":"def are_anagrams(str1: str, str2: str) -> bool: Determine if two strings are anagrams of each other, case insensitive. Args: str1 (string): The first input string. str2 (string): The second input string. Returns: bool: True if the strings are anagrams, False otherwise. # Normalize the strings to lowercase str1 = str1.lower() str2 = str2.lower() # If lengths are different, they cannot be anagrams if len(str1) != len(str2): return False # Count characters in both strings and compare from collections import Counter return Counter(str1) == Counter(str2)"},{"question":"# Scenario In cryptography, robust encryption relies on various mathematical algorithms including Euler\'s Totient Function. As part of a security module, you need to verify the efficiency and correctness of your implementation for computing the Totient Function over a series of tests. # Task Implement the function `euler_totient_array(n)`, which returns a list of Euler\'s Totient values for all integers from 1 to ( n ). # Input - An integer ( n ) (1 ≤ ( n ) ≤ ( 10^6 )). # Output - A list of integers where the ( i )-th integer in the list represents ( ϕ(i+1) ) (i.e., Euler\'s Totient function value for ( i+1 )). # Constraints - The function should be efficient in terms of both time and space. - Ensure that your solution handles the maximum constraints gracefully. # Function Signature ```python def euler_totient_array(n: int) -> List[int]: pass ``` # Examples ```python assert euler_totient_array(1) == [1] # ϕ(1) = 1 assert euler_totient_array(5) == [1, 1, 2, 2, 4] # ϕ(1) -> 1, ϕ(2) -> 1, ϕ(3) -> 2, ϕ(4) -> 2, ϕ(5) -> 4. assert euler_totient_array(10) == [1, 1, 2, 2, 4, 2, 6, 4, 6, 4] ``` # Explanation Let\'s analyze example for ( n=5 ): - ϕ(1) = 1 - ϕ(2) = 1 - ϕ(3) = 2, because 1 and 2 are coprime with 3. - ϕ(4) = 2, because 1 and 3 are coprime with 4. - ϕ(5) = 4, all numbers 1, 2, 3, and 4 are coprime with 5. Your task is to write this function efficiently for all integers from 1 to ( n ).","solution":"def euler_totient_array(n: int) -> list: Computes the Euler\'s Totient function value for each integer from 1 to n. Args: n (int): The upper limit integer. Returns: list: A list of integers where the i-th integer is the value of ϕ(i+1). # Step 1: Initialize a list to hold the totient values phi = list(range(n + 1)) # Step 2: Use a modified Sieve of Eratosthenes to compute totient function values for i in range(2, n + 1): if phi[i] == i: # i is a prime for j in range(i, n + 1, i): phi[j] = phi[j] * (i - 1) // i return phi[1:] # Exclude the value for 0, as we want results from 1 to n"},{"question":"Implement a Modified Stooge Sort **Problem Statement**: You are required to implement a modified version of the Stooge Sort algorithm. Given an array of integers, your function should sort the array in non-decreasing order using the Stooge Sort technique. However, to improve performance slightly, you will include an additional optimization: only recurse on sub-arrays that have more than three elements, as smaller sub-arrays are sorted by direct comparison and swapping. **Function Signature**: ```python def modified_stoogesort(arr: List[int], l: int, h: int) -> None: pass ``` **Input**: - `arr`: A list of integers, where 1 <= len(arr) <= 10^3. - `l`: The starting index of the array (always 0 when initially called). - `h`: The ending index of the array (always len(arr)-1 when initially called). **Output**: - The function modifies the input list to be sorted in-place. **Constraints**: - The function must implement the Stooge Sort mechanism. - You are permitted to use additional comparisons to minimize unnecessary recursive calls. - You must not use Python\'s built-in sorting functions. **Performance Requirements**: - Given the sub-optimal nature of Stooge Sort, efficiency improvements are encouraged but ensure the core principles of the algorithm are preserved. **Example**: ```python arr = [3, 1, 4, 1, 5, 9, 2] modified_stoogesort(arr, 0, len(arr) - 1) print(arr) # Output should be: [1, 1, 2, 3, 4, 5, 9] ``` **Notes**: - Pay attention to edge cases such as empty arrays and arrays with one element. - Ensure that your sorting is implemented in a recursive manner as described.","solution":"def modified_stoogesort(arr, l, h): if l >= h: return # If the element at l is greater than the element at h, swap them. if arr[l] > arr[h]: arr[l], arr[h] = arr[h], arr[l] # If there are more than three elements in the array, continue to sort. if h - l + 1 > 2: third = (h - l + 1) // 3 # Recursively sort the first two-thirds modified_stoogesort(arr, l, h - third) # Recursively sort the last two-thirds modified_stoogesort(arr, l + third, h) # Recursively sort the first two-thirds again modified_stoogesort(arr, l, h - third)"},{"question":"# Scenario You are provided a collection of integers that might contain duplicates. You need to generate all possible subsets (the power set) of these integers such that the solution set does not contain duplicate subsets. Write a function `unique_subsets(nums: List[int]) -> List[List[int]]` that returns all possible unique subsets of a list of integers. # Input & Output * **Input Format**: A single argument `nums` which is a list of integers that might include duplicates. * **Output Format**: A list of lists, where each list is a unique subset of the input integers. # Constraints * Length of `nums`: 0 <= len(nums) <= 10 * Integers in `nums` can be negative, zero, or positive. # Performance Requirements Your implementation should aim to handle the edge cases and typical scenarios efficiently, aiming for the least time complexity possible given the constraints. # Example Example 1: * Input: `nums = [1, 2, 2]` * Output: ``` [ [], [1], [1, 2], [1, 2, 2], [2], [2, 2] ] ``` Example 2: * Input: `nums = [1, 2, 2, 3]` * Output: ``` [ [], [1], [1, 2], [1, 2, 2], [1, 2, 2, 3], [1, 2, 3], [1, 3], [2], [2, 2], [2, 2, 3], [2, 3], [3] ] ``` Implement the function `unique_subsets(nums: List[int]) -> List[List[int]]` to solve this problem.","solution":"from typing import List def unique_subsets(nums: List[int]) -> List[List[int]]: Returns all unique subsets of a given list of integers, including handling duplicates. nums.sort() # Sort the array to handle duplicates easily result = [] backtrack(nums, 0, [], result) return result def backtrack(nums, index, path, result): result.append(path) for i in range(index, len(nums)): if i > index and nums[i] == nums[i-1]: # Skip duplicates continue backtrack(nums, i + 1, path + [nums[i]], result)"},{"question":"Context You are developing a tool that processes and analyzes web traffic data. Part of this tool requires you to extract clean, easily comparable domain names from a variety of URLs. To achieve this, you need to write a function that parses out and returns just the domain name from a given URL string. Problem Statement Write a function `parse_domain_name(url: str) -> str` that extracts and returns the domain name from the URL, following these rules: 1. **Input**: A string `url` representing the full URL. 2. **Output**: A string representing the extracted domain name. 3. **Constraints**: - The URL string will always contain at least one period (\\".\\"). - The URL may or may not include \\"http://\\" or \\"https://\\" at the beginning. - The URL may or may not include \\"www.\\" at the beginning. - The domain name will always be alphanumeric (and hyphens for subdomains). Examples ```python parse_domain_name(\\"http://github.com/SaadBenn\\") == \\"github\\" parse_domain_name(\\"http://www.zombie-bites.com\\") == \\"zombie-bites\\" parse_domain_name(\\"https://www.cnet.com\\") == \\"cnet\\" parse_domain_name(\\"https://subdomain.example.co.uk/path?query=123\\") == \\"subdomain\\" ``` Requirements - Do not use any external libraries or built-in modules such as `re` or `urlparse`. You may only utilize Python\'s built-in string methods. - Ensure that the solution is efficient and handles the specifications correctly. Write your implementation below: ```python def parse_domain_name(url: str) -> str: # Your code here pass # You can include example test cases to verify your implementation assert parse_domain_name(\\"http://github.com/SaadBenn\\") == \\"github\\" assert parse_domain_name(\\"http://www.zombie-bites.com\\") == \\"zombie-bites\\" assert parse_domain_name(\\"https://www.cnet.com\\") == \\"cnet\\" assert parse_domain_name(\\"https://subdomain.example.co.uk/path?query=123\\") == \\"subdomain\\" ``` Include additional test cases to validate edge cases and different URL structures.","solution":"def parse_domain_name(url: str) -> str: Extracts the domain name from a given URL. # Remove the protocol part if it exists if \\"://\\" in url: url = url.split(\\"://\\")[1] # Remove the \'www.\' part if it exists if url.startswith(\\"www.\\"): url = url[4:] # Extract the main domain name domain = url.split(\'.\')[0] return domain"},{"question":"# Question You are given an array containing various elements including integers and boolean values. Your task is to write a function `move_zeros_inplace(array)` that rearranges the array such that all zeros are moved to the end while preserving the order of the other elements. Boolean `False` should not be treated as a zero and must retain its position. The operations must be done in-place with O(1) extra space. Input - An array `array` (0 <= len(array) <= 10^5) which can contain integers, booleans, strings, etc. Output - The rearranged array with all zeros moved to the end. Constraints - Do not create a copy of the array. - The non-zero elements must retain their original order. - Boolean `False` should not be considered as zero. Example ```python move_zeros_inplace([False, 1, 0, 1, 2, 0, 1, 3, \'a\']) # Expected Output: [False, 1, 1, 2, 1, 3, \'a\', 0, 0] move_zeros_inplace([0, 0, 0, 0]) # Expected Output: [0, 0, 0, 0] move_zeros_inplace([1, 2, 3, 4]) # Expected Output: [1, 2, 3, 4] ``` You should implement the function `move_zeros_inplace` below: ```python def move_zeros_inplace(array): # Your code here ```","solution":"def move_zeros_inplace(array): Rearranges the array in-place such that all zeros are moved to the end while preserving the order of the other elements. Boolean False is not treated as zero and retains its position. last_non_zero_index = 0 for i in range(len(array)): if array[i] != 0 or isinstance(array[i], bool): array[last_non_zero_index] = array[i] last_non_zero_index += 1 for i in range(last_non_zero_index, len(array)): array[i] = 0"},{"question":"# Question: Path Resolution Function Implementation **Context** You are building a file management application where users input file paths to specify locations for configuration files, logs, and output data. To ensure consistency and avoid errors due to relative paths, you need to implement a function that standardizes these paths by converting them to their absolute forms. **Task** Write a function that takes a file path as input and returns its absolute path after expanding any user directory symbols (`~`). **Function Signature** ```python def resolve_path(file: str) -> str: # Your implementation here ``` **Input** * A string `file` (1 ≤ len(file) ≤ 100): The file path which may be relative, include user directory symbols (`~`), or be an absolute path. **Output** * Returns a string representing the absolute path. **Constraints** * The input string `file` will only consist of printable ASCII characters. * Do not use any third-party libraries; rely on standard Python libraries. **Examples** 1. Input: `\\"~/Documents/file.txt\\"` Output: `\\"/home/user/Documents/file.txt\\"` (Assuming /home/user is the user\'s home directory) 2. Input: `\\"../relative/path/file.txt\\"` Output: `\\"/home/user/relative/path/file.txt\\"` (Assuming the current working directory is /home/user) **Performance Requirements** * The function should handle inputs efficiently within the given constraints.","solution":"import os def resolve_path(file: str) -> str: Resolves the given file path to its absolute path. return os.path.abspath(os.path.expanduser(file))"},{"question":"# Fibonacci Number Calculation Problem Statement Given an integer `n`, write a function `efficient_fib(n)` to compute the n-th Fibonacci number. The function should use an efficient approach that runs in O(n) time and O(1) space complexity to handle very large values of n. Function Signature ```python def efficient_fib(n: int) -> int: pass ``` Input * `n` (0 ≤ n ≤ 10^5): An integer representing the position in the Fibonacci sequence. Output * Returns an integer which is the n-th Fibonacci number. Constraints * Your implementation should have a time complexity of O(n) and space complexity of O(1). * Handle input validation by ensuring `n` is a non-negative integer. If `n` is invalid, raise a `ValueError`. Example ```python assert efficient_fib(0) == 0 assert efficient_fib(1) == 1 assert efficient_fib(10) == 55 assert efficient_fib(100) == 354224848179261915075 assert efficient_fib(100000) is not None # This should run efficiently without excessive time or memory usage. ``` Additional Notes * Provide appropriate documentation and comments in your code. * Optimize the function to handle large values of n efficiently.","solution":"def efficient_fib(n: int) -> int: Computes the n-th Fibonacci number using an efficient iterative approach with O(n) time complexity and O(1) space complexity. Parameters: n (int): The position in the Fibonacci sequence (0 ≤ n ≤ 10^5). Returns: int: The n-th Fibonacci number. Raises: ValueError: If n is not a non-negative integer. if not isinstance(n, int) or n < 0: raise ValueError(\\"Input must be a non-negative integer\\") if n == 0: return 0 elif n == 1: return 1 a, b = 0, 1 for _ in range(2, n + 1): a, b = b, a + b return b"},{"question":"Identifying Strongly Connected Components **Context**: You are tasked with analyzing a network of computers in an office where the network is represented as a directed graph. Each computer is represented as a node, and a directed edge from node A to node B means that computer A can send data to computer B. To understand the robustness of the network, you need to determine the strongly connected components (SCCs) within the network. A strongly connected component is a subset of computers where each computer is reachable from every other computer in the subset. **Task**: Using Kosaraju\'s algorithm, implement a function to determine the number of strongly connected components in the network. **Function Signature**: ```python def count_strongly_connected_components(V: int, edges: List[Tuple[int, int]]) -> int: pass ``` **Input**: - `V` (int): The number of vertices (computers) in the graph. - `edges` (List[Tuple[int, int]]): A list of tuples representing the directed edges between the vertices. **Output**: - (int): The number of strongly connected components in the graph. **Constraints**: - 1 <= V <= 10000 - 0 <= len(edges) <= 10000 - The graph may be disconnected. **Example**: Input: ```python V = 6 edges = [(0, 2), (1, 0), (2, 3), (3, 1), (3, 4), (4, 5), (5, 4)] ``` Output: ```python 2 ``` Explanation: There are two SCCs in the given graph: 1. `{0, 1, 2, 3}` 2. `{4, 5}` **Note**: - You are expected to handle large graphs efficiently within the given constraints. - Make sure to handle edge cases such as empty graphs, graphs with no edges, and graphs where all vertices form a single SCC. Provide your implementation below:","solution":"from typing import List, Tuple def count_strongly_connected_components(V: int, edges: List[Tuple[int, int]]) -> int: from collections import defaultdict, deque def dfs(v, visited, stack): visited[v] = True for next_v in graph[v]: if not visited[next_v]: dfs(next_v, visited, stack) stack.append(v) def reverse_dfs(v, visited): visited[v] = True for next_v in reverse_graph[v]: if not visited[next_v]: reverse_dfs(next_v, visited) # Create the graph and the reverse graph graph = defaultdict(list) reverse_graph = defaultdict(list) for u, v in edges: graph[u].append(v) reverse_graph[v].append(u) # Step 1: Order vertices by finish time in decreasing order visited = [False] * V stack = [] for i in range(V): if not visited[i]: dfs(i, visited, stack) # Step 2: Reverse the graph is already done via reverse_graph # Step 3: Process all vertices in order defined by the stack visited = [False] * V scc_count = 0 while stack: v = stack.pop() if not visited[v]: reverse_dfs(v, visited) scc_count += 1 return scc_count"},{"question":"Substring Search Optimization You are given two strings, `haystack` and `needle`. Your task is to find the index of the first occurrence of `needle` in `haystack` using an optimized string matching algorithm, such as the Knuth-Morris-Pratt (KMP) algorithm. If `needle` is not part of `haystack`, return -1. Input and Output Format: - **Input**: Two strings `haystack` and `needle`. - `haystack` (1 ≤ length ≤ 10^5): The main string where you need to search. - `needle` (0 ≤ length ≤ 10^4): The sub-string you need to find. - **Output**: An integer indicating the starting index of the first occurrence of `needle` in `haystack`, or -1 if `needle` is not part of `haystack`. Constraints: - Both `haystack` and `needle` consist only of printable ASCII characters. - Performance requirements necessitate the use of optimized string matching techniques with time complexity better than O(n * m). Scenario: Imagine you are implementing a search feature for a text editor. Users can enter a keyword (the `needle`) and should receive the index of the first occurrence of that keyword within the document (the `haystack`). Example 1: - **Input**: `haystack = \\"hello\\"`, `needle = \\"ll\\"` - **Output**: 2 Example 2: - **Input**: `haystack = \\"aaaaa\\"`, `needle = \\"bba\\"` - **Output**: -1 Example 3: - **Input**: `haystack = \\"\\"`, `needle = \\"\\"` - **Output**: 0 Example 4: - **Input**: `haystack = \\"abcdefg\\"`, `needle = \\"efg\\"` - **Output**: 4 Implementation Guidance: To solve this problem, implement the Knuth-Morris-Pratt (KMP) algorithm because of its efficiency in handling the worst-case scenario. The KMP algorithm constructs a partial match table (also called \\"lps\\" array) that allows the algorithm to skip unnecessary comparisons. This optimization reduces the algorithm\'s time complexity to O(n + m). Good luck!","solution":"def kmp_search(haystack, needle): if not needle: return 0 n = len(haystack) m = len(needle) # Create the partial match table (lps array) lps = [0] * m j = 0 # Index for needle # Preprocess the pattern to create the lps array def compute_lps(needle, m, lps): length = 0 # Length of the previous longest prefix suffix i = 1 while i < m: if needle[i] == needle[length]: length += 1 lps[i] = length i += 1 else: if length != 0: length = lps[length - 1] else: lps[i] = 0 i += 1 # Fill the lps array compute_lps(needle, m, lps) i = 0 # Index for haystack while i < n: if needle[j] == haystack[i]: i += 1 j += 1 if j == m: return i - j elif i < n and needle[j] != haystack[i]: if j != 0: j = lps[j - 1] else: i += 1 return -1"},{"question":"# Question You are working on a project that requires generating all unique permutations of a list of distinct integers. To test your understanding of recursion and iteration in algorithm design, you are tasked with implementing a function that achieves this goal. **Objective**: Implement the function `generate_permutations` which generates all possible permutations of a given list of distinct integers. Input: - A list of distinct integers. Output: - A list of lists, where each sublist is a unique permutation of the input list. Constraints: 1. The input list length will be `1 <= len(elements) <= 9`. Example: - `generate_permutations([1, 2, 3])` should return: ```python [ [1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1] ] ``` - `generate_permutations([1])` should return: ```python [ [1] ] ``` - `generate_permutations([])` should return: ```python [ [] ] ``` # Requirements: 1. Ensure an in-depth understanding of both recursive and iterative approaches for permutations. 2. Handle edge cases like empty lists appropriately. 3. Aim for an optimal combination of clarity and performance. You may use helper functions if needed, but the primary function signature should be: ```python def generate_permutations(elements: List[int]) -> List[List[int]]: pass ```","solution":"from typing import List def generate_permutations(elements: List[int]) -> List[List[int]]: Generate all unique permutations of a list of distinct integers. if len(elements) == 0: return [[]] result = [] def permute(arr, l, r): if l == r: result.append(arr[:]) # Add a copy of the current permutation to the result else: for i in range(l, r + 1): arr[l], arr[i] = arr[i], arr[l] # Swap permute(arr, l + 1, r) arr[l], arr[i] = arr[i], arr[l] # Backtrack permute(elements, 0, len(elements) - 1) return result"},{"question":"# Question: Given an array of integers `nums` and an integer `target`, write a function `two_sum` that returns a tuple of indices of the two numbers in the array such that they add up to the target. Assume that each input would have exactly one solution, and you may not use the same element twice. # Input: * An array of integers `nums` (1 <= len(nums) <= 10^4, -10^9 <= nums[i] <= 10^9) * An integer `target` (-10^9 <= target <= 10^9) # Output: * A tuple containing the indices of the two numbers such that they add up to the given target. If no such pair exists, return `None`. # Example: Input: ```python nums = [2, 7, 11, 15] target = 9 ``` Output: ```python (0, 1) ``` # Constraints: 1. * Each input would have exactly one solution. 2. * You may not use the same element twice. # Requirements: 1. Implement the function with a time complexity of O(n). 2. Do not mutate the array `nums`. # Function Signature: ```python def two_sum(nums, target) -> (int, int): pass ``` # Scenario: Consider you are given a list of daily transactions from which you need to identify a pair of transactions that sum to a particular expense threshold. Your task is to write the `two_sum` function to automate this search efficiently.","solution":"def two_sum(nums, target): Returns a tuple of indices of the two numbers in the array such that they add up to the target. :param nums: List[int] -- List of integers :param target: int -- Target sum :return: Tuple[int, int] -- Tuple of indices num_to_index = {} for i, num in enumerate(nums): complement = target - num if complement in num_to_index: return (num_to_index[complement], i) num_to_index[num] = i # Example usage: # nums = [2, 7, 11, 15] # target = 9 # print(two_sum(nums, target)) # Output: (0, 1)"},{"question":"**Scenario**: You are working with a social networking platform where users are represented as nodes and their follower-following relationships are directed edges in a graph. To help with the analysis of social clusters, you need to identify groups of users who follow each other back either directly or indirectly. **Task**: Write a function `find_strongly_connected_components` using Kosaraju\'s Algorithm to identify the number of strongly connected components in a directed graph. **Function Signature**: ```python def find_strongly_connected_components(V: int, edges: List[Tuple[int, int]]) -> int: pass ``` **Input**: - `V` (int): Number of vertices in the graph (numbered from 0 to V-1). - `edges` (List[Tuple[int, int]]): List of directed edges where each tuple (u, v) represents a directed edge from node `u` to node `v`. **Output**: - Returns the number of strongly connected components in the graph. **Constraints**: - 1 <= V <= 10^5 - 0 <= len(edges) <= min(10^5, V * (V - 1) // 2) **Example**: ```python V = 6 edges = [(0, 2), (1, 0), (2, 3), (3, 1), (3, 4), (4, 5), (5, 4)] # The graph has 2 strongly connected components: # {0, 1, 2, 3} and {4, 5} assert find_strongly_connected_components(V, edges) == 2 ``` **Notes**: - Ensure your solution handles the edge cases of isolated nodes and disconnected graphs correctly. - Avoid excessive memory usage and consider time complexity for large graphs.","solution":"from typing import List, Tuple def find_strongly_connected_components(V: int, edges: List[Tuple[int, int]]) -> int: def dfs(v: int, visited: set, stack: List[int], graph: List[List[int]]): visited.add(v) for neighbour in graph[v]: if neighbour not in visited: dfs(neighbour, visited, stack, graph) stack.append(v) def transpose_graph(V: int, edges: List[Tuple[int, int]]) -> List[List[int]]: transposed_graph = [[] for _ in range(V)] for u, v in edges: transposed_graph[v].append(u) return transposed_graph def fill_order(V: int, graph: List[List[int]], visited: set) -> List[int]: stack = [] for i in range(V): if i not in visited: dfs(i, visited, stack, graph) return stack def dfs_util(v: int, visited: set, transposed_graph: List[List[int]]): visited.add(v) for neighbour in transposed_graph[v]: if neighbour not in visited: dfs_util(neighbour, visited, transposed_graph) # Step 1: Create the graph graph = [[] for _ in range(V)] for u, v in edges: graph[u].append(v) # Step 2: Fill vertices in stack according to their finishing times visited = set() stack = fill_order(V, graph, visited) # Step 3: Create a reversed graph transposed_graph = transpose_graph(V, edges) # Step 4: Process all vertices in order defined by Stack visited.clear() strongly_connected_components_count = 0 while stack: node = stack.pop() if node not in visited: dfs_util(node, visited, transposed_graph) strongly_connected_components_count += 1 return strongly_connected_components_count"},{"question":"# File Path Normalizer # Objective Write a function that normalizes file paths by resolving the following two issues: user home directory symbols (`~`) into absolute paths, and converting relative paths to absolute paths. # Function Signature ```python def normalize_file_path(file: str) -> str: ``` # Input * **file**: A string representing a file path. This could be a relative path, an absolute path, or a path starting with a user\'s home directory symbol (`~`). # Output * **Return**: A string representing the normalized absolute path of the input file. # Constraints - The input string will always be a non-empty string that represents a valid file path format. - The function should handle paths starting with `~` for user home directory expansion. - Assume the current working directory is always available and valid. # Example ```python assert normalize_file_path(\\"~/documents/reports\\") == \\"/home/username/documents/reports\\" assert normalize_file_path(\\"./scripts/test.py\\") == \\"/home/username/projects/scripts/test.py\\" assert normalize_file_path(\\"/usr/local/bin\\") == \\"/usr/local/bin\\" ``` The expected output will depend on the system’s user configuration and current working directory, where `/home/username` is an example of a user\'s home directory. # Performance Requirements - Ensure that your implementation correctly handles the common cases of relative and home-directory prefixed paths. - The solution should be efficient such that it operates within O(N) time complexity, where N is the length of the input path string.","solution":"import os def normalize_file_path(file: str) -> str: This function takes a file path string as input and normalizes it by: - Expanding `~` to the user\'s home directory path. - Resolving any relative path to an absolute path. Args: file (str): A string representing a file path which can be relative, absolute, or with a user\'s home directory symbol `~`. Returns: str: The normalized absolute file path. return os.path.abspath(os.path.expanduser(file))"},{"question":"# Scenario: You are working on a software that manipulates graphical data structures, specifically binary trees. One feature you need to implement is a way to invert a given binary tree. # Problem: Write a function `invert_tree` that inverts a binary tree. # Expected Function Signature: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def invert_tree(root: TreeNode) -> TreeNode: pass ``` # Input: * `root` — A TreeNode representing the root of a binary tree. It may be `None` if the tree is empty. # Output: * The function should return the root of the inverted tree (with the left and right children swapped at all levels). # Constraints: * The number of nodes in the tree can be in the range `[0, 10^4]`. * The tree\'s node values are not necessarily unique. # Example: ```python # Example usage: # Original Tree # 4 # / # 2 7 # / / #1 3 6 9 # Tree after inversion # 4 # / # 7 2 # / / #9 6 3 1 root = TreeNode(4, TreeNode(2, TreeNode(1), TreeNode(3)), TreeNode(7, TreeNode(6), TreeNode(9))) new_root = invert_tree(root) # Now new_root represents the tree with inverted nodes ``` # Objective: Implement the `invert_tree` function to correctly invert the given binary tree.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def invert_tree(root: TreeNode) -> TreeNode: if root is None: return None # Swap the left and right subtree root.left, root.right = root.right, root.left # Recursively invert the subtrees invert_tree(root.left) invert_tree(root.right) return root"},{"question":"Problem Statement Write a function that takes a positive integer `n` and returns a list of numbers from 1 to `n`. However, for multiples of three, replace the number with \\"Fizz\\", for multiples of five replace it with \\"Buzz\\", and for multiples of both three and five replace it with \\"FizzBuzz\\". The function should handle the following: - If `n` is less than 1, raise a `ValueError` with a descriptive message. - If `n` is `None`, raise a `TypeError` with a descriptive message. Implement the following function: ```python def fizzbuzz(n): # your code here ``` Example ```python assert fizzbuzz(5) == [1, 2, \'Fizz\', 4, \'Buzz\'] assert fizzbuzz(15) == [1, 2, \'Fizz\', 4, \'Buzz\', \'Fizz\', 7, 8, \'Fizz\', \'Buzz\', 11, \'Fizz\', 13, 14, \'FizzBuzz\'] ``` Input * `n` (integer): The upper limit of the sequence where 1 <= `n`. Output * List of numbers and/or strings in the format specified above. Constraints * The function should be efficient and handle large values of `n`. * The input will always be a single integer. Performance Requirements * The implementation should have a time complexity of O(n) and a space complexity of O(n).","solution":"def fizzbuzz(n): Generate a list of numbers from 1 to n with FizzBuzz rules applied. Args: n (int): The upper limit of the sequence where 1 <= n. Returns: list: A list of numbers and/or strings (Fizz, Buzz, FizzBuzz) according to the problem statement. Raises: ValueError: If n is less than 1. TypeError: If n is not an integer. if n is None: raise TypeError(\\"Input cannot be None.\\") if not isinstance(n, int): raise TypeError(\\"Input must be an integer.\\") if n < 1: raise ValueError(\\"Input must be greater than or equal to 1.\\") result = [] for i in range(1, n + 1): if i % 3 == 0 and i % 5 == 0: result.append(\\"FizzBuzz\\") elif i % 3 == 0: result.append(\\"Fizz\\") elif i % 5 == 0: result.append(\\"Buzz\\") else: result.append(i) return result"},{"question":"Custom Binary Tree Serialization In this task, you are required to implement a custom binary tree serialization and deserialization method. This new method should serialize the binary tree in a way that only stores the necessary values and reduces the size of the resulting string. Serialization Modify the serialization to only use: - For each node, store its value. - Use \\"L\\" to indicate moving to a left child. - Use \\"R\\" to indicate moving to a right child. - Use \\"N\\" to indicate a null child. For example, the tree: ``` 1 / 2 3 / 4 5 ``` should serialize to: `\\"1 L 2 N R N R 3 L 4 N R N R 5 N N\\"` Deserialization Modify the deserialization function to read from the above format to reconstruct the tree. # Requirements * **Function to Implement**: ```python def custom_serialize(root): pass def custom_deserialize(data): pass ``` * **Input/Output**: - `custom_serialize` should take the root of the binary tree and return a string. - `custom_deserialize` should take a string and return the root of the binary tree. * **Constraints**: - Tree nodes contain only integer values. - Tree can have a large number of nodes (test up to 10^5 nodes). # Example ```python class TreeNode(object): def __init__(self, x): self.val = x self.left = None self.right = None # Usage: root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) root.right.left = TreeNode(4) root.right.right = TreeNode(5) serialized = custom_serialize(root) # \\"1 L 2 N R N R 3 L 4 N R N R 5 N N\\" reconstructed_root = custom_deserialize(serialized) # reconstructed_root should match `root` ``` # Edge Cases 1. An empty tree should serialize to an empty string. 2. A tree with a single node should serialize correctly. 3. Handle both left-heavy and right-heavy trees.","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def custom_serialize(root): def dfs(node): if not node: return \\"N\\" left_serialized = dfs(node.left) right_serialized = dfs(node.right) return f\\"{node.val} L {left_serialized} R {right_serialized}\\" return dfs(root) def custom_deserialize(data): def dfs(data_list): if not data_list: return None val = data_list.pop(0) if val == \\"N\\": return None node = TreeNode(int(val)) if data_list.pop(0) == \\"L\\": node.left = dfs(data_list) if data_list.pop(0) == \\"R\\": node.right = dfs(data_list) return node data_list = data.split() return dfs(data_list)"},{"question":"# Strobogrammatic Number Checker In certain applications like electronic displays, it\'s important to know if a number will look the same even when turned upside down. Such numbers are referred to as strobogrammatic numbers. In this problem, you are required to determine if a given number (represented as a string) is a strobogrammatic number. Function Signature ```python def is_strobogrammatic(num: str) -> bool: # your code here ``` Input * A single string `num` where: * `1 <= len(num) <= 10^4` * The string only contains numeric characters (0-9). Output * Return `True` if the number is strobogrammatic, `False` otherwise. Constraints * You should aim for a linear time complexity. * Avoid excessive space usage. Examples ```python print(is_strobogrammatic(\\"69\\")) # True print(is_strobogrammatic(\\"88\\")) # True print(is_strobogrammatic(\\"818\\")) # True print(is_strobogrammatic(\\"962\\")) # False print(is_strobogrammatic(\\"1\\")) # True print(is_strobogrammatic(\\"2\\")) # False ``` Additional Information * Ensure to handle all edge cases and constraints. * Thoroughly test your solution to verify correctness.","solution":"def is_strobogrammatic(num: str) -> bool: Determine if a given number is strobogrammatic. Args: num (str): the number represented as a string. Returns: bool: True if the number is strobogrammatic, False otherwise. # Mapping of strobogrammatic digits strobo_map = {\'0\': \'0\', \'1\': \'1\', \'6\': \'9\', \'8\': \'8\', \'9\': \'6\'} # Two pointers to compare from start and end moving towards center left, right = 0, len(num) - 1 while left <= right: if num[left] not in strobo_map or strobo_map[num[left]] != num[right]: return False left += 1 right -= 1 return True"},{"question":"# Radix Sort Implementation and Testing Given the radix sort algorithm provided, you are required to implement and test a modified version that can handle a list of non-negative integers. Your function should also handle cases where the list might be empty. Moreover, you need to develop a series of unit tests to ensure the robustness of your implementation. Function Signature ```python def radix_sort(arr: List[int]) -> List[int]: pass ``` Input - A list `arr` of non-negative integers (0 ≤ arr[i] ≤ 10^6) and length of the list (0 ≤ len(arr) ≤ 10^5). Output - A sorted list of integers in ascending order. Constraints 1. The algorithm must maintain a linearithmic time complexity. 2. The function must handle edge cases like an empty list. 3. The input list can contain repeated numbers. Examples ```python assert radix_sort([170, 45, 75, 90, 802, 24, 2, 66]) == [2, 24, 45, 66, 75, 90, 170, 802] assert radix_sort([]) == [] assert radix_sort([1]) == [1] assert radix_sort([5, 5, 5, 5]) == [5, 5, 5, 5] ``` Scenario You are assessing the performance of an e-commerce application that processes a large array of order IDs. These order IDs are non-negative integers of varying lengths, and you need to sort them efficiently to optimize data retrieval. Implement the `radix_sort` function and provide a suite of test cases to ensure correctness and robustness.","solution":"from typing import List def radix_sort(arr: List[int]) -> List[int]: if len(arr) == 0: return arr max_num = max(arr) exp = 1 while max_num // exp > 0: arr = counting_sort(arr, exp) exp *= 10 return arr def counting_sort(arr: List[int], exp: int) -> List[int]: n = len(arr) output = [0] * n count = [0] * 10 for i in range(n): index = arr[i] // exp count[index % 10] += 1 for i in range(1, 10): count[i] += count[i - 1] for i in range(n - 1, -1, -1): index = arr[i] // exp output[count[index % 10] - 1] = arr[i] count[index % 10] -= 1 for i in range(n): arr[i] = output[i] return arr"},{"question":"**Binary Search Tree: Height Calculation and Balance Check** **Problem Scenario**: You have been assigned to extend the functionality of a Binary Search Tree (BST) by adding methods to compute the height of the tree and to check if the tree is balanced. A balanced tree is defined here as a tree where the difference between the heights of the left and right subtrees of any node in the tree is no more than 1. **Task**: Implement the following methods in the pre-defined `BST` class: 1. `height`: This method should calculate and return the height of the BST. 2. `is_balanced`: This method should return True if the tree is balanced and False otherwise. **Definitions**: - The height of a tree is the length of the path from the root to the deepest node in the tree. - A tree with only one node has height 0. **Function Signatures**: ```python class BST: ... def height(self) -> int: ... def is_balanced(self) -> bool: ... ``` **Input/Output Formats**: - `height`: - Input: None (method operates on the BST instance). - Output: Integer representing the height of the tree. - `is_balanced`: - Input: None (method operates on the BST instance). - Output: Boolean value (True if the BST is balanced, False otherwise). **Constraints**: - Assume all insertions to the BST are done using the provided `insert` method. - The tree can contain up to 10^3 nodes. **Examples**: ```python tree = BST() tree.insert(10) tree.insert(15) tree.insert(6) tree.insert(4) tree.insert(9) print(tree.height()) # Output: 3 print(tree.is_balanced()) # Output: True tree.insert(20) tree.insert(25) print(tree.is_balanced()) # Output: False ``` **Guidelines**: - Use recursive functions to determine height and balance status. - Optimize the `is_balanced` function to avoid redundant height calculations. **Notes**: - Ensure your implementation handles edge cases such as empty trees or single-node trees. - Consider time complexity when determining the most efficient approach for the balance check.","solution":"class TreeNode: def __init__(self, key): self.left = None self.right = None self.val = key class BST: def __init__(self): self.root = None def insert(self, key): if self.root is None: self.root = TreeNode(key) else: self._insert(self.root, key) def _insert(self, root, key): if key < root.val: if root.left is None: root.left = TreeNode(key) else: self._insert(root.left, key) else: if root.right is None: root.right = TreeNode(key) else: self._insert(root.right, key) def height(self): return self._height(self.root) def _height(self, node): if node is None: return -1 left_height = self._height(node.left) right_height = self._height(node.right) return 1 + max(left_height, right_height) def is_balanced(self): return self._is_balanced(self.root) != -1 def _is_balanced(self, node): if node is None: return 0 left_height = self._is_balanced(node.left) right_height = self._is_balanced(node.right) if left_height == -1 or right_height == -1 or abs(left_height - right_height) > 1: return -1 return 1 + max(left_height, right_height)"},{"question":"You are given either two sides of a right-angled triangle with the third side represented as a `\\"?\\"`. Implement a function `pythagorean_solver(opposite, adjacent, hypotenuse)` that calculates and returns the length of the unknown side. Input: - **opposite (float or str)**: The length of the side opposite to the right angle, or `\\"?\\"` if unknown. - **adjacent (float or str)**: The length of the side adjacent to the right angle, or `\\"?\\"` if unknown. - **hypotenuse (float or str)**: The length of the hypotenuse, or `\\"?\\"` if unknown. Output: - Returns a string indicating the length of the unknown side, formatted as `\\"{Side} = {length}\\"`. Constraints: - Only one side will be represented as `\\"?\\"`. - The lengths provided will be positive numbers. - The inputs passed will form a valid right-angled triangle. Examples: 1. `pythagorean_solver(3, 4, \\"?\\")` should return `\\"Hypotenuse = 5.0\\"` 2. `pythagorean_solver(3, \\"?\\", 5)` should return `\\"Adjacent = 4.0\\"` 3. `pythagorean_solver(\\"?\\", 4, 5)` should return `\\"Opposite = 3.0\\"` 4. `pythagorean_solver(3, 4, 5)` should return `\\"You already know the answer!\\"` **Note:** Ensure to raise a `ValueError` with the message `\\"invalid argument(s) were given.\\"` if the inputs do not satisfy the conditions of a valid right-angled triangle or the `\\"?\\"` is incorrectly placed.","solution":"import math def pythagorean_solver(opposite, adjacent, hypotenuse): Solves for the unknown side of a right-angled triangle given two sides. At least two sides, opposite and adjacent, must be provided as numbers. The third side, indicated as \\"?\\", will be calculated using the Pythagorean Theorem. Parameters: opposite (float or str): The length of the side opposite to the right angle, or \\"?\\" if unknown. adjacent (float or str): The length of the side adjacent to the right angle, or \\"?\\" if unknown. hypotenuse (float or str): The length of the hypotenuse, or \\"?\\" if unknown. Returns: str: The length of the unknown side, formatted as \\"{Side} = {length}\\". if hypotenuse == \\"?\\" and isinstance(opposite, (int, float)) and isinstance(adjacent, (int, float)): result = math.sqrt(opposite**2 + adjacent**2) return f\\"Hypotenuse = {result}\\" elif opposite == \\"?\\" and isinstance(adjacent, (int, float)) and isinstance(hypotenuse, (int, float)): if hypotenuse <= adjacent: raise ValueError(\\"invalid argument(s) were given.\\") result = math.sqrt(hypotenuse**2 - adjacent**2) return f\\"Opposite = {result}\\" elif adjacent == \\"?\\" and isinstance(opposite, (int, float)) and isinstance(hypotenuse, (int, float)): if hypotenuse <= opposite: raise ValueError(\\"invalid argument(s) were given.\\") result = math.sqrt(hypotenuse**2 - opposite**2) return f\\"Adjacent = {result}\\" elif all(isinstance(x, (int, float)) for x in [opposite, adjacent, hypotenuse]): return \\"You already know the answer!\\" else: raise ValueError(\\"invalid argument(s) were given.\\")"},{"question":"Graph Traversal: Comprehensive Search In this task, you are required to implement a function that determines whether all nodes in a graph are reachable from a given start node, deploying both Depth-First Search (DFS) and Breadth-First Search (BFS) algorithms. # Problem Statement Given a graph represented as an adjacency list and a start node, write two functions `is_reachable_dfs(graph, start)` and `is_reachable_bfs(graph, start)` that return a boolean indicating whether all nodes in the graph are reachable from the start node using DFS and BFS traversals respectively. # Input - `graph`: A dictionary where keys are nodes and values are lists of neighboring nodes. - `start`: The start node from which reachability is checked. # Output - A boolean value indicating whether all nodes are reachable from the start node. Both functions should return True if all nodes are reachable, otherwise False. # Constraints - The graph is a simple, connected, undirected graph. - Nodes are represented by integers (0 to N-1 where N is the number of nodes). # Example ```python graph = { 0: [1, 2], 1: [0, 3], 2: [0, 3], 3: [1, 2, 4], 4: [3] } start = 0 # Expected outputs print(is_reachable_dfs(graph, start)) # True print(is_reachable_bfs(graph, start)) # True graph_disconnected = { 0: [1], 1: [0], 2: [3], 3: [2] } start_disconnected = 0 # Expected outputs print(is_reachable_dfs(graph_disconnected, start_disconnected)) # False print(is_reachable_bfs(graph_disconnected, start_disconnected)) # False ``` # Notes - Ensure the solution handles all edge cases, including disconnected graphs and graphs with cycles. - Consider performance and memory usage, ensuring the solution is efficient for large graphs.","solution":"def is_reachable_dfs(graph, start): def dfs(node, visited): visited.add(node) for neighbor in graph[node]: if neighbor not in visited: dfs(neighbor, visited) visited = set() dfs(start, visited) return len(visited) == len(graph) def is_reachable_bfs(graph, start): from collections import deque visited = set() queue = deque([start]) while queue: node = queue.popleft() if node not in visited: visited.add(node) for neighbor in graph[node]: if neighbor not in visited: queue.append(neighbor) return len(visited) == len(graph)"},{"question":"# Segment Tree Implementation and Extended Functionality Context: You have been provided with a `SegmentTree` class that supports range queries and updates efficiently using a binary tree structure. The class can work with any commutative function provided by the user. This data structure is particularly powerful for handling dynamic range queries and updates on arrays. Task: Your task is to enhance this segment tree implementation by adding the following functionalities: 1. **Range Update**: - Implement a method `range_update(l, r, v)` that updates all elements in the range [l, r] to `v`. 2. **Median Query**: - Implement a method `query_median(l, r)` that returns the median of elements in the range [l, r]. Assume the segment tree only stores integer values for this functionality. Input Format: 1. The constructor initializes the segment tree with an input array and a function. 2. The `range_update(l, r, v)` method takes two integers `l`, `r` (0-indexed, inclusive) and an integer `v`, updating all elements in that range to `v`. 3. The `query_median(l, r)` method takes two integers `l`, `r` (0-indexed, inclusive) and returns the median of elements in the range. Output Format: 1. The `range_update` method does not return any value. 2. The `query_median` method returns an integer value representing the median. Constraints: * 1 <= array length <= 10^5 * 0 <= array element, v <= 10^9 * 0 <= l <= r < array length Example Usage: ```python # Basic Usage mytree = SegmentTree([10, 20, 30, 40, 50], max) mytree.range_update(1, 3, 25) print(mytree.query_median(0, 4)) # Output: 25 mytree = SegmentTree([1, 2, 3, 4, 5, 6], lambda a, b: a + b) mytree.range_update(2, 4, 3) print(mytree.query_median(0, 5)) # Output: 3 ``` Implementation: Complete the implementation of the `SegmentTree` class by adding the required methods.","solution":"class SegmentTree: def __init__(self, array, func): self.func = func self.n = len(array) self.tree = [0] * (2 * self.n) # Build the segment tree self.build(array) def build(self, array): # Insert leaf nodes in tree for i in range(self.n): self.tree[self.n + i] = array[i] # Build the tree by calculating parents for i in range(self.n - 1, 0, -1): self.tree[i] = self.func(self.tree[i * 2], self.tree[i * 2 + 1]) def update(self, pos, value): pos += self.n self.tree[pos] = value while pos > 1: pos //= 2 self.tree[pos] = self.func(self.tree[2 * pos], self.tree[2 * pos + 1]) def range_update(self, l, r, v): for i in range(l, r + 1): self.update(i, v) def query(self, l, r): l += self.n r += self.n res = None while l <= r: if l % 2 == 1: if res is None: res = self.tree[l] else: res = self.func(res, self.tree[l]) l += 1 if r % 2 == 0: if res is None: res = self.tree[r] else: res = self.func(res, self.tree[r]) r -= 1 l //= 2 r //= 2 return res def query_median(self, l, r): elements = [] for i in range(l, r + 1): elements.append(self.query(i, i)) elements.sort() mid = len(elements) // 2 return elements[mid] if len(elements) % 2 == 1 else (elements[mid - 1] + elements[mid]) // 2"},{"question":"You are given an array of integers sorted in non-decreasing order, and a target integer. Your task is to implement a function `two_sum_optimized` that returns the 1-based indices of the two numbers that add up to the target. # Requirements: 1. Your solution should use the two-pointer technique for an optimized O(n) time complexity. 2. No element can be used twice. 3. You may assume that there is exactly one solution. 4. Only a simple linear pass is allowed; do not use additional data structures such as hash maps. # Function Signature: ```python def two_sum_optimized(numbers: List[int], target: int) -> List[int]: pass ``` # Input: * `numbers` (List[int]): A list of sorted integers. * `target` (int): The target sum. # Output: * (List[int]): A list containing the indices (1-based) of the two numbers whose sum equals the target. # Constraints: * `2 <= len(numbers) <= 104` * `-109 <= numbers[i] <= 109` * `-109 <= target <= 109` # Example: ```python numbers = [2, 7, 11, 15] target = 9 assert two_sum_optimized(numbers, target) == [1, 2] ``` # Notes: - Focus on a solution with two pointers. - Ensure to check for edge cases like the smallest arrays and negative numbers. - You must avoid using additional space for any data structures apart from constant space variables.","solution":"from typing import List def two_sum_optimized(numbers: List[int], target: int) -> List[int]: Given a sorted list of integers and a target sum, returns the 1-based indices of the two numbers that add up to the target. left, right = 0, len(numbers) - 1 while left < right: current_sum = numbers[left] + numbers[right] if current_sum == target: return [left + 1, right + 1] elif current_sum < target: left += 1 else: right -= 1 return [] # This return will never be reached due to the assumption that there is exactly one solution."},{"question":"# Question: Modular Tree Traversal and Custom Formatting You are given a nested dictionary that represents a tree-like structure where each node can have multiple sub-elements, which may include strings, integers, or other values. Write a function `custom_tree_print(tree)` that traverses the tree and prints its elements. The function should be able to handle the following requirements: 1. Each key should be printed followed by its sub-elements. 2. After a sub-element that is an integer, a newline followed by space for indentation must be inserted. 3. Outputs should be formatted as specified, ensuring readability. Function Signature ```python def custom_tree_print(tree: dict) -> None: pass ``` Input * A dictionary `tree` where: * `key` : string identifier for the node. * `value`: a list of sub-elements which can be strings, integers, or other values. Output * The function prints the tree formatted according to the specifications. Example ```python tree = { \'a\': [\'Adam\', \'Book\', 4], \'b\': [\'Bill\', \'Computer\', 5, \'TV\', 6], \'Jill\': [\'Sports\', 1], \'c\': [\'Bill\', \'Sports\', 3], \'d\': [\'Adam\',\'Computer\', 3, \'Quin\', \'Computer\', 3], \'e\': [\'Quin\', \'Book\', 5, \'TV\', 2], \'f\': [\'Adam\', \'Computer\', 7] } custom_tree_print(tree) ``` ``` Expected Output: a -> Adam -> Book -> 4 b -> Bill -> Computer -> 5 TV -> 6 Jill -> Sports -> 1 c -> Bill -> Sports -> 3 d -> Adam -> Computer -> 3 Quin -> Computer -> 3 e -> Quin -> Book -> 5 TV -> 2 f -> Adam -> Computer -> 7 ``` Constraints * You may assume that the keys and values in the tree only contain alphanumeric characters. * Ensure the function can handle cases where the tree might have mixed data types in the sub-element lists. * Prioritize readability and maintainability of the tree structure when printed.","solution":"def custom_tree_print(tree: dict) -> None: Prints the tree dict in a custom formatted manner for key, value in tree.items(): print(f\\"{key} -> \\", end=\\"\\") for idx, elem in enumerate(value): if isinstance(elem, int): print(f\\"{elem} \\", end=\\"\\") if idx + 1 < len(value): print(\\"n \\", end=\\"\\") else: print(f\\"{elem} -> \\", end=\\"\\") # Move to the next line after finishing a key print()"},{"question":"# Question: Binary Search Tree Implementation and Extension Given the Binary Search Tree (BST) implementation provided, extend its functionality by implementing the following additional methods: 1. **Delete(Node)**: This method should remove a given node from the BST while maintaining the BST properties. 2. **MinValue(Node)**: This method should return the node with the minimum value in the BST. 3. **IsBalanced(Node)**: This function determines if the BST is balanced. A binary tree is balanced if for any node in the tree, the height of the left and right subtrees differ by no more than 1. Your implementation should include these three new methods within the given `BST` class. Write unit tests to verify the correctness of your implementation. Function Signatures: ```python def delete(self, data: int) -> bool: # Your code to delete a node with \'data\' value def min_value(self, node: Node) -> Node: # Your code to find the node with the minimum value def is_balanced(self, node: Node) -> bool: # Your code to check if the subtree rooted at \'node\' is balanced ``` Constraints: - Assume there are no duplicate values in the BST. - Nodes will have integer values. Examples: ```python tree = BST() tree.insert(10) tree.insert(5) tree.insert(15) tree.insert(2) # After the above insertions, BST should look like: # 10 # / # 5 15 # / #2 tree.delete(5) # After deleting 5, BST should look like: # 10 # / # 2 15 min_node = tree.min_value(tree.get_root()) # Should return node with value 2 is_bal = tree.is_balanced(tree.get_root()) # Should return True or False depending if the tree is balanced or not ``` Unit Test Structure: Extend/test your implementation by adding relevant test cases, similar to those provided in the initial code (for insertion, search, and size methods). Ensure you cover edge cases as well.","solution":"class Node: def __init__(self, data): self.data = data self.left = None self.right = None class BST: def __init__(self): self.root = None def insert(self, data): if self.root is None: self.root = Node(data) else: self._insert(self.root, data) def _insert(self, node, data): if data < node.data: if node.left is None: node.left = Node(data) else: self._insert(node.left, data) else: if node.right is None: node.right = Node(data) else: self._insert(node.right, data) def get_root(self): return self.root def delete(self, data): self.root = self._delete(self.root, data) def _delete(self, node, data): if node is None: return node if data < node.data: node.left = self._delete(node.left, data) elif data > node.data: node.right = self._delete(node.right, data) else: if node.left is None: return node.right elif node.right is None: return node.left min_node = self.min_value(node.right) node.data = min_node.data node.right = self._delete(node.right, min_node.data) return node def min_value(self, node): current = node while current.left is not None: current = current.left return current def is_balanced(self, node): def check_balance(node): if node is None: return 0, True left_height, left_balanced = check_balance(node.left) right_height, right_balanced = check_balance(node.right) current_height = max(left_height, right_height) + 1 balanced = left_balanced and right_balanced and abs(left_height - right_height) <= 1 return current_height, balanced _, balance = check_balance(node) return balance"},{"question":"# RandomizedSet Implementation **Problem Statement**: Design and implement a data structure called `RandomizedSet` which supports the following operations in average O(1) time: 1. **insert(val)**: Inserts an item `val` to the set if not already present. 2. **remove(val)**: Removes an item `val` from the set if present. 3. **random_element()**: Returns a random element from the current set of elements. Each element must have the same probability of being returned. **Input/Output Format**: - `insert(val: int) -> bool`: * **Input**: A single integer `val` to be inserted into the set. * **Output**: Returns `True` if the element was successfully inserted, `False` if the element was already in the set. - `remove(val: int) -> bool`: * **Input**: A single integer `val` to be removed from the set. * **Output**: Returns `True` if the element was successfully removed, `False` if the element was not present in the set. - `random_element() -> int`: * **Output**: Returns a random element from the set. If the set is empty, an exception should be raised. **Constraints**: - All `insert` and `remove` operations will be valid within the context of the set. - This implementation should handle the cases where the set is empty (especially for the `random_element` method). **Scenario**: You are working on a game development project that requires efficient tracking and random selection of items. The `RandomizedSet` structure will serve as a core component to manage game objects, ensuring fast insertions, deletions, and random selections. **Example**: ```python # Example Usage random_set = RandomizedSet() # Insert elements assert random_set.insert(1) == True assert random_set.insert(2) == True assert random_set.insert(1) == False # Remove elements assert random_set.remove(1) == True assert random_set.remove(1) == False # Fetch random elements assert random_set.random_element() in [1, 2] # Edge case: Random element from empty set should raise an exception random_set.remove(2) try: random_set.random_element() except Exception as e: print(e) # Expected: \\"Cannot get a random element from an empty set\\" ``` **Implementation**: Write your implementation below: ```python import random class RandomizedSet: def __init__(self): self.elements = [] self.index_map = {} def insert(self, val: int) -> bool: if val in self.index_map: return False self.index_map[val] = len(self.elements) self.elements.append(val) return True def remove(self, val: int) -> bool: if val not in self.index_map: return False index = self.index_map[val] last_element = self.elements[-1] # Move the last element to the place of the element to remove self.elements[index] = last_element self.index_map[last_element] = index # Remove the last element self.elements.pop() del self.index_map[val] return True def random_element(self) -> int: if not self.elements: raise Exception(\\"Cannot get a random element from an empty set\\") return random.choice(self.elements) ``` Implement the above methods to achieve the desired functionality.","solution":"import random class RandomizedSet: def __init__(self): self.elements = [] self.index_map = {} def insert(self, val: int) -> bool: if val in self.index_map: return False self.index_map[val] = len(self.elements) self.elements.append(val) return True def remove(self, val: int) -> bool: if val not in self.index_map: return False index = self.index_map[val] last_element = self.elements[-1] # Move the last element to the place of the element to remove self.elements[index] = last_element self.index_map[last_element] = index # Remove the last element self.elements.pop() del self.index_map[val] return True def random_element(self) -> int: if not self.elements: raise Exception(\\"Cannot get a random element from an empty set\\") return random.choice(self.elements)"},{"question":"# Objective Given a node from an undirected graph, write a function to clone the entire graph. Your solution should use the iterative Breadth-First Search (BFS) algorithm, but you should demonstrate your understanding by implementing an efficient and error-free graph cloning process. # Function Signature ```python def clone_graph_bfs(node: \'UndirectedGraphNode\') -> \'UndirectedGraphNode\': ``` # Input * `node`: A node from the undirected graph. Each `UndirectedGraphNode` contains an `int` label and a list of its neighbors. # Output * Returns the cloned node from which the entire graph can be accessed. # Example Given the serialized graph `0,1,2#1,2#2,2`: ``` 1 / / 0 --- 2 / _/ ``` * The function should return the cloned graph preserving the same structure and connections. # Constraints 1. Node labels are unique. 2. The graph is undirected. 3. The input node is not `None`. # Notes * You can assume all node labels will be non-negative integers. * The BFS traversal method should be used primarily to clone the graph. # Implementation Requirements * Efficient handling of memory. * Proper linking of neighbors. * Avoid redundant computations. * **No use of in-built library functions for graph cloning**. # Example Code ```python class UndirectedGraphNode: def __init__(self, label: int): self.label = label self.neighbors = [] def clone_graph_bfs(node: \'UndirectedGraphNode\') -> \'UndirectedGraphNode\': # Cloning logic using BFS goes here ``` Implement the above function, ensuring it passes various test cases, including complex graphs with cycles and self-loops.","solution":"class UndirectedGraphNode: def __init__(self, label: int): self.label = label self.neighbors = [] from collections import deque def clone_graph_bfs(node: \'UndirectedGraphNode\') -> \'UndirectedGraphNode\': if not node: return None node_copy = UndirectedGraphNode(node.label) queue = deque([node]) copies = {node: node_copy} while queue: current = queue.popleft() for neighbor in current.neighbors: if neighbor not in copies: neighbor_copy = UndirectedGraphNode(neighbor.label) copies[neighbor] = neighbor_copy queue.append(neighbor) copies[current].neighbors.append(copies[neighbor]) return node_copy"},{"question":"# Question: Calculate the Height of a Binary Tree **Context**: You are a software developer tasked with analyzing binary trees for various operations. One operation frequently required is calculating the height of a binary tree. You need to write a function to compute the height of a binary tree, where height is defined as the number of levels in the tree. **Function Details**: *Function Signature*: `def height(root: Node) -> int` **Input**: - `root`: the root node of a binary tree. The node is an instance of the `Node` class which is defined as: ```python class Node: def __init__(self, key): self.left = None self.right = None self.val = key ``` **Output**: - The function returns an integer representing the height of the tree. **Constraints**: - The tree will not contain more than 10^4 nodes. - You must implement this using a depth-first search approach for tree traversal. **Example**: ```python # Define the Node class as given class Node: def __init__(self, key): self.left = None self.right = None self.val = key # Example Usage: # Constructing a binary tree: # 9 # / # 6 12 # / / # 3 8 10 15 # / # 7 18 root = Node(9) root.left = Node(6) root.right = Node(12) root.left.left = Node(3) root.left.right = Node(8) root.left.right.left = Node(7) root.right.left = Node(10) root.right.right = Node(15) root.right.right.right = Node(18) print(height(root)) # Output should be 4 ``` **Note**: - Make sure your function works for both balanced and unbalanced trees. - You are not required to implement the insertion logic for the tree. Focus solely on the height computation.","solution":"class Node: def __init__(self, key): self.left = None self.right = None self.val = key def height(root: Node) -> int: Returns the height of the binary tree rooted at `root`. The height is defined as the number of levels in the tree. if root is None: return 0 left_height = height(root.left) right_height = height(root.right) return max(left_height, right_height) + 1"},{"question":"Given a grid, each cell can be a gate (0), a wall (-1), or an empty room (INF, where INF = 2147483647). Your task is to write a function that updates all empty rooms with the distance to the nearest gate. # Input - A 2D grid of integers `rooms` where: - -1 represents a wall or obstacle. - 0 represents a gate. - 2147483647 (INF) represents an empty room. # Output - Update the input grid `rooms` in-place with the distance to the nearest gate. # Constraints - The number of rows and columns in the grid is at most 100. - The grid might contain multiple gates. # Requirements - **Time Complexity**: O(m * n) - **Space Complexity**: O(m * n) (due to the recursion stack) # Example Input ``` rooms = [ [2147483647, -1, 0, 2147483647], [2147483647, 2147483647, 2147483647, -1], [2147483647, -1, 2147483647, -1], [0, -1, 2147483647, 2147483647] ] ``` Output ``` rooms = [ [3, -1, 0, 1], [2, 2, 1, -1], [1, -1, 2, -1], [0, -1, 3, 4] ] ``` # Further Guidance Your task is to implement the function: ```python def walls_and_gates(rooms): # Your code here ``` Make sure to handle edge cases where the grid might contain no gates, consists entirely of walls, or contains a mix of different cells appropriately.","solution":"from collections import deque INF = 2147483647 def walls_and_gates(rooms): if not rooms: return rows, cols = len(rooms), len(rooms[0]) queue = deque() # Initialize the queue with all gates\' positions for r in range(rows): for c in range(cols): if rooms[r][c] == 0: queue.append((r, c, 0)) # (row, col, distance) directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] # BFS from each gate while queue: r, c, d = queue.popleft() for dr, dc in directions: rr, cc = r + dr, c + dc if 0 <= rr < rows and 0 <= cc < cols and rooms[rr][cc] == INF: rooms[rr][cc] = d + 1 queue.append((rr, cc, d + 1))"},{"question":"Scenario You have been assigned to write a utility function for a database indexing system, where fast searches on large, sorted arrays are crucial. The database mostly contains uniformly distributed numerical data, and it\'s essential to quickly locate specific values given a unique identifier. Task Implement a function that uses interpolation search to find the index of a given search key in a sorted array. Your function should be efficient in terms of both time and space complexity. Function Signature ```python def interpolation_search(array: List[int], search_key: int) -> int: :param array: A sorted list of integers in ascending order. :param search_key: An integer to search for in the array. :returns: The index of the search key if found, otherwise -1. ``` Input - `array`: A list of integers, sorted in ascending order. (0 <= len(array) <= 10^6) - `search_key`: An integer to be searched within the array. (-10^6 <= search_key <= 10^6) Output - Returns the index of the search key if found, otherwise -1. Constraints - The array must be sorted in ascending order. - The search key must be within a reasonable range of -10^6 to 10^6. Performance Requirements - The function should have an average-case time complexity of (O(log log n)) and handle up to 10^6 elements efficiently. Example ```python assert interpolation_search([10, 20, 30, 40, 50], 30) == 2 assert interpolation_search([10, 20, 30, 40, 50], 35) == -1 assert interpolation_search([], 10) == -1 assert interpolation_search([5, 10, 12, 14, 17, 20, 21], 21) == 6 ``` Edge Cases - An empty array should return -1. - A search key outside the range of the array values should return -1. - Handling arrays with duplicate values correctly (although the function should conventionally return the first occurrence of the search key if it appears multiple times). Write and test your function implementation.","solution":"def interpolation_search(array, search_key): Interpolation search for finding the index of a given search key in a sorted array. :param array: A sorted list of integers in ascending order. :param search_key: An integer to search for in the array. :returns: The index of the search key if found, otherwise -1. low = 0 high = len(array) - 1 while low <= high and search_key >= array[low] and search_key <= array[high]: if low == high: if array[low] == search_key: return low return -1 pos = low + ((high - low) // (array[high] - array[low]) * (search_key - array[low])) if array[pos] == search_key: return pos if array[pos] < search_key: low = pos + 1 else: high = pos - 1 return -1"},{"question":"# Scenario You are building a data aggregation system that processes log files from various servers. Each server generates log entries in ascending timestamp order, and you receive these entries as linked lists. Your task is to merge these several sorted lists of log entries into one single sorted linked list to facilitate efficient log processing and analysis. # Task Implement a function `merge_k_sorted_lists` that receives a list of linked lists, where each linked list is sorted in ascending order, and returns a single merged linked list containing all elements from the input lists in ascending order. # Requirements * Define the ListNode class if not already provided. * Use a priority queue to achieve an optimal time complexity of O(n log k). * Ensure the function handles edge cases, such as empty lists. # Function Signature ```python def merge_k_sorted_lists(lists: List[Optional[ListNode]]) -> Optional[ListNode]: pass ``` # Constraints 1. The number of linked lists, `k`, is specified such that `1 <= k <= 10^4`. 2. The total number of nodes across all linked lists is specified such that `0 <= n <= 10^5`. 3. The node values are integers, with `-10^4 <= Node.val <= 10^4`. # Example Input: ```python lists = [ ListNode(1, ListNode(4, ListNode(5))), ListNode(1, ListNode(3, ListNode(4))), ListNode(2, ListNode(6)) ] result = merge_k_sorted_lists(lists) ``` Output: ``` 1 -> 1 -> 2 -> 3 -> 4 -> 4 -> 5 -> 6 ``` # Explanation: You are given three sorted linked lists: - 1 -> 4 -> 5 - 1 -> 3 -> 4 - 2 -> 6 The merged linked list in ascending order is: 1 -> 1 -> 2 -> 3 -> 4 -> 4 -> 5 -> 6","solution":"from typing import List, Optional import heapq class ListNode: def __init__(self, val: int = 0, next: Optional[\'ListNode\'] = None): self.val = val self.next = next def merge_k_sorted_lists(lists: List[Optional[ListNode]]) -> Optional[ListNode]: if not lists: return None min_heap = [] for idx, lst in enumerate(lists): if lst: heapq.heappush(min_heap, (lst.val, idx, lst)) dummy = ListNode() current = dummy while min_heap: val, idx, node = heapq.heappop(min_heap) current.next = node current = node if node.next: heapq.heappush(min_heap, (node.next.val, idx, node.next)) return dummy.next"},{"question":"You are given two arrays of integers, `main_array` and `queries_array`. Your task is to write a function `find_all_occurrences(main_array, queries_array)` that returns a dictionary. The dictionary\'s keys should be the elements from `queries_array`, and the values should be lists containing all indices of the occurrences of each query element in `main_array`. # Function Definition ```python def find_all_occurrences(main_array, queries_array): # Your code here ``` # Input * `main_array` (List[int]): A list of integers where you need to search for query elements. * `queries_array` (List[int]): A list of integers which you want to find in `main_array`. # Output * `Dict[int, List[int]]`: A dictionary where keys are elements from `queries_array` and the values are lists of indices in `main_array` where the query elements are found. # Constraints * Length of `main_array` (n): 1 ≤ n ≤ 10^5 * Length of `queries_array` (m): 1 ≤ m ≤ 10^4 * Elements of `main_array` and `queries_array` are all integers between -10^6 and 10^6. # Example ```python main_array = [1, 2, 3, 2, 4, 2, 5] queries_array = [2, 4] Output: { 2: [1, 3, 5], 4: [4] } ``` # Additional Notes * If a query element is not found in `main_array`, it should still be added to the dictionary but with an empty list as its value. * You are required to optimize your solution to efficiently handle the given constraints. # Explanation For `queries_array = [2, 4]`, the number 2 appears at indices [1, 3, 5] and the number 4 at index [4] in `main_array`.","solution":"def find_all_occurrences(main_array, queries_array): result = {} for query in queries_array: result[query] = [index for index, value in enumerate(main_array) if value == query] return result"},{"question":"# Question: Balanced Binary Tree Checker Scenario You are working on a software project where one of the tasks involves verifying the structural integrity of binary trees. Specifically, you need to implement a function that checks whether a given binary tree is balanced. A balanced binary tree is defined as a tree where the height of the two subtrees of any node differs by no more than one. Function Specification Implement the function `is_balanced` to determine if a binary tree is balanced. ```python class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def is_balanced(root: TreeNode) -> bool: pass ``` Input - `root`: The root node of the binary tree (TreeNode). Output - Return `True` if the tree is balanced, `False` otherwise. Constraints 1. The number of nodes in the tree is in the range [0, 10⁴]. 2. The value of each node is an integer. Example ```python # Example 1 root = TreeNode(1, TreeNode(2), TreeNode(3, TreeNode(4), TreeNode(5))) assert is_balanced(root) == True # Example 2 root = TreeNode(1, TreeNode(2, TreeNode(3, TreeNode(4), None), None), None) assert is_balanced(root) == False ``` Performance Requirements The solution should operate in O(N) time complexity where N is the number of nodes in the tree. Additional Notes Consider edge cases like an empty tree, single-node trees, and highly unbalanced trees (skewed left or right).","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def is_balanced(root: TreeNode) -> bool: def check_balance(node: TreeNode): if not node: return 0, True left_height, left_balanced = check_balance(node.left) right_height, right_balanced = check_balance(node.right) height = max(left_height, right_height) + 1 balanced = left_balanced and right_balanced and abs(left_height - right_height) <= 1 return height, balanced _, is_bal = check_balance(root) return is_bal"},{"question":"# Radix Sort Challenge Scenario You\'re part of a team working on optimizing the performance of the database of a retail application. Your task is to efficiently sort large sets of transaction IDs consisting of positive integers. The radix sort algorithm has been recommended for this task due to its efficient handling of integer sorting, but the current implementation will need to be enhanced to handle edge cases more robustly. Requirements Write a function in Python that: 1. Implements the radix sort algorithm. 2. Takes a list of non-negative integers as input. 3. Returns the sorted list as output. ```python def optimized_radix_sort(arr): Sorts a list of non-negative integers using an optimized radix sort algorithm. Parameters: arr (List[int]): A list of non-negative integers Returns: List[int]: A list of integers sorted in ascending order pass ``` Input * A list of non-negative integers, `arr` (0 ≤ len(arr) ≤ 10^6). * All integers in `arr` are within the range of 0 ≤ arr[i] < 10^9. Output * A new list of integers sorted in ascending order. Constraints * The provided list can be empty, thus handle this edge case. * Ensure the solution is memory-efficient and performs within reasonable time limits. Example ```python assert optimized_radix_sort([170, 45, 75, 90, 802, 24, 2, 66]) == [2, 24, 45, 66, 75, 90, 170, 802] assert optimized_radix_sort([]) == [] assert optimized_radix_sort([5]) == [5] assert optimized_radix_sort([5, 1]) == [1, 5] ``` **Note**: In addition to correctness, aim for optimal performance given the input size constraints.","solution":"def optimized_radix_sort(arr): Sorts a list of non-negative integers using an optimized radix sort algorithm. Parameters: arr (List[int]): A list of non-negative integers Returns: List[int]: A list of integers sorted in ascending order if len(arr) == 0: return [] # Find the maximum number to determine the number of digits max_num = max(arr) # Initialize the base (radix) exp = 1 base = 10 # Perform count sort for every digit from LSD to MSD while max_num // exp > 0: arr = counting_sort_by_digit(arr, exp, base) exp *= base return arr def counting_sort_by_digit(arr, exp, base): A helper function to perform counting sort based on the digit represented by exp. Parameters: arr (List[int]): A list of non-negative integers exp (int): The exponent corresponding to the current digit place base (int): The base, typically 10 Returns: List[int]: A list sorted by the current digit n = len(arr) output = [0] * n count = [0] * base # Store count of occurrences in count[] for i in range(n): index = (arr[i] // exp) % base count[index] += 1 # Change count[i] so that it contains the actual position # of this digit in output[] for i in range(1, base): count[i] += count[i - 1] # Build the output array for i in range(n - 1, -1, -1): index = (arr[i] // exp) % base output[count[index] - 1] = arr[i] count[index] -= 1 return output"},{"question":"# Programming Question **Context**: You are working on a software that processes transaction logs stored in a linked list. Each node in your linked list represents a transaction, and you need to implement a function that can remove a specified range of transactions. **Problem Statement**: Your goal is to implement a function called `remove_range` that takes a linked list `head` and two integers `start` and `end`, and removes the nodes from `start` to `end` indices (inclusive). ```python class ListNode: def __init__(self, value=0, next=None): self.value = value self.next = next def remove_range(head: ListNode, start: int, end: int) -> ListNode: # Your implementation here ``` **Function Specification**: - **Input**: - `head` (ListNode): a reference to the head of a singly linked list. - `start` (int): the starting index of the range to be removed (0-based). - `end` (int): the ending index of the range to be removed (0-based, inclusive). - **Output**: - Returns the head of the modified linked list after removing the specified range. **Constraints**: - Assume the linked list contains at least one node. - `0 <= start <= end < size of list`. **Example**: ```python # Helper function to convert list to Linked list for easy testing def list_to_linkedlist(arr): if not arr: return None head = ListNode(arr[0]) current = head for val in arr[1:]: current.next = ListNode(val) current = current.next return head # Helper function to convert Linked list to list for easy result comparison def linkedlist_to_list(head): result = [] current = head while current: result.append(current.value) current = current.next return result head = list_to_linkedlist([8, 13, 17, 4, 9, 12, 98, 41, 7, 23, 0, 92]) new_head = remove_range(head, 3, 8) print(linkedlist_to_list(new_head)) # Output: [8, 13, 17, 23, 0, 92] ``` **Additional Notes**: - Thoroughly test your implementation to ensure it works on edge cases, such as ranges affecting the head or the last few nodes of the list. - Avoid using additional data structures - rely on in-place modifications and pointer manipulations for optimized performance.","solution":"class ListNode: def __init__(self, value=0, next=None): self.value = value self.next = next def remove_range(head: ListNode, start: int, end: int) -> ListNode: if start == 0: # If the removal starts at the head for _ in range(end - start + 1): head = head.next return head current = head # Iterate to the node just before the start of the range to remove for _ in range(start - 1): current = current.next range_start_prev = current range_end = current.next # Iterate to the end of the range to be removed for _ in range(end - start + 1): range_end = range_end.next # Skip the nodes in the specified range range_start_prev.next = range_end return head"},{"question":"# Longest Palindromic Subsequence Challenge **Context**: You are developing a text analytics tool that requires identifying the longest palindromic subsequence in given strings. A palindrome is a sequence that reads the same forwards and backwards, and a subsequence is a sequence derived from another sequence by deleting some or no elements without changing the order of the remaining elements. **Task**: Write a function `longest_palindromic_subsequence` that takes a single string `s` as input and returns the length of the longest palindromic subsequence. Input Format: - A string `s` where `0 <= len(s) <= 1000` and `s` consists of only lowercase English letters. Output Format: - An integer representing the length of the longest palindromic subsequence in the input string. Constraints: - Your solution should handle edge cases where the string is empty, consists of all the same characters, or contains characters that do not form a palindrome. - Optimize for time and space complexity where possible while ensuring readability and maintainability of your code. Examples: 1. Input: `s = \\"bbbab\\"` Output: `4` Explanation: The longest palindromic subsequence is \\"bbbb\\". 2. Input: `s = \\"cbbd\\"` Output: `2` Explanation: The longest palindromic subsequence is \\"bb\\". Implementation Notes: - Consider using dynamic programming where necessary. - Aim for an O(n^2) time complexity solution, which is feasible for the input size constraints. - Ensure your function handles edge cases correctly. ```python def longest_palindromic_subsequence(s: str) -> int: # Implementation goes here pass ``` **Hints**: - Use a 2D table where `dp[i][j]` represents the length of the longest palindromic subsequence in `s[i:j+1]`. - The key transition is derived from comparing `s[i]` and `s[j]`.","solution":"def longest_palindromic_subsequence(s: str) -> int: n = len(s) if n == 0: return 0 # Create a 2D table to store lengths of longest palindromic subsequence dp = [[0] * n for _ in range(n)] # Every single character is a palindrome of length 1 for i in range(n): dp[i][i] = 1 # Build the table in bottom-up manner for cl in range(2, n + 1): for i in range(n - cl + 1): j = i + cl - 1 if s[i] == s[j]: if cl == 2: dp[i][j] = 2 else: dp[i][j] = dp[i + 1][j - 1] + 2 else: dp[i][j] = max(dp[i][j - 1], dp[i + 1][j]) return dp[0][n - 1]"},{"question":"# Regular Expression Matching Context You are building a pattern matching function for a text processing tool. The function\'s goal is to determine whether an entire input string matches a given pattern. The pattern includes wildcard characters `.` and `*`, where `.` matches any single character and `*` matches zero or more of the preceding character. Task Implement a function `is_match(s: str, p: str) -> bool` that checks if the input string `s` matches the pattern `p`. Input - `s` (string): The input string, containing only lowercase alphabetic letters (a-z). - `p` (string): The pattern string, which may contain lowercase alphabetic letters (a-z), `.` and `*`. Output - Return `True` if the entire input string `s` matches the pattern `p`, otherwise return `False`. Constraints - The lengths of `s` and `p` will be between 0 and 1000. - The pattern will be considered fully, meaning the check for matching spans the entire input string. Examples ```python assert is_match(\\"aa\\", \\"a\\") == False assert is_match(\\"aa\\", \\"aa\\") == True assert is_match(\\"aaa\\", \\"aa\\") == False assert is_match(\\"aa\\", \\"a*\\") == True assert is_match(\\"aa\\", \\".*\\") == True assert is_match(\\"ab\\", \\".*\\") == True assert is_match(\\"aab\\", \\"c*a*b\\") == True ``` Hints - Think about using a 2D table to store intermediate match results of substrings. - Consider edge cases such as empty strings and patterns consisting only of wildcards. - Pay special attention to how `*` operates in both matching zero characters and multiple characters.","solution":"def is_match(s: str, p: str) -> bool: Returns True if the string \'s\' matches the pattern \'p\', otherwise False. \'.\' matches any single character. \'*\' matches zero or more of the preceding element. # Create a DP table with default value False dp = [[False] * (len(p) + 1) for _ in range(len(s) + 1)] # Empty pattern matches empty string dp[0][0] = True # Deal with patterns like a*, a*b*, a*b*c* for j in range(2, len(p) + 1): if p[j - 1] == \'*\': dp[0][j] = dp[0][j - 2] # Iterate over each character in s and p to fill the table for i in range(1, len(s) + 1): for j in range(1, len(p) + 1): if p[j - 1] == \'.\' or p[j - 1] == s[i - 1]: dp[i][j] = dp[i - 1][j - 1] elif p[j - 1] == \'*\': dp[i][j] = dp[i][j - 2] or (dp[i - 1][j] if p[j - 2] == s[i - 1] or p[j - 2] == \'.\' else False) return dp[len(s)][len(p)]"},{"question":"# Problem Scenario You are developing a web application that dynamically constructs URLs for various APIs and resources. These URLs are built by joining a base URL with endpoint paths, query parameters, or resource identifiers. It’s crucial that each URL is correctly formatted to avoid any redundancy in slashes. # Task Write a function `join_paths(base, suffix)` that ensures the correct concatenation of a base URL/path with its suffix, with exactly one slash between them. # Function Signature ```python def join_paths(base: str, suffix: str) -> str: pass ``` # Input * `base` (str): The base path or URL. Assuming a non-null string. * `suffix` (str): The path or URL part to append. Assuming a non-null string. # Output * `str`: The concatenated and well-formed URL or path. # Examples ```python assert join_paths(\\"http://example.com\\", \\"user\\") == \\"http://example.com/user\\" assert join_paths(\\"http://example.com/\\", \\"/user\\") == \\"http://example.com/user\\" assert join_paths(\\"http://example.com//\\", \\"//user\\") == \\"http://example.com/user\\" assert join_paths(\\"path/to/dir\\", \\"file\\") == \\"path/to/dir/file\\" assert join_paths(\\"path/to/dir/\\", \\"file\\") == \\"path/to/dir/file\\" assert join_paths(\\"///\\", \\"/file\\") == \\"/file\\" assert join_paths(\\"\\", \\"file\\") == \\"/file\\" ``` # Constraints * Allow for multiple redundant slashes in input strings which should be normalized to a single slash. * Assume input strings are well-formed and contained valid path/URL characters. # Performance Requirements * Ensure the function efficiently handles inputs up to a length of 10,000 characters.","solution":"def join_paths(base: str, suffix: str) -> str: Joins a base URL/path with a suffix, ensuring exactly one slash between them. # Strip any leading and trailing slashes from both base and suffix base = base.rstrip(\'/\') suffix = suffix.lstrip(\'/\') # Join with a single slash if base: return f\\"{base}/{suffix}\\" else: return f\\"/{suffix}\\""},{"question":"# Bogo Sort Reimagined for Binary Strings As an exercise in understanding inefficient algorithms, we are going to use an impractical sorting method called Bogo Sort on a collection of binary strings. A binary string is a string consisting only of characters \'0\' and \'1\'. Your task is to write a function `bogo_sort_binary_strings(binary_strings: List[str], simulation: bool = False) -> List[str]` that applies the Bogo Sort algorithm to sort a list of binary strings in lexicographical order. # Function Signature ```python from typing import List def bogo_sort_binary_strings(binary_strings: List[str], simulation: bool = False) -> List[str]: pass ``` # Input * **binary_strings**: A list of binary strings with each string containing only \'0\'s and \'1\'s (1 ≤ len(binary_strings) ≤ 6 to keep the question feasible). * **simulation**: A boolean flag. If `True`, print the state of the list after each shuffle iteration. # Output * Returns the sorted list of binary strings in lexicographical order. # Constraints * The length of each binary string will be the same and within the range of 1 to 20. # Performance Requirements * Must handle the worst-case scenario gracefully, given the input size is small. # Example ```python assert bogo_sort_binary_strings([\\"110\\", \\"101\\", \\"111\\", \\"100\\"]) == [\\"100\\", \\"101\\", \\"110\\", \\"111\\"] ``` You are encouraged to think about the inefficiency boundary and understand why Bogo Sort is generally a bad choice for practical use but interesting to study in context.","solution":"import random from typing import List def is_sorted(binary_strings: List[str]) -> bool: for i in range(len(binary_strings) - 1): if binary_strings[i] > binary_strings[i + 1]: return False return True def bogo_sort_binary_strings(binary_strings: List[str], simulation: bool = False) -> List[str]: while not is_sorted(binary_strings): random.shuffle(binary_strings) if simulation: print(binary_strings) return binary_strings"},{"question":"# Binary Tree Inversion Function Given a binary tree, write a function `invert_binary_tree(root)` that inverts the binary tree using an iterative approach. The function should take the root of the binary tree as input and return the root of the inverted tree. The inversion should be done in-place. Function Signature ```python def invert_binary_tree(root: TreeNode) -> TreeNode: ``` Input - `root` (TreeNode): The root of the binary tree to be inverted. Each `TreeNode` has `val`, `left`, and `right` attributes. Output - The root of the inverted binary tree. Constraints - The tree can have a maximum of 10^4 nodes. - Each node\'s value is an integer and can be positive, negative, or zero. Performance Requirements - The function should run in (O(n)) time complexity. - The function should use (O(n)) additional space complexity for an explicit stack in the iterative implementation. Example Consider the following tree: ``` 1 / 2 3 / 4 5 ``` After inversion, the tree becomes: ``` 1 / 3 2 / 5 4 ``` Example Usage: ```python root = TreeNode(1, TreeNode(2, TreeNode(4), TreeNode(5)), TreeNode(3)) inverted_root = invert_binary_tree(root) # Inverted tree should have root with structure equivalent to: # TreeNode(1, TreeNode(3), TreeNode(2, TreeNode(5), TreeNode(4))) ``` Additional Notes - Assume the `TreeNode` class is already defined as follows: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` **Implement** the function `invert_binary_tree` using an iterative approach with an explicit stack to avoid deep recursion issues.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def invert_binary_tree(root: TreeNode) -> TreeNode: if not root: return None stack = [root] while stack: current = stack.pop() # Swap the children current.left, current.right = current.right, current.left # Push children to the stack if current.left: stack.append(current.left) if current.right: stack.append(current.right) return root"},{"question":"# Question: Manipulating Bits Efficiently You are working on a project that involves low-level hardware programming where you need to manipulate various flags represented as bits in an integer. Your task is to implement a set of utility functions to perform bitwise operations. These functions include checking, setting, clearing, and updating specific bits in a given integer. Function Signatures: ```python def get_bit(num: int, i: int) -> bool: pass def set_bit(num: int, i: int) -> int: pass def clear_bit(num: int, i: int) -> int: pass def update_bit(num: int, i: int, bit: int) -> int: pass ``` Requirements: 1. **get_bit(num, i)**: - **Input**: An integer `num` and a bit position `i` (0-indexed). - **Output**: Returns `True` if the bit at position `i` is 1, otherwise returns `False`. - **Constraints**: 0 <= `num` <= 10^9, 0 <= `i` <= 31 2. **set_bit(num, i)**: - **Input**: An integer `num` and a bit position `i` (0-indexed). - **Output**: Returns an integer with the bit at position `i` set to 1. - **Constraints**: 0 <= `num` <= 10^9, 0 <= `i` <= 31 3. **clear_bit(num, i)**: - **Input**: An integer `num` and a bit position `i` (0-indexed). - **Output**: Returns an integer with the bit at position `i` set to 0. - **Constraints**: 0 <= `num` <= 10^9, 0 <= `i` <= 31 4. **update_bit(num, i, bit)**: - **Input**: An integer `num`, a bit position `i` (0-indexed), and the bit value `bit` (`0` or `1`). - **Output**: Returns an integer with the bit at position `i` updated to `bit`. - **Constraints**: 0 <= `num` <= 10^9, 0 <= `i` <= 31, bit is either 0 or 1. In your implementations, pay attention to edge cases such as handling very large numbers and invalid bit positions. Ensure your code is efficient and correctly manipulates the bits.","solution":"def get_bit(num: int, i: int) -> bool: Returns True if the bit at position i is 1, otherwise returns False. return (num & (1 << i)) != 0 def set_bit(num: int, i: int) -> int: Returns an integer with the bit at position i set to 1. return num | (1 << i) def clear_bit(num: int, i: int) -> int: Returns an integer with the bit at position i cleared to 0. return num & ~(1 << i) def update_bit(num: int, i: int, bit: int) -> int: Returns an integer with the bit at position i updated to bit (0 or 1). mask = ~(1 << i) num_cleared = num & mask return num_cleared | (bit << i)"},{"question":"Scenario You are developing an application that involves validating user input based on specific numerical properties. One of the properties you need to verify is if a given number is a magic number. You need to implement a function following the rules provided. Task Write a function `is_magic_number(num)` that takes an integer `num` and returns `True` if the number is a magic number and `False` otherwise. Input and Output * **Input**: A single integer `num` where (0 leq num leq 10^9). * **Output**: A boolean value `True` if `num` is a magic number, `False` otherwise. Constraints * The function must handle all edge cases, including single-digit inputs and large numbers. * Aim for an efficient solution concerning both time and space complexity. Example ```python is_magic_number(50113) # Returns: True (5+0+1+1+3 = 10 -> 1+0 = 1) is_magic_number(1234) # Returns: True (1+2+3+4 = 10 -> 1+0 = 1) is_magic_number(199) # Returns: True (1+9+9 = 19 -> 1+9 = 10 -> 1+0 = 1) is_magic_number(111) # Returns: False (1+1+1 = 3) # Additional edge cases is_magic_number(1) # Returns: True (The single-digit 1 is a magic number) is_magic_number(0) # Returns: False (The single-digit 0 is not a magic number) ``` Write your function here: ```python def is_magic_number(num): total_sum = 0 while num > 0 or total_sum > 9: if num == 0: num = total_sum total_sum = 0 total_sum += num % 10 num //= 10 return total_sum == 1 ```","solution":"def is_magic_number(num): total_sum = 0 # Loop to calculate the sum of digits until it becomes a single digit while num > 0 or total_sum > 9: # If num is 0, we need to reset num to the current total_sum and reset total_sum if num == 0: num = total_sum total_sum = 0 # Adding the last digit to total_sum total_sum += num % 10 # Removing the last digit from num num //= 10 # Returning True if the final single digit is 1, else False return total_sum == 1"},{"question":"# Context and Task You have been provided with a Python class representing Monomials and Polynomials with an array of mathematical operations defined for them. Your task is to extend these capabilities to solve a more comprehensive problem. # Problem Statement Given a polynomial P(x), and a set of numerical substitutions for its variables: 1. Perform specific calculations involving addition, subtraction, and evaluation. 2. Produce a simplified or substituted polynomial when a new monomial involving a variable is introduced. # Requirements 1. Extend the Polynomial class to have a function that normalizes the polynomial into the simplest form after operations. 2. Implement functionality to differentiate the polynomial concerning a specific variable. 3. Perform substitution of variables and compute the value of the polynomial. # Function Definitions Normalize Polynomial Implement normalization to return a simplified form. ```python def normalize(self) -> Polynomial: Normalize the polynomial by combining like terms and return the simplest form. pass ``` Differentiate Polynomial Implement differentiation with respect to a specific variable. ```python def differentiate(self, var: int) -> Polynomial: Differentiate the polynomial concerning variable var. Parameters: var (int) : The variable concerning which differentiation is done. Returns: Polynomial: The resultant differentiated polynomial. pass ``` Substitute and Compute Implement a function to substitute variables and compute the resultant value. ```python def substitute_and_compute(self, substitutions: Dict[int, Union[int, float, Fraction]]) -> Union[int, float, Fraction]: Substitute the variables in the polynomial for values and compute the result. Parameters: substitutions (Dict[int, Union[int, float, Fraction]]): A dictionary specifying substitution for variables. Returns: Union[int, float, Fraction]: The computed result after substitution. pass ``` # Input and Output The function signature for the above methods is provided. You are to implement these methods inside the Polynomial class. # Example Usage Given a polynomial: [ P(x) = 2a_1^2 + 3a_1a_2 - a_3 + frac{7}{2} ] - **Normalization**: Ensure that any like terms are combined. - **Differentiation**: - Differentiating with respect to (a_1): [ frac{dP}{da_1} = 4a_1 + 3a_2 ] - Differentiating with respect to (a_2): [ frac{dP}{da_2} = 3a_1 ] - **Substitution**: - Given substitutions {1: 2, 2: 3, 3: 4}, compute the resulting value. # Evaluation Criteria 1. Correctness of implementation. 2. Handling of edge cases and invalid inputs. 3. Efficiency in terms of time and space complexity.","solution":"from fractions import Fraction from collections import defaultdict class Polynomial: def __init__(self, terms): Initialize a polynomial with terms given. terms is a list of tuples where: - each tuple represents a monomial - first element of tuple is coefficient - second element is a dictionary representing variable and its power Example: Polynomial([(2, {1:2}), (3, {1:1, 2:1}), (-1, {3:1}), (7/2, {})]) represents 2a_1^2 + 3a_1a_2 - a_3 + 7/2 self.terms = terms def normalize(self): Normalize polynomial by combining like terms and return simplest form. combined_terms = defaultdict(Fraction) for coeff, vars in self.terms: vars_tuple = tuple(sorted(vars.items())) combined_terms[vars_tuple] += Fraction(coeff) # Filter out zero coefficient terms and convert back to list format normalized_terms = [(float(coeff), dict(vars)) for vars, coeff in combined_terms.items() if coeff] return Polynomial(normalized_terms) def differentiate(self, var): Differentiate the polynomial with respect to variable var. Parameters: var (int) : The variable with respect to which differentiation is done. Returns: Polynomial: The resultant differentiated polynomial. differentiated_terms = [] for coeff, vars in self.terms: if var in vars: new_vars = vars.copy() power = new_vars[var] new_coeff = coeff * power if power == 1: del new_vars[var] else: new_vars[var] -= 1 differentiated_terms.append((new_coeff, new_vars)) return Polynomial(differentiated_terms).normalize() def substitute_and_compute(self, substitutions): Substitute the variables in the polynomial for given values and compute the result. Parameters: substitutions (Dict[int, Union[int, float, Fraction]]): A dictionary specifying substitution for variables. Returns: Union[int, float, Fraction]: The computed result after substitution. result = Fraction(0) for coeff, vars in self.terms: term_value = Fraction(coeff) for var, power in vars.items(): if var in substitutions: term_value *= substitutions[var] ** power else: raise ValueError(f\\"Missing substitution for variable {var}\\") result += term_value return float(result)"},{"question":"You are given a string `s` containing just the characters \'(\', \')\', \'{\', \'}\', \'[\' and \']\', where these characters represent different types of brackets. Your task is to write a function `is_valid(s: str) -> bool` that determines whether the input string has all brackets closed in the correct order. # Requirements 1. **Input Format**: A single string `s` containing up to 1000 characters, consisting solely of the characters \'(\', \')\', \'{\', \'}\', \'[\' and \']\'. 2. **Output Format**: A boolean value `True` if the string is valid, `False` otherwise. 3. **Constraints**: - An empty string is considered valid. - The function must have a time complexity of O(n) and a space complexity of O(n), where n is the length of the string. # Scenario Imagine you are developing a code editor that provides real-time feedback on code syntax. One feature needs to check if the brackets in the user\'s code are properly balanced and nested. Implement the `is_valid` function to enable this feature. # Example ```python print(is_valid(\\"()\\")) # Output: True print(is_valid(\\"()[]{}\\")) # Output: True print(is_valid(\\"(]\\")) # Output: False print(is_valid(\\"([)]\\")) # Output: False print(is_valid(\\"{[]}\\")) # Output: True ``` # Edge Cases 1. Input strings containing one specific type of bracket. 2. Completely balanced and unbalanced strings. 3. Partially correct but mismatched strings like \\"(]\\". Write the `is_valid` function to validate the bracket structure in the provided string.","solution":"def is_valid(s: str) -> bool: Determines if the input string has all brackets closed in the correct order. Parameters: - s: A string containing just the characters \'(\', \')\', \'{\', \'}\', \'[\' and \']\' Returns: - A boolean value: True if the string is valid, False otherwise. stack = [] mapping = {\')\': \'(\', \'}\': \'{\', \']\': \'[\'} for char in s: if char in mapping: top_element = stack.pop() if stack else \'#\' if mapping[char] != top_element: return False else: stack.append(char) return not stack"},{"question":"# Context You have been tasked with developing a new approach for calculating combinations in statistics. The factorial function, which is fundamental for combinations, is often computed multiple times with high values of `n`. To ensure reliability and performance, you\'ll enhance it with an additional feature to compute the result modulo a given number. # Problem Implement an efficient and reliable function `combination(n, k, mod=None)` that calculates the number of combinations, represented as `C(n, k)`, which is the number of ways to choose `k` elements from a set of `n` elements, optionally modulo a given number. Formula [ C(n, k) = frac{n!}{k! cdot (n-k)!} ] # Requirements 1. **Input**: * `n`: A non-negative integer representing the total number of elements. * `k`: A non-negative integer representing the number of elements to choose. * `mod` (optional): A positive integer for the modulo operation on the result of the combination. 2. **Output**: * The integer result of the combination calculation, optionally taken modulo `mod`. 3. **Constraints**: * `0 <= k <= n` * `mod` is `None` or a positive integer. 4. **Performance**: * Aim for a time complexity of O(n) due to factorial computations while achieving the task without excessive memory use. # Function Signature ```python def combination(n: int, k: int, mod: int = None) -> int: pass ``` # Example ```python print(combination(5, 2)) # Output: 10 print(combination(5, 2, 1000)) # Output: 10 print(combination(20, 10, 1000)) # Output: 184756 print(combination(50, 5, 100000)) # Output: 2118760 ``` # Notes * Use the provided factorial functions as needed. * Ensure to handle edge cases such as `k=0` and `n=k`. * Validate input types and ranges carefully. * Optimize your code to handle reasonably large `n` and `k`.","solution":"def factorial(n): result = 1 for i in range(2, n + 1): result *= i return result def combination(n, k, mod=None): if k < 0 or k > n: raise ValueError(\\"k must be between 0 and n.\\") if k == 0 or k == n: return 1 num = factorial(n) denom = factorial(k) * factorial(n - k) result = num // denom if mod: result = result % mod return result"},{"question":"# Matrix Multiplication Write a function `multiply_matrices(multiplicand, multiplier)` that multiplies two compatible two-dimensional matrices and returns the product. If the matrices are not compatible for multiplication (i.e., the number of columns in `multiplicand` does not equal the number of rows in `multiplier`), the function should raise an exception with an appropriate message. Input - **multiplicand**: A list of lists of integers, representing the first matrix. - **multiplier**: A list of lists of integers, representing the second matrix. Output - Returns a list of lists of integers, representing the product of the multiplication of the input matrices. Constraints - You can assume that the input matrices will always be valid matrices (i.e., all rows will have the same number of columns). - The elements of the matrices will be integers. - The matrices can be as large as 100x100. Performance Requirements - Your solution should efficiently handle the constraints provided, but you do not need to implement advanced optimization algorithms like Strassen\'s algorithm. Example ```python multiplicand = [ [1, 2], [3, 4], [5, 6] ] multiplier = [ [7, 8, 9], [10, 11, 12] ] result = multiply_matrices(multiplicand, multiplier) # Expected Output: # [ # [27, 30, 33], # [61, 68, 75], # [95, 106, 117] # ] ``` Function Signature ```python def multiply_matrices(multiplicand: list[list[int]], multiplier: list[list[int]]) -> list[list[int]]: # Your implementation here ``` Notes - Make sure to handle the edge case where the matrix dimensions are not compatible for multiplication by raising an `Exception` with the message \\"Multiplicand matrix not compatible with Multiplier matrix.\\" - You may assume that the input lists will always represent a valid matrix (i.e., a list of lists where each sublist is of the same length).","solution":"def multiply_matrices(multiplicand, multiplier): Multiplies two compatible two-dimensional matrices and returns the product. If the matrices are not compatible for multiplication, raises an exception. # Check if the number of columns in the multiplicand matrix equals the number of rows in the multiplier matrix if len(multiplicand[0]) != len(multiplier): raise Exception(\\"Multiplicand matrix not compatible with Multiplier matrix.\\") # Initialize the result matrix with zeros result = [[0 for _ in range(len(multiplier[0]))] for _ in range(len(multiplicand))] # Perform the matrix multiplication for i in range(len(multiplicand)): for j in range(len(multiplier[0])): for k in range(len(multiplier)): result[i][j] += multiplicand[i][k] * multiplier[k][j] return result"},{"question":"Implement a function `optimized_comb_sort(arr: List[int]) -> List[int]` that sorts an array of integers using an optimized version of the Comb Sort algorithm. Your implementation should incorporate an optimization where, after gap reduction, a different sorting method (e.g., Insertion Sort) is used for small gaps to improve performance. # Requirements - **Input**: A list of integers `arr` (0 <= len(arr) <= 10^6). - **Output**: A sorted list of integers in ascending order. # Constraints - Your solution must handle the entire range of input sizes efficiently, particularly focusing on handling the worst-case time complexity effectively. - You may not use Python\'s built-in sort or any sorting library. # Performance - The implementation should maintain a time complexity better than O(N^2) for average cases and be well-optimized for large datasets. - The space complexity should remain O(1), i.e., in-place sorting. # Example ```python assert optimized_comb_sort([64, 34, 25, 12, 22, 11, 90]) == [11, 12, 22, 25, 34, 64, 90] assert optimized_comb_sort([4, 3, 1, 2]) == [1, 2, 3, 4] assert optimized_comb_sort([]) == [] ``` # Explanation Your task is to optimize `comb_sort` by implementing a hybrid approach. You first perform comb sort steps with a shrinking gap until a certain threshold, then apply insertion sort to finalize sorting. This should combine the best attributes of both algorithms, improving performance on larger datasets.","solution":"from typing import List def optimized_comb_sort(arr: List[int]) -> List[int]: def insertion_sort(arr, start, gap): for i in range(start + gap, len(arr), gap): key = arr[i] j = i while j >= gap and arr[j - gap] > key: arr[j] = arr[j - gap] j -= gap arr[j] = key def comb_sort(arr): n = len(arr) gap = n shrink_factor = 1.3 sorted = False while not sorted: gap = int(gap // shrink_factor) if gap <= 1: gap = 1 sorted = True for i in range(n - gap): if arr[i] > arr[i + gap]: arr[i], arr[i + gap] = arr[i + gap], arr[i] sorted = False return arr n = len(arr) if n <= 1: return arr # Initial comb sort phase to reduce larger gaps comb_sort(arr) # Final pass with insertion sort for smaller gaps for start in range(1): insertion_sort(arr, start, 1) return arr"},{"question":"# Context You are developing a mini stack-based interpreter for a domain-specific language. To accommodate various stack usage scenarios, the interpreter must support both array-based and linked-list-based stack implementations. # Task Implement a function that uses stacks to reverse a string. The function should accept an instance of either `ArrayStack` or `LinkedListStack`. The function should perform the following steps: 1. Push all characters of the string onto the provided stack. 2. Pop all characters from the stack to form the reversed string. # Requirements - The function should handle strings with varying lengths, including an empty string. - You must raise an appropriate exception for any invalid input detected during implementation. # Function Signature ```python def reverse_string_using_stack(input_str: str, stack) -> str: # implement your function here pass ``` # Input/Output Examples ```python array_stack = ArrayStack() linked_list_stack = LinkedListStack() # Using ArrayStack assert reverse_string_using_stack(\\"hello\\", array_stack) == \\"olleh\\" assert reverse_string_using_stack(\\"\\", array_stack) == \\"\\" assert reverse_string_using_stack(\\"a\\", array_stack) == \\"a\\" # Using LinkedListStack assert reverse_string_using_stack(\\"hello\\", linked_list_stack) == \\"olleh\\" assert reverse_string_using_stack(\\"\\", linked_list_stack) == \\"\\" assert reverse_string_using_stack(\\"world\\", linked_list_stack) == \\"dlrow\\" ``` # Constraints - The input string length will not exceed 10,000 characters. - Do not use built-in string reverse functions.","solution":"class ArrayStack: def __init__(self): self.stack = [] def push(self, item): self.stack.append(item) def pop(self): if not self.stack: raise IndexError(\\"pop from empty stack\\") return self.stack.pop() def is_empty(self): return len(self.stack) == 0 class LinkedListStack: class Node: def __init__(self, item, next=None): self.item = item self.next = next def __init__(self): self.top = None def push(self, item): new_node = self.Node(item) new_node.next = self.top self.top = new_node def pop(self): if self.top is None: raise IndexError(\\"pop from empty stack\\") item = self.top.item self.top = self.top.next return item def is_empty(self): return self.top is None def reverse_string_using_stack(input_str: str, stack): # Push all characters onto the stack for char in input_str: stack.push(char) # Pop all characters to form the reversed string reversed_str = [] while not stack.is_empty(): reversed_str.append(stack.pop()) return \'\'.join(reversed_str)"},{"question":"# Increment Array Digits **Context:** You are given a number represented as an array of its digits stored in big-endian order (most significant digit first). Your task is to add one to this number and return the resulting array of digits. Ensure that proper handling is done for carry-overs when digits become 10. **Function Signature:** ```python def increment_digits(digits: List[int]) -> List[int]: :param digits: List[int] - a non-empty list of non-negative digits (0-9). :return: List[int] - the digits list representing the number after incrementing by one. ``` **Input Format:** - `digits`: A list of integers where each integer `digits[i]` (0 ≤ digits[i] ≤ 9) represents a single digit of a number. **Output Format:** - Return a list of integers representing the digits of the number after it has been incremented by one. **Examples:** ```python assert increment_digits([1,2,3]) == [1,2,4] assert increment_digits([9,9,9]) == [1,0,0,0] assert increment_digits([0]) == [1] assert increment_digits([9,5,9]) == [9,6,0] ``` **Constraints:** - The input list will contain at least one digit. - No non-numeric characters or negative digits will be present in the list. **Requirements:** - The solution must handle the increment and carry correctly. - Focus on optimizing space complexity if possible.","solution":"from typing import List def increment_digits(digits: List[int]) -> List[int]: # We start incrementing from the last digit n = len(digits) for i in range(n-1, -1, -1): if digits[i] < 9: digits[i] += 1 return digits digits[i] = 0 # If we reach here, it means all digits were 9 return [1] + [0] * n"},{"question":"# Rabin-Miller Primality Test Enhancement You are required to implement a modified version of the Rabin-Miller primality test with enhanced user interaction. In this enhanced version, the user should be able to specify the number of iterations ( k ) for the test. Furthermore, the program should validate if the user input for ( n ) (the number to be tested) and ( k ) (the number of iterations) are within valid ranges. Function Definition ```python def enhanced_is_prime(n: int, k: int) -> str: Determines if a given number n is prime using the Rabin-Miller primality test. The function should validate the input and return a string message indicating the result. Args: n (int): The number to be tested for primality. Must be greater than or equal to 5. k (int): The number of iterations for the test. Must be greater than 0. Returns: str: A message indicating whether `n` is prime or composite, based on the Rabin-Miller test. - \\"n is probably prime with a 4^-k chance of being wrong\\" if `n` passes the test. - \\"n is composite\\" if `n` fails the test. - \\"Invalid input\\" if the input args do not meet the constraints. pass ``` Input and Output Expectations: * **Input**: An integer ( n ) (>= 5) and an integer ( k ) (> 0). * **Output**: A string message indicating whether ( n ) is probably prime or composite, with specified error probability. Constraints: * ( n ) must be greater than or equal to 5. * ( k ) must be a positive integer greater than 0. Performance Requirements: The implementation should handle up to at least ( n = 10^{18} ) efficiently within a reasonable time frame. Example: ```python print(enhanced_is_prime(17, 5)) # Output: \'17 is probably prime with a 4^-5 chance of being wrong\' print(enhanced_is_prime(18, 3)) # Output: \'18 is composite\' print(enhanced_is_prime(4, 2)) # Output: \'Invalid input\' ``` Additional Notes: Ensure proper handling of edge cases, such as non-integer or negative values for ( n ) or ( k ). If the input values are not valid, the function should return the message \\"Invalid input\\".","solution":"import random def enhanced_is_prime(n: int, k: int) -> str: Determines if a given number n is prime using the Rabin-Miller primality test. The function should validate the input and return a string message indicating the result. Args: n (int): The number to be tested for primality. Must be greater than or equal to 5. k (int): The number of iterations for the test. Must be greater than 0. Returns: str: A message indicating whether `n` is prime or composite, based on the Rabin-Miller test. - \\"n is probably prime with a 4^-k chance of being wrong\\" if `n` passes the test. - \\"n is composite\\" if `n` fails the test. - \\"Invalid input\\" if the input args do not meet the constraints. if not isinstance(n, int) or not isinstance(k, int) or n < 5 or k <= 0: return \\"Invalid input\\" # Helper function for modular exponentiation def modular_pow(base, exponent, modulus): result = 1 base = base % modulus while exponent > 0: if (exponent % 2) == 1: result = (result * base) % modulus exponent = exponent >> 1 base = (base * base) % modulus return result # Helper function to check primality def miller_rabin_test(d, n): a = 2 + random.randint(1, n-4) x = modular_pow(a, d, n) if x == 1 or x == n - 1: return True while d != n - 1: x = (x * x) % n d *= 2 if x == 1: return False if x == n - 1: return True return False # Edge case for small primes if n in (5, 7, 11): return f\\"{n} is probably prime with a 4^-0 chance of being wrong\\" # Find d such that n-1 = d * 2^r d = n - 1 while d % 2 == 0: d //= 2 # Perform k iteration of Miller-Rabin test for _ in range(k): if not miller_rabin_test(d, n): return f\\"{n} is composite\\" return f\\"{n} is probably prime with a 4^-{k} chance of being wrong\\""},{"question":"The 0/1 Knapsack problem is a classic optimization problem where you need to determine the most valuable subset of items to include in a knapsack of fixed capacity. Each item can either be included or excluded, and you aim to maximize the total value without exceeding the knapsack\'s capacity. You are given a set of items, each with a value and a weight, and a knapsack with a capacity. Write a function `max_knapsack_value` that returns the maximum value that fits into the knapsack. **Function Signature**: ```python def max_knapsack_value(items: List[Tuple[int, int]], capacity: int) -> int: pass ``` # Input - `items`: A list of `n` tuples where each tuple `(value, weight)` represents the value and weight of an item. (1 <= n <= 1000) - `capacity`: An integer representing the maximum capacity of the knapsack. (0 <= capacity <= 1000) # Output - Returns an integer representing the maximum value of the items that can be included in the knapsack without exceeding the knapsack\'s capacity. # Constraints - All values and weights are non-negative integers. - The items\' weights and the knapsack\'s capacity are positive integers within the specified range. # Examples ```python items = [(60, 5), (50, 3), (70, 4), (30, 2)] capacity = 5 assert max_knapsack_value(items, capacity) == 80 items = [(10, 2), (20, 3), (30, 8)] capacity = 5 assert max_knapsack_value(items, capacity) == 30 ``` # Note - You should handle all mentioned edge cases such as zero capacity, empty item list, or cases where all item weights are greater than the knapsack capacity.","solution":"from typing import List, Tuple def max_knapsack_value(items: List[Tuple[int, int]], capacity: int) -> int: Returns the maximum value that fits into the knapsack without exceeding its capacity. :param items: A list of tuples where each tuple represents the (value, weight) of an item. :param capacity: The maximum capacity of the knapsack. :return: The maximum value that can be achieved within the knapsack capacity. n = len(items) dp = [[0 for _ in range(capacity + 1)] for _ in range(n + 1)] for i in range(1, n + 1): value, weight = items[i - 1] for w in range(capacity + 1): if weight <= w: dp[i][w] = max(dp[i - 1][w], dp[i - 1][w - weight] + value) else: dp[i][w] = dp[i - 1][w] return dp[n][capacity]"},{"question":"You are required to implement a sorting algorithm that will sort a list of integers in ascending order using the insertion sort approach. The implementation should focus on optimizing the performance and handling various edge cases efficiently. # Function Signature ```python def insertion_sort(arr: List[int]) -> List[int]: ``` # Input - **arr**: A list of integers `arr` where `1 <= len(arr) <= 10^4` and `-10^6 <= arr[i] <= 10^6`. # Output - Return a list of integers sorted in ascending order. # Constraints - The function should sort the array in-place with a space complexity of O(1). - The algorithm should be able to handle large lists efficiently, although the primary focus is correct implementation rather than optimal time complexity. - Consider edge cases such as an empty list, already sorted list, and list with identical elements. # Example ```python assert insertion_sort([4, 5, 3, 1, 2]) == [1, 2, 3, 4, 5] assert insertion_sort([10, 9, 8, 7, 6, 5, 4, 3, 2, 1]) == [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] assert insertion_sort([1, 1, 1, 1, 1]) == [1, 1, 1, 1, 1] assert insertion_sort([]) == [] ``` # Notes - Do not use built-in sort functions. - Ensure the code handles the edge cases gracefully. - Keep the implementation efficient, though you don\'t need to go beyond the standard O(n^2) time complexity associated with insertion sort.","solution":"def insertion_sort(arr): Sorts a list of integers in ascending order using the insertion sort algorithm. for i in range(1, len(arr)): key = arr[i] j = i - 1 while j >= 0 and key < arr[j]: arr[j + 1] = arr[j] j -= 1 arr[j + 1] = key return arr"},{"question":"**Advanced Coding Assessment Question: Flatten Nested Arrays Using Iteration** # Context: You work on a data processing team and frequently encounter data stored in deeply nested arrays. To improve performance and simplify manipulation, your task is to write a function that flattens these nested arrays. This function must handle wide variety of nested structures gracefully. # Challenge: We have provided you an outline of a recursive solution. Your task is to write an alternative, iterative approach that avoids using recursion to flatten a nested array. # Requirements: * Implement a function `flatten_iteratively()` that takes a nested list and returns a new list that is fully flattened. * Do not use recursion. Instead, use an explicit stack to manage the elements. # Expected Input and Output: * **Input**: A list, which may contain nested lists. ```python example_input = [1, [2, [3, 4], 5], 6, [[7, 8], 9]] ``` * **Output**: A single flattened list. ```python example_output = [1, 2, 3, 4, 5, 6, 7, 8, 9] ``` # Constraints: * Do not use Python\'s `flatten()` method from libraries such as `itertools`. * Handle nesting to any depth. * Expect input lists to be relatively large but fit memory comfortably when flattened. # Performance Requirements: * Aim for time complexity O(n), where n is the total number of elements across all nested levels. * Aim for space complexity O(n), where n is the total number of elements (excluding space used by the stack). # Implementation Hints: * Consider using a stack to store elements as you traverse the input list. * Consider how you might handle iterating over nested lists without using recursion. * Use appropriate checks to distinguish between iterable and non-iterable elements. # Function Signature: ```python def flatten_iteratively(nested_list): # Your implementation here pass # Example test cases input_data = [1, [2, [3, 4], 5], 6, [[7, 8], 9]] print(flatten_iteratively(input_data)) # Should output [1, 2, 3, 4, 5, 6, 7, 8, 9] ```","solution":"def flatten_iteratively(nested_list): Flattens a nested list without using recursion. Args: - nested_list: list of elements, where some elements may be nested lists Returns: - A single flattened list. flattened_list = [] stack = [nested_list] while stack: current = stack.pop() if isinstance(current, list): stack.extend(reversed(current)) else: flattened_list.append(current) return flattened_list"},{"question":"# Comb Sort Challenge You are tasked with implementing the Comb Sort algorithm to sort an array of integers. This algorithm is an improvement over the Bubble Sort algorithm and aims to reduce the total effort required by comparing and swapping data at a gradually reducing gap until the gap becomes 1. The goal is to handle large numbers of inversions more efficiently. Objective Write a function `comb_sort(arr: List[int]) -> List[int]` that takes a list of integers as input and returns a sorted list using the Comb Sort algorithm. # Input - `arr`: A list of integers, where each integer is in the range -10^6 to 10^6. - The length of the array will be between 0 and 10^5 inclusive. # Output - Return the sorted list of integers in ascending order. # Constraints - The algorithm should efficiently handle arrays with up to 100,000 elements. - Consider performance when choosing the shrink factor and handling edge cases. # Example ```python def comb_sort(arr): def swap(i, j): arr[i], arr[j] = arr[j], arr[i] n = len(arr) gap = n shrink = 1.3 sorted = False while not sorted: gap = int(gap / shrink) if gap > 1: sorted = False else: gap = 1 sorted = True i = 0 while i + gap < n: if arr[i] > arr[i + gap]: swap(i, i + gap) sorted = False i = i + 1 return arr # Test Cases print(comb_sort([5, 3, 8, 4, 2])) # Output: [2, 3, 4, 5, 8] print(comb_sort([9, 9, 9, 3])) # Output: [3, 9, 9, 9] print(comb_sort([])) # Output: [] print(comb_sort([-1, -5, 0, 5])) # Output: [-5, -1, 0, 5] ```","solution":"def comb_sort(arr): def swap(i, j): arr[i], arr[j] = arr[j], arr[i] n = len(arr) gap = n shrink = 1.3 sorted = False while not sorted: gap = int(gap / shrink) if gap > 1: sorted = False else: gap = 1 sorted = True i = 0 while i + gap < n: if arr[i] > arr[i + gap]: swap(i, i + gap) sorted = False i += 1 return arr"},{"question":"You need to implement a function that determines which letter was added to a randomly shuffled string, `t`, which is formed by shuffling `s` and adding one additional character in the new string. # Function Signature ```python def find_difference(s: str, t: str) -> str: ``` # Input * `s` : a string consisting of lowercase English letters (1 ≤ length(s) ≤ 10⁵). * `t`: a string consisting of lowercase English letters such that `t` is generated by shuffling `s` and adding one more letter at a random position in the new string. Therefore, `len(t) = len(s) + 1`. # Output * Return the character that was added to `t`. # Constraints * The strings only consist of lowercase English letters. # Example ```python # Example 1 s = \\"abcd\\" t = \\"abecd\\" print(find_difference(s, t)) # Output: \'e\' # Example 2 s = \\"xyz\\" t = \\"xyaz\\" print(find_difference(s, t)) # Output: \'a\' # Example 3 s = \\"a\\" t = \\"ab\\" print(find_difference(s, t)) # Output: \'b\' ``` # Explanation * In Example 1, the character \'e\' was added to the string \\"abcd\\". * In Example 2, the character \'a\' was added to the string \\"xyz\\". * In Example 3, the character \'b\' was added to the string \\"a\\". # Notes * Please consider edge cases such as very small and very large strings. * Ensure the function is efficient with linear time complexity.","solution":"def find_difference(s, t): Returns the character that was added to s to make t. :param s: input string s (original string) :param t: input string t (shuffled s with one additional character) :return: the extra character in t return chr(sum(map(ord, t)) - sum(map(ord, s)))"},{"question":"You are given the root of a binary tree. Your task is to implement a function to find all paths from the root node to all leaf nodes. Each path should be represented as a string of node values separated by the arrow (`->`). # Function Signature: ```python def binary_tree_paths(root: TreeNode) -> List[str]: ``` # Input: - `root` (TreeNode): A TreeNode object representing the root of the binary tree. Each node has the following structure: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` # Output: - List of paths (List[str]): A list where each element is a string representing a path from the root node to a leaf node. # Constraints: - The number of nodes in the tree is in the range [0, 100]. - Each node\'s value is an integer. # Example: ```plaintext Input: 1 / 2 3 5 Output [\\"1->2->5\\", \\"1->3\\"] Input: 1 Output [\\"1\\"] Input: root = None Output [] ``` # Performance Requirements: - The solution should be efficient in terms of both time and space (as discussed in the analysis, targeting O(n) time complexity and O(h) space complexity). # Note: - Ensure you handle edge cases such as empty trees and trees with only one node.","solution":"from typing import List class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def binary_tree_paths(root: TreeNode) -> List[str]: def build_paths(node, path, paths): if node: path += str(node.val) if not node.left and not node.right: # if leaf node paths.append(path) else: path += \'->\' build_paths(node.left, path, paths) build_paths(node.right, path, paths) paths = [] build_paths(root, \'\', paths) return paths"},{"question":"# Question: Implement a Min Heap As a software engineer at a company that deals in priority-based tasks, you need to implement a Min Heap to manage task priorities efficiently. The Min Heap should allow for insertion of tasks with a specific priority and enable the retrieval (and removal) of the task with the highest priority (i.e., the smallest priority number). Task: 1. **Implement the Min Heap Class**: - `insert(val: int) -> None`: Insert an integer value into the heap. - `remove_min() -> int`: Remove and return the smallest integer from the heap. 2. **Requirements**: - The insert operation should maintain the heap property, ensuring the smallest element is at the root. - The remove_min operation should remove the smallest element and reheapify to maintain the heap property. 3. **Constraints**: - The value inserted into the heap will always be a non-negative integer. - The heap will not contain more than `10^5` elements at any time. Example: ```python heap = BinaryHeap() heap.insert(10) heap.insert(5) heap.insert(30) print(heap.remove_min()) # Output: 5 print(heap.remove_min()) # Output: 10 heap.insert(2) print(heap.remove_min()) # Output: 2 ``` Notes: - You only need to implement the Binary Heap class with the specified methods. - The internal storage of the heap can be managed using a list, following a 1-based index approach.","solution":"class MinHeap: def __init__(self): self.heap = [0] # Initial heap list with a dummy value at index 0 def insert(self, val): # Append value to the heap self.heap.append(val) # Percolate Up to maintain heap property self._percolate_up(len(self.heap) - 1) def remove_min(self): if len(self.heap) == 1: # Only the dummy value raise IndexError(\\"Heap is empty\\") # The smallest value is at the root at index 1 min_val = self.heap[1] # Move the last element to the root and heapify down self.heap[1] = self.heap[-1] self.heap.pop() self._percolate_down(1) return min_val def _percolate_up(self, index): while index // 2 > 0: if self.heap[index] < self.heap[index // 2]: self.heap[index], self.heap[index // 2] = self.heap[index // 2], self.heap[index] index = index // 2 def _percolate_down(self, index): while index * 2 < len(self.heap): min_child_index = self._min_child(index) if self.heap[index] > self.heap[min_child_index]: self.heap[index], self.heap[min_child_index] = self.heap[min_child_index], self.heap[index] index = min_child_index def _min_child(self, index): if index * 2 + 1 >= len(self.heap): return index * 2 else: if self.heap[index * 2] < self.heap[index * 2 + 1]: return index * 2 else: return index * 2 + 1"},{"question":"# Problem Description You are provided with the root of a binary tree. Write a function `binary_tree_paths(root)` that returns all root-to-leaf paths in the binary tree. # Function Signature ```python def binary_tree_paths(root): ``` # Input * `root`: The root node of the binary tree. The tree nodes have the following structure: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` # Output * A list of strings, where each string represents a path from the root to a leaf. Each path contains the node values separated by \'->\'. # Constraints 1. The number of nodes in the tree is in the range [0, 100]. 2. -100 <= Node value <= 100 # Example Example 1: ``` Input: 1 / 2 3 5 Output: [\\"1->2->5\\", \\"1->3\\"] ``` Example 2: ``` Input: 1 / 2 3 Output: [\\"1->2\\", \\"1->3\\"] ``` # Performance Requirements The solution must have a time complexity of O(N), where N is the number of nodes in the tree, and a space complexity of O(H), where H is the height of the tree. # Additional Notes * Handle edge cases such as an empty tree (root is None), trees with only single child nodes, etc. * Ensure your solution is efficient and consider optimizing for memory usage where possible.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def binary_tree_paths(root): Returns all root-to-leaf paths in the binary tree. def construct_paths(node, path): if node: path += str(node.val) if not node.left and not node.right: # Leaf node. paths.append(path) else: path += \'->\' construct_paths(node.left, path) construct_paths(node.right, path) paths = [] construct_paths(root, \\"\\") return paths"},{"question":"# Coding Assignment Context: You are tasked with analyzing clusters of active cells in a 2D grid for an environmental research project. Each active cell is denoted by \'1\' and inactive by \'0\'. Cells are considered part of the same cluster if they are directly connected horizontally or vertically. Your task is to determine the number of clusters in the grid using an efficient algorithm. Task: Implement the following function: ```python def count_clusters(grid: List[List[int]]) -> int: # Your implementation here ``` Input: * `grid`: A 2D list where each element is either a 0 or 1: * grid represents a rectangular matrix with M rows and N columns. * 1 ≤ M, N ≤ 300 Output: * Returns the number of clusters (islands) of \'1\'s. Constraints: * The matrix elements are either 0 or 1. * You may assume that all edges of the matrix are surrounded by water (0s). Example: ```python grid1 = [ [1, 1, 1, 1, 0], [1, 1, 0, 1, 0], [1, 1, 0, 0, 0], [0, 0, 0, 0, 0] ] print(count_clusters(grid1)) # Output: 1 grid2 = [ [1, 1, 0, 0, 0], [1, 1, 0, 0, 0], [0, 0, 1, 0, 0], [0, 0, 0, 1, 1] ] print(count_clusters(grid2)) # Output: 3 grid3 = [ [1, 1, 1, 0, 0, 0], [1, 1, 0, 0, 0, 0], [1, 0, 0, 0, 0, 1], [0, 0, 1, 1, 0, 1], [0, 0, 1, 1, 0, 0] ] print(count_clusters(grid3)) # Output: 3 grid4 = [ [1, 1, 0, 0, 1, 1], [0, 0, 1, 1, 0, 0], [0, 0, 0, 0, 0, 1], [1, 1, 1, 1, 0, 0] ] print(count_clusters(grid4)) # Output: 5 ``` Evaluation Criteria: * Correctness: The implementation must return the correct number of clusters for various test cases. * Efficiency: The algorithm should run efficiently given the constraints. * Code quality: The implementation should be clean, well-commented, and easy to read.","solution":"from typing import List def count_clusters(grid: List[List[int]]) -> int: if not grid or not grid[0]: return 0 rows, cols = len(grid), len(grid[0]) visited = [[False] * cols for _ in range(rows)] def dfs(r, c): if r < 0 or r >= rows or c < 0 or c >= cols or grid[r][c] == 0 or visited[r][c]: return visited[r][c] = True dfs(r + 1, c) dfs(r - 1, c) dfs(r, c + 1) dfs(r, c - 1) cluster_count = 0 for r in range(rows): for c in range(cols): if grid[r][c] == 1 and not visited[r][c]: dfs(r, c) cluster_count += 1 return cluster_count"},{"question":"You are given two singly linked lists. Both lists may or may not intersect at some point. Your task is to write a function `find_intersection` that takes the heads of these two linked lists and returns the intersection node if it exists, or `None`. **Definition:** ```python class Node: def __init__(self, val=None): self.val = val self.next = None ``` **Function Signature**: ```python def find_intersection(head1: Node, head2: Node) -> Optional[Node]: :param head1: Node - The head of the first linked list :param head2: Node - The head of the second linked list :return: Node or None - The intersection node if it exists, otherwise None ``` # Input - `head1` (Node): Head node of the first singly linked list. - `head2` (Node): Head node of the second singly linked list. # Output Returns the intersecting node (Node) if it exists, otherwise `None`. # Constraints - The linked lists can be of different lengths. - The Node class is already implemented and nodes have unique identities based on their memory addresses, not just their values. - You may assume there are no cycles in the linked lists. # Performance Requirements - Time Complexity: O(N + M) where N and M are the lengths of the two lists. - Space Complexity: O(1). # Scenario Imagine you are working on a version control system that tracks changes across multiple branches. Some branches might share common history before they diverge. You need to find the point (node) where two branches last intersect. # Example Consider the lists: 1 -> 3 -> 5 7 -> 9 -> 11 / 2 -> 4 -> 6 - For the given lists, the output should be the node with the value 7. # Additional Test Case 1. If `head1` is `None` and `head2` is not `None`, return `None`. 2. If both `head1` and `head2` point to the same initial node, return this node. 3. Two lists of equal lengths but no intersection should return `None`. Write the function `find_intersection` to solve this problem.","solution":"class Node: def __init__(self, val=None): self.val = val self.next = None def find_intersection(head1: Node, head2: Node): Finds the intersection point of two singly linked lists if it exists. :param head1: Node - The head of the first linked list :param head2: Node - The head of the second linked list :return: Node or None - The intersection node if it exists, otherwise None def get_length(head: Node): length = 0 current = head while current: length += 1 current = current.next return length len1 = get_length(head1) len2 = get_length(head2) current1 = head1 current2 = head2 # Align the start of the two lists if len1 > len2: for _ in range(len1 - len2): current1 = current1.next else: for _ in range(len2 - len1): current2 = current2.next # Traverse both lists together to find the intersection point while current1 and current2: if current1 is current2: return current1 current1 = current1.next current2 = current2.next return None"},{"question":"# Question: Scenario As an intern at a software development firm, you are asked to implement a sorting utility for a small project. The request requires sorting of small datasets where the simplicity and in-memory operation of the sorting algorithm are beneficial. You decide to use Exchange Sort due to its straightforward implementation. Task Implement the function `exchange_sort(arr)` to sort a given array of integers in ascending order using the Exchange Sort algorithm. Ensure your implementation adheres to the properties of Exchange Sort. Function Signature ```python def exchange_sort(arr: List[int]) -> List[int]: ``` Input * `arr`: A list of integers, where 0 ≤ len(arr) ≤ 1000. Output * Return the sorted list of integers in ascending order. Example ```python # Input arr = [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5] # Output [1, 1, 2, 3, 3, 4, 5, 5, 5, 6, 9] ``` Constraints * The input list can include negative numbers. * Avoid using built-in sorting functions (`sort()` or `sorted()`). * Focus on the in-place and comparison-based nature of Exchange Sort. Performance Requirements * Given the time complexity of O(n²), the function should efficiently handle the input list sizes in typical scenarios constrained to n ≤ 1000. Notes * Ensure you handle edge cases such as empty lists, single-element lists, and duplicate elements appropriately. * Emphasize clarity and accuracy in adhering to the Exchange Sort algorithm.","solution":"from typing import List def exchange_sort(arr: List[int]) -> List[int]: Sorts the input list of integers in ascending order using Exchange Sort algorithm. n = len(arr) for i in range(n - 1): for j in range(i + 1, n): if arr[i] > arr[j]: arr[i], arr[j] = arr[j], arr[i] return arr"},{"question":"# Context You are in charge of planning broadcast events for a network. The network has multiple subsets of channels that can cover different geographic areas. Each subset has an associated broadcast cost. You need to find the minimal cost combination of subsets that will cover all geographic areas. # Task Implement a function that computes the minimum cost subcollection of channel sets that covers all designated geographic areas using both optimal and greedy approaches. # Function Signature ```python def optimal_set_cover(universe: set, subsets: dict, costs: dict) -> tuple: pass def greedy_set_cover(universe: set, subsets: dict, costs: dict) -> tuple: pass ``` # Input * **universe:** A set of integers representing the geographic areas to be covered. Example: {1, 2, 3, 4, 5} * **subsets:** A dictionary mapping subset names (string) to sets of integers representing the areas they cover. Example: {\'S1\': {1, 3, 4}, \'S2\': {2, 5}, \'S3\': {1, 2, 3, 4}} * **costs:** A dictionary mapping subset names (string) to their associated costs (integer). Example: {\'S1\': 5, \'S2\': 10, \'S3\': 3} # Output * **For optimal_set_cover:** Return a tuple consisting of: * A list of selected subset names representing the minimal cost cover. * An integer representing the total minimal cost. * **For greedy_set_cover:** Similarly, return a tuple consisting of: * A list of selected subset names found using the greedy approach. * An integer representing the total cost according to the greedy algorithm. # Constraints * All geographic areas in the universe must be covered by the subsets. * The number of subsets (m) must be such that (1 leq m leq 20). * Subset costs and number of areas covered by a subset can vary. # Examples ```python if __name__ == \'__main__\': universe = {1, 2, 3, 4, 5} subsets = {\'S1\': {4, 1, 3}, \'S2\': {2, 5}, \'S3\': {1, 4, 3, 2}} costs = {\'S1\': 5, \'S2\': 10, \'S3\': 3} optimal_cover, optimal_cost = optimal_set_cover(universe, subsets, costs) print(\'Optimal Set Cover:\', optimal_cover) print(\'Cost:\', optimal_cost) greedy_cover, greedy_cost = greedy_set_cover(universe, subsets, costs) print(\'Greedy Set Cover:\', greedy_cover) print(\'Cost:\', greedy_cost) ``` The expected output for the provided example should be: ``` Optimal Set Cover: [\'S2\', \'S3\'] Cost: 13 Greedy Set Cover: [\'S3\', \'S2\'] Cost: 13 ```","solution":"from itertools import chain, combinations def optimal_set_cover(universe: set, subsets: dict, costs: dict) -> tuple: Find the minimum cost subcollection of subsets that covers all areas in the universe. all_subsets = list(subsets.keys()) def powerset(iterable): \\"powerset([1,2,3]) -> (,) (1,) (2,) (3,) (1,2,) (1,3) (2,3) (1,2,3)\\" s = list(iterable) return chain.from_iterable(combinations(s, r) for r in range(len(s) + 1)) min_cost = float(\'inf\') best_combination = [] for sub in powerset(all_subsets): covered_areas = set().union(*(subsets[s] for s in sub)) if covered_areas == universe: cost = sum(costs[s] for s in sub) if cost < min_cost: min_cost = cost best_combination = list(sub) return best_combination, min_cost def greedy_set_cover(universe: set, subsets: dict, costs: dict) -> tuple: Find a covering subcollection of subsets using a greedy algorithm. uncovered = universe.copy() selected = [] total_cost = 0 while uncovered: best_subset = None best_cost_effect = float(\'inf\') for subset_name, areas in subsets.items(): covered_areas = uncovered.intersection(areas) if covered_areas: cost_effect = costs[subset_name] / len(covered_areas) if cost_effect < best_cost_effect: best_cost_effect = cost_effect best_subset = subset_name if not best_subset: raise ValueError(\\"No valid set cover found\\") selected.append(best_subset) total_cost += costs[best_subset] uncovered -= subsets[best_subset] return selected, total_cost"},{"question":"# Problem: Array Increment Algorithm You are given a non-negative integer represented as a list of digits. Your task is to write a function `increment_number` that adds one to the integer. The digits are stored in big-endian order, meaning that the most significant digit is at the start of the list. Function Signature ```python def increment_number(digits: List[int]) -> List[int]: ``` Input * `digits`: List of integers representing the digits (0-9) of a non-negative number. The list will have at least one element. Output * Returns a list of integers representing the digits of the incremented number. Constraints * Leading zeros are not present except in the case of single element `[0]`. * The length of `digits` will not exceed 1000 elements. Example 1. Input: `[1, 2, 3]` Output: `[1, 2, 4]` 2. Input: `[9, 9, 9]` Output: `[1, 0, 0, 0]` 3. Input: `[0]` Output: `[1]` 4. Input: `[2, 9, 9]` Output: `[3, 0, 0]` Note - You need to handle the carry over to multiple digits correctly. - Optimize for both time and space where feasible.","solution":"from typing import List def increment_number(digits: List[int]) -> List[int]: n = len(digits) for i in range(n-1, -1, -1): if digits[i] < 9: digits[i] += 1 return digits digits[i] = 0 return [1] + [0] * n"},{"question":"Summary Range Generation Scenario: You are part of a development team that deals with processing and summarizing sequential data. One of the tasks is to summarize ranges in a sorted list of unique integers. For instance, given a sorted list [0, 1, 2, 4, 5, 7], it should be summarized to [(0, 2), (4, 5), (7, 7)]. Prompt: Write a function called `summarize_ranges` which takes a sorted list of unique integers and returns a list of ranges. The format of a range is a tuple (start, end), where `start` and `end` are inclusive bounds of a contiguous sequence of numbers from the array. If the range consists of only one element, the tuple should have just one element (start). The resulting tuples should still be in the form of (start,). However, the final output of the function should be in the form of strings where single-element tuples are just their number and ranges have start and end separated by a hyphen. Function Signature: ```python def summarize_ranges(array: List[int]) -> List[str]: pass ``` Input: * **array**: A list of sorted unique integers, 0 <= len(array) <= 10^4. Output: * **A list of strings** where ranges are displayed in the format \\"start-end\\" or as a single number for a single-element range. Constraints: * The input array is sorted. * All integers in the array are unique. Examples: ```python # Example 1 array = [0, 1, 2, 4, 5, 7] summarize_ranges(array) # Expected output: [\'0-2\', \'4-5\', \'7\'] # Example 2 array = [1, 3, 4, 5, 7, 8, 10] summarize_ranges(array) # Expected output: [\'1\', \'3-5\', \'7-8\', \'10\'] # Example 3 array = [0] summarize_ranges(array) # Expected output: [\'0\'] # Example 4 array = [] summarize_ranges(array) # Expected output: [] ``` Notes: * Your solution should handle edge cases like empty arrays and arrays with a single element gracefully. * Ensure your implementation efficiently processes larger inputs within the constraint limits.","solution":"from typing import List def summarize_ranges(array: List[int]) -> List[str]: if not array: return [] ranges = [] start = array[0] end = array[0] for num in array[1:]: if num == end + 1: end = num else: if start == end: ranges.append(f\\"{start}\\") else: ranges.append(f\\"{start}-{end}\\") start = num end = num if start == end: ranges.append(f\\"{start}\\") else: ranges.append(f\\"{start}-{end}\\") return ranges"}]'),S={name:"App",components:{PoemCard:A},data(){return{searchQuery:"",visibleCount:4,poemsData:O,isLoading:!1}},computed:{filteredPoems(){const r=this.searchQuery.trim().toLowerCase();return r?this.poemsData.filter(e=>e.question&&e.question.toLowerCase().includes(r)||e.solution&&e.solution.toLowerCase().includes(r)):this.poemsData},displayedPoems(){return this.searchQuery.trim()?this.filteredPoems:this.filteredPoems.slice(0,this.visibleCount)},hasMorePoems(){return!this.searchQuery.trim()&&this.visibleCount<this.poemsData.length}},methods:{async loadMore(){this.isLoading=!0,await new Promise(r=>setTimeout(r,1e3)),this.visibleCount+=4,this.isLoading=!1}}},C={class:"search-container"},z={class:"card-container"},L={key:0,class:"empty-state"},F=["disabled"],R={key:0},Y={key:1};function j(r,e,l,p,a,s){const m=g("PoemCard");return n(),i("section",null,[e[4]||(e[4]=t("div",{class:"top-banner"},[t("div",{class:"top-banner-title"},[t("div",{class:"top-banner-title-text"},"🤔prompts chat🧠")])],-1)),t("div",C,[e[3]||(e[3]=t("span",{class:"search-icon"},"🔍",-1)),_(t("input",{type:"text",class:"search-input","onUpdate:modelValue":e[0]||(e[0]=o=>a.searchQuery=o),placeholder:"Search..."},null,512),[[y,a.searchQuery]]),a.searchQuery?(n(),i("button",{key:0,class:"clear-search",onClick:e[1]||(e[1]=o=>a.searchQuery="")}," ✕ ")):u("",!0)]),t("div",z,[(n(!0),i(b,null,v(s.displayedPoems,(o,f)=>(n(),w(m,{key:f,poem:o},null,8,["poem"]))),128)),s.displayedPoems.length===0?(n(),i("div",L,' No results found for "'+d(a.searchQuery)+'". ',1)):u("",!0)]),s.hasMorePoems?(n(),i("button",{key:0,class:"load-more-button",disabled:a.isLoading,onClick:e[2]||(e[2]=(...o)=>s.loadMore&&s.loadMore(...o))},[a.isLoading?(n(),i("span",Y,"Loading...")):(n(),i("span",R,"See more"))],8,F)):u("",!0)])}const B=c(S,[["render",j],["__scopeId","data-v-ea36c683"]]),M=JSON.parse('{"title":"","description":"","frontmatter":{"page":true},"headers":[],"relativePath":"drive/44.md","filePath":"drive/44.md"}'),D={name:"drive/44.md"},G=Object.assign(D,{setup(r){return(e,l)=>(n(),i("div",null,[x(B)]))}});export{M as __pageData,G as default};
