import{_ as c,o as r,c as s,a as t,m as _,t as u,C as h,M as g,U as b,f as d,F as y,p as v,e as x,q as w}from"./chunks/framework.B1z0IdBH.js";const k={name:"PoemCard",props:{poem:{type:Object,required:!0}}},q={class:"poem-container"},T={class:"review"},L={class:"review-title"},N={class:"review-content"};function A(i,e,l,f,a,n){return r(),s("div",q,[t("div",T,[t("div",L,[e[0]||(e[0]=t("span",{class:"icon"},"question:",-1)),_(u(l.poem.question),1)]),e[2]||(e[2]=t("div",{class:"divider"},null,-1)),t("p",N,[e[1]||(e[1]=t("span",{class:"icon"},"answer:",-1)),_(u(l.poem.solution),1)])])])}const R=c(k,[["render",A],["__scopeId","data-v-c2ed5eb8"]]),E=JSON.parse(`[{"question":"def is_self_dividing_number(number: int) -> bool: Checks if a number is a self-dividing number. A self-dividing number is a number that is divisible by every digit it contains. :param number: Positive integer to check. :return: Boolean indicating whether the number is self-dividing. Examples: >>> is_self_dividing_number(1) True >>> is_self_dividing_number(12) True >>> is_self_dividing_number(128) True >>> is_self_dividing_number(26) False >>> is_self_dividing_number(101) False from solution import is_self_dividing_number def test_is_self_dividing_number_single_digit(): assert is_self_dividing_number(1) == True assert is_self_dividing_number(5) == True assert is_self_dividing_number(7) == True def test_is_self_dividing_number_multiple_digits(): assert is_self_dividing_number(12) == True assert is_self_dividing_number(128) == True assert is_self_dividing_number(36) == True assert is_self_dividing_number(101) == False assert is_self_dividing_number(26) == False def test_is_self_dividing_number_with_zero_digit(): assert is_self_dividing_number(10) == False assert is_self_dividing_number(20) == False assert is_self_dividing_number(30) == False def test_is_self_dividing_number_edge_cases(): assert is_self_dividing_number(10000) == False assert is_self_dividing_number(9999) == True assert is_self_dividing_number(1) == True assert is_self_dividing_number(11) == True assert is_self_dividing_number(21) == False","solution":"def is_self_dividing_number(number: int) -> bool: Checks if a number is a self-dividing number. A self-dividing number is a number that is divisible by every digit it contains. :param number: Positive integer to check. :return: Boolean indicating whether the number is self-dividing. original_number = number while number > 0: digit = number % 10 if digit == 0 or original_number % digit != 0: return False number //= 10 return True"},{"question":"# Creating module \`solution\` Code Implementation import numpy as np from sklearn.feature_extraction.text import TfidfVectorizer from sklearn.linear_model import LogisticRegression from sklearn.metrics import accuracy_score, confusion_matrix from sklearn.model_selection import train_test_split from sklearn.datasets import load_files def preprocess_data(reviews: np.ndarray, labels: np.ndarray) -> tuple: Tokenizes and processes the text data, transforming it into numerical features using TF-IDF vectorization. Returns the vectorized features and corresponding labels. # Handle any missing values in the reviews reviews = np.array([review if isinstance(review, str) else \\"\\" for review in reviews]) vectorizer = TfidfVectorizer(stop_words=\\"english\\") features = vectorizer.fit_transform(reviews) return features, labels def logistic_regression(features: np.ndarray, labels: np.ndarray, test_features: np.ndarray) -> np.ndarray: Initializes and trains a logistic regression model on the training features and labels. Predicts the sentiment for the given test features and returns the predictions. model = LogisticRegression(random_state=42, max_iter=1000) model.fit(features, labels) predictions = model.predict(test_features) return predictions def main() -> None: # Load IMDB dataset reviews_data = load_files('path/to/imdb/reviews', shuffle=True) reviews, labels = reviews_data.data, reviews_data.target # Preprocess the dataset features, labels = preprocess_data(reviews, labels) x_train, x_test, y_train, y_test = train_test_split(features, labels, test_size=0.25, random_state=42) # Train and predict predictions = logistic_regression(x_train, y_train, x_test) # Output results print(f\\"Accuracy: {accuracy_score(y_test, predictions)}\\") print(f\\"Confusion Matrix:n{confusion_matrix(y_test, predictions)}\\") if __name__ == \\"__main__\\": main() Unit Tests import numpy as np from sklearn.model_selection import train_test_split from sklearn.metrics import accuracy_score from unittest.mock import patch def test_preprocess_data(): from solution import preprocess_data reviews = np.array([\\"Good movie!\\", \\"Bad film.\\", np.nan, \\"Awesome!\\", \\"Terrible...\\"]) labels = np.array([1, 0, 0, 1, 0]) # Preprocess the data features, processed_labels = preprocess_data(reviews, labels) # Verify the shape and ensure no nans in the reviews assert features.shape[0] == len(reviews), \\"Features shape mismatch\\" assert np.array_equal(labels, processed_labels), \\"Labels mismatch\\" def test_logistic_regression(): from solution import preprocess_data, logistic_regression # Sample data reviews = np.array([\\"Good movie!\\", \\"Bad film.\\", \\"Awesome!\\", \\"Terrible...\\"]) labels = np.array([1, 0, 1, 0]) # Preprocess the data features, processed_labels = preprocess_data(reviews, labels) x_train, x_test, y_train, y_test = train_test_split(features, processed_labels, test_size=0.25, random_state=42) # Train and predict predictions = logistic_regression(x_train, y_train, x_test) # Ensure predictions have the correct shape assert len(predictions) == len(y_test), \\"Predictions shape mismatch\\" def test_main(monkeypatch): import solution from solution import main # Mocking load_files to prevent actual IO operations def mock_load_files(*args, **kwargs): return type('MockedData', (object,), { 'data': np.array([\\"Good movie!\\", \\"Bad film.\\", \\"Awesome!\\", \\"Terrible...\\"]), 'target': np.array([1, 0, 1, 0]) }) monkeypatch.setattr(solution, 'load_files', mock_load_files) with patch('builtins.print') as mocked_print: main() # Check if accuracy and confusion matrix were printed assert mocked_print.called, \\"Print not called\\" called_args = [call.args[0] for call in mocked_print.call_args_list] assert any(\\"Accuracy\\" in arg for arg in called_args) and any \\"Confusion Matrix\\" in arg for call.args[0] in called_args), \\"Expected output not printed\\"","solution":"import numpy as np from sklearn.feature_extraction.text import TfidfVectorizer from sklearn.linear_model import LogisticRegression from sklearn.metrics import accuracy_score, confusion_matrix from sklearn.model_selection import train_test_split from sklearn.datasets import load_files def preprocess_data(reviews: np.ndarray, labels: np.ndarray) -> tuple: Tokenizes and processes the text data, transforming it into numerical features using TF-IDF vectorization. Returns the vectorized features and corresponding labels. # Handle any missing values in the reviews reviews = np.array([review if isinstance(review, str) else \\"\\" for review in reviews]) vectorizer = TfidfVectorizer(stop_words=\\"english\\") features = vectorizer.fit_transform(reviews) return features, labels def logistic_regression(features: np.ndarray, labels: np.ndarray, test_features: np.ndarray) -> np.ndarray: Initializes and trains a logistic regression model on the training features and labels. Predicts the sentiment for the given test features and returns the predictions. model = LogisticRegression(random_state=42, max_iter=1000) model.fit(features, labels) predictions = model.predict(test_features) return predictions def main() -> None: # Load IMDB dataset reviews_data = load_files('path/to/imdb/reviews', shuffle=True) reviews, labels = reviews_data.data, reviews_data.target # Preprocess the dataset features, labels = preprocess_data(reviews, labels) x_train, x_test, y_train, y_test = train_test_split(features, labels, test_size=0.25, random_state=42) # Train and predict predictions = logistic_regression(x_train, y_train, x_test) # Output results print(f\\"Accuracy: {accuracy_score(y_test, predictions)}\\") print(f\\"Confusion Matrix:n{confusion_matrix(y_test, predictions)}\\") if __name__ == \\"__main__\\": main()"},{"question":"def max_subarray_sum(profits: list) -> int: Returns the maximum sum of any contiguous subarray. # Initialize the maximum sum to the first element and the current sum to the first element. max_sum = current_sum = profits[0] # Iterate over the profits array starting from the second element for profit in profits[1:]: # Update the current_sum to the maximum of the current profit or the current_sum + profit. current_sum = max(profit, current_sum + profit) # Update the max_sum with the maximum of max_sum and current_sum. max_sum = max(max_sum, current_sum) return max_sum","solution":"def max_subarray_sum(profits): Returns the maximum sum of any contiguous subarray. # Initialize the maximum sum to the first element and the current sum to the first element. max_sum = current_sum = profits[0] # Iterate over the profits array starting from the second element for profit in profits[1:]: # Update the current_sum to the maximum of the current profit or the current_sum + profit. current_sum = max(profit, current_sum + profit) # Update the max_sum with the maximum of max_sum and current_sum. max_sum = max(max_sum, current_sum) return max_sum"},{"question":"def get_matrix_elements(matrix: list[list[int]], indices: list[tuple[int, int]]) -> list[any]: Given a 2D matrix and a list of indices representing elements in the matrix, validate the indices and return the values of the elements at the specified indices. If an index is invalid (i.e., out of the matrix bounds), replace it with \`None\` in the output list. Parameters: matrix (list[list[int]]): A 2D matrix of integers. indices (list[tuple[int, int]]): A list of tuples, where each tuple contains two integers representing the row and column indices of the matrix. Returns: list[any]: A list of elements from the matrix at the specified indices or \`None\` if the index is invalid. Examples: >>> matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] >>> indices = [(0, 0), (1, 2), (3, 1), (-1, 0)] >>> get_matrix_elements(matrix, indices) [1, 6, None, None]","solution":"def get_matrix_elements(matrix, indices): This function returns the values of the elements at the specified indices. If an index is invalid (i.e., out of the matrix bounds), it replaces the value with None. Parameters: matrix (list[list[int]]): A 2D matrix of integers. indices (list[tuple[int, int]]): A list of tuples representing row and column indices. Returns: list[any]: A list of elements from the matrix at the specified indices or None if the index is invalid. rows = len(matrix) cols = len(matrix[0]) if rows > 0 else 0 def is_valid_index(i, j): return 0 <= i < rows and 0 <= j < cols result = [] for (i, j) in indices: if is_valid_index(i, j): result.append(matrix[i][j]) else: result.append(None) return result"},{"question":"import numpy as np from typing import List def knn_recommendations(book_features: np.ndarray, book_id: int, k: int) -> List[int]: Parameters: book_features: np.ndarray -> Feature matrix representing all books (m x n) book_id: int -> ID of the book for which recommendations are being made (0 <= book_id < m) k: int -> Number of nearest neighbors to consider Returns: List[int] -> List of book IDs of the k nearest neighbors Example: >>> book_features = np.array([[1.0, 2.0, 3.0], [2.0, 3.0, 4.0], [1.0, 1.0, 1.0], [5.0, 5.0, 5.0], [1.5, 2.5, 3.5]]) >>> knn_recommendations(book_features, 0, 2) [4, 1] >>> book_features = np.array([[1.0, 1.0], [2.0, 2.0], [3.0, 3.0], [4.0, 4.0], [5.0, 5.0]]) >>> knn_recommendations(book_features, 2, 3) [1, 3, 0] def test_knn_simple_case(): book_features = np.array([[1.0, 2.0, 3.0], [2.0, 3.0, 4.0], [1.0, 1.0, 1.0], [5.0, 5.0, 5.0], [1.5, 2.5, 3.5]]) book_id = 0 k = 2 recommendations = knn_recommendations(book_features, book_id, k) assert recommendations == [4, 1], f\\"Expected recommendations to be [4, 1], but got {recommendations}\\" def test_knn_larger_k(): book_features = np.array([[1.0, 1.0], [2.0, 2.0], [3.0, 3.0], [4.0, 4.0], [5.0, 5.0]]) book_id = 2 k = 3 recommendations = knn_recommendations(book_features, book_id, k) assert recommendations == [1, 3, 0], f\\"Expected recommendations to be [1, 3, 0], but got {recommendations}\\" def test_knn_k_exceeds_books(): book_features = np.array([[1.0, 1.0], [2.0, 2.0], [3.0, 3.0]]) book_id = 0 k = 5 recommendations = knn_recommendations(book_features, book_id, k) assert recommendations == [1, 2], f\\"Expected recommendations to be [1, 2], but got {recommendations}\\" def test_knn_zero_k(): book_features = np.array([[1.0, 1.0], [2.0, 2.0], [3.0, 3.0]]) book_id = 1 k = 0 recommendations = knn_recommendations(book_features, book_id, k) assert recommendations == [], f\\"Expected recommendations to be [], but got {recommendations}\\" def test_knn_invalid_book_id(): book_features = np.array([[1.0, 1.0], [2.0, 2.0], [3.0, 3.0]]) book_id = 3 k = 2 try: knn_recommendations(book_features, book_id, k) assert False, \\"Expected ValueError but did not get one\\" except ValueError as e: assert str(e) == \\"book_id is out of the range of book_features\\"","solution":"import numpy as np from typing import List import heapq def knn_recommendations(book_features: np.ndarray, book_id: int, k: int) -> List[int]: Parameters: book_features: np.ndarray -> Feature matrix representing all books (m x n) book_id: int -> ID of the book for which recommendations are being made (0 <= book_id < m) k: int -> Number of nearest neighbors to consider Returns: List[int] -> List of book IDs of the k nearest neighbors if k <= 0: return [] if not (0 <= book_id < book_features.shape[0]): raise ValueError(\\"book_id is out of the range of book_features\\") distances = [] # Calculate the Euclidean distance from the book with book_id to all other books for idx in range(book_features.shape[0]): if idx != book_id: dist = np.linalg.norm(book_features[book_id] - book_features[idx]) distances.append((dist, idx)) # Find the k smallest distances k_nearest_neighbors = heapq.nsmallest(k, distances, key=lambda x: x[0]) return [neighbor[1] for neighbor in k_nearest_neighbors]"},{"question":"class FenwickTree: def __init__(self, size): self.size = size self.tree = [0] * (size + 1) self.data = [0] * size def update(self, index, value): Update the stock price at the given index in the Fenwick Tree. def query(self, index): Query the cumulative sum up to the given index in the Fenwick Tree. def build_fenwick_tree(prices): Build a Fenwick Tree from a list of stock prices. size = len(prices) fenwick_tree = FenwickTree(size) return fenwick_tree def query_range(fenwick_tree, left_bound, right_bound): Query the average stock price in the given range [left_bound, right_bound].","solution":"class FenwickTree: def __init__(self, size): self.size = size self.tree = [0] * (size + 1) self.data = [0] * size def update(self, index, value): delta = value - self.data[index] self.data[index] = value index += 1 while index <= self.size: self.tree[index] += delta index += index & -index def query(self, index): sum_ = 0 index += 1 while index > 0: sum_ += self.tree[index] index -= index & -index return sum_ def build_fenwick_tree(prices): size = len(prices) fenwick_tree = FenwickTree(size) for i in range(size): fenwick_tree.update(i, prices[i]) return fenwick_tree def query_range(fenwick_tree, left_bound, right_bound): if left_bound > right_bound or left_bound < 0 or right_bound >= fenwick_tree.size: return None # Invalid bounds sum_left = fenwick_tree.query(left_bound - 1) if left_bound > 0 else 0 sum_right = fenwick_tree.query(right_bound) total = sum_right - sum_left return total / (right_bound - left_bound + 1)"},{"question":"def hashmap(operations: List[Tuple[str, Any, Any]]) -> List[Any]: Implement a basic HashMap with insert and get operations. :param operations: A list of operations to be performed on the HashMap. Each operation is represented as a tuple where the first element is a string indicating the operation type ('insert' or 'get'), the second element is the key, and the third element is the value (only for 'insert' operations). :return: A list of results for all 'get' operations. Examples: >>> hashmap([('insert', 'a', 1), ('insert', 'b', 2), ('get', 'a', None), ('get', 'b', None)]) [1, 2] >>> hashmap([('insert', 'a', 1), ('insert', 'a', 2), ('get', 'a', None)]) [2] >>> hashmap([('get', 'unknown', None)]) [None] >>> hashmap([('insert', 'x', 42), ('get', 'x', None), ('insert', 'x', 84), ('get', 'x', None)]) [42, 84]","solution":"def hashmap(operations): Implement a basic HashMap with insert and get operations. :param operations: A list of operations to be performed on the HashMap. Each operation is represented as a tuple where the first element is a string indicating the operation type ('insert' or 'get'), the second element is the key, and the third element is the value (only for 'insert' operations). :return: A list of results for all 'get' operations. hmap = {} results = [] for operation in operations: if operation[0] == 'insert': hmap[operation[1]] = operation[2] elif operation[0] == 'get': results.append(hmap.get(operation[1], None)) return results"},{"question":"import matplotlib.pyplot as plt from collections import Counter def prime_factors(n): Helper function to decompose the input number into its prime factors. >>> prime_factors(360) [2, 2, 2, 3, 3, 5] >>> prime_factors(128) [2, 2, 2, 2, 2, 2, 2] i = 2 factors = [] while i * i <= n: if n % i: i += 1 else: n //= i factors.append(i) if n > 1: factors.append(n) return factors def prime_factor_pie_chart(number: int) -> None: Implement the function to perform prime factorization of the given integer and plot the result as a pie chart. >>> prime_factor_pie_chart(360) >>> prime_factor_pie_chart(128)","solution":"import matplotlib.pyplot as plt from collections import Counter def prime_factors(n): i = 2 factors = [] while i * i <= n: if n % i: i += 1 else: n //= i factors.append(i) if n > 1: factors.append(n) return factors def prime_factor_pie_chart(number: int) -> None: factors = prime_factors(number) counter = Counter(factors) labels = list(counter.keys()) sizes = list(counter.values()) plt.figure(figsize=(8, 8)) plt.pie(sizes, labels=labels, autopct='%1.1f%%', startangle=90) plt.title(f'Prime Factorization of {number}') plt.show()"},{"question":"from typing import List def int_division(a: List[int], k: int) -> List[int]: Performs integer division of each element in the list \`a\` by the integer \`k\`. >>> int_division([5, 10, 15, 20], 5) [1, 2, 3, 4] >>> int_division([4, 3, 2, 1], 2) [2, 1, 1, 0] >>> int_division([-5, -10, 15, 21], 5) [-1, -2, 3, 4] def test_int_division_basic(): assert int_division([5, 10, 15, 20], 5) == [1, 2, 3, 4] def test_int_division_even_and_odd(): assert int_division([4, 3, 2, 1], 2) == [2, 1, 1, 0] def test_int_division_negative_integers(): assert int_division([-5, -10, 15, 21], 5) == [-1, -2, 3, 4] def test_int_division_single_element(): assert int_division([10], 3) == [3] def test_int_division_large_values(): assert int_division([1000, 2000, 3000], 100) == [10, 20, 30] def test_int_division_all_zeroes(): assert int_division([0, 0, 0], 1) == [0, 0, 0] def test_int_division_divisor_is_one(): assert int_division([7, -13, 22], 1) == [7, -13, 22] def test_int_division_edge_case_large_numbers(): assert int_division([1000000000, -1000000000], 1000) == [1000000, -1000000] def test_int_division_both_positive_and_negative_numbers(): assert int_division([7, -14, 22, -8], 2) == [3, -7, 11, -4]","solution":"from typing import List def int_division(a: List[int], k: int) -> List[int]: Performs integer division of each element in the list \`a\` by the integer \`k\`. return [x // k for x in a]"},{"question":"def letter_frequency(text: str) -> dict: Returns the frequency of each letter in the provided text. Args: - text: str : The string to analyze Returns: - dict : A dictionary with letters as keys and their frequencies as values Raises: - ValueError: If the input string is empty >>> letter_frequency(\\"Hello, World!\\") {'h': 1, 'e': 1, 'l': 3, 'o': 2, 'w': 1, 'r': 1, 'd': 1} >>> letter_frequency(\\"Python Programming 123!!!\\") {'p': 2, 'y': 1, 't': 1, 'h': 1, 'o': 2, 'n': 2, 'r': 2, 'g': 2, 'a': 1, 'm': 2, 'i': 1} >>> letter_frequency(\\"\\") Traceback (most recent call last): ... ValueError: Empty string was passed to the function","solution":"def letter_frequency(text: str) -> dict: Returns the frequency of each letter in the provided text. Args: - text: str : The string to analyze Returns: - dict : A dictionary with letters as keys and their frequencies as values Raises: - ValueError: If the input string is empty if not text: raise ValueError(\\"Empty string was passed to the function\\") frequency = {} for char in text.lower(): if char.isalpha(): if char in frequency: frequency[char] += 1 else: frequency[char] = 1 return frequency"},{"question":"def first_unique_character(s: str) -> str: Find the first non-repeating character in the given string. Returns the first character that does not repeat. If no such character is found, returns an empty string. >>> first_unique_character(\\"leetcode\\") 'l' >>> first_unique_character(\\"loveleetcode\\") 'v' >>> first_unique_character(\\"aabb\\") ''","solution":"def first_unique_character(s): Returns the first non-repeating character in the string s. If no unique character is found, returns an empty string. # Step 1: Calculate the frequency of each character in the string char_frequency = {} for char in s: if char in char_frequency: char_frequency[char] += 1 else: char_frequency[char] = 1 # Step 2: Find and return the first character with a frequency of 1 for char in s: if char_frequency[char] == 1: return char return \\"\\""},{"question":"def sort_employees(employees: List[Dict[str, Union[str, int]]], key: str) -> List[str]: Returns a list of employee names sorted by the specified key. Parameters: employees (list of dict): List of dictionaries each containing 'name', 'age', and 'salary'. key (str): The key by which to sort the employees; can be 'name', 'age', or 'salary'. Returns: list of str: List of sorted employee names.","solution":"from typing import List, Dict, Union def sort_employees(employees: List[Dict[str, Union[str, int]]], key: str) -> List[str]: Returns a list of employee names sorted by the specified key. Parameters: employees (list of dict): List of dictionaries each containing 'name', 'age', and 'salary'. key (str): The key by which to sort the employees; can be 'name', 'age', or 'salary'. Returns: list of str: List of sorted employee names. sorted_employees = sorted(employees, key=lambda x: x[key]) return [employee['name'] for employee in sorted_employees]"},{"question":"def split_and_sort(input_file: str, chunk_size: int, temp_file_prefix: str) -> list[str]: Splits the large input file into sorted chunks and returns a list of temporary file paths. pass def merge_sorted_files(temp_files: list[str], output_file: str): Merges the sorted temporary files into a single sorted output file. pass def external_sort(input_file: str, output_file: str, chunk_size: int = 512_000_000): Orchestrates the external sorting process by splitting, sorting, and merging the input file. pass def create_test_file(file_name: str, lines: list[str]): with open(file_name, 'w') as f: f.writelines(lines) def test_split_and_sort(): test_input = 'test_input.txt' create_test_file(test_input, [\\"apple alphan\\", \\"zebra zoon\\", \\"banana betan\\", \\"cherry cherryn\\"]) temp_files = split_and_sort(test_input, 10, 'temp_sort_test_') assert len(temp_files) > 0 for temp_file in temp_files: with open(temp_file, 'r') as f: lines = f.readlines() sorted_lines = sorted(lines, key=lambda x: x.split()[0]) assert lines == sorted_lines os.remove(temp_file) os.remove(test_input) def test_merge_sorted_files(): temp_files = ['temp_merge_1.txt', 'temp_merge_2.txt'] create_test_file(temp_files[0], [\\"apple alphan\\", \\"banana betan\\"]) create_test_file(temp_files[1], [\\"cherry cherryn\\", \\"zebra zoon\\"]) output_file = 'test_output.txt' merge_sorted_files(temp_files, output_file) with open(output_file, 'r') as f: lines = f.readlines() assert lines == [\\"apple alphan\\", \\"banana betan\\", \\"cherry cherryn\\", \\"zebra zoon\\"] os.remove(output_file) def test_external_sort(): test_input = 'test_external_sort_input.txt' create_test_file(test_input, [\\"apple alphan\\", \\"zebra zoon\\", \\"banana betan\\", \\"cherry cherryn\\"]) output_file = 'test_external_sort_output.txt' external_sort(test_input, output_file, 10) with open(output_file, 'r') as f: lines = f.readlines() assert lines == [\\"apple alphan\\", \\"banana betan\\", \\"cherry cherryn\\", \\"zebra zoon\\"] os.remove(test_input) os.remove(output_file) if __name__ == \\"__main__\\": test_split_and_sort() test_merge_sorted_files() test_external_sort()","solution":"import heapq import os import tempfile def split_and_sort(input_file: str, chunk_size: int, temp_file_prefix: str) -> list[str]: temp_files = [] with open(input_file, 'r') as f: while True: lines = f.readlines(chunk_size) if not lines: break lines.sort(key=lambda x: x.split()[0]) temp_file = tempfile.NamedTemporaryFile(delete=False, prefix=temp_file_prefix, mode='w') temp_file.writelines(lines) temp_files.append(temp_file.name) temp_file.close() return temp_files def merge_sorted_files(temp_files: list[str], output_file: str): streams = [open(file, 'r') for file in temp_files] with open(output_file, 'w') as output: min_heap = [] # Initialize the heap with the first line of each file for stream_index, stream in enumerate(streams): line = stream.readline() if line: heapq.heappush(min_heap, (line.split()[0], line, stream_index)) while min_heap: _, line, stream_index = heapq.heappop(min_heap) output.write(line) next_line = streams[stream_index].readline() if next_line: heapq.heappush(min_heap, (next_line.split()[0], next_line, stream_index)) for stream in streams: stream.close() for temp_file in temp_files: os.remove(temp_file) def external_sort(input_file: str, output_file: str, chunk_size: int = 512_000_000): temp_files = split_and_sort(input_file, chunk_size, 'temp_sort_') merge_sorted_files(temp_files, output_file)"},{"question":"from typing import List def circular_array_rotation(arr: List[int], k: int) -> List[int]: Rotates the input array circularly by k positions to the right. Parameters: arr (List[int]): A list of integers to rotate. k (int): The number of positions to rotate the array. Returns: List[int]: The rotated list of integers. # Your code here # Unit tests def test_no_rotation(): assert circular_array_rotation([1, 2, 3], 0) == [1, 2, 3] def test_single_element(): assert circular_array_rotation([1], 5) == [1] def test_rotation_less_than_length(): assert circular_array_rotation([1, 2, 3, 4], 2) == [3, 4, 1, 2] def test_rotation_equal_to_length(): assert circular_array_rotation([1, 2, 3, 4], 4) == [1, 2, 3, 4] def test_rotation_more_than_length(): assert circular_array_rotation([1, 2, 3, 4], 6) == [3, 4, 1, 2] def test_empty_array(): assert circular_array_rotation([], 3) == [] def test_large_k_value(): assert circular_array_rotation([1, 2, 3, 4, 5], 1000000000) == [1, 2, 3, 4, 5] def test_rotation_large_array(): array = list(range(1, 100001)) assert circular_array_rotation(array, 1000000000) == array","solution":"from typing import List def circular_array_rotation(arr: List[int], k: int) -> List[int]: Rotates the input array circularly by k positions to the right. Parameters: arr (List[int]): A list of integers to rotate. k (int): The number of positions to rotate the array. Returns: List[int]: The rotated list of integers. if not arr: return arr n = len(arr) k = k % n # To handle cases where k is larger than the array size return arr[-k:] + arr[:-k]"},{"question":"def majority_element_boyer_moore(arr: list[int]) -> int: Function to find the majority element using Boyer-Moore Voting Algorithm. >>> majority_element_boyer_moore([3, 2, 3]) == 3 >>> majority_element_boyer_moore([2, 2, 1, 1, 1, 2, 2]) == 2 >>> majority_element_boyer_moore([1, 1, 1, 3, 3, 2, 2, 2]) Traceback (most recent call last): ... ValueError: No majority element found def majority_element_hash_map(arr: list[int]) -> int: Function to find the majority element using a hash map. >>> majority_element_hash_map([3, 2, 3]) == 3 >>> majority_element_hash_map([2, 2, 1, 1, 1, 2, 2]) == 2 >>> majority_element_hash_map([1, 1, 1, 3, 3, 2, 2, 2]) Traceback (most recent call last): ... ValueError: No majority element found","solution":"def majority_element_boyer_moore(arr: list[int]) -> int: Function to find the majority element using Boyer-Moore Voting Algorithm. count = 0 candidate = None for num in arr: if count == 0: candidate = num count += (1 if num == candidate else -1) # Verify if the candidate is really the majority element if arr.count(candidate) > len(arr) // 2: return candidate else: raise ValueError(\\"No majority element found\\") def majority_element_hash_map(arr: list[int]) -> int: Function to find the majority element using a hash map. from collections import defaultdict freq = defaultdict(int) majority_count = len(arr) // 2 for num in arr: freq[num] += 1 if freq[num] > majority_count: return num raise ValueError(\\"No majority element found\\")"},{"question":"def nth_fibonacci(n: int) -> int: Returns the nth Fibonacci number. >>> nth_fibonacci(0) 0 >>> nth_fibonacci(1) 1 >>> nth_fibonacci(2) 1 >>> nth_fibonacci(10) 55 pass # Unit tests def test_nth_fibonacci_base_cases(): assert nth_fibonacci(0) == 0 assert nth_fibonacci(1) == 1 def test_nth_fibonacci_small_numbers(): assert nth_fibonacci(2) == 1 assert nth_fibonacci(3) == 2 assert nth_fibonacci(4) == 3 assert nth_fibonacci(5) == 5 def test_nth_fibonacci_larger_numbers(): assert nth_fibonacci(10) == 55 assert nth_fibonacci(15) == 610 assert nth_fibonacci(20) == 6765 def test_nth_fibonacci_upper_bound(): assert nth_fibonacci(30) == 832040","solution":"def nth_fibonacci(n: int) -> int: Returns the nth Fibonacci number. if n == 0: return 0 elif n == 1: return 1 a, b = 0, 1 for _ in range(2, n + 1): a, b = b, a + b return b"},{"question":"from typing import List, Dict def segment_ages(ages: List[int]) -> Dict[str, int]: Segment the list of ages into predefined age groups and return their frequency counts. >>> segment_ages([10, 20, 34, 50, 85, 102, 17, 33, 41]) {'0-18': 2, '19-35': 3, '36-50': 2, '51-100': 1, '100+': 1} >>> segment_ages([1, 5, 75, 120, 35, 19, 45, 50]) {'0-18': 2, '19-35': 2, '36-50': 2, '51-100': 1, '100+': 1}","solution":"from typing import List, Dict def segment_ages(ages: List[int]) -> Dict[str, int]: # Initialize the dictionary with the age group labels and set counts to 0 age_groups = {\\"0-18\\": 0, \\"19-35\\": 0, \\"36-50\\": 0, \\"51-100\\": 0, \\"100+\\": 0} # Iterate through the list of ages and increment the appropriate age group count for age in ages: if 0 <= age <= 18: age_groups[\\"0-18\\"] += 1 elif 19 <= age <= 35: age_groups[\\"19-35\\"] += 1 elif 36 <= age <= 50: age_groups[\\"36-50\\"] += 1 elif 51 <= age <= 100: age_groups[\\"51-100\\"] += 1 elif age > 100: age_groups[\\"100+\\"] += 1 return age_groups"},{"question":"def floyd_warshall(matrix: list[list[float]]) -> list[list[float]]: Perform the Floyd-Warshall algorithm to find the shortest transmission times between all pairs of computers in the network. Args: matrix (list[list[float]]): A square matrix where the value at position (i, j) indicates the direct transmission time between nodes i and j. Returns: list[list[float]]: A matrix with the shortest transmission times between all pairs of nodes. Example: >>> floyd_warshall([ ... [0, 3, float('inf'), 5], ... [2, 0, float('inf'), 4], ... [float('inf'), 1, 0, float('inf')], ... [float('inf'), float('inf'), 2, 0] ... ]) [ [0, 3, 7, 5], [2, 0, 6, 4], [3, 1, 0, 5], [5, 3, 2, 0] ] pass def test_floyd_warshall_example(): network_matrix = [ [0, 3, float('inf'), 5], [2, 0, float('inf'), 4], [float('inf'), 1, 0, float('inf')], [float('inf'), float('inf'), 2, 0] ] expected = [ [0, 3, 7, 5], [2, 0, 6, 4], [3, 1, 0, 5], [5, 3, 2, 0] ] assert floyd_warshall(network_matrix) == expected def test_floyd_warshall_single_node(): network_matrix = [ [0] ] expected = [ [0] ] assert floyd_warshall(network_matrix) == expected def test_floyd_warshall_two_nodes(): network_matrix = [ [0, 1], [float('inf'), 0] ] expected = [ [0, 1], [float('inf'), 0] ] assert floyd_warshall(network_matrix) == expected def test_floyd_warshall_disconnected(): network_matrix = [ [0, float('inf'), 3], [2, 0, float('inf')], [float('inf'), 7, 0] ] expected = [ [0, 10, 3], [2, 0, 5], [9, 7, 0] ] assert floyd_warshall(network_matrix) == expected def test_floyd_warshall_negative_edge_weights(): network_matrix = [ [0, 1, float('inf')], [float('inf'), 0, -1], [2, 2, 0] ] expected = [ [0, 1, 0], [1, 0, -1], [2, 2, 0] ] assert floyd_warshall(network_matrix) == expected","solution":"def floyd_warshall(matrix): Perform the Floyd-Warshall algorithm to find the shortest paths between all pairs of nodes. n = len(matrix) dist = [row[:] for row in matrix] # Create a copy of the matrix for the distances # Floyd-Warshall algorithm for k in range(n): for i in range(n): for j in range(n): if dist[i][j] > dist[i][k] + dist[k][j]: dist[i][j] = dist[i][k] + dist[k][j] return dist"},{"question":"def compress_string(s: str) -> str: Compresses a string by replacing sequences of the same character with the character followed by the number of its repetitions. >>> compress_string(\\"aaabbbccc\\") \\"a3b3c3\\" >>> compress_string(\\"aabccc\\") \\"a2b1c3\\" >>> compress_string(\\"abcd\\") \\"a1b1c1d1\\" >>> compress_string(\\"aaaabbbcccddddd\\") \\"a4b3c3d5\\" pass","solution":"def compress_string(s: str) -> str: Compresses a string by replacing sequences of the same character with the character followed by the number of its repetitions. if not s: return \\"\\" compressed = [] current_char = s[0] count = 1 for char in s[1:]: if char == current_char: count += 1 else: compressed.append(f\\"{current_char}{count}\\") current_char = char count = 1 compressed.append(f\\"{current_char}{count}\\") return \\"\\".join(compressed)"},{"question":"def calculate_restock_amount(current_stock: dict, min_levels: dict) -> dict: Determines the optimal amount of stock to order for different products to meet the required minimum inventory levels. Parameters: - current_stock (dict): A dictionary with the current stock levels of products. - min_levels (dict): A dictionary with the required minimum stock levels for products. Returns: - dict: A dictionary with the amounts to be ordered for each product to restock to its required minimum level. Examples: >>> calculate_restock_amount({'apples': 30, 'bananas': 10, 'carrots': 15}, {'apples': 50, 'bananas': 20, 'carrots': 20}) {'apples': 20, 'bananas': 10, 'carrots': 5} >>> calculate_restock_amount({'bread': 5, 'milk': 7, 'eggs': 14}, {'bread': 10, 'milk': 10, 'eggs': 20}) {'bread': 5, 'milk': 3, 'eggs': 6}","solution":"def calculate_restock_amount(current_stock: dict, min_levels: dict) -> dict: Determines the optimal amount of stock to order for different products to meet the required minimum inventory levels. Parameters: - current_stock (dict): A dictionary with the current stock levels of products. - min_levels (dict): A dictionary with the required minimum stock levels for products. Returns: - dict: A dictionary with the amounts to be ordered for each product to restock to its required minimum level. restock_amount = {} for product, current in current_stock.items(): required_min = min_levels[product] order_amount = max(required_min - current, 0) restock_amount[product] = order_amount return restock_amount"},{"question":"def find_pivot_index(arr: list[int]) -> int: Find the index of the smallest element (pivot) in the rotated sorted array. >>> find_pivot_index([4, 5, 6, 7, 0, 1, 2]) 4 >>> find_pivot_index([12, 15, 18, 2, 3, 6]) 3 >>> find_pivot_index([1]) 0 >>> find_pivot_index([1, 2, 3, 4, 5]) 0 >>> find_pivot_index([5, 1, 2, 3, 4]) 1 def search_in_rotated_array(arr: list[int], target: int) -> int: Search for the target in the rotated sorted array and return its index, or -1 if not found. >>> search_in_rotated_array([4, 5, 6, 7, 0, 1, 2], 0) 4 >>> search_in_rotated_array([4, 5, 6, 7, 0, 1, 2], 3) -1 >>> search_in_rotated_array([12, 15, 18, 2, 3, 6], 15) 1 >>> search_in_rotated_array([12, 15, 18, 2, 3, 6], 6) 5 >>> search_in_rotated_array([1], 1) 0 >>> search_in_rotated_array([1], 0) -1 >>> search_in_rotated_array([5, 1, 2, 3, 4], 1) 1 >>> search_in_rotated_array([5, 1, 2, 3, 4], 5) 0 >>> search_in_rotated_array([1, 2, 3, 4, 5], 5) 4 >>> search_in_rotated_array([1, 2, 3, 4, 5], 0) -1","solution":"def find_pivot_index(arr): Finds the index of the smallest element (pivot) in the rotated sorted array. left, right = 0, len(arr) - 1 while left < right: mid = (left + right) // 2 if arr[mid] > arr[right]: left = mid + 1 else: right = mid return left def search_in_rotated_array(arr, target): Searches for the target in the rotated sorted array and returns its index, or -1 if not found. pivot = find_pivot_index(arr) n = len(arr) def binary_search(left, right): while left <= right: mid = (left + right) // 2 if arr[mid] == target: return mid elif arr[mid] < target: left = mid + 1 else: right = mid - 1 return -1 if target >= arr[pivot] and target <= arr[n - 1]: return binary_search(pivot, n - 1) else: return binary_search(0, pivot - 1)"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def binary_tree_height(root: TreeNode) -> int: Calculate the height of a binary tree. The height of a binary tree is the number of edges on the longest path from the root node to any leaf node. >>> binary_tree_height(None) -1 >>> root = TreeNode(10) >>> binary_tree_height(root) 0 >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> root.left.left = TreeNode(4) >>> root.left.right = TreeNode(5) >>> binary_tree_height(root) 2 >>> root = TreeNode(10) >>> root.left = TreeNode(20) >>> root.right = TreeNode(30) >>> root.right.right = TreeNode(40) >>> root.right.right.left = TreeNode(50) >>> binary_tree_height(root) 3 >>> root = TreeNode(10) >>> root.right = TreeNode(20) >>> binary_tree_height(root) 1 >>> root = TreeNode(1) >>> current_level = [root] >>> for _ in range(4): ... next_level = [] ... for node in current_level: ... node.left = TreeNode(node.val * 2) ... node.right = TreeNode(node.val * 2 + 1) ... next_level.extend([node.left, node.right]) ... current_level = next_level >>> binary_tree_height(root) 4 # Your code goes here pass","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def binary_tree_height(root: TreeNode) -> int: if root is None: return -1 else: left_height = binary_tree_height(root.left) right_height = binary_tree_height(root.right) return max(left_height, right_height) + 1"},{"question":"def convert_to_24_hour_format(time_12hr: str) -> str: Convert the given 12-hour formatted time string to a 24-hour formatted time string. Parameters: time_12hr (str): A string representing the time in 12-hour format with an 'AM' or 'PM' suffix. Returns: str: The converted time in 24-hour format. pass # Example test cases # Example 1 time_12hr = \\"07:05:45PM\\" # Conversion to 24-hour format converted_time = convert_to_24_hour_format(time_12hr) print(converted_time) # Expected output: \\"19:05:45\\" # Example 2 time_12hr = \\"12:00:00AM\\" # Conversion to 24-hour format converted_time = convert_to_24_hour_format(time_12hr) print(converted_time) # Expected output: \\"00:00:00\\"","solution":"def convert_to_24_hour_format(time_12hr: str) -> str: Convert the given 12-hour formatted time string to a 24-hour formatted time string. Parameters: time_12hr (str): A string representing the time in 12-hour format with an 'AM' or 'PM' suffix. Returns: str: The converted time in 24-hour format. period = time_12hr[-2:].upper() hour, minute, second = map(int, time_12hr[:-2].split(':')) if period == 'AM': if hour == 12: hour = 0 # Midnight case (e.g., 12:00:00AM -> 00:00:00) else: # period == 'PM' if hour != 12: hour += 12 # Add 12 to hour (e.g., 1PM -> 13) return f\\"{hour:02}:{minute:02}:{second:02}\\""},{"question":"from typing import Dict, List, Tuple def calculate_shortest_route(connections: Dict[str, List[Tuple[str, int]]], start: str, end: str) -> List[str]: Implement a shortest route calculator for delivery points in a city. Parameters: - connections: Dictionary where the key is a point (str) and the value is a list of tuples representing connected points and the distance (point, distance). - start: Starting delivery point (str). - end: Ending delivery point (str). Returns: - List of points (str) representing the shortest route from start to end. >>> connections = { 'A': [('B', 1), ('C', 4)], 'B': [('A', 1), ('C', 2), ('D', 5)], 'C': [('A', 4), ('B', 2), ('D', 1)], 'D': [('B', 5), ('C', 1)] } >>> calculate_shortest_route(connections, 'A', 'D') ['A', 'B', 'C', 'D'] >>> connections = { 'A': [] } >>> calculate_shortest_route(connections, 'A', 'A') ['A'] >>> connections = { 'A': [('B', 1)], 'B': [('A', 1)], 'C': [('D', 1)], 'D': [('C', 1)] } >>> calculate_shortest_route(connections, 'A', 'D') [] >>> connections = { 'A': [('B', 1)], 'B': [('A', 1)] } >>> calculate_shortest_route(connections, 'A', 'B') ['A', 'B']","solution":"import heapq from typing import Dict, List, Tuple def calculate_shortest_route(connections: Dict[str, List[Tuple[str, int]]], start: str, end: str) -> List[str]: Implement a shortest route calculator for delivery points in a city. Parameters: - connections: Dictionary where the key is a point (str) and the value is a list of tuples representing connected points and the distance (point, distance). - start: Starting delivery point (str). - end: Ending delivery point (str). Returns: - List of points (str) representing the shortest route from start to end. # Priority queue to manage the frontier nodes priority_queue = [(0, start)] # Dictionary to store the shortest distance from start to each node distances = {node: float('infinity') for node in connections} distances[start] = 0 # Dictionary to store the shortest path tree previous_nodes = {node: None for node in connections} while priority_queue: current_distance, current_node = heapq.heappop(priority_queue) if current_node == end: break if current_distance > distances[current_node]: continue for neighbor, weight in connections.get(current_node, []): distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance previous_nodes[neighbor] = current_node heapq.heappush(priority_queue, (distance, neighbor)) # Reconstruct the shortest path from end to start path = [] current_node = end while current_node is not None: path.append(current_node) current_node = previous_nodes[current_node] path.reverse() if path[0] == start: return path else: return []"},{"question":"def is_secure_password(password: str) -> bool: Check if the password meets the criteria. The length of the password should be at least 8 characters and at most 20 characters. The password must contain at least one uppercase letter, one lowercase letter, one digit, and one special character (any character that is not a letter or digit). >>> is_secure_password(\\"A1b!5678\\") True >>> is_secure_password(\\"@bcDEfgh123\\") True >>> is_secure_password(\\"Secure1Password!\\") True >>> is_secure_password(\\"P@ssw0rd123!\\") True >>> is_secure_password(\\"A1b!\\") False >>> is_secure_password(\\"A\\" * 21) False >>> is_secure_password(\\"abc123!@#\\") False >>> is_secure_password(\\"ABC123!@#\\") False >>> is_secure_password(\\"Abcdef!@#\\") False >>> is_secure_password(\\"Abcd1234\\") False >>> is_secure_password(\\"A1b!Cdefg\\") True >>> is_secure_password(\\"1Aa!1Aa!1Aa!1Aa!1Aa!\\") True >>> is_secure_password(\\"Aa1!\\") False >>> is_secure_password(\\"A\\" * 21 + \\"1a!\\") False","solution":"def is_secure_password(password: str) -> bool: if not (8 <= len(password) <= 20): return False has_upper = any(c.isupper() for c in password) has_lower = any(c.islower() for c in password) has_digit = any(c.isdigit() for c in password) has_special = any(not c.isalnum() for c in password) return has_upper and has_lower and has_digit and has_special"},{"question":"def depth_first_search(graph: dict, start_node: str) -> list: Traverse the graph of warehouses using depth-first search (DFS) algorithm starting from the start_node. :param graph: A dictionary where keys are warehouse identifiers and values are lists of adjacent warehouses. :param start_node: The identifier of the starting warehouse. :return: A list of warehouse identifiers representing the reachable warehouses from the start_node in the order visited by DFS. >>> depth_first_search({ ... 'A': ['B', 'C'], ... 'B': ['D'], ... 'C': ['E'], ... 'D': ['F'], ... 'E': [], ... 'F': [] ... }, 'A') ['A', 'B', 'D', 'F', 'C', 'E'] >>> depth_first_search({ ... 'A': [] ... }, 'A') ['A'] >>> depth_first_search({ ... 'A': ['B'], ... 'B': [], ... 'C': ['D'], ... 'D': [] ... }, 'A') ['A', 'B'] >>> depth_first_search({ ... 'A': ['B'], ... 'B': ['C'], ... 'C': ['A', 'D'], ... 'D': ['E'], ... 'E': [] ... }, 'A') ['A', 'B', 'C', 'D', 'E']","solution":"def depth_first_search(graph: dict, start_node: str) -> list: Performs an iterative depth-first search on the graph starting from the start_node. :param graph: A dictionary where keys are warehouse identifiers and values are lists of adjacent warehouses. :param start_node: The identifier of the starting warehouse. :return: A list of warehouse identifiers representing the reachable warehouses in the order they are visited. visited = set() stack = [start_node] result = [] while stack: node = stack.pop() if node not in visited: visited.add(node) result.append(node) # Extend the stack with the adjacent nodes in reverse order to maintain the correct order in DFS stack.extend(reversed(graph.get(node, []))) return result"},{"question":"def find_smallest_non_sum(arr: List[int]) -> int: Given a list of integers, determine the smallest non-negative integer that cannot be represented as the sum of any subset of the given list. Args: arr (List[int]): A list of positive integers. Returns: int: The smallest non-negative integer that cannot be represented as the sum of any subset of the given list. Examples: >>> find_smallest_non_sum([1, 2, 3, 8]) 7 >>> find_smallest_non_sum([12, 1, 61, 5, 9, 2]) 4 # Example test cases def test_example_cases(): assert find_smallest_non_sum([1, 2, 3, 8]) == 7 assert find_smallest_non_sum([12, 1, 61, 5, 9, 2]) == 4 def test_single_element(): assert find_smallest_non_sum([1]) == 2 assert find_smallest_non_sum([10]) == 1 def test_consecutive_elements(): assert find_smallest_non_sum([1, 2, 3, 4, 5]) == 16 def test_large_gaps(): assert find_smallest_non_sum([1, 2, 3, 100]) == 7 assert find_smallest_non_sum([1, 1, 3, 6]) == 12 def test_repeated_elements(): assert find_smallest_non_sum([1, 1, 1, 1]) == 5 assert find_smallest_non_sum([2, 2, 2, 2]) == 1 def test_large_numbers(): assert find_smallest_non_sum([10**9]) == 1 def test_multiple_elements_with_large_sum(): assert find_smallest_non_sum([1, 2, 4, 8, 16, 32, 64, 128, 256, 512]) == 1024","solution":"def find_smallest_non_sum(arr): Returns the smallest non-negative integer that cannot be represented as the sum of any subset of the given list. arr.sort() # Sort the array smallest_non_sum = 1 # Start with the smallest non-negative integer for num in arr: if num > smallest_non_sum: break smallest_non_sum += num return smallest_non_sum"},{"question":"# Rebuild a Binary Tree from Traversals Rebuild a Binary Tree from its inorder and postorder traversals. Implement the function based on the provided description and example: def build_tree(inorder: List[int], postorder: List[int]) -> Optional[TreeNode]: if not inorder or not postorder: return None # The root is the last element of postorder root_val = postorder.pop() root = TreeNode(root_val) # Find the index of the root in inorder traversal inorder_index = inorder.index(root_val) # Recursively build right and left subtrees # Note that we build right subtree first since we are popping from end of postorder root.right = build_tree(inorder[inorder_index+1:], postorder) root.left = build_tree(inorder[:inorder_index], postorder) return root def test_build_tree(): # Helper function to compare tree structures def assert_tree_equals(t1, t2): if not t1 and not t2: return True if not t1 or not t2: return False return (t1.val == t2.val and assert_tree_equals(t1.left, t2.left) and assert_tree_equals(t1.right, t2.right)) # Test case 1 inorder = [9, 3, 15, 20, 7] postorder = [9, 15, 7, 20, 3] expected_tree = TreeNode(3) expected_tree.left = TreeNode(9) expected_tree.right = TreeNode(20) expected_tree.right.left = TreeNode(15) expected_tree.right.right = TreeNode(7) result_tree = build_tree(inorder, postorder) assert assert_tree_equals(result_tree, expected_tree) # Test case 2 (single node) inorder = [1] postorder = [1] expected_tree = TreeNode(1) result_tree = build_tree(inorder, postorder) assert assert_tree_equals(result_tree, expected_tree) # Test case 3 (left-skewed tree) inorder = [3, 2, 1] postorder = [3, 2, 1] expected_tree = TreeNode(1) expected_tree.left = TreeNode(2) expected_tree.left.left = TreeNode(3) result_tree = build_tree(inorder, postorder) assert assert_tree_equals(result_tree, expected_tree) # Test case 4 (right-skewed tree) inorder = [1, 2, 3] postorder = [1, 2, 3] expected_tree = TreeNode(3) expected_tree.left = TreeNode(2) expected_tree.left.left = TreeNode(1) result_tree = build_tree(inorder, postorder) assert assert_tree_equals(result_tree, expected_tree) # Test case 5 (empty tree) inorder = [] postorder = [] expected_tree = None result_tree = build_tree(inorder, postorder) assert result_tree == expected_tree","solution":"from typing import List, Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def build_tree(inorder: List[int], postorder: List[int]) -> Optional[TreeNode]: if not inorder or not postorder: return None # The root is the last element of postorder root_val = postorder.pop() root = TreeNode(root_val) # Find the index of the root in inorder traversal inorder_index = inorder.index(root_val) # Recursively build right and left subtrees # Note that we build right subtree first since we are popping from end of postorder root.right = build_tree(inorder[inorder_index+1:], postorder) root.left = build_tree(inorder[:inorder_index], postorder) return root"},{"question":"def sublist_sum(arr: list[int], start_idx: int, end_idx: int) -> int: Computes the sum of elements in a specific sublist segment of a given list of integers. :param arr: List of integers :param start_idx: Starting index of the sublist (inclusive) :param end_idx: Ending index of the sublist (inclusive) :return: Sum of the specified sublist elements Examples: >>> sublist_sum([1, 2, 3, 4, 5], 1, 3) 9 >>> sublist_sum([-1, -2, -3, -4, -5], 0, 2) -6 >>> sublist_sum([10, 20, 30, 40, 50], 2, 4) 120 >>> sublist_sum([0, 0, 0, 0, 0], 0, 4) 0 >>> sublist_sum([5], 0, 0) 5","solution":"def sublist_sum(arr: list[int], start_idx: int, end_idx: int) -> int: Computes the sum of elements in a specific sublist segment of a given list of integers. :param arr: List of integers :param start_idx: Starting index of the sublist (inclusive) :param end_idx: Ending index of the sublist (inclusive) :return: Sum of the specified sublist elements sublist_sum = 0 for i in range(start_idx, end_idx + 1): sublist_sum += arr[i] return sublist_sum"},{"question":"def longest_increasing_path(matrix: List[List[int]]) -> int: Find the length of the longest increasing path in the given matrix. :param matrix: A 2D list of integers representing the matrix. :return: An integer representing the length of the longest increasing path. >>> longest_increasing_path([ [9, 9, 4], [6, 6, 8], [2, 1, 1] ]) == 4 >>> longest_increasing_path([[1]]) == 1 >>> longest_increasing_path([ [7, 7, 7], [7, 7, 7], [7, 7, 7] ]) == 1 >>> longest_increasing_path([ [1, 2, 3], [6, 5, 4], [7, 8, 9] ]) == 9 >>> longest_increasing_path([ [1, 2, 3, 4, 5], [16, 17, 18, 19, 6], [15, 24, 25, 20, 7], [14, 23, 22, 21, 8], [13, 12, 11, 10, 9] ]) == 25 pass","solution":"def longest_increasing_path(matrix): Find the length of the longest increasing path in the given matrix. :param matrix: A 2D list of integers representing the matrix. :return: An integer representing the length of the longest increasing path. if not matrix or not matrix[0]: return 0 rows, cols = len(matrix), len(matrix[0]) memo = [[-1] * cols for _ in range(rows)] directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] def dfs(x, y): if memo[x][y] != -1: return memo[x][y] max_length = 1 for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < rows and 0 <= ny < cols and matrix[nx][ny] > matrix[x][y]: max_length = max(max_length, 1 + dfs(nx, ny)) memo[x][y] = max_length return max_length max_path = 0 for r in range(rows): for c in range(cols): max_path = max(max_path, dfs(r, c)) return max_path"},{"question":"def fibonacci(n: int) -> int: Calculate the n-th Fibonacci number using an iterative approach with optimized memory usage. Args: n (int): The position in the Fibonacci sequence (where 0 <= n <= 1000000). Returns: int: The n-th Fibonacci number. Examples: >>> fibonacci(0) 0 >>> fibonacci(1) 1 >>> fibonacci(10) 55 >>> fibonacci(20) 6765 >>> fibonacci(50) 12586269025 pass def test_fibonacci_base_cases(): assert fibonacci(0) == 0 assert fibonacci(1) == 1 def test_fibonacci_small_numbers(): assert fibonacci(2) == 1 assert fibonacci(3) == 2 assert fibonacci(4) == 3 assert fibonacci(5) == 5 def test_fibonacci_larger_numbers(): assert fibonacci(10) == 55 assert fibonacci(20) == 6765 assert fibonacci(50) == 12586269025 def test_fibonacci_large_number(): assert fibonacci(100) == 354224848179261915075 def test_fibonacci_large_boundary(): assert fibonacci(1000000) # While we cannot assert the exact value due to its size, the function should not cause memory overflow","solution":"def fibonacci(n: int) -> int: Calculate the n-th Fibonacci number using an iterative approach with optimized memory usage. if n == 0: return 0 elif n == 1: return 1 a, b = 0, 1 for _ in range(2, n + 1): a, b = b, a + b return b"},{"question":"import heapq class PriorityQueue: This class models the behavior of a priority queue where each element has a priority, and the element with the highest priority is dequeued first. If multiple elements have the same priority, the one added first is dequeued first. def __init__(self): Initializes an empty priority queue. pass def enqueue(self, element: Any, priority: int) -> None: Adds an element to the queue with the given priority. Args: element (Any): The element to add. priority (int): The priority of the element. pass def dequeue(self) -> Any: Removes and returns the element with the highest priority. If multiple elements have the same priority, the element that was enqueued first is dequeued first. Returns: Any: The element with the highest priority. pass def peek(self) -> Any: Returns the element with the highest priority without removing it from the queue. Returns: Any: The element with the highest priority. pass def is_empty(self) -> bool: Checks if the priority queue is empty. Returns: bool: \`True\` if the queue is empty, \`False\` otherwise. pass import pytest def test_enqueue_dequeue(): pq = PriorityQueue() pq.enqueue(\\"task1\\", 1) pq.enqueue(\\"task2\\", 2) pq.enqueue(\\"task3\\", 1) assert pq.dequeue() == \\"task2\\" assert pq.dequeue() == \\"task1\\" assert pq.dequeue() == \\"task3\\" def test_peek(): pq = PriorityQueue() pq.enqueue(\\"task1\\", 1) pq.enqueue(\\"task2\\", 2) assert pq.peek() == \\"task2\\" pq.dequeue() assert pq.peek() == \\"task1\\" def test_is_empty(): pq = PriorityQueue() assert pq.is_empty() == True pq.enqueue(\\"task1\\", 1) assert pq.is_empty() == False pq.dequeue() assert pq.is_empty() == True def test_fifo_order_with_same_priority(): pq = PriorityQueue() pq.enqueue(\\"task1\\", 1) pq.enqueue(\\"task2\\", 1) pq.enqueue(\\"task3\\", 1) assert pq.dequeue() == \\"task1\\" assert pq.dequeue() == \\"task2\\" assert pq.dequeue() == \\"task3\\" def test_raise_exception_on_empty_dequeue_and_peek(): pq = PriorityQueue() with pytest.raises(IndexError): pq.dequeue() with pytest.raises(IndexError): pq.peek() if __name__ == \\"__main__\\": pytest.main()","solution":"import heapq class PriorityQueue: def __init__(self): Initializes an empty priority queue. self.counter = 0 # A counter to keep track of order of insertion self.pq = [] # The priority queue implemented as a heap def enqueue(self, element, priority): Adds an element to the queue with the given priority. Args: element (Any): The element to add. priority (int): The priority of the element. # Use a tuple with (-priority) to simulate a max-heap, and use counter to maintain FIFO order for the same priority heapq.heappush(self.pq, (-priority, self.counter, element)) self.counter += 1 def dequeue(self): Removes and returns the element with the highest priority. If multiple elements have the same priority, the element that was enqueued first is dequeued first. Returns: Any: The element with the highest priority. if self.is_empty(): raise IndexError(\\"Cannot dequeue from an empty queue\\") return heapq.heappop(self.pq)[2] def peek(self): Returns the element with the highest priority without removing it from the queue. Returns: Any: The element with the highest priority. if self.is_empty(): raise IndexError(\\"Cannot peek into an empty queue\\") return self.pq[0][2] def is_empty(self): Checks if the priority queue is empty. Returns: bool: \`True\` if the queue is empty, \`False\` otherwise. return len(self.pq) == 0"},{"question":"# Completion Task Implement \`predict_final_score\` function that builds a Decision Tree Regressor model to predict the final exam score based on assignment scores, and determines the optimal maximum depth of the tree using cross-validation. import numpy as np from sklearn.tree import DecisionTreeRegressor from sklearn.model_selection import cross_val_score, train_test_split def predict_final_score(features: np.ndarray, target: np.ndarray, depths: list, cv: int = 5) -> (dict, np.ndarray): Parameters: - features: np.ndarray, Training feature dataset. Shape (n_samples, n_features) - target: np.ndarray, Target values corresponding to the feature dataset. Shape (n_samples,) - depths: list, List of integers representing possible maximum depths of the tree. - cv: int, Number of cross-validation folds. Default is 5. Returns: - dict: Dictionary containing the best depth parameter. - np.ndarray: Array of predictions for the final exam scores using the best model. best_depth = None best_score = float('inf') for depth in depths: model = DecisionTreeRegressor(max_depth=depth) scores = cross_val_score(model, features, target, scoring='neg_mean_squared_error', cv=cv) mean_score = -scores.mean() if mean_score < best_score: best_score = mean_score best_depth = depth best_model = DecisionTreeRegressor(max_depth=best_depth) best_model.fit(features, target) predictions = best_model.predict(features) return {'best_depth': best_depth}, predictions","solution":"import numpy as np from sklearn.tree import DecisionTreeRegressor from sklearn.model_selection import cross_val_score, train_test_split def predict_final_score(features: np.ndarray, target: np.ndarray, depths: list, cv: int = 5) -> (dict, np.ndarray): best_depth = None best_score = float('inf') for depth in depths: model = DecisionTreeRegressor(max_depth=depth) scores = cross_val_score(model, features, target, scoring='neg_mean_squared_error', cv=cv) mean_score = -scores.mean() if mean_score < best_score: best_score = mean_score best_depth = depth best_model = DecisionTreeRegressor(max_depth=best_depth) best_model.fit(features, target) predictions = best_model.predict(features) return {'best_depth': best_depth}, predictions"},{"question":"def longest_word(s: str) -> str: Returns the longest word in the input string s. If there are multiple words with the same maximum length, returns the one that appears first. >>> longest_word(\\"A quick brown fox jumped over the lazy dog.\\") \\"jumped\\" >>> longest_word(\\"To be, or not to be: that is the question.\\") \\"question\\" >>> longest_word(\\"Well, this is a straightforward example!\\") \\"straightforward\\"","solution":"import re def longest_word(s: str) -> str: Returns the longest word in the input string s. If there are multiple words with the same maximum length, returns the one that appears first. # Use regular expression to find all words by splitting on non-word characters words = re.findall(r'bw+b', s) # Initialize variables to track the longest word max_length = 0 longest = \\"\\" # Iterate through words and update the longest word if necessary for word in words: if len(word) > max_length: max_length = len(word) longest = word return longest"},{"question":"def sort_colors(nums: list[int]) -> list[int]: Sorts the input list containing only 0, 1, and 2 in non-decreasing order. >>> sort_colors([2, 0, 2, 1, 1, 0]) [0, 0, 1, 1, 2, 2] >>> sort_colors([1, 0, 2]) [0, 1, 2] >>> sort_colors([0, 0, 0]) [0, 0, 0]","solution":"def sort_colors(nums: list[int]) -> list[int]: Sorts the input list containing only 0, 1, and 2 in non-decreasing order. low, mid, high = 0, 0, len(nums) - 1 while mid <= high: if nums[mid] == 0: nums[low], nums[mid] = nums[mid], nums[low] low += 1 mid += 1 elif nums[mid] == 1: mid += 1 else: nums[mid], nums[high] = nums[high], nums[mid] high -= 1 return nums"},{"question":"def prime_path_sum(grid: List[List[int]]) -> int: Finds the sum of the smallest prime numbers in each row of a grid. Args: grid (List[List[int]]): A 2D list of integers representing the grid. Each integer is between 1 and 10^6 inclusive. Returns: int: The sum of the smallest prime numbers in each row of the grid. If a row contains no prime numbers, include a sum of 0 for that row. >>> prime_path_sum([[2, 3, 4, 5]]) 2 >>> prime_path_sum([[4, 6, 8, 10]]) 0 >>> prime_path_sum([[17, 19, 23, 29]]) 17 >>> prime_path_sum([ ... [2, 4, 6], ... [11, 13, 14], ... [1, 22, 27] ... ]) 13 >>> prime_path_sum([ ... [7, 14, 15], ... [19, 20, 21], ... [1, 4, 6] ... ]) 26 >>> prime_path_sum([ ... [4, 6, 8], ... [10, 12, 14] ... ]) 0 pass","solution":"def prime_path_sum(grid): MAX_VALUE = 10**6 # Sieve of Eratosthenes to find all primes up to MAX_VALUE is_prime = [True] * (MAX_VALUE + 1) is_prime[0] = is_prime[1] = False for i in range(2, int(MAX_VALUE**0.5) + 1): if is_prime[i]: for j in range(i * i, MAX_VALUE + 1, i): is_prime[j] = False def is_prime_number(n): return is_prime[n] total_sum = 0 for row in grid: smallest_prime = float('inf') prime_found = False for num in row: if is_prime_number(num): smallest_prime = min(smallest_prime, num) prime_found = True total_sum += smallest_prime if prime_found else 0 return total_sum"},{"question":"def is_armstrong_number(n: int) -> bool: Determines if the given number \`n\` is an Armstrong number. :param n: Integer, the number to check :return: Boolean, True if \`n\` is an Armstrong number, False otherwise >>> is_armstrong_number(153) == True >>> is_armstrong_number(9474) == True >>> is_armstrong_number(123) == False","solution":"def is_armstrong_number(n: int) -> bool: Determines if the given number \`n\` is an Armstrong number. :param n: Integer, the number to check :return: Boolean, True if \`n\` is an Armstrong number, False otherwise digits = [int(d) for d in str(n)] num_digits = len(digits) sum_of_powers = sum(d ** num_digits for d in digits) return sum_of_powers == n"},{"question":"def find_closest_points(points: list[tuple[int, int]], k: int) -> list[tuple[int, int]]: Finds the \`k\` closest points to the origin (0, 0) using the Euclidean distance. Args: points (list of tuple): List of tuples where each tuple contains two integers representing the (x, y) coordinates of a point. k (int): Number of closest points to find, where 1 ≤ k ≤ len(points). Returns: list of tuple: List of \`k\` tuples, each representing the coordinates of one of the \`k\` closest points to the origin. Examples: >>> find_closest_points([(1, 3), (3, 4), (2, -1)], 2) [(1, 3), (2, -1)] >>> find_closest_points([(1, 1), (2, 2), (3, 3)], 2) [(1, 1), (2, 2)]","solution":"import heapq def euclidean_distance(point): Helper function to calculate the squared Euclidean distance from origin (0, 0). Squared distance is used to avoid floating-point operations and preserve performance. x, y = point return x * x + y * y def find_closest_points(points, k): Finds the k closest points to the origin (0, 0). Parameters: points (list of tuple): List of tuples representing points (x, y) in the 2D plane. k (int): Number of closest points to find. Returns: list of tuple: List of k tuples representing the closest points to the origin. # Create a max heap of size k max_heap = [] for point in points: distance = euclidean_distance(point) if len(max_heap) < k: heapq.heappush(max_heap, (-distance, point)) else: # If the current point is closer than the farthest point in the heap, replace it if -max_heap[0][0] > distance: heapq.heappop(max_heap) heapq.heappush(max_heap, (-distance, point)) # Extract the points from the heap result = [point for (neg_distance, point) in max_heap] return result"},{"question":"import heapq class MedianFinder: A class to calculate the median of values from data streams using two heaps. Methods: - def __init__(self) -> None: Initializes the data structure. - def add_num(self, num: int) -> None: Adds a number from the stream to the data structure. - def find_median(self) -> float: Returns the median of the current numbers in the stream. >>> mf = MedianFinder() >>> mf.add_num(1) >>> mf.add_num(2) >>> mf.find_median() 1.5 >>> mf.add_num(3) >>> mf.find_median() 2.0 def __init__(self) -> None: Initialize two heaps: one max-heap for the lower half and one min-heap for the upper half. In Python, heapq only provides a min-heap, so we use negative values to simulate a max-heap. pass def add_num(self, num: int) -> None: Add a number to the data structure. pass def find_median(self) -> float: Return the median of the current numbers in the data structure. pass # Example usage: mf = MedianFinder() mf.add_num(1) mf.add_num(2) print(mf.find_median()) # Output: 1.5 mf.add_num(3) print(mf.find_median()) # Output: 2.0","solution":"import heapq class MedianFinder: def __init__(self) -> None: Initialize two heaps: one max-heap for the lower half and one min-heap for the upper half. In Python, heapq only provides a min-heap, so we use negative values to simulate a max-heap. self.lower_half = [] # max-heap simulated by pushing negative values self.upper_half = [] # min-heap def add_num(self, num: int) -> None: Add a number to the data structure. # Add to the max-heap (lower half) heapq.heappush(self.lower_half, -num) # Move the largest value from lower_half to upper_half to maintain order property if self.lower_half and self.upper_half and (-self.lower_half[0] > self.upper_half[0]): heapq.heappush(self.upper_half, -heapq.heappop(self.lower_half)) # Balance the heaps: ensure the sizes differ by at most one if len(self.lower_half) > len(self.upper_half) + 1: heapq.heappush(self.upper_half, -heapq.heappop(self.lower_half)) if len(self.upper_half) > len(self.lower_half): heapq.heappush(self.lower_half, -heapq.heappop(self.upper_half)) def find_median(self) -> float: Return the median of the current numbers in the data structure. if len(self.lower_half) > len(self.upper_half): return -self.lower_half[0] else: return (-self.lower_half[0] + self.upper_half[0]) / 2.0"},{"question":"def calculate_fuel_cost(distance: float, fuel_efficiency: float, fuel_price: float) -> float: Calculates the total fuel cost for a trip based on the distance traveled, the vehicle's fuel efficiency, and the price of fuel. Parameters: distance (float): The total distance traveled in kilometers. Must be greater than 0. fuel_efficiency (float): The vehicle's fuel efficiency in kilometers per liter (km/L). Must be greater than 0. fuel_price (float): The price of fuel per liter in the local currency. Must be greater than 0. Returns: float: The total fuel cost for the trip. Examples: >>> calculate_fuel_cost(500, 15, 1.3) 43.33 >>> calculate_fuel_cost(200, 10, 1.5) 30.00 def test_calculate_fuel_cost_normal_cases(): assert abs(calculate_fuel_cost(500, 15, 1.3) - 43.33) < 0.01 assert abs(calculate_fuel_cost(200, 10, 1.5) - 30.00) < 0.01 def test_calculate_fuel_cost_edge_cases(): try: calculate_fuel_cost(0, 15, 1.3) except ValueError as e: assert str(e) == \\"Distance traveled must be > 0\\" try: calculate_fuel_cost(500, 0, 1.3) except ValueError as e: assert str(e) == \\"Fuel efficiency must be > 0\\" try: calculate_fuel_cost(500, 15, 0) except ValueError as e: assert str(e) == \\"Fuel price must be > 0\\" def test_calculate_fuel_cost_minimal_valid_input(): assert abs(calculate_fuel_cost(1, 1, 1) - 1.00) < 0.01 assert abs(calculate_fuel_cost(1, 2, 1) - 0.50) < 0.01 def test_calculate_fuel_cost_high_values(): assert abs(calculate_fuel_cost(1e6, 15, 1.3) - 86666.67) < 0.01 assert abs(calculate_fuel_cost(1e6, 10, 2) - 200000.00) < 0.01","solution":"def calculate_fuel_cost(distance: float, fuel_efficiency: float, fuel_price: float) -> float: Calculates the total fuel cost for a trip based on the distance traveled, the vehicle's fuel efficiency, and the price of fuel. Parameters: distance (float): The total distance traveled in kilometers. Must be greater than 0. fuel_efficiency (float): The vehicle's fuel efficiency in kilometers per liter (km/L). Must be greater than 0. fuel_price (float): The price of fuel per liter in the local currency. Must be greater than 0. Returns: float: The total fuel cost for the trip. if distance <= 0: raise ValueError(\\"Distance traveled must be > 0\\") if fuel_efficiency <= 0: raise ValueError(\\"Fuel efficiency must be > 0\\") if fuel_price <= 0: raise ValueError(\\"Fuel price must be > 0\\") fuel_needed = distance / fuel_efficiency total_cost = fuel_needed * fuel_price return total_cost"},{"question":"def flatten_nested_lists(nested_list: list) -> list: Flattens a nested list of arbitrary depth to a single flat list containing all elements. Params: nested_list (list): A list that may contain integers and/or other lists of integers. Returns: list: A flat list containing all integers from the nested structure, in their original order. Examples: >>> flatten_nested_lists([1, [2, [3, 4]], 5, [[6]], [[[7]]], 8]) [1, 2, 3, 4, 5, 6, 7, 8] >>> flatten_nested_lists([1, [2, 3], 4, [5, [6, 7]], 8]) [1, 2, 3, 4, 5, 6, 7, 8] >>> flatten_nested_lists([]) [] >>> flatten_nested_lists([[[]], [], [1, [2], [], 3], 4, [[[[5]]]], [6, [], [[7], [8]]]]) [1, 2, 3, 4, 5, 6, 7, 8]","solution":"def flatten_nested_lists(nested_list): Flattens a nested list of arbitrary depth to a single flat list containing all elements. Params: nested_list (list): A list that may contain integers and/or other lists of integers. Returns: list: A flat list containing all integers from the nested structure, in their original order. flat_list = [] def flatten(inner_list): for item in inner_list: if isinstance(item, list): flatten(item) else: flat_list.append(item) flatten(nested_list) return flat_list"},{"question":"def recursive_merge_sort(arr: list[int]) -> list[int]: Implement a recursive merge sort algorithm to sort a list of integers in ascending order. >>> recursive_merge_sort([3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5]) [1, 1, 2, 3, 3, 4, 5, 5, 5, 6, 9] >>> recursive_merge_sort([]) [] >>> recursive_merge_sort([1]) [1] >>> recursive_merge_sort([5, 4, 3, 2, 1]) [1, 2, 3, 4, 5] >>> recursive_merge_sort([-1, -3, -2, -5, -4]) [-5, -4, -3, -2, -1]","solution":"def recursive_merge_sort(arr: list[int]) -> list[int]: if len(arr) <= 1: return arr mid = len(arr) // 2 left_half = recursive_merge_sort(arr[:mid]) right_half = recursive_merge_sort(arr[mid:]) return merge(left_half, right_half) def merge(left: list[int], right: list[int]) -> list[int]: sorted_arr = [] i = j = 0 while i < len(left) and j < len(right): if left[i] < right[j]: sorted_arr.append(left[i]) i += 1 else: sorted_arr.append(right[j]) j += 1 sorted_arr.extend(left[i:]) sorted_arr.extend(right[j:]) return sorted_arr"},{"question":"def is_robot_stable(roll: float, pitch: float, yaw: float) -> bool: Determines if the robot is stable based on the provided Euler angles. Args: roll (float): The roll angle (in degrees) between -360 and 360. pitch (float): The pitch angle (in degrees) between -360 and 360. yaw (float): The yaw angle (in degrees) between -360 and 360. Returns: bool: True if the robot is stable, False otherwise. Examples: >>> is_robot_stable(10.0, 20.0, 15.0) True >>> is_robot_stable(35.0, 20.0, 15.0) False >>> is_robot_stable(-15.0, -20.0, -30.0) True >>> is_robot_stable(10.0, 45.0, 30.0) False","solution":"def is_robot_stable(roll: float, pitch: float, yaw: float) -> bool: Determines if the robot is stable based on the provided Euler angles. Args: roll (float): The roll angle (in degrees) between -360 and 360. pitch (float): The pitch angle (in degrees) between -360 and 360. yaw (float): The yaw angle (in degrees) between -360 and 360. Returns: bool: True if the robot is stable, False otherwise. return abs(roll) <= 30 and abs(pitch) <= 30 and abs(yaw) <= 30"},{"question":"from typing import List def convert_to_snake_case(identifiers: List[str]) -> List[str]: Convert a list of identifiers to snake_case. Args: identifiers (List[str]): A list of string identifiers to be converted. Returns: List[str]: A list of identifiers in snake_case. Examples: >>> convert_to_snake_case([\\"HelloWorld\\", \\"convert-To_Snake_Case\\", \\"example Identifier\\"]) ['hello_world', 'convert_to_snake_case', 'example_identifier'] >>> convert_to_snake_case([\\"testCase\\", \\"Snake-Case\\", \\"ANOTHER Example\\"]) ['test_case', 'snake_case', 'another_example'] >>> convert_to_snake_case([\\"simpletest\\"]) ['simpletest'] >>> convert_to_snake_case([]) []","solution":"from typing import List import re def convert_to_snake_case(identifiers: List[str]) -> List[str]: Converts a list of identifiers to snake_case. Args: identifiers (List[str]): A list of string identifiers to be converted. Returns: List[str]: A list of identifiers in snake_case. snake_case_identifiers = [] for identifier in identifiers: # Replace spaces or hyphens with underscores and convert to lowercase snake_case_identifier = re.sub(r'[s-]', '_', identifier).lower() snake_case_identifiers.append(snake_case_identifier) return snake_case_identifiers"},{"question":"import math def rotate_points(points: list[list[float]], angle_degrees: float) -> list[list[float]]: Rotate a list of 2D points by a given angle in degrees. Parameters: points (list of list of floats): The original points to rotate, each point represented as [x, y]. angle_degrees (float): The angle by which to rotate the points, in degrees. Returns: list of list of floats: The rotated points, with each point rounded to 3 decimal places. >>> rotate_points([[1.0, 0.0], [0.0, 1.0], [1.0, 1.0]], 90) [[0.0, 1.0], [-1.0, 0.0], [-1.0, 1.0]] >>> rotate_points([[2.0, 2.0], [3.0, 4.0], [5.0, 7.0]], 45) [[0.0, 2.828], [-0.707, 4.95], [-1.414, 8.485]] >>> rotate_points([[1.0, 0.0], [0.0, 1.0], [1.0, 1.0]], -90) [[0.0, -1.0], [1.0, 0.0], [1.0, -1.0]] >>> rotate_points([[3.0, 4.0], [1.0, 2.0], [5.0, 6.0]], 360) [[3.0, 4.0], [1.0, 2.0], [5.0, 6.0]] >>> rotate_points([[1.5, 2.5], [-3.0, 4.0], [5.0, -6.0]], 180) [[-1.5, -2.5], [3.0, -4.0], [-5.0, 6.0]]","solution":"import math def rotate_points(points: list[list[float]], angle_degrees: float) -> list[list[float]]: Rotate a list of 2D points by a given angle in degrees. Parameters: points (list of list of floats): The original points to rotate, each point represented as [x, y]. angle_degrees (float): The angle by which to rotate the points, in degrees. Returns: list of list of floats: The rotated points, with each point rounded to 3 decimal places. angle_radians = math.radians(angle_degrees) cos_theta = math.cos(angle_radians) sin_theta = math.sin(angle_radians) rotated_points = [] for x, y in points: new_x = cos_theta * x - sin_theta * y new_y = sin_theta * x + cos_theta * y rotated_points.append([round(new_x, 3), round(new_y, 3)]) return rotated_points"},{"question":"def weekly_summary(transactions: list[tuple[int, int]]) -> list[int]: Summarizes the transactions for each day of the week. Args: transactions: A list of tuples where each tuple contains: - day: integer (0 to 6) representing the day of the week - amount: integer representing the transaction amount Returns: list[int]: A list of total amounts for each day of the week (Sunday to Saturday). Examples: >>> weekly_summary([(0, 100), (2, 50), (2, 25), (6, 300), (0, 75)]) [175, 0, 75, 0, 0, 0, 300] >>> weekly_summary([(1, 200), (4, 150), (5, 50), (1, 10), (3, 5), (6, 0)]) [0, 210, 0, 5, 150, 50, 0] >>> weekly_summary([(0, 0), (0, 0), (0, 0)]) [0, 0, 0, 0, 0, 0, 0] >>> weekly_summary([]) [0, 0, 0, 0, 0, 0, 0]","solution":"def weekly_summary(transactions): Summarizes the transactions for each day of the week. Args: transactions: A list of tuples where each tuple contains: - day: integer (0 to 6) representing the day of the week - amount: integer representing the transaction amount Returns: list[int]: A list of total amounts for each day of the week (Sunday to Saturday). summary = [0] * 7 for day, amount in transactions: summary[day] += amount return summary"},{"question":"from typing import List import heapq def shortest_path(grid: List[List[int]]) -> int: Find the shortest path in a weighted grid using Dijkstra's algorithm. >>> grid = [ ... [1, 3, 1], ... [1, 5, 1], ... [4, 2, 1] ... ] >>> shortest_path(grid) 7 >>> grid = [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ] >>> shortest_path(grid) 21 >>> grid = [ ... [0] ... ] >>> shortest_path(grid) 0 >>> grid = [ ... [1, 2, 3, 4] ... ] >>> shortest_path(grid) 10 >>> grid = [ ... [1], ... [2], ... [3], ... [4] ... ] >>> shortest_path(grid) 10 >>> grid = [ ... [1, 3, 2, 8], ... [2, 8, 1, 5], ... [3, 2, 2, 2], ... [5, 8, 1, 1] ... ] >>> shortest_path(grid) 11","solution":"import heapq from typing import List def shortest_path(grid: List[List[int]]) -> int: Find the shortest path in a weighted grid using Dijkstra's algorithm. rows, cols = len(grid), len(grid[0]) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] # Min-heap priority queue to store (cost, x, y) min_heap = [(grid[0][0], 0, 0)] # Distance (cost) array initialized to infinity dist = [[float('inf')] * cols for _ in range(rows)] dist[0][0] = grid[0][0] while min_heap: current_cost, x, y = heapq.heappop(min_heap) # If we reached the bottom-right corner, return the cost if x == rows - 1 and y == cols - 1: return current_cost # Explore all possible directions for dx, dy in directions: new_x, new_y = x + dx, y + dy if 0 <= new_x < rows and 0 <= new_y < cols: new_cost = current_cost + grid[new_x][new_y] if new_cost < dist[new_x][new_y]: dist[new_x][new_y] = new_cost heapq.heappush(min_heap, (new_cost, new_x, new_y)) return dist[rows - 1][cols - 1]"},{"question":"from typing import List def fibonacci_sequence(n: int) -> List[int]: Returns the first n terms of the Fibonacci sequence. >>> fibonacci_sequence(1) [0] >>> fibonacci_sequence(2) [0, 1] >>> fibonacci_sequence(10) [0, 1, 1, 2, 3, 5, 8, 13, 21, 34] pass # Implement the function def arithmetic_progression_sum(a: int, d: int, n: int) -> int: Returns the sum of the first n terms of an arithmetic progression with the first term a and common difference d. >>> arithmetic_progression_sum(1, 1, 1) 1 >>> arithmetic_progression_sum(1, 1, 2) 3 >>> arithmetic_progression_sum(1, 3, 5) 35 >>> arithmetic_progression_sum(0, 5, 4) 30 pass # Implement the function","solution":"from typing import List def fibonacci_sequence(n: int) -> List[int]: Returns the first n terms of the Fibonacci sequence. if n <= 0: return [] elif n == 1: return [0] result = [0, 1] while len(result) < n: result.append(result[-1] + result[-2]) return result def arithmetic_progression_sum(a: int, d: int, n: int) -> int: Returns the sum of the first n terms of an arithmetic progression with the first term a and common difference d. return n * (2 * a + (n - 1) * d) // 2"},{"question":"def aggregate_sales(records: list) -> list: Aggregates total sales by product. :param records: List of dictionaries containing sales records. Each record has keys 'product' (string) and 'amount' (float). :return: A sorted list of tuples in the format (product, total_sales). >>> aggregate_sales([{'product': 'apple', 'amount': 10.0}, {'product': 'banana', 'amount': 5.5}, {'product': 'apple', 'amount': 3.0}]) [('apple', 13.0), ('banana', 5.5)] >>> aggregate_sales([]) [] >>> aggregate_sales([{'product': 'apple', 'amount': 10.0}]) [('apple', 10.0)] >>> aggregate_sales([{'product': 'banana', 'amount': 2.0}, {'product': 'banana', 'amount': 3.0}, {'product': 'apple', 'amount': 8.0}]) [('apple', 8.0), ('banana', 5.0)] >>> aggregate_sales([{'product': 'banana', 'amount': 0.0}, {'product': 'apple', 'amount': 0.0}]) [('apple', 0.0), ('banana', 0.0)] # Your implementation here","solution":"def aggregate_sales(records): Aggregates total sales by product. :param records: List of dictionaries containing sales records. Each record has keys 'product' (string) and 'amount' (float). :return: A sorted list of tuples in the format (product, total_sales). from collections import defaultdict sales_dict = defaultdict(float) for record in records: product = record['product'] amount = record['amount'] sales_dict[product] += amount # Converting the dictionary to a sorted list of tuples sorted_sales = sorted(sales_dict.items()) return sorted_sales"},{"question":"import os import re def clean_and_merge_articles(article_dir: str, output_file: str, banned_words: list) -> None: Clean up user-submitted articles by removing HTML tags, special characters, and banned words, and then merge all cleaned articles into a single document. Args: article_dir (str): Path to the directory containing article files. output_file (str): Path to the file where the merged articles should be saved. banned_words (list): List of banned words that need to be removed from the articles. >>> import tempfile, os >>> with tempfile.TemporaryDirectory() as temp_dir: ... file1_path = os.path.join(temp_dir, \\"article1.txt\\") ... file2_path = os.path.join(temp_dir, \\"article2.txt\\") ... output_path = os.path.join(temp_dir, \\"merged_output.txt\\") ... with open(file1_path, 'w', encoding='utf-8') as file1: ... file1.write('This is an <b>example</b> article with a bannedword1.nSpecial characters: @#*!&') ... with open(file2_path, 'w', encoding='utf-8') as file2: ... file2.write('Another <p>example</p> article with BANNEDWORD2.nSpecial characters: ^^&&**') ... banned_words = ['bannedword1', 'BANNEDWORD2'] ... clean_and_merge_articles(temp_dir, output_path, banned_words) ... with open(output_path, 'r', encoding='utf-8') as output_file: ... print(output_file.read()) This is an example article with a Special characters Another example article with Special characters pass if __name__ == \\"__main__\\": import os import tempfile def test_clean_and_merge_articles(): # Create temporary directory and files with tempfile.TemporaryDirectory() as temp_dir: file1_path = os.path.join(temp_dir, \\"article1.txt\\") file2_path = os.path.join(temp_dir, \\"article2.txt\\") output_path = os.path.join(temp_dir, \\"merged_output.txt\\") with open(file1_path, 'w', encoding='utf-8') as file1: file1.write('This is an <b>example</b> article with a bannedword1.nSpecial characters: @#*!&') with open(file2_path, 'w', encoding='utf-8') as file2: file2.write('Another <p>example</p> article with BANNEDWORD2.nSpecial characters: ^^&&**') banned_words = ['bannedword1', 'BANNEDWORD2'] # Run the function clean_and_merge_articles(temp_dir, output_path, banned_words) # Verify the output with open(output_path, 'r', encoding='utf-8') as output_file: result = output_file.read() expected_output = 'This is an example article with a nSpecial characters nAnother example article with nSpecial characters ' assert result == expected_output, f\\"Expected: {expected_output}, but got: {result}\\" test_clean_and_merge_articles()","solution":"import os import re def clean_html_tags(text): Remove HTML tags from text cleanr = re.compile('<.*?>') return re.sub(cleanr, '', text) def clean_special_characters(text): Remove special characters, keeping only alphanumeric and whitespace return re.sub(r'[^A-Za-z0-9s]', '', text) def remove_banned_words(text, banned_words): Remove banned words from text for word in banned_words: text = re.sub(r'b' + re.escape(word) + r'b', '', text, flags=re.IGNORECASE) return text def clean_and_merge_articles(article_dir, output_file, banned_words): articles = [] # Reading files and cleaning the contents for filename in sorted(os.listdir(article_dir)): if filename.endswith('.txt'): filepath = os.path.join(article_dir, filename) # Read article file with open(filepath, 'r', encoding='utf-8') as file: content = file.read() # Clean content content = clean_html_tags(content) content = clean_special_characters(content) content = remove_banned_words(content, banned_words) articles.append(content) # Merging cleaned articles into a single file merged_content = 'n'.join(articles) # Write merged content to the output file with open(output_file, 'w', encoding='utf-8') as file: file.write(merged_content)"},{"question":"def find_duplicate_number(numbers: List[int]) -> int: Finds and returns the duplicate number in the list of integers. >>> find_duplicate_number([1, 3, 4, 2, 2]) 2 >>> find_duplicate_number([3, 1, 3, 4, 2]) 3 >>> find_duplicate_number([1, 1]) 1 >>> find_duplicate_number([1, 2, 3, 4, 5, 6, 6, 7]) 6","solution":"from typing import List def find_duplicate_number(numbers: List[int]) -> int: Finds and returns the duplicate number in the list of integers. # Using Floyd's Tortoise and Hare (Cycle Detection) algorithm slow = numbers[0] fast = numbers[0] # Phase 1: Finding the intersection point in the cycle while True: slow = numbers[slow] fast = numbers[numbers[fast]] if slow == fast: break # Phase 2: Finding the entrance of the cycle (duplicate element) slow = numbers[0] while slow != fast: slow = numbers[slow] fast = numbers[fast] return slow"},{"question":"def merge_sort(sequence: list, start: int | None = None, end: int | None = None) -> None: Implements the Merge Sort algorithm to sort a list of integers. >>> seq = [10, 2, 3, 7, 6] >>> merge_sort(seq) >>> seq [2, 3, 6, 7, 10] >>> seq = [8, 7, 6, 5, 4, 3] >>> merge_sort(seq, 1, 4) >>> seq [8, 4, 5, 6, 7, 3] >>> seq = [7, 6, 5, 4, 3, 2, 1] >>> merge_sort(seq, start=3) >>> seq [7, 6, 5, 1, 2, 3, 4]","solution":"def merge_sort(sequence, start=None, end=None): Implements the Merge Sort algorithm to sort a list of integers in place. Parameters: - sequence (list): The list to be sorted. - start (int, optional): The starting index of the list portion to sort. Defaults to 0. - end (int, optional): The ending index of the list portion to sort. Defaults to the list's last index. if start is None: start = 0 if end is None: end = len(sequence) - 1 if start < end: # Find the middle point mid = (start + end) // 2 # Recursively sort the first and second halves merge_sort(sequence, start, mid) merge_sort(sequence, mid + 1, end) # Merge the sorted halves merge(sequence, start, mid, end) def merge(sequence, start, mid, end): Merges two halves of a list in sorted order. Parameters: - sequence (list): The list containing the two halves. - start (int): The starting index of the first half. - mid (int): The ending index of the first half (midpoint). - end (int): The ending index of the second half. # Create temporary arrays for the two halves left = sequence[start:mid + 1] right = sequence[mid + 1:end + 1] # Initial indices for the two halves i = 0 j = 0 # Initial index of merged array k = start # Merge the temporary arrays back into sequence while i < len(left) and j < len(right): if left[i] <= right[j]: sequence[k] = left[i] i += 1 else: sequence[k] = right[j] j += 1 k += 1 # Copy the remaining elements of left[], if there are any while i < len(left): sequence[k] = left[i] i += 1 k += 1 # Copy the remaining elements of right[], if there are any while j < len(right): sequence[k] = right[j] j += 1 k += 1"},{"question":"class TrieNode: A class representing a node in a Trie. Attributes ---------- children : dict A dictionary where the keys are characters and values are TrieNode objects. word_end : bool A boolean indicating if the node marks the end of a valid word. def __init__(self): self.children = {} self.word_end = False class Trie: A class representing a Trie data structure for storing words. Methods ------- insert(word: str) -> None: Adds a word to the Trie. search_with_prefix(prefix: str) -> list[str]: Searches for all words in the Trie that start with the specified prefix. def __init__(self): self.root = TrieNode() def insert(self, word: str) -> None: Adds a word to the Trie. Parameters ---------- word : str A string representing the word to add to the Trie. pass def search_with_prefix(self, prefix: str) -> list[str]: Searches for all words in the Trie that start with the specified prefix. Parameters ---------- prefix : str A string representing the prefix to search for. Returns ------- list[str] A list of strings representing words that start with the given prefix. Examples -------- >>> trie = Trie() >>> trie.insert(\\"apple\\") >>> trie.insert(\\"apples\\") >>> trie.insert(\\"apricot\\") >>> trie.insert(\\"banana\\") >>> trie.search_with_prefix(\\"app\\") [\\"apple\\", \\"apples\\"] >>> trie.search_with_prefix(\\"ban\\") [\\"banana\\"] pass","solution":"class TrieNode: def __init__(self): self.children = {} self.word_end = False class Trie: def __init__(self): self.root = TrieNode() def insert(self, word: str) -> None: node = self.root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.word_end = True def _find_prefix_node(self, prefix: str) -> TrieNode: node = self.root for char in prefix: if char in node.children: node = node.children[char] else: return None return node def _collect_words(self, node: TrieNode, prefix: str, words: list) -> None: if node.word_end: words.append(prefix) for char, child_node in node.children.items(): self._collect_words(child_node, prefix + char, words) def search_with_prefix(self, prefix: str) -> list[str]: words = [] prefix_node = self._find_prefix_node(prefix) if prefix_node: self._collect_words(prefix_node, prefix, words) return words"},{"question":"class Page: def __init__(self, content): self.content = content class Document: def __init__(self): self.pages = [] def add_page(self, page: Page, position: int = None): Add a page at a specified position. If no position is specified, add at the end. >>> document = Document() >>> page1 = Page(\\"Page 1 content\\") >>> document.add_page(page1) >>> document.get_page(0).content 'Page 1 content' >>> page2 = Page(\\"Page 2 content\\") >>> document.add_page(page2, 0) >>> document.get_page(0).content 'Page 2 content' >>> document.get_page(1).content 'Page 1 content' # Implement addition logic def get_page(self, position: int) -> Page: Retrieve the page at the specified position. >>> document = Document() >>> page1 = Page(\\"Page 1 content\\") >>> document.add_page(page1) >>> document.get_page(0).content 'Page 1 content' >>> document.get_page(1) Traceback (most recent call last): ... IndexError: Invalid position # Implement retrieval logic and handle invalid positions def remove_page(self, position: int): Remove the page at the specified position. >>> document = Document() >>> page1 = Page(\\"Page 1 content\\") >>> document.add_page(page1) >>> document.remove_page(0) >>> document.get_page(0) Traceback (most recent call last): ... IndexError: Invalid position # Implement removal logic and handle invalid positions","solution":"class Page: def __init__(self, content): self.content = content class Document: def __init__(self): self.pages = [] def add_page(self, page: Page, position: int = None): if position is None: self.pages.append(page) else: if position < 0 or position > len(self.pages): raise IndexError(\\"Invalid position\\") self.pages.insert(position, page) def get_page(self, position: int) -> Page: if position < 0 or position >= len(self.pages): raise IndexError(\\"Invalid position\\") return self.pages[position] def remove_page(self, position: int): if position < 0 or position >= len(self.pages): raise IndexError(\\"Invalid position\\") del self.pages[position]"},{"question":"from datetime import datetime class TaskManager: A class to manage time-sensitive tasks with deadlines and priorities. def __init__(self): self.tasks = [] # List to store tasks as dictionaries with keys: name, deadline, priority def add_task(self, name: str, deadline: datetime, priority: int) -> None: Adds a Task with a specified name, deadline, and priority. Args: name (str): The name of the task. deadline (datetime): The deadline of the task. priority (int): The priority of the task, ranging from 1 (highest) to 10 (lowest). pass def remove_task(self, name: str) -> None: Removes a Task based on its name. Args: name (str): The name of the task to remove. pass def get_next_task(self) -> dict: Returns the most urgent Task as a dictionary with keys: name, deadline, and priority. Returns: dict: The most urgent task. pass def update_priorities(self) -> None: Updates priority values for all tasks based on their proximity to deadlines. pass # Sample test cases from datetime import datetime, timedelta def test_add_task(): manager = TaskManager() manager.add_task(\\"Test Task\\", datetime.now() + timedelta(days=2), 5) assert len(manager.tasks) == 1 assert manager.tasks[0]['name'] == \\"Test Task\\" assert manager.tasks[0]['priority'] == 5 def test_add_task_in_past(): manager = TaskManager() try: manager.add_task(\\"Past Task\\", datetime.now() - timedelta(days=1), 5) except ValueError: assert len(manager.tasks) == 0 def test_add_task_duplicate_name(): manager = TaskManager() manager.add_task(\\"Test Task\\", datetime.now() + timedelta(days=1), 5) try: manager.add_task(\\"Test Task\\", datetime.now() + timedelta(days=2), 3) except ValueError: assert len(manager.tasks) == 1 def test_remove_task(): manager = TaskManager() manager.add_task(\\"Task to Remove\\", datetime.now() + timedelta(days=3), 6) manager.remove_task(\\"Task to Remove\\") assert len(manager.tasks) == 0 def test_get_next_task_by_priority(): manager = TaskManager() manager.add_task(\\"Task 1\\", datetime.now() + timedelta(days=5), 5) manager.add_task(\\"Task 2\\", datetime.now() + timedelta(days=4), 1) manager.add_task(\\"Task 3\\", datetime.now() + timedelta(days=2), 3) next_task = manager.get_next_task() assert next_task['name'] == \\"Task 2\\" # Highest priority task def test_update_priorities(): manager = TaskManager() manager.add_task(\\"Task 1\\", datetime.now() + timedelta(hours=5), 7) manager.add_task(\\"Task 2\\", datetime.now() + timedelta(hours=50), 5) manager.update_priorities() assert manager.tasks[0]['priority'] == 1 # Task 1 should now have highest priority def test_task_sorting(): manager = TaskManager() manager.add_task(\\"Task 1\\", datetime.now() + timedelta(days=7), 5) manager.add_task(\\"Task 2\\", datetime.now() + timedelta(days=6), 6) manager.add_task(\\"Task 3\\", datetime.now() + timedelta(days=1), 3) next_task = manager.get_next_task() assert next_task['name'] == \\"Task 3\\" # Task close to deadline should be prioritized def test_task_no_duplicate_name(): manager = TaskManager() manager.add_task(\\"Task 1\\", datetime.now() + timedelta(days=5), 4) try: manager.add_task(\\"Task 1\\", datetime.now() + timedelta(days=10), 6) except ValueError: pass assert len(manager.tasks) == 1 # Duplicate task should not be added","solution":"from datetime import datetime, timedelta class TaskManager: def __init__(self): self.tasks = [] # List to store tasks as dictionaries with keys: name, deadline, priority def add_task(self, name: str, deadline: datetime, priority: int) -> None: # Check that the deadline is not in the past if deadline < datetime.now(): raise ValueError(\\"The deadline should be in the future\\") # Check for duplicate task names if any(task['name'] == name for task in self.tasks): raise ValueError(\\"A task with this name already exists\\") # Add the task to the list self.tasks.append({'name': name, 'deadline': deadline, 'priority': priority}) def remove_task(self, name: str) -> None: self.tasks = [task for task in self.tasks if task['name'] != name] def get_next_task(self) -> dict: self.update_priorities() # Sort the tasks first by priority, then by deadline sorted_tasks = sorted(self.tasks, key=lambda x: (x['priority'], x['deadline'])) return sorted_tasks[0] if sorted_tasks else None def update_priorities(self) -> None: current_time = datetime.now() for task in self.tasks: time_remaining = (task['deadline'] - current_time).total_seconds() # Prioritize tasks near their deadlines (within 1 day) by setting higher priority if time_remaining < 24 * 60 * 60: # less than 1 day remaining task['priority'] = 1 elif time_remaining < 2 * 24 * 60 * 60: # 1 to 2 days remaining task['priority'] = min(2, task['priority']) elif time_remaining < 3 * 24 * 60 * 60: # 2 to 3 days remaining task['priority'] = min(3, task['priority']) else: # The farther the deadline, the lower the priority becomes; normalize between 4 and 10 days_remaining = time_remaining // (24 * 60 * 60) task['priority'] = min(max(4, 10 - int(days_remaining)), task['priority'])"},{"question":"from typing import List def normalize_data(data: List[float]) -> List[float]: Normalize a list of numerical values to the range [0, 1]. >>> normalize_data([100, 200, 300, 400, 500]) [0.0, 0.25, 0.5, 0.75, 1.0] >>> normalize_data([-100, -50, 0, 50, 100]) [0.0, 0.25, 0.5, 0.75, 1.0] >>> normalize_data([-100, 0, 100]) [0.0, 0.5, 1.0] >>> normalize_data([5, 5, 5]) [0.0, 0.0, 0.0] >>> normalize_data([3, 7]) [0.0, 1.0]","solution":"from typing import List def normalize_data(data: List[float]) -> List[float]: min_val = min(data) max_val = max(data) if min_val == max_val: # If all values in the data are the same, return 0 for each. return [0.0] * len(data) normalized_data = [(x - min_val) / (max_val - min_val) for x in data] return normalized_data"},{"question":"import requests USER_DETAILS_ENDPOINT = \\"http://example.com/api/users\\" def get_user_details(user_id): try: response = requests.get(f\\"{USER_DETAILS_ENDPOINT}/{user_id}\\") response.raise_for_status() return response.json() except requests.exceptions.Timeout: return {\\"status\\": \\"error\\", \\"message\\": \\"Request timed out\\"} except requests.exceptions.RequestException as e: return {\\"status\\": \\"error\\", \\"message\\": str(e)} def test_get_user_details(monkeypatch): class FakeResponse: def __init__(self, json_data, status_code): self.json_data = json_data self.status_code = status_code def json(self): return self.json_data def raise_for_status(self): if self.status_code != 200: raise requests.exceptions.RequestException(self.json_data[\\"message\\"]) def mock_get(url): if \\"timeout\\" in url: raise requests.exceptions.Timeout elif \\"invalid\\" in url: return FakeResponse({\\"status\\":\\"error\\",\\"message\\":\\"Invalid user\\"}, 400) else: return FakeResponse({\\"status\\":\\"success\\",\\"user\\":{\\"id\\":123,\\"name\\":\\"Alice\\"}}, 200) monkeypatch.setattr(requests, \\"get\\", mock_get) # Test successful data retrieval response = get_user_details(\\"123\\") assert response[\\"status\\"] == \\"success\\" assert response[\\"user\\"][\\"name\\"] == \\"Alice\\" # Test invalid data response response = get_user_details(\\"invalid\\") assert response[\\"status\\"] == \\"error\\" assert response[\\"message\\"] == \\"Invalid user\\" # Test request timeout response = get_user_details(\\"timeout\\") assert response[\\"status\\"] == \\"error\\" assert response[\\"message\\"] == \\"Request timed out\\"","solution":"import requests USER_DETAILS_ENDPOINT = \\"http://example.com/api/users\\" def get_user_details(user_id): try: response = requests.get(f\\"{USER_DETAILS_ENDPOINT}/{user_id}\\") response.raise_for_status() return response.json() except requests.exceptions.Timeout: return {\\"status\\": \\"error\\", \\"message\\": \\"Request timed out\\"} except requests.exceptions.RequestException as e: return {\\"status\\": \\"error\\", \\"message\\": str(e)}"},{"question":"import csv def process_fruit_data(file_path: str) -> list[dict]: Reads and processes fruit data from a CSV file with semicolon-separated values. Returns a list of dictionaries where each dictionary represents a single fruit and its properties. >>> file_path = 'path/to/fruits.csv' >>> process_fruit_data(file_path) [{'Name': 'Apple', 'Color': 'Red', 'Weight(g)': 150, 'Price()': 0.50}, {'Name': 'Banana', 'Color': 'Yellow', 'Weight(g)': 120, 'Price()': 0.30}, {'Name': 'Cherry', 'Color': 'Red', 'Weight(g)': 10, 'Price()': 0.20}]","solution":"import csv def process_fruit_data(file_path: str) -> list[dict]: Reads and processes fruit data from a CSV file with semicolon-separated values. Returns a list of dictionaries where each dictionary represents a single fruit and its properties. fruits = [] try: with open(file_path, mode='r', encoding='utf-8') as file: reader = csv.DictReader(file, delimiter=';') for row in reader: fruit = { 'Name': row['Name'], 'Color': row['Color'], 'Weight(g)': int(row['Weight(g)']), 'Price()': float(row['Price()']) } fruits.append(fruit) except FileNotFoundError: print(f\\"Error: The file {file_path} does not exist.\\") except Exception as e: print(f\\"An error occurred: {e}\\") return fruits"},{"question":"from typing import Tuple class Inventory: A class to manage a dynamic inventory system where products can be added, removed, and queried. Methods: - add_product(self, product_id: str, quantity: int, price: int) -> None: Adds the specified quantity of a product with the given price to the inventory. If the product already exists, update its quantity and price. - remove_product(self, product_id: str, quantity: int) -> bool: Removes the specified quantity of the product from the inventory. If the product does not exist or there is insufficient quantity, return False. Otherwise, return True. - get_total_value(self) -> int: Returns the total value of all products in the inventory (total quantity * price for each product). - get_product_info(self, product_id: str) -> Tuple[int, int]: Returns a tuple of the quantity and price of the specified product. If the product does not exist, return (0, 0). def __init__(self): pass def add_product(self, product_id: str, quantity: int, price: int) -> None: pass def remove_product(self, product_id: str, quantity: int) -> bool: pass def get_total_value(self) -> int: pass def get_product_info(self, product_id: str) -> Tuple[int, int]: pass # Unit tests def test_add_and_get_product_info(): inventory = Inventory() inventory.add_product('apple', 50, 2) inventory.add_product('banana', 30, 1) assert inventory.get_product_info('apple') == (50, 2) assert inventory.get_product_info('banana') == (30, 1) inventory.add_product('apple', 20, 3) assert inventory.get_product_info('apple') == (70, 3) assert inventory.get_product_info('nonexistent') == (0, 0) def test_remove_product(): inventory = Inventory() inventory.add_product('apple', 50, 2) inventory.add_product('banana', 30, 1) assert inventory.remove_product('banana', 10) == True assert inventory.get_product_info('banana') == (20, 1) assert inventory.remove_product('banana', 25) == False assert inventory.get_product_info('banana') == (20, 1) def test_get_total_value(): inventory = Inventory() inventory.add_product('apple', 50, 2) inventory.add_product('banana', 30, 1) inventory.add_product('apple', 20, 3) assert inventory.get_total_value() == (70 * 3 + 30 * 1) inventory.remove_product('banana', 10) assert inventory.get_total_value() == (70 * 3 + 20 * 1) inventory.remove_product('banana', 20) assert inventory.get_total_value() == (70 * 3) def test_remove_nonexistent_product(): inventory = Inventory() assert inventory.remove_product('nonexistent', 10) == False def test_remove_more_than_existing_quantity(): inventory = Inventory() inventory.add_product('apple', 50, 2) assert inventory.remove_product('apple', 60) == False assert inventory.get_product_info('apple') == (50, 2) def test_add_product_zero_quantity(): inventory = Inventory() inventory.add_product('apple', 0, 3) assert inventory.get_product_info('apple') == (0, 3)","solution":"from typing import Tuple class Inventory: def __init__(self): self.products = {} def add_product(self, product_id: str, quantity: int, price: int) -> None: if product_id in self.products: self.products[product_id]['quantity'] += quantity self.products[product_id]['price'] = price else: self.products[product_id] = {'quantity': quantity, 'price': price} def remove_product(self, product_id: str, quantity: int) -> bool: if product_id not in self.products or self.products[product_id]['quantity'] < quantity: return False self.products[product_id]['quantity'] -= quantity if self.products[product_id]['quantity'] == 0: del self.products[product_id] return True def get_total_value(self) -> int: total_value = 0 for product in self.products.values(): total_value += product['quantity'] * product['price'] return total_value def get_product_info(self, product_id: str) -> Tuple[int, int]: if product_id in self.products: product = self.products[product_id] return product['quantity'], product['price'] return 0, 0"},{"question":"from typing import List def find_missing_number(nums: List[int], n: int) -> int: Finds the missing number in a list that contains the numbers from 0 to n with exactly one number missing. >>> find_missing_number([3, 0, 1], 3) 2 >>> find_missing_number([0, 1], 2) 2 >>> find_missing_number([9, 6, 4, 2, 3, 5, 7, 0, 1], 9) 8 >>> find_missing_number([0], 1) 1","solution":"from typing import List def find_missing_number(nums: List[int], n: int) -> int: Finds the missing number in a list that contains the numbers from 0 to n with exactly one number missing. # Calculate the expected sum of numbers from 0 to n (inclusive). expected_sum = n * (n + 1) // 2 # Calculate the actual sum of numbers in the list. actual_sum = sum(nums) # The missing number is the difference between the expected sum and the actual sum. return expected_sum - actual_sum"},{"question":"def transpose_matrix(matrix: list[list[int]]) -> list[list[int]]: You are given a 2D matrix (a list of lists) containing integers. Your task is to implement a function that transposes the given matrix. Transposing a matrix means converting its rows into columns and vice versa. Args: matrix (list of lists of ints): The matrix to be transposed. Returns: list of lists of ints: The transposed matrix. Examples: >>> transpose_matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) [[1, 4, 7], [2, 5, 8], [3, 6, 9]] >>> transpose_matrix([[1, 2], [3, 4], [5, 6]]) [[1, 3, 5], [2, 4, 6]] pass","solution":"def transpose_matrix(matrix: list[list[int]]) -> list[list[int]]: Transposes the given 2D matrix. Args: matrix (list of lists of ints): The matrix to be transposed. Returns: list of lists of ints: The transposed matrix. return list(map(list, zip(*matrix)))"},{"question":"import hashlib class UrlShortener: A class to encode long URLs to short ones and decode short URLs to the original long URLs. Methods: encode(long_url: str) -> str: This method takes a long URL and returns a short URL. decode(short_url: str) -> str: This method takes a short URL and returns the original long URL. Example: url_shortener = UrlShortener() # Encode URLs short_url_1 = url_shortener.encode(\\"https://www.example.com/page1\\") short_url_2 = url_shortener.encode(\\"https://www.example.com/page2\\") # Decode URLs assert url_shortener.decode(short_url_1) == \\"https://www.example.com/page1\\" assert url_shortener.decode(short_url_2) == \\"https://www.example.com/page2\\" def __init__(self): self.url_to_code = {} self.code_to_url = {} self.base_url = \\"http://short.url/\\" def encode(self, long_url: str) -> str: pass def decode(self, short_url: str) -> str: pass # Unit Tests def test_encode_and_decode(): url_shortener = UrlShortener() long_url_1 = \\"https://www.example.com/page1\\" long_url_2 = \\"https://www.example.com/page2\\" short_url_1 = url_shortener.encode(long_url_1) short_url_2 = url_shortener.encode(long_url_2) assert url_shortener.decode(short_url_1) == long_url_1 assert url_shortener.decode(short_url_2) == long_url_2 def test_encode_consistency(): url_shortener = UrlShortener() long_url = \\"https://www.example.com/samepage\\" short_url_1 = url_shortener.encode(long_url) short_url_2 = url_shortener.encode(long_url) assert short_url_1 == short_url_2 assert url_shortener.decode(short_url_1) == long_url def test_different_urls(): url_shortener = UrlShortener() long_url_1 = \\"https://www.example.com/page1\\" long_url_2 = \\"https://www.example.com/page1/something\\" short_url_1 = url_shortener.encode(long_url_1) short_url_2 = url_shortener.encode(long_url_2) assert short_url_1 != short_url_2 assert url_shortener.decode(short_url_1) == long_url_1 assert url_shortener.decode(short_url_2) == long_url_2 def test_invalid_short_url(): url_shortener = UrlShortener() assert url_shortener.decode(\\"http://short.url/nonexistent\\") == None","solution":"import hashlib class UrlShortener: def __init__(self): self.url_to_code = {} self.code_to_url = {} self.base_url = \\"http://short.url/\\" def encode(self, long_url: str) -> str: # Generate a unique short code using hashing hash_object = hashlib.md5(long_url.encode()) short_code = hash_object.hexdigest()[:6] # Take first 6 characters of the hash for the short URL if short_code not in self.code_to_url: self.url_to_code[long_url] = short_code self.code_to_url[short_code] = long_url return self.base_url + short_code def decode(self, short_url: str) -> str: # Extract the short code from the URL short_code = short_url.split(\\"/\\")[-1] if short_code in self.code_to_url: return self.code_to_url[short_code] else: return None"},{"question":"class InventoryManager: Inventory management system for a large warehouse that tracks items, their quantities, and movements in and out of the inventory. Methods: - add_item(item_id: str, category: str, quantity: int) -> None: Add a new item to the inventory. If the item already exists, increase its quantity. - remove_item(item_id: str, quantity: int) -> None: Remove a specified quantity of an item from the inventory. Ensure the quantity does not fall below zero. - get_summary_by_category(category: str) -> dict: Return a summary of items in a specified category, with item IDs as keys and quantities as values. - get_total_quantity(item_id: str) -> int: Return the total quantity of a specified item in the inventory. Example Usage: >>> inventory = InventoryManager() >>> inventory.add_item(\\"item123\\", \\"electronics\\", 50) >>> inventory.get_total_quantity(\\"item123\\") 50 >>> inventory.remove_item(\\"item123\\", 20) >>> inventory.get_total_quantity(\\"item123\\") 30 >>> inventory.get_summary_by_category(\\"electronics\\") {\\"item123\\": 30} def __init__(self): # Initialize the inventory data structures. pass def add_item(self, item_id: str, category: str, quantity: int) -> None: # Implement the logic to add an item or update its quantity. pass def remove_item(self, item_id: str, quantity: int) -> None: # Implement the logic to remove a specified quantity of an item. pass def get_summary_by_category(self, category: str) -> dict: # Implement the logic to get an inventory summary by category. pass def get_total_quantity(self, item_id: str) -> int: # Implement the logic to get the total quantity of a specified item. pass # Unit Tests def test_add_item(): inventory = InventoryManager() inventory.add_item(\\"item123\\", \\"electronics\\", 50) assert inventory.get_total_quantity(\\"item123\\") == 50 def test_add_existing_item(): inventory = InventoryManager() inventory.add_item(\\"item123\\", \\"electronics\\", 50) inventory.add_item(\\"item123\\", \\"electronics\\", 30) assert inventory.get_total_quantity(\\"item123\\") == 80 def test_remove_item(): inventory = InventoryManager() inventory.add_item(\\"item123\\", \\"electronics\\", 50) inventory.remove_item(\\"item123\\", 20) assert inventory.get_total_quantity(\\"item123\\") == 30 def test_remove_item_more_than_available(): inventory = InventoryManager() inventory.add_item(\\"item123\\", \\"electronics\\", 30) inventory.remove_item(\\"item123\\", 40) assert inventory.get_total_quantity(\\"item123\\") == 0 def test_get_summary_by_category(): inventory = InventoryManager() inventory.add_item(\\"item123\\", \\"electronics\\", 50) inventory.add_item(\\"item124\\", \\"electronics\\", 30) summary = inventory.get_summary_by_category(\\"electronics\\") assert summary == {\\"item123\\": 50, \\"item124\\": 30} def test_get_summary_by_empty_category(): inventory = InventoryManager() summary = inventory.get_summary_by_category(\\"furniture\\") assert summary == {} def test_get_total_quantity_non_existent_item(): inventory = InventoryManager() quantity = inventory.get_total_quantity(\\"item999\\") assert quantity == 0","solution":"class InventoryManager: def __init__(self): self.inventory = {} self.categories = {} def add_item(self, item_id: str, category: str, quantity: int) -> None: if item_id in self.inventory: self.inventory[item_id]['quantity'] += quantity else: self.inventory[item_id] = {'category': category, 'quantity': quantity} if category not in self.categories: self.categories[category] = {} self.categories[category][item_id] = self.inventory[item_id]['quantity'] def remove_item(self, item_id: str, quantity: int) -> None: if item_id in self.inventory: self.inventory[item_id]['quantity'] = max(0, self.inventory[item_id]['quantity'] - quantity) self.categories[self.inventory[item_id]['category']][item_id] = self.inventory[item_id]['quantity'] def get_summary_by_category(self, category: str) -> dict: if category in self.categories: return self.categories[category] return {} def get_total_quantity(self, item_id: str) -> int: if item_id in self.inventory: return self.inventory[item_id]['quantity'] return 0"},{"question":"def longest_consecutive_character_sequence(s: str) -> int: Returns the length of the longest sequence of consecutive identical characters in a given string. >>> longest_consecutive_character_sequence(\\"aaabbbaac\\") 3 >>> longest_consecutive_character_sequence(\\"abcdefghijklmnopqrstuvwxyz\\") 1 >>> longest_consecutive_character_sequence(\\"aaaaa\\") 5 >>> longest_consecutive_character_sequence(\\"abbbccdddde\\") 4","solution":"def longest_consecutive_character_sequence(s: str) -> int: Returns the length of the longest sequence of consecutive identical characters in the string s. if not s: return 0 max_length = 1 current_length = 1 for i in range(1, len(s)): if s[i] == s[i - 1]: current_length += 1 else: max_length = max(max_length, current_length) current_length = 1 max_length = max(max_length, current_length) return max_length"},{"question":"def predict_stock_prices(prices: list[int], window_size: int) -> list[float]: Predicts stock prices using simple moving average (SMA). Parameters: prices (list): A list of historical stock prices. window_size (int): The size of the window over which to calculate the moving average. Returns: list: A list of predicted stock prices using the SMA. The first \`window_size-1\` values are \`None\`. Examples: >>> predict_stock_prices([1, 2, 3, 4, 5], 3) [None, None, 2.0, 3.0, 4.0] >>> predict_stock_prices([10, 20, 30, 40, 50], 2) [None, 15.0, 25.0, 35.0, 45.0] >>> predict_stock_prices([5, 3, 8, 10, 2], 4) [None, None, None, 6.5, 5.75] >>> predict_stock_prices([5, 5, 5, 5, 5], 1) [5.0, 5.0, 5.0, 5.0, 5.0] >>> predict_stock_prices([2, 4, 8, 16, 32], 5) [None, None, None, None, 12.4]","solution":"def predict_stock_prices(prices: list[int], window_size: int) -> list[float]: Predicts stock prices using simple moving average (SMA). Parameters: prices (list): A list of historical stock prices. window_size (int): The size of the window over which to calculate the moving average. Returns: list: A list of predicted stock prices using the SMA. The first \`window_size-1\` values are \`None\`. n = len(prices) result = [None] * (window_size - 1) current_sum = sum(prices[:window_size]) result.append(current_sum / window_size) for i in range(window_size, n): current_sum += prices[i] - prices[i - window_size] result.append(current_sum / window_size) return result"},{"question":"import threading from collections import defaultdict from typing import DefaultDict class ProductViewTracker: A class to track the number of times a product has been viewed. This class is thread-safe to handle concurrent views. def __init__(self): self.view_counts: DefaultDict[str, int] = defaultdict(int) self.lock = threading.Lock() def view_product(self, product_id: str) -> None: Increment the view count for the given product_id. Args: product_id (str): The ID of the product to be viewed. pass def get_view_count(self, product_id: str) -> int: Return the current view count for the given product_id. Args: product_id (str): The ID of the product. Returns: int: The view count of the product. pass # Unit tests def test_view_product_single_thread(): tracker = ProductViewTracker() tracker.view_product(\\"A123\\") assert tracker.get_view_count(\\"A123\\") == 1 tracker.view_product(\\"A123\\") assert tracker.get_view_count(\\"A123\\") == 2 def test_view_product_multiple_products(): tracker = ProductViewTracker() tracker.view_product(\\"A123\\") tracker.view_product(\\"B456\\") assert tracker.get_view_count(\\"A123\\") == 1 assert tracker.get_view_count(\\"B456\\") == 1 tracker.view_product(\\"B456\\") assert tracker.get_view_count(\\"B456\\") == 2 def test_concurrent_viewing(): tracker = ProductViewTracker() product_id = \\"A123\\" num_threads = 100 views_per_thread = 10 def view_product_multiple_times(): for _ in range(views_per_thread): tracker.view_product(product_id) threads = [ threading.Thread(target=view_product_multiple_times) for _ in range(num_threads) ] for thread in threads: thread.start() for thread in threads: thread.join() expected_views = num_threads * views_per_thread assert tracker.get_view_count(product_id) == expected_views def test_concurrent_viewing_with_multiple_products(): tracker = ProductViewTracker() products = [\\"A123\\", \\"B456\\", \\"C789\\"] num_threads = 50 views_per_thread = 10 def view_multiple_products(): for product in products: for _ in range(views_per_thread): tracker.view_product(product) threads = [ threading.Thread(target=view_multiple_products) for _ in range(num_threads) ] for thread in threads: thread.start() for thread in threads: thread.join() expected_views = num_threads * views_per_thread for product in products: assert tracker.get_view_count(product) == expected_views # Example usage: tracker = ProductViewTracker() tracker.view_product(\\"A123\\") print(tracker.get_view_count(\\"A123\\")) # Output should be 1 tracker.view_product(\\"A123\\") print(tracker.get_view_count(\\"A123\\")) # Output should be 2 tracker.view_product(\\"B456\\") print(tracker.get_view_count(\\"B456\\")) # Output should be 1","solution":"import threading from collections import defaultdict from typing import DefaultDict class ProductViewTracker: def __init__(self): self.view_counts: DefaultDict[str, int] = defaultdict(int) self.lock = threading.Lock() def view_product(self, product_id: str) -> None: with self.lock: self.view_counts[product_id] += 1 def get_view_count(self, product_id: str) -> int: with self.lock: return self.view_counts[product_id]"},{"question":"from typing import List def max_subarray_sum(nums: List[int]) -> int: Returns the maximum sum of any contiguous subarray within the given list. Utilizes Kadane's Algorithm for an efficient solution with O(n) complexity. Args: nums (List[int]): A list of integers representing daily price changes. Returns: int: The maximum sum of any contiguous subarray. Examples: >>> max_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) 6 >>> max_subarray_sum([5, 4, -1, 7, 8]) 23 >>> max_subarray_sum([-10, -2, -3, -4, -5, -6]) -2","solution":"from typing import List def max_subarray_sum(nums: List[int]) -> int: Returns the maximum sum of any contiguous subarray within the given list. Utilizes Kadane's Algorithm for an efficient solution with O(n) complexity. max_sum = cur_sum = nums[0] for num in nums[1:]: cur_sum = max(num, cur_sum + num) max_sum = max(max_sum, cur_sum) return max_sum"},{"question":"def memoized_fibonacci(n: int, memo: dict = None) -> int: Computes the nth Fibonacci number using a recursive approach with memoization. Args: n (int): The index of the Fibonacci number to compute. memo (dict, optional): A dictionary to store previously computed Fibonacci numbers. Returns: int: The nth Fibonacci number. Examples: >>> memoized_fibonacci(10) 55 >>> memoized_fibonacci(50) 12586269025 >>> memoized_fibonacci(100) 354224848179261915075 # Implement the function here # Unit tests def test_base_cases(): assert memoized_fibonacci(0) == 0 assert memoized_fibonacci(1) == 1 def test_small_numbers(): assert memoized_fibonacci(2) == 1 assert memoized_fibonacci(3) == 2 assert memoized_fibonacci(4) == 3 assert memoized_fibonacci(5) == 5 def test_medium_numbers(): assert memoized_fibonacci(10) == 55 assert memoized_fibonacci(20) == 6765 assert memoized_fibonacci(30) == 832040 def test_large_numbers(): assert memoized_fibonacci(50) == 12586269025 assert memoized_fibonacci(100) == 354224848179261915075","solution":"def memoized_fibonacci(n, memo=None): Computes the nth Fibonacci number using memoization. Args: n (int): The index of the Fibonacci number to compute. memo (dict, optional): A dictionary to store previously computed Fibonacci numbers. Returns: int: The nth Fibonacci number. if memo is None: memo = {} if n in memo: return memo[n] if n <= 1: return n memo[n] = memoized_fibonacci(n - 1, memo) + memoized_fibonacci(n - 2, memo) return memo[n]"},{"question":"def find_key(nested_dict: dict, search_key: str) -> Any: Search for a key within a nested dictionary and return the corresponding value. If the key is not found, return \`None\`. Parameters: nested_dict (dict): The dictionary to search in. search_key (str): The key to search for. Returns: Any: The value corresponding to search_key, or None if the key is not found. >>> data = {\\"a\\": {\\"b\\": {\\"c\\": 12, \\"d\\": \\"Hello\\"}, \\"e\\": {\\"f\\": 34, \\"g\\": [1, 2, 3]}}, \\"h\\": 56} >>> find_key(data, \\"c\\") 12 >>> find_key(data, \\"h\\") 56 >>> find_key(data, \\"z\\") None","solution":"def find_key(nested_dict, search_key): Fetches the value of search_key in a nested dictionary. Parameters: nested_dict (dict): The dictionary to search in. search_key (str): The key to search for. Returns: Any: The value corresponding to search_key, or None if key is not found. if search_key in nested_dict: return nested_dict[search_key] for key, value in nested_dict.items(): if isinstance(value, dict): result = find_key(value, search_key) if result is not None: return result return None"},{"question":"class Vehicle: A base class for different types of vehicles. Attributes: make (str): The manufacturer of the vehicle. model (str): The model of the vehicle. year (int): The manufacturing year of the vehicle. speed (float): The speed of the vehicle in km/h. def __init__(self, make: str, model: str, year: int, speed: float): Initializes the vehicle with the given make, model, year, and speed. pass def time_to_travel(self, distance: float) -> float: Calculates the time to travel a given distance in hours. pass class Car(Vehicle): A class representing a car, inheriting from Vehicle. Attributes: number_of_doors (int): Number of doors in the car. def __init__(self, make: str, model: str, year: int, speed: float, number_of_doors: int): Initializes the car with the given properties. pass class Bike(Vehicle): A class representing a bike, inheriting from Vehicle. Attributes: helmet_required (bool): Indicates if a helmet is required by law. def __init__(self, make: str, model: str, year: int, speed: float, helmet_required: bool): Initializes the bike with the given properties. pass def calculate_travel_time(vehicle: Vehicle, distance: float) -> str: Calculates the travel time for a given vehicle and distance. Args: vehicle (Vehicle): An instance of Vehicle or its subclasses. distance (float): Distance to be traveled in km. Returns: str: Formatted string indicating the type of vehicle and calculated travel time. >>> car = Car(\\"Toyota\\", \\"Corolla\\", 2020, 120.0, 4) >>> calculate_travel_time(car, 240) 'A car takes 2.00 hours to travel 240 km.' pass","solution":"class Vehicle: def __init__(self, make: str, model: str, year: int, speed: float): if speed <= 0: raise ValueError(\\"Speed must be positive.\\") self.make = make self.model = model self.year = year self.speed = speed def time_to_travel(self, distance: float) -> float: if distance < 0: raise ValueError(\\"Distance must be non-negative.\\") return distance / self.speed class Car(Vehicle): def __init__(self, make: str, model: str, year: int, speed: float, number_of_doors: int): super().__init__(make, model, year, speed) self.number_of_doors = number_of_doors class Bike(Vehicle): def __init__(self, make: str, model: str, year: int, speed: float, helmet_required: bool): super().__init__(make, model, year, speed) self.helmet_required = helmet_required def calculate_travel_time(vehicle: Vehicle, distance: float) -> str: time = vehicle.time_to_travel(distance) vehicle_type = type(vehicle).__name__.lower() return f\\"A {vehicle_type} takes {time:.2f} hours to travel {distance} km.\\""},{"question":"import re from collections import defaultdict def count_keyword_frequency(transcript: str, keyword: str) -> int: Returns the frequency of the keyword in the transcript. Parameters: - transcript (str): The text of the conversation. - keyword (str): The keyword to be counted. Returns: - int: The frequency of the keyword in the transcript. >>> count_keyword_frequency(\\"Hello world! Hello!\\", \\"hello\\") 2 >>> count_keyword_frequency(\\"The quick brown fox jumps over the lazy dog.\\", \\"The\\") 1 >>> count_keyword_frequency(\\"The quick brown fox jumps over the lazy dog.\\", \\"\\") 0 >>> count_keyword_frequency(\\"The quick brown fox jumps over the lazy dog.\\", \\"cat\\") 0 def count_all_keywords(transcript: str, keywords: List[str]) -> Dict[str, int]: Returns a dictionary with the frequency of each keyword in the transcript. Parameters: - transcript (str): The text of the conversation. - keywords (list): The list of keywords to be counted. Returns: - dict: A dictionary where keys are keywords and values are their respective frequencies. >>> count_all_keywords(\\"Hello world! Hello!\\", [\\"hello\\", \\"world\\"]) {'hello': 2, 'world': 1} >>> count_all_keywords(\\"The quick brown fox jumps over the lazy dog.\\", [\\"the\\", \\"quick\\", \\"dog\\", \\"cat\\"]) {'the': 2, 'quick': 1, 'dog': 1, 'cat': 0} >>> count_all_keywords(\\"The quick brown fox jumps over the lazy dog.\\", [\\"\\"]) {} >>> count_all_keywords(\\"The quick brown fox jumps over the lazy dog.\\", [\\"the\\", \\"\\", \\"lazy\\"]) {'the': 2, 'lazy': 1}","solution":"import re from collections import defaultdict def count_keyword_frequency(transcript, keyword): Returns the frequency of the keyword in the transcript. Parameters: - transcript (str): The text of the conversation. - keyword (str): The keyword to be counted. Returns: - int: The frequency of the keyword in the transcript. if not keyword: return 0 # Make case-insensitive search keyword = keyword.lower() words = re.findall(r'bw+b', transcript.lower()) return words.count(keyword) def count_all_keywords(transcript, keywords): Returns a dictionary with the frequency of each keyword in the transcript. Parameters: - transcript (str): The text of the conversation. - keywords (list): The list of keywords to be counted. Returns: - dict: A dictionary where keys are keywords and values are their respective frequencies. # Filter out empty keywords valid_keywords = [keyword.lower() for keyword in keywords if keyword] result = defaultdict(int) # If no valid keywords, return an empty dictionary if not valid_keywords: return result words = re.findall(r'bw+b', transcript.lower()) for word in words: if word in valid_keywords: result[word] += 1 # Ensure all keywords are included in the result for keyword in valid_keywords: if keyword not in result: result[keyword] = 0 return result"},{"question":"class Node: A Node in the BST, containing a value, and pointers to left and right children. def __init__(self, key): self.key = key self.left = None self.right = None class BST: A simple Binary Search Tree (BST) implementation. def __init__(self): self.root = None def insert(self, value: int) -> None: Insert a value into the BST. >>> bst = BST() >>> bst.insert(50) >>> bst.insert(30) >>> bst.insert(70) >>> bst.in_order_traversal() [30, 50, 70] pass # Implement this method def search(self, value: int) -> bool: Search for a value in the BST. >>> bst = BST() >>> bst.insert(50) >>> bst.insert(30) >>> bst.search(30) True >>> bst.search(70) False pass # Implement this method def in_order_traversal(self) -> list: Perform in-order traversal of the BST and return the sorted values as a list. >>> bst = BST() >>> bst.insert(50) >>> bst.insert(30) >>> bst.insert(70) >>> bst.in_order_traversal() [30, 50, 70] pass # Implement this method","solution":"class Node: A Node in the BST, containing a value, and pointers to left and right children. def __init__(self, key): self.key = key self.left = None self.right = None class BST: A simple Binary Search Tree (BST) implementation. def __init__(self): self.root = None def insert(self, value: int) -> None: Insert a value into the BST. if self.root is None: self.root = Node(value) else: self._insert_recursive(self.root, value) def _insert_recursive(self, node, value): if value < node.key: if node.left is None: node.left = Node(value) else: self._insert_recursive(node.left, value) else: if node.right is None: node.right = Node(value) else: self._insert_recursive(node.right, value) def search(self, value: int) -> bool: Search for a value in the BST. return self._search_recursive(self.root, value) def _search_recursive(self, node, value): if node is None: return False if node.key == value: return True elif value < node.key: return self._search_recursive(node.left, value) else: return self._search_recursive(node.right, value) def in_order_traversal(self) -> list: Perform in-order traversal of the BST and return the sorted values as a list. result = [] self._in_order_recursive(self.root, result) return result def _in_order_recursive(self, node, result): if node: self._in_order_recursive(node.left, result) result.append(node.key) self._in_order_recursive(node.right, result)"},{"question":"from typing import List def smallest_subsequence_length(nums: List[int], target: int) -> int: Determine the smallest subsequence with a given sum. Given a list of integers \`nums\` and an integer \`target\`, return the length of the smallest contiguous subsequence whose sum is at least \`target\`. Args: nums (List[int]): List of integers. target (int): The target sum. Returns: int: Length of the smallest subsequence whose sum is at least \`target\`, or 0 if no such subsequence exists. Example: >>> smallest_subsequence_length([2, 3, 1, 2, 4, 3], 7) 2 >>> smallest_subsequence_length([1, 4, 4], 4) 1 >>> smallest_subsequence_length([1, 1, 1, 1], 7) 0 pass def test_example_case_1(): assert smallest_subsequence_length([2, 3, 1, 2, 4, 3], 7) == 2 def test_example_case_2(): assert smallest_subsequence_length([1, 4, 4], 4) == 1 def test_example_case_3(): assert smallest_subsequence_length([1, 1, 1, 1], 7) == 0 def test_single_element_matches_target(): assert smallest_subsequence_length([5], 5) == 1 def test_entire_array_needed(): assert smallest_subsequence_length([1, 1, 1, 1, 1], 5) == 5 def test_large_inputs(): assert smallest_subsequence_length([1]*100000, 50000) == 50000 def test_subarray_at_end(): assert smallest_subsequence_length([1, 2, 3, 4, 5], 9) == 2 def test_no_subarray_possible(): assert smallest_subsequence_length([1, 2, 3], 7) == 0 def test_all_positive_integers(): assert smallest_subsequence_length([1, 5, 20, 10, -2, 5], 25) == 2 def test_large_target(): assert smallest_subsequence_length([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 55) == 10","solution":"from typing import List def smallest_subsequence_length(nums: List[int], target: int) -> int: n = len(nums) left = 0 current_sum = 0 min_length = float('inf') for right in range(n): current_sum += nums[right] while current_sum >= target: min_length = min(min_length, right - left + 1) current_sum -= nums[left] left += 1 return min_length if min_length != float('inf') else 0"},{"question":"def linear_search(arr: list, target: int) -> int: Perform a linear search to find the target in the list arr. :param arr: List of integers. :param target: The integer value to search for. :return: The index of the target if found, otherwise -1. >>> linear_search([10, 20, 30, 40, 50], 30) 2 >>> linear_search([10, 20, 30, 40, 50], 60) -1 >>> linear_search([], 60) -1 >>> linear_search([-1, -2, -3, -4, -5], -3) 2 >>> linear_search([1, 1, 1, 1, 1], 1) 0","solution":"def linear_search(arr, target): Perform a linear search to find the target in the list arr. :param arr: List of integers. :param target: The integer value to search for. :return: The index of the target if found, otherwise -1. for index, value in enumerate(arr): if value == target: return index return -1"},{"question":"def game_scores(game_results: list) -> dict: Calculate the scores of each team based on the results of the games. Parameters: game_results (list): A list of strings where each string represents the result of a game in the format: \\"TeamA ScoreA - ScoreB TeamB\\". Returns: dict: A dictionary where the keys are team names and values are the final scores. >>> game_scores([\\"Lions 3 - 1 Snakes\\", \\"Tigers 2 - 2 Bears\\", \\"Lions 1 - 1 Bears\\", \\"Snakes 0 - 2 Tigers\\", \\"Bears 3 - 3 Snakes\\"]) {'Lions': 4, 'Snakes': 1, 'Tigers': 4, 'Bears': 3} >>> game_scores([\\"Lions 3 - 1 Snakes\\"]) {'Lions': 3, 'Snakes': 0} >>> game_scores([\\"Lions 2 - 2 Snakes\\"]) {'Lions': 1, 'Snakes': 1} >>> game_scores([]) {}","solution":"def game_scores(game_results): Calculate the scores of each team based on the results of the games. Parameters: game_results (list): A list of strings where each string represents the result of a game in the format: \\"TeamA ScoreA - ScoreB TeamB\\". Returns: dict: A dictionary where the keys are team names and values are the final scores. scores = {} for game in game_results: parts = game.split() team_a = parts[0] score_a = int(parts[1]) score_b = int(parts[3]) # parts[2] is \\"-\\" team_b = parts[4] # Start scores with 0 if the team is seen for the first time if team_a not in scores: scores[team_a] = 0 if team_b not in scores: scores[team_b] = 0 # Evaluate the result of the game if score_a > score_b: scores[team_a] += 3 elif score_a < score_b: scores[team_b] += 3 else: scores[team_a] += 1 scores[team_b] += 1 return scores"},{"question":"class Matrix: def __init__(self, matrix): Initialize the Matrix class with a 2D matrix. >>> matrix = Matrix([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) self.matrix = matrix def submatrix_sum(self, top_left, bottom_right): Calculate the sum of the elements within the submatrix specified by the top-left and bottom-right coordinates. Args: top_left (tuple): coordinates of the top-left cell bottom_right (tuple): coordinates of the bottom-right cell Returns: int: sum of elements in the submatrix >>> matrix = Matrix([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) >>> matrix.submatrix_sum((0, 0), (1, 1)) 12 >>> matrix.submatrix_sum((0, 0), (2, 2)) 45 def update_value(self, row, col, new_value): Update the element at the specified row and column with the new value. Args: row (int): row index col (int): column index new_value (int): new value for the specified element >>> matrix = Matrix([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) >>> matrix.update_value(0, 0, 10) >>> matrix.matrix[0][0] 10 >>> matrix.submatrix_sum((0, 0), (1, 1)) 21 def rotate_90_clockwise(self): Rotate the entire matrix by 90 degrees in the clockwise direction. >>> matrix = Matrix([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) >>> matrix.rotate_90_clockwise() >>> matrix.matrix [[7, 4, 1], [8, 5, 2], [9, 6, 3]] def transpose(self): Transpose the matrix, flipping it over its diagonal. >>> matrix = Matrix([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) >>> matrix.transpose() >>> matrix.matrix [[1, 4, 7], [2, 5, 8], [3, 6, 9]]","solution":"class Matrix: def __init__(self, matrix): self.matrix = matrix def submatrix_sum(self, top_left, bottom_right): row1, col1 = top_left row2, col2 = bottom_right total = 0 for i in range(row1, row2 + 1): for j in range(col1, col2 + 1): total += self.matrix[i][j] return total def update_value(self, row, col, new_value): self.matrix[row][col] = new_value def rotate_90_clockwise(self): self.matrix = [list(reversed(col)) for col in zip(*self.matrix)] def transpose(self): self.matrix = [list(row) for row in zip(*self.matrix)]"},{"question":"Write a function \`filter_and_sort_users\` that takes in a list of dictionaries \`users\`, a dictionary \`filters\`, and a string \`sort_key\`, and returns a list of dictionaries representing the filtered and sorted users. # Function Signature: def filter_and_sort_users(users: List[Dict[str, Union[str, int]]], filters: Dict[str, Union[str, int]], sort_key: str) -> List[Dict[str, Union[str, int]]]: Filters and sorts a list of user data based on dynamic criteria. Args: users (List[Dict[str, Union[str, int]]]): A list of dictionaries, each representing a user with \\"name\\" (str), \\"age\\" (int), and \\"city\\" (str). filters (Dict[str, Union[str, int]]): A dictionary containing the criteria to filter users. Keys can be \\"age\\" or \\"city\\". sort_key (str): The key for sorting the filtered data, either \\"name\\" or \\"age\\". Returns: List[Dict[str, Union[str, int]]]: A list of dictionaries representing the filtered and sorted users. Raises: ValueError: If the sort_key is not \\"name\\" or \\"age\\". <|code|> # Validate the sort_key if sort_key not in {\\"name\\", \\"age\\"}: raise ValueError(f\\"Invalid sort_key: {sort_key}. Must be 'name' or 'age'\\") # Filter the users based on filters filtered_users = users for key, value in filters.items(): filtered_users = [user for user in filtered_users if user.get(key) == value] # Sort filtered users based on sort_key filtered_users.sort(key=lambda x: x[sort_key]) return filtered_users <|/code|> def test_filter_and_sort_users(): users = [ {\\"name\\": \\"Alice\\", \\"age\\": 30, \\"city\\": \\"New York\\"}, {\\"name\\": \\"Bob\\", \\"age\\": 25, \\"city\\": \\"San Francisco\\"}, {\\"name\\": \\"Charlie\\", \\"age\\": 35, \\"city\\": \\"Los Angeles\\"}, {\\"name\\": \\"David\\", \\"age\\": 30, \\"city\\": \\"New York\\"} ] # Test case 1: Filter by age and sort by name filters = {\\"age\\": 30} sort_key = \\"name\\" result = filter_and_sort_users(users, filters, sort_key) assert result == [ {\\"name\\": \\"Alice\\", \\"age\\": 30, \\"city\\": \\"New York\\"}, {\\"name\\": \\"David\\", \\"age\\": 30, \\"city\\": \\"New York\\"} ], f\\"Got {result}\\" # Test case 2: Filter by city and sort by age filters = {\\"city\\": \\"New York\\"} sort_key = \\"age\\" result = filter_and_sort_users(users, filters, sort_key) assert result == [ {\\"name\\": \\"Alice\\", \\"age\\": 30, \\"city\\": \\"New York\\"}, {\\"name\\": \\"David\\", \\"age\\": 30, \\"city\\": \\"New York\\"} ], f\\"Got {result}\\" # Test case 3: No filters, sort by name filters = {} sort_key = \\"name\\" result = filter_and_sort_users(users, filters, sort_key) assert result == [ {\\"name\\": \\"Alice\\", \\"age\\": 30, \\"city\\": \\"New York\\"}, {\\"name\\": \\"Bob\\", \\"age\\": 25, \\"city\\": \\"San Francisco\\"}, {\\"name\\": \\"Charlie\\", \\"age\\": 35, \\"city\\": \\"Los Angeles\\"}, {\\"name\\": \\"David\\", \\"age\\": 30, \\"city\\": \\"New York\\"} ], f\\"Got {result}\\" # Test case 4: No filters, sort by age filters = {} sort_key = \\"age\\" result = filter_and_sort_users(users, filters, sort_key) assert result == [ {\\"name\\": \\"Bob\\", \\"age\\": 25, \\"city\\": \\"San Francisco\\"}, {\\"name\\": \\"Alice\\", \\"age\\": 30, \\"city\\": \\"New York\\"}, {\\"name\\": \\"David\\", \\"age\\": 30, \\"city\\": \\"New York\\"}, {\\"name\\": \\"Charlie\\", \\"age\\": 35, \\"city\\": \\"Los Angeles\\"} ], f\\"Got {result}\\" # Test case 5: Invalid sort_key filters = {} sort_key = \\"invalid_key\\" try: filter_and_sort_users(users, filters, sort_key) except ValueError as e: assert str(e) == \\"Invalid sort_key: invalid_key. Must be 'name' or 'age'\\"","solution":"from typing import List, Dict, Union def filter_and_sort_users(users: List[Dict[str, Union[str, int]]], filters: Dict[str, Union[str, int]], sort_key: str) -> List[Dict[str, Union[str, int]]]: # Validate the sort_key if sort_key not in {\\"name\\", \\"age\\"}: raise ValueError(f\\"Invalid sort_key: {sort_key}. Must be 'name' or 'age'\\") # Filter the users based on filters filtered_users = users for key, value in filters.items(): filtered_users = [user for user in filtered_users if user.get(key) == value] # Sort filtered users based on sort_key filtered_users.sort(key=lambda x: x[sort_key]) return filtered_users"},{"question":"def matrix_multiplication(A: List[List[int]], B: List[List[int]]) -> List[List[int]]: Perform matrix multiplication on two given matrices A and B. A: Matrix with dimensions n x m B: Matrix with dimensions m x p Returns the resulting matrix with dimensions n x p >>> matrix_multiplication([[1, 2, 3], [4, 5, 6]], [[7, 8], [9, 10], [11, 12]]) [[58, 64], [139, 154]] >>> matrix_multiplication([[2]], [[3]]) [[6]] >>> matrix_multiplication([[1, 0], [0, 1]], [[5, 6], [7, 8]]) [[5, 6], [7, 8]] >>> matrix_multiplication([[1, 2], [3, 4], [5, 6]], [[7, 8, 9], [10, 11, 12]]) [[27, 30, 33], [61, 68, 75], [95, 106, 117]] >>> matrix_multiplication([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], [[16, 15, 14, 13], [12, 11, 10, 9], [8, 7, 6, 5], [4, 3, 2, 1]]) [[80, 70, 60, 50], [240, 214, 188, 162], [400, 358, 316, 274], [560, 502, 444, 386]]","solution":"from typing import List def matrix_multiplication(A: List[List[int]], B: List[List[int]]) -> List[List[int]]: # Get the dimensions of A and B n = len(A) m = len(A[0]) p = len(B[0]) # Initialize the result matrix C with zeros C = [[0] * p for _ in range(n)] # Perform the multiplication for i in range(n): for j in range(p): sum = 0 for k in range(m): sum += A[i][k] * B[k][j] C[i][j] = sum return C"},{"question":"def longest_subscription_streak(subscriptions: list) -> int: Find the longest sequence of consecutive subscribed days in a given list of subscription statuses for a month. Args: subscriptions (list): A list of integers of length 1 to 31, representing daily subscription status in a given month (1 for subscribed, 0 for unsubscribed). Returns: int: The length of the longest sequence of consecutive subscribed days. >>> longest_subscription_streak([1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 1, 0, 1, 1]) 4 >>> longest_subscription_streak([0, 0, 0, 0, 0, 0]) 0 >>> longest_subscription_streak([1]) 1","solution":"def longest_subscription_streak(subscriptions: list) -> int: This function finds the longest sequence of consecutive subscribed days in a given list of subscription statuses for a month. max_streak = 0 current_streak = 0 for status in subscriptions: if status == 1: current_streak += 1 if current_streak > max_streak: max_streak = current_streak else: current_streak = 0 return max_streak"},{"question":"import requests def get_weather_info(city: str, api_key: str = \\"YOUR_API_KEY\\") -> dict: Fetch current weather data based on a city name. The function returns a dictionary with weather information which includes temperature, humidity, description, and wind speed. >>> get_weather_info(\\"New York\\", \\"your_api_key\\") { \\"city\\": \\"New York\\", \\"temperature\\": 22.5, \\"humidity\\": 60, \\"description\\": \\"clear sky\\", \\"wind_speed\\": 5.5 } >>> get_weather_info(\\"InvalidCity\\", \\"your_api_key\\") { \\"error\\" : \\"HTTP Error\\"} import pytest from unittest.mock import patch, Mock from solution import get_weather_info def mock_request_get(url, params): class MockResponse: def __init__(self, json_data, status_code): self.json_data = json_data self.status_code = status_code def json(self): return self.json_data def raise_for_status(self): if self.status_code != 200: raise requests.RequestException(f\\"Status code: {self.status_code}\\") if params[\\"q\\"] == \\"New York\\": return MockResponse({ \\"name\\": \\"New York\\", \\"main\\": { \\"temp\\": 22.5, \\"humidity\\": 60 }, \\"weather\\": [ {\\"description\\": \\"clear sky\\"} ], \\"wind\\": { \\"speed\\": 5.5 } }, 200) elif params[\\"q\\"] == \\"InvalidCity\\": return MockResponse({}, 404) return MockResponse({}, 500) @patch('solution.requests.get', side_effect=mock_request_get) def test_get_weather_info_valid_city(mock_get): result = get_weather_info(\\"New York\\", \\"fake_api_key\\") assert result == { \\"city\\": \\"New York\\", \\"temperature\\": 22.5, \\"humidity\\": 60, \\"description\\": \\"clear sky\\", \\"wind_speed\\": 5.5 } @patch('solution.requests.get', side_effect=mock_request_get) def test_get_weather_info_invalid_city(mock_get): result = get_weather_info(\\"InvalidCity\\", \\"fake_api_key\\") assert \\"error\\" in result @patch('solution.requests.get', side_effect=mock_request_get) def test_get_weather_info_server_error(mock_get): result = get_weather_info(\\"ServerErrorCity\\", \\"fake_api_key\\") assert \\"error\\" in result def test_get_weather_info_no_internet(): with patch('solution.requests.get', side_effect=requests.ConnectionError): result = get_weather_info(\\"NewYork\\", \\"fake_api_key\\") assert \\"error\\" in result def test_get_weather_info_invalid_json(): with patch('solution.requests.get') as mock_get: mock_response = Mock() mock_response.status_code = 200 mock_response.json.return_value = {} # Invalid data without required keys mock_get.return_value = mock_response result = get_weather_info(\\"New York\\", \\"fake_api_key\\") assert \\"error\\" in result","solution":"import requests def get_weather_info(city: str, api_key: str = \\"YOUR_API_KEY\\") -> dict: base_url = \\"http://api.openweathermap.org/data/2.5/weather\\" params = { \\"q\\": city, \\"appid\\": api_key, \\"units\\": \\"metric\\" } retries = 3 while retries > 0: try: response = requests.get(base_url, params=params) response.raise_for_status() data = response.json() return { \\"city\\": data[\\"name\\"], \\"temperature\\": data[\\"main\\"][\\"temp\\"], \\"humidity\\": data[\\"main\\"][\\"humidity\\"], \\"description\\": data[\\"weather\\"][0][\\"description\\"], \\"wind_speed\\": data[\\"wind\\"][\\"speed\\"] } except requests.RequestException as e: retries -= 1 if retries == 0: return {\\"error\\": str(e)} except (ValueError, KeyError) as e: return {\\"error\\": f\\"Error parsing data: {e}\\"}"},{"question":"def isValid(s: str) -> bool: Function to check if the string s is a valid set of nested parentheses. :param s: (str) A string containing characters '(', ')', '{', '}', '[' and ']'. :return: bool: Returns True if the string forms a valid set of nested parentheses, otherwise returns False. >>> isValid(\\"()\\") == True >>> isValid(\\"()[]{}\\") == True >>> isValid(\\"(]\\") == False >>> isValid(\\"([)]\\") == False >>> isValid(\\"{[]}\\") == True","solution":"def isValid(s: str) -> bool: Function to check if the string s is a valid set of nested parentheses. Parameters: s (str): A string containing characters '(', ')', '{', '}', '[' and ']'. Returns: bool: Returns True if the string forms a valid set of nested parentheses, otherwise returns False. stack = [] # Mapping of closing to opening parentheses parentheses_map = {')': '(', '}': '{', ']': '['} for char in s: if char in parentheses_map: top_element = stack.pop() if stack else '#' if parentheses_map[char] != top_element: return False else: stack.append(char) return not stack"},{"question":"def calculate_determinant(matrix: list[list[float]]) -> float: Calculate the determinant of a given square matrix using Gaussian Elimination. :param matrix: List of lists representing a square matrix. :return: A float value representing the determinant of the matrix. :raises ValueError: If the input matrix is not square. pass import pytest def test_square_matrix_2x2(): matrix = [ [4, 3], [6, 3] ] assert calculate_determinant(matrix) == pytest.approx(-6.0) def test_square_matrix_3x3(): matrix = [ [2, -3, 1], [2, 0, -1], [1, 4, 5] ] assert calculate_determinant(matrix) == pytest.approx(49.0) def test_identity_matrix(): matrix = [ [1, 0, 0], [0, 1, 0], [0, 0, 1] ] assert calculate_determinant(matrix) == pytest.approx(1.0) def test_zero_determinant(): matrix = [ [2, 4], [1, 2] ] assert calculate_determinant(matrix) == pytest.approx(0.0) def test_larger_matrix(): matrix = [ [6, 1, 1], [4, -2, 5], [2, 8, 7] ] assert calculate_determinant(matrix) == pytest.approx(-306.0) def test_non_square_matrix(): matrix = [ [1, 2, 3], [4, 5, 6] ] with pytest.raises(ValueError, match=\\"The input matrix must be square.\\"): calculate_determinant(matrix) def test_single_element_matrix(): matrix = [ [5] ] assert calculate_determinant(matrix) == pytest.approx(5.0)","solution":"def calculate_determinant(matrix: list[list[float]]) -> float: Calculate the determinant of a given square matrix using Gaussian Elimination. :param matrix: List of lists representing a square matrix. :return: A float value representing the determinant of the matrix. :raises ValueError: If the input matrix is not square. # Check if the matrix is square n = len(matrix) if any(len(row) != n for row in matrix): raise ValueError(\\"The input matrix must be square.\\") # Function to perform row swaps and count them def swap_rows(mat, row1, row2): mat[row1], mat[row2] = mat[row2], mat[row1] # Copy the matrix to avoid modifying the original mat = [row[:] for row in matrix] swap_count = 0 # Gaussian Elimination to transform the matrix to upper triangular form for i in range(n): # Find the pivot row pivot_row = i for j in range(i + 1, n): if abs(mat[j][i]) > abs(mat[pivot_row][i]): pivot_row = j if pivot_row != i: swap_rows(mat, i, pivot_row) swap_count += 1 # Perform row reduction for j in range(i + 1, n): factor = mat[j][i] / mat[i][i] for k in range(i, n): mat[j][k] -= factor * mat[i][k] # Calculate the determinant as the product of the diagonal elements determinant = 1 for i in range(n): determinant *= mat[i][i] # Adjust determinant for the number of row swaps if swap_count % 2 != 0: determinant *= -1 return determinant"},{"question":"def character_frequency_count(s: str) -> dict: Computes the frequency of each character in the input string. :param s: String, the input string containing lowercase alphabets. :return: Dictionary, where keys are characters and values are their respective frequencies in the string. >>> character_frequency_count(\\"examplestring\\") {'e': 2, 'x': 1, 'a': 1, 'm': 1, 'p': 1, 'l': 1, 's': 1, 't': 1, 'r': 1, 'i': 1, 'n': 1, 'g': 1} >>> character_frequency_count(\\"aaaaaaa\\") {'a': 7} >>> character_frequency_count(\\"abcdef\\") {'a': 1, 'b': 1, 'c': 1, 'd': 1, 'e': 1, 'f': 1} >>> character_frequency_count(\\"mississippi\\") {'m': 1, 'i': 4, 's': 4, 'p': 2} >>> character_frequency_count(\\"cccccccccccccc\\") {'c': 14} >>> character_frequency_count(\\"z\\") {'z': 1} >>> input_string = \\"a\\" * 50000 + \\"b\\" * 50000 >>> expected_output = {'a': 50000, 'b': 50000} >>> character_frequency_count(input_string) == expected_output True >>> input_string = \\"abc\\" * 33333 + \\"a\\" >>> expected_output = {'a': 33334, 'b': 33333, 'c': 33333} >>> character_frequency_count(input_string) == expected_output True","solution":"def character_frequency_count(s: str) -> dict: Computes the frequency of each character in the input string. :param s: String, the input string containing lowercase alphabets. :return: Dictionary, where keys are characters and values are their respective frequencies in the string. frequency_dict = {} for char in s: if char in frequency_dict: frequency_dict[char] += 1 else: frequency_dict[char] = 1 return frequency_dict"},{"question":"def solution(arr: list, k: int) -> int: Returns the k-th smallest number in the list. :param arr: A list of integers from which to find the k-th smallest element. :param k: An integer representing the 1-based position of the desired smallest element. :return: The k-th smallest integer in the list. >>> solution([7, 10, 4, 3, 20, 15], 3) 7 >>> solution([7, 10, 4, 3, 20, 15], 4) 10 >>> solution([1, 2, 3, 4, 5], 5) 5 >>> solution([10], 1) 10 >>> solution([3, 1], 1) 1 >>> solution([3, 1], 2) 3 >>> solution(arr=[7, 10, 4, 3, 20, 15], k=0) Traceback (most recent call last): ... ValueError: Invalid k value. >>> solution(arr=[1, 2, 3, 4, 5], k=6) Traceback (most recent call last): ... ValueError: Invalid k value. >>> solution(arr=[1, 2, 3, 4, 5], k=5.5) Traceback (most recent call last): ... ValueError: Invalid k value.","solution":"def solution(arr: list, k: int) -> int: Returns the k-th smallest number in the list. :param arr: A list of integers from which to find the k-th smallest element. :param k: An integer representing the 1-based position of the desired smallest element. :return: The k-th smallest integer in the list. if not (1 <= k <= len(arr)): raise ValueError(\\"Invalid k value.\\") return quickselect(arr, 0, len(arr) - 1, k - 1) def quickselect(arr, low, high, k): if low == high: return arr[low] pivot_index = partition(arr, low, high) if k == pivot_index: return arr[k] elif k < pivot_index: return quickselect(arr, low, pivot_index - 1, k) else: return quickselect(arr, pivot_index + 1, high, k) def partition(arr, low, high): pivot = arr[high] pivot_index = low for j in range(low, high): if arr[j] <= pivot: arr[pivot_index], arr[j] = arr[j], arr[pivot_index] pivot_index += 1 arr[pivot_index], arr[high] = arr[high], arr[pivot_index] return pivot_index"},{"question":"def min_streetlights(building_heights: List[int], distance: int) -> int: Calculate the minimum number of streetlights required to illuminate all buildings in a city. Args: - building_heights: List[int]: A list of integers representing the heights of buildings. - distance: int: An integer representing the maximum illumination distance. Returns: - An integer representing the minimum number of streetlights required. Examples: >>> min_streetlights([3, 2, 1, 4, 3], 1) 3 >>> min_streetlights([6, 5, 3, 2, 8, 9], 2) 2 def test_min_streetlights(): assert min_streetlights([3, 2, 1, 4, 3], 1) == 3 assert min_streetlights([6, 5, 3, 2, 8, 9], 2) == 2 assert min_streetlights([1], 1) == 1 assert min_streetlights([1, 2], 1) == 1 assert min_streetlights([1, 10, 1, 10, 1, 10], 2) == 2 assert min_streetlights([1, 2, 3, 4, 5], 3) == 1 assert min_streetlights([2, 3, 4, 5, 6], 1) == 3 assert min_streetlights([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 1) == 5 assert min_streetlights(list(range(1000)), 10) == 50","solution":"def min_streetlights(building_heights, distance): This function calculates the minimum number of streetlights needed to illuminate all buildings. Each streetlight can cover buildings up to 'distance' units away on either side of its position. n = len(building_heights) i = 0 streetlights_count = 0 while i < n: # Place the streetlight at the furthest building it can cover to the right streetlight_pos = min(i + distance, n) # Move left from this position to place a streetlight while streetlight_pos > i and not (i <= streetlight_pos - distance <= n - 1 and streetlight_pos - (distance if streetlight_pos - distance >= 0 else 0) >= 0): streetlight_pos -= 1 # Increment counter and set next building to the position outside current streetlight coverage streetlights_count += 1 i = streetlight_pos + distance return streetlights_count"},{"question":"def filter_records(records, criteria): Filters records based on specified criteria. Args: records (list of dict): List of dictionaries representing records. criteria (dict): Dictionary of key-value pairs to filter records. Returns: list of dict: List of dictionaries filtered by criteria. >>> records = [{'id': 1, 'name': 'Alice', 'age': 30, 'salary': 5000}, {'id': 2, 'name': 'Bob', 'age': 25, 'salary': 4500}] >>> criteria = {'age': 30} >>> filter_records(records, criteria) [{'id': 1, 'name': 'Alice', 'age': 30, 'salary': 5000}] pass def aggregate_records(records, key, operation): Aggregates values of a specified key in the records based on the given operation. Args: records (list of dict): List of dictionaries representing records. key (str): Key to aggregate by. operation (str): Operation to perform (sum, average, min, max). Returns: float: Result of the aggregation operation. >>> records = [{'id': 1, 'name': 'Alice', 'age': 30, 'salary': 5000}, {'id': 2, 'name': 'Bob', 'age': 25, 'salary': 4500}] >>> aggregate_records(records, 'salary', 'sum') 9500 pass def group_by_field(records, key): Groups records by a specified key. Args: records (list of dict): List of dictionaries representing records. key (str): Key to group by. Returns: dict: Dictionary with unique keys and list of records as values. >>> records = [{'id': 1, 'name': 'Alice', 'age': 30, 'salary': 5000}, {'id': 2, 'name': 'Bob', 'age': 25, 'salary': 4500}] >>> group_by_field(records, 'age') {30: [{'id': 1, 'name': 'Alice', 'age': 30, 'salary': 5000}], 25: [{'id': 2, 'name': 'Bob', 'age': 25, 'salary': 4500}]} pass def sort_records(records, key, reverse=False): Sorts records by a specified key in ascending or descending order. Args: records (list of dict): List of dictionaries representing records. key (str): Key to sort by. reverse (bool, optional): Whether to sort in descending order. Default is False. Returns: list of dict: Sorted list of records. >>> records = [{'id': 1, 'name': 'Alice', 'age': 30, 'salary': 5000}, {'id': 2, 'name': 'Bob', 'age': 25, 'salary': 4500}] >>> sort_records(records, 'salary') [{'id': 2, 'name': 'Bob', 'age': 25, 'salary': 4500}, {'id': 1, 'name': 'Alice', 'age': 30, 'salary': 5000}] pass","solution":"def filter_records(records, criteria): Filters the records based on the specified criteria. Args: records (list of dict): List of records. criteria (dict): Dictionary with key-value pairs to filter the records. Returns: list of dict: Filtered list of records that match the criteria. return [record for record in records if all(record[k] == v for k, v in criteria.items())] def aggregate_records(records, key, operation): Aggregates the records based on the specified key and operation. Args: records (list of dict): List of records. key (str): The field to aggregate by. operation (str): Aggregation operation ('sum', 'average', 'min', 'max'). Returns: float: Result of the aggregation operation. values = [record[key] for record in records] if operation == 'sum': return sum(values) elif operation == 'average': return sum(values) / len(values) if values else 0 elif operation == 'min': return min(values) elif operation == 'max': return max(values) else: raise ValueError(\\"Invalid operation specified.\\") def group_by_field(records, key): Groups the records by the specified key. Args: records (list of dict): List of records. key (str): The field to group by. Returns: dict: Dictionary where the keys are unique values from the specified key, and the values are lists of records that contain that key value. grouped = {} for record in records: k = record[key] if k not in grouped: grouped[k] = [] grouped[k].append(record) return grouped def sort_records(records, key, reverse=False): Sorts the records by the specified key in ascending or descending order. Args: records (list of dict): List of records. key (str): The field to sort by. reverse (bool, optional): Whether to sort in descending order. Default is False (ascending order). Returns: list of dict: Sorted list of records based on the specified key. return sorted(records, key=lambda x: x[key], reverse=reverse)"},{"question":"def is_duplicate_within_k(nums: list[int], k: int) -> bool: Given a list of integers 'nums' and an integer 'k', returns True if there are any duplicate elements within distance k, otherwise returns False. Args: nums: list[int] - A list of integers. k: int - An integer representing the maximum distance. Returns: bool - True if duplicates are found within distance k, otherwise False. Examples: >>> is_duplicate_within_k([1, 2, 3, 1], 3) True >>> is_duplicate_within_k([1, 0, 1, 1], 1) True >>> is_duplicate_within_k([1, 2, 3, 4, 5], 3) False >>> is_duplicate_within_k([1, 2, 1, 1], 2) True","solution":"def is_duplicate_within_k(nums: list[int], k: int) -> bool: Given a list of integers 'nums' and an integer 'k', returns True if there are any duplicate elements within distance k, otherwise returns False. Args: nums: list[int] - A list of integers. k: int - An integer representing the maximum distance. Returns: bool - True if duplicates are found within distance k, otherwise False. seen = set() for i, num in enumerate(nums): if num in seen: return True seen.add(num) if len(seen) > k: seen.remove(nums[i - k]) return False"},{"question":"def is_book_available(inventory: dict, book_id: str) -> bool: This function checks if a given book (identified by its book_id) is available in the library inventory. Parameters: inventory (dict): A dictionary representing the library’s book inventory. book_id (str): A string representing the unique identifier of the book. Returns: bool: True if the book is available in the inventory, otherwise False. pass def test_book_available(): inventory = { \\"book_1\\": True, \\"book_2\\": False, \\"book_3\\": True, \\"book_4\\": False } assert is_book_available(inventory, \\"book_1\\") == True def test_book_not_available(): inventory = { \\"book_1\\": True, \\"book_2\\": False, \\"book_3\\": True, \\"book_4\\": False } assert is_book_available(inventory, \\"book_2\\") == False def test_book_id_not_in_inventory(): inventory = { \\"book_1\\": True, \\"book_2\\": False, \\"book_3\\": True, \\"book_4\\": False } assert is_book_available(inventory, \\"book_5\\") == False def test_empty_inventory(): inventory = {} assert is_book_available(inventory, \\"book_1\\") == False def test_invalid_book_id(): inventory = { \\"book_1\\": True, \\"book_2\\": False, } assert is_book_available(inventory, \\"\\") == False","solution":"def is_book_available(inventory: dict, book_id: str) -> bool: This function checks if a given book (identified by its book_id) is available in the library inventory. Parameters: inventory (dict): A dictionary representing the library’s book inventory. book_id (str): A string representing the unique identifier of the book. Returns: bool: True if the book is available in the inventory, otherwise False. return inventory.get(book_id, False)"},{"question":"class LinkedList: class Node: def __init__(self, value): self.value = value self.next = None def __init__(self) -> None: self.head = None def append(self, value) -> None: Append a new value to the linked list. new_node = self.Node(value) if self.head is None: self.head = new_node return last = self.head while last.next: last = last.next last.next = new_node def _merge_sort(self, head): Helper function to perform merge sort on the linked list. pass def _get_middle(self, head): Helper function to find the middle of the linked list. pass def _sorted_merge(self, left, right): Helper function to merge two sorted linked lists. pass def sort(self) -> None: Sort the linked list using merge sort. self.head = self._merge_sort(self.head) def to_list(self) -> list: Convert the linked list to a list for easy comparison in tests. result = [] current = self.head while current: result.append(current.value) current = current.next return result # Example Usage: if __name__ == \\"__main__\\": ll = LinkedList() ll.append(4) ll.append(2) ll.append(5) ll.append(1) ll.append(3) print(\\"Linked List before sorting:\\") print(ll.to_list()) ll.sort() print(\\"Linked List after sorting:\\") print(ll.to_list()) # Unit Tests def test_append(): ll = LinkedList() ll.append(1) ll.append(3) ll.append(2) assert ll.to_list() == [1, 3, 2] def test_sort_with_multiple_elements(): ll = LinkedList() ll.append(4) ll.append(2) ll.append(5) ll.append(1) ll.append(3) ll.sort() assert ll.to_list() == [1, 2, 3, 4, 5] def test_sort_empty_list(): ll = LinkedList() ll.sort() assert ll.to_list() == [] def test_sort_single_element(): ll = LinkedList() ll.append(1) ll.sort() assert ll.to_list() == [1] def test_sort_with_duplicate_elements(): ll = LinkedList() ll.append(4) ll.append(2) ll.append(2) ll.append(1) ll.append(3) ll.sort() assert ll.to_list() == [1, 2, 2, 3, 4]","solution":"class LinkedList: class Node: def __init__(self, value): self.value = value self.next = None def __init__(self) -> None: self.head = None def append(self, value) -> None: new_node = self.Node(value) if self.head is None: self.head = new_node return last = self.head while last.next: last = last.next last.next = new_node def _merge_sort(self, head): if not head or not head.next: return head middle = self._get_middle(head) next_to_middle = middle.next middle.next = None left = self._merge_sort(head) right = self._merge_sort(next_to_middle) sorted_list = self._sorted_merge(left, right) return sorted_list def _get_middle(self, head): if not head: return head slow, fast = head, head.next while fast and fast.next: slow, fast = slow.next, fast.next.next return slow def _sorted_merge(self, left, right): if not left: return right if not right: return left if left.value <= right.value: result = left result.next = self._sorted_merge(left.next, right) else: result = right result.next = self._sorted_merge(left, right.next) return result def sort(self) -> None: self.head = self._merge_sort(self.head) def to_list(self) -> list: result = [] current = self.head while current: result.append(current.value) current = current.next return result"},{"question":"import concurrent.futures import logging from typing import List, Callable def process_files(input_files: List[str], output_files: List[str], transform: Callable[[str], str]) -> None: Process multiple files simultaneously, applying a transformation to each line. Args: input_files (List[str]): A list of input filenames to process. output_files (List[str]): A list of corresponding output filenames. transform (Callable[[str], str]): A function that takes a string as input and returns a transformed string. Raises: ValueError: If the number of input files does not match the number of output files. Example: def upper_case_transform(line: str) -> str: return line.upper() input_files = [\\"input1.txt\\", \\"input2.txt\\"] output_files = [\\"output1.txt\\", \\"output2.txt\\"] process_files(input_files, output_files, upper_case_transform) Notes: - Ensure logging of success and failure messages per line. - Implement robust error handling to log any read/write errors per line. - Ensure that files are correctly closed after processing to prevent resource leaks. - Use appropriate concurrency mechanisms to handle multiple files efficiently. pass # Unit Tests import pytest import os def write_test_file(filename, lines): with open(filename, 'w') as f: for line in lines: f.write(line) def read_file_lines(filename): with open(filename, 'r') as f: return f.readlines() def test_process_files_single_file(tmp_path): input_file = tmp_path / \\"input.txt\\" output_file = tmp_path / \\"output.txt\\" test_lines = [ \\"hello worldn\\", \\"this is a testn\\", \\"processing lines\\" ] write_test_file(input_file, test_lines) process_files([input_file], [output_file], upper_case_transform) expected_lines = [line.upper() for line in test_lines] result_lines = read_file_lines(output_file) assert result_lines == expected_lines def test_process_files_multiple_files(tmp_path): input_files = [tmp_path / f\\"input{i}.txt\\" for i in range(3)] output_files = [tmp_path / f\\"output{i}.txt\\" for i in range(3)] test_data = [ [\\"hellon\\", \\"worldn\\"], [\\"foon\\", \\"barn\\"], [\\"loremn\\", \\"ipsumn\\"] ] for input_file, lines in zip(input_files, test_data): write_test_file(input_file, lines) process_files(input_files, output_files, upper_case_transform) for output_file, lines in zip(output_files, test_data): expected_lines = [line.upper() for line in lines] result_lines = read_file_lines(output_file) assert result_lines == expected_lines def test_process_files_mismatched_input_and_output_files(tmp_path): input_file = tmp_path / \\"input.txt\\" write_test_file(input_file, [\\"testn\\"]) output_file = tmp_path / \\"output.txt\\" with pytest.raises(ValueError): process_files([input_file], [], upper_case_transform) def test_process_files_handles_exception_during_transform(tmp_path, monkeypatch): input_file = tmp_path / \\"input.txt\\" output_file = tmp_path / \\"output.txt\\" test_lines = [ \\"normal linen\\", \\"error linen\\" ] write_test_file(input_file, test_lines) def error_transform(line: str) -> str: if \\"error\\" in line: raise ValueError(\\"Intentional error during transform\\") return line.upper() process_files([input_file], [output_file], error_transform) expected_lines = [\\"NORMAL LINEn\\"] result_lines = read_file_lines(output_file) assert result_lines == expected_lines def upper_case_transform(line: str) -> str: return line.upper()","solution":"import concurrent.futures import logging from typing import List, Callable import os # Set up logging configuration logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s') def process_file(input_file: str, output_file: str, transform: Callable[[str], str]) -> None: try: with open(input_file, 'r') as infile, open(output_file, 'w') as outfile: for line in infile: try: transformed_line = transform(line) outfile.write(transformed_line) logging.info(f\\"Successfully processed line in file: {input_file}\\") except Exception as e: logging.error(f\\"Error transforming line in file: {input_file} - {e}\\") except Exception as e: logging.error(f\\"Error processing file: {input_file} - {e}\\") def process_files(input_files: List[str], output_files: List[str], transform: Callable[[str], str]) -> None: if len(input_files) != len(output_files): raise ValueError(\\"The number of input files must match the number of output files.\\") with concurrent.futures.ThreadPoolExecutor() as executor: futures = [] for input_file, output_file in zip(input_files, output_files): futures.append(executor.submit(process_file, input_file, output_file, transform)) for future in concurrent.futures.as_completed(futures): future.result() # we don't need the result, but it will raise any exceptions here # Example transform function def upper_case_transform(line: str) -> str: return line.upper()"},{"question":"def sum_of_digits(n: int) -> int: Returns the sum of the digits of a given positive integer n. >>> sum_of_digits(1234) 10 >>> sum_of_digits(8675309) 38 >>> sum_of_digits(1000000001) 2","solution":"def sum_of_digits(n: int) -> int: Returns the sum of the digits of a given positive integer n. sum_d = 0 while n > 0: sum_d += n % 10 n //= 10 return sum_d"},{"question":"class TrieNode: def __init__(self, children=None, is_word=False): Initialize the children nodes and word flag. self.children = children if children is not None else {} self.is_word = is_word class CompressedTrie: def __init__(self): Initialize the root of the Trie. self.root = TrieNode() def insert(self, word): Insert a word into the compressed trie. >>> trie = CompressedTrie() >>> trie.insert(\\"apple\\") >>> trie.search(\\"apple\\") True pass def search(self, word): Search for a word in the compressed trie. >>> trie = CompressedTrie() >>> trie.insert(\\"apple\\") >>> trie.search(\\"apple\\") True >>> trie.search(\\"app\\") False pass def starts_with(self, prefix): Check if there is any word in the trie that starts with the given prefix. >>> trie = CompressedTrie() >>> trie.insert(\\"apple\\") >>> trie.insert(\\"app\\") >>> trie.starts_with(\\"ap\\") True >>> trie.starts_with(\\"b\\") False pass","solution":"class TrieNode: def __init__(self, children=None, is_word=False): self.children = children if children is not None else {} self.is_word = is_word class CompressedTrie: def __init__(self): self.root = TrieNode() def insert(self, word): node = self.root while word: found = False for key in node.children.keys(): if word.startswith(key): node = node.children[key] word = word[len(key):] found = True break if key.startswith(word): new_node = TrieNode(children={key[len(word):]: node.children[key]}, is_word=True) del node.children[key] node.children[word] = new_node return if not found: node.children[word] = TrieNode(is_word=True) return def search(self, word): node = self.root while word: found = False for key in node.children.keys(): if word.startswith(key): node = node.children[key] if len(word) == len(key): return node.is_word word = word[len(key):] found = True break if not found: return False return False def starts_with(self, prefix): node = self.root while prefix: found = False for key in node.children.keys(): if prefix.startswith(key): node = node.children[key] if len(prefix) == len(key): return True prefix = prefix[len(key):] found = True break if key.startswith(prefix): return True if not found: return False return False"},{"question":"from typing import List def page_rank(trans_matrix: List[List[float]], initial_vector: List[float] = None, iterations: int = 100) -> List[float]: Simulates a simplified version of a PageRank algorithm to rank web pages based on their importance. Parameters: trans_matrix (List[List[float]]): A 2D list of floats representing the transition probability matrix of the web pages. initial_vector (List[float], optional): An initial rank vector. Defaults to None which means equal rank for all pages. iterations (int): Number of iterations to run the algorithm. Defaults to 100. Returns: List[float]: The final rank vector after the specified iterations. >>> page_rank([[0.5, 0.5], [0.5, 0.5]], iterations=1) [0.5, 0.5] >>> page_rank([[0.0, 1.0], [1.0, 0.0]], iterations=2) [0.5, 0.5] pass def test_page_rank_example1(): trans_matrix = [ [0.5, 0.5], [0.5, 0.5] ] result = page_rank(trans_matrix, iterations=1) expected = [0.5, 0.5] assert result == expected def test_page_rank_example2(): trans_matrix = [ [0.0, 1.0], [1.0, 0.0] ] result = page_rank(trans_matrix, iterations=2) expected = [0.5, 0.5] assert result == expected def test_page_rank_initial_vector(): trans_matrix = [ [0.0, 1.0], [1.0, 0.0] ] initial_vector = [0.2, 0.8] result = page_rank(trans_matrix, initial_vector, iterations=1) expected = [0.8, 0.2] assert result == expected def test_page_rank_different_iterations(): trans_matrix = [ [0.0, 1.0], [1.0, 0.0] ] result_1 = page_rank(trans_matrix, iterations=1) result_2 = page_rank(trans_matrix, iterations=2) assert result_1 == [0.5, 0.5] and result_2 == [0.5, 0.5] def test_page_rank_no_iterations(): trans_matrix = [ [0.0, 1.0], [1.0, 0.0] ] result = page_rank(trans_matrix, iterations=0) expected = [0.5, 0.5] # Assuming 0 iterations returns equally distributed ranks assert result == expected","solution":"from typing import List def page_rank(trans_matrix: List[List[float]], initial_vector: List[float] = None, iterations: int = 100) -> List[float]: n = len(trans_matrix) if initial_vector is None: rank_vector = [1/n for _ in range(n)] else: rank_vector = initial_vector[:] for _ in range(iterations): new_rank_vector = [0] * n for i in range(n): new_rank_vector[i] = sum(trans_matrix[i][j] * rank_vector[j] for j in range(n)) # Normalize rank_vector total_rank = sum(new_rank_vector) rank_vector = [val/total_rank for val in new_rank_vector] return rank_vector"},{"question":"def find_missing_positive(arr: list) -> int: Find the smallest positive integer that is missing from the array. >>> find_missing_positive([3, 4, -1, 1]) 2 >>> find_missing_positive([1, 2, 0]) 3 >>> find_missing_positive([7, 8, 9, 11, 12]) 1 def test_example_input_1(): assert find_missing_positive([3, 4, -1, 1]) == 2 def test_example_input_2(): assert find_missing_positive([1, 2, 0]) == 3 def test_example_input_3(): assert find_missing_positive([7, 8, 9, 11, 12]) == 1 def test_all_negatives(): assert find_missing_positive([-1, -2, -3]) == 1 def test_sequential_numbers(): assert find_missing_positive([1, 2, 3, 4, 5]) == 6 def test_single_element_1(): assert find_missing_positive([1]) == 2 def test_single_element_2(): assert find_missing_positive([2]) == 1 def test_duplicates(): assert find_missing_positive([1, 1, 2, 3, 3, 4]) == 5 def test_unsorted(): assert find_missing_positive([4, 3, 2, 7, 8, 2, 3, 1]) == 5","solution":"def find_missing_positive(arr: list) -> int: n = len(arr) for i in range(n): while 1 <= arr[i] <= n and arr[arr[i] - 1] != arr[i]: arr[arr[i] - 1], arr[i] = arr[i], arr[arr[i] - 1] for i in range(n): if arr[i] != i + 1: return i + 1 return n + 1"},{"question":"def top_performing_students(student_scores: dict, threshold: float) -> list: Returns a list of names of students who scored above a given threshold. Parameters: student_scores (dict): Dictionary with student names as keys and scores as values. threshold (float): The score threshold. Returns: list: List of student names who scored above the threshold. Raises: ValueError: If \`student_scores\` is not a dictionary or if \`threshold\` is not a float between 0 and 100. Example Usage: >>> student_scores = { ... 'Alice': 89.5, ... 'Bob': 67.3, ... 'Charlie': 92.7, ... 'David': 55.1 ... } >>> top_performing_students(student_scores, 70.0) ['Alice', 'Charlie'] import pytest def test_top_performing_students_valid_input(): student_scores = { 'Alice': 89.5, 'Bob': 67.3, 'Charlie': 92.7, 'David': 55.1 } assert top_performing_students(student_scores, 70.0) == ['Alice', 'Charlie'] assert top_performing_students(student_scores, 90.0) == ['Charlie'] assert top_performing_students(student_scores, 95.0) == [] def test_top_performing_students_threshold_edge_cases(): student_scores = { 'Alice': 90.0, 'Bob': 90.0, 'Charlie': 90.1, 'David': 89.9 } assert top_performing_students(student_scores, 90.0) == ['Charlie'] assert top_performing_students(student_scores, 89.9) == ['Alice', 'Bob', 'Charlie'] assert top_performing_students(student_scores, 90.1) == [] def test_top_performing_students_invalid_student_scores_type(): with pytest.raises(ValueError): top_performing_students(['Alice', 'Bob'], 70.0) def test_top_performing_students_invalid_threshold_type(): student_scores = { 'Alice': 89.5, 'Bob': 67.3 } with pytest.raises(ValueError): top_performing_students(student_scores, '70.0') with pytest.raises(ValueError): top_performing_students(student_scores, [70.0]) def test_top_performing_students_invalid_threshold_range(): student_scores = { 'Alice': 89.5, 'Bob': 67.3 } with pytest.raises(ValueError): top_performing_students(student_scores, -1) with pytest.raises(ValueError): top_performing_students(student_scores, 101) def test_top_performing_students_all_students_above_threshold(): student_scores = { 'Alice': 95.0, 'Bob': 96.5, 'Charlie': 99.1 } assert top_performing_students(student_scores, 90.0) == ['Alice', 'Bob', 'Charlie'] def test_top_performing_students_no_students_above_threshold(): student_scores = { 'Alice': 50.0, 'Bob': 60.0 } assert top_performing_students(student_scores, 70.0) == [] def test_top_performing_students_empty_dictionary(): assert top_performing_students({}, 50.0) == []","solution":"def top_performing_students(student_scores: dict, threshold: float) -> list: Returns a list of names of students who scored above a given threshold. Parameters: student_scores (dict): Dictionary with student names as keys and scores as values. threshold (float): The score threshold. Returns: list: List of student names who scored above the threshold. # Validate the student_scores input if not isinstance(student_scores, dict): raise ValueError(f\\"Expected dictionary for student_scores, found {type(student_scores)}\\") # Validate the threshold input if not isinstance(threshold, (int, float)): raise ValueError(f\\"Expected float for threshold, found {type(threshold)}\\") if not (0 <= threshold <= 100): raise ValueError(\\"Threshold must be between 0 and 100.\\") # Identify students who scored above the threshold high_scorers = [name for name, score in student_scores.items() if score > threshold] return high_scorers"},{"question":"class TaskManager: def __init__(self): Initialize an empty task list self.tasks = [] def add_task(self, task: str) -> None: Adds a task with a status of 'incomplete' to the task list. Args: task (str): A new task description Example Usage: >>> tm = TaskManager() >>> tm.add_task(\\"Buy groceries\\") >>> tm.add_task(\\"Write report\\") pass def complete_task(self, task_id: int) -> None: Marks the task at \`task_id\` with the status 'complete'. Args: task_id (int): The index of the task to be marked as completed Example Usage: >>> tm = TaskManager() >>> tm.add_task(\\"Buy groceries\\") >>> tm.add_task(\\"Write report\\") >>> tm.complete_task(1) pass def list_tasks(self) -> list: Returns a list of all tasks with their current status in the format (index, task_description, status). Returns: list: A list of tuples, each containing the task index, task description, and status. Example Usage: >>> tm = TaskManager() >>> tm.add_task(\\"Buy groceries\\") >>> tm.add_task(\\"Write report\\") >>> tm.list_tasks() [(0, \\"Buy groceries\\", \\"incomplete\\"), (1, \\"Write report\\", \\"incomplete\\")] pass","solution":"class TaskManager: def __init__(self): self.tasks = [] def add_task(self, task): Adds a task with a status of 'incomplete' to the task list. self.tasks.append({\\"description\\": task, \\"status\\": \\"incomplete\\"}) def complete_task(self, task_id): Marks the task at \`task_id\` with the status 'complete'. if 0 <= task_id < len(self.tasks): self.tasks[task_id][\\"status\\"] = \\"complete\\" def list_tasks(self): Returns a list of all tasks with their current status in the format (index, task_description, status). return [(index, task[\\"description\\"], task[\\"status\\"]) for index, task in enumerate(self.tasks)]"},{"question":"def caesar_encode(s: str, shift: int) -> str: Encode a string using the Caesar Cipher with a given shift. >>> caesar_encode(\\"hello\\", 3) \\"khoor\\" >>> caesar_encode(\\"abc\\", 1) \\"bcd\\" >>> caesar_encode(\\"xyz\\", 3) \\"abc\\" >>> caesar_encode(\\"a\\", 0) \\"a\\" >>> caesar_encode(\\"z\\", 1) \\"a\\" >>> caesar_encode(\\"cdef\\", 2) \\"efgh\\" pass def caesar_decode(encoded_s: str, shift: int) -> str: Decode a string that was encoded using the Caesar Cipher with a given shift. >>> caesar_decode(\\"khoor\\", 3) \\"hello\\" >>> caesar_decode(\\"bcd\\", 1) \\"abc\\" >>> caesar_decode(\\"abc\\", 3) \\"xyz\\" >>> caesar_decode(\\"a\\", 0) \\"a\\" >>> caesar_decode(\\"a\\", 1) \\"z\\" >>> caesar_decode(\\"efgh\\", 2) \\"cdef\\" pass","solution":"def caesar_encode(s: str, shift: int) -> str: encoded = [] for char in s: encoded_char = chr(((ord(char) - ord('a') + shift) % 26) + ord('a')) encoded.append(encoded_char) return ''.join(encoded) def caesar_decode(encoded_s: str, shift: int) -> str: decoded = [] for char in encoded_s: decoded_char = chr(((ord(char) - ord('a') - shift) % 26) + ord('a')) decoded.append(decoded_char) return ''.join(decoded)"},{"question":"class ListNode: def __init__(self, value=0, next=None): self.value = value self.next = next def detect_and_remove_cycle(head: ListNode) -> None: Detects and removes a cycle in the linked list if present using Floyd’s Tortoise and Hare algorithm. >>> head = ListNode(1) >>> head.next = ListNode(2) >>> head.next.next = ListNode(3) >>> head.next.next.next = ListNode(4) >>> head.next.next.next.next = ListNode(5) >>> head.next.next.next.next.next = head.next.next # Creating a cycle >>> detect_and_remove_cycle(head) >>> print_list(head) # Expected Output: 1 2 3 4 5 >>> head = ListNode(1) >>> head.next = ListNode(2) >>> head.next.next = ListNode(3) >>> head.next.next.next = ListNode(4) >>> head.next.next.next.next = ListNode(5) >>> detect_and_remove_cycle(head) >>> print_list(head) # Expected Output: 1 2 3 4 5 pass def print_list(head: ListNode) -> None: Prints the value of each node in the list starting from head to end. >>> head = ListNode(1) >>> head.next = ListNode(2) >>> head.next.next = ListNode(3) >>> head.next.next.next = ListNode(4) >>> head.next.next.next.next = ListNode(5) >>> print_list(head) # Expected Output: 1 2 3 4 5 pass","solution":"class ListNode: def __init__(self, value=0, next=None): self.value = value self.next = next def detect_and_remove_cycle(head: ListNode) -> None: Detects and removes a cycle in the linked list using Floyd’s Tortoise and Hare algorithm. if head is None or head.next is None: return # No cycle possible in empty or single node list # Step 1: Detect cycle using Floyd’s Tortoise and Hare algorithm slow = head fast = head cycle_detected = False while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: cycle_detected = True break if not cycle_detected: return # No cycle detected # Step 2: Remove the cycle # Reset slow to head slow = head if slow == fast: while fast.next != slow: fast = fast.next fast.next = None else: while slow.next != fast.next: slow = slow.next fast = fast.next fast.next = None def print_list(head: ListNode) -> None: Prints the value of each node in the list starting from head to end. current = head while current: print(current.value, end=\\" \\") current = current.next print()"},{"question":"from typing import List, Tuple def allocate_vms(vms: List[Tuple[int, int, float]], tasks: List[Tuple[int, int]]) -> List[List[int]]: Allocates the optimal set of VMs to each task minimizing cost. :param vms: List of tuples representing VMs available (CPU cores, RAM units, cost per hour). :param tasks: List of tuples representing tasks (CPU cores required, RAM units required). :return: List of lists. Each inner list contains indices of allocated VMs for a corresponding task. pass def calculate_cost(vm_indices: List[int], vms: List[Tuple[int, int, float]]) -> float: Calculate the total cost of the VMs allocated for a task. :param vm_indices: List of indices of allocated VMs. :param vms: List of tuples representing VMs available (CPU cores, RAM units, cost per hour). :return: Total cost of the allocated VMs. pass def is_allocation_feasible(task: Tuple[int, int], vms: List[Tuple[int, int, float]], allocation: List[int]) -> bool: Check if the VM allocation meets the task's CPU and RAM requirements. :param task: Tuple representing a task (CPU cores required, RAM units required). :param vms: List of tuples representing VMs available (CPU cores, RAM units, cost per hour). :param allocation: List of indices of allocated VMs. :return: True if allocation meets the task's requirements, False otherwise. pass # Unit Tests def test_allocate_vms(): vms = [(4, 16, 0.5), (8, 32, 1.0), (2, 8, 0.25)] tasks = [(10, 40), (4, 20)] allocations = allocate_vms(vms, tasks) assert len(allocations) == 2 assert all(isinstance(alloc, list) for alloc in allocations) def test_calculate_cost(): vms = [(4, 16, 0.5), (8, 32, 1.0), (2, 8, 0.25)] vm_indices = [0, 1] cost = calculate_cost(vm_indices, vms) assert cost == 1.5 def test_is_allocation_feasible(): vms = [(4, 16, 0.5), (8, 32, 1.0), (2, 8, 0.25)] task = (10, 40) allocation = [0, 1] assert is_allocation_feasible(task, vms, allocation) def test_infeasible_allocation(): vms = [(4, 16, 0.5), (8, 32, 1.0)] task = (15, 50) allocation = [0] assert not is_allocation_feasible(task, vms, allocation) def test_zero_allocation_cost(): vms = [(4, 16, 0.5), (8, 32, 1.0)] vm_indices = [] cost = calculate_cost(vm_indices, vms) assert cost == 0","solution":"from typing import List, Tuple def allocate_vms(vms: List[Tuple[int, int, float]], tasks: List[Tuple[int, int]]) -> List[List[int]]: Allocates the optimal set of VMs to each task minimizing cost. :param vms: List of tuples representing VMs available (CPU cores, RAM units, cost per hour). :param tasks: List of tuples representing tasks (CPU cores required, RAM units required). :return: List of lists. Each inner list contains indices of allocated VMs for a corresponding task. def knapSack(W, wt, val, n): K = [[0 for x in range(W + 1)] for x in range(n + 1)] for i in range(n + 1): for w in range(W + 1): if i == 0 or w == 0: K[i][w] = 0 elif wt[i - 1] <= w: K[i][w] = max(val[i - 1] + K[i - 1][w - wt[i - 1]], K[i - 1][w]) else: K[i][w] = K[i - 1][w] res = K[n][W] w = W indices = [] for i in range(n, 0, -1): if res <= 0: break if res == K[i - 1][w]: continue else: indices.append(i - 1) res = res - val[i - 1] w = w - wt[i - 1] return indices allocations = [] for task in tasks: required_cpu, required_ram = task indices = knapSack(required_cpu, [vm[0] for vm in vms], [-vm[2] for vm in vms], len(vms)) allocated_vms = [] for index in indices: alloc_cpu, alloc_ram, _ = vms[index] required_cpu -= alloc_cpu required_ram -= alloc_ram allocated_vms.append(index) if required_cpu <= 0 and required_ram <= 0: break if required_cpu > 0 or required_ram > 0: for index in indices: alloc_cpu, alloc_ram, _ = vms[index] if required_ram > 0: while required_cpu > 0 and required_ram > 0: allocated_vms.append(index) required_cpu -= alloc_cpu required_ram -= alloc_ram if required_cpu <= 0 and required_ram <= 0: break allocations.append(allocated_vms) return allocations def calculate_cost(vm_indices: List[int], vms: List[Tuple[int, int, float]]) -> float: Calculate the total cost of the VMs allocated for a task. :param vm_indices: List of indices of allocated VMs. :param vms: List of tuples representing VMs available (CPU cores, RAM units, cost per hour). :return: Total cost of the allocated VMs. return sum(vms[index][2] for index in vm_indices) def is_allocation_feasible(task: Tuple[int, int], vms: List[Tuple[int, int, float]], allocation: List[int]) -> bool: Check if the VM allocation meets the task's CPU and RAM requirements. :param task: Tuple representing a task (CPU cores required, RAM units required). :param vms: List of tuples representing VMs available (CPU cores, RAM units, cost per hour). :param allocation: List of indices of allocated VMs. :return: True if allocation meets the task's requirements, False otherwise. allocated_cpu = sum(vms[index][0] for index in allocation) allocated_ram = sum(vms[index][1] for index in allocation) return allocated_cpu >= task[0] and allocated_ram >= task[1]"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right class BSTIterator: BSTIterator class for an initially given binary search tree (BST). This iterator provides an interface to iterate over the elements of the BST in ascending order. Methods: __init__(self, root: TreeNode) -> None has_next(self) -> bool next(self) -> int Example: >>> root = TreeNode(7, TreeNode(3), TreeNode(15, TreeNode(9), TreeNode(20))) >>> iterator = BSTIterator(root) >>> iterator.next() # 3 >>> iterator.next() # 7 >>> iterator.has_next() # True >>> iterator.next() # 9 >>> iterator.has_next() # True >>> iterator.next() # 15 >>> iterator.has_next() # True >>> iterator.next() # 20 >>> iterator.has_next() # False def __init__(self, root: Optional[TreeNode]) -> None: self.stack = [] self._leftmost_inorder(root) def _leftmost_inorder(self, node: Optional[TreeNode]) -> None: while node: self.stack.append(node) node = node.left def has_next(self) -> bool: return len(self.stack) > 0 def next(self) -> int: if not self.has_next(): raise ValueError(\\"No more elements in BST\\") topmost_node = self.stack.pop() if topmost_node.right: self._leftmost_inorder(topmost_node.right) return topmost_node.val # Unit Tests import pytest def test_bst_iterator_full_tree(): root = TreeNode(7, TreeNode(3), TreeNode(15, TreeNode(9), TreeNode(20))) iterator = BSTIterator(root) assert iterator.next() == 3 assert iterator.next() == 7 assert iterator.has_next() is True assert iterator.next() == 9 assert iterator.has_next() is True assert iterator.next() == 15 assert iterator.has_next() is True assert iterator.next() == 20 assert iterator.has_next() is False def test_bst_iterator_empty_tree(): root = None iterator = BSTIterator(root) assert iterator.has_next() is False with pytest.raises(ValueError): iterator.next() def test_bst_iterator_single_node(): root = TreeNode(42) iterator = BSTIterator(root) assert iterator.has_next() is True assert iterator.next() == 42 assert iterator.has_next() is False def test_bst_iterator_left_skewed_tree(): root = TreeNode(5, TreeNode(3, TreeNode(2, TreeNode(1))), None) iterator = BSTIterator(root) assert iterator.next() == 1 assert iterator.next() == 2 assert iterator.next() == 3 assert iterator.next() == 5 assert iterator.has_next() is False def test_bst_iterator_right_skewed_tree(): root = TreeNode(1, None, TreeNode(2, None, TreeNode(3, None, TreeNode(4)))) iterator = BSTIterator(root) assert iterator.next() == 1 assert iterator.next() == 2 assert iterator.next() == 3 assert iterator.next() == 4 assert iterator.has_next() is False","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right class BSTIterator: def __init__(self, root: TreeNode) -> None: self.stack = [] self._leftmost_inorder(root) def _leftmost_inorder(self, node: TreeNode) -> None: while node: self.stack.append(node) node = node.left def has_next(self) -> bool: return len(self.stack) > 0 def next(self) -> int: if not self.has_next(): raise ValueError(\\"No more elements in BST\\") topmost_node = self.stack.pop() if topmost_node.right: self._leftmost_inorder(topmost_node.right) return topmost_node.val"},{"question":"def sum_of_squares_even(start: int, end: int) -> int: Calculate the sum of squares of all even numbers within the given range [start, end]. Parameters: start (int): The start of the range. end (int): The end of the range. Returns: int: Sum of squares of all even numbers in the range, or 0 if the range is invalid. >>> sum_of_squares_even(1, 10) 220 >>> sum_of_squares_even(3, 7) 52 >>> sum_of_squares_even(10, 10) 100 >>> sum_of_squares_even(6, 2) 0 >>> sum_of_squares_even(1, 1) 0 >>> sum_of_squares_even(2, 2) 4","solution":"def sum_of_squares_even(start: int, end: int) -> int: Calculate the sum of squares of all even numbers within the given range [start, end]. Parameters: start (int): The start of the range. end (int): The end of the range. Returns: int: Sum of squares of all even numbers in the range, or 0 if the range is invalid. if start > end: return 0 sum_squares = 0 for num in range(start, end + 1): if num % 2 == 0: sum_squares += num ** 2 return sum_squares"},{"question":"import re from datetime import datetime def extract_dates(messages: list) -> list: Extracts dates from a list of messages and returns them in the YYYY-MM-DD format. Args: messages (list): List of strings where each string is a user message. Returns: list: List of strings where each string is a date in the format YYYY-MM-DD. >>> messages = [ ... \\"Our meeting is scheduled for 2023-09-14.\\", ... \\"Can we reschedule the 15th of August, 2022 meeting?\\", ... \\"Let's catch up on 2021-12-01.\\" ... ] >>> extract_dates(messages) ['2023-09-14', '2022-08-15', '2021-12-01']","solution":"import re from datetime import datetime def extract_dates(messages: list) -> list: Extracts dates from a list of messages and returns them in the YYYY-MM-DD format. Args: messages (list): List of strings where each string is a user message. Returns: list: List of strings where each string is a date in the format YYYY-MM-DD. # List to store extracted dates extracted_dates = [] # Regex patterns for different date formats date_patterns = [ r'(d{4}-d{2}-d{2})', # YYYY-MM-DD r'(d{1,2})(?:st|nd|rd|th)? of (w+), (d{4})' # DDth of Month, YYYY ] # Month mapping for textual month recognition months = { 'January': '01', 'February': '02', 'March': '03', 'April': '04', 'May': '05', 'June': '06', 'July': '07', 'August': '08', 'September': '09', 'October': '10', 'November': '11', 'December': '12' } # Helper function to convert month name to number def month_to_num(month): return months.get(month, None) for message in messages: for pattern in date_patterns: matches = re.findall(pattern, message) if pattern == date_patterns[0]: # YYYY-MM-DD for match in matches: try: # Validate and append the date datetime.strptime(match, \\"%Y-%m-%d\\") extracted_dates.append(match) except ValueError: # Invalid date string continue elif pattern == date_patterns[1]: # DDth of Month, YYYY for day, month, year in matches: day = int(day) month_num = month_to_num(month) if month_num: date_str = f\\"{year}-{month_num}-{day:02}\\" try: # Validate and append the date datetime.strptime(date_str, \\"%Y-%m-%d\\") extracted_dates.append(date_str) except ValueError: # Invalid date string continue return extracted_dates"},{"question":"class SuffixArray: def __init__(self, text: str) -> None: Initialize the Suffix Array for the given string \`text\`. Args: text (str): The input string consisting of lowercase English letters. pass def build_suffix_array(self) -> None: Build the Suffix Array for the given string \`text\`. pass def find_smallest_suffix(self, prefix: str) -> str: Find and return the smallest suffix starting with the given prefix. Args: prefix (str): The prefix to search for. Returns: str: The smallest suffix starting with the given prefix. >>> sa = SuffixArray(\\"banana\\") >>> sa.build_suffix_array() >>> sa.find_smallest_suffix(\\"ban\\") 'banana' >>> sa.find_smallest_suffix(\\"nan\\") 'nana' >>> sa.find_smallest_suffix(\\"a\\") 'a' >>> sa.find_smallest_suffix(\\"x\\") '' pass def count_occurrences(self, substring: str) -> int: Count and return the number of occurrences of the given substring in the string. Args: substring (str): The substring to look for. Returns: int: The number of occurrences of the given substring. >>> sa = SuffixArray(\\"banana\\") >>> sa.build_suffix_array() >>> sa.count_occurrences(\\"ana\\") 2 >>> sa.count_occurrences(\\"bn\\") 0 >>> sa.count_occurrences(\\"nana\\") 1 >>> sa.count_occurrences(\\"a\\") 3 >>> sa.count_occurrences(\\"banana\\") 1 pass","solution":"class SuffixArray: def __init__(self, text: str) -> None: self.text = text self.suffix_array = [] def build_suffix_array(self) -> None: self.suffix_array = sorted((self.text[i:], i) for i in range(len(self.text))) def find_smallest_suffix(self, prefix: str) -> str: left, right = 0, len(self.suffix_array) while left < right: mid = (left + right) // 2 if self.suffix_array[mid][0].startswith(prefix): if mid == 0 or not self.suffix_array[mid-1][0].startswith(prefix): return self.suffix_array[mid][0] right = mid elif self.suffix_array[mid][0] < prefix: left = mid + 1 else: right = mid return \\"\\" def count_occurrences(self, substring: str) -> int: def lower_bound(prefix): left, right = 0, len(self.suffix_array) while left < right: mid = (left + right) // 2 if self.suffix_array[mid][0] < prefix: left = mid + 1 else: right = mid return left def upper_bound(prefix): left, right = 0, len(self.suffix_array) while left < right: mid = (left + right) // 2 if self.suffix_array[mid][0] <= prefix: left = mid + 1 else: right = mid return left lower = lower_bound(substring) upper = upper_bound(substring + \\"{\\") return upper - lower"},{"question":"def is_readable_on_one_row(word: str) -> bool: Determines if a given word is readable when typed on a single row of the QWERTY keyboard layout. >>> is_readable_on_one_row(\\"hello\\") == False >>> is_readable_on_one_row(\\"type\\") == True >>> is_readable_on_one_row(\\"qwerty\\") == True >>> is_readable_on_one_row(\\"asdfg\\") == True >>> is_readable_on_one_row(\\"moon\\") == False","solution":"def is_readable_on_one_row(word: str) -> bool: first_row = set(\\"qwertyuiop\\") second_row = set(\\"asdfghjkl\\") third_row = set(\\"zxcvbnm\\") # Determine which row the first character belongs to if word[0] in first_row: row = first_row elif word[0] in second_row: row = second_row else: row = third_row # Check if all characters of the word are in the same row for char in word: if char not in row: return False return True"},{"question":"from typing import List def k_permutations(arr: List[int], k: int) -> List[List[int]]: Generates all possible k-permutations of a given list of integers. Parameters: arr (list[int]): The input list of integers. k (int): The length of each permutation. Returns: list[list[int]]: A list of lists where each inner list is a k-permutation of the given list. Examples: >>> k_permutations([1, 2, 3], 2) [[1, 2], [1, 3], [2, 1], [2, 3], [3, 1], [3, 2]] >>> k_permutations([1, 2, 3], 3) [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]] >>> k_permutations([1, 2], 1) [[1], [2]] >>> k_permutations([], 0) [[]] pass","solution":"from itertools import permutations def k_permutations(arr, k): Generates all possible k-permutations of a given list of integers. Parameters: arr (list[int]): The input list of integers. k (int): The length of each permutation. Returns: list[list[int]]: A list of lists where each inner list is a k-permutation of the given list. # Edge case: if k is 0, we return a list with an empty permutation if k == 0: return [[]] # If k is greater than the length of the list, return an empty list if k > len(arr): return [] # Generate and return all k-permutations return list(map(list, permutations(arr, k)))"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def has_path_sum(root: TreeNode, target: int) -> bool: Determine if the binary tree has a root-to-leaf path such that the sum of the values along the path equals the given target sum. >>> root1 = TreeNode(5) >>> root1.left = TreeNode(4) >>> root1.right = TreeNode(8) >>> root1.left.left = TreeNode(11) >>> root1.left.left.left = TreeNode(7) >>> root1.left.left.right = TreeNode(2) >>> root1.right.left = TreeNode(13) >>> root1.right.right = TreeNode(4) >>> root1.right.right.right = TreeNode(1) >>> has_path_sum(root1, 22) True >>> root2 = TreeNode(1) >>> root2.left = TreeNode(2) >>> root2.right = TreeNode(3) >>> has_path_sum(root2, 5) False >>> root3 = TreeNode(1) >>> has_path_sum(root3, 1) True >>> has_path_sum(None, 0) False >>> root4 = TreeNode(1) >>> has_path_sum(root4, 2) False >>> root5 = TreeNode(1) >>> has_path_sum(root5, 1) True >>> root6 = TreeNode(1) >>> root6.left = TreeNode(2) >>> root6.left.left = TreeNode(3) >>> root6.left.left.left = TreeNode(4) >>> root6.left.left.left.left = TreeNode(5) >>> has_path_sum(root6, 15) True >>> root7 = TreeNode(1) >>> root7.right = TreeNode(2) >>> root7.right.right = TreeNode(3) >>> root7.right.right.right = TreeNode(4) >>> root7.right.right.right.right = TreeNode(5) >>> has_path_sum(root7, 15) True >>> root8 = TreeNode(1) >>> root8.left = TreeNode(2) >>> root8.right = TreeNode(3) >>> root8.left.left = TreeNode(4) >>> root8.left.right = TreeNode(5) >>> root8.right.left = TreeNode(6) >>> root8.right.right = TreeNode(7) >>> has_path_sum(root8, 8) True >>> has_path_sum(root8, 9) False","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def has_path_sum(root: TreeNode, target: int) -> bool: if not root: return False if not root.left and not root.right: return target == root.val target -= root.val return has_path_sum(root.left, target) or has_path_sum(root.right, target)"},{"question":"def max_tasks(tasks: list[tuple[int, int]]) -> int: Determines the maximum number of non-overlapping tasks that can be completed before their respective deadlines. Args: tasks (list): A list of tuples where each tuple contains two integers: the deadline by which the task needs to be completed, and the duration it takes to complete the task. Returns: int: The maximum number of non-overlapping tasks that can be completed within their deadlines. Examples: --------- >>> max_tasks([(4, 2), (4, 1), (2, 1), (3, 2)]) 3 >>> max_tasks([(5, 2)]) 1 >>> max_tasks([]) 0 >>> max_tasks([(5, 2), (5, 2), (5, 1)]) 3 >>> max_tasks([(3, 2), (4, 3), (2, 1)]) 2 >>> max_tasks([(4, 1), (4, 1), (4, 2), (4, 1)]) 3","solution":"def max_tasks(tasks): Returns the maximum number of non-overlapping tasks that can be completed without missing their deadlines. Args: tasks (list of tuple): List of tuples where each tuple contains deadline and duration of a task. Returns: int: The maximum number of tasks that can be completed. # Sort tasks by their deadlines first tasks.sort(key=lambda x: x[0]) current_time = 0 count = 0 for deadline, duration in tasks: if current_time + duration <= deadline: current_time += duration count += 1 return count"},{"question":"import numpy as np def compute_hog_histogram(image: np.ndarray, cell_size: int) -> np.ndarray: Computes the histogram of oriented gradients (HOG) for a given grayscale image. Parameters: - image: np.ndarray, input grayscale image - cell_size: int, size of the cell in pixels Returns: - 2D array of histograms for each cell pass def test_compute_hog_histogram_basic(): image = np.array([ [10, 20, 30, 40], [50, 60, 70, 80], [90, 100, 110, 120], [130, 140, 150, 160] ]) cell_size = 2 hog_hist = compute_hog_histogram(image, cell_size) assert hog_hist.shape == (2, 2, 9) # You can add more specific assertions based on expected histogram values def test_compute_hog_histogram_larger_image(): image = np.array([ [10, 20, 30, 40, 50, 60], [70, 80, 90, 100, 110, 120], [130, 140, 150, 160, 170, 180], [190, 200, 210, 220, 230, 240], [250, 255, 245, 235, 225, 215], [205, 195, 185, 175, 165, 155] ]) cell_size = 2 hog_hist = compute_hog_histogram(image, cell_size) assert hog_hist.shape == (3, 3, 9) # You can add more specific assertions based on expected histogram values def test_compute_hog_histogram_non_square_image(): image = np.array([ [10, 20, 30], [40, 50, 60], [70, 80, 90], [100, 110, 120] ]) cell_size = 2 hog_hist = compute_hog_histogram(image, cell_size) assert hog_hist.shape == (2, 1, 9) # You can add more specific assertions based on expected histogram values def test_compute_hog_histogram_edge_case(): image = np.array([ [10, 20], [30, 40] ]) cell_size = 2 hog_hist = compute_hog_histogram(image, cell_size) assert hog_hist.shape == (1, 1, 9) # You can add more specific assertions based on expected histogram values","solution":"import numpy as np def compute_hog_histogram(image: np.ndarray, cell_size: int) -> np.ndarray: Computes the histogram of oriented gradients (HOG) for a given grayscale image. Parameters: - image: np.ndarray, input grayscale image - cell_size: int, size of the cell in pixels Returns: - 2D array of histograms for each cell # Compute gradients gx = np.gradient(image, axis=1) gy = np.gradient(image, axis=0) # Calculate magnitude and orientation of gradient magnitude = np.sqrt(gx ** 2 + gy ** 2) orientation = np.arctan2(gy, gx) * 180 / np.pi # Convert radians to degrees orientation[orientation < 0] += 180 # Keep orientation within [0, 180] degrees # Get dimensions of the input image height, width = image.shape # Establish number of cells along x and y axes n_cells_x = width // cell_size n_cells_y = height // cell_size # Initialize a 3D numpy array to hold the HOG histograms hog_hist = np.zeros((n_cells_y, n_cells_x, 9)) # Binning initialization bins = np.arange(0, 181, 20) for y in range(n_cells_y): for x in range(n_cells_x): # Extract cell gradients and orientations cell_magnitude = magnitude[y * cell_size:(y + 1) * cell_size, x * cell_size:(x + 1) * cell_size] cell_orientation = orientation[y * cell_size:(y + 1) * cell_size, x * cell_size:(x + 1) * cell_size] hist, _ = np.histogram(cell_orientation, bins=bins, weights=cell_magnitude) hog_hist[y, x, :] = hist return hog_hist"},{"question":"def separate_and_sum(input_str: str) -> (list, int): Processes the input string, separates the integers and the words, sorts the words alphabetically, and returns the sorted list of words along with the sum of the integers. Parameters: input_str (str): The input string in the format \\"[1,apple,3,banana,5,orange]\\" Returns: tuple: A tuple containing a list of words sorted alphabetically and the sum of integers. >>> separate_and_sum(\\"[1,apple,3,banana,5,orange]\\") (['apple', 'banana', 'orange'], 9) >>> separate_and_sum(\\"[10,apple,20,banana,30,orange,40]\\") (['apple', 'banana', 'orange'], 100) >>> separate_and_sum(\\"[1,zebra,2,apple,3,yak,banana]\\") (['apple', 'banana', 'yak', 'zebra'], 6) >>> separate_and_sum(\\"[1000,apple,2000,banana,5000,orange]\\") (['apple', 'banana', 'orange'], 8000) >>> separate_and_sum(\\"[1,apple,1,banana,1,orange]\\") (['apple', 'banana', 'orange'], 3) >>> separate_and_sum(\\"[3,cherry,1,banana,2,apple]\\") (['apple', 'banana', 'cherry'], 6)","solution":"def separate_and_sum(input_str: str) -> (list, int): Processes the input string, separates the integers and the words, sorts the words alphabetically, and returns the sorted list of words along with the sum of the integers. Parameters: input_str (str): The input string in the format \\"[1,apple,3,banana,5,orange]\\" Returns: tuple: A tuple containing a list of words sorted alphabetically and the sum of integers. # Removing the square brackets and splitting the string by comma elements = input_str.strip('[]').split(',') integers = [] words = [] for element in elements: if element.isdigit(): integers.append(int(element)) else: words.append(element) sum_of_integers = sum(integers) sorted_words = sorted(words) return (sorted_words, sum_of_integers)"},{"question":"from threading import Thread from typing import List class Matrix: def __init__(self, rows: int, cols: int, data: List[List[int]]): Initialize the Matrix with the given dimensions and data. pass def __getitem__(self, idx: int) -> List[int]: Get the row at the specified index. pass def __str__(self) -> str: Return a string representation of the matrix. pass def threaded_matrix_multiplication(mat1: Matrix, mat2: Matrix) -> Matrix: Perform multi-threaded matrix multiplication and return the resulting matrix. >>> mat1 = Matrix(2, 3, [[1, 2, 3], [4, 5, 6]]) >>> mat2 = Matrix(3, 2, [[7, 8], [9, 10], [11, 12]]) >>> result = threaded_matrix_multiplication(mat1, mat2) >>> print(result) 58 64 139 154 >>> mat1 = Matrix(2, 3, [[1, 2, 3], [4, 5, 6]]) >>> mat2 = Matrix(2, 2, [[7, 8], [9, 10]]) >>> threaded_matrix_multiplication(mat1, mat2) Traceback (most recent call last): ... ValueError: Incompatible matrix dimensions pass","solution":"from threading import Thread from typing import List class Matrix: def __init__(self, rows: int, cols: int, data: List[List[int]]): if len(data) != rows or any(len(row) != cols for row in data): raise ValueError(\\"Data dimensions do not match specified row and column counts\\") self.rows = rows self.cols = cols self.data = data def __getitem__(self, idx: int) -> List[int]: return self.data[idx] def __str__(self) -> str: return 'n'.join(' '.join(map(str, row)) for row in self.data) def threaded_matrix_multiplication(mat1: Matrix, mat2: Matrix) -> Matrix: if mat1.cols != mat2.rows: raise ValueError(\\"Incompatible matrix dimensions\\") result_data = [[0 for _ in range(mat2.cols)] for _ in range(mat1.rows)] def compute_element(i, j): result_data[i][j] = sum(mat1[i][k] * mat2[k][j] for k in range(mat1.cols)) threads = [] for i in range(mat1.rows): for j in range(mat2.cols): thread = Thread(target=compute_element, args=(i, j)) threads.append(thread) thread.start() for thread in threads: thread.join() return Matrix(rows=mat1.rows, cols=mat2.cols, data=result_data)"},{"question":"from typing import List, Tuple def find_dominant_color(image: List[List[Tuple[int, int, int]]]) -> Tuple[int, int, int]: Determines the most frequently occurring color in an image. >>> find_dominant_color([ ... [(255, 0, 0), (255, 0, 0), (0, 255, 0)], ... [(0, 255, 0), (0, 255, 0), (0, 255, 0)] ... ]) (0, 255, 0) >>> find_dominant_color([ ... [(123, 234, 111), (123, 234, 111), (123, 234, 111)], ... [(111, 222, 333), (111, 222, 333), (123, 234, 111)] ... ]) (123, 234, 111) >>> find_dominant_color([ ... [(50, 50, 50)] ... ]) (50, 50, 50)","solution":"from typing import List, Tuple from collections import Counter def find_dominant_color(image: List[List[Tuple[int, int, int]]]) -> Tuple[int, int, int]: Determines the most frequently occurring color in an image. Args: image: List of List of RGB tuples representing the image. Returns: The most frequent color as an RGB tuple. # Flatten the list of lists into a single list of pixels flat_pixels = [pixel for row in image for pixel in row] # Count the frequency of each color color_counts = Counter(flat_pixels) # Return the color with the highest frequency dominant_color = color_counts.most_common(1)[0][0] return dominant_color"},{"question":"class CustomHashMap: def __init__(self): Initialize your data structure here. # Implement initialization logic def insert(self, key, value): :param key: The key for the entry. :param value: The value associated with the key. :return: None. # Implement insertion logic def get(self, key): :param key: The key to find the corresponding value. :return: The value associated with the key, or None if the key does not exist. # Implement retrieval logic def delete(self, key): :param key: The key for the entry to be removed. :return: None. # Implement deletion logic def test_insert_and_get(): hash_map = CustomHashMap() hash_map.insert(1, \\"a\\") assert hash_map.get(1) == \\"a\\" hash_map.insert(2, \\"b\\") assert hash_map.get(2) == \\"b\\" def test_get_nonexistent(): hash_map = CustomHashMap() assert hash_map.get(3) == None def test_update_value(): hash_map = CustomHashMap() hash_map.insert(1, \\"a\\") assert hash_map.get(1) == \\"a\\" hash_map.insert(1, \\"b\\") assert hash_map.get(1) == \\"b\\" def test_delete(): hash_map = CustomHashMap() hash_map.insert(1, \\"a\\") hash_map.delete(1) assert hash_map.get(1) == None def test_delete_nonexistent(): hash_map = CustomHashMap() hash_map.delete(1) # Should not raise any exception def test_collision_handling(): hash_map = CustomHashMap(size=1) # Forces collision hash_map.insert(1, \\"a\\") hash_map.insert(2, \\"b\\") hash_map.insert(3, \\"c\\") assert hash_map.get(1) == \\"a\\" assert hash_map.get(2) == \\"b\\" assert hash_map.get(3) == \\"c\\" hash_map.delete(2) assert hash_map.get(2) == None assert hash_map.get(1) == \\"a\\" assert hash_map.get(3) == \\"c\\"","solution":"class ListNode: def __init__(self, key=None, value=None, next=None): self.key = key self.value = value self.next = next class CustomHashMap: def __init__(self, size=1000): self.size = size self.table = [None] * self.size def _hash(self, key): return key % self.size def insert(self, key, value): index = self._hash(key) if self.table[index] is None: self.table[index] = ListNode(key, value) else: current = self.table[index] while current: if current.key == key: current.value = value return if current.next is None: current.next = ListNode(key, value) return current = current.next def get(self, key): index = self._hash(key) current = self.table[index] while current: if current.key == key: return current.value current = current.next return None def delete(self, key): index = self._hash(key) current = self.table[index] if not current: return if current.key == key: self.table[index] = current.next return prev = current while current: if current.key == key: prev.next = current.next return prev = current current = current.next"},{"question":"import string def count_words(file_path): Count the frequency of unique words in a text file. Args: file_path (str): The path to the text file. Returns: dict: A dictionary with words as keys and their frequencies as values. Example: >>> count_words('sample.txt') {'hello': 2, 'world': 3, 'python': 1, 'welcome': 1, 'to': 1, 'the': 1, 'of': 1, 'programming': 1}","solution":"import string def count_words(file_path): Count the frequency of unique words in a text file. Args: file_path (str): The path to the text file. Returns: dict: A dictionary with words as keys and their frequencies as values. word_count = {} with open(file_path, 'r') as file: for line in file: # Remove punctuation, convert to lowercase and split line into words line = line.translate(str.maketrans('', '', string.punctuation)).lower() words = line.split() for word in words: if word in word_count: word_count[word] += 1 else: word_count[word] = 1 return word_count"},{"question":"def count_valid_bracket_sequences(n: int) -> int: Returns the number of valid bracket sequences of length 2 * n. >>> count_valid_bracket_sequences(3) 5 >>> count_valid_bracket_sequences(1) 1 >>> count_valid_bracket_sequences(2) 2 >>> count_valid_bracket_sequences(0) 1 >>> count_valid_bracket_sequences(-1) Traceback (most recent call last): ... ValueError: Input must be non-negative >>> count_valid_bracket_sequences(\\"3\\") Traceback (most recent call last): ... ValueError: Input must be an integer","solution":"def count_valid_bracket_sequences(n: int) -> int: Returns the number of valid bracket sequences of length 2 * n. if not isinstance(n, int): raise ValueError(\\"Input must be an integer\\") if n < 0: raise ValueError(\\"Input must be non-negative\\") # Function to compute the nth Catalan number def catalan_number(n): if n == 0 or n == 1: return 1 catalan = [0] * (n + 1) catalan[0], catalan[1] = 1, 1 for i in range(2, n + 1): catalan[i] = 0 for j in range(i): catalan[i] += catalan[j] * catalan[i - j - 1] return catalan[n] return catalan_number(n)"},{"question":"import math def calculate_diagonal(width: float, height: float) -> float: Calculate the diagonal length of a rectangle using the Pythagorean theorem. Parameters: width (float): The width of the rectangle. height (float): The height of the rectangle. Returns: float: The diagonal length of the rectangle, rounded to 2 decimal places. Raises: ValueError: If the width or height is non-positive. Examples: >>> calculate_diagonal(3, 4) 5.0 >>> calculate_diagonal(5, 12) 13.0 pass # Test cases import pytest def test_calculate_diagonal_simple(): assert calculate_diagonal(3, 4) == 5.0 def test_calculate_diagonal_two(): assert calculate_diagonal(5, 12) == 13.0 def test_calculate_diagonal_three(): assert calculate_diagonal(8, 15) == 17.0 def test_calculate_diagonal_with_zero(): with pytest.raises(ValueError, match=\\"Width and height must be positive numbers\\"): calculate_diagonal(0, 5) def test_calculate_diagonal_with_negative(): with pytest.raises(ValueError, match=\\"Width and height must be positive numbers\\"): calculate_diagonal(10, -2) def test_calculate_diagonal_floats(): assert calculate_diagonal(1.5, 2.5) == 2.92 def test_calculate_diagonal_large_numbers(): assert calculate_diagonal(300000, 400000) == 500000.0 def test_calculate_diagonal_minimum_positive(): assert calculate_diagonal(0.0001, 0.0001) == round(math.sqrt(2) * 0.0001, 2)","solution":"import math def calculate_diagonal(width: float, height: float) -> float: Calculate the diagonal length of a rectangle using the Pythagorean theorem. Parameters: width (float): The width of the rectangle. height (float): The height of the rectangle. Returns: float: The diagonal length of the rectangle, rounded to 2 decimal places. Raises: ValueError: If the width or height is non-positive. if width <= 0 or height <= 0: raise ValueError(\\"Width and height must be positive numbers\\") diagonal = math.sqrt(width**2 + height**2) return round(diagonal, 2)"},{"question":"from datetime import datetime def get_overdue_tasks(tasks, current_date): Returns a list of overdue tasks sorted by due date in ascending order. Parameters: tasks (list): A list of task dictionaries. Each dictionary contains \\"task_id\\", \\"due_date\\", and \\"task_name\\". current_date (string): The current date in \\"YYYY-MM-DD\\" format. Returns: list: A list of dictionaries, each containing \\"task_id\\" and \\"task_name\\" for overdue tasks. Example: >>> tasks = [ ... {\\"task_id\\": 1, \\"due_date\\": \\"2023-01-01\\", \\"task_name\\": \\"Task 1\\"}, ... {\\"task_id\\": 2, \\"due_date\\": \\"2023-05-01\\", \\"task_name\\": \\"Task 2\\"}, ... {\\"task_id\\": 3, \\"due_date\\": \\"2023-03-15\\", \\"task_name\\": \\"Task 3\\"} ... ] >>> current_date = \\"2023-04-01\\" >>> get_overdue_tasks(tasks, current_date) [{'task_id': 1, 'task_name': 'Task 1'}, {'task_id': 3, 'task_name': 'Task 3'}] def test_no_tasks(): assert get_overdue_tasks([], \\"2023-04-01\\") == [] def test_no_overdue_tasks(): tasks = [ {\\"task_id\\": 1, \\"due_date\\": \\"2023-05-01\\", \\"task_name\\": \\"Task 1\\"}, {\\"task_id\\": 2, \\"due_date\\": \\"2023-05-15\\", \\"task_name\\": \\"Task 2\\"} ] assert get_overdue_tasks(tasks, \\"2023-04-01\\") == [] def test_some_overdue_tasks(): tasks = [ {\\"task_id\\": 1, \\"due_date\\": \\"2023-01-01\\", \\"task_name\\": \\"Task 1\\"}, {\\"task_id\\": 2, \\"due_date\\": \\"2023-05-01\\", \\"task_name\\": \\"Task 2\\"}, {\\"task_id\\": 3, \\"due_date\\": \\"2023-03-15\\", \\"task_name\\": \\"Task 3\\"} ] overdue = get_overdue_tasks(tasks, \\"2023-04-01\\") assert overdue == [ {\\"task_id\\": 1, \\"task_name\\": \\"Task 1\\"}, {\\"task_id\\": 3, \\"task_name\\": \\"Task 3\\"} ] def test_all_overdue_tasks(): tasks = [ {\\"task_id\\": 1, \\"due_date\\": \\"2023-01-01\\", \\"task_name\\": \\"Task 1\\"}, {\\"task_id\\": 2, \\"due_date\\": \\"2023-03-01\\", \\"task_name\\": \\"Task 2\\"}, {\\"task_id\\": 3, \\"due_date\\": \\"2023-03-15\\", \\"task_name\\": \\"Task 3\\"} ] overdue = get_overdue_tasks(tasks, \\"2023-04-01\\") assert overdue == [ {\\"task_id\\": 1, \\"task_name\\": \\"Task 1\\"}, {\\"task_id\\": 2, \\"task_name\\": \\"Task 2\\"}, {\\"task_id\\": 3, \\"task_name\\": \\"Task 3\\"} ] def test_due_date_equal_to_current_date(): tasks = [ {\\"task_id\\": 1, \\"due_date\\": \\"2023-04-01\\", \\"task_name\\": \\"Task 1\\"}, {\\"task_id\\": 2, \\"due_date\\": \\"2023-05-01\\", \\"task_name\\": \\"Task 2\\"}, {\\"task_id\\": 3, \\"due_date\\": \\"2023-03-15\\", \\"task_name\\": \\"Task 3\\"} ] overdue = get_overdue_tasks(tasks, \\"2023-04-01\\") assert overdue == [ {\\"task_id\\": 3, \\"task_name\\": \\"Task 3\\"} ]","solution":"from datetime import datetime def get_overdue_tasks(tasks, current_date): Returns a list of overdue tasks sorted by due date in ascending order. Parameters: tasks (list): A list of task dictionaries. Each dictionary contains \\"task_id\\", \\"due_date\\", and \\"task_name\\". current_date (string): The current date in \\"YYYY-MM-DD\\" format. Returns: list: A list of dictionaries, each containing \\"task_id\\" and \\"task_name\\" for overdue tasks. # Convert current_date to a datetime object current_date = datetime.strptime(current_date, \\"%Y-%m-%d\\") # Filter out the overdue tasks overdue_tasks = [ {\\"task_id\\": task[\\"task_id\\"], \\"task_name\\": task[\\"task_name\\"]} for task in tasks if datetime.strptime(task[\\"due_date\\"], \\"%Y-%m-%d\\") < current_date ] # Sort overdue tasks by due_date overdue_tasks.sort(key=lambda task: datetime.strptime( next(t for t in tasks if t[\\"task_id\\"] == task[\\"task_id\\"])[\\"due_date\\"], \\"%Y-%m-%d\\" )) return overdue_tasks"},{"question":"# Maximal Network Rank In this task, you are given an undirected graph represented as an adjacency list. Your goal is to determine the maximal network rank between any two vertices. The network rank of a pair of vertices is defined as the total number of unique edges incident to either vertex. Your Task Write a function \`maximal_network_rank\` that computes the maximal network rank for the given graph. * **Input**: - \`n\`: Integer denoting the number of vertices. - \`roads\`: List of lists, where each inner list contains two integers representing a bidirectional road between vertex \`u\` and vertex \`v\`. * **Output**: - Return the maximal network rank as an integer. Constraints * (2 leq n leq 100) * (0 leq text{len(roads)} leq 5000) * Each vertex (0 leq u, v < n). * No duplicate edges between the same pair of vertices. def maximal_network_rank(n, roads): from collections import defaultdict # Initialize adjacency set to store roads graph = defaultdict(set) # Populate the graph with roads for u, v in roads: graph[u].add(v) graph[v].add(u) max_rank = 0 # Iterate over all pairs of vertices for i in range(n): for j in range(i + 1, n): # Calculate the network rank of the pair (i, j) current_rank = len(graph[i]) + len(graph[j]) - (1 if j in graph[i] else 0) # Update the maximum network rank found max_rank = max(max_rank, current_rank) return max_rank Example Usage n = 4 roads = [[0, 1], [0, 3], [1, 2], [1, 3]] print(maximal_network_rank(n, roads)) # Output: 4 Unit Test: def test_maximal_network_rank_basic(): assert maximal_network_rank(4, [[0, 1], [0, 3], [1, 2], [1, 3]]) == 4 def test_maximal_network_rank_no_roads(): assert maximal_network_rank(3, []) == 0 def test_maximal_network_rank_fully_connected(): assert maximal_network_rank(4, [[0, 1], [0, 2], [0, 3], [1, 2], [1, 3], [2, 3]]) == 5 def test_maximal_network_rank_two_vertices_one_road(): assert maximal_network_rank(2, [[0, 1]]) == 1 def test_maximal_network_rank_sparse_graph(): assert maximal_network_rank(5, [[0, 1], [2, 3]]) == 2 def test_maximal_network_rank_single_vertex_with_road(): assert maximal_network_rank(5, [[0, 4], [1, 4], [2, 4], [3, 4]]) == 4 def test_maximal_network_rank_disconnected_subgraphs(): assert maximal_network_rank(6, [[0, 1], [2, 3], [4, 5]]) == 2","solution":"def maximal_network_rank(n, roads): from collections import defaultdict # Initialize adjacency set to store roads graph = defaultdict(set) # Populate the graph with roads for u, v in roads: graph[u].add(v) graph[v].add(u) max_rank = 0 # Iterate over all pairs of vertices for i in range(n): for j in range(i + 1, n): # Calculate the network rank of the pair (i, j) current_rank = len(graph[i]) + len(graph[j]) - (1 if j in graph[i] else 0) # Update the maximum network rank found max_rank = max(max_rank, current_rank) return max_rank"},{"question":"from typing import List def matrix_transpose(matrix: List[List[int]]) -> List[List[int]]: Calculate the transpose of a given matrix. Parameters: matrix (List[List[int]]) : A 2D list (list of lists) where each list represents a row in the matrix. Returns: List[List[int]] : The transpose of the input matrix. Examples: >>> matrix_transpose([[1, 2], [3, 4], [5, 6]]) [[1, 3, 5], [2, 4, 6]] >>> matrix_transpose([[1]]) [[1]] pass def matrix_dot_product(matrix_a: List[List[int]], matrix_b: List[List[int]]) -> List[List[int]]: Calculate the dot product of two matrices. Parameters: matrix_a (List[List[int]]) : The first matrix in the dot product operation. matrix_b (List[List[int]]) : The second matrix in the dot product operation. Returns: List[List[int]] : The resulting matrix from the dot product operation. Raises: ValueError: If the number of columns in matrix_a does not match the number of rows in matrix_b. Examples: >>> matrix_dot_product([[1, 2], [3, 4]], [[2, 0], [1, 2]]) [[4, 4], [10, 8]] >>> matrix_dot_product([[2]], [[3]]) [[6]] pass # Unit Tests def test_matrix_transpose(): assert matrix_transpose([[1, 2], [3, 4], [5, 6]]) == [[1, 3, 5], [2, 4, 6]] assert matrix_transpose([[1]]) == [[1]] assert matrix_transpose([[1, 2, 3]]) == [[1], [2], [3]] assert matrix_transpose([[1], [2], [3]]) == [[1, 2, 3]] assert matrix_transpose([[1, 2], [3, 4]]) == [[1, 3], [2, 4]] def test_matrix_dot_product(): assert matrix_dot_product([[1, 2], [3, 4]], [[2, 0], [1, 2]]) == [[4, 4], [10, 8]] assert matrix_dot_product([[2]], [[3]]) == [[6]] assert matrix_dot_product([[2, 3]], [[3], [4]]) == [[2*3 + 3*4]] assert matrix_dot_product([[1, 2], [3, 4]], [[1, 2], [3, 4]]) == [[1*1 + 2*3, 1*2 + 2*4], [3*1 + 4*3, 3*2 + 4*4]] def test_matrix_dot_product_incompatible(): import pytest with pytest.raises(ValueError, match=\\"Incompatible matrices for dot product\\"): matrix_dot_product([[1, 2]], [[1, 2]]) if __name__ == \\"__main__\\": test_matrix_transpose() test_matrix_dot_product() test_matrix_dot_product_incompatible() print(\\"All tests passed!\\")","solution":"from typing import List def matrix_transpose(matrix: List[List[int]]) -> List[List[int]]: Calculate the transpose of a given matrix. Args: matrix (List[List[int]]): A 2D list (list of lists) where each list represents a row in the matrix. Returns: List[List[int]]: The transpose of the input matrix. return [list(row) for row in zip(*matrix)] def matrix_dot_product(matrix_a: List[List[int]], matrix_b: List[List[int]]) -> List[List[int]]: Calculate the dot product of two matrices. Args: matrix_a (List[List[int]]): The first matrix in the dot product operation. matrix_b (List[List[int]]): The second matrix in the dot product operation. Returns: List[List[int]]: The resulting matrix from the dot product operation. Raises: ValueError: If the number of columns in matrix_a does not match the number of rows in matrix_b. if len(matrix_a[0]) != len(matrix_b): raise ValueError(\\"Incompatible matrices for dot product.\\") # Transpose matrix_b for easier handling. matrix_b_transposed = matrix_transpose(matrix_b) # Calculate dot product dot_product = [ [ sum(a * b for a, b in zip(row_a, col_b)) for col_b in matrix_b_transposed ] for row_a in matrix_a ] return dot_product"},{"question":"from typing import List, Tuple def is_schedule_valid(courses: List[Tuple[int, int]]) -> bool: Determines if the student's schedule is valid without overlapping courses. Args: courses (List[Tuple[int, int]]): List of tuples where each tuple contains the start and end times of a course. Returns: bool: True if the schedule is valid (no overlaps), False otherwise Examples: >>> is_schedule_valid([(9, 12), (13, 15), (16, 18)]) True >>> is_schedule_valid([(9, 12), (11, 14), (16, 18)]) False >>> is_schedule_valid([(8, 10), (10, 12), (12, 14)]) True >>> is_schedule_valid([(10, 11), (12, 13), (11, 12)]) True def test_non_overlapping_courses(): assert is_schedule_valid([(9, 12), (13, 15), (16, 18)]) == True def test_overlapping_courses(): assert is_schedule_valid([(9, 12), (11, 14), (16, 18)]) == False def test_consecutive_courses(): assert is_schedule_valid([(8, 10), (10, 12), (12, 14)]) == True def test_edge_case_courses(): assert is_schedule_valid([(10, 11), (11, 12), (12, 13), (13, 14)]) == True def test_single_course(): assert is_schedule_valid([(10, 11)]) == True def test_encompassing_course(): assert is_schedule_valid([(9, 12), (10, 11)]) == False def test_exact_overlap(): assert is_schedule_valid([(9, 12), (12, 15)]) == True assert is_schedule_valid([(9, 12), (11, 12)]) == False","solution":"from typing import List, Tuple def is_schedule_valid(courses: List[Tuple[int, int]]) -> bool: Determines if the student's schedule is valid without overlapping courses. Args: courses (List[Tuple[int, int]]): List of tuples where each tuple contains the start and end times of a course. Returns: bool: True if the schedule is valid (no overlaps), False otherwise # Sort courses based on their start times courses.sort(key=lambda x: x[0]) for i in range(1, len(courses)): # Compare the end time of the previous course with the start time of the current course if courses[i-1][1] > courses[i][0]: return False return True"},{"question":"import numpy as np class Loss: @staticmethod def mean_squared_error(y_pred, y_true): Calculate the mean squared error (MSE) and its gradient. >>> mse, grad = Loss.mean_squared_error(np.array([2.0, 3.0, 4.0]), np.array([1.0, 2.0, 3.0])) >>> np.allclose(mse, 1.0) True >>> np.allclose(grad, [0.66666667, 0.66666667, 0.66666667]) True >>> # Edge case with different shapes >>> try: ... Loss.mean_squared_error(np.array([1.0, 2.0]), np.array([1.0, 2.0, 3.0])) ... except ValueError as e: ... str(e) 'Shape of y_pred and y_true must be the same.' >>> # Edge case with NaN values >>> try: ... Loss.mean_squared_error(np.array([np.nan, 2.0, 3.0]), np.array([1.0, 2.0, 3.0])) ... except ValueError as e: ... str(e) 'Input arrays contain NaN values.' >>> # Edge case with Inf values >>> try: ... Loss.mean_squared_error(np.array([np.inf, 2.0, 3.0]), np.array([1.0, 2.0, 3.0])) ... except ValueError as e: ... str(e) 'Input arrays contain Inf values.' >>> # Large input case >>> y_pred = np.random.rand(100000) >>> y_true = np.random.rand(100000) >>> mse, grad = Loss.mean_squared_error(y_pred, y_true) >>> mse >= 0, grad.shape == y_pred.shape (True, True) >>> # Zero error case >>> mse, grad = Loss.mean_squared_error(np.array([1.0, 2.0, 3.0]), np.array([1.0, 2.0, 3.0])) >>> np.allclose(mse, 0.0) True >>> np.allclose(grad, [0.0, 0.0, 0.0]) True pass","solution":"import numpy as np class Loss: @staticmethod def mean_squared_error(y_pred, y_true): # Check for the same shape of input arrays if y_pred.shape != y_true.shape: raise ValueError(\\"Shape of y_pred and y_true must be the same.\\") # Check for NaN or Inf values if np.any(np.isnan(y_pred)) or np.any(np.isnan(y_true)): raise ValueError(\\"Input arrays contain NaN values.\\") if np.any(np.isinf(y_pred)) or np.any(np.isinf(y_true)): raise ValueError(\\"Input arrays contain Inf values.\\") # Compute Mean Squared Error mse = np.mean((y_pred - y_true) ** 2) # Compute gradient gradient = 2 * (y_pred - y_true) / y_true.size return mse, gradient"},{"question":"def sort_twist(arr: list[int]) -> list[int]: Sorts the list such that all odd numbers come before all even numbers, maintaining their relative order. :param arr: A list of integers. :return: A list of integers sorted with all odds first and evens after (both maintaining original order). :raises ValueError: If the input is not a list of integers. >>> sort_twist([3, 1, 2, 4, 7, 8, 5]) [3, 1, 7, 5, 2, 4, 8] >>> sort_twist([10, 21, 22, 9, 4, 18]) [21, 9, 10, 22, 4, 18] >>> sort_twist([1, 11, 3, 7, 9]) [1, 11, 3, 7, 9] >>> sort_twist([2, 4, 6, 8]) [2, 4, 6, 8] >>> sort_twist([]) [] >>> sort_twist(\\"string input\\") Traceback (most recent call last): ... ValueError: the value of input must be a list of integers # Your code here","solution":"def sort_twist(arr): Sorts the list such that all odd numbers come before all even numbers, maintaining their relative order. :param arr: A list of integers. :return: A list of integers sorted with all odds first and evens after (both maintaining original order). :raises ValueError: If the input is not a list of integers. if not isinstance(arr, list) or not all(isinstance(x, int) for x in arr): raise ValueError(\\"the value of input must be a list of integers\\") odds = [x for x in arr if x % 2 != 0] evens = [x for x in arr if x % 2 == 0] return odds + evens"},{"question":"import heapq from collections import defaultdict class LogisticsGraph: A class to represent the logistics network using a weighted directed graph and implementing Dijkstra's algorithm to find the shortest path between two nodes. def __init__(self, edges): Initializes the graph. edges: List of tuples, where each tuple is (source, destination, weight). def add_edge(self, source, destination, weight): Adds an edge to the graph. source: Integer denoting the starting node of the edge. destination: Integer denoting the ending node of the edge. weight: Positive integer denoting the weight of the edge. def shortest_path(self, source, destination): Finds the shortest path from the source node to the destination node using Dijkstra's algorithm. source: Integer denoting the source node. destination: Integer denoting the destination node. Returns: Float representing the shortest path distance, or None if no path exists. >>> edges = [(1, 2, 4), (1, 3, 2), (2, 3, 5), (2, 4, 10), (3, 4, 3)] >>> graph = LogisticsGraph(edges) >>> graph.shortest_path(1, 4) 5 >>> graph.shortest_path(1, 5) None","solution":"import heapq from collections import defaultdict, deque class LogisticsGraph: def __init__(self, edges): Initializes the graph. edges: List of tuples, where each tuple is (source, destination, weight). self.graph = defaultdict(list) for source, destination, weight in edges: self.add_edge(source, destination, weight) def add_edge(self, source, destination, weight): Adds an edge to the graph. source: Integer denoting the starting node of the edge. destination: Integer denoting the ending node of the edge. weight: Positive integer denoting the weight of the edge. self.graph[source].append((destination, weight)) self.graph[destination].append((source, weight)) # Assuming undirected graph def shortest_path(self, source, destination): Finds the shortest path from the source node to the destination node using Dijkstra's algorithm. source: Integer denoting the source node. destination: Integer denoting the destination node. Returns: Float representing the shortest path distance, or None if no path exists. heap = [(0, source)] distances = {source: 0} visited = set() while heap: current_dist, current_node = heapq.heappop(heap) if current_node in visited: continue visited.add(current_node) if current_node == destination: return current_dist for neighbor, weight in self.graph[current_node]: if neighbor in visited: continue new_dist = current_dist + weight if new_dist < distances.get(neighbor, float('inf')): distances[neighbor] = new_dist heapq.heappush(heap, (new_dist, neighbor)) return None"},{"question":"def reverse_words_in_string(s: str) -> str: Reverses the order of words in a given string without reversing the individual words. >>> reverse_words_in_string(\\"the sky is blue\\") \\"blue is sky the\\" >>> reverse_words_in_string(\\"hello world\\") \\"world hello\\" >>> reverse_words_in_string(\\"coding is fun\\") \\"fun is coding\\" >>> reverse_words_in_string(\\"keep it simple\\") \\"simple it keep\\"","solution":"def reverse_words_in_string(s: str) -> str: Reverses the order of words in a given string without reversing the individual words. Parameters: s (str): Input string of lowercase alphabets and spaces. Returns: str: String with the order of the words reversed. return ' '.join(s.split()[::-1])"},{"question":"import re from collections import defaultdict def word_count(text: str) -> dict: Write a function that counts the number of occurrences of each word in a given string. Words are defined as sequences of alphabetic characters, and should be considered case-insensitive. >>> word_count(\\"Hello world! Hello!\\") {'hello': 2, 'world': 1} >>> word_count(\\"Python programming is fun. Isn't it? Programming, python!\\") {'python': 2, 'programming': 2, 'is': 1, 'fun': 1, 'isn': 1, 't': 1, 'it': 1} >>> word_count(\\"Data science is the future. Data science, AI, and ML.\\") {'data': 2, 'science': 2, 'is': 1, 'the': 1, 'future': 1, 'ai': 1, 'and': 1, 'ml': 1}","solution":"import re from collections import defaultdict def word_count(text: str) -> dict: Returns a dictionary of word counts from the input text. Words are defined as sequences of alphabetic characters, and the function is case-insensitive. # Convert the text to lowercase text = text.lower() # Use regex to find all words (sequences of alphabetic characters) words = re.findall(r'b[a-z]+b', text) # Use defaultdict to count occurrences of each word word_counts = defaultdict(int) for word in words: word_counts[word] += 1 return dict(word_counts)"},{"question":"class BSTNode: def __init__(self, value): self.value = value self.left = None self.right = None def insert(root, value): Insert a new value into the BST. Arguments: root -- the root node of the BST value -- the integer value to be inserted Returns: The root node of the BST after insertion. def range_sum_bst(root, low, high): Calculate the sum of all values in the BST that fall within the specified range [low, high]. Arguments: root -- the root node of the BST low -- the lower bound of the range (inclusive) high -- the upper bound of the range (inclusive) Returns: The sum of all values within the range [low, high]. def build_bst_from_list(values): Build a BST from a list of values. Arguments: values -- a list of integer values Returns: The root node of the constructed BST. # Unit Test def test_insert(): root = None values = [10, 5, 15, 3, 7, 18] for value in values: root = insert(root, value) assert(root.value == 10) assert(root.left.value == 5) assert(root.right.value == 15) assert(root.left.left.value == 3) assert(root.left.right.value == 7) assert(root.right.right.value == 18) def test_range_sum_bst(): values = [10, 5, 15, 3, 7, 18] root = build_bst_from_list(values) assert range_sum_bst(root, 7, 15) == 32 # 7 + 10 + 15 assert range_sum_bst(root, 6, 10) == 17 # 7 + 10 assert range_sum_bst(root, 15, 18) == 33 # 15 + 18 assert range_sum_bst(root, 5, 5) == 5 # 5 assert range_sum_bst(root, 3, 3) == 3 # 3 assert range_sum_bst(root, 1, 2) == 0 # no elements in the range def test_build_bst_from_list(): values = [10, 5, 15, 3, 7, 18] root = build_bst_from_list(values) assert(root.value == 10) assert(root.left.value == 5) assert(root.right.value == 15) assert(root.left.left.value == 3) assert(root.left.right.value == 7) assert(root.right.right.value == 18) values = [] root = build_bst_from_list(values) assert(root is None)","solution":"class BSTNode: def __init__(self, value): self.value = value self.left = None self.right = None def insert(root, value): if root is None: return BSTNode(value) if value < root.value: root.left = insert(root.left, value) else: root.right = insert(root.right, value) return root def range_sum_bst(root, low, high): if root is None: return 0 if root.value > high: return range_sum_bst(root.left, low, high) if root.value < low: return range_sum_bst(root.right, low, high) return root.value + range_sum_bst(root.left, low, high) + range_sum_bst(root.right, low, high) def build_bst_from_list(values): root = None for value in values: root = insert(root, value) return root"},{"question":"[Completion Task in Python] Task: Implement a function that trains a Random Forest Regressor on a given dataset and evaluates the model using RMSE. def train_random_forest(features: np.ndarray, target: np.ndarray, n_estimators: int, max_depth: int, test_size: float) -> float: Trains a Random Forest Regressor on the provided dataset and evaluates the model using RMSE. Parameters: - features: np.ndarray, Training feature dataset. Shape (n_samples, n_features) - target: np.ndarray, Target values corresponding to the feature dataset. Shape (n_samples,) - n_estimators: int, The number of trees in the forest. - max_depth: int, The maximum depth of the trees. - test_size: float, The proportion of the dataset to include in the test split. Returns: - float: The RMSE score of the model on the test set. import numpy as np from sklearn.ensemble import RandomForestRegressor from sklearn.metrics import mean_squared_error from sklearn.model_selection import train_test_split def train_random_forest(features: np.ndarray, target: np.ndarray, n_estimators: int, max_depth: int, test_size: float) -> float: # Split the dataset into training and testing sets X_train, X_test, y_train, y_test = train_test_split(features, target, test_size=test_size, random_state=42) # Initialize and train the Random Forest Regressor rf_model = RandomForestRegressor(n_estimators=n_estimators, max_depth=max_depth, random_state=42) rf_model.fit(X_train, y_train) # Make predictions on the test set y_pred = rf_model.predict(X_test) # Calculate RMSE rmse = np.sqrt(mean_squared_error(y_test, y_pred)) return rmse","solution":"import numpy as np from sklearn.ensemble import RandomForestRegressor from sklearn.metrics import mean_squared_error from sklearn.model_selection import train_test_split def train_random_forest(features: np.ndarray, target: np.ndarray, n_estimators: int, max_depth: int, test_size: float) -> float: Trains a Random Forest Regressor on the provided dataset and evaluates the model using RMSE. Parameters: - features: np.ndarray, Training feature dataset. Shape (n_samples, n_features) - target: np.ndarray, Target values corresponding to the feature dataset. Shape (n_samples,) - n_estimators: int, The number of trees in the forest. - max_depth: int, The maximum depth of the trees. - test_size: float, The proportion of the dataset to include in the test split. Returns: - float: The RMSE score of the model on the test set. # Split the dataset into training and testing sets X_train, X_test, y_train, y_test = train_test_split(features, target, test_size=test_size, random_state=42) # Initialize and train the Random Forest Regressor rf_model = RandomForestRegressor(n_estimators=n_estimators, max_depth=max_depth, random_state=42) rf_model.fit(X_train, y_train) # Make predictions on the test set y_pred = rf_model.predict(X_test) # Calculate RMSE rmse = np.sqrt(mean_squared_error(y_test, y_pred)) return rmse"},{"question":"def search_books_by_keyword(keyword: str) -> list: Searches for books containing the given keyword in their title or description and returns a list of dictionaries with the book title, author, and a snippet of the description. Args: keyword (str): The keyword to search for in book titles and descriptions. Returns: list: List of dictionaries where each dictionary has keys 'title', 'author', 'snippet'. >>> results = search_books_by_keyword(\\"thinking\\") >>> len(results) 1 >>> results[0]['title'] \\"The Magic of Thinking Big\\" >>> results[0]['author'] \\"David Schwartz\\" >>> \\"principles of thinking big\\" in results[0]['snippet'].lower() True >>> results = search_books_by_keyword(\\"magic\\") >>> len(results) 3 >>> any(book['title'] == \\"The Magic of Thinking Big\\" for book in results) True >>> any(book['title'] == \\"Fantasy Magic\\" for book in results) True >>> any(book['title'] == \\"Non-magic Book\\" for book in results) True >>> results = search_books_by_keyword(\\"nonexistent\\") >>> len(results) 0 >>> results = search_books_by_keyword(\\"MAGIC\\") >>> len(results) 3 >>> any(book['title'] == \\"The Magic of Thinking Big\\" for book in results) True >>> any(book['title'] == \\"Fantasy Magic\\" for book in results) True >>> any(book['title'] == \\"Non-magic Book\\" for book in results) True >>> results = search_books_by_keyword(\\"principles\\") >>> len(results) 1 >>> results[0]['title'] \\"The Magic of Thinking Big\\" >>> \\"explains the principles of thinking\\" in results[0]['snippet'] True","solution":"# Sample books_data for testing books_data = [ {\\"title\\": \\"The Magic of Thinking Big\\", \\"author\\": \\"David Schwartz\\", \\"description\\": \\"This book explains the principles of thinking big, setting high goals, and achieving them through a series of practical steps.\\"}, {\\"title\\": \\"Fantasy Magic\\", \\"author\\": \\"John Doe\\", \\"description\\": \\"An epic tale of magic and adventure set in a mystical land with numerous challenges.\\"}, {\\"title\\": \\"Non-magic Book\\", \\"author\\": \\"Jane Roe\\", \\"description\\": \\"This book has nothing to do with magic, rather it is about science and facts.\\"}, # More books... ] def search_books_by_keyword(keyword: str) -> list: Searches for books containing the given keyword in their title or description and returns a list of dictionaries with the book title, author, and a snippet of the description. Args: keyword (str): The keyword to search for in book titles and descriptions. Returns: list: List of dictionaries where each dictionary has keys 'title', 'author', 'snippet'. keyword = keyword.lower() results = [] for book in books_data: title = book['title'] author = book['author'] description = book['description'] title_lower = title.lower() description_lower = description.lower() if keyword in title_lower or keyword in description_lower: if keyword in description_lower: start_idx = description_lower.find(keyword) snippet_start = max(0, start_idx - 15) snippet_end = min(len(description), start_idx + 15 + len(keyword)) snippet = description[snippet_start:snippet_end] else: snippet = \\"\\" results.append({ 'title': title, 'author': author, 'snippet': snippet }) return results"},{"question":"from typing import List, Optional import heapq class ListNode: def __init__(self, val: int = 0, next: Optional['ListNode'] = None): self.val = val self.next = next def merge_k_sorted_lists(lists: List[Optional[ListNode]]) -> Optional[ListNode]: Merge k sorted linked lists into a single sorted linked list. >>> list1 = ListNode(1, ListNode(4, ListNode(5))) >>> list2 = ListNode(1, ListNode(3, ListNode(4))) >>> list3 = ListNode(2, ListNode(6)) >>> merged_head = merge_k_sorted_lists([list1, list2, list3]) >>> linkedlist_to_list(merged_head) [1, 1, 2, 3, 4, 4, 5, 6] >>> list1 = ListNode(1) >>> list2 = ListNode(0) >>> merged_head = merge_k_sorted_lists([list1, list2]) >>> linkedlist_to_list(merged_head) [0, 1]","solution":"from heapq import heappush, heappop from typing import List, Optional class ListNode: def __init__(self, val: int = 0, next: Optional['ListNode'] = None): self.val = val self.next = next def merge_k_sorted_lists(lists: List[Optional[ListNode]]) -> Optional[ListNode]: heap = [] # Initialize the heap with the head of each list for index, node in enumerate(lists): if node: heappush(heap, (node.val, index, node)) dummy = ListNode(0) current = dummy while heap: value, index, node = heappop(heap) current.next = ListNode(value) current = current.next if node.next: heappush(heap, (node.next.val, index, node.next)) return dummy.next"},{"question":"def has_temperature_inversion(temperatures: List[int]) -> bool: Determines if there's any temperature inversion in the list (a day's temperature being lower than the previous day's temperature). :param temperatures: List[int] - List of daily temperatures :return: boolean - True if there is at least one inversion, False otherwise >>> has_temperature_inversion([70, 72, 68, 69, 75]) == True >>> has_temperature_inversion([60, 65, 70, 75, 80]) == False >>> has_temperature_inversion([30, 25, 20, 15, 10]) == True >>> has_temperature_inversion([]) == False >>> has_temperature_inversion([50]) == False","solution":"def has_temperature_inversion(temperatures): Determines if there's any temperature inversion in the list (a day's temperature being lower than the previous day's temperature). :param temperatures: List[int] - List of daily temperatures :return: boolean - True if there is at least one inversion, False otherwise for i in range(1, len(temperatures)): if temperatures[i] < temperatures[i - 1]: return True return False"},{"question":"def evaluate_expression(expression: str) -> float: Evaluate a mathematical expression represented as a string. The expression includes real numbers, parentheses, and operators \`+\`, \`-\`, \`*\`, and \`/\`, and should be evaluated using the appropriate order of operations (PEMDAS/BODMAS rules). >>> evaluate_expression(\\"3 + 5 / 2\\") 5.5 >>> evaluate_expression(\\"(2 + 3) * 4\\") 20.0 >>> evaluate_expression(\\"2 + (3 * 4) - 5 / (2 + 3)\\") 13.0 pass def test_evaluate_simple_addition(): assert evaluate_expression(\\"3 + 2\\") == 5.0 def test_evaluate_simple_subtraction(): assert evaluate_expression(\\"5 - 3\\") == 2.0 def test_evaluate_simple_multiplication(): assert evaluate_expression(\\"4 * 2\\") == 8.0 def test_evaluate_simple_division(): assert evaluate_expression(\\"6 / 2\\") == 3.0 def test_evaluate_with_parentheses(): assert evaluate_expression(\\"(2 + 3) * 4\\") == 20.0 def test_evaluate_with_multiple_operators(): assert evaluate_expression(\\"2 + 3 * 4\\") == 14.0 def test_evaluate_with_multiple_operations_and_parentheses(): assert evaluate_expression(\\"2 + (3 * 4) - 5 / (2 + 3)\\") == 13.0 def test_evaluate_with_spaces_and_parentheses(): assert evaluate_expression(\\" ( 3 + 5 ) / 2 \\") == 4.0","solution":"def evaluate_expression(expression: str) -> float: def apply_operator(operators, values): operator = operators.pop() right = values.pop() left = values.pop() if operator == '+': values.append(left + right) elif operator == '-': values.append(left - right) elif operator == '*': values.append(left * right) elif operator == '/': values.append(left / right) def precedence(op): if op == '+' or op == '-': return 1 if op == '*' or op == '/': return 2 return 0 def evaluate(expression): i = 0 operators = [] values = [] while i < len(expression): if expression[i] == ' ': i += 1 continue elif expression[i] == '(': operators.append(expression[i]) elif expression[i].isdigit() or expression[i] == '.': val = 0 # There could be real numbers with decimal part while (i < len(expression) and (expression[i].isdigit() or expression[i] == '.')): val = val * 10 + float(expression[i]) i += 1 values.append(val) i -= 1 elif expression[i] == ')': while len(operators) != 0 and operators[-1] != '(': apply_operator(operators, values) operators.pop() # Remove the '(' else: while (len(operators) != 0 and precedence(operators[-1]) >= precedence(expression[i])): apply_operator(operators, values) operators.append(expression[i]) i += 1 while len(operators) != 0: apply_operator(operators, values) return values[-1] return evaluate(expression)"},{"question":"# Bubble Sort Implementation and Analysis You are required to implement the **Bubble Sort** algorithm and analyze its performance on given input arrays. Write a function that sorts an array of integers using Bubble Sort, and another function that counts the number of swaps performed during the sorting process. Function Signature def bubble_sort(arr: list) -> list: Sorts a list of integers using the Bubble Sort algorithm. n = len(arr) for i in range(n): for j in range(0, n-i-1): # Last i elements are already in place if arr[j] > arr[j+1]: arr[j], arr[j+1] = arr[j+1], arr[j] return arr def count_bubble_sort_swaps(arr: list) -> int: Counts the number of swaps performed during Bubble Sort. n = len(arr) swap_count = 0 for i in range(n): for j in range(0, n-i-1): # Last i elements are already in place if arr[j] > arr[j+1]: arr[j], arr[j+1] = arr[j+1], arr[j] swap_count += 1 return swap_count Input - \`arr\`: A list of integers, where 1 ≤ len(arr) ≤ 1000 and -10000 ≤ arr[i] ≤ 10000. Output - \`bubble_sort(arr)\`: Returns the sorted array of integers. - \`count_bubble_sort_swaps(arr)\`: Returns the number of swaps performed to sort the array. Constraints - Your implementation should use the Bubble Sort algorithm. Examples # Example 1 arr = [4, 3, 1, 2] # Expected Output for bubble_sort(arr): [1, 2, 3, 4] # Expected Output for count_bubble_sort_swaps(arr): 5 # Example 2 arr = [5, 1, 4, 2, 8] # Expected Output for bubble_sort(arr): [1, 2, 4, 5, 8] # Expected Output for count_bubble_sort_swaps(arr): 4 Note 1. Your implementation should handle different sizes of arrays efficiently. 2. Ensure that edge cases such as already sorted arrays or arrays with identical elements are handled correctly. 3. You can implement additional helper functions if needed. Unit Test: from solution import bubble_sort, count_bubble_sort_swaps def test_bubble_sort_example_1(): assert bubble_sort([4, 3, 1, 2]) == [1, 2, 3, 4] def test_count_bubble_sort_swaps_example_1(): assert count_bubble_sort_swaps([4, 3, 1, 2]) == 5 def test_bubble_sort_example_2(): assert bubble_sort([5, 1, 4, 2, 8]) == [1, 2, 4, 5, 8] def test_count_bubble_sort_swaps_example_2(): assert count_bubble_sort_swaps([5, 1, 4, 2, 8]) == 4 def test_bubble_sort_already_sorted(): assert bubble_sort([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5] def test_count_bubble_sort_swaps_already_sorted(): assert count_bubble_sort_swaps([1, 2, 3, 4, 5]) == 0 def test_bubble_sort_reverse_sorted(): assert bubble_sort([5, 4, 3, 2, 1]) == [1, 2, 3, 4, 5] def test_count_bubble_sort_swaps_reverse_sorted(): assert count_bubble_sort_swaps([5, 4, 3, 2, 1]) == 10 def test_bubble_sort_identical_elements(): assert bubble_sort([4, 4, 4, 4]) == [4, 4, 4, 4] def test_count_bubble_sort_swaps_identical_elements(): assert count_bubble_sort_swaps([4, 4, 4, 4]) == 0","solution":"def bubble_sort(arr: list) -> list: Sorts a list of integers using the Bubble Sort algorithm. n = len(arr) for i in range(n): for j in range(0, n-i-1): # Last i elements are already in place if arr[j] > arr[j+1]: arr[j], arr[j+1] = arr[j+1], arr[j] return arr def count_bubble_sort_swaps(arr: list) -> int: Counts the number of swaps performed during Bubble Sort. n = len(arr) swap_count = 0 for i in range(n): for j in range(0, n-i-1): # Last i elements are already in place if arr[j] > arr[j+1]: arr[j], arr[j+1] = arr[j+1], arr[j] swap_count += 1 return swap_count"},{"question":"Complete the function \`sum_of_digits_in_factorial\`. def sum_of_digits_in_factorial(n: int) -> int: ''' Calculates the sum of the digits of the factorial of a given number \`n\`. Parameters: n (int): A positive integer whose factorial’s digits sum is to be calculated. Returns: int: Sum of digits of the factorial of \`n\`. Example ------- >>> sum_of_digits_in_factorial(5) 3 >>> sum_of_digits_in_factorial(10) 27 ''' pass # Write the body of the function \`sum_of_digits_in_factorial\` here","solution":"import math def sum_of_digits_in_factorial(n: int) -> int: Returns the sum of the digits of the factorial of \`n\`. Parameters: n (int): A positive integer whose factorial's digits sum is to be calculated. Returns: int: Sum of digits of the factorial of \`n\`. factorial_result = math.factorial(n) return sum(int(digit) for digit in str(factorial_result))"},{"question":"def filter_employees(data: list[dict], department: str, min_salary: float) -> list[dict]: Filters the employee data based on department and minimum salary. Parameters: data (list): List of dictionaries, each representing an employee. department (str): Department name to filter employees. min_salary (float): Minimum salary to filter employees. Returns: list: List of dictionaries filtered by the specified department and minimum salary. >>> data = [ ... {\\"name\\": \\"Alice\\", \\"department\\": \\"Engineering\\", \\"salary\\": 70000}, ... {\\"name\\": \\"Bob\\", \\"department\\": \\"Marketing\\", \\"salary\\": 50000}, ... {\\"name\\": \\"Charlie\\", \\"department\\": \\"Engineering\\", \\"salary\\": 120000}, ... {\\"name\\": \\"Dana\\", \\"department\\": \\"Engineering\\", \\"salary\\": 90000} ... ] >>> filter_employees(data, \\"Engineering\\", 60000) [{'name': 'Alice', 'department': 'Engineering', 'salary': 70000}, {'name': 'Charlie', 'department': 'Engineering', 'salary': 120000}, {'name': 'Dana', 'department': 'Engineering', 'salary': 90000}] >>> filter_employees(data, \\"Marketing\\", 60000) [] >>> filter_employees(data, \\"Engineering\\", 130000) [] >>> filter_employees(data, \\"Engineering\\", 0) [{'name': 'Alice', 'department': 'Engineering', 'salary': 70000}, {'name': 'Charlie', 'department': 'Engineering', 'salary': 120000}, {'name': 'Dana', 'department': 'Engineering', 'salary': 90000}] pass def calculate_average_salary(employees: list[dict]) -> float: Calculates the average salary of a list of employees. Parameters: employees (list): List of dictionaries, each representing an employee. Returns: float: The average salary of the given employees. >>> employees = [ ... {\\"name\\": \\"Alice\\", \\"department\\": \\"Engineering\\", \\"salary\\": 70000}, ... {\\"name\\": \\"Charlie\\", \\"department\\": \\"Engineering\\", \\"salary\\": 120000}, ... {\\"name\\": \\"Dana\\", \\"department\\": \\"Engineering\\", \\"salary\\": 90000} ... ] >>> calculate_average_salary(employees) 93333.33 >>> calculate_average_salary([]) 0.0 >>> employees = [{\\"name\\": \\"Alice\\", \\"department\\": \\"Engineering\\", \\"salary\\": 70000}] >>> calculate_average_salary(employees) 70000 >>> employees = [ ... {\\"name\\": \\"Alice\\", \\"department\\": \\"Engineering\\", \\"salary\\": 70000}, ... {\\"name\\": \\"Bob\\", \\"department\\": \\"Marketing\\", \\"salary\\": 50000} ... ] >>> calculate_average_salary(employees) 60000 pass","solution":"def filter_employees(data, department, min_salary): Filters the employee data based on department and minimum salary. Parameters: data (list): List of dictionaries, each representing an employee. department (str): Department name to filter employees. min_salary (float): Minimum salary to filter employees. Returns: list: List of dictionaries filtered by the specified department and minimum salary. filtered_employees = [ employee for employee in data if employee.get(\\"department\\") == department and employee.get(\\"salary\\", 0) >= min_salary ] return filtered_employees def calculate_average_salary(employees): Calculates the average salary of a list of employees. Parameters: employees (list): List of dictionaries, each representing an employee. Returns: float: The average salary of the given employees. if not employees: return 0.0 total_salary = sum(employee.get(\\"salary\\", 0) for employee in employees) return total_salary / len(employees)"},{"question":"def find_scc(n: int, edges: List[Tuple[int, int]]) -> List[List[int]]: from collections import defaultdict def kosaraju_scc(n, graph): def dfs1(v): visited[v] = True for u in graph[v]: if not visited[u]: dfs1(u) stack.append(v) def dfs2(v, component): visited[v] = True component.append(v) for u in transpose[v]: if not visited[u]: dfs2(u, component) graph = defaultdict(list) for u, v in edges: graph[u].append(v) transpose = defaultdict(list) for u in graph: for v in graph[u]: transpose[v].append(u) visited = [False] * n stack = [] for i in range(n): if not visited[i]: dfs1(i) visited = [False] * n sccs = [] while stack: node = stack.pop() if not visited[node]: component = [] dfs2(node, component) sccs.append(sorted(component)) sccs.sort(key=lambda x: x[0]) return sccs return kosaraju_scc(n, edges)","solution":"from typing import List, Tuple def find_scc(n: int, edges: List[Tuple[int, int]]) -> List[List[int]]: from collections import defaultdict def kosaraju_scc(n, graph): def dfs1(v): visited[v] = True for u in graph[v]: if not visited[u]: dfs1(u) stack.append(v) def dfs2(v, component): visited[v] = True component.append(v) for u in transpose[v]: if not visited[u]: dfs2(u, component) graph = defaultdict(list) for u, v in edges: graph[u].append(v) transpose = defaultdict(list) for u in graph: for v in graph[u]: transpose[v].append(u) visited = [False] * n stack = [] for i in range(n): if not visited[i]: dfs1(i) visited = [False] * n sccs = [] while stack: node = stack.pop() if not visited[node]: component = [] dfs2(node, component) sccs.append(sorted(component)) sccs.sort(key=lambda x: x[0]) return sccs return kosaraju_scc(n, edges)"},{"question":"def reverse_preserve_non_alpha(string: str) -> str: Given a string, return a new string with the order of the alphanumeric characters reversed and non-alphanumeric characters left in their original positions. Parameters: string (str): The input string containing alphanumeric and non-alphanumeric characters. Returns: str: The string with alphanumeric characters reversed and non-alphanumeric characters preserved. Raises: ValueError: If the input is not a string. >>> reverse_preserve_non_alpha(\\"a!b.c\\") == \\"c!b.a\\" >>> reverse_preserve_non_alpha(\\"123-abc\\") == \\"cba-321\\" >>> reverse_preserve_non_alpha(\\"a1b2c3\\") == \\"3c2b1a\\" >>> reverse_preserve_non_alpha(\\"@hello#\\") == \\"@olleh#\\" >>> reverse_preserve_non_alpha(\\"\\") == \\"\\" >>> reverse_preserve_non_alpha(\\"!@#%^&*()\\") == \\"!@#%^&*()\\"","solution":"def reverse_preserve_non_alpha(string: str) -> str: Given a string, return a new string with the order of the alphanumeric characters reversed and non-alphanumeric characters left in their original positions. if not isinstance(string, str): raise ValueError(\\"Input must be a string\\") # Filtering alphanumeric characters alphanumeric_chars = [c for c in string if c.isalnum()] # Reversing the list of alphanumeric characters alphanumeric_chars.reverse() # Constructing the final result result = [] alphanumeric_index = 0 for char in string: if char.isalnum(): result.append(alphanumeric_chars[alphanumeric_index]) alphanumeric_index += 1 else: result.append(char) return ''.join(result)"},{"question":"def longest_palindrome_substring(s: str) -> str: Finds the longest palindromic substring in the provided string. >>> longest_palindrome_substring(\\"babad\\") in (\\"bab\\", \\"aba\\") >>> longest_palindrome_substring(\\"cbbd\\") == \\"bb\\" >>> longest_palindrome_substring(\\"a\\") == \\"a\\" >>> longest_palindrome_substring(\\"ac\\") in (\\"a\\", \\"c\\")","solution":"def longest_palindrome_substring(s: str) -> str: Finds the longest palindromic substring in the provided string. if len(s) == 0: return \\"\\" start, max_len = 0, 1 def expand_around_center(left: int, right: int): nonlocal start, max_len while left >= 0 and right < len(s) and s[left] == s[right]: current_len = right - left + 1 if current_len > max_len: start = left max_len = current_len left -= 1 right += 1 for i in range(len(s)): # Odd length palindromes expand_around_center(i, i) # Even length palindromes expand_around_center(i, i + 1) return s[start:start + max_len]"},{"question":"class Node: def __init__(self, value=0, next=None): self.value = value self.next = next class LinkedList: def __init__(self): self.head = None def append(self, value): if not self.head: self.head = Node(value) else: current = self.head while current.next: current = current.next current.next = Node(value) def reverse(self): Reverse the linked list in place. pass def has_cycle(self): Detect whether the linked list contains a cycle. Returns True if a cycle is detected, otherwise returns False. pass # Unit tests def test_reverse(): ll = LinkedList() ll.append(1) ll.append(2) ll.append(3) ll.append(4) ll.reverse() current = ll.head values = [] while current: values.append(current.value) current = current.next assert values == [4, 3, 2, 1] def test_has_no_cycle(): ll = LinkedList() ll.append(1) ll.append(2) ll.append(3) ll.append(4) assert not ll.has_cycle() def test_has_cycle(): ll = LinkedList() ll.append(1) ll.append(2) ll.append(3) ll.append(4) # Creating a cycle: 1 -> 2 -> 3 -> 4 -> 2 ll.head.next.next.next.next = ll.head.next assert ll.has_cycle() def test_reverse_and_cycle_detection(): ll = LinkedList() ll.append(1) ll.append(2) ll.append(3) ll.append(4) ll.reverse() assert not ll.has_cycle() # Reset list to create a cycle and reverse again ll = LinkedList() ll.append(1) ll.append(2) ll.append(3) ll.append(4) ll.head.next.next.next.next = ll.head.next # Check has_cycle before reversing assert ll.has_cycle() # Reversing should keep the cycle intact ll.reverse() assert ll.has_cycle()","solution":"class Node: def __init__(self, value=0, next=None): self.value = value self.next = next class LinkedList: def __init__(self): self.head = None def append(self, value): if not self.head: self.head = Node(value) else: current = self.head while current.next: current = current.next current.next = Node(value) def reverse(self): prev = None current = self.head while current: next_node = current.next current.next = prev prev = current current = next_node self.head = prev def has_cycle(self): slow = self.head fast = self.head while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: return True return False"},{"question":"from collections import deque class MyStack: This class simulates the behavior of a stack using queue operations. Methods: __init__(self): Initializes an empty stack. push(self, x: int) -> None: Push element \`x\` onto stack. pop(self) -> int: Removes the element on top of the stack and returns that element. top(self) -> int: Returns the element on the top of the stack without removing it. empty(self) -> bool: Returns \`True\` if the stack is empty, \`False\` otherwise. Example usage: stack = MyStack() stack.push(1) stack.push(2) assert stack.top() == 2 # returns 2 assert stack.pop() == 2 # returns 2 assert not stack.empty() # returns False stack.push(3) assert stack.pop() == 3 # returns 3 assert stack.pop() == 1 # returns 1 assert stack.empty() # returns True def __init__(self): pass def push(self, x: int) -> None: pass def pop(self) -> int: pass def top(self) -> int: pass def empty(self) -> bool: pass # Unit tests to validate the implementation def test_push_and_top(): stack = MyStack() stack.push(1) assert stack.top() == 1 stack.push(2) assert stack.top() == 2 stack.push(3) assert stack.top() == 3 def test_push_and_pop(): stack = MyStack() stack.push(1) stack.push(2) stack.push(3) assert stack.pop() == 3 assert stack.pop() == 2 assert stack.pop() == 1 def test_empty(): stack = MyStack() assert stack.empty() == True stack.push(1) assert stack.empty() == False stack.pop() assert stack.empty() == True def test_mixed_operations(): stack = MyStack() stack.push(1) stack.push(2) assert stack.top() == 2 assert stack.pop() == 2 assert stack.top() == 1 stack.push(3) assert stack.top() == 3 assert stack.pop() == 3 assert stack.pop() == 1 assert stack.empty() == True","solution":"from collections import deque class MyStack: def __init__(self): self.queue = deque() def push(self, x: int) -> None: self.queue.append(x) # Rotate the queue to make the last pushed element the first element. for _ in range(len(self.queue) - 1): self.queue.append(self.queue.popleft()) def pop(self) -> int: return self.queue.popleft() def top(self) -> int: return self.queue[0] def empty(self) -> bool: return not bool(self.queue) # Example usage: # stack = MyStack() # stack.push(1) # stack.push(2) # assert stack.top() == 2 # returns 2 # assert stack.pop() == 2 # returns 2 # assert not stack.empty() # returns False # stack.push(3) # assert stack.pop() == 3 # returns 3 # assert stack.pop() == 1 # returns 1 # assert stack.empty() # returns True"},{"question":"class ComplexNumber: def __init__(self, real: float, imaginary: float): self.real = real self.imaginary = imaginary def __add__(self, other): Add two complex numbers. >>> a = ComplexNumber(1, 2) >>> b = ComplexNumber(3, 4) >>> result = a + b >>> result.real 4 >>> result.imaginary 6 pass def __sub__(self, other): Subtract two complex numbers. >>> a = ComplexNumber(1, 2) >>> b = ComplexNumber(3, 4) >>> result = a - b >>> result.real -2 >>> result.imaginary -2 pass def __mul__(self, other): Multiply two complex numbers. >>> a = ComplexNumber(1, 2) >>> b = ComplexNumber(3, 4) >>> result = a * b >>> result.real -5 >>> result.imaginary 10 pass def __truediv__(self, other): Divide two complex numbers. >>> a = ComplexNumber(1, 2) >>> b = ComplexNumber(3, 4) >>> result = a / b >>> math.isclose(result.real, 0.44, rel_tol=1e-2) True >>> math.isclose(result.imaginary, 0.08, rel_tol=1e-2) True >>> b = ComplexNumber(0, 0) >>> result = a / b >>> math.isinf(result.real) True >>> math.isinf(result.imaginary) True pass def __str__(self): Return the string representation of the complex number. >>> a = ComplexNumber(1, 2) >>> str(a) \\"(1 + 2i)\\" pass","solution":"class ComplexNumber: def __init__(self, real: float, imaginary: float): self.real = real self.imaginary = imaginary def __add__(self, other): return ComplexNumber(self.real + other.real, self.imaginary + other.imaginary) def __sub__(self, other): return ComplexNumber(self.real - other.real, self.imaginary - other.imaginary) def __mul__(self, other): real_part = self.real * other.real - self.imaginary * other.imaginary imaginary_part = self.real * other.imaginary + self.imaginary * other.real return ComplexNumber(real_part, imaginary_part) def __truediv__(self, other): denominator = other.real ** 2 + other.imaginary ** 2 if denominator == 0: return ComplexNumber(float('inf'), float('inf')) # handle division by zero real_part = (self.real * other.real + self.imaginary * other.imaginary) / denominator imaginary_part = (self.imaginary * other.real - self.real * other.imaginary) / denominator return ComplexNumber(real_part, imaginary_part) def __str__(self): return f\\"({self.real} + {self.imaginary}i)\\""},{"question":"def find_largest_unique_number(numbers: list) -> int: Returns the largest integer that appears exactly once in the list. Raises ValueError if input is not a list of integers. >>> find_largest_unique_number([4, 4, 5, 2, 3, 2]) 5 >>> find_largest_unique_number([3, 3, 3, 3]) -1 >>> find_largest_unique_number([7, 1, 2, 9, 2, 7, 10]) 10 >>> find_largest_unique_number([8, 8, 8, 7, 9, 9, 6, 4, 5]) 7 >>> find_largest_unique_number([]) -1 >>> find_largest_unique_number([7]) 7 >>> find_largest_unique_number([0]) 0 >>> find_largest_unique_number([4, 2, 7, 1]) 7 >>> find_largest_unique_number([-5, -1, -2, -4]) -1","solution":"def find_largest_unique_number(numbers: list) -> int: Returns the largest integer that appears exactly once in the list. Raises ValueError if input is not a list of integers. if not isinstance(numbers, list): raise ValueError(\\"Input must be a list of integers\\") if not all(isinstance(x, int) for x in numbers): raise ValueError(\\"Input must be a list of integers\\") from collections import Counter count = Counter(numbers) # Filter the numbers that appear exactly once unique_numbers = [num for num, cnt in count.items() if cnt == 1] # Return the largest unique number, or -1 if none found return max(unique_numbers, default=-1)"},{"question":"def pawn_possible_moves(position: str, move_type: str) -> List[str]: Determine the possible positions a pawn could move to based on the given initial position and move type ('move' for a normal forward move or 'capture' for a diagonal capture move). >>> pawn_possible_moves('e2', 'move') ['e3'] >>> pawn_possible_moves('a1', 'move') ['a2'] >>> pawn_possible_moves('h7', 'move') ['h8'] >>> pawn_possible_moves('g8', 'move') [] >>> pawn_possible_moves('e2', 'capture') ['d3', 'f3'] >>> pawn_possible_moves('a7', 'capture') ['b8'] >>> pawn_possible_moves('h7', 'capture') ['g8'] >>> pawn_possible_moves('h1', 'capture') ['g2'] >>> pawn_possible_moves('a8', 'capture') [] >>> pawn_possible_moves('a8', 'move') [] >>> pawn_possible_moves('h8', 'move') [] >>> pawn_possible_moves('a1', 'capture') ['b2'] >>> pawn_possible_moves('h1', 'capture') ['g2']","solution":"from typing import List def pawn_possible_moves(position: str, move_type: str) -> List[str]: Determine the possible positions a pawn could move to based on the given initial position and move type ('move' for normal forward move or 'capture' for diagonal capture move). :param position: A string representing current position of pawn (e.g., 'e2'). :param move_type: A string indicating the type of move ('move' or 'capture'). :return: A list of strings representing possible new positions. col, row = position[0], int(position[1]) possible_moves = [] if move_type == 'move': if row < 8: possible_moves.append(f\\"{col}{row + 1}\\") elif move_type == 'capture': if row < 8: if col > 'a': possible_moves.append(f\\"{chr(ord(col) - 1)}{row + 1}\\") if col < 'h': possible_moves.append(f\\"{chr(ord(col) + 1)}{row + 1}\\") return possible_moves"},{"question":"def rotate_matrix(matrix: list[list[int]]) -> None: Rotates the matrix by 90 degrees clockwise in place. Args: - matrix (list of list of int): The NxN matrix to be rotated Returns: - None: The matrix is modified in place Examples: >>> m1 = [[1, 2], [3, 4]] >>> rotate_matrix(m1) >>> print(m1) [[3, 1], [4, 2]] >>> m2 = [[1, 2, 3], [4, 5, 6], [7, 8, 9]] >>> rotate_matrix(m2) >>> print(m2) [[7, 4, 1], [8, 5, 2], [9, 6, 3]]","solution":"def rotate_matrix(matrix: list[list[int]]) -> None: Rotates the matrix by 90 degrees clockwise in place. Args: - matrix (list of list of int): The NxN matrix to be rotated Returns: - None: The matrix is modified in place Examples: >>> m1 = [[1, 2], [3, 4]] >>> rotate_matrix(m1) >>> print(m1) [[3, 1], [4, 2]] >>> m2 = [[1, 2, 3], [4, 5, 6], [7, 8, 9]] >>> rotate_matrix(m2) >>> print(m2) [[7, 4, 1], [8, 5, 2], [9, 6, 3]] N = len(matrix) for i in range(N): for j in range(i, N): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] for i in range(N): matrix[i].reverse()"},{"question":"class GameUnitManager: Class to manage health status of multiple units in a game. Methods: - add_unit(unit_id: str, health: int) - remove_unit(unit_id: str) - update_health(unit_id: str, health: int) - get_units_with_health_above(threshold: int) -> list[str] Example: >>> manager = GameUnitManager() >>> manager.add_unit(\\"unit1\\", 100) >>> manager.add_unit(\\"unit2\\", 50) >>> manager.update_health(\\"unit2\\", 200) >>> manager.remove_unit(\\"unit1\\") >>> manager.get_units_with_health_above(100) [\\"unit2\\"] def __init__(self): # Initializes an empty structure to store units and their health. pass def add_unit(self, unit_id: str, health: int): # Accepts a unit_id and health; adds the unit with the given health to the collection. pass def remove_unit(self, unit_id: str): # Accepts a unit_id; removes the unit with the specified unit_id from the collection. pass def update_health(self, unit_id: str, health: int): # Accepts a unit_id and a new health value; updates the health value of the specified unit. pass def get_units_with_health_above(self, threshold: int) -> list[str]: # Accepts a threshold value and returns a list of unit IDs whose health is strictly greater than the threshold. pass","solution":"class GameUnitManager: def __init__(self): self.units = {} def add_unit(self, unit_id: str, health: int): if unit_id in self.units: raise ValueError(f\\"Unit with id {unit_id} already exists.\\") self.units[unit_id] = health def remove_unit(self, unit_id: str): if unit_id in self.units: del self.units[unit_id] def update_health(self, unit_id: str, health: int): if unit_id in self.units: self.units[unit_id] = health else: raise KeyError(f\\"Unit with id {unit_id} does not exist.\\") def get_units_with_health_above(self, threshold: int) -> list[str]: return [unit_id for unit_id, health in self.units.items() if health > threshold]"},{"question":"def can_purchase_exact_amount(prices: list[int], target: int) -> bool: Determines if a subset of prices can sum up exactly to the target amount. Args: prices (list[int]): A list of integers representing item prices. target (int): An integer representing the target amount. Returns: bool: True if it is possible to achieve the target amount using any combination of item prices, otherwise False. Examples: >>> can_purchase_exact_amount([2, 3, 7, 8, 10], 11) True >>> can_purchase_exact_amount([1, 2, 3, 4, 5], 9) True >>> can_purchase_exact_amount([1, 2, 3], 7) False >>> can_purchase_exact_amount([5, 5, 5, 5], 10) True >>> can_purchase_exact_amount([], 0) True >>> can_purchase_exact_amount([], 10) False pass def test_can_purchase_exact_amount(): assert can_purchase_exact_amount([2, 3, 7, 8, 10], 11) == True assert can_purchase_exact_amount([1, 2, 3, 4, 5], 9) == True assert can_purchase_exact_amount([1, 2, 3], 7) == False assert can_purchase_exact_amount([5, 5, 5, 5], 10) == True assert can_purchase_exact_amount([], 0) == True assert can_purchase_exact_amount([], 10) == False assert can_purchase_exact_amount([1000], 1000) == True assert can_purchase_exact_amount([1000], 999) == False assert can_purchase_exact_amount([1, 1, 1, 1, 1], 5) == True assert can_purchase_exact_amount([500, 500, 500], 1500) == True assert can_purchase_exact_amount([500, 499, 1], 1000) == True assert can_purchase_exact_amount([500, 499, 1], 900) == False","solution":"def can_purchase_exact_amount(prices, target): Determines if a subset of prices can sum up exactly to the target amount. :param prices: list of integers representing item prices :param target: integer representing target amount :return: bool, True if a subset of prices can sum up to target, else False # Define a helper function to use recursion and backtracking def backtrack(index, current_sum): # Base cases if current_sum == target: return True if index >= len(prices) or current_sum > target: return False # Recursive cases: include or exclude the current price # Include the current price if backtrack(index + 1, current_sum + prices[index]): return True # Exclude the current price if backtrack(index + 1, current_sum): return True return False return backtrack(0, 0)"},{"question":"def reverse_words_in_string(s: str) -> str: Reverse the characters in each word of the given string while preserving whitespace and word order. >>> reverse_words_in_string(\\"Let's take LeetCode contest\\") \\"s'teL ekat edoCteeL tsetnoc\\" >>> reverse_words_in_string(\\"hello world\\") \\"olleh dlrow\\" >>> reverse_words_in_string(\\"a\\") \\"a\\"","solution":"def reverse_words_in_string(s: str) -> str: Reverse the characters in each word of the given string while preserving whitespace and word order. :param s: Sentence consisting of words and spaces. :return: Sentence with each word reversed. return ' '.join(word[::-1] for word in s.split(' '))"},{"question":"def levenshtein_distance(str1: str, str2: str) -> int: Calculate the Levenshtein distance between two strings. >>> levenshtein_distance(\\"\\", \\"\\") 0 >>> levenshtein_distance(\\"abc\\", \\"\\") 3 >>> levenshtein_distance(\\"\\", \\"abc\\") 3 >>> levenshtein_distance(\\"test\\", \\"test\\") 0 >>> levenshtein_distance(\\"kitten\\", \\"sitten\\") 1 >>> levenshtein_distance(\\"kitten\\", \\"sitting\\") 3 >>> levenshtein_distance(\\"flaw\\", \\"lawn\\") 2 >>> levenshtein_distance(\\"abc\\", \\"xyz\\") 3 >>> levenshtein_distance(\\"a\\" * 1000, \\"a\\" * 999 + \\"b\\") 1","solution":"def levenshtein_distance(str1: str, str2: str) -> int: m, n = len(str1), len(str2) # Initialize the table with zeros dp = [[0] * (n + 1) for _ in range(m + 1)] # Base cases: when one of the strings is empty for i in range(m + 1): dp[i][0] = i for j in range(n + 1): dp[0][j] = j # Fill the table for i in range(1, m + 1): for j in range(1, n + 1): if str1[i - 1] == str2[j - 1]: cost = 0 else: cost = 1 dp[i][j] = min(dp[i - 1][j] + 1, # Deletion dp[i][j - 1] + 1, # Insertion dp[i - 1][j - 1] + cost) # Substitution # The answer is in the bottom-right corner of the matrix return dp[m][n]"},{"question":"def is_palindrome(num: int) -> bool: Check if a given number is a palindrome. >>> is_palindrome(121) True >>> is_palindrome(123) False >>> is_palindrome(1331) True >>> is_palindrome(1) True >>> is_palindrome(10) False pass def factorial(n: int) -> int: Calculate the factorial of a given number n. >>> factorial(0) 1 >>> factorial(1) 1 >>> factorial(2) 2 >>> factorial(3) 6 >>> factorial(5) 120 pass def find_palindromic_factorial() -> int: Find the smallest factorial number that is also a palindrome. >>> find_palindromic_factorial() 1 pass","solution":"def is_palindrome(num): Check if a given number is a palindrome. return str(num) == str(num)[::-1] def factorial(n): Calculate the factorial of a given number n. if n == 0 or n == 1: return 1 result = 1 for i in range(2, n + 1): result *= i return result def find_palindromic_factorial(): Find the smallest factorial number that is also a palindrome. n = 0 while True: fact = factorial(n) if is_palindrome(fact): return fact n += 1"},{"question":"from typing import List def largest_number(nums: List[int]) -> str: Arrange a list of non-negative integers to form the largest possible number and return it as a string. >>> largest_number([10, 2]) '210' >>> largest_number([3, 30, 34, 5, 9]) '9534330' >>> largest_number([1, 9, 3, 5]) '9531' >>> largest_number([0, 0, 0]) '0' >>> largest_number([12, 128, 124, 50, 105]) '5012812412105'","solution":"from typing import List from functools import cmp_to_key def largest_number(nums: List[int]) -> str: def compare(x, y): # Custom comparator to decide order based on concatenated result if x + y > y + x: return -1 elif x + y < y + x: return 1 else: return 0 # Convert numbers to strings for comparison nums_str = list(map(str, nums)) # Sort the numbers using the custom comparator nums_str.sort(key=cmp_to_key(compare)) # Join sorted strings into a single string and convert it to int and back to string to remove leading '0's largest_num = ''.join(nums_str) return str(int(largest_num))"},{"question":"def is_chemical_palindrome(symbol: str) -> bool: Determines whether a given chemical element's symbol is a palindrome. >>> is_chemical_palindrome(\\"H\\") True >>> is_chemical_palindrome(\\"HH\\") True >>> is_chemical_palindrome(\\"HE\\") False >>> is_chemical_palindrome(\\"O\\") True pass","solution":"def is_chemical_palindrome(symbol: str) -> bool: Determines whether a given chemical symbol is a palindrome. Parameters: symbol (str): The chemical symbol to be checked. Returns: bool: True if the symbol is a palindrome, False otherwise. return symbol == symbol[::-1]"},{"question":"def is_prime(n: int) -> bool: Check if a number is prime. >>> is_prime(2) == True >>> is_prime(3) == True >>> is_prime(4) == False >>> is_prime(5) == True >>> is_prime(10) == False >>> is_prime(11) == True >>> is_prime(1) == False >>> is_prime(0) == False pass def filter_non_primes(numbers: list) -> list: Filters out all prime numbers from the input list and returns a new list with the remaining integers. >>> filter_non_primes([2, 4, 6, 8, 11, 13, 17, 19, 20, 22, 23]) == [4, 6, 8, 20, 22] >>> filter_non_primes([1, 2, 3, 5, 7, 11, 13, 18]) == [1, 18] >>> filter_non_primes([25, 27, 28, 29, 30, 31, 32]) == [25, 27, 28, 30, 32] pass def sum_of_primes(numbers: list) -> int: Returns the sum of all the prime numbers that were filtered out. >>> sum_of_primes([2, 4, 6, 8, 11, 13, 17, 19, 20, 22, 23]) == 85 >>> sum_of_primes([1, 2, 3, 5, 7, 11, 13, 18]) == 41 >>> sum_of_primes([25, 27, 28, 29, 30, 31, 32]) == 60 pass import pytest @pytest.mark.parametrize(\\"n, expected\\", [ (2, True), (3, True), (4, False), (5, True), (10, False), (11, True), (1, False), (0, False), ]) def test_is_prime(n, expected): assert is_prime(n) == expected @pytest.mark.parametrize(\\"numbers, expected\\", [ ([2, 4, 6, 8, 11, 13, 17, 19, 20, 22, 23], [4, 6, 8, 20, 22]), ([1, 2, 3, 5, 7, 11, 13, 18], [1, 18]), ([25, 27, 28, 29, 30, 31, 32], [25, 27, 28, 30, 32]), ]) def test_filter_non_primes(numbers, expected): assert filter_non_primes(numbers) == expected @pytest.mark.parametrize(\\"numbers, expected\\", [ ([2, 4, 6, 8, 11, 13, 17, 19, 20, 22, 23], 85), ([1, 2, 3, 5, 7, 11, 13, 18], 41), ([25, 27, 28, 29, 30, 31, 32], 60), ]) def test_sum_of_primes(numbers, expected): assert sum_of_primes(numbers) == expected def test_mixed(): numbers = [0, 1, 2, 3, 5, 4, 6, 8, 10, 12, 11] assert filter_non_primes(numbers) == [0, 1, 4, 6, 8, 10, 12] assert sum_of_primes(numbers) == 21","solution":"def is_prime(n: int) -> bool: Check if a number is prime. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def filter_non_primes(numbers: list) -> list: Filters out all prime numbers from the input list and returns a new list with the remaining integers. return [num for num in numbers if not is_prime(num)] def sum_of_primes(numbers: list) -> int: Returns the sum of all the prime numbers that were filtered out. return sum(num for num in numbers if is_prime(num))"},{"question":"from typing import List, Dict from collections import deque class CustomGraph: def __init__(self, graph: Dict[int, List[int]]): self.graph = graph def has_cycle(self) -> bool: Check if the graph contains any cycles. >>> graph = {0: [1, 2], 1: [2], 2: [0, 3], 3: [3]} >>> custom_graph = CustomGraph(graph) >>> custom_graph.has_cycle() True >>> graph = {0: [1], 1: [2], 2: [3], 3: []} >>> custom_graph = CustomGraph(graph) >>> custom_graph.has_cycle() False def shortest_path(self, start: int, end: int) -> List[int]: Find the shortest path in terms of the number of edges between two nodes. If no path exists, return an empty list. >>> graph = {0: [1, 2], 1: [2], 2: [3], 3: []} >>> custom_graph = CustomGraph(graph) >>> custom_graph.shortest_path(1, 2) [1, 2] >>> custom_graph.shortest_path(0, 3) [0, 2, 3] >>> custom_graph.shortest_path(0, 4) [] >>> custom_graph.shortest_path(2, 2) [2]","solution":"from collections import deque class CustomGraph: def __init__(self, graph): self.graph = graph def has_cycle(self): def dfs(node, visited, rec_stack): visited[node] = True rec_stack[node] = True for neighbor in self.graph.get(node, []): if not visited[neighbor]: if dfs(neighbor, visited, rec_stack): return True elif rec_stack[neighbor]: return True rec_stack[node] = False return False visited = {node: False for node in self.graph} rec_stack = {node: False for node in self.graph} for node in self.graph: if not visited[node]: if dfs(node, visited, rec_stack): return True return False def shortest_path(self, start, end): if start == end: return [start] visited = {node: False for node in self.graph} prev = {node: None for node in self.graph} queue = deque([start]) visited[start] = True while queue: current = queue.popleft() for neighbor in self.graph.get(current, []): if not visited[neighbor]: queue.append(neighbor) visited[neighbor] = True prev[neighbor] = current if neighbor == end: break path = [] at = end while at is not None: path.insert(0, at) at = prev[at] if path and path[0] == start: return path else: return []"},{"question":"class Node: def __init__(self, data): Initialize a node with the provided data and next pointer set to None. >>> node = Node(5) >>> node.data 5 >>> node.next is None True self.data = data self.next = None class Queue: def __init__(self): Initialize an empty queue. >>> q = Queue() >>> q.is_empty() True self.front = None self.rear = None self._size = 0 def enqueue(self, data: any) -> None: Add an element to the end of the queue. >>> q = Queue() >>> q.enqueue(10) >>> q.to_list() [10] >>> q.enqueue(20) >>> q.to_list() [10, 20] pass def dequeue(self) -> any: Remove and return an element from the front of the queue. If the queue is empty, raise an appropriate exception. >>> q = Queue() >>> q.enqueue(10) >>> q.enqueue(20) >>> q.dequeue() 10 >>> q.dequeue() 20 >>> q.is_empty() True >>> q.dequeue() Traceback (most recent call last): ... Exception: Queue is empty pass def is_empty(self) -> bool: Check if the queue is empty. >>> q = Queue() >>> q.is_empty() True pass def size(self) -> int: Return the number of elements in the queue. >>> q = Queue() >>> q.enqueue(10) >>> q.enqueue(20) >>> q.size() 2 >>> q.dequeue() >>> q.size() 1 pass def to_list(self) -> list: Convert the queue to a list for easy comparison and testing. >>> q = Queue() >>> q.enqueue(10) >>> q.enqueue(20) >>> q.to_list() [10, 20] >>> q.dequeue() >>> q.to_list() [20] pass","solution":"class Node: def __init__(self, data): self.data = data self.next = None class Queue: def __init__(self): self.front = None self.rear = None self._size = 0 def enqueue(self, data: any) -> None: new_node = Node(data) if self.rear is None: self.front = self.rear = new_node else: self.rear.next = new_node self.rear = new_node self._size += 1 def dequeue(self) -> any: if self.is_empty(): raise Exception(\\"Queue is empty\\") removed_data = self.front.data self.front = self.front.next if self.front is None: self.rear = None self._size -= 1 return removed_data def is_empty(self) -> bool: return self.front is None def size(self) -> int: return self._size def to_list(self) -> list: elements = [] current = self.front while current: elements.append(current.data) current = current.next return elements"},{"question":"def sort_files_by_size(file_list: list[str]) -> list[str]: Sorts a list of filenames by their sizes in ascending order. :param file_list: List of filenames with their respective sizes in the format \\"filename_size.extension\\". :type file_list: list of str :return: Sorted list of filenames by size in ascending order. :rtype: list of str Example: >>> sort_files_by_size([\\"image_1MB.jpg\\", \\"text_500B.txt\\", \\"video_2GB.mp4\\"]) [\\"text_500B.txt\\", \\"image_1MB.jpg\\", \\"video_2GB.mp4\\"] pass # Unit tests def test_single_file(): assert sort_files_by_size([\\"file_10MB.txt\\"]) == [\\"file_10MB.txt\\"] def test_files_same_unit(): file_list = [\\"file1_1MB.txt\\", \\"file2_5MB.txt\\", \\"file3_2MB.txt\\"] sorted_list = [\\"file1_1MB.txt\\", \\"file3_2MB.txt\\", \\"file2_5MB.txt\\"] assert sort_files_by_size(file_list) == sorted_list def test_files_different_units(): file_list = [\\"file1_1KB.txt\\", \\"file2_1MB.txt\\", \\"file3_1GB.txt\\", \\"file4_1B.txt\\"] sorted_list = [\\"file4_1B.txt\\", \\"file1_1KB.txt\\", \\"file2_1MB.txt\\", \\"file3_1GB.txt\\"] assert sort_files_by_size(file_list) == sorted_list def test_files_with_mixed_units_and_sizes(): file_list = [\\"file1_500KB.doc\\", \\"file2_10MB.pdf\\", \\"file3_20B.txt\\", \\"file4_1GB.mp4\\", \\"file5_1KB.txt\\"] sorted_list = [\\"file3_20B.txt\\", \\"file5_1KB.txt\\", \\"file1_500KB.doc\\", \\"file2_10MB.pdf\\", \\"file4_1GB.mp4\\"] assert sort_files_by_size(file_list) == sorted_list def test_files_with_similar_names_different_sizes(): file_list = [\\"report_10MB.pdf\\", \\"report_500KB.doc\\", \\"report_1GB.pptx\\", \\"report_200KB.pdf\\"] sorted_list = [\\"report_200KB.pdf\\", \\"report_500KB.doc\\", \\"report_10MB.pdf\\", \\"report_1GB.pptx\\"] assert sort_files_by_size(file_list) == sorted_list def test_large_numbers(): file_list = [\\"large_999GB.pdf\\", \\"medium_500GB.pdf\\", \\"small_1GB.pdf\\", \\"tiny_1MB.pdf\\", \\"minuscule_1B.pdf\\"] sorted_list = [\\"minuscule_1B.pdf\\", \\"tiny_1MB.pdf\\", \\"small_1GB.pdf\\", \\"medium_500GB.pdf\\", \\"large_999GB.pdf\\"] assert sort_files_by_size(file_list) == sorted_list","solution":"def sort_files_by_size(file_list): Sorts a list of filenames by their sizes in ascending order. :param file_list: List of filenames with their respective sizes in the format \\"filename_size.extension\\". :type file_list: list of str :return: Sorted list of filenames by size in ascending order. :rtype: list of str def parse_size(size): units = {\\"B\\": 1, \\"KB\\": 1024, \\"MB\\": 1024**2, \\"GB\\": 1024**3} size = size.upper().strip() number = ''.join(filter(str.isdigit, size)) unit = ''.join(filter(str.isalpha, size)) return int(number) * units[unit] def extract_size(file): temp = file.split('_')[-1] size = temp.split('.')[0] return parse_size(size) return sorted(file_list, key=extract_size)"},{"question":"def calculate_bmi(weight: float, height: float) -> str: Compute the Body Mass Index and classify the health status. Parameters: weight (float): Weight of the individual in kilograms (must be positive). height (float): Height of the individual in meters (must be positive). Returns: str: Health status based on BMI (Underweight, Normal weight, Overweight, Obesity). Raises: ValueError: If weight or height are not positive values. Examples: >>> calculate_bmi(60, 1.75) 'Normal weight' >>> calculate_bmi(45, 1.6) 'Underweight' >>> calculate_bmi(90, 1.75) 'Overweight' >>> calculate_bmi(110, 1.7) 'Obesity' pass","solution":"def calculate_bmi(weight: float, height: float) -> str: Computes the Body Mass Index (BMI) and categorizes the health status. Parameters: weight (float): Weight of the individual in kilograms (must be positive). height (float): Height of the individual in meters (must be positive). Returns: str: Health status based on BMI (Underweight, Normal weight, Overweight, Obesity). if weight <= 0: raise ValueError(\\"Weight must be a positive value\\") if height <= 0: raise ValueError(\\"Height must be a positive value\\") # Calculating BMI bmi = weight / (height ** 2) # Classifying the health status based on BMI if bmi < 18.5: return \\"Underweight\\" elif 18.5 <= bmi < 24.9: return \\"Normal weight\\" elif 25 <= bmi < 29.9: return \\"Overweight\\" else: return \\"Obesity\\""},{"question":"def matrix_multiplication(A: list[list[int]], B: list[list[int]]) -> list[list[int]]: Multiplies two matrices A and B. Parameters: - A: The first matrix represented as a list of lists. - B: The second matrix represented as a list of lists. Returns: - A list of lists representing the product of matrices A and B or an empty list if the matrices cannot be multiplied. Examples: >>> A = [ ... [1, 2, 3], ... [4, 5, 6] ... ] >>> B = [ ... [7, 8], ... [9, 10], ... [11, 12] ... ] >>> matrix_multiplication(A, B) [[58, 64], [139, 154]] >>> matrix_multiplication([[1, 2], [3, 4]], [[5], [6]]) []","solution":"def matrix_multiplication(A, B): Multiplies two matrices A and B. Parameters: - A: The first matrix represented as a list of lists. - B: The second matrix represented as a list of lists. Returns: - A list of lists representing the product of matrices A and B or an empty list if the matrices cannot be multiplied. # Get dimensions of matrices rows_A, cols_A = len(A), len(A[0]) rows_B, cols_B = len(B), len(B[0]) # Check if matrices can be multiplied if cols_A != rows_B: return [] # Initialize the result matrix with zeros result = [[0 for _ in range(cols_B)] for _ in range(rows_A)] # Perform matrix multiplication for i in range(rows_A): for j in range(cols_B): for k in range(cols_A): result[i][j] += A[i][k] * B[k][j] return result"},{"question":"def find_missing_number(nums: list[int]) -> int: Finds and returns the missing number in the array containing numbers from 1 to n. Args: nums (list): List of integers from 1 to n with one number missing. Returns: int: The missing number. pass # Example test cases assert find_missing_number([3, 7, 1, 2, 8, 4, 5]) == 6 assert find_missing_number([1, 2, 4, 5, 6]) == 3 assert find_missing_number([2, 4, 1, 3, 6, 7, 8, 9, 10]) == 5 assert find_missing_number([1]) == 2","solution":"def find_missing_number(nums: list[int]) -> int: Finds and returns the missing number in the array containing numbers from 1 to n. Args: nums (list): List of integers from 1 to n with one number missing. Returns: int: The missing number. n = len(nums) + 1 total_sum = n * (n + 1) // 2 array_sum = sum(nums) return total_sum - array_sum"},{"question":"from typing import List, Dict from collections import deque class Graph: def __init__(self) -> None: self.graph: Dict[int, List[int]] = {} # adjacency list representation def add_edge(self, u: int, v: int) -> None: Adds an edge to the graph. :param u: Vertex u :param v: Vertex v if u not in self.graph: self.graph[u] = [] if v not in self.graph: self.graph[v] = [] self.graph[u].append(v) self.graph[v].append(u) # assuming an undirected graph def bfs(self, start_vertex: int) -> List[int]: Performs BFS starting from the given vertex. :param start_vertex: Vertex to start BFS from :return: List of vertices in the order they are visited pass def dfs(self, start_vertex: int) -> List[int]: Performs DFS starting from the given vertex. :param start_vertex: Vertex to start DFS from :return: List of vertices in the order they are visited pass def test_add_edge(): graph = Graph() graph.add_edge(1, 2) graph.add_edge(1, 3) assert graph.graph == {1: [2, 3], 2: [1], 3: [1]} def test_bfs(): graph = Graph() graph.add_edge(1, 2) graph.add_edge(1, 3) graph.add_edge(2, 4) graph.add_edge(3, 5) assert graph.bfs(1) == [1, 2, 3, 4, 5] def test_dfs(): graph = Graph() graph.add_edge(1, 2) graph.add_edge(1, 3) graph.add_edge(2, 4) graph.add_edge(3, 5) assert graph.dfs(1) == [1, 3, 5, 2, 4] def test_bfs_single_node(): graph = Graph() graph.add_edge(1, 1) # Self loop for a single node assert graph.bfs(1) == [1] def test_dfs_single_node(): graph = Graph() graph.add_edge(1, 1) # Self loop for a single node assert graph.dfs(1) == [1] def test_bfs_disconnected(): graph = Graph() graph.add_edge(1, 2) graph.add_edge(3, 4) assert graph.bfs(1) == [1, 2] assert graph.bfs(3) == [3, 4] def test_dfs_disconnected(): graph = Graph() graph.add_edge(1, 2) graph.add_edge(3, 4) assert graph.dfs(1) == [1, 2] assert graph.dfs(3) == [3, 4] def test_bfs_large_graph(): graph = Graph() for i in range(1, 1001): graph.add_edge(i, i + 1) assert graph.bfs(1) == list(range(1, 1002)) def test_dfs_large_graph(): graph = Graph() for i in range(1, 1001): graph.add_edge(i, i + 1) assert graph.dfs(1) == list(range(1, 1002))","solution":"from collections import deque from typing import List, Dict class Graph: def __init__(self) -> None: self.graph: Dict[int, List[int]] = {} # adjacency list representation def add_edge(self, u: int, v: int) -> None: Adds an edge to the graph. :param u: Vertex u :param v: Vertex v if u not in self.graph: self.graph[u] = [] if v not in self.graph: self.graph[v] = [] self.graph[u].append(v) self.graph[v].append(u) # assuming an undirected graph def bfs(self, start_vertex: int) -> List[int]: Performs BFS starting from the given vertex. :param start_vertex: Vertex to start BFS from :return: List of vertices in the order they are visited visited = set() queue = deque([start_vertex]) result = [] while queue: vertex = queue.popleft() if vertex not in visited: visited.add(vertex) result.append(vertex) queue.extend(v for v in self.graph[vertex] if v not in visited) return result def dfs(self, start_vertex: int) -> List[int]: Performs DFS starting from the given vertex. :param start_vertex: Vertex to start DFS from :return: List of vertices in the order they are visited visited = set() stack = [start_vertex] result = [] while stack: vertex = stack.pop() if vertex not in visited: visited.add(vertex) result.append(vertex) stack.extend(v for v in self.graph[vertex] if v not in visited) return result"},{"question":"def integer_square_root(n: int) -> int: Given a non-negative integer n, returns the integer square root of n using the binary search algorithm. The integer square root of a number n is the largest integer x such that x^2 is less than or equal to n. >>> integer_square_root(16) 4 >>> integer_square_root(8) 2 >>> integer_square_root(1) 1 >>> integer_square_root(0) 0 >>> integer_square_root(1000000000) 31622 from solution import integer_square_root def test_integer_square_root_perfect_square(): assert integer_square_root(16) == 4 assert integer_square_root(25) == 5 assert integer_square_root(100) == 10 def test_integer_square_root_non_perfect_square(): assert integer_square_root(8) == 2 assert integer_square_root(20) == 4 assert integer_square_root(300) == 17 def test_integer_square_root_edge_cases(): assert integer_square_root(0) == 0 assert integer_square_root(1) == 1 def test_integer_square_root_large_numbers(): assert integer_square_root(999999999) == 31622 assert integer_square_root(1000000000) == 31622 assert integer_square_root(2147483647) == 46340","solution":"def integer_square_root(n: int) -> int: Returns the integer square root of a non-negative integer n using binary search. if n < 2: return n left, right = 1, n // 2 while left <= right: mid = (left + right) // 2 square = mid * mid if square == n: return mid elif square < n: left = mid + 1 else: right = mid - 1 return right"},{"question":"def matrix_chain_order(dims: list[int]) -> tuple[list[list[int]], list[list[int]]]: Computes the minimum cost and splits for matrix chain multiplication. Args: dims (list[int]): List of dimensions where the i-th matrix has dimensions dims[i-1] x dims[i]. Returns: tuple: A tuple containing two lists: 1. m: A 2D list where m[i][j] is the minimum number of scalar multiplications needed to compute the product of matrices Ai through Aj. 2. s: A 2D list where s[i][j] is the index at which the optimal split occurs. pass def optimal_parenthesization(s: list[list[int]], i: int, j: int) -> str: Constructs the optimal parenthesization of matrices. Args: s (list[list[int]]): The split matrix to reconstruct the optimal parenthesization. i (int): Starting index. j (int): Ending index. Returns: str: The optimal parenthesization as a string. pass def main(dims: list[int]) -> tuple[int, str]: Main function to compute the minimum cost and optimal parenthesization for matrix chain multiplication. Args: dims (list[int]): List of dimensions where the i-th matrix has dimensions dims[i-1] x dims[i]. Returns: tuple: A tuple containing: 1. The minimum number of scalar multiplications needed to multiply the sequence of matrices. 2. The optimal parenthesization of the matrices. pass # Example usage: dims = [30, 35, 15, 5, 10, 20, 25] min_cost, opt_parenthesis = main(dims=dims) print(f\\"Minimum Cost: {min_cost}\\") print(f\\"Optimal Parenthesization: {opt_parenthesis}\\") # Test cases def test_matrix_chain_order(): dims = [30, 35, 15, 5, 10, 20, 25] m, s = matrix_chain_order(dims) # Test the final minimum cost assert m[0][len(dims) - 2] == 15125 def test_optimal_parenthesization(): dims = [30, 35, 15, 5, 10, 20, 25] m, s = matrix_chain_order(dims) parenthesis = optimal_parenthesization(s, 0, len(dims) - 2) assert parenthesis == \\"((A1(A2A3))((A4A5)A6))\\" def test_main(): dims = [30, 35, 15, 5, 10, 20, 25] min_cost, opt_parenthesis = main(dims) assert min_cost == 15125 assert opt_parenthesis == \\"((A1(A2A3))((A4A5)A6))\\" def test_small_chain(): dims = [10, 20, 30] min_cost, opt_parenthesis = main(dims) assert min_cost == 6000 assert opt_parenthesis == \\"(A1A2)\\" def test_single_matrix(): dims = [10, 20] min_cost, opt_parenthesis = main(dims) assert min_cost == 0 assert opt_parenthesis == \\"A1\\"","solution":"def matrix_chain_order(dims): Computes the minimum cost and splits for matrix chain multiplication. Args: dims (list[int]): List of dimensions where the i-th matrix has dimensions dims[i-1] x dims[i]. Returns: tuple: A tuple containing two lists: 1. m: A 2D list where m[i][j] is the minimum number of scalar multiplications needed to compute the product of matrices Ai through Aj. 2. s: A 2D list where s[i][j] is the index at which the optimal split occurs. n = len(dims) - 1 m = [[0 for _ in range(n)] for _ in range(n)] s = [[0 for _ in range(n)] for _ in range(n)] for l in range(2, n + 1): # l is the chain length for i in range(n - l + 1): j = i + l - 1 m[i][j] = float('inf') for k in range(i, j): q = m[i][k] + m[k + 1][j] + dims[i] * dims[k + 1] * dims[j + 1] if q < m[i][j]: m[i][j] = q s[i][j] = k return m, s def optimal_parenthesization(s, i, j): Constructs the optimal parenthesization of matrices. Args: s (list[list[int]]): The split matrix to reconstruct the optimal parenthesization. i (int): Starting index. j (int): Ending index. Returns: str: The optimal parenthesization as a string. if i == j: return f\\"A{i+1}\\" else: left = optimal_parenthesization(s, i, s[i][j]) right = optimal_parenthesization(s, s[i][j] + 1, j) return f\\"({left}{right})\\" def main(dims): m, s = matrix_chain_order(dims) n = len(dims) - 1 min_cost = m[0][n - 1] opt_parenthesis = optimal_parenthesization(s, 0, n - 1) return min_cost, opt_parenthesis # Example usage: dims = [30, 35, 15, 5, 10, 20, 25] min_cost, opt_parenthesis = main(dims=dims) print(f\\"Minimum Cost: {min_cost}\\") print(f\\"Optimal Parenthesization: {opt_parenthesis}\\")"},{"question":"def reverse_binary(n: int) -> str: This function takes an integer \`n\`, converts it to its binary representation, reverses the binary digits and returns the resulting string as a binary number prefixed with \\"0b\\". >>> reverse_binary(13) == '0b1011' >>> reverse_binary(8) == '0b1' >>> reverse_binary(5) == '0b101' >>> reverse_binary(256) == '0b1' >>> reverse_binary(0) == '0b0' >>> reverse_binary(1) == '0b1' >>> reverse_binary(6) == '0b11'","solution":"def reverse_binary(n: int) -> str: This function takes an integer \`n\`, converts it to its binary representation, reverses the binary digits and returns the resulting string as a binary number prefixed with \\"0b\\". # Convert to binary and strip off the '0b' prefix binary_rep = bin(n)[2:] # Reverse the binary representation reversed_binary_rep = binary_rep[::-1] # Convert back to integer to remove leading zeros and convert to binary string with prefix '0b' return '0b' + bin(int(reversed_binary_rep, 2))[2:]"},{"question":"Function Signature: def max_water_area(heights: List[int]) -> int: Given a list of non-negative integers representing the heights of vertical lines drawn at each unit index, this function calculates the maximum area of water that can be trapped between these bars. Args: heights (List[int]): A list of non-negative integers, where each integer represents the height of a vertical line. Returns: int: The maximum area of water that can be trapped between the bars. Returns 0 if the list contains fewer than 2 elements or if all elements are zero. Raises: ValueError: If any element in heights is not a non-negative integer. Example: >>> max_water_area([1, 8, 6, 2, 5, 4, 8, 3, 7]) 49 >>> max_water_area([1, 1]) 1 >>> max_water_area([4, 3, 2, 1, 4]) 16 >>> max_water_area([]) 0 Unit Test: from solution import max_water_area import pytest def test_example_cases(): assert max_water_area([1, 8, 6, 2, 5, 4, 8, 3, 7]) == 49 assert max_water_area([1, 1]) == 1 assert max_water_area([4, 3, 2, 1, 4]) == 16 assert max_water_area([]) == 0 def test_edge_cases(): assert max_water_area([1]) == 0 assert max_water_area([0, 0, 0, 0]) == 0 assert max_water_area([10000, 10000]) == 10000 def test_large_input(): large_heights = [10000] * 100000 assert max_water_area(large_heights) == 10000 * 99999 def test_invalid_input_cases(): with pytest.raises(ValueError): max_water_area([0, 1, -1]) with pytest.raises(ValueError): max_water_area([\\"a\\", \\"b\\", \\"c\\"]) if __name__ == \\"__main__\\": pytest.main([__file__]) Solution: from typing import List def max_water_area(heights: List[int]) -> int: if not all(isinstance(height, int) and height >= 0 for height in heights): raise ValueError(\\"All elements in heights must be non-negative integers.\\") n = len(heights) if n < 2: return 0 left, right = 0, n - 1 max_area = 0 while left < right: width = right - left height = min(heights[left], heights[right]) max_area = max(max_area, width * height) if heights[left] < heights[right]: left += 1 else: right -= 1 return max_area","solution":"from typing import List def max_water_area(heights: List[int]) -> int: if not all(isinstance(height, int) and height >= 0 for height in heights): raise ValueError(\\"All elements in heights must be non-negative integers.\\") n = len(heights) if n < 2: return 0 left, right = 0, n - 1 max_area = 0 while left < right: width = right - left height = min(heights[left], heights[right]) max_area = max(max_area, width * height) if heights[left] < heights[right]: left += 1 else: right -= 1 return max_area"},{"question":"from typing import Tuple import math def shortest_distance(point: Tuple[float, float], segment_start: Tuple[float, float], segment_end: Tuple[float, float]) -> float: Calculate the shortest distance from a given point to a line segment defined by two endpoints. Parameters: point (Tuple[float, float]): Coordinates (x, y) of the point. segment_start (Tuple[float, float]): Coordinates (x, y) of the starting point of the line segment. segment_end (Tuple[float, float]): Coordinates (x, y) of the ending point of the line segment. Returns: float: The shortest distance from the point to the line segment. >>> shortest_distance((3, 4), (0, 0), (5, 5)) 0.7071 >>> shortest_distance((3, 4), (0, 0), (6, 0)) 4.0 >>> shortest_distance((3, 4), (0, 0), (0, 6)) 3.0 >>> shortest_distance((0, 0), (0, 0), (5, 5)) 0.0 >>> shortest_distance((5, 5), (0, 0), (5, 5)) 0.0 >>> shortest_distance((7, 7), (0, 0), (5, 5)) 2.8284","solution":"from typing import Tuple import math def shortest_distance(point: Tuple[float, float], segment_start: Tuple[float, float], segment_end: Tuple[float, float]) -> float: px, py = point sx, sy = segment_start ex, ey = segment_end # Calculate the vector from segment_start to segment_end segment_vector_x = ex - sx segment_vector_y = ey - sy # Calculate the vector from segment_start to the point point_vector_x = px - sx point_vector_y = py - sy # Calculate the dot product of the above two vectors dot_product = point_vector_x * segment_vector_x + point_vector_y * segment_vector_y seg_len_squared = segment_vector_x**2 + segment_vector_y**2 # Project point onto the line defined by segment_start and segment_end t = dot_product / seg_len_squared if seg_len_squared != 0 else -1 # Clamp t to the range [0, 1] t = max(0, min(1, t)) # Find the closest point on the segment closest_x = sx + t * segment_vector_x closest_y = sy + t * segment_vector_y # Calculate the distance from the point to the closest point on the segment distance = math.sqrt((px - closest_x)**2 + (py - closest_y)**2) return distance"},{"question":"from typing import List import heapq def find_k_smallest_elements(arr: List[int], k: int) -> List[int]: Finds the k smallest elements from the array and returns them in sorted order. >>> find_k_smallest_elements([5, 3, 1, 2, 4], 3) [1, 2, 3] >>> find_k_smallest_elements([7, 10, 4, 3, 20, 15], 4) [3, 4, 7, 10] >>> find_k_smallest_elements([-1, -2, -3, -4, -5], 2) [-5, -4] >>> find_k_smallest_elements([1], 1) [1] >>> find_k_smallest_elements([9, 8, 7, 6, 5], 5) [5, 6, 7, 8, 9]","solution":"from typing import List import heapq def find_k_smallest_elements(arr: List[int], k: int) -> List[int]: Finds the k smallest elements from the array and returns them in sorted order. if k == 0: return [] # Use a max-heap (inverted min-heap) to keep track of k smallest elements # Heapq by default is a min-heap, so we insert negative values to simulate a max-heap max_heap = [] for num in arr: if len(max_heap) < k: heapq.heappush(max_heap, -num) else: heapq.heappushpop(max_heap, -num) # Convert back to positive, sort, and return the result return sorted(-x for x in max_heap)"},{"question":"class Book: A class to manage the state of a single book in a library system. Methods: - __init__(self, title: str): Initializes the book with its title. - checkout(self): Checks out the book if it is currently \\"available\\". - return_book(self): Returns the book if it is currently \\"checked out\\". - reserve(self): Reserves the book if it is currently \\"available\\". - get_status(self) -> str: Returns the current status of the book (\\"available\\", \\"checked out\\", or \\"reserved\\"). def __init__(self, title: str): pass def checkout(self): pass def return_book(self): pass def reserve(self): pass def get_status(self) -> str: pass import pytest def test_initial_status(): book = Book(\\"1984\\") assert book.get_status() == \\"available\\" def test_checkout(): book = Book(\\"1984\\") book.checkout() assert book.get_status() == \\"checked out\\" def test_return_book(): book = Book(\\"1984\\") book.checkout() book.return_book() assert book.get_status() == \\"available\\" def test_reserve(): book = Book(\\"1984\\") book.reserve() assert book.get_status() == \\"reserved\\" def test_checkout_when_unavailable(): book = Book(\\"1984\\") book.checkout() with pytest.raises(ValueError): book.checkout() def test_return_when_not_checked_out(): book = Book(\\"1984\\") with pytest.raises(ValueError): book.return_book() def test_reserve_when_unavailable(): book = Book(\\"1984\\") book.checkout() with pytest.raises(ValueError): book.reserve() def test_return_reserved_book(): book = Book(\\"1984\\") book.reserve() with pytest.raises(ValueError): book.return_book() def test_empty_title_raises_error(): with pytest.raises(ValueError): Book(\\"\\") def test_checkout_from_reserved(): book = Book(\\"1984\\") book.reserve() with pytest.raises(ValueError): book.checkout()","solution":"class Book: def __init__(self, title: str): if not title: raise ValueError(\\"Title must be a non-empty string.\\") self.title = title self.status = \\"available\\" def checkout(self): if self.status != \\"available\\": raise ValueError(\\"Book cannot be checked out unless it is available.\\") self.status = \\"checked out\\" def return_book(self): if self.status != \\"checked out\\": raise ValueError(\\"Book cannot be returned unless it is checked out.\\") self.status = \\"available\\" def reserve(self): if self.status != \\"available\\": raise ValueError(\\"Book cannot be reserved unless it is available.\\") self.status = \\"reserved\\" def get_status(self) -> str: return self.status"},{"question":"def max_profit_multiple_transactions(prices: list[int]) -> int: Calculate the maximum profit from multiple buy and sell transactions. :param prices: List of daily stock prices :return: Maximum profit achievable >>> max_profit_multiple_transactions([7, 1, 5, 3, 6, 4]) 7 >>> max_profit_multiple_transactions([1, 2, 3, 4, 5]) 4 >>> max_profit_multiple_transactions([7, 6, 4, 3, 1]) 0 >>> max_profit_multiple_transactions([3, 3, 5, 0, 0, 3, 1, 4]) 8 pass","solution":"def max_profit_multiple_transactions(prices: list[int]) -> int: Calculate the maximum profit from multiple buy and sell transactions. :param prices: List of daily stock prices :return: Maximum profit achievable max_profit = 0 for i in range(1, len(prices)): # If the current price is greater than the previous price, we make a profit if prices[i] > prices[i - 1]: max_profit += prices[i] - prices[i - 1] return max_profit"},{"question":"def unique_pair_sums(numbers: list[int], target_sum: int, order: str = \\"ascending\\") -> list[tuple[int, int]]: Identifies all unique pairs of integers in a given list that add up to a target sum. Args: numbers: List of integers (can include positive and negative numbers). target_sum: An integer representing the target sum for pairs of numbers. order: A string specifying the order of results (\\"ascending\\" or \\"descending\\"). Default is \\"ascending\\". Returns: List of tuples, where each tuple contains a unique pair of integers from the input list that add up to the target sum, sorted by the specified order. >>> unique_pair_sums([2, 4, 3, 5, 7, 8, -1, 0], 7) [(0, 7), (-1, 8), (2, 5), (3, 4)] >>> unique_pair_sums([2, 4, 3, 5, 7, 8, -1, 0], 7, \\"descending\\") [(3, 4), (2, 5), (-1, 8), (0, 7)] >>> unique_pair_sums([1, 2, 3], 10) [] pass from solution import unique_pair_sums def test_unique_pair_sums_valid_pairs(): assert unique_pair_sums([2, 4, 3, 5, 7, 8, -1, 0], 7) == [(-1, 8), (0, 7), (2, 5), (3, 4)] def test_unique_pair_sums_valid_pairs_descending(): assert unique_pair_sums([2, 4, 3, 5, 7, 8, -1, 0], 7, \\"descending\\") == [(3, 4), (2, 5), (0, 7), (-1, 8)] def test_unique_pair_sums_no_pairs(): assert unique_pair_sums([1, 2, 3], 10) == [] def test_unique_pair_sums_empty_list(): assert unique_pair_sums([], 7) == [] def test_unique_pair_sums_invalid_target_sum(): assert unique_pair_sums([1, 2, 3], \\"10\\") == [] def test_unique_pair_sums_multiplicity_handling(): assert unique_pair_sums([1, 1, 2, 2, 3, 4], 5) == [(1, 4), (2, 3)] def test_unique_pair_sums_negative_and_positive_numbers(): assert unique_pair_sums([-1, -2, -3, 3, 6], 3) == [(-3, 6)]","solution":"def unique_pair_sums(numbers, target_sum, order=\\"ascending\\"): if not isinstance(target_sum, int): return [] numbers = list(numbers) # Ensure we are working with a list pairs_set = set() unique_numbers = set(numbers) for num in numbers: complement = target_sum - num if complement in unique_numbers: pairs_set.add(tuple(sorted((num, complement)))) # Remove the complement from unique_numbers to avoid duplicates unique_numbers.discard(num) unique_numbers.discard(complement) pairs_list = list(pairs_set) if order == \\"ascending\\": pairs_list.sort() elif order == \\"descending\\": pairs_list.sort(reverse=True) return pairs_list"},{"question":"import re def is_valid_ip(ip: str) -> bool: Validate the extracted IP address to ensure each segment is between 0 and 255. :param ip: The IP address string. :return: True if the IP address is valid, False otherwise. segments = ip.split('.') return all(0 <= int(segment) < 256 for segment in segments) def find_unique_ips(logfile_path: str): Reads a log file, extracts unique IP addresses, and writes them to an output file. :param logfile_path: The path to the log file. >>> log_content = ''' ... 192.168.1.1 - log info ... 192.168.1.1 - more log info ... 10.0.0.1 - some other log ... 10.0.0.2 - another entry ... 10.0.0.1 - duplicate entry ... 255.255.255.255 - max valid ip ... 256.256.256.256 - invalid ip ... ''' >>> with open('logfile.log', 'w') as f: ... f.write(log_content) >>> find_unique_ips('logfile.log') >>> with open('unique_ips.txt', 'r') as f: ... sorted(f.read().splitlines()) ['10.0.0.1', '10.0.0.2', '192.168.1.1', '255.255.255.255'] >>> log_content = '' >>> with open('empty_logfile.log', 'w') as f: ... f.write(log_content) >>> find_unique_ips('empty_logfile.log') >>> with open('unique_ips.txt', 'r') as f: ... f.read().splitlines() []","solution":"import re def find_unique_ips(logfile_path): Reads a log file, extracts unique IP addresses, and writes them to an output file. :param logfile_path: The path to the log file. ip_pattern = re.compile(r'b(?:d{1,3}.){3}d{1,3}b') unique_ips = set() # Reading the log file efficiently with open(logfile_path, 'r') as file: for line in file: ips = ip_pattern.findall(line) for ip in ips: if is_valid_ip(ip): unique_ips.add(ip) # Writing the unique IP addresses to the output file with open('unique_ips.txt', 'w') as output_file: for ip in sorted(unique_ips): output_file.write(ip + 'n') def is_valid_ip(ip): Validate the extracted IP address to ensure each segment is between 0 and 255 :param ip: The IP address string. :return: True if the IP address is valid, False otherwise. segments = ip.split('.') return all(0 <= int(segment) < 256 for segment in segments)"},{"question":"def matrix_multiplication(A, B): Multiplies two matrices A and B and returns the resulting matrix. Parameters: A (list of lists): The first matrix. B (list of lists): The second matrix. Returns: list of lists: The resulting matrix product of A and B. >>> A = [[1, 2, 3], [4, 5, 6]] >>> B = [[7, 8], [9, 10], [11, 12]] >>> matrix_multiplication(A, B) [[58, 64], [139, 154]] >>> A = [[3]] >>> B = [[4]] >>> matrix_multiplication(A, B) [[12]] >>> A = [[1, 2], [3, 4]] >>> B = [[5, 6], [7, 8]] >>> matrix_multiplication(A, B) [[19, 22], [43, 50]] >>> A = [[1, 2], [3, 4]] >>> B = [[1, 0], [0, 1]] >>> matrix_multiplication(A, B) [[1, 2], [3, 4]] >>> A = [[1, 2], [3, 4]] >>> B = [[0, 0], [0, 0]] >>> matrix_multiplication(A, B) [[0, 0], [0, 0]] pass","solution":"def matrix_multiplication(A, B): Multiplies two matrices A and B and returns the resulting matrix. Parameters: A (list of lists): The first matrix. B (list of lists): The second matrix. Returns: list of lists: The resulting matrix product of A and B. # Number of rows in A rows_A = len(A) # Number of columns in A cols_A = len(A[0]) # Number of columns in B cols_B = len(B[0]) # Initialize the result matrix with zeros result = [[0 for _ in range(cols_B)] for _ in range(rows_A)] # Compute the product matrix for i in range(rows_A): for j in range(cols_B): for k in range(cols_A): result[i][j] += A[i][k] * B[k][j] return result"},{"question":"import pytest def is_power_of_two(number: int) -> bool: Checks if a given non-negative integer is a power of two. Args: - number (int): The number to check. Returns: - bool: True if the number is a power of two, False otherwise. Raises: - ValueError: If the input is not a non-negative integer. >>> is_power_of_two(0) False >>> is_power_of_two(1) True >>> is_power_of_two(2) True >>> is_power_of_two(3) False >>> is_power_of_two(16) True >>> is_power_of_two(-4) Traceback (most recent call last): ... ValueError: Input must be a non-negative integer >>> is_power_of_two('string') Traceback (most recent call last): ... ValueError: Input must be a non-negative integer >>> is_power_of_two(4.5) Traceback (most recent call last): ... ValueError: Input must be a non-negative integer def test_is_power_of_two_valid(): assert is_power_of_two(0) == False assert is_power_of_two(1) == True assert is_power_of_two(2) == True assert is_power_of_two(3) == False assert is_power_of_two(16) == True assert is_power_of_two(31) == False assert is_power_of_two(64) == True def test_is_power_of_two_invalid_inputs(): with pytest.raises(ValueError): is_power_of_two(-1) with pytest.raises(ValueError): is_power_of_two(\\"string\\") with pytest.raises(ValueError): is_power_of_two(4.5) with pytest.raises(ValueError): is_power_of_two(None) def test_is_power_of_two_large_numbers(): assert is_power_of_two(1024) == True assert is_power_of_two(1023) == False assert is_power_of_two(2048) == True assert is_power_of_two(4096) == True if __name__ == \\"__main__\\": pytest.main()","solution":"def is_power_of_two(number: int) -> bool: Checks if a given non-negative integer is a power of two. Args: - number (int): The number to check. Returns: - bool: True if the number is a power of two, False otherwise. Raises: - ValueError: If the input is not a non-negative integer. if not isinstance(number, int) or number < 0: raise ValueError(\\"Input must be a non-negative integer\\") # A number is a power of two if it is greater than 0 # and its binary representation has only one '1' bit return number != 0 and (number & (number - 1)) == 0"},{"question":"class BakeryInventory: def __init__(self): Initializes with an empty dictionary to store the inventory. def add_pastry(self, pastry_name: str, quantity: int) -> None: Adds a new type of pastry to the inventory with the given quantity. If the pastry already exists, it updates the quantity. def update_quantity(self, pastry_name: str, quantity: int) -> None: Updates the quantity of an existing pastry. If the pastry does not exist, it raises a ValueError. def generate_report(self) -> str: Returns a formatted string listing all pastries and their quantities, sorted by pastry name. >>> inventory = BakeryInventory() >>> inventory.add_pastry(\\"Croissant\\", 50) >>> inventory.add_pastry(\\"Baguette\\", 30) >>> inventory.update_quantity(\\"Croissant\\", 20) >>> print(inventory.generate_report()) Baguette: 30 Croissant: 20 import pytest def test_add_pastry(): inventory = BakeryInventory() inventory.add_pastry(\\"Croissant\\", 50) assert inventory.inventory[\\"Croissant\\"] == 50 inventory.add_pastry(\\"Croissant\\", 25) assert inventory.inventory[\\"Croissant\\"] == 75 inventory.add_pastry(\\"Baguette\\", 30) assert inventory.inventory[\\"Baguette\\"] == 30 def test_update_quantity(): inventory = BakeryInventory() inventory.add_pastry(\\"Croissant\\", 50) inventory.update_quantity(\\"Croissant\\", 20) assert inventory.inventory[\\"Croissant\\"] == 20 with pytest.raises(ValueError): inventory.update_quantity(\\"Brioche\\", 15) def test_generate_report(): inventory = BakeryInventory() inventory.add_pastry(\\"Croissant\\", 50) inventory.add_pastry(\\"Baguette\\", 30) report = inventory.generate_report() expected_report = \\"Baguette: 30nCroissant: 50\\" assert report == expected_report inventory.update_quantity(\\"Croissant\\", 20) report = inventory.generate_report() expected_report = \\"Baguette: 30nCroissant: 20\\" assert report == expected_report","solution":"class BakeryInventory: def __init__(self): self.inventory = {} def add_pastry(self, pastry_name: str, quantity: int) -> None: Adds a new type of pastry to the inventory with the given quantity. If the pastry already exists, it updates the quantity. if pastry_name in self.inventory: self.inventory[pastry_name] += quantity else: self.inventory[pastry_name] = quantity def update_quantity(self, pastry_name: str, quantity: int) -> None: Updates the quantity of an existing pastry. If the pastry does not exist, it raises a ValueError. if pastry_name in self.inventory: self.inventory[pastry_name] = quantity else: raise ValueError(f\\"Pastry '{pastry_name}' does not exist in the inventory.\\") def generate_report(self) -> str: Returns a formatted string listing all pastries and their quantities, sorted by pastry name. report = [] for pastry in sorted(self.inventory.keys()): report.append(f\\"{pastry}: {self.inventory[pastry]}\\") return \\"n\\".join(report)"},{"question":"def rectangle_properties(length: float, width: float, property: str) -> float: Calculates the specified property ('area' or 'perimeter') of a rectangle given its length and width. Parameters: length (float): The length of the rectangle. Must be positive. width (float): The width of the rectangle. Must be positive. property (str): The property to calculate, either 'area' or 'perimeter'. Returns: float: The value of the requested property. Raises: ValueError: If dimensions are not positive or if an invalid property is requested. pass # Test cases def test_rectangle_properties_area(): assert rectangle_properties(5, 10, 'area') == 50.0 def test_rectangle_properties_perimeter(): assert rectangle_properties(5, 10, 'perimeter') == 30.0 def test_rectangle_properties_invalid_length(): try: rectangle_properties(-5, 10, 'area') except ValueError as e: assert str(e) == \\"Dimensions must be positive\\" def test_rectangle_properties_invalid_width(): try: rectangle_properties(5, -10, 'area') except ValueError as e: assert str(e) == \\"Dimensions must be positive\\" def test_rectangle_properties_invalid_property(): try: rectangle_properties(5, 10, 'volume') except ValueError as e: assert str(e) == \\"Invalid property requested\\"","solution":"def rectangle_properties(length: float, width: float, property: str) -> float: Calculates the specified property ('area' or 'perimeter') of a rectangle given its length and width. Parameters: length (float): The length of the rectangle. Must be positive. width (float): The width of the rectangle. Must be positive. property (str): The property to calculate, either 'area' or 'perimeter'. Returns: float: The value of the requested property. Raises: ValueError: If dimensions are not positive or if an invalid property is requested. # Validate the dimensions if length <= 0 or width <= 0: raise ValueError(\\"Dimensions must be positive\\") # Calculate the requested property if property == 'area': return length * width elif property == 'perimeter': return 2 * (length + width) else: raise ValueError(\\"Invalid property requested\\")"},{"question":"def is_valid_brackets(sequence: str) -> bool: Verify if a given string consisting of brackets \`(\`, \`)\`, \`{\`, \`}\`, \`[\` and \`]\` is valid. A sequence of brackets is considered valid if all types of brackets are correctly matched and nested. >>> is_valid_brackets(\\"(){}[]\\") True >>> is_valid_brackets(\\"({[)]}\\") False >>> is_valid_brackets(\\"{[()]}\\") True >>> is_valid_brackets(\\"[({})\\") False >>> is_valid_brackets(\\"\\") True","solution":"def is_valid_brackets(sequence: str) -> bool: stack = [] bracket_pairs = {')': '(', '}': '{', ']': '['} for char in sequence: if char in bracket_pairs.values(): stack.append(char) elif char in bracket_pairs.keys(): if stack == [] or stack.pop() != bracket_pairs[char]: return False else: continue return stack == []"},{"question":"def fibonacci_optimized(n: int) -> int: Compute the nth Fibonacci number using an optimized iterative approach. :param n: The position in the Fibonacci sequence (0-indexed) whose Fibonacci number is to be computed. :return: The nth Fibonacci number >>> fibonacci_optimized(0) == 0 >>> fibonacci_optimized(1) == 1 >>> fibonacci_optimized(10) == 55 >>> fibonacci_optimized(50) == 12586269025","solution":"def fibonacci_optimized(n: int) -> int: Compute the nth Fibonacci number using an optimized iterative approach. :param n: The position in the Fibonacci sequence (0-indexed) whose Fibonacci number is to be computed. :return: The nth Fibonacci number if n == 0: return 0 elif n == 1: return 1 a, b = 0, 1 for _ in range(2, n + 1): a, b = b, a + b return b"},{"question":"def compress_string(s: str) -> str: Compress the input string using the counts of repeated characters. Returns the compressed string if it is shorter than the original string; otherwise, returns the original string. >>> compress_string(\\"a\\") == \\"a\\" >>> compress_string(\\"ab\\") == \\"ab\\" >>> compress_string(\\"abcdef\\") == \\"abcdef\\" >>> compress_string(\\"aaabccddd\\") == \\"a3b1c2d3\\" >>> compress_string(\\"a2b2c2\\") == \\"aabbcc\\" def decompress_string(s: str) -> str: Decompress the input string which is in the format produced by compress_string. Returns the original string. >>> decompress_string(\\"a3b1c2d3\\") == \\"aaabccddd\\" >>> decompress_string(\\"a12b1c6\\") == \\"aaaaaaaaaaaabcccccc\\" >>> decompress_string(\\"a1b1c1\\") == \\"abc\\" >>> decompress_string(\\"a2b10c3\\") == \\"aabbbbbbbbbbccc\\" >>> decompress_string(\\"a100\\") == \\"a\\" * 100","solution":"def compress_string(s): Compress the input string using the counts of repeated characters. Returns the compressed string if it is shorter than the original string, otherwise returns the original string. if not s: return s compressed = [] count = 1 prev_char = s[0] for char in s[1:]: if char == prev_char: count += 1 else: compressed.append(prev_char) compressed.append(str(count)) prev_char = char count = 1 compressed.append(prev_char) compressed.append(str(count)) compressed_string = ''.join(compressed) return compressed_string if len(compressed_string) < len(s) else s def decompress_string(s): Decompress the input string which is in the format produced by compress_string. Returns the original string. decompressed = [] i = 0 while i < len(s): char = s[i] i += 1 count = 0 while i < len(s) and s[i].isdigit(): count = count * 10 + int(s[i]) i += 1 decompressed.append(char * count) return ''.join(decompressed)"},{"question":"def is_binary_palindrome(binary_str: str) -> bool: Determine if a binary string is a palindrome. :param binary_str: String representing a binary number :return: Boolean indicating if the binary string is a palindrome >>> is_binary_palindrome(\\"101\\") True >>> is_binary_palindrome(\\"110\\") False >>> is_binary_palindrome(\\"1111\\") True >>> is_binary_palindrome(\\"1001\\") True >>> is_binary_palindrome(\\"1010\\") False","solution":"def is_binary_palindrome(binary_str: str) -> bool: Determine if a binary string is a palindrome. :param binary_str: String representing a binary number :return: Boolean indicating if the binary string is a palindrome >>> is_binary_palindrome(\\"101\\") True >>> is_binary_palindrome(\\"110\\") False >>> is_binary_palindrome(\\"1111\\") True >>> is_binary_palindrome(\\"1001\\") True >>> is_binary_palindrome(\\"1010\\") False return binary_str == binary_str[::-1]"},{"question":"import numpy as np from typing import Tuple def logistic_regression(X: np.ndarray, y: np.ndarray, learning_rate: float = 0.01, max_iter: int = 1000, tol: float = 1e-4, penalty: float = 1.0) -> Tuple[np.ndarray, list]: Perform logistic regression with L2 regularization on the given dataset. Parameters: X (np.ndarray): A 2D numpy array where each row is a feature vector. y (np.ndarray): A 1D numpy array containing the binary target values. learning_rate (float, optional): Learning rate for the gradient descent. Default is 0.01. max_iter (int, optional): Maximum number of iterations for the gradient descent. Default is 1000. tol (float, optional): The tolerance for stopping criteria. Default is 1e-4. penalty (float, optional): The penalty strength for L2 regularization. Default is 1.0. Returns: Tuple[np.ndarray, list]: Final coefficients and the log of the cost function over iterations. pass # Sample data X = np.array([ [1.0, 2.0], [1.5, 1.8], [5.0, 8.0], [8.0, 8.0], [1.0, 0.6], [9.0, 11.0] ]) y = np.array([0, 0, 1, 1, 0, 1]) # Parameters learning_rate = 0.01 max_iter = 1000 tol = 1e-4 penalty = 0.1 coefficients, cost_history = logistic_regression(X, y, learning_rate, max_iter, tol, penalty) print(\\"Coefficients:n\\", coefficients) print(\\"Cost History:n\\", cost_history)","solution":"import numpy as np from typing import Tuple def sigmoid(z): return 1 / (1 + np.exp(-z)) def compute_cost(X, y, theta, penalty): m = len(y) h = sigmoid(np.dot(X, theta)) cost = (-1/m) * np.sum(y * np.log(h) + (1 - y) * np.log(1 - h)) reg_cost = cost + (penalty/(2*m)) * np.sum(np.square(theta[1:])) return reg_cost def compute_gradient(X, y, theta, penalty): m = len(y) h = sigmoid(np.dot(X, theta)) gradient = (1/m) * np.dot(X.T, (h - y)) reg_gradient = gradient + (penalty/m) * np.append([0], theta[1:]) return reg_gradient def logistic_regression(X: np.ndarray, y: np.ndarray, learning_rate: float = 0.01, max_iter: int = 1000, tol: float = 1e-4, penalty: float = 1.0) -> Tuple[np.ndarray, list]: m, n = X.shape theta = np.zeros(n) cost_history = [] for i in range(max_iter): gradient = compute_gradient(X, y, theta, penalty) theta = theta - learning_rate * gradient cost = compute_cost(X, y, theta, penalty) cost_history.append(cost) # Early stopping based on tolerance if i > 0 and abs(cost_history[-2] - cost_history[-1]) < tol: break return theta, cost_history"},{"question":"class Trie: def __init__(self): self.root = {} self.end_of_word = \\"#\\" def insert(self, word: str) -> None: Insert a word into the trie. node = self.root for char in word: if char not in node: node[char] = {} node = node[char] node[self.end_of_word] = self.end_of_word def search_with_wildcard(self, pattern: str) -> list: Search for all words in the trie that match the given wildcard pattern. Arguments: pattern -- a string containing letters and the '.' wildcard character. Returns: A list of strings representing all words in the trie matching the pattern, ordered lexicographically. Examples: >>> trie = Trie() >>> trie.insert(\\"dog\\") >>> trie.insert(\\"cat\\") >>> trie.insert(\\"car\\") >>> trie.insert(\\"dag\\") >>> trie.insert(\\"cog\\") >>> trie.search_with_wildcard(\\"c.t\\") ['cat'] >>> trie.search_with_wildcard(\\"d.g\\") ['dag', 'dog'] >>> trie.search_with_wildcard(\\".og\\") ['cog', 'dog'] # Implement this method pass","solution":"class Trie: def __init__(self): self.root = {} self.end_of_word = \\"#\\" def insert(self, word: str) -> None: node = self.root for char in word: if char not in node: node[char] = {} node = node[char] node[self.end_of_word] = self.end_of_word def search_with_wildcard(self, pattern: str) -> list: def search(node, pattern): if not pattern: return [\\"\\" if self.end_of_word in node else None] char = pattern[0] if char == '.': results = [] for child_char in node: if child_char != self.end_of_word: child_results = search(node[child_char], pattern[1:]) for child_result in child_results: if child_result is not None: results.append(child_char + child_result) return results elif char in node: child_results = search(node[char], pattern[1:]) return [char + child_result for child_result in child_results if child_result is not None] else: return [] results = search(self.root, pattern) results = [result for result in results if result is not None] return sorted(results)"},{"question":"class LowPassFilter: def __init__(self, cutoff_freq, samplerate): Initialize the LowPassFilter with the given cut off frequency and sample rate. Args: cutoff_freq (float): The cut off frequency in Hertz. samplerate (int): The sample rate in samples per second. # Your initialization code here def process(self, sample: float) -> float: Process a single audio sample through the low-pass filter and return the filtered sample. Args: sample (float): The input audio sample. Returns: float: The filtered audio sample. # Your processing code here def configure_low_pass_filter(cutoff_freq: float, samplerate: int) -> LowPassFilter: Initialize and return an instance of LowPassFilter configured with the given cutoff frequency and sample rate. Args: cutoff_freq (float): The cut off frequency in Hertz. samplerate (int): The sample rate in samples per second. Returns: LowPassFilter: Configured LowPassFilter instance. Raises: ValueError: If cutoff_freq is not between 1 Hz and half of the samplerate or if samplerate is not a positive integer. # Your setup code here def show_frequency_response(filter_instance, samplerate): Visualize the frequency response of the given filter instance. Args: filter_instance (LowPassFilter): The filter instance to visualize. samplerate (int): The sample rate in samples per second. # Your visualization code here def show_impulse_response(filter_instance, samplerate): Visualize the impulse response of the given filter instance. Args: filter_instance (LowPassFilter): The filter instance to visualize. samplerate (int): The sample rate in samples per second. # Your visualization code here","solution":"import numpy as np from scipy.signal import butter, lfilter_zi, lfilter class LowPassFilter: def __init__(self, cutoff_freq, samplerate): self.cutoff_freq = cutoff_freq self.samplerate = samplerate self.b, self.a = butter(1, cutoff_freq / (0.5 * samplerate), btype='low', analog=False) self.zi = lfilter_zi(self.b, self.a) * 0 # initialize filter state def process(self, sample: float) -> float: filtered_sample, self.zi = lfilter(self.b, self.a, [sample], zi=self.zi) return filtered_sample[0] def configure_low_pass_filter(cutoff_freq: float, samplerate: int) -> LowPassFilter: if not (1 <= cutoff_freq <= samplerate / 2): raise ValueError(\\"cutoff_freq must be between 1 Hz and half of the samplerate\\") if samplerate <= 0: raise ValueError(\\"samplerate must be a positive integer\\") return LowPassFilter(cutoff_freq, samplerate) def show_frequency_response(filter_instance, samplerate): import matplotlib.pyplot as plt from scipy.signal import freqz w, h = freqz(filter_instance.b, filter_instance.a, worN=8000) plt.plot(0.5 * samplerate * w / np.pi, np.abs(h), 'b') plt.plot(filter_instance.cutoff_freq, 0.5 * np.sqrt(2), 'ko') plt.axvline(filter_instance.cutoff_freq, color='k') plt.xlim(0, 0.5 * samplerate) plt.title(\\"Frequency Response\\") plt.xlabel('Frequency [Hz]') plt.ylabel('Gain') plt.grid() plt.show() def show_impulse_response(filter_instance, samplerate): import matplotlib.pyplot as plt impulse = np.zeros(100) impulse[0] = 1.0 response = np.zeros(100) for i in range(100): response[i] = filter_instance.process(impulse[i]) plt.plot(response, 'b') plt.title('Impulse Response') plt.xlabel('Samples') plt.ylabel('Amplitude') plt.grid() plt.show()"},{"question":"class StringTransformer: def compress(self, s: str) -> str: Compress the input string \`s\` by replacing consecutive repeated characters with the character followed by the count of repetitions. >>> transformer = StringTransformer() >>> transformer.compress(\\"aaabbbccc\\") == \\"a3b3c3\\" >>> transformer.compress(\\"a\\") == \\"a1\\" >>> transformer.compress(\\"abc\\") == \\"a1b1c1\\" >>> transformer.compress(\\"abbbcccdde\\") == \\"a1b3c3d2e1\\" >>> transformer.compress(\\"\\") == \\"\\" pass def decompress(self, s: str) -> str: Decompress a run-length encoded string back to its original form. >>> transformer = StringTransformer() >>> transformer.decompress(\\"a3b3c3\\") == \\"aaabbbccc\\" >>> transformer.decompress(\\"a1\\") == \\"a\\" >>> transformer.decompress(\\"a1b1c1\\") == \\"abc\\" >>> transformer.decompress(\\"a1b3c3d2e1\\") == \\"abbbcccdde\\" >>> transformer.decompress(\\"\\") == \\"\\" pass def transform(self, s: str, shifts: list[int]) -> str: Apply a series of character shifts to the string \`s\`. Each character in \`s\` is shifted by the corresponding value in \`shifts\`. If shifts length is shorter than the string length, repeat the shifts cyclically. >>> transformer = StringTransformer() >>> transformer.transform(\\"abc\\", [1, -1, 3]) == \\"baf\\" >>> transformer.transform(\\"aaa\\", [25, 25, 25]) == \\"zzz\\" >>> transformer.transform(\\"xyz\\", [1, 1, 1]) == \\"yza\\" >>> transformer.transform(\\"abc\\", [1]) == \\"bcd\\" >>> transformer.transform(\\"abc\\", [-1, -1, -1]) == \\"zab\\" pass","solution":"class StringTransformer: def compress(self, s: str) -> str: if not s: return \\"\\" result = [] count = 1 for i in range(1, len(s)): if s[i] == s[i - 1]: count += 1 else: result.append(s[i - 1] + str(count)) count = 1 result.append(s[-1] + str(count)) # Append the last character and count return ''.join(result) def decompress(self, s: str) -> str: result = [] i = 0 while i < len(s): char = s[i] count = 0 i += 1 while i < len(s) and s[i].isdigit(): count = count * 10 + int(s[i]) i += 1 result.append(char * count) return ''.join(result) def transform(self, s: str, shifts: list[int]) -> str: result = [] n = len(shifts) for i, char in enumerate(s): shift_value = shifts[i % n] new_char = chr((ord(char) - ord('a') + shift_value) % 26 + ord('a')) result.append(new_char) return ''.join(result)"},{"question":"def sum_pascals_triangle(n: int) -> int: Calculates the sum of all elements in the first 'n' rows of Pascal's Triangle. Since sum of all elements in row 'i' is 2^i, we just need to calculate the sum of 2^0 + 2^1 + 2^2 + ... + 2^(n-1). This can be simplified using the formula for the sum of a geometric series. >>> sum_pascals_triangle(3) 7 >>> sum_pascals_triangle(4) 15","solution":"def sum_pascals_triangle(n: int) -> int: Calculates the sum of all elements in the first 'n' rows of Pascal's Triangle. Since sum of all elements in row 'i' is 2^i, we just need to calculate the sum of 2^0 + 2^1 + 2^2 + ... + 2^(n-1). This can be simplified using the formula for the sum of a geometric series. return (2 ** n) - 1"},{"question":"class Node: def __init__(self, val: int = 0, neighbors: list = None, random: 'Node' = None): self.val = val self.neighbors = neighbors if neighbors is not None else [] self.random = random def clone_graph(node: 'Node') -> 'Node': Creates a deep copy of a graph where each node contains an additional random pointer. Args: node (Node): The starting node of the graph. Returns: Node: The starting node of the deep copied graph. >>> node1 = Node(1) >>> node2 = Node(2) >>> node3 = Node(3) >>> node4 = Node(4) >>> node1.neighbors = [node2, node3] >>> node2.neighbors = [node3] >>> node3.neighbors = [node4] >>> node4.neighbors = [node1] >>> node1.random = node3 >>> node2.random = node1 >>> node3.random = node2 >>> node4.random = node4 >>> clone = clone_graph(node1) >>> clone.val == node1.val True >>> len(clone.neighbors) == 2 True >>> clone.neighbors[0].val == node2.val True >>> clone.neighbors[1].val == node3.val True >>> clone.random.val == node3.val True >>> clone.random is not node3 True","solution":"class Node: def __init__(self, val: int = 0, neighbors: list = None, random: 'Node' = None): self.val = val self.neighbors = neighbors if neighbors is not None else [] self.random = random def clone_graph(node: 'Node') -> 'Node': if not node: return None # Dictionary to save visited nodes and their clones visited = {} def clone(node): if node in visited: return visited[node] # Create a cloned node cloned_node = Node(node.val) visited[node] = cloned_node # Deep copy the neighbors for neighbor in node.neighbors: cloned_node.neighbors.append(clone(neighbor)) # Deep copy the random pointer if node.random: cloned_node.random = clone(node.random) return cloned_node return clone(node)"},{"question":"def find_most_frequent_string(strings: List[str]) -> str: Find the string which appears the most frequently in the list. If there are ties, return the lexicographically smallest string among those that appear the most frequently. >>> find_most_frequent_string([\\"apple\\", \\"banana\\", \\"apple\\", \\"orange\\", \\"banana\\", \\"apple\\"]) \\"apple\\" >>> find_most_frequent_string([\\"apple\\", \\"banana\\", \\"orange\\"]) \\"apple\\" >>> find_most_frequent_string([]) \\"\\" >>> find_most_frequent_string([\\"banana\\", \\"banana\\", \\"apple\\", \\"orange\\", \\"orange\\"]) \\"banana\\" >>> find_most_frequent_string([\\"apple\\", \\"apple\\", \\"banana\\", \\"banana\\", \\"cherry\\"]) \\"apple\\" pass","solution":"from typing import List from collections import Counter def find_most_frequent_string(strings: List[str]) -> str: if not strings: return \\"\\" frequency = Counter(strings) max_frequency = max(frequency.values()) most_frequent_strings = [s for s in frequency if frequency[s] == max_frequency] return min(most_frequent_strings)"},{"question":"from typing import List class CourseEnrollment: Course Enrollment System for a university. Allows you to enroll students in courses, check if a student is enrolled in a course, and list all students enrolled in a course. Examples: >>> course_system = CourseEnrollment() >>> course_system.enroll(1, \\"Math101\\") >>> course_system.enroll(2, \\"Math101\\") >>> course_system.is_enrolled(1, \\"Math101\\") True >>> course_system.is_enrolled(2, \\"CS101\\") False >>> course_system.list_students(\\"Math101\\") [1, 2] >>> course_system.list_students(\\"CS101\\") [] def __init__(self): pass def enroll(self, student_id: int, course_name: str) -> None: pass def is_enrolled(self, student_id: int, course_name: str) -> bool: pass def list_students(self, course_name: str) -> List[int]: pass","solution":"class CourseEnrollment: def __init__(self): self.course_enrollments = {} def enroll(self, student_id: int, course_name: str) -> None: if course_name not in self.course_enrollments: self.course_enrollments[course_name] = set() self.course_enrollments[course_name].add(student_id) def is_enrolled(self, student_id: int, course_name: str) -> bool: return student_id in self.course_enrollments.get(course_name, set()) def list_students(self, course_name: str) -> list: return sorted(self.course_enrollments.get(course_name, set())) # Example usage: # course_system = CourseEnrollment() # course_system.enroll(1, \\"Math101\\") # course_system.enroll(2, \\"Math101\\") # course_system.enroll(1, \\"CS101\\") # course_system.enroll(3, \\"Math101\\") # print(course_system.is_enrolled(1, \\"Math101\\")) # Expected: True # print(course_system.is_enrolled(2, \\"CS101\\")) # Expected: False # print(course_system.list_students(\\"Math101\\")) # Expected: [1, 2, 3] # print(course_system.list_students(\\"CS101\\")) # Expected: [1]"},{"question":"class DynamicArray: A Dynamic Array that resizes to manage memory efficiently. Methods: - push_back(value): Add an element at the end of the array. - pop_back(): Remove and return the last element of the array. - size(): Return the number of elements in the array. - capacity(): Return the current capacity of the array. - __getitem__(index): Access the element at the given index. Example usage: >>> arr = DynamicArray() >>> arr.push_back(1) >>> arr.push_back(2) >>> arr.size() # Output: 2 >>> arr.capacity() # Output: 2 >>> arr.pop_back() # Output: 2 Ensure proper handling of memory reallocation and no memory leaks. def __init__(self): # Initialize your DynamicArray def push_back(self, value): # Adds a new element to the end of the array def pop_back(self): # Removes and returns the last element of the array def size(self): # Returns the number of elements in the array def capacity(self): # Returns the internal capacity of the array def __getitem__(self, index): # Overloading the subscript operator for element access def _resize(self): # Handles the resizing of the array when it runs out of space def test_push_back(): arr = DynamicArray() arr.push_back(1) assert arr.size() == 1 assert arr.capacity() == 1 assert arr[0] == 1 arr.push_back(2) assert arr.size() == 2 assert arr.capacity() == 2 assert arr[1] == 2 def test_resize(): arr = DynamicArray() for i in range(4): arr.push_back(i) assert arr.size() == 4 assert arr.capacity() == 4 assert arr[0] == 0 assert arr[1] == 1 assert arr[2] == 2 assert arr[3] == 3 def test_pop_back(): arr = DynamicArray() arr.push_back(1) arr.push_back(2) assert arr.pop_back() == 2 assert arr.size() == 1 assert arr.pop_back() == 1 assert arr.size() == 0 try: arr.pop_back() except IndexError: assert True else: assert False def test_bounds_checking(): arr = DynamicArray() arr.push_back(1) try: arr[1] except IndexError: assert True else: assert False try: arr[-1] except IndexError: assert True else: assert False","solution":"class DynamicArray: def __init__(self): self._size = 0 self._capacity = 1 self._array = [0] * self._capacity def push_back(self, value): if self._size == self._capacity: self._resize() self._array[self._size] = value self._size += 1 def pop_back(self): if self._size == 0: raise IndexError(\\"pop_back from empty array\\") self._size -= 1 return self._array[self._size] def size(self): return self._size def capacity(self): return self._capacity def __getitem__(self, index): if index < 0 or index >= self._size: raise IndexError(\\"array index out of range\\") return self._array[index] def _resize(self): self._capacity *= 2 new_array = [0] * self._capacity for i in range(self._size): new_array[i] = self._array[i] self._array = new_array"},{"question":"def repeated_digit_sum(n: int) -> int: Given a number, return its repeated digit sum. >>> repeated_digit_sum(987) 6 >>> repeated_digit_sum(12345) 6 def test_repeated_digit_sum_single_digit(): assert repeated_digit_sum(0) == 0 assert repeated_digit_sum(5) == 5 def test_repeated_digit_sum_double_digits(): assert repeated_digit_sum(18) == 9 assert repeated_digit_sum(27) == 9 assert repeated_digit_sum(99) == 9 def test_repeated_digit_sum_large_number(): assert repeated_digit_sum(12345) == 6 assert repeated_digit_sum(987654321) == 9 def test_repeated_digit_sum_with_carry(): assert repeated_digit_sum(999999999) == 9 assert repeated_digit_sum(1001) == 2 def test_repeated_digit_sum_edge_cases(): assert repeated_digit_sum(1) == 1 assert repeated_digit_sum(1000000000000000000) == 1","solution":"def repeated_digit_sum(n: int) -> int: Given a number, return its repeated digit sum. if n == 0: return 0 if n % 9 == 0: return 9 else: return n % 9"},{"question":"def is_scramble(s1: str, s2: str) -> bool: Determines if string s1 is a scrambled string of s2. Args: s1 (str): The first string. s2 (str): The second string. Returns: bool: True if s1 is a scrambled string of s2, otherwise False. Examples: >>> is_scramble(\\"great\\", \\"rgeat\\") True >>> is_scramble(\\"abcde\\", \\"caebd\\") False >>> is_scramble(\\"a\\", \\"a\\") True >>> is_scramble(\\"abc\\", \\"bca\\") True >>> is_scramble(\\"abc\\", \\"cab\\") True pass","solution":"def is_scramble(s1: str, s2: str) -> bool: Determines if string s1 is a scrambled string of s2. Args: s1 (str): The first string. s2 (str): The second string. Returns: bool: True if s1 is a scrambled string of s2, otherwise False. # If the strings are equal, then s2 is a scrambled string of s1 if s1 == s2: return True # If the strings are not of the same length or have different character counts, they can't be scrambled versions if sorted(s1) != sorted(s2): return False n = len(s1) for i in range(1, n): # Check if there exists a split index \`i\` where one of the two conditions is true and make recursive calls if (is_scramble(s1[:i], s2[:i]) and is_scramble(s1[i:], s2[i:])) or (is_scramble(s1[:i], s2[-i:]) and is_scramble(s1[i:], s2[:-i])): return True return False"},{"question":"def is_sorted(arr: list[int]) -> bool: Checks if the given list is sorted in ascending order. >>> is_sorted([1, 2, 3, 4]) True >>> is_sorted([4, 3, 2, 1]) False >>> is_sorted([1, 3, 2, 4]) False >>> is_sorted([-5, -1, 0, 2, 5]) True def custom_binary_search(arr: list[int], target: int, log_steps: bool = False) -> tuple[int, list[tuple[int, str]]]: Performs binary search on a sorted array with logging and error handling for unsorted arrays. Args: arr: list[int] - Array of integers to search within. target: int - The target integer to search for. log_steps: bool - Flag to log the steps taken during search. Returns: tuple[int, list[tuple[int, str]]] - A tuple containing the index of the target if found, and a log of steps as (midpoint, comparison result) tuples. >>> custom_binary_search([1, 2, 3, 4, 5, 6], 4, log_steps=True) (3, [(2, 'less'), (4, 'greater'), (3, 'equal')]) >>> custom_binary_search([1, 2, 3, 4, 5, 6], 7, log_steps=True) (-1, [(2, 'less'), (4, 'less'), (5, 'less')]) >>> custom_binary_search([], 1, log_steps=True) (-1, []) import pytest def test_is_sorted(): assert is_sorted([1, 2, 3, 4]) assert is_sorted([1]) assert is_sorted([]) assert not is_sorted([4, 3, 2, 1]) assert not is_sorted([1, 3, 2, 4]) assert is_sorted([-5, -1, 0, 2, 5]) def test_custom_binary_search_sorted_array(): arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] target = 5 index, log = custom_binary_search(arr, target, log_steps=True) assert index == 4 assert log[-1] == (4, 'equal') def test_custom_binary_search_unsorted_array(): arr = [10, 9, 8, 7, 6, 5, 4, 3, 2, 1] with pytest.raises(ValueError, match=\\"The array is not sorted in ascending order.\\"): custom_binary_search(arr, 5) def test_custom_binary_search_target_not_in_array(): arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] target = 11 index, log = custom_binary_search(arr, target, log_steps=True) assert index == -1 assert log[-1][1] != 'equal' def test_custom_binary_search_empty_array(): arr = [] target = 1 index, log = custom_binary_search(arr, target, log_steps=True) assert index == -1 assert log == [] def test_custom_binary_search_single_element_array(): arr = [5] target = 5 index, log = custom_binary_search(arr, target, log_steps=True) assert index == 0 assert log[-1] == (0, 'equal') target = 4 index, log = custom_binary_search(arr, target, log_steps=True) assert index == -1 assert log[-1][1] != 'equal'","solution":"def is_sorted(arr: list[int]) -> bool: Checks if the given list is sorted in ascending order. for i in range(len(arr) - 1): if arr[i] > arr[i + 1]: return False return True def custom_binary_search(arr: list[int], target: int, log_steps: bool = False) -> tuple[int, list[tuple[int, str]]]: Performs binary search on a sorted array with logging and error handling for unsorted arrays. Args: arr: list[int] - Array of integers to search within. target: int - The target integer to search for. log_steps: bool - Flag to log the steps taken during search. Returns: tuple[int, list[tuple[int, str]]] - A tuple containing the index of the target if found, and a log of steps as (midpoint, comparison result) tuples. if not is_sorted(arr): raise ValueError(\\"The array is not sorted in ascending order.\\") left, right = 0, len(arr) - 1 log = [] while left <= right: mid = (left + right) // 2 if log_steps: if arr[mid] == target: log.append((mid, 'equal')) elif arr[mid] < target: log.append((mid, 'less')) else: log.append((mid, 'greater')) if arr[mid] == target: return (mid, log) elif arr[mid] < target: left = mid + 1 else: right = mid - 1 return (-1, log)"},{"question":"class CalendarEventManager: A utility to manage events in a calendar. It allows adding events, retrieving events occurring on a specific date, and removing events by their IDs. Methods: - add_event(event_date: str, event_name: str, event_description: str) -> int : Adds an event and returns a unique event ID. - get_events(event_date: str) -> list : Retrieves a list of events for a specified date. - remove_event(event_id: int) -> bool : Removes an event by its ID and returns True if successful, False otherwise. def __init__(self): self.events = {} def add_event(self, event_date: str, event_name: str, event_description: str) -> int: ... def get_events(self, event_date: str) -> list: ... def remove_event(self, event_id: int) -> bool: ... # Unit tests to verify the functionality of the CalendarEventManager class. def test_add_event(): calendar = CalendarEventManager() event_id = calendar.add_event(\\"2023-11-25\\", \\"Meeting\\", \\"Project status update meeting\\") assert event_id == 1 def test_get_events_no_events(): calendar = CalendarEventManager() events = calendar.get_events(\\"2023-11-25\\") assert events == [] def test_get_events_with_events(): calendar = CalendarEventManager() calendar.add_event(\\"2023-11-25\\", \\"Meeting\\", \\"Project status update meeting\\") calendar.add_event(\\"2023-11-25\\", \\"Workshop\\", \\"Python programming workshop\\") events = calendar.get_events(\\"2023-11-25\\") assert len(events) == 2 assert events[0]['name'] == \\"Meeting\\" assert events[1]['name'] == \\"Workshop\\" def test_remove_event_success(): calendar = CalendarEventManager() event_id = calendar.add_event(\\"2023-11-25\\", \\"Meeting\\", \\"Project status update meeting\\") result = calendar.remove_event(event_id) assert result == True def test_remove_event_fail(): calendar = CalendarEventManager() event_id = calendar.add_event(\\"2023-11-25\\", \\"Meeting\\", \\"Project status update meeting\\") result = calendar.remove_event(999) # Non-existing event ID assert result == False def test_get_events_after_removal(): calendar = CalendarEventManager() event_id1 = calendar.add_event(\\"2023-11-25\\", \\"Meeting\\", \\"Project status update meeting\\") event_id2 = calendar.add_event(\\"2023-11-25\\", \\"Workshop\\", \\"Python programming workshop\\") calendar.remove_event(event_id1) events = calendar.get_events(\\"2023-11-25\\") assert len(events) == 1 assert events[0]['id'] == event_id2 assert events[0]['name'] == \\"Workshop\\" assert events[0]['description'] == \\"Python programming workshop\\"","solution":"class CalendarEventManager: def __init__(self): self.events = {} self.next_id = 1 def add_event(self, event_date: str, event_name: str, event_description: str) -> int: event_id = self.next_id self.next_id += 1 if event_date not in self.events: self.events[event_date] = [] event = { 'id': event_id, 'name': event_name, 'description': event_description } self.events[event_date].append(event) return event_id def get_events(self, event_date: str) -> list: if event_date not in self.events: return [] return self.events[event_date] def remove_event(self, event_id: int) -> bool: for event_date, events in self.events.items(): for event in events: if event['id'] == event_id: events.remove(event) return True return False"},{"question":"from typing import Optional, List class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def inorder_traversal(root: Optional[TreeNode]) -> List[int]: Perform an inorder traversal of a binary tree and return the values in inorder. >>> root = TreeNode(1) ... root.right = TreeNode(2) ... root.right.left = TreeNode(3) ... inorder_traversal(root) [1, 3, 2] >>> inorder_traversal(None) [] >>> root = TreeNode(1) ... inorder_traversal(root) [1] >>> root = TreeNode(1) ... root.left = TreeNode(2) ... inorder_traversal(root) [2, 1] >>> root = TreeNode(1) ... root.right = TreeNode(2) ... inorder_traversal(root) [1, 2]","solution":"from typing import Optional, List class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def inorder_traversal(root: Optional[TreeNode]) -> List[int]: def inorder(node: Optional[TreeNode], result: List[int]): if not node: return inorder(node.left, result) result.append(node.val) inorder(node.right, result) result = [] inorder(root, result) return result"},{"question":"class SortedList: def __init__(self, elements): self.list = elements def binary_search(self, target: int) -> int: Searches for the target integer and returns its index, or -1 if not found. >>> sl = SortedList([1, 3, 5, 7, 9]) >>> sl.binary_search(5) 2 >>> sl.binary_search(4) -1 def insert(self, value: int) -> None: Inserts a new integer into the sorted list while maintaining order. >>> sl = SortedList([1, 3, 5, 7, 9]) >>> sl.insert(6) >>> sl.list [1, 3, 5, 6, 7, 9] >>> sl.insert(1) >>> sl.list [1, 1, 3, 5, 6, 7, 9] def remove(self, value: int) -> bool: Removes the first occurrence of the specified integer from the sorted list. >>> sl = SortedList([1, 3, 5, 7, 9]) >>> sl.remove(3) True >>> sl.list [1, 5, 7, 9] >>> sl.remove(4) False >>> sl.list [1, 5, 7, 9]","solution":"class SortedList: def __init__(self, elements): self.list = elements def binary_search(self, target: int) -> int: Searches for the target integer and returns its index, or -1 if not found. left, right = 0, len(self.list) - 1 while left <= right: mid = (left + right) // 2 if self.list[mid] == target: return mid elif self.list[mid] < target: left = mid + 1 else: right = mid - 1 return -1 def insert(self, value: int) -> None: Inserts a new integer into the sorted list while maintaining order. if not self.list: self.list.append(value) return for i in range(len(self.list)): if self.list[i] >= value: self.list.insert(i, value) return self.list.append(value) def remove(self, value: int) -> bool: Removes the first occurrence of the specified integer from the sorted list. index = self.binary_search(value) if index != -1: self.list.pop(index) return True return False"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def flatten_bst_to_linked_list(root: TreeNode) -> TreeNode: Flatten a binary search tree into a sorted linked list in-place. Given the root of a binary search tree, transform it such that the resulting linked list is in ascending order, where each node points to the next node (right child) and there are no left children. Parameters: root (TreeNode): The root of a Binary Search Tree (BST) Returns: TreeNode: The head node of the resulting linked list Examples: >>> # Create the binary search tree >>> root = TreeNode(5) >>> root.left = TreeNode(3) >>> root.left.left = TreeNode(2) >>> root.left.right = TreeNode(4) >>> root.right = TreeNode(7) >>> root.right.left = TreeNode(6) >>> root.right.right = TreeNode(8) >>> >>> # Convert BST to linked list >>> linked_list_head = flatten_bst_to_linked_list(root) >>> >>> # Traverse the resulting linked list and print the values >>> result = [] >>> current = linked_list_head >>> while current: >>> result.append(current.val) >>> current = current.right >>> result [2, 3, 4, 5, 6, 7, 8] >>> # Edge case: Single node >>> root = TreeNode(1) >>> linked_list_head = flatten_bst_to_linked_list(root) >>> result = [] >>> current = linked_list_head >>> while current: >>> result.append(current.val) >>> current = current.right >>> result [1] >>> # Edge case: Empty tree >>> root = None >>> linked_list_head = flatten_bst_to_linked_list(root) >>> result = [] >>> current = linked_list_head >>> while current: >>> result.append(current.val) >>> current = current.right >>> result []","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def flatten_bst_to_linked_list(root: TreeNode) -> TreeNode: Flatten a binary search tree into a sorted linked list in-place. if not root: return None # Create a dummy node to act as the previous node in the linked list dummy = TreeNode(-1) prev = dummy def inorder(node): nonlocal prev if not node: return inorder(node.left) # Current node processing prev.right = node node.left = None # Move prev to current node prev = node inorder(node.right) inorder(root) return dummy.right"},{"question":"from typing import List class TransactionData: A class to efficiently summarize and query large-scale financial transaction data. Attributes: ---------- transactions : List[int] A list of integers representing daily transaction amounts. Methods: ------- update(i: int, val: int) -> None: Updates the transaction amount at index i to val. sumRange(left: int, right: int) -> int: Returns the sum of transactions between the indices left and right inclusive. def __init__(self, transactions: List[int]): Initialize the data structure with the given transactions. pass def update(self, i: int, val: int) -> None: Update the transaction amount at index i to val. pass def sumRange(self, left: int, right: int) -> int: Return the sum of transactions between the indices left and right inclusive. pass # Example Usage: # transactions = [1, 3, 5] # trans_data = TransactionData(transactions) # print(trans_data.sumRange(0, 2)) # Output: 9 # trans_data.update(1, 2) # print(trans_data.sumRange(0, 2)) # Output: 8 def test_initial_sum_range(): trans_data = TransactionData([1, 3, 5]) assert trans_data.sumRange(0, 2) == 9 # 1 + 3 + 5 def test_update_and_sum_range(): trans_data = TransactionData([1, 3, 5]) trans_data.update(1, 2) # [1, 2, 5] assert trans_data.sumRange(0, 2) == 8 # 1 + 2 + 5 def test_single_update(): trans_data = TransactionData([1, 3, 5]) trans_data.update(0, 10) # [10, 3, 5] assert trans_data.sumRange(0, 0) == 10 # 10 assert trans_data.sumRange(0, 2) == 18 # 10 + 3 + 5 def test_multiple_updates(): trans_data = TransactionData([1, 3, 5]) trans_data.update(0, 10) # [10, 3, 5] trans_data.update(2, 6) # [10, 3, 6] assert trans_data.sumRange(1, 2) == 9 # 3 + 6 def test_edge_cases(): trans_data = TransactionData([0]) assert trans_data.sumRange(0, 0) == 0 trans_data.update(0, 1) assert trans_data.sumRange(0, 0) == 1","solution":"class TransactionData: def __init__(self, transactions): self.n = len(transactions) self.transactions = transactions self.tree = [0] * self.n + transactions # Binary Indexed Tree initialized for i in range(self.n - 1, 0, -1): self.tree[i] = self.tree[2 * i] + self.tree[2 * i + 1] def update(self, i, val): # Update the value in transactions and tree pos = i + self.n self.tree[pos] = val while pos > 1: pos //= 2 self.tree[pos] = self.tree[2 * pos] + self.tree[2 * pos + 1] def sumRange(self, left, right): # Calculate range sum from left to right left += self.n right += self.n sum = 0 while left <= right: if left % 2 == 1: sum += self.tree[left] left += 1 if right % 2 == 0: sum += self.tree[right] right -= 1 left //= 2 right //= 2 return sum"},{"question":"def evaluate_rpn(expression_list: list) -> int: Evaluate an expression in Reverse Polish Notation and return the result. Args: expression_list (list): A list of strings where each string is either an operand (digits, possibly negative) or an operator (\`+\`, \`-\`, \`*\`, \`/\`). Returns: int: The result of the postfix expression. Raises: ValueError: If an invalid element is found or the expression is invalid as postfix notation. Examples: >>> evaluate_rpn([\\"2\\", \\"1\\", \\"+\\", \\"3\\", \\"*\\"]) 9 >>> evaluate_rpn([\\"4\\", \\"13\\", \\"5\\", \\"/\\", \\"+\\"]) 6 >>> evaluate_rpn([\\"10\\", \\"6\\", \\"9\\", \\"3\\", \\"+\\", \\"-11\\", \\"*\\", \\"/\\", \\"*\\", \\"17\\", \\"+\\", \\"5\\", \\"+\\"]) 22 >>> evaluate_rpn([\\"3\\", \\"4\\", \\"+\\", \\"2\\", \\"*\\", \\"7\\", \\"/\\"]) 2 >>> evaluate_rpn([\\"5\\", \\"1\\", \\"2\\", \\"+\\", \\"4\\", \\"*\\", \\"+\\", \\"3\\", \\"-\\"]) 14 from solution import evaluate_rpn def test_case_1(): assert evaluate_rpn([\\"2\\", \\"1\\", \\"+\\", \\"3\\", \\"*\\"]) == 9 def test_case_2(): assert evaluate_rpn([\\"4\\", \\"13\\", \\"5\\", \\"/\\", \\"+\\"]) == 6 def test_case_3(): assert evaluate_rpn([\\"10\\", \\"6\\", \\"9\\", \\"3\\", \\"+\\", \\"-11\\", \\"*\\", \\"/\\", \\"*\\", \\"17\\", \\"+\\", \\"5\\", \\"+\\"]) == 22 def test_case_4(): assert evaluate_rpn([\\"3\\", \\"4\\", \\"+\\", \\"2\\", \\"*\\", \\"7\\", \\"/\\"]) == 2 def test_case_5(): assert evaluate_rpn([\\"5\\", \\"1\\", \\"2\\", \\"+\\", \\"4\\", \\"*\\", \\"+\\", \\"3\\", \\"-\\"]) == 14 def test_invalid_expression_element(): try: evaluate_rpn([\\"2\\", \\"1\\", \\"?\\", \\"3\\", \\"*\\"]) except ValueError as e: assert str(e) == \\"Invalid expression element\\" def test_invalid_postfix_expression_missing_operand(): try: evaluate_rpn([\\"2\\", \\"+\\"]) except ValueError as e: assert str(e) == \\"Invalid postfix expression\\" def test_invalid_postfix_expression_incomplete(): try: evaluate_rpn([\\"2\\", \\"1\\", \\"+\\", \\"+\\"]) except ValueError as e: assert str(e) == \\"Invalid postfix expression\\" def test_single_number(): assert evaluate_rpn([\\"42\\"]) == 42","solution":"def evaluate_rpn(expression_list: list) -> int: def is_operator(token): return token in {\\"+\\", \\"-\\", \\"*\\", \\"/\\"} stack = [] for token in expression_list: if token.lstrip('-').isdigit(): # Check if the token is a number (considering negative numbers too) stack.append(int(token)) elif is_operator(token): if len(stack) < 2: raise ValueError(\\"Invalid postfix expression\\") b = stack.pop() a = stack.pop() if token == '+': stack.append(a + b) elif token == '-': stack.append(a - b) elif token == '*': stack.append(a * b) elif token == '/': stack.append(int(a / b)) # Truncate towards zero else: raise ValueError(\\"Invalid expression element\\") if len(stack) != 1: raise ValueError(\\"Invalid postfix expression\\") return stack[0]"},{"question":"def nth_fibonacci(n: int) -> int: Returns the n-th Fibonacci number. >>> nth_fibonacci(0) 0 >>> nth_fibonacci(1) 1 >>> nth_fibonacci(10) 55 >>> nth_fibonacci(20) 6765","solution":"def nth_fibonacci(n: int) -> int: Returns the n-th Fibonacci number. if n == 0: return 0 elif n == 1: return 1 a, b = 0, 1 for _ in range(2, n + 1): a, b = b, a + b return b"},{"question":"def kmp_search(text: str, pattern: str) -> list[int]: Implement the Knuth-Morris-Pratt (KMP) Algorithm to search for occurrences of a pattern string within a text string. This function should return a list of starting indices where the pattern is found within the text. >>> kmp_search(\\"ababcabcabababd\\", \\"ababd\\") [10] >>> kmp_search(\\"AABAACAADAABAABA\\", \\"AABA\\") [0, 9, 12] >>> kmp_search(\\"hello\\", \\"world\\") [] >>> kmp_search(\\"\\", \\"pattern\\") [] >>> kmp_search(\\"pattern\\", \\"\\") []","solution":"def kmp_search(text: str, pattern: str) -> list[int]: if not text or not pattern: return [] def compute_lps(pattern): lps = [0] * len(pattern) j = 0 for i in range(1, len(pattern)): while (j > 0 and pattern[i] != pattern[j]): j = lps[j - 1] if pattern[i] == pattern[j]: j += 1 lps[i] = j else: lps[i] = 0 return lps lps = compute_lps(pattern) result = [] i = 0 j = 0 while i < len(text): if pattern[j] == text[i]: i += 1 j += 1 if j == len(pattern): result.append(i - j) j = lps[j - 1] elif i < len(text) and pattern[j] != text[i]: if j != 0: j = lps[j - 1] else: i += 1 return result"},{"question":"def sparse_matrix_addition( mat1: dict[tuple[int, int], int], mat2: dict[tuple[int, int], int] ) -> dict[tuple[int, int], int]: Write a function that takes two sparse matrices represented as dictionaries and returns their sum, also represented as a dictionary. >>> sparse_matrix_addition({(0, 1): 3, (1, 0): 2}, {(0, 1): 4, (1, 0): 3, (1, 1): 5}) {(0, 1): 7, (1, 0): 5, (1, 1): 5} >>> sparse_matrix_addition({}, {}) {}","solution":"def sparse_matrix_addition( mat1: dict[tuple[int, int], int], mat2: dict[tuple[int, int], int] ) -> dict[tuple[int, int], int]: result = {} for key in set(mat1.keys()).union(set(mat2.keys())): value = mat1.get(key, 0) + mat2.get(key, 0) if value != 0: result[key] = value return result"},{"question":"def find_list_depth(lst) -> int: Determines the depth of nesting within the list. :param lst: Nested list of integers and other lists :return: Integer representing the maximum depth of the list >>> find_list_depth([1, 2, [3, 4], 5]) 2 >>> find_list_depth([1, [2, [3, [4, 5]]]]) 4 >>> find_list_depth([1, 2, 3]) 1 >>> find_list_depth([[[[]]]]) 4","solution":"def find_list_depth(lst): Determines the depth of nesting within the list. :param lst: Nested list of integers and other lists :return: Integer representing the maximum depth of the list if not isinstance(lst, list): return 0 if not lst: return 1 else: return 1 + max(find_list_depth(x) for x in lst)"},{"question":"from typing import List def min_coins(coins: List[int], amount: int) -> int: Finds the minimum number of coins needed to make the specified amount. Args: coins (List[int]): List of coin denominations. amount (int): The target amount of money. Returns: int: The minimum number of coins needed to make the amount, or -1 if impossible. Examples: >>> min_coins([1, 2, 5], 11) 3 >>> min_coins([2], 3) -1 >>> min_coins([1], 0) 0 pass # Your implementation here # Unit tests def test_min_coins_example_1(): assert min_coins([1, 2, 5], 11) == 3 # 11 = 5 + 5 + 1 def test_min_coins_example_2(): assert min_coins([2], 3) == -1 # Not possible to make 3 with denomination 2 def test_min_coins_example_3(): assert min_coins([1], 0) == 0 # No coins needed to make 0 amount def test_min_coins_single_coin_exact_match(): assert min_coins([3], 9) == 3 # 9 = 3 + 3 + 3 def test_min_coins_multiple_coins(): assert min_coins([1, 3, 4], 6) == 2 # 6 = 3 + 3 or 6 = 4 + 1 + 1 def test_min_coins_no_combination_possible(): assert min_coins([5, 7], 1) == -1 # Not possible to make 1 with denominations 5 and 7","solution":"from typing import List def min_coins(coins: List[int], amount: int) -> int: Finds the minimum number of coins needed to make the specified amount. # Initialize the dp array with a value greater than possible maximum coins required dp = [float('inf')] * (amount + 1) dp[0] = 0 for coin in coins: for x in range(coin, amount + 1): if dp[x - coin] != float('inf'): dp[x] = min(dp[x], dp[x - coin] + 1) return dp[amount] if dp[amount] != float('inf') else -1"},{"question":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right class BST: def __init__(self): self.root = None def insert(self, value): Insert a value into the BST. pass def find_kth_largest(self, k): Find the kth largest element in the BST. Args: k: an integer representing the position (1-based) of the largest element to find. Returns: The value of the kth largest element in the BST. pass # Unit Test def test_empty_tree(): bst = BST() assert bst.find_kth_largest(1) is None def test_one_node_tree(): bst = BST() bst.insert(10) assert bst.find_kth_largest(1) == 10 def test_multiple_nodes(): bst = BST() values = [5, 3, 8, 2, 4, 10, 12] for value in values: bst.insert(value) assert bst.find_kth_largest(1) == 12 assert bst.find_kth_largest(2) == 10 assert bst.find_kth_largest(3) == 8 assert bst.find_kth_largest(4) == 5 assert bst.find_kth_largest(5) == 4 assert bst.find_kth_largest(6) == 3 assert bst.find_kth_largest(7) == 2 def test_edge_cases(): bst = BST() bst.insert(5) bst.insert(3) bst.insert(8) bst.insert(7) bst.insert(9) assert bst.find_kth_largest(1) == 9 assert bst.find_kth_largest(2) == 8 assert bst.find_kth_largest(3) == 7 assert bst.find_kth_largest(4) == 5 assert bst.find_kth_largest(5) == 3","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right class BST: def __init__(self): self.root = None def insert(self, value): if self.root is None: self.root = TreeNode(value) else: self._insert(self.root, value) def _insert(self, node, value): if value < node.value: if node.left is None: node.left = TreeNode(value) else: self._insert(node.left, value) else: if node.right is None: node.right = TreeNode(value) else: self._insert(node.right, value) def find_kth_largest(self, k): self.current_k = 0 self.kth_value = None self._find_kth_largest(self.root, k) return self.kth_value def _find_kth_largest(self, node, k): if node is None or self.current_k >= k: return # Start by traversing the right subtree self._find_kth_largest(node.right, k) if self.current_k < k: self.current_k += 1 if self.current_k == k: self.kth_value = node.value return # Then traverse the left subtree self._find_kth_largest(node.left, k)"},{"question":"def compute_force(spring_constant: float, displacement: float) -> float: Calculate the force exerted by the spring given the spring constant and displacement. >>> compute_force(200, 0.5) -100.0 >>> compute_force(-200, -0.5) -100.0 >>> compute_force(100, 1.0) -100.0 >>> compute_force(0, 5) Traceback (most recent call last): ... ValueError: Invalid inputs. Spring constant and displacement must be non-zero. >>> compute_force(5, 0) Traceback (most recent call last): ... ValueError: Invalid inputs. Spring constant and displacement must be non-zero. # your code here def compute_spring_constant(force: float, displacement: float) -> float: Calculate the spring constant given the force exerted and the displacement. >>> compute_spring_constant(150, 0.75) -200.0 >>> compute_spring_constant(-150, -0.75) -200.0 >>> compute_spring_constant(100, 0.5) -200.0 >>> compute_spring_constant(150, 0) Traceback (most recent call last): ... ValueError: Invalid inputs. Spring constant and displacement must be non-zero. # your code here def compute_displacement(force: float, spring_constant: float) -> float: Calculate the displacement of the spring given the force exerted and the spring constant. >>> compute_displacement(-80, 40) 2.0 >>> compute_displacement(80, -40) 2.0 >>> compute_displacement(100, 50) -2.0 >>> compute_displacement(80, 0) Traceback (most recent call last): ... ValueError: Invalid inputs. Spring constant and displacement must be non-zero. # your code here","solution":"def compute_force(spring_constant: float, displacement: float) -> float: if spring_constant == 0 or displacement == 0: raise ValueError(\\"Invalid inputs. Spring constant and displacement must be non-zero.\\") return -spring_constant * displacement def compute_spring_constant(force: float, displacement: float) -> float: if displacement == 0: raise ValueError(\\"Invalid inputs. Spring constant and displacement must be non-zero.\\") return -force / displacement def compute_displacement(force: float, spring_constant: float) -> float: if spring_constant == 0: raise ValueError(\\"Invalid inputs. Spring constant and displacement must be non-zero.\\") return -force / spring_constant"},{"question":"class BookInventory: A class to manage an online book store inventory. Methods ------- add_book(book: dict) -> None: Adds a new book to the inventory. search_books(attribute: str, value: str) -> List[dict]: Searches for books based on a specific attribute and value. update_stock(isbn: str, new_stock: int) -> None: Updates the stock quantity of a book by its ISBN. Examples -------- >>> inventory = BookInventory() >>> inventory.add_book({\\"title\\": \\"The Great Gatsby\\", \\"author\\": \\"F. Scott Fitzgerald\\", \\"isbn\\": \\"9780743273565\\", \\"price\\": 10.99, \\"stock\\": 5}) >>> inventory.search_books(\\"author\\", \\"F. Scott Fitzgerald\\") [{'title': 'The Great Gatsby', 'author': 'F. Scott Fitzgerald', 'isbn': '9780743273565', 'price': 10.99, 'stock': 5}] >>> inventory.update_stock(\\"9780451524935\\", 10) >>> inventory.update_stock(\\"9780451524999\\", 5) # Raises ValueError: 'ISBN not found in inventory'","solution":"class BookInventory: def __init__(self): self.inventory = [] def add_book(self, book): required_keys = {'title', 'author', 'isbn', 'price', 'stock'} if not required_keys.issubset(book.keys()): raise ValueError(\\"Missing required book information\\") self.inventory.append(book) def search_books(self, attribute, value): return [book for book in self.inventory if book.get(attribute) == value] def update_stock(self, isbn, new_stock): for book in self.inventory: if book.get(\\"isbn\\") == isbn: book['stock'] = new_stock return raise ValueError(\\"ISBN not found in inventory\\")"},{"question":"def initialize_grid(rows: int, cols: int, obstacles: list[tuple[int, int]]) -> list[list[int]]: Initializes a grid with given dimensions and obstacles. >>> initialize_grid(3, 3, []) [[0, 0, 0], [0, 0, 0], [0, 0, 0]] >>> initialize_grid(3, 3, [(0, 1), (1, 1)]) [[0, 1, 0], [0, 1, 0], [0, 0, 0]] def bfs_pathfinding(grid: list[list[int]], start: tuple[int, int], target: tuple[int, int]) -> list[tuple[int, int]]: Finds the shortest path from start to target avoiding obstacles using BFS. >>> bfs_pathfinding([[0, 0, 0], [0, 0, 0], [0, 0, 0]], (0, 0), (2, 2)) [(0, 0), (0, 1), (0, 2), (1, 2), (2, 2)] >>> bfs_pathfinding([[0, 1, 0], [0, 1, 0], [0, 0, 0]], (0, 0), (2, 2)) [(0, 0), (1, 0), (2, 0), (2, 1), (2, 2)] >>> bfs_pathfinding([[0, 1, 0], [0, 1, 0], [0, 0, 0]], (0, 0), (2, 2)) [] >>> bfs_pathfinding([[0, 0, 0], [0, 0, 0], [0, 0, 0]], (0, 0), (0, 0)) [(0, 0)]","solution":"from collections import deque def initialize_grid(rows: int, cols: int, obstacles: list[tuple[int, int]]) -> list[list[int]]: Initializes a grid with given dimensions and obstacles. grid = [[0 for _ in range(cols)] for _ in range(rows)] for (r, c) in obstacles: grid[r][c] = 1 return grid def bfs_pathfinding(grid: list[list[int]], start: tuple[int, int], target: tuple[int, int]) -> list[tuple[int, int]]: Finds the shortest path from start to target avoiding obstacles using BFS. rows, cols = len(grid), len(grid[0]) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([(start, [start])]) visited = set() visited.add(start) while queue: (current, path) = queue.popleft() if current == target: return path for dr, dc in directions: nr, nc = current[0] + dr, current[1] + dc if 0 <= nr < rows and 0 <= nc < cols and grid[nr][nc] == 0 and (nr, nc) not in visited: queue.append(((nr, nc), path + [(nr, nc)])) visited.add((nr, nc)) return [] # No path found"},{"question":"from typing import List def reorder_playlist(songs: List[str], pinned_groups: List[List[int]]) -> List[str]: Reorders a playlist while maintaining the integrity of certain groups of songs. Each group specified in pinned_groups should appear in the same sequential order relative to each other in the output, but their internal order can be shuffled within each group. The order of songs not in any pinned_groups sublist can be rearranged randomly. If there are overlapping indices in pinned_groups, a ValueError should be raised. Args: - songs (List[str]): The list of song names. - pinned_groups (List[List[int]]): List of sublists where each sublist of indices indicates which songs must remain in sequence. Returns: - List[str]: A new list of songs with reordered playlist. Examples: >>> reorder_playlist([\\"song1\\", \\"song2\\", \\"song3\\", \\"song4\\", \\"song5\\"], [[0, 2], [3, 4]]) [\\"song1\\", \\"song3\\", \\"song2\\", \\"song4\\", \\"song5\\"] >>> reorder_playlist([\\"track1\\", \\"track2\\", \\"track3\\", \\"track4\\"], [[]]) [\\"track1\\", \\"track2\\", \\"track3\\", \\"track4\\"]","solution":"from typing import List def reorder_playlist(songs: List[str], pinned_groups: List[List[int]]) -> List[str]: # Ensure no overlapping indices in pinned_groups all_pinned_indices = set() for group in pinned_groups: for idx in group: if idx in all_pinned_indices: raise ValueError(\\"Overlapping indices in pinned groups\\") all_pinned_indices.add(idx) result = [] # Collect all pinned group songs in order for group in pinned_groups: group_songs = [songs[idx] for idx in group] result.extend(group_songs) # Collect all non-pinned songs non_pinned_songs = [songs[i] for i in range(len(songs)) if i not in all_pinned_indices] result.extend(non_pinned_songs) return result"},{"question":"def longest_unique_substring(s: str) -> str: Returns the longest substring without repeating characters. >>> longest_unique_substring(\\"abcabcbb\\") 'abc' >>> longest_unique_substring(\\"bbbbb\\") 'b' >>> longest_unique_substring(\\"pwwkew\\") 'wke'","solution":"def longest_unique_substring(s: str) -> str: Returns the longest substring without repeating characters. start = 0 max_length = 0 max_substring = \\"\\" char_index_map = {} for end in range(len(s)): if s[end] in char_index_map and char_index_map[s[end]] >= start: start = char_index_map[s[end]] + 1 char_index_map[s[end]] = end current_length = end - start + 1 if current_length > max_length: max_length = current_length max_substring = s[start:end + 1] return max_substring"},{"question":"def can_accommodate_bookings(bookings: list[tuple[int, int]], rooms: int) -> bool: Determines if all bookings can be accommodated without overlapping beyond the specified number of rooms. Each booking is represented as a tuple (start, end). The function returns True if the bookings can be accommodated, else False. >>> can_accommodate_bookings([(1, 4), (2, 5), (7, 9), (3, 6)], 2) False >>> can_accommodate_bookings([(1, 2), (3, 4), (5, 6), (7, 8)], 1) True","solution":"def can_accommodate_bookings(bookings, rooms): if not bookings: return True events = [] for start, end in bookings: events.append((start, 1)) # 1 indicates a booking starts events.append((end, -1)) # -1 indicates a booking ends events.sort() current_rooms = 0 for time, event in events: current_rooms += event if current_rooms > rooms: return False return True"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def invertTree(root: TreeNode) -> TreeNode: Invert a binary tree. :param root: TreeNode - The root of the binary tree. :return: TreeNode - The root of the inverted binary tree. pass # Example usage root = TreeNode(4) root.left = TreeNode(2, TreeNode(1), TreeNode(3)) root.right = TreeNode(7, TreeNode(6), TreeNode(9)) inverted_root = invertTree(root) print(inverted_root.val) # Output: 4 print(inverted_root.left.val) # Output: 7 print(inverted_root.right.val) # Output: 2 print(inverted_root.left.left.val) # Output: 9 print(inverted_root.left.right.val) # Output: 6 print(inverted_root.right.left.val) # Output: 3 print(inverted_root.right.right.val) # Output: 1 # Unit Testing def test_invertTree_empty(): assert invertTree(None) == None def test_invertTree_single_node(): root = TreeNode(1) inverted = invertTree(root) assert inverted.val == 1 assert inverted.left == None assert inverted.right == None def test_invertTree_two_levels(): root = TreeNode(1, TreeNode(2), TreeNode(3)) inverted = invertTree(root) assert inverted.val == 1 assert inverted.left.val == 3 assert inverted.right.val == 2 def test_invertTree_three_levels(): root = TreeNode(1) root.left = TreeNode(2, TreeNode(4), TreeNode(5)) root.right = TreeNode(3, TreeNode(6), TreeNode(7)) inverted = invertTree(root) assert inverted.val == 1 assert inverted.left.val == 3 assert inverted.right.val == 2 assert inverted.left.left.val == 7 assert inverted.left.right.val == 6 assert inverted.right.left.val == 5 assert inverted.right.right.val == 4 def test_invertTree_example(): root = TreeNode(4) root.left = TreeNode(2, TreeNode(1), TreeNode(3)) root.right = TreeNode(7, TreeNode(6), TreeNode(9)) inverted = invertTree(root) assert inverted.val == 4 assert inverted.left.val == 7 assert inverted.right.val == 2 assert inverted.left.left.val == 9 assert inverted.left.right.val == 6 assert inverted.right.left.val == 3 assert inverted.right.right.val == 1","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def invertTree(root: TreeNode) -> TreeNode: Invert a binary tree. :param root: TreeNode - The root of the binary tree. :return: TreeNode - The root of the inverted binary tree. if root is None: return None # Swap the left and right children root.left, root.right = root.right, root.left # Recursively invert the left and right subtrees invertTree(root.left) invertTree(root.right) return root"},{"question":"from typing import List def init_system() -> None: Initializes the file version management system. pass def add_version(content: str) -> int: Adds a new version of the file's content. Parameters: content (str): The content of the file to be added as a new version. Returns: int: The version number of the added content. pass def get_version(version_number: int) -> str: Retrieves the content of a specific version. Parameters: version_number (int): The version number to retrieve. Returns: str: The content of the specified version. pass def compare_versions(version1: int, version2: int) -> List[str]: Compares two versions and returns the differences. Parameters: version1 (int): The version number of the first version. version2 (int): The version number of the second version. Returns: List[str]: The differences between the two versions. pass Example Usage: if __name__ == \\"__main__\\": init_system() version1 = add_version(\\"This is the first version of the file.\\") version2 = add_version(\\"This is the second version of the file with more text.\\") content_v1 = get_version(version1) print(content_v1) content_v2 = get_version(version2) print(content_v2) differences = compare_versions(version1, version2) print(differences) Unit Tests: import pytest def test_init_system(): init_system() with pytest.raises(ValueError): get_version(0) def test_add_version(): init_system() version0 = add_version(\\"First version content.\\") assert version0 == 0 version1 = add_version(\\"Second version content.\\") assert version1 == 1 def test_get_version(): init_system() v0_content = \\"First version content.\\" add_version(v0_content) assert get_version(0) == v0_content v1_content = \\"Second version content.\\" add_version(v1_content) assert get_version(1) == v1_content with pytest.raises(ValueError): get_version(2) def test_compare_versions(): init_system() content1 = \\"This is the first version.nIt has two lines.\\" version1 = add_version(content1) content2 = \\"This is the first version.nIt has two lines, but changed.\\" version2 = add_version(content2) diff = compare_versions(version1, version2) expected_diff = [ '--- v0', '+++ v1', '@@ -1,2 +1,2 @@', ' This is the first version.', '-It has two lines.', '+It has two lines, but changed.' ] assert diff == expected_diff","solution":"from typing import List import difflib # Initialize a global variable to hold versions versions = [] def init_system() -> None: Initializes the file version management system. global versions versions = [] def add_version(content: str) -> int: Adds a new version of the file's content. Parameters: content (str): The content of the file to be added as a new version. Returns: int: The version number of the added content. global versions version_number = len(versions) versions.append(content) return version_number def get_version(version_number: int) -> str: Retrieves the content of a specific version. Parameters: version_number (int): The version number to retrieve. Returns: str: The content of the specified version. global versions if version_number < 0 or version_number >= len(versions): raise ValueError(\\"Invalid version number.\\") return versions[version_number] def compare_versions(version1: int, version2: int) -> List[str]: Compares two versions and returns the differences. Parameters: version1 (int): The version number of the first version. version2 (int): The version number of the second version. Returns: List[str]: The differences between the two versions. content1 = get_version(version1).splitlines() content2 = get_version(version2).splitlines() diff = difflib.unified_diff(content1, content2, lineterm='', fromfile=f'v{version1}', tofile=f'v{version2}') return list(diff)"},{"question":"import math def calculate_area(shape: str, **dimensions) -> float: Calculate the area of the given shape with provided dimensions. Args: - shape (str): The type of shape (\\"rectangle\\", \\"circle\\", \\"triangle\\"). - dimensions (dict): The dimensions for calculating the area: - Rectangle: width, height - Circle: radius - Triangle: base, height Returns: - float: The calculated area of the shape. Raises: - ValueError: If a required dimension is missing or if the shape is unsupported. Examples: >>> calculate_area(\\"rectangle\\", width=5, height=10) 50.0 >>> calculate_area(\\"circle\\", radius=3) 28.274333882308138 >>> calculate_area(\\"triangle\\", base=4, height=7) 14.0 import pytest from solution import calculate_area def test_calculate_area_rectangle(): assert calculate_area(\\"rectangle\\", width=5, height=10) == 50.0 assert calculate_area(\\"rectangle\\", width=3, height=3) == 9.0 def test_calculate_area_circle(): assert calculate_area(\\"circle\\", radius=3) == pytest.approx(28.274333882308138) def test_calculate_area_triangle(): assert calculate_area(\\"triangle\\", base=4, height=7) == 14.0 assert calculate_area(\\"triangle\\", base=10, height=10) == 50.0 def test_missing_dimensions_rectangle(): with pytest.raises(ValueError, match=\\"Missing dimensions 'width' and/or 'height' for rectangle.\\"): calculate_area(\\"rectangle\\", width=5) def test_missing_dimensions_circle(): with pytest.raises(ValueError, match=\\"Missing dimension 'radius' for circle.\\"): calculate_area(\\"circle\\") def test_missing_dimensions_triangle(): with pytest.raises(ValueError, match=\\"Missing dimensions 'base' and/or 'height' for triangle.\\"): calculate_area(\\"triangle\\", base=5) def test_unsupported_shape(): with pytest.raises(ValueError, match=\\"Unsupported shape type. Supported shapes are 'rectangle', 'circle', and 'triangle'.\\"): calculate_area(\\"hexagon\\", side=6) def test_extra_dimensions(): # Edge case where extra dimensions are provided assert calculate_area(\\"rectangle\\", width=3, height=4, depth=2) == 12.0 assert calculate_area(\\"circle\\", radius=3, diameter=6) == pytest.approx(28.274333882308138) assert calculate_area(\\"triangle\\", base=5, height=2, hypotenuse=6) == 5.0","solution":"import math def calculate_area(shape: str, **dimensions) -> float: Calculate the area of the given shape with provided dimensions. Args: - shape (str): The type of shape (\\"rectangle\\", \\"circle\\", \\"triangle\\"). - dimensions (dict): The dimensions for calculating the area: - Rectangle: width, height - Circle: radius - Triangle: base, height Returns: - float: The calculated area of the shape. Raises: - ValueError: If a required dimension is missing or if the shape is unsupported. if shape == \\"rectangle\\": try: width = dimensions[\\"width\\"] height = dimensions[\\"height\\"] return width * height except KeyError: raise ValueError(\\"Missing dimensions 'width' and/or 'height' for rectangle.\\") elif shape == \\"circle\\": try: radius = dimensions[\\"radius\\"] return math.pi * (radius ** 2) except KeyError: raise ValueError(\\"Missing dimension 'radius' for circle.\\") elif shape == \\"triangle\\": try: base = dimensions[\\"base\\"] height = dimensions[\\"height\\"] return 0.5 * base * height except KeyError: raise ValueError(\\"Missing dimensions 'base' and/or 'height' for triangle.\\") else: raise ValueError(\\"Unsupported shape type. Supported shapes are 'rectangle', 'circle', and 'triangle'.\\")"},{"question":"class CharacterMovement: def __init__(self): Initializes the character's position at the origin (0, 0). def move(self, direction: str) -> None: Records a move in the specified direction. >>> character.move('up') >>> character.get_position() == (0, 1) def undo(self) -> None: Undoes the last recorded movement. If there are no movements to undo, it does nothing. >>> character.undo() >>> character.get_position() == (0, 0) def get_position(self) -> tuple[int, int]: Returns the current position of the character as a tuple (x, y). >>> character.get_position() == (0, 0) # Example Usage and Test Cases def test_initial_position(): character = CharacterMovement() assert character.get_position() == (0, 0) def test_move_up(): character = CharacterMovement() character.move('up') assert character.get_position() == (0, 1) def test_move_down(): character = CharacterMovement() character.move('down') assert character.get_position() == (0, -1) def test_move_left(): character = CharacterMovement() character.move('left') assert character.get_position() == (-1, 0) def test_move_right(): character = CharacterMovement() character.move('right') assert character.get_position() == (1, 0) def test_undo_move(): character = CharacterMovement() character.move('up') character.undo() assert character.get_position() == (0, 0) def test_undo_without_moves(): character = CharacterMovement() character.undo() assert character.get_position() == (0, 0) def test_multiple_moves_and_undos(): character = CharacterMovement() character.move('up') character.move('up') character.move('left') assert character.get_position() == (-1, 2) character.undo() assert character.get_position() == (0, 2) character.undo() character.undo() assert character.get_position() == (0, 0) def test_consecutive_undo(): character = CharacterMovement() character.move('up') character.move('left') character.undo() character.undo() character.undo() assert character.get_position() == (0, 0)","solution":"class CharacterMovement: def __init__(self): self.position = [0, 0] # Starting at origin (0,0) self.history = [] # List to track movements def move(self, direction: str) -> None: if direction == 'up': self.position[1] += 1 self.history.append(('up', -1)) elif direction == 'down': self.position[1] -= 1 self.history.append(('down', 1)) elif direction == 'left': self.position[0] -= 1 self.history.append(('left', 1)) elif direction == 'right': self.position[0] += 1 self.history.append(('right', -1)) def undo(self) -> None: if self.history: last_move, undo_amount = self.history.pop() if last_move == 'up' or last_move == 'down': self.position[1] += undo_amount else: self.position[0] += undo_amount def get_position(self) -> tuple[int, int]: return tuple(self.position)"},{"question":"def find_smallest_factorial_sum() -> int: Finds the smallest positive integer 'n' such that the sum of the factorial of its digits equals 'n'. Returns: - int: The smallest positive integer 'n' satisfying the condition. Example: >>> find_smallest_factorial_sum() 145","solution":"import math def find_smallest_factorial_sum() -> int: Finds the smallest positive integer 'n' such that the sum of the factorial of its digits equals 'n'. Returns: - int: The smallest positive integer 'n' satisfying the condition. def digit_factorial_sum(n): return sum(math.factorial(int(d)) for d in str(n)) num = 10 while True: if digit_factorial_sum(num) == num: return num num += 1"},{"question":"def rotate_matrix(matrix: list[list[int]]) -> None: Rotates an n x n matrix 90 degrees clockwise in place. >>> matrix1 = [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9], ... ] >>> rotate_matrix(matrix1) >>> matrix1 [ [7, 4, 1], [8, 5, 2], [9, 6, 3], ] >>> matrix2 = [ ... [5, 1, 9, 11], ... [2, 4, 8, 10], ... [13, 3, 6, 7], ... [15, 14, 12, 16], ... ] >>> rotate_matrix(matrix2) >>> matrix2 [ [15, 13, 2, 5], [14, 3, 4, 1], [12, 6, 8, 9], [16, 7, 10, 11], ] pass","solution":"def rotate_matrix(matrix: list[list[int]]) -> None: Rotates an n x n matrix 90 degrees clockwise in place. n = len(matrix) # Transpose the matrix (rows become columns) for i in range(n): for j in range(i, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Reverse each row to get the final rotated matrix for i in range(n): matrix[i].reverse()"},{"question":"from typing import List def find_local_peaks(rainfall_data: List[int]) -> List[int]: This function returns a list of indices where the rainfall amount represents a local peak. A local peak is defined as an element that is strictly greater than its neighbors, not considering the first and last elements. Examples: >>> find_local_peaks([10, 12, 5, 6, 8, 7, 5, 3, 11, 8]) [1, 4, 8] >>> find_local_peaks([5, 5, 5, 5, 5]) [] pass # Write your code here def test_find_local_peaks_all_equal(): assert find_local_peaks([5, 5, 5, 5, 5]) == [] def test_find_local_peaks_single_peak_middle(): assert find_local_peaks([10, 12, 10]) == [1] def test_find_local_peaks_no_peaks(): assert find_local_peaks([10, 9, 8, 7, 6]) == [] def test_find_local_peaks_multiple_peaks(): assert find_local_peaks([10, 12, 5, 6, 8, 7, 5, 3, 11, 8]) == [1, 4, 8] def test_find_local_peaks_edges_not_considered(): assert find_local_peaks([6, 10, 8]) == [1] def test_find_local_peaks_longer_sequence(): assert find_local_peaks([1, 3, 7, 1, 2, 6, 3, 8, 4, 10, 2]) == [2, 5, 7, 9]","solution":"from typing import List def find_local_peaks(rainfall_data: List[int]) -> List[int]: This function returns a list of indices where the rainfall amount represents a local peak. A local peak is defined as an element that is strictly greater than its neighbors, not considering the first and last elements. peaks = [] for i in range(1, len(rainfall_data) - 1): if rainfall_data[i] > rainfall_data[i - 1] and rainfall_data[i] > rainfall_data[i + 1]: peaks.append(i) return peaks"},{"question":"def event_monitor(events: list[tuple[int, int]], queries: list[int]) -> list[int]: Returns the number of active events at each query time point. Parameters: events (list of tuples): List of (start_time, end_time) tuples indicating event duration. queries (list of int): List of query time points. Returns: list of int: List of counts of active events at each query time point. Example: >>> events = [(1, 5), (3, 7), (6, 8)] >>> queries = [2, 4, 6, 8] >>> event_monitor(events, queries) [1, 2, 2, 1] pass # Unit Tests def test_event_monitor_example_case(): events = [(1, 5), (3, 7), (6, 8)] queries = [2, 4, 6, 8] assert event_monitor(events, queries) == [1, 2, 2, 1] def test_event_monitor_single_event(): events = [(2, 5)] queries = [1, 2, 3, 5, 6] assert event_monitor(events, queries) == [0, 1, 1, 1, 0] def test_event_monitor_multiple_events_same_time(): events = [(1, 3), (1, 3), (1, 3)] queries = [0, 1, 2, 3, 4] assert event_monitor(events, queries) == [0, 3, 3, 3, 0] def test_event_monitor_no_overlap(): events = [(1, 2), (3, 4), (5, 6)] queries = [0, 1, 2, 3, 4, 5, 6, 7] assert event_monitor(events, queries) == [0, 1, 1, 1, 1, 1, 1, 0] def test_event_monitor_all_times_covered(): events = [(0, 10), (5, 15), (10, 20)] queries = [5, 10, 15] assert event_monitor(events, queries) == [2, 3, 2] def test_event_monitor_no_events(): events = [] queries = [1, 2, 3, 4, 5] assert event_monitor(events, queries) == [0, 0, 0, 0, 0] def test_event_monitor_no_queries(): events = [(1, 5), (3, 7), (6, 8)] queries = [] assert event_monitor(events, queries) == []","solution":"def event_monitor(events: list[tuple[int, int]], queries: list[int]) -> list[int]: Returns the number of active events at each query time point. Parameters: events (list of tuples): List of (start_time, end_time) tuples indicating event duration. queries (list of int): List of query time points. Returns: list of int: List of counts of active events at each query time point. result = [] for query in queries: count = sum(start <= query <= end for start, end in events) result.append(count) return result"},{"question":"def rotate_matrix(matrix: list[list[int]]) -> None: Rotates the given n x n matrix by 90 degrees clockwise in place. >>> matrix = [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ] >>> rotate_matrix(matrix) >>> matrix [[7, 4, 1], [8, 5, 2], [9, 6, 3]] >>> matrix = [ ... [1, 2, 3, 4], ... [5, 6, 7, 8], ... [9, 10, 11, 12], ... [13, 14, 15, 16] ... ] >>> rotate_matrix(matrix) >>> matrix [[13, 9, 5, 1], [14, 10, 6, 2], [15, 11, 7, 3], [16, 12, 8, 4]] pass def test_rotate_3x3_matrix(): matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] rotate_matrix(matrix) assert matrix == [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] def test_rotate_4x4_matrix(): matrix = [ [1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16] ] rotate_matrix(matrix) assert matrix == [ [13, 9, 5, 1], [14, 10, 6, 2], [15, 11, 7, 3], [16, 12, 8, 4] ] def test_rotate_2x2_matrix(): matrix = [ [1, 2], [3, 4] ] rotate_matrix(matrix) assert matrix == [ [3, 1], [4, 2] ] def test_rotate_1x1_matrix(): matrix = [ [1] ] rotate_matrix(matrix) assert matrix == [ [1] ] def test_rotate_empty_matrix(): matrix = [] rotate_matrix(matrix) assert matrix == [] def test_rotate_5x5_matrix(): matrix = [ [1, 2, 3, 4, 5], [6, 7, 8, 9, 10], [11, 12, 13, 14, 15], [16, 17, 18, 19, 20], [21, 22, 23, 24, 25] ] rotate_matrix(matrix) assert matrix == [ [21, 16, 11, 6, 1], [22, 17, 12, 7, 2], [23, 18, 13, 8, 3], [24, 19, 14, 9, 4], [25, 20, 15, 10, 5] ]","solution":"def rotate_matrix(matrix: list[list[int]]) -> None: Rotates the given n x n matrix by 90 degrees clockwise in place. n = len(matrix) # Step 1: Transpose the matrix for i in range(n): for j in range(i, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Step 2: Reverse each row for i in range(n): matrix[i].reverse()"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_bst_symmetric(root: TreeNode) -> bool: Determines if a given Binary Search Tree (BST) is symmetric. >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(2) >>> root.left.left = TreeNode(3) >>> root.left.right = TreeNode(4) >>> root.right.left = TreeNode(4) >>> root.right.right = TreeNode(3) >>> is_bst_symmetric(root) True >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(2) >>> root.left.right = TreeNode(3) >>> root.right.right = TreeNode(3) >>> is_bst_symmetric(root) False","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_symmetric(left: TreeNode, right: TreeNode) -> bool: if not left and not right: return True if not left or not right: return False return (left.val == right.val and is_symmetric(left.left, right.right) and is_symmetric(left.right, right.left)) def is_bst_symmetric(root: TreeNode) -> bool: if not root: return True return is_symmetric(root.left, root.right)"},{"question":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def calculate_tree_depth(root): Calculate the depth of a binary tree. :param root: TreeNode or None :return: int >>> calculate_tree_depth(None) 0 >>> root = TreeNode(1) >>> calculate_tree_depth(root) 1 >>> root = TreeNode(3) >>> root.left = TreeNode(9) >>> root.right = TreeNode(20, TreeNode(15), TreeNode(7)) >>> calculate_tree_depth(root) 3","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def calculate_tree_depth(root): Calculate the depth of a binary tree. :param root: TreeNode or None :return: int if root is None: return 0 else: left_depth = calculate_tree_depth(root.left) right_depth = calculate_tree_depth(root.right) return max(left_depth, right_depth) + 1"},{"question":"def reverse_string_in_place(s: list) -> None: Reverses the list of characters in place. >>> input_list = ['h', 'e', 'l', 'l', 'o'] >>> reverse_string_in_place(input_list) >>> input_list ['o', 'l', 'l', 'e', 'h'] >>> input_list = ['a', 'b', 'c', 'd'] >>> reverse_string_in_place(input_list) >>> input_list ['d', 'c', 'b', 'a'] >>> input_list = ['z'] >>> reverse_string_in_place(input_list) >>> input_list ['z'] >>> input_list = [] >>> reverse_string_in_place(input_list) >>> input_list [] >>> input_list = ['a', ' ', 'b', ' ', 'c'] >>> reverse_string_in_place(input_list) >>> input_list ['c', ' ', 'b', ' ', 'a'] pass","solution":"def reverse_string_in_place(s: list) -> None: Reverses the list of characters in place. Parameters: s (list): A list of characters to be reversed in place. Returns: None: The input list \`s\` is modified in place. left, right = 0, len(s) - 1 while left < right: # Swap the characters at positions left and right s[left], s[right] = s[right], s[left] # Move the pointers towards the center left += 1 right -= 1"},{"question":"def is_secure_password(password: str) -> bool: Evaluate whether a given password is secure and valid based on the following criteria: - At least 8 characters long. - Contains at least one uppercase letter ('A'-'Z'). - Contains at least one lowercase letter ('a'-'z'). - Contains at least one digit ('0'-'9'). - Contains at least one special character from the set !@#%^&*()-_+=<>? >>> is_secure_password(\\"Password123!\\") == True >>> is_secure_password(\\"Password\\") == False >>> is_secure_password(\\"12345678\\") == False >>> is_secure_password(\\"P@ssw0rd\\") == True >>> is_secure_password(\\"short!\\") == False","solution":"import re def is_secure_password(password: str) -> bool: Checks if the given password is secure based on the following criteria: - At least 8 characters long. - Contains at least one uppercase letter. - Contains at least one lowercase letter. - Contains at least one digit. - Contains at least one special character from the set !@#%^&*()-_+=<>? Args: password (str): The password to be checked. Returns: bool: True if the password meets all criteria, False otherwise. if len(password) < 8: return False has_upper = re.search(r'[A-Z]', password) has_lower = re.search(r'[a-z]', password) has_digit = re.search(r'[0-9]', password) has_special = re.search(r'[!@#%^&*()-_=+<>?]', password) return bool(has_upper and has_lower and has_digit and has_special)"},{"question":"class Cache: A simple Cache class that simulates a key-value store with a fixed maximum size. It evicts the least recently used (LRU) item when the maximum size is exceeded. Tracks cache hits and misses. >>> cache = Cache(maxsize=2) >>> cache.set('a', 1) >>> cache.set('b', 2) >>> cache.get('a') # Accessing 'a' 1 >>> cache.get('c') # Attempting to access non-existent key 'c' None >>> cache.set('c', 3) # This should evict 'b' >>> cache.get('b') # Accessing 'b' which should be evicted None >>> cache.get('c') # Accessing 'c' 3 >>> cache.get_hits() # Number of cache hits 2 >>> cache.get_misses() # Number of cache misses 2 def __init__(self, maxsize): self.maxsize = maxsize self.cache = {} self.order = [] self.hits = 0 self.misses = 0 def set(self, key, value): pass def get(self, key): pass def get_hits(self): pass def get_misses(self): pass","solution":"class Cache: def __init__(self, maxsize): self.maxsize = maxsize self.cache = {} self.order = [] self.hits = 0 self.misses = 0 def set(self, key, value): if key in self.cache: self.order.remove(key) elif len(self.cache) >= self.maxsize: lru_key = self.order.pop(0) del self.cache[lru_key] self.cache[key] = value self.order.append(key) def get(self, key): if key in self.cache: self.order.remove(key) self.order.append(key) self.hits += 1 return self.cache[key] else: self.misses += 1 return None def get_hits(self): return self.hits def get_misses(self): return self.misses"},{"question":"from typing import List, Tuple def manage_warehouse(commands: List[str]) -> List[Tuple[str, int]]: Simulates the logistics of a small warehouse. Takes a list of string commands where each command represents an operation on the warehouse inventory. >>> manage_warehouse([ \\"ADD apple 10\\", \\"ADD banana 5\\", \\"UPDATE apple 20\\", \\"REMOVE banana\\", \\"ADD orange 15\\" ]) [('apple', 20), ('orange', 15)] >>> manage_warehouse([ \\"ADD grapes 30\\", \\"ADD apple 10\\", \\"REMOVE grapes\\", \\"ADD banana 5\\", \\"ADD apple 20\\" ]) [('apple', 30), ('banana', 5)] >>> manage_warehouse([ \\"ADD apple 10\\", \\"UPDATE apple 25\\" ]) [('apple', 25)] >>> manage_warehouse([ \\"REMOVE apple\\", \\"ADD banana 40\\" ]) [('banana', 40)] >>> manage_warehouse([ \\"ADD apple 10\\", \\"ADD banana 5\\", \\"ADD pear 15\\", \\"ADD grape 20\\" ]) [('apple', 10), ('banana', 5), ('grape', 20), ('pear', 15)] >>> manage_warehouse([ \\"ADD apple 10\\", \\"UPDATE apple 20\\", \\"REMOVE apple\\", \\"ADD banana 5\\", \\"UPDATE banana 10\\" ]) [('banana', 10)]","solution":"from typing import List, Tuple def manage_warehouse(commands: List[str]) -> List[Tuple[str, int]]: # Initialize an empty dictionary to store the product inventory inventory = {} # Process each command in order for command in commands: parts = command.split() action = parts[0] product_name = parts[1] if action == \\"ADD\\": quantity = int(parts[2]) if product_name in inventory: inventory[product_name] += quantity else: inventory[product_name] = quantity elif action == \\"REMOVE\\": if product_name in inventory: del inventory[product_name] elif action == \\"UPDATE\\": quantity = int(parts[2]) if product_name in inventory: inventory[product_name] = quantity # Convert the inventory dictionary to a sorted list of tuples sorted_inventory = sorted(inventory.items()) return sorted_inventory"},{"question":"class LibraryManagement: def __init__(self): Initialize the storage for branches and books. def add_book(self, branch: str, book_title: str, count: int) -> None: Add a given number of copies of a book to a specific branch. >>> lm = LibraryManagement() >>> lm.add_book('branch_1', 'book_1', 5) >>> lm.availability('branch_1', 'book_1') 5 def borrow_book(self, branch: str, book_title: str) -> bool: Borrow a book from a specific branch. Return True if the book is successfully borrowed, False otherwise. >>> lm = LibraryManagement() >>> lm.add_book('branch_1', 'book_1', 5) >>> lm.borrow_book('branch_1', 'book_1') True >>> lm.availability('branch_1', 'book_1') 4 def return_book(self, branch: str, book_title: str) -> None: Return a borrowed book to a specific branch. >>> lm = LibraryManagement() >>> lm.add_book('branch_1', 'book_1', 5) >>> lm.borrow_book('branch_1', 'book_1') >>> lm.return_book('branch_1', 'book_1') >>> lm.availability('branch_1', 'book_1') 5 def availability(self, branch: str, book_title: str) -> int: Check how many copies of a book are available at a specific branch. >>> lm = LibraryManagement() >>> lm.add_book('branch_1', 'book_1', 5) >>> lm.availability('branch_1', 'book_1') 5 >>> lm.availability('branch_1', 'non_existing_book') 0","solution":"class LibraryManagement: def __init__(self): self.library = {} def add_book(self, branch: str, book_title: str, count: int) -> None: if branch not in self.library: self.library[branch] = {} if book_title not in self.library[branch]: self.library[branch][book_title] = 0 self.library[branch][book_title] += count def borrow_book(self, branch: str, book_title: str) -> bool: if branch in self.library and book_title in self.library[branch] and self.library[branch][book_title] > 0: self.library[branch][book_title] -= 1 return True return False def return_book(self, branch: str, book_title: str) -> None: if branch in self.library and book_title in self.library[branch]: self.library[branch][book_title] += 1 else: self.add_book(branch, book_title, 1) def availability(self, branch: str, book_title: str) -> int: if branch in self.library and book_title in self.library[branch]: return self.library[branch][book_title] return 0"},{"question":"def validSegmentSums(nums: List[int], k: int) -> bool: Check if every contiguous subarray of length k has a positive sum. Arguments: nums: List[int] - A list of integers. k: int - Length of the contiguous subarrays to check. Returns: bool - True if all contiguous subarrays of length k have a positive sum, otherwise False. >>> validSegmentSums([3, -1, 2, 1, 4], 2) True >>> validSegmentSums([3, -1, -2, 1, 4], 2) False >>> validSegmentSums([1, 2, 3, -2, 5], 3) True","solution":"def validSegmentSums(nums, k): Check if every contiguous subarray of length k has a positive sum. Args: nums: List[int] - A list of integers. k: int - Length of the contiguous subarrays to check. Returns: bool - True if all contiguous subarrays of length k have a positive sum, otherwise False. # Calculate the sum of the first window of size k window_sum = sum(nums[:k]) # If the sum of the first window is not positive, we can return False immediately if window_sum <= 0: return False # Slide the window from left to right across the array for i in range(k, len(nums)): # Slide the window to the right by subtracting the element that is leaving the window # and adding the element that is entering the window window_sum += nums[i] - nums[i - k] # If the sum of the current window is not positive, return False if window_sum <= 0: return False # If all windows have positive sums, return True return True"},{"question":"def detect_cycle(graph: dict) -> bool: Determine if there is a cycle in the given undirected graph. The graph is represented as an adjacency list. Parameters: graph (dict): A dictionary where keys are node identifiers and values are lists of adjacent nodes. Returns: bool: True if there is a cycle in the graph, False otherwise. >>> graph1 = { ... 1: [2, 3], ... 2: [1, 4], ... 3: [1, 4], ... 4: [2, 3] ... } >>> detect_cycle(graph1) True >>> graph2 = { ... 1: [2], ... 2: [1, 3], ... 3: [2, 4], ... 4: [3] ... } >>> detect_cycle(graph2) False >>> graph3 = { ... 1: [2], ... 2: [1, 3], ... 3: [2] ... } >>> detect_cycle(graph3) False >>> graph4 = { ... 1: [2, 4], ... 2: [1, 3], ... 3: [2, 4], ... 4: [1, 3] ... } >>> detect_cycle(graph4) True # Your implementation here # Example test cases if __name__ == \\"__main__\\": graph1 = { 1: [2, 3], 2: [1, 4], 3: [1, 4], 4: [2, 3] } print(detect_cycle(graph1)) # Output: True graph2 = { 1: [2], 2: [1, 3], 3: [2, 4], 4: [3] } print(detect_cycle(graph2)) # Output: False graph3 = { 1: [2], 2: [1, 3], 3: [2] } print(detect_cycle(graph3)) # Output: False graph4 = { 1: [2, 4], 2: [1, 3], 3: [2, 4], 4: [1, 3] } print(detect_cycle(graph4)) # Output: True","solution":"def detect_cycle(graph): def dfs(v, parent): visited.add(v) for neighbor in graph.get(v, []): if neighbor not in visited: if dfs(neighbor, v): return True elif neighbor != parent: return True return False visited = set() for node in graph: if node not in visited: if dfs(node, -1): return True return False"},{"question":"def rotate_list(nums: list[int], k: int) -> None: Rotates the given list \`nums\` to the right by \`k\` steps. Args: nums: List of integers to rotate. k: Number of steps to rotate the list. Returns: None. The function modifies the list in place. Example: >>> lst = [1, 2, 3, 4, 5] >>> rotate_list(lst, 2) >>> lst [4, 5, 1, 2, 3] >>> lst2 = [0, 1, 2] >>> rotate_list(lst2, 4) >>> lst2 [2, 0, 1] >>> lst3 = [1, 2, 3] >>> rotate_list(lst3, 0) >>> lst3 [1, 2, 3] >>> lst4 = [1, 2, 3, 4] >>> rotate_list(lst4, 4) >>> lst4 [1, 2, 3, 4] >>> lst5 = [1, 2, 3] >>> rotate_list(lst5, 5) >>> lst5 [2, 3, 1] >>> lst6 = [] >>> rotate_list(lst6, 3) >>> lst6 [] >>> lst7 = [1] >>> rotate_list(lst7, 10) >>> lst7 [1] # Your code goes here","solution":"def rotate_list(nums: list[int], k: int) -> None: Rotates the given list \`nums\` to the right by \`k\` steps. Args: nums: List of integers to rotate. k: Number of steps to rotate the list. Returns: None. The function modifies the list in place. if not nums or k <= 0: return n = len(nums) k = k % n # Handle cases where k is larger than the list length nums[:] = nums[-k:] + nums[:-k]"},{"question":"from typing import List def longest_increasing_subsequence(arr: List[int]) -> int: Implement a Dynamic Programming Algorithm to solve the Longest Increasing Subsequence (LIS) problem. >>> longest_increasing_subsequence([10, 9, 2, 5, 3, 7, 101, 18]) 4 >>> longest_increasing_subsequence([4, 10, 4, 3, 8, 9]) 3 >>> longest_increasing_subsequence([7, 7, 7, 7, 7]) 1 >>> longest_increasing_subsequence([]) 0 >>> longest_increasing_subsequence([1, 3, 6, 7, 9, 4, 10, 5, 6]) 6 >>> longest_increasing_subsequence([3, 10, 2, 1, 20]) 3","solution":"from typing import List def longest_increasing_subsequence(arr: List[int]) -> int: if not arr: return 0 n = len(arr) lis = [1] * n for i in range(1, n): for j in range(0, i): if arr[i] > arr[j] and lis[i] < lis[j] + 1: lis[i] = lis[j] + 1 return max(lis)"},{"question":"class CustomObject: def __init__(self, name: str, priority: int, timestamp: int): self.name = name self.priority = priority self.timestamp = timestamp def custom_sort(objects: List[CustomObject]) -> List[CustomObject]: Sort a list of CustomObject instances first by 'priority' and then by 'timestamp'. >>> custom_sort([CustomObject('obj1', 2, 3), CustomObject('obj2', 1, 2), CustomObject('obj3', 2, 1)]) [CustomObject('obj2', 1, 2), CustomObject('obj3', 2, 1), CustomObject('obj1', 2, 3)]","solution":"class CustomObject: def __init__(self, name, priority, timestamp): self.name = name self.priority = priority self.timestamp = timestamp def __repr__(self): return f\\"{self.name} (priority: {self.priority}, timestamp: {self.timestamp})\\" def custom_sort(objects): return sorted(objects, key=lambda obj: (obj.priority, obj.timestamp)) # Demonstrating the use of the custom_sort function objects = [ CustomObject('obj1', 2, 3), CustomObject('obj2', 1, 2), CustomObject('obj3', 2, 1), CustomObject('obj4', 1, 3), CustomObject('obj5', 3, 2) ] sorted_objects = custom_sort(objects) print(sorted_objects) # Output: # [obj2 (priority: 1, timestamp: 2), # obj4 (priority: 1, timestamp: 3), # obj3 (priority: 2, timestamp: 1), # obj1 (priority: 2, timestamp: 3), # obj5 (priority: 3, timestamp: 2)]"},{"question":"import random import time from typing import List, Dict, Tuple def generate_readings(num_readings: int, seed: int) -> List[Dict[str, float]]: Generate a list of sensor readings. Each reading consists of a dictionary with 'timestamp' and 'value'. Args: - num_readings (int): Number of readings to generate. - seed (int): Seed for random number generation. Returns: - List[Dict[str, float]]: A list of sensor readings. pass def filter_readings(readings: List[Dict[str, float]], value_range: Tuple[float, float], time_frame: Tuple[int, int]) -> List[Dict[str, float]]: Filter the list of sensor readings based on value range and timeframe. Args: - readings (List[Dict[str, float]]): List of sensor readings. - value_range (Tuple[float, float]): A tuple (min_value, max_value) representing the value range. - time_frame (Tuple[int, int]): A tuple (start_time, end_time) representing the timeframe. Returns: - List[Dict[str, float]]: Filtered list of sensor readings. Raises: - ValueError: If the input criteria are invalid or the reading list is empty. pass # Example Usage num_readings = 10 seed = 42 readings = generate_readings(num_readings, seed) filtered = filter_readings(readings, value_range=(20.0, 80.0), time_frame=(1625097600, 1625184000)) print(filtered) # Output: List of filtered readings Unit Test: from solution import generate_readings, filter_readings def test_generate_readings(): readings = generate_readings(5, 42) assert len(readings) == 5 for reading in readings: assert 'timestamp' in reading assert 'value' in reading assert isinstance(reading['timestamp'], int) assert isinstance(reading['value'], float) def test_filter_readings_valid(): readings = [ {'timestamp': 1625087600, 'value': 50.0}, {'timestamp': 1625097600, 'value': 75.0}, {'timestamp': 1625184000, 'value': 30.0}, {'timestamp': 1625194000, 'value': 85.0}, ] filtered = filter_readings(readings, value_range=(20.0, 80.0), time_frame=(1625097600, 1625184000)) assert len(filtered) == 2 assert filtered[0]['value'] == 75.0 assert filtered[1]['value'] == 30.0 def test_filter_readings_empty_list(): try: filter_readings([], (20.0, 80.0), (1625097600, 1625184000)) except ValueError as e: assert str(e) == \\"The list of readings is empty.\\" def test_filter_readings_invalid_value_range(): readings = [{'timestamp': 1625097600, 'value': 75.0}] try: filter_readings(readings, (80.0, 20.0), (1625097600, 1625184000)) except ValueError as e: assert str(e) == \\"Invalid value range. Min value should be less than max value.\\" def test_filter_readings_invalid_time_frame(): readings = [{'timestamp': 1625097600, 'value': 75.0}] try: filter_readings(readings, (20.0, 80.0), (1625184000, 1625097600)) except ValueError as e: assert str(e) == \\"Invalid time frame. Start time should be less than end time.\\" def test_filter_readings_no_matches(): readings = [ {'timestamp': 1625087600, 'value': 15.0}, {'timestamp': 1625097600, 'value': 95.0} ] filtered = filter_readings(readings, value_range=(20.0, 80.0), time_frame=(1625097600, 1625184000)) assert len(filtered) == 0","solution":"import random import time def generate_readings(num_readings, seed): Generate a list of sensor readings. Each reading consists of a dictionary with 'timestamp' and 'value'. Args: - num_readings (int): Number of readings to generate. - seed (int): Seed for random number generation. Returns: - List[Dict]: A list of sensor readings. random.seed(seed) readings = [] current_time = int(time.time()) for _ in range(num_readings): timestamp = current_time - random.randint(0, 86400) # Random timestamp within the last 24 hours value = random.uniform(10.0, 100.0) # Random value between 10.0 and 100.0 readings.append({'timestamp': timestamp, 'value': value}) return readings def filter_readings(readings, value_range, time_frame): Filter the list of sensor readings based on value range and timeframe. Args: - readings (List[Dict]): List of sensor readings. - value_range (Tuple[float, float]): A tuple (min_value, max_value) representing the value range. - time_frame (Tuple[int, int]): A tuple (start_time, end_time) representing the timeframe. Returns: - List[Dict]: Filtered list of sensor readings. Raises: - ValueError: If the input criteria are invalid or the reading list is empty. min_value, max_value = value_range start_time, end_time = time_frame if not readings: raise ValueError(\\"The list of readings is empty.\\") if min_value >= max_value: raise ValueError(\\"Invalid value range. Min value should be less than max value.\\") if start_time >= end_time: raise ValueError(\\"Invalid time frame. Start time should be less than end time.\\") filtered_readings = [ reading for reading in readings if min_value <= reading['value'] <= max_value and start_time <= reading['timestamp'] <= end_time ] return filtered_readings"},{"question":"from collections import deque, defaultdict from typing import List, Dict class Graph: def __init__(self, n: int): self.n = n self.adj_list = defaultdict(list) def add_edge(self, u: int, v: int): self.adj_list[u].append(v) self.adj_list[v].append(u) def bfs(self, start: int) -> List[int]: Performs Breadth-First Search (BFS) starting from the vertex \`start\` and returns a list of vertices in the order they are visited. >>> graph = Graph(5) >>> graph.add_edge(0, 1) >>> graph.add_edge(0, 2) >>> graph.bfs(0) [0, 1, 2] >>> graph.bfs(3) [3] >>> graph.bfs(5) [] def shortest_path(self, u: int, v: int) -> List[int]: Finds the shortest path between the vertices \`u\` and \`v\` using BFS and returns the list of vertices representing this path. If no path exists, return an empty list. >>> graph = Graph(5) >>> graph.add_edge(0, 1) >>> graph.add_edge(0, 2) >>> graph.add_edge(1, 2) >>> graph.add_edge(1, 3) >>> graph.add_edge(3, 4) >>> graph.shortest_path(0, 4) [0, 1, 3, 4] >>> graph.shortest_path(0, 2) [0, 2] >>> graph.shortest_path(0, 4) [] >>> graph.shortest_path(2, 2) [2] >>> graph.shortest_path(0, 5) [] >>> graph.shortest_path(0, 6) []","solution":"from collections import deque, defaultdict from typing import List, Dict class Graph: def __init__(self, n: int): self.n = n self.adj_list = defaultdict(list) def add_edge(self, u: int, v: int): self.adj_list[u].append(v) self.adj_list[v].append(u) def bfs(self, start: int) -> List[int]: if start < 0 or start >= self.n: return [] # If the start vertex doesn't exist visited = [False] * self.n queue = deque([start]) visited[start] = True order = [] while queue: vertex = queue.popleft() order.append(vertex) for neighbor in self.adj_list[vertex]: if not visited[neighbor]: queue.append(neighbor) visited[neighbor] = True return order def shortest_path(self, u: int, v: int) -> List[int]: if u < 0 or u >= self.n or v < 0 or v >= self.n: return [] # If either vertex doesn't exist if u == v: return [u] parent = {u: None} queue = deque([u]) while queue: vertex = queue.popleft() if vertex == v: break for neighbor in self.adj_list[vertex]: if neighbor not in parent: parent[neighbor] = vertex queue.append(neighbor) path = [] if v in parent: while v is not None: path.append(v) v = parent[v] path.reverse() return path"},{"question":"def rle_encode(text: str) -> str: Encodes the given string using Run-Length Encoding algorithm. If the encoded string is not shorter than the original, returns the original string. >>> rle_encode(\\"aaabbbbbcc\\") \\"3a5b2c\\" >>> rle_encode(\\"abcd\\") \\"abcd\\" >>> rle_encode(\\"wwwwaaadexxxxxx\\") \\"4w3a1d1e6x\\" >>> rle_encode(\\"aabcccdee\\") \\"aabcccdee\\"","solution":"def rle_encode(text: str) -> str: Encodes the given string using Run-Length Encoding algorithm. If the encoded string is not shorter than the original, returns the original string. n = len(text) if n == 0: return text encoded_string = [] i = 0 while i < n: count = 1 while i < n - 1 and text[i] == text[i + 1]: i += 1 count += 1 encoded_string.append(str(count) + text[i]) i += 1 encoded_string = ''.join(encoded_string) return encoded_string if len(encoded_string) < n else text"},{"question":"class EventBookingSystem: Online ticket booking system for a venue that hosts various events. Methods: add_event(event_name: str, event_date: str, capacity: int): Register a new event by storing its name, date, and seating capacity. book_tickets(event_name: str, number_of_tickets: int) -> str: Book a specified number of tickets for an event. Return a confirmation message upon successful booking or an error message if the booking cannot be completed. check_availability(event_name: str) -> int: Return the number of available tickets for a specified event. cancel_booking(event_name: str, number_of_tickets: int) -> str: Cancel a specified number of tickets for an event, increasing the number of available seats accordingly. Return a confirmation message upon successful cancellation or an error message if the cancellation cannot be completed. def __init__(self): # Initialization of the system with an empty list of events and their bookings pass def add_event(self, event_name: str, event_date: str, capacity: int): # Register new events with details pass def book_tickets(self, event_name: str, number_of_tickets: int) -> str: # Book a specified number of tickets for a particular event pass def check_availability(self, event_name: str) -> int: # Check the availability of tickets for a given event pass def cancel_booking(self, event_name: str, number_of_tickets: int) -> str: # Allow users to cancel their booking, freeing up the tickets pass # Example usage: if __name__ == \\"__main__\\": ebs = EventBookingSystem() # Add events to the system ebs.add_event(\\"Concert\\", \\"2023-12-25\\", 100) # Book tickets for the events print(ebs.book_tickets(\\"Concert\\", 10)) # Output: \\"Successfully booked 10 tickets for Concert.\\" # Check availability of tickets print(ebs.check_availability(\\"Concert\\")) # Output: 90 # Cancel bookings for the events print(ebs.cancel_booking(\\"Concert\\", 5)) # Output: \\"Successfully cancelled 5 tickets for Concert.\\"","solution":"class EventBookingSystem: def __init__(self): self.events = {} def add_event(self, event_name: str, event_date: str, capacity: int): if event_name not in self.events: self.events[event_name] = {'date': event_date, 'capacity': capacity, 'booked': 0} def book_tickets(self, event_name: str, number_of_tickets: int) -> str: if event_name in self.events: available_tickets = self.events[event_name]['capacity'] - self.events[event_name]['booked'] if number_of_tickets <= available_tickets: self.events[event_name]['booked'] += number_of_tickets return f\\"Successfully booked {number_of_tickets} tickets for {event_name}.\\" else: return f\\"Error: Not enough available seats for {event_name}.\\" else: return \\"Error: Event not found.\\" def check_availability(self, event_name: str) -> int: if event_name in self.events: return self.events[event_name]['capacity'] - self.events[event_name]['booked'] else: return -1 # Return -1 if event not found def cancel_booking(self, event_name: str, number_of_tickets: int) -> str: if event_name in self.events: if number_of_tickets <= self.events[event_name]['booked']: self.events[event_name]['booked'] -= number_of_tickets return f\\"Successfully cancelled {number_of_tickets} tickets for {event_name}.\\" else: return f\\"Error: Cannot cancel more tickets than booked for {event_name}.\\" else: return \\"Error: Event not found.\\""},{"question":"def factorial(n: int) -> (int, int): Calculates the factorial of a given integer n using both iterative and recursive approaches. Args: n (int): The integer for which to calculate the factorial. Should be in the range 0 <= n <= 20. Returns: (int, int): A tuple where the first element is the factorial calculated iteratively, and the second element is the factorial calculated recursively. Raises: ValueError: If n is not an integer or is not in the range 0 <= n <= 20. def test_factorial_base_cases(): assert factorial(0) == (1, 1) assert factorial(1) == (1, 1) def test_factorial_standard_cases(): assert factorial(2) == (2, 2) assert factorial(3) == (6, 6) assert factorial(4) == (24, 24) assert factorial(5) == (120, 120) assert factorial(10) == (3628800, 3628800) def test_factorial_upper_bound(): assert factorial(20) == (2432902008176640000, 2432902008176640000) def test_factorial_invalid_inputs(): try: factorial(-1) except ValueError as e: assert str(e) == \\"n must be an integer in the range 0 <= n <= 20\\" try: factorial(21) except ValueError as e: assert str(e) == \\"n must be an integer in the range 0 <= n <= 20\\" try: factorial(5.5) except ValueError as e: assert str(e) == \\"n must be an integer in the range 0 <= n <= 20\\"","solution":"def factorial(n: int) -> (int, int): Calculates the factorial of a given integer n using both iterative and recursive approaches. Args: n (int): The integer for which to calculate the factorial. Should be in the range 0 <= n <= 20. Returns: (int, int): A tuple where the first element is the factorial calculated iteratively, and the second element is the factorial calculated recursively. Raises: ValueError: If n is not an integer or is not in the range 0 <= n <= 20. if not isinstance(n, int) or n < 0 or n > 20: raise ValueError(\\"n must be an integer in the range 0 <= n <= 20\\") # Iterative approach def factorial_iterative(n): result = 1 for i in range(2, n + 1): result *= i return result # Recursive approach def factorial_recursive(n): if n == 0: return 1 else: return n * factorial_recursive(n - 1) return factorial_iterative(n), factorial_recursive(n)"},{"question":"def count_unique_palindromic_substrings(s: str) -> int: Given a string \`s\`, count the number of unique substrings that are palindromes. >>> count_unique_palindromic_substrings(\\"ababa\\") 5 >>> count_unique_palindromic_substrings(\\"abc\\") 3 >>> count_unique_palindromic_substrings(\\"aaa\\") 3 pass def test_count_unique_palindromic_substrings(): assert count_unique_palindromic_substrings(\\"ababa\\") == 5 assert count_unique_palindromic_substrings(\\"abc\\") == 3 assert count_unique_palindromic_substrings(\\"aaa\\") == 3 assert count_unique_palindromic_substrings(\\"a\\") == 1 assert count_unique_palindromic_substrings(\\"ab\\") == 2 assert count_unique_palindromic_substrings(\\"abbac\\") == 5 assert count_unique_palindromic_substrings(\\"racecar\\") == 7 assert count_unique_palindromic_substrings(\\"aaaaa\\") == 5 assert count_unique_palindromic_substrings(\\"abcdefg\\") == 7 assert count_unique_palindromic_substrings(\\"\\") == 0","solution":"def count_unique_palindromic_substrings(s: str) -> int: def is_palindrome(sub: str) -> bool: return sub == sub[::-1] unique_palindromes = set() n = len(s) for i in range(n): for j in range(i + 1, n + 1): sub = s[i:j] if is_palindrome(sub): unique_palindromes.add(sub) return len(unique_palindromes)"},{"question":"from typing import Callable def integrate_simpson(func: Callable[[float], float], lower_bound: float, upper_bound: float, subdivisions: int) -> float: Implement Simpson's Rule to numerically integrate a given function over a specified interval with a specified number of subdivisions. Parameters: func (Callable[[float], float]): The function to be integrated. lower_bound (float): The lower bound of the integration interval. upper_bound (float): The upper bound of the integration interval. subdivisions (int): The number of subdivisions (must be even). Returns: float: The estimated integral of the function over the interval. Example: >>> def example_func(x: float) -> float: ... return x**3 ... >>> integrate_simpson(example_func, 0.0, 1.0, 10) 0.25 pass","solution":"from typing import Callable def integrate_simpson(func: Callable[[float], float], lower_bound: float, upper_bound: float, subdivisions: int) -> float: if subdivisions <= 0 or subdivisions % 2 != 0: raise ValueError(\\"Number of subdivisions must be a positive even integer.\\") h = (upper_bound - lower_bound) / subdivisions sum_odd = 0 sum_even = 0 for i in range(1, subdivisions, 2): sum_odd += func(lower_bound + i * h) for i in range(2, subdivisions, 2): sum_even += func(lower_bound + i * h) result = (h/3) * (func(lower_bound) + 4 * sum_odd + 2 * sum_even + func(upper_bound)) return result"},{"question":"def filter_products_by_category(products: Dict[str, Dict[str, Any]], category: str) -> List[Dict[str, Any]]: Filters products by a given category. return [details for details in products.values() if details['category'] == category] def sort_products(products: List[Dict[str, Any]], sort_key: str, reverse: bool = False) -> List[Dict[str, Any]]: Sorts products based on a specified key. return sorted(products, key=lambda x: x[sort_key], reverse=reverse) def generate_report(products: Dict[str, Dict[str, Any]], category: str, sort_key: str, reverse: bool = False) -> List[Dict[str, Any]]: Combines filtering by category and sorting to generate a report of products. filtered_products = filter_products_by_category(products, category) sorted_products = sort_products(filtered_products, sort_key, reverse) return sorted_products","solution":"from typing import Dict, List, Any def filter_products_by_category(products: Dict[str, Dict[str, Any]], category: str) -> List[Dict[str, Any]]: Filters products by a given category. return [details for details in products.values() if details['category'] == category] def sort_products(products: List[Dict[str, Any]], sort_key: str, reverse: bool = False) -> List[Dict[str, Any]]: Sorts products based on a specified key. return sorted(products, key=lambda x: x[sort_key], reverse=reverse) def generate_report(products: Dict[str, Dict[str, Any]], category: str, sort_key: str, reverse: bool = False) -> List[Dict[str, Any]]: Combines filtering by category and sorting to generate a report of products. filtered_products = filter_products_by_category(products, category) sorted_products = sort_products(filtered_products, sort_key, reverse) return sorted_products"},{"question":"from typing import List def is_unique_anagram_identifier(word_list: List[str]) -> List[bool]: Determines for each word in the input list if it is the unique combination of letters among its anagrams in the list. Args: word_list (List[str]): A list of words containing only lowercase alphabetical characters. Returns: List[bool]: A list of booleans where the boolean value at each index indicates whether the corresponding word is unique among its anagrams. Examples: >>> is_unique_anagram_identifier([\\"listen\\", \\"silent\\", \\"enlist\\", \\"inlets\\", \\"google\\", \\"goolge\\"]) [False, False, False, False, False, False] >>> is_unique_anagram_identifier([\\"rat\\", \\"tar\\", \\"art\\", \\"car\\"]) [False, False, False, True] >>> is_unique_anagram_identifier([\\"abcd\\", \\"abc\\", \\"bac\\", \\"dabc\\", \\"abcdef\\", \\"bcdeaf\\"]) [False, True, True, False, False, False] >>> is_unique_anagram_identifier([\\"hello\\", \\"world\\", \\"python\\"]) [True, True, True] >>> is_unique_anagram_identifier([\\"a\\", \\"b\\", \\"a\\", \\"a\\"]) [False, True, False, False]","solution":"from typing import List def is_unique_anagram_identifier(word_list: List[str]) -> List[bool]: anagram_map = {} result = [True] * len(word_list) for idx, word in enumerate(word_list): sorted_word = ''.join(sorted(word)) if sorted_word in anagram_map: for linked_idx in anagram_map[sorted_word]: result[linked_idx] = False result[idx] = False anagram_map[sorted_word].append(idx) else: anagram_map[sorted_word] = [idx] return result"},{"question":"from typing import List, Dict def sort_events_by_date(events: List[Dict[str, str]]) -> List[Dict[str, str]]: Sorts a list of event dictionaries by their date in ascending order. Args: events (List[Dict[str, str]]): List of events where each event is represented as a dictionary with 'name' and 'date'. Returns: List[Dict[str, str]]: List of events sorted by date in ascending order. Example: >>> events = [ ... {\\"name\\": \\"Event A\\", \\"date\\": \\"2023-03-15\\"}, ... {\\"name\\": \\"Event B\\", \\"date\\": \\"2022-12-01\\"}, ... {\\"name\\": \\"Event C\\", \\"date\\": \\"2023-01-10\\"} ... ] >>> sorted_events = sort_events_by_date(events) >>> sorted_events [ {\\"name\\": \\"Event B\\", \\"date\\": \\"2022-12-01\\"}, {\\"name\\": \\"Event C\\", \\"date\\": \\"2023-01-10\\"}, {\\"name\\": \\"Event A\\", \\"date\\": \\"2023-03-15\\"} ] def test_sort_events_by_date_with_sample_events(): events = [ {\\"name\\": \\"Event A\\", \\"date\\": \\"2023-03-15\\"}, {\\"name\\": \\"Event B\\", \\"date\\": \\"2022-12-01\\"}, {\\"name\\": \\"Event C\\", \\"date\\": \\"2023-01-10\\"} ] expected = [ {\\"name\\": \\"Event B\\", \\"date\\": \\"2022-12-01\\"}, {\\"name\\": \\"Event C\\", \\"date\\": \\"2023-01-10\\"}, {\\"name\\": \\"Event A\\", \\"date\\": \\"2023-03-15\\"} ] assert sort_events_by_date(events) == expected def test_sort_events_by_date_with_empty_list(): events = [] expected = [] assert sort_events_by_date(events) == expected def test_sort_events_by_date_with_single_event(): events = [{\\"name\\": \\"Event A\\", \\"date\\": \\"2023-03-15\\"}] expected = [{\\"name\\": \\"Event A\\", \\"date\\": \\"2023-03-15\\"}] assert sort_events_by_date(events) == expected def test_sort_events_by_date_with_multiple_events(): events = [ {\\"name\\": \\"Event Y\\", \\"date\\": \\"2021-10-10\\"}, {\\"name\\": \\"Event Z\\", \\"date\\": \\"2021-12-25\\"}, {\\"name\\": \\"Event X\\", \\"date\\": \\"2020-01-01\\"}, {\\"name\\": \\"Event A\\", \\"date\\": \\"2019-07-14\\"} ] expected = [ {\\"name\\": \\"Event A\\", \\"date\\": \\"2019-07-14\\"}, {\\"name\\": \\"Event X\\", \\"date\\": \\"2020-01-01\\"}, {\\"name\\": \\"Event Y\\", \\"date\\": \\"2021-10-10\\"}, {\\"name\\": \\"Event Z\\", \\"date\\": \\"2021-12-25\\"} ] assert sort_events_by_date(events) == expected def test_sort_events_by_date_with_unsorted_dates(): events = [ {\\"name\\": \\"Event C\\", \\"date\\": \\"2022-05-05\\"}, {\\"name\\": \\"Event B\\", \\"date\\": \\"2022-05-03\\"}, {\\"name\\": \\"Event D\\", \\"date\\": \\"2022-05-06\\"}, {\\"name\\": \\"Event A\\", \\"date\\": \\"2022-05-02\\"} ] expected = [ {\\"name\\": \\"Event A\\", \\"date\\": \\"2022-05-02\\"}, {\\"name\\": \\"Event B\\", \\"date\\": \\"2022-05-03\\"}, {\\"name\\": \\"Event C\\", \\"date\\": \\"2022-05-05\\"}, {\\"name\\": \\"Event D\\", \\"date\\": \\"2022-05-06\\"} ] assert sort_events_by_date(events) == expected","solution":"from typing import List, Dict def sort_events_by_date(events: List[Dict[str, str]]) -> List[Dict[str, str]]: Sorts a list of event dictionaries by their date in ascending order. Args: events (List[Dict[str, str]]): List of events where each event is represented as a dictionary. Returns: List[Dict[str, str]]: List of events sorted by date in ascending order. return sorted(events, key=lambda event: event['date'])"},{"question":"def estimate_delivery_time(distance: float, speed: float) -> float: Calculate the estimated delivery time in hours. Args: distance (float): The distance to the destination in kilometers. Must be a positive value. speed (float): The speed of the delivery vehicle in kilometers per hour. Must be a positive value. Returns: float: The estimated delivery time in hours. Raises: ValueError: If distance or speed is not a positive value. >>> estimate_delivery_time(100, 50) 2.0 >>> estimate_delivery_time(200, 100) 2.0 >>> estimate_delivery_time(-150, 50) Traceback (most recent call last): ... ValueError: Distance must be a positive value >>> estimate_delivery_time(150, -50) Traceback (most recent call last): ... ValueError: Speed must be a positive value","solution":"def estimate_delivery_time(distance: float, speed: float) -> float: Calculate the estimated delivery time in hours. Args: distance (float): The distance to the destination in kilometers. Must be a positive value. speed (float): The speed of the delivery vehicle in kilometers per hour. Must be a positive value. Returns: float: The estimated delivery time in hours. Raises: ValueError: If distance or speed is not a positive value. if distance <= 0: raise ValueError(\\"Distance must be a positive value\\") if speed <= 0: raise ValueError(\\"Speed must be a positive value\\") return distance / speed"},{"question":"from typing import List, Tuple, Dict def track_checkins(records: List[Tuple[int, str, str]]) -> Dict[str, Dict[int, str]]: Process a series of check-in records and return a summary dictionary indicating the first check-in time for each employee per day. Each record consists of an employee ID, a timestamp, and a date. Ensure that only the first check-in of the day is recorded for each employee. >>> track_checkins([(1, \\"08:30\\", \\"2023-01-01\\"), (2, \\"09:00\\", \\"2023-01-01\\"), (1, \\"09:15\\", \\"2023-01-01\\"), (1, \\"08:45\\", \\"2023-01-02\\")]) {\\"2023-01-01\\": {1: \\"08:30\\", 2: \\"09:00\\"}, \\"2023-01-02\\": {1: \\"08:45\\"}} >>> track_checkins([(1, \\"07:30\\", \\"2023-05-05\\"), (1, \\"07:30\\", \\"2023-05-05\\"), (2, \\"08:00\\", \\"2023-05-05\\"), (3, \\"08:45\\", \\"2023-05-05\\"), (2, \\"08:30\\", \\"2023-05-05\\")]) {\\"2023-05-05\\": {1: \\"07:30\\", 2: \\"08:00\\", 3: \\"08:45\\"}} >>> track_checkins([]) {} >>> track_checkins([(1, \\"08:30\\", \\"2023-01-01\\")]) {\\"2023-01-01\\": {1: \\"08:30\\"}} >>> track_checkins([(1, \\"08:30\\", \\"2023-01-01\\"), (2, \\"09:00\\", \\"2023-01-01\\"), (3, \\"07:30\\", \\"2023-01-01\\")]) {\\"2023-01-01\\": {1: \\"08:30\\", 2: \\"09:00\\", 3: \\"07:30\\"}}","solution":"from typing import List, Tuple, Dict def track_checkins(records: List[Tuple[int, str, str]]) -> Dict[str, Dict[int, str]]: checkin_summary = {} for employee_id, timestamp, date in records: if date not in checkin_summary: checkin_summary[date] = {} if employee_id not in checkin_summary[date]: checkin_summary[date][employee_id] = timestamp return checkin_summary"},{"question":"from typing import List def can_reach_end(grid: List[List[int]]) -> bool: Determine if a robot can reach the bottom-right corner of a grid from the top-left corner. The grid contains: - 0: empty cells the robot can traverse. - 1: obstacles that the robot cannot traverse. - 2: cells that only allow movement to the right. - 3: cells that only allow movement down. >>> grid = [ ... [0, 0, 0, 0], ... [0, 1, 1, 0], ... [0, 0, 0, 0], ... [1, 1, 0, 0] ... ] >>> can_reach_end(grid) True >>> grid = [ ... [0, 1, 0], ... [1, 0, 0], ... [0, 1, 0] ... ] >>> can_reach_end(grid) False >>> grid = [ ... [0, 0, 1], ... [1, 0, 1], ... [1, 0, 0] ... ] >>> can_reach_end(grid) True >>> grid = [ ... [0, 0, 2], ... [2, 1, 2], ... [2, 2, 0] ... ] >>> can_reach_end(grid) False >>> grid = [ ... [0] ... ] >>> can_reach_end(grid) True >>> grid = [[0] * 100 for _ in range(100)] >>> grid[99][99] = 0 >>> can_reach_end(grid) True","solution":"from typing import List def can_reach_end(grid: List[List[int]]) -> bool: def dfs(x, y): if x == len(grid) - 1 and y == len(grid[0]) - 1: return True if not (0 <= x < len(grid) and 0 <= y < len(grid[0])) or visited[x][y] or grid[x][y] == 1: return False visited[x][y] = True # Moving right if grid[x][y] in (0, 2) and not visited[x][y + 1] if y + 1 < len(grid[0]) else False: if dfs(x, y + 1): return True # Moving down if grid[x][y] in (0, 3) and not visited[x + 1][y] if x + 1 < len(grid) else False: if dfs(x + 1, y): return True return False visited = [[False] * len(grid[0]) for _ in range(len(grid))] return dfs(0, 0)"},{"question":"def filter_search_query(query: str, stop_words: list) -> str: Removes stop words from the search query. Parameters: query (str): The user's search query. stop_words (list): The list of stop words to be filtered out. Returns: str: The filtered search query with stop words removed. Example: >>> filter_search_query(\\"find the best restaurants near me\\", [\\"the\\", \\"near\\"]) 'find best restaurants me' >>> filter_search_query(\\"data analysis and machine learning\\", [\\"and\\"]) 'data analysis machine learning' >>> filter_search_query(\\"buy cheap books online\\", [\\"cheap\\", \\"online\\"]) 'buy books'","solution":"def filter_search_query(query: str, stop_words: list) -> str: Removes stop words from the search query. Parameters: query (str): The user's search query. stop_words (list): The list of stop words to be filtered out. Returns: str: The filtered search query with stop words removed. query_words = query.split() filtered_words = [word for word in query_words if word not in stop_words] return ' '.join(filtered_words)"},{"question":"def k_means_clustering(points: list[list[float]], K: int) -> list[int]: Implement an efficient version of the K-Means clustering algorithm for partitioning a dataset into K distinct clusters. Args: - points: A list of points where each point is represented as a list of its coordinates in multi-dimensional space. - K: The number of clusters to form. Returns: - A list of integers where each integer represents the assigned cluster index for the corresponding point in the input list. >>> points = [ ... [1.0, 2.0], ... [2.0, 3.0], ... [3.0, 4.0], ... [8.0, 8.0], ... [9.0, 9.0], ... [10.0, 10.0] ... ] >>> K = 2 >>> k_means_clustering(points, K) [0, 0, 0, 1, 1, 1] # or [1, 1, 1, 0, 0, 0] depending on initialization pass","solution":"import random import numpy as np def k_means_clustering(points: list[list[float]], K: int) -> list[int]: points = np.array(points) n = len(points) d = points.shape[1] # Step 1: Randomly initialize K centroids from the given points initial_indices = random.sample(range(n), K) centroids = points[initial_indices] # Step 2: Iterate until convergence or a maximum number of iterations max_iterations = 300 for _ in range(max_iterations): # Assign each point to the nearest centroid distances = np.sqrt(((points - centroids[:, np.newaxis])**2).sum(axis=2)) labels = np.argmin(distances, axis=0) # Calculate new centroids from the mean of the assigned points new_centroids = np.array([points[labels == k].mean(axis=0) for k in range(K)]) # Check for convergence (if centroids do not change) if np.allclose(centroids, new_centroids): break centroids = new_centroids # Return the labels for each point return labels.tolist()"},{"question":"# Completion Task: Find the Longest Common Prefix Given a list of strings, write a function \`longest_common_prefix(strs: List[str]) -> str\` to find the longest common prefix string amongst an array of strings. If there is no common prefix, return an empty string. Example def longest_common_prefix(strs: List[str]) -> str: if not strs: return \\"\\" # Sort the list to have the smallest and largest strings strs.sort() # Compare only the first and the last string in the sorted list first, last = strs[0], strs[-1] i = 0 while i < len(first) and i < len(last) and first[i] == last[i]: i += 1 return first[:i] # Example Usage print(longest_common_prefix([\\"flower\\", \\"flow\\", \\"flight\\"])) # Output: \\"fl\\" print(longest_common_prefix([\\"dog\\", \\"racecar\\", \\"car\\"])) # Output: \\"\\" print(longest_common_prefix([\\"interview\\", \\"integral\\", \\"internal\\"])) # Output: \\"inte\\" print(longest_common_prefix([\\"reliable\\", \\"relief\\", \\"remark\\"])) # Output: \\"rel\\"","solution":"def transform_array(arr): Transforms the array in place following the given transformation rule to result in a sorted array. n = len(arr) for i in range(n): for j in range(n - 1): if arr[j] > arr[j + 1]: arr[j], arr[j + 1] = arr[j + 1], arr[j] return arr"},{"question":"Implement a function \`power\` utilizing exponentiation by squaring to compute the power of a base number raised to a specified exponent. The function should handle both positive and negative exponents efficiently. def power(base: int, exponent: int) -> float: if exponent == 0: return 1.0 # Handle negative exponent if exponent < 0: base = 1 / base exponent = -exponent result = 1.0 current_base = base while exponent > 0: if exponent % 2 == 1: # If exponent is odd result *= current_base current_base *= current_base # Square the base exponent //= 2 return result Unit tests: def test_power_positive_exponents(): assert power(2, 3) == 8.0 assert power(3, 2) == 9.0 assert power(5, 5) == 3125.0 def test_power_negative_exponents(): assert round(power(2, -3), 5) == 0.12500 assert round(power(5, -2), 5) == 0.04 assert round(power(3, -3), 5) == 0.03704 def test_power_edge_cases(): assert power(0, 0) == 1.0 assert power(0, 5) == 0.0 assert power(2, 0) == 1.0 def test_power_large_exponents(): assert power(2, 10) == 1024.0 assert power(10, 5) == 100000.0 def test_power_base_one(): assert power(1, 1000) == 1.0 assert power(1, -1000) == 1.0 assert power(1, 0) == 1.0","solution":"def power(base: int, exponent: int) -> float: if exponent == 0: return 1.0 # Handle negative exponent if exponent < 0: base = 1 / base exponent = -exponent result = 1.0 current_base = base while exponent > 0: if exponent % 2 == 1: # If exponent is odd result *= current_base current_base *= current_base # Square the base exponent //= 2 return result"},{"question":"class BookNotFoundError(Exception): Raised when a book is not found in the catalog. pass class BookAlreadyBorrowedError(Exception): Raised when a book that is already borrowed is attempted to be borrowed again. pass class BookAlreadyReturnedError(Exception): Raised when a book that is not borrowed is attempted to be returned. pass class Library: Library Management System to keep track of books and borrowing/returning operations. Methods: - add_book(book_id: int): Add a book with a unique book_id to the catalog. - remove_book(book_id: int): Remove a book with the given book_id from the catalog. - borrow(book_id: int) -> bool: Borrow a book with the given book_id if available. - return_book(book_id: int) -> bool: Return a book with the given book_id. - is_available(book_id: int) -> bool: Check if a book with the given book_id is available for borrowing. - available_books() -> List[int]: Return a list of all available books in the catalog, sorted by book_id. def __init__(self): self.catalog = set() self.borrowed_books = set() def add_book(self, book_id: int): Add a book with a unique book_id to the catalog. pass def remove_book(self, book_id: int): Remove a book with the given book_id from the catalog. Raises BookNotFoundError if the book does not exist in the catalog. pass def borrow(self, book_id: int) -> bool: Borrow a book with the given book_id if available. Returns True if the borrowing is successful, False otherwise. Raises BookNotFoundError if the book does not exist in the catalog. Raises BookAlreadyBorrowedError if the book has already been borrowed. pass def return_book(self, book_id: int) -> bool: Return a book with the given book_id. Returns True if the return is successful, False otherwise. Raises BookNotFoundError if the book does not exist in the catalog. Raises BookAlreadyReturnedError if the book has not been borrowed. pass def is_available(self, book_id: int) -> bool: Check if a book with the given book_id is available for borrowing. Returns True if available, False otherwise. pass def available_books(self) -> list: Return a list of all available books in the catalog, sorted by book_id. pass import pytest def test_add_book(): library = Library() assert library.add_book(101) is None assert 101 in library.catalog def test_remove_book(): library = Library() library.add_book(101) library.remove_book(101) assert 101 not in library.catalog def test_remove_book_not_found(): library = Library() with pytest.raises(BookNotFoundError): library.remove_book(101) def test_borrow_book(): library = Library() library.add_book(101) assert library.borrow(101) == True assert 101 in library.borrowed_books def test_borrow_book_already_borrowed(): library = Library() library.add_book(101) library.borrow(101) with pytest.raises(BookAlreadyBorrowedError): library.borrow(101) def test_borrow_book_not_found(): library = Library() with pytest.raises(BookNotFoundError): library.borrow(101) def test_return_book(): library = Library() library.add_book(101) library.borrow(101) assert library.return_book(101) == True assert 101 not in library.borrowed_books def test_return_book_not_borrowed(): library = Library() library.add_book(101) with pytest.raises(BookAlreadyReturnedError): library.return_book(101) def test_return_book_not_found(): library = Library() with pytest.raises(BookNotFoundError): library.return_book(101) def test_is_available(): library = Library() library.add_book(101) assert library.is_available(101) == True library.borrow(101) assert library.is_available(101) == False def test_is_available_not_in_catalog(): library = Library() assert library.is_available(101) == False def test_available_books(): library = Library() library.add_book(101) library.add_book(102) library.borrow(101) assert library.available_books() == [102] library.return_book(101) assert library.available_books() == [101, 102]","solution":"class BookNotFoundError(Exception): pass class BookAlreadyBorrowedError(Exception): pass class BookAlreadyReturnedError(Exception): pass class Library: def __init__(self): self.catalog = set() self.borrowed_books = set() def add_book(self, book_id: int): self.catalog.add(book_id) def remove_book(self, book_id: int): if book_id not in self.catalog: raise BookNotFoundError(f\\"Book ID {book_id} not found in the catalog.\\") self.catalog.remove(book_id) self.borrowed_books.discard(book_id) def borrow(self, book_id: int) -> bool: if book_id not in self.catalog: raise BookNotFoundError(f\\"Book ID {book_id} not found in the catalog.\\") if book_id in self.borrowed_books: raise BookAlreadyBorrowedError(f\\"Book ID {book_id} is already borrowed.\\") self.borrowed_books.add(book_id) return True def return_book(self, book_id: int) -> bool: if book_id not in self.catalog: raise BookNotFoundError(f\\"Book ID {book_id} not found in the catalog.\\") if book_id not in self.borrowed_books: raise BookAlreadyReturnedError(f\\"Book ID {book_id} was not borrowed.\\") self.borrowed_books.remove(book_id) return True def is_available(self, book_id: int) -> bool: if book_id not in self.catalog: return False return book_id not in self.borrowed_books def available_books(self) -> list: return sorted(book_id for book_id in self.catalog if book_id not in self.borrowed_books)"},{"question":"def are_permutations(str1: str, str2: str) -> bool: Checks if two given strings are permutations of each other. :param str1: The first string. :param str2: The second string. :return: True if str1 and str2 are permutations of each other, False otherwise. :raises ValueError: If either string is empty or if their lengths differ. >>> are_permutations(\\"abc\\", \\"bca\\") True >>> are_permutations(\\"abc\\", \\"abcd\\") False >>> are_permutations(\\"abc\\", \\"ABC\\") False >>> are_permutations(\\"abc \\", \\" cba\\") True","solution":"def are_permutations(str1, str2): Checks if two given strings are permutations of each other. :param str1: The first string. :param str2: The second string. :return: True if str1 and str2 are permutations of each other, False otherwise. :raises ValueError: If either string is empty or if their lengths differ. if not str1 or not str2: raise ValueError(\\"Strings must not be empty.\\") if len(str1) != len(str2): return False return sorted(str1) == sorted(str2)"},{"question":"from typing import List import heapq def kth_smallest(matrix: List[List[int]], k: int) -> int: Given an \`n x n\` matrix where each of the rows and columns are sorted in ascending order, return the k-th smallest element in the matrix. Args: matrix (List of List of int): An \`n x n\` 2D list where each row and column are sorted in ascending order. k (int): The position (1-indexed) of the element to find. Returns: int: The k-th smallest element in the matrix. Raises: AssertionError: If matrix is empty or k is out of valid range. Example: >>> kth_smallest([ ... [1, 5, 9], ... [10, 11, 13], ... [12, 13, 15] ... ], 8) 13 >>> kth_smallest([ ... [-5, -4], ... [-3, -1] ... ], 2) -4 >>> kth_smallest([], 1) Traceback (most recent call last): ... AssertionError: Matrix cannot be empty >>> kth_smallest([[1]], 0) Traceback (most recent call last): ... AssertionError: k must be within the valid range, got k=0","solution":"from typing import List import heapq def kth_smallest(matrix: List[List[int]], k: int) -> int: if not matrix or not matrix[0]: raise AssertionError(\\"Matrix cannot be empty\\") n = len(matrix) if k < 1 or k > n * n: raise AssertionError(f\\"k must be within the valid range, got k={k}\\") # Min-heap to store the elements min_heap = [] # Initialize the heap with the first element of each row for r in range(min(n, k)): # We only need up to the first k rows heapq.heappush(min_heap, (matrix[r][0], r, 0)) # Iterate k-1 times to pop the smallest element while k > 0: element, r, c = heapq.heappop(min_heap) k -= 1 if k == 0: return element if c + 1 < n: # Push the next element in the same row heapq.heappush(min_heap, (matrix[r][c + 1], r, c + 1))"},{"question":"class Library: def __init__(self): Initializes an empty library. pass def add_book(self, title: str, author: str, copies: int) -> None: Add a new book or update the number of copies of an existing book. Args: title (str): The title of the book. author (str): The author of the book. copies (int): The number of copies to add. def borrow_book(self, title: str) -> bool: Reduce the number of available copies of the specified book by one, if available. Args: title (str): The title of the book to borrow. Returns: bool: True if the book was borrowed successfully, False otherwise. def return_book(self, title: str) -> bool: Increase the number of available copies of the specified book by one. Args: title (str): The title of the book to return. Returns: bool: True if the book was returned successfully, False otherwise. def get_available_copies(self, title: str) -> int: Retrieve the number of available copies for a specified book. Args: title (str): The title of the book. Returns: int: The number of available copies.","solution":"class Library: def __init__(self): self.books = {} def add_book(self, title: str, author: str, copies: int) -> None: if title in self.books: self.books[title]['copies'] += copies else: self.books[title] = {'author': author, 'copies': copies} def borrow_book(self, title: str) -> bool: if title in self.books and self.books[title]['copies'] > 0: self.books[title]['copies'] -= 1 return True return False def return_book(self, title: str) -> bool: if title in self.books: self.books[title]['copies'] += 1 return True return False def get_available_copies(self, title: str) -> int: if title in self.books: return self.books[title]['copies'] return 0"},{"question":"import heapq from typing import List def dijkstra(adj_matrix: List[List[int]], start: int) -> List[int]: Implement Dijkstra's algorithm to find the shortest path from a source node to all other nodes in a given directed weighted graph using an adjacency matrix. >>> adj_matrix = [ ... [0, 2, float('inf'), 4], ... [2, 0, 1, float('inf')], ... [float('inf'), 1, 0, 3], ... [4, float('inf'), 3, 0] ... ] >>> start = 0 >>> dijkstra(adj_matrix, start) [0, 2, 3, 4] >>> adj_matrix = [ ... [0, 1, float('inf')], ... [1, 0, float('inf')], ... [float('inf'), float('inf'), 0] ... ] >>> start = 0 >>> dijkstra(adj_matrix, start) [0, 1, float('inf')] >>> adj_matrix = [ ... [0] ... ] >>> start = 0 >>> dijkstra(adj_matrix, start) [0]","solution":"import heapq from typing import List def dijkstra(adj_matrix: List[List[int]], start: int) -> List[int]: n = len(adj_matrix) distances = [float('inf')] * n distances[start] = 0 visited = [False] * n min_heap = [(0, start)] # (distance, node) while min_heap: current_distance, current_node = heapq.heappop(min_heap) if visited[current_node]: continue visited[current_node] = True for neighbor in range(n): weight = adj_matrix[current_node][neighbor] if weight != float('inf') and not visited[neighbor]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(min_heap, (distance, neighbor)) return distances"},{"question":"def subarray_sum(nums: list[int], k: int) -> int: Calculates the number of contiguous subarrays that sum to a given target value k. >>> subarray_sum([1, 1, 1], 2) 2 >>> subarray_sum([1], 1) 1 >>> subarray_sum([1], 2) 0 >>> subarray_sum([-1, -1, 1], 0) 1 >>> subarray_sum([1, 2, 3, 0, 1, -1], 3) 4 >>> subarray_sum([1, 2, 1, 2, 1], 100) 0 >>> subarray_sum([-1, -1, -1, -1], -2) 3 >>> subarray_sum([0, 0, 0, 0], 0) 10","solution":"def subarray_sum(nums: list[int], k: int) -> int: Calculates the number of contiguous subarrays that sum to a given target value k. :param nums: List of integers :param k: Target sum :return: Number of contiguous subarrays summing to k count = 0 current_sum = 0 sum_counts = {0: 1} # Initialize with zero sum having one count for num in nums: current_sum += num if (current_sum - k) in sum_counts: count += sum_counts[current_sum - k] if current_sum in sum_counts: sum_counts[current_sum] += 1 else: sum_counts[current_sum] = 1 return count"},{"question":"def fahrenheit_to_celsius(fahrenheit: float) -> float: Converts a temperature from Fahrenheit to Celsius. >>> fahrenheit_to_celsius(212) 100.00 >>> fahrenheit_to_celsius(32) 0.00 >>> fahrenheit_to_celsius(-40) -40.00 >>> fahrenheit_to_celsius(0) -17.78 >>> fahrenheit_to_celsius(98.6) 37.00 pass def celsius_to_fahrenheit(celsius: float) -> float: Converts a temperature from Celsius to Fahrenheit. >>> celsius_to_fahrenheit(100) 212.00 >>> celsius_to_fahrenheit(0) 32.00 >>> celsius_to_fahrenheit(-40) -40.00 >>> celsius_to_fahrenheit(-100) -148.00 >>> celsius_to_fahrenheit(37) 98.60 pass","solution":"def fahrenheit_to_celsius(fahrenheit: float) -> float: Converts Fahrenheit to Celsius and returns the value rounded to two decimal points. celsius = (fahrenheit - 32) * 5 / 9 return round(celsius, 2) def celsius_to_fahrenheit(celsius: float) -> float: Converts Celsius to Fahrenheit and returns the value rounded to two decimal points. fahrenheit = (celsius * 9 / 5) + 32 return round(fahrenheit, 2)"},{"question":"def count_distinct_substrings(s: str, k: int) -> int: Counts the number of distinct substrings of length k in the given string. Args: s (str): The input string. k (int): The length of the substrings to consider. Returns: int: The number of distinct substrings of length k. Raises: ValueError: If k is greater than the length of the string or if k is non-positive. >>> count_distinct_substrings(\\"abcabc\\", 2) == 3 >>> count_distinct_substrings(\\"aaaa\\", 1) == 1 >>> (count_distinct_substrings(\\"abcd\\", 5)) Traceback (most recent call last): ... ValueError: k is greater than the length of the string or is non-positive","solution":"def count_distinct_substrings(s: str, k: int) -> int: Counts the number of distinct substrings of length k in the given string. Args: s (str): The input string. k (int): The length of the substrings to consider. Returns: int: The number of distinct substrings of length k. Raises: ValueError: If k is greater than the length of the string or if k is non-positive. if k <= 0 or k > len(s): raise ValueError(\\"k is greater than the length of the string or is non-positive.\\") substrings = set() for i in range(len(s) - k + 1): substrings.add(s[i:i + k]) return len(substrings)"},{"question":"def rotate_matrix_clockwise(matrix: list) -> list: Rotates a given square matrix 90 degrees clockwise. >>> rotate_matrix_clockwise([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] >>> rotate_matrix_clockwise([ ... [1, 2], ... [3, 4] ... ]) [ [3, 1], [4, 2] ] # Your code here def rotate_matrix_counterclockwise(matrix: list) -> list: Rotates a given square matrix 90 degrees counterclockwise. >>> rotate_matrix_counterclockwise([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) [ [3, 6, 9], [2, 5, 8], [1, 4, 7] ] >>> rotate_matrix_counterclockwise([ ... [1, 2], ... [3, 4] ... ]) [ [2, 4], [1, 3] ] # Your code here","solution":"def rotate_matrix_clockwise(matrix: list) -> list: Rotates a given square matrix 90 degrees clockwise. n = len(matrix) # The new matrix to hold the rotated values rotated = [[0] * n for _ in range(n)] for i in range(n): for j in range(n): rotated[j][n - 1 - i] = matrix[i][j] return rotated def rotate_matrix_counterclockwise(matrix: list) -> list: Rotates a given square matrix 90 degrees counterclockwise. n = len(matrix) # The new matrix to hold the rotated values rotated = [[0] * n for _ in range(n)] for i in range(n): for j in range(n): rotated[n - 1 - j][i] = matrix[i][j] return rotated"},{"question":"import random from typing import List, Tuple def simulate_game_actions(starting_health: int, starting_energy: int, actions: List[Tuple[str, int, int]], num_actions: int) -> Tuple[int, int]: Simulates a sequence of actions on a game character and returns the final health and energy levels. Parameters: - starting_health (int): Initial health level. - starting_energy (int): Initial energy level. - actions (List[Tuple[str, int, int]]): List of actions where each action is a tuple (name, health_change, energy_change). - num_actions (int): Number of actions to simulate. Returns: - Tuple[int, int]: Final health and energy levels as a tuple (final_health, final_energy). pass # Example tests def test_simulate_game_actions_basic(): actions = [ ('rest', 10, 20), ('work', -5, -20), ('exercise', -10, -30), ('eat', 20, 5) ] result = simulate_game_actions(100, 100, actions, 50) assert isinstance(result, tuple) assert len(result) == 2 assert result[0] >= 0 assert result[1] >= 0 def test_simulate_game_actions_zero_num_actions(): actions = [ ('rest', 10, 20), ('work', -5, -20), ('exercise', -10, -30), ('eat', 20, 5) ] result = simulate_game_actions(100, 100, actions, 0) assert result == (100, 100) def test_simulate_game_actions_only_negative_health(): actions = [ ('work', -20, 0), ('exercise', -30, 0) ] result = simulate_game_actions(100, 100, actions, 10) assert isinstance(result, tuple) assert len(result) == 2 assert result[0] >= 0 assert result[1] >= 0 def test_simulate_game_actions_only_negative_energy(): actions = [ ('work', 0, -20), ('exercise', 0, -30) ] result = simulate_game_actions(100, 100, actions, 10) assert isinstance(result, tuple) assert len(result) == 2 assert result[0] >= 0 assert result[1] >= 0 def test_simulate_game_actions_mixed_actions(): actions = [ ('rest', 10, 20), ('work', -5, -20), ('exercise', -10, -30), ('eat', 20, 5) ] result = simulate_game_actions(50, 50, actions, 100) assert isinstance(result, tuple) assert len(result) == 2 assert result[0] >= 0 assert result[1] >= 0","solution":"import random def simulate_game_actions(starting_health, starting_energy, actions, num_actions): Simulates a sequence of actions on a game character and returns the final health and energy levels. Parameters: - starting_health (int): Initial health level. - starting_energy (int): Initial energy level. - actions (list of tuple): List of actions where each action is a tuple (name, health_change, energy_change). - num_actions (int): Number of actions to simulate. Returns: - tuple: Final health and energy levels as a tuple (final_health, final_energy). current_health = starting_health current_energy = starting_energy for _ in range(num_actions): action_name, health_change, energy_change = random.choice(actions) current_health = max(0, current_health + health_change) current_energy = max(0, current_energy + energy_change) return current_health, current_energy"},{"question":"class Node: def __init__(self, key): self.key = key self.left = None self.right = None class BST: def __init__(self): self.root = None def insert(self, key): self.root = self._insert_recursive(self.root, key) def _insert_recursive(self, node, key): if node is None: return Node(key) if key < node.key: node.left = self._insert_recursive(node.left, key) elif key > node.key: node.right = self._insert_recursive(node.right, key) return node def search(self, key): return self._search_recursive(self.root, key) is not None def _search_recursive(self, node, key): if node is None or node.key == key: return node if key < node.key: return self._search_recursive(node.left, key) else: return self._search_recursive(node.right, key) def delete(self, key): self.root = self._delete_recursive(self.root, key) def _delete_recursive(self, node, key): if node is None: return node if key < node.key: node.left = self._delete_recursive(node.left, key) elif key > node.key: node.right = self._delete_recursive(node.right, key) else: if node.left is None: return node.right elif node.right is None: return node.left temp = self._min_value_node(node.right) node.key = temp.key node.right = self._delete_recursive(node.right, temp.key) return node def _min_value_node(self, node): current = node while current.left is not None: current = current.left return current def inorder(self): result = [] self._inorder_recursive(self.root, result) return result def _inorder_recursive(self, node, result): if node is not None: self._inorder_recursive(node.left, result) result.append(node.key) self._inorder_recursive(node.right, result) def bst_operations(operations: list[tuple[str, int]]) -> list[list[int]]: Performs a series of operations on a Binary Search Tree. Args: operations: List of tuples where each tuple represents an operation in the format (op_type, value) - op_type: Operation type - \\"insert\\", \\"delete\\", \\"search\\", \\"inorder\\" - value: Value associated with the operation (integer) Returns: List of lists where each sublist contains the result of \\"inorder\\" traversal after its corresponding operation. For \\"search\\" operations, include a list of a single boolean value indicating whether the searched value is found. Example: bst_operations([ (\\"insert\\", 5), (\\"insert\\", 3), (\\"insert\\", 8), (\\"inorder\\", 0), (\\"search\\", 3), (\\"delete\\", 3), (\\"inorder\\", 0), (\\"search\\", 3) ]) => [[3, 5, 8], [True], [5, 8], [False]]","solution":"class Node: def __init__(self, key): self.key = key self.left = None self.right = None class BST: def __init__(self): self.root = None def insert(self, key): self.root = self._insert_recursive(self.root, key) def _insert_recursive(self, node, key): if node is None: return Node(key) if key < node.key: node.left = self._insert_recursive(node.left, key) elif key > node.key: node.right = self._insert_recursive(node.right, key) return node def search(self, key): return self._search_recursive(self.root, key) is not None def _search_recursive(self, node, key): if node is None or node.key == key: return node if key < node.key: return self._search_recursive(node.left, key) else: return self._search_recursive(node.right, key) def delete(self, key): self.root = self._delete_recursive(self.root, key) def _delete_recursive(self, node, key): if node is None: return node if key < node.key: node.left = self._delete_recursive(node.left, key) elif key > node.key: node.right = self._delete_recursive(node.right, key) else: if node.left is None: return node.right elif node.right is None: return node.left temp = self._min_value_node(node.right) node.key = temp.key node.right = self._delete_recursive(node.right, temp.key) return node def _min_value_node(self, node): current = node while current.left is not None: current = current.left return current def inorder(self): result = [] self._inorder_recursive(self.root, result) return result def _inorder_recursive(self, node, result): if node is not None: self._inorder_recursive(node.left, result) result.append(node.key) self._inorder_recursive(node.right, result) def bst_operations(operations): bst = BST() results = [] for op, value in operations: if op == \\"insert\\": bst.insert(value) elif op == \\"delete\\": bst.delete(value) elif op == \\"search\\": results.append([bst.search(value)]) elif op == \\"inorder\\": results.append(bst.inorder()) return results"},{"question":"class Inventory: def __init__(self): # Initializes an empty inventory pass def add_product(self, product_id: str, name: str, category: str, quantity: int, price: float) -> None: Adds a new product to the inventory. Parameters: - product_id (str): Unique identifier for the product - name (str): Name of the product - category (str): Category of the product - quantity (int): Quantity of the product - price (float): Price of the product Raises: - ValueError: If product_id already exists pass def update_product(self, product_id: str, quantity: int, price: float) -> None: Updates the quantity and price of an existing product by its ID. Parameters: - product_id (str): Unique identifier for the product - quantity (int): Updated quantity of the product - price (float): Updated price of the product Raises: - ValueError: If product_id does not exist pass def get_product(self, product_id: str) -> dict: Retrieves the details of a product by its ID. Parameters: - product_id (str): Unique identifier for the product Returns: - dict: A dictionary containing product details with keys \\"product_id\\", \\"name\\", \\"category\\", \\"quantity\\", and \\"price\\" Raises: - ValueError: If product_id does not exist pass def get_products_by_category(self, category: str) -> list: Retrieves a list of all products in the specified category. Parameters: - category (str): The category to search for products Returns: - list: A list of dictionaries, each containing details of a product in the specified category pass # Unit tests import pytest def test_add_product(): inventory = Inventory() inventory.add_product(\\"101\\", \\"Widget A\\", \\"Widgets\\", 100, 2.99) product = inventory.get_product(\\"101\\") assert product[\\"product_id\\"] == \\"101\\" assert product[\\"name\\"] == \\"Widget A\\" assert product[\\"category\\"] == \\"Widgets\\" assert product[\\"quantity\\"] == 100 assert product[\\"price\\"] == 2.99 def test_add_product_duplicate_id(): inventory = Inventory() inventory.add_product(\\"101\\", \\"Widget A\\", \\"Widgets\\", 100, 2.99) with pytest.raises(ValueError) as excinfo: inventory.add_product(\\"101\\", \\"Widget B\\", \\"Widgets\\", 150, 3.49) assert \\"Product ID 101 already exists.\\" in str(excinfo.value) def test_update_product(): inventory = Inventory() inventory.add_product(\\"101\\", \\"Widget A\\", \\"Widgets\\", 100, 2.99) inventory.update_product(\\"101\\", 120, 2.95) product = inventory.get_product(\\"101\\") assert product[\\"quantity\\"] == 120 assert product[\\"price\\"] == 2.95 def test_update_non_existing_product(): inventory = Inventory() with pytest.raises(ValueError) as excinfo: inventory.update_product(\\"999\\", 100, 9.99) assert \\"Product ID 999 does not exist.\\" in str(excinfo.value) def test_get_product(): inventory = Inventory() inventory.add_product(\\"101\\", \\"Widget A\\", \\"Widgets\\", 100, 2.99) product = inventory.get_product(\\"101\\") assert product == { \\"product_id\\": \\"101\\", \\"name\\": \\"Widget A\\", \\"category\\": \\"Widgets\\", \\"quantity\\": 100, \\"price\\": 2.99 } def test_get_non_existing_product(): inventory = Inventory() with pytest.raises(ValueError) as excinfo: inventory.get_product(\\"999\\") assert \\"Product ID 999 does not exist.\\" in str(excinfo.value) def test_get_products_by_category(): inventory = Inventory() inventory.add_product(\\"101\\", \\"Widget A\\", \\"Widgets\\", 100, 2.99) inventory.add_product(\\"102\\", \\"Widget B\\", \\"Widgets\\", 150, 3.49) inventory.add_product(\\"201\\", \\"Gadget A\\", \\"Gadgets\\", 60, 12.99) widgets = inventory.get_products_by_category(\\"Widgets\\") assert len(widgets) == 2 assert widgets[0][\\"product_id\\"] == \\"101\\" assert widgets[1][\\"product_id\\"] == \\"102\\" def test_get_products_by_empty_category(): inventory = Inventory() inventory.add_product(\\"101\\", \\"Widget A\\", \\"Widgets\\", 100, 2.99) gadgets = inventory.get_products_by_category(\\"Gadgets\\") assert len(gadgets) == 0","solution":"class Inventory: def __init__(self): self.products = {} def add_product(self, product_id: str, name: str, category: str, quantity: int, price: float) -> None: if product_id in self.products: raise ValueError(f\\"Product ID {product_id} already exists.\\") self.products[product_id] = { \\"name\\": name, \\"category\\": category, \\"quantity\\": quantity, \\"price\\": price } def update_product(self, product_id: str, quantity: int, price: float) -> None: if product_id not in self.products: raise ValueError(f\\"Product ID {product_id} does not exist.\\") self.products[product_id][\\"quantity\\"] = quantity self.products[product_id][\\"price\\"] = price def get_product(self, product_id: str) -> dict: if product_id not in self.products: raise ValueError(f\\"Product ID {product_id} does not exist.\\") return {**{\\"product_id\\": product_id}, **self.products[product_id]} def get_products_by_category(self, category: str) -> list: return [ {**{\\"product_id\\": pid}, **details} for pid, details in self.products.items() if details[\\"category\\"] == category ]"},{"question":"def run_length_encoding(s: str) -> str: Implement a function that takes a string as input and returns its run-length encoded version. The run-length encoding involves replacing consecutive identical characters with the character followed by the count of consecutive occurrences. >>> run_length_encoding(\\"aaabbc\\") 'a3b2c1' >>> run_length_encoding(\\"abcd\\") 'a1b1c1d1' >>> run_length_encoding(\\"aAaaBBBb\\") 'a1A1a2B3b1' >>> run_length_encoding(\\"\\") '' >>> run_length_encoding(\\"zzzzz\\") 'z5'","solution":"def run_length_encoding(s: str) -> str: if not s: return \\"\\" encoded_str = [] count = 1 for i in range(1, len(s)): if s[i] == s[i - 1]: count += 1 else: encoded_str.append(s[i - 1] + str(count)) count = 1 encoded_str.append(s[-1] + str(count)) # Add the last run return \\"\\".join(encoded_str)"},{"question":"from typing import List, Dict def generate_daily_report(sensor_data: List[Dict]) -> Dict: Generate a daily summary report from a list of sensor data. The report includes total steps taken, average heart rate, and total calories burned. Args: sensor_data (List[Dict]): A list of dictionaries containing sensor data with \\"timestamp\\" and \\"data\\". Returns: Dict: A dictionary containing the daily summary report. Example: >>> sensor_data = [ ... {\\"timestamp\\": \\"2023-05-01T08:00:00Z\\", \\"data\\": {\\"steps\\": 100, \\"heart_rate\\": 80, \\"calories_burned\\": 5}}, ... {\\"timestamp\\": \\"2023-05-01T08:30:00Z\\", \\"data\\": {\\"steps\\": 150, \\"heart_rate\\": 85, \\"calories_burned\\": 7}}, ... {\\"timestamp\\": \\"2023-05-01T09:00:00Z\\", \\"data\\": {\\"steps\\": 200, \\"heart_rate\\": 78, \\"calories_burned\\": 8}}, ... {\\"timestamp\\": \\"2023-05-01T09:30:00Z\\", \\"data\\": {\\"steps\\": 50, \\"heart_rate\\": None, \\"calories_burned\\": 2}}, ... ] >>> generate_daily_report(sensor_data) {'total_steps': 500, 'average_heart_rate': 81, 'total_calories_burned': 22} pass def test_generate_daily_report(): sensor_data = [ {\\"timestamp\\": \\"2023-05-01T08:00:00Z\\", \\"data\\": {\\"steps\\": 100, \\"heart_rate\\": 80, \\"calories_burned\\": 5}}, {\\"timestamp\\": \\"2023-05-01T08:30:00Z\\", \\"data\\": {\\"steps\\": 150, \\"heart_rate\\": 85, \\"calories_burned\\": 7}}, {\\"timestamp\\": \\"2023-05-01T09:00:00Z\\", \\"data\\": {\\"steps\\": 200, \\"heart_rate\\": 78, \\"calories_burned\\": 8}}, {\\"timestamp\\": \\"2023-05-01T09:30:00Z\\", \\"data\\": {\\"steps\\": 50, \\"heart_rate\\": None, \\"calories_burned\\": 2}}, ] expected_output = { \\"total_steps\\": 500, \\"average_heart_rate\\": 81, \\"total_calories_burned\\": 22 } assert generate_daily_report(sensor_data) == expected_output def test_generate_daily_report_with_missing_fields(): sensor_data = [ {\\"timestamp\\": \\"2023-05-01T08:00:00Z\\", \\"data\\": {\\"steps\\": 100, \\"heart_rate\\": 80}}, {\\"timestamp\\": \\"2023-05-01T08:30:00Z\\", \\"data\\": {\\"calories_burned\\": 7}}, {\\"timestamp\\": \\"2023-05-01T09:00:00Z\\", \\"data\\": {\\"heart_rate\\": 78, \\"calories_burned\\": 8}}, {\\"timestamp\\": \\"2023-05-01T09:30:00Z\\", \\"data\\": {\\"steps\\": 50}}, ] expected_output = { \\"total_steps\\": 150, \\"average_heart_rate\\": 79, \\"total_calories_burned\\": 15 } assert generate_daily_report(sensor_data) == expected_output def test_generate_daily_report_no_data_points(): sensor_data = [] expected_output = { \\"total_steps\\": 0, \\"average_heart_rate\\": 0, \\"total_calories_burned\\": 0 } assert generate_daily_report(sensor_data) == expected_output def test_generate_daily_report_all_missing_heart_rate(): sensor_data = [ {\\"timestamp\\": \\"2023-05-01T08:00:00Z\\", \\"data\\": {\\"steps\\": 100, \\"calories_burned\\": 5}}, {\\"timestamp\\": \\"2023-05-01T08:30:00Z\\", \\"data\\": {\\"steps\\": 150, \\"calories_burned\\": 7}}, ] expected_output = { \\"total_steps\\": 250, \\"average_heart_rate\\": 0, \\"total_calories_burned\\": 12 } assert generate_daily_report(sensor_data) == expected_output","solution":"from typing import List, Dict def generate_daily_report(sensor_data: List[Dict]) -> Dict: total_steps = 0 total_heart_rate = 0 heart_rate_count = 0 total_calories_burned = 0 for entry in sensor_data: data = entry.get(\\"data\\", {}) steps = data.get(\\"steps\\", 0) heart_rate = data.get(\\"heart_rate\\") calories_burned = data.get(\\"calories_burned\\", 0) total_steps += steps if heart_rate is not None: total_heart_rate += heart_rate heart_rate_count += 1 total_calories_burned += calories_burned average_heart_rate = round(total_heart_rate / heart_rate_count) if heart_rate_count > 0 else 0 return { \\"total_steps\\": total_steps, \\"average_heart_rate\\": average_heart_rate, \\"total_calories_burned\\": total_calories_burned }"},{"question":"class Node: def __init__(self, char): self.char = char self.left = None self.equal = None self.right = None self.is_end_of_word = False class TernarySearchTree: def __init__(self): Initialize the TST with the root set as None. pass def insert(self, word: str) -> None: Insert a word into the TST. :param word: A string to be inserted into the TST. pass def search(self, word: str) -> bool: Search for a word in the TST. :param word: A string to search for in the TST. :return: \`True\` if the word is found in the TST, otherwise \`False\`. pass # Example Usage if __name__ == \\"__main__\\": tst = TernarySearchTree() tst.insert(\\"apple\\") tst.insert(\\"app\\") tst.insert(\\"orange\\") print(tst.search(\\"apple\\")) # Expected Output: True print(tst.search(\\"app\\")) # Expected Output: True print(tst.search(\\"orange\\")) # Expected Output: True print(tst.search(\\"banana\\")) # Expected Output: False","solution":"class Node: def __init__(self, char): self.char = char self.left = None self.equal = None self.right = None self.is_end_of_word = False class TernarySearchTree: def __init__(self): Initialize the TST with the root set as None. self.root = None def _insert(self, node, word, index): char = word[index] if node is None: node = Node(char) if char < node.char: node.left = self._insert(node.left, word, index) elif char > node.char: node.right = self._insert(node.right, word, index) else: if index + 1 == len(word): node.is_end_of_word = True else: node.equal = self._insert(node.equal, word, index + 1) return node def insert(self, word): Insert a word into the TST. :param word: A string to be inserted into the TST. if word: self.root = self._insert(self.root, word, 0) def _search(self, node, word, index): if node is None: return False char = word[index] if char < node.char: return self._search(node.left, word, index) elif char > node.char: return self._search(node.right, word, index) else: if index + 1 == len(word): return node.is_end_of_word return self._search(node.equal, word, index + 1) def search(self, word): Search for a word in the TST. :param word: A string to search for in the TST. :return: \`True\` if the word is found in the TST, otherwise \`False\`. if word: return self._search(self.root, word, 0) return False"},{"question":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def construct_balanced_bst(sorted_list): Construct a balanced binary search tree (BST) from a sorted list of integers. Args: sorted_list (List[int]): A list of integers sorted in ascending order. Returns: TreeNode: The root node of the balanced BST. Example: >>> sorted_list = [-10, -3, 0, 5, 9] >>> root = construct_balanced_bst(sorted_list) >>> def inorder_traversal(root): ... if root is None: ... return [] ... return inorder_traversal(root.left) + [root.value] + inorder_traversal(root.right) >>> inorder_traversal(root) [-10, -3, 0, 5, 9] # Your implementation here # Test cases def inorder_traversal(root): return inorder_traversal(root.left) + [root.value] + inorder_traversal(root.right) if root else [] def test_construct_balanced_bst(): sorted_list = [-10, -3, 0, 5, 9] root = construct_balanced_bst(sorted_list) assert inorder_traversal(root) == sorted_list def test_single_element(): sorted_list = [1] root = construct_balanced_bst(sorted_list) assert inorder_traversal(root) == sorted_list def test_empty_list(): sorted_list = [] root = construct_balanced_bst(sorted_list) assert inorder_traversal(root) == sorted_list def test_large_list(): sorted_list = list(range(-100000, 100001)) root = construct_balanced_bst(sorted_list) assert inorder_traversal(root) == sorted_list","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def construct_balanced_bst(sorted_list): if not sorted_list: return None def build_bst(start, end): if start > end: return None mid = (start + end) // 2 node = TreeNode(value=sorted_list[mid]) node.left = build_bst(start, mid - 1) node.right = build_bst(mid + 1, end) return node return build_bst(0, len(sorted_list) - 1)"},{"question":"def infix_to_postfix(expression: str) -> str: Convert an infix expression to postfix (Reverse Polish Notation). >>> infix_to_postfix(\\"a+b*(c^d-e)^(f+g*h)-i\\") \\"abcd^e-fgh*+^*+i-\\" >>> infix_to_postfix(\\"(a+b)*c\\") \\"ab+c*\\" >>> infix_to_postfix(\\"a\\") \\"a\\" >>> infix_to_postfix(\\"a+b*c\\") \\"abc*+\\" >>> infix_to_postfix(\\"a+b*c/d-e\\") \\"abc*d/+e-\\"","solution":"def infix_to_postfix(expression: str) -> str: precedence = {'+': 1, '-': 1, '*': 2, '/': 2, '^': 3} output = [] stack = [] for char in expression: if char.isalnum(): # operand (letter or digit) output.append(char) elif char == '(': # left parenthesis stack.append(char) elif char == ')': # right parenthesis while stack and stack[-1] != '(': output.append(stack.pop()) stack.pop() # Remove '(' from stack else: # operator while stack and stack[-1] != '(' and precedence[char] <= precedence.get(stack[-1], 0): output.append(stack.pop()) stack.append(char) while stack: output.append(stack.pop()) return ''.join(output)"},{"question":"from typing import List def mark_regions(matrix: List[List[int]]) -> None: Mark regions in a binary matrix. :param matrix: 2D binary matrix (list of lists) :type matrix: List[List[int]] pass # Example usage matrix = [ [1, 1, 0, 0, 0], [1, 0, 0, 1, 1], [0, 0, 1, 0, 0], [0, 1, 1, 1, 0] ] mark_regions(matrix) print(matrix) # Expected Output: # [ # [2, 2, 0, 0, 0], # [2, 0, 0, 3, 3], # [0, 0, 4, 0, 0], # [0, 4, 4, 4, 0] # ] def test_mark_regions(): matrix1 = [ [1, 1, 0, 0, 0], [1, 0, 0, 1, 1], [0, 0, 1, 0, 0], [0, 1, 1, 1, 0] ] expected1 = [ [2, 2, 0, 0, 0], [2, 0, 0, 3, 3], [0, 0, 4, 0, 0], [0, 4, 4, 4, 0] ] matrix2 = [ [1, 0, 0], [0, 1, 1], [0, 1, 0] ] expected2 = [ [2, 0, 0], [0, 3, 3], [0, 3, 0] ] matrix3 = [ [0, 0, 0], [0, 0, 0], [0, 0, 0] ] expected3 = [ [0, 0, 0], [0, 0, 0], [0, 0, 0] ] matrix4 = [ [1, 1, 1, 1, 1] ] expected4 = [ [2, 2, 2, 2, 2] ] matrix5 = [ [1, 0, 1], [0, 1, 0], [1, 0, 1] ] expected5 = [ [2, 0, 3], [0, 4, 0], [5, 0, 6] ] mark_regions(matrix1) assert matrix1 == expected1 mark_regions(matrix2) assert matrix2 == expected2 mark_regions(matrix3) assert matrix3 == expected3 mark_regions(matrix4) assert matrix4 == expected4 mark_regions(matrix5) assert matrix5 == expected5","solution":"from typing import List def mark_regions(matrix: List[List[int]]) -> None: Mark regions in a binary matrix using Depth-First Search (DFS). :param matrix: 2D binary matrix (list of lists) :type matrix: List[List[int]] def dfs(matrix, i, j, region_id): # directions: N, E, S, W directions = [(-1, 0), (0, 1), (1, 0), (0, -1)] stack = [(i, j)] while stack: x, y = stack.pop() for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < len(matrix) and 0 <= ny < len(matrix[0]) and matrix[nx][ny] == 1: matrix[nx][ny] = region_id stack.append((nx, ny)) region_id = 2 # Start labeling regions from 2 for i in range(len(matrix)): for j in range(len(matrix[0])): if matrix[i][j] == 1: matrix[i][j] = region_id dfs(matrix, i, j, region_id) region_id += 1"},{"question":"from typing import List, Tuple def max_non_overlapping_sessions(sessions: List[Tuple[int, int]]) -> int: Determines the maximum number of non-overlapping sessions that can be scheduled. Parameters: sessions (List[Tuple[int, int]]): A list of tuples where each tuple contains the start and end time of a session. Returns: int: The maximum number of non-overlapping sessions. Example: >>> max_non_overlapping_sessions([(1, 4), (2, 5), (3, 6), (7, 8), (8, 9)]) 3 >>> max_non_overlapping_sessions([(1, 2), (2, 3), (1, 3)]) 2 >>> max_non_overlapping_sessions([(1, 3), (3, 5), (5, 7)]) 3","solution":"from typing import List, Tuple def max_non_overlapping_sessions(sessions: List[Tuple[int, int]]) -> int: Determines the maximum number of non-overlapping sessions that can be scheduled. Parameters: sessions (List[Tuple[int, int]]): A list of tuples where each tuple contains the start and end time of a session. Returns: int: The maximum number of non-overlapping sessions. if not sessions: return 0 # Sort the sessions by their end times sessions.sort(key=lambda x: x[1]) max_sessions = 0 last_end_time = 0 for start, end in sessions: if start >= last_end_time: max_sessions += 1 last_end_time = end return max_sessions"},{"question":"def find_minimum(nums): Finds the minimum element in a sorted, rotated array. Args: nums (List[int]): The input list of integers. Returns: int: The minimum element in the list. Example: >>> find_minimum([3, 4, 5, 1, 2]) 1 >>> find_minimum([4, 5, 6, 7, 0, 1, 2]) 0 >>> find_minimum([11, 13, 15, 17]) 11 >>> find_minimum([2, 1]) 1 >>> find_minimum([2]) 2 pass import pytest def test_find_minimum(): assert find_minimum([3, 4, 5, 1, 2]) == 1 assert find_minimum([4, 5, 6, 7, 0, 1, 2]) == 0 assert find_minimum([11, 13, 15, 17]) == 11 assert find_minimum([2, 1]) == 1 assert find_minimum([2]) == 2 def test_find_minimum_not_rotated(): assert find_minimum([1, 2, 3, 4, 5]) == 1 assert find_minimum([1]) == 1 assert find_minimum([-4, -3, -2, -1, 0, 1, 2, 3, 4]) == -4 def test_find_minimum_large_range(): assert find_minimum(list(range(1000000, 2*1000000))) == 1000000 assert find_minimum(list(range(500000, 1000000)) + list(range(500000))) == 0 def test_find_minimum_with_duplicates(): assert find_minimum([3, 4, 5, 5, 1, 1, 2, 2]) == 1 def test_find_minimum_all_identical(): assert find_minimum([1, 1, 1, 1]) == 1 def test_find_minimum_empty(): with pytest.raises(ValueError): find_minimum([]) # Execute the test cases pytest.main()","solution":"def find_minimum(nums): Finds the minimum element in a sorted, rotated array. Args: nums (List[int]): The input list of integers. Returns: int: The minimum element in the list. if not nums: raise ValueError(\\"nums must contain at least one element\\") left, right = 0, len(nums) - 1 # If the array is not rotated (the smallest element is at the front) if nums[left] < nums[right]: return nums[left] while left < right: mid = (left + right) // 2 if nums[mid] > nums[right]: left = mid + 1 else: right = mid return nums[left]"},{"question":"from collections import defaultdict, deque class TaskScheduler: def __init__(self): Initialize the TaskScheduler with an empty graph and in-degrees. self.graph = defaultdict(list) self.in_degree = defaultdict(int) self.tasks = set() def add_task(self, task_id: int, dependencies: list[int]): Add a task with its dependencies to the TaskScheduler. Args: task_id (int): The unique identifier for the task. dependencies (list[int]): A list of task IDs that the task depends on. pass def can_schedule(self) -> bool: Determine if the tasks can be scheduled without dependency conflicts. Returns: bool: True if the tasks can be scheduled without dependency conflicts, otherwise False. pass def get_schedule(self) -> list[int]: Generate a valid task schedule based on dependencies. Returns: list[int]: A list of task IDs in order satisfying the dependencies, or an empty list if scheduling is not possible due to cyclic dependencies. pass","solution":"from collections import defaultdict, deque class TaskScheduler: def __init__(self): # Initialize the graph and in-degrees self.graph = defaultdict(list) self.in_degree = defaultdict(int) self.tasks = set() def add_task(self, task_id: int, dependencies: list[int]): # Update the graph and in-degrees if task_id not in self.tasks: self.tasks.add(task_id) self.in_degree[task_id] = 0 for dep in dependencies: self.graph[dep].append(task_id) self.in_degree[task_id] += 1 if dep not in self.tasks: self.tasks.add(dep) self.in_degree[dep] = 0 def can_schedule(self) -> bool: # Check if a valid schedule exists using Kahn's algorithm for topological sorting in_degree_copy = self.in_degree.copy() zero_in_degree_queue = deque([task for task in self.tasks if in_degree_copy[task] == 0]) visited_count = 0 while zero_in_degree_queue: current = zero_in_degree_queue.popleft() visited_count += 1 for neighbor in self.graph[current]: in_degree_copy[neighbor] -= 1 if in_degree_copy[neighbor] == 0: zero_in_degree_queue.append(neighbor) return visited_count == len(self.tasks) def get_schedule(self) -> list[int]: if not self.can_schedule(): return [] # Generate the order using Kahn's algorithm in_degree_copy = self.in_degree.copy() zero_in_degree_queue = deque([task for task in self.tasks if in_degree_copy[task] == 0]) result = [] while zero_in_degree_queue: current = zero_in_degree_queue.popleft() result.append(current) for neighbor in self.graph[current]: in_degree_copy[neighbor] -= 1 if in_degree_copy[neighbor] == 0: zero_in_degree_queue.append(neighbor) return result"},{"question":"def longest_subarray_with_sum(nums: list[int], target_sum: int) -> int: Find the longest subarray (contiguous sequence of elements) in the array that sums up to the target sum. >>> longest_subarray_with_sum([1, -1, 5, -2, 3], 3) 4 >>> longest_subarray_with_sum([-2, -1, 2, 1], 1) 2 >>> longest_subarray_with_sum([1, 2, 3], 6) 3 >>> longest_subarray_with_sum([1, 2, 3], 7) 0 pass","solution":"def longest_subarray_with_sum(nums, target_sum): sum_indices = {0: -1} # Dictionary to store cumulative sums and their earliest index max_length = 0 cumulative_sum = 0 for i in range(len(nums)): cumulative_sum += nums[i] if cumulative_sum - target_sum in sum_indices: max_length = max(max_length, i - sum_indices[cumulative_sum - target_sum]) if cumulative_sum not in sum_indices: sum_indices[cumulative_sum] = i return max_length"},{"question":"def calculate_total_size(directory: dict) -> int: Traverses the nested directory structure and returns the total size of all unique files. >>> example = { ... \\"dir1\\": { ... \\"file1\\": 100, ... \\"file2\\": 200, ... \\"dir2\\": { ... \\"file3\\": 300, ... \\"file4\\": 400 ... } ... }, ... \\"file1\\": 100, ... \\"file5\\": 500 ... } >>> calculate_total_size(example) 1500 import pytest def test_single_file(): directory = {\\"file1\\": 100} assert calculate_total_size(directory) == 100 def test_nested_directories(): directory = { \\"dir1\\": { \\"file1\\": 100, \\"file2\\": 200, \\"dir2\\": { \\"file3\\": 300, \\"file4\\": 400, } }, \\"dir3\\": { \\"file5\\": 500, } } assert calculate_total_size(directory) == 1500 def test_duplicate_files(): directory = { \\"dir1\\": { \\"file1\\": 100, \\"dir2\\": { \\"file1\\": 100, \\"file2\\": 200, } }, \\"file1\\": 100, \\"file2\\": 200 } assert calculate_total_size(directory) == 300 def test_empty_directory(): directory = {} assert calculate_total_size(directory) == 0 def test_mixed_structure(): directory = { \\"dir1\\": { \\"file1\\": 50, \\"file2\\": 150, }, \\"file1\\": 50, \\"subdir\\": { \\"file3\\": 300 } } assert calculate_total_size(directory) == 500","solution":"def calculate_total_size(directory: dict) -> int: Traverses the nested directory structure and returns the total size of all unique files. def traverse(dir, seen_files): total_size = 0 for key, value in dir.items(): if isinstance(value, dict): # Recurse into sub-directory total_size += traverse(value, seen_files) elif isinstance(value, int): # It's a file, check if it's already seen if key not in seen_files: seen_files.add(key) total_size += value return total_size seen_files = set() return traverse(directory, seen_files)"},{"question":"class AVLTreeNode: def __init__(self, value): self.value = value self.left = None self.right = None self.height = 1 class AVLTree: def __init__(self): self.root = None def insert(self, value): Insert a value into the AVL Tree and balance the tree. >>> avl_tree = AVLTree() >>> avl_tree.insert(10) >>> avl_tree.insert(20) >>> in_order_traversal(avl_tree.root) [10, 20] pass # Implement insertion logic here def delete(self, value): Delete a value from the AVL Tree and balance the tree. >>> avl_tree = AVLTree() >>> avl_tree.insert(10) >>> avl_tree.insert(20) >>> avl_tree.delete(10) >>> in_order_traversal(avl_tree.root) [20] pass # Implement deletion logic here def in_order_traversal(root): Helper function to perform in-order traversal of the tree. >>> avl_tree = AVLTree() >>> avl_tree.insert(10) >>> avl_tree.insert(20) >>> in_order_traversal(avl_tree.root) [10, 20] if not root: return [] return in_order_traversal(root.left) + [root.value] + in_order_traversal(root.right)","solution":"class AVLTreeNode: def __init__(self, value): self.value = value self.left = None self.right = None self.height = 1 class AVLTree: def __init__(self): self.root = None def insert(self, value): self.root = self._insert(self.root, value) def delete(self, value): self.root = self._delete(self.root, value) def _insert(self, node, value): if not node: return AVLTreeNode(value) if value < node.value: node.left = self._insert(node.left, value) else: node.right = self._insert(node.right, value) node.height = 1 + max(self._get_height(node.left), self._get_height(node.right)) balance = self._get_balance(node) if balance > 1 and value < node.left.value: return self._right_rotate(node) if balance < -1 and value > node.right.value: return self._left_rotate(node) if balance > 1 and value > node.left.value: node.left = self._left_rotate(node.left) return self._right_rotate(node) if balance < -1 and value < node.right.value: node.right = self._right_rotate(node.right) return self._left_rotate(node) return node def _delete(self, node, value): if not node: return node if value < node.value: node.left = self._delete(node.left, value) elif value > node.value: node.right = self._delete(node.right, value) else: if not node.left: return node.right elif not node.right: return node.left temp = self._get_min_value_node(node.right) node.value = temp.value node.right = self._delete(node.right, temp.value) node.height = 1 + max(self._get_height(node.left), self._get_height(node.right)) balance = self._get_balance(node) if balance > 1 and self._get_balance(node.left) >= 0: return self._right_rotate(node) if balance > 1 and self._get_balance(node.left) < 0: node.left = self._left_rotate(node.left) return self._right_rotate(node) if balance < -1 and self._get_balance(node.right) <= 0: return self._left_rotate(node) if balance < -1 and self._get_balance(node.right) > 0: node.right = self._right_rotate(node.right) return self._left_rotate(node) return node def _left_rotate(self, z): y = z.right T2 = y.left y.left = z z.right = T2 z.height = 1 + max(self._get_height(z.left), self._get_height(z.right)) y.height = 1 + max(self._get_height(y.left), self._get_height(y.right)) return y def _right_rotate(self, z): y = z.left T3 = y.right y.right = z z.left = T3 z.height = 1 + max(self._get_height(z.left), self._get_height(z.right)) y.height = 1 + max(self._get_height(y.left), self._get_height(y.right)) return y def _get_height(self, node): if not node: return 0 return node.height def _get_balance(self, node): if not node: return 0 return self._get_height(node.left) - self._get_height(node.right) def _get_min_value_node(self, node): current = node while current.left is not None: current = current.left return current"},{"question":"from typing import List def most_frequent_sales(sales: List[int]) -> int: :param sales: List of integers representing sales made by different salespersons. :return: Integer value that occurred most frequently (smallest one in case of a tie). pass # Example Test Cases def test_single_value_list(): assert most_frequent_sales([500]) == 500 def test_multiple_frequencies_single_max(): assert most_frequent_sales([500, 900, 800, 500, 1200, 800, 800]) == 800 def test_multiple_frequencies_with_tie(): assert most_frequent_sales([300, 200, 200, 300, 100, 100, 100]) == 100 def test_all_elements_same(): assert most_frequent_sales([300, 300, 300, 300, 300]) == 300 def test_two_elements(): assert most_frequent_sales([500, 500, 600, 600, 600]) == 600 def test_large_input(): sales = [1] * 50000 + [2] * 50000 assert most_frequent_sales(sales) == 1 def test_distinct_elements(): assert most_frequent_sales([1, 2, 3, 4, 5]) == 1 def test_mixed_entries(): assert most_frequent_sales([2, 2, 3, 3, 1, 1, 1]) == 1 def test_repeated_entries(): assert most_frequent_sales([5, 5, 5, 2, 2, 2, 3]) == 2","solution":"from collections import Counter def most_frequent_sales(sales: list) -> int: Returns the sales value that occurred most frequently in the sales list. If there is a tie, returns the smallest sales value among those with highest frequency. :param sales: List of integers representing sales made by different salespersons. :return: Integer value that occurred most frequently (smallest one in case of a tie). # Count the frequency of each sales value sales_count = Counter(sales) # Find the maximum frequency max_frequency = max(sales_count.values()) # Get all sales values with the maximum frequency most_frequent_sales_values = [key for key, count in sales_count.items() if count == max_frequency] # Return the smallest sales value among those with the highest frequency return min(most_frequent_sales_values)"},{"question":"def validate_sequence(seq: List[int], replacements: int) -> bool: Determine whether a given sequence of integers can be transformed into a non-decreasing sequence by replacing at most a certain number of elements. >>> validate_sequence([4, 2, 3], 1) # True >>> validate_sequence([4, 2, 1], 1) # False >>> validate_sequence([3, 4, 2, 3], 1) # False >>> validate_sequence([5, 1, 2, 3], 2) # True >>> validate_sequence([1, 3, 2, 4], 1) # True def test_validate_sequence_example_cases(): assert validate_sequence([4, 2, 3], 1) == True assert validate_sequence([4, 2, 1], 1) == False assert validate_sequence([3, 4, 2, 3], 1) == False assert validate_sequence([5, 1, 2, 3], 2) == True assert validate_sequence([1, 3, 2, 4], 1) == True def test_validate_sequence_no_replacements_needed(): assert validate_sequence([1, 2, 3, 4, 5], 0) == True assert validate_sequence([1], 0) == True def test_validate_sequence_minimal_replacements_needed(): assert validate_sequence([1, 5, 3, 4], 1) == True assert validate_sequence([10, 1, 2, 3, 4, 5], 1) == True def test_validate_sequence_edge_cases(): assert validate_sequence([5, 4, 3, 2, 1], 4) == True assert validate_sequence([5, 4, 3, 2, 1], 3) == False def test_validate_sequence_various_lengths(): assert validate_sequence([1, 3, 2, 4, 5, 6], 1) == True assert validate_sequence([1, 3, 2, 4, 2, 6], 2) == True assert validate_sequence([3, 2, 1], 2) == True assert validate_sequence([3, 2, 1], 1) == False","solution":"def validate_sequence(seq, replacements): n = len(seq) count = 0 for i in range(n - 1): if seq[i] > seq[i + 1]: count += 1 if count > replacements: return False if i > 0 and seq[i - 1] > seq[i + 1]: seq[i + 1] = seq[i] else: seq[i] = seq[i + 1] return True"},{"question":"def categorize_vehicles_by_speed(vehicle_data: list[tuple[str, int]]) -> dict[str, list[str]]: Categorize vehicles based on their speed. Args: vehicle_data (list[tuple[str, int]]): List of tuples where each tuple contains a vehicle type (string) and its speed (integer in km/h). Returns: dict[str, list[str]]: Dictionary with keys \\"slow\\", \\"medium\\", \\"fast\\" and values are lists of vehicle types. Example: >>> categorize_vehicles_by_speed([(\\"bicycle\\", 15), (\\"car\\", 80), (\\"motorbike\\", 120), (\\"train\\", 130)]) {'slow': ['bicycle'], 'medium': ['car', 'motorbike'], 'fast': ['train']} >>> categorize_vehicles_by_speed([(\\"scooter\\", 50), (\\"jet\\", 900), (\\"horse\\", 30), (\\"plane\\", 890)]) {'slow': ['scooter', 'horse'], 'medium': [], 'fast': ['jet', 'plane']} pass","solution":"def categorize_vehicles_by_speed(vehicle_data): Categorize vehicles based on their speed. Args: vehicle_data (list of tuple): List of tuples where each tuple contains a vehicle type (string) and its speed (integer in km/h). Returns: dict: Dictionary with keys \\"slow\\", \\"medium\\", \\"fast\\" and values are lists of vehicle types. categories = {\\"slow\\": [], \\"medium\\": [], \\"fast\\": []} for vehicle, speed in vehicle_data: if speed < 60: categories[\\"slow\\"].append(vehicle) elif speed < 120: categories[\\"medium\\"].append(vehicle) else: categories[\\"fast\\"].append(vehicle) return categories"},{"question":"def graph_coloring(num_nodes: int, edges: list[tuple[int, int]]) -> tuple[int, list[int]]: Determine the minimum number of colors required to color a given undirected graph such that no two adjacent vertices share the same color. >>> graph_coloring(4, [(0, 1), (1, 2), (2, 3), (3, 0), (0, 2)]) (3, [0, 1, 2, 1]) >>> graph_coloring(3, [(0, 1), (1, 2), (2, 0)]) (3, [0, 1, 2]) >>> graph_coloring(5, [(0, 1), (1, 2), (2, 3), (3, 4), (4, 0)]) (3, [0, 1, 2, 1, 0])","solution":"def graph_coloring(num_nodes, edges): def greedy_coloring(num_nodes, adj_list): result = [-1] * num_nodes available = [False] * num_nodes result[0] = 0 for u in range(1, num_nodes): for i in adj_list[u]: if result[i] != -1: available[result[i]] = True cr = 0 while cr < num_nodes and available[cr]: cr += 1 result[u] = cr for i in adj_list[u]: if result[i] != -1: available[result[i]] = False return result adj_list = [[] for _ in range(num_nodes)] for u, v in edges: adj_list[u].append(v) adj_list[v].append(u) coloring = greedy_coloring(num_nodes, adj_list) num_colors = max(coloring) + 1 return num_colors, coloring"},{"question":"from typing import List def top_k_frequent(s: str, k: int) -> List[str]: Identifies the k most frequent characters in the string and returns them in descending order based on their frequency. If two characters have the same frequency, order them lexicographically. :param s: Input string containing lowercase letters. :param k: Number of top frequent characters to return. :return: List of k characters in descending order of their frequency. >>> top_k_frequent(\\"aabbccdd\\", 2) ['a', 'b'] >>> top_k_frequent(\\"aabbccdd\\", 3) ['a', 'b', 'c'] >>> top_k_frequent(\\"abcabcabc\\", 1) ['a'] >>> top_k_frequent(\\"\\", 1) [] >>> top_k_frequent(\\"abcdef\\", 3) ['a', 'b', 'c'] >>> top_k_frequent(\\"abcdef\\", 6) ['a', 'b', 'c', 'd', 'e', 'f'] >>> top_k_frequent(\\"abcdef\\", 10) ['a', 'b', 'c', 'd', 'e', 'f'] >>> top_k_frequent(\\"a\\" * 50000 + \\"b\\" * 30000 + \\"c\\" * 20000, 2) ['a', 'b'] >>> top_k_frequent(\\"a\\" * 50000 + \\"b\\" * 30000 + \\"c\\" * 20000, 3) ['a', 'b', 'c'] >>> top_k_frequent(\\"aaabbbccc\\", 2) ['a', 'b'] >>> top_k_frequent(\\"cccaaaabbbb\\", 2) ['a', 'b'] use efficient data structures and algorithms to handle large string lengths. Consider edge cases such an empty string, strings have multiple characters same frequency","solution":"from collections import Counter def top_k_frequent(s, k): Identifies the k most frequent characters in the string and returns them in descending order based on their frequency. If two characters have the same frequency, order them lexicographically. :param s: Input string containing lowercase letters. :param k: Number of top frequent characters to return. :return: List of k characters in descending order of their frequency. # Count frequency of each character in the string freq = Counter(s) # Sort characters first by frequency (descending) then lexicographically (ascending) sorted_chars = sorted(freq.keys(), key=lambda x: (-freq[x], x)) # Return the top k characters return sorted_chars[:k]"},{"question":"from typing import List def max_profit(arr: List[int]) -> int: Computes the maximum possible profit from a single buy-sell transaction. If no profit can be made, returns 0. Examples: >>> max_profit([7, 1, 5, 3, 6, 4]) 5 >>> max_profit([7, 6, 4, 3, 1]) 0","solution":"from typing import List def max_profit(arr: List[int]) -> int: Computes the maximum possible profit from a single buy-sell transaction. If no profit can be made, returns 0. if len(arr) < 2: return 0 # no profit can be made with less than 2 prices min_price = float('inf') max_profit = 0 for price in arr: if price < min_price: min_price = price potential_profit = price - min_price if potential_profit > max_profit: max_profit = potential_profit return max_profit"},{"question":"def alternating_case(s: str) -> str: Converts each character in a string to alternating case, starting with uppercase for characters at even positions (0-indexed) and lowercase for characters at odd positions. >>> alternating_case(\\"hello\\") 'HeLlO' >>> alternating_case(\\"PyThOn\\") 'PyThOn' >>> alternating_case(\\"ALTERNATINGcase\\") 'AlTeRnAtInGcAsE'","solution":"def alternating_case(s: str) -> str: Converts each character in a string to alternating case, starting with uppercase for characters at even positions (0-indexed) and lowercase for characters at odd positions. result = [] for i, char in enumerate(s): if i % 2 == 0: result.append(char.upper()) else: result.append(char.lower()) return ''.join(result)"},{"question":"from sklearn.feature_extraction.text import TfidfVectorizer from sklearn.cluster import KMeans import numpy as np def text_kmeans_clustering(docs: list[str], k: int) -> list[int]: Perform K-Means clustering on a list of text documents based on their TF-IDF features. Parameters: docs (list[str]): A list of text documents. k (int): The number of clusters for the K-Means algorithm. Returns: list[int]: A list of integers where each index represents the cluster assignment of the corresponding document in \`docs\`. Examples: >>> text_kmeans_clustering([ ... \\"This is a document about machine learning.\\", ... \\"Machine learning involves models and data.\\", ... \\"This document is about natural language processing.\\", ... \\"Natural language processing and machine learning are closely related.\\" ... ], 2) [0, 0, 1, 1] >>> text_kmeans_clustering([ ... \\"Apple is a fruit.\\", ... \\"Banana is also a fruit.\\", ... \\"Apple and Banana are fruits.\\", ... \\"Computers are electronic devices.\\", ... \\"Laptops are a type of computer.\\" ... ], 3) [0, 0, 0, 1, 1] # Unit tests def test_text_kmeans_clustering_example_1(): docs = [ \\"This is a document about machine learning.\\", \\"Machine learning involves models and data.\\", \\"This document is about natural language processing.\\", \\"Natural language processing and machine learning are closely related.\\" ] k = 2 result = text_kmeans_clustering(docs, k) assert isinstance(result, list) assert len(result) == len(docs) assert set(result) == {0, 1} def test_text_kmeans_clustering_example_2(): docs = [ \\"Apple is a fruit.\\", \\"Banana is also a fruit.\\", \\"Apple and Banana are fruits.\\", \\"Computers are electronic devices.\\", \\"Laptops are a type of computer.\\" ] k = 3 result = text_kmeans_clustering(docs, k) assert isinstance(result, list) assert len(result) == len(docs) assert len(set(result)) == 3 def test_empty_string_documents(): docs = [\\"\\", \\"\\", \\"\\", \\"\\"] k = 2 try: text_kmeans_clustering(docs, k) assert False, \\"Expected ValueError for empty strings\\" except ValueError: pass def test_invalid_k_greater_than_docs(): docs = [\\"doc1\\", \\"doc2\\", \\"doc3\\"] k = 4 try: text_kmeans_clustering(docs, k) assert False, \\"Expected ValueError for k greater than number of documents\\" except ValueError: pass def test_invalid_k_non_positive(): docs = [\\"doc1\\", \\"doc2\\", \\"doc3\\"] k = 0 try: text_kmeans_clustering(docs, k) assert False, \\"Expected ValueError for non-positive k\\" except ValueError: pass def test_invalid_docs_not_all_strings(): docs = [\\"doc1\\", 123, \\"doc3\\"] k = 2 try: text_kmeans_clustering(docs, k) assert False, \\"Expected ValueError for non-string elements in docs\\" except ValueError: pass","solution":"from sklearn.feature_extraction.text import TfidfVectorizer from sklearn.cluster import KMeans import numpy as np def text_kmeans_clustering(docs: list[str], k: int) -> list[int]: if not isinstance(docs, list) or not all(isinstance(doc, str) for doc in docs): raise ValueError(\\"docs must be a list of strings.\\") if not isinstance(k, int) or k <= 0 or k > len(docs): raise ValueError(\\"k must be a positive integer and less than or equal to the number of documents.\\") # Initialize TfidfVectorizer vectorizer = TfidfVectorizer(stop_words='english', lowercase=True) tfidf_matrix = vectorizer.fit_transform(docs) # Perform K-Means clustering kmeans = KMeans(n_clusters=k, random_state=42) kmeans.fit(tfidf_matrix) # Return the cluster assignments return kmeans.labels_.tolist()"},{"question":"class BinarySearchTree: def __init__(self): Initialize an empty Binary Search Tree. self.root = None def insert(self, value: int): Inserts a value into the binary search tree. Parameters: value (int): The value to be inserted. # TODO: Implement the insert method to add value to the BST. def get_depth(self) -> int: Returns the current depth of the binary search tree. Returns: int: The depth of the tree. # TODO: Implement the get_depth method to calculate the depth of the BST. # Example Usage if __name__ == \\"__main__\\": bst = BinarySearchTree() bst.insert(10) bst.insert(5) bst.insert(15) bst.insert(3) bst.insert(7) print(bst.get_depth()) # Expected output: 3 # Unit Tests def test_insert_and_depth(): bst = BinarySearchTree() bst.insert(10) bst.insert(5) bst.insert(15) bst.insert(3) bst.insert(7) assert bst.get_depth() == 3 # Depth should be 3 def test_insert_root_only(): bst = BinarySearchTree() bst.insert(10) assert bst.get_depth() == 1 # Only root, depth should be 1 def test_left_heavy_tree(): bst = BinarySearchTree() bst.insert(10) bst.insert(9) bst.insert(8) bst.insert(7) bst.insert(6) assert bst.get_depth() == 5 # Depth should be 5 def test_right_heavy_tree(): bst = BinarySearchTree() bst.insert(10) bst.insert(11) bst.insert(12) bst.insert(13) bst.insert(14) assert bst.get_depth() == 5 # Depth should be 5 def test_balanced_tree(): bst = BinarySearchTree() values = [10, 5, 15, 3, 7, 12, 18] for value in values: bst.insert(value) assert bst.get_depth() == 3 # Depth should be 3 if __name__ == \\"__main__\\": test_insert_and_depth() test_insert_root_only() test_left_heavy_tree() test_right_heavy_tree() test_balanced_tree()","solution":"class TreeNode: def __init__(self, value): self.value = value self.left = None self.right = None class BinarySearchTree: def __init__(self): self.root = None def insert(self, value: int): if self.root is None: self.root = TreeNode(value) else: self._insert(self.root, value) def _insert(self, node, value): if value < node.value: if node.left is None: node.left = TreeNode(value) else: self._insert(node.left, value) else: # value >= node.value if node.right is None: node.right = TreeNode(value) else: self._insert(node.right, value) def get_depth(self) -> int: return self._get_depth(self.root) def _get_depth(self, node): if node is None: return 0 else: left_depth = self._get_depth(node.left) right_depth = self._get_depth(node.right) return max(left_depth, right_depth) + 1"},{"question":"def find_missing_number(nums: List[int]) -> int: Find and return the missing number in a list of unique numbers ranging from 0 to n. Parameters: - nums (List[int]): A list of unique integers from 0 to n with one number missing. Returns: - int: The missing number in the range. Example: >>> find_missing_number([3, 0, 1]) 2 >>> find_missing_number([0, 1]) 2 >>> find_missing_number([9,6,4,2,3,5,7,0,1]) 8","solution":"def find_missing_number(nums): Find and return the missing number in a list of unique numbers ranging from 0 to n. Parameters: - nums (List[int]): A list of unique integers from 0 to n with one number missing. Returns: - int: The missing number in the range. n = len(nums) expected_sum = n * (n + 1) / 2 actual_sum = sum(nums) return int(expected_sum - actual_sum)"},{"question":"from typing import List def rotate_matrix(matrix: List[List[int]]) -> None: Rotates the given n x n matrix by 90 degrees clockwise in place. >>> matrix = [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ] >>> rotate_matrix(matrix) >>> matrix [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] >>> matrix = [ ... [5, 1, 9, 11], ... [2, 4, 8, 10], ... [13, 3, 6, 7], ... [15, 14, 12, 16] ... ] >>> rotate_matrix(matrix) >>> matrix [ [15, 13, 2, 5], [14, 3, 4, 1], [12, 6, 8, 9], [16, 7, 10, 11] ]","solution":"from typing import List def rotate_matrix(matrix: List[List[int]]) -> None: Rotates the given n x n matrix by 90 degrees clockwise in place. n = len(matrix) # Transpose the matrix for i in range(n): for j in range(i, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Reverse each row for i in range(n): matrix[i].reverse()"},{"question":"class CircularBuffer: A Circular Buffer data structure. >>> buffer = CircularBuffer(3) >>> buffer.enqueue(1) >>> buffer.enqueue(2) >>> buffer.enqueue(3) >>> buffer.size() 3 >>> buffer.is_full() True >>> buffer.enqueue(4) >>> buffer.dequeue() 2 >>> buffer.dequeue() 3 >>> buffer.enqueue(5) >>> buffer.size() 2 >>> buffer.is_empty() False >>> buffer.peek() 3 >>> buffer.dequeue() 3 >>> buffer.dequeue() 5 >>> buffer.is_empty() True >>> buffer.peek() # should raise IndexError: Buffer is empty Traceback (most recent call last): ... IndexError: Buffer is empty def __init__(self, size: int): self.buffer = [None] * size self.size = size self.head = 0 self.tail = 0 self.count = 0 def enqueue(self, element): Adds an element to the buffer. If the buffer is full, it overwrites the oldest data. pass def dequeue(self): Removes and returns the oldest element from the buffer. If the buffer is empty, raises IndexError with the message \\"Buffer is empty\\". pass def current_size(self): Returns the number of elements currently in the buffer. pass def is_empty(self): Returns True if the buffer is empty, False otherwise. pass def is_full(self): Returns True if the buffer is full, False otherwise. pass def peek(self): Returns the oldest element without removing it. If the buffer is empty, raises IndexError with the message \\"Buffer is empty\\". pass","solution":"class CircularBuffer: def __init__(self, size: int): self.buffer = [None] * size self.size = size self.head = 0 self.tail = 0 self.count = 0 def enqueue(self, element): if self.is_full(): self.head = (self.head + 1) % self.size else: self.count += 1 self.buffer[self.tail] = element self.tail = (self.tail + 1) % self.size def dequeue(self): if self.is_empty(): raise IndexError(\\"Buffer is empty\\") element = self.buffer[self.head] self.buffer[self.head] = None self.head = (self.head + 1) % self.size self.count -= 1 return element def current_size(self): return self.count def is_empty(self): return self.count == 0 def is_full(self): return self.count == self.size def peek(self): if self.is_empty(): raise IndexError(\\"Buffer is empty\\") return self.buffer[self.head]"},{"question":"class MinHeap: def __init__(self): Initializes an empty heap. pass def insert(self, element: int) -> None: Inserts an element into the heap. Args: element (int): The element to be inserted. pass def get_min(self) -> int: Returns the smallest element in the heap without removing it. Raises: Exception: If the heap is empty with the message \\"Empty Heap\\". Returns: int: The smallest element in the heap. pass def extract_min(self) -> int: Removes and returns the smallest element in the heap. Raises: Exception: If the heap is empty with the message \\"Empty Heap\\". Returns: int: The smallest element in the heap. pass def is_empty(self) -> bool: Returns True if the heap is empty, False otherwise. Returns: bool: True if the heap is empty, False otherwise. pass import pytest def test_min_heap_operations(): heap = MinHeap() # Testing is_empty on a new heap assert heap.is_empty() == True # Inserting elements heap.insert(10) heap.insert(5) heap.insert(14) # Testing get_min assert heap.get_min() == 5 # Testing is_empty after inserting elements assert heap.is_empty() == False # Testing extract_min assert heap.extract_min() == 5 assert heap.get_min() == 10 # Inserting another element heap.insert(7) assert heap.extract_min() == 7 # Extracting remaining elements assert heap.extract_min() == 10 assert heap.extract_min() == 14 # Testing operations on an empty heap with pytest.raises(Exception) as e_info: heap.get_min() assert str(e_info.value) == \\"Empty Heap\\" with pytest.raises(Exception) as e_info: heap.extract_min() assert str(e_info.value) == \\"Empty Heap\\" def test_min_heap_empty_exceptions(): heap = MinHeap() # Testing get_min on empty heap with pytest.raises(Exception) as e: heap.get_min() assert str(e.value) == \\"Empty Heap\\" # Testing extract_min on empty heap with pytest.raises(Exception) as e: heap.extract_min() assert str(e.value) == \\"Empty Heap\\"","solution":"import heapq class MinHeap: def __init__(self): self.heap = [] def insert(self, element: int) -> None: heapq.heappush(self.heap, element) def get_min(self) -> int: if not self.heap: raise Exception(\\"Empty Heap\\") return self.heap[0] def extract_min(self) -> int: if not self.heap: raise Exception(\\"Empty Heap\\") return heapq.heappop(self.heap) def is_empty(self) -> bool: return len(self.heap) == 0"},{"question":"from typing import List, Dict, Union def search_and_sort_books(books: List[Dict[str, Union[str, int]]], author: str) -> List[str]: This function retrieves the titles of books written by a specific author, sorted in ascending order by their publication year. Args: books (List[Dict[str, Union[str, int]]]): List of books represented as dictionaries with keys 'title', 'author', and 'year'. author (str): The author to search for in the list of books. Returns: List[str]: A list of book titles written by the specified author sorted by the publication year in ascending order. Examples: >>> search_and_sort_books([{'title': 'Book A', 'author': 'Author 1', 'year': 2005}, {'title': 'Book B', 'author': 'Author 1', 'year': 2001}, {'title': 'Book C', 'author': 'Author 2', 'year': 1999}], 'Author 1') ['Book B', 'Book A'] >>> search_and_sort_books([{'title': 'Book A', 'author': 'Author 1', 'year': 2005}], 'Author 2') [] >>> search_and_sort_books([{'title': 'Book A', 'author': 'Author 1', 'year': 2005}, {'title': 'Book B', 'author': 'Author 1', 'year': 2001}], 'Author 1') ['Book B', 'Book A']","solution":"from typing import List, Dict, Union def search_and_sort_books(books: List[Dict[str, Union[str, int]]], author: str) -> List[str]: This function retrieves the titles of books written by the given author, sorted in ascending order by their publication year. # Filter books by the given author filtered_books = [book for book in books if book['author'] == author] # Sort the filtered books by publication year sorted_books = sorted(filtered_books, key=lambda x: x['year']) # Extract titles from the sorted list sorted_titles = [book['title'] for book in sorted_books] return sorted_titles"},{"question":"def sort_list_preserve_zeros(arr: list[int]) -> list[int]: Sort the list of integers in ascending order while preserving the position of zeros. Args: arr (list[int]): The input list of integers. Returns: list[int]: The sorted list with zero positions preserved. Example: >>> sort_list_preserve_zeros([5, 0, 3, 0, 9, -1]) == [-1, 0, 3, 0, 5, 9] >>> sort_list_preserve_zeros([0, 34, -2, 0, 9, 0, 5]) == [0, -2, 5, 0, 9, 0, 34] >>> sort_list_preserve_zeros([0, 0, 0]) == [0, 0, 0] >>> sort_list_preserve_zeros([-3, 0, -1, 0, 2]) == [-3, 0, -1, 0, 2] pass","solution":"def sort_list_preserve_zeros(arr): Sort the list of integers in ascending order while preserving the position of zeros. Args: arr (list[int]): The input list of integers. Returns: list[int]: The sorted list with zero positions preserved. non_zero_elements = [x for x in arr if x != 0] non_zero_elements.sort() result = [] non_zero_index = 0 for num in arr: if num == 0: result.append(0) else: result.append(non_zero_elements[non_zero_index]) non_zero_index += 1 return result"},{"question":"def merge_sort(arr: list) -> list: Implement the Merge Sort algorithm to sort a list of integers in ascending order. Args: arr (list): A list of integers to sort. Returns: list: A new list with the elements of arr sorted in ascending order. Example: >>> merge_sort([34, 7, 23, 32, 5, 62]) [5, 7, 23, 32, 34, 62] from solution import merge_sort def test_merge_sort_single_element(): assert merge_sort([1]) == [1] def test_merge_sort_sorted_list(): assert merge_sort([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5] def test_merge_sort_reverse_list(): assert merge_sort([5, 4, 3, 2, 1]) == [1, 2, 3, 4, 5] def test_merge_sort_random_list(): assert merge_sort([34, 7, 23, 32, 5, 62]) == [5, 7, 23, 32, 34, 62] def test_merge_sort_duplicates(): assert merge_sort([4, 1, 3, 4, 2, 3]) == [1, 2, 3, 3, 4, 4] def test_merge_sort_large_list(): large_list = list(range(1000, 0, -1)) assert merge_sort(large_list) == list(range(1, 1001))","solution":"def merge_sort(arr): Sorts a list of integers in ascending order using the Merge Sort algorithm. if len(arr) <= 1: return arr def merge(left, right): merged = [] i = j = 0 # Merge two sorted lists while i < len(left) and j < len(right): if left[i] <= right[j]: merged.append(left[i]) i += 1 else: merged.append(right[j]) j += 1 # Collect remaining elements (if any) merged.extend(left[i:]) merged.extend(right[j:]) return merged # Split the list into halves mid = len(arr) // 2 left_half = merge_sort(arr[:mid]) right_half = merge_sort(arr[mid:]) # Merge the sorted halves return merge(left_half, right_half)"},{"question":"from typing import Dict, List, Tuple def dijkstra_shortest_paths(graph: Dict[int, List[Tuple[int, int]]], source: int) -> Dict[int, float]: Compute the shortest path from a given source node to all other nodes in a weighted, directed graph using Dijkstra's algorithm. :param graph: A dictionary representing a weighted, directed graph where keys are vertex identifiers and values are lists of tuples. Each tuple contains a neighboring vertex identifier and the weight of the edge to that neighbor. :param source: An integer representing the starting vertex for the shortest paths calculation. :return: A dictionary where keys are vertex identifiers and values are the shortest distance from the source to that vertex. >>> test_graph_1 = { ... 0: [(1, 4), (2, 1)], ... 1: [(3, 1)], ... 2: [(1, 2), (3, 5)], ... 3: [], ... 4: [(5, 1)], ... 5: [(4, 2)] ... } >>> dijkstra_shortest_paths(test_graph_1, 0) {0: 0, 1: 3, 2: 1, 3: 4, 4: float('inf'), 5: float('inf')} >>> test_graph_2 = { ... 0: [(1, 1)], ... 1: [(2, 2)], ... 2: [(3, 1)], ... 3: [(4, 3)], ... 4: [] ... } >>> dijkstra_shortest_paths(test_graph_2, 0) {0: 0, 1: 1, 2: 3, 3: 4, 4: 7} >>> dijkstra_shortest_paths(test_graph_2, 3) {0: float('inf'), 1: float('inf'), 2: float('inf'), 3: 0, 4: 3}","solution":"import heapq def dijkstra_shortest_paths(graph: dict, source: int) -> dict: Compute the shortest path from a given source node to all other nodes in a weighted, directed graph using Dijkstra's algorithm. :param graph: A dictionary representing a weighted, directed graph where keys are vertex identifiers and values are lists of tuples. Each tuple contains a neighboring vertex identifier and the weight of the edge to that neighbor. :param source: An integer representing the starting vertex for the shortest paths calculation. :return: A dictionary where keys are vertex identifiers and values are the shortest distance from the source to that vertex. # Initialize distances to all vertices as infinity and to source as 0 distances = {vertex: float('inf') for vertex in graph} distances[source] = 0 # Priority queue to explore the closest node first priority_queue = [(0, source)] # (distance, vertex) while priority_queue: current_distance, current_vertex = heapq.heappop(priority_queue) # If the popped vertex has already a greater distance, continue if current_distance > distances[current_vertex]: continue # Explore neighbors and update their shortest paths for neighbor, weight in graph[current_vertex]: distance = current_distance + weight # Only consider this new path if it's better if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return distances"},{"question":"def solve_sudoku(grid: list[list[int]]) -> list[list[int]]: Solves the Sudoku puzzle and returns the completed grid. >>> grid = [ >>> [5, 3, 0, 0, 7, 0, 0, 0, 0], >>> [6, 0, 0, 1, 9, 5, 0, 0, 0], >>> [0, 9, 8, 0, 0, 0, 0, 6, 0], >>> [8, 0, 0, 0, 6, 0, 0, 0, 3], >>> [4, 0, 0, 8, 0, 3, 0, 0, 1], >>> [7, 0, 0, 0, 2, 0, 0, 0, 6], >>> [0, 6, 0, 0, 0, 0, 2, 8, 0], >>> [0, 0, 0, 4, 1, 9, 0, 0, 5], >>> [0, 0, 0, 0, 8, 0, 0, 7, 9] >>> ] >>> solve_sudoku(grid) [ [5, 3, 4, 6, 7, 8, 9, 1, 2], [6, 7, 2, 1, 9, 5, 3, 4, 8], [1, 9, 8, 3, 4, 2, 5, 6, 7], [8, 5, 9, 7, 6, 1, 4, 2, 3], [4, 2, 6, 8, 5, 3, 7, 9, 1], [7, 1, 3, 9, 2, 4, 8, 5, 6], [9, 6, 1, 5, 3, 7, 2, 8, 4], [2, 8, 7, 4, 1, 9, 6, 3, 5], [3, 4, 5, 2, 8, 6, 1, 7, 9] ]","solution":"def solve_sudoku(grid): Solves the Sudoku puzzle and returns the completed grid. def is_valid(board, row, col, num): # Check row for x in range(9): if board[row][x] == num: return False # Check column for x in range(9): if board[x][col] == num: return False # Check 3x3 sub-grid start_row, start_col = 3 * (row // 3), 3 * (col // 3) for i in range(start_row, start_row + 3): for j in range(start_col, start_col + 3): if board[i][j] == num: return False return True def solve(board): for i in range(9): for j in range(9): if board[i][j] == 0: for num in range(1, 10): if is_valid(board, i, j, num): board[i][j] = num if solve(board): return True board[i][j] = 0 return False return True solve(grid) return grid"},{"question":"def recommend_books(purchase_history, customer): Recommends books based on the purchase history of similar customers. Args: purchase_history (dict): A dictionary where keys are customer IDs and values are lists of book titles purchased by that customer. customer (str): The customer ID for whom recommendations are to be made. Returns: list of str: A list of recommended book titles. Examples: >>> purchase_history = { ... \\"C1\\": [\\"BookA\\", \\"BookB\\", \\"BookC\\"], ... \\"C2\\": [\\"BookD\\", \\"BookE\\", \\"BookA\\"], ... \\"C3\\": [\\"BookA\\", \\"BookC\\", \\"BookE\\"] ... } >>> customer = \\"C1\\" >>> recommend_books(purchase_history, customer) [\\"BookE\\"] >>> purchase_history = { ... \\"C1\\": [\\"BookA\\", \\"BookB\\"], ... \\"C2\\": [\\"BookA\\", \\"BookC\\"], ... \\"C3\\": [\\"BookA\\", \\"BookB\\"] ... } >>> customer = \\"C1\\" >>> recommend_books(purchase_history, customer) [] from solution import recommend_books def test_recommend_books_example_case(): purchase_history = { \\"C1\\": [\\"BookA\\", \\"BookB\\", \\"BookC\\"], \\"C2\\": [\\"BookD\\", \\"BookE\\", \\"BookA\\"], \\"C3\\": [\\"BookA\\", \\"BookC\\", \\"BookE\\"] } customer = \\"C1\\" assert recommend_books(purchase_history, customer) == [\\"BookE\\"] def test_recommend_books_no_recommendation(): purchase_history = { \\"C1\\": [\\"BookA\\", \\"BookB\\"], \\"C2\\": [\\"BookA\\", \\"BookC\\"], \\"C3\\": [\\"BookA\\", \\"BookB\\"] } customer = \\"C1\\" assert recommend_books(purchase_history, customer) == [] def test_recommend_books_multiple_recommendations(): purchase_history = { \\"C1\\": [\\"BookA\\"], \\"C2\\": [\\"BookA\\", \\"BookB\\", \\"BookC\\"], \\"C3\\": [\\"BookA\\", \\"BookD\\"] } customer = \\"C1\\" result = recommend_books(purchase_history, customer) assert set(result) == {\\"BookB\\", \\"BookC\\"} def test_recommend_books_tie_breaker(): purchase_history = { \\"C1\\": [\\"BookA\\"], \\"C2\\": [\\"BookB\\", \\"BookC\\"], \\"C3\\": [\\"BookB\\", \\"BookC\\"] } customer = \\"C1\\" assert recommend_books(purchase_history, customer) == [\\"BookB\\", \\"BookC\\"] def test_recommend_books_large_input(): purchase_history = { \\"C1\\": [\\"Book1\\", \\"Book2\\"], \\"C2\\": [\\"Book3\\", \\"Book4\\", \\"Book1\\"], \\"C3\\": [\\"Book1\\", \\"Book4\\"], \\"C4\\": [\\"Book2\\", \\"Book3\\", \\"Book4\\", \\"Book1\\"] } customer = \\"C1\\" assert recommend_books(purchase_history, customer) == [\\"Book3\\", \\"Book4\\"]","solution":"def recommend_books(purchase_history, customer): Recommends books based on the purchase history of similar customers. Args: purchase_history (dict): A dictionary where keys are customer IDs and values are lists of book titles purchased by that customer. customer (str): The customer ID for whom recommendations are to be made. Returns: list of str: A list of recommended book titles. target_books = set(purchase_history[customer]) max_similarity = -1 best_match = None for other_customer, books in purchase_history.items(): if other_customer == customer: continue common_books = target_books.intersection(books) similarity = len(common_books) if (similarity > max_similarity) or (similarity == max_similarity and other_customer < best_match): max_similarity = similarity best_match = other_customer if best_match is None: return [] recommended_books = set(purchase_history[best_match]) - target_books return list(recommended_books)"},{"question":"from typing import List def unique_anagrams(s: str) -> List[str]: Generates all unique anagram combinations of the given string s. Returns the list of anagrams sorted lexicographically. >>> unique_anagrams('abc') ['abc', 'acb', 'bac', 'bca', 'cab', 'cba'] >>> unique_anagrams('aab') ['aab', 'aba', 'baa'] >>> unique_anagrams('abcd') ['abcd', 'abdc', 'acbd', 'acdb', 'adbc', 'adcb', 'bacd', 'badc', 'bcad', 'bcda', 'bdac', 'bdca', 'cabd', 'cadb', 'cbad', 'cbda', 'cdab', 'cdba', 'dabc', 'dacb', 'dbac', 'dbca', 'dcab', 'dcba'] >>> unique_anagrams('aa') ['aa'] >>> unique_anagrams('') [''] pass","solution":"from typing import List from itertools import permutations def unique_anagrams(s: str) -> List[str]: Generates all unique anagram combinations of the given string s. Returns the list of anagrams sorted lexicographically. # Generate all permutations of the string perm = permutations(s) # Convert permutations to a set to ensure uniqueness unique_perm = set([''.join(p) for p in perm]) # Convert the set to a list and sort it lexicographically sorted_perm = sorted(unique_perm) return sorted_perm"},{"question":"def largest_number(s: str) -> str: Return the largest number that can be formed by rearranging the digits of the given string. >>> largest_number(\\"429\\") \\"942\\" >>> largest_number(\\"459850\\") \\"985540\\" >>> largest_number(\\"0\\") \\"0\\" >>> largest_number(\\"0000021\\") \\"2100000\\"","solution":"def largest_number(s: str) -> str: Return the largest number that can be formed by rearranging the digits of the given string. if set(s) == {'0'}: # if the input string consists only of '0's return '0' return ''.join(sorted(s, reverse=True))"},{"question":"def max_profit(prices: list[int]) -> int: Calculates the maximum profit that can be achieved by buying and selling stocks given the prices list. :param prices: List of integers representing stock prices on different days. :return: Maximum profit achievable. >>> max_profit([7, 1, 5, 3, 6, 4]) 7 >>> max_profit([1, 2, 3, 4, 5]) 4 >>> max_profit([7, 6, 4, 3, 1]) 0 pass","solution":"def max_profit(prices: list[int]) -> int: Calculates the maximum profit that can be achieved by buying and selling stocks given the prices list. :param prices: List of integers representing stock prices on different days. :return: Maximum profit achievable. max_profit = 0 for i in range(1, len(prices)): if prices[i] > prices[i - 1]: max_profit += prices[i] - prices[i - 1] return max_profit"},{"question":"def categorize_number(num: float) -> str: Categorizes a numeric value. Parameters: num (int, float): The numeric value to categorize. Returns: str: A string representing the category of the number ('small', 'medium', or 'large'). Raises: TypeError: If num is not an int or float. Example: >>> categorize_number(5) 'small' >>> categorize_number(-5) 'small' >>> categorize_number(1e-6) 'small' >>> categorize_number(10) 'medium' >>> categorize_number(50) 'medium' >>> categorize_number(100) 'medium' >>> categorize_number(150) 'large' >>> categorize_number(1e3) 'large' >>> categorize_number(\\"Test\\") Traceback (most recent call last): ... TypeError: num must be an int or float >>> categorize_number([1, 2, 3]) Traceback (most recent call last): ... TypeError: num must be an int or float >>> categorize_number(None) Traceback (most recent call last): ... TypeError: num must be an int or float >>> categorize_number(9.9999) 'small' >>> categorize_number(10.0) 'medium' >>> categorize_number(100.0) 'medium' >>> categorize_number(100.0001) 'large'","solution":"def categorize_number(num): Categorizes a numeric value. Parameters: num (int, float): The numeric value to categorize. Returns: str: A string representing the category of the number ('small', 'medium', or 'large'). Raises: TypeError: If num is not an int or float. if not isinstance(num, (int, float)): raise TypeError(\\"num must be an int or float\\") if num < 10: return 'small' elif 10 <= num <= 100: return 'medium' else: return 'large'"},{"question":"class CustomerQueue: A simple queue system to manage customers in a bank. >>> queue = CustomerQueue() >>> queue.enqueue(\\"Alice\\") >>> queue.enqueue(\\"Bob\\") >>> queue.size() 2 >>> queue.dequeue() 'Alice' >>> queue.size() 1 >>> queue.dequeue() 'Bob' >>> queue.dequeue() Traceback (most recent call last): ... IndexError: Cannot dequeue from an empty queue. >>> queue.enqueue(123) Traceback (most recent call last): ... TypeError: Customer name must be a string. def __init__(self): ... def enqueue(self, customer: str) -> None: ... def dequeue(self) -> str: ... def size(self) -> int: ... # Unit test import pytest def test_enqueue_valid_customer(): queue = CustomerQueue() queue.enqueue(\\"Alice\\") assert queue.size() == 1 queue.enqueue(\\"Bob\\") assert queue.size() == 2 def test_enqueue_invalid_customer(): queue = CustomerQueue() with pytest.raises(TypeError): queue.enqueue(123) def test_dequeue_from_non_empty_queue(): queue = CustomerQueue() queue.enqueue(\\"Alice\\") queue.enqueue(\\"Bob\\") assert queue.dequeue() == \\"Alice\\" assert queue.size() == 1 assert queue.dequeue() == \\"Bob\\" assert queue.size() == 0 def test_dequeue_from_empty_queue(): queue = CustomerQueue() with pytest.raises(IndexError): queue.dequeue() def test_enqueue_and_dequeue_combination(): queue = CustomerQueue() queue.enqueue(\\"Alice\\") queue.enqueue(\\"Bob\\") queue.enqueue(\\"Charlie\\") assert queue.size() == 3 assert queue.dequeue() == \\"Alice\\" assert queue.size() == 2 queue.enqueue(\\"Dave\\") assert queue.size() == 3 assert queue.dequeue() == \\"Bob\\" assert queue.dequeue() == \\"Charlie\\" assert queue.size() == 1 assert queue.dequeue() == \\"Dave\\" assert queue.size() == 0","solution":"class CustomerQueue: def __init__(self): self._queue = [] def enqueue(self, customer: str) -> None: if not isinstance(customer, str): raise TypeError(\\"Customer name must be a string.\\") self._queue.append(customer) def dequeue(self) -> str: if len(self._queue) == 0: raise IndexError(\\"Cannot dequeue from an empty queue.\\") return self._queue.pop(0) def size(self) -> int: return len(self._queue)"},{"question":"def max_subarray_sum(nums: List[int]) -> Tuple[int, List[int]]: Identify the subarray with the maximum sum and return both the maximum sum and the indices of the subarray. :param nums: A list of integers. :return: A tuple containing the maximum sum and a list of two integers representing the starting and ending indices of the subarray. Examples: >>> max_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) (6, [3, 6]) >>> max_subarray_sum([1]) (1, [0, 0]) >>> max_subarray_sum([5, 4, -1, 7, 8]) (23, [0, 4]) >>> max_subarray_sum([]) (0, [])","solution":"def max_subarray_sum(nums): if not nums: return 0, [] max_sum = current_sum = nums[0] start = end = 0 temp_start = 0 for i in range(1, len(nums)): if current_sum < 0: current_sum = nums[i] temp_start = i else: current_sum += nums[i] if current_sum > max_sum: max_sum = current_sum start = temp_start end = i return max_sum, [start, end]"},{"question":"from typing import List def least_common_interval(tasks: List[int]) -> int: Calculate the least common interval (LCI) for the given list of task intervals. >>> least_common_interval([5]) 5 >>> least_common_interval([2, 3]) 6 >>> least_common_interval([2, 3, 4]) 12 >>> least_common_interval([4, 5, 6]) 60 >>> least_common_interval([3, 3, 3]) 3 >>> least_common_interval([1000000, 500000]) 1000000 >>> least_common_interval([2, 3, 5, 7, 11]) 2310 pass","solution":"import math from typing import List def least_common_interval(tasks: List[int]) -> int: Calculate the least common interval (LCI) for the given list of task intervals. def lcm(a, b): return abs(a * b) // math.gcd(a, b) current_lcm = tasks[0] for task in tasks[1:]: current_lcm = lcm(current_lcm, task) return current_lcm"},{"question":"class MinHeap: def __init__(self): Initializes an empty heap. pass def insert(self, val: int) -> None: Inserts a new integer \`val\` into the heap. Parameters: val (int): The value to insert into the heap. pass def extract_min(self) -> int: Removes and returns the smallest element from the heap. If the heap is empty, it should raise an appropriate exception. Returns: int: The smallest element in the heap. Raises: IndexError: If the heap is empty. pass # Unit tests def test_insert_and_extract(): heap = MinHeap() heap.insert(9) heap.insert(3) heap.insert(7) heap.insert(1) assert heap.extract_min() == 1 heap.insert(8) assert heap.extract_min() == 3 def test_extract_min_single_element(): heap = MinHeap() heap.insert(10) assert heap.extract_min() == 10 def test_extract_min_empty(): heap = MinHeap() try: heap.extract_min() assert False, \\"Expected IndexError\\" except IndexError: assert True def test_multiple_insert_and_extract(): heap = MinHeap() heap.insert(7) heap.insert(2) heap.insert(20) heap.insert(15) heap.insert(5) assert heap.extract_min() == 2 assert heap.extract_min() == 5 assert heap.extract_min() == 7 assert heap.extract_min() == 15 assert heap.extract_min() == 20 def test_minheap_property(): heap = MinHeap() values = [5, 12, 3, 8, 7, 15, 1, 9] for value in values: heap.insert(value) sorted_values = sorted(values) heap_values = [] while True: try: heap_values.append(heap.extract_min()) except IndexError: break assert heap_values == sorted_values","solution":"class MinHeap: def __init__(self): self.heap = [] def insert(self, val: int) -> None: self.heap.append(val) self._bubble_up(len(self.heap) - 1) def extract_min(self) -> int: if len(self.heap) == 0: raise IndexError(\\"extract_min() called on empty heap\\") min_val = self.heap[0] last_val = self.heap.pop() if len(self.heap) > 0: self.heap[0] = last_val self._bubble_down(0) return min_val def _bubble_up(self, index: int) -> None: parent_index = (index - 1) // 2 if parent_index >= 0 and self.heap[index] < self.heap[parent_index]: self.heap[index], self.heap[parent_index] = self.heap[parent_index], self.heap[index] self._bubble_up(parent_index) def _bubble_down(self, index: int) -> None: smallest = index left_child_index = 2 * index + 1 right_child_index = 2 * index + 2 if left_child_index < len(self.heap) and self.heap[left_child_index] < self.heap[smallest]: smallest = left_child_index if right_child_index < len(self.heap) and self.heap[right_child_index] < self.heap[smallest]: smallest = right_child_index if smallest != index: self.heap[index], self.heap[smallest] = self.heap[smallest], self.heap[index] self._bubble_down(smallest)"},{"question":"class TrafficLight: def __init__(self) -> None: Initializes the traffic light with an initial state RED. def change_light(self) -> None: Changes the light state in the sequence RED -> GREEN -> YELLOW -> RED. def current_state(self) -> str: Returns: str: The current state of the traffic light ('RED', 'YELLOW', 'GREEN').","solution":"class TrafficLight: def __init__(self) -> None: Initializes the traffic light with an initial state RED. self.states = [\\"RED\\", \\"GREEN\\", \\"YELLOW\\"] self.current_index = 0 def change_light(self) -> None: Changes the light state in the sequence RED -> GREEN -> YELLOW -> RED. self.current_index = (self.current_index + 1) % 3 def current_state(self) -> str: Returns: str: The current state of the traffic light ('RED', 'YELLOW', 'GREEN'). return self.states[self.current_index] # Example usage traffic_light = TrafficLight() print(traffic_light.current_state()) # Expected output: \\"RED\\" traffic_light.change_light() print(traffic_light.current_state()) # Expected output: \\"GREEN\\" traffic_light.change_light() print(traffic_light.current_state()) # Expected output: \\"YELLOW\\" traffic_light.change_light() print(traffic_light.current_state()) # Expected output: \\"RED\\""},{"question":"def format_text_file(input_file: str, output_file: str) -> None: Reads an input file, processes its content by trimming leading and trailing whitespace from each line, and writes the formatted output to a new file. pass def validate_format(output_file: str, expected_output: str) -> bool: Checks if an output file matches the expected formatted content. pass import os def create_test_file(file_path, content): with open(file_path, 'w') as file: file.write(content) def test_format_text_file(): input_content = \\" Hello World nThis is a test. nn Another line. n n\\" expected_output_content = \\"Hello WorldnThis is a test.nAnother line.n\\" input_file = 'test_input.txt' output_file = 'test_output.txt' expected_output_file = 'expected_output.txt' create_test_file(input_file, input_content) create_test_file(expected_output_file, expected_output_content) format_text_file(input_file, output_file) assert validate_format(output_file, expected_output_file) # Clean up test files os.remove(input_file) os.remove(output_file) os.remove(expected_output_file) def test_format_text_file_with_all_whitespace_lines(): input_content = \\" ntnnn\\" expected_output_content = \\"\\" input_file = 'test_input_whitespace.txt' output_file = 'test_output_whitespace.txt' expected_output_file = 'expected_output_whitespace.txt' create_test_file(input_file, input_content) create_test_file(expected_output_file, expected_output_content) format_text_file(input_file, output_file) assert validate_format(output_file, expected_output_file) # Clean up test files os.remove(input_file) os.remove(output_file) os.remove(expected_output_file) def test_format_text_file_no_changes_needed(): input_content = \\"Line1nLine2nLine3n\\" expected_output_content = \\"Line1nLine2nLine3n\\" input_file = 'test_input_no_change.txt' output_file = 'test_output_no_change.txt' expected_output_file = 'expected_output_no_change.txt' create_test_file(input_file, input_content) create_test_file(expected_output_file, expected_output_content) format_text_file(input_file, output_file) assert validate_format(output_file, expected_output_file) # Clean up test files os.remove(input_file) os.remove(output_file) os.remove(expected_output_file) def test_format_empty_input_file(): input_content = \\"\\" expected_output_content = \\"\\" input_file = 'test_input_empty.txt' output_file = 'test_output_empty.txt' expected_output_file = 'expected_output_empty.txt' create_test_file(input_file, input_content) create_test_file(expected_output_file, expected_output_content) format_text_file(input_file, output_file) assert validate_format(output_file, expected_output_file) # Clean up test files os.remove(input_file) os.remove(output_file) os.remove(expected_output_file)","solution":"def format_text_file(input_file: str, output_file: str) -> None: with open(input_file, 'r') as infile: lines = infile.readlines() with open(output_file, 'w') as outfile: for line in lines: formatted_line = line.strip() if formatted_line: outfile.write(formatted_line + 'n') def validate_format(output_file: str, expected_output: str) -> bool: with open(output_file, 'r') as outfile: output_content = outfile.read() with open(expected_output, 'r') as expectedfile: expected_content = expectedfile.read() return output_content == expected_content"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_valid_bst(root: TreeNode) -> bool: Determine if the binary tree rooted at 'root' is a valid binary search tree (BST). Parameters: root (TreeNode): The root node of the binary tree to check. Returns: bool: True if the tree is a valid BST, False otherwise. Example Usage: >>> root = TreeNode(2) >>> root.left = TreeNode(1) >>> root.right = TreeNode(3) >>> is_valid_bst(root) True >>> root = TreeNode(5) >>> root.left = TreeNode(1) >>> root.right = TreeNode(4) >>> root.right.left = TreeNode(3) >>> root.right.right = TreeNode(6) >>> is_valid_bst(root) False # Your code here # Unit Tests def test_bst_empty_tree(): assert is_valid_bst(None) == True def test_bst_single_node(): assert is_valid_bst(TreeNode(1)) == True def test_bst_valid_tree(): root = TreeNode(2) root.left = TreeNode(1) root.right = TreeNode(3) assert is_valid_bst(root) == True def test_bst_invalid_tree(): root = TreeNode(5) root.left = TreeNode(1) root.right = TreeNode(4) root.right.left = TreeNode(3) root.right.right = TreeNode(6) assert is_valid_bst(root) == False def test_bst_duplicate_values(): root = TreeNode(2) root.left = TreeNode(1) root.right = TreeNode(2) assert is_valid_bst(root) == False def test_bst_large_tree(): root = TreeNode(10) root.left = TreeNode(5) root.right = TreeNode(15) root.left.left = TreeNode(2) root.left.right = TreeNode(7) root.right.left = TreeNode(12) root.right.right = TreeNode(20) assert is_valid_bst(root) == True def test_bst_bounds_check(): root = TreeNode(10) root.left = TreeNode(5) root.right = TreeNode(15) root.left.left = TreeNode(-2147483648) root.left.right = TreeNode(7) root.right.left = TreeNode(9) root.right.right = TreeNode(2147483647) assert is_valid_bst(root) == False","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_valid_bst(root: TreeNode) -> bool: Determine if the binary tree rooted at 'root' is a valid binary search tree (BST). def validate(node, low=-float('inf'), high=float('inf')): # An empty tree is a valid BST if not node: return True # The current node's value must be between the low and high bounds if not (low < node.val < high): return False # Recursively check the subtrees with updated bounds return (validate(node.left, low, node.val) and validate(node.right, node.val, high)) return validate(root)"},{"question":"class LRUCache: Implements a Least Recently Used (LRU) Cache with a fixed capacity. Attributes: capacity (int): The maximum number of items the cache can hold. cache (dict): Dictionary to store the cache items. head (Node): The head dummy node of the doubly linked list. tail (Node): The tail dummy node of the doubly linked list. Methods: __init__(self, capacity: int): Initializes the cache with a given capacity. get(self, key: int) -> int: Retrieves the value associated with the key, if present in the cache. put(self, key: int, value: int) -> None: Adds a key-value pair to the cache, evicting the least recently used item if necessary. def __init__(self, capacity: int): Initializes the cache with a fixed capacity. Args: capacity (int): Maximum number of items in the cache. def get(self, key: int) -> int: Retrieves the value associated with the given key if it exists in the cache. Args: key (int): The key to look up in the cache. Returns: int: The value associated with the key, or -1 if the key is not found. def put(self, key: int, value: int) -> None: Adds a key-value pair to the cache. If the cache reaches its capacity, evicts the least recently used item. Args: key (int): The key of the item to add to the cache. value (int): The value of the item to add to the cache. # Example Usage: # cache = LRUCache(2) # cache.put(1, 1) # Cache is {1=1} # cache.put(2, 2) # Cache is {1=1, 2=2} # print(cache.get(1)) # Returns 1 # cache.put(3, 3) # Evicts key 2, Cache is {1=1, 3=3} # print(cache.get(2)) # Returns -1 (not found) # cache.put(4, 4) # Evicts key 1, Cache is {4=4, 3=3} # print(cache.get(1)) # Returns -1 (not found) # print(cache.get(3)) # Returns 3 # print(cache.get(4)) # Returns 4","solution":"class Node: def __init__(self, key:int, value:int): self.key = key self.value = value self.prev = None self.next = None class LRUCache: def __init__(self, capacity: int): self.capacity = capacity self.cache = {} self.head, self.tail = Node(0, 0), Node(0, 0) self.head.next, self.tail.prev = self.tail, self.head def _add(self, node: Node) -> None: p = self.tail.prev p.next = node self.tail.prev = node node.prev = p node.next = self.tail def _remove(self, node: Node) -> None: p = node.prev n = node.next p.next = n n.prev = p def get(self, key: int) -> int: if key in self.cache: node = self.cache[key] self._remove(node) self._add(node) return node.value return -1 def put(self, key: int, value: int) -> None: if key in self.cache: self._remove(self.cache[key]) elif len(self.cache) >= self.capacity: lru = self.head.next self._remove(lru) del self.cache[lru.key] node = Node(key, value) self._add(node) self.cache[key] = node"},{"question":"class TextEditor: A simple text editor that supports append, delete, print_k, and undo operations. Methods: append(text: str) -> None: Appends a given string to the end of the current text. delete(k: int) -> None: Deletes the last k characters of the current text. print_k(k: int) -> str: Returns the k-th character of the current text (1-indexed). undo() -> None: Undoes the last operation (either append or delete). Example Usage: >>> editor = TextEditor() >>> editor.append(\\"hello\\") >>> editor.append(\\" world\\") >>> editor.print_k(6) # Output: ' ' >>> editor.delete(6) >>> editor.print_k(5) # Output: 'o' >>> editor.undo() >>> editor.print_k(6) # Output: ' ' >>> editor.undo() >>> editor.print_k(5) # Output: 'o' def __init__(self): pass def append(self, text: str) -> None: pass def delete(self, k: int) -> None: pass def print_k(self, k: int) -> str: pass def undo(self) -> None: pass def test_append(): editor = TextEditor() editor.append(\\"hello\\") assert editor.text == \\"hello\\" editor.append(\\" world\\") assert editor.text == \\"hello world\\" def test_delete(): editor = TextEditor() editor.append(\\"hello world\\") editor.delete(6) assert editor.text == \\"hello\\" def test_print_k(): editor = TextEditor() editor.append(\\"hello world\\") assert editor.print_k(6) == ' ' assert editor.print_k(1) == 'h' assert editor.print_k(11) == 'd' def test_undo(): editor = TextEditor() editor.append(\\"hello\\") editor.append(\\" world\\") assert editor.text == \\"hello world\\" editor.undo() assert editor.text == \\"hello\\" editor.undo() assert editor.text == \\"\\" def test_combined_operations(): editor = TextEditor() editor.append(\\"hello\\") assert editor.text == \\"hello\\" editor.append(\\" world\\") assert editor.text == \\"hello world\\" editor.delete(6) assert editor.text == \\"hello\\" editor.undo() assert editor.text == \\"hello world\\" editor.undo() assert editor.text == \\"hello\\" editor.undo() assert editor.text == \\"\\" def test_print_k_boundaries(): editor = TextEditor() editor.append(\\"hello\\") try: editor.print_k(0) assert False, \\"Should raise ValueError for index 0\\" except ValueError: pass try: editor.print_k(6) assert False, \\"Should raise ValueError for index 6\\" except ValueError: pass def test_undo_without_history(): editor = TextEditor() try: editor.undo() assert False, \\"Should raise RuntimeError when there are no operations to undo\\" except RuntimeError: pass","solution":"class TextEditor: def __init__(self): self.text = \\"\\" self.history = [] def append(self, text: str) -> None: self.history.append(self.text) self.text += text def delete(self, k: int) -> None: self.history.append(self.text) self.text = self.text[:-k] def print_k(self, k: int) -> str: if 1 <= k <= len(self.text): return self.text[k-1] else: raise ValueError(\\"Index out of bounds\\") def undo(self) -> None: if self.history: self.text = self.history.pop() else: raise RuntimeError(\\"No operations to undo\\")"},{"question":"def most_frequent_character(s: str) -> str: Find the most frequent character in a given string. If multiple characters have the same highest frequency, return the lexicographically smallest one. >>> most_frequent_character(\\"apple\\") \\"p\\" >>> most_frequent_character(\\"banana\\") \\"a\\" >>> most_frequent_character(\\"character\\") \\"c\\" >>> most_frequent_character(\\"mississippi\\") \\"i\\"","solution":"def most_frequent_character(s: str) -> str: from collections import Counter # Get the frequency of each character in the string frequency = Counter(s) # Find the character with the highest frequency most_frequent = max(frequency.items(), key=lambda item: (item[1], -ord(item[0]))) return most_frequent[0]"},{"question":"from dataclasses import dataclass from typing import List, Optional @dataclass class Node: data: float left: Optional['Node'] = None right: Optional['Node'] = None def kth_smallest_element(root: Node, k: int) -> float: Find the k-th smallest element in a binary search tree (BST). Args: root (Node): The root node of the BST. k (int): The position of the smallest element to find (1-based index). Returns: float: The k-th smallest element in the BST. Examples: >>> root = Node(data=3) >>> root.left = Node(data=1) >>> root.right = Node(data=4) >>> root.left.right = Node(data=2) >>> kth_smallest_element(root, 1) 1.0 >>> kth_smallest_element(root, 3) 3.0","solution":"from dataclasses import dataclass @dataclass class Node: data: float left: 'Node' = None right: 'Node' = None def kth_smallest_element(root: Node, k: int) -> float: # In-order traversal of the tree yields elements in sorted order for a BST def inorder_traversal(node: Node): if not node: return [] # Traverse the left subtree, the node itself, and then the right subtree return inorder_traversal(node.left) + [node.data] + inorder_traversal(node.right) sorted_elements = inorder_traversal(root) return sorted_elements[k - 1]"},{"question":"def compress_string(text: str) -> str: Compresses the input string by replacing consecutive identical characters with the character followed by the count of its occurrences. If the compressed string is not shorter, the original string is returned. Parameters: text (str): The string to be compressed. Returns: str: The compressed string or the original if compression is not beneficial. >>> compress_string(\\"aabcccccaaa\\") 'a2bc5a3' >>> compress_string(\\"abcd\\") 'abcd' >>> compress_string(\\"aabbcc\\") 'aabbcc' >>> compress_string(\\"zzzzyyyyyyy\\") 'z4y7' >>> compress_string(\\"\\") '' >>> compress_string(\\"a\\") 'a' >>> compress_string(\\"z\\") 'z' >>> compress_string(\\"aabbcccbaa\\") 'a2b2c3ba2' >>> compress_string(\\"a\\" * 999 + \\"b\\") 'a999b' >>> compress_string(\\"a\\" * 1000) 'a1000'","solution":"def compress_string(text: str) -> str: Compresses the input string by replacing consecutive identical characters with the character followed by the count of its occurrences. If the compressed string is not shorter, the original string is returned. Parameters: text (str): The string to be compressed. Returns: str: The compressed string or the original if compression is not beneficial. if not text: return text compressed = [] count = 1 for i in range(1, len(text)): if text[i] == text[i - 1]: count += 1 else: compressed.append(text[i - 1] + (str(count) if count > 1 else '')) count = 1 compressed.append(text[-1] + (str(count) if count > 1 else '')) compressed_str = ''.join(compressed) return compressed_str if len(compressed_str) < len(text) else text"},{"question":"def organize_tasks(task_list: list[tuple[str, str, int]]) -> list[tuple[str, str, int]]: Sorts tasks based on deadlines in ascending order and priorities in descending order. Args: task_list (list): A list of tuples where each tuple contains task_name (str), deadline (str in YYYY-MM-DD format), and priority (int). Returns: list: A sorted list of tuples. Example: >>> organize_tasks([ ... (\\"task1\\", \\"2023-05-01\\", 1), ... (\\"task2\\", \\"2023-05-01\\", 2), ... (\\"task3\\", \\"2023-04-01\\", 3), ... (\\"task4\\", \\"2023-04-01\\", 1) ... ]) == [ ... (\\"task3\\", \\"2023-04-01\\", 3), ... (\\"task4\\", \\"2023-04-01\\", 1), ... (\\"task2\\", \\"2023-05-01\\", 2), ... (\\"task1\\", \\"2023-05-01\\", 1) ... ] >>> organize_tasks([ ... (\\"task1\\", \\"2023-07-01\\", 2), ... (\\"task2\\", \\"2023-05-01\\", 1), ... (\\"task3\\", \\"2023-06-01\\", 1), ... (\\"task4\\", \\"2023-04-01\\", 3) ... ]) == [ ... (\\"task4\\", \\"2023-04-01\\", 3), ... (\\"task2\\", \\"2023-05-01\\", 1), ... (\\"task3\\", \\"2023-06-01\\", 1), ... (\\"task1\\", \\"2023-07-01\\", 2) ... ] >>> organize_tasks([ ... (\\"task1\\", \\"2023-05-01\\", 1), ... (\\"task2\\", \\"2023-05-01\\", 3), ... (\\"task3\\", \\"2023-05-01\\", 2), ... (\\"task4\\", \\"2023-05-01\\", 4) ... ]) == [ ... (\\"task4\\", \\"2023-05-01\\", 4), ... (\\"task2\\", \\"2023-05-01\\", 3), ... (\\"task3\\", \\"2023-05-01\\", 2), ... (\\"task1\\", \\"2023-05-01\\", 1) ... ] >>> organize_tasks([(\\"task1\\", \\"2023-07-01\\", 2)]) == [(\\"task1\\", \\"2023-07-01\\", 2)] >>> organize_tasks([]) == []","solution":"def organize_tasks(task_list): Sorts tasks based on deadlines in ascending order and priorities in descending order. Args: task_list (list): A list of tuples where each tuple contains task_name (str), deadline (str in YYYY-MM-DD format), and priority (int). Returns: list: A sorted list of tuples. return sorted(task_list, key=lambda task: (task[1], -task[2]))"},{"question":"class LRUCache: Implement LRU Cache System. Initialize the LRU cache with a given capacity. >>> lru = LRUCache(2) >>> lru.put(1, 1) >>> lru.put(2, 2) >>> lru.get(1) # Expected Output: 1 1 >>> lru.put(3, 3) # Evicts key 2 >>> lru.get(2) # Expected Output: -1 (key 2 was evicted) -1 >>> lru.put(4, 4) # Evicts key 1 >>> lru.get(1) # Expected Output: -1 (key 1 was evicted) -1 >>> lru.get(3) # Expected Output: 3 3 >>> lru.get(4) # Expected Output: 4 4 def __init__(self, capacity: int): # Initialize the LRU cache with a given capacity pass def get(self, key: int) -> int: # Retrieve item from cache pass def put(self, key: int, value: int) -> None: # Add/Update item in cache pass # Test cases to verify correctness of the implementation def test_lru_cache(): lru = LRUCache(2) # Initial state tests assert lru.get(1) == -1 # Cache operations lru.put(1, 1) lru.put(2, 2) assert lru.get(1) == 1 lru.put(3, 3) # Evict key 2 assert lru.get(2) == -1 # Key 2 should be evicted lru.put(4, 4) # Evict key 1 assert lru.get(1) == -1 # Key 1 should be evicted assert lru.get(3) == 3 assert lru.get(4) == 4","solution":"class Node: def __init__(self, key: int, value: int): self.key = key self.value = value self.prev = None self.next = None class LRUCache: def __init__(self, capacity: int): self.capacity = capacity self.cache = {} self.head = Node(0, 0) self.tail = Node(0, 0) self.head.next = self.tail self.tail.prev = self.head def _remove(self, node): prev_node = node.prev next_node = node.next prev_node.next = next_node next_node.prev = prev_node def _add(self, node): prev_node = self.tail.prev prev_node.next = node self.tail.prev = node node.prev = prev_node node.next = self.tail def get(self, key: int) -> int: if key in self.cache: node = self.cache[key] self._remove(node) self._add(node) return node.value return -1 def put(self, key: int, value: int) -> None: if key in self.cache: self._remove(self.cache[key]) node = Node(key, value) self._add(node) self.cache[key] = node if len(self.cache) > self.capacity: lru = self.head.next self._remove(lru) del self.cache[lru.key]"},{"question":"def normalize_points(data_points: list[list[float]]) -> list[list[float]]: Args: data_points: A list of data points (each being a list of m float numbers representing m-dimensional coordinates). Returns: A list of data points where each point is normalized by its Euclidean distance from the origin. Example: >>> data_points = [[3.0, 4.0], [1.0, 1.0, 1.0], [-3.0, -4.0, 0.0]] >>> normalize_points(data_points) [[0.6, 0.8], [0.5773502691896257, 0.5773502691896257, 0.5773502691896257], [-0.6, -0.8, 0.0]] pass import math def test_normalize_points_basic(): data_points = [[3.0, 4.0], [1.0, 1.0, 1.0], [-3.0, -4.0, 0.0]] expected_output = [ [0.6, 0.8], [1 / math.sqrt(3), 1 / math.sqrt(3), 1 / math.sqrt(3)], [-0.6, -0.8, 0.0] ] assert normalize_points(data_points) == expected_output def test_normalize_points_single_dimension(): data_points = [[5.0], [-2.0]] expected_output = [[1.0], [-1.0]] assert normalize_points(data_points) == expected_output def test_normalize_points_already_normalized(): data_points = [[0.6, 0.8], [1 / math.sqrt(3), 1 / math.sqrt(3), 1 / math.sqrt(3)]] # These points are already unit vectors, so result should be the same. assert normalize_points(data_points) == data_points def test_normalize_points_large_values(): data_points = [[1000.0, 0.0], [0.0, -1000.0]] expected_output = [[1.0, 0.0], [0.0, -1.0]] assert normalize_points(data_points) == expected_output def test_normalize_points_varied_number_of_dimensions(): data_points = [[1.0, 2.0], [3.0, 4.0, 1.0], [1.0, 2.0, 3.0, 4.0]] expected_output = [ [1 / math.sqrt(5), 2 / math.sqrt(5)], [3 / math.sqrt(26), 4 / math.sqrt(26), 1 / math.sqrt(26)], [1 / math.sqrt(30), 2 / math.sqrt(30), 3 / math.sqrt(30), 4 / math.sqrt(30)] ] assert normalize_points(data_points) == expected_output def test_normalize_points_invalid_input_zeros(): data_points = [[0.0, 0.0], [1.0, 0.0], [0.0, 1.0]] try: normalize_points(data_points) except ZeroDivisionError: assert True","solution":"import math def normalize_points(data_points: list[list[float]]) -> list[list[float]]: def euclidean_distance(point): return math.sqrt(sum(x ** 2 for x in point)) normalized_data_points = [] for point in data_points: distance = euclidean_distance(point) normalized_point = [x / distance for x in point] normalized_data_points.append(normalized_point) return normalized_data_points"},{"question":"def first_palindromic_index(chars: str, length: int) -> int: Returns the starting index of the first palindromic substring of specified length. If no such substring exists, returns -1. pass def test_first_palindromic_index_case1(): assert first_palindromic_index(\\"abacdfgdcabba\\", 3) == 0 # \\"aba\\" is the first palindrome of length 3 def test_first_palindromic_index_case2(): assert first_palindromic_index(\\"abcdefg\\", 3) == -1 # No palindrome of length 3 def test_first_palindromic_index_case3(): assert first_palindromic_index(\\"madamracecar\\", 5) == 0 # \\"madam\\" is the first palindrome of length 5 def test_first_palindromic_index_case4(): assert first_palindromic_index(\\"abccba\\", 4) == 1 # \\"bccb\\" is the first palindrome of length 4 def test_first_palindromic_index_case5(): assert first_palindromic_index(\\"aabbaacc\\", 2) == 0 # \\"aa\\" is the first palindrome of length 2 def test_first_palindromic_index_case6(): assert first_palindromic_index(\\"\\", 1) == -1 # Edge case: Empty string def test_first_palindromic_index_case7(): assert first_palindromic_index(\\"abc\\", 5) == -1 # Length greater than string length def test_first_palindromic_index_case8(): assert first_palindromic_index(\\"racecarr\\", 7) == 0 # \\"racecar\\" is the first palindrome of length 7 def test_first_palindromic_index_case9(): assert first_palindromic_index(\\"noonmadam\\", 4) == 0 # \\"noon\\" is the first palindrome of length 4 def test_first_palindromic_index_case10(): assert first_palindromic_index(\\"neveroddoreven\\", 14) == 0 # \\"neveroddoreven\\" is the first palindrome of length 14","solution":"def first_palindromic_index(chars: str, length: int) -> int: Returns the starting index of the first palindromic substring of specified length. If no such substring exists, returns -1. n = len(chars) if length > n: return -1 for i in range(n - length + 1): substr = chars[i:i+length] if substr == substr[::-1]: return i return -1"},{"question":"def enhanced_is_palindrome(input_str: str, ignorable_chars: set) -> bool: Checks if the input string is a palindrome, ignoring given ignorable characters and checking in a case-insensitive manner. Parameters: input_str (str): The string to be checked. ignorable_chars (set): A set of characters that should be ignored in the palindrome check. Returns: bool: True if the string is a palindrome ignoring the ignorable characters, otherwise False. Raises: ValueError: When the input is not a string. >>> enhanced_is_palindrome(\\"A man, a plan, a canal, Panama!\\", {\\" \\"}) True >>> enhanced_is_palindrome(\\"No 'x' in Nixon\\", {\\"'\\", \\" \\"}) True >>> enhanced_is_palindrome(\\"Was it a car or a cat I saw?\\", set()) True >>> enhanced_is_palindrome(\\"Hello, World!\\", {\\",\\"}) False >>> enhanced_is_palindrome(\\"MadamInEdenImAdam\\", {\\"I\\", \\"m\\"}) False >>> enhanced_is_palindrome(12345, set()) Traceback (most recent call last): ... ValueError: Expected string as input, found <class 'int'> pass","solution":"def enhanced_is_palindrome(input_str: str, ignorable_chars: set) -> bool: Checks if the input string is a palindrome, ignoring given ignorable characters and checking in a case-insensitive manner. Parameters: input_str (str): The string to be checked. ignorable_chars (set): A set of characters that should be ignored in the palindrome check. Returns: bool: True if the string is a palindrome ignoring the ignorable characters, otherwise False. Raises: ValueError: When the input is not a string. if not isinstance(input_str, str): raise ValueError(f\\"Expected string as input, found {type(input_str)}\\") left, right = 0, len(input_str) - 1 ignorable_chars = set(ignorable_chars) # Ensure set to ignore duplicates while left < right: while left < right and (not input_str[left].isalnum() or input_str[left] in ignorable_chars): left += 1 while left < right and (not input_str[right].isalnum() or input_str[right] in ignorable_chars): right -= 1 if left < right and input_str[left].lower() != input_str[right].lower(): return False left += 1 right -= 1 return True"},{"question":"from typing import List, Dict, Any def sort_and_filter_students(students: List[Dict[str, Any]], min_score: int) -> List[Dict[str, Any]]: Filter out students who have scored below min_score and then sort the remaining students by their score in descending order and by their name in ascending order. >>> students = [ ... {\\"name\\": \\"Alice\\", \\"score\\": 50}, ... {\\"name\\": \\"Bob\\", \\"score\\": 80}, ... {\\"name\\": \\"Charlie\\", \\"score\\": 50}, ... {\\"name\\": \\"David\\", \\"score\\": 90}, ... {\\"name\\": \\"Eve\\", \\"score\\": 85} ... ] >>> sort_and_filter_students(students, 60) [{'name': 'David', 'score': 90}, {'name': 'Eve', 'score': 85}, {'name': 'Bob', 'score': 80}] >>> sort_and_filter_students(students, 100) [] >>> sort_and_filter_students([], 50) [] >>> sort_and_filter_students(students, 40) [{'name': 'David', 'score': 90}, {'name': 'Eve', 'score': 85}, {'name': 'Bob', 'score': 80}, {'name': 'Alice', 'score': 50}, {'name': 'Charlie', 'score': 50}]","solution":"from typing import List, Dict, Any def sort_and_filter_students(students: List[Dict[str, Any]], min_score: int) -> List[Dict[str, Any]]: # Filter students based on min_score filtered_students = [student for student in students if student['score'] >= min_score] # Sort students by score in descending order, and then by name in ascending order sorted_students = sorted(filtered_students, key=lambda student: (-student['score'], student['name'])) return sorted_students"},{"question":"from typing import List def max_subarray_sum_fixed_size(nums: List[int], k: int) -> int: Computes the maximum sum of any subarray with a fixed size k. >>> max_subarray_sum_fixed_size([1, -2, 3, 4, -1, 2, 1, -5, 4], 3) 6 >>> max_subarray_sum_fixed_size([1, 2, 3, 4, -10], 4) 10 >>> max_subarray_sum_fixed_size([5, -3, 5, 1], 2) 6 Args: nums -- List of integers representing the array. k -- Integer representing the size of subarray. Returns: Integer representing the maximum sum of any subarray of size k. Raises: ValueError -- If the input array is empty or if k is not valid.","solution":"from typing import List def max_subarray_sum_fixed_size(nums: List[int], k: int) -> int: Computes the maximum sum of any subarray with a fixed size k. if not nums or k <= 0 or k > len(nums): raise ValueError(\\"Invalid input\\") # Calculate the sum of the first k elements window_sum = sum(nums[:k]) max_sum = window_sum # Slide the window over the array for i in range(k, len(nums)): window_sum += nums[i] - nums[i - k] max_sum = max(max_sum, window_sum) return max_sum"},{"question":"def generate_morse_code(text: str) -> str: Converts a given text string into its equivalent Morse code representation. Each character in the text string will be converted to Morse code, with individual Morse code symbols separated by a single space and words separated by a single forward slash ('/'). Args: text (str): A string consisting of letters (both uppercase and lowercase), numbers, punctuation, and spaces. Returns: str: A string representing the input text converted to Morse code. >>> generate_morse_code(\\"Hello\\") \\".... . .-.. .-.. ---\\" >>> generate_morse_code(\\"Hello, World!\\") \\".... . .-.. .-.. --- --..-- / .-- --- .-. .-.. -.. -.-.--\\" >>> generate_morse_code(\\"123\\") \\".---- ..--- ...--\\" >>> generate_morse_code(\\"Hello WoRLd\\") \\".... . .-.. .-.. --- / .-- --- .-. .-.. -..\\" >>> generate_morse_code(\\"Hello World\\") \\".... . .-.. .-.. --- / / / .-- --- .-. .-.. -..\\" >>> generate_morse_code(\\"HELLO?\\") \\".... . .-.. .-.. --- ..--..\\" >>> generate_morse_code(\\"STOP.\\") \\"... - --- .--. .-.-.-\\" morse_code_dict = { 'A': '.-', 'B': '-...', 'C': '-.-.', 'D': '-..', 'E': '.', 'F': '..-.', 'G': '--.', 'H': '....', 'I': '..', 'J': '.---', 'K': '-.-', 'L': '.-..', 'M': '--', 'N': '-.', 'O': '---', 'P': '.--.', 'Q': '--.-', 'R': '.-.', 'S': '...', 'T': '-', 'U': '..-', 'V': '...-', 'W': '.--', 'X': '-..-', 'Y': '-.--', 'Z': '--..', '0': '-----', '1': '.----', '2': '..---', '3': '...--', '4': '....-', '5': '.....', '6': '-....', '7': '--...', '8': '---..', '9': '----.', '.': '.-.-.-', ',': '--..--', '?': '..--..', '!': '-.-.--', ' ': '/' } result = [] for char in text.upper(): if char in morse_code_dict: result.append(morse_code_dict[char]) return ' '.join(result)","solution":"def generate_morse_code(text: str) -> str: morse_code_dict = { 'A': '.-', 'B': '-...', 'C': '-.-.', 'D': '-..', 'E': '.', 'F': '..-.', 'G': '--.', 'H': '....', 'I': '..', 'J': '.---', 'K': '-.-', 'L': '.-..', 'M': '--', 'N': '-.', 'O': '---', 'P': '.--.', 'Q': '--.-', 'R': '.-.', 'S': '...', 'T': '-', 'U': '..-', 'V': '...-', 'W': '.--', 'X': '-..-', 'Y': '-.--', 'Z': '--..', '0': '-----', '1': '.----', '2': '..---', '3': '...--', '4': '....-', '5': '.....', '6': '-....', '7': '--...', '8': '---..', '9': '----.', '.': '.-.-.-', ',': '--..--', '?': '..--..', '!': '-.-.--', ' ': '/' } result = [] for char in text.upper(): if char in morse_code_dict: result.append(morse_code_dict[char]) return ' '.join(result)"},{"question":"def longest_compound_word(words: List[str]) -> str: Find the longest word in the list that can be constructed by utilizing other words from the list. Each word must be used exactly once to form the longest word. >>> longest_compound_word([\\"cat\\", \\"cats\\", \\"catsdogcats\\", \\"dog\\", \\"dogs\\", \\"dogcatsdog\\"]) 'catsdogcats' >>> longest_compound_word([\\"rat\\", \\"ratcat\\", \\"cat\\", \\"ate\\", \\"rate\\", \\"ratcatdog\\", \\"dog\\"]) 'ratcatdog' >>> longest_compound_word([\\"a\\", \\"aa\\", \\"aaa\\", \\"aaaa\\"]) 'aaaa' pass import pytest def test_example_1(): assert longest_compound_word([\\"cat\\", \\"cats\\", \\"catsdogcats\\", \\"dog\\", \\"dogs\\", \\"dogcatsdog\\"]) == \\"catsdogcats\\" def test_example_2(): assert longest_compound_word([\\"rat\\", \\"ratcat\\", \\"cat\\", \\"ate\\", \\"rate\\", \\"ratcatdog\\", \\"dog\\"]) == \\"ratcatdog\\" def test_example_3(): assert longest_compound_word([\\"a\\", \\"aa\\", \\"aaa\\", \\"aaaa\\"]) == \\"aaaa\\" def test_empty_list_raises_error(): with pytest.raises(ValueError): longest_compound_word([]) def test_no_compound_word(): assert longest_compound_word([\\"apple\\", \\"banana\\", \\"cherry\\"]) == \\"\\" def test_single_letter_words(): assert longest_compound_word([\\"a\\", \\"b\\", \\"c\\", \\"ab\\", \\"bc\\", \\"abc\\"]) == \\"abc\\" def test_longest_word_first(): assert longest_compound_word([\\"longword\\", \\"long\\", \\"word\\", \\"longerword\\", \\"longer\\", \\"worder\\"]) == \\"longerword\\" def test_words_with_duplicates(): assert longest_compound_word([\\"a\\", \\"b\\", \\"ab\\", \\"bab\\", \\"abb\\", \\"abba\\"]) == \\"abba\\"","solution":"def longest_compound_word(words): if not words: raise ValueError(\\"Input list should not be empty\\") word_set = set(words) def can_form(word, word_set): if word in word_set: return True for i in range(1, len(word)): if word[:i] in word_set and can_form(word[i:], word_set): return True return False compound_words = [] for word in words: word_set.remove(word) if can_form(word, word_set): compound_words.append(word) word_set.add(word) return max(compound_words, key=len, default='') # Test cases for manual verification print(longest_compound_word([\\"cat\\", \\"cats\\", \\"catsdogcats\\", \\"dog\\", \\"dogs\\", \\"dogcatsdog\\"])) # Output: \\"catsdogcats\\" print(longest_compound_word([\\"rat\\", \\"ratcat\\", \\"cat\\", \\"ate\\", \\"rate\\", \\"ratcatdog\\", \\"dog\\"])) # Output: \\"ratcatdog\\" print(longest_compound_word([\\"a\\", \\"aa\\", \\"aaa\\", \\"aaaa\\"])) # Output: \\"aaaa\\""},{"question":"def is_valid_rook_move(board: list, start: tuple, end: tuple) -> bool: Checks if a rook can legally move from the start position to the end position on the board. :param board: List[List[str]] - 2D list representing the chessboard :param start: Tuple[int, int] - starting coordinates (row, col) of the rook :param end: Tuple[int, int] - ending coordinates (row, col) of the rook :return: bool - True if the move is valid, False otherwise Example: >>> board = [ >>> [\\"WR\\", \\"\\", \\"\\", \\"\\", \\"\\", \\"\\", \\"\\", \\"\\"], >>> [\\"\\", \\"\\", \\"\\", \\"\\", \\"WP\\", \\"\\", \\"\\", \\"\\"], >>> [\\"\\", \\"\\", \\"\\", \\"\\", \\"\\", \\"\\", \\"\\", \\"\\"], >>> [\\"\\", \\"\\", \\"\\", \\"\\", \\"\\", \\"\\", \\"\\", \\"\\"], >>> [\\"\\", \\"\\", \\"\\", \\"\\", \\"\\", \\"\\", \\"\\", \\"\\"], >>> [\\"\\", \\"\\", \\"\\", \\"\\", \\"\\", \\"\\", \\"\\", \\"\\"], >>> [\\"\\", \\"\\", \\"\\", \\"\\", \\"\\", \\"\\", \\"\\", \\"\\"], >>> [\\"BR\\", \\"\\", \\"\\", \\"\\", \\"\\", \\"\\", \\"\\", \\"WR\\"], >>> ] >>> is_valid_rook_move(board, (0, 0), (0, 7)) True >>> board = [ >>> [\\"WR\\", \\"\\", \\"\\", \\"WP\\", \\"\\", \\"\\", \\"\\", \\"\\"], >>> [\\"\\", \\"\\", \\"\\", \\"\\", \\"\\", \\"\\", \\"\\", \\"\\"], >>> [\\"\\", \\"\\", \\"\\", \\"\\", \\"\\", \\"\\", \\"\\", \\"\\"], >>> [\\"\\", \\"\\", \\"\\", \\"\\", \\"\\", \\"\\", \\"\\", \\"\\"], >>> [\\"\\", \\"\\", \\"\\", \\"\\", \\"\\", \\"\\", \\"\\", \\"\\"], >>> [\\"\\", \\"\\", \\"\\", \\"\\", \\"\\", \\"\\", \\"\\", \\"\\"], >>> [\\"\\", \\"\\", \\"\\", \\"\\", \\"\\", \\"\\", \\"\\", \\"\\"], >>> [\\"\\", \\"\\", \\"\\", \\"\\", \\"\\", \\"\\", \\"\\", \\"WR\\"], >>> ] >>> is_valid_rook_move(board, (0, 0), (0, 7)) False pass if __name__ == \\"__main__\\": import doctest doctest.testmod()","solution":"def is_valid_rook_move(board, start, end): Checks if a rook can legally move from the start position to the end position on the board. :param board: List[List[str]] - 2D list representing the chessboard :param start: Tuple[int, int] - starting coordinates (row, col) of the rook :param end: Tuple[int, int] - ending coordinates (row, col) of the rook :return: bool - True if the move is valid, False otherwise start_row, start_col = start end_row, end_col = end start_piece = board[start_row][start_col] end_piece = board[end_row][end_col] if start_piece == \\"\\" or \\"R\\" not in start_piece: return False if start_row != end_row and start_col != end_col: return False if start_row == end_row: step = 1 if start_col < end_col else -1 for col in range(start_col + step, end_col, step): if board[start_row][col] != \\"\\": return False if start_col == end_col: step = 1 if start_row < end_row else -1 for row in range(start_row + step, end_row, step): if board[row][start_col] != \\"\\": return False if end_piece != \\"\\" and start_piece[0] == end_piece[0]: return False return True"},{"question":"def prime_factors(n: int) -> list: Computes the prime factors of a given integer. :param n: An integer to factorize. :return: A list of prime factors in ascending order. >>> prime_factors(60) [2, 2, 3, 5] >>> prime_factors(45) [3, 3, 5] >>> prime_factors(13) [13] >>> prime_factors(1) []","solution":"def prime_factors(n: int) -> list: Computes the prime factors of a given integer. :param n: An integer to factorize. :return: A list of prime factors in ascending order. if n < 2: return [] factors = [] # Handle the smallest prime number (2) while n % 2 == 0: factors.append(2) n //= 2 # Handle odd numbers from 3 upwards factor = 3 while factor * factor <= n: while n % factor == 0: factors.append(factor) n //= factor factor += 2 # If n is still larger than 2, then it's a prime number if n > 1: factors.append(n) return factors"},{"question":"def maximize_sales(product_infos, max_units): Determine the maximum profit achievable without exceeding the storage limit using dynamic programming. :param product_infos: List of tuples (profit, weight) for each product. :param max_units: Maximum number of units that can be stocked. :return: Maximum profit. >>> maximize_sales([(10, 2), (5, 1), (15, 3), (7, 2)], 5) 25 >>> maximize_sales([(20, 5)], 5) 20 >>> maximize_sales([(20, 6)], 5) 0 >>> maximize_sales([(10, 1), (20, 2), (30, 3)], 6) 60 >>> maximize_sales([(10, 1), (20, 2), (30, 3)], 0) 0","solution":"def maximize_sales(product_infos, max_units): Determine the maximum profit achievable without exceeding the storage limit using dynamic programming. :param product_infos: List of tuples (profit, weight) for each product. :param max_units: Maximum number of units that can be stocked. :return: Maximum profit. n = len(product_infos) # Initialize the DP array with 0s dp = [0] * (max_units + 1) # Iterate over each product's profit and weight for profit, weight in product_infos: # Traverse the dp array backwards to avoid recomputation for i in range(max_units, weight - 1, -1): dp[i] = max(dp[i], dp[i - weight] + profit) return dp[max_units]"},{"question":"def initialize_population(pop_size: int, string_length: int) -> list[str]: Generate the initial population of binary strings. Args: - pop_size (int): Number of individuals in the population. - string_length (int): Length of each binary string. Returns: - list[str]: List of binary strings representing the initial population. pass def fitness(binary_string: str) -> int: Compute the fitness of a binary string. Higher number of '1's implies higher fitness. Args: - binary_string (str): Binary string to evaluate. Returns: - int: Fitness value of the binary string. pass def selection(population: list[str], fitnesses: list[int]) -> list[str]: Select pairs of parents using roulette wheel selection based on fitness. Args: - population (list[str]): List of binary strings representing the population. - fitnesses (list[int]): Corresponding fitness values of the population. Returns: - list[str]: List of selected parent binary strings. pass def crossover(parents: list[str], crossover_rate: float) -> list[str]: Perform single-point crossover between pairs of parents. Args: - parents (list[str]): List of selected parent binary strings. - crossover_rate (float): Probability of crossover occurring. Returns: - list[str]: List of binary strings representing the new generation after crossover. pass def mutation(population: list[str], mutation_rate: float) -> list[str]: Mutate the binary strings with a given mutation rate. Args: - population (list[str]): List of binary strings representing the population. - mutation_rate (float): Probability of flipping each bit. Returns: - list[str]: List of mutated binary strings. pass def evolve(initial_population: list[str], generations: int, crossover_rate: float, mutation_rate: float) -> list[str]: Evolve the population over a specified number of generations. Args: - initial_population (list[str]): Initial population of binary strings. - generations (int): Number of generations to evolve. - crossover_rate (float): Probability of crossover occurring. - mutation_rate (float): Probability of flipping each bit. Returns: - list[str]: Final population after evolution. pass from solution import initialize_population, fitness, selection, crossover, mutation, evolve def test_initialize_population(): pop_size = 10 string_length = 8 population = initialize_population(pop_size, string_length) assert len(population) == pop_size assert all(len(individual) == string_length for individual in population) def test_fitness(): assert fitness(\\"1100\\") == 2 assert fitness(\\"1111\\") == 4 assert fitness(\\"0000\\") == 0 def test_selection(): population = [\\"1100\\", \\"1010\\", \\"1001\\", \\"0110\\"] fitnesses = [fitness(ind) for ind in population] selected = selection(population, fitnesses) assert len(selected) == len(population) assert set(selected).issubset(set(population)) def test_crossover(): parents = [\\"1100\\", \\"0011\\"] crossover_rate = 1.0 # Ensure crossover happens new_population = crossover(parents, crossover_rate) assert len(new_population) == len(parents) assert new_population[0] != parents[0] and new_population[1] != parents[1] def test_mutation(): population = [\\"1100\\", \\"0011\\"] mutation_rate = 1.0 # Ensure mutation happens new_population = mutation(population, mutation_rate) assert len(new_population) == len(population) assert new_population[0] != population[0] and new_population[1] != population[1] def test_evolve(): pop_size = 10 string_length = 8 generations = 5 crossover_rate = 0.7 mutation_rate = 0.01 initial_population = initialize_population(pop_size, string_length) final_population = evolve(initial_population, generations, crossover_rate, mutation_rate) assert len(final_population) == pop_size","solution":"import random def initialize_population(pop_size: int, string_length: int) -> list[str]: Generate the initial population of binary strings. Args: - pop_size (int): Number of individuals in the population. - string_length (int): Length of each binary string. Returns: - list[str]: List of binary strings representing the initial population. return [''.join(random.choice('01') for _ in range(string_length)) for _ in range(pop_size)] def fitness(binary_string: str) -> int: Compute the fitness of a binary string. Higher number of '1's implies higher fitness. Args: - binary_string (str): Binary string to evaluate. Returns: - int: Fitness value of the binary string. return binary_string.count('1') def selection(population: list[str], fitnesses: list[int]) -> list[str]: Select pairs of parents using roulette wheel selection based on fitness. Args: - population (list[str]): List of binary strings representing the population. - fitnesses (list[int]): Corresponding fitness values of the population. Returns: - list[str]: List of selected parent binary strings. total_fitness = sum(fitnesses) weights = [f/total_fitness for f in fitnesses] selected_parents = random.choices(population, weights=weights, k=len(population)) return selected_parents def crossover(parents: list[str], crossover_rate: float) -> list[str]: Perform single-point crossover between pairs of parents. Args: - parents (list[str]): List of selected parent binary strings. - crossover_rate (float): Probability of crossover occurring. Returns: - list[str]: List of binary strings representing the new generation after crossover. new_generation = [] for i in range(0, len(parents), 2): parent1 = parents[i] parent2 = parents[i+1 if i+1 < len(parents) else i] if random.random() < crossover_rate and parent1 != parent2: crossover_point = random.randint(1, len(parent1) - 1) offspring1 = parent1[:crossover_point] + parent2[crossover_point:] offspring2 = parent2[:crossover_point] + parent1[crossover_point:] new_generation.extend([offspring1, offspring2]) else: new_generation.extend([parent1, parent2]) return new_generation def mutation(population: list[str], mutation_rate: float) -> list[str]: Mutate the binary strings with a given mutation rate. Args: - population (list[str]): List of binary strings representing the population. - mutation_rate (float): Probability of flipping each bit. Returns: - list[str]: List of mutated binary strings. mutated_population = [] for individual in population: mutated_individual = ''.join( bit if random.random() > mutation_rate else '1' if bit == '0' else '0' for bit in individual ) mutated_population.append(mutated_individual) return mutated_population def evolve(initial_population: list[str], generations: int, crossover_rate: float, mutation_rate: float) -> list[str]: Evolve the population over a specified number of generations. Args: - initial_population (list[str]): Initial population of binary strings. - generations (int): Number of generations to evolve. - crossover_rate (float): Probability of crossover occurring. - mutation_rate (float): Probability of flipping each bit. Returns: - list[str]: Final population after evolution. population = initial_population for _ in range(generations): fitnesses = [fitness(individual) for individual in population] selected_parents = selection(population, fitnesses) population = crossover(selected_parents, crossover_rate) population = mutation(population, mutation_rate) return population"},{"question":"from typing import List def find_majority_element(nums: List[int]) -> int: Return the majority element of the array if it exists, otherwise -1. >>> find_majority_element([3, 3, 4, 2, 3, 3, 5, 3]) 3 >>> find_majority_element([1, 1, 2, 2, 2]) 2 >>> find_majority_element([1, 2, 3]) -1","solution":"from typing import List def find_majority_element(nums: List[int]) -> int: Return the majority element of the array if it exists, otherwise -1. count = 0 candidate = None # Phase 1: Find a candidate for the majority element for num in nums: if count == 0: candidate = num count += (1 if num == candidate else -1) # Phase 2: Verify that the candidate is a majority element if nums.count(candidate) > len(nums) // 2: return candidate else: return -1"},{"question":"def min_platforms(arr: list[str], dep: list[str]) -> int: Calculate the minimum number of platforms required at a station such that no train waits. >>> min_platforms([\\"09:00\\", \\"09:40\\", \\"09:50\\", \\"11:00\\"], [\\"09:10\\", \\"12:00\\", \\"11:20\\", \\"11:30\\"]) 3 >>> min_platforms([\\"09:00\\", \\"09:20\\"], [\\"09:19\\", \\"09:21\\"]) 1 >>> min_platforms([\\"10:00\\", \\"10:05\\"], [\\"10:10\\", \\"10:15\\"]) 2 >>> min_platforms([], []) 0","solution":"def min_platforms(arr: list[str], dep: list[str]) -> int: Calculate the minimum number of platforms required at a station such that no train waits. Parameters: arr (list of str): A list of strings representing the arrival times of trains in \\"HH:MM\\" format. dep (list of str): A list of strings representing the departure times of trains in \\"HH:MM\\" format. Returns: int: The minimum number of platforms required. if not arr or not dep or len(arr) != len(dep): return 0 # Convert times to minutes from midnight for easy comparison arr = [int(a[:2])*60 + int(a[3:]) for a in arr] dep = [int(d[:2])*60 + int(d[3:]) for d in dep] # Sort arrival and departure times arr.sort() dep.sort() # Initialize platform need and result platform_needed = 0 max_platforms = 0 # Pointers to track arrivals and departures i, j = 0, 0 n = len(arr) # Similar to merge process of merge sort while i < n and j < n: if arr[i] < dep[j]: platform_needed += 1 i += 1 if platform_needed > max_platforms: max_platforms = platform_needed else: platform_needed -= 1 j += 1 return max_platforms"},{"question":"def calculate_change(amount_paid: float, item_cost: float) -> dict: Calculate the smallest number of coins and bills required to make the change. Denominations include 100, 50, 20, 10, 5, 1, 0.25, 0.10, 0.05, and 0.01. >>> calculate_change(200, 121.96) {'100': 0, '50': 1, '20': 1, '10': 0, '5': 1, '1': 3, '0.25': 0, '0.10': 0, '0.05': 0, '0.01': 4} >>> calculate_change(150, 143.45) {'100': 0, '50': 0, '20': 0, '10': 0, '5': 1, '1': 1, '0.25': 2, '0.10': 0, '0.05': 1, '0.01': 0} >>> calculate_change(10, 10) {'100': 0, '50': 0, '20': 0, '10': 0, '5': 0, '1': 0, '0.25': 0, '0.10': 0, '0.05': 0, '0.01': 0}","solution":"def calculate_change(amount_paid: float, item_cost: float) -> dict: Calculate the smallest number of coins and bills required to make the change. denominations = [ ('100', 100.0), ('50', 50.0), ('20', 20.0), ('10', 10.0), ('5', 5.0), ('1', 1.0), ('0.25', 0.25), ('0.10', 0.10), ('0.05', 0.05), ('0.01', 0.01) ] change_dict = {den: 0 for den, _ in denominations} change = round(amount_paid - item_cost, 2) for den, value in denominations: count = int(change // value) change_dict[den] = count change -= count * value change = round(change, 2) # Avoid floating point precision issues return change_dict"},{"question":"def calculate_histogram(image: list[list[int]]) -> list[int]: Calculate the histogram of pixel intensities for a given grayscale image. :param image: 2D list of integers where each integer is between 0 and 255 inclusive :return: List of 256 integers representing the histogram of pixel intensities >>> image = [ ... [0, 255, 127, 127], ... [0, 127, 127, 0], ... [255, 0, 0, 255], ... [127, 127, 0, 0] ... ] >>> calculate_histogram(image) [7, 0, 0, ..., 0, 0, 4] # length of the list is 256 pass # Unit Tests def test_calculate_histogram_uniform_image(): image = [ [5, 5, 5], [5, 5, 5], [5, 5, 5] ] assert calculate_histogram(image) == [0]*5 + [9] + [0]*250 def test_calculate_histogram_all_zero(): image = [ [0, 0], [0, 0] ] assert calculate_histogram(image) == [4] + [0]*255 def test_calculate_histogram_mixed_values(): image = [ [0, 1, 2, 3, 4], [5, 6, 7, 8, 9], [10, 11, 12, 13, 14] ] expected_result = [1] * 15 + [0] * 241 assert calculate_histogram(image) == expected_result def test_calculate_histogram_large_image(): image = [[i % 256 for i in range(256)] for _ in range(256)] expected_result = [256] * 256 assert calculate_histogram(image) == expected_result def test_calculate_histogram_single_pixel(): image = [ [123] ] assert calculate_histogram(image) == [0]*123 + [1] + [0]*132 # Running the tests if __name__ == \\"__main__\\": import pytest pytest.main([__file__])","solution":"def calculate_histogram(image: list[list[int]]) -> list[int]: Calculate the histogram of pixel intensities for a given grayscale image. :param image: 2D list of integers where each integer is between 0 and 255 inclusive :return: List of 256 integers representing the histogram of pixel intensities histogram = [0] * 256 for row in image: for pixel in row: histogram[pixel] += 1 return histogram"},{"question":"class UniqueNumberFinder: def __init__(self, nums: list[int]): Initialize with a list of integers. self.nums = nums def find_unique_number(self) -> int: Find the unique number in the list where every other number appears exactly twice. >>> unf = UniqueNumberFinder([4, 1, 2, 1, 2]) >>> unf.find_unique_number() 4 >>> unf = UniqueNumberFinder([7]) >>> unf.find_unique_number() 7 >>> unf = UniqueNumberFinder([5, 5, 8, 8, 1, 1, 9, 9, 17]) >>> unf.find_unique_number() 17 >>> unf = UniqueNumberFinder([10, -10, -10]) >>> unf.find_unique_number() 10 >>> unf = UniqueNumberFinder([-1, 3, -1, 2, 3, 4, 2]) >>> unf.find_unique_number() 4","solution":"class UniqueNumberFinder: def __init__(self, nums: list[int]): self.nums = nums def find_unique_number(self) -> int: unique_number = 0 for num in self.nums: unique_number ^= num return unique_number"},{"question":"from typing import List def min_coin_count(coins: List[int], amount: int) -> int: Finds the minimum number of coins needed to make up a given amount with a provided set of coin denominations. Arguments: coins: List[int] -- an array of distinct integers representing coin denominations amount: int -- an integer representing the total amount of money Returns: int -- the minimal number of coins needed to make up the given amount, or -1 if it's not possible Examples: >>> min_coin_count([1, 2, 5], 11) 3 >>> min_coin_count([2], 3) -1 >>> min_coin_count([1, 2, 5, 10], 18) 4 def test_min_coin_count(): assert min_coin_count([1, 2, 5], 11) == 3 assert min_coin_count([2], 3) == -1 assert min_coin_count([1, 2, 5, 10], 18) == 4 assert min_coin_count([1], 0) == 0 assert min_coin_count([1], 1) == 1 assert min_coin_count([1, 3, 4], 6) == 2 # 4 + 2 assert min_coin_count([2, 4, 5], 11) == 3 # 5 + 4 + 2 assert min_coin_count([5], 10) == 2 assert min_coin_count([2, 5, 10], 27) == 4 # 10 + 10 + 5 + 2 assert min_coin_count([1, 7, 10], 14) == 2 # 7 + 7 # To run tests if __name__ == \\"__main__\\": import pytest pytest.main([__file__])","solution":"def min_coin_count(coins, amount): Function to find the minimum number of coins needed to make up a given amount. # Initialize the dp array with inf. # dp[i] will be storing the minimum number of coins required for amount i dp = [float('inf')] * (amount + 1) # Base case: No coins are needed to make up 0 amount dp[0] = 0 # Iterate through all amounts from 1 to 'amount' for i in range(1, amount + 1): for coin in coins: # If the coin value is less than or equal to the amount, # only then we can use it to form the given amount if i - coin >= 0: dp[i] = min(dp[i], dp[i - coin] + 1) return dp[amount] if dp[amount] != float('inf') else -1"},{"question":"def calculate_speed(distance_run: float, total_time: float) -> float: Calculate the average speed given a distance and total time. Args: distance_run: float : Distance run in kilometers. total_time: float : Total time in minutes. Returns: float : Average speed in kilometers per hour. # Implement the calculation of average speed def pace_analysis(average_speed: float) -> str: Provide a brief description of the runner's pace based on average speed. Args: average_speed: float : Average speed in kilometers per hour. Returns: str : Description of the runner's pace. # Implement the pace analysis logic def running_summary(average_speed: float) -> str: Suggest the next milestone based on current performance. Args: average_speed: float : Average speed in kilometers per hour. Returns: str : Suggested next milestone. # Implement the running summary logic def runner_insights(distance_run: float, total_time: float) -> dict: Provides a detailed summary of the runner's performance. Args: distance_run: float : Distance run in kilometers. total_time: float : Total time in minutes. Returns: dict : Detailed summary of the runner's performance. # Implement the runner insights functionality # Unit tests def test_calculate_speed(): assert calculate_speed(5, 25) == 12.0 assert calculate_speed(10, 60) == 10.0 assert calculate_speed(2.5, 30) == 5.0 assert calculate_speed(7, 35) == 12.0 def test_pace_analysis(): assert pace_analysis(5.0) == 'Slow pace' assert pace_analysis(10.0) == 'Moderate pace' assert pace_analysis(12.0) == 'Moderate pace' assert pace_analysis(13.0) == 'Fast pace' def test_running_summary(): assert running_summary(5.0) == 'Run 5 km' assert running_summary(10.0) == 'Run 10 km' assert running_summary(12.0) == 'Run 10 km' assert running_summary(13.0) == 'Run 15 km' def test_runner_insights(): result = runner_insights(5, 25) assert result['average_speed'] == 12.0 assert result['pace_analysis'] == 'Moderate pace' assert result['recommended_milestone'] == 'Run 10 km' result = runner_insights(10, 60) assert result['average_speed'] == 10.0 assert result['pace_analysis'] == 'Moderate pace' assert result['recommended_milestone'] == 'Run 10 km' result = runner_insights(2.5, 30) assert result['average_speed'] == 5.0 assert result['pace_analysis'] == 'Slow pace' assert result['recommended_milestone'] == 'Run 5 km' result = runner_insights(7, 35) assert result['average_speed'] == 12.0 assert result['pace_analysis'] == 'Moderate pace' assert result['recommended_milestone'] == 'Run 10 km'","solution":"def calculate_speed(distance_run, total_time): Calculate the average speed given a distance and total time. Args: distance_run: float : Distance run in kilometers. total_time: float : Total time in minutes. Returns: float : Average speed in kilometers per hour. return (distance_run / total_time) * 60 def pace_analysis(average_speed): Provide a brief description of the runner's pace based on average speed. Args: average_speed: float : Average speed in kilometers per hour. Returns: str : Description of the runner's pace. if average_speed < 8: return 'Slow pace' elif 8 <= average_speed <= 12: return 'Moderate pace' else: return 'Fast pace' def running_summary(average_speed): Suggest the next milestone based on current performance. Args: average_speed: float : Average speed in kilometers per hour. Returns: str : Suggested next milestone. if average_speed < 8: return 'Run 5 km' elif 8 <= average_speed <= 12: return 'Run 10 km' else: return 'Run 15 km' def runner_insights(distance_run, total_time): Provides a detailed summary of the runner's performance. Args: distance_run: float : Distance run in kilometers. total_time: float : Total time in minutes. Returns: dict : Detailed summary of the runner's performance. average_speed = calculate_speed(distance_run, total_time) pace_desc = pace_analysis(average_speed) milestone = running_summary(average_speed) return { 'average_speed': round(average_speed, 2), 'pace_analysis': pace_desc, 'recommended_milestone': milestone }"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def count_nodes_in_range(root: TreeNode, low: int, high: int) -> int: Count the number of nodes in the BST with values in the range [low, high]. Args: root (TreeNode): The root of the binary search tree. low (int): The lower bound of the range. high (int): The upper bound of the range. Returns: int: The count of nodes within the specified range. Examples: >>> root = TreeNode(10, TreeNode(5), TreeNode(15, None, TreeNode(20))) >>> count_nodes_in_range(root, 5, 15) 3 >>> root = TreeNode(12, TreeNode(7, TreeNode(5), TreeNode(9)), TreeNode(15, None, TreeNode(18))) >>> count_nodes_in_range(root, 6, 10) 2 >>> root = None >>> count_nodes_in_range(root, 1, 10) 0 # Implement your code here...","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def count_nodes_in_range(root: TreeNode, low: int, high: int) -> int: Count the number of nodes in the BST with values in the range [low, high]. Args: root (TreeNode): The root of the binary search tree. low (int): The lower bound of the range. high (int): The upper bound of the range. Returns: int: The count of nodes within the specified range. if root is None: return 0 count = 0 if low <= root.val <= high: count += 1 if root.val > low: count += count_nodes_in_range(root.left, low, high) if root.val < high: count += count_nodes_in_range(root.right, low, high) return count"},{"question":"def find_duplicates(transactions: list[int]) -> list[int]: Determine which transaction amounts have duplicates and return them in the sequence they first appeared as duplicates. >>> find_duplicates([10, 15, 10, 20, 15, 30, 10]) [10, 15] >>> find_duplicates([5, 25, 15, 25, 5, 15, 5]) [25, 5, 15]","solution":"def find_duplicates(transactions: list[int]) -> list[int]: seen = set() duplicates = set() result = [] for transaction in transactions: if transaction in seen: if transaction not in duplicates: duplicates.add(transaction) result.append(transaction) else: seen.add(transaction) return result"},{"question":"from typing import List def median_filter(signal: List[int], k: int) -> List[int]: Applies a median filter to the input signal. Parameters: signal (list): A list of integers representing the signal to be filtered. k (int): An odd integer representing the size of the window to apply median filtering. Returns: list: A list of integers representing the filtered signal. Raises: ValueError: If k is not a positive odd integer or if the length of the signal is less than the window size k. Examples: >>> median_filter([1, 2, 3, 4, 5], 3) [2, 3, 4] >>> median_filter([4, 1, 7, 8, 2, 5], 3) [4, 7, 7, 5] >>> median_filter([7, 7, 7, 7, 7], 3) [7, 7, 7] >>> median_filter([10, 20, 30, 40, 50, 60, 70, 80, 90], 5) [30, 40, 50, 60, 70] >>> try: ... median_filter([1, 2, 3, 4, 5], 2) ... except ValueError as e: ... e ValueError: \\"Window size k must be a positive odd integer\\" >>> try: ... median_filter([1, 2, 3], 5) ... except ValueError as e: ... e ValueError: \\"Signal length must be at least as large as the window size k\\"","solution":"def median_filter(signal, k): Applies a median filter to the input signal. Parameters: signal (list): A list of integers representing the signal to be filtered. k (int): An odd integer representing the size of the window to apply median filtering. Returns: list: A list of integers representing the filtered signal. Raises: ValueError: If k is not a positive odd integer or if the length of the signal is less than the window size k. if k <= 0 or k % 2 == 0: raise ValueError(\\"Window size k must be a positive odd integer\\") if len(signal) < k: raise ValueError(\\"Signal length must be at least as large as the window size k\\") half_k = k // 2 filtered_signal = [] for i in range(len(signal) - k + 1): window = signal[i:i+k] median = sorted(window)[half_k] filtered_signal.append(median) return filtered_signal"},{"question":"from typing import List, Dict, Tuple def analyze_earthquake_data(data: List[Dict], threshold: float) -> Tuple[float, int, Dict]: Analyzes earthquake data to compute various statistics. Parameters: - data (List[Dict]): A list of dictionaries, each representing an earthquake event with at least a \\"magnitude\\" key. - threshold (float): The magnitude threshold to count significant earthquakes. Returns: - Tuple[float, int, Dict]: A tuple containing the average magnitude, the count of significant earthquakes, and the largest earthquake event. pass # Example usage: earthquake_data = [ {\\"id\\": \\"event1\\", \\"magnitude\\": 4.5, \\"location\\": \\"California\\"}, {\\"id\\": \\"event2\\", \\"magnitude\\": 2.8, \\"location\\": \\"Nevada\\"}, {\\"id\\": \\"event3\\", \\"magnitude\\": 5.9, \\"location\\": \\"Alaska\\"}, {\\"id\\": \\"event4\\", \\"magnitude\\": 3.2, \\"location\\": \\"Mexico\\"}, {\\"id\\": \\"event5\\", \\"magnitude\\": 6.1, \\"location\\": \\"Japan\\"} ] average_magnitude, significant_count, largest_earthquake = analyze_earthquake_data(earthquake_data, 5.0) print(average_magnitude) # Expected output: 4.5 print(significant_count) # Expected output: 2 print(largest_earthquake) # Expected output: {\\"id\\": \\"event5\\", \\"magnitude\\": 6.1, \\"location\\": \\"Japan\\"} # Unit Tests def test_analyze_earthquake_data_basic(): earthquake_data = [ {\\"id\\": \\"event1\\", \\"magnitude\\": 4.5, \\"location\\": \\"California\\"}, {\\"id\\": \\"event2\\", \\"magnitude\\": 2.8, \\"location\\": \\"Nevada\\"}, {\\"id\\": \\"event3\\", \\"magnitude\\": 5.9, \\"location\\": \\"Alaska\\"}, {\\"id\\": \\"event4\\", \\"magnitude\\": 3.2, \\"location\\": \\"Mexico\\"}, {\\"id\\": \\"event5\\", \\"magnitude\\": 6.1, \\"location\\": \\"Japan\\"} ] avg_magnitude, sig_count, largest_eq = analyze_earthquake_data(earthquake_data, 5.0) assert avg_magnitude == 4.5 assert sig_count == 2 assert largest_eq == {\\"id\\": \\"event5\\", \\"magnitude\\": 6.1, \\"location\\": \\"Japan\\"} def test_analyze_earthquake_data_empty(): earthquake_data = [] avg_magnitude, sig_count, largest_eq = analyze_earthquake_data(earthquake_data, 5.0) assert avg_magnitude == 0.0 assert sig_count == 0 assert largest_eq == {} def test_analyze_earthquake_data_threshold(): earthquake_data = [ {\\"id\\": \\"event1\\", \\"magnitude\\": 4.5, \\"location\\": \\"California\\"}, {\\"id\\": \\"event2\\", \\"magnitude\\": 3.7, \\"location\\": \\"Peru\\"} ] avg_magnitude, sig_count, largest_eq = analyze_earthquake_data(earthquake_data, 4.0) assert avg_magnitude == (4.5 + 3.7) / 2 assert sig_count == 1 assert largest_eq == {\\"id\\": \\"event1\\", \\"magnitude\\": 4.5, \\"location\\": \\"California\\"} def test_analyze_earthquake_data_invalid_magnitude(): earthquake_data = [ {\\"id\\": \\"event1\\", \\"magnitude\\": 4.5, \\"location\\": \\"California\\"}, {\\"id\\": \\"event2\\"}, {\\"id\\": \\"event3\\", \\"magnitude\\": \\"not_a_number\\", \\"location\\": \\"ErrorLand\\"}, {\\"id\\": \\"event4\\", \\"magnitude\\": 6.1, \\"location\\": \\"Japan\\"} ] avg_magnitude, sig_count, largest_eq = analyze_earthquake_data(earthquake_data, 5.0) assert avg_magnitude == (4.5 + 6.1) / 4 assert sig_count == 1 assert largest_eq == {\\"id\\": \\"event4\\", \\"magnitude\\": 6.1, \\"location\\": \\"Japan\\"} def test_analyze_earthquake_data_all_events_below_threshold(): earthquake_data = [ {\\"id\\": \\"event1\\", \\"magnitude\\": 4.0, \\"location\\": \\"California\\"}, {\\"id\\": \\"event2\\", \\"magnitude\\": 3.9, \\"location\\": \\"Nevada\\"}, {\\"id\\": \\"event3\\", \\"magnitude\\": 2.8, \\"location\\": \\"Alaska\\"}, ] avg_magnitude, sig_count, largest_eq = analyze_earthquake_data(earthquake_data, 5.0) assert avg_magnitude == (4.0 + 3.9 + 2.8) / 3 assert sig_count == 0 assert largest_eq == {\\"id\\": \\"event1\\", \\"magnitude\\": 4.0, \\"location\\": \\"California\\"}","solution":"from typing import List, Dict, Tuple def analyze_earthquake_data(data: List[Dict], threshold: float) -> Tuple[float, int, Dict]: Analyzes earthquake data to compute various statistics. Parameters: - data (List[Dict]): A list of dictionaries, each representing an earthquake event with at least a \\"magnitude\\" key. - threshold (float): The magnitude threshold to count significant earthquakes. Returns: - Tuple[float, int, Dict]: A tuple containing the average magnitude, the count of significant earthquakes, and the largest earthquake event. if not data: return (0.0, 0, {}) total_magnitude = 0.0 significant_count = 0 largest_earthquake = None for event in data: try: magnitude = float(event[\\"magnitude\\"]) except (KeyError, ValueError, TypeError): continue total_magnitude += magnitude if magnitude > threshold: significant_count += 1 if largest_earthquake is None or magnitude > largest_earthquake[\\"magnitude\\"]: largest_earthquake = event average_magnitude = total_magnitude / len(data) return (average_magnitude, significant_count, largest_earthquake)"},{"question":"def binary_search(arr: list, target: int) -> int: Perform a binary search to find the position of the target value within a sorted list. Parameters: arr (list): A sorted list of integers in ascending order. target (int): The integer value to search for in the list. Returns: int: The index of the target value if found, otherwise -1. Examples: >>> binary_search([1, 3, 5, 7, 9, 11], 5) 2 >>> binary_search([2, 4, 6, 8, 10], 7) -1 >>> binary_search([], 10) -1 >>> binary_search([5], 5) 0 >>> binary_search([5], 3) -1 >>> binary_search([1, 3, 5, 7, 9, 11], 1) 0 >>> binary_search([1, 3, 5, 7, 9, 11], 11) 5","solution":"def binary_search(arr: list, target: int) -> int: Perform a binary search to find the position of the target value within a sorted list. Parameters: arr (list): A sorted list of integers in ascending order. target (int): The integer value to search for in the list. Returns: int: The index of the target value if found, otherwise -1. left, right = 0, len(arr) - 1 while left <= right: mid = (left + right) // 2 mid_value = arr[mid] if mid_value == target: return mid elif mid_value < target: left = mid + 1 else: right = mid - 1 return -1"},{"question":"def vdc_sequence(n: int, base: int) -> list: Generates the first n elements of the base \`base\` van der Corput sequence. >>> vdc_sequence(5, 2) [0.0, 0.5, 0.25, 0.75, 0.125] >>> vdc_sequence(5, 3) [0.0, 0.3333333333333333, 0.6666666666666666, 0.1111111111111111, 0.4444444444444444]","solution":"def vdc_sequence(n: int, base: int) -> list: def vdc(i, base): vdc_value = 0 denom = 1 while i > 0: i, remainder = divmod(i, base) denom *= base vdc_value += remainder / denom return vdc_value return [vdc(i, base) for i in range(n)]"},{"question":"def longest_unique_substring(s: str) -> int: Returns the length of the longest substring with unique characters. >>> longest_unique_substring(\\"abrkaabcdefghijjxxx\\") 10 >>> longest_unique_substring(\\"aaaaa\\") 1 >>> longest_unique_substring(\\"abcdef\\") 6 >>> longest_unique_substring(\\"pwwkew\\") 3 >>> longest_unique_substring(\\"\\") 0 >>> longest_unique_substring(\\"aAbBcC\\") 6 >>> longest_unique_substring(\\"a1b2c3!@\\") 8 >>> longest_unique_substring(\\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890!@#%^&*()\\") 70","solution":"def longest_unique_substring(s): Returns the length of the longest substring with unique characters. max_length = 0 start = 0 seen = {} for end in range(len(s)): if s[end] in seen and seen[s[end]] >= start: start = seen[s[end]] + 1 seen[s[end]] = end max_length = max(max_length, end - start + 1) return max_length"},{"question":"from typing import List def daily_temperatures(temperatures: List[int]) -> List[int]: Compute the number of days to wait for a warmer temperature. >>> daily_temperatures([73, 74, 75, 71, 69, 72, 76, 73]) == [1, 1, 4, 2, 1, 1, 0, 0] >>> daily_temperatures([100, 99, 98, 97, 96]) == [0, 0, 0, 0, 0] >>> daily_temperatures([70, 70, 70, 70]) == [0, 0, 0, 0] >>> daily_temperatures([50, 60, 70, 80]) == [1, 1, 1, 0] >>> daily_temperatures([30, 40, 50, 60, 50, 40, 30, 70]) == [1, 1, 1, 4, 3, 2, 1, 0] >>> daily_temperatures([50]) == [0] >>> daily_temperatures([60, 70]) == [1, 0] >>> daily_temperatures([70, 60]) == [0, 0]","solution":"from typing import List def daily_temperatures(temperatures: List[int]) -> List[int]: n = len(temperatures) res = [0] * n stack = [] # Stack of indices for i in range(n): # While stack is not empty and the current temperature is greater than the # temperature at the index stored at the top of the stack while stack and temperatures[i] > temperatures[stack[-1]]: last_index = stack.pop() res[last_index] = i - last_index stack.append(i) return res"},{"question":"class UserInbox: UserInbox class to manage the user's messages. Supports adding messages, retrieving the most recent message, deleting messages by their IDs, and checking if the inbox is empty. Example Usage: >>> inbox = UserInbox() >>> inbox.is_empty() True >>> inbox.get_recent_message() None >>> inbox.add_message(1, 'Hello World') >>> inbox.is_empty() False >>> inbox.get_recent_message() 'Hello World' >>> inbox.add_message(2, 'Welcome to the system') >>> inbox.get_recent_message() 'Welcome to the system' >>> inbox.delete_message(2) >>> inbox.get_recent_message() 'Hello World' >>> inbox.delete_message(1) >>> inbox.get_recent_message() None >>> inbox.is_empty() True def __init__(self): Initialize the user inbox without any messages. pass def add_message(self, message_id: int, content: str): Add a new message with a unique \`message_id\` and its \`content\`. pass def get_recent_message(self) -> str: Retrieve the most recent message's content. pass def delete_message(self, message_id: int): Delete the message with the given \`message_id\`. pass def is_empty(self) -> bool: Check if the inbox has no messages. pass # Unit tests def test_user_inbox_initialization(): inbox = UserInbox() assert inbox.is_empty() == True assert inbox.get_recent_message() == None def test_user_inbox_add_message(): inbox = UserInbox() inbox.add_message(1, 'Hello World') assert inbox.is_empty() == False assert inbox.get_recent_message() == 'Hello World' def test_user_inbox_get_recent_message(): inbox = UserInbox() inbox.add_message(1, 'Hello World') inbox.add_message(2, 'Welcome to the system') assert inbox.get_recent_message() == 'Welcome to the system' def test_user_inbox_delete_message(): inbox = UserInbox() inbox.add_message(1, 'Hello World') inbox.add_message(2, 'Welcome to the system') inbox.add_message(3, 'Your profile is created') inbox.delete_message(2) assert inbox.get_recent_message() == 'Your profile is created' inbox.delete_message(3) assert inbox.get_recent_message() == 'Hello World' inbox.delete_message(1) assert inbox.get_recent_message() == None assert inbox.is_empty() == True def test_user_inbox_delete_non_existent_message(): inbox = UserInbox() inbox.add_message(1, 'Hello World') inbox.delete_message(2) # Deleting non-existing message assert inbox.get_recent_message() == 'Hello World' assert inbox.is_empty() == False","solution":"class UserInbox: def __init__(self): self.messages = {} self.order = [] def add_message(self, message_id, content): self.messages[message_id] = content self.order.append(message_id) def get_recent_message(self): if not self.order: return None recent_message_id = self.order[-1] return self.messages[recent_message_id] def delete_message(self, message_id): if message_id in self.messages: del self.messages[message_id] self.order.remove(message_id) def is_empty(self): return not self.messages"},{"question":"def find_two_highest(num_list: list[int]) -> tuple[int, int]: Given a list of integers, returns a tuple containing the two highest integers. >>> find_two_highest([3, 5, 1, 7, 9]) (9, 7) >>> find_two_highest([-1, -2, -3, -4, -5]) (-1, -2) >>> find_two_highest([10, -10, 5, -5]) (10, 5) pass def max_product(highest_values: tuple[int, int]) -> int: Given a tuple of two integers, returns the product of these two integers. >>> max_product((9, 7)) 63 >>> max_product((-1, -2)) 2 >>> max_product((10, 5)) 50 pass","solution":"def find_two_highest(num_list): Given a list of integers, returns a tuple containing the two highest integers. highest = second_highest = float('-inf') for num in num_list: if num > highest: second_highest = highest highest = num elif num > second_highest: second_highest = num return (highest, second_highest) def max_product(highest_values): Given a tuple of two integers, returns the product of these two integers. return highest_values[0] * highest_values[1]"},{"question":"from typing import List, Tuple def process_temperatures(sensor_data: List[List[int]]) -> Tuple[float, int, int]: Process temperature data from multiple sensors to compute the average, maximum, and minimum temperatures. Parameters: sensor_data (List[List[int]]): A list of lists where each inner list contains temperature readings from a single sensor. Returns: Tuple[float, int, int]: A tuple containing the average temperature (rounded to 2 decimals), the maximum temperature, and the minimum temperature. Example: >>> process_temperatures([ [22, 24, 21, 23], [19, 18, 20, 22], [25, 27, 26, 28] ]) (23.33, 28, 18) >>> process_temperatures([[10, 15, 20, 25, 30]]) (20.0, 30, 10) def test_process_temperatures_normal_case(): sensor_data = [ [22, 24, 21, 23], [19, 18, 20, 22], [25, 27, 26, 28] ] result = process_temperatures(sensor_data) assert result == (23.33, 28, 18) def test_process_temperatures_single_sensor(): sensor_data = [ [10, 15, 20, 25, 30] ] result = process_temperatures(sensor_data) assert result == (20.0, 30, 10) def test_process_temperatures_negative_case(): sensor_data = [ [-10, -20, -30], [-5, -15, -25] ] result = process_temperatures(sensor_data) assert result == (-17.5, -5, -30) def test_process_temperatures_empty_sensor(): sensor_data = [ [] ] result = process_temperatures(sensor_data) assert result == (0.0, None, None) def test_process_temperatures_mixed_values(): sensor_data = [ [100, -100, 50], [0, 1, -1] ] result = process_temperatures(sensor_data) assert result == (8.33, 100, -100) def test_process_temperatures_all_same_values(): sensor_data = [ [10, 10, 10], [10, 10, 10] ] result = process_temperatures(sensor_data) assert result == (10.0, 10, 10) def test_process_temperatures_varying_lengths(): sensor_data = [ [10, 20], [30, 40, 50] ] result = process_temperatures(sensor_data) assert result == (30.0, 50, 10) def test_process_temperatures_all_empty_sensors(): sensor_data = [ [], [], [], ] result = process_temperatures(sensor_data) assert result == (0.0, None, None)","solution":"from typing import List, Tuple def process_temperatures(sensor_data: List[List[int]]) -> Tuple[float, int, int]: Processes temperature data from multiple sensors to compute the average, maximum, and minimum temperatures. Parameters: sensor_data (List[List[int]]): A list of lists where each inner list contains temperature readings from a single sensor. Returns: Tuple[float, int, int]: A tuple containing the average temperature (rounded to 2 decimals), the maximum temperature, and the minimum temperature. if not sensor_data or all(not readings for readings in sensor_data): return 0.0, None, None # Return early if no data is provided total_sum = 0 count = 0 max_temp = float('-inf') min_temp = float('inf') for readings in sensor_data: for temp in readings: total_sum += temp count += 1 if temp > max_temp: max_temp = temp if temp < min_temp: min_temp = temp average_temp = round(total_sum / count, 2) if count != 0 else 0.0 return average_temp, max_temp, min_temp"},{"question":"class ListNode: def __init__(self, data=0, next=None): self.data = data self.next = next def reverse_list_iter(head: ListNode) -> ListNode: Reverse a singly linked list iteratively. Args: head (ListNode): The head of the singly linked list. Returns: ListNode: The new head of the reversed linked list. # Your code here def reverse_list_recur(head: ListNode) -> ListNode: Reverse a singly linked list recursively. Args: head (ListNode): The head of the singly linked list. Returns: ListNode: The new head of the reversed linked list. # Your code here","solution":"class ListNode: def __init__(self, data=0, next=None): self.data = data self.next = next def reverse_list_iter(head: ListNode) -> ListNode: prev = None current = head while current is not None: next_node = current.next current.next = prev prev = current current = next_node return prev def reverse_list_recur(head: ListNode) -> ListNode: if head is None or head.next is None: return head new_head = reverse_list_recur(head.next) head.next.next = head head.next = None return new_head"},{"question":"def rpsls(player1: str, player2: str) -> str: Determines the outcome of the game \\"Rock, Paper, Scissors, Lizard, Spock\\" between two players. Parameters: player1 (str): The move of player 1. player2 (str): The move of player 2. Returns: str: The result of the game, which can be \\"Player 1 wins\\", \\"Player 2 wins\\", or \\"Tie\\". >>> rpsls(\\"Rock\\", \\"Scissors\\") 'Player 1 wins' >>> rpsls(\\"Lizard\\", \\"Spock\\") 'Player 1 wins' >>> rpsls(\\"Paper\\", \\"Paper\\") 'Tie' >>> rpsls(\\"Spock\\", \\"Rock\\") 'Player 1 wins' >>> rpsls(\\"Scissors\\", \\"Lizard\\") 'Player 1 wins' >>> rpsls(\\"Scissors\\", \\"Spock\\") 'Player 2 wins'","solution":"def rpsls(player1: str, player2: str) -> str: Determines the outcome of the game \\"Rock, Paper, Scissors, Lizard, Spock\\" between two players. Parameters: player1 (str): The move of player 1. player2 (str): The move of player 2. Returns: str: The result of the game, which can be \\"Player 1 wins\\", \\"Player 2 wins\\", or \\"Tie\\". winning_combinations = { 'Rock': ['Scissors', 'Lizard'], 'Paper': ['Rock', 'Spock'], 'Scissors': ['Paper', 'Lizard'], 'Lizard': ['Spock', 'Paper'], 'Spock': ['Scissors', 'Rock'] } if player1 == player2: return \\"Tie\\" elif player2 in winning_combinations[player1]: return \\"Player 1 wins\\" else: return \\"Player 2 wins\\""},{"question":"from typing import List def largest_concatenated_number(lst: List[int]) -> str: if not lst: return '0' # Convert integers to strings for custom sorting lst = list(map(str, lst)) # Custom sort comparator: sorts by the concatenated result of two numbers lst.sort(key=lambda x: x*10, reverse=True) # Edge case check: if the highest number after sorting is '0', the whole number is '0' if lst[0] == '0': return '0' return ''.join(lst) # Unit tests def test_largest_concatenated_number_single_element(): assert largest_concatenated_number([1]) == '1' def test_largest_concatenated_number_all_zeros(): assert largest_concatenated_number([0, 0, 0]) == '0' def test_largest_concatenated_number_example1(): assert largest_concatenated_number([10, 2]) == '210' def test_largest_concatenated_number_example2(): assert largest_concatenated_number([3, 30, 34, 5, 9]) == '9534330' def test_largest_concatenated_number_large_numbers(): assert largest_concatenated_number([999999999, 999999998, 999999997]) == '999999999999999998999999997' def test_largest_concatenated_number_additional_case(): assert largest_concatenated_number([121, 12]) == '12121' def test_largest_concatenated_number_zero_case(): assert largest_concatenated_number([10, 0, 0, 1]) == '11000'","solution":"from typing import List def largest_concatenated_number(lst: List[int]) -> str: if not lst: return '0' # Convert integers to strings for custom sorting lst = list(map(str, lst)) # Custom sort comparator: sorts by the concatenated result of two numbers lst.sort(key=lambda x: x*10, reverse=True) # Edge case check: if the highest number after sorting is '0', the whole number is '0' if lst[0] == '0': return '0' return ''.join(lst)"},{"question":"import pandas as pd def analyze_stock_data(filename: str) -> dict: Parse and analyze stock trading data from a CSV file and generate summary statistics. >>> analyze_stock_data(\\"stock_data.csv\\") { 'CompanyA': { 'Average_Price': 152.5, 'Price_StdDev': 2.385, 'Total_Volume': 18500 }, 'CompanyB': { 'Average_Price': 75.45, 'Price_StdDev': 4.875, 'Total_Volume': 50000 } }","solution":"import pandas as pd def analyze_stock_data(filename: str) -> dict: # Read the CSV file into a DataFrame df = pd.read_csv(filename) # Initialize result dictionary result = {} # Group the data by Company grouped = df.groupby('Company') # Iterate over each group to compute statistics for name, group in grouped: # Drop NaN values in Close_Price and Volume columns close_prices = group['Close_Price'].dropna() volumes = group['Volume'].dropna() # Compute statistics avg_price = close_prices.mean() stddev_price = close_prices.std() total_volume = volumes.sum() # Store results in the dictionary result[name] = { 'Average_Price': avg_price, 'Price_StdDev': stddev_price, 'Total_Volume': total_volume } return result"},{"question":"# Completion Task def horner_evaluation(coeffs, x): Evaluate a polynomial at a given point x using Horner's method. Parameters: coeffs (list of floats): Coefficients of the polynomial in descending order of powers. x (float): The value at which to evaluate the polynomial. Returns: float: The value of the polynomial evaluated at x. result = 0 for coefficient in coeffs: result = result * x + coefficient return result # Test Cases def test_horner_evaluation_simple(): coeffs = [1, 0, -1] # Represents x^2 - 1 x = 2 assert horner_evaluation(coeffs, x) == 3 def test_horner_evaluation_negative_coefficients(): coeffs = [-1, -2, -3] # Represents -x^2 - 2x - 3 x = 2 assert horner_evaluation(coeffs, x) == -11 def test_horner_evaluation_zero_x(): coeffs = [3, -6, 4, -5] # Represents 3x^3 - 6x^2 + 4x - 5 x = 0 assert horner_evaluation(coeffs, x) == -5 def test_horner_evaluation_zero_polynomial(): coeffs = [0, 0, 0, 0] # Represents 0 x = 5 assert horner_evaluation(coeffs, x) == 0 def test_horner_evaluation_polynomial_with_zero_coefficients(): coeffs = [1, 0, 0, 0, -1] # Represents x^4 - 1 x = 2 assert horner_evaluation(coeffs, x) == 15 def test_horner_evaluation_one_coefficient(): coeffs = [3] # The constant polynomial 3 x = 100 assert horner_evaluation(coeffs, x) == 3 def test_horner_evaluation_large_polynomial(): coeffs = [1] * 1001 # Represents x^1000 + x^999 + ... + x + 1 x = 1 assert horner_evaluation(coeffs, x) == 1001","solution":"def horner_evaluation(coeffs, x): Evaluate a polynomial at a given point x using Horner's method. Parameters: coeffs (list of floats): Coefficients of the polynomial in descending order of powers. x (float): The value at which to evaluate the polynomial. Returns: float: The value of the polynomial evaluated at x. result = 0 for coefficient in coeffs: result = result * x + coefficient return result"},{"question":"def find_missing_number(sequence: List[int]) -> int: Identifies the missing number in an arithmetic sequence. Parameters: sequence (List[int]): A list of integers representing an incomplete arithmetic sequence. Returns: int: The missing number in the arithmetic sequence. Example: >>> find_missing_number([1, 3, 5, 9, 11]) 7 >>> find_missing_number([10, 20, 30, 50, 60, 70]) 40 >>> find_missing_number([2, 4, 8, 10]) 6 >>> find_missing_number([5, 10, 15, 25]) 20 >>> find_missing_number([100, 200, 300, 500, 600]) 400","solution":"from typing import List def find_missing_number(sequence: List[int]) -> int: Identifies the missing number in an arithmetic sequence. Parameters: sequence (List[int]): A list of integers representing an incomplete arithmetic sequence. Returns: int: The missing number in the arithmetic sequence. n = len(sequence) total_sum = (n + 1) * (sequence[0] + sequence[-1]) // 2 actual_sum = sum(sequence) return total_sum - actual_sum"},{"question":"import re from typing import List def validate_and_normalize_email(email: str) -> str: Validate and normalize a given email address string. Parameters: email (str): A string representing the email address. Returns: (str or None): The normalized email if the input is valid, otherwise \`None\`. Examples: >>> validate_and_normalize_email(\\"User.name@gmail.com\\") == \\"username@gmail.com\\" >>> validate_and_normalize_email(\\"invalid_email@@example.com\\") is None >>> validate_and_normalize_email(\\"User.name@example.com\\") == \\"user.name@example.com\\" # Your code here def normalize_emails(emails: List[str]) -> List[str]: Normalize a list of email addresses by removing duplicates and maintaining valid ones only. Parameters: emails (List[str]): A list of email address strings. Returns: (List[str]): A list of unique, normalized, and valid email addresses. Examples: >>> normalize_emails([\\"User.name@gmail.com\\", \\"username@gmail.com\\", \\"valid.email@example.com\\", \\"invalid_email@@example.com\\"]) == [\\"username@gmail.com\\", \\"valid.email@example.com\\"] # Your code here # Test your implementation def test_validate_and_normalize_email_valid_gmail(): assert validate_and_normalize_email(\\"User.name@gmail.com\\") == \\"username@gmail.com\\" assert validate_and_normalize_email(\\"User.Name@GMAIL.com\\") == \\"username@gmail.com\\" def test_validate_and_normalize_email_invalid(): assert validate_and_normalize_email(\\"invalid_email@@example.com\\") is None assert validate_and_normalize_email(\\"invalidemail.com\\") is None assert validate_and_normalize_email(\\"@example.com\\") is None def test_validate_and_normalize_email_valid_non_gmail(): assert validate_and_normalize_email(\\"User.name@example.com\\") == \\"user.name@example.com\\" assert validate_and_normalize_email(\\"User.Name@Example.com\\") == \\"user.name@example.com\\" def test_normalize_emails_mix(): assert normalize_emails([ \\"User.name@gmail.com\\", \\"username@gmail.com\\", \\"valid.email@example.com\\", \\"valid.Email@Example.com\\", \\"invalid_email@@example.com\\" ]) == [\\"username@gmail.com\\", \\"valid.email@example.com\\"] def test_normalize_emails_duplicates(): assert normalize_emails([ \\"User.name@gmail.com\\", \\"username@gmail.com\\", \\"username@gmail.com\\" ]) == [\\"username@gmail.com\\"] def test_normalize_emails_only_invalid(): assert normalize_emails([ \\"invalid_email@@example.com\\", \\"another_invalid_email@domain\\" ]) == [] def test_normalize_emails_case_insensitivity(): assert normalize_emails([ \\"User.name@gmail.com\\", \\"user.Name@GMAIL.COM\\", \\"username@Gmail.com\\" ]) == [\\"username@gmail.com\\"]","solution":"import re def validate_and_normalize_email(email: str) -> str: # Regex pattern for validating email email_pattern = r'^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+.[a-zA-Z0-9-.]+' if not re.match(email_pattern, email): return None local, domain = email.split('@') if domain.lower() == \\"gmail.com\\": local = local.replace('.', '').lower() else: local = local.lower() return f\\"{local}@{domain.lower()}\\" def normalize_emails(emails: list) -> list: normalized_set = set() result = [] for email in emails: normalized_email = validate_and_normalize_email(email) if normalized_email and normalized_email not in normalized_set: normalized_set.add(normalized_email) result.append(normalized_email) return result"},{"question":"class Library: def __init__(self, books): Initialize the library with a list of books. Each book is a dictionary with keys 'title' and 'author'. ... def borrow_book(self, title: str) -> bool: Borrow a book given its title. Returns True if the book was successfully borrowed, False otherwise. >>> lib = Library([{\\"title\\": \\"1984\\", \\"author\\": \\"George Orwell\\"}]) >>> lib.borrow_book(\\"1984\\") True >>> lib.borrow_book(\\"1984\\") False ... def return_book(self, title: str) -> bool: Return a borrowed book given its title. Returns True if the book was successfully returned, False otherwise. >>> lib = Library([{\\"title\\": \\"1984\\", \\"author\\": \\"George Orwell\\"}]) >>> lib.borrow_book(\\"1984\\") True >>> lib.return_book(\\"1984\\") True >>> lib.return_book(\\"1984\\") False ... def list_available_books(self): List all available books in the library. Returns a list of titles of available books. >>> lib = Library([ ... {\\"title\\": \\"1984\\", \\"author\\": \\"George Orwell\\"}, ... {\\"title\\": \\"Brave New World\\", \\"author\\": \\"Aldous Huxley\\"} ... ]) >>> lib.borrow_book(\\"1984\\") True >>> lib.list_available_books() ['Brave New World'] ... def is_book_available(self, title: str) -> bool: Check if a specific book is available. Returns True if the book is available, False otherwise. >>> lib = Library([{\\"title\\": \\"1984\\", \\"author\\": \\"George Orwell\\"}]) >>> lib.is_book_available(\\"1984\\") True >>> lib.borrow_book(\\"1984\\") True >>> lib.is_book_available(\\"1984\\") False ... import unittest class TestLibrary(unittest.TestCase): def setUp(self): books = [ {\\"title\\": \\"1984\\", \\"author\\": \\"George Orwell\\"}, {\\"title\\": \\"Brave New World\\", \\"author\\": \\"Aldous Huxley\\"}, {\\"title\\": \\"Fahrenheit 451\\", \\"author\\": \\"Ray Bradbury\\"} ] self.library = Library(books) def test_borrow_book(self): self.assertTrue(self.library.borrow_book(\\"1984\\")) self.assertFalse(self.library.borrow_book(\\"1984\\")) def test_return_book(self): self.library.borrow_book(\\"1984\\") self.assertTrue(self.library.return_book(\\"1984\\")) self.assertFalse(self.library.return_book(\\"1984\\")) def test_list_available_books(self): self.assertSetEqual(set(self.library.list_available_books()), {\\"1984\\", \\"Brave New World\\", \\"Fahrenheit 451\\"}) self.library.borrow_book(\\"1984\\") self.assertSetEqual(set(self.library.list_available_books()), {\\"Brave New World\\", \\"Fahrenheit 451\\"}) def test_is_book_available(self): self.assertTrue(self.library.is_book_available(\\"1984\\")) self.library.borrow_book(\\"1984\\") self.assertFalse(self.library.is_book_available(\\"1984\\")) self.library.return_book(\\"1984\\") self.assertTrue(self.library.is_book_available(\\"1984\\")) def test_borrow_nonexistent_book(self): self.assertFalse(self.library.borrow_book(\\"Unknown Book\\")) def test_return_nonexistent_book(self): self.assertFalse(self.library.return_book(\\"Unknown Book\\")) if __name__ == \\"__main__\\": unittest.main()","solution":"class Library: def __init__(self, books): Initialize the library with a list of books. Each book is a dictionary with keys 'title' and 'author'. self.books = {book[\\"title\\"]: book for book in books} self.borrowed_books = set() def borrow_book(self, title: str) -> bool: Borrow a book given its title. Returns True if the book was successfully borrowed, False otherwise. if title in self.books and title not in self.borrowed_books: self.borrowed_books.add(title) return True return False def return_book(self, title: str) -> bool: Return a borrowed book given its title. Returns True if the book was successfully returned, False otherwise. if title in self.borrowed_books: self.borrowed_books.remove(title) return True return False def list_available_books(self): List all available books in the library. Returns a list of titles of available books. return [title for title in self.books if title not in self.borrowed_books] def is_book_available(self, title: str) -> bool: Check if a specific book is available. Returns True if the book is available, False otherwise. return title in self.books and title not in self.borrowed_books"},{"question":"def max_consecutive_ones(binary_list: list) -> int: Computes the maximum length of consecutive 1s in a binary list. :param binary_list: list of int - A list of integers containing only 0s and 1s :return: int - The length of the longest sequence of consecutive 1s >>> max_consecutive_ones([1, 1, 0, 1, 1, 1]) 3 >>> max_consecutive_ones([1, 0, 1, 0, 1]) 1 >>> max_consecutive_ones([0, 0, 0, 0]) 0 >>> max_consecutive_ones([]) 0 >>> max_consecutive_ones([1, 1, 1, 1, 1, 1]) 6 >>> max_consecutive_ones([1]) 1","solution":"def max_consecutive_ones(binary_list): Returns the maximum length of consecutive 1s in the binary list. :param binary_list: List[int] - A list of binary integers (0 and 1) :return: int - The length of the longest sequence of consecutive 1s max_count = 0 current_count = 0 for num in binary_list: if num == 1: current_count += 1 if current_count > max_count: max_count = current_count else: current_count = 0 return max_count"},{"question":"import random import string def generate_password(length: int, include_digits: bool, include_uppercase: bool, include_special: bool) -> str: Generates a random password with specified criteria. Parameters: length (int): Length of the password to be generated (minimum 6). include_digits (bool): Whether the password should include digits. include_uppercase (bool): Whether the password should include uppercase letters. include_special (bool): Whether the password should include special characters. Returns: str: The generated random password. pass import re def test_generate_password_minimum_length(): password = generate_password(6, False, False, False) assert len(password) == 6 def test_generate_password_with_digits(): password = generate_password(10, True, False, False) assert len(password) == 10 assert any(char.isdigit() for char in password) def test_generate_password_with_uppercase(): password = generate_password(10, False, True, False) assert len(password) == 10 assert any(char.isupper() for char in password) def test_generate_password_with_special_characters(): password = generate_password(10, False, False, True) assert len(password) == 10 assert any(char in '@#%&*' for char in password) def test_generate_password_with_all_options(): password = generate_password(12, True, True, True) assert len(password) == 12 assert any(char.isdigit() for char in password) assert any(char.isupper() for char in password) assert any(char in '@#%&*' for char in password) def test_generate_password_invalid_length(): try: generate_password(5, False, False, False) except ValueError as e: assert str(e) == \\"Password length must be at least 6.\\" def test_generate_password_returns_random_results(): passwords = {generate_password(8, True, True, True) for _ in range(100)} assert len(passwords) == 100 # Every password should be unique","solution":"import random import string def generate_password(length: int, include_digits: bool, include_uppercase: bool, include_special: bool) -> str: Generates a random password with specified criteria. Parameters: length (int): Length of the password to be generated (minimum 6). include_digits (bool): Whether the password should include digits. include_uppercase (bool): Whether the password should include uppercase letters. include_special (bool): Whether the password should include special characters. Returns: str: The generated random password. if length < 6: raise ValueError(\\"Password length must be at least 6.\\") characters = string.ascii_lowercase if include_digits: characters += string.digits if include_uppercase: characters += string.ascii_uppercase if include_special: characters += '@#%&*' password = [random.choice(characters) for _ in range(length)] if include_digits: password[random.randint(0, length-1)] = random.choice(string.digits) if include_uppercase: password[random.randint(0, length-1)] = random.choice(string.ascii_uppercase) if include_special: password[random.randint(0, length-1)] = random.choice('@#%&*') random.shuffle(password) return ''.join(password)"},{"question":"from typing import List, Tuple, Dict import heapq def shortest_delivery_route(start: str, edges: List[Tuple[str, str, int]]) -> Dict[str, int]: Calculate the shortest delivery route from the starting point to all other delivery points using Dijkstra's Algorithm. :param start: The starting delivery point :param edges: A list of tuples representing the directed edges and travel times :return: A dictionary where keys are delivery points and values are the shortest travel times from the start point :raises Exception: If the start point is an empty string. :raises Exception: If any delivery point in the edges is an empty string. :raises Exception: If any travel time in the edges is not a positive integer. >>> shortest_delivery_route(\\"A\\", [(\\"A\\", \\"B\\", 1), (\\"B\\", \\"C\\", 2), (\\"A\\", \\"C\\", 4)]) == {'A': 0, 'B': 1, 'C': 3} >>> shortest_delivery_route(\\"X\\", [(\\"X\\", \\"Y\\", 5), (\\"Y\\", \\"Z\\", 10), (\\"X\\", \\"Z\\", 100)]) == {'X': 0, 'Y': 5, 'Z': 15} >>> shortest_delivery_route(\\"\\", [(\\"A\\", \\"B\\", 1)]) # Raises Exception: \\"Start point must be a non-empty string\\" >>> shortest_delivery_route(\\"A\\", [(\\"A\\", \\"B\\", -2)]) # Raises Exception: \\"Travel time must be a positive integer\\" >>> shortest_delivery_route(\\"A\\", [(\\"\\", \\"B\\", 1)]) # Raises Exception: \\"Delivery points must be non-empty strings\\"","solution":"from typing import List, Tuple, Dict import heapq def shortest_delivery_route(start: str, edges: List[Tuple[str, str, int]]) -> Dict[str, int]: Calculate the shortest delivery route from the starting point to all other delivery points using Dijkstra's Algorithm. :param start: The starting delivery point :param edges: A list of tuples representing the directed edges and travel times :return: A dictionary where keys are delivery points and values are the shortest travel times from the start point # Validate input if not start: raise Exception(\\"Start point must be a non-empty string\\") for edge in edges: if not edge[0] or not edge[1]: raise Exception(\\"Delivery points must be non-empty strings\\") if edge[2] <= 0: raise Exception(\\"Travel time must be a positive integer\\") # Create adjacency list for the graph graph = {} for u, v, w in edges: if u not in graph: graph[u] = [] graph[u].append((v, w)) # Initialize distances and priority queue distances = {} pq = [] # Add nodes from edges to distances for u, _, _ in edges: distances[u] = float('inf') for _, v, _ in edges: distances[v] = float('inf') # Initialize start point distance if start in distances: distances[start] = 0 pq.append((0, start)) # Dijkstra's Algorithm while pq: current_distance, current_vertex = heapq.heappop(pq) if current_distance > distances[current_vertex]: continue for neighbor, weight in graph.get(current_vertex, []): distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(pq, (distance, neighbor)) return distances"},{"question":"from typing import List, Optional def matrix_transpose_iterative(matrix: List[List[int]]) -> List[List[int]]: Performs matrix transposition in an iterative manner. >>> matrix_transpose_iterative([[1, 2, 3], [4, 5, 6]]) [[1, 4], [2, 5], [3, 6]] >>> matrix_transpose_iterative([[1]]) [[1]] pass def matrix_transpose_recursive(matrix: List[List[int]], transpose: Optional[List[List[int]]] = None, row: int = 0) -> List[List[int]]: Performs matrix transposition using recursion. >>> matrix_transpose_recursive([[1, 2, 3], [4, 5, 6]]) [[1, 4], [2, 5], [3, 6]] >>> matrix_transpose_recursive([[1]]) [[1]] pass def matrix_multiply_iterative(matrix_a: List[List[int]], matrix_b: List[List[int]]) -> List[List[int]]: Performs matrix multiplication in an iterative manner. >>> matrix_multiply_iterative([[1, 2], [3, 4]], [[5, 6], [7, 8]]) [[19, 22], [43, 50]] >>> matrix_multiply_iterative([[1]], [[1]]) [[1]] pass def matrix_multiply_recursive(matrix_a: List[List[int]], matrix_b: List[List[int]], result: Optional[List[List[int]]] = None, i: int = 0, j: int = 0, k: int = 0) -> List[List[int]]: Performs matrix multiplication using recursion. >>> matrix_multiply_recursive([[1, 2], [3, 4]], [[5, 6], [7, 8]]) [[19, 22], [43, 50]] >>> matrix_multiply_recursive([[1]], [[1]]) [[1]] pass","solution":"from typing import List, Optional def matrix_transpose_iterative(matrix: List[List[int]]) -> List[List[int]]: if not matrix or not matrix[0]: raise ValueError(\\"Matrix is empty or not rectangular\\") num_rows, num_cols = len(matrix), len(matrix[0]) transpose = [[matrix[row][col] for row in range(num_rows)] for col in range(num_cols)] return transpose def matrix_transpose_recursive(matrix: List[List[int]], transpose: Optional[List[List[int]]] = None, row: int = 0) -> List[List[int]]: if not matrix or not matrix[0]: raise ValueError(\\"Matrix is empty or not rectangular\\") if transpose is None: num_cols = len(matrix[0]) transpose = [[] for _ in range(num_cols)] if row == len(matrix): return transpose else: for col in range(len(matrix[row])): transpose[col].append(matrix[row][col]) return matrix_transpose_recursive(matrix, transpose, row + 1) def matrix_multiply_iterative(matrix_a: List[List[int]], matrix_b: List[List[int]]) -> List[List[int]]: if not matrix_a or not matrix_b or not matrix_a[0] or not matrix_b[0] or len(matrix_a[0]) != len(matrix_b): raise ValueError(\\"Invalid matrix dimensions for multiplication\\") result = [[0 for _ in range(len(matrix_b[0]))] for _ in range(len(matrix_a))] for i in range(len(matrix_a)): for j in range(len(matrix_b[0])): for k in range(len(matrix_b)): result[i][j] += matrix_a[i][k] * matrix_b[k][j] return result def matrix_multiply_recursive(matrix_a: List[List[int]], matrix_b: List[List[int]], result: Optional[List[List[int]]] = None, i: int = 0, j: int = 0, k: int = 0) -> List[List[int]]: if not matrix_a or not matrix_b or not matrix_a[0] or not matrix_b[0] or len(matrix_a[0]) != len(matrix_b): raise ValueError(\\"Invalid matrix dimensions for multiplication\\") if result is None: result = [[0 for _ in range(len(matrix_b[0]))] for _ in range(len(matrix_a))] if i >= len(matrix_a): return result if j >= len(matrix_b[0]): return matrix_multiply_recursive(matrix_a, matrix_b, result, i + 1, 0, 0) if k >= len(matrix_b): return matrix_multiply_recursive(matrix_a, matrix_b, result, i, j + 1, 0) result[i][j] += matrix_a[i][k] * matrix_b[k][j] return matrix_multiply_recursive(matrix_a, matrix_b, result, i, j, k + 1)"},{"question":"def sort_anagram_groups(strings: list[str]) -> list[str]: Sort a given list of strings such that all anagrams are grouped together and the groups of anagrams themselves are sorted lexicographically. >>> sort_anagram_groups([\\"bat\\", \\"tab\\", \\"eat\\", \\"tea\\", \\"tan\\", \\"nat\\", \\"bat\\"]) ['bat', 'bat', 'tab', 'eat', 'tea', 'nat', 'tan'] >>> sort_anagram_groups(['bat']) ['bat'] >>> sort_anagram_groups(['bat', 'tab']) ['bat', 'tab'] >>> sort_anagram_groups(['bat', 'dog', 'cat']) ['bat', 'cat', 'dog'] >>> sort_anagram_groups(['', 'b', 'b', '']) ['', '', 'b', 'b']","solution":"def sort_anagram_groups(strings): Groups anagrams together and sorts them lexicographically. :param strings: List of strings :return: List of strings with anagrams grouped together and sorted lexicographically from collections import defaultdict # Dictionary to hold groups of anagrams anagram_map = defaultdict(list) for s in strings: # Sort the characters of the string to form the key key = ''.join(sorted(s)) anagram_map[key].append(s) # Collect all anagram groups into a list result = [] for key in sorted(anagram_map.keys()): # Sort each group of anagrams and add to the result list result.extend(sorted(anagram_map[key])) return result # Example usage strings = [\\"bat\\", \\"tab\\", \\"eat\\", \\"tea\\", \\"tan\\", \\"nat\\", \\"bat\\"] print(sort_anagram_groups(strings)) # Output: ['bat', 'bat', 'tab', 'eat', 'tea', 'nat', 'tan']"},{"question":"from typing import List def merge_sort(arr: List[int]) -> List[int]: Implement the Merge Sort algorithm in Python to sort a list of integers. Parameters: arr (List[int]): A list of integers which needs to be sorted. Returns: List[int]: A sorted list of integers. Examples: >>> merge_sort([12, 11, 13, 5, 6, 7]) [5, 6, 7, 11, 12, 13] >>> merge_sort([4, 2, 6, 1]) [1, 2, 4, 6] >>> merge_sort([]) [] >>> merge_sort([-3, 2, -1, 4]) [-3, -1, 2, 4] >>> merge_sort([5]) [5] # Your implementation here","solution":"from typing import List def merge_sort(arr: List[int]) -> List[int]: if len(arr) <= 1: return arr def merge(left: List[int], right: List[int]) -> List[int]: merged = [] left_index, right_index = 0, 0 while left_index < len(left) and right_index < len(right): if left[left_index] <= right[right_index]: merged.append(left[left_index]) left_index += 1 else: merged.append(right[right_index]) right_index += 1 merged.extend(left[left_index:]) merged.extend(right[right_index:]) return merged mid = len(arr) // 2 left_half = merge_sort(arr[:mid]) right_half = merge_sort(arr[mid:]) return merge(left_half, right_half)"},{"question":"import random import math from typing import List, Tuple, Dict def k_means_clustering(data_points: List[Tuple[float, float]], k: int) -> Dict[int, List[Tuple[float, float]]]: Perform k-means clustering on a given set of data points. >>> k_means_clustering([(2.3, 4.5), (1.1, 0.2), (4.4, 2.1), (5.1, 1.9), (3.5, 3.5)], 2) {0: [(2.3, 4.5), (1.1, 0.2)], 1: [(4.4, 2.1), (5.1, 1.9), (3.5, 3.5)]} def evaluate_clustering(data_points: List[Tuple[float, float]], k: int): Calculate and print the sum of squared distances from each data point to its assigned centroid.","solution":"import random import math def initialize_centroids(data_points, k): return random.sample(data_points, k) def assign_clusters(data_points, centroids): clusters = {i: [] for i in range(len(centroids))} for point in data_points: closest_centroid_index = min( range(len(centroids)), key=lambda i: euclidean_distance(point, centroids[i])) clusters[closest_centroid_index].append(point) return clusters def update_centroids(clusters): new_centroids = [] for cluster_points in clusters.values(): new_centroids.append(tuple(map(lambda x: sum(x) / len(x), zip(*cluster_points)))) return new_centroids def euclidean_distance(point1, point2): return math.sqrt(sum((x - y) ** 2 for x, y in zip(point1, point2))) def k_means_clustering(data_points, k): centroids = initialize_centroids(data_points, k) previous_centroids = [] while previous_centroids != centroids: clusters = assign_clusters(data_points, centroids) previous_centroids = centroids centroids = update_centroids(clusters) return clusters def evaluate_clustering(data_points, k): clusters = k_means_clustering(data_points, k) sum_squared_distances = 0 for cluster_index, cluster_points in clusters.items(): centroid = tuple(map(lambda x: sum(x) / len(x), zip(*cluster_points))) for point in cluster_points: sum_squared_distances += euclidean_distance(point, centroid) ** 2 print(f\\"Sum of squared distances: {sum_squared_distances}\\")"},{"question":"from typing import List, Dict def calculate_kinetic_energies(data: List[Dict[str, float]]) -> List[float]: Calculates the kinetic energy of each celestial body in the dataset, given by the formula KE = (1/2) * mass * velocity^2. Args: data: A list of dictionaries, each containing mass and velocity of the celestial body. - 'mass': A floating-point number representing the mass of the celestial body. - 'velocity': A floating-point number representing the velocity of the celestial body. Returns: A list of floating-point numbers, where each element is the kinetic energy (in joules) of the corresponding celestial body in the input list. Example: >>> data = [ ... {'mass': 5.0, 'velocity': 3.0}, ... {'mass': 2.0, 'velocity': 4.0}, ... {'mass': 1.5, 'velocity': 2.5} ... ] >>> calculate_kinetic_energies(data) [22.5, 16.0, 4.6875] import pytest def test_calculate_kinetic_energies(): data = [ {'mass': 5.0, 'velocity': 3.0}, {'mass': 2.0, 'velocity': 4.0}, {'mass': 1.5, 'velocity': 2.5} ] result = calculate_kinetic_energies(data) expected = [22.5, 16.0, 4.6875] assert result == expected def test_calculate_kinetic_energies_with_zero_velocity(): data = [ {'mass': 5.0, 'velocity': 0.0}, {'mass': 0.0, 'velocity': 4.0} ] result = calculate_kinetic_energies(data) expected = [0.0, 0.0] assert result == expected def test_calculate_kinetic_energies_with_large_values(): data = [ {'mass': 1e6, 'velocity': 1e3}, {'mass': 1e3, 'velocity': 1e6} ] result = calculate_kinetic_energies(data) expected = [0.5 * 1e6 * (1e3)**2, 0.5 * 1e3 * (1e6)**2] assert result == expected def test_calculate_kinetic_energies_with_small_values(): data = [ {'mass': 1e-6, 'velocity': 1e-3}, {'mass': 1e-3, 'velocity': 1e-6} ] result = calculate_kinetic_energies(data) expected = [0.5 * 1e-6 * (1e-3)**2, 0.5 * 1e-3 * (1e-6)**2] assert result == expected def test_calculate_kinetic_energies_with_mixed_values(): data = [ {'mass': 1e6, 'velocity': 1e-3}, {'mass': 1e-3, 'velocity': 1e6} ] result = calculate_kinetic_energies(data) expected = [0.5 * 1e6 * (1e-3)**2, 0.5 * 1e-3 * (1e6)**2] assert result == expected","solution":"from typing import List, Dict def calculate_kinetic_energies(data: List[Dict[str, float]]) -> List[float]: Calculates the kinetic energy of each celestial body in the dataset. Args: data: A list of dictionaries, each containing mass and velocity of the celestial body. Returns: A list of kinetic energies of the corresponding celestial bodies. kinetic_energies = [] for body in data: mass = body['mass'] velocity = body['velocity'] kinetic_energy = 0.5 * mass * velocity ** 2 kinetic_energies.append(kinetic_energy) return kinetic_energies"},{"question":"def calculate_inventory(operations: list[tuple[str, int]]) -> dict: Returns a dictionary with the total count of each item in the inventory. >>> calculate_inventory([(\\"A123\\", 10), (\\"B456\\", 5), (\\"A123\\", -3), (\\"C789\\", 7), (\\"B456\\", 2), (\\"C789\\", -4), (\\"A123\\", 6)]) {'A123': 13, 'B456': 7, 'C789': 3} >>> calculate_inventory([(\\"ItemX\\", 100), (\\"ItemY\\", 150), (\\"ItemX\\", -50), (\\"ItemZ\\", 75), (\\"ItemY\\", -25), (\\"ItemZ\\", 10)]) {'ItemX': 50, 'ItemY': 125, 'ItemZ': 85}","solution":"def calculate_inventory(operations): Returns a dictionary with the total count of each item in the inventory. inventory = {} for item_id, count in operations: if item_id not in inventory: inventory[item_id] = 0 inventory[item_id] += count return inventory"},{"question":"from typing import List def determinant(matrix: List[List[float]]) -> float: Calculate the determinant of a square matrix using recursion (Laplace expansion). >>> determinant([[4]]) == 4 >>> determinant([[1, 2], [3, 4]]) == -2 >>> determinant([[6, 1, 1], [4, -2, 5], [2, 8, 7]]) == -306 def has_unique_solution(coeff_matrix: List[List[float]], const_vector: List[float]) -> bool: Check if the system of linear equations represented by coeff_matrix and const_vector has a unique solution by checking if the determinant of coeff_matrix is non-zero. >>> has_unique_solution([[2, -1, 0], [1, 3, -2], [0, -1, 4]], [1, 2, 3]) == True >>> has_unique_solution([[1, 2, 3], [4, 5, 6], [7, 8, 9]], [1, 0, 0]) == False","solution":"from typing import List def determinant(matrix: List[List[float]]) -> float: Calculate the determinant of a square matrix using recursion (Laplace expansion). if len(matrix) != len(matrix[0]): raise ValueError(\\"Matrix must be square\\") if len(matrix) == 1: return matrix[0][0] if len(matrix) == 2: return matrix[0][0] * matrix[1][1] - matrix[0][1] * matrix[1][0] det = 0 for c in range(len(matrix)): sub_matrix = [row[:c] + row[c+1:] for row in matrix[1:]] det += ((-1) ** c) * matrix[0][c] * determinant(sub_matrix) return det def has_unique_solution(coeff_matrix: List[List[float]], const_vector: List[float]) -> bool: Check if the system of linear equations represented by coeff_matrix and const_vector has a unique solution by checking if the determinant of coeff_matrix is non-zero. if len(coeff_matrix) != len(const_vector): raise ValueError(\\"The coefficient matrix and the constant vector must have compatible dimensions\\") det = determinant(coeff_matrix) return det != 0"},{"question":"def merge_styles(base_style: dict, additional_style: dict) -> dict: Merges two style dictionaries giving precedence to additional_style. Parameters: - base_style: dict. Dictionary representing the base CSS styles. - additional_style: dict. Dictionary representing the additional CSS styles. Returns: - dict. Merged dictionary with additional_style values taking precedence. Examples: >>> base_style = {'color': 'blue', 'font-size': '12px', 'margin': '5px'} >>> additional_style = {'color': 'red', 'padding': '10px'} >>> merge_styles(base_style, additional_style) {'color': 'red', 'font-size': '12px', 'margin': '5px', 'padding': '10px'} >>> base_style = {'width': '100px'} >>> additional_style = {'height': '200px'} >>> merge_styles(base_style, additional_style) {'width': '100px', 'height': '200px'} >>> base_style = {'background': 'white', 'border': '1px solid black'} >>> additional_style = {'background': 'blue'} >>> merge_styles(base_style, additional_style) {'background': 'blue', 'border': '1px solid black'}","solution":"def merge_styles(base_style, additional_style): Merges two style dictionaries giving precedence to additional_style. Parameters: - base_style: dict. Dictionary representing the base CSS styles. - additional_style: dict. Dictionary representing the additional CSS styles. Returns: - dict. Merged dictionary with additional_style values taking precedence. merged_style = base_style.copy() # Start with base_style merged_style.update(additional_style) # Override with additional_style return merged_style"},{"question":"def matrix_determinant(matrix): Function to calculate the determinant of a square matrix. :param matrix: 2D list representing the square matrix. :return: Float value representing the determinant of the matrix. pass # Example test cases def test_1x1_matrix(): assert matrix_determinant([[3]]) == 3 def test_2x2_matrix(): assert matrix_determinant([[4, 3], [6, 3]]) == -6 def test_3x3_matrix(): assert matrix_determinant([[1, 2, 3], [0, 1, 4], [5, 6, 0]]) == 1 def test_3x3_matrix_with_zero_elements(): assert matrix_determinant([[1, 0, 2], [0, 3, 4], [0, 0, 5]]) == 15 def test_4x4_matrix(): assert matrix_determinant([ [1, 0, 2, -1], [3, 0, 0, 5], [2, 1, 4, -3], [1, 0, 5, 0] ]) == 30 def test_singular_matrix(): assert matrix_determinant([ [2, 3, 1], [4, 6, 2], [1, -1, 0] ]) == 0 def test_large_number_matrix(): assert matrix_determinant([ [1e10, 1], [1, 1e10] ]) == 1e20 - 1 def test_float_matrix(): assert matrix_determinant([ [1.5, 0.5], [0.5, 1.5] ]) == 2","solution":"def matrix_determinant(matrix): Function to calculate the determinant of a square matrix. :param matrix: 2D list representing the square matrix. :return: Float value representing the determinant of the matrix. def get_minor(matrix, i, j): # Return the minor of the matrix by removing row i and column j return [row[:j] + row[j+1:] for row in (matrix[:i] + matrix[i+1:])] def determinant(matrix): # Base case for 1x1 matrix if len(matrix) == 1: return matrix[0][0] # Base case for 2x2 matrix if len(matrix) == 2: return matrix[0][0] * matrix[1][1] - matrix[0][1] * matrix[1][0] det = 0 # Expand along the first row for c in range(len(matrix)): det += ((-1) ** c) * matrix[0][c] * determinant(get_minor(matrix, 0, c)) return det return determinant(matrix)"},{"question":"def longest_repeated_substring(s: str) -> tuple: Find the longest substring of consecutive repeated characters in a given string. Args: s: A single string input. Returns: A tuple containing the longest repeated substring and its length. Examples: >>> longest_repeated_substring(\\"aabbccdd\\") ('aa', 2) >>> longest_repeated_substring(\\"ababa\\") ('a', 1) >>> longest_repeated_substring(\\"aaaabbcc\\") ('aaaa', 4) >>> longest_repeated_substring(\\"abcdee\\") ('ee', 2) >>> longest_repeated_substring(\\"a\\") ('a', 1) >>> longest_repeated_substring(\\"abbaaaacccccccccdd\\") ('ccccccccc', 9) from solution import longest_repeated_substring def test_example_1(): assert longest_repeated_substring(\\"aabbccdd\\") == ('aa', 2) def test_example_2(): assert longest_repeated_substring(\\"ababa\\") == ('a', 1) def test_example_3(): assert longest_repeated_substring(\\"aaaabbcc\\") == ('aaaa', 4) def test_example_4(): assert longest_repeated_substring(\\"abcdee\\") == ('ee', 2) def test_example_5(): assert longest_repeated_substring(\\"a\\") == ('a', 1) def test_example_6(): assert longest_repeated_substring(\\"abbaaaacccccccccdd\\") == ('ccccccccc', 9) def test_empty_string(): assert longest_repeated_substring(\\"\\") == (\\"\\", 0) def test_no_repeated_chars(): assert longest_repeated_substring(\\"abcde\\") == ('a', 1) def test_all_same_chars(): assert longest_repeated_substring(\\"aaaaa\\") == ('aaaaa', 5) def test_multiple_same_max_length(): assert longest_repeated_substring(\\"aabbbccc\\") == ('bbb', 3)","solution":"def longest_repeated_substring(s: str) -> tuple: if not s: return (\\"\\", 0) max_len = 1 max_substr = s[0] current_len = 1 current_char = s[0] for i in range(1, len(s)): if s[i] == current_char: current_len += 1 else: if current_len > max_len: max_len = current_len max_substr = current_char * current_len current_char = s[i] current_len = 1 # check last sequence if current_len > max_len: max_len = current_len max_substr = current_char * current_len return (max_substr, max_len)"},{"question":"from collections import defaultdict import re STOP_WORDS = {'a', 'an', 'the', 'and', 'or', 'but', 'on', 'in', 'with', 'is', 'it', 'by', 'to', 'of', 'for', 'at', 'as', 'be', 'from', 'that', 'this', 'which'} def word_frequency_counter(text: str) -> dict: Returns a dictionary with the frequency count of each word in the provided text, excluding common stop words. >>> word_frequency_counter(\\"The quick brown fox jumps over the lazy dog\\") {'quick': 1, 'brown': 1, 'fox': 1, 'jumps': 1, 'over': 1, 'lazy': 1, 'dog': 1} >>> word_frequency_counter(\\"This is a test. This test is simple.\\") {'test': 2, 'simple': 1} >>> word_frequency_counter(\\"Python programming is fun and educational. Educational content is valuable.\\") {'python': 1, 'programming': 1, 'fun': 1, 'educational': 2, 'content': 1, 'valuable': 1} word_count = defaultdict(int) # Convert to lowercase and remove punctuation text = re.sub(r'[^ws]', '', text.lower()) words = text.split() for word in words: if word not in STOP_WORDS: word_count[word] += 1 return dict(word_count)","solution":"import re from collections import defaultdict STOP_WORDS = {'a', 'an', 'the', 'and', 'or', 'but', 'on', 'in', 'with', 'is', 'it', 'by', 'to', 'of', 'for', 'at', 'as', 'be', 'from', 'that', 'this', 'which'} def word_frequency_counter(text): Returns a dictionary with the frequency count of each word in the provided text, excluding common stop words. word_count = defaultdict(int) # Convert to lowercase and remove punctuation text = re.sub(r'[^ws]', '', text.lower()) words = text.split() for word in words: if word not in STOP_WORDS: word_count[word] += 1 return dict(word_count)"},{"question":"class RomanNumeralConverter: @staticmethod def to_roman(num: int) -> str: Convert an integer to its Roman numeral representation. >>> RomanNumeralConverter.to_roman(1) == \\"I\\" >>> RomanNumeralConverter.to_roman(1994) == \\"MCMXCIV\\" @staticmethod def to_integer(s: str) -> int: Convert a Roman numeral to its integer representation. >>> RomanNumeralConverter.to_integer(\\"I\\") == 1 >>> RomanNumeralConverter.to_integer(\\"MCMXCIV\\") == 1994 def roman_numeral_operations(operations: List[Tuple[str, Union[int, str]]]) -> List[Union[int, str]]: Perform the given list of operations converting between integers and Roman numerals. Args: operations: A list of tuples where each tuple contains a string indicating the operation type (\\"to_roman\\" or \\"to_integer\\") and an integer or string which is the number to convert to a Roman numeral or Roman numeral to convert to an integer. Returns: A list of integers or strings where each element is the result of the corresponding conversion operation. Example: >>> operations = [(\\"to_roman\\", 1997), (\\"to_integer\\", \\"MCMLXX\\"), (\\"to_roman\\", 49), (\\"to_integer\\", \\"XLIX\\")] >>> roman_numeral_operations(operations) [\\"MCMXCVII\\", 1970, \\"XLIX\\", 49] # Unit Tests def test_roman_numeral_operations(): operations = [(\\"to_roman\\", 1997), (\\"to_integer\\", \\"MCMLXX\\"), (\\"to_roman\\", 49), (\\"to_integer\\", \\"XLIX\\")] assert roman_numeral_operations(operations) == [\\"MCMXCVII\\", 1970, \\"XLIX\\", 49] def test_to_roman_basic(): assert RomanNumeralConverter.to_roman(1) == \\"I\\" assert RomanNumeralConverter.to_roman(4) == \\"IV\\" assert RomanNumeralConverter.to_roman(9) == \\"IX\\" assert RomanNumeralConverter.to_roman(58) == \\"LVIII\\" assert RomanNumeralConverter.to_roman(1994) == \\"MCMXCIV\\" def test_to_integer_basic(): assert RomanNumeralConverter.to_integer(\\"I\\") == 1 assert RomanNumeralConverter.to_integer(\\"IV\\") == 4 assert RomanNumeralConverter.to_integer(\\"IX\\") == 9 assert RomanNumeralConverter.to_integer(\\"LVIII\\") == 58 assert RomanNumeralConverter.to_integer(\\"MCMXCIV\\") == 1994 def test_invalid_operations(): operations = [(\\"invalid_op\\", 1997), (\\"to_roman\\", \\"MCMLXX\\"), (\\"to_integer\\", 49), (\\"to_roman\\", 49)] assert roman_numeral_operations(operations) == [\\"XLIX\\"]","solution":"class RomanNumeralConverter: @staticmethod def to_roman(num): val = [ 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1 ] syb = [ \\"M\\", \\"CM\\", \\"D\\", \\"CD\\", \\"C\\", \\"XC\\", \\"L\\", \\"XL\\", \\"X\\", \\"IX\\", \\"V\\", \\"IV\\", \\"I\\" ] roman_num = '' i = 0 while num > 0: for _ in range(num // val[i]): roman_num += syb[i] num -= val[i] i += 1 return roman_num @staticmethod def to_integer(s): roman = { 'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000 } integer = 0 for i in range(len(s)): if i > 0 and roman[s[i]] > roman[s[i - 1]]: integer += roman[s[i]] - 2 * roman[s[i - 1]] else: integer += roman[s[i]] return integer def roman_numeral_operations(operations): results = [] for op, value in operations: if op == \\"to_roman\\" and isinstance(value, int): results.append(RomanNumeralConverter.to_roman(value)) elif op == \\"to_integer\\" and isinstance(value, str): results.append(RomanNumeralConverter.to_integer(value)) return results"},{"question":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def remove_duplicates_from_sorted_linked_list(head: ListNode) -> ListNode: Remove duplicates from a sorted singly linked list. >>> head1 = ListNode(1, ListNode(1, ListNode(2))) >>> new_head1 = remove_duplicates_from_sorted_linked_list(head1) >>> linked_list_to_list(new_head1) [1, 2] >>> head2 = ListNode(1, ListNode(1, ListNode(2, ListNode(3, ListNode(3))))) >>> new_head2 = remove_duplicates_from_sorted_linked_list(head2) >>> linked_list_to_list(new_head2) [1, 2, 3] >>> head3 = ListNode(4, ListNode(4, ListNode(4, ListNode(4)))) >>> new_head3 = remove_duplicates_from_sorted_linked_list(head3) >>> linked_list_to_list(new_head3) [4] >>> head4 = ListNode(5) >>> new_head4 = remove_duplicates_from_sorted_linked_list(head4) >>> linked_list_to_list(new_head4) [5] >>> head5 = None >>> new_head5 = remove_duplicates_from_sorted_linked_list(head5) >>> linked_list_to_list(new_head5) [] pass def linked_list_to_list(head): result = [] while head: result.append(head.val) head = head.next return result","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def remove_duplicates_from_sorted_linked_list(head: ListNode) -> ListNode: current = head while current and current.next: if current.val == current.next.val: current.next = current.next.next else: current = current.next return head"},{"question":"from typing import List def min_path_sum(grid: List[List[int]]) -> int: Calculates the minimum sum of all numbers along a path from the top-left corner to the bottom-right corner of the grid. You can only move either down or right at any point in time. >>> min_path_sum([[1, 3, 1], [1, 5, 1], [4, 2, 1]]) 7 >>> min_path_sum([[1, 2, 3], [4, 5, 6]]) 12 >>> min_path_sum([[1, 2], [1, 1]]) 3 >>> min_path_sum([[0]]) 0 >>> min_path_sum([[1]]) 1 >>> min_path_sum([]) 0 >>> min_path_sum([[1, 2, 5], [3, 2, 1]]) 6","solution":"from typing import List def min_path_sum(grid: List[List[int]]) -> int: if not grid or not grid[0]: return 0 rows, cols = len(grid), len(grid[0]) dp = [[0] * cols for _ in range(rows)] dp[0][0] = grid[0][0] for i in range(1, rows): dp[i][0] = dp[i-1][0] + grid[i][0] for j in range(1, cols): dp[0][j] = dp[0][j-1] + grid[0][j] for i in range(1, rows): for j in range(1, cols): dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j] return dp[rows-1][cols-1]"},{"question":"from typing import List def shortest_path_in_grid(grid: List[List[int]]) -> int: Computes the shortest path from the top-left corner to the bottom-right corner of the grid, only passing through walkable cells. If there is no possible path, the function should return -1. >>> grid = [ ... [0, 0, 1], ... [0, 1, 0], ... [0, 0, 0] ... ] >>> shortest_path_in_grid(grid) 4 >>> grid = [ ... [0, 1], ... [1, 0] ... ] >>> shortest_path_in_grid(grid) -1 pass def test_shortest_path_in_simple_grid(): grid = [ [0, 1], [1, 0] ] assert shortest_path_in_grid(grid) == -1 def test_shortest_path_with_direct_path(): grid = [ [0, 0, 1], [0, 1, 0], [0, 0, 0] ] assert shortest_path_in_grid(grid) == 4 def test_shortest_path_on_obstructed_grid(): grid = [ [0, 0, 0], [1, 1, 0], [0, 0, 0] ] assert shortest_path_in_grid(grid) == 4 def test_shortest_path_in_large_grid(): grid = [ [0] * 500 for _ in range(500) ] assert shortest_path_in_grid(grid) == 998 def test_no_path_available(): grid = [ [0, 1, 0], [1, 1, 0], [0, 0, 0] ] assert shortest_path_in_grid(grid) == -1 def test_start_or_end_blocked(): grid1 = [ [1, 0], [0, 0] ] assert shortest_path_in_grid(grid1) == -1 grid2 = [ [0, 0], [0, 1] ] assert shortest_path_in_grid(grid2) == -1","solution":"from collections import deque def shortest_path_in_grid(grid: list[list[int]]) -> int: rows = len(grid) cols = len(grid[0]) if grid[0][0] == 1 or grid[rows-1][cols-1] == 1: return -1 directions = [(1, 0), (0, 1), (-1, 0), (0, -1)] queue = deque([(0, 0, 0)]) # (x, y, distance) visited = set((0, 0)) while queue: x, y, dist = queue.popleft() if x == rows-1 and y == cols-1: return dist for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < rows and 0 <= ny < cols and grid[nx][ny] == 0 and (nx, ny) not in visited: queue.append((nx, ny, dist + 1)) visited.add((nx, ny)) return -1"},{"question":"def modified_fibonacci(n: int) -> List[int]: Returns the first n numbers in a modified Fibonacci sequence where each term is the sum of the last three terms. >>> modified_fibonacci(1) [0] >>> modified_fibonacci(2) [0, 1] >>> modified_fibonacci(3) [0, 1, 1] >>> modified_fibonacci(5) [0, 1, 1, 2, 4] >>> modified_fibonacci(10) [0, 1, 1, 2, 4, 7, 13, 24, 44, 81]","solution":"from typing import List def modified_fibonacci(n: int) -> List[int]: Returns the first n numbers in a modified Fibonacci sequence where each term is the sum of the last three terms. if n == 1: return [0] elif n == 2: return [0, 1] elif n == 3: return [0, 1, 1] sequence = [0, 1, 1] for i in range(3, n): next_term = sequence[-1] + sequence[-2] + sequence[-3] sequence.append(next_term) return sequence"},{"question":"def reorder_string(s: str) -> str: Reorders the input string such that all digits are moved to the front, followed by alphabetic characters, and then special characters. The relative order of each category (digits, alphabetic characters, special characters) is preserved. :param s: Input string containing digits, alphabetic characters, and special characters :return: Reordered string pass def test_digits_only(): assert reorder_string(\\"12345\\") == \\"12345\\" def test_alphabets_only(): assert reorder_string(\\"abcDEF\\") == \\"abcDEF\\" def test_special_chars_only(): assert reorder_string(\\"!@#%\\") == \\"!@#%\\" def test_digits_and_alphabets(): assert reorder_string(\\"a1b2c3\\") == \\"123abc\\" def test_digits_and_special_chars(): assert reorder_string(\\"1!2@3#\\") == \\"123!@#\\" def test_all_mixed(): assert reorder_string(\\"a1!b2@c3#\\") == \\"123abc!@#\\" def test_empty_string(): assert reorder_string(\\"\\") == \\"\\" def test_no_digits(): assert reorder_string(\\"abc!@#\\") == \\"abc!@#\\" def test_no_alphabets(): assert reorder_string(\\"123!@#\\") == \\"123!@#\\" def test_no_special_chars(): assert reorder_string(\\"123abc\\") == \\"123abc\\" def test_long_string(): s = \\"a\\"*1000 + \\"1\\"*1000 + \\"!\\"*1000 assert reorder_string(s) == \\"1\\"*1000 + \\"a\\"*1000 + \\"!\\"*1000","solution":"def reorder_string(s: str) -> str: Reorders the input string such that all digits are moved to the front, followed by alphabetic characters, and then special characters. The relative order of each category (digits, alphabetic characters, special characters) is preserved. :param s: Input string containing digits, alphabetic characters, and special characters :return: Reordered string digits = [] alphabets = [] specials = [] for char in s: if char.isdigit(): digits.append(char) elif char.isalpha(): alphabets.append(char) else: specials.append(char) return ''.join(digits + alphabets + specials)"},{"question":"from typing import Dict, List, Tuple def add_contact(all_contacts: Dict[str, str], name: str, phone: str) -> None: Adds a new contact to the dictionary of contacts. If the contact name already exists, update the phone number. :param all_contacts: Dictionary containing all contacts. :param name: Name of the contact. :param phone: Phone number of the contact. >>> contacts = {} >>> add_contact(contacts, \\"Alice\\", \\"12345\\") >>> contacts {'Alice': '12345'} >>> add_contact(contacts, \\"Alice\\", \\"54321\\") >>> contacts {'Alice': '54321'} pass def find_contact(all_contacts: Dict[str, str], name: str) -> str: Finds the phone number of the given contact name. If the contact does not exist, return \\"Contact not found\\". :param all_contacts: Dictionary containing all contacts. :param name: Name of the contact to find. :return: Phone number of the contact or \\"Contact not found\\" if the contact does not exist. >>> contacts = {\\"Alice\\": \\"54321\\"} >>> find_contact(contacts, \\"Alice\\") '54321' >>> find_contact(contacts, \\"Bob\\") 'Contact not found' pass def list_contacts(all_contacts: Dict[str, str]) -> List[Tuple[str, str]]: Returns a list of all contacts in lexicographical order, where each contact is a tuple consisting of the name and the phone number. :param all_contacts: Dictionary containing all contacts. :return: List of tuples, each containing the contact name and phone number, in lexicographical order. >>> contacts = {\\"Bob\\": \\"67890\\", \\"Alice\\": \\"54321\\"} >>> list_contacts(contacts) [('Alice', '54321'), ('Bob', '67890')] pass","solution":"from typing import Dict, Tuple, List def add_contact(all_contacts: Dict[str, str], name: str, phone: str) -> None: Adds a new contact to the dictionary of contacts. If the contact name already exists, update the phone number. :param all_contacts: Dictionary containing all contacts. :param name: Name of the contact. :param phone: Phone number of the contact. all_contacts[name] = phone def find_contact(all_contacts: Dict[str, str], name: str) -> str: Finds the phone number of the given contact name. If the contact does not exist, return \\"Contact not found\\". :param all_contacts: Dictionary containing all contacts. :param name: Name of the contact to find. :return: Phone number of the contact or \\"Contact not found\\" if the contact does not exist. return all_contacts.get(name, \\"Contact not found\\") def list_contacts(all_contacts: Dict[str, str]) -> List[Tuple[str, str]]: Returns a list of all contacts in lexicographical order, where each contact is a tuple consisting of the name and the phone number. :param all_contacts: Dictionary containing all contacts. :return: List of tuples, each containing the contact name and phone number, in lexicographical order. return sorted(all_contacts.items())"},{"question":"from collections import deque class OrderManager: def __init__(self): Initializes an empty order management system. def add_order(self, order_id: int) -> None: Adds a new order to the system. :param order_id: Integer representing the unique ID of the order. def complete_order(self) -> int: Marks the next pending order as completed and removes it from the system. :return: The ID of the completed order. If there are no pending orders, return -1. def next_order(self) -> int: Retrieves the ID of the next pending order without marking it as completed. :return: The ID of the next pending order. If there are no pending orders, return -1. def test_order_manager_empty(): om = OrderManager() assert om.next_order() == -1 assert om.complete_order() == -1 def test_order_manager_single_order(): om = OrderManager() om.add_order(101) assert om.next_order() == 101 assert om.complete_order() == 101 assert om.next_order() == -1 assert om.complete_order() == -1 def test_order_manager_multiple_orders(): om = OrderManager() om.add_order(101) om.add_order(102) om.add_order(103) assert om.next_order() == 101 assert om.complete_order() == 101 assert om.next_order() == 102 assert om.complete_order() == 102 assert om.next_order() == 103 assert om.complete_order() == 103 assert om.next_order() == -1 assert om.complete_order() == -1 def test_order_manager_add_and_complete(): om = OrderManager() om.add_order(101) om.add_order(102) assert om.complete_order() == 101 om.add_order(103) assert om.next_order() == 102 assert om.complete_order() == 102 assert om.complete_order() == 103 assert om.next_order() == -1 assert om.complete_order() == -1 def test_order_manager_edge_cases(): om = OrderManager() assert om.complete_order() == -1 om.add_order(101) assert om.complete_order() == 101 assert om.complete_order() == -1","solution":"from collections import deque class OrderManager: def __init__(self): Initializes an empty order management system. self.orders = deque() def add_order(self, order_id: int) -> None: Adds a new order to the system. :param order_id: Integer representing the unique ID of the order. self.orders.append(order_id) def complete_order(self) -> int: Marks the next pending order as completed and removes it from the system. :return: The ID of the completed order. If there are no pending orders, return -1. if not self.orders: return -1 return self.orders.popleft() def next_order(self) -> int: Retrieves the ID of the next pending order without marking it as completed. :return: The ID of the next pending order. If there are no pending orders, return -1. if not self.orders: return -1 return self.orders[0]"},{"question":"class StudentRecords: def __init__(self): self.students = {} def add_student(self, student_id: int, name: str, gpa: float) -> None: Adds a new student to the records or updates an existing student if the ID already exists. pass def search_student(self, student_id: int) -> dict: Returns the student's information as a dictionary if found, else None. pass def average_gpa(self) -> float: Calculates and returns the average GPA of all student records, rounded to two decimal places. pass # Unit tests def test_add_student(): sr = StudentRecords() sr.add_student(101, \\"Alice\\", 3.5) sr.add_student(102, \\"Bob\\", 3.8) assert sr.search_student(101) == {\\"id\\": 101, \\"name\\": \\"Alice\\", \\"gpa\\": 3.5} assert sr.search_student(102) == {\\"id\\": 102, \\"name\\": \\"Bob\\", \\"gpa\\": 3.8} def test_update_student(): sr = StudentRecords() sr.add_student(101, \\"Alice\\", 3.5) sr.add_student(101, \\"Alice Smith\\", 3.7) assert sr.search_student(101) == {\\"id\\": 101, \\"name\\": \\"Alice Smith\\", \\"gpa\\": 3.7} def test_search_student_not_found(): sr = StudentRecords() assert sr.search_student(999) == None def test_average_gpa(): sr = StudentRecords() sr.add_student(101, \\"Alice\\", 3.5) sr.add_student(102, \\"Bob\\", 3.8) assert sr.average_gpa() == 3.65 def test_average_gpa_no_students(): sr = StudentRecords() assert sr.average_gpa() == 0.0 def test_average_gpa_one_student(): sr = StudentRecords() sr.add_student(101, \\"Alice\\", 4.0) assert sr.average_gpa() == 4.0","solution":"class StudentRecords: def __init__(self): self.students = {} def add_student(self, student_id: int, name: str, gpa: float) -> None: Adds a new student to the records or updates an existing student if the ID already exists. self.students[student_id] = {\\"name\\": name, \\"gpa\\": gpa} def search_student(self, student_id: int) -> dict: Returns the student's information as a dictionary if found, else None. if student_id in self.students: return {\\"id\\": student_id, \\"name\\": self.students[student_id][\\"name\\"], \\"gpa\\": self.students[student_id][\\"gpa\\"]} return None def average_gpa(self) -> float: Calculates and returns the average GPA of all student records, rounded to two decimal places. if not self.students: return 0.0 total_gpa = sum(student[\\"gpa\\"] for student in self.students.values()) return round(total_gpa / len(self.students), 2)"},{"question":"def calculate_average_scores(student_scores: dict) -> dict: Calculate the average score for each student. Args: student_scores (dict): A dictionary with student names as keys and lists of their scores as values. Returns: dict: A dictionary with student names as keys and their average scores as values rounded to two decimal places. Example: >>> calculate_average_scores({\\"Alice\\": [90, 80, 70], \\"Bob\\": [100, 90]}) {\\"Alice\\": 80.0, \\"Bob\\": 95.0} >>> calculate_average_scores({\\"Charlie\\": [70, 85, 90, 95], \\"David\\": [80]}) {\\"Charlie\\": 85.0, \\"David\\": 80.0} >>> calculate_average_scores({\\"Eve\\": [50, 60, 40], \\"Frank\\": [90, 87, 85, 92]}) {\\"Eve\\": 50.0, \\"Frank\\": 88.5}","solution":"def calculate_average_scores(student_scores: dict) -> dict: Calculate the average score for each student. Args: student_scores (dict): A dictionary with student names as keys and lists of their scores as values. Returns: dict: A dictionary with student names as keys and their average scores as values rounded to two decimal places. average_scores = {} for student, scores in student_scores.items(): average = round(sum(scores) / len(scores), 2) average_scores[student] = average return average_scores"},{"question":"def min_path_sum(grid_str: str) -> int: Calculates the minimum cost path sum from the top-left corner to the bottom-right corner of the grid. Parameters: grid_str (str): Grid represented as a string of space-separated integers. Returns: int: Minimum cost path sum. Example: >>> min_path_sum(\\"1 3 1n1 5 1n4 2 1\\") 7 >>> min_path_sum(\\"1 2n4 5\\") 8 >>> min_path_sum(\\"1 2 3\\") 6 >>> min_path_sum(\\"1n2n3\\") 6 >>> min_path_sum(\\"1 2 3n4 8 2n1 5 3\\") 11 >>> min_path_sum(\\"5\\") 5 >>> min_path_sum(\\"5 10n15 20\\") 35 >>> min_path_sum(\\"0 0 0n0 0 0n0 0 0\\") 0","solution":"def min_path_sum(grid_str: str) -> int: Calculates the minimum cost path sum from the top-left corner to the bottom-right corner of the grid. :param grid_str: Grid represented as a string of space-separated integers. :return: Minimum cost path sum. # Convert grid string to a 2D list of integers grid = [list(map(int, row.split())) for row in grid_str.strip().split('n')] rows = len(grid) cols = len(grid[0]) # Using dynamic programming to store the minimum path sums dp = [[0] * cols for _ in range(rows)] # Initialize the first cell dp[0][0] = grid[0][0] # Fill the first row (can only come from the left) for col in range(1, cols): dp[0][col] = dp[0][col - 1] + grid[0][col] # Fill the first column (can only come from above) for row in range(1, rows): dp[row][0] = dp[row - 1][0] + grid[row][0] # Fill the rest of the dp table for row in range(1, rows): for col in range(1, cols): dp[row][col] = min(dp[row - 1][col], dp[row][col - 1]) + grid[row][col] return dp[-1][-1]"},{"question":"class Node: def __init__(self, value): self.value = value self.next = None class Stack: Implement a stack using a singly linked list. Methods: is_empty() -> bool: Check if the stack is empty. push(value: int) -> None: Push a new element onto the stack. pop() -> int: Remove and return the top element of the stack. peek() -> int: Return the top element of the stack without removing it. __str__() -> str: Get the string representation of the stack state. >>> stack = Stack() >>> stack.push(1) >>> str(stack) '1' >>> stack.push(2) >>> str(stack) '2->1' >>> stack.push(3) >>> str(stack) '3->2->1' >>> stack.peek() 3 >>> stack.pop() 3 >>> str(stack) '2->1' >>> stack.is_empty() False >>> stack.pop() 2 >>> stack.pop() 1 >>> str(stack) 'Stack is empty' >>> stack.is_empty() True","solution":"class Node: def __init__(self, value): self.value = value self.next = None class Stack: def __init__(self): self.top = None def is_empty(self): return self.top is None def push(self, value): new_node = Node(value) new_node.next = self.top self.top = new_node def pop(self): if self.is_empty(): raise IndexError(\\"pop from empty stack\\") value = self.top.value self.top = self.top.next return value def peek(self): if self.is_empty(): raise IndexError(\\"peek from empty stack\\") return self.top.value def __str__(self): if self.is_empty(): return \\"Stack is empty\\" current = self.top elements = [] while current: elements.append(str(current.value)) current = current.next return \\"->\\".join(elements)"},{"question":"from typing import List def column_sums(matrix: List[List[int]]) -> List[int]: Calculate the sum of each column in a 2D matrix. Parameters: matrix (List[List[int]]): The input 2-dimensional matrix of integers. Returns: List[int]: A list containing the sums of each column. Raises: ValueError: If the input matrix is empty or if any of its rows have different lengths. Examples: >>> column_sums([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) [12, 15, 18] >>> column_sums([[1, 2], [3, 4], [5, 6]]) [9, 12] >>> column_sums([[10], [20], [30]]) [60] >>> column_sums([]) Traceback (most recent call last): ... ValueError: Matrix must not be empty. >>> column_sums([[1, 2], [3, 4, 5], [6, 7]]) Traceback (most recent call last): ... ValueError: All rows in the matrix must have the same length.","solution":"from typing import List def column_sums(matrix: List[List[int]]) -> List[int]: Calculates the sum of each column in the given 2D matrix. Parameters: matrix (List[List[int]]): The input 2-dimensional matrix of integers. Returns: List[int]: A list containing the sums of each column. Raises: ValueError: If the input matrix is empty or if any of its rows have different lengths. # Check if matrix is empty if not matrix or not matrix[0]: raise ValueError(\\"Matrix must not be empty.\\") # Check if all rows have the same length row_length = len(matrix[0]) for row in matrix: if len(row) != row_length: raise ValueError(\\"All rows in the matrix must have the same length.\\") # Compute column sums num_columns = row_length sums = [0] * num_columns for row in matrix: for i in range(num_columns): sums[i] += row[i] return sums"},{"question":"def is_prime(num: int) -> bool: Check if a number is prime. >>> is_prime(2) True >>> is_prime(4) False def is_palindrome(num: int) -> bool: Check if a number is a palindrome. >>> is_palindrome(121) True >>> is_palindrome(123) False def largest_prime_palindrome(n: int) -> int: Identify the largest prime palindrome less than a given integer \`n\`. >>> largest_prime_palindrome(1000) 929 >>> largest_prime_palindrome(10) 7 from solution import largest_prime_palindrome def test_largest_prime_palindrome_1000(): assert largest_prime_palindrome(1000) == 929 def test_largest_prime_palindrome_10(): assert largest_prime_palindrome(10) == 7 def test_largest_prime_palindrome_100(): assert largest_prime_palindrome(100) == 11 def test_largest_prime_palindrome_1(): assert largest_prime_palindrome(1) == -1 def test_largest_prime_palindrome_2(): assert largest_prime_palindrome(2) == -1 def test_largest_prime_palindrome_10_000(): assert largest_prime_palindrome(10000) == 929 def test_largest_prime_palindrome_1_000_000(): assert largest_prime_palindrome(1000000) == 98689","solution":"def is_prime(num): if num <= 1: return False if num <= 3: return True if num % 2 == 0 or num % 3 == 0: return False i = 5 while i * i <= num: if num % i == 0 or num % (i + 2) == 0: return False i += 6 return True def is_palindrome(num): return str(num) == str(num)[::-1] def largest_prime_palindrome(n): for num in range(n - 1, 1, -1): if is_palindrome(num) and is_prime(num): return num return -1"},{"question":"from typing import List def transform_text(text: str, operations: List[str]) -> str: Transform text based on a list of operations. Each operation is a string in one of the following formats: - \\"upper\\": Convert the entire string to uppercase. - \\"lower\\": Convert the entire string to lowercase. - \\"capitalize\\": Capitalize the first letter of each word in the string. - \\"reverse\\": Reverse the entire string. - \\"replace <old> <new>\\": Replace all occurrences of substring \`<old>\` with substring \`<new>\`. Args: text (str): the initial string to be transformed. operations (List[str]): a list of transformation commands. Returns: str: the transformed string after applying all operations in the given order. >>> transform_text(\\"hello world\\", [\\"upper\\"]) 'HELLO WORLD' >>> transform_text(\\"HELLO WORLD\\", [\\"lower\\", \\"capitalize\\"]) 'Hello World' >>> transform_text(\\"abc def ghi\\", [\\"replace def xyz\\", \\"reverse\\"]) 'ihg zyx cba' >>> transform_text(\\"tech assessments\\", [\\"replace tech code\\", \\"upper\\"]) 'CODE ASSESSMENTS'","solution":"from typing import List def transform_text(text: str, operations: List[str]) -> str: for operation in operations: if operation == \\"upper\\": text = text.upper() elif operation == \\"lower\\": text = text.lower() elif operation == \\"capitalize\\": text = text.title() elif operation == \\"reverse\\": text = text[::-1] elif operation.startswith(\\"replace \\"): parts = operation.split(\\" \\", 2) old = parts[1] new = parts[2] text = text.replace(old, new) return text"},{"question":"from typing import List def average_contribution_time(contributions: List[int]) -> float: Compute the average contribution time for a list of developers in minutes. Args: contributions (List[int]): List of contribution times in minutes. Returns: float: Average time spent, rounded to two decimal places. Examples: >>> average_contribution_time([120, 140, 160]) 140.00 >>> average_contribution_time([45, 30, 50, 80]) 51.25 >>> average_contribution_time([]) 0.00 pass def test_average_normal_case(): assert average_contribution_time([120, 140, 160]) == 140.00 def test_average_mixed_contributions(): assert average_contribution_time([45, 30, 50, 80]) == 51.25 def test_average_empty_list(): assert average_contribution_time([]) == 0.00 def test_average_single_contribution(): assert average_contribution_time([100]) == 100.00 def test_average_zero_contributions(): assert average_contribution_time([0, 0, 0]) == 0.00 def test_average_large_numbers(): assert average_contribution_time([1000000, 2000000, 3000000]) == 2000000.00 def test_average_rounded_result(): assert average_contribution_time([10, 20, 30]) == 20.00 assert average_contribution_time([10, 20, 31]) == 20.33","solution":"from typing import List def average_contribution_time(contributions: List[int]) -> float: if not contributions: return 0.00 average = sum(contributions) / len(contributions) return round(average, 2)"},{"question":"def is_prime(n: int) -> bool: Determine if the given integer is a prime number. Parameters: n (int): The integer to check for primality. Returns: bool: True if n is a prime number, otherwise False. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def group_by_prime(numbers: list[int]) -> dict[str, list[int]]: Group a list of integers into prime and non-prime categories. Parameters: numbers (list[int]): A list of integers to be grouped. Returns: dict[str, list[int]]: A dictionary with keys 'prime' and 'non_prime' mapping to lists containing primes and non-primes respectively. Examples: >>> group_by_prime([2, 3, 4, 5, 8, 11, 14, 17]) {'prime': [2, 3, 5, 11, 17], 'non_prime': [4, 8, 14]} >>> group_by_prime([0, 1, 2, 3, 4]) {'prime': [2, 3], 'non_prime': [0, 1, 4]}","solution":"def is_prime(n: int) -> bool: Determine if the given integer is a prime number. Parameters: n (int): The integer to check for primality. Returns: bool: True if n is a prime number, otherwise False. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def group_by_prime(numbers: list[int]) -> dict[str, list[int]]: Group a list of integers into prime and non-prime categories. Parameters: numbers (list[int]): A list of integers to be grouped. Returns: dict[str, list[int]]: A dictionary with keys 'prime' and 'non_prime' mapping to lists containing primes and non-primes respectively. grouped = {\\"prime\\": [], \\"non_prime\\": []} for number in numbers: if is_prime(number): grouped[\\"prime\\"].append(number) else: grouped[\\"non_prime\\"].append(number) return grouped"},{"question":"import heapq from typing import List class TaskScheduler: Class to manage and schedule tasks based on priority using a priority queue. Methods: - add_task(task_name: str, priority: int): Adds a task with the specified priority. - get_task() -> str: Retrieves the highest priority task without removing it. - remove_task() -> str: Removes and returns the highest priority task. - process_tasks(n: int) -> List[str]: Processes and removes the top \`n\` highest priority tasks and returns them. def __init__(self): self.task_queue = [] self.task_counter = 0 def add_task(self, task_name: str, priority: int): Adds a task with the specified priority. >>> scheduler = TaskScheduler() >>> scheduler.add_task(\\"Task 1\\", 3) pass def get_task(self) -> str: Retrieves the highest priority task without removing it. >>> scheduler = TaskScheduler() >>> scheduler.add_task(\\"Task 1\\", 3) >>> scheduler.add_task(\\"Task 2\\", 1) >>> scheduler.get_task() 'Task 2' pass def remove_task(self) -> str: Removes and returns the highest priority task. >>> scheduler = TaskScheduler() >>> scheduler.add_task(\\"Task 1\\", 3) >>> scheduler.add_task(\\"Task 2\\", 1) >>> scheduler.remove_task() 'Task 2' pass def process_tasks(self, n: int) -> List[str]: Processes and removes the top \`n\` highest priority tasks and returns them in order of processing. >>> scheduler = TaskScheduler() >>> scheduler.add_task(\\"Task 1\\", 3) >>> scheduler.add_task(\\"Task 2\\", 1) >>> scheduler.add_task(\\"Task 3\\", 2) >>> scheduler.process_tasks(2) ['Task 2', 'Task 3'] pass","solution":"import heapq class TaskScheduler: def __init__(self): self.task_queue = [] self.task_counter = 0 # to maintain insertion order for tasks with same priority def add_task(self, task_name, priority): heapq.heappush(self.task_queue, (priority, self.task_counter, task_name)) self.task_counter += 1 def get_task(self): if self.task_queue: return self.task_queue[0][2] return None def remove_task(self): if self.task_queue: return heapq.heappop(self.task_queue)[2] return None def process_tasks(self, n): processed_tasks = [] for _ in range(n): if self.task_queue: processed_tasks.append(self.remove_task()) else: break return processed_tasks"},{"question":"def is_palindromic_product(a: int, b: int) -> bool: Determine if the product of two given positive integers is a palindrome. >>> is_palindromic_product(11, 11) True >>> is_palindromic_product(123, 321) False >>> is_palindromic_product(111, 121) True >>> is_palindromic_product(10, 90) False","solution":"def is_palindromic_product(a: int, b: int) -> bool: This function returns True if the product of \`a\` and \`b\` is a palindrome, otherwise False. Parameters: a (int): A positive integer. b (int): A positive integer. Returns: bool: True if the product of \`a\` and \`b\` is a palindrome, otherwise False. product = a * b string_product = str(product) return string_product == string_product[::-1]"},{"question":"from typing import List def count_increasing_subsequences(arr: List[int], k: int) -> int: Returns the number of strictly increasing subsequences of length k that can be found in arr. >>> count_increasing_subsequences([1, 2, 3, 4], 2) 6 >>> count_increasing_subsequences([2, 1, 3, 2, 4], 3) 3 >>> count_increasing_subsequences([], 0) 1 >>> count_increasing_subsequences([1, 2, 3], 0) 1 >>> count_increasing_subsequences([1, 2, 3], 4) 0 >>> count_increasing_subsequences([1], 1) 1 >>> count_increasing_subsequences([3, 2, 1], 2) 0","solution":"from typing import List def count_increasing_subsequences(arr: List[int], k: int) -> int: Returns the number of strictly increasing subsequences of length k that can be found in arr. if k == 0: return 1 if k > len(arr): return 0 # Create a 2D dp array, where dp[i][j] represents the number of increasing subsequences # of length j+1 ending with arr[i]. dp = [[0] * k for _ in range(len(arr))] # Initialize dp for subsequences of length 1 for i in range(len(arr)): dp[i][0] = 1 # Fill the dp array for j in range(1, k): for i in range(j, len(arr)): # i needs to be at least j (to have enough elements before) for p in range(i): # Consider all previous elements arr[p] < arr[i] if arr[p] < arr[i]: dp[i][j] += dp[p][j-1] # Sum up all the ways to end a subsequence of length k result = 0 for i in range(len(arr)): result += dp[i][k-1] return result"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_valid_bst(root: TreeNode) -> bool: Determine if a binary tree is a valid Binary Search Tree (BST). You are required to implement a function to determine if a binary tree is a valid Binary Search Tree. Input: - root (TreeNode): The root of the binary tree. Output: - bool: True if the binary tree is a valid BST, False otherwise. Constraints: - Each node in the binary tree contains an integer value. - The number of nodes in the tree is 0 <= n <= 10^4. Example usage: >>> root = TreeNode(2) >>> root.left = TreeNode(1) >>> root.right = TreeNode(3) >>> is_valid_bst(root) True >>> root = TreeNode(5) >>> root.left = TreeNode(1) >>> root.right = TreeNode(4) >>> root.right.left = TreeNode(3) >>> root.right.right = TreeNode(6) >>> is_valid_bst(root) False >>> is_valid_bst(None) True >>> root = TreeNode(1) >>> root.left = TreeNode(1) >>> is_valid_bst(root) False # Your code here from solution import TreeNode, is_valid_bst def test_example_1(): root = TreeNode(2) root.left = TreeNode(1) root.right = TreeNode(3) assert is_valid_bst(root) == True def test_example_2(): root = TreeNode(5) root.left = TreeNode(1) root.right = TreeNode(4) root.right.left = TreeNode(3) root.right.right = TreeNode(6) assert is_valid_bst(root) == False def test_empty_tree(): assert is_valid_bst(None) == True def test_single_node(): root = TreeNode(1) assert is_valid_bst(root) == True def test_duplicate_values(): root = TreeNode(1) root.left = TreeNode(1) assert is_valid_bst(root) == False def test_large_bst(): root = TreeNode(10) root.left = TreeNode(5) root.right = TreeNode(15) root.left.left = TreeNode(3) root.left.right = TreeNode(7) root.right.left = TreeNode(12) root.right.right = TreeNode(17) assert is_valid_bst(root) == True def test_invalid_bst_with_wrong_subtree(): root = TreeNode(10) root.left = TreeNode(5) root.right = TreeNode(15) root.left.left = TreeNode(3) root.left.right = TreeNode(7) root.right.left = TreeNode(6) # Incorrect placement root.right.right = TreeNode(17) assert is_valid_bst(root) == False","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_valid_bst(root: TreeNode) -> bool: def validate(node, low=float('-inf'), high=float('inf')): if not node: return True if not (low < node.val < high): return False return validate(node.left, low, node.val) and validate(node.right, node.val, high) return validate(root)"},{"question":"def dot_product(vector_a: list, vector_b: list) -> float: Calculate the dot product of two vectors. Parameters: - vector_a (list): A list of floats representing the first vector. - vector_b (list): A list of floats representing the second vector. Returns: - result (float): The dot product of the two vectors. Example: >>> dot_product([1, 2, 3], [4, 5, 6]) 32.0 >>> dot_product([1.5, 2.5], [3.5, 4.5]) 16.75 >>> dot_product([0, 0, 0], [1, 2, 3]) 0.0 >>> dot_product([1, 2], [3]) None # The vectors are of different lengths. Constraints: - Each vector can have up to 100 elements. - Each element in the vectors is a float. - If the vectors are of different lengths, return None. pass def test_dot_product(): # Test with positive integers assert dot_product([1, 2, 3], [4, 5, 6]) == 32.0 # Test with floating points assert dot_product([1.5, 2.5], [3.5, 4.5]) == 1.5 * 3.5 + 2.5 * 4.5 # Test with zero vector assert dot_product([0, 0, 0], [1, 2, 3]) == 0.0 # Test with differing lengths assert dot_product([1, 2], [3]) == None # Test with negative numbers assert dot_product([-1, -2, -3], [-4, -5, -6]) == 32.0 # Test with a mix of positive and negative numbers assert dot_product([1, -2, 3], [-4, 5, -6]) == -1 * 4 - 2 * 5 - 3 * 6 # Test with floating points and negative numbers assert dot_product([-1.5, 2.3], [3.4, -4.6]) == -1.5 * 3.4 + 2.3 * (-4.6) if __name__ == \\"__main__\\": test_dot_product() print(\\"All tests passed.\\")","solution":"def dot_product(vector_a: list, vector_b: list) -> float: Calculate the dot product of two vectors. Parameters: - vector_a (list): A list of floats representing the first vector. - vector_b (list): A list of floats representing the second vector. Returns: - result (float): The dot product of the two vectors. If the vectors are of different lengths, returns None. if len(vector_a) != len(vector_b): return None return sum(a * b for a, b in zip(vector_a, vector_b))"},{"question":"def filter_and_sort_records(records: list[dict], filter_field: str, substring: str, sort_field: str) -> list[dict]: Filters the records that contain the substring in the specified field and sorts the resulting records by another field. Parameters: records (list[dict]): A list of dictionaries representing the records. filter_field (str): The field name in which to search for the substring. substring (str): The substring to search for in the filter_field. sort_field (str): The field name by which to sort the resulting records. Returns: list[dict]: A list of dictionaries representing the filtered and sorted records. Raises: ValueError: If the filter_field or sort_field is not present in any of the records. Example: >>> records = [ ... {\\"name\\": \\"Alice\\", \\"age\\": 30, \\"city\\": \\"New York\\"}, ... {\\"name\\": \\"Bob\\", \\"age\\": 25, \\"city\\": \\"Los Angeles\\"}, ... {\\"name\\": \\"Charlie\\", \\"age\\": 35, \\"city\\": \\"Chicago\\"}, ... {\\"name\\": \\"Diana\\", \\"age\\": 40, \\"city\\": \\"New York\\"}, ... ] >>> filter_and_sort_records(records, \\"city\\", \\"New\\", \\"age\\") [{'name': 'Alice', 'age': 30, 'city': 'New York'}, {'name': 'Diana', 'age': 40, 'city': 'New York'}] from solution import filter_and_sort_records def test_empty_result(): records = [ {\\"name\\": \\"Alice\\", \\"age\\": 30, \\"city\\": \\"New York\\"}, {\\"name\\": \\"Bob\\", \\"age\\": 25, \\"city\\": \\"Los Angeles\\"}, {\\"name\\": \\"Charlie\\", \\"age\\": 35, \\"city\\": \\"Chicago\\"}, {\\"name\\": \\"Diana\\", \\"age\\": 40, \\"city\\": \\"New York\\"}, ] assert filter_and_sort_records(records, \\"name\\", \\"Z\\", \\"age\\") == [] def test_successful_filter_and_sort(): records = [ {\\"name\\": \\"Alice\\", \\"age\\": 30, \\"city\\": \\"New York\\"}, {\\"name\\": \\"Bob\\", \\"age\\": 25, \\"city\\": \\"Los Angeles\\"}, {\\"name\\": \\"Charlie\\", \\"age\\": 35, \\"city\\": \\"Chicago\\"}, {\\"name\\": \\"Diana\\", \\"age\\": 40, \\"city\\": \\"New York\\"}, ] result = filter_and_sort_records(records, \\"city\\", \\"New\\", \\"age\\") expected = [ {\\"name\\": \\"Alice\\", \\"age\\": 30, \\"city\\": \\"New York\\"}, {\\"name\\": \\"Diana\\", \\"age\\": 40, \\"city\\": \\"New York\\"} ] assert result == expected def test_another_successful_filter_and_sort(): records = [ {\\"name\\": \\"Alice\\", \\"age\\": 30, \\"city\\": \\"New York\\"}, {\\"name\\": \\"Bob\\", \\"age\\": 25, \\"city\\": \\"Los Angeles\\"}, {\\"name\\": \\"Charlie\\", \\"age\\": 35, \\"city\\": \\"Chicago\\"}, {\\"name\\": \\"Diana\\", \\"age\\": 40, \\"city\\": \\"New York\\"}, ] result = filter_and_sort_records(records, \\"name\\", \\"a\\", \\"age\\") expected = [ {\\"name\\": \\"Charlie\\", \\"age\\": 35, \\"city\\": \\"Chicago\\"}, {\\"name\\": \\"Diana\\", \\"age\\": 40, \\"city\\": \\"New York\\"} ] assert result == expected def test_invalid_filter_field(): records = [ {\\"name\\": \\"Alice\\", \\"age\\": 30, \\"city\\": \\"New York\\"}, {\\"name\\": \\"Bob\\", \\"age\\": 25, \\"city\\": \\"Los Angeles\\"}, {\\"name\\": \\"Charlie\\", \\"age\\": 35, \\"city\\": \\"Chicago\\"}, {\\"name\\": \\"Diana\\", \\"age\\": 40, \\"city\\": \\"New York\\"}, ] try: filter_and_sort_records(records, \\"country\\", \\"USA\\", \\"city\\") assert False, \\"Expected ValueError\\" except ValueError as e: assert str(e) == \\"Invalid field name provided.\\" def test_invalid_sort_field(): records = [ {\\"name\\": \\"Alice\\", \\"age\\": 30, \\"city\\": \\"New York\\"}, {\\"name\\": \\"Bob\\", \\"age\\": 25, \\"city\\": \\"Los Angeles\\"}, {\\"name\\": \\"Charlie\\", \\"age\\": 35, \\"city\\": \\"Chicago\\"}, {\\"name\\": \\"Diana\\", \\"age\\": 40, \\"city\\": \\"New York\\"}, ] try: filter_and_sort_records(records, \\"city\\", \\"New\\", \\"country\\") assert False, \\"Expected ValueError\\" except ValueError as e: assert str(e) == \\"Invalid field name provided.\\"","solution":"def filter_and_sort_records(records: list[dict], filter_field: str, substring: str, sort_field: str) -> list[dict]: Filters the records that contain the substring in the specified field and sorts the resulting records by another field. Parameters: records (list[dict]): A list of dictionaries representing the records. filter_field (str): The field name in which to search for the substring. substring (str): The substring to search for in the filter_field. sort_field (str): The field name by which to sort the resulting records. Returns: list[dict]: A list of dictionaries representing the filtered and sorted records. # Check if filter_field and sort_field are valid keys if not all([filter_field in record for record in records]) or not all([sort_field in record for record in records]): raise ValueError(\\"Invalid field name provided.\\") # Filter records based on the presence of the substring in the filter_field filtered_records = [record for record in records if substring in str(record[filter_field])] # Sort the filtered records by the sort_field sorted_records = sorted(filtered_records, key=lambda x: x[sort_field]) return sorted_records"},{"question":"import random class RandomizedSet: Custom data structure that supports insertion, deletion, and random retrieval of elements. Example: >>> rs = RandomizedSet() >>> print(rs) '{}' >>> rs.insert(1) True >>> rs.insert(2) True >>> rs.insert(2) False >>> print(rs) '{1, 2}' >>> rs.remove(1) True >>> rs.remove(1) False >>> print(rs) '{2}' >>> rs.getRandom() 2 >>> rs.insert(3) True >>> print(rs) '{2, 3}' >>> random_element = rs.getRandom() >>> random_element in [2, 3] True def __init__(self): pass def insert(self, val: int) -> bool: pass def remove(self, val: int) -> bool: pass def getRandom(self) -> int: pass def __str__(self) -> str: pass import pytest def test_randomized_set_operations(): rs = RandomizedSet() assert str(rs) == \\"{}\\" assert rs.insert(1) == True assert str(rs) == \\"{1}\\" assert rs.insert(2) == True assert str(rs) in [\\"{1, 2}\\", \\"{2, 1}\\"] assert rs.insert(2) == False assert str(rs) in [\\"{1, 2}\\", \\"{2, 1}\\"] assert rs.remove(1) == True assert str(rs) == \\"{2}\\" assert rs.remove(1) == False assert str(rs) == \\"{2}\\" assert rs.getRandom() == 2 assert rs.insert(3) == True assert str(rs) in [\\"{2, 3}\\", \\"{3, 2}\\"] random_element = rs.getRandom() assert random_element in [2, 3] def test_empty_set_random(): rs = RandomizedSet() with pytest.raises(ValueError): rs.getRandom()","solution":"import random class RandomizedSet: def __init__(self): self.num_list = [] self.num_dict = {} def insert(self, val: int) -> bool: if val in self.num_dict: return False self.num_dict[val] = len(self.num_list) self.num_list.append(val) return True def remove(self, val: int) -> bool: if val not in self.num_dict: return False index = self.num_dict[val] last_element = self.num_list[-1] self.num_list[index] = last_element self.num_dict[last_element] = index self.num_list.pop() del self.num_dict[val] return True def getRandom(self) -> int: if not self.num_list: raise ValueError(\\"The set is empty\\") return random.choice(self.num_list) def __str__(self) -> str: return \\"{\\" + \\", \\".join(map(str, self.num_list)) + \\"}\\""},{"question":"class StringPatternMatcher: def __init__(self) -> None: Initialize the StringPatternMatcher with no pattern set. pass def set_pattern(self, pattern: str) -> None: Set the pattern to be used for matching. pass def match(self, string: str) -> bool: Return True if the string matches the set pattern, otherwise False. pass def clear_pattern(self) -> None: Clear the current pattern. pass # Unit Tests def test_no_pattern_set(): matcher = StringPatternMatcher() assert matcher.match(\\"test\\") == False def test_exact_match(): matcher = StringPatternMatcher() matcher.set_pattern(\\"abc\\") assert matcher.match(\\"abc\\") == True assert matcher.match(\\"abcd\\") == False assert matcher.match(\\"ab\\") == False def test_single_wildcard(): matcher = StringPatternMatcher() matcher.set_pattern(\\"a*c\\") assert matcher.match(\\"ac\\") == True assert matcher.match(\\"abc\\") == True assert matcher.match(\\"abbc\\") == True assert matcher.match(\\"ab\\") == False def test_multiple_wildcards(): matcher = StringPatternMatcher() matcher.set_pattern(\\"a*b*c\\") assert matcher.match(\\"abc\\") == True assert matcher.match(\\"aabbcc\\") == True assert matcher.match(\\"abxyzbc\\") == True assert matcher.match(\\"abx\\") == False def test_question_mark_wildcard(): matcher = StringPatternMatcher() matcher.set_pattern(\\"a?c\\") assert matcher.match(\\"abc\\") == True assert matcher.match(\\"axc\\") == True assert matcher.match(\\"abxc\\") == False assert matcher.match(\\"ac\\") == False def test_combination_wildcards(): matcher = StringPatternMatcher() matcher.set_pattern(\\"a*b?c\\") assert matcher.match(\\"aabbxc\\") == True assert matcher.match(\\"abbxc\\") == True assert matcher.match(\\"abxc\\") == True assert matcher.match(\\"abc\\") == False def test_clear_pattern(): matcher = StringPatternMatcher() matcher.set_pattern(\\"a*b\\") matcher.clear_pattern() assert matcher.match(\\"aab\\") == False assert matcher.match(\\"ab\\") == False","solution":"class StringPatternMatcher: def __init__(self) -> None: Initialize the StringPatternMatcher with no pattern set. self.pattern = None def set_pattern(self, pattern: str) -> None: Set the pattern to be used for matching. self.pattern = pattern def match(self, string: str) -> bool: Return True if the string matches the set pattern, otherwise False. if self.pattern is None: return False return self._match_helper(string, self.pattern) def _match_helper(self, string: str, pattern: str) -> bool: Helper function to perform pattern matching using dynamic programming. m, n = len(string), len(pattern) # dp[i][j] will be True if the first i characters in string match the first j characters in the pattern. dp = [[False] * (n + 1) for _ in range(m + 1)] # Empty pattern matches empty string dp[0][0] = True # Fill the first row for patterns with leading stars for j in range(1, n + 1): if pattern[j - 1] == '*': dp[0][j] = dp[0][j - 1] # Fill the dp table for i in range(1, m + 1): for j in range(1, n + 1): if pattern[j - 1] == '*': dp[i][j] = dp[i][j - 1] or dp[i - 1][j] elif pattern[j - 1] == string[i - 1] or pattern[j - 1] == '?': dp[i][j] = dp[i - 1][j - 1] return dp[m][n] def clear_pattern(self) -> None: Clear the current pattern. self.pattern = None"},{"question":"import time from collections import defaultdict class RateLimiter: def __init__(self, max_requests: int, window_size: int): Initialize the rate limiter with a maximum number of requests and the size of the time window in seconds. :param max_requests: Maximum number of requests allowed in the time window :param window_size: Length of the time window in seconds def request(self, user_id: str) -> bool: Track a request from a user. Return True if the request is allowed, otherwise return False if the rate limit is exceeded. :param user_id: Unique identifier for the user making the request :return: Boolean indicating whether the request is allowed # Test cases def test_rate_limiter_basic(): rate_limiter = RateLimiter(5, 60) user_id = \\"user1\\" assert rate_limiter.request(user_id) == True assert rate_limiter.request(user_id) == True assert rate_limiter.request(user_id) == True assert rate_limiter.request(user_id) == True assert rate_limiter.request(user_id) == True assert rate_limiter.request(user_id) == False def test_rate_limiter_reset(): rate_limiter = RateLimiter(5, 1) user_id = \\"user2\\" for _ in range(5): assert rate_limiter.request(user_id) == True assert rate_limiter.request(user_id) == False time.sleep(1) assert rate_limiter.request(user_id) == True def test_rate_limiter_multiple_users(): rate_limiter = RateLimiter(3, 60) user1, user2 = \\"user1\\", \\"user2\\" assert rate_limiter.request(user1) == True assert rate_limiter.request(user2) == True assert rate_limiter.request(user1) == True assert rate_limiter.request(user2) == True assert rate_limiter.request(user1) == True assert rate_limiter.request(user2) == True assert rate_limiter.request(user1) == False assert rate_limiter.request(user2) == False def test_rate_limiter_edge_case_zero_requests(): rate_limiter = RateLimiter(0, 60) user_id = \\"user0\\" assert rate_limiter.request(user_id) == False def test_rate_limiter_edge_case_one_request(): rate_limiter = RateLimiter(1, 60) user_id = \\"user1\\" assert rate_limiter.request(user_id) == True assert rate_limiter.request(user_id) == False","solution":"import time from collections import defaultdict class RateLimiter: def __init__(self, max_requests: int, window_size: int): Initialize the rate limiter with a maximum number of requests and the size of the time window in seconds. :param max_requests: Maximum number of requests allowed in the time window :param window_size: Length of the time window in seconds self.max_requests = max_requests self.window_size = window_size self.requests = defaultdict(list) def request(self, user_id: str) -> bool: Track a request from a user. Return True if the request is allowed, otherwise return False if the rate limit is exceeded. :param user_id: Unique identifier for the user making the request :return: Boolean indicating whether the request is allowed current_time = int(time.time()) if user_id not in self.requests: self.requests[user_id] = [] user_requests = self.requests[user_id] # Remove requests that are outside the window while user_requests and user_requests[0] <= current_time - self.window_size: user_requests.pop(0) if len(user_requests) < self.max_requests: user_requests.append(current_time) return True return False"},{"question":"def tribonacci_recursive(n: int) -> int: Compute the n-th Tribonacci number using the recursive method with memoization. >>> tribonacci_recursive(4) 4 >>> tribonacci_recursive(25) 1389537 >>> tribonacci_recursive(10) 149 >>> tribonacci_recursive(0) 0 >>> tribonacci_recursive(1) 1 >>> tribonacci_recursive(2) 1 >>> tribonacci_recursive(-1) ValueError: tribonacci_recursive() not defined for negative values >>> tribonacci_recursive(3.5) ValueError: tribonacci_recursive() only accepts integral values pass def tribonacci_iterative(n: int) -> int: Compute the n-th Tribonacci number using the iterative method. >>> tribonacci_iterative(4) 4 >>> tribonacci_iterative(25) 1389537 >>> tribonacci_iterative(10) 149 >>> tribonacci_iterative(0) 0 >>> tribonacci_iterative(1) 1 >>> tribonacci_iterative(2) 1 >>> tribonacci_iterative(-1) ValueError: tribonacci_iterative() not defined for negative values >>> tribonacci_iterative(3.5) ValueError: tribonacci_iterative() only accepts integral values pass","solution":"def tribonacci_recursive(n: int) -> int: def memo_tribo(n, memo): if n in memo: return memo[n] memo[n] = memo_tribo(n-1, memo) + memo_tribo(n-2, memo) + memo_tribo(n-3, memo) return memo[n] if not isinstance(n, int): raise ValueError(\\"tribonacci_recursive() only accepts integral values\\") if n < 0: raise ValueError(\\"tribonacci_recursive() not defined for negative values\\") memo = {0: 0, 1: 1, 2: 1} return memo_tribo(n, memo) def tribonacci_iterative(n: int) -> int: if not isinstance(n, int): raise ValueError(\\"tribonacci_iterative() only accepts integral values\\") if n < 0: raise ValueError(\\"tribonacci_iterative() not defined for negative values\\") if n == 0: return 0 if n == 1 or n == 2: return 1 t0, t1, t2 = 0, 1, 1 for i in range(3, n + 1): t_next = t0 + t1 + t2 t0, t1, t2 = t1, t2, t_next return t2"},{"question":"def permutation_cycles(arr: list[int]) -> list[int]: Find and return the sizes of permutation cycles in a given array where each element represents a permutation of indices (0-based). >>> sorted(permutation_cycles([1, 2, 0])) == [3] >>> sorted(permutation_cycles([1, 0, 3, 4, 5, 2])) == [2, 4] >>> sorted(permutation_cycles([1, 0, 4, 3, 2])) == [1, 2, 2] >>> sorted(permutation_cycles([0, 1, 2, 3, 4])) == [1, 1, 1, 1, 1] pass","solution":"def permutation_cycles(arr): def find_cycle_length(start, visited): current = start length = 0 while not visited[current]: visited[current] = True current = arr[current] length += 1 return length n = len(arr) visited = [False] * n cycle_sizes = [] for i in range(n): if not visited[i]: cycle_size = find_cycle_length(i, visited) cycle_sizes.append(cycle_size) return cycle_sizes"},{"question":"from typing import List def matrix_multiplication( matrix_a: List[List[float]], matrix_b: List[List[float]] ) -> List[List[float]]: Perform matrix multiplication without using any external libraries. Args: matrix_a (List[List[float]]): 2D list of floats representing the first matrix. matrix_b (List[List[float]]): 2D list of floats representing the second matrix. Returns: List[List[float]]: The resultant matrix of the matrix multiplication. Example: >>> matrix_a = [ ... [1, 2, 3], ... [4, 5, 6] ... ] >>> matrix_b = [ ... [7, 8], ... [9, 10], ... [11, 12] ... ] >>> matrix_multiplication(matrix_a, matrix_b) [[58.0, 64.0], [139.0, 154.0]] pass def test_basic_case(): matrix_a = [ [1, 2, 3], [4, 5, 6] ] matrix_b = [ [7, 8], [9, 10], [11, 12] ] expected = [ [58.0, 64.0], [139.0, 154.0] ] assert matrix_multiplication(matrix_a, matrix_b) == expected def test_identity_matrix(): matrix_a = [ [1, 0, 0], [0, 1, 0], [0, 0, 1] ] matrix_b = [ [5, 6, 7], [8, 9, 10], [11, 12, 13] ] expected = [ [5, 6, 7], [8, 9, 10], [11, 12, 13] ] assert matrix_multiplication(matrix_a, matrix_b) == expected def test_different_dimensions(): matrix_a = [ [1, 2], [3, 4], [5, 6] ] matrix_b = [ [7, 8, 9], [10, 11, 12] ] expected = [ [27.0, 30.0, 33.0], [61.0, 68.0, 75.0], [95.0, 106.0, 117.0] ] assert matrix_multiplication(matrix_a, matrix_b) == expected def test_single_element_matrices(): matrix_a = [[2]] matrix_b = [[3]] expected = [[6.0]] assert matrix_multiplication(matrix_a, matrix_b) == expected def test_single_row_and_column(): matrix_a = [[1, 2, 3]] matrix_b = [ [4], [5], [6] ] expected = [[32.0]] assert matrix_multiplication(matrix_a, matrix_b) == expected def test_large_numbers(): matrix_a = [ [1000, -1000], [-1000, 1000] ] matrix_b = [ [1000, -1000], [-1000, 1000] ] expected = [ [2000000.0, -2000000.0], [-2000000.0, 2000000.0] ] assert matrix_multiplication(matrix_a, matrix_b) == expected","solution":"from typing import List def matrix_multiplication(matrix_a: List[List[float]], matrix_b: List[List[float]]) -> List[List[float]]: # Get dimensions of input matrices m = len(matrix_a) n = len(matrix_a[0]) p = len(matrix_b[0]) # Initialize result matrix with zeros of size m x p result = [[0.0 for _ in range(p)] for _ in range(m)] # Perform matrix multiplication for i in range(m): for j in range(p): for k in range(n): result[i][j] += matrix_a[i][k] * matrix_b[k][j] return result"},{"question":"from typing import List def find_unique_files(file_paths: List[str]) -> List[str]: Identify and return file paths that have unique file names. >>> find_unique_files([ ... \\"dir1/file1.txt\\", ... \\"dir2/file2.txt\\", ... \\"dir3/file1.txt\\", ... \\"dir4/file3.txt\\" ... ]) [\\"dir2/file2.txt\\", \\"dir4/file3.txt\\"] >>> find_unique_files([ ... \\"dir1/file1.txt\\", ... \\"dir2/file1.txt\\", ... \\"dir3/file1.txt\\" ... ]) []","solution":"from typing import List from collections import defaultdict def find_unique_files(file_paths: List[str]) -> List[str]: # Dictionary to keep track of file name counts and their corresponding paths file_count = defaultdict(int) file_path_map = defaultdict(list) for path in file_paths: directory, file_name = path.rsplit('/', 1) file_count[file_name] += 1 file_path_map[file_name].append(path) # Filter out file paths that have unique file names unique_file_paths = [] for file_name, count in file_count.items(): if count == 1: unique_file_paths.extend(file_path_map[file_name]) return unique_file_paths"},{"question":"def filter_and_analyze_grades(students: list, min_grade: float, subject: str) -> dict: Filter students based on a minimum grade threshold and compute statistical measures of filtered students' grades. Parameters: - students <type: list>: List of student data dictionaries. - min_grade <type: float>: Minimum grade threshold for filtering. - subject <type: str>: Subject key for which the filtering and analysis should be performed. Returns: - <type: dict>: Dictionary of statistics of filtered grades including 'filtered_count', 'filtered_average', 'filtered_min', 'filtered_max'. Example: >>> students = [ {'student_id': 1, 'name': 'Alice', 'Math': 85, 'Science': 78}, {'student_id': 2, 'name': 'Bob', 'Math': 90, 'Science': 88}, {'student_id': 3, 'name': 'Charlie', 'Math': 75, 'Science': 95}, {'student_id': 4, 'name': 'David', 'Math': 95, 'Science': 92} ] >>> filter_and_analyze_grades(students, 80, 'Math') == { 'filtered_count': 3, 'filtered_average': (85 + 90 + 95) / 3, 'filtered_min': 85, 'filtered_max': 95 } pass # Implementation here from solution import filter_and_analyze_grades def test_filter_and_analyze_grades_with_valid_data(): students = [ {'student_id': 1, 'name': 'Alice', 'Math': 85, 'Science': 78}, {'student_id': 2, 'name': 'Bob', 'Math': 90, 'Science': 88}, {'student_id': 3, 'name': 'Charlie', 'Math': 75, 'Science': 95}, {'student_id': 4, 'name': 'David', 'Math': 95, 'Science': 92} ] result = filter_and_analyze_grades(students, 80, 'Math') assert result == { 'filtered_count': 3, 'filtered_average': (85 + 90 + 95) / 3, 'filtered_min': 85, 'filtered_max': 95 } def test_filter_and_analyze_grades_with_no_students_meeting_threshold(): students = [ {'student_id': 1, 'name': 'Alice', 'Math': 85, 'Science': 78}, {'student_id': 2, 'name': 'Bob', 'Math': 90, 'Science': 88}, {'student_id': 3, 'name': 'Charlie', 'Math': 75, 'Science': 95}, {'student_id': 4, 'name': 'David', 'Math': 95, 'Science': 92} ] result = filter_and_analyze_grades(students, 100, 'Math') assert result == { 'filtered_count': 0, 'filtered_average': 0, 'filtered_min': 0, 'filtered_max': 0 } def test_filter_and_analyze_grades_with_missing_subject_key(): students = [ {'student_id': 1, 'name': 'Alice', 'Math': 85}, {'student_id': 2, 'name': 'Bob', 'Math': 90}, {'student_id': 3, 'name': 'Charlie', 'Math': 75}, {'student_id': 4, 'name': 'David', 'Math': 95} ] result = filter_and_analyze_grades(students, 80, 'Science') assert result == { 'filtered_count': 0, 'filtered_average': 0, 'filtered_min': 0, 'filtered_max': 0 } def test_filter_and_analyze_grades_with_all_students_meeting_threshold(): students = [ {'student_id': 1, 'name': 'Alice', 'Math': 85, 'Science': 78}, {'student_id': 2, 'name': 'Bob', 'Math': 90, 'Science': 88}, {'student_id': 3, 'name': 'Charlie', 'Math': 75, 'Science': 95}, {'student_id': 4, 'name': 'David', 'Math': 95, 'Science': 92} ] result = filter_and_analyze_grades(students, 70, 'Science') assert result == { 'filtered_count': 4, 'filtered_average': (78 + 88 + 95 + 92) / 4, 'filtered_min': 78, 'filtered_max': 95 }","solution":"def filter_and_analyze_grades(students: list, min_grade: float, subject: str) -> dict: Filter students based on a minimum grade threshold and compute statistical measures of filtered students' grades. Parameters: - students <type: list>: List of student data dictionaries. - min_grade <type: float>: Minimum grade threshold for filtering. - subject <type: str>: Subject key for which the filtering and analysis should be performed. Returns: - <type: dict>: Dictionary of statistics of filtered grades including 'filtered_count', 'filtered_average', 'filtered_min', 'filtered_max'. filtered_grades = [student[subject] for student in students if student.get(subject) is not None and student[subject] >= min_grade] if not filtered_grades: return {'filtered_count': 0, 'filtered_average': 0, 'filtered_min': 0, 'filtered_max': 0} filtered_count = len(filtered_grades) filtered_average = sum(filtered_grades) / filtered_count filtered_min = min(filtered_grades) filtered_max = max(filtered_grades) return { 'filtered_count': filtered_count, 'filtered_average': filtered_average, 'filtered_min': filtered_min, 'filtered_max': filtered_max }"},{"question":"def longest_unique_substring(s: str) -> int: Computes the length of the longest substring of \`s\` that contains only unique characters. >>> longest_unique_substring(\\"abcabcbb\\") 3 >>> longest_unique_substring(\\"bbbbb\\") 1 >>> longest_unique_substring(\\"pwwkew\\") 3 >>> longest_unique_substring(\\"\\") 0 from solution import longest_unique_substring def test_longest_unique_substring_basic_cases(): assert longest_unique_substring(\\"abcabcbb\\") == 3 assert longest_unique_substring(\\"bbbbb\\") == 1 assert longest_unique_substring(\\"pwwkew\\") == 3 def test_longest_unique_substring_edge_cases(): assert longest_unique_substring(\\"\\") == 0 assert longest_unique_substring(\\" \\") == 1 assert longest_unique_substring(\\"au\\") == 2 assert longest_unique_substring(\\"a\\") == 1 def test_longest_unique_substring_large_input(): assert longest_unique_substring(\\"a\\" * 100000) == 1 assert longest_unique_substring(\\"ab\\" * 50000) == 2 def test_longest_unique_substring_mixed_characters(): assert longest_unique_substring(\\"abcabcbbabc\\") == 4 assert longest_unique_substring(\\"1234567890abcdef\\") == 16 def test_longest_unique_substring_repeating_patterns(): assert longest_unique_substring(\\"abababababababababab\\") == 2 assert longest_unique_substring(\\"xyzxyzxyzxyzxyz\\") == 3","solution":"def longest_unique_substring(s: str) -> int: Returns the length of the longest substring with unique characters in the given string s. char_index_map = {} longest = 0 left = 0 for right in range(len(s)): if s[right] in char_index_map and char_index_map[s[right]] >= left: left = char_index_map[s[right]] + 1 char_index_map[s[right]] = right longest = max(longest, right - left + 1) return longest"},{"question":"def custom_binary_search(arr: list, target: any, comp: callable) -> int: Perform a binary search on a given sorted list arr to locate target using a custom comparator function comp. >>> def custom_compare(a, b): ... return a - b >>> custom_binary_search([1, 2, 3, 4, 5], 3, custom_compare) 2 >>> custom_binary_search(['apple', 'banana', 'cherry'], 'banana', lambda a, b: (a > b) - (a < b)) 1 >>> custom_binary_search([10, 20, 30, 40], 25, lambda a, b: a - b) -1 pass def custom_compare_int(a, b): return a - b def custom_compare_str(a, b): return (a > b) - (a < b) def custom_compare_len(a, b): return len(a) - len(b) def test_custom_binary_search_integer(): arr = [1, 2, 3, 4, 5] target = 3 assert custom_binary_search(arr, target, custom_compare_int) == 2 assert custom_binary_search(arr, 1, custom_compare_int) == 0 assert custom_binary_search(arr, 5, custom_compare_int) == 4 assert custom_binary_search(arr, 6, custom_compare_int) == -1 def test_custom_binary_search_string(): arr = [\\"apple\\", \\"banana\\", \\"cherry\\"] target = \\"banana\\" assert custom_binary_search(arr, target, custom_compare_str) == 1 assert custom_binary_search(arr, \\"apple\\", custom_compare_str) == 0 assert custom_binary_search(arr, \\"cherry\\", custom_compare_str) == 2 assert custom_binary_search(arr, \\"date\\", custom_compare_str) == -1 def test_custom_binary_search_by_length(): arr = [\\"a\\", \\"aa\\", \\"aaa\\", \\"aaaa\\"] target = \\"aa\\" assert custom_binary_search(arr, target, custom_compare_len) == 1 assert custom_binary_search(arr, \\"a\\", custom_compare_len) == 0 assert custom_binary_search(arr, \\"aaa\\", custom_compare_len) == 2 assert custom_binary_search(arr, \\"aaaaa\\", custom_compare_len) == -1 def test_custom_binary_search_mixed(): arr = [10, 20, 30, 40] target = 25 assert custom_binary_search(arr, target, custom_compare_int) == -1 target = 30 assert custom_binary_search(arr, target, custom_compare_int) == 2 def test_custom_binary_search_empty(): arr = [] target = 10 assert custom_binary_search(arr, target, custom_compare_int) == -1","solution":"def custom_binary_search(arr, target, comp): Perform a binary search on a sorted list using a custom comparator function. :param arr: List of elements sorted based on custom comparator. :param target: Element to search for in the list. :param comp: Comparator function to determine the order of elements. :return: Index of target in arr if present, otherwise -1. left, right = 0, len(arr) - 1 while left <= right: mid = (left + right) // 2 comparison = comp(arr[mid], target) if comparison == 0: return mid elif comparison < 0: left = mid + 1 else: right = mid - 1 return -1"},{"question":"def common_chars(words: list[str]) -> list[str]: Returns a list of characters that appear in all strings within the list, including duplicates. >>> common_chars([\\"bella\\", \\"label\\", \\"roller\\"]) [\\"e\\", \\"l\\", \\"l\\"] >>> common_chars([\\"cool\\", \\"lock\\", \\"cook\\"]) [\\"c\\", \\"o\\"] >>> common_chars([\\"apple\\", \\"banana\\", \\"cherry\\"]) []","solution":"def common_chars(words: list[str]) -> list[str]: Returns a list of characters that appear in all strings within the list, including duplicates. if not words: return [] # Start with the character count of the first word common_count = {char: words[0].count(char) for char in set(words[0])} # Iterate through the rest of the words for word in words[1:]: current_count = {char: word.count(char) for char in set(word)} # Update the common count dictionary for char in list(common_count.keys()): if char in current_count: common_count[char] = min(common_count[char], current_count[char]) else: del common_count[char] # Convert the common count dictionary to the result list result = [] for char, count in common_count.items(): result.extend([char] * count) return result"},{"question":"class Inventory: def __init__(self): Initializer for the inventory management system. def add_product(self, product_id: str, name: str, quantity: int) -> None: Adds a new product to the inventory. Args: product_id (str): Unique identifier for the product. name (str): Name of the product. quantity (int): Initial stock quantity. def update_quantity(self, product_id: str, quantity: int) -> None: Updates the quantity of a specific product. Args: product_id (str): Unique identifier for the product. quantity (int): New stock quantity. def query_quantity(self, product_id: str) -> int: Queries the current stock level of a specific product. Args: product_id (str): Unique identifier for the product. Returns: int: The current stock level, or 0 if the product does not exist. # Example usage: inventory = Inventory() inventory.add_product(\\"001\\", \\"Laptop\\", 10) inventory.add_product(\\"002\\", \\"Keyboard\\", 20) inventory.update_quantity(\\"002\\", 15) assert inventory.query_quantity(\\"001\\") == 10 assert inventory.query_quantity(\\"002\\") == 15","solution":"class Inventory: def __init__(self): self.items = {} def add_product(self, product_id: str, name: str, quantity: int) -> None: Adds a new product to the inventory. If the product already exists, it will not be added again. if product_id not in self.items: self.items[product_id] = {'name': name, 'quantity': quantity} def update_quantity(self, product_id: str, quantity: int) -> None: Updates the quantity of a specific product. If the product does not exist, no changes are made. if product_id in self.items: self.items[product_id]['quantity'] = quantity def query_quantity(self, product_id: str) -> int: Queries the current stock level of a specific product. Returns the quantity if the product exists, otherwise returns 0. if product_id in self.items: return self.items[product_id]['quantity'] return 0"},{"question":"def fullJustify(words, maxWidth): Fully justify a list of words to fit within each line of maxWidth. >>> fullJustify([\\"This\\", \\"is\\", \\"an\\", \\"example\\", \\"of\\", \\"text\\", \\"justification.\\"], 16) [\\"This is an\\", \\"example of text\\", \\"justification. \\"] >>> fullJustify([\\"What\\",\\"must\\",\\"be\\",\\"acknowledgment\\",\\"shall\\",\\"be\\"], 16) [\\"What must be\\", \\"acknowledgment \\", \\"shall be \\"] >>> fullJustify([\\"Science\\",\\"is\\",\\"what\\",\\"we\\",\\"understand\\",\\"well\\",\\"enough\\",\\"to\\",\\"explain\\", \\"to\\",\\"a\\",\\"computer.\\",\\"Art\\",\\"is\\",\\"everything\\",\\"else\\",\\"we\\",\\"do\\"], 20) [\\"Science is what we\\", \\"understand well\\", \\"enough to explain to\\", \\"a computer. Art is\\", \\"everything else we\\", \\"do \\"] >>> fullJustify([\\"One\\"], 3) [\\"One\\"] >>> fullJustify([\\"One\\", \\"word\\", \\"per\\", \\"line\\"], 6) [\\"One \\", \\"word \\", \\"per \\", \\"line \\"] >>> fullJustify([\\"\\"], 5) [\\" \\"]","solution":"def fullJustify(words, maxWidth): def justify_line(words, max_width, is_last_line=False): if not words: return '' if is_last_line or len(words) == 1: # Left-justified for the last line or single word line. return ' '.join(words).ljust(max_width) num_spaces = len(words) - 1 total_spaces = max_width - sum(len(word) for word in words) space_between, extra_spaces = divmod(total_spaces, num_spaces) for i in range(extra_spaces): words[i] += ' ' return (' ' * space_between).join(words) current_line_words = [] current_line_length = 0 result = [] for word in words: if current_line_length + len(current_line_words) + len(word) > maxWidth: result.append(justify_line(current_line_words, maxWidth)) current_line_words = [] current_line_length = 0 current_line_words.append(word) current_line_length += len(word) result.append(justify_line(current_line_words, maxWidth, is_last_line=True)) return result"},{"question":"from sklearn.model_selection import train_test_split from sklearn.linear_model import LogisticRegression from sklearn.preprocessing import StandardScaler from sklearn.metrics import accuracy_score def logistic_regression_classifier(data: dict) -> float: Train a logistic regression classifier and return the accuracy on test set. Parameters: - data (dict): Contains \\"data\\" (list of lists of features) and \\"target\\" (list of binary labels) Returns: - float: Accuracy score of the logistic regression model on the test set Example: >>> data = { ... \\"data\\": [ ... [5.1, 3.5, 1.4, 0.2], ... [4.9, 3.0, 1.4, 0.2], ... # Add more feature sets ... ], ... \\"target\\": [0, 0, # Add more binary labels ... ] ... } >>> logistic_regression_classifier(data) 0.95 # Example output representing accuracy score of the model # Extract features and target from the data dictionary X = data[\\"data\\"] y = data[\\"target\\"] # <Additional implementation goes here> return accuracy","solution":"from sklearn.model_selection import train_test_split from sklearn.linear_model import LogisticRegression from sklearn.preprocessing import StandardScaler from sklearn.metrics import accuracy_score def logistic_regression_classifier(data: dict) -> float: Train a logistic regression classifier and return the accuracy on test set. Parameters: - data (dict): Contains \\"data\\" (list of lists of features) and \\"target\\" (list of binary labels) Returns: - float: Accuracy score of the logistic regression model on the test set # Extract features and target from the data dictionary X = data[\\"data\\"] y = data[\\"target\\"] # Split the data into training and testing sets using an 80-20 split X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42) # Standardize the features scaler = StandardScaler() X_train = scaler.fit_transform(X_train) X_test = scaler.transform(X_test) # Train the logistic regression model model = LogisticRegression(solver='lbfgs', max_iter=1000) model.fit(X_train, y_train) # Predict the labels for the test set y_pred = model.predict(X_test) # Calculate the accuracy score accuracy = accuracy_score(y_test, y_pred) return accuracy"},{"question":"from collections import deque from typing import List def shortest_path(grid: List[List[int]]) -> int: Find the shortest path from the top-left corner to the bottom-right corner in a grid representing a maze. >>> grid1 = [ ... [0, 0, 1], ... [0, 1, 0], ... [0, 0, 0] ... ] >>> shortest_path(grid1) 4 >>> grid2 = [ ... [1, 0, 0], ... [0, 0, 0], ... [0, 0, 0] ... ] >>> shortest_path(grid2) -1 >>> grid3 = [ ... [0, 0, 0], ... [0, 0, 0], ... [0, 0, 1] ... ] >>> shortest_path(grid3) -1 >>> grid4 = [ ... [0, 0, 0], ... [0, 0, 0], ... [0, 0, 0] ... ] >>> shortest_path(grid4) 4 >>> grid5 = [ ... [0, 0, 1, 0, 0], ... [1, 0, 1, 0, 1], ... [0, 0, 0, 0, 1], ... [0, 1, 1, 0, 0], ... [0, 0, 0, 1, 0] ... ] >>> shortest_path(grid5) 8 >>> grid6 = [ ... [0, 1, 1, 1], ... [1, 1, 1, 0], ... [0, 0, 0, 1], ... [1, 1, 1, 0] ... ] >>> shortest_path(grid6) -1","solution":"from collections import deque from typing import List def shortest_path(grid: List[List[int]]) -> int: if not grid or not grid[0]: return -1 rows, cols = len(grid), len(grid[0]) if grid[0][0] == 1 or grid[rows-1][cols-1] == 1: return -1 directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([(0, 0, 0)]) # (row, col, distance) visited = set() visited.add((0, 0)) while queue: r, c, dist = queue.popleft() if r == rows-1 and c == cols-1: return dist for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < rows and 0 <= nc < cols and grid[nr][nc] == 0 and (nr, nc) not in visited: visited.add((nr, nc)) queue.append((nr, nc, dist + 1)) return -1"},{"question":"import math def great_circle_distance(lat1: float, lon1: float, lat2: float, lon2: float) -> float: Calculates the great-circle distance between two points specified by latitude and longitude on the Earth's surface. Parameters: - lat1: Latitude of the first point in degrees. - lon1: Longitude of the first point in degrees. - lat2: Latitude of the second point in degrees. - lon2: Longitude of the second point in degrees. Returns: - Great-circle distance in kilometers. Raises: - ValueError: If any of the latitude or longitude values are out of range. def test_great_circle_distance_typical_case(): assert pytest.approx(great_circle_distance(34.0522, -118.2437, 40.7128, -74.0060), 0.1) == 3940.295 def test_great_circle_distance_on_equator(): assert pytest.approx(great_circle_distance(0, 0, 0, 90), 0.1) == 10007.543 def test_great_circle_distance_same_point(): assert great_circle_distance(0, 0, 0, 0) == 0.0 def test_great_circle_distance_hemispheres(): assert pytest.approx(great_circle_distance(-33.8688, 151.2093, 51.5074, -0.1278), 0.1) == 16993.93 def test_great_circle_distance_out_of_range_latitude(): with pytest.raises(ValueError, match=\\"Latitude 1 is out of range. Must be between -90 and 90.\\"): great_circle_distance(91, 0, 0, 0) def test_great_circle_distance_out_of_range_longitude(): with pytest.raises(ValueError, match=\\"Longitude 1 is out of range. Must be between -180 and 180.\\"): great_circle_distance(0, 181, 0, 0) def test_great_circle_distance_negative_latitude(): assert pytest.approx(great_circle_distance(-90, 0, 0, 0), 0.1) == 10007.543 def test_great_circle_distance_negative_longitude(): assert pytest.approx(great_circle_distance(0, -180, 0, 0), 0.1) == 20015.086","solution":"import math def great_circle_distance(lat1: float, lon1: float, lat2: float, lon2: float) -> float: Calculates the great-circle distance between two points specified by latitude and longitude on the Earth's surface. Parameters: - lat1: Latitude of the first point in degrees. - lon1: Longitude of the first point in degrees. - lat2: Latitude of the second point in degrees. - lon2: Longitude of the second point in degrees. Returns: - Great-circle distance in kilometers. Raises: - ValueError: If any of the latitude or longitude values are out of range. if not (-90 <= lat1 <= 90): raise ValueError(\\"Latitude 1 is out of range. Must be between -90 and 90.\\") if not (-180 <= lon1 <= 180): raise ValueError(\\"Longitude 1 is out of range. Must be between -180 and 180.\\") if not (-90 <= lat2 <= 90): raise ValueError(\\"Latitude 2 is out of range. Must be between -90 and 90.\\") if not (-180 <= lon2 <= 180): raise ValueError(\\"Longitude 2 is out of range. Must be between -180 and 180.\\") # Convert degrees to radians lat1, lon1, lat2, lon2 = map(math.radians, [lat1, lon1, lat2, lon2]) # Haversine formula dlat = lat2 - lat1 dlon = lon2 - lon1 a = math.sin(dlat / 2)**2 + math.cos(lat1) * math.cos(lat2) * math.sin(dlon / 2)**2 c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a)) # Radius of Earth in kilometers R = 6371.0 distance = R * c return distance"},{"question":"def is_valid_parentheses(s: str) -> bool: Determine if the input string of parentheses is well-formed. >>> is_valid_parentheses(\\"()\\") True >>> is_valid_parentheses(\\")(\\") False >>> is_valid_parentheses(\\"()()\\") True >>> is_valid_parentheses(\\"(()\\") False >>> is_valid_parentheses(\\"\\") True >>> is_valid_parentheses(\\"((())())\\") True >>> is_valid_parentheses(\\"(()))(()\\") False pass def generate_parentheses(n: int) -> list: Generate all combination of well-formed parentheses pairs. >>> generate_parentheses(0) [\\"\\"] >>> generate_parentheses(1) [\\"()\\"] >>> generate_parentheses(2) [\\"(())\\", \\"()()\\"] >>> generate_parentheses(3) [\\"((()))\\", \\"(()())\\", \\"(())()\\", \\"()(())\\", \\"()()()\\"] pass # Test cases for is_valid_parentheses def test_is_valid_parentheses(): assert is_valid_parentheses(\\"()\\") == True assert is_valid_parentheses(\\")(\\") == False assert is_valid_parentheses(\\"()()\\") == True assert is_valid_parentheses(\\"(()\\") == False assert is_valid_parentheses(\\"\\") == True assert is_valid_parentheses(\\"((())())\\") == True assert is_valid_parentheses(\\"(()))(()\\") == False # Test cases for generate_parentheses def test_generate_parentheses(): assert generate_parentheses(0) == [\\"\\"] assert generate_parentheses(1) == [\\"()\\"] assert generate_parentheses(2) == [\\"(())\\", \\"()()\\"] Combinations_3 = generate_parentheses(3) Expected_3 = [\\"((()))\\", \\"(()())\\", \\"(())()\\", \\"()(())\\", \\"()()()\\"] for combo in Expected_3: assert combo in Combinations_3 def test_generate_parentheses_edge_cases(): assert len(generate_parentheses(0)) == 1 assert len(generate_parentheses(1)) == 1 assert len(generate_parentheses(10)) == 16796 # Known count of combinations for 10 if __name__ == \\"__main__\\": test_is_valid_parentheses() test_generate_parentheses() test_generate_parentheses_edge_cases() print(\\"All tests passed.\\")","solution":"def is_valid_parentheses(s: str) -> bool: Determine if the input string of parentheses is well-formed. Parameters: s (str): The string containing only '(' and ')'. Returns: bool: True if the string is a valid well-formed parentheses expression, False otherwise. stack = [] for char in s: if char == '(': stack.append(char) elif char == ')': if not stack: return False stack.pop() return len(stack) == 0 def generate_parentheses(n: int): Generate all combinations of well-formed parentheses pairs. Parameters: n (int): The number of pairs of parentheses. Returns: List[str]: A list of strings representing all valid combinations of well-formed parentheses pairs. result = [] def backtrack(current, open_count, close_count): if len(current) == 2 * n: result.append(current) return if open_count < n: backtrack(current + \\"(\\", open_count + 1, close_count) if close_count < open_count: backtrack(current + \\")\\", open_count, close_count + 1) backtrack(\\"\\", 0, 0) return result"},{"question":"from typing import List def sum_of_maximal_connected_subarray(arr: List[int]) -> int: Determines the sum of the maximal connected subarray within a given list of integers. A connected subarray is a subarray whose elements' absolute differences between adjacent elements are at most one. >>> sum_of_maximal_connected_subarray([1, 2, 3, 10, 11, 12, 3, 4, 5]) 33 >>> sum_of_maximal_connected_subarray([-1, -2, -3, 7, 8, -4, -5, -6, 7, 6]) 15","solution":"from typing import List def sum_of_maximal_connected_subarray(arr: List[int]) -> int: Function to find the sum of the maximal connected subarray. A connected subarray has elements whose absolute differences between adjacent elements are at most one. if not arr: return 0 max_sum = current_sum = arr[0] for i in range(1, len(arr)): if abs(arr[i] - arr[i - 1]) <= 1: current_sum += arr[i] else: current_sum = arr[i] if current_sum > max_sum: max_sum = current_sum return max_sum"},{"question":"class LRUCache: Simple LRU Cache implementation. The cache supports O(1) time for insertion, deletion, and access. Parameters: capacity (int): positive integer representing the capacity of the cache Methods: get(key: int) -> int: Returns the value associated with the key if it exists in the cache, otherwise returns -1. put(key: int, value: int) -> None: Adds a new key-value pair to the cache. If the cache is already at capacity, it evicts the least recently used item before adding the new key-value pair. Examples: >>> cache = LRUCache(2) >>> cache.put(1, 1) >>> cache.put(2, 2) >>> cache.get(1) 1 >>> cache.put(3, 3) # Evicts key 2 >>> cache.get(2) -1 >>> cache.put(4, 4) # Evicts key 1 >>> cache.get(1) -1 >>> cache.get(3) 3 >>> cache.get(4) 4 def __init__(self, capacity: int): # Your code to initialize the LRUCache def get(self, key: int) -> int: # Your code to retrieve value by key def put(self, key: int, value: int) -> None: # Your code to insert key-value pair into cache","solution":"class LRUCache: class Node: def __init__(self, key, value): self.key = key self.value = value self.prev = None self.next = None def __init__(self, capacity: int): self.capacity = capacity self.cache = {} self.head = self.Node(0, 0) self.tail = self.Node(0, 0) self.head.next = self.tail self.tail.prev = self.head def _remove(self, node): prev = node.prev nxt = node.next prev.next = nxt nxt.prev = prev def _insert(self, node): prev = self.tail.prev prev.next = node self.tail.prev = node node.prev = prev node.next = self.tail def get(self, key: int) -> int: if key in self.cache: node = self.cache[key] self._remove(node) self._insert(node) return node.value return -1 def put(self, key: int, value: int) -> None: if key in self.cache: self._remove(self.cache[key]) node = self.Node(key, value) self._insert(node) self.cache[key] = node if len(self.cache) > self.capacity: lru = self.head.next self._remove(lru) del self.cache[lru.key]"},{"question":"from typing import List, Tuple class IntervalTree: def __init__(self): # Initialization of interval tree pass def insert(self, interval: Tuple[int, int]): Insert an interval into the interval tree. Args: interval (Tuple[int, int]): The interval to be inserted. pass def remove(self, interval: Tuple[int, int]): Remove an interval from the interval tree. Args: interval (Tuple[int, int]): The interval to be removed. pass def query(self, query_interval: Tuple[int, int]) -> List[Tuple[int, int]]: Query overlapping intervals with a given interval. Args: query_interval (Tuple[int, int]): The interval to query overlap with. Returns: List[Tuple[int, int]]: A list of overlapping intervals. Examples: >>> tree = IntervalTree() >>> intervals = [(1, 5), (10, 15), (20, 25), (30, 35)] >>> for interval in intervals: ... tree.insert(interval) >>> tree.query((0, 6)) [(1, 5)] >>> tree.query((10, 14)) [(10, 15)] >>> tree.query((20, 30)) [(20, 25), (30, 35)] pass","solution":"import bisect class IntervalTree: def __init__(self): # Store start and end points separately for efficient querying self.start_points = [] self.end_points = [] self.intervals = [] def insert(self, interval): # Use binary search for efficient insertion bisect.insort_left(self.start_points, interval[0]) bisect.insort_left(self.end_points, interval[1]) self.intervals.append(interval) def remove(self, interval): # Remove by interval identity if interval in self.intervals: self.intervals.remove(interval) # Remove from sorted lists self.start_points.remove(interval[0]) self.end_points.remove(interval[1]) def query(self, query_interval): start, end = query_interval result = [] for interval in self.intervals: if not (interval[1] < start or interval[0] > end): result.append(interval) return result"},{"question":"def dijkstra_algorithm(graph, start): Implements Dijkstra's algorithm to find the shortest path from the start node to all other nodes. Args: graph (dict): a dictionary representing the weighted graph. start (str): the starting node. Returns: dict: a dictionary with the shortest distance from the start node to every other node. # Placeholder for the complete algorithm implementation def find_shortest_paths(graph, start): Finds the shortest paths from the start city to all other cities using Dijkstra's algorithm. Args: graph (dict): a dictionary representing the weighted graph. start (str): the starting city. Returns: dict: a dictionary with the shortest distance from the start city to every other city. Examples: >>> graph = {'A': {'B': 1, 'C': 4}, 'B': {'C': 2, 'D': 5}, 'C': {'D': 1}, 'D': {}} >>> start = 'A' >>> find_shortest_paths(graph, start) {'A': 0, 'B': 1, 'C': 3, 'D': 4} >>> graph = {'A': {}, 'B': {'C': 2}, 'C': {}, 'D': {'E': 3}} >>> start = 'A' >>> find_shortest_paths(graph, start) {'A': 0, 'B': float('inf'), 'C': float('inf'), 'D': float('inf'), 'E': float('inf')} >>> graph = {'A': {'B': 1, 'C': 4}, 'B': {'C': 2, 'D': 5}, 'C': {'D': 1}, 'D': {}} >>> start = 'B' >>> find_shortest_paths(graph, start) {'A': float('inf'), 'B': 0, 'C': 2, 'D': 3}","solution":"import heapq def dijkstra_algorithm(graph, start): Implements Dijkstra's algorithm to find the shortest path from the start node to all other nodes. Args: graph (dict): a dictionary representing the weighted graph. start (str): the starting node. Returns: dict: a dictionary with the shortest distance from the start node to every other node. # Priority queue to store (distance, node) priority_queue = [(0, start)] # Dictionary to store the shortest distance from start to each node distances = {node: float('inf') for node in graph} distances[start] = 0 while priority_queue: current_distance, current_node = heapq.heappop(priority_queue) if current_distance > distances[current_node]: continue for neighbor, weight in graph[current_node].items(): distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return distances def find_shortest_paths(graph, start): Finds the shortest paths from the start city to all other cities using Dijkstra's algorithm. Args: graph (dict): a dictionary representing the weighted graph. start (str): the starting city. Returns: dict: a dictionary with the shortest distance from the start city to every other city. return dijkstra_algorithm(graph, start)"},{"question":"from typing import List def process_operations(values: List[int], operations: List[str]) -> List[int]: Process a list of operations on the given list of integers. Arguments: values -- list of integers operations -- list of operations to perform on values Returns: list of integers after performing all operations >>> process_operations([1, 2, 3], [\\"add 2\\", \\"mul 3\\"]) [9, 12, 15] >>> process_operations([4, 5, 6], [\\"delete 1\\", \\"insert 10 1\\"]) [4, 10, 6] def test_process_operations(): assert process_operations([1, 2, 3], [\\"add 2\\", \\"mul 3\\"]) == [9, 12, 15], \\"Test case 1 failed\\" assert process_operations([4, 5, 6], [\\"delete 1\\", \\"insert 10 1\\"]) == [4, 10, 6], \\"Test case 2 failed\\" assert process_operations([], [\\"add 2\\", \\"insert 5 0\\"]) == [5], \\"Test case 3 failed\\" assert process_operations([10, 20, 30], [\\"delete -1\\"]) == [10, 20, 30], \\"Test case 4 failed\\" assert process_operations([10, 20, 30], [\\"insert 5 100\\"]) == [10, 20, 30, 5], \\"Test case 5 failed\\" assert process_operations([1, 2, 3], [\\"add 1\\", \\"add 2\\", \\"add 3\\"]) == [7, 8, 9], \\"Test case 6 failed\\" assert process_operations([1], [\\"delete 0\\", \\"insert 5 0\\"]) == [5], \\"Test case 7 failed\\" assert process_operations([1], [\\"delete 1\\", \\"insert 5 1\\"]) == [1, 5], \\"Test case 8 failed\\" assert process_operations([], [\\"insert 1 0\\", \\"mul 2\\"]) == [2], \\"Test case 9 failed\\" test_process_operations()","solution":"def process_operations(values, operations): Process a list of operations on the given list of integers. for operation in operations: op = operation.split() command = op[0] if command == \\"add\\": x = int(op[1]) values = [v + x for v in values] elif command == \\"mul\\": x = int(op[1]) values = [v * x for v in values] elif command == \\"delete\\": d = int(op[1]) if 0 <= d < len(values): values.pop(d) elif command == \\"insert\\": x = int(op[1]) d = int(op[2]) if 0 <= d <= len(values): values.insert(d, x) else: values.append(x) return values"},{"question":"import numpy as np def matrix_multiply(matrix_a: np.ndarray, matrix_b: np.ndarray) -> np.ndarray: Compute the product of two matrices. Args: matrix_a (np.ndarray): The first input matrix. matrix_b (np.ndarray): The second input matrix. Returns: np.ndarray: The product matrix resulting from multiplying matrix_a with matrix_b. >>> matrix_a = np.array([[1, 2], [3, 4]]) >>> matrix_b = np.array([[2, 0], [1, 2]]) >>> matrix_multiply(matrix_a, matrix_b) array([[ 4, 4], [10, 8]]) >>> matrix_a = np.array([[1, 2, 3], [4, 5, 6]]) >>> matrix_b = np.array([[7, 8], [9, 10], [11, 12]]) >>> matrix_multiply(matrix_a, matrix_b) array([[ 58, 64], [139, 154]])","solution":"import numpy as np def matrix_multiply(matrix_a: np.ndarray, matrix_b: np.ndarray) -> np.ndarray: Compute the product of two matrices. Args: matrix_a (np.ndarray): The first input matrix. matrix_b (np.ndarray): The second input matrix. Returns: np.ndarray: The product matrix resulting from multiplying matrix_a with matrix_b. # Check if the number of columns in matrix_a matches the number of rows in matrix_b if matrix_a.shape[1] != matrix_b.shape[0]: raise ValueError(\\"Incompatible dimensions for matrix multiplication\\") # Use numpy's dot product function to multiply the matrices return np.dot(matrix_a, matrix_b)"},{"question":"import requests OMDB_API_KEY = \\"your_omdb_api_key\\" TMDB_API_KEY = \\"your_tmdb_api_key\\" def get_movie_details(title: str) -> dict: Fetches and aggregates movie data from OMDB and TMDb for a given movie title. :param title: A string representing the movie title. :return: A dictionary containing the aggregated movie information. :raises ValueError: If no API keys are provided or no valid data is returned. >>> get_movie_details(\\"Inception\\") { \\"OMDB\\": {\\"Title\\": \\"Inception\\", \\"Year\\": \\"2010\\", \\"Rated\\": \\"PG-13\\"}, \\"TMDb\\": {\\"title\\": \\"Inception\\", \\"release_date\\": \\"2010-07-16\\"} } >>> get_movie_details(\\"UnknownTitle\\") ValueError: Unable to fetch data from both OMDB and TMDb pass def test_get_movie_details_success(monkeypatch): # Mock API responses def mock_get_omdb_data(title): return {\\"Title\\": title, \\"Year\\": \\"2010\\", \\"Rated\\": \\"PG-13\\"} def mock_get_tmdb_data(title): return {\\"title\\": title, \\"release_date\\": \\"2010-07-16\\"} monkeypatch.setattr('solution.get_omdb_data', mock_get_omdb_data) monkeypatch.setattr('solution.get_tmdb_data', mock_get_tmdb_data) result = get_movie_details(\\"Inception\\") assert result == { \\"OMDB\\": {\\"Title\\": \\"Inception\\", \\"Year\\": \\"2010\\", \\"Rated\\": \\"PG-13\\"}, \\"TMDb\\": {\\"title\\": \\"Inception\\", \\"release_date\\": \\"2010-07-16\\"} } def test_get_movie_details_no_omdb_data(monkeypatch): # Mock API responses where OMDB returns no data def mock_get_omdb_data(title): return None def mock_get_tmdb_data(title): return {\\"title\\": title, \\"release_date\\": \\"2010-07-16\\"} monkeypatch.setattr('solution.get_omdb_data', mock_get_omdb_data) monkeypatch.setattr('solution.get_tmdb_data', mock_get_tmdb_data) result = get_movie_details(\\"Inception\\") assert result == { \\"OMDB\\": None, \\"TMDb\\": {\\"title\\": \\"Inception\\", \\"release_date\\": \\"2010-07-16\\"} } def test_get_movie_details_no_tmdb_data(monkeypatch): # Mock API responses where TMDb returns no data def mock_get_omdb_data(title): return {\\"Title\\": title, \\"Year\\": \\"2010\\", \\"Rated\\": \\"PG-13\\"} def mock_get_tmdb_data(title): return None monkeypatch.setattr('solution.get_omdb_data', mock_get_omdb_data) monkeypatch.setattr('solution.get_tmdb_data', mock_get_tmdb_data) result = get_movie_details(\\"Inception\\") assert result == { \\"OMDB\\": {\\"Title\\": \\"Inception\\", \\"Year\\": \\"2010\\", \\"Rated\\": \\"PG-13\\"}, \\"TMDb\\": None } def test_get_movie_details_no_data(monkeypatch): # Mock API responses where both APIs return no data def mock_get_omdb_data(title): return None def mock_get_tmdb_data(title): return None monkeypatch.setattr('solution.get_omdb_data', mock_get_omdb_data) monkeypatch.setattr('solution.get_tmdb_data', mock_get_tmdb_data) try: get_movie_details(\\"UnknownTitle\\") assert False # Should not reach here except ValueError as e: assert str(e) == \\"Unable to fetch data from both OMDB and TMDb\\"","solution":"import requests OMDB_API_KEY = \\"your_omdb_api_key\\" TMDB_API_KEY = \\"your_tmdb_api_key\\" def get_omdb_data(title): url = f\\"http://www.omdbapi.com/?t={title}&apikey={OMDB_API_KEY}\\" try: response = requests.get(url, timeout=10) response.raise_for_status() # will throw an error for HTTP error codes return response.json() except requests.RequestException as e: print(f\\"Error fetching OMDB data: {e}\\") return None def get_tmdb_data(title): url = f\\"https://api.themoviedb.org/3/search/movie\\" params = {\\"api_key\\": TMDB_API_KEY, \\"query\\": title} try: response = requests.get(url, params=params, timeout=10) response.raise_for_status() # will throw an error for HTTP error codes return response.json().get('results', [])[0] if response.json().get('results') else None except requests.RequestException as e: print(f\\"Error fetching TMDb data: {e}\\") return None def get_movie_details(title: str) -> dict: omdb_data = get_omdb_data(title) tmdb_data = get_tmdb_data(title) if not omdb_data and not tmdb_data: raise ValueError(\\"Unable to fetch data from both OMDB and TMDb\\") return {\\"OMDB\\": omdb_data, \\"TMDb\\": tmdb_data}"},{"question":"def merge_files(file_paths: list[str], output_file: str) -> None: Merge multiple text files containing lists of names into a single unified file without any duplicates. Args: file_paths (list[str]): A list of strings where each string represents the path to a text file. output_file (str): A string representing the path to the output text file. Output: None. The function writes the merged and deduplicated list of names to the specified output file. - The merging process is case-insensitive, but the output should retain the original case format of the first occurrence of any given name. - The final unified file should contain names sorted in case-insensitive alphabetical order. - Ensure the solution works efficiently for multiple input files with combined sizes up to 1,000,000 lines. Example: Given three files with the following content: file1.txt: Alice bob CHARLIE dave file2.txt: alice Bob Eve Frank file3.txt: ALICE eve frank Grace The call merge_files(['file1.txt', 'file2.txt', 'file3.txt'], 'output.txt') should create output.txt with the following content: Alice bob CHARLIE dave Eve Frank Grace >>> import os >>> create_test_file('file1.txt', 'AlicenbobnCHARLIEndaven') >>> create_test_file('file2.txt', 'alicenBobnEvenFrankn') >>> create_test_file('file3.txt', 'ALICEnevenfranknGracen') >>> merge_files(['file1.txt', 'file2.txt', 'file3.txt'], 'output.txt') >>> with open('output.txt') as f: ... print(f.read()) Alice bob CHARLIE dave Eve Frank Grace >>> # Cleanup >>> os.remove('file1.txt') >>> os.remove('file2.txt') >>> os.remove('file3.txt') >>> os.remove('output.txt') pass","solution":"def merge_files(file_paths, output_file): merged_names = {} for file_path in file_paths: with open(file_path, 'r') as file: for line in file: name = line.strip() name_lower = name.lower() if name_lower not in merged_names: merged_names[name_lower] = name sorted_names = sorted(merged_names.values(), key=lambda x: x.lower()) with open(output_file, 'w') as file: for name in sorted_names: file.write(f\\"{name}n\\")"},{"question":"from typing import List def rotate_90_degrees(matrix: List[List[int]]) -> List[List[int]]: Rotates a square matrix 90 degrees clockwise. >>> rotate_90_degrees([[1, 2], [3, 4]]) [[3, 1], [4, 2]] pass def is_rotated_version(matrix1: List[List[int]], matrix2: List[List[int]]) -> bool: Checks if one matrix can be obtained by rotating another matrix. >>> is_rotated_version([[1, 2], [3, 4]], [[3, 1], [4, 2]]) True >>> is_rotated_version([[1, 2], [3, 4]], [[4, 3], [2, 1]]) True >>> is_rotated_version([[1, 2], [3, 4]], [[2, 1], [3, 4]]) False >>> is_rotated_version([[1, 2], [3, 4]], [[1, 2], [3, 4]]) True pass","solution":"from typing import List def rotate_90_degrees(matrix: List[List[int]]) -> List[List[int]]: Rotates a square matrix 90 degrees clockwise. n = len(matrix) rotated = [[0] * n for _ in range(n)] for i in range(n): for j in range(n): rotated[j][n-1-i] = matrix[i][j] return rotated def is_rotated_version(matrix1: List[List[int]], matrix2: List[List[int]]) -> bool: Checks if one matrix can be obtained by rotating another matrix if matrix1 == matrix2: return True rotated_90 = rotate_90_degrees(matrix1) if rotated_90 == matrix2: return True rotated_180 = rotate_90_degrees(rotated_90) if rotated_180 == matrix2: return True rotated_270 = rotate_90_degrees(rotated_180) if rotated_270 == matrix2: return True return False"},{"question":"def min_steps_to_equal_elements(n: int, arr: List[int]) -> int: Determines the minimum number of decrement operations needed to make all elements in an array equal. >>> min_steps_to_equal_elements(5, [2, 3, 4, 5, 6]) # Output: 10 >>> min_steps_to_equal_elements(3, [1, 2, 3]) # Output: 3 >>> min_steps_to_equal_elements(4, [4, 4, 4, 4]) # Output: 0 >>> min_steps_to_equal_elements(2, [100, 200]) # Output: 100 >>> min_steps_to_equal_elements(6, [5, 5, 5, 5, 5, 6]) # Output: 1 >>> min_steps_to_equal_elements(1, [10]) # Output: 0 >>> min_steps_to_equal_elements(3, [1000, 999, 998]) # Output: 3","solution":"def min_steps_to_equal_elements(n, arr): Determines the minimum number of decrement operations needed to make all elements in an array equal. :param n: int - Number of elements in the array :param arr: List[int] - List of integers representing the array elements :return: int - Minimum number of decrement operations min_value = min(arr) steps = sum(x - min_value for x in arr) return steps"},{"question":"from typing import List def find_single_number(nums: List[int]) -> int: Returns the element that appears exactly once in an array where all other elements appear twice. Args: nums (List[int]): List of integers where exactly one element appears once and all others appear twice. Returns: int: The single number that appears exactly once. Examples: >>> find_single_number([2, 2, 1]) 1 >>> find_single_number([4, 1, 2, 1, 2]) 4 >>> find_single_number([1]) 1 pass # Unit tests def test_find_single_number_example1(): assert find_single_number([2, 2, 1]) == 1 def test_find_single_number_example2(): assert find_single_number([4, 1, 2, 1, 2]) == 4 def test_find_single_number_example3(): assert find_single_number([1]) == 1 def test_find_single_number_large(): assert find_single_number([9999] + [i for i in range(-3 * 10**4, 3 * 10**4) if i != 9999] * 2) == 9999 def test_find_single_number_negative_nums(): assert find_single_number([-1, -2, -2]) == -1 def test_find_single_number_mixed_nums(): assert find_single_number([10, 20, 10]) == 20","solution":"from typing import List def find_single_number(nums: List[int]) -> int: Returns the element that appears exactly once in an array where all other elements appear twice. result = 0 for num in nums: result ^= num return result"},{"question":"import matplotlib.pyplot as plt import pandas as pd from datetime import datetime def generate_customer_purchases_visualization(transactions: list) -> None: Generate a bar chart plot for total amounts spent by each customer from the list of transactions. Save the chart as 'customer_purchases.png'. Example of calling the function: >>> transactions = [ ... {\\"transaction_id\\": \\"T1\\", \\"customer_id\\": \\"C1\\", \\"date\\": \\"2023-09-01\\", \\"product\\": \\"Product A\\", \\"quantity\\": 1, \\"amount\\": 100.0}, ... {\\"transaction_id\\": \\"T2\\", \\"customer_id\\": \\"C2\\", \\"date\\": \\"2023-09-02\\", \\"product\\": \\"Product B\\", \\"quantity\\": 2, \\"amount\\": 200.0}, ... {\\"transaction_id\\": \\"T3\\", \\"customer_id\\": \\"C1\\", \\"date\\": \\"2023-09-03\\", \\"product\\": \\"Product C\\", \\"quantity\\": 1, \\"amount\\": 150.0} ... ] >>> generate_customer_purchases_visualization(transactions) Test Cases: 1. Calling \`generate_customer_purchases_visualization([])\` should raise a \`ValueError\` with a message \\"Input must be a non-empty list of dictionaries.\\" 2. Providing an invalid list should return the appropriate ValueError. 3. Providing a valid list of transactions should generate and save \`customer_purchases.png\`.","solution":"import matplotlib.pyplot as plt import pandas as pd from datetime import datetime def generate_customer_purchases_visualization(transactions: list) -> None: if not transactions or not isinstance(transactions, list) or not all(isinstance(t, dict) for t in transactions): raise ValueError(\\"Input must be a non-empty list of dictionaries.\\") required_keys = {'transaction_id', 'customer_id', 'date', 'product', 'quantity', 'amount'} for t in transactions: if not required_keys.issubset(t.keys()): raise ValueError(\\"Each dictionary must contain the keys: 'transaction_id', 'customer_id', 'date', 'product', 'quantity', 'amount'\\") try: # Convert list of transactions to a DataFrame df = pd.DataFrame(transactions) # Convert 'date' column to datetime df['date'] = pd.to_datetime(df['date'], format='%Y-%m-%d') # Group by customer ID and calculate total amount spent and total number of transactions customer_summary = df.groupby('customer_id').agg( total_amount_spent=pd.NamedAgg(column='amount', aggfunc='sum'), total_transactions=pd.NamedAgg(column='transaction_id', aggfunc='count') ).reset_index() # Create bar chart plt.figure(figsize=(10, 6)) plt.bar(customer_summary['customer_id'], customer_summary['total_amount_spent'], color='blue') plt.xlabel('Customer ID') plt.ylabel('Total Amount Spent') plt.title('Total Amount Spent by Each Customer') plt.xticks(rotation=45, ha='right') plt.tight_layout() # Save the plot as a PNG file plt.savefig('customer_purchases.png') plt.close() except Exception as e: raise RuntimeError(f\\"An error occurred while generating the visualization: {e}\\")"},{"question":"import requests from datetime import datetime, timedelta def fetch_historical_weather(city: str, start_date: str, end_date: str) -> list: Fetch historical weather data for a given city within a specified date range. The function takes in a city name and a date range (start and end dates in \\"YYYY-MM-DD\\" format) and returns a list of weather data for each day within the specified date range. Each day's data is represented by a dictionary containing the date, temperature, and weather description. :param city: The name of the city to retrieve weather data for. :param start_date: The start date of the date range in \\"YYYY-MM-DD\\" format. :param end_date: The end date of the date range in \\"YYYY-MM-DD\\" format. :return: List of dictionaries, where each dictionary contains: - 'date' (str): The date in \\"YYYY-MM-DD\\" format. - 'temperature' (float): The average temperature of the day. - 'description' (str): The weather description of the day. >>> weather = fetch_historical_weather('London', '2023-09-01', '2023-09-05') >>> for day in weather: >>> print(day) Example output: {'date': '2023-09-01', 'temperature': 15.0, 'description': 'Sunny'} {'date': '2023-09-02', 'temperature': 15.0, 'description': 'Sunny'} {'date': '2023-09-03', 'temperature': 15.0, 'description': 'Sunny'} {'date': '2023-09-04', 'temperature': 15.0, 'description': 'Sunny'} {'date': '2023-09-05', 'temperature': 15.0, 'description': 'Sunny'} weather_data = [] api_key = 'your_api_key' # Replace with your actual API key base_url = 'http://api.weatherapi.com/v1/history.json' current_date = start_date while current_date <= end_date: # Form the URL for the current date url = f'{base_url}?key={api_key}&q={city}&dt={current_date}' # Fetch and parse the JSON content response = requests.get(url, timeout=10) response.raise_for_status() # Ensure the request succeeded data = response.json() # Extract the weather data if 'forecast' in data and 'forecastday' in data['forecast'] and data['forecast']['forecastday']: day_data = data['forecast']['forecastday'][0]['day'] date = data['forecast']['forecastday'][0]['date'] temperature = day_data['avgtemp_c'] description = day_data['condition']['text'] weather_data.append({'date': date, 'temperature': temperature, 'description': description}) # Move to the next date current_date = (datetime.strptime(current_date, \\"%Y-%m-%d\\") + timedelta(days=1)).strftime(\\"%Y-%m-%d\\") return weather_data","solution":"import requests from datetime import datetime, timedelta def fetch_historical_weather(city: str, start_date: str, end_date: str) -> list: weather_data = [] api_key = 'your_api_key' # Replace with your actual API key base_url = 'https://api.weatherapi.com/v1/history.json' current_date = start_date while current_date <= end_date: # Form the URL for the current date url = f'{base_url}?key={api_key}&q={city}&dt={current_date}' # Fetch and parse the JSON content try: response = requests.get(url, timeout=10) response.raise_for_status() # Ensure the request succeeded data = response.json() except requests.RequestException as e: print(f\\"Network error occurred: {e}\\") break # Exit the loop in case of a network error # Extract the weather data if 'forecast' in data and 'forecastday' in data['forecast'] and data['forecast']['forecastday']: day_data = data['forecast']['forecastday'][0]['day'] date = data['forecast']['forecastday'][0]['date'] temperature = day_data['avgtemp_c'] description = day_data['condition']['text'] weather_data.append({'date': date, 'temperature': temperature, 'description': description}) # Move to the next date current_date = (datetime.strptime(current_date, \\"%Y-%m-%d\\") + timedelta(days=1)).strftime(\\"%Y-%m-%d\\") return weather_data"},{"question":"from collections import deque class CustomQueue: Implement a Custom Queue Data Structure with the ability to retrieve the maximum value in the queue in constant time. Methods: enqueue(value): Adds 'value' (an integer) to the end of the queue. dequeue(): Removes and returns the front element of the queue. max_value(): Returns the maximum value in the queue in O(1) time. If 'dequeue()' is called on an empty queue, it should raise an Exception. If 'max_value()' is called on an empty queue, it should raise an Exception. Example of usage: >>> custom_queue = CustomQueue() >>> custom_queue.enqueue(1) >>> custom_queue.enqueue(3) >>> custom_queue.enqueue(2) >>> custom_queue.max_value() # Expected output: 3 >>> custom_queue.dequeue() # Expected output: 1 >>> custom_queue.max_value() # Expected output: 3 >>> custom_queue.dequeue() >>> custom_queue.max_value() # Expected output: 2 def __init__(self): self.queue = deque() self.max_vals = deque() def enqueue(self, value): pass def dequeue(self): pass def max_value(self): pass","solution":"from collections import deque class CustomQueue: def __init__(self): self.queue = deque() self.max_vals = deque() def enqueue(self, value): self.queue.append(value) while self.max_vals and self.max_vals[-1] < value: self.max_vals.pop() self.max_vals.append(value) def dequeue(self): if not self.queue: raise Exception(\\"Queue is empty\\") value = self.queue.popleft() if value == self.max_vals[0]: self.max_vals.popleft() return value def max_value(self): if not self.max_vals: raise Exception(\\"Queue is empty\\") return self.max_vals[0]"},{"question":"class SegmentTree: def __init__(self, data: list): Initialize the segment tree with a given list of integers. Parameters: data (list): List of integers to build the segment tree from. Example Usage: >>> st = SegmentTree([1, 3, 5, 7, 9, 11]) >>> st.range_min_query(1, 4) 3 >>> st.update(2, 0) >>> st.range_min_query(1, 4) 0 pass def range_min_query(self, left: int, right: int) -> int: Returns the minimum value in the range [left, right). Parameters: left (int): left bound of the range (inclusive). right (int): right bound of the range (exclusive). Returns: int: Minimum value in the specified range. Example Usage: >>> st = SegmentTree([1, 3, 5, 7, 9, 11]) >>> st.range_min_query(1, 4) 3 pass def update(self, index: int, value: int) -> None: Update the value at a specific index in the array. Parameters: index (int): Index of the element to update. value (int): New value to set at the specified index. Returns: None. Example Usage: >>> st = SegmentTree([1, 3, 5, 7, 9, 11]) >>> st.update(2, 0) >>> st.range_min_query(1, 4) 0 pass","solution":"class SegmentTree: def __init__(self, data: list): self.n = len(data) self.tree = [0] * (2 * self.n) self.build(data) def build(self, data): for i in range(self.n): self.tree[self.n + i] = data[i] for i in range(self.n - 1, 0, -1): self.tree[i] = min(self.tree[2 * i], self.tree[2 * i + 1]) def range_min_query(self, left: int, right: int) -> int: left += self.n right += self.n min_value = float('inf') while left < right: if left % 2: min_value = min(min_value, self.tree[left]) left += 1 if right % 2: right -= 1 min_value = min(min_value, self.tree[right]) left //= 2 right //= 2 return min_value def update(self, index: int, value: int) -> None: pos = index + self.n self.tree[pos] = value while pos > 1: pos //= 2 self.tree[pos] = min(self.tree[2 * pos], self.tree[2 * pos + 1])"},{"question":"def retrieve_value(nested_dict: dict, keys: list) -> any: Given a nested dictionary and a list of keys, this function returns the value found by navigating through the dictionary using the provided keys. If any key is not found at any level, returns None. Examples: >>> retrieve_value({\\"a\\": {\\"b\\": {\\"c\\": 42}}}, [\\"a\\", \\"b\\", \\"c\\"]) 42 >>> retrieve_value({\\"a\\": {\\"b\\": {\\"c\\": {\\"d\\": 99}}}}, [\\"a\\", \\"b\\", \\"c\\", \\"d\\"]) 99 >>> retrieve_value({\\"a\\": {\\"b\\": {\\"x\\": 25}}}, [\\"a\\", \\"b\\", \\"c\\"]) None >>> retrieve_value({\\"k1\\": {\\"k2\\": {\\"k3\\": \\"value\\"}}}, [\\"k1\\", \\"k4\\"]) None >>> retrieve_value({\\"a\\": {\\"b\\": {\\"c\\": 42}}}, []) {'a': {'b': {'c': 42}}} >>> retrieve_value({\\"k1\\": 10}, [\\"k1\\"]) 10 >>> retrieve_value({\\"a\\": {\\"b\\": {\\"c\\": {\\"d\\": 99}}}}, [\\"a\\", \\"b\\"]) {'c': {'d': 99}} pass","solution":"def retrieve_value(nested_dict: dict, keys: list) -> any: Given a nested dictionary and a list of keys, this function returns the value found by navigating through the dictionary using the provided keys. If any key is not found at any level, returns None. current_level = nested_dict for key in keys: if isinstance(current_level, dict) and key in current_level: current_level = current_level[key] else: return None return current_level"},{"question":"from typing import List def shortest_subarray_with_sum_at_least_k(arr: List[int], K: int) -> int: Returns the length of the shortest continuous subarray whose sum is at least K. If no such subarray exists, returns -1. :param arr: A list of positive integers. :param K: An integer, the target sum. :return: The length of the shortest contiguous subarray with sum at least K. >>> shortest_subarray_with_sum_at_least_k([2, 1, 5, 2, 3, 2], 8) 3 >>> shortest_subarray_with_sum_at_least_k([3, 1, 1, 1, 5, 0, 0], 11) 5 >>> shortest_subarray_with_sum_at_least_k([1, 2, 3], 7) -1 >>> shortest_subarray_with_sum_at_least_k([1, 4, 2, 3, 5], 7) 2 pass","solution":"from collections import deque from typing import List def shortest_subarray_with_sum_at_least_k(arr: List[int], K: int) -> int: Returns the length of the shortest continuous subarray whose sum is at least K. If no such subarray exists, returns -1. :param arr: A list of positive integers. :param K: An integer, the target sum. :return: The length of the shortest contiguous subarray with sum at least K. N = len(arr) prefix_sum = [0] * (N + 1) for i in range(N): prefix_sum[i + 1] = prefix_sum[i] + arr[i] # Deque to keep indexes of prefix_sum array dq = deque() min_length = float('inf') for i in range(N + 1): while dq and prefix_sum[i] - prefix_sum[dq[0]] >= K: min_length = min(min_length, i - dq.popleft()) while dq and prefix_sum[i] <= prefix_sum[dq[-1]]: dq.pop() dq.append(i) return min_length if min_length != float('inf') else -1"},{"question":"import numpy as np def is_symmetric(matrix: np.ndarray) -> bool: Check if the given matrix is symmetric. Parameters: matrix (np.ndarray): A square matrix Returns: bool: True if the matrix is symmetric, False otherwise Examples: >>> is_symmetric(np.array([[1, 7, 3], [7, 4, -5], [3, -5, 6]])) True >>> is_symmetric(np.array([[1, 0, 3], [0, 4, -5], [2, -5, 6]])) False def matrix_power(matrix: np.ndarray, exponent: int) -> np.ndarray: Compute the power of a symmetric matrix raised to a given integer exponent. Parameters: matrix (np.ndarray): A symmetric square matrix exponent (int): The integer power Returns: np.ndarray: The resulting matrix after raising the input matrix to the given exponent Raises: ValueError: If the matrix is not symmetric or if the exponent is negative Examples: >>> matrix_power(np.array([[1, 2], [2, 3]]), 2) array([[ 5, 8], [ 8, 13]]) >>> matrix_power(np.eye(3), 5) array([[1, 0, 0], [0, 1, 0], [0, 0, 1]])","solution":"import numpy as np def is_symmetric(matrix: np.ndarray) -> bool: Check if the given matrix is symmetric. Parameters: matrix (np.ndarray): A square matrix Returns: bool: True if the matrix is symmetric, False otherwise return np.array_equal(matrix, matrix.T) def matrix_power(matrix: np.ndarray, exponent: int) -> np.ndarray: Compute the power of a symmetric matrix raised to a given integer exponent. Parameters: matrix (np.ndarray): A symmetric square matrix exponent (int): The integer power Returns: np.ndarray: The resulting matrix after raising the input matrix to the given exponent Raises: ValueError: If the matrix is not symmetric or if the exponent is negative if not is_symmetric(matrix): raise ValueError(\\"The matrix is not symmetric\\") if exponent < 0: raise ValueError(\\"Exponent must be a non-negative integer\\") return np.linalg.matrix_power(matrix, exponent)"},{"question":"def min_subset_difference(arr: list[int]) -> int: Partition the array into two subsets and returns the minimum possible absolute difference between the sums of these subsets. >>> min_subset_difference([1, 6, 11, 5]) 1 >>> min_subset_difference([10, 10, 10, 10]) 0 >>> min_subset_difference([1, 2, 3, 9]) 3 >>> min_subset_difference([5]) 5 >>> min_subset_difference([1, 3]) 2 >>> min_subset_difference([1, 1, 1, 1]) 0 >>> min_subset_difference([3, 1, 4, 2, 2, 1]) 1 pass","solution":"def min_subset_difference(arr): Returns the minimum possible absolute difference between the sums of two subsets. total_sum = sum(arr) n = len(arr) # Initialize a DP array to keep track of achievable sums up to total_sum//2 dp = [False] * (total_sum // 2 + 1) dp[0] = True # Process each number in the array for num in arr: for j in range(total_sum // 2, num - 1, -1): dp[j] = dp[j] or dp[j - num] # Find the closest achievable sum to total_sum // 2 for j in range(total_sum // 2, -1, -1): if dp[j]: return total_sum - 2 * j"},{"question":"from collections import defaultdict, deque import heapq class Graph: def __init__(self): Initialize an empty graph with an adjacency list. self.adjacency_list = defaultdict(dict) def add_vertex(self, vertex) -> None: Add a vertex to the graph. - vertex: A single value representing the vertex. >>> g = Graph() >>> g.add_vertex('A') >>> 'A' in g.adjacency_list True def add_edge(self, v1, v2, weight=1) -> None: Add an edge to the graph. - v1: The first vertex. - v2: The second vertex. - weight: The weight of the edge (default is 1). >>> g = Graph() >>> g.add_vertex('A') >>> g.add_vertex('B') >>> g.add_edge('A', 'B', 2) >>> g.adjacency_list['A']['B'] == 2 True >>> g.adjacency_list['B']['A'] == 2 True def remove_edge(self, v1, v2) -> None: Remove an edge from the graph. - v1: The first vertex. - v2: The second vertex. >>> g = Graph() >>> g.add_vertex('A') >>> g.add_vertex('B') >>> g.add_edge('A', 'B', 2) >>> g.remove_edge('A', 'B') >>> 'B' not in g.adjacency_list['A'] True >>> 'A' not in g.adjacency_list['B'] True def dijkstra(self, start_vertex) -> dict: Find the shortest path using Dijkstra's algorithm. - start_vertex: The starting vertex. >>> g = Graph() >>> g.add_vertex('A') >>> g.add_vertex('B') >>> g.add_vertex('C') >>> g.add_edge('A', 'B', 2) >>> g.add_edge('A', 'C', 4) >>> g.add_edge('B', 'C', 1) >>> g.dijkstra('A') == {'A': 0, 'B': 2, 'C': 3} True def dfs(self, start_vertex) -> list: Perform a depth-first search traversal. - start_vertex: The starting vertex. >>> g = Graph() >>> g.add_vertex('A') >>> g.add_vertex('B') >>> g.add_vertex('C') >>> g.add_edge('A', 'B', 2) >>> g.add_edge('A', 'C', 4) >>> g.dfs('A') ['A', 'C', 'B'] or ['A', 'B', 'C'] def bfs(self, start_vertex) -> list: Perform a breadth-first search traversal. - start_vertex: The starting vertex. >>> g = Graph() >>> g.add_vertex('A') >>> g.add_vertex('B') >>> g.add_vertex('C') >>> g.add_edge('A', 'B', 2) >>> g.add_edge('A', 'C', 4) >>> g.bfs('A') ['A', 'B', 'C']","solution":"import heapq from collections import defaultdict, deque class Graph: def __init__(self): self.adjacency_list = defaultdict(dict) def add_vertex(self, vertex): if vertex not in self.adjacency_list: self.adjacency_list[vertex] = {} def add_edge(self, v1, v2, weight=1): if v1 in self.adjacency_list and v2 in self.adjacency_list: self.adjacency_list[v1][v2] = weight self.adjacency_list[v2][v1] = weight def remove_edge(self, v1, v2): if v1 in self.adjacency_list and v2 in self.adjacency_list[v1]: del self.adjacency_list[v1][v2] del self.adjacency_list[v2][v1] else: raise KeyError(\\"Edge does not exist\\") def dijkstra(self, start_vertex): distances = {vertex: float('inf') for vertex in self.adjacency_list} distances[start_vertex] = 0 priority_queue = [(0, start_vertex)] while priority_queue: current_distance, current_vertex = heapq.heappop(priority_queue) if current_distance > distances[current_vertex]: continue for neighbor, weight in self.adjacency_list[current_vertex].items(): distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return distances def dfs(self, start_vertex): visited = set() result = [] stack = [start_vertex] while stack: vertex = stack.pop() if vertex not in visited: visited.add(vertex) result.append(vertex) stack.extend(self.adjacency_list[vertex].keys()) return result def bfs(self, start_vertex): visited = set() result = [] queue = deque([start_vertex]) while queue: vertex = queue.popleft() if vertex not in visited: visited.add(vertex) result.append(vertex) queue.extend(self.adjacency_list[vertex].keys()) return result"},{"question":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next class LinkedListPalindromeChecker: def is_palindrome(self, head: ListNode) -> bool: Determine if a singly linked list of integers is a palindrome. >>> node1 = ListNode(1) >>> node2 = ListNode(2) >>> node3 = ListNode(2) >>> node4 = ListNode(1) >>> node1.next = node2 >>> node2.next = node3 >>> node3.next = node4 >>> checker = LinkedListPalindromeChecker() >>> checker.is_palindrome(node1) True >>> node5 = ListNode(3) >>> node4.next = node5 >>> checker.is_palindrome(node1) False import pytest def test_empty_list(): checker = LinkedListPalindromeChecker() head = None assert checker.is_palindrome(head) == True def test_single_node(): checker = LinkedListPalindromeChecker() head = ListNode(1) assert checker.is_palindrome(head) == True def test_two_nodes_palindrome(): checker = LinkedListPalindromeChecker() head = ListNode(1) head.next = ListNode(1) assert checker.is_palindrome(head) == True def test_two_nodes_not_palindrome(): checker = LinkedListPalindromeChecker() head = ListNode(1) head.next = ListNode(2) assert checker.is_palindrome(head) == False def test_long_palindrome(): checker = LinkedListPalindromeChecker() head = ListNode(1) n1 = ListNode(2) n2 = ListNode(3) n3 = ListNode(2) n4 = ListNode(1) head.next = n1 n1.next = n2 n2.next = n3 n3.next = n4 assert checker.is_palindrome(head) == True def test_long_non_palindrome(): checker = LinkedListPalindromeChecker() head = ListNode(1) n1 = ListNode(2) n2 = ListNode(3) n3 = ListNode(4) n4 = ListNode(5) head.next = n1 n1.next = n2 n2.next = n3 n3.next = n4 assert checker.is_palindrome(head) == False def test_palindrome_with_negative_numbers(): checker = LinkedListPalindromeChecker() head = ListNode(-1) n1 = ListNode(0) n2 = ListNode(-1) head.next = n1 n1.next = n2 assert checker.is_palindrome(head) == True def test_mixed_palindrome(): checker = LinkedListPalindromeChecker() head = ListNode(1) n1 = ListNode(2) n2 = ListNode(3) n3 = ListNode(2) n4 = ListNode(1) n5 = ListNode(4) head.next = n1 n1.next = n2 n2.next = n3 n3.next = n4 n4.next = n5 assert checker.is_palindrome(head) == False","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next class LinkedListPalindromeChecker: def is_palindrome(self, head: ListNode) -> bool: if not head or not head.next: return True # Use two pointers to find the midpoint slow, fast = head, head while fast and fast.next: slow = slow.next fast = fast.next.next # Reverse the second half of the list prev, curr = None, slow while curr: next_temp = curr.next curr.next = prev prev = curr curr = next_temp # Compare the first and second half nodes first, second = head, prev while second: # Only need to compare until second part is exhausted if first.val != second.val: return False first, second = first.next, second.next return True"},{"question":"class WordDictionary: def __init__(self) -> None: Initializes the data structure. pass def add_word(self, word: str) -> None: Adds a word to the dictionary. pass def search(self, word: str) -> bool: Returns True if there exists any word in the dictionary that matches the given word with wildcards, False otherwise. The word can contain the dot character '.' to represent any one letter. pass # Unit tests def test_add_and_search_word(): wd = WordDictionary() wd.add_word(\\"bad\\") wd.add_word(\\"dad\\") wd.add_word(\\"mad\\") assert not wd.search(\\"pad\\") # No word \\"pad\\" in dictionary assert wd.search(\\"bad\\") # \\"bad\\" is in the dictionary assert wd.search(\\".ad\\") # matches with \\"bad\\", \\"dad\\", \\"mad\\" assert wd.search(\\"b..\\") # matches with \\"bad\\" def test_search_with_only_dot(): wd = WordDictionary() wd.add_word(\\"a\\") wd.add_word(\\"b\\") assert wd.search(\\".\\") # matches \\"a\\" and \\"b\\" def test_add_and_search_empty_word(): wd = WordDictionary() wd.add_word(\\"\\") assert wd.search(\\"\\") # Empty string is a valid word def test_search_non_existent_word(): wd = WordDictionary() wd.add_word(\\"hello\\") assert not wd.search(\\"helloo\\") # \\"helloo\\" is not in the dictionary assert not wd.search(\\"hell\\") # \\"hell\\" is not in the dictionary def test_complex_search(): wd = WordDictionary() wd.add_word(\\"abcde\\") wd.add_word(\\"xyz\\") assert wd.search(\\"a.c.e\\") # Matches with \\"abcde\\" assert wd.search(\\"x.z\\") # Matches with \\"xyz\\" assert not wd.search(\\"ab..def\\") # No match","solution":"class WordDictionary: def __init__(self): self.trie = {} def add_word(self, word: str) -> None: node = self.trie for char in word: if char not in node: node[char] = {} node = node[char] node['#'] = True # End of word marker def search(self, word: str) -> bool: def dfs(node, word): for i, char in enumerate(word): if char == '.': for key in node: if key != '#' and dfs(node[key], word[i+1:]): return True return False if char not in node: return False node = node[char] return '#' in node return dfs(self.trie, word)"},{"question":"def transpose_and_sum_diagonals(matrix: List[List[int]]) -> Tuple[List[List[int]], int]: Transpose the given square matrix and return the matrix along with the sum of the elements in both main diagonals. Parameters: matrix (List[List[int]]): The input square matrix. Returns: Tuple[List[List[int]], int]: A tuple containing the transposed matrix and the sum of the diagonal elements. Example Usage: >>> transpose_and_sum_diagonals([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) ([[1, 4, 7], [2, 5, 8], [3, 6, 9]], 25) >>> transpose_and_sum_diagonals([[5]]) ([[5]], 5)","solution":"from typing import List, Tuple def transpose_and_sum_diagonals(matrix: List[List[int]]) -> Tuple[List[List[int]], int]: n = len(matrix) # Transpose the matrix transposed_matrix = [[matrix[j][i] for j in range(n)] for i in range(n)] # Calculate the sum of both diagonals diagonal_sum = 0 for i in range(n): diagonal_sum += matrix[i][i] # Main diagonal if i != n - i - 1: # Check to avoid double-counting the center element in case of odd-sized matrix diagonal_sum += matrix[i][n - i - 1] # Anti diagonal return transposed_matrix, diagonal_sum"},{"question":"from typing import List def largest_rectangle_area(heights: List[int]) -> int: Returns the area of the largest rectangle that can be formed within the bounds of the histogram. >>> largest_rectangle_area([2, 1, 5, 6, 2, 3]) == 10 >>> largest_rectangle_area([4, 2, 0, 3, 2, 5]) == 6","solution":"def largest_rectangle_area(heights): Returns the area of the largest rectangle that can be formed within the bounds of the histogram. stack = [] max_area = 0 index = 0 while index < len(heights): if not stack or heights[stack[-1]] <= heights[index]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"from typing import List def rotate_matrix(matrix: List[List[int]]) -> List[List[int]]: Rotates a given square matrix by 90 degrees clockwise. Args: - matrix: A 2D list of integers representing the matrix to be rotated. Returns: - A 2D list of integers representing the rotated matrix. Examples: >>> rotate_matrix([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) [[7, 4, 1], [8, 5, 2], [9, 6, 3]] >>> rotate_matrix([ ... [1] ... ]) [[1]] def test_rotate_matrix_even_size(): matrix = [ [1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16] ] rotated = [ [13, 9, 5, 1], [14, 10, 6, 2], [15, 11, 7, 3], [16, 12, 8, 4] ] assert rotate_matrix(matrix) == rotated def test_rotate_matrix_odd_size(): matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] rotated = [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] assert rotate_matrix(matrix) == rotated def test_rotate_matrix_single_element(): matrix = [ [1] ] rotated = [ [1] ] assert rotate_matrix(matrix) == rotated def test_rotate_matrix_two_by_two(): matrix = [ [1, 2], [3, 4] ] rotated = [ [3, 1], [4, 2] ] assert rotate_matrix(matrix) == rotated def test_rotate_matrix_large(): matrix = [ [1, 2, 3, 4, 5], [6, 7, 8, 9, 10], [11, 12, 13, 14, 15], [16, 17, 18, 19, 20], [21, 22, 23, 24, 25], ] rotated = [ [21, 16, 11, 6, 1], [22, 17, 12, 7, 2], [23, 18, 13, 8, 3], [24, 19, 14, 9, 4], [25, 20, 15, 10, 5], ] assert rotate_matrix(matrix) == rotated","solution":"from typing import List def rotate_matrix(matrix: List[List[int]]) -> List[List[int]]: Rotates a given square matrix by 90 degrees clockwise. Args: - matrix: A 2D list of integers representing the matrix to be rotated. Returns: - A 2D list of integers representing the rotated matrix. n = len(matrix) # Create a new matrix to store the rotated values rotated = [[0] * n for _ in range(n)] for i in range(n): for j in range(n): rotated[j][n - 1 - i] = matrix[i][j] return rotated"},{"question":"def highlight_keywords(text: str, keywords: List[str], tag: str) -> str: Wraps each occurrence of a set of target keywords in a given string with a specified HTML tag. >>> highlight_keywords(\\"Hello world!\\", [\\"world\\"], \\"b\\") 'Hello <b>world</b>!' >>> highlight_keywords(\\"Programming in Python is fun!\\", [\\"python\\", \\"fun\\"], \\"i\\") 'Programming in <i>Python</i> is <i>fun</i>!' >>> highlight_keywords(\\"The quick brown fox jumps over the lazy dog\\", [\\"quick\\", \\"fox\\", \\"dog\\"], \\"u\\") 'The <u>quick</u> brown <u>fox</u> jumps over the lazy <u>dog</u>' from typing import List # Test cases def test_single_keyword(): assert highlight_keywords(\\"Hello world!\\", [\\"world\\"], \\"b\\") == \\"Hello <b>world</b>!\\" def test_multiple_keywords(): assert highlight_keywords(\\"Programming in Python is fun!\\", [\\"python\\", \\"fun\\"], \\"i\\") == \\"Programming in <i>Python</i> is <i>fun</i>!\\" def test_no_keywords(): assert highlight_keywords(\\"This text has no keywords.\\", [], \\"u\\") == \\"This text has no keywords.\\" def test_case_insensitivity(): assert highlight_keywords(\\"Case INsensitive MATCH\\", [\\"case\\", \\"match\\"], \\"b\\") == \\"<b>Case</b> INsensitive <b>MATCH</b>\\" def test_partial_overlap(): assert highlight_keywords(\\"The quick brown fox jumps over the lazy dog\\", [\\"quick\\", \\"fox\\", \\"dog\\"], \\"u\\") == \\"The <u>quick</u> brown <u>fox</u> jumps over the lazy <u>dog</u>\\" def test_keyword_in_different_cases(): assert highlight_keywords(\\"CaSe InSeNsItIvE\\", [\\"case\\", \\"insensitive\\"], \\"i\\") == \\"<i>CaSe</i> <i>InSeNsItIvE</i>\\" def test_repeated_keyword(): assert highlight_keywords(\\"hello hello hello\\", [\\"hello\\"], \\"b\\") == \\"<b>hello</b> <b>hello</b> <b>hello</b>\\" def test_no_match(): assert highlight_keywords(\\"Completely different\\", [\\"unmatched\\"], \\"i\\") == \\"Completely different\\" def test_long_text(): long_text = \\"a\\" * 1000000 + \\"keyword\\" + \\"b\\" * 1000000 assert highlight_keywords(long_text, [\\"keyword\\"], \\"b\\") == \\"a\\" * 1000000 + \\"<b>keyword</b>\\" + \\"b\\" * 1000000","solution":"def highlight_keywords(text, keywords, tag): Function to wrap specified keywords within the text with the given HTML tag. import re def replace(match): return f\\"<{tag}>{match.group(0)}</{tag}>\\" for keyword in keywords: pattern = re.compile(re.escape(keyword), re.IGNORECASE) text = pattern.sub(replace, text) return text"},{"question":"def insertion_sort(data: list) -> list: Sorts a list of integers in ascending order using the Insertion Sort algorithm. Args: data (list): The list of integers to be sorted. Returns: list: A sorted list of integers. Examples: >>> insertion_sort([4, 3, 2, 10, 12, 1, 5, 6]) [1, 2, 3, 4, 5, 6, 10, 12] >>> insertion_sort([5, 4, 3, 2, 1]) [1, 2, 3, 4, 5] >>> insertion_sort([1, 2, 3, 4, 5]) [1, 2, 3, 4, 5] >>> insertion_sort([]) [] >>> insertion_sort([1]) [1] import pytest from insertion_sort import insertion_sort def test_insertion_sort_example_cases(): assert insertion_sort([4, 3, 2, 10, 12, 1, 5, 6]) == [1, 2, 3, 4, 5, 6, 10, 12] assert insertion_sort([5, 4, 3, 2, 1]) == [1, 2, 3, 4, 5] assert insertion_sort([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5] assert insertion_sort([]) == [] assert insertion_sort([1]) == [1] def test_insertion_sort_edge_cases(): assert insertion_sort([0]) == [0] assert insertion_sort([-1, 2, -3, 4, -5]) == [-5, -3, -1, 2, 4] assert insertion_sort([1000, 100, 10, 1, 0]) == [0, 1, 10, 100, 1000] def test_insertion_sort_large_case(): import random data = [random.randint(1, 1000) for _ in range(1000)] assert insertion_sort(data) == sorted(data) def test_insertion_sort_invalid_input(): try: insertion_sort(\\"not a list\\") except ValueError as e: assert str(e) == \\"Input should be a list.\\" try: insertion_sort([4, 3, \\"a\\", 10]) except ValueError as e: assert str(e) == \\"All elements in the list should be integers.\\" if __name__ == \\"__main__\\": pytest.main()","solution":"def insertion_sort(data): Sorts a list of integers in ascending order using the Insertion Sort algorithm. Args: data (list): The list of integers to be sorted. Returns: list: A sorted list of integers. if not isinstance(data, list): raise ValueError(\\"Input should be a list.\\") for element in data: if not isinstance(element, int): raise ValueError(\\"All elements in the list should be integers.\\") n = len(data) for i in range(1, n): key = data[i] j = i - 1 # Move elements of data[0..i-1], that are greater than key, # to one position ahead of their current position while j >= 0 and data[j] > key: data[j + 1] = data[j] j -= 1 data[j + 1] = key return data"},{"question":"def parse_currency(amount_str): Parse a string representing a monetary amount and convert it to a float. >>> parse_currency(\\"123.45\\") 123.45 >>> parse_currency(\\"0.99\\") 0.99 def validate_currency(amount_str): Validate if a given string is a correctly formatted monetary amount. >>> validate_currency(\\"123.45\\") True >>> validate_currency(\\"123.45\\") False def add_currency(amount1, amount2): Add two monetary amounts and return the result. >>> add_currency(123.45, 0.55) 124.00 >>> add_currency(100.00, 23.45) 123.45","solution":"def parse_currency(amount_str): Parse a string representing a monetary amount and convert it to a float. if amount_str.startswith('') and validate_currency(amount_str): return float(amount_str[1:]) raise ValueError(\\"Invalid currency format\\") def validate_currency(amount_str): Validate if a given string is a correctly formatted monetary amount. if not amount_str.startswith(''): return False try: amount = float(amount_str[1:]) except ValueError: return False # Ensure two decimal places parts = amount_str.split('.') if len(parts) != 2 or len(parts[1]) != 2: return False return True def add_currency(amount1, amount2): Add two monetary amounts and return the result. # Round the result to two decimal places in case of floating-point arithmetic issues return round(amount1 + amount2, 2)"},{"question":"def analyze_transactions(transactions: list[dict[str, str]]) -> dict[str, float | str]: Analyzes transaction records, calculates the success and failure rates, and identifies the most common reasons for failure. >>> transactions = [ ... {\\"id\\": \\"txn001\\", \\"status\\": \\"success\\", \\"reason\\": \\"\\"}, ... {\\"id\\": \\"txn002\\", \\"status\\": \\"failure\\", \\"reason\\": \\"Network Error\\"}, ... {\\"id\\": \\"txn003\\", \\"status\\": \\"failure\\", \\"reason\\": \\"Insufficient Funds\\"}, ... {\\"id\\": \\"txn004\\", \\"status\\": \\"success\\", \\"reason\\": \\"\\"}, ... {\\"id\\": \\"txn005\\", \\"status\\": \\"failure\\", \\"reason\\": \\"Network Error\\"} ... ] >>> analyze_transactions(transactions) {'success_rate': 40.0, 'failure_rate': 60.0, 'most_common_failure_reason': 'Network Error'} >>> transactions = [ ... {\\"id\\": \\"txn001\\", \\"status\\": \\"success\\", \\"reason\\": \\"\\"}, ... {\\"id\\": \\"txn002\\", \\"status\\": \\"success\\", \\"reason\\": \\"\\"} ... ] >>> analyze_transactions(transactions) {'success_rate': 100.0, 'failure_rate': 0.0, 'most_common_failure_reason': ''} pass","solution":"def analyze_transactions(transactions): total_transactions = len(transactions) successful_transactions = sum(1 for txn in transactions if txn[\\"status\\"] == \\"success\\") failed_transactions = total_transactions - successful_transactions success_rate = (successful_transactions / total_transactions) * 100 failure_rate = (failed_transactions / total_transactions) * 100 # Count occurrences of each failure reason failure_reasons = {} for txn in transactions: if txn[\\"status\\"] == \\"failure\\": reason = txn[\\"reason\\"] if reason in failure_reasons: failure_reasons[reason] += 1 else: failure_reasons[reason] = 1 if failure_reasons: most_common_failure_reason = max(failure_reasons, key=failure_reasons.get) else: most_common_failure_reason = \\"\\" # Return the results in a dictionary return { \\"success_rate\\": round(success_rate, 2), \\"failure_rate\\": round(failure_rate, 2), \\"most_common_failure_reason\\": most_common_failure_reason }"},{"question":"def set_union(set1, set2): Returns the union of two sets, set1 and set2. >>> set_union([1, 2, 3], [3, 4, 5]) {1, 2, 3, 4, 5} >>> set_union([1, 2, 3], []) {1, 2, 3} >>> set_union([], [3, 4, 5]) {3, 4, 5} >>> set_union([], []) set() >>> set_union([1, 2, 2], [2, 3, 3]) {1, 2, 3} def set_intersection(set1, set2): Returns the intersection of two sets, set1 and set2. >>> set_intersection([1, 2, 3], [3, 4, 5]) {3} >>> set_intersection([1, 2, 3], []) set() >>> set_intersection([], [3, 4, 5]) set() >>> set_intersection([], []) set() >>> set_intersection([1, 2, 2], [2, 3, 3]) {2} def set_symmetric_difference(set1, set2): Returns the symmetric difference of two sets, set1 and set2. >>> set_symmetric_difference([1, 2, 3], [3, 4, 5]) {1, 2, 4, 5} >>> set_symmetric_difference([1, 2, 3], []) {1, 2, 3} >>> set_symmetric_difference([], [3, 4, 5]) {3, 4, 5} >>> set_symmetric_difference([], []) set() >>> set_symmetric_difference([1, 2, 2], [2, 3, 3]) {1, 3}","solution":"def set_union(set1, set2): Returns the union of two sets, set1 and set2. return set(set1).union(set2) def set_intersection(set1, set2): Returns the intersection of two sets, set1 and set2. return set(set1).intersection(set2) def set_symmetric_difference(set1, set2): Returns the symmetric difference of two sets, set1 and set2. return set(set1).symmetric_difference(set2)"},{"question":"import heapq from typing import List, Tuple class TicketingSystem: def __init__(self): self.tickets = [] def add_ticket(self, timestamp: int, severity: int): Adds a new ticket with the given timestamp and severity. Args: timestamp (int): The time of arrival of the ticket in microseconds since the epoch. severity (int): The severity of the issue. pass def close_highest_priority(self) -> Tuple[int, int]: Closes the highest priority ticket and returns it. Returns: Tuple[int, int]: The highest priority ticket as a tuple (timestamp, severity). If no tickets are present, return (-1, -1). pass def fetch_highest_priority(self) -> Tuple[int, int]: Returns the highest priority ticket without closing it. Returns: Tuple[int, int]: The highest priority ticket as a tuple (timestamp, severity). If no tickets are present, return (-1, -1). pass","solution":"import heapq from typing import List, Tuple class TicketingSystem: def __init__(self): self.tickets = [] def add_ticket(self, timestamp: int, severity: int): heapq.heappush(self.tickets, (-severity, timestamp)) def close_highest_priority(self) -> Tuple[int, int]: if not self.tickets: return (-1, -1) severity, timestamp = heapq.heappop(self.tickets) return (timestamp, -severity) def fetch_highest_priority(self) -> Tuple[int, int]: if not self.tickets: return (-1, -1) severity, timestamp = self.tickets[0] return (timestamp, -severity)"},{"question":"from typing import List def sum_of_unique_elements(nums: List[int]) -> int: Returns the sum of all unique integers in the array \`nums\`. Examples: >>> sum_of_unique_elements([1, 2, 3, 2, 4]) 10 >>> sum_of_unique_elements([1, 1, 1, 1, 1]) 1 >>> sum_of_unique_elements([0, -1, 1]) 0 >>> sum_of_unique_elements([-1, -2, -2, -3, -4]) -10 >>> sum_of_unique_elements([1000000, -1000000, 1000000]) -1000000","solution":"from typing import List def sum_of_unique_elements(nums: List[int]) -> int: Returns the sum of all unique integers in the array \`nums\`. Elements are considered unique even if they appear more than once in the input list. return sum(set(nums))"},{"question":"def sort_list_of_dicts(data: list, keys: list, reverse: bool = False) -> list: Sorts a list of dictionaries by specified keys. Parameters: data (list): A list of dictionaries to be sorted. keys (list): A list of keys used for sorting. reverse (bool): Should the list be sorted in descending order? Defaults to False. Returns: list: The sorted list of dictionaries. pass # Example Test Cases def test_sort_by_single_key_ascending(): data = [ {\\"name\\": \\"Alice\\", \\"age\\": 30, \\"score\\": 85}, {\\"name\\": \\"Bob\\", \\"age\\": 25, \\"score\\": 90}, {\\"name\\": \\"Charlie\\", \\"age\\": 35, \\"score\\": 78} ] sorted_data = sort_list_of_dicts(data, [\\"age\\"]) expected_data = [ {\\"name\\": \\"Bob\\", \\"age\\": 25, \\"score\\": 90}, {\\"name\\": \\"Alice\\", \\"age\\": 30, \\"score\\": 85}, {\\"name\\": \\"Charlie\\", \\"age\\": 35, \\"score\\": 78} ] assert sorted_data == expected_data def test_sort_by_single_key_descending(): data = [ {\\"name\\": \\"Alice\\", \\"age\\": 30, \\"score\\": 85}, {\\"name\\": \\"Bob\\", \\"age\\": 25, \\"score\\": 90}, {\\"name\\": \\"Charlie\\", \\"age\\": 35, \\"score\\": 78} ] sorted_data = sort_list_of_dicts(data, [\\"score\\"], True) expected_data = [ {\\"name\\": \\"Bob\\", \\"score\\": 90, \\"age\\": 25}, {\\"name\\": \\"Alice\\", \\"score\\": 85, \\"age\\": 30}, {\\"name\\": \\"Charlie\\", \\"score\\": 78, \\"age\\": 35} ] assert sorted_data == expected_data def test_sort_by_multiple_keys_ascending(): data = [ {\\"name\\": \\"Alice\\", \\"age\\": 30, \\"score\\": 85}, {\\"name\\": \\"Bob\\", \\"age\\": 30, \\"score\\": 90}, {\\"name\\": \\"Charlie\\", \\"age\\": 35, \\"score\\": 78} ] sorted_data = sort_list_of_dicts(data, [\\"age\\", \\"score\\"]) expected_data = [ {\\"name\\": \\"Alice\\", \\"age\\": 30, \\"score\\": 85}, {\\"name\\": \\"Bob\\", \\"age\\": 30, \\"score\\": 90}, {\\"name\\": \\"Charlie\\", \\"age\\": 35, \\"score\\": 78} ] assert sorted_data == expected_data def test_sort_by_multiple_keys_descending(): data = [ {\\"name\\": \\"Alice\\", \\"age\\": 30, \\"score\\": 90}, {\\"name\\": \\"Bob\\", \\"age\\": 30, \\"score\\": 85}, {\\"name\\": \\"Charlie\\", \\"age\\": 35, \\"score\\": 78} ] sorted_data = sort_list_of_dicts(data, [\\"age\\", \\"score\\"], True) expected_data = [ {\\"name\\": \\"Charlie\\", \\"age\\": 35, \\"score\\": 78}, {\\"name\\": \\"Alice\\", \\"age\\": 30, \\"score\\": 90}, {\\"name\\": \\"Bob\\", \\"age\\": 30, \\"score\\": 85} ] assert sorted_data == expected_data","solution":"def sort_list_of_dicts(data: list, keys: list, reverse: bool = False) -> list: Sorts a list of dictionaries by specified keys. Parameters: data (list): A list of dictionaries to be sorted. keys (list): A list of keys used for sorting. reverse (bool): Should the list be sorted in descending order? Defaults to False. Returns: list: The sorted list of dictionaries. def get_sort_key(item): return tuple(item[key] for key in keys) sorted_data = sorted(data, key=get_sort_key, reverse=reverse) return sorted_data"},{"question":"def calculate_fare(base_fare: float, per_km_charge: float, per_minute_charge: float, distance_km: float, time_minutes: float) -> float: Compute the total fare for a ride in a ride-sharing application. Args: - base_fare (float): The base fare charged for every ride. - per_km_charge (float): The charge per kilometer traveled. - per_minute_charge (float): The charge per minute spent on the ride. - distance_km (float): The total distance traveled in kilometers. - time_minutes (float): The total time spent on the ride in minutes. Returns: - float: The total fare for the ride. >>> calculate_fare(50.0, 10.0, 2.0, 15.5, 30) 265.0 >>> calculate_fare(50.0, 10.0, 2.0, 0, 30) 110.0 >>> calculate_fare(50.0, 10.0, 2.0, 15.5, 0) 205.0 >>> calculate_fare(50.0, 10.0, 2.0, 0, 0) 50.0 >>> calculate_fare(0, 10.0, 2.0, 15.5, 30) 215.0 >>> calculate_fare(1000, 1000, 1000, 1000, 1000) 2001000.0","solution":"def calculate_fare(base_fare: float, per_km_charge: float, per_minute_charge: float, distance_km: float, time_minutes: float) -> float: Compute the total fare for a ride in a ride-sharing application. Args: - base_fare (float): The base fare charged for every ride. - per_km_charge (float): The charge per kilometer traveled. - per_minute_charge (float): The charge per minute spent on the ride. - distance_km (float): The total distance traveled in kilometers. - time_minutes (float): The total time spent on the ride in minutes. Returns: - float: The total fare for the ride. return base_fare + (per_km_charge * distance_km) + (per_minute_charge * time_minutes)"},{"question":"def min_add_to_make_valid(s: str) -> int: Returns the minimum number of additional bracket symbols required to balance the input string. Parameters: s (str): A string consisting of round bracket characters only ('(' and ')'). Returns: int: The minimum number of additional bracket symbols needed to balance the input string. >>> min_add_to_make_valid(\\"()\\") 0 >>> min_add_to_make_valid(\\"(())\\") 0 >>> min_add_to_make_valid(\\"(()(\\") 2 >>> min_add_to_make_valid(\\"(((\\") 3 >>> min_add_to_make_valid(\\"())\\") 1 >>> min_add_to_make_valid(\\")))\\") 3 >>> min_add_to_make_valid(\\"()))((\\") 4 >>> min_add_to_make_valid(\\"((()))(()\\") 1 >>> min_add_to_make_valid(\\"\\") 0","solution":"def min_add_to_make_valid(s: str) -> int: Returns the minimum number of additional bracket symbols required to balance the input string. Parameters: s (str): A string consisting of round bracket characters only ('(' and ')'). Returns: int: The minimum number of additional bracket symbols needed to balance the input string. open_brackets_needed = 0 close_brackets_needed = 0 for char in s: if char == '(': open_brackets_needed += 1 elif char == ')': if open_brackets_needed > 0: open_brackets_needed -= 1 else: close_brackets_needed += 1 return open_brackets_needed + close_brackets_needed"},{"question":"def remove_invalid_parentheses(s: str) -> list: Given a string \`s\` containing only '(' and ')', return all possible valid strings obtained by removing the minimum number of invalid parentheses. :param s: The input string containing parentheses :type s: str :return: A list of all possible valid strings after parentheses removal :rtype: list Examples: >>> remove_invalid_parentheses(\\"()())()\\") [\\"()()()\\", \\"(())()\\"] >>> remove_invalid_parentheses(\\"(a)())()\\") [\\"(a)()()\\", \\"(a())()\\"] >>> remove_invalid_parentheses(\\")(\\") [\\"\\"] >>> remove_invalid_parentheses(\\"(((abc)\\") [\\"(abc)\\", \\"(abc)\\", \\"(abc\\"] >>> remove_invalid_parentheses(\\"()\\") [\\"()\\"] pass","solution":"from collections import deque def remove_invalid_parentheses(s: str) -> list: Given a string \`s\` containing only '(' and ')', return all possible valid strings obtained by removing the minimum number of invalid parentheses. :param s: The input string containing parentheses :type s: str :return: A list of all possible valid strings after parentheses removal :rtype: list def is_valid(string): balance = 0 for char in string: if char == '(': balance += 1 elif char == ')': balance -= 1 if balance < 0: return False return balance == 0 if is_valid(s): return [s] visited = set() queue = deque([s]) found = False valid_expressions = [] while queue: current = queue.popleft() if is_valid(current): valid_expressions.append(current) found = True if found: continue for i in range(len(current)): if current[i] not in ('(', ')'): continue next_state = current[:i] + current[i+1:] if next_state not in visited: visited.add(next_state) queue.append(next_state) return valid_expressions"},{"question":"def knapsack(capacity: int, weights: List[int], values: List[int]) -> int: Solve the Knapsack problem using a dynamic programming algorithm. Determine the maximum total value of items that can be placed into a knapsack of a given capacity. :param capacity: Maximum weight capacity of the knapsack :param weights: List of integers representing the weight of each item :param values: List of integers representing the value of each item :return: Maximum value that can be obtained within the given capacity >>> knapsack(50, [10, 20, 30], [60, 100, 120]) 220 >>> knapsack(0, [10, 20, 30], [60, 100, 120]) 0 >>> knapsack(50, [], []) 0 >>> knapsack(10, [10], [60]) 60 >>> knapsack(5, [10], [60]) 0 >>> knapsack(50, [10, 20, 30], [60, 100, 120]) 220 >>> knapsack(7, [1, 3, 4, 5], [1, 4, 5, 7]) 9 >>> knapsack(10, [1, 1, 1], [10, 20, 30]) 60 # Your code here","solution":"from typing import List def knapsack(capacity: int, weights: List[int], values: List[int]) -> int: Returns the maximum value that can be carried in the knapsack of given capacity using dynamic programming. :param capacity: Maximum weight capacity of the knapsack :param weights: List of item weights :param values: List of item values :return: Maximum value that can be obtained within the given capacity n = len(weights) # Create a 2D list to store the maximum value at each n weight from 0 to capacity dp = [[0 for _ in range(capacity + 1)] for _ in range(n + 1)] # Fill the dp table in bottom-up manner for i in range(1, n + 1): for w in range(capacity + 1): if weights[i-1] <= w: # Item can be included dp[i][w] = max(dp[i-1][w], dp[i-1][w-weights[i-1]] + values[i-1]) else: # Item cannot be included dp[i][w] = dp[i-1][w] return dp[n][capacity]"},{"question":"import pandas as pd def calculate_average_session_duration(log_file_path: str) -> str: Calculate the average session duration from the log file. Args: log_file_path (str): Path to the CSV log file. Returns: str: The average session duration formatted as \\"HH:MM:SS\\". >>> calculate_average_session_duration(\\"/path/to/log_file.csv\\") '02:00:00' import tempfile import os # Function to create a temporary CSV file for testing def create_temp_csv(content): fd, path = tempfile.mkstemp(suffix='.csv') with os.fdopen(fd, 'w') as f: f.write(content) return path def test_calculate_average_session_duration(): content = user_id,action,timestamp 1,login,2023-01-01 08:00:00 1,logout,2023-01-01 10:00:00 2,login,2023-01-01 09:00:00 2,logout,2023-01-01 11:00:00 path = create_temp_csv(content) try: result = calculate_average_session_duration(path) assert result == \\"02:00:00\\" finally: os.remove(path) def test_calculate_average_session_duration_with_single_session(): content = user_id,action,timestamp 1,login,2023-01-01 08:00:00 1,logout,2023-01-01 10:00:00 path = create_temp_csv(content) try: result = calculate_average_session_duration(path) assert result == \\"02:00:00\\" finally: os.remove(path) def test_calculate_average_session_duration_with_multiple_sessions(): content = user_id,action,timestamp 1,login,2023-01-01 08:00:00 1,logout,2023-01-01 08:30:00 1,login,2023-01-01 09:00:00 1,logout,2023-01-01 10:00:00 path = create_temp_csv(content) try: result = calculate_average_session_duration(path) assert result == \\"00:45:00\\" finally: os.remove(path) def test_calculate_average_session_duration_with_invalid_file(): try: result = calculate_average_session_duration(\\"non_existent_file.csv\\") assert \\"Error processing log file\\" in result except: assert False, \\"The function should handle invalid file paths gracefully\\"","solution":"import pandas as pd def calculate_average_session_duration(log_file_path: str) -> str: Calculate the average session duration from the log file. Args: log_file_path (str): Path to the CSV log file. Returns: str: The average session duration formatted as \\"HH:MM:SS\\". try: # Load the log file df = pd.read_csv(log_file_path) # Ensure data integrity by sorting and grouping df = df.sort_values(by=['user_id', 'timestamp']) # Calculate session durations session_durations = [] for user_id, group in df.groupby('user_id'): logins = group[group.action == 'login']['timestamp'] logouts = group[group.action == 'logout']['timestamp'] durations = (pd.to_datetime(logouts.values) - pd.to_datetime(logins.values)).total_seconds() session_durations.extend(durations) # Calculate the average session duration average_duration_sec = sum(session_durations) / len(session_durations) # Convert to HH:MM:SS format hours, remainder = divmod(average_duration_sec, 3600) minutes, seconds = divmod(remainder, 60) average_duration = f'{int(hours):02}:{int(minutes):02}:{int(seconds):02}' return average_duration except Exception as e: return \\"Error processing log file: \\" + str(e)"},{"question":"from typing import List def sparse_matrix_multiply(mat1: List[List[int]], mat2: List[List[int]]) -> List[List[int]]: Efficiently multiplies two sparse matrices. Args: mat1 (List[List[int]]): First sparse matrix. mat2 (List[List[int]]): Second sparse matrix. Returns: List[List[int]]: Resulting sparse matrix after multiplication. Examples: >>> mat1 = [ ... [1, 0, 0], ... [-1, 0, 3] ... ] >>> mat2 = [ ... [7, 0, 0], ... [0, 0, 0], ... [0, 0, 1] ... ] >>> sparse_matrix_multiply(mat1, mat2) [[7, 0, 0], [-7, 0, 3]] >>> mat1 = [ ... [1, 2, 0], ... [0, 0, 0], ... [4, 0, 0] ... ] >>> mat2 = [ ... [0, 3], ... [0, 0], ... [2, 0] ... ] >>> sparse_matrix_multiply(mat1, mat2) [[0, 3], [0, 0], [0, 12]] >>> mat1 = [ ... [0, 0], ... [0, 0] ... ] >>> mat2 = [ ... [0, 0], ... [0, 0] ... ] >>> sparse_matrix_multiply(mat1, mat2) [[0, 0], [0, 0]]","solution":"from typing import List def sparse_matrix_multiply(mat1: List[List[int]], mat2: List[List[int]]) -> List[List[int]]: if not mat1 or not mat2 or not mat1[0] or not mat2[0]: return [[]] m, n = len(mat1), len(mat1[0]) p = len(mat2[0]) result = [[0 for _ in range(p)] for _ in range(m)] # Convert mat1 to a sparse representation sparse_mat1 = {} for i in range(m): for j in range(n): if mat1[i][j] != 0: if i not in sparse_mat1: sparse_mat1[i] = {} sparse_mat1[i][j] = mat1[i][j] # Convert mat2 to a sparse representation sparse_mat2 = {} for j in range(n): for k in range(p): if mat2[j][k] != 0: if j not in sparse_mat2: sparse_mat2[j] = {} sparse_mat2[j][k] = mat2[j][k] # Perform the multiplication for i in sparse_mat1: for j in sparse_mat1[i]: if j in sparse_mat2: for k in sparse_mat2[j]: result[i][k] += sparse_mat1[i][j] * sparse_mat2[j][k] return result"},{"question":"class Polynomial: def __init__(self, coefficients): self.coefficients = coefficients # List of coefficients, from lowest to highest degree def evaluate(self, x): Evaluates the polynomial at the given value x. def __add__(self, other): Adds two polynomials and returns a new polynomial. def __sub__(self, other): Subtracts one polynomial from another and returns a new polynomial. def __eq__(self, other): Checks if two polynomials are equal. def __repr__(self): Returns a readable string representation of the polynomial. # Testing examples def test_polynomial(): assert Polynomial([2, 0, 3]).evaluate(1) == 5 assert Polynomial([2, 0, 3]).evaluate(0) == 2 assert Polynomial([2, 0, 3]).evaluate(2) == 14 assert (Polynomial([2, 0, 3]) + Polynomial([1, 2])).coefficients == [3, 2, 3] assert (Polynomial([2, 0, 3]) - Polynomial([1, 2])).coefficients == [1, -2, 3] assert Polynomial([2, 0, 3]) == Polynomial([2, 0, 3]) assert Polynomial([2, 0, 3]) != Polynomial([1, 2]) assert repr(Polynomial([2, 0, 3])) == '3x^2 + 2' assert repr(Polynomial([1, 2])) == '2x + 1' assert repr(Polynomial([0, 0, 0])) == '0'","solution":"class Polynomial: def __init__(self, coefficients): self.coefficients = coefficients # List of coefficients, from lowest to highest degree def evaluate(self, x): Evaluates the polynomial at the given value x. result = 0 for exponent, coefficient in enumerate(self.coefficients): result += coefficient * (x ** exponent) return result def __add__(self, other): Adds two polynomials and returns a new polynomial. max_len = max(len(self.coefficients), len(other.coefficients)) result_coefficients = [0] * max_len for i in range(max_len): if i < len(self.coefficients): result_coefficients[i] += self.coefficients[i] if i < len(other.coefficients): result_coefficients[i] += other.coefficients[i] return Polynomial(result_coefficients) def __sub__(self, other): Subtracts one polynomial from another and returns a new polynomial. max_len = max(len(self.coefficients), len(other.coefficients)) result_coefficients = [0] * max_len for i in range(max_len): if i < len(self.coefficients): result_coefficients[i] += self.coefficients[i] if i < len(other.coefficients): result_coefficients[i] -= other.coefficients[i] return Polynomial(result_coefficients) def __eq__(self, other): Checks if two polynomials are equal. return self.coefficients == other.coefficients def __repr__(self): Returns a readable string representation of the polynomial. terms = [] for exponent, coefficient in enumerate(self.coefficients): if coefficient != 0: term = str(coefficient) if exponent == 1: term += 'x' elif exponent > 1: term += f'x^{exponent}' terms.append(term) return ' + '.join(terms[::-1]) if terms else '0'"},{"question":"import statistics from collections import Counter def compute_statistics(data: list) -> dict: Compute various statistical measures (mean, median, mode, variance, standard deviation) for a given list of numbers, ensuring robustness and efficiency. Parameters: data (list): List of numbers for which statistical measures are computed. Returns: dict: Dictionary containing mean, median, mode, variance, and standard deviation, or appropriate values/errors for empty/non-numeric lists. Example: >>> compute_statistics([1, 2, 2, 3, 4]) { 'mean': 2.4, 'median': 2, 'mode': 2, 'variance': 1.3, 'standard_deviation': 1.140175425099138 } >>> compute_statistics([]) { 'mean': None, 'median': None, 'mode': None, 'variance': None, 'standard_deviation': None } >>> compute_statistics([1, 'a', 2, 2, 3, None, 4]) { 'mean': 2.4, 'median': 2, 'mode': 2, 'variance': 1.3, 'standard_deviation': 1.140175425099138 } def test_all_numeric_list(): data = [1, 2, 2, 3, 4] result = compute_statistics(data) assert result == { 'mean': 2.4, 'median': 2, 'mode': 2, 'variance': 1.3, 'standard_deviation': 1.140175425099138 } def test_empty_list(): data = [] result = compute_statistics(data) assert result == { 'mean': None, 'median': None, 'mode': None, 'variance': None, 'standard_deviation': None } def test_list_with_non_numeric_values(): data = [1, 'a', 2, 2, 3, None, 4] result = compute_statistics(data) assert result == { 'mean': 2.4, 'median': 2, 'mode': 2, 'variance': 1.3, 'standard_deviation': 1.140175425099138 } def test_single_element_list(): data = [2] result = compute_statistics(data) assert result == { 'mean': 2, 'median': 2, 'mode': 2, 'variance': 0.0, 'standard_deviation': 0.0 } def test_large_dataset(): data = list(range(1000000)) # Large dataset from 0 to 999999 result = compute_statistics(data) assert result['mean'] == 499999.5 assert result['median'] == 499999.5 assert result['mode'] == 0 # For range, the first element is considered mode assert result['variance'] > 0 assert result['standard_deviation'] > 0","solution":"import statistics from collections import Counter def compute_statistics(data: list) -> dict: Compute various statistical measures (mean, median, mode, variance, standard deviation) for a given list of numbers. Parameters: data (list): List of numbers for which statistical measures are computed. Returns: dict: Dictionary containing mean, median, mode, variance, and standard deviation. try: # Ensure that all elements are numeric cleaned_data = [x for x in data if isinstance(x, (int, float))] if not cleaned_data: return { 'mean': None, 'median': None, 'mode': None, 'variance': None, 'standard_deviation': None } data_count = len(cleaned_data) # Mean mean = statistics.mean(cleaned_data) # Median median = statistics.median(cleaned_data) # Mode mode = None try: mode = statistics.mode(cleaned_data) except statistics.StatisticsError: # When there is no unique mode mode = None # Variance and Standard Deviation variance = statistics.variance(cleaned_data) if data_count > 1 else 0.0 standard_deviation = statistics.stdev(cleaned_data) if data_count > 1 else 0.0 return { 'mean': mean, 'median': median, 'mode': mode, 'variance': variance, 'standard_deviation': standard_deviation } except Exception as e: return { 'mean': None, 'median': None, 'mode': None, 'variance': None, 'standard_deviation': None, 'error': str(e) }"},{"question":"def number_of_ones(n: int) -> int: Returns the number of '1's in the binary representation of \`n\`. return bin(n).count('1')","solution":"def number_of_ones(n: int) -> int: Returns the number of '1's in the binary representation of n. # Use bin() to get the binary representation of n and count '1's return bin(n).count('1')"},{"question":"# Triangle Area Calculation Function Context The area of a triangle can be calculated using various methods based on the data provided. Common methods include using the base and height, or using the lengths of all three sides with Heron's formula. This problem requires a function to compute the area of a triangle given either the base and height or all three sides of the triangle. Function Signature def compute_triangle_area( base: float = None, height: float = None, side1: float = None, side2: float = None, side3: float = None ) -> float: Computes the area of a triangle using either the base and height or the lengths of all three sides. Args: - base (float, optional): The base length of the triangle. - height (float, optional): The height of the triangle from the base. - side1 (float, optional): The length of the first side of the triangle. - side2 (float, optional): The length of the second side of the triangle. - side3 (float, optional): The length of the third side of the triangle. Returns: - float: The area of the triangle. Raises: - ValueError: If any parameter is provided with a non-positive value. - ValueError: If an inappropriate combination or number of parameters is provided. - ValueError: If the sides provided do not form a valid triangle according to the triangle inequality theorem. import math # Validate input if (base is not None and height is not None) and (side1 is not None or side2 is not None or side3 is not None): raise ValueError(\\"Provide either base and height or all three sides, not both.\\") if base is not None and height is not None: if base <= 0 or height <= 0: raise ValueError(\\"All dimension values must be positive\\") return 0.5 * base * height if side1 is not None and side2 is not None and side3 is not None: if side1 <= 0 or side2 <= 0 or side3 <= 0: raise ValueError(\\"All dimension values must be positive\\") if side1 + side2 <= side3 or side1 + side3 <= side2 or side2 + side3 <= side1: raise ValueError(\\"The provided side lengths do not form a valid triangle\\") s = (side1 + side2 + side3) / 2 area = math.sqrt(s * (s - side1) * (s - side2) * (s - side3)) return area raise ValueError(\\"Provide either base and height or all three sides.\\") # Examples (for testing) print(compute_triangle_area(base=10, height=5)) # 25.0 print(compute_triangle_area(side1=3, side2=4, side3=5)) # 6.0 print(compute_triangle_area(base=10, height=-5)) # ValueError: All dimension values must be positive print(compute_triangle_area(side1=1, side2=2, side3=10)) # ValueError: The provided side lengths do not form a valid triangle print(compute_triangle_area(base=10, height=5, side1=3, side2=4, side3=5)) # ValueError: Provide either base and height or all three sides, not both","solution":"import math def compute_triangle_area( base: float = None, height: float = None, side1: float = None, side2: float = None, side3: float = None ) -> float: # Validate input if (base is not None and height is not None) and (side1 is not None or side2 is not None or side3 is not None): raise ValueError(\\"Provide either base and height or all three sides, not both.\\") if base is not None and height is not None: if base <= 0 or height <= 0: raise ValueError(\\"All dimension values must be positive\\") return 0.5 * base * height if side1 is not None and side2 is not None and side3 is not None: if side1 <= 0 or side2 <= 0 or side3 <= 0: raise ValueError(\\"All dimension values must be positive\\") if side1 + side2 <= side3 or side1 + side3 <= side2 or side2 + side3 <= side1: raise ValueError(\\"The provided side lengths do not form a valid triangle\\") s = (side1 + side2 + side3) / 2 area = math.sqrt(s * (s - side1) * (s - side2) * (s - side3)) return area raise ValueError(\\"Provide either base and height or all three sides.\\")"},{"question":"Define a class \`Queue\` that supports the following methods: - \`__init__(self) -> None\`: Initialize your queue class. No input parameters; no return value. - \`enqueue(self, element: int) -> None\`: Add an element to the end of the queue. Takes an integer \`element\` to be added to the queue; no return value. - \`dequeue(self) -> int\`: Remove and return the element from the front of the queue. If the queue is empty, raise an \`IndexError\` with the message \\"Queue is empty\\". Returns the integer that was removed from the front of the queue. - \`peek(self) -> int\`: Return the element at the front of the queue without removing it. If the queue is empty, raise an \`IndexError\` with the message \\"Queue is empty\\". Returns the integer at the front of the queue. - \`is_empty(self) -> bool\`: Check if the queue is empty. No input parameters; returns a boolean value \`True\` if the queue is empty, \`False\` otherwise. # Examples # Example for initializing and basic operations q = Queue() q.enqueue(1) q.enqueue(2) assert q.peek() == 1 assert q.dequeue() == 1 assert q.peek() == 2 assert q.is_empty() == False assert q.dequeue() == 2 assert q.is_empty() == True # Example for handling empty queue case empty_q = Queue() try: empty_q.dequeue() except IndexError as e: assert str(e) == \\"Queue is empty\\" try: empty_q.peek() except IndexError as e: assert str(e) == \\"Queue is empty\\"","solution":"class Queue: def __init__(self): self._queue = [] def enqueue(self, element: int) -> None: self._queue.append(element) def dequeue(self) -> int: if self.is_empty(): raise IndexError(\\"Queue is empty\\") return self._queue.pop(0) def peek(self) -> int: if self.is_empty(): raise IndexError(\\"Queue is empty\\") return self._queue[0] def is_empty(self) -> bool: return len(self._queue) == 0"},{"question":"class ListNode: def __init__(self, x): self.val = x self.next = None def remove_duplicates(head: Optional[ListNode]) -> Optional[ListNode]: Remove duplicates from a linked list but retain one instance of each value and preserve the original order of their first occurrences. >>> convert_linkedlist_to_list(remove_duplicates(convert_list_to_linkedlist([1, 3, 3, 2, 2, 1, 4]))) [1, 3, 2, 4] >>> convert_linkedlist_to_list(remove_duplicates(convert_list_to_linkedlist([1, 2, 3, 4]))) [1, 2, 3, 4] >>> convert_linkedlist_to_list(remove_duplicates(convert_list_to_linkedlist([1, 1, 1, 1]))) [1] >>> convert_linkedlist_to_list(remove_duplicates(convert_list_to_linkedlist([]))) [] >>> convert_linkedlist_to_list(remove_duplicates(convert_list_to_linkedlist([1]))) [1] def convert_list_to_linkedlist(elements): if not elements: return None head = ListNode(elements[0]) current = head for element in elements[1:]: current.next = ListNode(element) current = current.next return head def convert_linkedlist_to_list(head): elements = [] while head: elements.append(head.val) head = head.next return elements","solution":"class ListNode: def __init__(self, x): self.val = x self.next = None def remove_duplicates(head: ListNode) -> ListNode: if not head: return None seen = set() current = head seen.add(current.val) while current and current.next: if current.next.val in seen: current.next = current.next.next else: seen.add(current.next.val) current = current.next return head"},{"question":"def nth_fibonacci(n: int) -> int: This function takes an integer n and returns the nth number in the Fibonacci sequence. :param n: An integer representing the position in the Fibonacci sequence. :return: An integer representing the nth Fibonacci number. >>> nth_fibonacci(0) 0 >>> nth_fibonacci(1) 1 >>> nth_fibonacci(20) 6765 >>> nth_fibonacci(100) 354224848179261915075 from solution import nth_fibonacci def test_nth_fibonacci_zero(): assert nth_fibonacci(0) == 0 def test_nth_fibonacci_one(): assert nth_fibonacci(1) == 1 def test_nth_fibonacci_small_number(): assert nth_fibonacci(5) == 5 def test_nth_fibonacci_medium_number(): assert nth_fibonacci(15) == 610 def test_nth_fibonacci_large_number(): assert nth_fibonacci(100) == 354224848179261915075 def test_nth_fibonacci_very_large_number(): # This is just a check to ensure the function can handle large inputs without crashing # We won't validate the exact number due to the sheer size result = nth_fibonacci(10000) assert result > 0 def test_invalid_input_negative(): try: nth_fibonacci(-1) except ValueError as e: assert str(e) == \\"Input should be a non-negative integer.\\"","solution":"def nth_fibonacci(n: int) -> int: Returns the nth Fibonacci number. :param n: An integer representing the position in the Fibonacci sequence. :return: An integer representing the nth Fibonacci number. if n < 0: raise ValueError(\\"Input should be a non-negative integer.\\") if n == 0: return 0 elif n == 1: return 1 a, b = 0, 1 for _ in range(2, n + 1): a, b = b, a + b return b"},{"question":"def rotate_list(nums: list[int], k: int) -> list[int]: Rotates the list nums to the right by k steps. :param nums: list of integers to be rotated :param k: number of steps to rotate :return: rotated list >>> rotate_list([1, 2, 3, 4, 5, 6, 7], 3) [5, 6, 7, 1, 2, 3, 4] >>> rotate_list([1, 2, 3], 1) [3, 1, 2] >>> rotate_list([1, 2, 3], 4) [3, 1, 2] def sum_of_divisibles(rotated_list: list[int], d: int) -> int: Returns the sum of all elements in the rotated_list that are divisible by d. :param rotated_list: list of rotated integers :param d: integer divisor :return: sum of elements divisible by d >>> sum_of_divisibles([5, 6, 7, 1, 2, 3, 4], 2) 12 >>> sum_of_divisibles([10, 20, 30], 5) 60 >>> sum_of_divisibles([1, 3, 5, 7], 2) 0","solution":"def rotate_list(nums, k): Rotates the list nums to the right by k steps. :param nums: List[int] - list of integers to be rotated :param k: int - number of steps to rotate :return: List[int] - rotated list n = len(nums) k = k % n # To handle cases where k is greater than the length of the list return nums[-k:] + nums[:-k] def sum_of_divisibles(rotated_list, d): Returns the sum of all elements in the rotated_list that are divisible by d. :param rotated_list: List[int] - list of rotated integers :param d: int - integer divisor :return: int - sum of elements divisible by d return sum(x for x in rotated_list if x % d == 0)"},{"question":"from typing import List import threading def worker(A, B, result, row, col): Worker function to compute a single element of the result matrix. Parameters: A (List[List[int]]): The first matrix. B (List[List[int]]): The second matrix. result (List[List[int]]): The resulting matrix to store the product. row (int): Row index for the element to compute. col (int): Column index for the element to compute. result[row][col] = sum(A[row][k] * B[k][col] for k in range(len(A[row]))) def multi_threaded_matrix_multiplication(A: List[List[int]], B: List[List[int]]) -> List[List[int]]: Multiplies two matrices using multi-threading. Parameters: A (List[List[int]]): The first matrix, where each sublist is a row. B (List[List[int]]): The second matrix, where each sublist is a row. It is guaranteed that the number of columns in A equals the number of rows in B. Returns: List[List[int]]: The resulting matrix product. M = len(A) K = len(A[0]) N = len(B[0]) result = [[0] * N for _ in range(M)] threads = [] for i in range(M): for j in range(N): thread = threading.Thread(target=worker, args=(A, B, result, i, j)) threads.append(thread) thread.start() for thread in threads: thread.join() return result # Unit tests def test_matrix_multiplication_2x2(): A = [ [1, 2], [3, 4] ] B = [ [5, 6], [7, 8] ] result = multi_threaded_matrix_multiplication(A, B) expected = [ [19, 22], [43, 50] ] assert result == expected def test_matrix_multiplication_1x1(): A = [[2]] B = [[3]] result = multi_threaded_matrix_multiplication(A, B) expected = [[6]] assert result == expected def test_matrix_multiplication_single_row_col(): A = [[1, 2, 3]] B = [ [4], [5], [6] ] result = multi_threaded_matrix_multiplication(A, B) expected = [[32]] assert result == expected def test_matrix_multiplication_larger_matrices(): A = [ [1, 2, 3], [4, 5, 6] ] B = [ [7, 8], [9, 10], [11, 12] ] result = multi_threaded_matrix_multiplication(A, B) expected = [ [58, 64], [139, 154] ] assert result == expected def test_matrix_multiplication_identity_matrix(): A = [ [1, 0], [0, 1] ] B = [ [5, 6], [7, 8] ] result = multi_threaded_matrix_multiplication(A, B) expected = [ [5, 6], [7, 8] ] assert result == expected","solution":"from typing import List import threading def worker(A, B, result, row, col): result[row][col] = sum(A[row][k] * B[k][col] for k in range(len(A[row]))) def multi_threaded_matrix_multiplication(A: List[List[int]], B: List[List[int]]) -> List[List[int]]: M = len(A) K = len(A[0]) N = len(B[0]) result = [[0] * N for _ in range(M)] threads = [] for i in range(M): for j in range(N): thread = threading.Thread(target=worker, args=(A, B, result, i, j)) threads.append(thread) thread.start() for thread in threads: thread.join() return result"},{"question":"from typing import List def assign_trainer(customer_slots: List[str], trainer_slots: List[str]) -> str: Match a customer with a trainer based on their availability. :param customer_slots: A list of time slots the customer is available (in \\"HH:MM-HH:MM\\" format). :param trainer_slots: A list of time slots the trainer is available (in \\"HH:MM-HH:MM\\" format). :return: The matching time slot (in \\"HH:MM-HH:MM\\" format) if there is a common slot. Return \\"No Slot Available\\" if there is no common slot. pass def test_no_common_slots(): assert assign_trainer([\\"08:00-09:00\\", \\"10:00-11:00\\"], [\\"11:00-12:00\\", \\"12:00-13:00\\"]) == \\"No Slot Available\\" def test_exact_matching_slots(): assert assign_trainer([\\"15:00-16:00\\"], [\\"15:00-16:00\\"]) == \\"15:00-16:00\\" def test_first_common_slot(): assert assign_trainer([\\"08:30-09:30\\", \\"10:00-11:00\\"], [\\"08:30-09:30\\", \\"11:00-12:00\\"]) == \\"08:30-09:30\\" def test_no_common_slots_with_gap(): assert assign_trainer([\\"09:15-10:15\\"], [\\"10:00-11:00\\"]) == \\"No Slot Available\\" def test_first_common_slot_different_slots(): assert assign_trainer([\\"09:00-10:00\\", \\"11:00-12:00\\"], [\\"10:00-11:00\\", \\"11:00-12:00\\"]) == \\"11:00-12:00\\" def test_multiple_matching_slots(): assert assign_trainer([\\"09:00-10:00\\", \\"11:00-12:00\\", \\"14:00-15:00\\"], [\\"11:00-12:00\\", \\"14:00-15:00\\"]) == \\"11:00-12:00\\"","solution":"from typing import List def assign_trainer(customer_slots: List[str], trainer_slots: List[str]) -> str: Match a customer with a trainer based on their availability. :param customer_slots: A list of time slots the customer is available (in \\"HH:MM-HH:MM\\" format). :param trainer_slots: A list of time slots the trainer is available (in \\"HH:MM-HH:MM\\" format). :return: The matching time slot (in \\"HH:MM-HH:MM\\" format) if there is a common slot. Return \\"No Slot Available\\" if there is no common slot. customer_set = set(customer_slots) trainer_set = set(trainer_slots) common_slots = customer_set.intersection(trainer_set) if common_slots: return sorted(common_slots)[0] else: return \\"No Slot Available\\""},{"question":"from typing import List def max_skyline_area(arr: List[int]) -> int: Given a list of integers arr representing the heights of buildings, returns the maximum possible area of a rectangle formed by the buildings' heights in a continuous subarray. >>> max_skyline_area([2, 1, 5, 6, 2, 3]) == 10 >>> max_skyline_area([0, 3, 5, 0, 0, 5, 6, 0, 4]) == 10 pass def test_max_skyline_area(): assert max_skyline_area([2, 1, 5, 6, 2, 3]) == 10 assert max_skyline_area([0, 3, 5, 0, 0, 5, 6, 0, 4]) == 10 assert max_skyline_area([4, 100, 1, 2, 3, 99]) == 100 assert max_skyline_area([2, 4]) == 4 assert max_skyline_area([4, 2, 0]) == 4 assert max_skyline_area([0, 0, 0]) == 0 assert max_skyline_area([1]) == 1 assert max_skyline_area([]) == 0 if __name__ == \\"__main__\\": test_max_skyline_area()","solution":"from typing import List def max_skyline_area(arr: List[int]) -> int: stack = [] max_area = 0 index = 0 while index < len(arr): if not stack or arr[stack[-1]] <= arr[index]: stack.append(index) index += 1 else: top_of_stack = stack.pop() if stack: area = arr[top_of_stack] * (index - stack[-1] - 1) else: area = arr[top_of_stack] * index max_area = max(max_area, area) while stack: top_of_stack = stack.pop() if stack: area = arr[top_of_stack] * (index - stack[-1] - 1) else: area = arr[top_of_stack] * index max_area = max(max_area, area) return max_area"},{"question":"from typing import List def rotate_90(A: List[List[int]]) -> List[List[int]]: Rotates the matrix A by 90 degrees clockwise. def is_rotation_matrix(A: List[List[int]], B: List[List[int]]) -> bool: Determine if matrix B can be obtained by rotating matrix A by 90, 180, or 270 degrees. >>> A = [ ... [1, 2], ... [3, 4] ... ] >>> B = [ ... [3, 1], ... [4, 2] ... ] >>> is_rotation_matrix(A, B) True >>> A = [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ] >>> B = [ ... [9, 8, 7], ... [6, 5, 4], ... [3, 2, 1] ... ] >>> is_rotation_matrix(A, B) True >>> A = [ ... [1, 2], ... [3, 4] ... ] >>> B = [ ... [1, 2], ... [3, 4] ... ] >>> is_rotation_matrix(A, B) False >>> A = [ ... [1, 2], ... [3, 4] ... ] >>> B = [ ... [2, 1], ... [4, 3] ... ] >>> is_rotation_matrix(A, B) False","solution":"from typing import List def rotate_90(A: List[List[int]]) -> List[List[int]]: Rotates the matrix A by 90 degrees clockwise. n = len(A) return [[A[n - j - 1][i] for j in range(n)] for i in range(n)] def is_rotation_matrix(A: List[List[int]], B: List[List[int]]) -> bool: Returns True if matrix B is a rotation of matrix A by 90, 180, or 270 degrees. if A == B: return False rotated_90 = rotate_90(A) rotated_180 = rotate_90(rotated_90) rotated_270 = rotate_90(rotated_180) return B == rotated_90 or B == rotated_180 or B == rotated_270"},{"question":"from typing import List, Tuple def validate_and_categorize_orders(order_refs: List[str]) -> List[Tuple[str, str]]: Validates and categorizes each order reference. :param order_refs: List of strings, each being an order reference. :return: List of tuples, each containing the order reference and its category. >>> validate_and_categorize_orders([\\"ABCD1234\\", \\"ZZZZ9999\\", \\"INVALID12\\", \\"AAAA1111\\"]) [(\\"ABCD1234\\", \\"Low Value\\"), (\\"ZZZZ9999\\", \\"High Value\\"), (\\"AAAA1111\\", \\"Low Value\\")] >>> validate_and_categorize_orders([\\"A1B2C3D4\\", \\"XXXX5678\\"]) [(\\"A1B2C3D4\\", \\"Low Value\\"), (\\"XXXX5678\\", \\"High Value\\")] pass","solution":"import re from typing import List, Tuple def validate_and_categorize_orders(order_refs: List[str]) -> List[Tuple[str, str]]: Validates and categorizes each order reference. :param order_refs: List of strings, each being an order reference. :return: List of tuples, each containing the order reference and its category. result = [] pattern = re.compile(r'^[A-Z]{4}d{4}') for order in order_refs: if pattern.match(order): digits_sum = sum(int(digit) for digit in order[4:]) category = \\"High Value\\" if digits_sum >= 25 else \\"Low Value\\" result.append((order, category)) else: # If order ID does not match the pattern, we can ignore it. # This can be altered if invalid orders also need to be handled. continue return result"},{"question":"def generate_fibonacci_series(n: int) -> list: Generates the first n numbers in the Fibonacci sequence. Parameters: - n (int): The number of terms in the Fibonacci sequence to generate. Returns: - list: A list containing the first n numbers of the Fibonacci sequence. >>> generate_fibonacci_series(0) [] >>> generate_fibonacci_series(1) [0] >>> generate_fibonacci_series(2) [0, 1] >>> generate_fibonacci_series(5) [0, 1, 1, 2, 3] >>> generate_fibonacci_series(10) [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]","solution":"def generate_fibonacci_series(n: int) -> list: Generates the first n numbers in the Fibonacci sequence. Parameters: - n (int): The number of terms in the Fibonacci sequence to generate. Returns: - list: A list containing the first n numbers of the Fibonacci sequence. if n <= 0: return [] fibonacci_series = [0] # Initializing the first number of the series if n == 1: return fibonacci_series fibonacci_series.append(1) # Adding the second number of the series for i in range(2, n): next_value = fibonacci_series[-1] + fibonacci_series[-2] fibonacci_series.append(next_value) return fibonacci_series"},{"question":"def print_directory(directory: dict, indent: int = 0) -> None: Print the directory structure in a readable format. Each folder and file is displayed on a new line with a specific indentation level to denote its depth. Args: directory (dict): A dictionary representing the directory structure. indent (int): The current indentation level (default is 0). Example: >>> directory_structure = { ... \\"folder1\\": { ... \\"subfolder1\\": [\\"file1.txt\\", \\"file2.txt\\"], ... \\"subfolder2\\": { ... \\"subsubfolder1\\": [\\"file3.txt\\"] ... }, ... }, ... \\"folder2\\": [\\"file4.txt\\"], ... \\"file5.txt\\": [] ... } >>> print_directory(directory_structure) folder1/ subfolder1/ file1.txt file2.txt subfolder2/ subsubfolder1/ file3.txt folder2/ file4.txt file5.txt/ Test Cases: def test_print_directory_basic(capfd): simple_directory = { \\"folder1\\": { \\"file1.txt\\": [], \\"file2.txt\\": [] }, \\"file3.txt\\": [] } print_directory(simple_directory) out, err = capfd.readouterr() expected_output = folder1/ file1.txt/ file2.txt/ file3.txt/ assert out == expected_output def test_print_directory_nested(capfd): nested_directory = { \\"folder1\\": { \\"subfolder1\\": [\\"file1.txt\\", \\"file2.txt\\"], \\"subfolder2\\": { \\"subsubfolder1\\": [\\"file3.txt\\"] }, }, \\"folder2\\": [\\"file4.txt\\"], \\"file5.txt\\": [] } print_directory(nested_directory) out, err = capfd.readouterr() expected_output = folder1/ subfolder1/ file1.txt file2.txt subfolder2/ subsubfolder1/ file3.txt folder2/ file4.txt file5.txt/ assert out == expected_output def test_print_directory_empty_folder(capfd): empty_folder_directory = { \\"folder1\\": {}, \\"folder2\\": [\\"file1.txt\\"] } print_directory(empty_folder_directory) out, err = capfd.readouterr() expected_output = folder1/ folder2/ file1.txt assert out == expected_output def test_print_directory_single_file(capfd): single_file_directory = { \\"file1.txt\\": [] } print_directory(single_file_directory) out, err = capfd.readouterr() expected_output = file1.txt/ assert out == expected_output def test_print_directory_empty(capfd): empty_directory = {} print_directory(empty_directory) out, err = capfd.readouterr() expected_output = \\"\\" assert out == expected_output","solution":"def print_directory(directory: dict, indent: int = 0) -> None: for key, value in directory.items(): if isinstance(value, dict): # Print folder names with a trailing slash and apply indentation print(\\" \\" * indent + key + \\"/\\") # Recursively print the contents of the folder print_directory(value, indent + 2) elif isinstance(value, list): if value: # For folders with files, print folder name with a trailing slash and apply indentation print(\\" \\" * indent + key + \\"/\\") for item in value: # Print each file with increased indentation print(\\" \\" * (indent + 2) + item) else: # For empty folders, just print the folder name with a trailing slash print(\\" \\" * indent + key + \\"/\\")"},{"question":"def longest_zero_sum_subarray(array: list) -> int: Find the length of the longest subarray with a sum of zero. >>> longest_zero_sum_subarray([]) == 0 True >>> longest_zero_sum_subarray([4, 2, -3, 1, 6]) == 3 True >>> longest_zero_sum_subarray([1, 2, 3]) == 0 True >>> longest_zero_sum_subarray([1, -1, 3, -3, 4]) == 4 True >>> longest_zero_sum_subarray([-1, 1, 1, -1, -1, 1]) == 6 True pass def test_longest_zero_sum_subarray(): assert longest_zero_sum_subarray([]) == 0 assert longest_zero_sum_subarray([1, 2, 3]) == 0 assert longest_zero_sum_subarray([0]) == 1 assert longest_zero_sum_subarray([1]) == 0 assert longest_zero_sum_subarray([4, 2, -3, 1, 6]) == 3 assert longest_zero_sum_subarray([1, 2, 3, -6, 3]) == 4 assert longest_zero_sum_subarray([1, -1, 3, -3, 4]) == 4 assert longest_zero_sum_subarray([1, -1, 1, -1, 1, -1]) == 6 large_array = [i for i in range(1, 10001)] + [-sum(range(1, 10001))] assert longest_zero_sum_subarray(large_array) == 10001","solution":"def longest_zero_sum_subarray(array: list) -> int: prefix_sum = 0 sum_indices = {0: -1} max_len = 0 for idx, value in enumerate(array): prefix_sum += value if prefix_sum in sum_indices: max_len = max(max_len, idx - sum_indices[prefix_sum]) else: sum_indices[prefix_sum] = idx return max_len"},{"question":"def flatten_dictionary(nested_dict: dict) -> dict: Flattens a nested dictionary into a single-level dictionary. Args: - nested_dict (dict): A dictionary which may contain nested dictionaries. Returns: - dict: A flattened dictionary with concatenated keys. Example: >>> flatten_dictionary({ \\"a\\": 1, \\"b\\": { \\"c\\": 2, \\"d\\": { \\"e\\": 3, \\"f\\": 4 } } }) == { \\"a\\": 1, \\"b.c\\": 2, \\"b.d.e\\": 3, \\"b.d.f\\": 4 } >>> flatten_dictionary({ \\"x\\": 10, \\"y\\": { \\"z\\": 20, \\"w\\": { \\"v\\": 30 } }, \\"u\\": { \\"t\\": 40 } }) == { \\"x\\": 10, \\"y.z\\": 20, \\"y.w.v\\": 30, \\"u.t\\": 40 }","solution":"def flatten_dictionary(nested_dict: dict) -> dict: def flatten(current_dict, parent_key=''): items = [] for key, value in current_dict.items(): new_key = parent_key + '.' + key if parent_key else key if isinstance(value, dict): items.extend(flatten(value, new_key).items()) else: items.append((new_key, value)) return dict(items) return flatten(nested_dict)"},{"question":"MORSE_CODE_DICT = { \\".-\\": \\"A\\", \\"-...\\": \\"B\\", \\"-.-.\\": \\"C\\", \\"-..\\": \\"D\\", \\".\\": \\"E\\", \\"..-.\\": \\"F\\", \\"--.\\": \\"G\\", \\"....\\": \\"H\\", \\"..\\": \\"I\\", \\".---\\": \\"J\\", \\"-.-\\": \\"K\\", \\".-..\\": \\"L\\", \\"--\\": \\"M\\", \\"-.\\": \\"N\\", \\"---\\": \\"O\\", \\".--.\\": \\"P\\", \\"--.-\\": \\"Q\\", \\".-.\\": \\"R\\", \\"...\\": \\"S\\", \\"-\\": \\"T\\", \\"..-\\": \\"U\\", \\"...-\\": \\"V\\", \\".--\\": \\"W\\", \\"-..-\\": \\"X\\", \\"-.--\\": \\"Y\\", \\"--..\\": \\"Z\\" } def morse_to_text(morse_code: str) -> str: Translate a given Morse code string into its corresponding English text. :param morse_code: A string that represents a sentence in Morse code, with individual Morse letters separated by spaces and words separated by slashes ('/'). :return: The decoded English sentence as a string. Example: >>> morse_to_text(\\".... . .-.. .-.. --- / .-- --- .-. .-.. -..\\") 'HELLO WORLD' >>> morse_to_text(\\"- .... .. ... / .. ... / .- / - . ... -\\") 'THIS IS A TEST' >>> morse_to_text(\\"--. --- --- -.. / -- --- .-. -. .. -. --.\\") 'GOOD MORNING'","solution":"MORSE_CODE_DICT = { \\".-\\": \\"A\\", \\"-...\\": \\"B\\", \\"-.-.\\": \\"C\\", \\"-..\\": \\"D\\", \\".\\": \\"E\\", \\"..-.\\": \\"F\\", \\"--.\\": \\"G\\", \\"....\\": \\"H\\", \\"..\\": \\"I\\", \\".---\\": \\"J\\", \\"-.-\\": \\"K\\", \\".-..\\": \\"L\\", \\"--\\": \\"M\\", \\"-.\\": \\"N\\", \\"---\\": \\"O\\", \\".--.\\": \\"P\\", \\"--.-\\": \\"Q\\", \\".-.\\": \\"R\\", \\"...\\": \\"S\\", \\"-\\": \\"T\\", \\"..-\\": \\"U\\", \\"...-\\": \\"V\\", \\".--\\": \\"W\\", \\"-..-\\": \\"X\\", \\"-.--\\": \\"Y\\", \\"--..\\": \\"Z\\" } def morse_to_text(morse_code: str) -> str: words = morse_code.strip().split(' / ') decoded_sentence = [] for word in words: letters = word.split() decoded_word = ''.join(MORSE_CODE_DICT.get(letter, '') for letter in letters) decoded_sentence.append(decoded_word) return ' '.join(decoded_sentence)"},{"question":"import pandas as pd import matplotlib.pyplot as plt def analyze_sales_data(file_path: str) -> dict: Load sales data from a CSV, compute sales analysis, and create a bar plot. Args: file_path (str): Path to the CSV file containing sales data. Returns: dict: A dictionary containing: - 'total_sales_per_product' (dict): Total sales for each product across all stores. - 'top_selling_store' (str): The store with the highest total sales. - 'chart' (plt.Figure): Matplotlib figure object representing the bar plot of total sales per product. Example usage: >>> result = analyze_sales_data('sales_data.csv') >>> result['total_sales_per_product'] {'Product A': 15000.0, 'Product B': 12000.0, ...} >>> result['top_selling_store'] 'Store 1' import pandas as pd import matplotlib.pyplot as plt from solution import analyze_sales_data # Create a temporary CSV file for testing purposes def create_test_csv(content: str, file_name: str): with open(file_name, 'w') as file: file.write(content) def test_analyze_sales_data(): # Create CSV files for testing test_csv_content = date,store,product,quantity,price 2023-01-01,Store 1,Product A,10,50.0 2023-01-02,Store 1,Product B,5,30.0 2023-01-03,Store 2,Product A,7,55.0 2023-01-04,Store 3,Product C,20,10.0 create_test_csv(test_csv_content, \\"test_sales_data.csv\\") result = analyze_sales_data(\\"test_sales_data.csv\\") assert result[\\"total_sales_per_product\\"] == { \\"Product A\\": 10*50.0 + 7*55.0, \\"Product B\\": 5*30.0, \\"Product C\\": 20*10.0 } assert result[\\"top_selling_store\\"] == \\"Store 1\\" # Store 1 has highest total sales chart = result[\\"chart\\"] assert isinstance(chart, plt.Figure) # Ensure chart is a Matplotlib figure def test_file_not_found(): result = analyze_sales_data(\\"non_existent_file.csv\\") assert result == {} def test_empty_file(): create_test_csv(\\"\\", \\"empty_sales_data.csv\\") result = analyze_sales_data(\\"empty_sales_data.csv\\") assert result == {} def test_invalid_data(): invalid_csv_content = date,store,product,quantity,price 2023-01-01,Store 1,Product A,ten,50.0 create_test_csv(invalid_csv_content, \\"invalid_sales_data.csv\\") result = analyze_sales_data(\\"invalid_sales_data.csv\\") assert result == {} # Deleting the test CSV files after tests import os def teardown_module(module): os.remove(\\"test_sales_data.csv\\") os.remove(\\"empty_sales_data.csv\\") os.remove(\\"invalid_sales_data.csv\\")","solution":"import pandas as pd import matplotlib.pyplot as plt def analyze_sales_data(file_path: str) -> dict: try: # Load data from CSV file data = pd.read_csv(file_path) # Compute total sales for each product across all stores data['total_price'] = data['quantity'] * data['price'] total_sales_per_product = data.groupby('product')['total_price'].sum().to_dict() # Identify the store with the highest total sales total_sales_per_store = data.groupby('store')['total_price'].sum() top_selling_store = total_sales_per_store.idxmax() # Create a bar plot showing the total sales for each product plt.figure(figsize=(10, 6)) plt.bar(total_sales_per_product.keys(), total_sales_per_product.values()) plt.xlabel('Product') plt.ylabel('Total Sales') plt.title('Total Sales for Each Product') plt.xticks(rotation=45) plt.tight_layout() chart = plt.gcf() # Get current figure # Return results in the specified format return { \\"total_sales_per_product\\": total_sales_per_product, \\"top_selling_store\\": top_selling_store, \\"chart\\": chart } except FileNotFoundError: print(f\\"Error: The file {file_path} does not exist.\\") return {} except pd.errors.EmptyDataError: print(f\\"Error: The file {file_path} is empty.\\") return {} except Exception as e: print(f\\"An error occurred: {e}\\") return {}"},{"question":"import numpy as np from typing import List class EnhancedKNN: def __init__(self, n_neighbors=5, metric='euclidean'): self.n_neighbors = n_neighbors self.metric = metric self.data = None self.targets = None def fit(self, x: np.ndarray, y: np.ndarray): Stores the training data and target values. self.data = x self.targets = y def predict_weighted(self, x: np.ndarray) -> np.ndarray: Predicts the target value for an input point using weighted KNN for regression. >>> x_train = np.array([[10], [20], [30], [40], [50]]) >>> y_train = np.array([5, 10, 15, 20, 25]) >>> x_predict = np.array([[15]]) >>> knn = EnhancedKNN(n_neighbors=3, metric='euclidean') >>> knn.fit(x_train, y_train) >>> prediction = knn.predict_weighted(x_predict) >>> prediction.shape == (1,) True pass def _calculate_distance(self, point1: np.ndarray, point2: np.ndarray) -> float: Calculates distance between two points based on the selected metric. >>> point1 = np.array([0, 0]) >>> point2 = np.array([3, 4]) >>> knn = EnhancedKNN(metric='euclidean') >>> knn._calculate_distance(point1, point2) 5.0 >>> knn = EnhancedKNN(metric='manhattan') >>> knn._calculate_distance(point1, point2) 7.0 if self.metric == 'euclidean': return np.sqrt(np.sum((point1 - point2) ** 2)) elif self.metric == 'manhattan': return np.sum(np.abs(point1 - point2)) else: raise ValueError(\\"Unsupported metric\\")","solution":"import numpy as np class EnhancedKNN: def __init__(self, n_neighbors=5, metric='euclidean'): self.n_neighbors = n_neighbors self.metric = metric self.data = None self.targets = None def fit(self, x, y): # Store the training data and target values self.data = x self.targets = y def predict_weighted(self, x): predictions = [] for point in x: distances = [self._calculate_distance(point, train_point) for train_point in self.data] neighbors_idx = np.argsort(distances)[:self.n_neighbors] neighbors_distances = np.array(distances)[neighbors_idx] neighbors_targets = self.targets[neighbors_idx] # Avoid division by zero by replacing zero distances with a very small number neighbors_distances[neighbors_distances == 0] = 1e-5 # Using inverse distance as weights weights = 1 / neighbors_distances weighted_sum = np.sum(weights * neighbors_targets) sum_weights = np.sum(weights) weighted_average = weighted_sum / sum_weights predictions.append(weighted_average) return np.array(predictions) def _calculate_distance(self, point1, point2): # Private method to calculate distance based on the metric if self.metric == 'euclidean': return np.sqrt(np.sum((point1 - point2) ** 2)) elif self.metric == 'manhattan': return np.sum(np.abs(point1 - point2)) else: raise ValueError(\\"Unsupported metric\\")"},{"question":"def word_ladder_length(start: str, end: str, word_dict: set) -> int: Determine the minimum number of steps required to transform one word into another by changing one letter at a time, such that each intermediate word is a valid word in a given dictionary. >>> word_ladder_length(\\"hit\\", \\"cog\\", {\\"hot\\", \\"dot\\", \\"dog\\", \\"lot\\", \\"log\\", \\"cog\\"}) == 5 >>> word_ladder_length(\\"hit\\", \\"cog\\", {\\"hot\\", \\"dot\\", \\"dog\\", \\"lot\\", \\"log\\"}) == -1 >>> word_ladder_length(\\"hit\\", \\"hot\\", {\\"hot\\", \\"dot\\", \\"dog\\", \\"lot\\", \\"log\\"}) == 2 >>> word_ladder_length(\\"angel\\", \\"devil\\", {\\"angel\\", \\"angle\\", \\"anglo\\", \\"devel\\", \\"devil\\"}) == -1 >>> word_ladder_length(\\"same\\", \\"same\\", {\\"same\\", \\"lame\\", \\"lime\\", \\"time\\", \\"came\\"}) == 1","solution":"from collections import deque def word_ladder_length(start: str, end: str, word_dict: set) -> int: if end not in word_dict: return -1 word_dict.add(end) queue = deque([(start, 1)]) alphabet = 'abcdefghijklmnopqrstuvwxyz' while queue: current_word, steps = queue.popleft() if current_word == end: return steps for i in range(len(current_word)): prefix, suffix = current_word[:i], current_word[i+1:] for char in alphabet: if char != current_word[i]: next_word = prefix + char + suffix if next_word in word_dict: queue.append((next_word, steps + 1)) word_dict.remove(next_word) return -1"},{"question":"def diagonal_sum(mat: List[List[int]]) -> int: Compute the sum of elements on both the primary diagonal and the secondary diagonal of a square matrix. If an element is found on both diagonals, it should only be counted once. Parameters: mat (List[List[int]]): A square matrix of integers. Returns: int: The sum of the primary and secondary diagonal elements, with overlapping elements counted only once. Example: >>> diagonal_sum([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) 25 >>> diagonal_sum([[1, 2], [3, 4]]) 10 from solution import diagonal_sum def test_single_element_matrix(): assert diagonal_sum([[5]]) == 5 def test_odd_sized_matrix(): mat = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] assert diagonal_sum(mat) == 25 def test_even_sized_matrix(): mat = [ [1, 2], [3, 4] ] assert diagonal_sum(mat) == 10 def test_zero_matrix(): mat = [ [0, 0], [0, 0] ] assert diagonal_sum(mat) == 0 def test_negative_values_matrix(): mat = [ [-1, -2, -3], [-4, -5, -6], [-7, -8, -9] ] assert diagonal_sum(mat) == -25 def test_large_matrix(): mat = [ [1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16] ] assert diagonal_sum(mat) == 68","solution":"from typing import List def diagonal_sum(mat: List[List[int]]) -> int: n = len(mat) total_sum = 0 for i in range(n): total_sum += mat[i][i] # Primary diagonal total_sum += mat[i][n - 1 - i] # Secondary diagonal if n % 2 == 1: # Subtract the middle element which is added twice for odd n total_sum -= mat[n // 2][n // 2] return total_sum"},{"question":"def sum_of_diagonals(matrix: List[List[int]]) -> int: Calculate the sum of the main diagonal elements of a square matrix. >>> sum_of_diagonals([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) 15 >>> sum_of_diagonals([[10, 20], [30, 40]]) 50 >>> sum_of_diagonals([[0]]) 0","solution":"def sum_of_diagonals(matrix): Returns the sum of the main diagonal elements of a square matrix. Parameters: matrix (List[List[int]]): A square matrix represented as a list of lists Returns: int: The sum of the main diagonal elements return sum(matrix[i][i] for i in range(len(matrix)))"},{"question":"def matrix_multiply(A, B): Multiply two matrices A and B. Each matrix is represented as a list of lists. Parameters: A (list of lists of floats): The first matrix to multiply. B (list of lists of floats): The second matrix to multiply. Returns: list of lists of floats: The resulting matrix product. >>> matrix_multiply([[1, 2, 3], [4, 5, 6]], [[7, 8], [9, 10], [11, 12]]) [[58, 64], [139, 154]] >>> matrix_multiply([[1, 2], [3, 4]], [[1, 0], [0, 1]]) [[1, 2], [3, 4]] >>> matrix_multiply([[1, 2], [3, 4]], [[0, 0], [0, 0]]) [[0, 0], [0, 0]] >>> matrix_multiply([[2]], [[3]]) [[6]] >>> matrix_multiply([[1, 2]], [[3], [4]]) [[11]] >>> matrix_multiply([[1, 2, 3], [4, 5, 6], [7, 8, 9]], [[9, 8, 7], [6, 5, 4], [3, 2, 1]]) [[30, 24, 18], [84, 69, 54], [138, 114, 90]]","solution":"def matrix_multiply(A, B): Multiply two matrices A and B. Each matrix is represented as a list of lists. Parameters: A (list of lists of floats): The first matrix to multiply. B (list of lists of floats): The second matrix to multiply. Returns: list of lists of floats: The resulting matrix product. # Number of rows in A m = len(A) # Number of columns in A (also number of rows in B) n = len(A[0]) # Number of columns in B p = len(B[0]) # Initialize the resulting matrix with zeros result = [[0 for _ in range(p)] for _ in range(m)] # Perform matrix multiplication for i in range(m): for j in range(p): result[i][j] = sum(A[i][k] * B[k][j] for k in range(n)) return result"},{"question":"def flatten_json(nested_json: dict) -> dict: Flattens a nested JSON object to a simple dictionary with dot notations. >>> flatten_json({ \\"a\\": { \\"b\\": { \\"c\\": 1, \\"d\\": 2 }, \\"e\\": 3 }, \\"f\\": 4 }) { \\"a.b.c\\": 1, \\"a.b.d\\": 2, \\"a.e\\": 3, \\"f\\": 4 } >>> flatten_json({ \\"x\\": { \\"y\\": { \\"z\\": 5 }, \\"w\\": { \\"v\\": 6 } } }) { \\"x.y.z\\": 5, \\"x.w.v\\": 6 } def unflatten_json(flat_json: dict) -> dict: Converts a flat JSON object to its nested form. >>> unflatten_json({ \\"a.b.c\\": 1, \\"a.b.d\\": 2, \\"a.e\\": 3, \\"f\\": 4 }) { \\"a\\": { \\"b\\": { \\"c\\": 1, \\"d\\": 2 }, \\"e\\": 3 }, \\"f\\": 4 } >>> unflatten_json({ \\"x.y.z\\": 5, \\"x.w.v\\": 6 }) { \\"x\\": { \\"y\\": { \\"z\\": 5 }, \\"w\\": { \\"v\\": 6 } } }","solution":"def flatten_json(nested_json: dict, parent_key: str = '', sep: str = '.') -> dict: Flattens a nested JSON object to a simple dictionary with dot notations. Parameters: nested_json (dict): A dictionary representing the nested JSON object. parent_key (str): A string representing the base key. Used in recursion. sep (str): A string used to separate keys. Returns: dict: A dictionary representing the flattened JSON object. items = [] for k, v in nested_json.items(): new_key = f\\"{parent_key}{sep}{k}\\" if parent_key else k if isinstance(v, dict): items.extend(flatten_json(v, new_key, sep=sep).items()) else: items.append((new_key, v)) return dict(items) def unflatten_json(flat_json: dict, sep: str = '.') -> dict: Converts a flat JSON object to its nested form. Parameters: flat_json (dict): A dictionary representing the flattened JSON object. sep (str): A string used to separate keys in dot notation. Returns: dict: A dictionary representing the nested JSON object. nested_json = {} for k, v in flat_json.items(): parts = k.split(sep) d = nested_json for part in parts[:-1]: if part not in d: d[part] = {} d = d[part] d[parts[-1]] = v return nested_json"},{"question":"def effective_annual_rate(nominal_rate: float, periods_per_year: float) -> float: Computes the effective annual rate (EAR) for a given nominal annual interest rate compounded over a specified number of periods per year. Args: nominal_rate (float): The nominal annual interest rate expressed as a decimal. periods_per_year (float): The number of compounding periods per year. Returns: float: The effective annual rate. Raises: ValueError: If nominal_rate < 0 or periods_per_year <= 0. Example: >>> effective_annual_rate(0.05, 12) 0.05116189788173302 >>> effective_annual_rate(0.04, 4) 0.040604010000000086","solution":"def effective_annual_rate(nominal_rate: float, periods_per_year: float) -> float: Computes the effective annual rate (EAR) for a given nominal annual interest rate compounded over a specified number of periods per year. Args: nominal_rate (float): The nominal annual interest rate expressed as a decimal. periods_per_year (float): The number of compounding periods per year. Returns: float: The effective annual rate. Raises: ValueError: If nominal_rate < 0 or periods_per_year <= 0. if nominal_rate < 0: raise ValueError(\\"Nominal rate must be non-negative\\") if periods_per_year <= 0: raise ValueError(\\"Periods per year must be greater than zero\\") ear = (1 + nominal_rate / periods_per_year) ** periods_per_year - 1 return ear"},{"question":"from typing import List def can_reach_end(nums: List[int]) -> bool: Determine if you can reach the last index of the list. Parameters: nums (List[int]): A list of non-negative integers where each integer represents the number of steps you can move forward from that position. Returns: bool: True if you can reach the last index, False otherwise. >>> can_reach_end([2, 3, 1, 1, 4]) True >>> can_reach_end([3, 2, 1, 0, 4]) False pass def test_can_reach_end(): assert can_reach_end([2, 3, 1, 1, 4]) == True assert can_reach_end([3, 2, 1, 0, 4]) == False assert can_reach_end([0]) == True assert can_reach_end([0, 0, 0, 0]) == False assert can_reach_end([1, 1, 1, 1, 1]) == True assert can_reach_end([5, 1, 1, 0, 0, 4]) == True assert can_reach_end([0, 0, 0, 1000, 0]) == False assert can_reach_end([1, 0, 0, 0, 0]) == False assert can_reach_end([2, 0, 2, 0, 2]) == True if __name__ == \\"__main__\\": test_can_reach_end()","solution":"def can_reach_end(nums): Function to determine if you can reach the last index of the list. Parameters: nums (List[int]): A list of non-negative integers where each integer represents the number of steps you can move forward from that position. Returns: bool: True if you can reach the last index, False otherwise. max_reachable = 0 last_index = len(nums) - 1 for i, num in enumerate(nums): if i > max_reachable: break max_reachable = max(max_reachable, i + num) if max_reachable >= last_index: return True return False"},{"question":"class FileSystem: A simple file system that supports basic operations such as creating directories, adding content to files, and reading content from files. >>> fs = FileSystem() >>> fs.mkdir(\\"/a/b/c\\") >>> fs.addContentToFile(\\"/a/b/c/d\\", \\"hello\\") >>> fs.addContentToFile(\\"/a/b/c/e\\", \\"world\\") >>> fs.readContentFromFile(\\"/a/b/c/d\\") \\"hello\\" >>> fs.readContentFromFile(\\"/a/b/c/e\\") \\"world\\" def __init__(self): self.filesystem = {} def mkdir(self, path: str): pass def addContentToFile(self, filePath: str, content: str): pass def readContentFromFile(self, filePath: str) -> str: pass import pytest def test_mkdir(): fs = FileSystem() fs.mkdir(\\"/a\\") assert \\"a\\" in fs.filesystem fs.mkdir(\\"/a/b\\") assert \\"b\\" in fs.filesystem[\\"a\\"] def test_addContentToFile(): fs = FileSystem() fs.addContentToFile(\\"/a/b/c\\", \\"hello\\") assert fs.readContentFromFile(\\"/a/b/c\\") == \\"hello\\" def test_readContentFromFile_nonexistent_file(): fs = FileSystem() assert fs.readContentFromFile(\\"/nonexistent\\") == \\"\\" def test_readContentFromFile(): fs = FileSystem() fs.addContentToFile(\\"/file\\", \\"content\\") assert fs.readContentFromFile(\\"/file\\") == \\"content\\" def test_additional_content_to_file(): fs = FileSystem() fs.addContentToFile(\\"/file\\", \\"hello\\") fs.addContentToFile(\\"/file\\", \\" world\\") assert fs.readContentFromFile(\\"/file\\") == \\"hello world\\" def test_create_nested_directories(): fs = FileSystem() fs.mkdir(\\"/a/b/c\\") fs.addContentToFile(\\"/a/b/c/file\\", \\"data\\") assert fs.readContentFromFile(\\"/a/b/c/file\\") == \\"data\\"","solution":"class FileSystem: def __init__(self): self.filesystem = {} # Use a dictionary to manage the directory structure def mkdir(self, path: str): parts = path.strip('/').split('/') cur = self.filesystem for part in parts: if part not in cur: cur[part] = {} cur = cur[part] def addContentToFile(self, filePath: str, content: str): parts = filePath.strip('/').split('/') cur = self.filesystem for part in parts[:-1]: if part not in cur: cur[part] = {} cur = cur[part] if parts[-1] in cur: cur[parts[-1]] += content else: cur[parts[-1]] = content def readContentFromFile(self, filePath: str) -> str: parts = filePath.strip('/').split('/') cur = self.filesystem for part in parts: if part in cur: cur = cur[part] else: return \\"\\" return cur if isinstance(cur, str) else \\"\\""},{"question":"from typing import Callable def transform_image(image: list[list[int]], transform_function: Callable[[int], int]) -> None: Apply a transformation function to each pixel in the image grid. :param image: 2D list of integers representing pixel values of an image (0-255) :param transform_function: Function that takes an integer (pixel value) and returns a transformed integer >>> image = [ ... [255, 128, 64], ... [0, 64, 128], ... [64, 32, 16] ... ] >>> def invert(pixel): ... return 255 - pixel >>> transform_image(image, invert) >>> image [[0, 127, 191], [255, 191, 127], [191, 223, 239]]","solution":"from typing import Callable def transform_image(image: list[list[int]], transform_function: Callable[[int], int]) -> None: Apply transformation function to each pixel in the image grid in place. :param image: 2D list of integers representing pixel values of an image (0-255) :param transform_function: Function that takes an integer (pixel value) and returns a transformed integer for i in range(len(image)): for j in range(len(image[i])): image[i][j] = transform_function(image[i][j])"},{"question":"class FileSystem: Simulate a file system that supports creation of files and directories. - mkdir(path: str): Creates a directory at the given path. - create_file(path: str, content: str): Creates a file with the given content at the given path. - ls(path: str): Lists the contents of the directory at the given path. >>> fs = FileSystem() >>> fs.mkdir(\\"/a\\") >>> fs.mkdir(\\"/a/b\\") >>> fs.create_file(\\"/c.txt\\", \\"Hello, World!\\") >>> fs.create_file(\\"/a/b/d.txt\\", \\"Another file\\") >>> fs.ls(\\"/\\") == [\\"a\\", \\"c.txt\\"] True >>> fs.ls(\\"/a\\") == [\\"b\\"] True >>> fs.ls(\\"/a/b\\") == [\\"d.txt\\"] True >>> fs.ls(\\"/a/b/d.txt\\") == [] True def __init__(self): # Constructor to initialize the file system pass def mkdir(self, path: str): # Creates a directory at the given path pass def create_file(self, path: str, content: str): # Creates a file with the given content at the given path pass def ls(self, path: str): # Lists the contents of the directory at the given path pass # Test cases def test_filesystem(): fs = FileSystem() fs.mkdir(\\"/a\\") fs.mkdir(\\"/a/b\\") fs.create_file(\\"/c.txt\\", \\"Hello, World!\\") fs.create_file(\\"/a/b/d.txt\\", \\"Another file\\") assert fs.ls(\\"/\\") == [\\"a\\", \\"c.txt\\"] assert fs.ls(\\"/a\\") == [\\"b\\"] assert fs.ls(\\"/a/b\\") == [\\"d.txt\\"] assert fs.ls(\\"/a/b/d.txt\\") == [] def test_filesystem_empty_directory(): fs = FileSystem() fs.mkdir(\\"/a\\") fs.mkdir(\\"/a/b\\") assert fs.ls(\\"/\\") == [\\"a\\"] assert fs.ls(\\"/a\\") == [\\"b\\"] def test_filesystem_create_file_in_root(): fs = FileSystem() fs.create_file(\\"/file_in_root.txt\\", \\"Content in root file\\") assert fs.ls(\\"/\\") == [\\"file_in_root.txt\\"] def test_filesystem_non_existing_path(): fs = FileSystem() assert fs.ls(\\"/non_existing\\") == [] def test_filesystem_with_multiple_levels(): fs = FileSystem() fs.mkdir(\\"/a\\") fs.mkdir(\\"/a/b\\") fs.mkdir(\\"/a/b/c\\") fs.create_file(\\"/a/b/c/file.txt\\", \\"Nested file\\") assert fs.ls(\\"/\\") == [\\"a\\"] assert fs.ls(\\"/a\\") == [\\"b\\"] assert fs.ls(\\"/a/b\\") == [\\"c\\"] assert fs.ls(\\"/a/b/c\\") == [\\"file.txt\\"] def test_filesystem_overwrite_file(): fs = FileSystem() fs.create_file(\\"/overwrite.txt\\", \\"Original content\\") fs.create_file(\\"/overwrite.txt\\", \\"Updated content\\") assert fs.ls(\\"/\\") == [\\"overwrite.txt\\"]","solution":"class FileSystem: def __init__(self): self.fs = {\\"\\": {}} def mkdir(self, path: str): parts = path.strip(\\"/\\").split(\\"/\\") current = self.fs[\\"\\"] for part in parts: if part not in current: current[part] = {} current = current[part] def create_file(self, path: str, content: str): parts = path.strip(\\"/\\").split(\\"/\\") file_name = parts.pop() current = self.fs[\\"\\"] for part in parts: if part not in current: current[part] = {} current = current[part] current[file_name] = content def ls(self, path: str): if path == \\"/\\": current = self.fs[\\"\\"] else: parts = path.strip(\\"/\\").split(\\"/\\") current = self.fs[\\"\\"] for part in parts: if part in current: current = current[part] else: return [] if isinstance(current, dict): return sorted(current.keys()) return []"},{"question":"# **Dictionary Key Reversal Function** Complete the function \`reverse_dict_keys\` that takes a dictionary with string keys and integer values and returns a new dictionary with the keys and values swapped. Ensure to handle input type validation as described in the provided constraints. def reverse_dict_keys(dict_input: dict[str, int]) -> dict[int, str]: Returns a new dictionary with keys and values swapped from the input dictionary. Raises TypeError if keys are not strings or values are not integers. <|TODO|> Unit Test: from solution import reverse_dict_keys def test_reverse_dict_keys_regular_case(): assert reverse_dict_keys({\\"one\\": 1, \\"two\\": 2, \\"three\\": 3}) == {1: 'one', 2: 'two', 3: 'three'} def test_reverse_dict_keys_empty(): assert reverse_dict_keys({}) == {} def test_reverse_dict_keys_type_error_keys(): try: reverse_dict_keys({1: \\"one\\", 2: \\"two\\"}) except TypeError as e: assert str(e) == \\"All keys in dict_input must be strings\\" def test_reverse_dict_keys_type_error_values(): try: reverse_dict_keys({\\"one\\": \\"one\\", \\"two\\": 2}) except TypeError as e: assert str(e) == \\"All values in dict_input must be integers\\" def test_reverse_dict_keys_regular_case_2(): assert reverse_dict_keys({\\"apple\\": 10, \\"banana\\": 20, \\"cherry\\": 30}) == {10: 'apple', 20: 'banana', 30: 'cherry'} def test_reverse_dict_keys_duplicate_values(): try: reverse_dict_keys({\\"a\\": 1, \\"b\\": 2, \\"c\\": 2}) except ValueError as e: assert str(e) == \\"dict_input cannot have duplicate values\\"","solution":"def reverse_dict_keys(dict_input: dict[str, int]) -> dict[int, str]: Returns a new dictionary with keys and values swapped from the input dictionary. Raises TypeError if keys are not strings or values are not integers. if not all(isinstance(k, str) for k in dict_input.keys()): raise TypeError(\\"All keys in dict_input must be strings\\") if not all(isinstance(v, int) for v in dict_input.values()): raise TypeError(\\"All values in dict_input must be integers\\") return {v: k for k, v in dict_input.items()}"},{"question":"class ListNode: def __init__(self, key: int = 0, value: int = 0): self.key = key self.value = value self.prev = None self.next = None class LRUCache: def __init__(self, capacity: int): Initialize the LRU cache with a given capacity. Args: capacity: Maximum number of items the cache can hold. # Implementation details def get(self, key: int) -> int: Retrieve the value associated with the given key. Args: key: An integer key to retrieve the value. Returns: The value associated with the key, or -1 if the key does not exist. >>> cache = LRUCache(2) >>> cache.put(1, 1) >>> cache.put(2, 2) >>> cache.get(1) 1 >>> cache.get(3) -1 # To be implemented by students def put(self, key: int, value: int) -> None: Insert or update the value associated with the given key. Args: key: An integer key to insert or update. value: The value associated with the key. >>> cache = LRUCache(2) >>> cache.put(1, 1) >>> cache.put(2, 2) >>> cache.put(3, 3) >>> cache.get(2) -1 >>> cache.put(4, 4) >>> cache.get(1) -1 >>> cache.get(3) 3 # To be implemented by students # Unit tests def test_lru_cache_operations(): # Test 1: Basic Operations cache = LRUCache(2) cache.put(1, 1) cache.put(2, 2) assert cache.get(1) == 1 # returns 1 cache.put(3, 3) # evicts key 2 assert cache.get(2) == -1 # returns -1 (not found) cache.put(4, 4) # evicts key 1 assert cache.get(1) == -1 # returns -1 (not found) assert cache.get(3) == 3 # returns 3 assert cache.get(4) == 4 # returns 4 def test_lru_cache_capacity_update(): # Test 2: Capacity Update cache = LRUCache(1) cache.put(1, 1) cache.put(2, 2) assert cache.get(1) == -1 # returns -1 (not found) assert cache.get(2) == 2 # returns 2 def test_lru_cache_value_update(): # Test 3: Value Update cache = LRUCache(2) cache.put(1, 1) cache.put(1, 2) # update value of key 1 assert cache.get(1) == 2 # returns 2 def test_lru_cache_eviction_order(): # Test 4: Eviction Order cache = LRUCache(2) cache.put(1, 1) cache.put(2, 2) cache.get(1) # access key 1 cache.put(3, 3) # evicts key 2 assert cache.get(2) == -1 # returns -1 (not found) assert cache.get(1) == 1 # returns 1 if __name__ == \\"__main__\\": test_lru_cache_operations() test_lru_cache_capacity_update() test_lru_cache_value_update() test_lru_cache_eviction_order() print(\\"All tests passed.\\")","solution":"class ListNode: def __init__(self, key: int = 0, value: int = 0): self.key = key self.value = value self.prev = None self.next = None class LRUCache: def __init__(self, capacity: int): self.capacity = capacity self.cache = {} self.head = ListNode() self.tail = ListNode() self.head.next = self.tail self.tail.prev = self.head def _remove_node(self, node): prev = node.prev next = node.next prev.next = next next.prev = prev def _add_to_head(self, node): node.prev = self.head node.next = self.head.next self.head.next.prev = node self.head.next = node def _move_to_head(self, node): self._remove_node(node) self._add_to_head(node) def _pop_tail(self): res = self.tail.prev self._remove_node(res) return res def get(self, key: int) -> int: node = self.cache.get(key) if not node: return -1 self._move_to_head(node) return node.value def put(self, key: int, value: int) -> None: node = self.cache.get(key) if not node: newNode = ListNode(key, value) self.cache[key] = newNode self._add_to_head(newNode) if len(self.cache) > self.capacity: tail = self._pop_tail() del self.cache[tail.key] else: node.value = value self._move_to_head(node)"},{"question":"# Scenario As a developer, you are tasked with designing a URL shortening service similar to bit.ly or tinyurl.com. The service should generate unique shortened URLs for long URLs and provide the ability to retrieve the original URL when given the shortened version. # Task Implement a URL shortening service that efficiently handles URL creation and retrieval. Your implementation should: 1. Generate a unique shortened URL for each provided long URL. 2. Retrieve the original long URL when provided with the shortened version. 3. Ensure the shortened URLs are as short as possible while maintaining uniqueness. 4. Store the URL mappings in a persistent manner. 5. Handle collisions and edge cases gracefully. # Function Signature class URLShortener: def __init__(self): # Initialize necessary data structures here pass def shorten(self, long_url: str) -> str: Generates a unique shortened URL for the provided long URL. Args: long_url (str): The original long URL to be shortened. Returns: str: The shortened URL. # Your implementation here def retrieve(self, short_url: str) -> str: Retrieves the original long URL given the shortened version. Args: short_url (str): The shortened URL. Returns: str: The original long URL. # Your implementation here # Explanation 1. **long_url**: The original URL that needs to be shortened. 2. **short_url**: The shortened version of the URL that will be generated and used to retrieve the original URL. # Constraints - The length of the shortened URL should be minimized. - Handle up to 10,000 unique URL mappings. - Ensure that the shortened URL remains unique across different requests. - Provide meaningful error messages for invalid or non-existent shortened URLs. # Example # Initialize the URL shortener service url_shortener = URLShortener() # Shorten a long URL short_url = url_shortener.shorten(\\"https://www.example.com/some/very/long/url/path\\") print(short_url) # Output: a shortened URL like \\"http://short.url/abc123\\" # Retrieve the original long URL original_url = url_shortener.retrieve(short_url) print(original_url) # Output: \\"https://www.example.com/some/very/long/url/path\\" # Notes - Consider using techniques such as hashing, encoding, or base conversion to generate shortened URLs. - Think about how you would store the URL mappings (e.g., using a database or in-memory data structure). - Ensure that the service remains performant and scalable for a high number of requests.","solution":"import hashlib import string import random class URLShortener: def __init__(self): self.long_to_short = {} self.short_to_long = {} self.charset = string.ascii_letters + string.digits self.base_url = \\"http://short.url/\\" self.code_length = 6 def _generate_short_code(self): return ''.join(random.choice(self.charset) for _ in range(self.code_length)) def shorten(self, long_url: str) -> str: Generates a unique shortened URL for the provided long URL. Args: long_url (str): The original long URL to be shortened. Returns: str: The shortened URL. if long_url in self.long_to_short: return self.long_to_short[long_url] while True: short_code = self._generate_short_code() short_url = self.base_url + short_code if short_url not in self.short_to_long: self.long_to_short[long_url] = short_url self.short_to_long[short_url] = long_url break return short_url def retrieve(self, short_url: str) -> str: Retrieves the original long URL given the shortened version. Args: short_url (str): The shortened URL. Returns: str: The original long URL. if short_url in self.short_to_long: return self.short_to_long[short_url] else: raise KeyError(\\"Short URL not found\\")"},{"question":"# Scenario You are building a software system that involves processing large volumes of log data. One of the tasks requires you to identify the longest sequence of unique characters in a given log entry. This measure helps in understanding the complexity and variety within log entries. # Task Write a function \`longest_unique_substring(s: str) -> int\` that returns the length of the longest substring that contains only unique characters in the given string \`s\`. # Input * **s**: A string \`0 <= len(s) <= 10^5\`, consisting of alphanumeric characters and symbols. # Output * Return the length of the longest substring with all unique characters. # Function Signature def longest_unique_substring(s: str) -> int: Returns the length of the longest substring without repeating characters. max_length = 0 # To keep track of the maximum length of unique substring start = 0 # Left boundary of the sliding window char_index_map = {} # To store the most recent index of each character for end in range(len(s)): if s[end] in char_index_map: # Move the start position to the right of the last occurrence of current character start = max(start, char_index_map[s[end]] + 1) # Update the most recent index of the current character char_index_map[s[end]] = end # Calculate the maximum length of the unique substring seen so far max_length = max(max_length, end - start + 1) return max_length","solution":"def longest_unique_substring(s: str) -> int: Returns the length of the longest substring without repeating characters. max_length = 0 # To keep track of the maximum length of unique substring start = 0 # Left boundary of the sliding window char_index_map = {} # To store the most recent index of each character for end in range(len(s)): if s[end] in char_index_map: # Move the start position to the right of the last occurrence of current character start = max(start, char_index_map[s[end]] + 1) # Update the most recent index of the current character char_index_map[s[end]] = end # Calculate the maximum length of the unique substring seen so far max_length = max(max_length, end - start + 1) return max_length"},{"question":"def highest_power_of_2(n: int) -> int: Returns the highest power of 2 less than or equal to a given positive integer. >>> highest_power_of_2(5) 4 >>> highest_power_of_2(8) 8 >>> highest_power_of_2(10) 8 >>> highest_power_of_2(17) 16 >>> highest_power_of_2(1) 1 def test_highest_power_of_2(): assert highest_power_of_2(5) == 4 assert highest_power_of_2(8) == 8 assert highest_power_of_2(10) == 8 assert highest_power_of_2(17) == 16 assert highest_power_of_2(1) == 1 assert highest_power_of_2(1024) == 1024 assert highest_power_of_2(1023) == 512 assert highest_power_of_2(10**9) == 2**29 def test_invalid_input(): try: highest_power_of_2(0) except ValueError as e: assert str(e) == \\"n must be at least 1\\" try: highest_power_of_2(-5) except ValueError as e: assert str(e) == \\"n must be at least 1\\"","solution":"def highest_power_of_2(n: int) -> int: Returns the highest power of 2 less than or equal to a given positive integer. if n < 1: raise ValueError(\\"n must be at least 1\\") power = 1 while power <= n: power <<= 1 return power >> 1"},{"question":"def convert_to_base(n: int, base: int) -> str: Convert an integer to the specified base (between 2 and 36). >>> convert_to_base(255, 16) 'FF' >>> convert_to_base(255, 2) '11111111' def sum_of_digits_in_base(n: int, base: int) -> int: Calculate the sum of digits in the specified base. >>> sum_of_digits_in_base(255, 16) 30 # 'FF' -> 15 + 15 >>> sum_of_digits_in_base(255, 2) 8 # '11111111' -> 1+1+1+1+1+1+1+1","solution":"def convert_to_base(n: int, base: int) -> str: if n == 0: return \\"0\\" digits = \\"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\\" result = \\"\\" while n > 0: result = digits[n % base] + result n //= base return result def sum_of_digits_in_base(n: int, base: int) -> int: converted = convert_to_base(n, base) return sum(int(char, base) for char in converted)"},{"question":"def left_rotate(s: str, n: int) -> str: Returns the string after rotating it to the left by n positions. >>> left_rotate(\\"abcdef\\", 2) 'cdefab' >>> left_rotate(\\"hello123\\", 5) '123hello' pass def right_rotate(s: str, n: int) -> str: Returns the string after rotating it to the right by n positions. >>> right_rotate(\\"abcdef\\", 2) 'efabcd' >>> right_rotate(\\"hello123\\", 5) 'o123hell' pass","solution":"def left_rotate(s: str, n: int) -> str: Returns the string after rotating it to the left by n positions. if len(s) == 0: return s n = n % len(s) return s[n:] + s[:n] def right_rotate(s: str, n: int) -> str: Returns the string after rotating it to the right by n positions. if len(s) == 0: return s n = n % len(s) return s[-n:] + s[:-n]"},{"question":"from typing import Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def find_target(root: Optional[TreeNode], k: int) -> bool: Determines if there exist two distinct elements in the BST whose sum is equal to k. Parameters: root (TreeNode): The root node of the Binary Search Tree (BST) k (int): The target sum Returns: bool: True if there exist two elements in the BST whose sum is equal to k, otherwise False Example: >>> root = TreeNode(5) >>> root.left = TreeNode(3) >>> root.right = TreeNode(6) >>> root.left.left = TreeNode(2) >>> root.left.right = TreeNode(4) >>> root.right.right = TreeNode(7) >>> k = 9 >>> find_target(root, k) True >>> root = TreeNode(5) >>> root.left = TreeNode(3) >>> root.right = TreeNode(6) >>> root.left.left = TreeNode(2) >>> root.left.right = TreeNode(4) >>> root.right.right = TreeNode(7) >>> k = 28 >>> find_target(root, k) False","solution":"from typing import Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def find_target(root: Optional[TreeNode], k: int) -> bool: def inorder(node, elements): if not node: return inorder(node.left, elements) elements.add(node.val) inorder(node.right, elements) elements = set() inorder(root, elements) for element in elements: if (k - element) in elements and (k - element) != element: return True return False"},{"question":"from typing import List, Dict def process_log_file(log_entries: List[str]) -> Dict[str, int]: Processes log entries and returns a summary of frequencies of unique entries. Arguments: log_entries -- a list of strings, where each string represents a log entry Returns: A dictionary with unique log entries as keys and their frequency counts as values. pass # Example log_entries = [ \\"INFO User logged in\\", \\"ERROR Database connection failed\\", \\"INFO User logged in\\", \\"INFO User logged out\\", \\"WARNING Disk space low\\", \\"INFO User logged in\\" ] # Call the function summary = process_log_file(log_entries) # expected output # { # \\"INFO User logged in\\": 3, # \\"ERROR Database connection failed\\": 1, # \\"INFO User logged out\\": 1, # \\"WARNING Disk space low\\": 1 # } # Unit Tests def test_single_entry(): log_entries = [\\"INFO User logged in\\"] expected_output = {\\"INFO User logged in\\": 1} assert process_log_file(log_entries) == expected_output def test_multiple_unique_entries(): log_entries = [ \\"INFO User logged in\\", \\"ERROR Database connection failed\\", \\"INFO User logged out\\" ] expected_output = { \\"INFO User logged in\\": 1, \\"ERROR Database connection failed\\": 1, \\"INFO User logged out\\": 1 } assert process_log_file(log_entries) == expected_output def test_duplicate_entries(): log_entries = [ \\"INFO User logged in\\", \\"ERROR Database connection failed\\", \\"INFO User logged in\\", \\"INFO User logged out\\", \\"INFO User logged in\\" ] expected_output = { \\"INFO User logged in\\": 3, \\"ERROR Database connection failed\\": 1, \\"INFO User logged out\\": 1 } assert process_log_file(log_entries) == expected_output def test_all_identical_entries(): log_entries = [\\"ERROR System crash\\"] * 5 expected_output = {\\"ERROR System crash\\": 5} assert process_log_file(log_entries) == expected_output def test_empty_log_entries(): log_entries = [] expected_output = {} assert process_log_file(log_entries) == expected_output def test_mixed_entries(): log_entries = [ \\"INFO User logged in\\", \\"ERROR Database connection failed\\", \\"INFO User logged in\\", \\"WARNING Disk space low\\", \\"INFO User logged out\\", \\"INFO User logged in\\", \\"ERROR Database connection failed\\" ] expected_output = { \\"INFO User logged in\\": 3, \\"ERROR Database connection failed\\": 2, \\"WARNING Disk space low\\": 1, \\"INFO User logged out\\": 1 } assert process_log_file(log_entries) == expected_output","solution":"def process_log_file(log_entries): Processes log entries and returns a summary of frequencies of unique entries. Arguments: log_entries -- a list of strings, where each string represents a log entry Returns: A dictionary with unique log entries as keys and their frequency counts as values. from collections import defaultdict frequency_dict = defaultdict(int) for entry in log_entries: frequency_dict[entry] += 1 return dict(frequency_dict)"},{"question":"import numpy as np def pad_matrix_to_power_of_two(A: np.ndarray) -> np.ndarray: Pad the input matrix to the next power of 2 dimensions. >>> A = np.array([[1, 2], [3, 4]]) >>> pad_matrix_to_power_of_two(A) array([[1, 2], [3, 4]]) pass def unpad_matrix(A: np.ndarray, original_size: int) -> np.ndarray: Unpad the matrix to its original size. >>> A = np.array([[1, 2], [3, 4]]) >>> unpad_matrix(A, 2) array([[1, 2], [3, 4]]) pass def strassen_matrix_multiplication(A: np.ndarray, B: np.ndarray) -> np.ndarray: Multiply two square matrices using Strassen's algorithm. >>> A = np.array([[1, 2], [3, 4]]) >>> B = np.array([[5, 6], [7, 8]]) >>> strassen_matrix_multiplication(A, B) array([[19, 22], [43, 50]]) pass def compare_matrix_multiplication(A: np.ndarray, B: np.ndarray) -> dict: Compare the execution time of Strassen's algorithm against the naive method. >>> A = np.array([[1, 2], [3, 4]]) >>> B = np.array([[5, 6], [7, 8]]) >>> compare_matrix_multiplication(A, B) {'naive': 0.0023, 'strassen': 0.0018} pass","solution":"import numpy as np import time def strassen_matrix_multiplication(A: np.ndarray, B: np.ndarray) -> np.ndarray: assert A.shape == B.shape, 'Matrices must be the same size' assert A.shape[0] == A.shape[1], 'Matrices must be square' n = A.shape[0] if n == 1: return A * B mid = n // 2 # Splitting the matrices into quadrants A11, A12, A21, A22 = A[:mid, :mid], A[:mid, mid:], A[mid:, :mid], A[mid:, mid:] B11, B12, B21, B22 = B[:mid, :mid], B[:mid, mid:], B[mid:, :mid], B[mid:, mid:] # Strassen’s formulas M1 = strassen_matrix_multiplication(A11 + A22, B11 + B22) M2 = strassen_matrix_multiplication(A21 + A22, B11) M3 = strassen_matrix_multiplication(A11, B12 - B22) M4 = strassen_matrix_multiplication(A22, B21 - B11) M5 = strassen_matrix_multiplication(A11 + A12, B22) M6 = strassen_matrix_multiplication(A21 - A11, B11 + B12) M7 = strassen_matrix_multiplication(A12 - A22, B21 + B22) C11 = M1 + M4 - M5 + M7 C12 = M3 + M5 C21 = M2 + M4 C22 = M1 + M3 - M2 + M6 # Combining the quadrants into a single matrix C = np.empty_like(A) C[:mid, :mid] = C11 C[:mid, mid:] = C12 C[mid:, :mid] = C21 C[mid:, mid:] = C22 return C def pad_matrix_to_power_of_two(A: np.ndarray) -> np.ndarray: n = A.shape[0] m = 2 ** np.ceil(np.log2(n)).astype(int) padded_A = np.zeros((m, m), dtype=A.dtype) padded_A[:n, :n] = A return padded_A def unpad_matrix(A: np.ndarray, original_size: int) -> np.ndarray: return A[:original_size, :original_size] def compare_matrix_multiplication(A: np.ndarray, B: np.ndarray) -> dict: A_pad = pad_matrix_to_power_of_two(A) B_pad = pad_matrix_to_power_of_two(B) start_time = time.time() naive_result = np.matmul(A, B) naive_time = time.time() - start_time start_time = time.time() strassen_result = strassen_matrix_multiplication(A_pad, B_pad) strassen_result = unpad_matrix(strassen_result, A.shape[0]) strassen_time = time.time() - start_time return { 'naive': naive_time, 'strassen': strassen_time }"},{"question":"from typing import Tuple def and_gate(input_1: int, input_2: int) -> int: return input_1 & input_2 def or_gate(input_1: int, input_2: int) -> int: return input_1 | input_2 def xor_gate(input_1: int, input_2: int) -> int: return input_1 ^ input_2 def ripple_carry_adder(a: int, b: int) -> Tuple[int, int]: Compute the 4-bit sum and carry-out using a ripple carry adder. :param a: First 4-bit integer (0 to 15) :param b: Second 4-bit integer (0 to 15) :return: A tuple with the 4-bit sum and the carry-out (sum, carry-out) >>> ripple_carry_adder(3, 6) (9, 0) >>> ripple_carry_adder(7, 8) (15, 0) >>> ripple_carry_adder(15, 1) (0, 1) >>> ripple_carry_adder(9, 6) (15, 0)","solution":"from typing import Tuple def and_gate(input_1: int, input_2: int) -> int: return input_1 & input_2 def or_gate(input_1: int, input_2: int) -> int: return input_1 | input_2 def xor_gate(input_1: int, input_2: int) -> int: return input_1 ^ input_2 def full_adder(bit_a: int, bit_b: int, carry_in: int) -> Tuple[int, int]: sum_ab = xor_gate(xor_gate(bit_a, bit_b), carry_in) carry_out = or_gate(and_gate(bit_a, bit_b), and_gate(carry_in, xor_gate(bit_a, bit_b))) return sum_ab, carry_out def ripple_carry_adder(a: int, b: int) -> Tuple[int, int]: a_bits = [(a >> i) & 1 for i in range(4)] b_bits = [(b >> i) & 1 for i in range(4)] carry = 0 sum_bits = [] for bit_a, bit_b in zip(a_bits, b_bits): sum_bit, carry = full_adder(bit_a, bit_b, carry) sum_bits.append(sum_bit) sum_result = sum((bit << i) for i, bit in enumerate(sum_bits)) return sum_result, carry"},{"question":"def count_substring_occurrences(main_str: str, sub_str: str) -> int: Returns the number of non-overlapping occurrences of sub_str in main_str. >>> count_substring_occurrences(\\"ababcabc\\", \\"abc\\") 2 >>> count_substring_occurrences(\\"aaaaaa\\", \\"aa\\") 3","solution":"def count_substring_occurrences(main_str, sub_str): Returns the number of non-overlapping occurrences of sub_str in main_str. count = 0 start = 0 while True: start = main_str.find(sub_str, start) if start == -1: break count += 1 start += len(sub_str) return count"},{"question":"def newtons_second_law(force: float, mass: float) -> float: Calculates the acceleration of an object based on the provided force and mass. Parameters: force (float): The net force acting on the object in Newtons (N). mass (float): The mass of the object in kilograms (kg). Must be greater than 0. Returns: float: The acceleration in meters per second squared (m/s^2). Raises: ValueError: If mass is less than or equal to 0. Example Usage: >>> newtons_second_law(10, 5) 2.0 >>> newtons_second_law(-20, 4) -5.0 >>> newtons_second_law(0, 2) 0.0 >>> newtons_second_law(15, 0) Traceback (most recent call last): ... ValueError: Impossible mass >>> newtons_second_law(15, -3) Traceback (most recent call last): ... ValueError: Impossible mass","solution":"def newtons_second_law(force: float, mass: float) -> float: Calculates the acceleration of an object based on the provided force and mass. Parameters: force (float): The net force acting on the object in Newtons (N). mass (float): The mass of the object in kilograms (kg). Must be greater than 0. Returns: float: The acceleration in meters per second squared (m/s^2). Raises: ValueError: If mass is less than or equal to 0. if mass <= 0: raise ValueError(\\"Impossible mass\\") acceleration = force / mass return acceleration"},{"question":"import string class URLShortener: A URL shortener service that encodes long URLs to short URLs and decodes short URLs back to the original long URLs. Methods: - encode(long_url: str) -> str: Encodes a long URL to a shortened URL. - decode(short_url: str) -> str: Decodes a shortened URL to its original long URL. def __init__(self): self.url_to_id = {} self.id_to_url = {} self.counter = 1 self.alphabet = string.ascii_letters + string.digits def encode(self, long_url: str) -> str: Encodes a long URL to a shortened URL. >>> shortener = URLShortener() >>> shortener.encode(\\"https://www.example.com\\") 'b' >>> shortener.encode(\\"https://www.anotherexample.com\\") 'c' def decode(self, short_url: str) -> str: Decodes a shortened URL to its original long URL. >>> shortener = URLShortener() >>> shortener.decode(\\"b\\") 'https://www.example.com' >>> shortener.decode(\\"c\\") 'https://www.anotherexample.com' def test_encode_and_decode(): shortener = URLShortener() long_url1 = \\"https://www.example.com\\" long_url2 = \\"https://www.anotherexample.com\\" short_url1 = shortener.encode(long_url1) short_url2 = shortener.encode(long_url2) assert shortener.decode(short_url1) == long_url1 assert shortener.decode(short_url2) == long_url2 def test_repeated_encode(): shortener = URLShortener() long_url = \\"https://www.example.com\\" short_url1 = shortener.encode(long_url) short_url2 = shortener.encode(long_url) assert short_url1 == short_url2 assert shortener.decode(short_url1) == long_url def test_unique_short_urls(): shortener = URLShortener() long_url1 = \\"https://www.example.com\\" long_url2 = \\"https://www.anotherexample.com\\" short_url1 = shortener.encode(long_url1) short_url2 = shortener.encode(long_url2) assert short_url1 != short_url2 def test_decode_nonexistent_url(): shortener = URLShortener() assert shortener.decode(\\"nonexistent\\") == \\"\\"","solution":"import string class URLShortener: def __init__(self): self.url_to_id = {} self.id_to_url = {} self.counter = 1 self.alphabet = string.ascii_letters + string.digits def _encode_id(self, id): Encodes an integer ID to a base62 string. base62 = [] while id > 0: base62.append(self.alphabet[id % 62]) id //= 62 return ''.join(reversed(base62)) def _decode_id(self, short_url): Decodes a base62 string to an integer ID. id = 0 for char in short_url: id = id * 62 + self.alphabet.index(char) return id def encode(self, long_url: str) -> str: Encodes a long URL to a shortened URL. if long_url in self.url_to_id: id = self.url_to_id[long_url] else: id = self.counter self.url_to_id[long_url] = id self.id_to_url[id] = long_url self.counter += 1 return self._encode_id(id) def decode(self, short_url: str) -> str: Decodes a shortened URL to its original long URL. id = self._decode_id(short_url) return self.id_to_url.get(id, \\"\\")"},{"question":"def sort_by_frequency(s: str) -> str: Sort the letters of the string 's' by their frequency in descending order. :param s: A string consisting of lowercase letters only. :return: A new string with letters sorted by frequency in descending order. >>> sort_by_frequency(\\"tree\\") in [\\"eert\\", \\"eetr\\"] True >>> sort_by_frequency(\\"banana\\") == \\"aaannb\\" True >>> sort_by_frequency(\\"a\\") == \\"a\\" True >>> sort_by_frequency(\\"abc\\") in ['abc', 'bac', 'bca', 'cab', 'cba'] True >>> sort_by_frequency(\\"aaaa\\") == \\"aaaa\\" True >>> large_input = \\"a\\" * 50000 + \\"b\\" * 50000 >>> sort_by_frequency(large_input) in [\\"a\\" * 50000 + \\"b\\" * 50000, \\"b\\" * 50000 + \\"a\\" * 50000] True","solution":"from collections import Counter def sort_by_frequency(s: str) -> str: Sort the letters of the string 's' by their frequency in descending order. :param s: A string consisting of lowercase letters only. :return: A new string with letters sorted by frequency in descending order. frequency_counter = Counter(s) # Sort by frequency first (-frequency to sort in descending order), then by first appearance sorted_characters = sorted(frequency_counter.keys(), key=lambda x: (-frequency_counter[x], s.index(x))) # Construct the result string based on sorted characters result = ''.join(char * frequency_counter[char] for char in sorted_characters) return result"},{"question":"class ArticleManager: A class to manage articles with unique identifiers, content, and timestamps. Methods: add_article(id: str, content: str, timestamp: int): Adds a new article with the given id, content, and timestamp. get_article_content(id: str) -> str: Returns the content of the specified article. update_article(id: str, new_content: str, new_timestamp: int): Updates the content of the specified article to \`new_content\` and its timestamp to \`new_timestamp\`. get_latest_article() -> str: Returns the id of the most recently updated article. Example: >>> manager = ArticleManager() >>> manager.add_article(\\"A1\\", \\"Initial Content A1\\", 1) >>> manager.add_article(\\"A2\\", \\"Initial Content A2\\", 2) >>> manager.get_article_content(\\"A1\\") \\"Initial Content A1\\" >>> manager.update_article(\\"A1\\", \\"Updated Content A1\\", 4) >>> manager.get_article_content(\\"A1\\") \\"Updated Content A1\\" >>> manager.get_latest_article() \\"A1\\" >>> manager.update_article(\\"A2\\", \\"Updated Content A2\\", 5) >>> manager.get_latest_article() \\"A2\\" def __init__(self): pass def add_article(self, id: str, content: str, timestamp: int): pass def get_article_content(self, id: str) -> str: pass def update_article(self, id: str, new_content: str, new_timestamp: int): pass def get_latest_article(self) -> str: pass # Unit Test def test_add_article(): manager = ArticleManager() manager.add_article(\\"A1\\", \\"Initial Content A1\\", 1) assert manager.get_article_content(\\"A1\\") == \\"Initial Content A1\\" def test_update_article(): manager = ArticleManager() manager.add_article(\\"A1\\", \\"Initial Content A1\\", 1) manager.update_article(\\"A1\\", \\"Updated Content A1\\", 2) assert manager.get_article_content(\\"A1\\") == \\"Updated Content A1\\" def test_get_latest_article_initial(): manager = ArticleManager() manager.add_article(\\"A1\\", \\"Initial Content A1\\", 1) manager.add_article(\\"A2\\", \\"Initial Content A2\\", 2) assert manager.get_latest_article() == \\"A2\\" def test_get_latest_article_post_update(): manager = ArticleManager() manager.add_article(\\"A1\\", \\"Initial Content A1\\", 1) manager.add_article(\\"A2\\", \\"Initial Content A2\\", 2) manager.update_article(\\"A1\\", \\"Updated Content A1\\", 3) assert manager.get_latest_article() == \\"A1\\" def test_no_article_found(): manager = ArticleManager() assert manager.get_article_content(\\"A1\\") == None assert manager.get_latest_article() == None def test_update_with_older_timestamp(): manager = ArticleManager() manager.add_article(\\"A1\\", \\"Initial Content A1\\", 2) manager.update_article(\\"A1\\", \\"Old Content A1\\", 1) assert manager.get_article_content(\\"A1\\") == \\"Initial Content A1\\" assert manager.get_latest_article() == \\"A1\\"","solution":"class ArticleManager: def __init__(self): self.articles = {} self.latest_article_id = None def add_article(self, id: str, content: str, timestamp: int): self.articles[id] = {'content': content, 'timestamp': timestamp} if self.latest_article_id is None or self.articles[self.latest_article_id]['timestamp'] < timestamp: self.latest_article_id = id def get_article_content(self, id: str) -> str: article = self.articles.get(id) if article is not None: return article['content'] return None def update_article(self, id: str, new_content: str, new_timestamp: int): if id in self.articles and self.articles[id]['timestamp'] < new_timestamp: self.articles[id]['content'] = new_content self.articles[id]['timestamp'] = new_timestamp if self.latest_article_id is None or self.articles[self.latest_article_id]['timestamp'] < new_timestamp: self.latest_article_id = id def get_latest_article(self) -> str: return self.latest_article_id"},{"question":"def quickselect(arr: list[int], k: int) -> int: Returns the k-th smallest element in the list using the Quickselect algorithm. Args: arr (list[int]): The unsorted list of integers. k (int): The position (1-based index) of the smallest element to find in the list. Returns: int: The k-th smallest element in the list. Example: >>> quickselect([10, 4, 5, 8, 6, 11, 26], 3) 6 >>> quickselect([3, 2, 1, 5, 4], 1) 1 >>> quickselect([7, 10, 4, 3, 20, 15], 4) 10 from solution import quickselect def test_quickselect_example1(): arr = [10, 4, 5, 8, 6, 11, 26] assert quickselect(arr, 3) == 6 def test_quickselect_example2(): arr = [3, 2, 1, 5, 4] assert quickselect(arr, 1) == 1 def test_quickselect_example3(): arr = [7, 10, 4, 3, 20, 15] assert quickselect(arr, 4) == 10 def test_quickselect_large_numbers(): arr = [1000000000, -1000000000, 0, 999999999, -999999999] assert quickselect(arr, 3) == 0 def test_quickselect_single_element(): arr = [42] assert quickselect(arr, 1) == 42 def test_quickselect_sorted(): arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] assert quickselect(arr, 5) == 5 def test_quickselect_reversed(): arr = [10, 9, 8, 7, 6, 5, 4, 3, 2, 1] assert quickselect(arr, 5) == 5 def test_quickselect_duplicates(): arr = [1, 3, 3, 3, 2, 1, 5, 6] assert quickselect(arr, 3) == 2 assert quickselect(arr, 4) == 3 def test_quickselect_negative_numbers(): arr = [-5, -10, -3, -1, -6] assert quickselect(arr, 2) == -6 assert quickselect(arr, 4) == -3","solution":"def quickselect(arr: list[int], k: int) -> int: Returns the k-th smallest element in the list using the Quickselect algorithm. def partition(left, right, pivot_index): pivot_value = arr[pivot_index] # move pivot to end arr[pivot_index], arr[right] = arr[right], arr[pivot_index] store_index = left # move all smaller elements to the left for i in range(left, right): if arr[i] < pivot_value: arr[store_index], arr[i] = arr[i], arr[store_index] store_index += 1 # move pivot to its final place arr[right], arr[store_index] = arr[store_index], arr[right] return store_index def select(left, right, k_smallest): Returns the k-th smallest element of the list within left..right. if left == right: # If the list contains only one element, return arr[left] # return that element # select a random pivot_index between pivot_index = left + (right - left) // 2 # find the pivot position in a sorted list pivot_index = partition(left, right, pivot_index) # the pivot is in its final sorted position if k_smallest == pivot_index: return arr[k_smallest] # go left elif k_smallest < pivot_index: return select(left, pivot_index - 1, k_smallest) # go right else: return select(pivot_index + 1, right, k_smallest) return select(0, len(arr) - 1, k - 1)"},{"question":"def transpose_matrix(matrix: List[List[int]]) -> List[List[int]]: Transposes the given 2D matrix. Args: matrix (List[List[int]]): The input 2D list representing the matrix to be transposed. Returns: List[List[int]]: A 2D list representing the transposed matrix. Examples: >>> transpose_matrix([[1, 2, 3], [4, 5, 6]]) [[1, 4], [2, 5], [3, 6]] >>> transpose_matrix([[1, 2], [3, 4], [5, 6]]) [[1, 3, 5], [2, 4, 6]]","solution":"def transpose_matrix(matrix): Transposes the given 2D matrix. Args: matrix (List[List[int]]): The input 2D list representing the matrix to be transposed. Returns: List[List[int]]: A 2D list representing the transposed matrix. # Using list comprehension to transpose the matrix return [list(row) for row in zip(*matrix)]"},{"question":"class ListNode: def __init__(self, data=0, next_node=None): self.data = data self.next = next_node def find_intersection(head1, head2): Determines the first common node at which two singly linked lists intersect. Parameters: head1 (ListNode): The head of the first singly linked list. head2 (ListNode): The head of the second singly linked list. Returns: int: The data value of the first intersection node, or None if there is no intersection. >>> common = ListNode(6, ListNode(7)) >>> head1 = ListNode(1, ListNode(2, ListNode(3, common))) >>> head2 = ListNode(4, ListNode(5, common)) >>> find_intersection(head1, head2) == 6 >>> head1 = ListNode(1, ListNode(2, ListNode(3))) >>> head2 = ListNode(6, ListNode(7, ListNode(4, ListNode(5)))) >>> find_intersection(head1, head2) is None >>> common = ListNode(5) >>> head1 = ListNode(1, ListNode(2, ListNode(3, ListNode(4, common)))) >>> head2 = ListNode(6, ListNode(7, ListNode(9, ListNode(10, ListNode(8, common))))) >>> find_intersection(head1, head2) == 5 >>> common = ListNode(2, ListNode(3, ListNode(4))) >>> head1 = ListNode(1, common) >>> head2 = ListNode(5, common) >>> find_intersection(head1, head2) == 2 >>> try: >>> find_intersection(123, 'head') >>> except TypeError as e: >>> assert str(e) == \\"Inputs must be instances of ListNode\\"","solution":"class ListNode: def __init__(self, data=0, next_node=None): self.data = data self.next = next_node def find_intersection(head1, head2): Determines the first common node at which two singly linked lists intersect. Parameters: head1 (ListNode): The head of the first singly linked list. head2 (ListNode): The head of the second singly linked list. Returns: int: The data value of the first intersection node, or None if there is no intersection. if not isinstance(head1, ListNode) or not isinstance(head2, ListNode): raise TypeError(\\"Inputs must be instances of ListNode\\") # Use two pointers to traverse both linked lists ptr1, ptr2 = head1, head2 while ptr1 != ptr2: # Move to the next node or switch to the other head ptr1 = ptr1.next if ptr1 else head2 ptr2 = ptr2.next if ptr2 else head1 return ptr1.data if ptr1 else None"},{"question":"from typing import List, Tuple, Dict def calculate_total_discount(items: List[Tuple[int, float]], coupons: Dict[int, float]) -> float: Calculate the total discount applied to the items in the cart. >>> calculate_total_discount([(1, 100.0), (2, 200.0)], {1: 90.0, 2: 150.0}) 240.0 >>> calculate_total_discount([(1, 100.0), (2, 200.0)], {}) 0.0 >>> calculate_total_discount([(1, 100.0), (2, 200.0), (3, 50.0)], {1: 90.0, 3: 30.0}) 120.0 >>> calculate_total_discount([(1, 100.0), (2, 200.0)], {1: 150.0, 2: 250.0}) 300.0 >>> calculate_total_discount([(1, 100.0), (2, 200.0)], {1: 0.0, 2: 0.0}) 0.0 >>> calculate_total_discount([], {1: 50.0, 2: 100.0}) 0.0 >>> calculate_total_discount([(i, 100.0) for i in range(1, 101)], {i: 50.0 for i in range(1, 101)}) 5000.0","solution":"from typing import List, Tuple, Dict def calculate_total_discount(items: List[Tuple[int, float]], coupons: Dict[int, float]) -> float: total_discount = 0.0 for item_id, price in items: if item_id in coupons: discount = min(price, coupons[item_id]) total_discount += discount return total_discount"},{"question":"from typing import List def max_subarray_with_one_exclusion(arr: List[int]) -> int: Calculate the maximum sum of a contiguous subarray with at most one element excluded. >>> max_subarray_with_one_exclusion([1, -2, 0, 3]) 4 >>> max_subarray_with_one_exclusion([1, -2, 0, -3, 5]) 5","solution":"from typing import List def max_subarray_with_one_exclusion(arr: List[int]) -> int: n = len(arr) if n == 1: return arr[0] # Initialize arrays to store the maximum sum subarray ending at each index max_end_here = [0] * n max_start_here = [0] * n # Compute the maximum subarray sum ending at each index max_end_here[0] = arr[0] for i in range(1, n): max_end_here[i] = max(arr[i], max_end_here[i-1] + arr[i]) # Compute the maximum subarray sum starting from each index max_start_here[-1] = arr[-1] for i in range(n-2, -1, -1): max_start_here[i] = max(arr[i], max_start_here[i+1] + arr[i]) # Find the maximum subarray sum with at most one exclusion max_sum = max(max_end_here) for i in range(1, n-1): max_sum = max(max_sum, max_end_here[i-1] + max_start_here[i+1]) return max(max_sum, max(max_start_here[-1], max_end_here[-1]))"},{"question":"from typing import List, Callable def longest_subsequence(arr: List[int], condition: Callable[[int], bool]) -> int: Returns the length of the longest contiguous subsequence within arr where every integer meets the condition. Examples: >>> longest_subsequence([1, 2, 3, 4, 5, 6, 7, 8], lambda x: x % 2 == 0) 4 >>> longest_subsequence([1, -2, -3, 4, -5, 6, 7, -8], lambda x: x < 0) 2 >>> longest_subsequence([10, 15, 20, 25, 30, 35], lambda x: x % 5 == 0) 6","solution":"from typing import List, Callable def longest_subsequence(arr: List[int], condition: Callable[[int], bool]) -> int: Returns the length of the longest contiguous subsequence within arr where every integer meets the condition. max_length = 0 current_length = 0 for num in arr: if condition(num): current_length += 1 if current_length > max_length: max_length = current_length else: current_length = 0 return max_length"},{"question":"class CustomHashMap: def __init__(self): Initializes the CustomHashMap with default values. def put(self, key: int, value: int) -> None: Inserts the key-value pair into the CustomHashMap. If the key already exists, it updates the value. def get(self, key: int) -> Optional[int]: Returns the value to which the specified key is mapped, or None if the key is not present. def remove(self, key: int) -> None: Removes the mapping for the specified key if it exists. # Example usage: # cmap = CustomHashMap() # cmap.put(1, 1) # cmap.put(2, 2) # print(cmap.get(1)) # Output: 1 # print(cmap.get(3)) # Output: None # cmap.put(2, 1) # print(cmap.get(2)) # Output: 1 # cmap.remove(2) # print(cmap.get(2)) # Output: None # Unit Tests def test_put_and_get(): cmap = CustomHashMap() cmap.put(1, 1) cmap.put(2, 2) assert cmap.get(1) == 1 assert cmap.get(2) == 2 assert cmap.get(3) == None def test_remove(): cmap = CustomHashMap() cmap.put(1, 1) cmap.remove(1) assert cmap.get(1) == None def test_update_value(): cmap = CustomHashMap() cmap.put(1, 1) assert cmap.get(1) == 1 cmap.put(1, 2) assert cmap.get(1) == 2 def test_resize(): cmap = CustomHashMap() for i in range(10): cmap.put(i, i) for i in range(10): assert cmap.get(i) == i def test_remove_non_existing_key(): cmap = CustomHashMap() cmap.put(1, 1) cmap.remove(2) assert cmap.get(1) == 1 def test_get_empty(): cmap = CustomHashMap() assert cmap.get(0) == None assert cmap.get(100) == None","solution":"class CustomHashMap: def __init__(self): self.initial_size = 8 self.load_factor_threshold = 0.7 self.buckets = [[] for _ in range(self.initial_size)] self.size = 0 def _hash(self, key): return key % len(self.buckets) def _resize(self): new_buckets = [[] for _ in range(len(self.buckets) * 2)] for bucket in self.buckets: for key, value in bucket: index = key % len(new_buckets) new_buckets[index].append((key, value)) self.buckets = new_buckets def put(self, key: int, value: int) -> None: if self.size / len(self.buckets) > self.load_factor_threshold: self._resize() index = self._hash(key) bucket = self.buckets[index] for i, (k, v) in enumerate(bucket): if k == key: bucket[i] = (key, value) return bucket.append((key, value)) self.size += 1 def get(self, key: int): index = self._hash(key) bucket = self.buckets[index] for k, v in bucket: if k == key: return v return None def remove(self, key: int) -> None: index = self._hash(key) bucket = self.buckets[index] for i, (k, v) in enumerate(bucket): if k == key: del bucket[i] self.size -= 1 return"},{"question":"def register_candidate(candidate: str, candidates: list[str]) -> list[str]: Registers a candidate if they are not already in the list of candidates. >>> candidates = [] >>> candidates = register_candidate(\\"Alice\\", candidates) >>> candidates ['Alice'] ... def cast_vote(candidate: str, votes: dict[str, int]) -> dict[str, int]: Records a vote for a candidate if the candidate exists in the current candidates' list. >>> candidates = [\\"Alice\\", \\"Bob\\"] >>> votes = {candidate: 0 for candidate in candidates} >>> votes = cast_vote(\\"Alice\\", votes) >>> votes[\\"Alice\\"] 1 ... def validate_candidate(candidate: str, candidates: list[str]) -> bool: Validates that a candidate is unique in the list of candidates. >>> candidates = [\\"Alice\\", \\"Bob\\"] >>> validate_candidate(\\"Charlie\\", candidates) True ... def display_results(votes: dict[str, int]) -> None: Prints the tally of votes for each candidate. >>> votes = {\\"Alice\\": 1, \\"Bob\\": 2} >>> display_results(votes) Alice: 1 vote(s) Bob: 2 vote(s) ...","solution":"def register_candidate(candidate, candidates): Registers a candidate if they are not already in the list of candidates. if candidate in candidates: raise ValueError(f\\"Candidate {candidate} is already registered.\\") candidates.append(candidate) return candidates def cast_vote(candidate, votes): Records a vote for a candidate if the candidate exists in the current candidates' list. if candidate not in votes: raise ValueError(f\\"Candidate {candidate} is not valid.\\") votes[candidate] += 1 return votes def validate_candidate(candidate, candidates): Validates that a candidate is unique in the list of candidates. if candidate in candidates: raise ValueError(f\\"Candidate {candidate} already exists.\\") return True def display_results(votes): Prints the tally of votes for each candidate. for candidate, vote_count in votes.items(): print(f\\"{candidate}: {vote_count} vote(s)\\")"},{"question":"def find_unknown_words(sentence: str, dictionary: List[str]) -> List[str]: Identifies the unknown words in a sentence based on a given dictionary of valid words. Parameters: sentence (str): A string containing a sentence with words separated by spaces. dictionary (List[str]): A list of strings representing the valid words. Returns: List[str]: A list of strings representing the words from the sentence that are not present in the dictionary. The order of the words should match their order in the sentence. If all words are valid, return an empty list. Examples: >>> find_unknown_words(\\"hello world this is a test\\", [\\"hello\\", \\"world\\", \\"this\\", \\"is\\", \\"a\\", \\"valid\\", \\"sentence\\"]) ['test'] >>> find_unknown_words(\\"programming languages like python are amazing\\", [\\"programming\\", \\"languages\\", \\"like\\", \\"python\\", \\"are\\", \\"amazing\\"]) [] >>> find_unknown_words(\\"check the weather before going for a hike\\", [\\"check\\", \\"the\\", \\"weather\\", \\"before\\", \\"going\\", \\"for\\", \\"a\\"]) ['hike']","solution":"def find_unknown_words(sentence, dictionary): Identifies the unknown words in a sentence based on a given dictionary of valid words. Parameters: sentence (str): A string containing a sentence with words separated by spaces. dictionary (List[str]): A list of strings representing the valid words. Returns: List[str]: A list of strings representing the words from the sentence that are not present in the dictionary. The order of the words should match their order in the sentence. If all words are valid, return an empty list. dictionary_set = set(dictionary) words = sentence.split() unknown_words = [word for word in words if word not in dictionary_set] return unknown_words"},{"question":"def longest_palindromic_subsequence(s: str) -> int: Computes the length of the longest palindromic subsequence in the input string s. >>> longest_palindromic_subsequence(\\"bbbab\\") == 4 >>> longest_palindromic_subsequence(\\"cbbd\\") == 2","solution":"def longest_palindromic_subsequence(s: str) -> int: Computes the length of the longest palindromic subsequence in the input string s. n = len(s) # Create a 2D array dp to store the lengths of palindromic subsequences. dp = [[0 for _ in range(n)] for _ in range(n)] # Each character on its own is a palindrome of length 1. for i in range(n): dp[i][i] = 1 # Fill the dp array. for length in range(2, n + 1): for i in range(n - length + 1): j = i + length - 1 if s[i] == s[j] and length == 2: dp[i][j] = 2 elif s[i] == s[j]: dp[i][j] = dp[i + 1][j - 1] + 2 else: dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]) return dp[0][n - 1]"},{"question":"import heapq class MinHeap: A class to represent a Min-Heap data structure with key update functionality. Methods ------- __init__(self): Initializes an empty min-heap. insert(self, key, value): Inserts a key-value pair into the min-heap. extract_min(self): Removes and returns the key-value pair with the smallest key from the heap. update_key(self, current_key, new_key): Updates the key of an existing element to a new key, maintaining the heap property. def __init__(self): pass def insert(self, key, value): pass def extract_min(self): pass def update_key(self, current_key, new_key): pass # Example usage min_heap = MinHeap() min_heap.insert(10, \\"Value1\\") min_heap.insert(4, \\"Value2\\") min_heap.insert(15, \\"Value3\\") print(min_heap.extract_min()) # Output: (4, \\"Value2\\") min_heap.update_key(10, 2) print(min_heap.extract_min()) # Output: (2, \\"Value1\\") print(min_heap.extract_min()) # Output: (15, \\"Value3\\") # Unit Tests def test_insert_and_extract_min(): min_heap = MinHeap() min_heap.insert(10, \\"Value1\\") min_heap.insert(4, \\"Value2\\") min_heap.insert(15, \\"Value3\\") assert min_heap.extract_min() == (4, \\"Value2\\") assert min_heap.extract_min() == (10, \\"Value1\\") assert min_heap.extract_min() == (15, \\"Value3\\") def test_update_key(): min_heap = MinHeap() min_heap.insert(10, \\"Value1\\") min_heap.insert(4, \\"Value2\\") min_heap.insert(15, \\"Value3\\") min_heap.update_key(10, 2) assert min_heap.extract_min() == (2, \\"Value1\\") assert min_heap.extract_min() == (4, \\"Value2\\") assert min_heap.extract_min() == (15, \\"Value3\\") def test_extract_min_empty_heap(): min_heap = MinHeap() with pytest.raises(KeyError): min_heap.extract_min() def test_update_key_non_existing(): min_heap = MinHeap() min_heap.insert(10, \\"Value1\\") with pytest.raises(KeyError): min_heap.update_key(5, 7) def test_insert_update_extract(): min_heap = MinHeap() min_heap.insert(6, \\"Test1\\") min_heap.insert(8, \\"Test2\\") min_heap.update_key(6, 5) assert min_heap.extract_min() == (5, \\"Test1\\") assert min_heap.extract_min() == (8, \\"Test2\\")","solution":"import heapq class MinHeap: def __init__(self): self.heap = [] self.entry_finder = {} # mapping of keys to entries self.REMOVED = '<removed-item>' # placeholder for a removed item self.counter = 0 def insert(self, key, value): 'Add a new key or update the value of an existing key' if key in self.entry_finder: self.remove_entry(key) count = self.counter entry = [key, count, value] self.entry_finder[key] = entry heapq.heappush(self.heap, entry) self.counter += 1 def remove_entry(self, key): 'Mark an existing entry as REMOVED. Raise KeyError if not found.' entry = self.entry_finder.pop(key) entry[-1] = self.REMOVED def extract_min(self): 'Remove and return the lowest key and value pair. Raise KeyError if empty.' while self.heap: key, count, value = heapq.heappop(self.heap) if value is not self.REMOVED: del self.entry_finder[key] return (key, value) raise KeyError('pop from an empty priority queue') def update_key(self, current_key, new_key): 'Update the key of an existing entry to a new key' if current_key not in self.entry_finder: raise KeyError('Current key not found.') value = self.entry_finder[current_key][2] self.remove_entry(current_key) self.insert(new_key, value)"},{"question":"import numpy as np def initialize_centroids(data: np.ndarray, k: int) -> np.ndarray: Randomly selects k data points from the input data as initial centroids. # Your code here to randomly select k data points as initial centroids def euclidean_distance(a: np.ndarray, b: np.ndarray) -> float: Computes the Euclidean distance between two points a and b. # Your code here to compute the Euclidean distance between two points def k_means(data: np.ndarray, k: int, max_iters: int = 100) -> (np.ndarray, np.ndarray): Performs K-Means clustering algorithm. Parameters: data (np.ndarray): The input data points (n_samples x n_features). k (int): The number of clusters. max_iters (int): The maximum number of iterations. Returns: centroids (np.ndarray): The final centroids (k x n_features). labels (np.ndarray): The cluster assignments for each data point (n_samples). # Your code here to implement the K-Means clustering algorithm # Return the final centroids and data point assignments from solution import initialize_centroids, euclidean_distance, k_means def test_initialize_centroids(): data = np.array([[1, 2], [3, 4], [5, 6], [7, 8], [9, 10]]) k = 2 centroids = initialize_centroids(data, k) assert centroids.shape == (k, data.shape[1]) for centroid in centroids: assert any((centroid == data_point).all() for data_point in data) def test_euclidean_distance(): a = np.array([1, 2]) b = np.array([4, 6]) assert euclidean_distance(a, b) == 5.0 def test_k_means_convergence(): data = np.array([[1, 2], [2, 3], [3, 4], [8, 9], [9, 10], [10, 11]]) k = 2 centroids, labels = k_means(data, k, max_iters=100) assert centroids.shape == (k, data.shape[1]) assert labels.shape == (data.shape[0],) assert set(labels) == {0, 1} def test_k_means_clusters(): data = np.array([[1, 2], [2, 3], [3, 4], [8, 9], [9, 10], [10, 11]]) k = 2 max_iters = 100 centroids, labels = k_means(data, k, max_iters) assert len(set(labels)) == k def test_k_means_single_cluster(): data = np.array([[1, 2], [2, 3], [3, 4]]) k = 1 centroids, labels = k_means(data, k, max_iters=100) assert centroids.shape == (k, data.shape[1]) assert all(label == 0 for label in labels) np.testing.assert_array_equal(centroids, data.mean(axis=0).reshape((1, -1)))","solution":"import numpy as np def initialize_centroids(data: np.ndarray, k: int) -> np.ndarray: Randomly selects k data points from the input data as initial centroids. indices = np.random.choice(data.shape[0], k, replace=False) return data[indices] def euclidean_distance(a: np.ndarray, b: np.ndarray) -> float: Computes the Euclidean distance between two points a and b. return np.sqrt(np.sum((a - b) ** 2)) def k_means(data: np.ndarray, k: int, max_iters: int = 100) -> (np.ndarray, np.ndarray): Performs K-Means clustering algorithm. Parameters: data (np.ndarray): The input data points (n_samples x n_features). k (int): The number of clusters. max_iters (int): The maximum number of iterations. Returns: centroids (np.ndarray): The final centroids (k x n_features). labels (np.ndarray): The cluster assignments for each data point (n_samples). centroids = initialize_centroids(data, k) for _ in range(max_iters): # Assign each data point to the nearest centroid labels = np.array([np.argmin([euclidean_distance(x, centroid) for centroid in centroids]) for x in data]) # Compute new centroids new_centroids = np.array([data[labels == i].mean(axis=0) for i in range(k)]) # Check for convergence (i.e., if centroids do not change) if np.all(centroids == new_centroids): break centroids = new_centroids return centroids, labels"},{"question":"def count_unique_elements(arr: list[int]) -> int: Count the number of unique elements in a given sorted rotated array. Parameters: arr (list[int]): A sorted rotated array of unique integers. Returns: int: The count of unique elements in the array. >>> count_unique_elements([4, 5, 6, 7, 0, 1, 2]) 7 >>> count_unique_elements([1]) 1 >>> count_unique_elements([]) 0 import pytest def test_count_unique_elements(): assert count_unique_elements([4, 5, 6, 7, 0, 1, 2]) == 7 assert count_unique_elements([1, 2, 3, 4, 5, 6, 7]) == 7 assert count_unique_elements([1]) == 1 assert count_unique_elements([]) == 0 assert count_unique_elements([10, 20, 30, 40, 50, 5, 6, 7, 8, 9]) == 10 assert count_unique_elements([3, 4, 5, 1, 2]) == 5 def test_count_unique_elements_large_input(): # Test case with large input size large_input = list(range(1000000)) + [1000000] assert count_unique_elements(large_input) == 1000001","solution":"def count_unique_elements(arr: list[int]) -> int: Returns the count of unique elements in the given sorted rotated array. Parameters: arr (list[int]): A sorted rotated array of unique integers. Returns: int: The count of unique elements in the array. return len(arr)"},{"question":"def reverse_words(s: str) -> str: Reverse the order of words in a given string. :param s: Input string to reverse words in. :return: String with words in reversed order. >>> reverse_words(\\"hello world\\") \\"world hello\\" >>> reverse_words(\\" hello world \\") \\"world hello\\" >>> reverse_words(\\"a quick brown fox\\") \\"fox brown quick a\\" >>> reverse_words(\\"the quick BROWN fox\\") \\"fox BROWN quick the\\" >>> reverse_words(\\"Keep Coding and keep Learning\\") \\"Learning keep and Coding Keep\\"","solution":"def reverse_words(s: str) -> str: Reverse the order of words in a given string. :param s: Input string to reverse words in. :return: String with words in reversed order. # Split the string into words, filtering out empty words caused by multiple spaces words = [word for word in s.split() if word] # Reverse the list of words reversed_words = words[::-1] # Join the reversed list of words into a single string with a single space separator return ' '.join(reversed_words)"},{"question":"from typing import List, Tuple def min_spanning_tree( num_nodes: int, edges: List[Tuple[int, int, int]] ) -> Tuple[int, List[Tuple[int, int]]]: Compute the Minimum Spanning Tree (MST) of a given graph using Kruskal's algorithm. Parameters: num_nodes (int): The number of nodes in the graph. edges (List[Tuple[int, int, int]]): A list of tuples where each tuple (u, v, w) represents an edge between nodes u and v with weight w. Returns: Tuple[int, List[Tuple[int, int]]]: The total weight of the MST and a list of edges (as tuples of nodes) that form the MST. Examples: >>> min_spanning_tree(4, [(0, 1, 1), (1, 2, 4), (0, 2, 3), (2, 3, 2), (1, 3, 5)]) (6, [(0, 1), (2, 3), (0, 2)]) >>> min_spanning_tree(3, [(0, 1, 1), (1, 2, 2), (0, 2, 3)]) (3, [(0, 1), (1, 2)]) pass # Test cases def test_example1(): num_nodes = 4 edges = [(0, 1, 1), (1, 2, 4), (0, 2, 3), (2, 3, 2), (1, 3, 5)] result = min_spanning_tree(num_nodes, edges) assert result == (6, [(0, 1), (2, 3), (0, 2)]) def test_example2(): num_nodes = 3 edges = [(0, 1, 1), (1, 2, 2), (0, 2, 3)] result = min_spanning_tree(num_nodes, edges) assert result == (3, [(0, 1), (1, 2)]) def test_single_edge(): num_nodes = 2 edges = [(0, 1, 10)] result = min_spanning_tree(num_nodes, edges) assert result == (10, [(0, 1)]) def test_large_graph(): num_nodes = 4 edges = [(0, 1, 10), (0, 2, 6), (0, 3, 5), (1, 3, 15), (2, 3, 4)] result = min_spanning_tree(num_nodes, edges) assert result == (19, [(2, 3), (0, 3), (0, 1)])","solution":"from typing import List, Tuple def find(parent, i): if parent[i] == i: return i else: return find(parent, parent[i]) def union(parent, rank, x, y): xroot = find(parent, x) yroot = find(parent, y) if rank[xroot] < rank[yroot]: parent[xroot] = yroot elif rank[xroot] > rank[yroot]: parent[yroot] = xroot else: parent[yroot] = xroot rank[xroot] += 1 def min_spanning_tree(num_nodes: int, edges: List[Tuple[int, int, int]]) -> Tuple[int, List[Tuple[int, int]]]: Compute the Minimum Spanning Tree (MST) of a given graph using Kruskal's algorithm. Parameters: num_nodes (int): The number of nodes in the graph. edges (List[Tuple[int, int, int]]): A list of tuples where each tuple (u, v, w) represents an edge between nodes u and v with weight w. Returns: Tuple[int, List[Tuple[int, int]]]: The total weight of the MST and a list of edges (as tuples of nodes) that form the MST. # Sort all the edges in non-decreasing order of their weight edges = sorted(edges, key=lambda item: item[2]) parent = [] rank = [] # Initialize \`parent\` and \`rank\` arrays for all nodes for node in range(num_nodes): parent.append(node) rank.append(0) result = [] # This will store the resultant MST i = 0 # Index variable, used for sorted edges e = 0 # Index variable, used for result array # Number of edges to be taken is equal to V-1 while e < num_nodes - 1: # Step 2: Pick the smallest edge. Check if it forms a cycle with the spanning tree formed so far. u, v, w = edges[i] i = i + 1 x = find(parent, u) y = find(parent, v) # If including this edge does not cause a cycle, include it in the result. if x != y: e = e + 1 result.append((u, v, w)) union(parent, rank, x, y) # Calculate the total weight of the MST total_weight = sum([w for u, v, w in result]) # Extract only the edges, without the weights mst_edges = [(u, v) for u, v, w in result] return total_weight, mst_edges"},{"question":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def insert_bst(root, value): Inserts a value into the BST while maintaining the BST property. :param root: TreeNode, the root node of the BST :param value: int, the value to be inserted :return: TreeNode, the root node of the BST after insertion # Implement the function to insert a value into the BST pass def bst_depth(root): Calculates the depth (or height) of the BST. :param root: TreeNode, the root node of the BST :return: int, the depth of the BST # Implement the function to calculate the depth of the BST pass","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def insert_bst(root, value): Inserts a value into the BST while maintaining the BST property. :param root: TreeNode, the root node of the BST :param value: int, the value to be inserted :return: TreeNode, the root node of the BST after insertion if root is None: return TreeNode(value) if value < root.value: root.left = insert_bst(root.left, value) elif value > root.value: root.right = insert_bst(root.right, value) return root def bst_depth(root): Calculates the depth (or height) of the BST. :param root: TreeNode, the root node of the BST :return: int, the depth of the BST if root is None: return 0 left_depth = bst_depth(root.left) right_depth = bst_depth(root.right) return max(left_depth, right_depth) + 1"},{"question":"def extract_html_content(html: str, tag: str) -> list[str]: Extracts the content within all HTML tags of a specified type. Args: html (str): The HTML document as a string. tag (str): The HTML tag of interest (e.g., \\"div\\", \\"p\\"). Returns: list[str]: A list of strings representing the content within each matching tag. >>> extract_html_content(\\"<div><p>This is a test</p><p>Another test</p></div>\\", \\"p\\") [\\"This is a test\\", \\"Another test\\"] >>> extract_html_content(\\"<div>Content 1 <span>Ignored</span> Content 2</div><div>Content 3</div>\\", \\"div\\") [\\"Content 1 <span>Ignored</span> Content 2\\", \\"Content 3\\"] >>> extract_html_content(\\"<html><body><h1>Title</h1><p>Paragraph</p></body></html>\\", \\"body\\") [\\"<h1>Title</h1><p>Paragraph</p>\\"] def test_extract_html_content_basic(): html_doc = \\"<div><p>This is a test</p><p>Another test</p></div>\\" assert extract_html_content(html_doc, \\"p\\") == [\\"This is a test\\", \\"Another test\\"] def test_extract_html_content_nested(): html_doc = \\"<div>Content 1 <span>Ignored</span> Content 2</div><div>Content 3</div>\\" assert extract_html_content(html_doc, \\"div\\") == [\\"Content 1 <span>Ignored</span> Content 2\\", \\"Content 3\\"] def test_extract_html_content_single_tag(): html_doc = \\"<html><body><h1>Title</h1><p>Paragraph</p></body></html>\\" assert extract_html_content(html_doc, \\"body\\") == [\\"<h1>Title</h1><p>Paragraph</p>\\"] def test_extract_html_content_no_matching_tags(): html_doc = \\"<html><head>Header</head><body>Content</body></html>\\" assert extract_html_content(html_doc, \\"div\\") == [] def test_extract_html_content_empty_html(): html_doc = \\"\\" assert extract_html_content(html_doc, \\"div\\") == [] def test_extract_html_content_tags_with_attributes(): html_doc = \\"<div class='test'>Content 1</div><div id='main'>Content 2</div>\\" assert extract_html_content(html_doc, \\"div\\") == [\\"Content 1\\", \\"Content 2\\"] def test_extract_html_content_self_closing_tags(): html_doc = \\"<div>Content <img src='image.jpg'/> inside</div>\\" assert extract_html_content(html_doc, \\"div\\") == [\\"Content <img src='image.jpg'/> inside\\"] def test_extract_html_content_whitespace_handling(): html_doc = \\"<div> Content with spaces </div><div>Another content</div>\\" assert extract_html_content(html_doc, \\"div\\") == [\\" Content with spaces \\", \\"Another content\\"] def test_extract_html_content_nested_tag_structure(): html_doc = \\"<div><p><span>Nested</span> Content</p><p>Another test</p></div>\\" assert extract_html_content(html_doc, \\"p\\") == [\\"<span>Nested</span> Content\\", \\"Another test\\"] def test_extract_html_content_no_closing_tag(): html_doc = \\"<div>Content without closing tag\\" assert extract_html_content(html_doc, \\"div\\") == []","solution":"def extract_html_content(html: str, tag: str) -> list[str]: Extracts the content within all HTML tags of a specified type. Args: html (str): The HTML document as a string. tag (str): The HTML tag of interest (e.g., \\"div\\", \\"p\\"). Returns: list[str]: A list of strings representing the content within each matching tag. import re # Pattern to match the given tag and capture the content within it pattern = f'<{tag}[^>]*>(.*?)</{tag}>' # Using re.findall to find all occurrences of the pattern content_list = re.findall(pattern, html, re.DOTALL) # Return the list of matched content return content_list"},{"question":"import random from typing import List def brownian_motion(steps: int, step_size: float) -> List[float]: Simulate the path of a particle undergoing Brownian motion in one-dimensional space. Args: steps (int): The number of steps the particle will take. step_size (float): The size of each step. Returns: List[float]: The positions of the particle at each step, starting from the origin (0.0). >>> brownian_motion(5, 0.5) [0.0, 0.5, 1.0, 0.5, 0.0, 0.5] >>> brownian_motion(3, 1.0) [0.0, -1.0, 0.0, 1.0] >>> brownian_motion(7, 0.1) [0.0, -0.1, -0.2, -0.1, -0.2, -0.1, -0.2, -0.1] pass # Implementation here def test_brownian_motion_basic(): result = brownian_motion(5, 0.5) assert len(result) == 6 assert all(isinstance(pos, float) for pos in result) def test_brownian_motion_step_size_1(): result = brownian_motion(3, 1.0) assert len(result) == 4 assert all(int(pos) == pos for pos in result) def test_brownian_motion_single_step(): result = brownian_motion(1, 0.5) assert len(result) == 2 assert all(isinstance(pos, float) for pos in result) def test_brownian_motion_large_steps(): result = brownian_motion(1000, 0.1) assert len(result) == 1001 assert all(isinstance(pos, float) for pos in result) def test_brownian_motion_zero_step_size(): result = brownian_motion(0, 0.5) assert len(result) == 1 assert result[0] == 0.0","solution":"import random from typing import List def brownian_motion(steps: int, step_size: float) -> List[float]: Simulate the path of a particle undergoing Brownian motion in one-dimensional space. Args: steps: int - the number of steps the particle will take. step_size: float - the size of each step. Returns: List[float] - the positions of the particle at each step, starting from the origin (0.0). positions = [0.0] current_position = 0.0 for _ in range(steps): direction = random.choice([-1, 1]) current_position += direction * step_size positions.append(current_position) return positions"},{"question":"def evaluate_postfix_expression(expression: str) -> float: Evaluates a postfix expression and returns the result as a float. :param expression: A postfix expression string :return: The result of the expression (float) pass # Example Usage # >>> evaluate_postfix_expression(\\"3 4 +\\") # 7.0 # >>> evaluate_postfix_expression(\\"2 3 1 * + 9 -\\") # -4.0 # >>> evaluate_postfix_expression(\\"5 1 2 + 4 * + 3 -\\") # 14.0","solution":"def evaluate_postfix_expression(expression: str) -> float: Evaluates a postfix expression and returns the result as a float. :param expression: A postfix expression string :return: The result of the expression (float) stack = [] operators = {'+', '-', '*', '/'} for token in expression.split(): if token not in operators: stack.append(float(token)) else: b = stack.pop() a = stack.pop() if token == '+': result = a + b elif token == '-': result = a - b elif token == '*': result = a * b elif token == '/': result = a / b stack.append(result) return stack[0]"},{"question":"from typing import List def sum_after_removal(matrix: List[List[int]]) -> int: Sums up the elements in the matrix after removing the maximum and minimum values from each row. Parameters: - matrix: List[List[int]] A 2D list (matrix) where each sublist represents a row of integers. Returns: - int: The sum of the elements in the matrix after removing the maximum and minimum values in each row. Example: >>> sum_after_removal([[10, 20, 30], [5, 15, 25], [1, 2, 3, 4]]) 40 >>> sum_after_removal([[7, 8], [1, -1, 4], [4]]) 1","solution":"from typing import List def sum_after_removal(matrix: List[List[int]]) -> int: total_sum = 0 for row in matrix: if len(row) > 2: max_val = max(row) min_val = min(row) filtered_row = [x for x in row if x != max_val and x != min_val] # In case max and min are the same and removed completely if len(filtered_row) == 0: filtered_row = [0] elif len(row) == 2: # If row has exactly two elements, both are removed filtered_row = [0] elif len(row) == 1: # If row has exactly one element, it is considered zero after removal filtered_row = [0] else: # If the row is empty filtered_row = [0] total_sum += sum(filtered_row) return total_sum"},{"question":"def paint_fill(image: list[list[int]], sr: int, sc: int, new_color: int) -> list[list[int]]: Perform a paint fill on a 2D image. Starting from a given cell, the paint fill changes the color of the starting cell and all connected cells with the same color to a new specified color. A cell is considered connected if it is horizontally or vertically adjacent to another cell with the same color as the starting cell. Args: image (list[list[int]]): A 2D list representing the image. sr (int): The starting row. sc (int): The starting column. new_color (int): The new color to apply. Returns: list[list[int]]: The modified image after performing the paint fill. Examples: >>> image = [ ... [1, 1, 1], ... [1, 1, 0], ... [1, 0, 1] ... ] >>> paint_fill(image, 1, 1, 2) [[2, 2, 2], [2, 2, 0], [2, 0, 1]] >>> image = [ ... [0, 0, 0], ... [0, 0, 0] ... ] >>> paint_fill(image, 0, 0, 3) [[3, 3, 3], [3, 3, 3]] >>> image = [ ... [0] ... ] >>> paint_fill(image, 0, 0, 1) [[1]]","solution":"def paint_fill(image: list[list[int]], sr: int, sc: int, new_color: int) -> list[list[int]]: old_color = image[sr][sc] if old_color == new_color: return image def fill(x, y): if x < 0 or x >= len(image) or y < 0 or y >= len(image[0]): return if image[x][y] != old_color: return image[x][y] = new_color fill(x + 1, y) fill(x - 1, y) fill(x, y + 1) fill(x, y - 1) fill(sr, sc) return image"},{"question":"def frequency_sort(lst: list[int]) -> list[int]: Sorts the list by the frequency of the elements in descending order. If two elements have the same frequency, they should appear in ascending order. Examples: >>> frequency_sort([4, 5, 6, 5, 4, 3]) [4, 4, 5, 5, 3, 6] >>> frequency_sort([1, 2, 1, 2, 1, 3]) [1, 1, 1, 2, 2, 3] >>> frequency_sort([1, 2, 3, 4, 5]) [1, 2, 3, 4, 5] >>> frequency_sort([-1, -1, -2, -2, -2, 0]) [-2, -2, -2, -1, -1, 0]","solution":"from collections import Counter def frequency_sort(lst: list[int]) -> list[int]: Sorts the list by the frequency of the elements in descending order. If two elements have the same frequency, they should appear in ascending order. count = Counter(lst) # Sort by frequency first (descending) and then by element value (ascending) sorted_lst = sorted(lst, key=lambda x: (-count[x], x)) return sorted_lst"},{"question":"class Queue: def __init__(self, limit=10): self.front = 0 self.rear = 0 self.size = 0 self.queue = [None] * limit self.limit = limit def is_empty(self): return self.size == 0 def is_full(self): return self.size == self.limit def enqueue(self, item): if self.is_full(): raise OverflowError(\\"Queue is full\\") self.queue[self.rear] = item self.rear = (self.rear + 1) % self.limit self.size += 1 def dequeue(self): if self.is_empty(): raise IndexError(\\"Queue is empty\\") item = self.queue[self.front] self.queue[self.front] = None self.front = (self.front + 1) % self.limit self.size -= 1 return item def peek(self): if self.is_empty(): raise IndexError(\\"Queue is empty\\") return self.queue[self.front] def get_size(self): return self.size def clone_queue(self) -> 'Queue': Create a clone of the current queue with the same elements in the same order. >>> Q = Queue() >>> Q.enqueue(1) >>> Q.enqueue(2) >>> Q.enqueue(3) >>> new_queue = Q.clone_queue() >>> print(list(new_queue)) [1, 2, 3] # Your code goes here def __iter__(self): idx = self.front count = 0 while count < self.size: yield self.queue[idx] idx = (idx + 1) % self.limit count += 1 import pytest from solution import Queue def test_clone_empty_queue(): Q = Queue() cloned_Q = Q.clone_queue() assert list(cloned_Q) == [] def test_clone_non_empty_queue(): Q = Queue() Q.enqueue(1) Q.enqueue(2) Q.enqueue(3) cloned_Q = Q.clone_queue() assert list(cloned_Q) == [1, 2, 3] def test_clone_queue_integrity(): Q = Queue() Q.enqueue(10) Q.enqueue(20) Q.enqueue(30) Q.enqueue(40) cloned_Q = Q.clone_queue() assert list(cloned_Q) == [10, 20, 30, 40] Q.dequeue() Q.enqueue(50) assert list(Q) == [20, 30, 40, 50] assert list(cloned_Q) == [10, 20, 30, 40] def test_clone_full_queue(): Q = Queue(3) Q.enqueue(1) Q.enqueue(2) Q.enqueue(3) cloned_Q = Q.clone_queue() assert list(cloned_Q) == [1, 2, 3] with pytest.raises(OverflowError): cloned_Q.enqueue(4)","solution":"class Queue: def __init__(self, limit=10): self.front = 0 self.rear = 0 self.size = 0 self.queue = [None] * limit self.limit = limit def is_empty(self): return self.size == 0 def is_full(self): return self.size == self.limit def enqueue(self, item): if self.is_full(): raise OverflowError(\\"Queue is full\\") self.queue[self.rear] = item self.rear = (self.rear + 1) % self.limit self.size += 1 def dequeue(self): if self.is_empty(): raise IndexError(\\"Queue is empty\\") item = self.queue[self.front] self.queue[self.front] = None self.front = (self.front + 1) % self.limit self.size -= 1 return item def peek(self): if self.is_empty(): raise IndexError(\\"Queue is empty\\") return self.queue[self.front] def get_size(self): return self.size def clone_queue(self): new_queue = Queue(self.limit) for i in range(self.size): item = self.queue[(self.front + i) % self.limit] new_queue.enqueue(item) return new_queue def __iter__(self): idx = self.front count = 0 while count < self.size: yield self.queue[idx] idx = (idx + 1) % self.limit count += 1"},{"question":"def find_common_elements(arr1: list, arr2: list) -> list: Finds all the common elements between two sorted lists and returns them in a new sorted list. >>> find_common_elements([1, 2, 4, 5, 6], [2, 3, 5, 7]) [2, 5] >>> find_common_elements([10, 20, 30, 40, 50], [15, 25, 35, 45]) [] >>> find_common_elements([7, 8, 9], [7, 8, 9]) [7, 8, 9] >>> find_common_elements([], [1, 2, 3]) [] >>> find_common_elements([100, 200], [50, 100, 150, 200]) [100, 200]","solution":"def find_common_elements(arr1, arr2): Finds the common elements between two sorted lists and returns them in sorted order. Parameters: - arr1: list, the first sorted list of integers - arr2: list, the second sorted list of integers Returns: - list: a sorted list containing the common elements # Initialize pointers for both lists i, j = 0, 0 result = [] # Traverse both lists until we reach the end of one of them while i < len(arr1) and j < len(arr2): if arr1[i] == arr2[j]: result.append(arr1[i]) i += 1 j += 1 elif arr1[i] < arr2[j]: i += 1 else: j += 1 return result"},{"question":"from typing import List def find_subarray_with_max_sum(arr: List[int]) -> int: Find the contiguous subarray within a given array of integers \`arr\` which has the largest sum. >>> find_subarray_with_max_sum([1, -3, 2, 1, -1]) 3 >>> find_subarray_with_max_sum([-2, -3, -1]) -1 >>> find_subarray_with_max_sum([5, 4, -1, 7, 8]) 23","solution":"from typing import List def find_subarray_with_max_sum(arr: List[int]) -> int: max_current = max_global = arr[0] for num in arr[1:]: max_current = max(num, max_current + num) if max_current > max_global: max_global = max_current return max_global print(find_subarray_with_max_sum([1, -3, 2, 1, -1])) # Output: 3 print(find_subarray_with_max_sum([-2, -3, -1])) # Output: -1 print(find_subarray_with_max_sum([5, 4, -1, 7, 8])) # Output: 23"},{"question":"def max_difference(array: list[int]) -> int: Find the largest difference between any two elements in an array such that the larger element comes after the smaller one. >>> max_difference([2, 3, 10, 6, 4, 8, 1]) 8 >>> max_difference([7, 9, 5, 6, 3, 2]) 2 >>> max_difference([1, 2]) 1 >>> max_difference([4, 3, 2, 1]) -1 >>> max_difference([10, 2, 5, 1, 8, 7, 6]) 7","solution":"def max_difference(array: list[int]) -> int: if not array or len(array) < 2: return -1 min_element = array[0] max_diff = -1 for i in range(1, len(array)): if array[i] > min_element: max_diff = max(max_diff, array[i] - min_element) min_element = min(min_element, array[i]) return max_diff"},{"question":"def reverse_preserve_spaces(input_string: str) -> str: Reverse the words in the given string while maintaining the positions of spaces. Examples: >>> reverse_preserve_spaces(\\"hello world\\") 'world hello' >>> reverse_preserve_spaces(\\" quick brown fox \\") ' fox brown quick ' >>> reverse_preserve_spaces(\\"a b c\\") 'c b a' >>> reverse_preserve_spaces(\\"singleWord\\") 'singleWord' >>> reverse_preserve_spaces(\\"a\\") 'a' >>> reverse_preserve_spaces(123) Traceback (most recent call last): ... TypeError: input_string must be a string.","solution":"def reverse_preserve_spaces(input_string: str) -> str: if not isinstance(input_string, str): raise TypeError(\\"input_string must be a string.\\") # Split the input_string by spaces to get the words words = input_string.split() # Reverse the list of words reversed_words = list(reversed(words)) # Create an iterator for the reversed words word_iter = iter(reversed_words) # Rebuild the output string using the original spacing as a template output = [] in_word = False for char in input_string: if char == ' ': output.append(char) in_word = False else: if not in_word: output.append(next(word_iter)) in_word = True return \\"\\".join(output)"},{"question":"from typing import List, Tuple def find_ceo(N: int, relationships: List[Tuple[int, int]]) -> int: Identify the CEO's ID based on employee-manager relationships. Parameters: N (int): Total number of employees. relationships (List[Tuple[int, int]]): List of pairs where each pair (x, y) indicates employee x reports to manager y. Returns: int: The ID of the CEO, who has no manager. Examples: >>> find_ceo(3, [(2, 1), (3, 1)]) 1 >>> find_ceo(4, [(2, 1), (3, 2), (4, 2)]) 1 >>> find_ceo(5, [(2, 3), (3, 4), (4, 5), (1, 5)]) 5 pass def test_find_ceo_example1(): N = 3 relationships = [(2, 1), (3, 1)] assert find_ceo(N, relationships) == 1 def test_find_ceo_example2(): N = 4 relationships = [(2, 1), (3, 2), (4, 2)] assert find_ceo(N, relationships) == 1 def test_find_ceo_example3(): N = 5 relationships = [(2, 3), (3, 4), (4, 5), (1, 5)] assert find_ceo(N, relationships) == 5 def test_find_ceo_single_chain(): N = 4 relationships = [(2, 1), (3, 2), (4, 3)] assert find_ceo(N, relationships) == 1 def test_find_ceo_two_levels(): N = 6 relationships = [(2, 1), (3, 1), (4, 2), (5, 2), (6, 3)] assert find_ceo(N, relationships) == 1 def test_find_ceo_uneven_structure(): N = 7 relationships = [(2, 1), (3, 1), (4, 3), (5, 3), (6, 5), (7, 5)] assert find_ceo(N, relationships) == 1","solution":"from typing import List, Tuple def find_ceo(N: int, relationships: List[Tuple[int, int]]) -> int: # Step 1: Create a set for all employees and another set for those who are direct subordinates employees = set(range(1, N+1)) subordinates = set() # Step 2: Populate the subordinates set for emp, mgr in relationships: subordinates.add(emp) # Step 3: The CEO will be the one who is not a subordinate of anyone else ceo = employees - subordinates # Step 4: Convert the set to list and return the first (and only) element return list(ceo)[0]"},{"question":"def quicksort(arr: list[int], low: int, high: int) -> None: Sorts the array using the QuickSort algorithm with Lomuto partition scheme. Parameters: arr (list[int]): A list of integers to be sorted. low (int): The starting index of the list to sort. high (int): The ending index of the list to sort. Returns: None: The function sorts the input list in-place. Examples: >>> arr = [3, 6, 8, 10, 1, 2, 1] >>> quicksort(arr, 0, len(arr) - 1) >>> arr [1, 1, 2, 3, 6, 8, 10] >>> arr = [1] >>> quicksort(arr, 0, len(arr) - 1) >>> arr [1] >>> arr = [10, 7, 8, 9, 1, 5] >>> quicksort(arr, 0, len(arr) - 1) >>> arr [1, 5, 7, 8, 9, 10] pass def test_simple_case(): arr = [3, 6, 8, 10, 1, 2, 1] quicksort(arr, 0, len(arr) - 1) assert arr == [1, 1, 2, 3, 6, 8, 10] def test_single_element(): arr = [1] quicksort(arr, 0, len(arr) - 1) assert arr == [1] def test_already_sorted(): arr = [1, 2, 3, 4, 5] quicksort(arr, 0, len(arr) - 1) assert arr == [1, 2, 3, 4, 5] def test_reverse_sorted(): arr = [5, 4, 3, 2, 1] quicksort(arr, 0, len(arr) - 1) assert arr == [1, 2, 3, 4, 5] def test_with_duplicates(): arr = [4, 5, 4, 4, 2, 1, 3, 4] quicksort(arr, 0, len(arr) - 1) assert arr == [1, 2, 3, 4, 4, 4, 4, 5] def test_large_numbers(): arr = [1000000000, -1000000000, 0, 999999999, -999999999] quicksort(arr, 0, len(arr) - 1) assert arr == [-1000000000, -999999999, 0, 999999999, 1000000000] def test_empty_array(): arr = [] quicksort(arr, 0, len(arr) - 1) assert arr == []","solution":"def quicksort(arr, low, high): Sorts the array using the QuickSort algorithm with Lomuto partition scheme. Parameters: arr (list[int]): A list of integers to be sorted. low (int): The starting index of the list to sort. high (int): The ending index of the list to sort. Returns: None: The function sorts the input list in-place. def lomuto_partition(arr, low, high): pivot = arr[high] i = low - 1 for j in range(low, high): if arr[j] <= pivot: i += 1 arr[i], arr[j] = arr[j], arr[i] arr[i + 1], arr[high] = arr[high], arr[i + 1] return i + 1 if low < high: p = lomuto_partition(arr, low, high) quicksort(arr, low, p - 1) quicksort(arr, p + 1, high)"},{"question":"from typing import List def is_prime_trial_division(n: int) -> bool: Determines if n is a prime number using trial division method. >>> is_prime_trial_division(29) True >>> is_prime_trial_division(45) False pass def primes_sieve_of_eratosthenes(limit: int) -> List[int]: Generates a list of prime numbers up to limit using the Sieve of Eratosthenes. >>> primes_sieve_of_eratosthenes(30) [2, 3, 5, 7, 11, 13, 17, 19, 23, 29] >>> primes_sieve_of_eratosthenes(1) [] pass","solution":"from typing import List def is_prime_trial_division(n: int) -> bool: Determines if n is a prime number using trial division method. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while (i * i) <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def primes_sieve_of_eratosthenes(limit: int) -> List[int]: Generates a list of prime numbers up to limit using the Sieve of Eratosthenes. if limit < 2: return [] sieve = [True] * (limit + 1) sieve[0] = sieve[1] = False for start in range(2, int(limit**0.5) + 1): if sieve[start]: for multiple in range(start*start, limit + 1, start): sieve[multiple] = False return [num for num in range(limit + 1) if sieve[num]]"},{"question":"import heapq from typing import Dict, List, Tuple def prims_mst(graph: Dict[int, List[Tuple[int, float]]]) -> List[Tuple[int, int, float]]: Execute Prim's algorithm to find the Minimum Spanning Tree of the given graph. Args: graph (Dict[int, List[Tuple[int, float]]]): The adjacency list of a weighted undirected graph. Returns: List[Tuple[int, int, float]]: A list of edges in the Minimum Spanning Tree. Each edge is represented as a tuple (node1, node2, weight). Examples: >>> graph = { ... 0: [(1, 4), (7, 8)], ... 1: [(0, 4), (2, 8), (7, 11)], ... 2: [(1, 8), (3, 7), (8, 2), (5, 4)], ... 3: [(2, 7), (4, 9), (5, 14)], ... 4: [(3, 9), (5, 10)], ... 5: [(2, 4), (3, 14), (4, 10), (6, 2)], ... 6: [(5, 2), (7, 1), (8, 6)], ... 7: [(0, 8), (1, 11), (6, 1), (8, 7)], ... 8: [(2, 2), (6, 6), (7, 7)] ... } >>> prims_mst(graph) [(0, 1, 4), (0, 7, 8), (7, 6, 1), (6, 5, 2), (5, 2, 4), (2, 8, 2), (2, 3, 7), (3, 4, 9)]","solution":"import heapq from typing import Dict, List, Tuple def prims_mst(graph: Dict[int, List[Tuple[int, float]]]) -> List[Tuple[int, int, float]]: # Number of nodes in the graph num_nodes = len(graph) # To store the MST edges mst_edges = [] # Priority queue for edges edge_pq = [] # Visited set to keep track of nodes already added to MST visited = set() # Start with an arbitrary node, here node 0 start_node = 0 visited.add(start_node) # Add all edges from the start node to the priority queue for neighbor, weight in graph[start_node]: heapq.heappush(edge_pq, (weight, start_node, neighbor)) # While there are edges in the priority queue and we haven't visited all nodes while edge_pq and len(visited) < num_nodes: # Get the edge with the smallest weight weight, frm, to = heapq.heappop(edge_pq) # If the destination node of this edge is already visited, skip it if to in visited: continue # Add the edge to the MST mst_edges.append((frm, to, weight)) visited.add(to) # Add all edges from the new node to non-visited nodes to the priority queue for neighbor, weight in graph[to]: if neighbor not in visited: heapq.heappush(edge_pq, (weight, to, neighbor)) return mst_edges"},{"question":"def is_prime_palindrome(n: int) -> bool: Determine if a number is a prime palindrome. A prime palindrome is a number that is both a prime number and reads the same backward as forward. Args: n (int): The number to check. Returns: bool: True if the number is a prime palindrome, False otherwise. Examples: >>> is_prime_palindrome(131) True >>> is_prime_palindrome(101) True >>> is_prime_palindrome(123) False >>> is_prime_palindrome(10) False","solution":"def is_prime_palindrome(n: int) -> bool: # Function to check if a number is prime def is_prime(num): if num <= 1: return False if num <= 3: return True if num % 2 == 0 or num % 3 == 0: return False i = 5 while i * i <= num: if num % i == 0 or num % (i + 2) == 0: return False i += 6 return True # Function to check if a number is a palindrome def is_palindrome(num): return str(num) == str(num)[::-1] # Check both conditions return is_prime(n) and is_palindrome(n)"},{"question":"from datetime import datetime class Logger: def __init__(self, level: str = \\"INFO\\"): Initializes the Logger with a specified logging level (\\"INFO\\", \\"WARNING\\", \\"ERROR\\"). def log_info(self, message: str): Logs an informational message with the level INFO. def log_warning(self, message: str): Logs a warning message with the level WARNING. def log_error(self, message: str): Logs an error message with the level ERROR. def set_level(self, level: str): Sets the logging level (INFO, WARNING, ERROR). def get_logs(self): Returns a list of all logged messages that meet or exceed the current logging level, each prefixed with its level and timestamp. # Unit tests import pytest import time def test_log_info(): logger = Logger() logger.log_info(\\"This is an info message\\") logs = logger.get_logs() assert len(logs) == 1 assert \\"[INFO] This is an info message\\" in logs[0] def test_log_warning(): logger = Logger() logger.log_warning(\\"This is a warning message\\") logs = logger.get_logs() assert len(logs) == 1 assert \\"[WARNING] This is a warning message\\" in logs[0] def test_log_error(): logger = Logger() logger.log_error(\\"This is an error message\\") logs = logger.get_logs() assert len(logs) == 1 assert \\"[ERROR] This is an error message\\" in logs[0] def test_set_level(): logger = Logger() logger.set_level(\\"WARNING\\") assert logger.level == \\"WARNING\\" with pytest.raises(ValueError): logger.set_level(\\"INVALID\\") def test_filter_logs_by_level(): logger = Logger() logger.log_info(\\"Info message\\") logger.log_warning(\\"Warning message\\") logger.log_error(\\"Error message\\") logger.set_level(\\"WARNING\\") logs = logger.get_logs() assert len(logs) == 2 assert \\"[WARNING] Warning message\\" in logs[0] assert \\"[ERROR] Error message\\" in logs[1] logger.set_level(\\"ERROR\\") logs = logger.get_logs() assert len(logs) == 1 assert \\"[ERROR] Error message\\" in logs[0] def test_log_timestamps(): logger = Logger() logger.log_info(\\"First message\\") time.sleep(1) logger.log_warning(\\"Second message\\") time.sleep(1) logger.log_error(\\"Third message\\") logs = logger.get_logs() timestamps = [datetime.strptime(log.split(' [')[0], \\"%Y-%m-%d %H:%M:%S\\") for log in logs] assert len(logs) == 3 assert (timestamps[1] - timestamps[0]).seconds == 1 assert (timestamps[2] - timestamps[1]).seconds == 1","solution":"from datetime import datetime class Logger: def __init__(self, level: str = \\"INFO\\"): self.level = level self.logs = [] self.levels = {\\"INFO\\": 1, \\"WARNING\\": 2, \\"ERROR\\": 3} def log_info(self, message: str): self._log(\\"INFO\\", message) def log_warning(self, message: str): self._log(\\"WARNING\\", message) def log_error(self, message: str): self._log(\\"ERROR\\", message) def set_level(self, level: str): if level in self.levels: self.level = level else: raise ValueError(\\"Invalid logging level\\") def get_logs(self): current_level_num = self.levels[self.level] filtered_logs = [log for log in self.logs if self.levels[log['level']] >= current_level_num] return [self._format_log(log) for log in filtered_logs] def _log(self, level: str, message: str): timestamp = datetime.now().strftime(\\"%Y-%m-%d %H:%M:%S\\") self.logs.append({\\"level\\": level, \\"message\\": message, \\"timestamp\\": timestamp}) def _format_log(self, log): return f\\"{log['timestamp']} [{log['level']}] {log['message']}\\""},{"question":"import hashlib import os def register_user(username: str, password: str) -> dict: Register a new user, hashing their password with a unique salt. Parameters: - username <type: str>: the username to register. - password <type: str>: the user's password. Return: - user_db <type: dict>: dictionary with 'username' as key and hashed password with salt as value. # Implementation here def login_user(username: str, password: str, user_db: dict) -> bool: Authenticate a user by validating their password. Parameters: - username <type: str>: the username to login. - password <type: str>: the password provided by the user. - user_db <type: dict>: dictionary with registered users and their hashed passwords. Return: - <type: bool>: True if login is successful, False otherwise. # Implementation here def test_register_user(): user_db = register_user(\\"testuser\\", \\"securepassword\\") assert \\"testuser\\" in user_db salt, hashed_password = user_db[\\"testuser\\"] assert len(salt) == 16 # Ensure salt length is 16 bytes assert len(hashed_password) == 64 # Hexdigest length for SHA-256 is 64 characters def test_login_user_success(): user_db = register_user(\\"testuser\\", \\"securepassword\\") assert login_user(\\"testuser\\", \\"securepassword\\", user_db) == True def test_login_user_failure_wrong_password(): user_db = register_user(\\"testuser\\", \\"securepassword\\") assert login_user(\\"testuser\\", \\"wrongpassword\\", user_db) == False def test_login_user_failure_nonexistent_user(): user_db = register_user(\\"testuser\\", \\"securepassword\\") assert login_user(\\"nonexistentuser\\", \\"securepassword\\", user_db) == False def test_register_user_with_empty_username(): try: register_user(\\"\\", \\"securepassword\\") except ValueError as e: assert str(e) == \\"Username and password must be non-empty\\" def test_register_user_with_empty_password(): try: register_user(\\"testuser\\", \\"\\") except ValueError as e: assert str(e) == \\"Username and password must be non-empty\\"","solution":"import hashlib import os def register_user(username: str, password: str) -> dict: Register a new user, hashing their password with a unique salt. Parameters: - username <type: str>: the username to register. - password <type: str>: the user's password. Return: - user_db <type: dict>: dictionary with 'username' as key and hashed password with salt as value. if not username or not password: raise ValueError(\\"Username and password must be non-empty\\") salt = os.urandom(16) # Generate a unique salt hashed_password = hashlib.sha256(salt + password.encode()).hexdigest() return {username: (salt, hashed_password)} def login_user(username: str, password: str, user_db: dict) -> bool: Authenticate a user by validating their password. Parameters: - username <type: str>: the username to login. - password <type: str>: the password provided by the user. - user_db <type: dict>: dictionary with registered users and their hashed passwords. Return: - <type: bool>: True if login is successful, False otherwise. if username not in user_db: return False salt, stored_hash = user_db[username] hashed_password = hashlib.sha256(salt + password.encode()).hexdigest() return hashed_password == stored_hash"},{"question":"from typing import List def median_of_medians(arr: List[int], left: int, right: int) -> int: Selects the pivot element using the Median of Medians method within the given subarray. :param arr: The input array. :param left: The starting index of the subarray. :param right: The ending index of the subarray. :return: The pivot element selected using the Median of Medians method. pass def partition(arr: List[int], left: int, right: int, pivot: int) -> int: Partitions the array around the given pivot element. :param arr: The input array. :param left: The starting index of the subarray. :param right: The ending index of the subarray. :param pivot: The pivot element for partitioning. :return: The index of the pivot element after partitioning. pass def quickselect(arr: List[int], left: int, right: int, k: int) -> int: Finds the k-th smallest element in the array using the Quickselect algorithm. :param arr: The input array. :param left: The starting index of the subarray. :param right: The ending index of the subarray. :param k: The order of the smallest element to find (1-based index). :return: The k-th smallest element in the array. pass def test_quickselect_example(): array = [12, 3, 5, 7, 4, 19, 26] k = 3 assert quickselect(array, 0, len(array) - 1, k) == 5 def test_quickselect_duplicate_elements(): array = [12, 3, 5, 7, 5, 19, 12, 26] k = 4 assert quickselect(array, 0, len(array) - 1, k) == 7 def test_quickselect_single_element(): array = [10] k = 1 assert quickselect(array, 0, 0, k) == 10 def test_quickselect_k_out_of_bounds(): array = [1, 2, 3, 4, 5] k = 6 try: quickselect(array, 0, len(array) - 1, k) assert False, \\"Expected an IndexError\\" except IndexError: assert True def test_quickselect_large_dataset(): array = list(range(1000, 0, -1)) k = 500 assert quickselect(array, 0, len(array) - 1, k) == 500","solution":"from typing import List def median_of_medians(arr: List[int], left: int, right: int) -> int: Selects the pivot element using the Median of Medians method within the given subarray. n = right - left + 1 if n <= 5: return sorted(arr[left:right + 1])[n // 2] medians = [] for i in range(left, right + 1, 5): sub_right = min(i + 4, right) median = sorted(arr[i:sub_right + 1])[((sub_right - i) // 2)] medians.append(median) return median_of_medians(medians, 0, len(medians) - 1) def partition(arr: List[int], left: int, right: int, pivot: int) -> int: Partitions the array around the given pivot element. pivot_index = arr.index(pivot) arr[pivot_index], arr[right] = arr[right], arr[pivot_index] store_index = left for i in range(left, right): if arr[i] < pivot: arr[store_index], arr[i] = arr[i], arr[store_index] store_index += 1 arr[store_index], arr[right] = arr[right], arr[store_index] return store_index def quickselect(arr: List[int], left: int, right: int, k: int) -> int: Finds the k-th smallest element in the array using the Quickselect algorithm. if left == right: return arr[left] pivot = median_of_medians(arr, left, right) pivot_index = partition(arr, left, right, pivot) if k - 1 == pivot_index: return arr[pivot_index] elif k - 1 < pivot_index: return quickselect(arr, left, pivot_index - 1, k) else: return quickselect(arr, pivot_index + 1, right, k)"},{"question":"from typing import List def most_frequent_words(documents: List[str]) -> List[str]: Find the most frequent word for each document. If there are multiple words with the same highest frequency, return the word that appears first in lexicographical order. >>> most_frequent_words([\\"apple banana apple\\", \\"cat bat cat dog bat\\"]) [\\"apple\\", \\"bat\\"] >>> most_frequent_words([\\"the quick brown fox\\", \\"jumped over the lazy dog\\"]) [\\"the\\", \\"dog\\"] >>> most_frequent_words([\\"hello world hello\\", \\"test test test\\", \\"word\\"]) [\\"hello\\", \\"test\\", \\"word\\"] pass","solution":"def most_frequent_words(documents: list[str]) -> list[str]: from collections import Counter result = [] for doc in documents: words = doc.split() word_count = Counter(words) most_frequent = sorted(word_count.items(), key=lambda x: (-x[1], x[0])) result.append(most_frequent[0][0]) return result"},{"question":"from typing import List, Union, Dict def label_encode(categories: List[Union[str, int]]) -> Dict[Union[str, int], int]: Encodes a list of categories (strings or integers) into a dictionary mapping each unique category to a unique integer. Parameters: categories (List[Union[str, int]]): The list of categories to encode. Returns: Dict[Union[str, int], int]: A dictionary with keys as unique categories and values as unique integers. Examples: >>> label_encode([\\"apple\\", \\"banana\\", \\"apple\\", \\"orange\\"]) {'apple': 0, 'banana': 1, 'orange': 2} >>> label_encode([1, \\"one\\", 2, \\"two\\", 1]) {1: 0, 'one': 1, 2: 2, 'two': 3} >>> label_encode([10, 10, 20, \\"10\\", \\"10\\"]) {10: 0, 20: 1, '10': 2} >>> label_encode([]) {}","solution":"from typing import List, Union, Dict def label_encode(categories: List[Union[str, int]]) -> Dict[Union[str, int], int]: Encodes a list of categories (strings or integers) into a dictionary mapping each unique category to a unique integer. Parameters: categories (List[Union[str, int]]): The list of categories to encode. Returns: Dict[Union[str, int], int]: A dictionary with keys as unique categories and values as unique integers. encoding_map = {} current_index = 0 for category in categories: if category not in encoding_map: encoding_map[category] = current_index current_index += 1 return encoding_map"},{"question":"def max_profit_with_cooldown(prices: List[int]) -> int: Calculate the maximum profit with a cooldown of one day between selling and buying. >>> max_profit_with_cooldown([1, 2, 3, 0, 2]) 3 >>> max_profit_with_cooldown([6, 1, 6, 4, 3, 0, 2]) 7 >>> max_profit_with_cooldown([1]) 0 >>> max_profit_with_cooldown([]) 0","solution":"from typing import List def max_profit_with_cooldown(prices: List[int]) -> int: if not prices: return 0 n = len(prices) if n == 1: return 0 # DP arrays sell = [0] * n buy = [0] * n cooldown = [0] * n # Initialization buy[0] = -prices[0] sell[0] = 0 cooldown[0] = 0 for i in range(1, n): buy[i] = max(buy[i-1], cooldown[i-1] - prices[i]) sell[i] = max(sell[i-1], buy[i-1] + prices[i]) cooldown[i] = max(cooldown[i-1], sell[i-1]) return max(sell[n-1], cooldown[n-1])"},{"question":"from typing import List def frequency_sort(arr: List[int]) -> List[int]: Sort a list of integers based on the frequency of elements. The elements with higher frequency should come first. If two elements have the same frequency, the smaller element should come first. >>> frequency_sort([1, 1, 2, 2, 2, 3]) [2, 2, 2, 1, 1, 3] >>> frequency_sort([4, 4, 4, 5, 5, 3]) [4, 4, 4, 5, 5, 3] >>> frequency_sort([1, 2, 3, 0, 0, 0, -1, -1, 4, 4, 4, 4]) [4, 4, 4, 4, 0, 0, 0, -1, -1, 1, 2, 3]","solution":"from typing import List from collections import Counter def frequency_sort(arr: List[int]) -> List[int]: freq = Counter(arr) # Sort by frequency first (negative for descending), then by value (ascending) sorted_arr = sorted(arr, key=lambda x: (-freq[x], x)) return sorted_arr"},{"question":"def is_circular_shift(s1: str, s2: str) -> bool: Check if one string can become the other string through any number of circular shifts. >>> is_circular_shift(\\"abcde\\", \\"cdeab\\") True >>> is_circular_shift(\\"abcde\\", \\"abced\\") False >>> is_circular_shift(\\"aaaaa\\", \\"aaaaa\\") True >>> is_circular_shift(\\"a\\", \\"a\\") True >>> is_circular_shift(\\"ab\\", \\"ba\\") True >>> is_circular_shift(\\"ab\\", \\"ab\\") True >>> is_circular_shift(\\"abcde\\", \\"abcd\\") False >>> is_circular_shift(\\"abcdefg\\", \\"defgabc\\") True >>> is_circular_shift(\\"a\\" * 1000, \\"a\\" * 1000) True >>> is_circular_shift(\\"xyzw\\", \\"wxyz\\") True >>> is_circular_shift(\\"xyzw\\", \\"zyxw\\") False # Implementation here","solution":"def is_circular_shift(s1: str, s2: str) -> bool: Check if one string can become the other string through any number of circular shifts. Args: s1 (str): The first string. s2 (str): The second string. Returns: bool: True if one string can become the other through circular shifts, otherwise False. if len(s1) != len(s2): return False return s2 in (s1 + s1)"},{"question":"def max_rocks_sequence(rocks: list) -> int: Determine the maximum number of consecutive days during which the number of rocks thrown increases or stays the same each day. >>> max_rocks_sequence([1, 2, 2, 3, 1, 2, 3, 4]) 4 >>> max_rocks_sequence([5, 4, 3, 2, 1]) 1 >>> max_rocks_sequence([2, 2, 2, 2, 2]) 5 >>> max_rocks_sequence([]) 0 >>> max_rocks_sequence([3, 3, 4, 2, 2, 2, 1, 0]) 3","solution":"def max_rocks_sequence(rocks: list) -> int: Returns the length of the longest sequence of consecutive days during which the number of rocks thrown is non-decreasing. if not rocks: return 0 max_length = 1 current_length = 1 for i in range(1, len(rocks)): if rocks[i] >= rocks[i - 1]: current_length += 1 max_length = max(max_length, current_length) else: current_length = 1 return max_length"},{"question":"def calculate_bmi_and_recommendation(height: float, weight: float) -> dict: Calculate BMI (Body Mass Index) and provide health recommendation. :param height: A positive float representing the height in meters. :param weight: A positive float representing the weight in kilograms. :return: A dictionary containing the BMI value and the health recommendation. :raises ValueError: If height or weight is non-positive. :raises TypeError: If height or weight is not a number. >>> calculate_bmi_and_recommendation(1.75, 70) {\\"bmi\\": 22.86, \\"recommendation\\": \\"Normal weight\\"} >>> calculate_bmi_and_recommendation(1.6, 90) {\\"bmi\\": 35.16, \\"recommendation\\": \\"Obesity\\"} >>> calculate_bmi_and_recommendation(1.8, 50) {\\"bmi\\": 15.43, \\"recommendation\\": \\"Underweight\\"} >>> calculate_bmi_and_recommendation(-1.75, 70) Traceback (most recent call last): ValueError: Invalid height. Should be a positive number. >>> calculate_bmi_and_recommendation(1.75, -70) Traceback (most recent call last): ValueError: Invalid weight. Should be a positive number. >>> calculate_bmi_and_recommendation(\\"1.75\\", 70) Traceback (most recent call last): TypeError: Both height and weight must be numbers. >>> calculate_bmi_and_recommendation(1.75, \\"70\\") Traceback (most recent call last): TypeError: Both height and weight must be numbers.","solution":"def calculate_bmi_and_recommendation(height: float, weight: float) -> dict: Calculate BMI (Body Mass Index) and provide health recommendation. :param height: A positive float representing the height in meters. :param weight: A positive float representing the weight in kilograms. :return: A dictionary containing the BMI value and the health recommendation. :raises ValueError: If height or weight is non-positive. :raises TypeError: If height or weight is not a number. if not isinstance(height, (int, float)) or not isinstance(weight, (int, float)): raise TypeError(\\"Both height and weight must be numbers.\\") if height <= 0: raise ValueError(\\"Invalid height. Should be a positive number.\\") if weight <= 0: raise ValueError(\\"Invalid weight. Should be a positive number.\\") bmi = weight / (height ** 2) bmi = round(bmi, 2) if bmi < 18.5: recommendation = \\"Underweight\\" elif 18.5 <= bmi < 24.9: recommendation = \\"Normal weight\\" elif 25.0 <= bmi < 29.9: recommendation = \\"Overweight\\" else: recommendation = \\"Obesity\\" return {\\"bmi\\": bmi, \\"recommendation\\": recommendation}"},{"question":"longest_common_prefix([\\"flower\\", \\"flow\\", \\"flight\\"]) \`fl\` longest_common_prefix([\\"dog\\", \\"racecar\\", \\"car\\"]) \`\`","solution":"def is_palindrome(x: int) -> bool: Determines if x is a palindrome number. A palindrome number reads the same backward as forward. if x < 0: return False original, reversed_num = x, 0 while x > 0: last_digit = x % 10 reversed_num = reversed_num * 10 + last_digit x //= 10 return original == reversed_num"},{"question":"from typing import List def sort_even_odd(numbers: List[int]) -> List[int]: Sort even and odd integers separately. This function takes a list of integers and returns a new list where all even integers appear first, sorted in non-decreasing order, followed by all odd integers, also sorted in non-decreasing order. >>> sort_even_odd([4, 3, 7, 8, 2, 5, 1, 6]) [2, 4, 6, 8, 1, 3, 5, 7] >>> sort_even_odd([15, 14, 13, 12, 11, 10]) [10, 12, 14, 11, 13, 15]","solution":"from typing import List def sort_even_odd(numbers: List[int]) -> List[int]: Returns a new list with all even integers appearing first, followed by all odd integers, with each group sorted in non-decreasing order. even_numbers = sorted([num for num in numbers if num % 2 == 0]) odd_numbers = sorted([num for num in numbers if num % 2 != 0]) return even_numbers + odd_numbers"},{"question":"from typing import List, Tuple class Graph: def __init__(self): self.graph = defaultdict(list) def mod_add_edge(self, from_vertex: int, to_vertex: int, weight: int) -> None: Adds an undirected edge from \`from_vertex\` to \`to_vertex\` with the specified weight. :param from_vertex: The source vertex :param to_vertex: The destination vertex :param weight: The weight of the edge def prim_mst(self) -> None: Computes the Minimum Spanning Tree of the graph using Prim's algorithm and prints the edges in the MST along with their weights. If the graph is disconnected, print \\"Graph is disconnected, no MST exists\\". # Example usage: g = Graph() g.mod_add_edge(0, 1, 10) g.mod_add_edge(0, 2, 6) g.mod_add_edge(0, 3, 5) g.mod_add_edge(1, 3, 15) g.mod_add_edge(2, 3, 4) g.prim_mst()","solution":"import heapq from collections import defaultdict class Graph: def __init__(self): self.graph = defaultdict(list) def mod_add_edge(self, from_vertex, to_vertex, weight): self.graph[from_vertex].append((weight, to_vertex)) self.graph[to_vertex].append((weight, from_vertex)) def prim_mst(self): if not self.graph: print(\\"Graph is empty, no MST exists\\") return start_vertex = list(self.graph.keys())[0] visited = set() min_heap = [] min_cost = 0 def add_edges(vertex): for weight, to_vertex in self.graph[vertex]: if to_vertex not in visited: heapq.heappush(min_heap, (weight, vertex, to_vertex)) add_edges(start_vertex) mst_edges = [] while min_heap and len(visited) < len(self.graph): weight, from_vertex, to_vertex = heapq.heappop(min_heap) if to_vertex not in visited: visited.add(to_vertex) min_cost += weight mst_edges.append((from_vertex, to_vertex, weight)) add_edges(to_vertex) if len(visited) != len(self.graph): print(\\"Graph is disconnected, no MST exists\\") else: print(\\"Minimum Spanning Tree edges:\\") for from_vertex, to_vertex, weight in mst_edges: print(f\\"{from_vertex} - {to_vertex} with weight {weight}\\") print(f\\"Total weight of MST: {min_cost}\\") # Example usage: g = Graph() g.mod_add_edge(0, 1, 10) g.mod_add_edge(0, 2, 6) g.mod_add_edge(0, 3, 5) g.mod_add_edge(1, 3, 15) g.mod_add_edge(2, 3, 4) g.prim_mst()"},{"question":"from typing import List, Tuple def max_profit_days(prices: List[float]) -> Tuple[int, int]: Identify the best day to buy and the best day to sell to maximize the profit. >>> max_profit_days([7, 1, 5, 3, 6, 4]) (1, 4) >>> max_profit_days([1, 2, 3, 4, 5, 6]) (0, 5) >>> max_profit_days([6, 5, 4, 3, 2, 1]) (-1, -1) >>> max_profit_days([10, 12, 4, 5, 9, 3, 15]) (5, 6) >>> max_profit_days([10, 7, 5, 8, 11, 9, 1, 11]) (6, 7) >>> max_profit_days([5, 5]) (-1, -1) >>> max_profit_days([]) (-1, -1) >>> max_profit_days([3, 3, 3, 3, 3]) (-1, -1) >>> max_profit_days([8, 1, 2, 5, 7]) (1, 4)","solution":"from typing import List, Tuple def max_profit_days(prices: List[float]) -> Tuple[int, int]: if not prices or len(prices) < 2: return -1, -1 min_price_index = 0 max_profit = 0 buy_day = -1 sell_day = -1 for current_day in range(1, len(prices)): if prices[current_day] - prices[min_price_index] > max_profit: max_profit = prices[current_day] - prices[min_price_index] buy_day = min_price_index sell_day = current_day if prices[current_day] < prices[min_price_index]: min_price_index = current_day if buy_day == -1 or sell_day == -1: return -1, -1 else: return buy_day, sell_day"},{"question":"def rotate_matrix(matrix: List[List[int]]) -> None: Rotate the n x n binary matrix 90 degrees clockwise in-place. :param matrix: List[List[int]] - n x n binary matrix where matrix[i][j] is either 0 or 1. The function modifies the input matrix in-place and does not return any value. >>> matrix1 = [ ... [1, 0, 0], ... [0, 1, 0], ... [0, 0, 1] ... ] >>> rotate_matrix(matrix1) >>> matrix1 [ [0, 0, 1], [0, 1, 0], [1, 0, 0] ] >>> matrix2 = [ ... [1, 1, 0, 0], ... [0, 1, 1, 0], ... [0, 0, 1, 1], ... [1, 0, 0, 1] ... ] >>> rotate_matrix(matrix2) >>> matrix2 [ [1, 0, 0, 1], [0, 0, 1, 1], [0, 1, 1, 0], [1, 1, 0, 0] ]","solution":"def rotate_matrix(matrix): Rotate the n x n binary matrix 90 degrees clockwise in-place. :param matrix: List[List[int]] :return: None n = len(matrix) # Step 1: Transpose the matrix for i in range(n): for j in range(i, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Step 2: Reverse each row for i in range(n): matrix[i].reverse()"},{"question":"def right_aligned_staircase(steps: int) -> str: Generate a string representation of a right-aligned staircase of integers. >>> print(right_aligned_staircase(5)) 1 12 123 1234 12345 >>> print(right_aligned_staircase(3)) 1 12 123 >>> print(right_aligned_staircase(1)) 1","solution":"def right_aligned_staircase(steps: int) -> str: staircase = [] for i in range(1, steps + 1): line = ' ' * (steps - i) + ''.join(str(x) for x in range(1, i + 1)) staircase.append(line) return 'n'.join(staircase)"},{"question":"def format_phone_number(phone_number: str) -> str: Formats a phone number to the standard format (XXX) XXX-XXXX. Args: phone_number (str): The input phone number in various formats. Returns: str: Formatted phone number. Raises: ValueError: If the cleaned phone number does not contain exactly 10 digits. Examples: >>> format_phone_number(\\"123-456-7890\\") '(123) 456-7890' >>> format_phone_number(\\"123 456 7890\\") '(123) 456-7890' >>> format_phone_number(\\"(123).456-7890\\") '(123) 456-7890'","solution":"def format_phone_number(phone_number): Formats a phone number to the standard format (XXX) XXX-XXXX. Args: phone_number (str): The input phone number in various formats. Returns: str: Formatted phone number. Raises: ValueError: If the cleaned phone number does not contain exactly 10 digits. # Remove non-digit characters cleaned_number = ''.join(filter(str.isdigit, phone_number)) # Check if the cleaned number contains exactly 10 digits if len(cleaned_number) != 10: raise ValueError(\\"Invalid phone number format\\") # Format the phone number formatted_number = f\\"({cleaned_number[:3]}) {cleaned_number[3:6]}-{cleaned_number[6:]}\\" return formatted_number"},{"question":"from collections import deque def word_ladder_length(start: str, end: str, word_dict: list[str]) -> int: Transform the start word into the end word, changing only one letter at a time while ensuring that each transformed word exists in the dictionary. Determine the minimum number of transformations required or return 0 if it is not possible. >>> word_ladder_length(\\"hit\\", \\"cog\\", [\\"hot\\", \\"dot\\", \\"dog\\", \\"lot\\", \\"log\\", \\"cog\\"]) # should return 5 >>> word_ladder_length(\\"hit\\", \\"cog\\", [\\"hot\\", \\"dot\\", \\"dog\\", \\"lot\\", \\"log\\"]) # should return 0 >>> word_ladder_length(\\"abc\\", \\"abd\\", [\\"abd\\"]) # should return 2 >>> word_ladder_length(\\"hit\\", \\"hit\\", [\\"hot\\", \\"dot\\", \\"dog\\", \\"lot\\", \\"log\\", \\"cog\\"]) # should return 0","solution":"from collections import deque def word_ladder_length(start: str, end: str, word_dict: list[str]) -> int: if end not in word_dict or not start or not end or not word_dict: return 0 # All words including start, end should be in the word_dict word_dict = set(word_dict) word_dict.add(start) word_dict.add(end) queue = deque([(start, 1)]) while queue: current_word, steps = queue.popleft() # Generate all possible transformations for i in range(len(current_word)): for char in 'abcdefghijklmnopqrstuvwxyz': if char != current_word[i]: transformed_word = current_word[:i] + char + current_word[i+1:] if transformed_word == end: return steps + 1 if transformed_word in word_dict: queue.append((transformed_word, steps + 1)) word_dict.remove(transformed_word) return 0"},{"question":"def evaluate_expression(expression: str) -> float: Evaluates a mathematical expression provided as a string and returns the result as a float. # Define a scope with restricted built-in functions for eval allowed_names = {\\"__builtins__\\": None} expression = expression.replace(' ', '') # Remove spaces in the expression # Try to evaluate the expression using eval within the restricted scope try: result = eval(expression, allowed_names) return float(result) except ZeroDivisionError: raise ZeroDivisionError(\\"division by zero\\") except SyntaxError: raise ValueError(\\"Invalid expression provided\\") except Exception as e: raise ValueError(f\\"An error occurred: {e}\\")","solution":"def evaluate_expression(expression: str) -> float: Evaluates a mathematical expression provided as a string and returns the result as a float. # Define a scope with restricted built-in functions for eval allowed_names = {\\"__builtins__\\": None} expression = expression.replace(' ', '') # Remove spaces in the expression # Try to evaluate the expression using eval within the restricted scope try: result = eval(expression, allowed_names) return float(result) except ZeroDivisionError: raise ZeroDivisionError(\\"division by zero\\") except SyntaxError: raise ValueError(\\"Invalid expression provided\\") except Exception as e: raise ValueError(f\\"An error occurred: {e}\\") # Example Usage: # print(evaluate_expression(\\"3 + 5\\")) # Outputs: 8.0 # print(evaluate_expression(\\"10 - 2 * 3\\")) # Outputs: 4.0 # print(evaluate_expression(\\"2.5 * 4\\")) # Outputs: 10.0 # print(evaluate_expression(\\"8 / 2 + 3\\")) # Outputs: 7.0"},{"question":"def find_overlapping_interval(set1, set2): ''' Returns the earliest overlapping interval between the two sets of intervals. ''' overlap = None def get_overlap(interval1, interval2): ''' Helper function to find overlap between two intervals, Returns None if there's no overlap, otherwise the overlapping interval. ''' start1, end1 = interval1 start2, end2 = interval2 if end1 < start2 or end2 < start1: return None else: return (max(start1, start2), min(end1, end2)) earliest_start = float('inf') for int1 in set1: for int2 in set2: current_overlap = get_overlap(int1, int2) if current_overlap: start, end = current_overlap if start < earliest_start: earliest_start = start overlap = current_overlap return overlap # Example usage print(find_overlapping_interval([(1, 5), (10, 15)], [(3, 6), (8, 10)])) # Output should be (3, 5)","solution":"def find_overlapping_interval(set1, set2): Returns the earliest overlapping interval between the two sets of intervals. overlap = None def get_overlap(interval1, interval2): Helper function to find overlap between two intervals. Returns None if there's no overlap, otherwise the overlapping interval. start1, end1 = interval1 start2, end2 = interval2 if end1 < start2 or end2 < start1: return None else: return (max(start1, start2), min(end1, end2)) earliest_start = float('inf') for int1 in set1: for int2 in set2: current_overlap = get_overlap(int1, int2) if current_overlap: start, end = current_overlap if start < earliest_start: earliest_start = start overlap = current_overlap return overlap # Example usage print(find_overlapping_interval([(1, 5), (10, 15)], [(3, 6), (8, 10)])) # Output should be (3, 5)"},{"question":"import time from collections import defaultdict, deque class RateLimiter: def __init__(self, max_requests: int, time_window: int): Initialize the rate limiter with max_requests and time_window. self.max_requests = max_requests self.time_window = time_window self.user_request_timestamps = defaultdict(deque) def is_request_allowed(self, user_id: str) -> bool: Processes an API request for the user_id and determines if it is allowed based on the rate limits. def __call__(self, user_id: str) -> bool: return self.is_request_allowed(user_id) # Unit tests def test_initial_requests_allowed(): rate_limiter = RateLimiter(max_requests=5, time_window=60) user_id = 'user_1' for _ in range(5): assert rate_limiter(user_id) == True def test_exceeding_requests_denied(): rate_limiter = RateLimiter(max_requests=5, time_window=60) user_id = 'user_1' for _ in range(5): rate_limiter(user_id) assert rate_limiter(user_id) == False def test_old_requests_removed(): rate_limiter = RateLimiter(max_requests=3, time_window=2) user_id = 'user_2' assert rate_limiter(user_id) == True time.sleep(1) assert rate_limiter(user_id) == True time.sleep(1.5) assert rate_limiter(user_id) == True # Previous requests should be removed assert rate_limiter(user_id) == True # Previous requests should be removed def test_multiple_users(): rate_limiter = RateLimiter(max_requests=2, time_window=60) user_id_1 = 'user_1' user_id_2 = 'user_2' assert rate_limiter(user_id_1) == True assert rate_limiter(user_id_1) == True assert rate_limiter(user_id_1) == False assert rate_limiter(user_id_2) == True assert rate_limiter(user_id_2) == True assert rate_limiter(user_id_2) == False def test_time_window_effect(): rate_limiter = RateLimiter(max_requests=2, time_window=2) user_id = 'user_3' assert rate_limiter(user_id) == True assert rate_limiter(user_id) == True assert rate_limiter(user_id) == False time.sleep(2) assert rate_limiter(user_id) == True assert rate_limiter(user_id) == True assert rate_limiter(user_id) == False # Example usage: if __name__ == \\"__main__\\": rate_limiter = RateLimiter(max_requests=5, time_window=60) # Allow max 5 requests per user per 60 seconds user_id = 'user_123' # Test with burst of requests for i in range(7): if rate_limiter(user_id): print(f\\"Request {i+1} for {user_id}: Allowed\\") else: print(f\\"Request {i+1} for {user_id}: Denied\\") time.sleep(10) # Simulate time between requests","solution":"import time from collections import defaultdict, deque class RateLimiter: def __init__(self, max_requests: int, time_window: int): Initialize the rate limiter with max_requests and time_window. self.max_requests = max_requests self.time_window = time_window self.user_request_timestamps = defaultdict(deque) def is_request_allowed(self, user_id: str) -> bool: Processes an API request for the user_id and determines if it is allowed based on the rate limits. current_time = time.time() user_queue = self.user_request_timestamps[user_id] # Remove timestamps that are outside the time window while user_queue and user_queue[0] <= current_time - self.time_window: user_queue.popleft() if len(user_queue) < self.max_requests: user_queue.append(current_time) return True else: return False def __call__(self, user_id: str) -> bool: return self.is_request_allowed(user_id)"},{"question":"def list_subtract(main_list: list, sub_list: list) -> list: Subtract elements of one list from another. >>> list_subtract([1, 2, 3, 4, 2, 3], [2, 3]) [1, 4] >>> list_subtract([\\"apple\\", \\"banana\\", \\"apple\\", \\"cherry\\"], [\\"apple\\"]) [\\"banana\\", \\"cherry\\"] >>> list_subtract([1, 1, 1], [1]) [] >>> list_subtract([1, 2, 3], []) [1, 2, 3] >>> list_subtract([], [1, 2]) []","solution":"def list_subtract(main_list: list, sub_list: list) -> list: Returns a list with all occurrences of elements in sub_list removed from main_list. sub_set = set(sub_list) return [item for item in main_list if item not in sub_set]"},{"question":"def validate_expression(expression: str) -> bool: Validates a mathematical expression for correct syntax and balanced parentheses. >>> validate_expression(\\"(1+2)*3\\") True >>> validate_expression(\\"((1+2)*3\\") False >>> validate_expression(\\"(1+2)*3)\\") False >>> validate_expression(\\"3+5*(2+1\\") False >>> validate_expression(\\"\\") True >>> validate_expression(\\"((10 + 2) - (3 * 7)) / (7 / 2)\\") True >>> validate_expression(\\"+1+2\\") False >>> validate_expression(\\"1+2+\\") False >>> validate_expression(\\"*1+2\\") False >>> validate_expression(\\"1+*2\\") False >>> validate_expression(\\"1+2*\\") False >>> validate_expression(\\"1a+2b\\") False >>> validate_expression(\\"1234567890\\") True # Your code here","solution":"def validate_expression(expression: str) -> bool: Validates a mathematical expression for correct syntax and balanced parentheses. stack = [] operators = set('+-*/') prev_char = None for char in expression: if char in '0123456789': prev_char = 'num' continue elif char in operators: if prev_char != 'num' and prev_char != ')': return False prev_char = 'op' elif char == '(': stack.append(char) prev_char = '(' elif char == ')': if not stack or stack[-1] != '(': return False stack.pop() if prev_char == 'op': return False prev_char = ')' elif char == ' ': continue else: return False if prev_char == 'op': return False return len(stack) == 0"},{"question":"from typing import List def max_subarray_sum(nums: List[int], K: int) -> int: Find the maximum possible sum of any contiguous subarray of length K. >>> max_subarray_sum([2, 1, 5, 1, 3, 2], 3) 9 >>> max_subarray_sum([1, -1, 5, 1, -3, 2, 3], 4) 6 pass def test_example_1(): nums = [2, 1, 5, 1, 3, 2] assert max_subarray_sum(nums, 3) == 9 def test_example_2(): nums = [1, -1, 5, 1, -3, 2, 3] assert max_subarray_sum(nums, 4) == 6 def test_all_negative(): nums = [-1, -2, -3, -4, -5] assert max_subarray_sum(nums, 2) == -3 def test_all_positive(): nums = [1, 2, 3, 4, 5] assert max_subarray_sum(nums, 3) == 12 def test_mixed_numbers(): nums = [-1, 2, 3, -4, 5, -2, 1] assert max_subarray_sum(nums, 2) == 5 def test_single_element_subarray(): nums = [-1, 2, 3, -4, 5, -2, 1] assert max_subarray_sum(nums, 1) == 5 def test_array_size_equals_k(): nums = [4, -1, 2, 1] assert max_subarray_sum(nums, 4) == 6 def test_large_input(): nums = [i for i in range(1, 100001)] assert max_subarray_sum(nums, 100000) == sum(nums) def test_small_k_large_array(): nums = [0] * 100000 nums[50000] = 100 assert max_subarray_sum(nums, 1) == 100","solution":"from typing import List def max_subarray_sum(nums: List[int], K: int) -> int: # Initialize the maximum sum and the current window sum max_sum = float('-inf') current_sum = 0 # Loop through the array for i in range(len(nums)): current_sum += nums[i] # When the window hits size K if i >= K - 1: # Update the maximum sum if necessary max_sum = max(max_sum, current_sum) # Remove the element going out of the window current_sum -= nums[i - (K - 1)] return max_sum"},{"question":"from typing import List def search_rotated_sorted_array(nums: List[int], target: int) -> int: Search in a rotated sorted array. Given a list of integers sorted in ascending order and then rotated at some pivot, find the index of the target number in the list. If the target is not found, return -1. The algorithm should have O(log n) runtime complexity. >>> search_rotated_sorted_array([4, 5, 6, 7, 0, 1, 2], 0) 4 >>> search_rotated_sorted_array([4, 5, 6, 7, 0, 1, 2], 3) -1 >>> search_rotated_sorted_array([1], 0) -1 >>> search_rotated_sorted_array([1], 1) 0 >>> search_rotated_sorted_array([], 5) -1 >>> search_rotated_sorted_array([6, 7, 0, 1, 2, 4, 5], 6) 0","solution":"from typing import List def search_rotated_sorted_array(nums: List[int], target: int) -> int: if not nums: return -1 left, right = 0, len(nums) - 1 while left <= right: mid = (left + right) // 2 if nums[mid] == target: return mid if nums[left] <= nums[mid]: # left to mid is sorted if nums[left] <= target < nums[mid]: right = mid - 1 else: left = mid + 1 else: # mid to right is sorted if nums[mid] < target <= nums[right]: left = mid + 1 else: right = mid - 1 return -1"},{"question":"def rotate_array(arr: list[int], positions: int) -> list[int]: Rotates an array of integers to the left by a specified number of positions. Args: arr (list[int]): The array of integers to be rotated. positions (int): The number of positions to rotate the array to the left. Returns: list[int]: The rotated array of integers. Raises: TypeError: If arr is not a list of integers or if positions is not an integer. Examples: >>> rotate_array([1, 2, 3, 4, 5], 2) [3, 4, 5, 1, 2] >>> rotate_array([10, 20, 30, 40, 50], 3) [40, 50, 10, 20, 30] >>> rotate_array([1, 2, 3], 0) [1, 2, 3] >>> rotate_array([], 5) [] >>> rotate_array([1], 3) [1] >>> rotate_array([5, 6, 7, 8], 6) [7, 8, 5, 6] pass import pytest def test_rotate_array_typical_cases(): assert rotate_array([1, 2, 3, 4, 5], 2) == [3, 4, 5, 1, 2] assert rotate_array([10, 20, 30, 40, 50], 3) == [40, 50, 10, 20, 30] assert rotate_array([1, 2, 3], 0) == [1, 2, 3] def test_rotate_array_corner_cases(): assert rotate_array([], 5) == [] assert rotate_array([1], 3) == [1] def test_rotate_array_large_rotation(): assert rotate_array([5, 6, 7, 8], 6) == [7, 8, 5, 6] def test_rotate_array_equal_to_length(): assert rotate_array([1, 2, 3, 4], 4) == [1, 2, 3, 4] def test_rotate_array_type_errors(): with pytest.raises(TypeError): rotate_array(\\"not a list\\", 2) with pytest.raises(TypeError): rotate_array([1, 2, 3], \\"2\\") with pytest.raises(TypeError): rotate_array([1, \\"2\\", 3], 2) def test_rotate_array_empty_cases(): assert rotate_array([], 0) == [] assert rotate_array([], 1) == [] def test_rotate_array_zero_positions(): assert rotate_array([1, 2, 3, 4, 5], 0) == [1, 2, 3, 4, 5]","solution":"def rotate_array(arr: list[int], positions: int) -> list[int]: Rotates an array of integers to the left by a specified number of positions. if not isinstance(arr, list) or not all(isinstance(x, int) for x in arr): raise TypeError(\\"Input must be a list of integers\\") if not isinstance(positions, int): raise TypeError(\\"Positions value must be an integer\\") n = len(arr) if n == 0: return [] # Normalize the positions to avoid unnecessary full rotations positions = positions % n # Perform the rotation return arr[positions:] + arr[:positions]"},{"question":"def segregate_even_odd(arr: list[int]) -> list[int]: Segregates even and odd numbers in an array such that all even numbers come before all odd numbers and the relative order of the numbers within their groups is preserved. :param arr: List of integers to be segregated :return: New list with even numbers before odd numbers, maintaining relative order Constraints: - The length of the input list will be at most 1000. - All integers will be in the range of [-100000, 100000]. >>> segregate_even_odd([1, 2, 3, 4, 5, 6]) [2, 4, 6, 1, 3, 5] >>> segregate_even_odd([12, 34, 45, 9, 8, 90, 3]) [12, 34, 8, 90, 45, 9, 3] >>> segregate_even_odd([0, 1, 2, -3, -4, 5]) [0, 2, -4, 1, -3, 5] >>> segregate_even_odd([]) [] # Unit Tests def test_segregate_even_odd_typical_case(): assert segregate_even_odd([1, 2, 3, 4, 5, 6]) == [2, 4, 6, 1, 3, 5] def test_segregate_even_odd_with_large_values(): assert segregate_even_odd([12, 34, 45, 9, 8, 90, 3]) == [12, 34, 8, 90, 45, 9, 3] def test_segregate_even_odd_with_mixed_sign_values(): assert segregate_even_odd([0, 1, 2, -3, -4, 5]) == [0, 2, -4, 1, -3, 5] def test_segregate_even_odd_with_only_even(): assert segregate_even_odd([2, 4, 6, 8]) == [2, 4, 6, 8] def test_segregate_even_odd_with_only_odd(): assert segregate_even_odd([1, 3, 5, 7]) == [1, 3, 5, 7] def test_segregate_even_odd_with_empty_list(): assert segregate_even_odd([]) == [] def test_segregate_even_odd_with_single_element(): assert segregate_even_odd([1]) == [1] assert segregate_even_odd([2]) == [2]","solution":"def segregate_even_odd(arr: list[int]) -> list[int]: Segregates even and odd numbers in an array such that all even numbers come before all odd numbers and the relative order of the numbers within their groups is preserved. :param arr: List of integers to be segregated :return: New list with even numbers before odd numbers, maintaining relative order evens = [num for num in arr if num % 2 == 0] odds = [num for num in arr if num % 2 != 0] return evens + odds"},{"question":"def is_leap_year(year: int) -> bool: Determines if a given year is a leap year. # Implement is_leap_year function here def next_leap_year(year: int) -> int: Finds and returns the next leap year after the given year. >>> next_leap_year(2021) 2024 >>> next_leap_year(1900) 1904 >>> next_leap_year(2000) 2004 # Implement next_leap_year function here","solution":"def is_leap_year(year: int) -> bool: Determines if a given year is a leap year. if year % 4 == 0: if year % 100 == 0: if year % 400 == 0: return True else: return False else: return True else: return False def next_leap_year(year: int) -> int: Finds and returns the next leap year after the given year. year += 1 # Start checking from the next year while not is_leap_year(year): year += 1 return year"},{"question":"def diagonal_sum(matrix: list[list[int]]) -> tuple[int, int]: Computes and returns the sum of the main diagonal and the anti-diagonal of a square matrix. The main diagonal runs from the top-left to the bottom-right of the matrix. The anti-diagonal runs from the top-right to the bottom-left of the matrix. Examples: >>> diagonal_sum([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) (15, 15) >>> diagonal_sum([[5, 1], [2, 3]]) (8, 3) >>> diagonal_sum([[1]]) (1, 1) >>> diagonal_sum([[3, 2, 1, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]]) (36, 34) pass","solution":"def diagonal_sum(matrix: list[list[int]]) -> tuple[int, int]: Computes and returns the sum of the main diagonal and the anti-diagonal of a square matrix. The main diagonal runs from the top-left to the bottom-right of the matrix. The anti-diagonal runs from the top-right to the bottom-left of the matrix. n = len(matrix) main_diagonal_sum = sum(matrix[i][i] for i in range(n)) anti_diagonal_sum = sum(matrix[i][n - 1 - i] for i in range(n)) return (main_diagonal_sum, anti_diagonal_sum)"},{"question":"from typing import List def replace_elements_with_products(arr: List[int]) -> List[int]: Processes an array of integers by replacing each element with the product of all other elements in the array, except the element at the current index. >>> replace_elements_with_products([1, 2, 3, 4]) [24, 12, 8, 6] >>> replace_elements_with_products([2, 3, 5, 7]) [105, 70, 42, 30] >>> replace_elements_with_products([3, 0, 2]) [0, 6, 0]","solution":"from typing import List def replace_elements_with_products(arr: List[int]) -> List[int]: n = len(arr) if n == 0: return [] left_products = [1] * n right_products = [1] * n # Calculate left products for i in range(1, n): left_products[i] = left_products[i-1] * arr[i-1] # Calculate right products for i in range(n-2, -1, -1): right_products[i] = right_products[i+1] * arr[i+1] # Calculate result by multiplying left and right products result = [left_products[i] * right_products[i] for i in range(n)] return result"},{"question":"class Node: def __init__(self, value): self.value = value self.next = None class CustomQueue: def __init__(self): self.front = None self.rear = None def enqueue(self, value: int) -> None: Adds an element to the end of the queue. Parameters: value (int): The value to be added to the queue. def dequeue(self) -> int: Removes and returns the element from the front of the queue. Returns: int: The value of the front element. Raises: IndexError: If the queue is empty. def peek(self) -> int: Returns the element at the front of the queue without removing it. Returns: int: The value of the front element. Raises: IndexError: If the queue is empty. def is_empty(self) -> bool: Checks if the queue is empty. Returns: bool: True if the queue is empty, False otherwise.","solution":"class Node: def __init__(self, value): self.value = value self.next = None class CustomQueue: def __init__(self): self.front = None self.rear = None def enqueue(self, value: int) -> None: new_node = Node(value) if self.rear is None: self.front = self.rear = new_node else: self.rear.next = new_node self.rear = new_node def dequeue(self) -> int: if self.front is None: raise IndexError(\\"dequeue from empty queue\\") value = self.front.value self.front = self.front.next if self.front is None: self.rear = None return value def peek(self) -> int: if self.front is None: raise IndexError(\\"peek from empty queue\\") return self.front.value def is_empty(self) -> bool: return self.front is None"},{"question":"def find_majority_element(arr: list[int]) -> int: Returns the majority element in the array using the Boyer-Moore Voting Algorithm. Args: arr: A list of integers representing the input array. Returns: An integer representing the majority element in the array. Example: >>> find_majority_element([3, 3, 4, 2, 4, 4, 2, 4, 4]) 4 >>> find_majority_element([2, 2, 1, 1, 1, 2, 2]) 2 candidate = None count = 0 # First pass to find the candidate for num in arr: if count == 0: candidate = num count += (1 if num == candidate else -1) # The candidate is the majority element, as per the problem's constraint return candidate","solution":"def find_majority_element(arr): Returns the majority element in the array using the Boyer-Moore Voting Algorithm. # Boyer-Moore Voting Algorithm initialization candidate = None count = 0 # First pass to find the candidate for num in arr: if count == 0: candidate = num count += (1 if num == candidate else -1) # The candidate is the majority element, as per the problem's constraint return candidate"},{"question":"from typing import List, Tuple def has_overlapping_intervals(intervals: List[Tuple[int, int]]) -> bool: Determine if any two intervals overlap. Args: intervals: List of tuples, where each tuple contains two integers (start, end). Returns: True if any two intervals overlap, otherwise False. Examples: >>> has_overlapping_intervals([(1, 3), (2, 4), (5, 7)]) True >>> has_overlapping_intervals([(1, 2), (2, 3), (3, 4)]) False >>> has_overlapping_intervals([(1, 5), (3, 6), (7, 9)]) True >>> has_overlapping_intervals([(1, 3), (4, 6), (8, 10)]) False pass","solution":"from typing import List, Tuple def has_overlapping_intervals(intervals: List[Tuple[int, int]]) -> bool: Determine if any two intervals overlap. Args: intervals: List of tuples, where each tuple contains two integers (start, end). Returns: True if any two intervals overlap, otherwise False. # Sort intervals based on the start time intervals.sort(key=lambda x: x[0]) # Compare each interval with the previous one for i in range(1, len(intervals)): # If the current interval starts before the previous one ends, there's an overlap if intervals[i][0] < intervals[i-1][1]: return True return False"},{"question":"# Implementing a File System with In-Memory Structure Implement the \`FileSystem\` class and its methods as described below: # \`FileSystem\` Class 1. **Init Method**: Initialize the class with a root directory. def __init__(self): pass 2. **Make Directory Method**: Implement a method to create a new directory at a specified path. def mkdir(self, path: str) -> None: pass 3. **Add File Method**: Implement a method to create a new file with content at a specified path. def add_file(self, path: str, content: str) -> None: pass 4. **Read File Method**: Implement a method to read the content of a file at a specified path. def read_file(self, path: str) -> str: pass 5. **List Directory Method**: Implement a method to list all files and directories at a specified path. def ls(self, path: str) -> [str]: pass Example Usage # Initialize the file system fs = FileSystem() # Create directories fs.mkdir(\\"/a/b/c\\") # Add files fs.add_file(\\"/a/b/c/d.txt\\", \\"Hello world\\") # Read files assert fs.read_file(\\"/a/b/c/d.txt\\") == \\"Hello world\\" # List directories and files assert fs.ls(\\"/\\") == [\\"a\\"] assert fs.ls(\\"/a/b/c\\") == [\\"d.txt\\"] assert fs.ls(\\"/a/b\\") == [\\"c\\"] # Create more directories and files fs.mkdir(\\"/a/b/e\\") fs.add_file(\\"/a/b/e/f.txt\\", \\"Another file\\") assert fs.ls(\\"/a/b\\") == [\\"c\\", \\"e\\"] assert fs.ls(\\"/a/b/e\\") == [\\"f.txt\\"] assert fs.read_file(\\"/a/b/e/f.txt\\") == \\"Another file\\" Constraints * Path strings will always start with \\"/\\" and will not end with \\"/\\". * 1 ≤ length of any directory name or file name ≤ 100 * 1 ≤ depth of any path ≤ 100 * The text content of files will only contain ASCII characters.","solution":"class FileSystem: def __init__(self): self.fs = {} def mkdir(self, path: str) -> None: dirs = path.split('/')[1:] current = self.fs for d in dirs: if d not in current: current[d] = {} current = current[d] def add_file(self, path: str, content: str) -> None: dirs, file_name = path.rsplit('/', 1) self.mkdir(dirs) current = self.fs for d in dirs.split('/')[1:]: current = current[d] current[file_name] = content def read_file(self, path: str) -> str: dirs, file_name = path.rsplit('/', 1) current = self.fs for d in dirs.split('/')[1:]: current = current[d] return current[file_name] def ls(self, path: str) -> [str]: if path == \\"/\\": return sorted(self.fs.keys()) else: dirs = path.split('/')[1:] current = self.fs for d in dirs: current = current[d] if isinstance(current, dict): return sorted(current.keys()) else: return []"},{"question":"def max_profit_twice(prices: str) -> int: Calculate the maximum profit that can be achieved by buying and selling the stock at most twice during a day. Args: prices: A string of space-separated integers representing stock prices recorded during a single day. Returns: An integer representing the maximum profit that could be obtained with up to two buy-sell operations. >>> max_profit_twice(\\"3 3 5 0 0 3 1 4\\") 6 >>> max_profit_twice(\\"1 2 3 4 5\\") 4 >>> max_profit_twice(\\"7 6 4 3 1\\") 0 >>> max_profit_twice(\\"2 1 2 0 1\\") 2 >>> max_profit_twice(\\"1 2 4 2 5 7 2 4 9 0\\") 13","solution":"def max_profit_twice(prices: str) -> int: prices_list = list(map(int, prices.split())) n = len(prices_list) if n < 2: return 0 # Step 1: Create profit array where profit[i] stores the maximum profit using # at most one transaction from day 0 to day i. profit = [0] * n min_price = prices_list[0] for i in range(1, n): profit[i] = max(profit[i - 1], prices_list[i] - min_price) min_price = min(min_price, prices_list[i]) # Step 2: Traverse the list from end to start to find the maximum profit # with two transactions max_price = prices_list[-1] max_profit = profit[-1] for i in range(n - 2, -1, -1): max_profit = max(max_profit, max_price - prices_list[i] + profit[i]) max_price = max(max_price, prices_list[i]) return max_profit"},{"question":"import os import time from datetime import datetime import logging def update_file_timestamps(repo_path: str, timestamp: str) -> None: Update the last modified and last accessed timestamps of all files within the given repository to match the provided timestamp. Args: repo_path (str): The path to the repository. timestamp (str): The new timestamp in the format YYYY-MM-DD HH:MM:SS. pass if __name__ == \\"__main__\\": import pytest def test_update_file_timestamps(): # Create a temporary directory with tempfile.TemporaryDirectory() as repo_path: # Create some test files file_1_path = os.path.join(repo_path, \\"file_1.py\\") with open(file_1_path, \\"w\\") as file_1: file_1.write(\\"print('Hello World')\\") file_2_path = os.path.join(repo_path, \\"file_2.txt\\") with open(file_2_path, \\"w\\") as file_2: file_2.write(\\"This is a test file.\\") # Create a timestamp for testing test_timestamp = \\"2023-01-01 12:00:00\\" expected_time_seconds = time.mktime(datetime.strptime(test_timestamp, '%Y-%m-%d %H:%M:%S').timetuple()) # Run the function update_file_timestamps(repo_path, test_timestamp) # Check the new timestamps file_1_stat = os.stat(file_1_path) file_2_stat = os.stat(file_2_path) assert abs(file_1_stat.st_atime - expected_time_seconds) < 1 assert abs(file_1_stat.st_mtime - expected_time_seconds) < 1 assert abs(file_2_stat.st_atime - expected_time_seconds) < 1 assert abs(file_2_stat.st_mtime - expected_time_seconds) < 1 def test_update_file_timestamps_skips_directories(): with tempfile.TemporaryDirectory() as repo_path: # Create a subdirectory os.mkdir(os.path.join(repo_path, \\"subdir\\")) # Create a file within the subdirectory file_path = os.path.join(repo_path, \\"subdir\\", \\"file.py\\") with open(file_path, \\"w\\") as file: file.write(\\"print('Hello Subdir')\\") # Create a timestamp for testing test_timestamp = \\"2023-01-01 12:00:00\\" expected_time_seconds = time.mktime(datetime.strptime(test_timestamp, '%Y-%m-%d %H:%M:%S').timetuple()) # Run the function update_file_timestamps(repo_path, test_timestamp) # Check the new timestamp for the file file_stat = os.stat(file_path) assert abs(file_stat.st_atime - expected_time_seconds) < 1 assert abs(file_stat.st_mtime - expected_time_seconds) < 1 # Check that the directory timestamp has not been altered subdir_stat = os.stat(os.path.join(repo_path, \\"subdir\\")) # Since we don't change directory timestamps, they should not match the new_time_seconds assert subdir_stat.st_atime != expected_time_seconds assert subdir_stat.st_mtime != expected_time_seconds def test_update_file_timestamps_handle_permission_error(monkeypatch): # Simulate a permission error when updating file timestamps def mock_os_utime(path, times): raise PermissionError(\\"Mocked permission error\\") monkeypatch.setattr(os, 'utime', mock_os_utime) with tempfile.TemporaryDirectory() as repo_path: file_path = os.path.join(repo_path, \\"file.py\\") with open(file_path, \\"w\\") as file: file.write(\\"This should trigger permission error\\") test_timestamp = \\"2023-01-01 12:00:00\\" # Run the function; it should log an error, but not raise an exception update_file_timestamps(repo_path, test_timestamp) pytest.main()","solution":"import os import time import logging from datetime import datetime def update_file_timestamps(repo_path: str, timestamp: str) -> None: Update the last modified and last accessed timestamps of all files within the given repository to match the provided timestamp. Args: repo_path (str): The path to the repository. timestamp (str): The new timestamp in the format YYYY-MM-DD HH:MM:SS. # Configure logging logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s') # Parse the timestamp new_time_seconds = time.mktime(datetime.strptime(timestamp, '%Y-%m-%d %H:%M:%S').timetuple()) # Traverse the repository starting from repo_path for root, dirs, files in os.walk(repo_path): for file in files: file_path = os.path.join(root, file) try: # Update the last modified and last accessed times os.utime(file_path, (new_time_seconds, new_time_seconds)) except Exception as e: logging.error(f\\"Failed to update timestamp for {file_path}: {e}\\")"},{"question":"class Node: def __init__(self, data: int): Node contains data and a pointer to the next node. self.data = data self.next = None class LinkedList: def __init__(self): Initialize an empty linked list. self.head = None def append(self, data: int): Append a node with the given data to the end of the linked list. pass def to_list(self) -> list: Convert the linked list to a regular Python list for output/display purposes. pass def merge_sort(self): Sort the linked list using merge sort. pass def merge_sort_linked_list(linked_list: LinkedList): Function to sort the linked list. linked_list.merge_sort()","solution":"class Node: def __init__(self, data: int): self.data = data self.next = None class LinkedList: def __init__(self): self.head = None def append(self, data: int): if self.head is None: self.head = Node(data) else: current = self.head while current.next: current = current.next current.next = Node(data) def to_list(self) -> list: result = [] current = self.head while current: result.append(current.data) current = current.next return result def _split(self, head): slow = head fast = head prev = None while fast and fast.next: prev = slow slow = slow.next fast = fast.next.next if prev: prev.next = None return head, slow def _merge(self, left, right): dummy = Node(0) current = dummy while left and right: if left.data < right.data: current.next = left left = left.next else: current.next = right right = right.next current = current.next current.next = left or right return dummy.next def _merge_sort(self, head): if not head or not head.next: return head left, right = self._split(head) left = self._merge_sort(left) right = self._merge_sort(right) return self._merge(left, right) def merge_sort(self): self.head = self._merge_sort(self.head) def merge_sort_linked_list(linked_list: LinkedList): linked_list.merge_sort()"},{"question":"def merge_k_sorted_arrays(arrays: list) -> list: Merges k sorted arrays into a single sorted array using a min-heap. Parameters: arrays (list of list of int): List of k sorted arrays, each of size n. Returns: list: A single sorted list with all elements from the k input arrays. >>> merge_k_sorted_arrays([ ... [1, 4, 7], ... [2, 5, 8], ... [3, 6, 9] ... ]) [1, 2, 3, 4, 5, 6, 7, 8, 9] >>> merge_k_sorted_arrays([ ... [1, 3, 5], ... [2, 4, 6], ... [0, 7, 8] ... ]) [0, 1, 2, 3, 4, 5, 6, 7, 8] pass def test_merge_k_sorted_arrays(): arrays = [ [1, 4, 7], [2, 5, 8], [3, 6, 9] ] expected = [1, 2, 3, 4, 5, 6, 7, 8, 9] assert merge_k_sorted_arrays(arrays) == expected arrays = [ [1, 3, 5], [2, 4, 6], [0, 7, 8] ] expected = [0, 1, 2, 3, 4, 5, 6, 7, 8] assert merge_k_sorted_arrays(arrays) == expected arrays = [ [1, 2, 3, 4, 5] ] expected = [1, 2, 3, 4, 5] assert merge_k_sorted_arrays(arrays) == expected arrays = [] expected = [] assert merge_k_sorted_arrays(arrays) == expected arrays = [ [1, 4, 9], [2, 5], [3, 6, 10, 11] ] expected = [1, 2, 3, 4, 5, 6, 9, 10, 11] assert merge_k_sorted_arrays(arrays) == expected arrays = [ [1, 1, 1], [1, 1, 1], [1, 1, 1] ] expected = [1, 1, 1, 1, 1, 1, 1, 1, 1] assert merge_k_sorted_arrays(arrays) == expected arrays = [ list(range(1, 500 + 1)), list(range(501, 1000 + 1)), list(range(1001, 1500 + 1)) ] expected = list(range(1, 1500 + 1)) assert merge_k_sorted_arrays(arrays) == expected","solution":"import heapq def merge_k_sorted_arrays(arrays): Merges k sorted arrays into a single sorted array using a min-heap. Parameters: arrays (list of list of int): List of k sorted arrays, each of size n. Returns: list: A single sorted list with all elements from the k input arrays. min_heap = [] # Store the iterator for each array iterators = [iter(array) for array in arrays] # Populate the heap with the first element from each array, along with the array index for i, it in enumerate(iterators): element = next(it, None) if element is not None: heapq.heappush(min_heap, (element, i)) result = [] while min_heap: smallest, i = heapq.heappop(min_heap) result.append(smallest) # Get the next element from the iterator corresponding to the array \`i\` element = next(iterators[i], None) if element is not None: heapq.heappush(min_heap, (element, i)) return result"},{"question":"from typing import List, Tuple, Set def generate_hypercube(n: int) -> Tuple[List[Tuple[int, ...]], Set[Tuple[Tuple[int, ...], Tuple[int, ...]]]]: Generates the vertices and edges of an n-dimensional hypercube. Parameters: n (int): The number of dimensions of the hypercube. Returns: tuple: A list of vertices and a set of edges representing the hypercube. >>> generate_hypercube(0) ([()], set()) >>> generate_hypercube(1) ([(0,), (1,)], {((0,), (1,))}) >>> generate_hypercube(2) ([(0, 0), (1, 0), (0, 1), (1, 1)], {((0, 0), (1, 0)), ((0, 0), (0, 1)), ((1, 0), (1, 1)), ((0, 1), (1, 1))}) >>> generate_hypercube(3) ([(0, 0, 0), (1, 0, 0), (0, 1, 0), (1, 1, 0), (0, 0, 1), (1, 0, 1), (0, 1, 1), (1, 1, 1)], { ((0, 0, 0), (1, 0, 0)), ((0, 0, 0), (0, 1, 0)), ((0, 0, 0), (0, 0, 1)), ((1, 0, 0), (1, 1, 0)), ((1, 0, 0), (1, 0, 1)), ((0, 1, 0), (1, 1, 0)), ((0, 1, 0), (0, 1, 1)), ((1, 1, 0), (1, 1, 1)), ((0, 0, 1), (1, 0, 1)), ((0, 0, 1), (0, 1, 1)), ((1, 0, 1), (1, 1, 1)), ((0, 1, 1), (1, 1, 1)) }) >>> generate_hypercube(4) ([(0, 0, 0, 0), (1, 0, 0, 0), (0, 1, 0, 0), (1, 1, 0, 0), (0, 0, 1, 0), (1, 0, 1, 0), (0, 1, 1, 0), (1, 1, 1, 0), (0, 0, 0, 1), (1, 0, 0, 1), (0, 1, 0, 1), (1, 1, 0, 1), (0, 0, 1, 1), (1, 0, 1, 1), (0, 1, 1, 1), (1, 1, 1, 1)], {...})","solution":"from itertools import combinations def generate_hypercube(n): Generates the vertices and edges of an n-dimensional hypercube. Parameters: n (int): The number of dimensions of the hypercube. Returns: tuple: A list of vertices and a set of edges representing the hypercube. # Generate vertices vertices = [] for i in range(2**n): vertex = tuple((i >> j) & 1 for j in range(n)) vertices.append(vertex) # Generate edges edges = set() for v1, v2 in combinations(vertices, 2): # Calculate the Hamming distance between v1 and v2 if sum(a != b for a, b in zip(v1, v2)) == 1: edges.add((v1, v2)) return vertices, edges"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def insert_into_bst(root, value): Inserts a value into the Binary Search Tree and returns the root of the updated tree. >>> root = None >>> root = insert_into_bst(root, 3) >>> inorder_traversal(root) [3] >>> root = TreeNode(5) >>> root = insert_into_bst(root, 3) >>> inorder_traversal(root) [3, 5] >>> root = TreeNode(5) >>> root = insert_into_bst(root, 3) >>> root = insert_into_bst(root, 7) >>> inorder_traversal(root) [3, 5, 7] >>> root = TreeNode(3, TreeNode(1), TreeNode(4)) >>> root = insert_into_bst(root, 2) >>> inorder_traversal(root) [1, 2, 3, 4] pass def inorder_traversal(root): Helper function to perform in-order traversal of the BST. Returns a list of node values. result = [] def _inorder(node): if node is not None: _inorder(node.left) result.append(node.val) _inorder(node.right) _inorder(root) return result","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def insert_into_bst(root, value): Inserts a value into the Binary Search Tree and returns the root of the updated tree. if root is None: return TreeNode(value) if value < root.val: root.left = insert_into_bst(root.left, value) else: root.right = insert_into_bst(root.right, value) return root"},{"question":"def is_valid_triangle(a: int, b: int, c: int) -> bool: Validate whether three given lengths can form a valid triangle. A triangle is valid if the sum of any two sides is greater than the third side. >>> is_valid_triangle(3, 4, 5) True >>> is_valid_triangle(1, 2, 3) False >>> is_valid_triangle(5, 5, 10) False from solution import is_valid_triangle def test_valid_triangles(): assert is_valid_triangle(3, 4, 5) == True assert is_valid_triangle(1, 1, 1) == True assert is_valid_triangle(5, 10, 12) == True assert is_valid_triangle(7, 10, 5) == True assert is_valid_triangle(6, 8, 10) == True def test_invalid_triangles(): assert is_valid_triangle(1, 2, 3) == False assert is_valid_triangle(5, 5, 10) == False assert is_valid_triangle(1, 1, 2) == False assert is_valid_triangle(10, 1, 1) == False assert is_valid_triangle(2, 3, 5) == False def test_edge_cases(): assert is_valid_triangle(2, 2, 3) == True assert is_valid_triangle(2, 3, 4) == True assert is_valid_triangle(100, 100, 50) == True assert is_valid_triangle(50, 100, 100) == True","solution":"def is_valid_triangle(a: int, b: int, c: int) -> bool: Returns True if the given side lengths can form a valid triangle, otherwise False. A triangle is valid if the sum of any two sides is greater than the third side. return a + b > c and a + c > b and b + c > a"},{"question":"from typing import List def find_misspelled_words(dictionary: List[str], document: List[str]) -> List[str]: Returns the list of words from the document that are not found in the dictionary. >>> find_misspelled_words([\\"apple\\", \\"banana\\", \\"orange\\", \\"grape\\"], [\\"apple\\", \\"aple\\", \\"banana\\", \\"grap\\", \\"orange\\", \\"grape\\", \\"berry\\"]) ['aple', 'grap', 'berry'] >>> find_misspelled_words([\\"pear\\", \\"peach\\", \\"plum\\"], [\\"pear\\", \\"peach\\", \\"plum\\"]) []","solution":"from typing import List def find_misspelled_words(dictionary: List[str], document: List[str]) -> List[str]: Returns the list of words from the document that are not found in the dictionary. dict_set = set(dictionary) # Convert dictionary list to set for faster lookup misspelled_words = [word for word in document if word not in dict_set] return misspelled_words"},{"question":"from datetime import datetime from threading import Lock from typing import List, Tuple class ThreadSafeLogger: A multi-threaded logging system that ensures thread-safe logging of events in a distributed environment. The system supports creating log entries, retrieving all logs in chronological order, and clearing the log records. Methods: log_event(event: str) -> None: Adds the event to the log with the current timestamp. get_logs() -> List[Tuple[str, datetime]]: Returns all logs sorted by timestamp. clear_logs() -> None: Clears all log entries. Example Usage: >>> from threading import Thread >>> import time >>> logger = ThreadSafeLogger() >>> def log_events(thread_id): ... for i in range(5): ... logger.log_event(f\\"Event from thread {thread_id}, log {i}\\") ... time.sleep(0.1) >>> threads = [Thread(target=log_events, args=(i,)) for i in range(3)] >>> for thread in threads: ... thread.start() >>> for thread in threads: ... thread.join() >>> logs = logger.get_logs() >>> print(logs) >>> logger.clear_logs() def __init__(self): # Initialize necessary data structures and locks pass def log_event(self, event: str) -> None: # Log the event with the current timestamp pass def get_logs(self) -> List[Tuple[str, datetime]]: # Return all logs sorted by timestamp pass def clear_logs(self) -> None: # Clear all log entries pass # Unit Tests def test_log_and_retrieve(): logger = ThreadSafeLogger() # Add some logs logger.log_event(\\"Test event 1\\") logger.log_event(\\"Test event 2\\") logs = logger.get_logs() assert len(logs) == 2 assert logs[0][0] == \\"Test event 1\\" assert logs[1][0] == \\"Test event 2\\" # Timestamps should be of datetime type assert isinstance(logs[0][1], datetime) assert isinstance(logs[1][1], datetime) def test_clear_logs(): logger = ThreadSafeLogger() # Add some logs logger.log_event(\\"Test event 1\\") logger.log_event(\\"Test event 2\\") logger.clear_logs() logs = logger.get_logs() assert len(logs) == 0 def test_thread_safety(): logger = ThreadSafeLogger() # Define a function to log events in a thread. def log_events(thread_id): for i in range(5): logger.log_event(f\\"Event from thread {thread_id}, log {i}\\") time.sleep(0.1) threads = [Thread(target=log_events, args=(i,)) for i in range(3)] for thread in threads: thread.start() for thread in threads: thread.join() logs = logger.get_logs() assert len(logs) == 15 # 3 threads * 5 logs each # Ensure logs are sorted by timestamp for i in range(14): assert logs[i][1] <= logs[i + 1][1] def test_concurrent_clear_and_log(): logger = ThreadSafeLogger() logger.log_event(\\"Initial event\\") def log_and_clear(): logger.log_event(\\"Concurrent event\\") logger.clear_logs() threads = [Thread(target=log_and_clear) for _ in range(5)] for thread in threads: thread.start() for thread in threads: thread.join() logs = logger.get_logs() # logs should be either empty or contain only \\"Concurrent event\\" logs assert all(log[0] == \\"Concurrent event\\" for log in logs) or len(logs) == 0","solution":"from datetime import datetime from threading import Lock from typing import List, Tuple class ThreadSafeLogger: def __init__(self): self.logs = [] self.lock = Lock() def log_event(self, event: str) -> None: with self.lock: timestamp = datetime.now() self.logs.append((event, timestamp)) def get_logs(self) -> List[Tuple[str, datetime]]: with self.lock: return sorted(self.logs, key=lambda x: x[1]) def clear_logs(self) -> None: with self.lock: self.logs.clear()"},{"question":"def element_frequency(lst: list) -> dict: Given a list of elements (integers or strings), returns a dictionary where each key is an element from the list and the corresponding value is the count of that element's occurrences in the list. Raises a TypeError if the input is not a list, or if the list contains elements that are neither integers nor strings. Parameters: lst (list): A list of elements (integers or strings). Returns: dict: A dictionary with elements as keys and their frequency as values. Example: >>> element_frequency([1, 2, 2, 3, 'a', 'a', 'b']) {1: 1, 2: 2, 3: 1, 'a': 2, 'b': 1} >>> element_frequency(['apple', 'banana', 'apple']) {'apple': 2, 'banana': 1} Constraints: * The input list can contain a maximum of 10^5 elements. * Elements in the list can either be integers or strings. pass","solution":"def element_frequency(lst): Given a list of elements (integers or strings), returns a dictionary where each key is an element from the list and the corresponding value is the count of that element's occurrences in the list. Parameters: lst (list): A list of elements (integers or strings). Returns: dict: A dictionary with elements as keys and their frequency as values. if not isinstance(lst, list): raise TypeError(\\"Input must be a list\\") frequency = {} for elem in lst: if not isinstance(elem, (int, str)): raise TypeError(\\"List elements must be integers or strings\\") if elem in frequency: frequency[elem] += 1 else: frequency[elem] = 1 return frequency"},{"question":"from typing import List def product_except_self(nums: List[int]) -> List[int]: Write a function that takes a list of integers and returns a new list where each integer is replaced by the product of all other integers in the list except the integer at the current position. >>> product_except_self([1, 2, 3, 4]) == [24, 12, 8, 6] >>> product_except_self([0, 1, 2, 3]) == [6, 0, 0, 0] >>> product_except_self([0, 0, 3, 4]) == [0, 0, 0, 0] >>> product_except_self([2, 3, 4, 5]) == [60, 40, 30, 24] >>> product_except_self([1]) == [1] >>> product_except_self([]) == [] # Your implementation goes here","solution":"from typing import List def product_except_self(nums: List[int]) -> List[int]: n = len(nums) if n == 0: return [] elif n == 1: return [1] left_products = [1] * n right_products = [1] * n left_cumulative_product = 1 for i in range(n): left_products[i] = left_cumulative_product left_cumulative_product *= nums[i] right_cumulative_product = 1 for i in range(n-1, -1, -1): right_products[i] = right_cumulative_product right_cumulative_product *= nums[i] result = [] for i in range(n): result.append(left_products[i] * right_products[i]) return result"},{"question":"def is_approved(yes_votes: int, no_votes: int) -> bool: Determines whether a proposal is approved based on the counts of \\"yes\\" and \\"no\\" votes. :param yes_votes: The number of \\"yes\\" votes. :param no_votes: The number of \\"no\\" votes. :return: True if the proposal is approved (i.e., yes_votes > no_votes), otherwise False. Examples: >>> is_approved(10, 5) True >>> is_approved(3, 3) False >>> is_approved(7, 10) False Raises: ValueError: If \`yes_votes\` or \`no_votes\` is not a non-negative integer.","solution":"def is_approved(yes_votes: int, no_votes: int) -> bool: Determines whether a proposal is approved based on the counts of \\"yes\\" and \\"no\\" votes. :param yes_votes: The number of \\"yes\\" votes. :param no_votes: The number of \\"no\\" votes. :return: True if the proposal is approved (i.e., yes_votes > no_votes), otherwise False. if not (isinstance(yes_votes, int) and isinstance(no_votes, int)): raise ValueError(\\"Vote counts must be non-negative integers\\") if yes_votes < 0 or no_votes < 0: raise ValueError(\\"Vote counts must be non-negative integers\\") return yes_votes > no_votes"},{"question":"def unique_user_access(entries, start_time, end_time): Returns a set of unique usernames who have accessed the service between start_time and end_time inclusive. Args: - entries: list of tuples (username: str, timestamp: float) - start_time: float, start of the time frame (inclusive) - end_time: float, end of the time frame (inclusive) Returns: - set of unique usernames >>> unique_user_access([('user123', 1609459200.0), ('user456', 1609545600.0), ('user123', 1609632000.0)], 1609459200.0, 1609545600.0) {'user123', 'user456'} >>> unique_user_access([('user123', 1609459200.0), ('user456', 1609545600.0), ('User123', 1609632000.0)], 1609459200.0, 1609459300.0) {'user123'} >>> unique_user_access([('user123', 1609459200.0), ('user456', 1609545600.0), ('user123', 1609632000.0)], 1609632000.0, 1609632100.0) {'user123'} >>> unique_user_access([('user123', 1609459200.0), ('user456', 1609545600.0)], 1609545601.0, 1609632000.0) set() >>> unique_user_access([], 1609459200.0, 1609545600.0) set()","solution":"def unique_user_access(entries, start_time, end_time): Returns a set of unique usernames who have accessed the service between start_time and end_time inclusive. Args: - entries: list of tuples (username: str, timestamp: float) - start_time: float, start of the time frame (inclusive) - end_time: float, end of the time frame (inclusive) Returns: - set of unique usernames unique_users = set() for username, timestamp in entries: if start_time <= timestamp <= end_time: unique_users.add(username) return unique_users"},{"question":"def verify_traversals(in_order: list[int], pre_order: list[int], post_order: list[int]) -> bool: Verify that the given in-order, pre-order, and post-order traversal lists correspond to the same binary tree. >>> verify_traversals([4, 2, 5, 1, 6, 3, 7], [1, 2, 4, 5, 3, 6, 7], [4, 5, 2, 6, 7, 3, 1]) == True >>> verify_traversals([4, 2, 5, 1, 6, 3, 7], [1, 2, 4, 5, 6, 3, 7], [4, 5, 2, 6, 7, 3, 1]) == False >>> verify_traversals([2, 1], [1, 2], [2, 1]) == True >>> verify_traversals([], [], []) == True >>> verify_traversals([1], [1], [1]) == True >>> verify_traversals([1, 2], [1], [2, 1]) == False >>> verify_traversals([8, 4, 2, 5, 1, 6, 3, 7], [1, 2, 4, 8, 5, 3, 6, 7], [8, 4, 5, 2, 6, 7, 3, 1]) == True","solution":"def verify_traversals(in_order, pre_order, post_order): if not in_order or not pre_order or not post_order: return in_order == pre_order == post_order == [] if len(in_order) != len(pre_order) or len(in_order) != len(post_order): return False def build_tree_from_in_pre(pre_order, in_order_map, pre_start, pre_end, in_start, in_end): if pre_start > pre_end or in_start > in_end: return None, pre_start - 1 root_value = pre_order[pre_start] root_index_in_order = in_order_map[root_value] left_tree_size = root_index_in_order - in_start left_subtree, left_end_index = build_tree_from_in_pre(pre_order, in_order_map, pre_start + 1, pre_start + left_tree_size, in_start, root_index_in_order - 1) right_subtree, right_end_index = build_tree_from_in_pre(pre_order, in_order_map, pre_start + left_tree_size + 1, pre_end, root_index_in_order + 1, in_end) return root_value, right_end_index in_order_map = {value: idx for idx, value in enumerate(in_order)} root_val, pre_end_index = build_tree_from_in_pre(pre_order, in_order_map, 0, len(pre_order) - 1, 0, len(in_order) - 1) def get_post_order_from_in_pre(pre_order, in_order_map, pre_start, pre_end, in_start, in_end): if pre_start > pre_end or in_start > in_end: return [] root_value = pre_order[pre_start] root_index_in_order = in_order_map[root_value] left_tree_size = root_index_in_order - in_start left_subtree_post_order = get_post_order_from_in_pre(pre_order, in_order_map, pre_start + 1, pre_start + left_tree_size, in_start, root_index_in_order - 1) right_subtree_post_order = get_post_order_from_in_pre(pre_order, in_order_map, pre_start + left_tree_size + 1, pre_end, root_index_in_order + 1, in_end) return left_subtree_post_order + right_subtree_post_order + [root_value] derived_post_order = get_post_order_from_in_pre(pre_order, in_order_map, 0, len(pre_order) - 1, 0, len(in_order) - 1) return derived_post_order == post_order"},{"question":"def find_nth_digit(n: int) -> str: Create a function that takes an integer n and returns the nth number in the sequence formed by arranging all positive integers in increasing order and then concatenating their digits into a single string. >>> find_nth_digit(15) '2' >>> find_nth_digit(20) '1'","solution":"def find_nth_digit(n: int) -> str: length = 1 count = 9 start = 1 while n > length * count: n -= length * count length += 1 count *= 10 start *= 10 start += (n - 1) // length digit_index = (n - 1) % length return str(start)[digit_index]"},{"question":"from typing import Dict def add_item(inventory: Dict[str, int], item_name: str, quantity: int) -> None: Updates the inventory by adding the given quantity of the specified item. Args: inventory (dict): The current inventory. item_name (str): The name of the item to add or update. quantity (int): The quantity to add to the existing quantity. Returns: None pass def remove_item(inventory: Dict[str, int], item_name: str, quantity: int) -> bool: Updates the inventory by removing the given quantity of the specified item. Args: inventory (dict): The current inventory. item_name (str): The name of the item to remove. quantity (int): The quantity to remove from the existing quantity. Returns: bool: True if the operation was successful, False if the item did not exist. pass # Example usage inventory = {\\"apple\\": 10, \\"banana\\": 5, \\"orange\\": 7} # Add items to the inventory add_item(inventory, \\"apple\\", 5) # Inventory: {\\"apple\\": 15, \\"banana\\": 5, \\"orange\\": 7} add_item(inventory, \\"pear\\", 12) # Inventory: {\\"apple\\": 15, \\"banana\\": 5, \\"orange\\": 7, \\"pear\\": 12} # Remove items from the inventory print(remove_item(inventory, \\"banana\\", 2)) # True, Inventory: {\\"apple\\": 15, \\"banana\\": 3, \\"orange\\": 7, \\"pear\\": 12} print(remove_item(inventory, \\"orange\\", 10)) # True, Inventory: {\\"apple\\": 15, \\"banana\\": 3, \\"pear\\": 12} print(remove_item(inventory, \\"grape\\", 1)) # False, Inventory unchanged: {\\"apple\\": 15, \\"banana\\": 3, \\"pear\\": 12} # Unit Tests def test_add_item_new_item(): inventory = {} add_item(inventory, \\"apple\\", 5) assert inventory == {\\"apple\\": 5} def test_add_item_existing_item(): inventory = {\\"apple\\": 10} add_item(inventory, \\"apple\\", 5) assert inventory == {\\"apple\\": 15} def test_remove_item_existing_item_sufficient_quantity(): inventory = {\\"banana\\": 5} result = remove_item(inventory, \\"banana\\", 3) assert result == True assert inventory == {\\"banana\\": 2} def test_remove_item_existing_item_insufficient_quantity(): inventory = {\\"orange\\": 7} result = remove_item(inventory, \\"orange\\", 10) assert result == True assert inventory == {} def test_remove_item_non_existent_item(): inventory = {\\"pear\\": 12} result = remove_item(inventory, \\"grape\\", 1) assert result == False assert inventory == {\\"pear\\": 12} def test_add_and_remove_item(): inventory = {\\"banana\\": 5} add_item(inventory, \\"banana\\", 10) assert inventory == {\\"banana\\": 15} result = remove_item(inventory, \\"banana\\", 10) assert result == True assert inventory == {\\"banana\\": 5} result = remove_item(inventory, \\"banana\\", 5) assert result == True assert inventory == {}","solution":"def add_item(inventory, item_name, quantity): Updates the inventory by adding the given quantity of the specified item. Args: inventory (dict): The current inventory. item_name (str): The name of the item to add or update. quantity (int): The quantity to add to the existing quantity. Returns: None if item_name in inventory: inventory[item_name] += quantity else: inventory[item_name] = quantity def remove_item(inventory, item_name, quantity): Updates the inventory by removing the given quantity of the specified item. Args: inventory (dict): The current inventory. item_name (str): The name of the item to remove. quantity (int): The quantity to remove from the existing quantity. Returns: bool: True if the operation was successful, False if the item did not exist. if item_name not in inventory: return False if inventory[item_name] <= quantity: del inventory[item_name] else: inventory[item_name] -= quantity return True"},{"question":"import heapq from typing import Any class BinaryHeapPriorityQueue: A priority queue implemented using a binary heap (max-heap). Methods: 1. insert(element: Any, priority: int) -> None : Insert an element with the given priority into the priority queue. 2. extract_max() -> Any : Extract and return the element with the highest priority. 3. peek() -> Any : Return the element with the highest priority without removing it. Example: >>> queue = BinaryHeapPriorityQueue() >>> queue.insert('task1', 3) >>> queue.insert('task2', 1) >>> queue.peek() # 'task1' 'task1' >>> queue.insert('task3', 4) >>> queue.peek() # 'task3' 'task3' >>> queue.extract_max() # 'task3' 'task3' Raises: IndexError: If extract_max or peek operations are called on an empty priority queue. def __init__(self): self.heap = [] self.count = 0 def insert(self, element: Any, priority: int) -> None: Insert an element with the given priority into the priority queue. pass def extract_max(self) -> Any: Extract and return the element with the highest priority. pass def peek(self) -> Any: Return the element with the highest priority without removing it. pass import pytest def test_insert_and_peek(): queue = BinaryHeapPriorityQueue() queue.insert('task1', 3) queue.insert('task2', 1) assert queue.peek() == 'task1' queue.insert('task3', 4) assert queue.peek() == 'task3' def test_extract_max(): queue = BinaryHeapPriorityQueue() queue.insert('task1', 3) queue.insert('task2', 1) queue.insert('task3', 4) queue.insert('task4', 2) assert queue.extract_max() == 'task3' assert queue.extract_max() == 'task1' assert queue.extract_max() == 'task4' assert queue.extract_max() == 'task2' with pytest.raises(IndexError): queue.extract_max() def test_peek_empty(): queue = BinaryHeapPriorityQueue() with pytest.raises(IndexError): queue.peek()","solution":"import heapq class BinaryHeapPriorityQueue: def __init__(self): self.heap = [] self.count = 0 # Unique sequence count def insert(self, element, priority): # Since heapq in Python implements a min-heap, we store negative priorities for max-heap behavior heapq.heappush(self.heap, (-priority, self.count, element)) self.count += 1 def extract_max(self): if not self.heap: raise IndexError(\\"extract_max from an empty priority queue\\") return heapq.heappop(self.heap)[2] def peek(self): if not self.heap: raise IndexError(\\"peek from an empty priority queue\\") return self.heap[0][2]"},{"question":"def count_unique_anagrams(words: list[str]) -> int: Count the number of unique anagrams in the list of strings. >>> count_unique_anagrams([\\"listen\\", \\"silent\\", \\"enlist\\", \\"google\\", \\"gogole\\"]) 2 >>> count_unique_anagrams([\\"cat\\", \\"tac\\", \\"act\\", \\"dog\\", \\"god\\"]) 2 >>> count_unique_anagrams([\\"a\\", \\"b\\", \\"c\\", \\"a\\", \\"a\\"]) 3 >>> count_unique_anagrams([\\"aaa\\", \\"aaa\\", \\"aaa\\"]) 1 >>> count_unique_anagrams([]) 0","solution":"def count_unique_anagrams(words: list[str]) -> int: Returns the number of unique anagrams in the list. # Use a set to store unique signatures of the words unique_anagrams = set() for word in words: # Sort the word to get its signature and add to the set signature = ''.join(sorted(word)) unique_anagrams.add(signature) # The size of the set will be the count of unique anagrams return len(unique_anagrams)"},{"question":"from typing import List class TaskScheduler: def __init__(self): Initialize the task scheduler. pass def add_task(self, task_id: int, priority: int) -> None: Add a new task with a given \`task_id\` and \`priority\`. If the task_id already exists, update its priority. pass def remove_task(self, task_id: int) -> bool: Remove a task identified by the \`task_id\`. Return \`True\` if removal is successful, \`False\` if the task is not found. pass def get_task(self) -> int: Return the \`task_id\` of the highest priority task. If there are multiple tasks with the same priority, return any one of them. Return \`-1\` if no tasks are present. pass # Example usage: if __name__ == \\"__main__\\": # Initialize the task scheduler scheduler = TaskScheduler() # Add tasks with various priorities scheduler.add_task(1, 5) scheduler.add_task(2, 3) scheduler.add_task(3, 9) # Get the highest priority task assert scheduler.get_task() == 3 # Remove a task assert scheduler.remove_task(3) is True # Get the next highest priority task assert scheduler.get_task() == 1 # Remove a non-existent task assert scheduler.remove_task(4) is False # Add a new task with a higher priority scheduler.add_task(4, 10) assert scheduler.get_task() == 4","solution":"import heapq class TaskScheduler: def __init__(self): self.heap = [] self.task_map = {} self.counter = 0 def add_task(self, task_id: int, priority: int) -> None: if task_id in self.task_map: # If the task_id already exists, remove it first before adding the updated one self.remove_task(task_id) entry = (-priority, self.counter, task_id) self.task_map[task_id] = entry heapq.heappush(self.heap, entry) self.counter += 1 def remove_task(self, task_id: int) -> bool: if task_id not in self.task_map: return False entry = self.task_map.pop(task_id) # Mark entry as removed by setting task_id to None self.heap[self.heap.index(entry) if entry in self.heap else 0] = (-entry[0], entry[1], None) heapq.heapify(self.heap) return True def get_task(self) -> int: while self.heap: priority, count, task_id = heapq.heappop(self.heap) if task_id is not None: heapq.heappush(self.heap, (priority, count, task_id)) return task_id return -1"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def mirror_tree(root: TreeNode) -> None: Convert the given binary tree to its mirror in place. Parameters: root (TreeNode): The root of the binary tree. Returns: None Example: >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> root.left.left = TreeNode(4) >>> root.left.right = TreeNode(5) >>> mirror_tree(root) >>> print(root.left.val) # Output should be 3 3 >>> print(root.right.val) # Output should be 2 2 >>> print(root.right.left.val) # Output should be 5 5 >>> print(root.right.right.val) # Output should be 4 4","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def mirror_tree(root: TreeNode) -> None: Convert the given binary tree to its mirror in place. Parameters: root (TreeNode): The root of the binary tree. Returns: None if root is None: return # Swap the left and right children root.left, root.right = root.right, root.left # Recursively mirror the left and right subtrees mirror_tree(root.left) mirror_tree(root.right)"},{"question":"def count_even_divisors(n: int) -> int: Returns the count of numbers between 1 and n that have an even number of divisors. A number has an even number of divisors if and only if it is not a perfect square. Example: >>> count_even_divisors(10) 7 >>> count_even_divisors(15) 12 >>> count_even_divisors(20) 16","solution":"def count_even_divisors(n: int) -> int: Returns the count of numbers between 1 and n that have an even number of divisors. A number has an even number of divisors if and only if it is not a perfect square. # Calculate the number of perfect squares between 1 and n max_square_root = int(n**0.5) perfect_squares_count = max_square_root # since there are max_square_root perfect squares from 1 to n # Total numbers between 1 and n minus the perfect squares gives us the numbers with even divisors even_divisors_count = n - perfect_squares_count return even_divisors_count"},{"question":"class SimpleTextEditor: A simple text editor class that supports appending text, deleting text, and searching for substrings using the Knuth-Morris-Pratt (KMP) algorithm. Methods: - append(self, text: str) -> None: Appends the given text to the editor content. - delete(self, k: int) -> None: Deletes the last k characters from the editor content. - search(self, substring: str) -> int: Returns the starting index of the substring using KMP algorithm, or -1 if not found. def __init__(self): self.content = \\"\\" def append(self, text: str) -> None: pass def delete(self, k: int) -> None: pass def search(self, substring: str) -> int: pass def test_append_and_search(): editor = SimpleTextEditor() editor.append(\\"hello\\") assert editor.search(\\"hello\\") == 0 editor.append(\\" world\\") assert editor.search(\\"world\\") == 6 def test_delete_and_search(): editor = SimpleTextEditor() editor.append(\\"hello world\\") editor.delete(6) assert editor.search(\\"world\\") == -1 assert editor.search(\\"hello\\") == 0 def test_search_non_existent_string(): editor = SimpleTextEditor() editor.append(\\"hello world\\") assert editor.search(\\"xyz\\") == -1 def test_search_partial_match(): editor = SimpleTextEditor() editor.append(\\"ababcabcabababd\\") assert editor.search(\\"ababd\\") == 10 def test_search_with_edge_cases(): editor = SimpleTextEditor() editor.append(\\"a\\" * 1000000) editor.append(\\"abc\\") assert editor.search(\\"abc\\") == 1000000 editor.delete(1000003) assert editor.search(\\"abc\\") == -1 editor.append(\\"xyz\\" * 333333) assert editor.search(\\"xyz\\") == 0","solution":"class SimpleTextEditor: def __init__(self): self.content = \\"\\" def append(self, text): self.content += text def delete(self, k): self.content = self.content[:-k] def search(self, substring): return self.kmp_search(substring) def kmp_search(self, pat): M = len(pat) N = len(self.content) lps = [0] * M j = 0 self.compute_lps_array(pat, M, lps) i = 0 while i < N: if pat[j] == self.content[i]: i += 1 j += 1 if j == M: return i - j elif i < N and pat[j] != self.content[i]: if j != 0: j = lps[j-1] else: i += 1 return -1 def compute_lps_array(self, pat, M, lps): length = 0 lps[0] = 0 i = 1 while i < M: if pat[i] == pat[length]: length += 1 lps[i] = length i += 1 else: if length != 0: length = lps[length-1] else: lps[i] = 0 i += 1"},{"question":"import requests def fetch_weather_data(base_url: str, params: dict) -> tuple: Fetch weather data from a provided API for a specified city and return the temperature and weather conditions. Args: base_url (str): The base URL for the weather API. params (dict): A dictionary of parameters that includes the city name, and API key. Returns: tuple: A tuple containing: - A string with the temperature in Celsius. - A string describing the weather conditions. Constraints: The function should handle network and API errors gracefully and retry a specified number of times before failing. Maximum allowed retries: 3. Implement proper exception handling for various potential failures (HTTP errors, parsing errors, etc.) Example: >>> params = { >>> \\"q\\": \\"Berlin\\", >>> \\"appid\\": \\"your_api_key\\", >>> \\"units\\": \\"metric\\" >>> } >>> result = fetch_weather_data(\\"http://api.openweathermap.org/data/2.5/weather\\", params) >>> assert result == (\\"22\\", \\"Clear sky\\") Test cases: >>> from unittest.mock import patch >>> >>> def test_fetch_weather_data_success(): >>> mock_response = { >>> \\"main\\": { >>> \\"temp\\": 22 >>> }, >>> \\"weather\\": [ >>> {\\"description\\": \\"clear sky\\"} >>> ] >>> } >>> with patch('requests.get') as mock_get: >>> mock_get.return_value.status_code = 200 >>> mock_get.return_value.json.return_value = mock_response >>> result = fetch_weather_data(\\"http://api.openweathermap.org/data/2.5/weather\\", {\\"q\\": \\"Berlin\\", \\"appid\\": \\"test_api_key\\", \\"units\\": \\"metric\\"}) >>> assert result == (\\"22\\", \\"Clear sky\\") >>> >>> def test_fetch_weather_data_http_error(): >>> with patch('requests.get') as mock_get: >>> mock_get.side_effect = requests.exceptions.HTTPError >>> result = fetch_weather_data(\\"http://api.openweathermap.org/data/2.5/weather\\", {\\"q\\": \\"Berlin\\", \\"appid\\": \\"test_api_key\\", \\"units\\": \\"metric\\"}) >>> assert result == (\\"Error\\", \\"Failed to fetch data after multiple attempts\\") >>> >>> def test_fetch_weather_data_parsing_error(): >>> mock_response = { >>> \\"incorrect_key\\": { >>> \\"temp\\": 22 >>> } >>> } >>> with patch('requests.get') as mock_get: >>> mock_get.return_value.status_code = 200 >>> mock_get.return_value.json.return_value = mock_response >>> result = fetch_weather_data(\\"http://api.openweathermap.org/data/2.5/weather\\", {\\"q\\": \\"Berlin\\", \\"appid\\": \\"test_api_key\\", \\"units\\": \\"metric\\"}) >>> assert result == (\\"Error\\", \\"Error in parsing weather data\\") >>> >>> def test_fetch_weather_data_requests_exception(): >>> with patch('requests.get') as mock_get: >>> mock_get.side_effect = requests.exceptions.RequestException >>> result = fetch_weather_data(\\"http://api.openweathermap.org/data/2.5/weather\\", {\\"q\\": \\"Berlin\\", \\"appid\\": \\"test_api_key\\", \\"units\\": \\"metric\\"}) >>> assert result == (\\"Error\\", \\"Failed to fetch data after multiple attempts\\")","solution":"import requests def fetch_weather_data(base_url: str, params: dict) -> tuple: Fetches weather data from a provided API for a specified city and returns the temperature in Celsius and weather conditions. max_retries = 3 for attempt in range(max_retries): try: response = requests.get(base_url, params=params) response.raise_for_status() data = response.json() # Parsing and processing weather data temperature = str(data['main']['temp']) weather_conditions = data['weather'][0]['description'].capitalize() return (temperature, weather_conditions) except requests.exceptions.RequestException as e: if attempt == max_retries - 1: return (\\"Error\\", \\"Failed to fetch data after multiple attempts\\") except (KeyError, ValueError, TypeError) as e: return (\\"Error\\", \\"Error in parsing weather data\\") # Example usage: # params = { # \\"q\\": \\"Berlin\\", # \\"appid\\": \\"your_api_key\\", # \\"units\\": \\"metric\\" # } # result = fetch_weather_data(\\"http://api.openweathermap.org/data/2.5/weather\\", params) # print(result)"},{"question":"from collections import deque def find_shortest_path(city_grid: list[list[int]], start: tuple[int, int], destination: tuple[int, int]) -> int: Calculate the most efficient route between two points in a city grid. The city grid is represented as a 2D list with roads (0) and buildings (1). The function should return the minimum number of moves required to reach the destination, or -1 if it is not possible. >>> city_grid = [ ... [0, 0, 0], ... [0, 1, 0], ... [0, 0, 0], ... ] >>> find_shortest_path(city_grid, (0, 0), (2, 2)) 4 >>> city_grid = [ ... [0, 1, 0], ... [1, 1, 0], ... [0, 1, 0], ... ] >>> find_shortest_path(city_grid, (0, 0), (2, 2)) -1","solution":"from collections import deque def find_shortest_path(city_grid, start, destination): rows, cols = len(city_grid), len(city_grid[0]) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] # Check if start and destination are the same if start == destination: return 0 queue = deque([(start[0], start[1], 0)]) # (row, col, steps) visited = set() visited.add((start[0], start[1])) while queue: x, y, steps = queue.popleft() for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < rows and 0 <= ny < cols and (nx, ny) not in visited and city_grid[nx][ny] == 0: if (nx, ny) == destination: return steps + 1 queue.append((nx, ny, steps + 1)) visited.add((nx, ny)) return -1"},{"question":"from typing import Optional class Node: def __init__(self, value: int = 0, left: Optional['Node'] = None, right: Optional['Node'] = None): self.value = value self.left = left self.right = right def sum_of_leaves(root: Optional[Node]) -> int: Implement a function \`sum_of_leaves(root)\` which takes the root of a binary tree and returns the sum of all the leaf nodes' values. >>> root = Node(1) >>> root.left = Node(2) >>> root.right = Node(3) >>> root.left.left = Node(4) >>> root.left.right = Node(5) >>> root.right.left = Node(6) >>> root.right.right = Node(7) >>> sum_of_leaves(root) 22 >>> sum_of_leaves(Node(1)) 1 >>> sum_of_leaves(None) 0 pass def test_sum_of_leaves_single_node(): root = Node(1) assert sum_of_leaves(root) == 1 def test_sum_of_leaves_empty_tree(): root = None assert sum_of_leaves(root) == 0 def test_sum_of_leaves_all_leaf_nodes(): root = Node(1, Node(2), Node(3)) assert sum_of_leaves(root) == 5 def test_sum_of_leaves_mixed_tree(): root = Node(1) root.left = Node(2) root.right = Node(3) root.left.left = Node(4) root.left.right = Node(5) root.right.left = Node(6) root.right.right = Node(7) assert sum_of_leaves(root) == 22 def test_sum_of_leaves_large_tree(): root = Node(1) root.left = Node(2) root.right = Node(3) root.left.left = Node(4) root.left.right = Node(5) root.right.right = Node(6) root.left.left.left = Node(7) root.left.left.right = Node(8) root.right.right.left = Node(9) root.right.right.right = Node(10) assert sum_of_leaves(root) == 7 + 8 + 5 + 9 + 10","solution":"class Node: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def sum_of_leaves(root): if root is None: return 0 if root.left is None and root.right is None: return root.value return sum_of_leaves(root.left) + sum_of_leaves(root.right)"},{"question":"def prime_pair_partition(n: int) -> list[tuple[int, int]]: Determines all unique prime pairs that sum up to the given integer n. Raises a TypeError if input is not an integer. Returns an empty list if input is negative or less than 2. Args: n (int): The integer input. Returns: list[tuple[int, int]]: A list of tuples, each containing a pair of prime numbers that sum up to n. Examples: >>> prime_pair_partition(-5) [] >>> prime_pair_partition(1) [] >>> prime_pair_partition(4) [(2, 2)] >>> prime_pair_partition(10) [(3, 7), (5, 5)] >>> prime_pair_partition(16) [(3, 13), (5, 11)] >>> prime_pair_partition(100) [(3, 97), (11, 89), (17, 83), (29, 71), (41, 59), (47, 53)]","solution":"def prime_pair_partition(n: int) -> list[tuple[int, int]]: if not isinstance(n, int): raise TypeError(\\"Input must be an integer.\\") if n < 2: return [] def sieve_of_eratosthenes(limit): is_prime = [True] * (limit + 1) p = 2 while (p * p <= limit): if (is_prime[p] == True): for i in range(p * p, limit + 1, p): is_prime[i] = False p += 1 return [p for p in range(2, limit + 1) if is_prime[p]] primes = sieve_of_eratosthenes(n) prime_set = set(primes) result = [] for p1 in primes: p2 = n - p1 if p2 in prime_set and p1 <= p2: result.append((p1, p2)) return result"},{"question":"class ListNode: def __init__(self, value=0, next=None): self.value = value self.next = next class LinkedList: def reverse_list(self, head: ListNode) -> ListNode: Reverses the linked list and returns the head of the new list. >>> head = ListNode(1, ListNode(2, ListNode(3, ListNode(4)))) >>> ll = LinkedList() >>> new_head = ll.reverse_list(head) >>> values = [] >>> current = new_head >>> while current: ... values.append(current.value) ... current = current.next >>> values [4, 3, 2, 1]","solution":"class ListNode: def __init__(self, value=0, next=None): self.value = value self.next = next class LinkedList: def reverse_list(self, head: ListNode) -> ListNode: prev = None current = head while current: next_node = current.next current.next = prev prev = current current = next_node return prev # New head after reversing the list"},{"question":"from typing import List class ProductSegmentTree: A class to represent a segment tree for efficiently computing the product of elements in subarrays and allowing point updates. Methods ------- __init__(self, array: List[int]) -> None: Initializes the ProductSegmentTree with the given array and builds the segment tree. update(self, index: int, value: int) -> None: Updates the value at the specified index and updates the segment tree. query(self, left: int, right: int) -> int: Queries the product of elements within the range [left, right). def test_segment_tree_initial_query(): pst = ProductSegmentTree([2, 3, 5, 7, 11]) assert pst.query(1, 4) == 105 # product of subarray [3, 5, 7] def test_segment_tree_update_and_query(): pst = ProductSegmentTree([2, 3, 5, 7, 11]) pst.update(2, 4) # array becomes [2, 3, 4, 7, 11] assert pst.query(1, 4) == 84 # product of subarray [3, 4, 7] def test_full_array_query(): pst = ProductSegmentTree([2, 3, 5, 7, 11]) assert pst.query(0, 5) == 2 * 3 * 5 * 7 * 11 def test_single_element_update(): pst = ProductSegmentTree([2, 3, 5, 7, 11]) pst.update(0, 1) # array becomes [1, 3, 5, 7, 11] assert pst.query(0, 5) == 1 * 3 * 5 * 7 * 11 def test_query_single_element(): pst = ProductSegmentTree([2, 3, 5, 7, 11]) assert pst.query(2, 3) == 5 # product of subarray [5] def test_query_subarray(): pst = ProductSegmentTree([2, 3, 5, 7, 11]) assert pst.query(1, 3) == 3 * 5 assert pst.query(2, 5) == 5 * 7 * 11","solution":"from typing import List class ProductSegmentTree: def __init__(self, array: List[int]) -> None: self.n = len(array) self.tree = [1] * (2 * self.n) self.build(array) def build(self, array: List[int]) -> None: # Initialize the leaf nodes for i in range(self.n): self.tree[self.n + i] = array[i] # Build the tree by calculating parents for i in range(self.n - 1, 0, -1): self.tree[i] = self.tree[i << 1] * self.tree[i << 1 | 1] def update(self, index: int, value: int) -> None: # Update the value at position \`index\` pos = index + self.n self.tree[pos] = value # Update the segment tree while pos > 1: pos >>= 1 self.tree[pos] = self.tree[pos << 1] * self.tree[pos << 1 | 1] def query(self, left: int, right: int) -> int: # Move the indices to correspond leaf nodes in the tree left += self.n right += self.n product = 1 while left < right: if left & 1: product *= self.tree[left] left += 1 if right & 1: right -= 1 product *= self.tree[right] left >>= 1 right >>= 1 return product"},{"question":"def merge_and_sort(list1: list, list2: list) -> list: Merge two sorted lists into one sorted list. :param list1: A sorted list of integers. :param list2: Another sorted list of integers. :return: A new sorted list containing all elements from list1 and list2. >>> merge_and_sort([1, 3, 5], [2, 4, 6]) [1, 2, 3, 4, 5, 6] >>> merge_and_sort([1, 2, 3], [1, 2, 3]) [1, 1, 2, 2, 3, 3] >>> merge_and_sort([], [1, 3, 5]) [1, 3, 5] >>> merge_and_sort([], []) [] >>> merge_and_sort([1], [2]) [1, 2] >>> merge_and_sort([1] * 100000, [2] * 100000) [1]*100000 + [2]*100000 # Write your code here","solution":"def merge_and_sort(list1, list2): Merge two sorted lists into one sorted list. :param list1: A sorted list of integers. :param list2: Another sorted list of integers. :return: A new sorted list containing all elements from list1 and list2. i, j = 0, 0 merged_list = [] while i < len(list1) and j < len(list2): if list1[i] < list2[j]: merged_list.append(list1[i]) i += 1 else: merged_list.append(list2[j]) j += 1 while i < len(list1): merged_list.append(list1[i]) i += 1 while j < len(list2): merged_list.append(list2[j]) j += 1 return merged_list"},{"question":"import random from typing import List, Tuple, Any class KnapsackProblem: def __init__(self, items: List[Tuple[float, float, float]], weight_limit: float, volume_limit: float): Initialize the Knapsack Problem with items, weight limit, and volume limit. def initialize_population(self, population_size: int) -> List[List[int]]: Initialize the population as a list of individuals (solutions). def fitness(self, individual: List[int]) -> float: Calculate and return the fitness of the individual. def select_parents(self, population: List[List[int]]) -> Tuple[List[int], List[int]]: Select two parents from the population based on their fitness. def crossover(self, parent1: List[int], parent2: List[int]) -> List[int]: Perform crossover between two parents to produce a child. def mutate(self, individual: List[int], mutation_rate: float) -> List[int]: Mutate an individual based on the mutation rate. def genetic_algorithm_knapsack( problem: KnapsackProblem, population_size: int = 100, crossover_rate: float = 0.8, mutation_rate: float = 0.02, generations: int = 100 ) -> Any: Optimize the knapsack problem using a genetic algorithm.","solution":"import random class KnapsackProblem: def __init__(self, items, weight_limit, volume_limit): self.items = items self.weight_limit = weight_limit self.volume_limit = volume_limit def initialize_population(self, population_size): population = [] for _ in range(population_size): individual = [random.randint(0, 1) for _ in range(len(self.items))] population.append(individual) return population def fitness(self, individual): total_weight = total_value = total_volume = 0 for selected, item in zip(individual, self.items): if selected: total_weight += item[0] total_value += item[1] total_volume += item[2] if total_weight > self.weight_limit or total_volume > self.volume_limit: return 0 return total_value def select_parents(self, population): weights = [self.fitness(individual) for individual in population] total_fitness = sum(weights) if total_fitness == 0: return random.choice(population), random.choice(population) probabilities = [weight / total_fitness for weight in weights] parent1, parent2 = random.choices(population, weights=probabilities, k=2) return parent1, parent2 def crossover(self, parent1, parent2): point = random.randint(1, len(parent1) - 1) child = parent1[:point] + parent2[point:] return child def mutate(self, individual, mutation_rate): mutated_individual = individual[:] for i in range(len(individual)): if random.random() < mutation_rate: mutated_individual[i] = 1 - mutated_individual[i] return mutated_individual def genetic_algorithm_knapsack(problem, population_size=100, crossover_rate=0.8, mutation_rate=0.02, generations=100): population = problem.initialize_population(population_size) for _ in range(generations): new_population = [] for _ in range(population_size): parent1, parent2 = problem.select_parents(population) child = problem.crossover(parent1, parent2) if random.random() < crossover_rate else parent1 child = problem.mutate(child, mutation_rate) new_population.append(child) population = new_population[:] best_individual = max(population, key=problem.fitness) return best_individual"},{"question":"class MaxDataStructure: Class to implement a data structure that supports O(1) insertion of integers and retrieval of the maximum integer. Methods: - insert(item: int) -> None : Inserts an element into the data structure. - get_max() -> int : Retrieves the maximum element in the data structure. Example: >>> max_data_struct = MaxDataStructure() >>> max_data_struct.insert(1) >>> max_data_struct.insert(5) >>> max_data_struct.get_max() 5 >>> max_data_struct.insert(10) >>> max_data_struct.get_max() 10 def insert(self, item: int) -> None: pass def get_max(self) -> int: pass","solution":"class MaxDataStructure: def __init__(self): self.data = [] self.max_data = [] def insert(self, item: int) -> None: self.data.append(item) # keep max_data up to date if not self.max_data or item >= self.max_data[-1]: self.max_data.append(item) else: self.max_data.append(self.max_data[-1]) def get_max(self) -> int: if not self.data: raise ValueError(\\"data structure is empty\\") return self.max_data[-1]"},{"question":"from typing import List def shortest_path(grid: List[List[int]], tx: int, ty: int) -> int: Determine if there exists a path that the robot can take to reach from its starting point to the target cell given by coordinates (tx, ty). Return the length of the shortest path; otherwise, return -1. >>> grid = [ ... [0, 0, 1, 0], ... [0, 1, 0, 0], ... ['R', 0, 0, 0] ... ] >>> shortest_path(grid, 2, 3) 3 >>> grid = [ ... ['R', 0, 1], ... [1, 0, 1], ... [0, 0, 0] ... ] >>> shortest_path(grid, 2, 2) 4 >>> grid = [ ... ['R', 1, 1], ... [1, 0, 1], ... [1, 1, 1] ... ] >>> shortest_path(grid, 2, 2) -1","solution":"from collections import deque from typing import List, Tuple def shortest_path(grid: List[List[int]], tx: int, ty: int) -> int: # Find the starting position of the robot m, n = len(grid), len(grid[0]) start_x, start_y = -1, -1 for i in range(m): for j in range(n): if grid[i][j] == 'R': start_x, start_y = i, j break if start_x != -1: break # Directions for movement directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # BFS initialization queue = deque([(start_x, start_y, 0)]) # (x, y, distance) visited = set((start_x, start_y)) # BFS for shortest path while queue: x, y, dist = queue.popleft() # Check if we reached the target if x == tx and y == ty: return dist # Explore neighbors for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and (nx, ny) not in visited and grid[nx][ny] != 1: queue.append((nx, ny, dist + 1)) visited.add((nx, ny)) return -1"},{"question":"def calculate_check_digit(isbn: str) -> str: Calculate the check digit for the given 9-character ISBN-10. >>> calculate_check_digit('030640615') '2' >>> calculate_check_digit('156881111') 'X' pass def validate_isbn(isbn: str) -> bool: Validate the given 10-character ISBN-10. >>> validate_isbn('0306406152') True >>> validate_isbn('030640615X') False >>> validate_isbn('156881111X') True pass","solution":"def calculate_check_digit(isbn: str) -> str: Calculate the check digit for the given 9-character ISBN-10. Parameters: isbn (str): A string of 9 characters representing the first 9 digits of an ISBN-10. Returns: str: The check digit, which can be a number (0-9) or 'X'. if len(isbn) != 9 or not isbn.isdigit(): raise ValueError(\\"ISBN must be a 9-character string of digits.\\") total = sum((10 - i) * int(char) for i, char in enumerate(isbn)) remainder = total % 11 if remainder == 0: check_digit = '0' elif remainder == 1: check_digit = 'X' else: check_digit = str(11 - remainder) return check_digit def validate_isbn(isbn: str) -> bool: Validate the given 10-character ISBN-10. Parameters: isbn (str): A string of 10 characters representing a complete ISBN-10. Returns: bool: True if the ISBN-10 is valid, False otherwise. if len(isbn) != 10 or not (isbn[:-1].isdigit() and (isbn[-1].isdigit() or isbn[-1] == 'X')): return False check_digit = isbn[-1] calculated_check_digit = calculate_check_digit(isbn[:-1]) return check_digit == calculated_check_digit"},{"question":"def check_permission(permissions: Dict[str, Dict[str, List[str]]], user: str, target: str, operation: str) -> bool: Verifies whether a user has a particular permission on a file or directory. Parameters: - permissions: Dictionary describing permissions of files/directories. - user: The user name whose permissions are to be checked. - target: The file or directory name to check permissions on. - operation: The requested operation (e.g., \\"read\\", \\"write\\", or \\"execute\\"). Returns: - Boolean indicating whether the user has the required permission. >>> permissions = { ... \\"file1.txt\\": { ... \\"alice\\": [\\"read\\", \\"write\\"], ... \\"bob\\": [\\"read\\"], ... }, ... \\"docs\\": { ... \\"admin\\": [\\"read\\", \\"write\\", \\"execute\\"], ... \\"ubuntu\\": [\\"execute\\"], ... } ... } >>> check_permission(permissions, \\"alice\\", \\"file1.txt\\", \\"write\\") True >>> check_permission(permissions, \\"bob\\", \\"file1.txt\\", \\"write\\") False >>> check_permission(permissions, \\"charlie\\", \\"file1.txt\\", \\"read\\") False >>> check_permission(permissions, \\"alice\\", \\"unknown_file.txt\\", \\"read\\") False pass","solution":"def check_permission(permissions, user, target, operation): Verifies whether a user has a particular permission on a file or directory. Parameters: - permissions: Dictionary describing permissions of files/directories. - user: The user name whose permissions are to be checked. - target: The file or directory name to check permissions on. - operation: The requested operation (e.g., \\"read\\", \\"write\\", or \\"execute\\"). Returns: - Boolean indicating whether the user has the required permission. # Check if the target exists in the permission dictionary. if target in permissions: # Check if the user has specific permissions for the target. if user in permissions[target]: # Check if the requested operation is in the list of permissible operations for the user. if operation in permissions[target][user]: return True return False"},{"question":"from typing import List from math import sqrt, pow def dist_euclidean_2d(x1: float, y1: float, x2: float, y2: float) -> float: Calculate the Euclidean distance (2D) between two points. >>> abs(dist_euclidean_2d(0, 0, 3, 4) - 5) < 1e-6 True >>> abs(dist_euclidean_2d(1, 2, 1, 2) - 0) < 1e-6 True def dist_euclidean_3d(x1: float, y1: float, z1: float, x2: float, y2: float, z2: float) -> float: Calculate the Euclidean distance (3D) between two points. >>> abs(dist_euclidean_3d(0, 0, 0, 1, 2, 2) - 3) < 1e-6 True >>> abs(dist_euclidean_3d(1, 1, 1, 1, 1, 1) - 0) < 1e-6 True def dist_manhattan(x1: float, y1: float, x2: float, y2: float) -> float: Calculate the Manhattan distance between two points. >>> abs(dist_manhattan(1, 2, 4, 6) - 7) < 1e-6 True >>> abs(dist_manhattan(0, 0, 0, 0) - 0) < 1e-6 True def dist_chebyshev(x1: float, y1: float, x2: float, y2: float) -> float: Calculate the Chebyshev distance between two points. >>> abs(dist_chebyshev(1, 2, 4, 6) - 4) < 1e-6 True >>> abs(dist_chebyshev(0, 0, 7, -7) - 7) < 1e-6 True def dist_minkowski(x1: float, y1: float, x2: float, y2: float, p: float) -> float: Calculate the Minkowski distance between two points. >>> abs(dist_minkowski(1, 2, 4, 6, 3) - 4.497941445275415) < 1e-6 True >>> abs(dist_minkowski(0, 0, 8, 6, 2) - 10) < 1e-6 True # Tests assert abs(dist_euclidean_2d(0, 0, 3, 4) - 5) < 1e-6 assert abs(dist_euclidean_2d(1, 2, 1, 2) - 0) < 1e-6 assert abs(dist_euclidean_3d(0, 0, 0, 1, 2, 2) - 3) < 1e-6 assert abs(dist_euclidean_3d(1, 1, 1, 1, 1, 1) - 0) < 1e-6 assert abs(dist_manhattan(1, 2, 4, 6) - 7) < 1e-6 assert abs(dist_manhattan(0, 0, 0, 0) - 0) < 1e-6 assert abs(dist_chebyshev(1, 2, 4, 6) - 4) < 1e-6 assert abs(dist_chebyshev(0, 0, 7, -7) - 7) < 1e-6 assert abs(dist_minkowski(1, 2, 4, 6, 3) - 4.497941445275415) < 1e-6 assert abs(dist_minkowski(0, 0, 8, 6, 2) - 10) < 1e-6","solution":"from math import sqrt, pow def dist_euclidean_2d(x1, y1, x2, y2): if not all(isinstance(i, (int, float)) for i in [x1, y1, x2, y2]): raise ValueError(\\"dist_euclidean_2d() only accepts numerical values\\") return sqrt((x2 - x1)**2 + (y2 - y1)**2) def dist_euclidean_3d(x1, y1, z1, x2, y2, z2): if not all(isinstance(i, (int, float)) for i in [x1, y1, z1, x2, y2, z2]): raise ValueError(\\"dist_euclidean_3d() only accepts numerical values\\") return sqrt((x2 - x1)**2 + (y2 - y1)**2 + (z2 - z1)**2) def dist_manhattan(x1, y1, x2, y2): if not all(isinstance(i, (int, float)) for i in [x1, y1, x2, y2]): raise ValueError(\\"dist_manhattan() only accepts numerical values\\") return abs(x2 - x1) + abs(y2 - y1) def dist_chebyshev(x1, y1, x2, y2): if not all(isinstance(i, (int, float)) for i in [x1, y1, x2, y2]): raise ValueError(\\"dist_chebyshev() only accepts numerical values\\") return max(abs(x2 - x1), abs(y2 - y1)) def dist_minkowski(x1, y1, x2, y2, p): if not all(isinstance(i, (int, float)) for i in [x1, y1, x2, y2, p]): raise ValueError(\\"dist_minkowski() only accepts numerical values\\") if p <= 0: raise ValueError(\\"The order p must be a positive number\\") return pow(pow(abs(x2 - x1), p) + pow(abs(y2 - y1), p), 1/p)"},{"question":"from typing import List def unique_subsets(nums: List[int]) -> List[List[int]]: Generate all unique subsets of a given list of integers in lexicographical order without duplicates. Each subset should be sorted internally. >>> unique_subsets([1, 2, 2]) [[], [1], [1, 2], [1, 2, 2], [2], [2, 2]] >>> unique_subsets([-1, 0, 1]) [[], [-1], [-1, 0], [-1, 0, 1], [-1, 1], [0], [0, 1], [1]] # Your code here pass","solution":"from typing import List def unique_subsets(nums: List[int]) -> List[List[int]]: Given a list of integers, return all possible unique subsets in lexicographical order. Each subset should be sorted internally. nums.sort() result = [] subset = [] def backtrack(start): result.append(subset[:]) # Add a copy of subset to result for i in range(start, len(nums)): if i > start and nums[i] == nums[i-1]: continue # skip duplicates subset.append(nums[i]) backtrack(i + 1) subset.pop() # remove last element for backtracking backtrack(0) return result"},{"question":"def unique_paths(m: int, n: int) -> int: Returns the number of unique paths from the top-left corner to the bottom-right corner of a m x n grid. >>> unique_paths(3, 7) 28 >>> unique_paths(3, 2) 3 >>> unique_paths(7, 3) 28 >>> unique_paths(1, 1) 1","solution":"def unique_paths(m: int, n: int) -> int: Returns the number of unique paths from the top-left corner to the bottom-right corner of a m x n grid. if m == 1 or n == 1: return 1 # Create a 2D array 'dp' with m rows and n columns dp = [[1] * n for _ in range(m)] # Iterate through the grid starting from cell (1,1) for i in range(1, m): for j in range(1, n): # The number of ways to reach cell (i, j) is equal to the sum of the number of ways to reach # cell (i-1, j) and the number of ways to reach cell (i, j-1) dp[i][j] = dp[i-1][j] + dp[i][j-1] return dp[m-1][n-1]"},{"question":"import os def process_log_file(filepath: str, chunk_size: int) -> dict: Reads a log file in chunks and counts the occurrences of each IP address. Parameters: filepath (str): The path to the log file. chunk_size (int): The size (in bytes) of each chunk to be read. Returns: dict: A dictionary where the keys are IP addresses and the values are the counts of occurrences. Example: >>> process_log_file('path_to_log_file.log', 1024) { '192.168.1.1': 2, '192.168.1.2': 1, ... } # Unit Tests def create_temp_log_file(content, filename=\\"temp_log_file.log\\"): with open(filename, \\"w\\") as f: f.write(content) return filename def delete_temp_log_file(filename=\\"temp_log_file.log\\"): if os.path.exists(filename): os.remove(filename) def test_process_log_file_single_chunk(): log_content = 192.168.1.1 - User1 [01/Jan/2021:12:00:00 -0700] \\"GET /index.html HTTP/1.1\\" 200 1234 192.168.1.2 - User2 [01/Jan/2021:12:01:00 -0700] \\"POST /submit HTTP/1.1\\" 200 5678 192.168.1.1 - User1 [01/Jan/2021:12:02:00 -0700] \\"GET /about.html HTTP/1.1\\" 200 2345 filepath = create_temp_log_file(log_content) result = process_log_file(filepath, 1024) delete_temp_log_file(filepath) assert result == { '192.168.1.1': 2, '192.168.1.2': 1, } def test_process_log_file_multiple_chunks(): log_content = 192.168.1.1 - User1 [01/Jan/2021:12:00:00 -0700] \\"GET /index.html HTTP/1.1\\" 200 1234 192.168.1.2 - User2 [01/Jan/2021:12:01:00 -0700] \\"POST /submit HTTP/1.1\\" 200 5678 192.168.1.1 - User1 [01/Jan/2021:12:02:00 -0700] \\"GET /about.html HTTP/1.1\\" 200 2345 192.168.1.3 - User3 [01/Jan/2021:12:03:00 -0700] \\"GET /contact.html HTTP/1.1\\" 200 4321 192.168.1.1 - User1 [01/Jan/2021:12:04:00 -0700] \\"GET /home.html HTTP/1.1\\" 200 3456 filepath = create_temp_log_file(log_content) result = process_log_file(filepath, 50) delete_temp_log_file(filepath) assert result == { '192.168.1.1': 3, '192.168.1.2': 1, '192.168.1.3': 1, } def test_process_log_file_incomplete_line(): log_content = 192.168.1.1 - User1 [01/Jan/2021:12:00:00 -0700] \\"GET /index.html HTTP/1.1\\" 200 1234 192.168.1.2 - User2 [01/Jan/2021:12:01:00 -0700] \\"POST /submit HTTP/1.1\\" 200 5678 192.168.1.1 - User1 [01/Jan/2021:12:02:00 -0700] \\"GET /about.html HTTP/1.1\\" 200 2345 192.168.1.3 filepath = create_temp_log_file(log_content) result = process_log_file(filepath, 50) delete_temp_log_file(filepath) assert result == { '192.168.1.1': 2, '192.168.1.2': 1, '192.168.1.3': 1, } def test_process_log_file_empty_file(): log_content = \\"\\" filepath = create_temp_log_file(log_content) result = process_log_file(filepath, 50) delete_temp_log_file(filepath) assert result == {} def test_process_log_file_single_line(): log_content = 192.168.1.1 - User1 [01/Jan/2021:12:00:00 -0700] \\"GET /index.html HTTP/1.1\\" 200 1234 filepath = create_temp_log_file(log_content) result = process_log_file(filepath, 50) delete_temp_log_file(filepath) assert result == {'192.168.1.1': 1}","solution":"def process_log_file(filepath, chunk_size): Reads a log file in chunks and counts the occurrences of each IP address. Parameters: filepath (str): The path to the log file. chunk_size (int): The size (in bytes) of each chunk to be read. Returns: dict: A dictionary where the keys are IP addresses and the values are the counts of occurrences. ip_counts = {} buffer = \\"\\" with open(filepath, \\"r\\") as file: while True: chunk = file.read(chunk_size) if not chunk: break lines = (buffer + chunk).splitlines() # If the last character is not a newline, then the last line is incomplete if chunk and chunk[-1] != 'n': buffer = lines.pop() else: buffer = \\"\\" for line in lines: if line: ip_address = line.split(\\" \\")[0] if ip_address in ip_counts: ip_counts[ip_address] += 1 else: ip_counts[ip_address] = 1 # Process any remaining buffer if exists if buffer: ip_address = buffer.split(\\" \\")[0] if ip_address in ip_counts: ip_counts[ip_address] += 1 else: ip_counts[ip_address] = 1 return ip_counts"},{"question":"def notify_milestones(step_data: dict, milestones: list) -> dict: Determines which milestones have been hit for each user on the most recent day. Parameters: step_data (dict): A dictionary where keys are user IDs (strings) and values are lists of daily step counts (integers). milestones (list): A list of integers representing the step count milestones. Returns: dict: A dictionary where each key is a user ID and each value is a list of milestones achieved on the most recent day. Example usage: >>> step_data = { ... \\"user1\\": [1000, 2000, 3000], ... \\"user2\\": [500, 1500, 2500], ... \\"user3\\": [6000, 7000, 8000] ... } >>> milestones = [1000, 5000, 10000] >>> notify_milestones(step_data, milestones) { \\"user1\\": [1000], \\"user2\\": [1000], \\"user3\\": [1000, 5000] } from solution import notify_milestones def test_sample_case(): step_data = { \\"user1\\": [1000, 2000, 3000], \\"user2\\": [500, 1500, 2500], \\"user3\\": [6000, 7000, 8000] } milestones = [1000, 5000, 10000] expected_output = { \\"user1\\": [1000], \\"user2\\": [1000], \\"user3\\": [1000, 5000] } assert notify_milestones(step_data, milestones) == expected_output def test_empty_step_data(): step_data = {} milestones = [1000, 5000, 10000] expected_output = {} assert notify_milestones(step_data, milestones) == expected_output def test_no_milestones_met(): step_data = { \\"user1\\": [200, 300, 400], \\"user2\\": [600, 700, 800] } milestones = [1000, 5000, 10000] expected_output = { \\"user1\\": [], \\"user2\\": [] } assert notify_milestones(step_data, milestones) == expected_output def test_all_milestones_met(): step_data = { \\"user1\\": [10000, 20000, 30000], \\"user2\\": [7000, 8000, 9000] } milestones = [1000, 5000, 10000] expected_output = { \\"user1\\": [1000, 5000, 10000], \\"user2\\": [1000, 5000] } assert notify_milestones(step_data, milestones) == expected_output def test_compare_latest_step(): step_data = { \\"user1\\": [500, 1500, 2500], \\"user2\\": [3000, 3500, 6000] } milestones = [1000, 2000, 5000] expected_output = { \\"user1\\": [1000, 2000], \\"user2\\": [1000, 2000, 5000] } assert notify_milestones(step_data, milestones) == expected_output","solution":"def notify_milestones(step_data: dict, milestones: list) -> dict: Determines which milestones have been hit for each user on the most recent day. Parameters: step_data (dict): A dictionary where keys are user IDs (strings) and values are lists of daily step counts (integers). milestones (list): A list of integers representing the step count milestones. Returns: dict: A dictionary where each key is a user ID and each value is a list of milestones achieved on the most recent day. result = {} for user_id, steps in step_data.items(): latest_steps = steps[-1] # Get the most recent step count user_milestones = [] for milestone in milestones: if milestone <= latest_steps: user_milestones.append(milestone) result[user_id] = user_milestones return result"},{"question":"def find_central_element(data: list) -> int or tuple[int, int]: Identify and return the central element(s) of a list. If the list has an odd number of elements, return the single central element. If the list has an even number of elements, return the two central elements. >>> find_central_element([1, 2, 3, 4, 5]) 3 >>> find_central_element([10, 20, 30, 40, 50, 60]) (30, 40) >>> find_central_element(['a', 'b', 'c', 'd', 'e']) 'c' >>> find_central_element(['alpha', 'beta', 'gamma']) 'beta' >>> find_central_element([7]) 7 >>> find_central_element([5, 10]) (5, 10)","solution":"def find_central_element(data): Returns the central element(s) of a sorted list. If the list has an odd number of elements, return the single central element. If the list has an even number of elements, return the two central elements as a tuple. n = len(data) mid = n // 2 if n % 2 == 1: return data[mid] else: return (data[mid - 1], data[mid])"},{"question":"from typing import List def trap_rain_water(heights: List[int]) -> int: Given a list of integers representing the height of buildings in a skyline, determine the volume of water that can be trapped after raining. Parameters: ---------- heights: List[int] - List of non-negative integers representing the heights of the buildings. Returns: ------- int - The total volume of water that can be trapped. Constraints: ----------- - 0 <= len(heights) <= 1000 - 0 <= heights[i] <= 1000 >>> trap_rain_water([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) == 6 >>> trap_rain_water([4, 2, 0, 3, 2, 5]) == 9 >>> trap_rain_water([]) == 0 >>> trap_rain_water([0, 0, 0, 0]) == 0 >>> trap_rain_water([1, 1, 1, 1]) == 0 >>> trap_rain_water([5]) == 0 >>> trap_rain_water([5, 4]) == 0 >>> trap_rain_water([1, 2, 3, 4, 5, 6]) == 0 >>> trap_rain_water([6, 5, 4, 3, 2, 1]) == 0 >>> trap_rain_water([5, 0, 6, 2, 3, 8, 1, 0, 3, 1]) == 17","solution":"from typing import List def trap_rain_water(heights: List[int]) -> int: if not heights: return 0 n = len(heights) # Initialize arrays to store the maximum heights to the left and right of each position left_max = [0] * n right_max = [0] * n # Fill left_max array left_max[0] = heights[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], heights[i]) # Fill right_max array right_max[n - 1] = heights[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], heights[i]) # Calculate the trapped water total_water = 0 for i in range(n): total_water += min(left_max[i], right_max[i]) - heights[i] return total_water"},{"question":"def binomial_coefficient(n: int, k: int) -> int: Calculate the binomial coefficient 'n choose k' for given n and k. The binomial coefficient is the number of ways to choose k elements out of n, without considering the order. It is defined as: C(n, k) = n! / (k! * (n - k)!) The function should raise a ValueError if the input constraints are violated (0 ≤ k ≤ n). >>> binomial_coefficient(5, 2) 10 >>> binomial_coefficient(6, 3) 20 >>> binomial_coefficient(10, 5) 252 pass","solution":"def binomial_coefficient(n: int, k: int) -> int: if k < 0 or k > n: raise ValueError(\\"k must be in the range [0, n]\\") if k == 0 or k == n: return 1 k = min(k, n - k) # Optimize the computation by choosing the smaller k c = 1 for i in range(k): c = c * (n - i) // (i + 1) return c"},{"question":"def insert_text(original: str, text: str, index: int) -> str: Inserts the given text into the original string at the specified index. >>> insert_text(\\"hello world\\", \\"beautiful \\", 6) \\"hello beautiful world\\" >>> insert_text(\\"abc\\", \\"xyz\\", 10) \\"abcxyz\\" >>> insert_text(\\"abc\\", \\"xyz\\", -1) \\"abxyzc\\" def reverse_substring(text: str, start: int, end: int) -> str: Reverses the portion of the text from start index to end index (inclusive). >>> reverse_substring(\\"hello world\\", 0, 4) \\"olleh world\\" >>> reverse_substring(\\"abcde\\", 1, 3) \\"adcbe\\" >>> reverse_substring(\\"abc\\", 0, 0) \\"abc\\" >>> reverse_substring(\\"one\\", 0, 2) \\"eno\\"","solution":"def insert_text(original: str, text: str, index: int) -> str: Inserts the given text into the original string at the specified index. if index < 0: index = len(original) + index if index > len(original): index = len(original) return original[:index] + text + original[index:] def reverse_substring(text: str, start: int, end: int) -> str: Reverses the portion of the text from start index to end index (inclusive). if start < 0: start = 0 if end >= len(text): end = len(text) - 1 if start > end: return text return text[:start] + text[start:end+1][::-1] + text[end+1:]"},{"question":"class JoggingTracker: A class used to track jogging routes and total distance run. Methods ------- add_route(name: str, distance: float) -> None Adds a new jogging route with the given name and distance. remove_route(name: str) -> None Removes an existing jogging route by name. get_total_distance() -> float Returns the total distance run across all routes. def test_add_route(): tracker = JoggingTracker() tracker.add_route(\\"Morning Run\\", 5.2) assert tracker.get_total_distance() == 5.2 def test_add_multiple_routes(): tracker = JoggingTracker() tracker.add_route(\\"Morning Run\\", 5.2) tracker.add_route(\\"Evening Run\\", 3.8) assert tracker.get_total_distance() == 9.0 def test_remove_route(): tracker = JoggingTracker() tracker.add_route(\\"Morning Run\\", 5.2) tracker.remove_route(\\"Morning Run\\") assert tracker.get_total_distance() == 0.0 def test_remove_nonexistent_route(): tracker = JoggingTracker() tracker.add_route(\\"Morning Run\\", 5.2) tracker.remove_route(\\"Evening Run\\") # Should handle gracefully assert tracker.get_total_distance() == 5.2 def test_remove_one_of_multiple_routes(): tracker = JoggingTracker() tracker.add_route(\\"Morning Run\\", 5.2) tracker.add_route(\\"Evening Run\\", 3.8) tracker.remove_route(\\"Morning Run\\") assert tracker.get_total_distance() == 3.8 def test_edge_case_zero_distance(): tracker = JoggingTracker() tracker.add_route(\\"Morning Walk\\", 0.0) assert tracker.get_total_distance() == 0.0 def test_negative_distance(): tracker = JoggingTracker() try: tracker.add_route(\\"Morning Run\\", -5.0) except ValueError as e: assert str(e) == \\"Distance cannot be negative\\" def test_duplicate_route_names(): tracker = JoggingTracker() tracker.add_route(\\"Morning Run\\", 5.2) tracker.add_route(\\"Morning Run\\", 4.3) # This should overwrite the previous distance assert tracker.get_total_distance() == 4.3 def test_no_routes(): tracker = JoggingTracker() assert tracker.get_total_distance() == 0.0","solution":"class JoggingTracker: A class used to track jogging routes and total distance run. def __init__(self): self.routes = {} def add_route(self, name: str, distance: float) -> None: Adds a new jogging route with the given name and distance. if distance < 0: raise ValueError(\\"Distance cannot be negative\\") self.routes[name] = distance def remove_route(self, name: str) -> None: Removes an existing jogging route by name. if name in self.routes: del self.routes[name] def get_total_distance(self) -> float: Returns the total distance run across all routes. return sum(self.routes.values())"},{"question":"def longest_common_subsequence(seq1: str, seq2: str) -> str: Returns the longest common subsequence (LCS) of two given DNA sequences. >>> longest_common_subsequence(\\"ACGT\\", \\"ACGT\\") 'ACGT' >>> longest_common_subsequence(\\"ACCGGTCGAGTGCGCGGAAGCCGGCCGAA\\", \\"GTCGTTCGGAATGCCGTTGCTCTGTAAA\\") 'GTCGTCGGAAGCCGGCCGAA' >>> longest_common_subsequence(\\"AGGTAB\\", \\"GXTXAYB\\") 'GTAB' >>> longest_common_subsequence(\\"ABCBDAB\\", \\"BDCAB\\") 'BCAB'","solution":"def longest_common_subsequence(seq1: str, seq2: str) -> str: Returns the longest common subsequence (LCS) of two given DNA sequences. m, n = len(seq1), len(seq2) # Create a 2D array to store lengths of longest common subsequence dp = [[0] * (n + 1) for _ in range(m + 1)] # Building the dp array for i in range(m): for j in range(n): if seq1[i] == seq2[j]: dp[i + 1][j + 1] = dp[i][j] + 1 else: dp[i + 1][j + 1] = max(dp[i + 1][j], dp[i][j + 1]) # Reconstructing the LCS from the dp array lcs = [] x, y = m, n while x > 0 and y > 0: if dp[x][y] == dp[x - 1][y]: x -= 1 elif dp[x][y] == dp[x][y - 1]: y -= 1 else: lcs.append(seq1[x - 1]) x -= 1 y -= 1 return ''.join(reversed(lcs))"},{"question":"from typing import List def largest_price_drop(prices: List[int]) -> int: Determines the largest drop in stock prices over a period of time. The largest drop is defined as the maximum difference between a peak price and any subsequent lower price. The peak must occur before the low point. >>> largest_price_drop([100, 90, 80, 70, 60, 50]) == 50 >>> largest_price_drop([10, 20, 30, 5, 15, 25, 35]) == 25 >>> largest_price_drop([150, 180, 90, 60, 120, 40, 30]) == 150 def test_largest_price_drop_decreasing_prices(): assert largest_price_drop([100, 90, 80, 70, 60, 50]) == 50 def test_largest_price_drop_mixed_prices(): assert largest_price_drop([10, 20, 30, 5, 15, 25, 35]) == 25 def test_largest_price_drop_varying_prices(): assert largest_price_drop([150, 180, 90, 60, 120, 40, 30]) == 150 def test_largest_price_drop_single_day(): assert largest_price_drop([1000]) == 0 def test_largest_price_drop_small_prices(): assert largest_price_drop([1, 2, 1]) == 1 def test_largest_price_drop_no_drop(): assert largest_price_drop([1, 2, 3, 4, 5]) == 0 def test_largest_price_drop_largest_at_begginging(): assert largest_price_drop([50, 10, 20, 30, 20, 10]) == 40 def test_largest_price_drop_very_large_numbers(): assert largest_price_drop([1000000, 1]) == 999999","solution":"from typing import List def largest_price_drop(prices: List[int]) -> int: max_price = prices[0] largest_drop = 0 for price in prices: if price > max_price: max_price = price drop = max_price - price if drop > largest_drop: largest_drop = drop return largest_drop"},{"question":"class Player: def __init__(self, start_x: int, start_y: int): Initializes the player's position. >>> player = Player(0, 0) >>> player.get_position() == (0, 0) True pass def move(self, direction: str) -> tuple: Updates the player's position based on the given direction. Ensure the player does not move outside the map boundaries. >>> player = Player(1, 1) >>> player.move('U') >>> player.get_position() == (0, 1) True pass def get_position(self) -> tuple: Returns the current position of the player. >>> player = Player(3, 3) >>> player.get_position() == (3, 3) True pass def check_goal(self, goal_x: int, goal_y: int) -> bool: Checks if the player has reached the goal position. >>> player = Player(0, 0) >>> player.check_goal(0, 0) True >>> player.check_goal(1, 1) False pass # Example usage: player = Player(0, 0) player.move('R') player.move('D') player.move('D') print(player.get_position()) # Example Output: (1, 2) goal_reached = player.check_goal(1, 2) print(goal_reached) # Example Output: True","solution":"class Player: def __init__(self, start_x: int, start_y: int): self.position = (start_x, start_y) def move(self, direction: str) -> tuple: x, y = self.position if direction == 'U' and x > 0: x -= 1 elif direction == 'D' and x < 9: x += 1 elif direction == 'L' and y > 0: y -= 1 elif direction == 'R' and y < 9: y += 1 self.position = (x, y) return self.position def get_position(self) -> tuple: return self.position def check_goal(self, goal_x: int, goal_y: int) -> bool: return self.position == (goal_x, goal_y)"},{"question":"from typing import List, Dict def topological_sort(graph: Dict[int, List[int]]) -> List[int]: Perform a topological sort on a given directed acyclic graph (DAG) represented using an adjacency list. Parameters: graph (Dict[int, List[int]]): The adjacency list of the graph. Returns: List[int]: A list of nodes in topologically sorted order. Example usage: >>> graph = { ... 5: [2, 0], ... 4: [0, 1], ... 3: [1], ... 2: [3], ... 1: [], ... 0: [], ... } >>> topological_sort(graph) [4, 5, 2, 3, 1, 0] # Or any other correct topological ordering >>> graph = { ... 1: [], ... 2: [1], ... 3: [2], ... 4: [3], ... 5: [4] ... } >>> topological_sort(graph) [5, 4, 3, 2, 1]","solution":"from typing import List, Dict def topological_sort(graph: Dict[int, List[int]]) -> List[int]: Perform a topological sort on a given directed acyclic graph (DAG) represented using an adjacency list. Parameters: graph (Dict[int, List[int]]): The adjacency list of the graph. Returns: List[int]: A list of nodes in topologically sorted order. from collections import defaultdict, deque # Container for in-degrees of each node in_degree = defaultdict(int) for node in graph: if node not in in_degree: in_degree[node] = 0 for neighbor in graph[node]: in_degree[neighbor] += 1 # Queue to maintain nodes with zero in-degree zero_in_degree_queue = deque([node for node in in_degree if in_degree[node] == 0]) topological_order = [] while zero_in_degree_queue: current_node = zero_in_degree_queue.popleft() topological_order.append(current_node) # For all the neighbors of the current node for neighbor in graph[current_node]: in_degree[neighbor] -= 1 # If in-degree becomes zero, add it to the queue if in_degree[neighbor] == 0: zero_in_degree_queue.append(neighbor) # If topological order includes all the nodes, return it if len(topological_order) == len(graph): return topological_order else: # The graph was not a DAG or did not include all nodes raise ValueError(\\"Graph has cycles or is not a valid DAG\\") # Example usage: # graph = { # 5: [2, 0], # 4: [0, 1], # 3: [1], # 2: [3], # 1: [], # 0: [], # } # print(topological_sort(graph)) # # Expected Output: [4, 5, 2, 3, 1, 0] or [5, 4, 2, 3, 1, 0] or any other correct topological ordering"},{"question":"import re from collections import defaultdict def word_frequencies(sentences: list) -> dict: Calculate the frequency of words in a list of sentences. Args: sentences (list): A list of sentences (strings). Returns: dict: A dictionary where keys are words (case-insensitive) and values are word counts. >>> word_frequencies([\\"Hello world\\", \\"Hello again, world!\\"]) {'hello': 2, 'world': 2, 'again': 1} >>> word_frequencies([\\"The quick brown fox\\", \\"jumps over the lazy dog\\"]) {'the': 2, 'quick': 1, 'brown': 1, 'fox': 1, 'jumps': 1, 'over': 1, 'lazy': 1, 'dog': 1} ... def most_common_word(frequencies: dict) -> str: Finds the most common word in a dictionary of word frequencies. Args: frequencies (dict): A dictionary of word frequencies. Returns: str: The most common word. If there's a tie, the lexicographically smallest word is returned. >>> most_common_word({'hello': 2, 'world': 2, 'again': 1}) 'hello' >>> most_common_word({'the': 2, 'quick': 1, 'brown': 1, 'fox': 1, 'jumps': 1, 'over': 1, 'lazy': 1, 'dog': 1}) 'the' ... import pytest def test_word_frequencies_basic(): assert word_frequencies([\\"Hello world\\", \\"Hello again, world!\\"]) == {'hello': 2, 'world': 2, 'again': 1} def test_word_frequencies_mixed_case(): assert word_frequencies([\\"The quick brown fox\\", \\"jumps over the lazy dog\\"]) == { 'the': 2, 'quick': 1, 'brown': 1, 'fox': 1, 'jumps': 1, 'over': 1, 'lazy': 1, 'dog': 1 } def test_word_frequencies_empty_list(): assert word_frequencies([]) == {} def test_word_frequencies_special_characters(): assert word_frequencies([\\"Hello, world!\\", \\"It's a nice day.\\"]) == {'hello': 1, 'world': 1, 'it': 1, 's': 1, 'a': 1, 'nice': 1, 'day': 1} def test_most_common_word_basic(): assert most_common_word({'hello': 2, 'world': 2, 'again': 1}) == 'hello' def test_most_common_word_single(): assert most_common_word({'the': 2, 'quick': 1, 'brown': 1, 'fox': 1, 'jumps': 1, 'over': 1, 'lazy': 1, 'dog': 1}) == 'the' def test_most_common_word_empty(): assert most_common_word({}) == '' def test_most_common_word_tie(): assert most_common_word({'a': 3, 'b': 3, 'c': 2}) == 'a' pytest.main()","solution":"import re from collections import defaultdict def word_frequencies(sentences): Calculate the frequency of words in a list of sentences. Args: sentences (list): A list of sentences (strings). Returns: dict: A dictionary where keys are words (case-insensitive) and values are word counts. frequency = defaultdict(int) for sentence in sentences: words = re.findall(r'b[a-zA-Z]+b', sentence.lower()) for word in words: frequency[word] += 1 return frequency def most_common_word(frequencies): Finds the most common word in a dictionary of word frequencies. Args: frequencies (dict): A dictionary of word frequencies. Returns: str: The most common word. If there's a tie, the lexicographically smallest word is returned. if not frequencies: return '' most_common = max(frequencies.items(), key=lambda item: (item[1], -ord(item[0][0]))) return most_common[0]"},{"question":"import math class TruckTracker: def __init__(self): self.truck_locations = {} def update_location(self, truck_id: str, latitude: float, longitude: float) -> None: Updates the location of the truck identified by \`truck_id\`. if not (-90 <= latitude <= 90) or not (-180 <= longitude <= 180): raise ValueError(\\"Invalid latitude or longitude values.\\") self.truck_locations[truck_id] = (latitude, longitude) def get_location(self, truck_id: str) -> tuple: Returns the current location (latitude, longitude) of the truck identified by \`truck_id\`. if truck_id not in self.truck_locations: raise ValueError(\\"Truck ID not found.\\") return self.truck_locations[truck_id] def get_distance_between(self, truck_id1: str, truck_id2: str) -> float: Calculates the distance between two trucks identified by \`truck_id1\` and \`truck_id2\` using the Haversine formula. if truck_id1 not in self.truck_locations or truck_id2 not in self.truck_locations: raise ValueError(\\"One or both truck IDs not found.\\") def haversine(lat1, lon1, lat2, lon2): R = 6371 # Earth radius in kilometers phi1 = math.radians(lat1) phi2 = math.radians(lat2) delta_phi = math.radians(lat2 - lat1) delta_lambda = math.radians(lon2 - lon1) a = math.sin(delta_phi / 2) ** 2 + math.cos(phi1) * math.cos(phi2) * math.sin(delta_lambda / 2) ** 2 c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a)) return R * c lat1, lon1 = self.truck_locations[truck_id1] lat2, lon2 = self.truck_locations[truck_id2] return haversine(lat1, lon1, lat2, lon2) # Examples: # tracker = TruckTracker() # tracker.update_location(\\"truck1\\", 51.5074, -0.1278) # print(tracker.get_location(\\"truck1\\")) # Output: (51.5074, -0.1278) # print(tracker.get_distance_between(\\"truck1\\", \\"truck2\\")) # Output: raises ValueError if truck2 is not defined import pytest def test_update_location(): tracker = TruckTracker() tracker.update_location(\\"truck1\\", 51.5074, -0.1278) assert tracker.get_location(\\"truck1\\") == (51.5074, -0.1278) def test_invalid_latitude_longitude(): tracker = TruckTracker() with pytest.raises(ValueError, match=\\"Invalid latitude or longitude values.\\"): tracker.update_location(\\"truck1\\", 100.0, -0.1278) def test_get_location_with_non_existent_truck(): tracker = TruckTracker() with pytest.raises(ValueError, match=\\"Truck ID not found.\\"): tracker.get_location(\\"truck1\\") def test_get_distance_between(): tracker = TruckTracker() tracker.update_location(\\"truck1\\", 51.5074, -0.1278) tracker.update_location(\\"truck2\\", 48.8566, 2.3522) distance = tracker.get_distance_between(\\"truck1\\", \\"truck2\\") assert math.isclose(distance, 343.456, rel_tol=0.01) def test_get_distance_non_existent_truck(): tracker = TruckTracker() tracker.update_location(\\"truck1\\", 51.5074, -0.1278) with pytest.raises(ValueError, match=\\"One or both truck IDs not found.\\"): tracker.get_distance_between(\\"truck1\\", \\"truck3\\")","solution":"import math class TruckTracker: def __init__(self): self.truck_locations = {} def update_location(self, truck_id: str, latitude: float, longitude: float) -> None: Updates the location of the truck identified by \`truck_id\`. if not (-90 <= latitude <= 90) or not (-180 <= longitude <= 180): raise ValueError(\\"Invalid latitude or longitude values.\\") self.truck_locations[truck_id] = (latitude, longitude) def get_location(self, truck_id: str) -> tuple: Returns the current location (latitude, longitude) of the truck identified by \`truck_id\`. if truck_id not in self.truck_locations: raise ValueError(\\"Truck ID not found.\\") return self.truck_locations[truck_id] def get_distance_between(self, truck_id1: str, truck_id2: str) -> float: Calculates the distance between two trucks identified by \`truck_id1\` and \`truck_id2\` using the Haversine formula. if truck_id1 not in self.truck_locations or truck_id2 not in self.truck_locations: raise ValueError(\\"One or both truck IDs not found.\\") def haversine(lat1, lon1, lat2, lon2): R = 6371 # Earth radius in kilometers phi1 = math.radians(lat1) phi2 = math.radians(lat2) delta_phi = math.radians(lat2 - lat1) delta_lambda = math.radians(lon2 - lon1) a = math.sin(delta_phi / 2) ** 2 + math.cos(phi1) * math.cos(phi2) * math.sin(delta_lambda / 2) ** 2 c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a)) return R * c lat1, lon1 = self.truck_locations[truck_id1] lat2, lon2 = self.truck_locations[truck_id2] return haversine(lat1, lon1, lat2, lon2)"},{"question":"# Rolling Average Implement the function \`rolling_average\` that calculates the rolling average over a specified window size for a given list of numbers representing a time-series dataset. from typing import List def rolling_average(data: List[float], window_size: int) -> List[float]: if not data or window_size > len(data): return [] averages = [] for i in range(len(data) - window_size + 1): window = data[i:i + window_size] averages.append(sum(window) / window_size) return averages # Example test cases data = [1.0, 2.0, 3.0, 4.0, 5.0] window_size = 3 assert rolling_average(data, window_size) == [2.0, 3.0, 4.0] data = [10, 20, 30, 40, 50, 60] window_size = 2 assert rolling_average(data, window_size) == [15.0, 25.0, 35.0, 45.0, 55.0] # Edge case: window size larger than data length data = [1.0, 2.0] window_size = 3 assert rolling_average(data, window_size) == [] # Edge case: empty data data = [] window_size = 2 assert rolling_average(data, window_size) == [] # Window size of one data = [3.0, 5.0, 7.0] window_size = 1 assert rolling_average(data, window_size) == [3.0, 5.0, 7.0] # With negative numbers data = [-1.0, -2.0, -3.0, -4.0, -5.0] window_size = 2 assert rolling_average(data, window_size) == [-1.5, -2.5, -3.5, -4.5] # Float precision data = [1.5, 3.0, 4.5, 6.0, 7.5] window_size = 2 assert rolling_average(data, window_size) == [2.25, 3.75, 5.25, 6.75]","solution":"from typing import List def rolling_average(data: List[float], window_size: int) -> List[float]: if not data or window_size > len(data): return [] averages = [] for i in range(len(data) - window_size + 1): window = data[i:i + window_size] averages.append(sum(window) / window_size) return averages"},{"question":"import pandas as pd def create_feature_matrix(file_path: str, n_lags: int, output_path: str) -> None: Reads a CSV file and generates a matrix with lagged observations as features. Parameters: file_path (str): Path to the CSV file containing the dataset. n_lags (int): Number of lagged observations to include as features. output_path (str): Path to save the generated feature matrix CSV file. Returns: None Example usage: >>> create_feature_matrix('data.csv', 3, 'output.csv')","solution":"import pandas as pd def create_feature_matrix(file_path: str, n_lags: int, output_path: str) -> None: Reads a CSV file and generates a matrix with lagged observations as features. Parameters: file_path (str): Path to the CSV file containing the dataset. n_lags (int): Number of lagged observations to include as features. output_path (str): Path to save the generated feature matrix CSV file. Returns: None try: # Read the CSV file df = pd.read_csv(file_path) # Generate lagged features for i in range(1, n_lags + 1): df[f'lag_{i}'] = df['value'].shift(i) # Save the resulting dataframe to the specified output path df.to_csv(output_path, index=False) except Exception as e: print(f\\"An error occurred: {e}\\")"},{"question":"def tokenize(review: str) -> list: Convert a string into a list of words in lowercase. >>> tokenize(\\"I loved this product! It was fantastic.\\") ['i', 'loved', 'this', 'product!', 'it', 'was', 'fantastic.'] def calculate_word_frequencies(reviews: list, labels: list) -> dict: Calculate word frequencies for each class. >>> reviews = [['i', 'love', 'it'], ['hate', 'this', 'product']] >>> labels = ['positive', 'negative'] {\\"positive\\": {\\"i\\": 1, \\"love\\": 1, \\"it\\": 1}, \\"negative\\": {\\"hate\\": 1, \\"this\\": 1, \\"product\\": 1}} def calculate_class_probabilities(review_counts: dict, total_reviews: int) -> dict: Compute the probabilities of each class. >>> review_counts = {'positive': 30, 'negative': 20} >>> total_reviews = 50 {'positive': 0.6, 'negative': 0.4} def predict_sentiment(review: list, word_frequencies: dict, class_probabilities: dict, vocab_size: int) -> str: Predict the sentiment of the review using the Naive Bayes algorithm. >>> review = ['i', 'love', 'it'] >>> word_frequencies = {'positive': {'i': 2, 'love': 3, 'it': 1}, 'negative': {'i': 1, 'hate': 3, 'it': 2}} >>> class_probabilities = {'positive': 0.6, 'negative': 0.4} >>> vocab_size = 10 'positive' >>> review = ['i', 'hate', 'it'] 'negative' def evaluate_accuracy(actual_labels: list, predicted_labels: list) -> float: Calculate the accuracy of the predictions. >>> actual_labels = ['positive', 'negative', 'positive'] >>> predicted_labels = ['positive', 'positive', 'positive'] 66.66666666666666","solution":"def tokenize(review): Convert a string into a list of words in lowercase. return review.lower().split() def calculate_word_frequencies(reviews, labels): Calculate word frequencies for each class. from collections import defaultdict word_frequencies = { 'positive': defaultdict(int), 'negative': defaultdict(int) } for review, label in zip(reviews, labels): for word in review: word_frequencies[label][word] += 1 return word_frequencies def calculate_class_probabilities(review_counts, total_reviews): Compute the probabilities of each class. return {cls: count / total_reviews for cls, count in review_counts.items()} def predict_sentiment(review, word_frequencies, class_probabilities, vocab_size): Predict the sentiment of the review using the Naive Bayes algorithm. import math def calculate_word_probability(word, label): word_freq = word_frequencies[label].get(word, 0) total_words_in_class = sum(word_frequencies[label].values()) return (word_freq + 1) / (total_words_in_class + vocab_size) # Add-1 smoothing class_scores = {} for cls in class_probabilities: class_scores[cls] = math.log(class_probabilities[cls]) for word in review: class_scores[cls] += math.log(calculate_word_probability(word, cls)) return max(class_scores, key=class_scores.get) def evaluate_accuracy(actual_labels, predicted_labels): Calculate the accuracy of the predictions. correct_predictions = sum(1 for actual, predicted in zip(actual_labels, predicted_labels) if actual == predicted) return (correct_predictions / len(actual_labels)) * 100"},{"question":"from collections import deque class RateLimiter: def __init__(self, maxRequests: int, timeframeMillis: int): Initialize the Rate Limiter with the given maxRequests and timeframeMillis. Args: maxRequests (int): Maximum number of allowed requests. timeframeMillis (int): Timeframe in milliseconds within which the maxRequests must be enforced. pass def allowRequest(self, timestamp: int) -> bool: Determine whether a request at the given timestamp is allowed. Args: timestamp (int): The request timestamp in milliseconds since the epoch. Returns: bool: True if the request is allowed, otherwise False. pass def test_rate_limiter_basic_functionality(): rateLimiter = RateLimiter(2, 1000) assert rateLimiter.allowRequest(1000) == True assert rateLimiter.allowRequest(1500) == True assert rateLimiter.allowRequest(1800) == False assert rateLimiter.allowRequest(2500) == True def test_rate_limiter_exact_timeframe(): rateLimiter = RateLimiter(2, 1000) assert rateLimiter.allowRequest(1000) == True assert rateLimiter.allowRequest(1500) == True assert rateLimiter.allowRequest(2000) == True # Previous request 1000 is out of timeframe def test_rate_limiter_high_frequency(): rateLimiter = RateLimiter(3, 2000) assert rateLimiter.allowRequest(1000) == True assert rateLimiter.allowRequest(1200) == True assert rateLimiter.allowRequest(1400) == True assert rateLimiter.allowRequest(1500) == False assert rateLimiter.allowRequest(3000) == True def test_rate_limiter_no_requests(): rateLimiter = RateLimiter(2, 1000) # No requests made, so should return True for the first request assert rateLimiter.allowRequest(5000) == True def test_rate_limiter_large_time_gap(): rateLimiter = RateLimiter(2, 1000) assert rateLimiter.allowRequest(1000) == True assert rateLimiter.allowRequest(5000) == True # Large gap, resetting previous count assert rateLimiter.allowRequest(6000) == True","solution":"from collections import deque class RateLimiter: def __init__(self, maxRequests, timeframeMillis): Initialize the Rate Limiter with the given maxRequests and timeframeMillis. self.maxRequests = maxRequests self.timeframeMillis = timeframeMillis self.requests = deque() def allowRequest(self, timestamp): Determine whether a request at the given timestamp is allowed. # Remove all requests that are outside the timeframe while self.requests and self.requests[0] <= timestamp - self.timeframeMillis: self.requests.popleft() # Check if we can allow this request if len(self.requests) < self.maxRequests: self.requests.append(timestamp) return True else: return False"},{"question":"import pandas as pd def process_data(file_path: str) -> dict: Given the file path to a CSV file containing raw data, process the data and return a summarized report. Parameters: file_path (str): The path to the CSV file. Returns: dict: A dictionary containing the summarized report. # Read the CSV file # Drop rows with missing or malformed data # Total number of data entries # Average of the \`value\` column # Maximum value in the \`value\` column and its associated timestamp # Minimum value in the \`value\` column and its associated timestamp # Count of entries per category # Return the summarized report pass import pytest from io import StringIO # Sample CSV data for testing csv_data = timestamp,value,category 2023-01-01 12:00:00,100.0,A 2023-01-02 13:00:00,50.0,B 2023-01-03 14:00:00,75.0,B 2023-01-04 15:00:00,25.0,A 2023-01-05 16:00:00,0.0,C # Create a temporary CSV file for testing @pytest.fixture def tmp_csv_file(tmp_path): csv_file_path = tmp_path / \\"test_data.csv\\" with open(csv_file_path, 'w') as f: f.write(csv_data) return csv_file_path def test_process_data(tmp_csv_file): report = process_data(tmp_csv_file) assert report['total_entries'] == 5 assert pytest.approx(report['average_value']) == 50.0 assert report['max_value'] == {'timestamp': pd.Timestamp('2023-01-01 12:00:00'), 'value': 100.0} assert report['min_value'] == {'timestamp': pd.Timestamp('2023-01-05 16:00:00'), 'value': 0.0} assert report['entries_per_category'] == {'B': 2, 'A': 2, 'C': 1} def test_process_data_with_missing_values(tmp_path): csv_data_with_missing_values = timestamp,value,category 2023-01-01 12:00:00,100.0,A ,, 2023-01-04 15:00:00,25.0,A 2023-01-05 16:00:00,,C csv_file_path = tmp_path / \\"test_data_missing.csv\\" with open(csv_file_path, 'w') as f: f.write(csv_data_with_missing_values) report = process_data(csv_file_path) assert report['total_entries'] == 2 assert pytest.approx(report['average_value']) == 62.5 assert report['max_value'] == {'timestamp': pd.Timestamp('2023-01-01 12:00:00'), 'value': 100.0} assert report['min_value'] == {'timestamp': pd.Timestamp('2023-01-04 15:00:00'), 'value': 25.0} assert report['entries_per_category'] == {'A': 2}","solution":"import pandas as pd def process_data(file_path: str) -> dict: Given the file path to a CSV file containing raw data, process the data and return a summarized report. Parameters: file_path (str): The path to the CSV file. Returns: dict: A dictionary containing the summarized report. # Read the CSV file data = pd.read_csv(file_path, parse_dates=['timestamp']) # Drop rows with missing or malformed data data.dropna(subset=['timestamp', 'value', 'category'], inplace=True) # Total number of data entries total_entries = data.shape[0] # Average of the \`value\` column average_value = data['value'].mean() # Maximum value in the \`value\` column and its associated timestamp max_row = data.loc[data['value'].idxmax()] max_value = {'timestamp': max_row['timestamp'], 'value': max_row['value']} # Minimum value in the \`value\` column and its associated timestamp min_row = data.loc[data['value'].idxmin()] min_value = {'timestamp': min_row['timestamp'], 'value': min_row['value']} # Count of entries per category entries_per_category = data['category'].value_counts().to_dict() # Return the summarized report return { 'total_entries': total_entries, 'average_value': average_value, 'max_value': max_value, 'min_value': min_value, 'entries_per_category': entries_per_category }"},{"question":"class EmployeeBST: class Node: def __init__(self, emp_id, emp_name): self.emp_id = emp_id self.emp_name = emp_name self.left = None self.right = None def __init__(self): self.root = None def insert(self, emp_id, emp_name): Insert a new employee record into the BST. Args: emp_id (int): The employee's unique ID. emp_name (str): The employee's name. def find(self, emp_id): Search for an employee in the BST by their ID. Args: emp_id (int): The employee's unique ID. Returns: str: The employee's name if found, or None if not found. def height(self): Report the height of the BST. Returns: int: The height of the BST. # Example usage: # bst = EmployeeBST() # bst.insert(1001, \\"John Smith\\") # bst.insert(1002, \\"Jane Doe\\") # print(bst.find(1001)) # Output: \\"John Smith\\" # print(bst.find(1003)) # Output: None # print(bst.height()) # Output: Relevant height of the tree # Unit Tests: def test_insert_and_find(): bst = EmployeeBST() bst.insert(1001, \\"John Smith\\") assert bst.find(1001) == \\"John Smith\\" bst.insert(1002, \\"Jane Doe\\") assert bst.find(1002) == \\"Jane Doe\\" assert bst.find(1003) == None def test_find_nonexistent(): bst = EmployeeBST() bst.insert(2001, \\"Alice\\") bst.insert(2002, \\"Bob\\") assert bst.find(2003) == None def test_height(): bst = EmployeeBST() assert bst.height() == -1 # Empty tree bst.insert(1001, \\"John Smith\\") assert bst.height() == 0 bst.insert(1002, \\"Jane Doe\\") assert bst.height() == 1 bst.insert(999, \\"Alice\\") assert bst.height() == 1 # Balanced insertion should still result in 1 for this case bst.insert(998, \\"Bob\\") assert bst.height() == 2 # Left-heavy tree, height should increase def test_balanced_insert(): bst = EmployeeBST() # Inserting nodes in such a way to try to keep the tree balanced bst.insert(50, \\"Emp50\\") bst.insert(30, \\"Emp30\\") bst.insert(70, \\"Emp70\\") bst.insert(20, \\"Emp20\\") bst.insert(40, \\"Emp40\\") bst.insert(60, \\"Emp60\\") bst.insert(80, \\"Emp80\\") assert bst.height() == 2 # Perfectly balanced tree for 7 nodes if __name__ == \\"__main__\\": test_insert_and_find() test_find_nonexistent() test_height() test_balanced_insert() print(\\"All tests passed!\\")","solution":"class EmployeeBST: class Node: def __init__(self, emp_id, emp_name): self.emp_id = emp_id self.emp_name = emp_name self.left = None self.right = None def __init__(self): self.root = None def insert(self, emp_id, emp_name): if self.root is None: self.root = self.Node(emp_id, emp_name) else: self._insert(self.root, emp_id, emp_name) def _insert(self, node, emp_id, emp_name): if emp_id < node.emp_id: if node.left is None: node.left = self.Node(emp_id, emp_name) else: self._insert(node.left, emp_id, emp_name) elif emp_id > node.emp_id: if node.right is None: node.right = self.Node(emp_id, emp_name) else: self._insert(node.right, emp_id, emp_name) # Duplicate emp_id is ignored; assumption based on unique IDs in constraints def find(self, emp_id): return self._find(self.root, emp_id) def _find(self, node, emp_id): if node is None: return None if emp_id == node.emp_id: return node.emp_name elif emp_id < node.emp_id: return self._find(node.left, emp_id) else: return self._find(node.right, emp_id) def height(self): return self._height(self.root) def _height(self, node): if node is None: return -1 left_height = self._height(node.left) right_height = self._height(node.right) return 1 + max(left_height, right_height) # Example usage: # bst = EmployeeBST() # bst.insert(1001, \\"John Smith\\") # bst.insert(1002, \\"Jane Doe\\") # print(bst.find(1001)) # Output: \\"John Smith\\" # print(bst.find(1003)) # Output: None # print(bst.height()) # Output: Relevant height of the tree"},{"question":"from collections import deque, defaultdict from typing import List, Dict class Graph: def __init__(self): self.nodes = set() self.edges = defaultdict(list) def add_node(self, node: str) -> None: Adds a node to the graph. pass def add_edge(self, node1: str, node2: str) -> None: Adds an undirected edge between two nodes. pass def bfs(self, start: str) -> List[str]: Performs BFS and returns the list of nodes visited from the starting node. pass def bfs_connected_components(graph: Graph) -> Dict[str, List[str]]: Takes an instance of Graph and returns a dictionary where keys are node names and values are lists of nodes that are in the same connected component as the key node. >>> g = Graph() >>> g.add_node('A') >>> g.add_node('B') >>> g.add_node('C') >>> g.add_node('D') >>> g.add_node('E') >>> g.add_edge('A', 'B') >>> g.add_edge('A', 'C') >>> g.add_edge('B', 'C') >>> g.add_edge('D', 'E') >>> components = bfs_connected_components(g) >>> components == { ... 'A': ['A', 'B', 'C'], ... 'B': ['A', 'B', 'C'], ... 'C': ['A', 'B', 'C'], ... 'D': ['D', 'E'], ... 'E': ['D', 'E'] ... } True pass","solution":"from collections import deque, defaultdict class Graph: def __init__(self): self.nodes = set() self.edges = defaultdict(list) def add_node(self, node: str) -> None: self.nodes.add(node) def add_edge(self, node1: str, node2: str) -> None: self.edges[node1].append(node2) self.edges[node2].append(node1) def bfs(self, start: str): visited = set() queue = deque([start]) order = [] while queue: node = queue.popleft() if node not in visited: visited.add(node) order.append(node) for neighbor in self.edges[node]: if neighbor not in visited: queue.append(neighbor) return order def bfs_connected_components(graph): visited = set() components = {} for node in graph.nodes: if node not in visited: connected_component = graph.bfs(node) for component_node in connected_component: components[component_node] = connected_component visited.add(component_node) return components # Example usage: g = Graph() g.add_node('A') g.add_node('B') g.add_node('C') g.add_node('D') g.add_node('E') g.add_edge('A', 'B') g.add_edge('A', 'C') g.add_edge('B', 'C') g.add_edge('D', 'E') print(g.bfs('A')) # Output: ['A', 'B', 'C'] components = bfs_connected_components(g) print(components) # Output: { # 'A': ['A', 'B', 'C'], # 'B': ['A', 'B', 'C'], # 'C': ['A', 'B', 'C'], # 'D': ['D', 'E'], # 'E': ['D', 'E'] # }"},{"question":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def max_depth(root: TreeNode) -> int: Returns the depth of the deepest leaf node in a binary tree. The function uses depth-first search (DFS) approach to traverse the tree. Args: root (TreeNode): The root node of a binary tree. Returns: int: The maximum depth of the deepest leaf node. Examples: >>> max_depth(None) 0 >>> max_depth(TreeNode(1)) 1 >>> max_depth(TreeNode(1, right=TreeNode(2, right=TreeNode(3)))) 3 >>> max_depth(TreeNode(1, left=TreeNode(2), right=TreeNode(3))) 2 >>> max_depth(TreeNode(1, left=TreeNode(2, left=TreeNode(4), right=TreeNode(5)), right=TreeNode(3))) 3 pass","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def max_depth(root: TreeNode) -> int: if not root: return 0 left_depth = max_depth(root.left) right_depth = max_depth(root.right) return max(left_depth, right_depth) + 1"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def balance_bst(root: TreeNode) -> TreeNode: Converts an unbalanced BST into a balanced BST while preserving the original in-order traversal sequence. >>> root = TreeNode(1) >>> root.right = TreeNode(2) >>> root.right.right = TreeNode(3) >>> root.right.right.right = TreeNode(4) >>> root.right.right.right.right = TreeNode(5) >>> balanced_root = balance_bst(root) >>> def inorder_traversal(root): >>> return inorder_traversal(root.left) + [root.val] + inorder_traversal(root.right) if root else [] >>> inorder_traversal(balanced_root) [1, 2, 3, 4, 5] pass","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def balance_bst(root: TreeNode) -> TreeNode: def inorder_traversal(node): if not node: return [] return inorder_traversal(node.left) + [node.val] + inorder_traversal(node.right) def sorted_list_to_bst(lst): if not lst: return None mid = len(lst) // 2 root = TreeNode(lst[mid]) root.left = sorted_list_to_bst(lst[:mid]) root.right = sorted_list_to_bst(lst[mid + 1:]) return root sorted_values = inorder_traversal(root) return sorted_list_to_bst(sorted_values)"},{"question":"def merge_k_sorted_lists(message_lists: list[list[dict]]) -> list[dict]: Merges k sorted lists of messages while maintaining the overall sorted order by timestamp. :param message_lists: List of k sorted lists of messages. Each message is a dictionary with a 'timestamp' key. :return: List of all messages sorted by 'timestamp'. pass from solution import merge_k_sorted_lists def test_merge_k_sorted_lists(): messages_lists = [ [{'timestamp': 1, 'text': 'Hi'}, {'timestamp': 4, 'text': 'Good morning'}, {'timestamp': 10, 'text': 'Bye'}], [{'timestamp': 2, 'text': 'Hello'}, {'timestamp': 6, 'text': 'How are you?'}, {'timestamp': 9, 'text': 'Good night'}], [{'timestamp': 3, 'text': 'Hey'}, {'timestamp': 5, 'text': 'I am fine'}, {'timestamp': 8, 'text': 'See you'}] ] expected_output = [ {'timestamp': 1, 'text': 'Hi'}, {'timestamp': 2, 'text': 'Hello'}, {'timestamp': 3, 'text': 'Hey'}, {'timestamp': 4, 'text': 'Good morning'}, {'timestamp': 5, 'text': 'I am fine'}, {'timestamp': 6, 'text': 'How are you?'}, {'timestamp': 8, 'text': 'See you'}, {'timestamp': 9, 'text': 'Good night'}, {'timestamp': 10, 'text': 'Bye'} ] assert merge_k_sorted_lists(messages_lists) == expected_output def test_merge_with_empty_lists(): messages_lists = [ [{'timestamp': 2, 'text': 'Hello'}], [], [{'timestamp': 1, 'text': 'Hi'}] ] expected_output = [ {'timestamp': 1, 'text': 'Hi'}, {'timestamp': 2, 'text': 'Hello'} ] assert merge_k_sorted_lists(messages_lists) == expected_output def test_merge_single_list(): messages_lists = [ [{'timestamp': 1, 'text': 'Hi'}, {'timestamp': 2, 'text': 'Hello'}] ] expected_output = [ {'timestamp': 1, 'text': 'Hi'}, {'timestamp': 2, 'text': 'Hello'} ] assert merge_k_sorted_lists(messages_lists) == expected_output def test_merge_all_empty_lists(): messages_lists = [ [], [], [] ] expected_output = [] assert merge_k_sorted_lists(messages_lists) == expected_output def test_merge_varied_lengths(): messages_lists = [ [{'timestamp': 1, 'text': 'Hi'}], [{'timestamp': 2, 'text': 'Hello'}, {'timestamp': 3, 'text': 'Hey'}], [{'timestamp': 4, 'text': 'Hi again'}, {'timestamp': 5, 'text': 'Hello again'}, {'timestamp': 6, 'text': 'Hey again'}] ] expected_output = [ {'timestamp': 1, 'text': 'Hi'}, {'timestamp': 2, 'text': 'Hello'}, {'timestamp': 3, 'text': 'Hey'}, {'timestamp': 4, 'text': 'Hi again'}, {'timestamp': 5, 'text': 'Hello again'}, {'timestamp': 6, 'text': 'Hey again'} ] assert merge_k_sorted_lists(messages_lists) == expected_output","solution":"from heapq import heappop, heappush, heapify def merge_k_sorted_lists(message_lists): Merges k sorted lists of messages while maintaining the overall sorted order by timestamp. :param message_lists: List of k sorted lists of messages. Each message is a dictionary with a 'timestamp' key. :return: List of all messages sorted by 'timestamp'. min_heap = [] # Initialize the heap for i, message_list in enumerate(message_lists): if message_list: heappush(min_heap, (message_list[0]['timestamp'], i, 0)) merged_messages = [] while min_heap: timestamp, list_idx, msg_idx = heappop(min_heap) merged_messages.append(message_lists[list_idx][msg_idx]) # If there are more messages in the same list, add the next one to the heap if msg_idx + 1 < len(message_lists[list_idx]): next_msg = message_lists[list_idx][msg_idx + 1] heappush(min_heap, (next_msg['timestamp'], list_idx, msg_idx + 1)) return merged_messages"},{"question":"def validate_and_generate_isbn(isbn_number: str) -> dict: Check and Generate ISBN Number A publisher needs a software tool to verify and generate valid International Standard Book Numbers (ISBN). The ISBN-10 format is used for books published before 2007 and consists of 9 digits, followed by a check digit. 1. Takes a string \`isbn_number\` which is either a 9-digit string (indicating the core of the ISBN) or a 10-digit string (indicating a complete ISBN including check digit). 2. Determines if the provided ISBN number is valid when it includes the check digit, or generates the correct check digit if only 9 digits are provided. The function must: - First validate the input based on length and character restrictions. - If the input is a 10-digit ISBN, validate that the check digit is correct. - If the input is a 9-digit core, compute the check digit and form a valid 10-digit ISBN. - Return a dictionary with key \`status\` indicating \\"Valid\\" or \\"Invalid\\", and \`isbn\` indicating the correct/validated ISBN. Examples: >>> validate_and_generate_isbn(\\"030640615\\") == {'status': 'Valid', 'isbn': '0306406152'} >>> validate_and_generate_isbn(\\"0306406152\\") == {'status': 'Valid', 'isbn': '0306406152'} >>> validate_and_generate_isbn(\\"030640615X\\") == {'status': 'Invalid', 'isbn': 'Invalid'} >>> validate_and_generate_isbn(\\"12345678\\") == {'status': 'Invalid', 'isbn': 'Invalid'} >>> validate_and_generate_isbn(\\"0471958697\\") == {'status': 'Valid', 'isbn': '0471958697'}","solution":"def validate_and_generate_isbn(isbn_number: str) -> dict: if not (len(isbn_number) == 9 or len(isbn_number) == 10): return {'status': 'Invalid', 'isbn': 'Invalid'} if len(isbn_number) == 9 and not isbn_number.isdigit(): return {'status': 'Invalid', 'isbn': 'Invalid'} if len(isbn_number) == 10: if not isbn_number[:-1].isdigit() or (isbn_number[-1] not in '0123456789X'): return {'status': 'Invalid', 'isbn': 'Invalid'} def calculate_check_digit(isbn_core): total = sum((i + 1) * int(digit) for i, digit in enumerate(isbn_core)) check_digit = total % 11 return 'X' if check_digit == 10 else str(check_digit) if len(isbn_number) == 9: check_digit = calculate_check_digit(isbn_number) return {'status': 'Valid', 'isbn': isbn_number + check_digit} if len(isbn_number) == 10: isbn_core = isbn_number[:-1] provided_check_digit = isbn_number[-1] calculated_check_digit = calculate_check_digit(isbn_core) if provided_check_digit == calculated_check_digit: return {'status': 'Valid', 'isbn': isbn_number} else: return {'status': 'Invalid', 'isbn': 'Invalid'}"},{"question":"def shift_string(s: str, n: int) -> str: Shifts each character in the string s by n positions forward in the alphabet. Wraps around if the shift moves past 'z'. >>> shift_string(\\"abc\\", 1) 'bcd' >>> shift_string(\\"xyz\\", 3) 'abc' >>> shift_string(\\"hello\\", 13) 'uryyb' >>> shift_string(\\"apple\\", 25) 'zookd' >>> shift_string(\\"shiftme\\", 52) 'shiftme' >>> shift_string(\\"wraparound\\", 26) 'wraparound' >>> shift_string(\\"negative\\", 0) 'negative' >>> shift_string(\\"overshift\\", 130) 'overshift'","solution":"def shift_string(s: str, n: int) -> str: Shifts each character in the string s by n positions forward in the alphabet. Wraps around if the shift moves past 'z'. shifted_string = [] for char in s: shifted_char = chr((ord(char) - ord('a') + n) % 26 + ord('a')) shifted_string.append(shifted_char) return ''.join(shifted_string)"},{"question":"def distribute_inventory(total_items: int, box_capacity: int) -> list: Distribute total_items into boxes each with a maximum capacity of box_capacity. Args: total_items (int): The total number of items to distribute. box_capacity (int): The capacity of each box. Returns: list: A list representing the number of items in each box. >>> distribute_inventory(15, 4) [4, 4, 4, 3] >>> distribute_inventory(10, 3) [3, 3, 3, 1] >>> distribute_inventory(25, 7) [7, 7, 7, 4] >>> distribute_inventory(7, 7) [7] >>> distribute_inventory(0, 5) [] pass import pytest def test_distribute_inventory_example_cases(): assert distribute_inventory(15, 4) == [4, 4, 4, 3] assert distribute_inventory(10, 3) == [3, 3, 3, 1] assert distribute_inventory(25, 7) == [7, 7, 7, 4] assert distribute_inventory(7, 7) == [7] assert distribute_inventory(0, 5) == [] def test_distribute_inventory_edge_cases(): with pytest.raises(ValueError): distribute_inventory(-1, 5) with pytest.raises(ValueError): distribute_inventory(10, 0) with pytest.raises(ValueError): distribute_inventory(10, -5) with pytest.raises(ValueError): distribute_inventory(\\"10\\", 5) with pytest.raises(ValueError): distribute_inventory(10, \\"5\\") def test_distribute_inventory_large_numbers(): assert distribute_inventory(1000000, 100000) == [100000] * 10 def test_distribute_inventory_exact_fit(): assert distribute_inventory(14, 7) == [7, 7] def test_distribute_inventory_one_item(): assert distribute_inventory(1, 1) == [1] assert distribute_inventory(1, 2) == [1]","solution":"def distribute_inventory(total_items: int, box_capacity: int) -> list: Distribute total_items into boxes each with a maximum capacity of box_capacity. Args: total_items (int): The total number of items to distribute. box_capacity (int): The capacity of each box. Returns: list: A list representing the number of items in each box. if not isinstance(total_items, int) or not isinstance(box_capacity, int): raise ValueError(\\"Both total_items and box_capacity must be integers.\\") if total_items < 0 or box_capacity <= 0: raise ValueError(\\"total_items must be non-negative and box_capacity must be greater than zero.\\") result = [] remaining_items = total_items while remaining_items > 0: if remaining_items >= box_capacity: result.append(box_capacity) else: result.append(remaining_items) remaining_items -= box_capacity return result"},{"question":"def common_elements(list1: List[int], list2: List[int]) -> List[int]: Returns a list of integers that are common to both list1 and list2. Both lists are assumed to be sorted in non-decreasing order. >>> common_elements([1, 3, 4, 6, 7, 9], [3, 5, 7, 8, 9, 10]) [3, 7, 9] >>> common_elements([1, 2, 2, 3], [2, 2, 3, 3]) [2, 3] >>> common_elements([1, 2, 3], [4, 5, 6]) []","solution":"from typing import List def common_elements(list1: List[int], list2: List[int]) -> List[int]: Returns a list of integers that are common to both list1 and list2. Both lists are assumed to be sorted in non-decreasing order. common = [] i, j = 0, 0 n, m = len(list1), len(list2) while i < n and j < m: if list1[i] == list2[j]: if not common or common[-1] != list1[i]: common.append(list1[i]) i += 1 j += 1 elif list1[i] < list2[j]: i += 1 else: j += 1 return common"},{"question":"def is_power_of_two(number: int) -> bool: Determines if the given number is a power of two. Parameters: number (int): The number to check. Returns: bool: True if the number is a power of two, False otherwise. Raises: TypeError: If the input is not an integer or if it is negative. Examples: >>> is_power_of_two(1) True >>> is_power_of_two(2) True >>> is_power_of_two(3) False >>> is_power_of_two(4) True >>> is_power_of_two(18) False def test_is_power_of_two(): # Test valid power of two assert is_power_of_two(1) == True # 2^0 assert is_power_of_two(2) == True # 2^1 assert is_power_of_two(4) == True # 2^2 assert is_power_of_two(8) == True # 2^3 assert is_power_of_two(16) == True # 2^4 # Test invalid power of two assert is_power_of_two(0) == False assert is_power_of_two(3) == False assert is_power_of_two(5) == False assert is_power_of_two(10) == False assert is_power_of_two(18) == False # Test large values assert is_power_of_two(1024) == True # 2^10 assert is_power_of_two(1048576) == True # 2^20 assert is_power_of_two(1073741824) == True # 2^30 def test_is_power_of_two_invalid_input(): # Test negative numbers should raise TypeError import pytest with pytest.raises(TypeError): is_power_of_two(-1) with pytest.raises(TypeError): is_power_of_two(-2) # Test non-integer inputs should raise TypeError with pytest.raises(TypeError): is_power_of_two(2.5) with pytest.raises(TypeError): is_power_of_two(\\"16\\") with pytest.raises(TypeError): is_power_of_two(None)","solution":"def is_power_of_two(number: int) -> bool: Determines if the given number is a power of two. Parameters: number (int): The number to check. Returns: bool: True if the number is a power of two, False otherwise. Raises: TypeError: If the input is not an integer or if it is negative. if not isinstance(number, int) or number < 0: raise TypeError(\\"Input value must be a non-negative integer\\") return number != 0 and (number & (number - 1)) == 0"},{"question":"def battleship_move(board: List[str], move: Tuple[int, int]) -> Tuple[List[str], str]: Simulates a simple version of the game \\"Battleship\\" and updates the game board based on an incoming move. >>> board = [ ... \\"..........\\", ... \\"..S.......\\", ... \\"..S.......\\", ... \\"..........\\", ... \\".....S....\\", ... \\"..........\\", ... \\"..........\\", ... \\"..........\\", ... \\".....S....\\", ... \\".....S....\\" ... ] >>> move = (1, 2) >>> battleship_move(board, move) ([\\"..........\\", \\"..H.......\\", \\"..S.......\\", \\"..........\\", \\".....S....\\", \\"..........\\", \\"..........\\", \\"..........\\", \\".....S....\\", \\".....S....\\"], \\"Hit!\\") >>> move = (0, 0) >>> battleship_move(board, move) ([\\"..........\\", \\"..S.......\\", \\"..S.......\\", \\"..........\\", \\".....S....\\", \\"..........\\", \\"..........\\", \\"..........\\", \\".....S....\\", \\".....S....\\"], \\"Miss!\\") >>> move = (1, 2) >>> battleship_move(board, move) ([\\"..........\\", \\"..H.......\\", \\"..S.......\\", \\"..........\\", \\".....S....\\", \\"..........\\", \\"..........\\", \\"..........\\", \\".....S....\\", \\".....S....\\"], \\"Already Hit!\\")","solution":"from typing import List, Tuple def battleship_move(board: List[str], move: Tuple[int, int]) -> Tuple[List[str], str]: row, col = move cell = board[row][col] if cell == 'S': new_row = board[row][:col] + 'H' + board[row][col + 1:] board[row] = new_row outcome = \\"Hit!\\" elif cell == '.': outcome = \\"Miss!\\" elif cell == 'H': outcome = \\"Already Hit!\\" return board, outcome"},{"question":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverse_linked_list(head: ListNode) -> ListNode: Reverses a singly linked list using recursion. Args: head (ListNode): The head node of the linked list. Returns: ListNode: The new head of the reversed linked list. pass def list_to_linked_list(elements): Helper function to convert a list to a linked list. if not elements: return None head = ListNode(elements[0]) current = head for element in elements[1:]: current.next = ListNode(element) current = current.next return head def linked_list_to_list(head): Helper function to convert a linked list back to a list. elements = [] while head: elements.append(head.val) head = head.next return elements def test_reverse_linked_list_multiple_elements(): head = list_to_linked_list([1, 2, 3]) new_head = reverse_linked_list(head) assert linked_list_to_list(new_head) == [3, 2, 1] def test_reverse_linked_list_single_element(): head = list_to_linked_list([1]) new_head = reverse_linked_list(head) assert linked_list_to_list(new_head) == [1] def test_reverse_linked_list_empty(): head = list_to_linked_list([]) new_head = reverse_linked_list(head) assert linked_list_to_list(new_head) == [] def test_reverse_linked_list_two_elements(): head = list_to_linked_list([1, 2]) new_head = reverse_linked_list(head) assert linked_list_to_list(new_head) == [2, 1]","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverse_linked_list(head: ListNode) -> ListNode: Reverses a singly linked list using recursion. Args: head (ListNode): The head node of the linked list. Returns: ListNode: The new head of the reversed linked list. # Base case: If the list is empty or has reached the last node if head is None or head.next is None: return head # Recurse on the next node new_head = reverse_linked_list(head.next) # Adjust the pointers head.next.next = head head.next = None return new_head"},{"question":"def prime_factors(n: int) -> list: Generate the list of prime factors of a given integer. >>> prime_factors(28) [2, 2, 7] >>> prime_factors(100) [2, 2, 5, 5] >>> prime_factors(13195) [5, 7, 13, 29] # Your implementation here pass # Example test cases print(prime_factors(28)) # Output: [2, 2, 7] print(prime_factors(100)) # Output: [2, 2, 5, 5] print(prime_factors(13195)) # Output: [5, 7, 13, 29] print(prime_factors(9973)) # Output: [9973] print(prime_factors(84)) # Output: [2, 2, 3, 7]","solution":"def prime_factors(n: int) -> list: if n < 2: raise ValueError(\\"Input must be an integer greater than 1.\\") factors = [] # Handle factor of 2 while n % 2 == 0: factors.append(2) n //= 2 # Handle odd factors from 3 onwards up to √n factor = 3 while factor * factor <= n: while n % factor == 0: factors.append(factor) n //= factor factor += 2 # If n is still greater than 2, then it must be a prime factor if n > 2: factors.append(n) return factors"},{"question":"def evaluate_boolean_expression(expression: str) -> bool: Evaluate and interpret Boolean expressions. The function evaluates Boolean expressions containing \`AND\`, \`OR\`, and \`NOT\` operations, and handles parentheses for grouping. Args: expression (str): A string representing the Boolean expression. Returns: bool: The evaluated result as a Boolean value, or None if the expression is invalid. >>> evaluate_boolean_expression(\\"(TRUE AND (FALSE OR TRUE))\\") True >>> evaluate_boolean_expression(\\"((TRUE OR FALSE) AND NOT FALSE)\\") True >>> evaluate_boolean_expression(\\"(NOT TRUE AND TRUE)\\") False >>> evaluate_boolean_expression(\\"((TRUE AND FALSE) OR (NOT FALSE))\\") True >>> evaluate_boolean_expression(\\"(TRUE AND )\\") None >>> evaluate_boolean_expression(\\"((TRUE OR FALSE)) AND\\") None >>> evaluate_boolean_expression(\\"()\\") None # Unit tests def test_evaluate_boolean_expression(): assert evaluate_boolean_expression(\\"(TRUE AND (FALSE OR TRUE))\\") == True assert evaluate_boolean_expression(\\"((TRUE OR FALSE) AND NOT FALSE)\\") == True assert evaluate_boolean_expression(\\"(NOT TRUE AND TRUE)\\") == False assert evaluate_boolean_expression(\\"((TRUE AND FALSE) OR (NOT FALSE))\\") == True assert evaluate_boolean_expression(\\"(TRUE AND )\\") == None assert evaluate_boolean_expression(\\"((TRUE OR FALSE)) AND\\") == None assert evaluate_boolean_expression(\\"()\\") == None assert evaluate_boolean_expression(\\"\\") == None assert evaluate_boolean_expression(\\"TRUE AND FALSE OR TRUE\\") == True assert evaluate_boolean_expression(\\"NOT FALSE AND TRUE\\") == True assert evaluate_boolean_expression(\\"TRUE AND (NOT FALSE)\\") == True assert evaluate_boolean_expression(\\"NOT (TRUE AND FALSE)\\") == True assert evaluate_boolean_expression(\\"NOT (TRUE AND )\\") == None assert evaluate_boolean_expression(\\"(((NOT TRUE AND FALSE)))\\") == False assert evaluate_boolean_expression(\\"TRUE AND (FALSE OR NOT TRUE)\\") == False # Run the tests test_evaluate_boolean_expression()","solution":"def evaluate_boolean_expression(expression: str) -> bool: import re def parse_tokens(expression): tokens = re.findall(r'bTRUEb|bFALSEb|bANDb|bORb|bNOTb|(|)', expression) return tokens def precedence(op): if op == 'NOT': return 3 if op in ('AND', 'OR'): return 2 return 0 def apply_op(operands, op): if op == 'AND': right = operands.pop() left = operands.pop() operands.append(left and right) elif op == 'OR': right = operands.pop() left = operands.pop() operands.append(left or right) elif op == 'NOT': operand = operands.pop() operands.append(not operand) def evaluate_tokens(tokens): operands = [] operators = [] i = 0 while i < len(tokens): token = tokens[i] if token == 'TRUE': operands.append(True) elif token == 'FALSE': operands.append(False) elif token == '(': operators.append(token) elif token == ')': while operators and operators[-1] != '(': apply_op(operands, operators.pop()) operators.pop() # Remove '(' elif token in ('AND', 'OR', 'NOT'): while (operators and precedence(operators[-1]) >= precedence(token)): apply_op(operands, operators.pop()) operators.append(token) i += 1 while operators: apply_op(operands, operators.pop()) return operands[0] if operands else None tokens = parse_tokens(expression) if not tokens: # empty or invalid expression return None try: result = evaluate_tokens(tokens) except (IndexError, TypeError): return None return result"},{"question":"import numpy as np from scipy.ndimage import median_filter import matplotlib.pyplot as plt class MedianFilter: def __init__(self, kernel_size: int): Initialize the MedianFilter with provided kernel size. Parameters: kernel_size (int): Size of the median filter kernel (must be odd, between 3 and 9). self.kernel_size = kernel_size def apply_filter(self, image: np.ndarray) -> np.ndarray: Apply the median filter to a grayscale image. Parameters: image (np.ndarray): 2D numpy array representing the grayscale image. Returns: np.ndarray: Filtered image as a 2D numpy array. >>> mf = MedianFilter(3) >>> image = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) >>> mf.apply_filter(image) # doctest: +NORMALIZE_WHITESPACE array([[2, 3, 3], [4, 5, 6], [7, 7, 8]]) pass def configure_median_filter(kernel_size: int) -> MedianFilter: Configure and return a MedianFilter instance with the given kernel size. Parameters: kernel_size (int): Size of the median filter kernel (must be odd, between 3 and 9). Returns: MedianFilter: An instance of MedianFilter. >>> configure_median_filter(3) # doctest: +ELLIPSIS <__main__.MedianFilter object at ...> pass # Test Cases def test_median_filter_odd_kernel(): image = np.random.rand(10, 10) filter_instance = configure_median_filter(3) filtered_image = filter_instance.apply_filter(image) assert filtered_image.shape == image.shape def test_median_filter_kernel_size_error(): with pytest.raises(ValueError): configure_median_filter(4) # kernel_size must be odd def test_median_filter_kernel_size_out_of_bounds(): with pytest.raises(ValueError): configure_median_filter(10) # kernel_size must be between 3 and 9 def test_median_filter_non_2d_input(): image = np.random.rand(10, 10, 3) filter_instance = configure_median_filter(3) with pytest.raises(ValueError): filter_instance.apply_filter(image) # Input image must be 2D def test_kernel_size_valid_ranges(): for k in range(3, 10, 2): m_filter = configure_median_filter(k) assert m_filter.kernel_size == k def test_image_smaller_than_kernel(): image = np.random.rand(5, 5) filter_instance = configure_median_filter(7) with pytest.raises(ValueError): filter_instance.apply_filter(image) # Image dimensions should be at least kernel_size x kernel_size def test_kernel_size_even_value(): with pytest.raises(ValueError): configure_median_filter(2) def test_large_image(): image = np.random.rand(1000, 1000) filter_instance = configure_median_filter(3) filtered_image = filter_instance.apply_filter(image) assert filtered_image.shape == image.shape","solution":"import numpy as np from scipy.ndimage import median_filter import matplotlib.pyplot as plt class MedianFilter: def __init__(self, kernel_size: int): if kernel_size % 2 == 0: raise ValueError(\\"kernel_size must be an odd integer\\") if kernel_size < 3 or kernel_size > 9: raise ValueError(\\"kernel_size must be between 3 and 9\\") self.kernel_size = kernel_size def apply_filter(self, image: np.ndarray) -> np.ndarray: if image.ndim != 2: raise ValueError(\\"Input image must be a 2D numpy array\\") if image.shape[0] < self.kernel_size or image.shape[1] < self.kernel_size: raise ValueError(\\"Image dimensions should be at least kernel_size x kernel_size\\") return median_filter(image, size=self.kernel_size) def configure_median_filter(kernel_size: int) -> MedianFilter: return MedianFilter(kernel_size) # Sample usage: # Load a sample grayscale image image = np.random.rand(100, 100) * 255 # A random grayscale image for illustration image = image.astype(np.uint8) # Configure median filter median_filter_instance = configure_median_filter(5) # Apply median filter filtered_image = median_filter_instance.apply_filter(image) # Display original and filtered images fig, axes = plt.subplots(1, 2, figsize=(10, 5)) axes[0].imshow(image, cmap='gray') axes[0].set_title('Original Image') axes[0].axis('off') axes[1].imshow(filtered_image, cmap='gray') axes[1].set_title('Filtered Image') axes[1].axis('off') plt.show()"},{"question":"import csv def aggregate_purchases(file_paths: list[str]) -> dict[str, float]: Write a Python function \`aggregate_purchases\` that takes in a list of file paths to CSV files and returns a dictionary where the keys are customer IDs and the values are the total purchase amounts. - \`file_paths\` (list of str): List of absolute or relative paths to CSV files (e.g., [\\"data1.csv\\", \\"data2.csv\\"]). - Returns a dictionary with each customer ID as the key and the total purchase amount (float) as the value. Each CSV file has a header row with the columns: \\"customer_id\\" (str), \\"purchase_amount\\" (float). The function should handle cases where some files might be missing or corrupted gracefully and skip those files. Duplicate entries of the same customer within or across CSV files should be summed. Use Python's built-in CSV module to read the files. Assume each CSV file can fit into memory. >>> file_paths = [\\"data1.csv\\", \\"data2.csv\\"] >>> aggregate_purchases(file_paths) {'C001': 250.5, 'C002': 250.5, 'C003': 300.0}","solution":"import csv def aggregate_purchases(file_paths: list[str]) -> dict[str, float]: purchase_dict = {} for path in file_paths: try: with open(path, mode='r', newline='') as file: reader = csv.DictReader(file) for row in reader: customer_id = row['customer_id'] purchase_amount = float(row['purchase_amount']) if customer_id in purchase_dict: purchase_dict[customer_id] += purchase_amount else: purchase_dict[customer_id] = purchase_amount except (FileNotFoundError, IOError, ValueError, KeyError): # Gracefully skip the file if it's missing or corrupted continue return purchase_dict"},{"question":"def count_islands(matrix: list[list[int]]) -> int: Counts the number of islands in a matrix. A group of contiguous cells with the same value is considered an island. Contiguity is defined by the four cardinal directions (up, down, left, right). Parameters: matrix (list[list[int]]): The 2D matrix containing integer values representing heights or water. Returns: int: The number of islands in the given matrix. Examples: >>> matrix = [ ... [1, 1, 0, 0, 2], ... [1, 0, 0, 2, 2], ... [1, 1, 0, 2, 0], ... [0, 0, 0, 0, 0], ... [2, 2, 2, 1, 1] ... ] >>> count_islands(matrix) 5 >>> matrix = [[1]] >>> count_islands(matrix) 1 >>> matrix = [ ... [1, 1, 1], ... [1, 1, 1], ... [1, 1, 1] ... ] >>> count_islands(matrix) 1 >>> matrix = [ ... [1, 0, 0], ... [0, 1, 0], ... [0, 0, 1] ... ] >>> count_islands(matrix) 5 >>> matrix = [ ... [1] * 100, ... [1] * 100, ... [0] * 100, ... [1] * 100, ... [1] * 100 ... ] >>> count_islands(matrix) 3","solution":"def count_islands(matrix: list[list[int]]) -> int: if not matrix: return 0 rows = len(matrix) cols = len(matrix[0]) visited = [[False for _ in range(cols)] for _ in range(rows)] def dfs(r, c, value): if not (0 <= r < rows and 0 <= c < cols): return if visited[r][c] or matrix[r][c] != value: return visited[r][c] = True # Traverse the four cardinal directions dfs(r - 1, c, value) dfs(r + 1, c, value) dfs(r, c - 1, value) dfs(r, c + 1, value) count = 0 for r in range(rows): for c in range(cols): if not visited[r][c]: count += 1 dfs(r, c, matrix[r][c]) return count"},{"question":"def maximal_square(matrix: list[list[int]]) -> int: Find the side length of the largest square containing only 1's in the given binary matrix. >>> maximal_square([ ... [1, 0, 1, 0, 0], ... [1, 0, 1, 1, 1], ... [1, 1, 1, 1, 1], ... [1, 0, 0, 1, 0] ... ]) 2 >>> maximal_square([ ... [0, 1], ... [1, 0] ... ]) 1 >>> maximal_square([ ... [0] ... ]) 0 >>> maximal_square([ ... [1, 1, 1, 1], ... [1, 1, 1, 1], ... [1, 1, 1, 1], ... [1, 1, 1, 1] ... ]) 4","solution":"def maximal_square(matrix: list[list[int]]) -> int: if not matrix or not matrix[0]: return 0 r = len(matrix) c = len(matrix[0]) max_side = 0 # Create a DP array to store the side length of the largest square ending at (i, j) dp = [[0] * c for _ in range(r)] for i in range(r): for j in range(c): if matrix[i][j] == 1: if i == 0 or j == 0: dp[i][j] = 1 else: dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1 max_side = max(max_side, dp[i][j]) return max_side"},{"question":"def is_toeplitz(matrix: list[list[int]]) -> bool: Checks if the given matrix is a Toeplitz matrix. Args: matrix (list[list[int]]): The input 2D list of integers representing the matrix. Returns: bool: True if the matrix is a Toeplitz matrix, False otherwise. >>> is_toeplitz([[1, 2, 3, 4], [5, 1, 2, 3], [6, 5, 1, 2], [7, 6, 5, 1]]) True >>> is_toeplitz([[1, 2, 3, 4], [5, 1, 9, 3], [6, 5, 1, 2], [7, 6, 5, 1]]) False >>> is_toeplitz([[1]]) True >>> is_toeplitz([]) True","solution":"def is_toeplitz(matrix): Checks if the given matrix is a Toeplitz matrix. Args: matrix (list[list[int]]): The input 2D list of integers representing the matrix. Returns: bool: True if the matrix is a Toeplitz matrix, False otherwise. if not matrix or not matrix[0]: return True rows = len(matrix) cols = len(matrix[0]) for row in range(1, rows): for col in range(1, cols): if matrix[row][col] != matrix[row - 1][col - 1]: return False return True"},{"question":"def sum_combinations(n: int) -> list[list[int]]: Find and return all unique combinations of positive integers that sum up to a given number n. Parameters: n (int): The target integer to reach using combinations of positive integers. Returns: list[list[int]]: A list of lists, where each inner list contains a combination of integers that add up to n. Raises: ValueError: If the input n is not a positive integer. Examples: >>> sum_combinations(4) [[1, 1, 1, 1], [1, 1, 2], [1, 3], [2, 2], [4]] >>> sum_combinations(3) [[1, 1, 1], [1, 2], [3]] >>> sum_combinations(1) [[1]] >>> sum_combinations(0) ValueError: Sum must be a positive integer","solution":"def sum_combinations(n: int) -> list[list[int]]: if n <= 0: raise ValueError(\\"Sum must be a positive integer\\") def find_combinations(target, start, path, result): if target == 0: result.append(path) return for i in range(start, n + 1): if target - i >= 0: find_combinations(target - i, i, path + [i], result) result = [] find_combinations(n, 1, [], result) return result"},{"question":"class Inventory: def __init__(self): Initialize the Inventory class with an empty dictionary. pass def add_product(self, product_name: str, quantity: int): Adds a new product with the given quantity. If the product already exists, update its quantity to the new value. >>> inv = Inventory() >>> inv.add_product('apple', 10) >>> inv.list_products() {'apple': 10} pass def remove_product(self, product_name: str): Removes the product from the inventory if it exists. >>> inv = Inventory() >>> inv.add_product('apple', 10) >>> inv.remove_product('apple') >>> inv.list_products() {} pass def update_quantity(self, product_name: str, quantity: int): Updates the quantity of the specified product. If the product does not exist, it raises a ValueError. >>> inv = Inventory() >>> inv.add_product('apple', 10) >>> inv.update_quantity('apple', 15) >>> inv.list_products() {'apple': 15} >>> inv.update_quantity('orange', 5) Traceback (most recent call last): ... ValueError: Product 'orange' does not exist. pass def list_products(self) -> dict: Returns the dictionary of all products and their quantities. >>> inv = Inventory() >>> inv.add_product('apple', 10) >>> inv.add_product('banana', 5) >>> inv.list_products() {'apple': 10, 'banana': 5} pass","solution":"class Inventory: def __init__(self): self.products = {} def add_product(self, product_name: str, quantity: int): Adds a product with the specified quantity. If the product already exists, update its quantity. self.products[product_name] = quantity def remove_product(self, product_name: str): Removes the product from the inventory if it exists. if product_name in self.products: del self.products[product_name] else: raise ValueError(f\\"Product '{product_name}' does not exist.\\") def update_quantity(self, product_name: str, quantity: int): Updates the quantity of the specified product. Raises ValueError if the product does not exist. if product_name in self.products: self.products[product_name] = quantity else: raise ValueError(f\\"Product '{product_name}' does not exist.\\") def list_products(self) -> dict: Returns the dictionary of products and their quantities. return self.products"},{"question":"from typing import List def knapsack_max_value(weights: List[int], values: List[int], W: int) -> int: Determine the maximum value that can be obtained by selecting items such that their total weight does not exceed a given limit W. Args: weights: A list of integers representing weights of the items. values: A list of integers representing values of the items. W: An integer representing the maximum weight capacity of the knapsack. Returns: An integer representing the maximum value that can be obtained. Examples: >>> knapsack_max_value([1, 2, 3], [10, 15, 40], 6) 65 >>> knapsack_max_value([1, 3, 4, 5], [1, 4, 5, 7], 7) 9 >>> knapsack_max_value([2, 3, 4, 5], [1, 2, 5, 6], 8) 8 >>> knapsack_max_value([3, 1, 2], [5, 1, 3], 5) 8 >>> knapsack_max_value([10, 20, 30], [60, 100, 120], 50) 220","solution":"def knapsack_max_value(weights, values, W): n = len(weights) # Initialize DP table dp = [[0 for _ in range(W + 1)] for _ in range(n + 1)] # Fill the DP table for i in range(1, n + 1): for w in range(1, W + 1): if weights[i - 1] <= w: dp[i][w] = max(dp[i - 1][w], values[i - 1] + dp[i - 1][w - weights[i - 1]]) else: dp[i][w] = dp[i - 1][w] return dp[n][W]"},{"question":"def calculate_compression_ratio( original_size: float, compressed_size: float ) -> tuple[str, float]: Calculates the compression ratio based on the original and compressed sizes. Classifies the efficiency of compression. Args: original_size (float): The size of the original data. compressed_size (float): The size of the compressed data. Returns: tuple[str, float]: A tuple containing the classification and compression ratio. Raises: ValueError: If any of the sizes are not positive and non-zero. >>> calculate_compression_ratio(1000, 250) ('High Efficiency', 0.25) >>> calculate_compression_ratio(1000, 750) ('Low Efficiency', 0.75) >>> calculate_compression_ratio(0, 200) Traceback (most recent call last): ... ValueError: Sizes must be positive and non-zero >>> calculate_compression_ratio(-100, 300) Traceback (most recent call last): ... ValueError: Sizes must be positive and non-zero","solution":"def calculate_compression_ratio(original_size: float, compressed_size: float) -> tuple[str, float]: Calculates the compression ratio based on the original and compressed sizes. Classifies the efficiency of compression. Args: - original_size (float): The size of the original data. - compressed_size (float): The size of the compressed data. Returns: - tuple[str, float]: A tuple containing the classification and compression ratio. Raises: - ValueError: If any of the sizes are not positive and non-zero. if original_size <= 0 or compressed_size <= 0: raise ValueError(\\"Sizes must be positive and non-zero\\") compression_ratio = compressed_size / original_size if compression_ratio <= 0.3: return (\\"High Efficiency\\", compression_ratio) elif compression_ratio <= 0.7: return (\\"Moderate Efficiency\\", compression_ratio) else: return (\\"Low Efficiency\\", compression_ratio)"},{"question":"def longest_increasing_subsequence(nums: List[int]) -> int: Function to find the length of the longest increasing subsequence in a given list of integers representing stock prices. Examples: >>> longest_increasing_subsequence([10, 9, 2, 5, 3, 7, 101, 18]) 4 >>> longest_increasing_subsequence([0, 1, 0, 3, 2, 3]) 4 >>> longest_increasing_subsequence([7, 7, 7, 7, 7, 7]) 1 >>> longest_increasing_subsequence([]) 0 >>> longest_increasing_subsequence([10]) 1 >>> longest_increasing_subsequence([1, 2, 3, 4, 5]) 5 >>> longest_increasing_subsequence([5, 4, 3, 2, 1]) 1","solution":"from typing import List def longest_increasing_subsequence(nums: List[int]) -> int: Function to find the length of the longest increasing subsequence in a given list of integers. if not nums: return 0 dp = [1] * len(nums) for i in range(1, len(nums)): for j in range(i): if nums[i] > nums[j]: dp[i] = max(dp[i], dp[j] + 1) return max(dp)"},{"question":"def can_reach_target(m: int, n: int, s: int) -> bool: Returns True if it is possible to reach the bottom-right cell of an m x n grid starting from the top-left cell with exactly s steps, where each step is either moving right or down. >>> can_reach_target(2, 2, 2) True >>> can_reach_target(2, 2, 3) False >>> can_reach_target(3, 3, 4) True >>> can_reach_target(3, 3, 5) False","solution":"def can_reach_target(m: int, n: int, s: int) -> bool: Returns True if it is possible to reach the bottom-right cell of an m x n grid starting from the top-left cell with exactly s steps, where each step is either moving right or down. # The minimum number of steps required to reach the bottom-right corner min_steps = (m - 1) + (n - 1) # Check if the exact number of steps s matches min_steps added with any number of extra moves return s >= min_steps and (s - min_steps) % 2 == 0"},{"question":"def is_arithmetic_sequence(arr: list) -> bool: Check if the given list of integers forms an arithmetic sequence. >>> is_arithmetic_sequence([1, 3, 5, 7, 9]) True >>> is_arithmetic_sequence([2, 4, 8, 16]) False >>> is_arithmetic_sequence([-5, -2, 1, 4, 7]) True >>> is_arithmetic_sequence([0, 0, 0, 0, 0]) True >>> is_arithmetic_sequence([]) True >>> is_arithmetic_sequence([42]) True >>> is_arithmetic_sequence([5, 10]) True >>> is_arithmetic_sequence([1, 2, 4, 8, 16]) False >>> is_arithmetic_sequence([-3, -1, 1, 3, 5]) True >>> is_arithmetic_sequence([1000000, 999999, 999998]) True >>> is_arithmetic_sequence([1000000, 999998, 999995]) False >>> is_arithmetic_sequence([10, 20, 30, 40, 50]) True >>> is_arithmetic_sequence([10, 20, 25, 30]) False","solution":"def is_arithmetic_sequence(arr: list) -> bool: Check if the given list of integers forms an arithmetic sequence. if len(arr) <= 1: return True common_difference = arr[1] - arr[0] for i in range(2, len(arr)): if arr[i] - arr[i-1] != common_difference: return False return True"},{"question":"def shortest_path_with_constraints(roads: list[tuple[int, int, int]], source: int, destination: int, blocked: list[tuple[int, int]]) -> int: Calculates the shortest travel time between two cities given a set of blocked roads. >>> shortest_path_with_constraints([(1, 2, 10), (2, 3, 10), (1, 3, 20)], 1, 3, [(1, 2)]) 20 >>> shortest_path_with_constraints([(1, 2, 10), (2, 3, 10), (1, 3, 50)], 1, 3, [(1, 2), (1, 3)]) -1 >>> shortest_path_with_constraints([(1, 2, 10), (3, 4, 50), (1, 3, 5), (3, 2, 1)], 1, 4, []) 55 >>> shortest_path_with_constraints([(1, 2, 10), (2, 3, 10), (1, 3, 20), (3, 4, 10)], 1, 4, [(1, 2), (2, 3)]) 30 >>> shortest_path_with_constraints([(1, 2, 10), (2, 3, 10), (1, 3, 5)], 1, 3, [(2, 3)]) 5","solution":"import heapq def shortest_path_with_constraints(roads, source, destination, blocked): # Create an adjacency list for graph representation graph = {} for u, v, t in roads: if (u, v) in blocked or (v, u) in blocked: continue if u not in graph: graph[u] = [] if v not in graph: graph[v] = [] graph[u].append((v, t)) graph[v].append((u, t)) # Use a priority queue to implement Dijkstra's algorithm pq = [(0, source)] # (distance, node) distances = {source: 0} while pq: current_distance, current_node = heapq.heappop(pq) if current_node == destination: return current_distance if current_distance > distances.get(current_node, float('inf')): continue for neighbor, weight in graph.get(current_node, []): distance = current_distance + weight if distance < distances.get(neighbor, float('inf')): distances[neighbor] = distance heapq.heappush(pq, (distance, neighbor)) return -1"},{"question":"def permute_unique(nums): Generate all unique permutations of the list of integers. @param nums: a list of integers which may contain duplicates. @return: a list of lists, where each list is a unique permutation of the nums list. pass # Example Input: # nums = [1, 1, 2] # Output: [[1, 1, 2], [1, 2, 1], [2, 1, 1]] # Example Input: # nums = [2, 2, 1, 1] # Output: [[1, 1, 2, 2], [1, 2, 1, 2], [1, 2, 2, 1], # [2, 1, 1, 2], [2, 1, 2, 1], [2, 2, 1, 1]] # Unit Test from solution import permute_unique def test_permute_unique_single_element(): assert permute_unique([1]) == [[1]] def test_permute_unique_two_elements(): assert permute_unique([1, 1]) == [[1, 1]] def test_permute_unique_three_elements(): assert permute_unique([1, 2, 3]) == [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]] def test_permute_unique_with_duplicates(): result = permute_unique([1, 1, 2]) expected = [[1, 1, 2], [1, 2, 1], [2, 1, 1]] assert sorted(result) == sorted(expected) def test_permute_unique_four_elements_with_duplicates(): result = permute_unique([2, 2, 1, 1]) expected = [[1, 1, 2, 2], [1, 2, 1, 2], [1, 2, 2, 1], [2, 1, 1, 2], [2, 1, 2, 1], [2, 2, 1, 1]] assert sorted(result) == sorted(expected) def test_permute_unique_no_duplicates(): result = permute_unique([1, 2, 3]) expected = [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]] assert sorted(result) == sorted(expected) def test_permute_unique_empty_list(): assert permute_unique([]) == [[]]","solution":"def permute_unique(nums): from collections import Counter def backtrack(combination, counter): if len(combination) == len(nums): result.append(list(combination)) return for num in counter: if counter[num] > 0: combination.append(num) counter[num] -= 1 backtrack(combination, counter) combination.pop() counter[num] += 1 result = [] counter = Counter(nums) backtrack([], counter) return result"},{"question":"def largest_connected_component(friends: Dict[int, List[int]]) -> List[int]: Find the largest connected component in an undirected graph representing the network. >>> largest_connected_component({1: [2, 3], 2: [1, 4], 3: [1], 4: [2], 5: [6], 6: [5, 7], 7: [6]}) [1, 2, 3, 4] >>> largest_connected_component({1: [2], 2: [1, 3], 3: [2], 4: [5], 5: [4]}) [1, 2, 3] >>> largest_connected_component({1: [2], 2: [1], 3: [4], 4: [3]}) [1, 2] >>> largest_connected_component({}) [] >>> largest_connected_component({1: []}) [1] >>> largest_connected_component({1: [2, 3], 2: [1, 4], 3: [1, 5], 4: [2], 5: [3, 6], 6: [5]}) [1, 2, 3, 4, 5, 6]","solution":"from typing import Dict, List def largest_connected_component(friends: Dict[int, List[int]]) -> List[int]: def bfs(node): queue = [node] visited.add(node) component = [] while queue: current = queue.pop(0) component.append(current) for neighbor in friends[current]: if neighbor not in visited: visited.add(neighbor) queue.append(neighbor) return sorted(component) visited = set() largest_component = [] for node in friends: if node not in visited: component = bfs(node) if len(component) > len(largest_component): largest_component = component return largest_component"},{"question":"from typing import List def merge_sort(lst: List[int]) -> List[int]: Recursively divides the list into halves and merges them in sorted order. >>> merge_sort([34, 7, 23, 32, 5, 62]) [5, 7, 23, 32, 34, 62] >>> merge_sort([12, 11, 13, 5, 6, 7]) [5, 6, 7, 11, 12, 13] >>> merge_sort([-3, -1, -7, -5, 0, 2, 1]) [-7, -5, -3, -1, 0, 1, 2] >>> merge_sort([3, 5, 3, 9, 8, 3, 1]) [1, 3, 3, 3, 5, 8, 9] >>> merge_sort([5]) [5] >>> merge_sort([]) [] >>> merge_sort([1, 2, 3, 4, 5]) [1, 2, 3, 4, 5] >>> merge_sort([5, 4, 3, 2, 1]) [1, 2, 3, 4, 5]","solution":"from typing import List def merge_sort(lst: List[int]) -> List[int]: Recursively divides the list into halves and merges them in sorted order. if len(lst) <= 1: return lst mid = len(lst) // 2 left_half = merge_sort(lst[:mid]) right_half = merge_sort(lst[mid:]) return merge(left_half, right_half) def merge(left: List[int], right: List[int]) -> List[int]: Merges two sorted lists into one sorted list. sorted_list = [] left_index, right_index = 0, 0 # Merge the two lists by comparing their elements while left_index < len(left) and right_index < len(right): if left[left_index] < right[right_index]: sorted_list.append(left[left_index]) left_index += 1 else: sorted_list.append(right[right_index]) right_index += 1 # If there are remaining elements in the left or right list, add them sorted_list.extend(left[left_index:]) sorted_list.extend(right[right_index:]) return sorted_list"},{"question":"from typing import List def max_consecutive_integers(data: List[int]) -> int: Determine the maximum length of any contiguous subarray where all elements are the same. >>> max_consecutive_integers([1, 1, 2, 2, 2, 3]) 3 >>> max_consecutive_integers([4, 4, 4, 4, 4]) 5 >>> max_consecutive_integers([1, 2, 3, 4, 5]) 1 >>> max_consecutive_integers([]) 0 >>> max_consecutive_integers([5, 5, 5, 1, 1, 1, 5, 5]) 3","solution":"from typing import List def max_consecutive_integers(data: List[int]) -> int: # Edge case: if the list is empty, return 0 if not data: return 0 max_len = current_len = 1 # Initialize lengths for i in range(1, len(data)): if data[i] == data[i - 1]: current_len += 1 # Increment length of current consecutive segment else: max_len = max(max_len, current_len) # Update max length if current is greater current_len = 1 # Reset current length for a new segment return max(max_len, current_len) # Consider the last segment"},{"question":"def compress_string(s: str) -> str: Compresses the string using Run Length Encoding, where repeated characters are replaced by the character followed by the number of repetitions. If the compressed string is not shorter than the original string, returns the original string. >>> compress_string(\\"aabcccccaaa\\") \\"a2b1c5a3\\" >>> compress_string(\\"abc\\") \\"abc\\" >>> compress_string(\\"AaaBBbCccDd\\") \\"AaaBBbCccDd\\"","solution":"def compress_string(s: str) -> str: Compresses the string using Run Length Encoding, where repeated characters are replaced by the character followed by the number of repetitions. If the compressed string is not shorter than the original string, returns the original string. if not s: return s compressed = [] count = 1 for i in range(1, len(s)): if s[i] == s[i - 1]: count += 1 else: compressed.append(s[i - 1]) compressed.append(str(count)) count = 1 # Don't forget to add the last accumulated character and its count compressed.append(s[-1]) compressed.append(str(count)) compressed_string = ''.join(compressed) return compressed_string if len(compressed_string) < len(s) else s"},{"question":"class SortedList: def __init__(self): self.list = [] def add_element(self, element: int) -> None: Add an element to the list and keep it sorted. >>> s_list = SortedList() >>> s_list.add_element(10) >>> s_list.add_element(20) >>> s_list.add_element(5) >>> s_list.add_element(7) >>> s_list.list [5, 7, 10, 20] self.list.append(element) self.list.sort() def binary_search(self, element: int) -> str: Search for an element in the list using binary search. Handle cases where the list is empty, and return appropriate messages or values when the element is not found. >>> s_list = SortedList() >>> s_list.add_element(10) >>> s_list.add_element(20) >>> s_list.add_element(5) >>> s_list.add_element(7) >>> s_list.binary_search(7) 'Element 7 found at index 1' >>> s_list.binary_search(15) 'Element 15 not found' >>> s_list.binary_search(10) 'Element 10 found at index 2' >>> empty_list = SortedList() >>> empty_list.binary_search(7) 'Error: List is empty'","solution":"class SortedList: def __init__(self): self.list = [] def add_element(self, element: int) -> None: self.list.append(element) self.list.sort() def binary_search(self, element: int) -> str: if not self.list: return \\"Error: List is empty\\" left, right = 0, len(self.list) - 1 while left <= right: mid = (left + right) // 2 if self.list[mid] == element: return f\\"Element {element} found at index {mid}\\" elif self.list[mid] < element: left = mid + 1 else: right = mid - 1 return f\\"Element {element} not found\\" if __name__ == \\"__main__\\": s_list = SortedList() s_list.add_element(10) s_list.add_element(20) s_list.add_element(5) s_list.add_element(7) print(s_list.list) print(s_list.binary_search(7)) print(s_list.binary_search(15)) print(s_list.binary_search(10)) empty_list = SortedList() print(empty_list.binary_search(7))"},{"question":"import heapq import time from typing import Optional, Any class KeyValueStore: def __init__(self): self.store = {} self.expiry_heap = [] def set(self, key: str, value: Any, expire_in: Optional[int] = None): Store the key-value pair with an optional expiry time in seconds. >>> store = KeyValueStore() >>> store.set(\\"foo\\", \\"bar\\", expire_in=5) >>> store.get(\\"foo\\") 'bar' >>> time.sleep(6) >>> store.get(\\"foo\\") None def get(self, key: str): Retrieve the value for the given key, considering its expiry time. >>> store = KeyValueStore() >>> store.set(\\"foo\\", \\"bar\\", expire_in=5) >>> store.get(\\"foo\\") 'bar' >>> time.sleep(6) >>> store.get(\\"foo\\") None def delete(self, key: str): Manually remove a key-value pair from the store. >>> store = KeyValueStore() >>> store.set(\\"foo\\", \\"bar\\") >>> store.delete(\\"foo\\") >>> store.get(\\"foo\\") None def cleanup(self): Periodically remove expired entries from the store. def test_set_and_get(): store = KeyValueStore() store.set(\\"foo\\", \\"bar\\") assert store.get(\\"foo\\") == \\"bar\\" def test_expired_key(): store = KeyValueStore() store.set(\\"foo\\", \\"bar\\", expire_in=1) time.sleep(2) assert store.get(\\"foo\\") is None def test_delete_key(): store = KeyValueStore() store.set(\\"foo\\", \\"bar\\") store.delete(\\"foo\\") assert store.get(\\"foo\\") is None def test_non_expired_key(): store = KeyValueStore() store.set(\\"foo\\", \\"bar\\", expire_in=5) time.sleep(2) assert store.get(\\"foo\\") == \\"bar\\" def test_cleanup_expired_keys(): store = KeyValueStore() store.set(\\"foo\\", \\"bar\\", expire_in=1) store.set(\\"baz\\", \\"buzz\\", expire_in=3) time.sleep(2) assert store.get(\\"foo\\") is None assert store.get(\\"baz\\") == \\"buzz\\" store.cleanup() assert store.get(\\"foo\\") is None def test_set_multiple_keys(): store = KeyValueStore() store.set(\\"key1\\", \\"value1\\", expire_in=3) store.set(\\"key2\\", \\"value2\\", expire_in=5) time.sleep(4) assert store.get(\\"key1\\") is None assert store.get(\\"key2\\") == \\"value2\\"","solution":"import heapq import time class KeyValueStore: def __init__(self): self.store = {} self.expiry_heap = [] def set(self, key, value, expire_in=None): expiry_time = time.time() + expire_in if expire_in is not None else None self.store[key] = (value, expiry_time) if expiry_time is not None: heapq.heappush(self.expiry_heap, (expiry_time, key)) def get(self, key): self.cleanup() if key in self.store: value, expiry_time = self.store[key] if expiry_time is None or expiry_time > time.time(): return value return None def delete(self, key): if key in self.store: del self.store[key] def cleanup(self): current_time = time.time() while self.expiry_heap and self.expiry_heap[0][0] <= current_time: _, key = heapq.heappop(self.expiry_heap) if key in self.store and self.store[key][1] <= current_time: del self.store[key]"},{"question":"from typing import List, Tuple def compress_image(image: List[List[int]]) -> List[Tuple[int, int]]: Compress a 2D image using Run-Length Encoding. :param image: List[List[int]] - A 2D list of integers representing the pixel values. :return: List[Tuple[int, int]] - A list of tuples representing the pixel values and their run lengths. >>> compress_image([[1, 1, 1, 2, 2], [3, 3, 3, 3, 1], [2, 2, 1, 1, 1]]) == [(1, 3), (2, 2), (3, 4), (1, 1), (2, 2), (1, 3)] >>> compress_image([]) == [] pass def decompress_image(compressed_image: List[Tuple[int, int]], rows: int, cols: int) -> List[List[int]]: Decompress a Run-Length Encoded image back to its original 2D format. :param compressed_image: List[Tuple[int, int]] - A list of tuples generated by the compression function. :param rows: int - The number of rows in the original image. :param cols: int - The number of columns in the original image. :return: List[List[int]] - The reconstructed 2D list of integers representing the decompressed image. >>> decompress_image([(1, 3), (2, 2), (3, 4), (1, 1), (2, 2), (1, 3)], 3, 5) == [[1, 1, 1, 2, 2], [3, 3, 3, 3, 1], [2, 2, 1, 1, 1]] >>> decompress_image([], 3, 5) == [[], [], []] pass","solution":"from typing import List, Tuple def compress_image(image: List[List[int]]) -> List[Tuple[int, int]]: Compress a 2D image using Run-Length Encoding. :param image: List[List[int]] - A 2D list of integers representing the pixel values. :return: List[Tuple[int, int]] - A list of tuples representing the pixel values and their run lengths. if not image or not image[0]: return [] compressed = [] for row in image: current_pixel = row[0] count = 1 for pixel in row[1:]: if pixel == current_pixel: count += 1 else: compressed.append((current_pixel, count)) current_pixel = pixel count = 1 compressed.append((current_pixel, count)) return compressed def decompress_image(compressed_image: List[Tuple[int, int]], rows: int, cols: int) -> List[List[int]]: Decompress a Run-Length Encoded image back to its original 2D format. :param compressed_image: List[Tuple[int, int]] - A list of tuples generated by the compression function. :param rows: int - The number of rows in the original image. :param cols: int - The number of columns in the original image. :return: List[List[int]] - The reconstructed 2D list of integers representing the decompressed image. if not compressed_image: return [[] for _ in range(rows)] decompressed = [] row = [] for (pixel, count) in compressed_image: while count > 0: if len(row) < cols: row.append(pixel) count -= 1 if len(row) == cols: decompressed.append(row) row = [] return decompressed"},{"question":"# Function Signature def multiplication_table(n: int, m: int) -> List[List[int]]: Generate the multiplication table for integers from 1 to n with each value multiplied by m. if not isinstance(n, int) or not isinstance(m, int) or n <= 0 or m <= 0: raise ValueError(\\"Both n and m must be positive integers.\\") table = [] for i in range(1, n + 1): row = [] for j in range(1, n + 1): row.append(j * m * i) table.append(row) return table","solution":"def multiplication_table(n: int, m: int): Generate the multiplication table for integers from 1 to n with each value multiplied by m. if not isinstance(n, int) or not isinstance(m, int) or n <= 0 or m <= 0: raise ValueError(\\"Both n and m must be positive integers.\\") table = [] for i in range(1, n + 1): row = [] for j in range(1, n + 1): row.append(j * m * i) table.append(row) return table"},{"question":"import re from collections import defaultdict def extract_numbers(text: str) -> list: Extracts all the numbers from the input text and returns a list of integers. >>> extract_numbers(\\"123 apples and 987 bananas were sold for 456 and 123 more\\") [123, 987, 456, 123] >>> extract_numbers(\\"There are 2 cats and 5 dogs, 2 mice, and 3 birds.\\") [2, 5, 2, 3] >>> extract_numbers(\\"No numbers here!\\") [] def count_frequencies(numbers: list) -> dict: Takes a list of integers and returns a dictionary where keys are the unique numbers and values are the frequency counts of each number. >>> count_frequencies([123, 987, 456, 123]) {123: 2, 987: 1, 456: 1} >>> count_frequencies([2, 5, 2, 3]) {2: 2, 5: 1, 3: 1} >>> count_frequencies([]) {} def test_extract_numbers(): assert extract_numbers(\\"123 apples and 987 bananas were sold for 456 and 123 more\\") == [123, 987, 456, 123] assert extract_numbers(\\"There are 2 cats and 5 dogs, 2 mice, and 3 birds.\\") == [2, 5, 2, 3] assert extract_numbers(\\"No numbers here!\\") == [] assert extract_numbers(\\"# 1 # 22 # 333 #\\") == [1, 22, 333] assert extract_numbers(\\"100.50 and 2000.75\\") == [100, 50, 2000, 75] def test_count_frequencies(): assert count_frequencies([123, 987, 456, 123]) == {123: 2, 987: 1, 456: 1} assert count_frequencies([2, 5, 2, 3]) == {2: 2, 5: 1, 3: 1} assert count_frequencies([]) == {} assert count_frequencies([1, 22, 333, 22, 1, 333, 333]) == {1: 2, 22: 2, 333: 3} if __name__ == \\"__main__\\": test_extract_numbers() test_count_frequencies() print(\\"All tests passed.\\")","solution":"import re from collections import defaultdict def extract_numbers(text: str) -> list: Extracts all the numbers from the input text and returns a list of integers. # Extract all the numbers using regex numbers = re.findall(r'd+', text) return list(map(int, numbers)) def count_frequencies(numbers: list) -> dict: Takes a list of integers and returns a dictionary where keys are the unique numbers and values are the frequency counts of each number. frequency_dict = defaultdict(int) for number in numbers: frequency_dict[number] += 1 return dict(frequency_dict)"},{"question":"from typing import List def autocomplete(words: List[str], prefix: str) -> List[str]: Implement a text autocompletion system for a given list of words. The system will take a list of words as the dictionary and a prefix string. It will return all words from the dictionary that start with the given prefix, sorted in lexicographical order. >>> autocomplete([\\"apple\\", \\"app\\", \\"apricot\\", \\"banana\\", \\"bat\\", \\"ball\\", \\"batman\\"], \\"ap\\") [\\"app\\", \\"apple\\", \\"apricot\\"] >>> autocomplete([\\"apple\\", \\"app\\", \\"apricot\\", \\"banana\\", \\"bat\\", \\"ball\\", \\"batman\\"], \\"z\\") [] >>> autocomplete([\\"apple\\", \\"app\\", \\"apricot\\", \\"banana\\", \\"bat\\", \\"ball\\", \\"batman\\"], \\"apple\\") [\\"apple\\"] >>> autocomplete([\\"apple\\", \\"app\\", \\"apricot\\", \\"banana\\", \\"bat\\", \\"ball\\", \\"batman\\"], \\"batman\\") [\\"batman\\"] >>> autocomplete([\\"app\\", \\"apple\\", \\"application\\", \\"appetizer\\", \\"app\\"], \\"app\\") [\\"app\\", \\"app\\", \\"appetizer\\", \\"apple\\", \\"application\\"] >>> autocomplete([\\"app\\", \\"apple\\", \\"application\\", \\"appetizer\\", \\"app\\"], \\"orange\\") []","solution":"from typing import List def autocomplete(words: List[str], prefix: str) -> List[str]: Returns a list of words from the dictionary that start with the given prefix, sorted lexicographically. matching_words = [word for word in words if word.startswith(prefix)] return sorted(matching_words)"},{"question":"class CircularBuffer: Circular Buffer (Ring Buffer) with Dynamic Resizing. Circular buffers are fixed-size data structures that operate in a FIFO (First-In-First-Out) manner. When the buffer is full and new data is added, the oldest data is overwritten. Args: capacity (int): The initial capacity of the buffer. Methods: add(value: int) -> None: Adds an element to the buffer. get() -> int: Retrieves and removes the oldest element from the buffer. size() -> int: Returns the number of elements in the buffer. is_empty() -> bool: Returns True if the buffer is empty, False otherwise. def __init__(self, capacity: int): pass def add(self, value: int) -> None: pass def get(self) -> int: pass def size(self) -> int: pass def is_empty(self) -> bool: pass # Example Usage: buffer = CircularBuffer(3) buffer.add(1) buffer.add(2) buffer.add(3) print(buffer.size()) # Output: 3 print(buffer.get()) # Output: 1 print(buffer.size()) # Output: 2 buffer.add(4) buffer.add(5) # Buffer resizes here print(buffer.size()) # Output: 4 print(buffer.get()) # Output: 2 print(buffer.is_empty()) # Output: False","solution":"class CircularBuffer: def __init__(self, capacity: int): if capacity <= 0: raise ValueError(\\"Capacity must be a positive integer\\") self.buffer = [None] * capacity self.capacity = capacity self.start = 0 self.end = 0 self.count = 0 def add(self, value: int) -> None: if self.count == self.capacity: self._resize() self.buffer[self.end] = value self.end = (self.end + 1) % self.capacity self.count += 1 def _resize(self) -> None: new_capacity = self.capacity * 2 new_buffer = [None] * new_capacity for i in range(self.count): new_buffer[i] = self.buffer[(self.start + i) % self.capacity] self.buffer = new_buffer self.start = 0 self.end = self.count self.capacity = new_capacity def get(self) -> int: if self.is_empty(): raise IndexError(\\"get from empty buffer\\") value = self.buffer[self.start] self.buffer[self.start] = None self.start = (self.start + 1) % self.capacity self.count -= 1 return value def size(self) -> int: return self.count def is_empty(self) -> bool: return self.count == 0"},{"question":"[Completion Task in Python] def climb_stairs(n: int) -> int: Calculates the number of unique ways to climb a staircase with \`n\` steps where you can take either 1 or 2 steps at a time. :param n: The total number of steps in the staircase :return: Number of distinct ways to climb to the top Example: >>> climb_stairs(5) 8 if n == 1: return 1 # Initialize the base cases a, b = 1, 1 # Iterate from 2 to n to build up the solution for _ in range(2, n + 1): a, b = b, a + b return b","solution":"def climb_stairs(n: int) -> int: Calculates the number of unique ways to climb a staircase with \`n\` steps where you can take either 1 or 2 steps at a time. :param n: The total number of steps in the staircase :return: Number of distinct ways to climb to the top Example: >>> climb_stairs(5) 8 if n == 1: return 1 # Initialize the base cases a, b = 1, 1 # Iterate from 2 to n to build up the solution for _ in range(2, n + 1): a, b = b, a + b return b"},{"question":"def is_valid_email(email_address: str) -> bool: Validate the given email address based on specified criteria. Parameters: ----------- email_address: str The email address to be validated. Returns: -------- bool A boolean indicating whether the email address is valid based on the given criteria. Raises: ------- ValueError If the input is not a string or if it is an empty string. >>> is_valid_email(\\"example.user@domain.com\\") True >>> is_valid_email(\\"example.user@mail.server.info\\") True >>> is_valid_email(\\"example@user@domain.com\\") False >>> is_valid_email(\\"example.user@\\") False >>> is_valid_email(\\"@domain.com\\") False >>> is_valid_email(\\"user_name@domain.co.uk\\") True >>> is_valid_email(\\"user@dom.longtld\\") False >>> is_valid_email(123) ValueError('Input Error: Email address must be a non-empty string.') >>> is_valid_email(\\"\\") ValueError('Input Error: Email address must be a non-empty string.') >>> is_valid_email(\\"user-name@domain.com\\") True >>> is_valid_email(\\"user_name@domain.com\\") True","solution":"import re def is_valid_email(email_address: str) -> bool: Validate the given email address based on specified criteria. Parameters: ----------- email_address: str The email address to be validated. Returns: -------- bool A boolean indicating whether the email address is valid based on the given criteria. Raises: ------- ValueError If the input is not a string or if it is an empty string. if not isinstance(email_address, str) or not email_address: raise ValueError('Input Error: Email address must be a non-empty string.') # Regular expression for validating an Email regex = r'^[A-Za-z0-9][A-Za-z0-9._-]*@[A-Za-z0-9.-]+.[A-Za-z]{2,6}' # Matching the regular expression if re.match(regex, email_address): return True return False"},{"question":"def longest_repeating_subsequence(s: str) -> int: Write a function longest_repeating_subsequence that returns the length of the longest subsequence of a given string s that appears more than once in the string. A subsequence should keep the relative order of characters in the original string. >>> longest_repeating_subsequence(\\"aabb\\") 2 >>> longest_repeating_subsequence(\\"abc\\") 0 >>> longest_repeating_subsequence(\\"aab\\") 1 n = len(s) dp = [[0] * (n + 1) for _ in range(n + 1)] for i in range(1, n + 1): for j in range(1, n + 1): if s[i - 1] == s[j - 1] and i != j: dp[i][j] = 1 + dp[i - 1][j - 1] else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) return dp[n][n]","solution":"def longest_repeating_subsequence(s: str) -> int: n = len(s) dp = [[0] * (n + 1) for _ in range(n + 1)] for i in range(1, n + 1): for j in range(1, n + 1): if s[i - 1] == s[j - 1] and i != j: dp[i][j] = 1 + dp[i - 1][j - 1] else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) return dp[n][n]"},{"question":"from collections import deque class PagingSystem: def __init__(self, number_of_frames: int) -> None: self.number_of_frames = number_of_frames self.frames = [-1] * number_of_frames # Initialize memory frames self.page_faults = 0 self.lru_queue = deque() # Queue to keep track of LRU order self.frame_map = {} # Dictionary to keep track of pages in frames def page_fault_handler(self, page_requests: list[int]) -> tuple[int, list[int]]: Function to handle page faults using the LRU page replacement algorithm. >>> system = PagingSystem(3) >>> system.page_fault_handler([1, 2, 3]) (3, [1, 2, 3]) >>> system = PagingSystem(3) >>> system.page_fault_handler([1, 2, 3, 4]) (4, [4, 2, 3]) >>> system = PagingSystem(2) >>> system.page_fault_handler([1, 2, 1, 3]) (3, [1, 3]) >>> system = PagingSystem(3) >>> system.page_fault_handler([1, 2, 3, 1, 4]) (4, [1, 4, 3]) >>> system = PagingSystem(1) >>> system.page_fault_handler([1, 2, 3, 4]) (4, [4]) >>> system = PagingSystem(1) >>> system.page_fault_handler([1, 1, 1, 1]) (1, [1]) pass","solution":"from collections import deque class PagingSystem: def __init__(self, number_of_frames: int) -> None: self.number_of_frames = number_of_frames self.frames = [-1] * number_of_frames # Initialize memory frames self.page_faults = 0 self.lru_queue = deque() # Queue to keep track of LRU order self.frame_map = {} # Dictionary to keep track of pages in frames def page_fault_handler(self, page_requests: list[int]) -> tuple[int, list[int]]: Function to handle page faults using the LRU page replacement algorithm. for page in page_requests: if page not in self.frame_map: # Page fault occurs self.page_faults += 1 if len(self.lru_queue) < self.number_of_frames: # There is still space in frames for i in range(self.number_of_frames): if self.frames[i] == -1: self.frames[i] = page self.frame_map[page] = i break else: # Need to replace LRU page lru_page = self.lru_queue.popleft() lru_index = self.frame_map.pop(lru_page) self.frames[lru_index] = page self.frame_map[page] = lru_index else: # Page is already in memory, update LRU queue self.lru_queue.remove(page) self.lru_queue.append(page) return self.page_faults, self.frames if __name__ == \\"__main__\\": number_of_frames = 4 page_requests = [1, 3, 0, 3, 5, 6, 3] system = PagingSystem(number_of_frames) page_faults, final_frames = system.page_fault_handler(page_requests) print(f\\"Page Faults: {page_faults}\\") print(f\\"Final Memory Frames: {final_frames}\\")"},{"question":"def is_balanced(expression: str) -> bool: Returns True if the parentheses/brackets in the given expression are balanced, else returns False. >>> is_balanced(\\"(){}[]\\") == True >>> is_balanced(\\"({[()]})\\") == True >>> is_balanced(\\"{[(])}\\") == False >>> is_balanced(\\"(({{[[]]}}))\\") == True >>> is_balanced(\\"[({})](]\\") == False","solution":"def is_balanced(expression: str) -> bool: Returns True if the parentheses/brackets in the given expression are balanced, else returns False. stack = [] matching_bracket = {')': '(', '}': '{', ']': '['} for char in expression: if char in matching_bracket.values(): stack.append(char) elif char in matching_bracket.keys(): if stack == [] or matching_bracket[char] != stack.pop(): return False return stack == []"},{"question":"def shortest_path(connections: dict[int, list[int]], start: int, end: int) -> list[int]: Find the shortest path of friendship connections (degree of separation) between two users in a social network graph. Args: connections (dict[int, list[int]]): A dictionary representing the social network as an adjacency list. start (int): The user ID where the search starts. end (int): The user ID where the search ends. Returns: list[int]: A list of user IDs representing the shortest path of connections from start to end. If no such path exists, return an empty list. Examples: >>> shortest_path( ... { ... 1: [2, 3], ... 2: [1, 4], ... 3: [1, 4], ... 4: [2, 3, 5], ... 5: [4] ... }, ... 1, ... 5 ... ) [1, 2, 4, 5] >>> shortest_path( ... { ... 1: [2], ... 2: [1, 3], ... 3: [2, 4], ... 4: [3] ... }, ... 1, ... 5 ... ) []","solution":"from collections import deque def shortest_path(connections: dict[int, list[int]], start: int, end: int) -> list[int]: if start not in connections or end not in connections: return [] queue = deque([(start, [start])]) visited = set([start]) while queue: current, path = queue.popleft() if current == end: return path for neighbor in connections[current]: if neighbor not in visited: visited.add(neighbor) queue.append((neighbor, path + [neighbor])) return []"},{"question":"class TextEditor: def __init__(self): Initialize your data structure here. ... def type(self, text: str): Add a new string of characters to the end of the current text. Args: text (str): String to be appended to the current text. ... def undo(self): Revert the last change made to the text. ... def redo(self): Reapply the last undone change. ... def get_text(self) -> str: Get the current text in the editor. Returns: str: Current text in the editor. ... def test_text_editor_operations(): editor = TextEditor() # Test initial state assert editor.get_text() == \\"\\", \\"Test Case 0 Failed\\" # Type some text editor.type('hello') assert editor.get_text() == 'hello', \\"Test Case 1 Failed\\" # Type more text editor.type(' world') assert editor.get_text() == 'hello world', \\"Test Case 2 Failed\\" # Undo the last operation editor.undo() assert editor.get_text() == 'hello', \\"Test Case 3 Failed\\" # Redo the last undone operation editor.redo() assert editor.get_text() == 'hello world', \\"Test Case 4 Failed\\" # Undo twice editor.undo() editor.undo() assert editor.get_text() == '', \\"Test Case 5 Failed\\" # Redo twice editor.redo() editor.redo() assert editor.get_text() == 'hello world', \\"Test Case 6 Failed\\" # Additional complex sequence editor.undo() editor.type('y') assert editor.get_text() == 'helloy', \\"Test Case 7 Failed\\" editor.undo() assert editor.get_text() == 'hello', \\"Test Case 8 Failed\\" editor.redo() assert editor.get_text() == 'helloy', \\"Test Case 9 Failed\\" # Ensure redo stack is cleared after new type editor.type(' again') assert editor.get_text() == 'helloy again', \\"Test Case 10 Failed\\" editor.redo() assert editor.get_text() == 'helloy again', \\"Test Case 11 Failed\\" # No effect as redo stack should be cleared def test_edge_cases(): editor = TextEditor() # Undo without any type (should remain empty) editor.undo() assert editor.get_text() == \\"\\", \\"Edge Case Test 1 Failed\\" # Redo without any undo (should remain empty) editor.redo() assert editor.get_text() == \\"\\", \\"Edge Case Test 2 Failed\\" # Type and undo multiple times editor.type(\\"first\\") assert editor.get_text() == \\"first\\", \\"Edge Case Test 3 Failed\\" editor.undo() assert editor.get_text() == \\"\\", \\"Edge Case Test 4 Failed\\" editor.redo() assert editor.get_text() == \\"first\\", \\"Edge Case Test 5 Failed\\" # Multiple types with undos and redos editor.type(\\" second\\") assert editor.get_text() == \\"first second\\", \\"Edge Case Test 6 Failed\\" editor.undo() assert editor.get_text() == \\"first\\", \\"Edge Case Test 7 Failed\\" editor.undo() assert editor.get_text() == \\"\\", \\"Edge Case Test 8 Failed\\" editor.redo() assert editor.get_text() == \\"first\\", \\"Edge Case Test 9 Failed\\" editor.redo() assert editor.get_text() == \\"first second\\", \\"Edge Case Test 10 Failed\\" # Run the test functions test_text_editor_operations() test_edge_cases()","solution":"class TextEditor: def __init__(self): self.current_text = '' self.history = [] self.undo_stack = [] def type(self, text: str) -> None: self.history.append(self.current_text) self.current_text += text self.undo_stack.clear() def undo(self) -> None: if self.history: self.undo_stack.append(self.current_text) self.current_text = self.history.pop() def redo(self) -> None: if self.undo_stack: self.history.append(self.current_text) self.current_text = self.undo_stack.pop() def get_text(self) -> str: return self.current_text"},{"question":"def is_palindrome(s: str) -> bool: Determines if the given string is a palindrome, ignoring spaces, punctuation, and case differences. Args: s (str): The input string. Returns: bool: True if the string is a palindrome, False otherwise. >>> is_palindrome(\\"A man, a plan, a canal, Panama\\") == True >>> is_palindrome(\\"racecar\\") == True >>> is_palindrome(\\"No lemon, no melon\\") == True >>> is_palindrome(\\"Hello, World!\\") == False >>> is_palindrome(\\"\\") == True pass import re def test_palindrome_with_mixed_cases_and_punctuation(): assert is_palindrome(\\"A man, a plan, a canal, Panama\\") == True def test_palindrome_single_word(): assert is_palindrome(\\"racecar\\") == True def test_palindrome_with_spaces_and_punctuation(): assert is_palindrome(\\"No lemon, no melon\\") == True def test_non_palindrome(): assert is_palindrome(\\"Hello, World!\\") == False def test_empty_string(): assert is_palindrome(\\"\\") == True def test_single_character(): assert is_palindrome(\\"a\\") == True assert is_palindrome(\\"A\\") == True def test_non_alphanumeric_characters(): assert is_palindrome(\\"!!!\\") == True def test_mixed_string_with_numbers(): assert is_palindrome(\\"12321\\") == True assert is_palindrome(\\"12345\\") == False def test_multiline_string(): multiline_string = \\"Able was I, ere I saw Elba\\" assert is_palindrome(multiline_string) == True print(\\"All test cases passed\\")","solution":"import re def is_palindrome(s: str) -> bool: Determines if the given string is a palindrome, ignoring spaces, punctuation, and case differences. Args: s (str): The input string. Returns: bool: True if the string is a palindrome, False otherwise. # Remove non-alphanumeric characters and convert to lower case cleaned = re.sub(r'[^a-zA-Z0-9]', '', s).lower() # Check if cleaned string is equal to its reverse return cleaned == cleaned[::-1]"},{"question":"def find_palindromes(words: list) -> list: This function takes a list of strings and returns a new list containing only the strings that are palindromes. Parameters: words (list): A list of strings. Returns: list: A list of palindromic strings. >>> find_palindromes([\\"madam\\", \\"racecar\\", \\"hello\\", \\"world\\"]) [\\"madam\\", \\"racecar\\"] >>> find_palindromes([\\"a\\", \\"b\\", \\"c\\"]) [\\"a\\", \\"b\\", \\"c\\"] >>> find_palindromes([\\"apple\\", \\"banana\\", \\"cherry\\"]) [] >>> find_palindromes([]) [] >>> find_palindromes([\\"radar\\", \\"level\\", \\"rotor\\"]) [\\"radar\\", \\"level\\", \\"rotor\\"] >>> find_palindromes([\\"Madam\\", \\"Racecar\\", \\"Hello\\", \\"World\\"]) [] >>> find_palindromes([\\"refer\\", \\"deified\\", \\"civic\\", \\"level\\", \\"kayak\\"]) [\\"refer\\", \\"deified\\", \\"civic\\", \\"level\\", \\"kayak\\"] >>> find_palindromes([\\"ab\\", \\"bc\\", \\"cd\\"]) []","solution":"def find_palindromes(words: list) -> list: This function takes a list of strings and returns a new list containing only the strings that are palindromes. Parameters: words (list): A list of strings. Returns: list: A list of palindromic strings. return [word for word in words if word == word[::-1]]"},{"question":"def url_decode(encoded_url: str) -> str: Decodes a URL-encoded string. >>> url_decode(\\"Hello%20World%21\\") \\"Hello World!\\" >>> url_decode(\\"%7Bfoo%7D\\") \\"{foo}\\" >>> url_decode(\\"key%3Dvalue%26other%3Ddata\\") \\"key=value&other=data\\" >>> url_decode(\\"a+%2B+b\\") \\"a + b\\" >>> url_decode(\\"%%7A\\") error: raise ValueError(\\"Malformed URL-encoded string.\\")","solution":"def url_decode(encoded_url: str) -> str: Decodes a URL-encoded string. import re def hex_to_char(match): hex_value = match.group(1) if len(hex_value) != 2 or not re.match(r'^[0-9a-fA-F]{2}', hex_value): raise ValueError(\\"Malformed URL-encoded string.\\") return chr(int(hex_value, 16)) decoded_url = encoded_url.replace('+', ' ') decoded_url = re.sub(r'%([0-9a-fA-F]{2})', hex_to_char, decoded_url) return decoded_url"},{"question":"def rearrange_string(s: str, k: int) -> str: Rearranges the given string \`s\` so that the same characters are at least k distance apart. If it is not possible, returns an empty string. Parameters: s (str): The input string. k (int): The distance each same character must be apart. Returns: str: The rearranged string or an empty string if the rearrangement is not possible. >>> rearrange_string(\\"aabbcc\\", 3) 'abcabc' >>> rearrange_string(\\"aaabc\\", 2) 'abaca' >>> rearrange_string(\\"aaadbbcc\\", 2) 'abacadbc' >>> rearrange_string(\\"aa\\", 2) '' pass","solution":"from heapq import heappush, heappop from collections import deque, Counter def rearrange_string(s, k): if k <= 1: return s # When k is less than or equal to 1, any arrangement is valid # Counter to count frequency of each character char_count = Counter(s) max_heap = [] # Push all characters along with their frequencies into the max heap for char, freq in char_count.items(): heappush(max_heap, (-freq, char)) queue = deque() result = [] while max_heap: freq, char = heappop(max_heap) result.append(char) queue.append((char, freq + 1)) # Reduce frequency if len(queue) >= k: # Maintain a window of size k front_char, front_freq = queue.popleft() if front_freq < 0: # If still pending tasks for this char heappush(max_heap, (front_freq, front_char)) rearranged_string = ''.join(result) # Check if rearranged string meets the requirement return rearranged_string if len(rearranged_string) == len(s) else \\"\\""},{"question":"def longest_word(words: list) -> str: Finds the longest word in a given list of strings. If there are multiple words with the maximum length, return the first one encountered. >>> longest_word([\\"apple\\", \\"banana\\", \\"cherry\\", \\"date\\"]) \\"banana\\" >>> longest_word([\\"dog\\", \\"elephant\\", \\"frog\\", \\"hippopotamus\\"]) \\"hippopotamus\\" >>> longest_word([\\"ant\\", \\"bee\\", \\"cat\\", \\"dog\\", \\"eel\\"]) \\"cat\\" >>> longest_word([\\"\\"]) Traceback (most recent call last): ... ValueError: Invalid input >>> longest_word([\\"apple123\\", \\"pear\\"]) Traceback (most recent call last): ... ValueError: Invalid input pass","solution":"def longest_word(words: list) -> str: Returns the longest word in the list. If multiple words have the longest length, the first one encountered is returned. if not words: raise ValueError(\\"Invalid input\\") # Check each word for alphabetic characters only and non-empty strings for word in words: if not word.isalpha(): raise ValueError(\\"Invalid input\\") # Initialize the longest word tracking longest = words[0] # Find the longest word for word in words: if len(word) > len(longest): longest = word return longest"},{"question":"from typing import List, Dict def count_unique_words(paragraphs: List[str]) -> List[Dict[str, int]]: Count unique words in each paragraph from a list of paragraphs. :param paragraphs: List[str] - A list of strings where each string represents a paragraph of text. :return: List[Dict[str, int]] - A list of dictionaries where each dictionary contains unique words as keys and their counts as values for the corresponding paragraph. >>> count_unique_words([\\"Hello world\\", \\"Hello hello world\\"]) [{'hello': 1, 'world': 1}, {'hello': 2, 'world': 1}] >>> count_unique_words([\\"Python is great!\\", \\"I love Python. Python is awesome!\\"]) [{'python': 1, 'is': 1, 'great': 1}, {'i': 1, 'love': 1, 'python': 2, 'is': 1, 'awesome': 1}]","solution":"from typing import List, Dict import re from collections import defaultdict def count_unique_words(paragraphs: List[str]) -> List[Dict[str, int]]: results = [] for paragraph in paragraphs: word_count = defaultdict(int) # Using regex to extract words and convert them to lowercase words = re.findall(r'bw+b', paragraph.lower()) for word in words: word_count[word] += 1 results.append(dict(word_count)) return results"},{"question":"def primary_diagonal_sum(matrix: list[list[int]]) -> int: Calculate the sum of the primary diagonal of the square matrix. :param matrix: list of lists of integers representing the square matrix :return: Integer representing the sum of the primary diagonal elements :raises ValueError: If input is invalid (non-list or non-square matrix) >>> primary_diagonal_sum([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) 15 >>> primary_diagonal_sum([[42]]) 42 >>> primary_diagonal_sum([]) Traceback (most recent call last): ... ValueError: Matrix must be non-empty and square >>> primary_diagonal_sum([[1, 2], [3, 4, 5]]) Traceback (most recent call last): ... ValueError: Matrix must be non-empty and square pass def secondary_diagonal_sum(matrix: list[list[int]]) -> int: Calculate the sum of the secondary diagonal of the square matrix. :param matrix: list of lists of integers representing the square matrix :return: Integer representing the sum of the secondary diagonal elements :raises ValueError: If input is invalid (non-list or non-square matrix) >>> secondary_diagonal_sum([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) 15 >>> secondary_diagonal_sum([[42]]) 42 >>> secondary_diagonal_sum([]) Traceback (most recent call last): ... ValueError: Matrix must be non-empty and square >>> secondary_diagonal_sum([[1, 2], [3, 4, 5]]) Traceback (most recent call last): ... ValueError: Matrix must be non-empty and square pass","solution":"def primary_diagonal_sum(matrix: list[list[int]]) -> int: Calculate the sum of the primary diagonal of the square matrix. :param matrix: list of lists of integers representing the square matrix :return: Integer representing the sum of the primary diagonal elements :raises ValueError: If input is invalid (non-list or non-square matrix) if not isinstance(matrix, list) or not all(isinstance(row, list) for row in matrix): raise ValueError(\\"Input must be a list of lists\\") n = len(matrix) if n == 0 or not all(len(row) == n for row in matrix): raise ValueError(\\"Matrix must be non-empty and square\\") return sum(matrix[i][i] for i in range(n)) def secondary_diagonal_sum(matrix: list[list[int]]) -> int: Calculate the sum of the secondary diagonal of the square matrix. :param matrix: list of lists of integers representing the square matrix :return: Integer representing the sum of the secondary diagonal elements :raises ValueError: If input is invalid (non-list or non-square matrix) if not isinstance(matrix, list) or not all(isinstance(row, list) for row in matrix): raise ValueError(\\"Input must be a list of lists\\") n = len(matrix) if n == 0 or not all(len(row) == n for row in matrix): raise ValueError(\\"Matrix must be non-empty and square\\") return sum(matrix[i][n - 1 - i] for i in range(n))"},{"question":"from typing import List def quick_sort(arr: List[int]) -> List[int]: Sorts an array of integers in ascending order using the QuickSort algorithm. >>> quick_sort([34, 7, 23, 32, 5, 62]) [5, 7, 23, 32, 34, 62] >>> quick_sort([3, -1, 2, 5, 4]) [-1, 2, 3, 4, 5] >>> quick_sort([1]) [1] >>> quick_sort([]) [] def test_quick_sort_with_positive_numbers(): assert quick_sort([34, 7, 23, 32, 5, 62]) == [5, 7, 23, 32, 34, 62] def test_quick_sort_with_mixed_numbers(): assert quick_sort([3, -1, 2, 5, 4]) == [-1, 2, 3, 4, 5] def test_quick_sort_with_single_element(): assert quick_sort([1]) == [1] def test_quick_sort_with_empty_list(): assert quick_sort([]) == [] def test_quick_sort_with_duplicates(): assert quick_sort([3, 1, 2, 3, 4, 1]) == [1, 1, 2, 3, 3, 4] def test_quick_sort_with_sorted_list(): assert quick_sort([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5] def test_quick_sort_with_reverse_sorted_list(): assert quick_sort([5, 4, 3, 2, 1]) == [1, 2, 3, 4, 5] def test_quick_sort_with_negative_numbers(): assert quick_sort([-3, -1, -2, -5, -4]) == [-5, -4, -3, -2, -1] def test_quick_sort_with_large_list(): import random large_list = random.sample(range(-10000, 10001), 1000) # Generate 1000 unique integers in the range assert quick_sort(large_list) == sorted(large_list)","solution":"def quick_sort(arr): Sorts an array of integers in ascending order using the QuickSort algorithm. Parameters: arr (List[int]): The list of integers to sort. Returns: List[int]: The list of integers sorted in ascending order. if len(arr) <= 1: return arr else: pivot = arr[len(arr) // 2] left = [x for x in arr if x < pivot] middle = [x for x in arr if x == pivot] right = [x for x in arr if x > pivot] return quick_sort(left) + middle + quick_sort(right)"},{"question":"from typing import Callable, Dict, List def define_dfa(states: Dict[int, Dict[str, int]]) -> Callable[[int, str], bool]: Define a DFA based on the provided state transitions. The DFA function should take an initial state and input string, processing the string to determine the final state. def is_accepted(dfa: Callable[[int, str], bool], initial_state: int, accepting_states: List[int], input_string: str) -> bool: Check if the given input string is accepted by the DFA. The function takes a DFA function, an initial state, a list of accepting states, and the input string to be checked. >>> states = { ... 0: {'a': 1, 'b': 0}, ... 1: {'a': 1, 'b': 2}, ... 2: {'a': 1, 'b': 0}, ... } >>> dfa = define_dfa(states) >>> is_accepted(dfa, 0, [2], \\"aab\\") True >>> is_accepted(dfa, 0, [2], \\"aaa\\") False >>> is_accepted(dfa, 0, [0], \\"\\") True >>> is_accepted(dfa, 0, [2], \\"\\") False >>> is_accepted(dfa, 0, [2], \\"aac\\") # c is an invalid character False","solution":"from typing import Callable, Dict, List def define_dfa(states: Dict[int, Dict[str, int]]) -> Callable[[int, str], bool]: def dfa(initial_state: int, input_string: str) -> int: current_state = initial_state for char in input_string: if char in states[current_state]: current_state = states[current_state][char] else: return -1 # Invalid transition return current_state return dfa def is_accepted(dfa: Callable[[int, str], bool], initial_state: int, accepting_states: List[int], input_string: str) -> bool: final_state = dfa(initial_state, input_string) return final_state in accepting_states"},{"question":"import math def rotate_point(px: float, py: float, ox: float, oy: float, angle: float) -> (float, float): Rotate point (px, py) around point (ox, oy) by the given angle in degrees. :param px: The x-coordinate of the point to rotate :param py: The y-coordinate of the point to rotate :param ox: The x-coordinate of the origin point :param oy: The y-coordinate of the origin point :param angle: The angle in degrees to rotate the point :return: A tuple (new_px, new_py) representing the new coordinates of the point after rotation Raises: TypeError: If any of the inputs are not float or int Examples: >>> rotate_point(1, 0, 0, 0, 90) (0.0, 1.0) >>> rotate_point(0, 1, 0, 0, 90) (-1.0, 0.0) >>> rotate_point(1, 2, 1, 1, 180) (1.0, 0.0) >>> rotate_point(2, 2, 1, 1, 45) (1.0, 2.414213562373095)","solution":"import math def rotate_point(px: float, py: float, ox: float, oy: float, angle: float) -> (float, float): Rotate point (px, py) around point (ox, oy) by the given angle in degrees. :param px: The x-coordinate of the point to rotate :param py: The y-coordinate of the point to rotate :param ox: The x-coordinate of the origin point :param oy: The y-coordinate of the origin point :param angle: The angle in degrees to rotate the point :return: A tuple (new_px, new_py) representing the new coordinates of the point after rotation Raises: TypeError: If any of the inputs are not float or int Examples: >>> rotate_point(1, 0, 0, 0, 90) (0.0, 1.0) >>> rotate_point(0, 1, 0, 0, 90) (-1.0, 0.0) >>> rotate_point(1, 2, 1, 1, 180) (1.0, 0.0) >>> rotate_point(2, 2, 1, 1, 45) (1.0, 2.414213562373095) # Validate input types if not all(isinstance(arg, (float, int)) for arg in [px, py, ox, oy, angle]): raise TypeError(\\"All input values must be of type float or int.\\") # Convert angle from degrees to radians angle_rad = math.radians(angle) # Translate point back to origin translated_px = px - ox translated_py = py - oy # Apply rotation cos_theta = math.cos(angle_rad) sin_theta = math.sin(angle_rad) rotated_px = translated_px * cos_theta - translated_py * sin_theta rotated_py = translated_px * sin_theta + translated_py * cos_theta # Translate point back to original position new_px = rotated_px + ox new_py = rotated_py + oy return new_px, new_py"},{"question":"def rearrange_by_frequency(s: str) -> str: Rearrange a string so that characters that appear more frequently come first. If two characters have the same frequency, they should be arranged in alphabetical order. >>> rearrange_by_frequency(\\"tree\\") in [\\"eert\\", \\"reet\\"] True >>> rearrange_by_frequency(\\"banana\\") == \\"aaannb\\" True","solution":"def rearrange_by_frequency(s: str) -> str: from collections import Counter # Count the frequency of each character in the string freq = Counter(s) # Sort characters first by frequency (in descending order) and then by alphabetical order sorted_chars = sorted(freq.items(), key=lambda x: (-x[1], x[0])) # Build the result string by repeating characters based on their frequency result = ''.join(char * count for char, count in sorted_chars) return result"},{"question":"def int_to_roman(num: int) -> str: Converts an integer to its Roman numeral representation. Args: - num: an integer between 1 and 3999 inclusive. Returns: - A string stating: 'The number {num} in Roman numerals is {roman}!', where {roman} is the constructed Roman numeral string. Raises: - ValueError: if the number is outside the range of 1 to 3999 inclusive. Examples: >>> int_to_roman(4) 'The number 4 in Roman numerals is IV!' >>> int_to_roman(1990) 'The number 1990 in Roman numerals is MCMXC!' >>> int_to_roman(2024) 'The number 2024 in Roman numerals is MMXXIV!' >>> int_to_roman(1) 'The number 1 in Roman numerals is I!' >>> int_to_roman(3999) 'The number 3999 in Roman numerals is MMMCMXCIX!'","solution":"def int_to_roman(num): Converts an integer to its Roman numeral representation. Args: - num: an integer between 1 and 3999 inclusive. Returns: - A string stating: 'The number {num} in Roman numerals is {roman}!', where {roman} is the constructed Roman numeral string. if not (1 <= num <= 3999): raise ValueError(\\"The number must be between 1 and 3999 inclusive.\\") val = [ 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1 ] syb = [ \\"M\\", \\"CM\\", \\"D\\", \\"CD\\", \\"C\\", \\"XC\\", \\"L\\", \\"XL\\", \\"X\\", \\"IX\\", \\"V\\", \\"IV\\", \\"I\\" ] roman_num = '' i = 0 while num > 0: for _ in range(num // val[i]): roman_num += syb[i] num -= val[i] i += 1 return f'The number {num} in Roman numerals is {roman_num}!'"},{"question":"import csv from datetime import datetime from typing import List, Tuple def get_top_selling_products(file_path: str, start_date: str, end_date: str, top_n: int) -> List[Tuple[str, int]]: Analyze a company’s sales data from a CSV file to identify the best-selling products within a given time frame. Args: file_path (str): Path to the CSV file containing sales data. start_date (str): Start date in \`YYYY-MM-DD\` format. end_date (str): End date in \`YYYY-MM-DD\` format. top_n (int): Number of top-selling products to return. Returns: List[Tuple[str, int]]: A list of tuples, where each tuple contains the product ID and the total quantity sold, sorted in descending order of quantity. Example: >>> get_top_selling_products(\\"sales_data.csv\\", \\"2023-01-01\\", \\"2023-01-31\\", 5) [('A', 100), ('B', 95), ('C', 90), ('D', 85), ('E', 80)] # Your implementation here pass # Example call top_products = get_top_selling_products(\\"sales_data.csv\\", \\"2023-01-01\\", \\"2023-01-31\\", 5) for product in top_products: print(product)","solution":"import csv from datetime import datetime from collections import defaultdict def get_top_selling_products(file_path: str, start_date: str, end_date: str, top_n: int) -> list: sales_data = defaultdict(int) start_date = datetime.strptime(start_date, \\"%Y-%m-%d\\") end_date = datetime.strptime(end_date, \\"%Y-%m-%d\\") with open(file_path, newline='') as csvfile: reader = csv.DictReader(csvfile) for row in reader: sale_date = datetime.strptime(row['date'], \\"%Y-%m-%d\\") if start_date <= sale_date <= end_date: product_id = row['product_id'] quantity = int(row['quantity']) sales_data[product_id] += quantity sorted_sales = sorted(sales_data.items(), key=lambda x: x[1], reverse=True) return sorted_sales[:top_n]"},{"question":"def word_pattern(pattern: str, s: str) -> bool: Check if a given word pattern matches a sequence of words. Args: pattern (str): A string representing the pattern. s (str): A string representing a sequence of words separated by spaces. Returns: bool: True if the pattern matches the sequence, otherwise False. Examples: >>> word_pattern(\\"abba\\", \\"dog cat cat dog\\") True >>> word_pattern(\\"abba\\", \\"dog cat cat fish\\") False from solution import word_pattern def test_word_pattern_match(): assert word_pattern(\\"abba\\", \\"dog cat cat dog\\") == True def test_word_pattern_mismatch(): assert word_pattern(\\"abba\\", \\"dog cat cat fish\\") == False def test_word_pattern_all_same_characters(): assert word_pattern(\\"aaaa\\", \\"dog dog dog dog\\") == True assert word_pattern(\\"aaaa\\", \\"dog dog dog cat\\") == False def test_word_pattern_one_to_one_mapping(): assert word_pattern(\\"abc\\", \\"dog cat fish\\") == True assert word_pattern(\\"abc\\", \\"dog cat dog\\") == False def test_word_pattern_different_lengths(): assert word_pattern(\\"abc\\", \\"dog cat\\") == False assert word_pattern(\\"ab\\", \\"dog cat fish\\") == False def test_word_pattern_empty_pattern(): assert word_pattern(\\"\\", \\"\\") == True assert word_pattern(\\"\\", \\"dog cat\\") == False def test_word_pattern_empty_sequence(): assert word_pattern(\\"abba\\", \\"\\") == False","solution":"def word_pattern(pattern: str, s: str) -> bool: words = s.split() if len(pattern) != len(words): return False char_to_word = {} word_to_char = {} for char, word in zip(pattern, words): if char in char_to_word: if char_to_word[char] != word: return False else: if word in word_to_char: return False char_to_word[char] = word word_to_char[word] = char return True"},{"question":"def simple_hash(input_string: str, max_size: int) -> int: Computes a hash for the given input string. Parameters: - input_string: The string to be hashed. - max_size: The maximum size for the hash table (i.e., max hash value). Returns: - An integer which is the hash value of the input string. Examples: >>> 0 <= simple_hash(\\"hello\\", 100) < 100 True >>> 0 <= simple_hash(\\"world\\", 100) < 100 True >>> 0 <= simple_hash(\\"hello world\\", 100) < 100 True","solution":"def simple_hash(input_string: str, max_size: int) -> int: Computes a hash for the given input string. Parameters: - input_string: The string to be hashed. - max_size: The maximum size for the hash table (i.e., max hash value). Returns: - An integer which is the hash value of the input string. hash_value = 0 for i, char in enumerate(input_string): hash_value += (i + 1) * ord(char) return hash_value % max_size"},{"question":"def filter_positive_reviews(reviews: list[tuple[int, str]]) -> list[str]: Filters out positive reviews from the list of reviews. A review is considered positive if its rating is 4 or 5. Args: reviews (list): A list of tuples, where each tuple contains a rating (integer) and a review text (string). Returns: list: A list of review texts that have a rating of 4 or 5. Example: >>> reviews = [ >>> (5, \\"Fantastic food and great service!\\"), >>> (3, \\"Average experience, nothing special.\\"), >>> (4, \\"Good place, will visit again.\\"), >>> (2, \\"Not worth the money.\\"), >>> (5, \\"Absolutely loved it! Highly recommend.\\") >>> ] >>> filter_positive_reviews(reviews) [\\"Fantastic food and great service!\\", \\"Good place, will visit again.\\", \\"Absolutely loved it! Highly recommend.\\"] pass def test_filter_positive_reviews(): reviews = [ (5, \\"Fantastic food and great service!\\"), (3, \\"Average experience, nothing special.\\"), (4, \\"Good place, will visit again.\\"), (2, \\"Not worth the money.\\"), (5, \\"Absolutely loved it! Highly recommend.\\") ] assert filter_positive_reviews(reviews) == [ \\"Fantastic food and great service!\\", \\"Good place, will visit again.\\", \\"Absolutely loved it! Highly recommend.\\" ] def test_filter_positive_reviews_with_no_positive(): reviews = [ (1, \\"Terrible experience.\\"), (2, \\"Not good.\\"), (3, \\"It was okay.\\"), ] assert filter_positive_reviews(reviews) == [] def test_filter_positive_reviews_with_all_positive(): reviews = [ (4, \\"Great!\\"), (5, \\"Excellent!\\"), (4, \\"Really good!\\"), (5, \\"Absolutely wonderful!\\"), ] assert filter_positive_reviews(reviews) == [ \\"Great!\\", \\"Excellent!\\", \\"Really good!\\", \\"Absolutely wonderful!\\" ] def test_filter_positive_reviews_mixed_ratings(): reviews = [ (1, \\"Not good at all.\\"), (4, \\"Decent food.\\"), (5, \\"Awesome experience!\\"), (2, \\"Could be better.\\"), (3, \\"It was fine.\\"), (5, \\"Loved it!\\"), ] assert filter_positive_reviews(reviews) == [ \\"Decent food.\\", \\"Awesome experience!\\", \\"Loved it!\\" ] def test_filter_positive_reviews_edge_cases(): reviews = [ (4, \\"\\"), (5, \\" \\") ] assert filter_positive_reviews(reviews) == [\\"\\", \\" \\"] def test_filter_positive_reviews_empty_list(): reviews = [] assert filter_positive_reviews(reviews) == [] def test_filter_positive_reviews_single_positive(): reviews = [ (5, \\"Great service!\\") ] assert filter_positive_reviews(reviews) == [\\"Great service!\\"] def test_filter_positive_reviews_single_negative(): reviews = [ (1, \\"Bad experience.\\") ] assert filter_positive_reviews(reviews) == []","solution":"def filter_positive_reviews(reviews): Filters out positive reviews from the list of reviews. A review is considered positive if its rating is 4 or 5. Args: reviews (list): A list of tuples, where each tuple contains a rating (integer) and a review text (string). Returns: list: A list of review texts that have a rating of 4 or 5. return [comment for rating, comment in reviews if rating == 4 or rating == 5]"},{"question":"from typing import List def rearrange_array(arr: List[int]) -> List[int]: Rearranges the elements of the given array such that all even numbers appear before all odd numbers, while preserving their relative order within the even and odd groups. Examples: >>> rearrange_array([3, 1, 2, 4]) [2, 4, 3, 1] >>> rearrange_array([7, 8, 5, 6, 3, 10]) [8, 6, 10, 7, 5, 3] >>> rearrange_array([1, 3, 5, 7]) [1, 3, 5, 7] >>> rearrange_array([2, 4, 6]) [2, 4, 6]","solution":"from typing import List def rearrange_array(arr: List[int]) -> List[int]: Rearranges the elements of the given array such that all even numbers appear before all odd numbers, while preserving their relative order within the even and odd groups. evens = [x for x in arr if x % 2 == 0] odds = [x for x in arr if x % 2 != 0] return evens + odds"},{"question":"def tic_tac_toe_judge(board: list) -> str: Determine the status of a completed Tic-Tac-Toe game. >>> board1 = [ ... ['X', 'O', 'X'], ... ['O', 'X', ''], ... ['O', '', 'X'] ... ] >>> tic_tac_toe_judge(board1) 'X' >>> board2 = [ ... ['X', 'O', 'X'], ... ['O', 'O', 'X'], ... ['O', 'X', 'X'] ... ] >>> tic_tac_toe_judge(board2) 'Draw' >>> board3 = [ ... ['X', 'O', 'X'], ... ['O', 'X', ''], ... ['O', '', ''] ... ] >>> tic_tac_toe_judge(board3) 'Incomplete'","solution":"def tic_tac_toe_judge(board: list) -> str: # Check rows and columns for i in range(3): if board[i][0] != '' and board[i][0] == board[i][1] and board[i][1] == board[i][2]: return board[i][0] if board[0][i] != '' and board[0][i] == board[1][i] and board[1][i] == board[2][i]: return board[0][i] # Check diagonals if board[0][0] != '' and board[0][0] == board[1][1] and board[1][1] == board[2][2]: return board[0][0] if board[0][2] != '' and board[0][2] == board[1][1] and board[1][1] == board[2][0]: return board[0][2] # Check for incomplete game for row in board: if '' in row: return 'Incomplete' # If no winner and no incomplete spots, it's a draw return 'Draw'"},{"question":"from typing import List, Tuple def remove_conflicts(events: List[Tuple[int, int]]) -> List[Tuple[int, int]]: Remove the minimal number of conflicting events to ensure no events overlap. Args: events (List[Tuple[int, int]]): List of tuples where each tuple represents an event with a start and end time. Returns: List[Tuple[int, int]]: List of non-conflicting events. >>> remove_conflicts([(1, 2), (2, 3), (3, 4)]) [(1, 2), (2, 3), (3, 4)] >>> remove_conflicts([(1, 5), (2, 6), (3, 7)]) [(1, 5)]","solution":"from typing import List, Tuple def remove_conflicts(events: List[Tuple[int, int]]) -> List[Tuple[int, int]]: # Sort events based on start time events.sort() # Initialize list of non-conflicting events result = [] # Iterate through events and add the ones that don't conflict prev_end = -1 for start, end in events: if start >= prev_end: result.append((start, end)) prev_end = end return result"},{"question":"def optimized_quick_sort(collection: list) -> list: Perform an optimized quick sort on the given collection using the median-of-three partitioning scheme and recursion on the smaller subarray first to improve worst-case performance. >>> optimized_quick_sort([3, 1, 4, 1, 5, 9]) [1, 1, 3, 4, 5, 9] >>> optimized_quick_sort([0, 5, 3, 2, 2]) [0, 2, 2, 3, 5] >>> optimized_quick_sort([-2, -5, -45]) [-45, -5, -2] >>> optimized_quick_sort([]) [] >>> optimized_quick_sort([1]) [1] >>> optimized_quick_sort([0]) [0] >>> optimized_quick_sort([1, 2, 3, 4, 5]) [1, 2, 3, 4, 5] >>> optimized_quick_sort([10, 20, 30, 40, 50]) [10, 20, 30, 40, 50] >>> optimized_quick_sort([5, 4, 3, 2, 1]) [1, 2, 3, 4, 5] >>> optimized_quick_sort([100, 90, 80, 70, 60]) [60, 70, 80, 90, 100]","solution":"def optimized_quick_sort(collection: list) -> list: Perform an optimized quick sort on the given collection using the median-of-three partitioning scheme and recursion on the smaller subarray first to improve worst-case performance. def median_of_three(lo, hi): mid = (lo + hi) // 2 if collection[lo] > collection[mid]: collection[lo], collection[mid] = collection[mid], collection[lo] if collection[lo] > collection[hi]: collection[lo], collection[hi] = collection[hi], collection[lo] if collection[mid] > collection[hi]: collection[mid], collection[hi] = collection[hi], collection[mid] collection[mid], collection[hi-1] = collection[hi-1], collection[mid] return collection[hi-1] def quick_sort(lo, hi): if hi - lo <= 10: insertion_sort(lo, hi) return pivot = median_of_three(lo, hi) left = lo + 1 right = hi - 2 while True: while collection[left] < pivot: left += 1 while collection[right] > pivot: right -= 1 if left < right: collection[left], collection[right] = collection[right], collection[left] left += 1 right -= 1 else: break collection[left], collection[hi-1] = collection[hi-1], collection[left] if left - lo < hi - left: quick_sort(lo, left - 1) quick_sort(left + 1, hi) else: quick_sort(left + 1, hi) quick_sort(lo, left - 1) def insertion_sort(lo, hi): for i in range(lo + 1, hi + 1): key = collection[i] j = i - 1 while j >= lo and collection[j] > key: collection[j + 1] = collection[j] j -= 1 collection[j + 1] = key quick_sort(0, len(collection) - 1) return collection"},{"question":"def find_second_highest(scores: list[int]) -> int: Returns the second highest unique score from the list. If there is no second highest unique score, returns None. Examples: >>> find_second_highest([4, 2, 10, 10, 6, 8]) 8 >>> find_second_highest([1, 2, 2, 2]) 1 >>> find_second_highest([5]) None >>> find_second_highest([3, 3, 3, 3]) None >>> find_second_highest([-5, -2, -8, -1]) -2","solution":"def find_second_highest(scores: list[int]) -> int: Returns the second highest unique score from the list. If there is no second highest unique score, returns None. unique_scores = list(set(scores)) if len(unique_scores) < 2: return None unique_scores.sort(reverse=True) return unique_scores[1]"},{"question":"class SimpleCalculator: ... def power(self, base: float, exponent: float) -> float: This method should return the base raised to the power of the exponent. >>> sc = SimpleCalculator() >>> sc.power(2, 3) 8.0 >>> sc.power(5, -2) 0.04 >>> sc.power(10, 0) 1.0 >>> sc.power(3, 1) 3.0","solution":"class SimpleCalculator: # The power method is defined to calculate base raised to the power of exponent def power(self, base: float, exponent: float) -> float: return base ** exponent"},{"question":"def max_parenthesis_depth(s: str) -> int: Determine the maximum depth of a valid, balanced parenthesis string. :param s: A balanced parenthesis string composed of characters '(' and ')'. :return: An integer representing the maximum depth of nested parentheses. >>> max_parenthesis_depth(\\"((()))\\") 3 >>> max_parenthesis_depth(\\"()\\") 1 >>> max_parenthesis_depth(\\"(())()\\") 2 >>> max_parenthesis_depth(\\"()()()\\") 1 pass from your_test_module import max_parenthesis_depth def test_simple_pairs(): assert max_parenthesis_depth(\\"()()\\") == 1 assert max_parenthesis_depth(\\"((()))\\") == 3 def test_mixed_pairs(): assert max_parenthesis_depth(\\"(())()\\") == 2 assert max_parenthesis_depth(\\"(()(()))\\") == 3 def test_single_pair(): assert max_parenthesis_depth(\\"()\\") == 1 def test_intermixed_pairs(): assert max_parenthesis_depth(\\"((())())\\") == 3 assert max_parenthesis_depth(\\"((()())(()))\\") == 3 assert max_parenthesis_depth(\\"()(()())\\") == 2 def test_large_string(): n = 10**4 // 2 s = \\"(\\" * n + \\")\\" * n assert max_parenthesis_depth(s) == n","solution":"def max_parenthesis_depth(s: str) -> int: Determine the maximum depth of a valid, balanced parenthesis string. :param s: A balanced parenthesis string composed of characters '(' and ')'. :return: An integer representing the maximum depth of nested parentheses. max_depth = 0 current_depth = 0 for char in s: if char == '(': current_depth += 1 if current_depth > max_depth: max_depth = current_depth elif char == ')': current_depth -= 1 return max_depth"},{"question":"[Completion Task in Python] class SegmentTree: def __init__(self, nums: List[int]): self.n = len(nums) self.tree = [0] * (2 * self.n) self.build(nums) def build(self, nums): for i in range(self.n): self.tree[i + self.n] = nums[i] for i in range(self.n - 1, 0, -1): self.tree[i] = self.tree[i * 2] + self.tree[i * 2 + 1] def update(self, index: int, value: int): pos = index + self.n self.tree[pos] = value while pos > 1: pos //= 2 self.tree[pos] = self.tree[pos * 2] + self.tree[pos * 2 + 1] def range_sum(self, left: int, right: int) -> int: left += self.n right += self.n + 1 sum_ = 0 while left < right: if left % 2 == 1: sum_ += self.tree[left] left += 1 if right % 2 == 1: right -= 1 sum_ += self.tree[right] left //= 2 right //= 2 return sum_","solution":"class SegmentTree: def __init__(self, nums): self.n = len(nums) self.tree = [0] * (2 * self.n) self.build(nums) def build(self, nums): for i in range(self.n): self.tree[i + self.n] = nums[i] for i in range(self.n - 1, 0, -1): self.tree[i] = self.tree[i * 2] + self.tree[i * 2 + 1] def update(self, index, value): pos = index + self.n self.tree[pos] = value while pos > 1: pos //= 2 self.tree[pos] = self.tree[pos * 2] + self.tree[pos * 2 + 1] def range_sum(self, left, right): left += self.n right += self.n + 1 sum_ = 0 while left < right: if left % 2 == 1: sum_ += self.tree[left] left += 1 if right % 2 == 1: right -= 1 sum_ += self.tree[right] left //= 2 right //= 2 return sum_"},{"question":"def count_battleships(board: List[List[str]]) -> int: Write a function to count the number of battleships on a given board. >>> count_battleships([ ... ['X', '.', '.', 'X'], ... ['.', '.', '.', 'X'], ... ['.', '.', '.', 'X'] ... ]) 2 >>> count_battleships([ ... ['.', 'X', 'X', '.'], ... ['.', '.', '.', '.'], ... ['.', 'X', 'X', '.'] ... ]) 2 >>> count_battleships([ ... ['.', '.', '.'], ... ['.', '.', '.'], ... ['.', '.', '.'] ... ]) 0","solution":"def count_battleships(board): if not board: return 0 def dfs(i, j): if i < 0 or i >= len(board) or j < 0 or j >= len(board[0]) or board[i][j] == '.': return board[i][j] = '.' for x, y in ((0, 1), (1, 0), (0, -1), (-1, 0)): dfs(i + x, j + y) count = 0 for i in range(len(board)): for j in range(len(board[0])): if board[i][j] == 'X': count += 1 dfs(i, j) return count"},{"question":"from typing import List def rotate_matrix(matrix: List[List[int]]) -> None: Rotate the given n x n matrix by 90 degrees clockwise in-place. Parameters: matrix (List[List[int]]): 2D list representing the n x n matrix. Example: >>> matrix = [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ] >>> rotate_matrix(matrix) >>> print(matrix) [[7, 4, 1], [8, 5, 2], [9, 6, 3]] >>> matrix = [ ... [5, 1, 9, 11], ... [2, 4, 8, 10], ... [13, 3, 6, 7], ... [15, 14, 12, 16] ... ] >>> rotate_matrix(matrix) >>> print(matrix) [[15, 13, 2, 5], [14, 3, 4, 1], [12, 6, 8, 9], [16, 7, 10, 11]]","solution":"from typing import List def rotate_matrix(matrix: List[List[int]]) -> None: Rotate the given n x n matrix by 90 degrees clockwise in-place. Parameters: matrix (List[List[int]]): 2D list representing the n x n matrix. n = len(matrix) # Transpose the matrix for i in range(n): for j in range(i, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Reverse each row for i in range(n): matrix[i].reverse()"},{"question":"from typing import List def average_temperature(temperatures: List[float]) -> float: Returns the average of the temperature readings. If the list is empty, return 0.0. >>> average_temperature([30.0, 32.0, 31.0, 28.0, 35.0]) 31.2 >>> average_temperature([-10.0, 0.0, 10.0]) 0.0 >>> average_temperature([25.5]) 25.5 >>> average_temperature([]) 0.0 >>> average_temperature([-5.0, -15.0, -10.0, -20.0]) -12.5 >>> average_temperature([15.1, 16.1, 15.9, 16.4]) 15.875","solution":"from typing import List def average_temperature(temperatures: List[float]) -> float: Returns the average of the temperature readings. If the list is empty, return 0.0. if not temperatures: return 0.0 return sum(temperatures) / len(temperatures)"},{"question":"def shuffle_array(arr: List[int]) -> List[int]: Rearranges the elements in such a way that every consecutive pair of elements is swapped. If the list has an odd number of elements, the last element should remain in its original position. :param arr: List[int] - A list of integers. :return: List[int] - A new list of integers where each consecutive pair of elements has been swapped. >>> shuffle_array([1, 2, 3, 4]) [2, 1, 4, 3] >>> shuffle_array([5, 6, 7]) [6, 5, 7] >>> shuffle_array([9, 1, 8, 3, 4]) [1, 9, 3, 8, 4] >>> shuffle_array([]) [] >>> shuffle_array([10]) [10]","solution":"def shuffle_array(arr): Rearranges the elements in such a way that every consecutive pair of elements is swapped. If the list has an odd number of elements, the last element should remain in its original position. :param arr: List[int] - A list of integers. :return: List[int] - A new list of integers where each consecutive pair of elements has been swapped. # Create a copy of the original list to avoid modifying it in-place new_arr = arr.copy() # Iterate over the list in steps of 2 for i in range(1, len(arr), 2): new_arr[i], new_arr[i-1] = arr[i-1], arr[i] return new_arr"},{"question":"def evaluate_expression(expression: str, variables: dict) -> float: Evaluates a mathematical expression with given variable mappings. Args: expression (str): The mathematical expression to evaluate. variables (dict): A dictionary mapping variable names to their respective float values. Returns: float: The result of evaluating the expression. Raises: ValueError: If the expression is invalid or contains issues. from solution import evaluate_expression def test_evaluate_expression_basic(): assert evaluate_expression(\\"a + b * (c - d)\\", {\\"a\\": 2.0, \\"b\\": 3.0, \\"c\\": 10.0, \\"d\\": 2.0}) == 26.0 assert evaluate_expression(\\"x / y + z\\", {\\"x\\": 10.0, \\"y\\": 2.0, \\"z\\": 3.0}) == 8.0 def test_evaluate_expression_with_zero(): assert evaluate_expression(\\"a * b\\", {\\"a\\": 0.0, \\"b\\": 100.0}) == 0.0 assert evaluate_expression(\\"a + b\\", {\\"a\\": 0.0, \\"b\\": 0.0}) == 0.0 def test_evaluate_expression_negative_numbers(): assert evaluate_expression(\\"a - b\\", {\\"a\\": -5.0, \\"b\\": -10.0}) == 5.0 assert evaluate_expression(\\"a - (b + c)\\", {\\"a\\": 0.0, \\"b\\": -5.0, \\"c\\": 5.0}) == 0.0 def test_evaluate_expression_division(): assert evaluate_expression(\\"a / b\\", {\\"a\\": 10.0, \\"b\\": 2.0}) == 5.0 assert evaluate_expression(\\"a / b\\", {\\"a\\": 1.0, \\"b\\": -1.0}) == -1.0 def test_invalid_expression(): try: evaluate_expression(\\"a + (b * c\\", {\\"a\\": 1.0, \\"b\\": 2.0, \\"c\\": 3.0}) except ValueError: assert True else: assert False try: evaluate_expression(\\"a + b * (c - d)\\", {}) except ValueError: assert True else: assert False","solution":"def evaluate_expression(expression: str, variables: dict) -> float: Evaluates a mathematical expression with given variable mappings. Args: expression (str): The mathematical expression to evaluate. variables (dict): A dictionary mapping variable names to their respective float values. Returns: float: The result of evaluating the expression. Raises: ValueError: If the expression is invalid or contains issues. # Replace variables with their values in the expression for var, value in variables.items(): # Ensure proper replacement of variable names with their values expression = expression.replace(var, str(value)) try: result = eval(expression, {\\"__builtins__\\": None}, {}) except Exception as e: raise ValueError(f\\"Invalid expression: {e}\\") return result"},{"question":"def smallest_subarray_with_given_sum(target_sum: int, arr: list) -> int: Find the length of the smallest contiguous subarray whose sum is greater than or equal to the target sum. Args: target_sum (int): The target sum. arr (list): List of integers. Returns: int: Length of the smallest contiguous subarray whose sum is greater than or equal to the target sum. If no such subarray exists, return 0. Examples: >>> smallest_subarray_with_given_sum(7, [2, 1, 5, 2, 3, 2]) 2 >>> smallest_subarray_with_given_sum(15, [1, 2, 3, 4, 5]) 5 >>> smallest_subarray_with_given_sum(3, [1, 1]) 0 >>> smallest_subarray_with_given_sum(5, [5]) 1 >>> smallest_subarray_with_given_sum(8, [2, 3, 1, 2, 4, 3]) 3 >>> smallest_subarray_with_given_sum(20, [1, 2, 3, 4, 5]) 0 >>> smallest_subarray_with_given_sum(10, [1, 2, 3, 4]) 4 >>> smallest_subarray_with_given_sum(100000, [10] * 10000) 10000 >>> smallest_subarray_with_given_sum(7, [1, 2, 3, 4, 5]) 2","solution":"def smallest_subarray_with_given_sum(target_sum: int, arr: list) -> int: n = len(arr) min_length = float('inf') current_sum = 0 start = 0 for end in range(n): current_sum += arr[end] while current_sum >= target_sum: min_length = min(min_length, end - start + 1) current_sum -= arr[start] start += 1 return min_length if min_length != float('inf') else 0"},{"question":"def calculate_fibonacci(n: int) -> int: Calculate the n-th Fibonacci number using an iterative approach. Parameters: n (int): The position in the Fibonacci sequence (0-indexed). Returns: int: The n-th Fibonacci number. Constraints: 1. The input integer \`n\` should be in the range [0, 30]. 2. The function should raise a \`ValueError\` with appropriate messages for inputs violating the above constraint. Example: >>> calculate_fibonacci(0) 0 >>> calculate_fibonacci(1) 1 >>> calculate_fibonacci(10) 55 >>> calculate_fibonacci(30) 832040","solution":"def calculate_fibonacci(n: int) -> int: if n < 0 or n > 30: raise ValueError(\\"Input out of range. Valid range: 0 to 30\\") if n == 0: return 0 elif n == 1: return 1 a, b = 0, 1 for i in range(2, n + 1): a, b = b, a + b return b"}]`),C={name:"App",components:{PoemCard:R},data(){return{searchQuery:"",visibleCount:4,poemsData:E,isLoading:!1}},computed:{filteredPoems(){const i=this.searchQuery.trim().toLowerCase();return i?this.poemsData.filter(e=>e.question&&e.question.toLowerCase().includes(i)||e.solution&&e.solution.toLowerCase().includes(i)):this.poemsData},displayedPoems(){return this.searchQuery.trim()?this.filteredPoems:this.filteredPoems.slice(0,this.visibleCount)},hasMorePoems(){return!this.searchQuery.trim()&&this.visibleCount<this.poemsData.length}},methods:{async loadMore(){this.isLoading=!0,await new Promise(i=>setTimeout(i,1e3)),this.visibleCount+=4,this.isLoading=!1}}},z={class:"search-container"},I={class:"card-container"},F={key:0,class:"empty-state"},S=["disabled"],D={key:0},B={key:1};function M(i,e,l,f,a,n){const m=h("PoemCard");return r(),s("section",null,[e[4]||(e[4]=t("div",{class:"top-banner"},[t("div",{class:"top-banner-title"},[t("div",{class:"top-banner-title-text"},"🤔prompts chat🧠")])],-1)),t("div",z,[e[3]||(e[3]=t("span",{class:"search-icon"},"🔍",-1)),g(t("input",{type:"text",class:"search-input","onUpdate:modelValue":e[0]||(e[0]=o=>a.searchQuery=o),placeholder:"Search..."},null,512),[[b,a.searchQuery]]),a.searchQuery?(r(),s("button",{key:0,class:"clear-search",onClick:e[1]||(e[1]=o=>a.searchQuery="")}," ✕ ")):d("",!0)]),t("div",I,[(r(!0),s(y,null,v(n.displayedPoems,(o,p)=>(r(),x(m,{key:p,poem:o},null,8,["poem"]))),128)),n.displayedPoems.length===0?(r(),s("div",F,' No results found for "'+u(a.searchQuery)+'". ',1)):d("",!0)]),n.hasMorePoems?(r(),s("button",{key:0,class:"load-more-button",disabled:a.isLoading,onClick:e[2]||(e[2]=(...o)=>n.loadMore&&n.loadMore(...o))},[a.isLoading?(r(),s("span",B,"Loading...")):(r(),s("span",D,"See more"))],8,S)):d("",!0)])}const j=c(C,[["render",M],["__scopeId","data-v-77e0d2c6"]]),U=JSON.parse('{"title":"","description":"","frontmatter":{"page":true},"headers":[],"relativePath":"library/31.md","filePath":"library/31.md"}'),P={name:"library/31.md"},O=Object.assign(P,{setup(i){return(e,l)=>(r(),s("div",null,[w(j)]))}});export{U as __pageData,O as default};
